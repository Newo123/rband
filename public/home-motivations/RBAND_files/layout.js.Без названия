/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Cnode_modules%5C%5C.pnpm%5C%5Cnext%4014.2.1_react-dom%4018.3.1_react%4018.3.1__react%4018.3.1_sass%401.77.2%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Cimage-component.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Cnode_modules%5C%5C.pnpm%5C%5Cnext%4014.2.1_react-dom%4018.3.1_react%4018.3.1__react%4018.3.1_sass%401.77.2%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Clink.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Cnode_modules%5C%5C.pnpm%5C%5Cnext%4014.2.1_react-dom%4018.3.1_react%4018.3.1__react%4018.3.1_sass%401.77.2%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Clocal%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%5C%5C%5C%5Capp%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22src%5C%22%3A%5B%7B%5C%22path%5C%22%3A%5C%22..%2Ffonts%2FIntroBlackCaps.ttf%5C%22%7D%2C%7B%5C%22path%5C%22%3A%5C%22..%2Ffonts%2FIntroBlackCaps.woff%5C%22%7D%2C%7B%5C%22path%5C%22%3A%5C%22..%2Ffonts%2FIntroBlackCaps.woff2%5C%22%7D%5D%2C%5C%22variable%5C%22%3A%5C%22--font-intro%5C%22%2C%5C%22style%5C%22%3A%5C%22normal%5C%22%2C%5C%22weight%5C%22%3A%5C%22900%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22intro%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Cnode_modules%5C%5C.pnpm%5C%5Cnext%4014.2.1_react-dom%4018.3.1_react%4018.3.1__react%4018.3.1_sass%401.77.2%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%5C%5C%5C%5Capp%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Montserrat%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%2C%5C%22cyrillic%5C%22%5D%2C%5C%22variable%5C%22%3A%5C%22--font-montserrat%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22montserrat%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cheader%5C%5CHeader.tsx%22%2C%22ids%22%3A%5B%22Header%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cui%5C%5Ccontainer%5C%5CStyles.scss%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cfooter%5C%5Cstyles.module.scss%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Cproviders%5C%5Cproviders.tsx%22%2C%22ids%22%3A%5B%22Providers%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Cstyles%5C%5Cglobals.scss%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Cnode_modules%5C%5C.pnpm%5C%5Cnext%4014.2.1_react-dom%4018.3.1_react%4018.3.1__react%4018.3.1_sass%401.77.2%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Cimage-component.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Cnode_modules%5C%5C.pnpm%5C%5Cnext%4014.2.1_react-dom%4018.3.1_react%4018.3.1__react%4018.3.1_sass%401.77.2%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Clink.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Cnode_modules%5C%5C.pnpm%5C%5Cnext%4014.2.1_react-dom%4018.3.1_react%4018.3.1__react%4018.3.1_sass%401.77.2%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Clocal%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%5C%5C%5C%5Capp%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22src%5C%22%3A%5B%7B%5C%22path%5C%22%3A%5C%22..%2Ffonts%2FIntroBlackCaps.ttf%5C%22%7D%2C%7B%5C%22path%5C%22%3A%5C%22..%2Ffonts%2FIntroBlackCaps.woff%5C%22%7D%2C%7B%5C%22path%5C%22%3A%5C%22..%2Ffonts%2FIntroBlackCaps.woff2%5C%22%7D%5D%2C%5C%22variable%5C%22%3A%5C%22--font-intro%5C%22%2C%5C%22style%5C%22%3A%5C%22normal%5C%22%2C%5C%22weight%5C%22%3A%5C%22900%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22intro%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Cnode_modules%5C%5C.pnpm%5C%5Cnext%4014.2.1_react-dom%4018.3.1_react%4018.3.1__react%4018.3.1_sass%401.77.2%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%5C%5C%5C%5Capp%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Montserrat%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%2C%5C%22cyrillic%5C%22%5D%2C%5C%22variable%5C%22%3A%5C%22--font-montserrat%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22montserrat%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cheader%5C%5CHeader.tsx%22%2C%22ids%22%3A%5B%22Header%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cui%5C%5Ccontainer%5C%5CStyles.scss%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cfooter%5C%5Cstyles.module.scss%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Cproviders%5C%5Cproviders.tsx%22%2C%22ids%22%3A%5B%22Providers%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Cstyles%5C%5Cglobals.scss%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/image-component.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/image-component.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/link.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/link.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/font/local/target.css?{\"path\":\"src\\\\app\\\\layout.tsx\",\"import\":\"\",\"arguments\":[{\"src\":[{\"path\":\"../fonts/IntroBlackCaps.ttf\"},{\"path\":\"../fonts/IntroBlackCaps.woff\"},{\"path\":\"../fonts/IntroBlackCaps.woff2\"}],\"variable\":\"--font-intro\",\"style\":\"normal\",\"weight\":\"900\"}],\"variableName\":\"intro\"} */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/font/local/target.css?{\\\"path\\\":\\\"src\\\\\\\\app\\\\\\\\layout.tsx\\\",\\\"import\\\":\\\"\\\",\\\"arguments\\\":[{\\\"src\\\":[{\\\"path\\\":\\\"../fonts/IntroBlackCaps.ttf\\\"},{\\\"path\\\":\\\"../fonts/IntroBlackCaps.woff\\\"},{\\\"path\\\":\\\"../fonts/IntroBlackCaps.woff2\\\"}],\\\"variable\\\":\\\"--font-intro\\\",\\\"style\\\":\\\"normal\\\",\\\"weight\\\":\\\"900\\\"}],\\\"variableName\\\":\\\"intro\\\"}\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/font/google/target.css?{\"path\":\"src\\\\app\\\\layout.tsx\",\"import\":\"Montserrat\",\"arguments\":[{\"subsets\":[\"latin\",\"cyrillic\"],\"variable\":\"--font-montserrat\"}],\"variableName\":\"montserrat\"} */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/font/google/target.css?{\\\"path\\\":\\\"src\\\\\\\\app\\\\\\\\layout.tsx\\\",\\\"import\\\":\\\"Montserrat\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\",\\\"cyrillic\\\"],\\\"variable\\\":\\\"--font-montserrat\\\"}],\\\"variableName\\\":\\\"montserrat\\\"}\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/header/Header.tsx */ \"(app-pages-browser)/./src/components/header/Header.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/ui/container/Styles.scss */ \"(app-pages-browser)/./src/components/ui/container/Styles.scss\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./src/components/footer/styles.module.scss */ \"(app-pages-browser)/./src/components/footer/styles.module.scss\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/providers/providers.tsx */ \"(app-pages-browser)/./src/providers/providers.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/styles/globals.scss */ \"(app-pages-browser)/./src/styles/globals.scss\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDNzk1MzMlNUMlNUNEZXNrdG9wJTVDJTVDZnJvbnQtcmJhbmQlNUMlNUNyYmFuZCU1QyU1Q25vZGVfbW9kdWxlcyU1QyU1Qy5wbnBtJTVDJTVDbmV4dCU0MDE0LjIuMV9yZWFjdC1kb20lNDAxOC4zLjFfcmVhY3QlNDAxOC4zLjFfX3JlYWN0JTQwMTguMy4xX3Nhc3MlNDAxLjc3LjIlNUMlNUNub2RlX21vZHVsZXMlNUMlNUNuZXh0JTVDJTVDZGlzdCU1QyU1Q2NsaWVudCU1QyU1Q2ltYWdlLWNvbXBvbmVudC5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjJDJTNBJTVDJTVDVXNlcnMlNUMlNUM3OTUzMyU1QyU1Q0Rlc2t0b3AlNUMlNUNmcm9udC1yYmFuZCU1QyU1Q3JiYW5kJTVDJTVDbm9kZV9tb2R1bGVzJTVDJTVDLnBucG0lNUMlNUNuZXh0JTQwMTQuMi4xX3JlYWN0LWRvbSU0MDE4LjMuMV9yZWFjdCU0MDE4LjMuMV9fcmVhY3QlNDAxOC4zLjFfc2FzcyU0MDEuNzcuMiU1QyU1Q25vZGVfbW9kdWxlcyU1QyU1Q25leHQlNUMlNUNkaXN0JTVDJTVDY2xpZW50JTVDJTVDbGluay5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiUyMmRlZmF1bHQlMjIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDNzk1MzMlNUMlNUNEZXNrdG9wJTVDJTVDZnJvbnQtcmJhbmQlNUMlNUNyYmFuZCU1QyU1Q25vZGVfbW9kdWxlcyU1QyU1Qy5wbnBtJTVDJTVDbmV4dCU0MDE0LjIuMV9yZWFjdC1kb20lNDAxOC4zLjFfcmVhY3QlNDAxOC4zLjFfX3JlYWN0JTQwMTguMy4xX3Nhc3MlNDAxLjc3LjIlNUMlNUNub2RlX21vZHVsZXMlNUMlNUNuZXh0JTVDJTVDZm9udCU1QyU1Q2xvY2FsJTVDJTVDdGFyZ2V0LmNzcyUzRiU3QiU1QyUyMnBhdGglNUMlMjIlM0ElNUMlMjJzcmMlNUMlNUMlNUMlNUNhcHAlNUMlNUMlNUMlNUNsYXlvdXQudHN4JTVDJTIyJTJDJTVDJTIyaW1wb3J0JTVDJTIyJTNBJTVDJTIyJTVDJTIyJTJDJTVDJTIyYXJndW1lbnRzJTVDJTIyJTNBJTVCJTdCJTVDJTIyc3JjJTVDJTIyJTNBJTVCJTdCJTVDJTIycGF0aCU1QyUyMiUzQSU1QyUyMi4uJTJGZm9udHMlMkZJbnRyb0JsYWNrQ2Fwcy50dGYlNUMlMjIlN0QlMkMlN0IlNUMlMjJwYXRoJTVDJTIyJTNBJTVDJTIyLi4lMkZmb250cyUyRkludHJvQmxhY2tDYXBzLndvZmYlNUMlMjIlN0QlMkMlN0IlNUMlMjJwYXRoJTVDJTIyJTNBJTVDJTIyLi4lMkZmb250cyUyRkludHJvQmxhY2tDYXBzLndvZmYyJTVDJTIyJTdEJTVEJTJDJTVDJTIydmFyaWFibGUlNUMlMjIlM0ElNUMlMjItLWZvbnQtaW50cm8lNUMlMjIlMkMlNUMlMjJzdHlsZSU1QyUyMiUzQSU1QyUyMm5vcm1hbCU1QyUyMiUyQyU1QyUyMndlaWdodCU1QyUyMiUzQSU1QyUyMjkwMCU1QyUyMiU3RCU1RCUyQyU1QyUyMnZhcmlhYmxlTmFtZSU1QyUyMiUzQSU1QyUyMmludHJvJTVDJTIyJTdEJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkMlM0ElNUMlNUNVc2VycyU1QyU1Qzc5NTMzJTVDJTVDRGVza3RvcCU1QyU1Q2Zyb250LXJiYW5kJTVDJTVDcmJhbmQlNUMlNUNub2RlX21vZHVsZXMlNUMlNUMucG5wbSU1QyU1Q25leHQlNDAxNC4yLjFfcmVhY3QtZG9tJTQwMTguMy4xX3JlYWN0JTQwMTguMy4xX19yZWFjdCU0MDE4LjMuMV9zYXNzJTQwMS43Ny4yJTVDJTVDbm9kZV9tb2R1bGVzJTVDJTVDbmV4dCU1QyU1Q2ZvbnQlNUMlNUNnb29nbGUlNUMlNUN0YXJnZXQuY3NzJTNGJTdCJTVDJTIycGF0aCU1QyUyMiUzQSU1QyUyMnNyYyU1QyU1QyU1QyU1Q2FwcCU1QyU1QyU1QyU1Q2xheW91dC50c3glNUMlMjIlMkMlNUMlMjJpbXBvcnQlNUMlMjIlM0ElNUMlMjJNb250c2VycmF0JTVDJTIyJTJDJTVDJTIyYXJndW1lbnRzJTVDJTIyJTNBJTVCJTdCJTVDJTIyc3Vic2V0cyU1QyUyMiUzQSU1QiU1QyUyMmxhdGluJTVDJTIyJTJDJTVDJTIyY3lyaWxsaWMlNUMlMjIlNUQlMkMlNUMlMjJ2YXJpYWJsZSU1QyUyMiUzQSU1QyUyMi0tZm9udC1tb250c2VycmF0JTVDJTIyJTdEJTVEJTJDJTVDJTIydmFyaWFibGVOYW1lJTVDJTIyJTNBJTVDJTIybW9udHNlcnJhdCU1QyUyMiU3RCUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjJDJTNBJTVDJTVDVXNlcnMlNUMlNUM3OTUzMyU1QyU1Q0Rlc2t0b3AlNUMlNUNmcm9udC1yYmFuZCU1QyU1Q3JiYW5kJTVDJTVDc3JjJTVDJTVDY29tcG9uZW50cyU1QyU1Q2hlYWRlciU1QyU1Q0hlYWRlci50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJIZWFkZXIlMjIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDNzk1MzMlNUMlNUNEZXNrdG9wJTVDJTVDZnJvbnQtcmJhbmQlNUMlNUNyYmFuZCU1QyU1Q3NyYyU1QyU1Q2NvbXBvbmVudHMlNUMlNUN1aSU1QyU1Q2NvbnRhaW5lciU1QyU1Q1N0eWxlcy5zY3NzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkMlM0ElNUMlNUNVc2VycyU1QyU1Qzc5NTMzJTVDJTVDRGVza3RvcCU1QyU1Q2Zyb250LXJiYW5kJTVDJTVDcmJhbmQlNUMlNUNzcmMlNUMlNUNjb21wb25lbnRzJTVDJTVDZm9vdGVyJTVDJTVDc3R5bGVzLm1vZHVsZS5zY3NzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkMlM0ElNUMlNUNVc2VycyU1QyU1Qzc5NTMzJTVDJTVDRGVza3RvcCU1QyU1Q2Zyb250LXJiYW5kJTVDJTVDcmJhbmQlNUMlNUNzcmMlNUMlNUNwcm92aWRlcnMlNUMlNUNwcm92aWRlcnMudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyUHJvdmlkZXJzJTIyJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkMlM0ElNUMlNUNVc2VycyU1QyU1Qzc5NTMzJTVDJTVDRGVza3RvcCU1QyU1Q2Zyb250LXJiYW5kJTVDJTVDcmJhbmQlNUMlNUNzcmMlNUMlNUNzdHlsZXMlNUMlNUNnbG9iYWxzLnNjc3MlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSxrWkFBa087QUFDbE87QUFDQSw0WEFBb1A7QUFDcFA7QUFDQSxzOEJBQWtoQjtBQUNsaEI7QUFDQSw4dEJBQXNaO0FBQ3RaO0FBQ0EsOExBQW1KO0FBQ25KO0FBQ0EsNE1BQStIO0FBQy9IO0FBQ0Esb05BQStIO0FBQy9IO0FBQ0Esb0xBQWdKO0FBQ2hKO0FBQ0EsNEtBQTZHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/NzljNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXFVzZXJzXFxcXDc5NTMzXFxcXERlc2t0b3BcXFxcZnJvbnQtcmJhbmRcXFxccmJhbmRcXFxcbm9kZV9tb2R1bGVzXFxcXC5wbnBtXFxcXG5leHRAMTQuMi4xX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjFfc2Fzc0AxLjc3LjJcXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZGlzdFxcXFxjbGllbnRcXFxcaW1hZ2UtY29tcG9uZW50LmpzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJkZWZhdWx0XCJdICovIFwiQzpcXFxcVXNlcnNcXFxcNzk1MzNcXFxcRGVza3RvcFxcXFxmcm9udC1yYmFuZFxcXFxyYmFuZFxcXFxub2RlX21vZHVsZXNcXFxcLnBucG1cXFxcbmV4dEAxNC4yLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuNzcuMlxcXFxub2RlX21vZHVsZXNcXFxcbmV4dFxcXFxkaXN0XFxcXGNsaWVudFxcXFxsaW5rLmpzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJDOlxcXFxVc2Vyc1xcXFw3OTUzM1xcXFxEZXNrdG9wXFxcXGZyb250LXJiYW5kXFxcXHJiYW5kXFxcXG5vZGVfbW9kdWxlc1xcXFwucG5wbVxcXFxuZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGZvbnRcXFxcbG9jYWxcXFxcdGFyZ2V0LmNzcz97XFxcInBhdGhcXFwiOlxcXCJzcmNcXFxcXFxcXGFwcFxcXFxcXFxcbGF5b3V0LnRzeFxcXCIsXFxcImltcG9ydFxcXCI6XFxcIlxcXCIsXFxcImFyZ3VtZW50c1xcXCI6W3tcXFwic3JjXFxcIjpbe1xcXCJwYXRoXFxcIjpcXFwiLi4vZm9udHMvSW50cm9CbGFja0NhcHMudHRmXFxcIn0se1xcXCJwYXRoXFxcIjpcXFwiLi4vZm9udHMvSW50cm9CbGFja0NhcHMud29mZlxcXCJ9LHtcXFwicGF0aFxcXCI6XFxcIi4uL2ZvbnRzL0ludHJvQmxhY2tDYXBzLndvZmYyXFxcIn1dLFxcXCJ2YXJpYWJsZVxcXCI6XFxcIi0tZm9udC1pbnRyb1xcXCIsXFxcInN0eWxlXFxcIjpcXFwibm9ybWFsXFxcIixcXFwid2VpZ2h0XFxcIjpcXFwiOTAwXFxcIn1dLFxcXCJ2YXJpYWJsZU5hbWVcXFwiOlxcXCJpbnRyb1xcXCJ9XCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJDOlxcXFxVc2Vyc1xcXFw3OTUzM1xcXFxEZXNrdG9wXFxcXGZyb250LXJiYW5kXFxcXHJiYW5kXFxcXG5vZGVfbW9kdWxlc1xcXFwucG5wbVxcXFxuZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGZvbnRcXFxcZ29vZ2xlXFxcXHRhcmdldC5jc3M/e1xcXCJwYXRoXFxcIjpcXFwic3JjXFxcXFxcXFxhcHBcXFxcXFxcXGxheW91dC50c3hcXFwiLFxcXCJpbXBvcnRcXFwiOlxcXCJNb250c2VycmF0XFxcIixcXFwiYXJndW1lbnRzXFxcIjpbe1xcXCJzdWJzZXRzXFxcIjpbXFxcImxhdGluXFxcIixcXFwiY3lyaWxsaWNcXFwiXSxcXFwidmFyaWFibGVcXFwiOlxcXCItLWZvbnQtbW9udHNlcnJhdFxcXCJ9XSxcXFwidmFyaWFibGVOYW1lXFxcIjpcXFwibW9udHNlcnJhdFxcXCJ9XCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJIZWFkZXJcIl0gKi8gXCJDOlxcXFxVc2Vyc1xcXFw3OTUzM1xcXFxEZXNrdG9wXFxcXGZyb250LXJiYW5kXFxcXHJiYW5kXFxcXHNyY1xcXFxjb21wb25lbnRzXFxcXGhlYWRlclxcXFxIZWFkZXIudHN4XCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJDOlxcXFxVc2Vyc1xcXFw3OTUzM1xcXFxEZXNrdG9wXFxcXGZyb250LXJiYW5kXFxcXHJiYW5kXFxcXHNyY1xcXFxjb21wb25lbnRzXFxcXHVpXFxcXGNvbnRhaW5lclxcXFxTdHlsZXMuc2Nzc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcNzk1MzNcXFxcRGVza3RvcFxcXFxmcm9udC1yYmFuZFxcXFxyYmFuZFxcXFxzcmNcXFxcY29tcG9uZW50c1xcXFxmb290ZXJcXFxcc3R5bGVzLm1vZHVsZS5zY3NzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJQcm92aWRlcnNcIl0gKi8gXCJDOlxcXFxVc2Vyc1xcXFw3OTUzM1xcXFxEZXNrdG9wXFxcXGZyb250LXJiYW5kXFxcXHJiYW5kXFxcXHNyY1xcXFxwcm92aWRlcnNcXFxccHJvdmlkZXJzLnRzeFwiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcNzk1MzNcXFxcRGVza3RvcFxcXFxmcm9udC1yYmFuZFxcXFxyYmFuZFxcXFxzcmNcXFxcc3R5bGVzXFxcXGdsb2JhbHMuc2Nzc1wiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Cnode_modules%5C%5C.pnpm%5C%5Cnext%4014.2.1_react-dom%4018.3.1_react%4018.3.1__react%4018.3.1_sass%401.77.2%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Cimage-component.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Cnode_modules%5C%5C.pnpm%5C%5Cnext%4014.2.1_react-dom%4018.3.1_react%4018.3.1__react%4018.3.1_sass%401.77.2%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Clink.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Cnode_modules%5C%5C.pnpm%5C%5Cnext%4014.2.1_react-dom%4018.3.1_react%4018.3.1__react%4018.3.1_sass%401.77.2%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Clocal%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%5C%5C%5C%5Capp%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22src%5C%22%3A%5B%7B%5C%22path%5C%22%3A%5C%22..%2Ffonts%2FIntroBlackCaps.ttf%5C%22%7D%2C%7B%5C%22path%5C%22%3A%5C%22..%2Ffonts%2FIntroBlackCaps.woff%5C%22%7D%2C%7B%5C%22path%5C%22%3A%5C%22..%2Ffonts%2FIntroBlackCaps.woff2%5C%22%7D%5D%2C%5C%22variable%5C%22%3A%5C%22--font-intro%5C%22%2C%5C%22style%5C%22%3A%5C%22normal%5C%22%2C%5C%22weight%5C%22%3A%5C%22900%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22intro%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Cnode_modules%5C%5C.pnpm%5C%5Cnext%4014.2.1_react-dom%4018.3.1_react%4018.3.1__react%4018.3.1_sass%401.77.2%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%5C%5C%5C%5Capp%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Montserrat%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%2C%5C%22cyrillic%5C%22%5D%2C%5C%22variable%5C%22%3A%5C%22--font-montserrat%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22montserrat%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cheader%5C%5CHeader.tsx%22%2C%22ids%22%3A%5B%22Header%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cui%5C%5Ccontainer%5C%5CStyles.scss%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cfooter%5C%5Cstyles.module.scss%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Cproviders%5C%5Cproviders.tsx%22%2C%22ids%22%3A%5B%22Providers%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Cstyles%5C%5Cglobals.scss%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@gsap+react@2.1.1/node_modules/@gsap/react/src/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/@gsap+react@2.1.1/node_modules/@gsap/react/src/index.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGSAP: function() { return /* binding */ useGSAP; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gsap */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js\");\n/*!\n * @gsap/react 2.1.1\n * https://gsap.com\n *\n * Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\n\n\nlet useIsomorphicLayoutEffect = typeof window !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n    isConfig = value => value && !Array.isArray(value) && typeof(value) === \"object\",\n    emptyArray = [],\n    defaultConfig = {},\n    _gsap = gsap__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; // accommodates situations where different versions of GSAP may be loaded, so a user can gsap.registerPlugin(useGSAP);\n\nconst useGSAP = (callback, dependencies = emptyArray) => {\n  let config = defaultConfig;\n  if (isConfig(callback)) {\n    config = callback;\n    callback = null;\n    dependencies = \"dependencies\" in config ? config.dependencies : emptyArray;\n  } else if (isConfig(dependencies)) {\n    config = dependencies;\n    dependencies = \"dependencies\" in config ? config.dependencies : emptyArray;\n  }\n  (callback && typeof callback !== \"function\") && console.warn(\"First parameter must be a function or config object\");\n  const { scope, revertOnUpdate } = config,\n        mounted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false),\n        context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(_gsap.context(() => { }, scope)),\n        contextSafe = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)((func) => context.current.add(null, func)),\n        deferCleanup = dependencies && dependencies.length && !revertOnUpdate;\n  useIsomorphicLayoutEffect(() => {\n    callback && context.current.add(callback, scope);\n    if (!deferCleanup || !mounted.current) { // React renders bottom-up, thus there could be hooks with dependencies that run BEFORE the component mounts, thus cleanup wouldn't occur since a hook with an empty dependency Array would only run once the component mounts.\n      return () => context.current.revert();\n    }\n  }, dependencies);\n  deferCleanup && useIsomorphicLayoutEffect(() => {\n      mounted.current = true;\n      return () => context.current.revert();\n    }, emptyArray);\n  return { context: context.current, contextSafe: contextSafe.current };\n};\nuseGSAP.register = core => { _gsap = core; };\nuseGSAP.headless = true; // doesn't require the window to be registered.\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AZ3NhcCtyZWFjdEAyLjEuMS9ub2RlX21vZHVsZXMvQGdzYXAvcmVhY3Qvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMyRDtBQUNuQzs7QUFFeEIsZ0VBQWdFLGtEQUFlLEdBQUcsNENBQVM7QUFDM0Y7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixZQUFZLDRDQUFJLEVBQUU7O0FBRVg7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEMsa0JBQWtCLDZDQUFNO0FBQ3hCLGtCQUFrQiw2Q0FBTSx3QkFBd0I7QUFDaEQsc0JBQXNCLDZDQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXO0FBQ1g7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AZ3NhcCtyZWFjdEAyLjEuMS9ub2RlX21vZHVsZXMvQGdzYXAvcmVhY3Qvc3JjL2luZGV4LmpzPzBiOGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAZ3NhcC9yZWFjdCAyLjEuMVxuICogaHR0cHM6Ly9nc2FwLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDA4LTIwMjQsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3NhcC5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR1NBUCBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgZ3NhcCBmcm9tIFwiZ3NhcFwiO1xuXG5sZXQgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3QsXG4gICAgaXNDb25maWcgPSB2YWx1ZSA9PiB2YWx1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mKHZhbHVlKSA9PT0gXCJvYmplY3RcIixcbiAgICBlbXB0eUFycmF5ID0gW10sXG4gICAgZGVmYXVsdENvbmZpZyA9IHt9LFxuICAgIF9nc2FwID0gZ3NhcDsgLy8gYWNjb21tb2RhdGVzIHNpdHVhdGlvbnMgd2hlcmUgZGlmZmVyZW50IHZlcnNpb25zIG9mIEdTQVAgbWF5IGJlIGxvYWRlZCwgc28gYSB1c2VyIGNhbiBnc2FwLnJlZ2lzdGVyUGx1Z2luKHVzZUdTQVApO1xuXG5leHBvcnQgY29uc3QgdXNlR1NBUCA9IChjYWxsYmFjaywgZGVwZW5kZW5jaWVzID0gZW1wdHlBcnJheSkgPT4ge1xuICBsZXQgY29uZmlnID0gZGVmYXVsdENvbmZpZztcbiAgaWYgKGlzQ29uZmlnKGNhbGxiYWNrKSkge1xuICAgIGNvbmZpZyA9IGNhbGxiYWNrO1xuICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICBkZXBlbmRlbmNpZXMgPSBcImRlcGVuZGVuY2llc1wiIGluIGNvbmZpZyA/IGNvbmZpZy5kZXBlbmRlbmNpZXMgOiBlbXB0eUFycmF5O1xuICB9IGVsc2UgaWYgKGlzQ29uZmlnKGRlcGVuZGVuY2llcykpIHtcbiAgICBjb25maWcgPSBkZXBlbmRlbmNpZXM7XG4gICAgZGVwZW5kZW5jaWVzID0gXCJkZXBlbmRlbmNpZXNcIiBpbiBjb25maWcgPyBjb25maWcuZGVwZW5kZW5jaWVzIDogZW1wdHlBcnJheTtcbiAgfVxuICAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpICYmIGNvbnNvbGUud2FybihcIkZpcnN0IHBhcmFtZXRlciBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgY29uZmlnIG9iamVjdFwiKTtcbiAgY29uc3QgeyBzY29wZSwgcmV2ZXJ0T25VcGRhdGUgfSA9IGNvbmZpZyxcbiAgICAgICAgbW91bnRlZCA9IHVzZVJlZihmYWxzZSksXG4gICAgICAgIGNvbnRleHQgPSB1c2VSZWYoX2dzYXAuY29udGV4dCgoKSA9PiB7IH0sIHNjb3BlKSksXG4gICAgICAgIGNvbnRleHRTYWZlID0gdXNlUmVmKChmdW5jKSA9PiBjb250ZXh0LmN1cnJlbnQuYWRkKG51bGwsIGZ1bmMpKSxcbiAgICAgICAgZGVmZXJDbGVhbnVwID0gZGVwZW5kZW5jaWVzICYmIGRlcGVuZGVuY2llcy5sZW5ndGggJiYgIXJldmVydE9uVXBkYXRlO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjYWxsYmFjayAmJiBjb250ZXh0LmN1cnJlbnQuYWRkKGNhbGxiYWNrLCBzY29wZSk7XG4gICAgaWYgKCFkZWZlckNsZWFudXAgfHwgIW1vdW50ZWQuY3VycmVudCkgeyAvLyBSZWFjdCByZW5kZXJzIGJvdHRvbS11cCwgdGh1cyB0aGVyZSBjb3VsZCBiZSBob29rcyB3aXRoIGRlcGVuZGVuY2llcyB0aGF0IHJ1biBCRUZPUkUgdGhlIGNvbXBvbmVudCBtb3VudHMsIHRodXMgY2xlYW51cCB3b3VsZG4ndCBvY2N1ciBzaW5jZSBhIGhvb2sgd2l0aCBhbiBlbXB0eSBkZXBlbmRlbmN5IEFycmF5IHdvdWxkIG9ubHkgcnVuIG9uY2UgdGhlIGNvbXBvbmVudCBtb3VudHMuXG4gICAgICByZXR1cm4gKCkgPT4gY29udGV4dC5jdXJyZW50LnJldmVydCgpO1xuICAgIH1cbiAgfSwgZGVwZW5kZW5jaWVzKTtcbiAgZGVmZXJDbGVhbnVwICYmIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgbW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIHJldHVybiAoKSA9PiBjb250ZXh0LmN1cnJlbnQucmV2ZXJ0KCk7XG4gICAgfSwgZW1wdHlBcnJheSk7XG4gIHJldHVybiB7IGNvbnRleHQ6IGNvbnRleHQuY3VycmVudCwgY29udGV4dFNhZmU6IGNvbnRleHRTYWZlLmN1cnJlbnQgfTtcbn07XG51c2VHU0FQLnJlZ2lzdGVyID0gY29yZSA9PiB7IF9nc2FwID0gY29yZTsgfTtcbnVzZUdTQVAuaGVhZGxlc3MgPSB0cnVlOyAvLyBkb2Vzbid0IHJlcXVpcmUgdGhlIHdpbmRvdyB0byBiZSByZWdpc3RlcmVkLlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@gsap+react@2.1.1/node_modules/@gsap/react/src/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@iconify+react@4.1.1_react@18.3.1/node_modules/@iconify/react/dist/iconify.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@iconify+react@4.1.1_react@18.3.1/node_modules/@iconify/react/dist/iconify.js ***!
  \**********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_class_call_check.js\");\nvar _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_create_class.js\");\nvar _inherits = __webpack_require__(/*! @swc/helpers/_/_inherits */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_inherits.js\");\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\nvar _type_of = __webpack_require__(/*! @swc/helpers/_/_type_of */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_type_of.js\");\nvar _create_super = __webpack_require__(/*! @swc/helpers/_/_create_super */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_create_super.js\");\nvar React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\nvar matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;\nvar stringToIcon = function(value, validate, allowSimpleName) {\n    var provider = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"\";\n    var colonSeparated = value.split(\":\");\n    if (value.slice(0, 1) === \"@\") {\n        if (colonSeparated.length < 2 || colonSeparated.length > 3) {\n            return null;\n        }\n        provider = colonSeparated.shift().slice(1);\n    }\n    if (colonSeparated.length > 3 || !colonSeparated.length) {\n        return null;\n    }\n    if (colonSeparated.length > 1) {\n        var name2 = colonSeparated.pop();\n        var prefix = colonSeparated.pop();\n        var result = {\n            // Allow provider without '@': \"provider:prefix:name\"\n            provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,\n            prefix: prefix,\n            name: name2\n        };\n        return validate && !validateIconName(result) ? null : result;\n    }\n    var name = colonSeparated[0];\n    var dashSeparated = name.split(\"-\");\n    if (dashSeparated.length > 1) {\n        var result1 = {\n            provider: provider,\n            prefix: dashSeparated.shift(),\n            name: dashSeparated.join(\"-\")\n        };\n        return validate && !validateIconName(result1) ? null : result1;\n    }\n    if (allowSimpleName && provider === \"\") {\n        var result2 = {\n            provider: provider,\n            prefix: \"\",\n            name: name\n        };\n        return validate && !validateIconName(result2, allowSimpleName) ? null : result2;\n    }\n    return null;\n};\nvar validateIconName = function(icon, allowSimpleName) {\n    if (!icon) {\n        return false;\n    }\n    return !!((icon.provider === \"\" || icon.provider.match(matchIconName)) && (allowSimpleName && icon.prefix === \"\" || icon.prefix.match(matchIconName)) && icon.name.match(matchIconName));\n};\nvar defaultIconDimensions = Object.freeze({\n    left: 0,\n    top: 0,\n    width: 16,\n    height: 16\n});\nvar defaultIconTransformations = Object.freeze({\n    rotate: 0,\n    vFlip: false,\n    hFlip: false\n});\nvar defaultIconProps = Object.freeze(_object_spread._({}, defaultIconDimensions, defaultIconTransformations));\nvar defaultExtendedIconProps = Object.freeze(_object_spread_props._(_object_spread._({}, defaultIconProps), {\n    body: \"\",\n    hidden: false\n}));\nfunction mergeIconTransformations(obj1, obj2) {\n    var result = {};\n    if (!obj1.hFlip !== !obj2.hFlip) {\n        result.hFlip = true;\n    }\n    if (!obj1.vFlip !== !obj2.vFlip) {\n        result.vFlip = true;\n    }\n    var rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;\n    if (rotate) {\n        result.rotate = rotate;\n    }\n    return result;\n}\nfunction mergeIconData(parent, child) {\n    var result = mergeIconTransformations(parent, child);\n    for(var key in defaultExtendedIconProps){\n        if (key in defaultIconTransformations) {\n            if (key in parent && !(key in result)) {\n                result[key] = defaultIconTransformations[key];\n            }\n        } else if (key in child) {\n            result[key] = child[key];\n        } else if (key in parent) {\n            result[key] = parent[key];\n        }\n    }\n    return result;\n}\nfunction getIconsTree(data, names) {\n    var icons = data.icons;\n    var aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n    var resolved = /* @__PURE__ */ Object.create(null);\n    function resolve(name) {\n        if (icons[name]) {\n            return resolved[name] = [];\n        }\n        if (!(name in resolved)) {\n            resolved[name] = null;\n            var parent = aliases[name] && aliases[name].parent;\n            var value = parent && resolve(parent);\n            if (value) {\n                resolved[name] = [\n                    parent\n                ].concat(value);\n            }\n        }\n        return resolved[name];\n    }\n    (names || Object.keys(icons).concat(Object.keys(aliases))).forEach(resolve);\n    return resolved;\n}\nfunction internalGetIconData(data, name, tree) {\n    var icons = data.icons;\n    var aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n    var currentProps = {};\n    function parse(name2) {\n        currentProps = mergeIconData(icons[name2] || aliases[name2], currentProps);\n    }\n    parse(name);\n    tree.forEach(parse);\n    return mergeIconData(data, currentProps);\n}\nfunction parseIconSet(data, callback) {\n    var names = [];\n    if (typeof data !== \"object\" || typeof data.icons !== \"object\") {\n        return names;\n    }\n    if (data.not_found instanceof Array) {\n        data.not_found.forEach(function(name) {\n            callback(name, null);\n            names.push(name);\n        });\n    }\n    var tree = getIconsTree(data);\n    for(var name in tree){\n        var item = tree[name];\n        if (item) {\n            callback(name, internalGetIconData(data, name, item));\n            names.push(name);\n        }\n    }\n    return names;\n}\nvar optionalPropertyDefaults = _object_spread._({\n    provider: \"\",\n    aliases: {},\n    not_found: {}\n}, defaultIconDimensions);\nfunction checkOptionalProps(item, defaults) {\n    for(var prop in defaults){\n        if (prop in item && _type_of._(item[prop]) !== _type_of._(defaults[prop])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction quicklyValidateIconSet(obj) {\n    if (typeof obj !== \"object\" || obj === null) {\n        return null;\n    }\n    var data = obj;\n    if (typeof data.prefix !== \"string\" || !obj.icons || typeof obj.icons !== \"object\") {\n        return null;\n    }\n    if (!checkOptionalProps(obj, optionalPropertyDefaults)) {\n        return null;\n    }\n    var icons = data.icons;\n    for(var name in icons){\n        var icon = icons[name];\n        if (!name.match(matchIconName) || typeof icon.body !== \"string\" || !checkOptionalProps(icon, defaultExtendedIconProps)) {\n            return null;\n        }\n    }\n    var aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n    for(var name1 in aliases){\n        var icon1 = aliases[name1];\n        var parent = icon1.parent;\n        if (!name1.match(matchIconName) || typeof parent !== \"string\" || !icons[parent] && !aliases[parent] || !checkOptionalProps(icon1, defaultExtendedIconProps)) {\n            return null;\n        }\n    }\n    return data;\n}\nvar dataStorage = /* @__PURE__ */ Object.create(null);\nfunction newStorage(provider, prefix) {\n    return {\n        provider: provider,\n        prefix: prefix,\n        icons: /* @__PURE__ */ Object.create(null),\n        missing: /* @__PURE__ */ new Set()\n    };\n}\nfunction getStorage(provider, prefix) {\n    var providerStorage = dataStorage[provider] || (dataStorage[provider] = /* @__PURE__ */ Object.create(null));\n    return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));\n}\nfunction addIconSet(storage, data) {\n    if (!quicklyValidateIconSet(data)) {\n        return [];\n    }\n    return parseIconSet(data, function(name, icon) {\n        if (icon) {\n            storage.icons[name] = icon;\n        } else {\n            storage.missing.add(name);\n        }\n    });\n}\nfunction addIconToStorage(storage, name, icon) {\n    try {\n        if (typeof icon.body === \"string\") {\n            storage.icons[name] = _object_spread._({}, icon);\n            return true;\n        }\n    } catch (err) {}\n    return false;\n}\nfunction listIcons(provider, prefix) {\n    var allIcons = [];\n    var providers = typeof provider === \"string\" ? [\n        provider\n    ] : Object.keys(dataStorage);\n    providers.forEach(function(provider2) {\n        var prefixes = typeof provider2 === \"string\" && typeof prefix === \"string\" ? [\n            prefix\n        ] : Object.keys(dataStorage[provider2] || {});\n        prefixes.forEach(function(prefix2) {\n            var storage = getStorage(provider2, prefix2);\n            allIcons = allIcons.concat(Object.keys(storage.icons).map(function(name) {\n                return (provider2 !== \"\" ? \"@\" + provider2 + \":\" : \"\") + prefix2 + \":\" + name;\n            }));\n        });\n    });\n    return allIcons;\n}\nvar simpleNames = false;\nfunction allowSimpleNames(allow) {\n    if (typeof allow === \"boolean\") {\n        simpleNames = allow;\n    }\n    return simpleNames;\n}\nfunction getIconData(name) {\n    var icon = typeof name === \"string\" ? stringToIcon(name, true, simpleNames) : name;\n    if (icon) {\n        var storage = getStorage(icon.provider, icon.prefix);\n        var iconName = icon.name;\n        return storage.icons[iconName] || (storage.missing.has(iconName) ? null : void 0);\n    }\n}\nfunction addIcon(name, data) {\n    var icon = stringToIcon(name, true, simpleNames);\n    if (!icon) {\n        return false;\n    }\n    var storage = getStorage(icon.provider, icon.prefix);\n    return addIconToStorage(storage, icon.name, data);\n}\nfunction addCollection(data, provider) {\n    if (typeof data !== \"object\") {\n        return false;\n    }\n    if (typeof provider !== \"string\") {\n        provider = data.provider || \"\";\n    }\n    if (simpleNames && !provider && !data.prefix) {\n        var added = false;\n        if (quicklyValidateIconSet(data)) {\n            data.prefix = \"\";\n            parseIconSet(data, function(name, icon) {\n                if (icon && addIcon(name, icon)) {\n                    added = true;\n                }\n            });\n        }\n        return added;\n    }\n    var prefix = data.prefix;\n    if (!validateIconName({\n        provider: provider,\n        prefix: prefix,\n        name: \"a\"\n    })) {\n        return false;\n    }\n    var storage = getStorage(provider, prefix);\n    return !!addIconSet(storage, data);\n}\nfunction iconExists(name) {\n    return !!getIconData(name);\n}\nfunction getIcon(name) {\n    var result = getIconData(name);\n    return result ? _object_spread._({}, defaultIconProps, result) : null;\n}\nvar defaultIconSizeCustomisations = Object.freeze({\n    width: null,\n    height: null\n});\nvar defaultIconCustomisations = Object.freeze(_object_spread._({}, defaultIconSizeCustomisations, defaultIconTransformations));\nvar unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;\nvar unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;\nfunction calculateSize(size, ratio, precision) {\n    if (ratio === 1) {\n        return size;\n    }\n    precision = precision || 100;\n    if (typeof size === \"number\") {\n        return Math.ceil(size * ratio * precision) / precision;\n    }\n    if (typeof size !== \"string\") {\n        return size;\n    }\n    var oldParts = size.split(unitsSplit);\n    if (oldParts === null || !oldParts.length) {\n        return size;\n    }\n    var newParts = [];\n    var code = oldParts.shift();\n    var isNumber = unitsTest.test(code);\n    while(true){\n        if (isNumber) {\n            var num = parseFloat(code);\n            if (isNaN(num)) {\n                newParts.push(code);\n            } else {\n                newParts.push(Math.ceil(num * ratio * precision) / precision);\n            }\n        } else {\n            newParts.push(code);\n        }\n        code = oldParts.shift();\n        if (code === void 0) {\n            return newParts.join(\"\");\n        }\n        isNumber = !isNumber;\n    }\n}\nvar isUnsetKeyword = function(value) {\n    return value === \"unset\" || value === \"undefined\" || value === \"none\";\n};\nfunction iconToSVG(icon, customisations) {\n    var fullIcon = _object_spread._({}, defaultIconProps, icon);\n    var fullCustomisations = _object_spread._({}, defaultIconCustomisations, customisations);\n    var box = {\n        left: fullIcon.left,\n        top: fullIcon.top,\n        width: fullIcon.width,\n        height: fullIcon.height\n    };\n    var body = fullIcon.body;\n    [\n        fullIcon,\n        fullCustomisations\n    ].forEach(function(props) {\n        var transformations = [];\n        var hFlip = props.hFlip;\n        var vFlip = props.vFlip;\n        var rotation = props.rotate;\n        if (hFlip) {\n            if (vFlip) {\n                rotation += 2;\n            } else {\n                transformations.push(\"translate(\" + (box.width + box.left).toString() + \" \" + (0 - box.top).toString() + \")\");\n                transformations.push(\"scale(-1 1)\");\n                box.top = box.left = 0;\n            }\n        } else if (vFlip) {\n            transformations.push(\"translate(\" + (0 - box.left).toString() + \" \" + (box.height + box.top).toString() + \")\");\n            transformations.push(\"scale(1 -1)\");\n            box.top = box.left = 0;\n        }\n        var tempValue;\n        if (rotation < 0) {\n            rotation -= Math.floor(rotation / 4) * 4;\n        }\n        rotation = rotation % 4;\n        switch(rotation){\n            case 1:\n                tempValue = box.height / 2 + box.top;\n                transformations.unshift(\"rotate(90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n                break;\n            case 2:\n                transformations.unshift(\"rotate(180 \" + (box.width / 2 + box.left).toString() + \" \" + (box.height / 2 + box.top).toString() + \")\");\n                break;\n            case 3:\n                tempValue = box.width / 2 + box.left;\n                transformations.unshift(\"rotate(-90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n                break;\n        }\n        if (rotation % 2 === 1) {\n            if (box.left !== box.top) {\n                tempValue = box.left;\n                box.left = box.top;\n                box.top = tempValue;\n            }\n            if (box.width !== box.height) {\n                tempValue = box.width;\n                box.width = box.height;\n                box.height = tempValue;\n            }\n        }\n        if (transformations.length) {\n            body = '<g transform=\"' + transformations.join(\" \") + '\">' + body + \"</g>\";\n        }\n    });\n    var customisationsWidth = fullCustomisations.width;\n    var customisationsHeight = fullCustomisations.height;\n    var boxWidth = box.width;\n    var boxHeight = box.height;\n    var width;\n    var height;\n    if (customisationsWidth === null) {\n        height = customisationsHeight === null ? \"1em\" : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n        width = calculateSize(height, boxWidth / boxHeight);\n    } else {\n        width = customisationsWidth === \"auto\" ? boxWidth : customisationsWidth;\n        height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n    }\n    var attributes = {};\n    var setAttr = function(prop, value) {\n        if (!isUnsetKeyword(value)) {\n            attributes[prop] = value.toString();\n        }\n    };\n    setAttr(\"width\", width);\n    setAttr(\"height\", height);\n    attributes.viewBox = box.left.toString() + \" \" + box.top.toString() + \" \" + boxWidth.toString() + \" \" + boxHeight.toString();\n    return {\n        attributes: attributes,\n        body: body\n    };\n}\nvar regex = /\\sid=\"(\\S+)\"/g;\nvar randomPrefix = \"IconifyId\" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);\nvar counter = 0;\nfunction replaceIDs(body) {\n    var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : randomPrefix;\n    var ids = [];\n    var match;\n    while(match = regex.exec(body)){\n        ids.push(match[1]);\n    }\n    if (!ids.length) {\n        return body;\n    }\n    var suffix = \"suffix\" + (Math.random() * 16777216 | Date.now()).toString(16);\n    ids.forEach(function(id) {\n        var newID = typeof prefix === \"function\" ? prefix(id) : prefix + (counter++).toString();\n        var escapedID = id.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n        body = body.replace(// Allowed characters before id: [#;\"]\n        // Allowed characters after id: [)\"], .[a-z]\n        new RegExp('([#;\"])(' + escapedID + ')([\")]|\\\\.[a-z])', \"g\"), \"$1\" + newID + suffix + \"$3\");\n    });\n    body = body.replace(new RegExp(suffix, \"g\"), \"\");\n    return body;\n}\nvar storage = /* @__PURE__ */ Object.create(null);\nfunction setAPIModule(provider, item) {\n    storage[provider] = item;\n}\nfunction getAPIModule(provider) {\n    return storage[provider] || storage[\"\"];\n}\nfunction createAPIConfig(source) {\n    var resources;\n    if (typeof source.resources === \"string\") {\n        resources = [\n            source.resources\n        ];\n    } else {\n        resources = source.resources;\n        if (!(resources instanceof Array) || !resources.length) {\n            return null;\n        }\n    }\n    var result = {\n        // API hosts\n        resources: resources,\n        // Root path\n        path: source.path || \"/\",\n        // URL length limit\n        maxURL: source.maxURL || 500,\n        // Timeout before next host is used.\n        rotate: source.rotate || 750,\n        // Timeout before failing query.\n        timeout: source.timeout || 5e3,\n        // Randomise default API end point.\n        random: source.random === true,\n        // Start index\n        index: source.index || 0,\n        // Receive data after time out (used if time out kicks in first, then API module sends data anyway).\n        dataAfterTimeout: source.dataAfterTimeout !== false\n    };\n    return result;\n}\nvar configStorage = /* @__PURE__ */ Object.create(null);\nvar fallBackAPISources = [\n    \"https://api.simplesvg.com\",\n    \"https://api.unisvg.com\"\n];\nvar fallBackAPI = [];\nwhile(fallBackAPISources.length > 0){\n    if (fallBackAPISources.length === 1) {\n        fallBackAPI.push(fallBackAPISources.shift());\n    } else {\n        if (Math.random() > 0.5) {\n            fallBackAPI.push(fallBackAPISources.shift());\n        } else {\n            fallBackAPI.push(fallBackAPISources.pop());\n        }\n    }\n}\nconfigStorage[\"\"] = createAPIConfig({\n    resources: [\n        \"https://api.iconify.design\"\n    ].concat(fallBackAPI)\n});\nfunction addAPIProvider(provider, customConfig) {\n    var config = createAPIConfig(customConfig);\n    if (config === null) {\n        return false;\n    }\n    configStorage[provider] = config;\n    return true;\n}\nfunction getAPIConfig(provider) {\n    return configStorage[provider];\n}\nfunction listAPIProviders() {\n    return Object.keys(configStorage);\n}\nvar detectFetch = function() {\n    var callback;\n    try {\n        callback = fetch;\n        if (typeof callback === \"function\") {\n            return callback;\n        }\n    } catch (err) {}\n};\nvar fetchModule = detectFetch();\nfunction setFetch(fetch2) {\n    fetchModule = fetch2;\n}\nfunction getFetch() {\n    return fetchModule;\n}\nfunction calculateMaxLength(provider, prefix) {\n    var config = getAPIConfig(provider);\n    if (!config) {\n        return 0;\n    }\n    var result;\n    if (!config.maxURL) {\n        result = 0;\n    } else {\n        var maxHostLength = 0;\n        config.resources.forEach(function(item) {\n            var host = item;\n            maxHostLength = Math.max(maxHostLength, host.length);\n        });\n        var url = prefix + \".json?icons=\";\n        result = config.maxURL - maxHostLength - config.path.length - url.length;\n    }\n    return result;\n}\nfunction shouldAbort(status) {\n    return status === 404;\n}\nvar prepare = function(provider, prefix, icons) {\n    var results = [];\n    var maxLength = calculateMaxLength(provider, prefix);\n    var type = \"icons\";\n    var item = {\n        type: type,\n        provider: provider,\n        prefix: prefix,\n        icons: []\n    };\n    var length = 0;\n    icons.forEach(function(name, index) {\n        length += name.length + 1;\n        if (length >= maxLength && index > 0) {\n            results.push(item);\n            item = {\n                type: type,\n                provider: provider,\n                prefix: prefix,\n                icons: []\n            };\n            length = name.length;\n        }\n        item.icons.push(name);\n    });\n    results.push(item);\n    return results;\n};\nfunction getPath(provider) {\n    if (typeof provider === \"string\") {\n        var config = getAPIConfig(provider);\n        if (config) {\n            return config.path;\n        }\n    }\n    return \"/\";\n}\nvar send = function(host, params, callback) {\n    if (!fetchModule) {\n        callback(\"abort\", 424);\n        return;\n    }\n    var path = getPath(params.provider);\n    switch(params.type){\n        case \"icons\":\n            {\n                var prefix = params.prefix;\n                var icons = params.icons;\n                var iconsList = icons.join(\",\");\n                var urlParams = new URLSearchParams({\n                    icons: iconsList\n                });\n                path += prefix + \".json?\" + urlParams.toString();\n                break;\n            }\n        case \"custom\":\n            {\n                var uri = params.uri;\n                path += uri.slice(0, 1) === \"/\" ? uri.slice(1) : uri;\n                break;\n            }\n        default:\n            callback(\"abort\", 400);\n            return;\n    }\n    var defaultError = 503;\n    fetchModule(host + path).then(function(response) {\n        var status = response.status;\n        if (status !== 200) {\n            setTimeout(function() {\n                callback(shouldAbort(status) ? \"abort\" : \"next\", status);\n            });\n            return;\n        }\n        defaultError = 501;\n        return response.json();\n    }).then(function(data) {\n        if (typeof data !== \"object\" || data === null) {\n            setTimeout(function() {\n                if (data === 404) {\n                    callback(\"abort\", data);\n                } else {\n                    callback(\"next\", defaultError);\n                }\n            });\n            return;\n        }\n        setTimeout(function() {\n            callback(\"success\", data);\n        });\n    })[\"catch\"](function() {\n        callback(\"next\", defaultError);\n    });\n};\nvar fetchAPIModule = {\n    prepare: prepare,\n    send: send\n};\nfunction sortIcons(icons) {\n    var result = {\n        loaded: [],\n        missing: [],\n        pending: []\n    };\n    var storage = /* @__PURE__ */ Object.create(null);\n    icons.sort(function(a, b) {\n        if (a.provider !== b.provider) {\n            return a.provider.localeCompare(b.provider);\n        }\n        if (a.prefix !== b.prefix) {\n            return a.prefix.localeCompare(b.prefix);\n        }\n        return a.name.localeCompare(b.name);\n    });\n    var lastIcon = {\n        provider: \"\",\n        prefix: \"\",\n        name: \"\"\n    };\n    icons.forEach(function(icon) {\n        if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {\n            return;\n        }\n        lastIcon = icon;\n        var provider = icon.provider;\n        var prefix = icon.prefix;\n        var name = icon.name;\n        var providerStorage = storage[provider] || (storage[provider] = /* @__PURE__ */ Object.create(null));\n        var localStorage = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));\n        var list;\n        if (name in localStorage.icons) {\n            list = result.loaded;\n        } else if (prefix === \"\" || localStorage.missing.has(name)) {\n            list = result.missing;\n        } else {\n            list = result.pending;\n        }\n        var item = {\n            provider: provider,\n            prefix: prefix,\n            name: name\n        };\n        list.push(item);\n    });\n    return result;\n}\nfunction removeCallback(storages, id) {\n    storages.forEach(function(storage) {\n        var items = storage.loaderCallbacks;\n        if (items) {\n            storage.loaderCallbacks = items.filter(function(row) {\n                return row.id !== id;\n            });\n        }\n    });\n}\nfunction updateCallbacks(storage) {\n    if (!storage.pendingCallbacksFlag) {\n        storage.pendingCallbacksFlag = true;\n        setTimeout(function() {\n            storage.pendingCallbacksFlag = false;\n            var items = storage.loaderCallbacks ? storage.loaderCallbacks.slice(0) : [];\n            if (!items.length) {\n                return;\n            }\n            var hasPending = false;\n            var provider = storage.provider;\n            var prefix = storage.prefix;\n            items.forEach(function(item) {\n                var icons = item.icons;\n                var oldLength = icons.pending.length;\n                icons.pending = icons.pending.filter(function(icon) {\n                    if (icon.prefix !== prefix) {\n                        return true;\n                    }\n                    var name = icon.name;\n                    if (storage.icons[name]) {\n                        icons.loaded.push({\n                            provider: provider,\n                            prefix: prefix,\n                            name: name\n                        });\n                    } else if (storage.missing.has(name)) {\n                        icons.missing.push({\n                            provider: provider,\n                            prefix: prefix,\n                            name: name\n                        });\n                    } else {\n                        hasPending = true;\n                        return true;\n                    }\n                    return false;\n                });\n                if (icons.pending.length !== oldLength) {\n                    if (!hasPending) {\n                        removeCallback([\n                            storage\n                        ], item.id);\n                    }\n                    item.callback(icons.loaded.slice(0), icons.missing.slice(0), icons.pending.slice(0), item.abort);\n                }\n            });\n        });\n    }\n}\nvar idCounter = 0;\nfunction storeCallback(callback, icons, pendingSources) {\n    var id = idCounter++;\n    var abort = removeCallback.bind(null, pendingSources, id);\n    if (!icons.pending.length) {\n        return abort;\n    }\n    var item = {\n        id: id,\n        icons: icons,\n        callback: callback,\n        abort: abort\n    };\n    pendingSources.forEach(function(storage) {\n        (storage.loaderCallbacks || (storage.loaderCallbacks = [])).push(item);\n    });\n    return abort;\n}\nfunction listToIcons(list) {\n    var validate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, simpleNames = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    var result = [];\n    list.forEach(function(item) {\n        var icon = typeof item === \"string\" ? stringToIcon(item, validate, simpleNames) : item;\n        if (icon) {\n            result.push(icon);\n        }\n    });\n    return result;\n}\n// src/config.ts\nvar defaultConfig = {\n    resources: [],\n    index: 0,\n    timeout: 2e3,\n    rotate: 750,\n    random: false,\n    dataAfterTimeout: false\n};\n// src/query.ts\nfunction sendQuery(config, payload, query, done) {\n    var resourcesCount = config.resources.length;\n    var startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;\n    var resources;\n    if (config.random) {\n        var list = config.resources.slice(0);\n        resources = [];\n        while(list.length > 1){\n            var nextIndex = Math.floor(Math.random() * list.length);\n            resources.push(list[nextIndex]);\n            list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));\n        }\n        resources = resources.concat(list);\n    } else {\n        resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));\n    }\n    var startTime = Date.now();\n    var status = \"pending\";\n    var queriesSent = 0;\n    var lastError;\n    var timer = null;\n    var queue = [];\n    var doneCallbacks = [];\n    if (typeof done === \"function\") {\n        doneCallbacks.push(done);\n    }\n    function resetTimer() {\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n        }\n    }\n    function abort() {\n        if (status === \"pending\") {\n            status = \"aborted\";\n        }\n        resetTimer();\n        queue.forEach(function(item) {\n            if (item.status === \"pending\") {\n                item.status = \"aborted\";\n            }\n        });\n        queue = [];\n    }\n    function subscribe(callback, overwrite) {\n        if (overwrite) {\n            doneCallbacks = [];\n        }\n        if (typeof callback === \"function\") {\n            doneCallbacks.push(callback);\n        }\n    }\n    function getQueryStatus() {\n        return {\n            startTime: startTime,\n            payload: payload,\n            status: status,\n            queriesSent: queriesSent,\n            queriesPending: queue.length,\n            subscribe: subscribe,\n            abort: abort\n        };\n    }\n    function failQuery() {\n        status = \"failed\";\n        doneCallbacks.forEach(function(callback) {\n            callback(void 0, lastError);\n        });\n    }\n    function clearQueue() {\n        queue.forEach(function(item) {\n            if (item.status === \"pending\") {\n                item.status = \"aborted\";\n            }\n        });\n        queue = [];\n    }\n    function moduleResponse(item, response, data) {\n        var isError = response !== \"success\";\n        queue = queue.filter(function(queued) {\n            return queued !== item;\n        });\n        switch(status){\n            case \"pending\":\n                break;\n            case \"failed\":\n                if (isError || !config.dataAfterTimeout) {\n                    return;\n                }\n                break;\n            default:\n                return;\n        }\n        if (response === \"abort\") {\n            lastError = data;\n            failQuery();\n            return;\n        }\n        if (isError) {\n            lastError = data;\n            if (!queue.length) {\n                if (!resources.length) {\n                    failQuery();\n                } else {\n                    execNext();\n                }\n            }\n            return;\n        }\n        resetTimer();\n        clearQueue();\n        if (!config.random) {\n            var index = config.resources.indexOf(item.resource);\n            if (index !== -1 && index !== config.index) {\n                config.index = index;\n            }\n        }\n        status = \"completed\";\n        doneCallbacks.forEach(function(callback) {\n            callback(data);\n        });\n    }\n    function execNext() {\n        if (status !== \"pending\") {\n            return;\n        }\n        resetTimer();\n        var resource = resources.shift();\n        if (resource === void 0) {\n            if (queue.length) {\n                timer = setTimeout(function() {\n                    resetTimer();\n                    if (status === \"pending\") {\n                        clearQueue();\n                        failQuery();\n                    }\n                }, config.timeout);\n                return;\n            }\n            failQuery();\n            return;\n        }\n        var item = {\n            status: \"pending\",\n            resource: resource,\n            callback: function(status2, data) {\n                moduleResponse(item, status2, data);\n            }\n        };\n        queue.push(item);\n        queriesSent++;\n        timer = setTimeout(execNext, config.rotate);\n        query(resource, payload, item.callback);\n    }\n    setTimeout(execNext);\n    return getQueryStatus;\n}\n// src/index.ts\nfunction initRedundancy(cfg) {\n    var config = _object_spread._({}, defaultConfig, cfg);\n    var queries = [];\n    function cleanup() {\n        queries = queries.filter(function(item) {\n            return item().status === \"pending\";\n        });\n    }\n    function query(payload, queryCallback, doneCallback) {\n        var query2 = sendQuery(config, payload, queryCallback, function(data, error) {\n            cleanup();\n            if (doneCallback) {\n                doneCallback(data, error);\n            }\n        });\n        queries.push(query2);\n        return query2;\n    }\n    function find(callback) {\n        return queries.find(function(value) {\n            return callback(value);\n        }) || null;\n    }\n    var instance = {\n        query: query,\n        find: find,\n        setIndex: function(index) {\n            config.index = index;\n        },\n        getIndex: function() {\n            return config.index;\n        },\n        cleanup: cleanup\n    };\n    return instance;\n}\nfunction emptyCallback$1() {}\nvar redundancyCache = /* @__PURE__ */ Object.create(null);\nfunction getRedundancyCache(provider) {\n    if (!redundancyCache[provider]) {\n        var config = getAPIConfig(provider);\n        if (!config) {\n            return;\n        }\n        var redundancy = initRedundancy(config);\n        var cachedReundancy = {\n            config: config,\n            redundancy: redundancy\n        };\n        redundancyCache[provider] = cachedReundancy;\n    }\n    return redundancyCache[provider];\n}\nfunction sendAPIQuery(target, query, callback) {\n    var redundancy;\n    var send;\n    if (typeof target === \"string\") {\n        var api = getAPIModule(target);\n        if (!api) {\n            callback(void 0, 424);\n            return emptyCallback$1;\n        }\n        send = api.send;\n        var cached = getRedundancyCache(target);\n        if (cached) {\n            redundancy = cached.redundancy;\n        }\n    } else {\n        var config = createAPIConfig(target);\n        if (config) {\n            redundancy = initRedundancy(config);\n            var moduleKey = target.resources ? target.resources[0] : \"\";\n            var api1 = getAPIModule(moduleKey);\n            if (api1) {\n                send = api1.send;\n            }\n        }\n    }\n    if (!redundancy || !send) {\n        callback(void 0, 424);\n        return emptyCallback$1;\n    }\n    return redundancy.query(query, send, callback)().abort;\n}\nvar browserCacheVersion = \"iconify2\";\nvar browserCachePrefix = \"iconify\";\nvar browserCacheCountKey = browserCachePrefix + \"-count\";\nvar browserCacheVersionKey = browserCachePrefix + \"-version\";\nvar browserStorageHour = 36e5;\nvar browserStorageCacheExpiration = 168;\nfunction getStoredItem(func, key) {\n    try {\n        return func.getItem(key);\n    } catch (err) {}\n}\nfunction setStoredItem(func, key, value) {\n    try {\n        func.setItem(key, value);\n        return true;\n    } catch (err) {}\n}\nfunction removeStoredItem(func, key) {\n    try {\n        func.removeItem(key);\n    } catch (err) {}\n}\nfunction setBrowserStorageItemsCount(storage, value) {\n    return setStoredItem(storage, browserCacheCountKey, value.toString());\n}\nfunction getBrowserStorageItemsCount(storage) {\n    return parseInt(getStoredItem(storage, browserCacheCountKey)) || 0;\n}\nvar browserStorageConfig = {\n    local: true,\n    session: true\n};\nvar browserStorageEmptyItems = {\n    local: /* @__PURE__ */ new Set(),\n    session: /* @__PURE__ */ new Set()\n};\nvar browserStorageStatus = false;\nfunction setBrowserStorageStatus(status) {\n    browserStorageStatus = status;\n}\nvar _window = typeof window === \"undefined\" ? {} : window;\nfunction getBrowserStorage(key) {\n    var attr = key + \"Storage\";\n    try {\n        if (_window && _window[attr] && typeof _window[attr].length === \"number\") {\n            return _window[attr];\n        }\n    } catch (err) {}\n    browserStorageConfig[key] = false;\n}\nfunction iterateBrowserStorage(key, callback) {\n    var func = getBrowserStorage(key);\n    if (!func) {\n        return;\n    }\n    var version = getStoredItem(func, browserCacheVersionKey);\n    if (version !== browserCacheVersion) {\n        if (version) {\n            var total2 = getBrowserStorageItemsCount(func);\n            for(var i = 0; i < total2; i++){\n                removeStoredItem(func, browserCachePrefix + i.toString());\n            }\n        }\n        setStoredItem(func, browserCacheVersionKey, browserCacheVersion);\n        setBrowserStorageItemsCount(func, 0);\n        return;\n    }\n    var minTime = Math.floor(Date.now() / browserStorageHour) - browserStorageCacheExpiration;\n    var parseItem = function(index) {\n        var name = browserCachePrefix + index.toString();\n        var item = getStoredItem(func, name);\n        if (typeof item !== \"string\") {\n            return;\n        }\n        try {\n            var data = JSON.parse(item);\n            if (typeof data === \"object\" && typeof data.cached === \"number\" && data.cached > minTime && typeof data.provider === \"string\" && typeof data.data === \"object\" && typeof data.data.prefix === \"string\" && // Valid item: run callback\n            callback(data, index)) {\n                return true;\n            }\n        } catch (err) {}\n        removeStoredItem(func, name);\n    };\n    var total = getBrowserStorageItemsCount(func);\n    for(var i1 = total - 1; i1 >= 0; i1--){\n        if (!parseItem(i1)) {\n            if (i1 === total - 1) {\n                total--;\n                setBrowserStorageItemsCount(func, total);\n            } else {\n                browserStorageEmptyItems[key].add(i1);\n            }\n        }\n    }\n}\nfunction initBrowserStorage() {\n    if (browserStorageStatus) {\n        return;\n    }\n    setBrowserStorageStatus(true);\n    for(var key in browserStorageConfig){\n        iterateBrowserStorage(key, function(item) {\n            var iconSet = item.data;\n            var provider = item.provider;\n            var prefix = iconSet.prefix;\n            var storage = getStorage(provider, prefix);\n            if (!addIconSet(storage, iconSet).length) {\n                return false;\n            }\n            var lastModified = iconSet.lastModified || -1;\n            storage.lastModifiedCached = storage.lastModifiedCached ? Math.min(storage.lastModifiedCached, lastModified) : lastModified;\n            return true;\n        });\n    }\n}\nfunction updateLastModified(storage, lastModified) {\n    var lastValue = storage.lastModifiedCached;\n    if (// Matches or newer\n    lastValue && lastValue >= lastModified) {\n        return lastValue === lastModified;\n    }\n    storage.lastModifiedCached = lastModified;\n    if (lastValue) {\n        for(var key in browserStorageConfig){\n            iterateBrowserStorage(key, function(item) {\n                var iconSet = item.data;\n                return item.provider !== storage.provider || iconSet.prefix !== storage.prefix || iconSet.lastModified === lastModified;\n            });\n        }\n    }\n    return true;\n}\nfunction storeInBrowserStorage(storage, data) {\n    if (!browserStorageStatus) {\n        initBrowserStorage();\n    }\n    function store(key) {\n        var func;\n        if (!browserStorageConfig[key] || !(func = getBrowserStorage(key))) {\n            return;\n        }\n        var set = browserStorageEmptyItems[key];\n        var index;\n        if (set.size) {\n            set[\"delete\"](index = Array.from(set).shift());\n        } else {\n            index = getBrowserStorageItemsCount(func);\n            if (!setBrowserStorageItemsCount(func, index + 1)) {\n                return;\n            }\n        }\n        var item = {\n            cached: Math.floor(Date.now() / browserStorageHour),\n            provider: storage.provider,\n            data: data\n        };\n        return setStoredItem(func, browserCachePrefix + index.toString(), JSON.stringify(item));\n    }\n    if (data.lastModified && !updateLastModified(storage, data.lastModified)) {\n        return;\n    }\n    if (!Object.keys(data.icons).length) {\n        return;\n    }\n    if (data.not_found) {\n        data = Object.assign({}, data);\n        delete data.not_found;\n    }\n    if (!store(\"local\")) {\n        store(\"session\");\n    }\n}\nfunction emptyCallback() {}\nfunction loadedNewIcons(storage) {\n    if (!storage.iconsLoaderFlag) {\n        storage.iconsLoaderFlag = true;\n        setTimeout(function() {\n            storage.iconsLoaderFlag = false;\n            updateCallbacks(storage);\n        });\n    }\n}\nfunction loadNewIcons(storage, icons) {\n    if (!storage.iconsToLoad) {\n        storage.iconsToLoad = icons;\n    } else {\n        storage.iconsToLoad = storage.iconsToLoad.concat(icons).sort();\n    }\n    if (!storage.iconsQueueFlag) {\n        storage.iconsQueueFlag = true;\n        setTimeout(function() {\n            storage.iconsQueueFlag = false;\n            var provider = storage.provider, prefix = storage.prefix;\n            var icons2 = storage.iconsToLoad;\n            delete storage.iconsToLoad;\n            var api;\n            if (!icons2 || !(api = getAPIModule(provider))) {\n                return;\n            }\n            var params = api.prepare(provider, prefix, icons2);\n            params.forEach(function(item) {\n                sendAPIQuery(provider, item, function(data) {\n                    if (typeof data !== \"object\") {\n                        item.icons.forEach(function(name) {\n                            storage.missing.add(name);\n                        });\n                    } else {\n                        try {\n                            var parsed = addIconSet(storage, data);\n                            if (!parsed.length) {\n                                return;\n                            }\n                            var pending = storage.pendingIcons;\n                            if (pending) {\n                                parsed.forEach(function(name) {\n                                    pending[\"delete\"](name);\n                                });\n                            }\n                            storeInBrowserStorage(storage, data);\n                        } catch (err) {\n                            console.error(err);\n                        }\n                    }\n                    loadedNewIcons(storage);\n                });\n            });\n        });\n    }\n}\nvar loadIcons = function(icons, callback) {\n    var cleanedIcons = listToIcons(icons, true, allowSimpleNames());\n    var sortedIcons = sortIcons(cleanedIcons);\n    if (!sortedIcons.pending.length) {\n        var callCallback = true;\n        if (callback) {\n            setTimeout(function() {\n                if (callCallback) {\n                    callback(sortedIcons.loaded, sortedIcons.missing, sortedIcons.pending, emptyCallback);\n                }\n            });\n        }\n        return function() {\n            callCallback = false;\n        };\n    }\n    var newIcons = /* @__PURE__ */ Object.create(null);\n    var sources = [];\n    var lastProvider, lastPrefix;\n    sortedIcons.pending.forEach(function(icon) {\n        var provider = icon.provider, prefix = icon.prefix;\n        if (prefix === lastPrefix && provider === lastProvider) {\n            return;\n        }\n        lastProvider = provider;\n        lastPrefix = prefix;\n        sources.push(getStorage(provider, prefix));\n        var providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */ Object.create(null));\n        if (!providerNewIcons[prefix]) {\n            providerNewIcons[prefix] = [];\n        }\n    });\n    sortedIcons.pending.forEach(function(icon) {\n        var provider = icon.provider, prefix = icon.prefix, name = icon.name;\n        var storage = getStorage(provider, prefix);\n        var pendingQueue = storage.pendingIcons || (storage.pendingIcons = /* @__PURE__ */ new Set());\n        if (!pendingQueue.has(name)) {\n            pendingQueue.add(name);\n            newIcons[provider][prefix].push(name);\n        }\n    });\n    sources.forEach(function(storage) {\n        var provider = storage.provider, prefix = storage.prefix;\n        if (newIcons[provider][prefix].length) {\n            loadNewIcons(storage, newIcons[provider][prefix]);\n        }\n    });\n    return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;\n};\nvar loadIcon = function(icon) {\n    return new Promise(function(fulfill, reject) {\n        var iconObj = typeof icon === \"string\" ? stringToIcon(icon, true) : icon;\n        if (!iconObj) {\n            reject(icon);\n            return;\n        }\n        loadIcons([\n            iconObj || icon\n        ], function(loaded) {\n            if (loaded.length && iconObj) {\n                var data = getIconData(iconObj);\n                if (data) {\n                    fulfill(_object_spread._({}, defaultIconProps, data));\n                    return;\n                }\n            }\n            reject(icon);\n        });\n    });\n};\nfunction toggleBrowserCache(storage, value) {\n    switch(storage){\n        case \"local\":\n        case \"session\":\n            browserStorageConfig[storage] = value;\n            break;\n        case \"all\":\n            for(var key in browserStorageConfig){\n                browserStorageConfig[key] = value;\n            }\n            break;\n    }\n}\nfunction mergeCustomisations(defaults, item) {\n    var result = _object_spread._({}, defaults);\n    for(var key in item){\n        var value = item[key];\n        var valueType = typeof value === \"undefined\" ? \"undefined\" : _type_of._(value);\n        if (key in defaultIconSizeCustomisations) {\n            if (value === null || value && (valueType === \"string\" || valueType === \"number\")) {\n                result[key] = value;\n            }\n        } else if (valueType === _type_of._(result[key])) {\n            result[key] = key === \"rotate\" ? value % 4 : value;\n        }\n    }\n    return result;\n}\nvar separator = /[\\s,]+/;\nfunction flipFromString(custom, flip) {\n    flip.split(separator).forEach(function(str) {\n        var value = str.trim();\n        switch(value){\n            case \"horizontal\":\n                custom.hFlip = true;\n                break;\n            case \"vertical\":\n                custom.vFlip = true;\n                break;\n        }\n    });\n}\nfunction rotateFromString(value) {\n    var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    var units = value.replace(/^-?[0-9.]*/, \"\");\n    function cleanup(value2) {\n        while(value2 < 0){\n            value2 += 4;\n        }\n        return value2 % 4;\n    }\n    if (units === \"\") {\n        var num = parseInt(value);\n        return isNaN(num) ? 0 : cleanup(num);\n    } else if (units !== value) {\n        var split = 0;\n        switch(units){\n            case \"%\":\n                split = 25;\n                break;\n            case \"deg\":\n                split = 90;\n        }\n        if (split) {\n            var num1 = parseFloat(value.slice(0, value.length - units.length));\n            if (isNaN(num1)) {\n                return 0;\n            }\n            num1 = num1 / split;\n            return num1 % 1 === 0 ? cleanup(num1) : 0;\n        }\n    }\n    return defaultValue;\n}\nfunction iconToHTML(body, attributes) {\n    var renderAttribsHTML = body.indexOf(\"xlink:\") === -1 ? \"\" : ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n    for(var attr in attributes){\n        renderAttribsHTML += \" \" + attr + '=\"' + attributes[attr] + '\"';\n    }\n    return '<svg xmlns=\"http://www.w3.org/2000/svg\"' + renderAttribsHTML + \">\" + body + \"</svg>\";\n}\nfunction encodeSVGforURL(svg) {\n    return svg.replace(/\"/g, \"'\").replace(/%/g, \"%25\").replace(/#/g, \"%23\").replace(/</g, \"%3C\").replace(/>/g, \"%3E\").replace(/\\s+/g, \" \");\n}\nfunction svgToData(svg) {\n    return \"data:image/svg+xml,\" + encodeSVGforURL(svg);\n}\nfunction svgToURL(svg) {\n    return 'url(\"' + svgToData(svg) + '\")';\n}\nvar policy;\nfunction createPolicy() {\n    try {\n        policy = window.trustedTypes.createPolicy(\"iconify\", {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            createHTML: function(s) {\n                return s;\n            }\n        });\n    } catch (err) {\n        policy = null;\n    }\n}\nfunction cleanUpInnerHTML(html) {\n    if (policy === void 0) {\n        createPolicy();\n    }\n    return policy ? policy.createHTML(html) : html;\n}\nvar defaultExtendedIconCustomisations = _object_spread_props._(_object_spread._({}, defaultIconCustomisations), {\n    inline: false\n});\n/**\n * Default SVG attributes\n */ var svgDefaults = {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    xmlnsXlink: \"http://www.w3.org/1999/xlink\",\n    \"aria-hidden\": true,\n    role: \"img\"\n};\n/**\n * Style modes\n */ var commonProps = {\n    display: \"inline-block\"\n};\nvar monotoneProps = {\n    backgroundColor: \"currentColor\"\n};\nvar coloredProps = {\n    backgroundColor: \"transparent\"\n};\n// Dynamically add common props to variables above\nvar propsToAdd = {\n    Image: \"var(--svg)\",\n    Repeat: \"no-repeat\",\n    Size: \"100% 100%\"\n};\nvar propsToAddTo = {\n    WebkitMask: monotoneProps,\n    mask: monotoneProps,\n    background: coloredProps\n};\nfor(var prefix in propsToAddTo){\n    var list = propsToAddTo[prefix];\n    for(var prop in propsToAdd){\n        list[prefix + prop] = propsToAdd[prop];\n    }\n}\n/**\n * Default values for customisations for inline icon\n */ var inlineDefaults = _object_spread_props._(_object_spread._({}, defaultExtendedIconCustomisations), {\n    inline: true\n});\n/**\n * Fix size: add 'px' to numbers\n */ function fixSize(value) {\n    return value + (value.match(/^[-0-9.]+$/) ? \"px\" : \"\");\n}\n/**\n * Render icon\n */ var render = function(// Icon must be validated before calling this function\nicon, // Partial properties\nprops, // True if icon should have vertical-align added\ninline, // Optional reference for SVG/SPAN, extracted by React.forwardRef()\nref) {\n    // Get default properties\n    var defaultProps = inline ? inlineDefaults : defaultExtendedIconCustomisations;\n    // Get all customisations\n    var customisations = mergeCustomisations(defaultProps, props);\n    // Check mode\n    var mode = props.mode || \"svg\";\n    // Create style\n    var style = {};\n    var customStyle = props.style || {};\n    // Create SVG component properties\n    var componentProps = _object_spread_props._(_object_spread._({}, mode === \"svg\" ? svgDefaults : {}), {\n        ref: ref\n    });\n    // Get element properties\n    for(var key in props){\n        var value = props[key];\n        if (value === void 0) {\n            continue;\n        }\n        switch(key){\n            // Properties to ignore\n            case \"icon\":\n            case \"style\":\n            case \"children\":\n            case \"onLoad\":\n            case \"mode\":\n            case \"_ref\":\n            case \"_inline\":\n                break;\n            // Boolean attributes\n            case \"inline\":\n            case \"hFlip\":\n            case \"vFlip\":\n                customisations[key] = value === true || value === \"true\" || value === 1;\n                break;\n            // Flip as string: 'horizontal,vertical'\n            case \"flip\":\n                if (typeof value === \"string\") {\n                    flipFromString(customisations, value);\n                }\n                break;\n            // Color: copy to style\n            case \"color\":\n                style.color = value;\n                break;\n            // Rotation as string\n            case \"rotate\":\n                if (typeof value === \"string\") {\n                    customisations[key] = rotateFromString(value);\n                } else if (typeof value === \"number\") {\n                    customisations[key] = value;\n                }\n                break;\n            // Remove aria-hidden\n            case \"ariaHidden\":\n            case \"aria-hidden\":\n                if (value !== true && value !== \"true\") {\n                    delete componentProps[\"aria-hidden\"];\n                }\n                break;\n            // Copy missing property if it does not exist in customisations\n            default:\n                if (defaultProps[key] === void 0) {\n                    componentProps[key] = value;\n                }\n        }\n    }\n    // Generate icon\n    var item = iconToSVG(icon, customisations);\n    var renderAttribs = item.attributes;\n    // Inline display\n    if (customisations.inline) {\n        style.verticalAlign = \"-0.125em\";\n    }\n    if (mode === \"svg\") {\n        // Add style\n        componentProps.style = _object_spread._({}, style, customStyle);\n        // Add icon stuff\n        Object.assign(componentProps, renderAttribs);\n        // Counter for ids based on \"id\" property to render icons consistently on server and client\n        var localCounter = 0;\n        var id = props.id;\n        if (typeof id === \"string\") {\n            // Convert '-' to '_' to avoid errors in animations\n            id = id.replace(/-/g, \"_\");\n        }\n        // Add icon stuff\n        componentProps.dangerouslySetInnerHTML = {\n            __html: cleanUpInnerHTML(replaceIDs(item.body, id ? function() {\n                return id + \"ID\" + localCounter++;\n            } : \"iconifyReact\"))\n        };\n        return React.createElement(\"svg\", componentProps);\n    }\n    // Render <span> with style\n    var body = icon.body, width = icon.width, height = icon.height;\n    var useMask = mode === \"mask\" || (mode === \"bg\" ? false : body.indexOf(\"currentColor\") !== -1);\n    // Generate SVG\n    var html = iconToHTML(body, _object_spread_props._(_object_spread._({}, renderAttribs), {\n        width: width + \"\",\n        height: height + \"\"\n    }));\n    // Generate style\n    componentProps.style = _object_spread._(_object_spread_props._(_object_spread._({}, style), {\n        \"--svg\": svgToURL(html),\n        width: fixSize(renderAttribs.width),\n        height: fixSize(renderAttribs.height)\n    }), commonProps, useMask ? monotoneProps : coloredProps, customStyle);\n    return React.createElement(\"span\", componentProps);\n};\n/**\n * Enable cache\n */ function enableCache(storage) {\n    toggleBrowserCache(storage, true);\n}\n/**\n * Disable cache\n */ function disableCache(storage) {\n    toggleBrowserCache(storage, false);\n}\n/**\n * Initialise stuff\n */ // Enable short names\nallowSimpleNames(true);\n// Set API module\nsetAPIModule(\"\", fetchAPIModule);\n/**\n * Browser stuff\n */ if (typeof document !== \"undefined\" && typeof window !== \"undefined\") {\n    // Set cache and load existing cache\n    initBrowserStorage();\n    var _window1 = window;\n    // Load icons from global \"IconifyPreload\"\n    if (_window1.IconifyPreload !== void 0) {\n        var preload = _window1.IconifyPreload;\n        var err = \"Invalid IconifyPreload syntax.\";\n        if (typeof preload === \"object\" && preload !== null) {\n            (preload instanceof Array ? preload : [\n                preload\n            ]).forEach(function(item) {\n                try {\n                    if (// Check if item is an object and not null/array\n                    typeof item !== \"object\" || item === null || item instanceof Array || // Check for 'icons' and 'prefix'\n                    typeof item.icons !== \"object\" || typeof item.prefix !== \"string\" || // Add icon set\n                    !addCollection(item)) {\n                        console.error(err);\n                    }\n                } catch (e) {\n                    console.error(err);\n                }\n            });\n        }\n    }\n    // Set API from global \"IconifyProviders\"\n    if (_window1.IconifyProviders !== void 0) {\n        var providers = _window1.IconifyProviders;\n        if (typeof providers === \"object\" && providers !== null) {\n            for(var key in providers){\n                var err1 = \"IconifyProviders[\" + key + \"] is invalid.\";\n                try {\n                    var value = providers[key];\n                    if (typeof value !== \"object\" || !value || value.resources === void 0) {\n                        continue;\n                    }\n                    if (!addAPIProvider(key, value)) {\n                        console.error(err1);\n                    }\n                } catch (e) {\n                    console.error(err1);\n                }\n            }\n        }\n    }\n}\nvar IconComponent = /*#__PURE__*/ function(_React_Component) {\n    _inherits._(IconComponent, _React_Component);\n    var _super = _create_super._(IconComponent);\n    function IconComponent(props) {\n        _class_call_check._(this, IconComponent);\n        var _this;\n        _this = _super.call(this, props);\n        _this.state = {\n            // Render placeholder before component is mounted\n            icon: null\n        };\n        return _this;\n    }\n    _create_class._(IconComponent, [\n        {\n            /**\n     * Abort loading icon\n     */ key: \"_abortLoading\",\n            value: function _abortLoading() {\n                if (this._loading) {\n                    this._loading.abort();\n                    this._loading = null;\n                }\n            }\n        },\n        {\n            /**\n     * Update state\n     */ key: \"_setData\",\n            value: function _setData(icon) {\n                if (this.state.icon !== icon) {\n                    this.setState({\n                        icon: icon\n                    });\n                }\n            }\n        },\n        {\n            /**\n     * Check if icon should be loaded\n     */ key: \"_checkIcon\",\n            value: function _checkIcon(changed) {\n                var state = this.state;\n                var icon = this.props.icon;\n                // Icon is an object\n                if (typeof icon === \"object\" && icon !== null && typeof icon.body === \"string\") {\n                    // Stop loading\n                    this._icon = \"\";\n                    this._abortLoading();\n                    if (changed || state.icon === null) {\n                        // Set data if it was changed\n                        this._setData({\n                            data: icon\n                        });\n                    }\n                    return;\n                }\n                // Invalid icon?\n                var iconName;\n                if (typeof icon !== \"string\" || (iconName = stringToIcon(icon, false, true)) === null) {\n                    this._abortLoading();\n                    this._setData(null);\n                    return;\n                }\n                // Load icon\n                var data = getIconData(iconName);\n                if (!data) {\n                    // Icon data is not available\n                    if (!this._loading || this._loading.name !== icon) {\n                        // New icon to load\n                        this._abortLoading();\n                        this._icon = \"\";\n                        this._setData(null);\n                        if (data !== null) {\n                            // Icon was not loaded\n                            this._loading = {\n                                name: icon,\n                                abort: loadIcons([\n                                    iconName\n                                ], this._checkIcon.bind(this, false))\n                            };\n                        }\n                    }\n                    return;\n                }\n                // Icon data is available\n                if (this._icon !== icon || state.icon === null) {\n                    // New icon or icon has been loaded\n                    this._abortLoading();\n                    this._icon = icon;\n                    // Add classes\n                    var classes = [\n                        \"iconify\"\n                    ];\n                    if (iconName.prefix !== \"\") {\n                        classes.push(\"iconify--\" + iconName.prefix);\n                    }\n                    if (iconName.provider !== \"\") {\n                        classes.push(\"iconify--\" + iconName.provider);\n                    }\n                    // Set data\n                    this._setData({\n                        data: data,\n                        classes: classes\n                    });\n                    if (this.props.onLoad) {\n                        this.props.onLoad(icon);\n                    }\n                }\n            }\n        },\n        {\n            /**\n     * Component mounted\n     */ key: \"componentDidMount\",\n            value: function componentDidMount() {\n                this._checkIcon(false);\n            }\n        },\n        {\n            /**\n     * Component updated\n     */ key: \"componentDidUpdate\",\n            value: function componentDidUpdate(oldProps) {\n                if (oldProps.icon !== this.props.icon) {\n                    this._checkIcon(true);\n                }\n            }\n        },\n        {\n            /**\n     * Abort loading\n     */ key: \"componentWillUnmount\",\n            value: function componentWillUnmount() {\n                this._abortLoading();\n            }\n        },\n        {\n            /**\n     * Render\n     */ key: \"render\",\n            value: function render1() {\n                var props = this.props;\n                var icon = this.state.icon;\n                if (icon === null) {\n                    // Render placeholder\n                    return props.children ? props.children : React.createElement(\"span\", {});\n                }\n                // Add classes\n                var newProps = props;\n                if (icon.classes) {\n                    newProps = _object_spread_props._(_object_spread._({}, props), {\n                        className: (typeof props.className === \"string\" ? props.className + \" \" : \"\") + icon.classes.join(\" \")\n                    });\n                }\n                // Render icon\n                return render(_object_spread._({}, defaultIconProps, icon.data), newProps, props._inline, props._ref);\n            }\n        }\n    ]);\n    return IconComponent;\n}(React.Component);\n/**\n * Block icon\n *\n * @param props - Component properties\n */ var Icon = React.forwardRef(_c = function Icon(props, ref) {\n    var newProps = _object_spread_props._(_object_spread._({}, props), {\n        _ref: ref,\n        _inline: false\n    });\n    return React.createElement(IconComponent, newProps);\n});\n_c1 = Icon;\n/**\n * Inline icon (has negative verticalAlign that makes it behave like icon font)\n *\n * @param props - Component properties\n */ var InlineIcon = React.forwardRef(_c2 = function InlineIcon(props, ref) {\n    var newProps = _object_spread_props._(_object_spread._({}, props), {\n        _ref: ref,\n        _inline: true\n    });\n    return React.createElement(IconComponent, newProps);\n});\n_c3 = InlineIcon;\n/**\n * Internal API\n */ var _api = {\n    getAPIConfig: getAPIConfig,\n    setAPIModule: setAPIModule,\n    sendAPIQuery: sendAPIQuery,\n    setFetch: setFetch,\n    getFetch: getFetch,\n    listAPIProviders: listAPIProviders\n};\nexports.Icon = Icon;\nexports.InlineIcon = InlineIcon;\nexports._api = _api;\nexports.addAPIProvider = addAPIProvider;\nexports.addCollection = addCollection;\nexports.addIcon = addIcon;\nexports.buildIcon = iconToSVG;\nexports.calculateSize = calculateSize;\nexports.disableCache = disableCache;\nexports.enableCache = enableCache;\nexports.getIcon = getIcon;\nexports.iconExists = iconExists;\nexports.listIcons = listIcons;\nexports.loadIcon = loadIcon;\nexports.loadIcons = loadIcons;\nexports.replaceIDs = replaceIDs;\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"Icon$React.forwardRef\");\n$RefreshReg$(_c1, \"Icon\");\n$RefreshReg$(_c2, \"InlineIcon$React.forwardRef\");\n$RefreshReg$(_c3, \"InlineIcon\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AaWNvbmlmeStyZWFjdEA0LjEuMV9yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL0BpY29uaWZ5L3JlYWN0L2Rpc3QvaWNvbmlmeS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7QUFFQSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUVwQixJQUFNQyxnQkFBZ0I7QUFDdEIsSUFBTUMsZUFBZSxTQUFDQyxPQUFPQyxVQUFVQztRQUFpQkMsNEVBQVc7SUFDakUsSUFBTUMsaUJBQWlCSixNQUFNSyxLQUFLLENBQUM7SUFDbkMsSUFBSUwsTUFBTU0sS0FBSyxDQUFDLEdBQUcsT0FBTyxLQUFLO1FBQzdCLElBQUlGLGVBQWVHLE1BQU0sR0FBRyxLQUFLSCxlQUFlRyxNQUFNLEdBQUcsR0FBRztZQUMxRCxPQUFPO1FBQ1Q7UUFDQUosV0FBV0MsZUFBZUksS0FBSyxHQUFHRixLQUFLLENBQUM7SUFDMUM7SUFDQSxJQUFJRixlQUFlRyxNQUFNLEdBQUcsS0FBSyxDQUFDSCxlQUFlRyxNQUFNLEVBQUU7UUFDdkQsT0FBTztJQUNUO0lBQ0EsSUFBSUgsZUFBZUcsTUFBTSxHQUFHLEdBQUc7UUFDN0IsSUFBTUUsUUFBUUwsZUFBZU0sR0FBRztRQUNoQyxJQUFNQyxTQUFTUCxlQUFlTSxHQUFHO1FBQ2pDLElBQU1FLFNBQVM7WUFDYixxREFBcUQ7WUFDckRULFVBQVVDLGVBQWVHLE1BQU0sR0FBRyxJQUFJSCxjQUFjLENBQUMsRUFBRSxHQUFHRDtZQUMxRFEsUUFBQUE7WUFDQUUsTUFBTUo7UUFDUjtRQUNBLE9BQU9SLFlBQVksQ0FBQ2EsaUJBQWlCRixVQUFVLE9BQU9BO0lBQ3hEO0lBQ0EsSUFBTUMsT0FBT1QsY0FBYyxDQUFDLEVBQUU7SUFDOUIsSUFBTVcsZ0JBQWdCRixLQUFLUixLQUFLLENBQUM7SUFDakMsSUFBSVUsY0FBY1IsTUFBTSxHQUFHLEdBQUc7UUFDNUIsSUFBTUssVUFBUztZ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TUFBTXhDO1FBQ051QyxTQUFTOztJQUViLE9BQU9yYixNQUFNMFosYUFBYSxDQUFDUyxlQUFlZ0I7QUFDOUM7O0FBQ0E7Ozs7Q0FJQyxHQUNELElBQU1PLGFBQWExYixNQUFNeWIsVUFBVSxPQUFDLFNBQVNDLFdBQVc3VCxLQUFLLEVBQUVpUixHQUFHO0lBQzlELElBQU1xQyxXQUFXLDRDQUNWdFQ7UUFDSHlULE1BQU14QztRQUNOdUMsU0FBUzs7SUFFYixPQUFPcmIsTUFBTTBaLGFBQWEsQ0FBQ1MsZUFBZWdCO0FBQzlDOztBQUNBOztDQUVDLEdBQ0QsSUFBTVEsT0FBTztJQUNUalIsY0FBQUE7SUFDQWhCLGNBQUFBO0lBQ0F5SCxjQUFBQTtJQUNBcEcsVUFBQUE7SUFDQUUsVUFBQUE7SUFDQU4sa0JBQUFBO0FBQ0o7QUFFQWlSLFlBQVksR0FBR0o7QUFDZkksa0JBQWtCLEdBQUdGO0FBQ3JCRSxZQUFZLEdBQUdEO0FBQ2ZDLHNCQUFzQixHQUFHclI7QUFDekJxUixxQkFBcUIsR0FBRzNWO0FBQ3hCMlYsZUFBZSxHQUFHNVY7QUFDbEI0VixpQkFBaUIsR0FBR3BVO0FBQ3BCb1UscUJBQXFCLEdBQUduVjtBQUN4Qm1WLG9CQUFvQixHQUFHL0I7QUFDdkIrQixtQkFBbUIsR0FBR2hDO0FBQ3RCZ0MsZUFBZSxHQUFHeFY7QUFDbEJ3VixrQkFBa0IsR0FBR3pWO0FBQ3JCeVYsaUJBQWlCLEdBQUd6VztBQUNwQnlXLGdCQUFnQixHQUFHaEc7QUFDbkJnRyxpQkFBaUIsR0FBRzFHO0FBQ3BCMEcsa0JBQWtCLEdBQUczUyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQGljb25pZnkrcmVhY3RANC4xLjFfcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9AaWNvbmlmeS9yZWFjdC9kaXN0L2ljb25pZnkuanM/MWQyMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmNvbnN0IG1hdGNoSWNvbk5hbWUgPSAvXlthLXowLTldKygtW2EtejAtOV0rKSokLztcbmNvbnN0IHN0cmluZ1RvSWNvbiA9ICh2YWx1ZSwgdmFsaWRhdGUsIGFsbG93U2ltcGxlTmFtZSwgcHJvdmlkZXIgPSBcIlwiKSA9PiB7XG4gIGNvbnN0IGNvbG9uU2VwYXJhdGVkID0gdmFsdWUuc3BsaXQoXCI6XCIpO1xuICBpZiAodmFsdWUuc2xpY2UoMCwgMSkgPT09IFwiQFwiKSB7XG4gICAgaWYgKGNvbG9uU2VwYXJhdGVkLmxlbmd0aCA8IDIgfHwgY29sb25TZXBhcmF0ZWQubGVuZ3RoID4gMykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHByb3ZpZGVyID0gY29sb25TZXBhcmF0ZWQuc2hpZnQoKS5zbGljZSgxKTtcbiAgfVxuICBpZiAoY29sb25TZXBhcmF0ZWQubGVuZ3RoID4gMyB8fCAhY29sb25TZXBhcmF0ZWQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGNvbG9uU2VwYXJhdGVkLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBuYW1lMiA9IGNvbG9uU2VwYXJhdGVkLnBvcCgpO1xuICAgIGNvbnN0IHByZWZpeCA9IGNvbG9uU2VwYXJhdGVkLnBvcCgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIC8vIEFsbG93IHByb3ZpZGVyIHdpdGhvdXQgJ0AnOiBcInByb3ZpZGVyOnByZWZpeDpuYW1lXCJcbiAgICAgIHByb3ZpZGVyOiBjb2xvblNlcGFyYXRlZC5sZW5ndGggPiAwID8gY29sb25TZXBhcmF0ZWRbMF0gOiBwcm92aWRlcixcbiAgICAgIHByZWZpeCxcbiAgICAgIG5hbWU6IG5hbWUyXG4gICAgfTtcbiAgICByZXR1cm4gdmFsaWRhdGUgJiYgIXZhbGlkYXRlSWNvbk5hbWUocmVzdWx0KSA/IG51bGwgOiByZXN1bHQ7XG4gIH1cbiAgY29uc3QgbmFtZSA9IGNvbG9uU2VwYXJhdGVkWzBdO1xuICBjb25zdCBkYXNoU2VwYXJhdGVkID0gbmFtZS5zcGxpdChcIi1cIik7XG4gIGlmIChkYXNoU2VwYXJhdGVkLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBwcm92aWRlcixcbiAgICAgIHByZWZpeDogZGFzaFNlcGFyYXRlZC5zaGlmdCgpLFxuICAgICAgbmFtZTogZGFzaFNlcGFyYXRlZC5qb2luKFwiLVwiKVxuICAgIH07XG4gICAgcmV0dXJuIHZhbGlkYXRlICYmICF2YWxpZGF0ZUljb25OYW1lKHJlc3VsdCkgPyBudWxsIDogcmVzdWx0O1xuICB9XG4gIGlmIChhbGxvd1NpbXBsZU5hbWUgJiYgcHJvdmlkZXIgPT09IFwiXCIpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBwcm92aWRlcixcbiAgICAgIHByZWZpeDogXCJcIixcbiAgICAgIG5hbWVcbiAgICB9O1xuICAgIHJldHVybiB2YWxpZGF0ZSAmJiAhdmFsaWRhdGVJY29uTmFtZShyZXN1bHQsIGFsbG93U2ltcGxlTmFtZSkgPyBudWxsIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbmNvbnN0IHZhbGlkYXRlSWNvbk5hbWUgPSAoaWNvbiwgYWxsb3dTaW1wbGVOYW1lKSA9PiB7XG4gIGlmICghaWNvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gISEoKGljb24ucHJvdmlkZXIgPT09IFwiXCIgfHwgaWNvbi5wcm92aWRlci5tYXRjaChtYXRjaEljb25OYW1lKSkgJiYgKGFsbG93U2ltcGxlTmFtZSAmJiBpY29uLnByZWZpeCA9PT0gXCJcIiB8fCBpY29uLnByZWZpeC5tYXRjaChtYXRjaEljb25OYW1lKSkgJiYgaWNvbi5uYW1lLm1hdGNoKG1hdGNoSWNvbk5hbWUpKTtcbn07XG5cbmNvbnN0IGRlZmF1bHRJY29uRGltZW5zaW9ucyA9IE9iamVjdC5mcmVlemUoXG4gIHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbiAgICB3aWR0aDogMTYsXG4gICAgaGVpZ2h0OiAxNlxuICB9XG4pO1xuY29uc3QgZGVmYXVsdEljb25UcmFuc2Zvcm1hdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgcm90YXRlOiAwLFxuICB2RmxpcDogZmFsc2UsXG4gIGhGbGlwOiBmYWxzZVxufSk7XG5jb25zdCBkZWZhdWx0SWNvblByb3BzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIC4uLmRlZmF1bHRJY29uRGltZW5zaW9ucyxcbiAgLi4uZGVmYXVsdEljb25UcmFuc2Zvcm1hdGlvbnNcbn0pO1xuY29uc3QgZGVmYXVsdEV4dGVuZGVkSWNvblByb3BzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIC4uLmRlZmF1bHRJY29uUHJvcHMsXG4gIGJvZHk6IFwiXCIsXG4gIGhpZGRlbjogZmFsc2Vcbn0pO1xuXG5mdW5jdGlvbiBtZXJnZUljb25UcmFuc2Zvcm1hdGlvbnMob2JqMSwgb2JqMikge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgaWYgKCFvYmoxLmhGbGlwICE9PSAhb2JqMi5oRmxpcCkge1xuICAgIHJlc3VsdC5oRmxpcCA9IHRydWU7XG4gIH1cbiAgaWYgKCFvYmoxLnZGbGlwICE9PSAhb2JqMi52RmxpcCkge1xuICAgIHJlc3VsdC52RmxpcCA9IHRydWU7XG4gIH1cbiAgY29uc3Qgcm90YXRlID0gKChvYmoxLnJvdGF0ZSB8fCAwKSArIChvYmoyLnJvdGF0ZSB8fCAwKSkgJSA0O1xuICBpZiAocm90YXRlKSB7XG4gICAgcmVzdWx0LnJvdGF0ZSA9IHJvdGF0ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtZXJnZUljb25EYXRhKHBhcmVudCwgY2hpbGQpIHtcbiAgY29uc3QgcmVzdWx0ID0gbWVyZ2VJY29uVHJhbnNmb3JtYXRpb25zKHBhcmVudCwgY2hpbGQpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0RXh0ZW5kZWRJY29uUHJvcHMpIHtcbiAgICBpZiAoa2V5IGluIGRlZmF1bHRJY29uVHJhbnNmb3JtYXRpb25zKSB7XG4gICAgICBpZiAoa2V5IGluIHBhcmVudCAmJiAhKGtleSBpbiByZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gZGVmYXVsdEljb25UcmFuc2Zvcm1hdGlvbnNba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSBpbiBjaGlsZCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBjaGlsZFtrZXldO1xuICAgIH0gZWxzZSBpZiAoa2V5IGluIHBhcmVudCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBwYXJlbnRba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0SWNvbnNUcmVlKGRhdGEsIG5hbWVzKSB7XG4gIGNvbnN0IGljb25zID0gZGF0YS5pY29ucztcbiAgY29uc3QgYWxpYXNlcyA9IGRhdGEuYWxpYXNlcyB8fCAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgcmVzb2x2ZWQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZnVuY3Rpb24gcmVzb2x2ZShuYW1lKSB7XG4gICAgaWYgKGljb25zW25hbWVdKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRbbmFtZV0gPSBbXTtcbiAgICB9XG4gICAgaWYgKCEobmFtZSBpbiByZXNvbHZlZCkpIHtcbiAgICAgIHJlc29sdmVkW25hbWVdID0gbnVsbDtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGFsaWFzZXNbbmFtZV0gJiYgYWxpYXNlc1tuYW1lXS5wYXJlbnQ7XG4gICAgICBjb25zdCB2YWx1ZSA9IHBhcmVudCAmJiByZXNvbHZlKHBhcmVudCk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZWRbbmFtZV0gPSBbcGFyZW50XS5jb25jYXQodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZWRbbmFtZV07XG4gIH1cbiAgKG5hbWVzIHx8IE9iamVjdC5rZXlzKGljb25zKS5jb25jYXQoT2JqZWN0LmtleXMoYWxpYXNlcykpKS5mb3JFYWNoKHJlc29sdmUpO1xuICByZXR1cm4gcmVzb2x2ZWQ7XG59XG5cbmZ1bmN0aW9uIGludGVybmFsR2V0SWNvbkRhdGEoZGF0YSwgbmFtZSwgdHJlZSkge1xuICBjb25zdCBpY29ucyA9IGRhdGEuaWNvbnM7XG4gIGNvbnN0IGFsaWFzZXMgPSBkYXRhLmFsaWFzZXMgfHwgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBjdXJyZW50UHJvcHMgPSB7fTtcbiAgZnVuY3Rpb24gcGFyc2UobmFtZTIpIHtcbiAgICBjdXJyZW50UHJvcHMgPSBtZXJnZUljb25EYXRhKFxuICAgICAgaWNvbnNbbmFtZTJdIHx8IGFsaWFzZXNbbmFtZTJdLFxuICAgICAgY3VycmVudFByb3BzXG4gICAgKTtcbiAgfVxuICBwYXJzZShuYW1lKTtcbiAgdHJlZS5mb3JFYWNoKHBhcnNlKTtcbiAgcmV0dXJuIG1lcmdlSWNvbkRhdGEoZGF0YSwgY3VycmVudFByb3BzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VJY29uU2V0KGRhdGEsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IG5hbWVzID0gW107XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZGF0YS5pY29ucyAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBuYW1lcztcbiAgfVxuICBpZiAoZGF0YS5ub3RfZm91bmQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGRhdGEubm90X2ZvdW5kLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIGNhbGxiYWNrKG5hbWUsIG51bGwpO1xuICAgICAgbmFtZXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCB0cmVlID0gZ2V0SWNvbnNUcmVlKGRhdGEpO1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gdHJlZSkge1xuICAgIGNvbnN0IGl0ZW0gPSB0cmVlW25hbWVdO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBjYWxsYmFjayhuYW1lLCBpbnRlcm5hbEdldEljb25EYXRhKGRhdGEsIG5hbWUsIGl0ZW0pKTtcbiAgICAgIG5hbWVzLnB1c2gobmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuYW1lcztcbn1cblxuY29uc3Qgb3B0aW9uYWxQcm9wZXJ0eURlZmF1bHRzID0ge1xuICBwcm92aWRlcjogXCJcIixcbiAgYWxpYXNlczoge30sXG4gIG5vdF9mb3VuZDoge30sXG4gIC4uLmRlZmF1bHRJY29uRGltZW5zaW9uc1xufTtcbmZ1bmN0aW9uIGNoZWNrT3B0aW9uYWxQcm9wcyhpdGVtLCBkZWZhdWx0cykge1xuICBmb3IgKGNvbnN0IHByb3AgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAocHJvcCBpbiBpdGVtICYmIHR5cGVvZiBpdGVtW3Byb3BdICE9PSB0eXBlb2YgZGVmYXVsdHNbcHJvcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBxdWlja2x5VmFsaWRhdGVJY29uU2V0KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBkYXRhID0gb2JqO1xuICBpZiAodHlwZW9mIGRhdGEucHJlZml4ICE9PSBcInN0cmluZ1wiIHx8ICFvYmouaWNvbnMgfHwgdHlwZW9mIG9iai5pY29ucyAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghY2hlY2tPcHRpb25hbFByb3BzKG9iaiwgb3B0aW9uYWxQcm9wZXJ0eURlZmF1bHRzKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGljb25zID0gZGF0YS5pY29ucztcbiAgZm9yIChjb25zdCBuYW1lIGluIGljb25zKSB7XG4gICAgY29uc3QgaWNvbiA9IGljb25zW25hbWVdO1xuICAgIGlmICghbmFtZS5tYXRjaChtYXRjaEljb25OYW1lKSB8fCB0eXBlb2YgaWNvbi5ib2R5ICE9PSBcInN0cmluZ1wiIHx8ICFjaGVja09wdGlvbmFsUHJvcHMoXG4gICAgICBpY29uLFxuICAgICAgZGVmYXVsdEV4dGVuZGVkSWNvblByb3BzXG4gICAgKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGNvbnN0IGFsaWFzZXMgPSBkYXRhLmFsaWFzZXMgfHwgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3QgbmFtZSBpbiBhbGlhc2VzKSB7XG4gICAgY29uc3QgaWNvbiA9IGFsaWFzZXNbbmFtZV07XG4gICAgY29uc3QgcGFyZW50ID0gaWNvbi5wYXJlbnQ7XG4gICAgaWYgKCFuYW1lLm1hdGNoKG1hdGNoSWNvbk5hbWUpIHx8IHR5cGVvZiBwYXJlbnQgIT09IFwic3RyaW5nXCIgfHwgIWljb25zW3BhcmVudF0gJiYgIWFsaWFzZXNbcGFyZW50XSB8fCAhY2hlY2tPcHRpb25hbFByb3BzKFxuICAgICAgaWNvbixcbiAgICAgIGRlZmF1bHRFeHRlbmRlZEljb25Qcm9wc1xuICAgICkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuY29uc3QgZGF0YVN0b3JhZ2UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIG5ld1N0b3JhZ2UocHJvdmlkZXIsIHByZWZpeCkge1xuICByZXR1cm4ge1xuICAgIHByb3ZpZGVyLFxuICAgIHByZWZpeCxcbiAgICBpY29uczogLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgbWlzc2luZzogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSB7XG4gIGNvbnN0IHByb3ZpZGVyU3RvcmFnZSA9IGRhdGFTdG9yYWdlW3Byb3ZpZGVyXSB8fCAoZGF0YVN0b3JhZ2VbcHJvdmlkZXJdID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICByZXR1cm4gcHJvdmlkZXJTdG9yYWdlW3ByZWZpeF0gfHwgKHByb3ZpZGVyU3RvcmFnZVtwcmVmaXhdID0gbmV3U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSk7XG59XG5mdW5jdGlvbiBhZGRJY29uU2V0KHN0b3JhZ2UsIGRhdGEpIHtcbiAgaWYgKCFxdWlja2x5VmFsaWRhdGVJY29uU2V0KGRhdGEpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBwYXJzZUljb25TZXQoZGF0YSwgKG5hbWUsIGljb24pID0+IHtcbiAgICBpZiAoaWNvbikge1xuICAgICAgc3RvcmFnZS5pY29uc1tuYW1lXSA9IGljb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3JhZ2UubWlzc2luZy5hZGQobmFtZSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZEljb25Ub1N0b3JhZ2Uoc3RvcmFnZSwgbmFtZSwgaWNvbikge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgaWNvbi5ib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBzdG9yYWdlLmljb25zW25hbWVdID0geyAuLi5pY29uIH07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGxpc3RJY29ucyhwcm92aWRlciwgcHJlZml4KSB7XG4gIGxldCBhbGxJY29ucyA9IFtdO1xuICBjb25zdCBwcm92aWRlcnMgPSB0eXBlb2YgcHJvdmlkZXIgPT09IFwic3RyaW5nXCIgPyBbcHJvdmlkZXJdIDogT2JqZWN0LmtleXMoZGF0YVN0b3JhZ2UpO1xuICBwcm92aWRlcnMuZm9yRWFjaCgocHJvdmlkZXIyKSA9PiB7XG4gICAgY29uc3QgcHJlZml4ZXMgPSB0eXBlb2YgcHJvdmlkZXIyID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwcmVmaXggPT09IFwic3RyaW5nXCIgPyBbcHJlZml4XSA6IE9iamVjdC5rZXlzKGRhdGFTdG9yYWdlW3Byb3ZpZGVyMl0gfHwge30pO1xuICAgIHByZWZpeGVzLmZvckVhY2goKHByZWZpeDIpID0+IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHByb3ZpZGVyMiwgcHJlZml4Mik7XG4gICAgICBhbGxJY29ucyA9IGFsbEljb25zLmNvbmNhdChcbiAgICAgICAgT2JqZWN0LmtleXMoc3RvcmFnZS5pY29ucykubWFwKFxuICAgICAgICAgIChuYW1lKSA9PiAocHJvdmlkZXIyICE9PSBcIlwiID8gXCJAXCIgKyBwcm92aWRlcjIgKyBcIjpcIiA6IFwiXCIpICsgcHJlZml4MiArIFwiOlwiICsgbmFtZVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGFsbEljb25zO1xufVxuXG5sZXQgc2ltcGxlTmFtZXMgPSBmYWxzZTtcbmZ1bmN0aW9uIGFsbG93U2ltcGxlTmFtZXMoYWxsb3cpIHtcbiAgaWYgKHR5cGVvZiBhbGxvdyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICBzaW1wbGVOYW1lcyA9IGFsbG93O1xuICB9XG4gIHJldHVybiBzaW1wbGVOYW1lcztcbn1cbmZ1bmN0aW9uIGdldEljb25EYXRhKG5hbWUpIHtcbiAgY29uc3QgaWNvbiA9IHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiID8gc3RyaW5nVG9JY29uKG5hbWUsIHRydWUsIHNpbXBsZU5hbWVzKSA6IG5hbWU7XG4gIGlmIChpY29uKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UoaWNvbi5wcm92aWRlciwgaWNvbi5wcmVmaXgpO1xuICAgIGNvbnN0IGljb25OYW1lID0gaWNvbi5uYW1lO1xuICAgIHJldHVybiBzdG9yYWdlLmljb25zW2ljb25OYW1lXSB8fCAoc3RvcmFnZS5taXNzaW5nLmhhcyhpY29uTmFtZSkgPyBudWxsIDogdm9pZCAwKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkSWNvbihuYW1lLCBkYXRhKSB7XG4gIGNvbnN0IGljb24gPSBzdHJpbmdUb0ljb24obmFtZSwgdHJ1ZSwgc2ltcGxlTmFtZXMpO1xuICBpZiAoIWljb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UoaWNvbi5wcm92aWRlciwgaWNvbi5wcmVmaXgpO1xuICByZXR1cm4gYWRkSWNvblRvU3RvcmFnZShzdG9yYWdlLCBpY29uLm5hbWUsIGRhdGEpO1xufVxuZnVuY3Rpb24gYWRkQ29sbGVjdGlvbihkYXRhLCBwcm92aWRlcikge1xuICBpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm92aWRlciAhPT0gXCJzdHJpbmdcIikge1xuICAgIHByb3ZpZGVyID0gZGF0YS5wcm92aWRlciB8fCBcIlwiO1xuICB9XG4gIGlmIChzaW1wbGVOYW1lcyAmJiAhcHJvdmlkZXIgJiYgIWRhdGEucHJlZml4KSB7XG4gICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgaWYgKHF1aWNrbHlWYWxpZGF0ZUljb25TZXQoZGF0YSkpIHtcbiAgICAgIGRhdGEucHJlZml4ID0gXCJcIjtcbiAgICAgIHBhcnNlSWNvblNldChkYXRhLCAobmFtZSwgaWNvbikgPT4ge1xuICAgICAgICBpZiAoaWNvbiAmJiBhZGRJY29uKG5hbWUsIGljb24pKSB7XG4gICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZGVkO1xuICB9XG4gIGNvbnN0IHByZWZpeCA9IGRhdGEucHJlZml4O1xuICBpZiAoIXZhbGlkYXRlSWNvbk5hbWUoe1xuICAgIHByb3ZpZGVyLFxuICAgIHByZWZpeCxcbiAgICBuYW1lOiBcImFcIlxuICB9KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzdG9yYWdlID0gZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KTtcbiAgcmV0dXJuICEhYWRkSWNvblNldChzdG9yYWdlLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIGljb25FeGlzdHMobmFtZSkge1xuICByZXR1cm4gISFnZXRJY29uRGF0YShuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldEljb24obmFtZSkge1xuICBjb25zdCByZXN1bHQgPSBnZXRJY29uRGF0YShuYW1lKTtcbiAgcmV0dXJuIHJlc3VsdCA/IHtcbiAgICAuLi5kZWZhdWx0SWNvblByb3BzLFxuICAgIC4uLnJlc3VsdFxuICB9IDogbnVsbDtcbn1cblxuY29uc3QgZGVmYXVsdEljb25TaXplQ3VzdG9taXNhdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgd2lkdGg6IG51bGwsXG4gIGhlaWdodDogbnVsbFxufSk7XG5jb25zdCBkZWZhdWx0SWNvbkN1c3RvbWlzYXRpb25zID0gT2JqZWN0LmZyZWV6ZSh7XG4gIC8vIERpbWVuc2lvbnNcbiAgLi4uZGVmYXVsdEljb25TaXplQ3VzdG9taXNhdGlvbnMsXG4gIC8vIFRyYW5zZm9ybWF0aW9uc1xuICAuLi5kZWZhdWx0SWNvblRyYW5zZm9ybWF0aW9uc1xufSk7XG5cbmNvbnN0IHVuaXRzU3BsaXQgPSAvKC0/WzAtOS5dKlswLTldK1swLTkuXSopL2c7XG5jb25zdCB1bml0c1Rlc3QgPSAvXi0/WzAtOS5dKlswLTldK1swLTkuXSokL2c7XG5mdW5jdGlvbiBjYWxjdWxhdGVTaXplKHNpemUsIHJhdGlvLCBwcmVjaXNpb24pIHtcbiAgaWYgKHJhdGlvID09PSAxKSB7XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cbiAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDEwMDtcbiAgaWYgKHR5cGVvZiBzaXplID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbChzaXplICogcmF0aW8gKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzaXplO1xuICB9XG4gIGNvbnN0IG9sZFBhcnRzID0gc2l6ZS5zcGxpdCh1bml0c1NwbGl0KTtcbiAgaWYgKG9sZFBhcnRzID09PSBudWxsIHx8ICFvbGRQYXJ0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICBjb25zdCBuZXdQYXJ0cyA9IFtdO1xuICBsZXQgY29kZSA9IG9sZFBhcnRzLnNoaWZ0KCk7XG4gIGxldCBpc051bWJlciA9IHVuaXRzVGVzdC50ZXN0KGNvZGUpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChpc051bWJlcikge1xuICAgICAgY29uc3QgbnVtID0gcGFyc2VGbG9hdChjb2RlKTtcbiAgICAgIGlmIChpc05hTihudW0pKSB7XG4gICAgICAgIG5ld1BhcnRzLnB1c2goY29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdQYXJ0cy5wdXNoKE1hdGguY2VpbChudW0gKiByYXRpbyAqIHByZWNpc2lvbikgLyBwcmVjaXNpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdQYXJ0cy5wdXNoKGNvZGUpO1xuICAgIH1cbiAgICBjb2RlID0gb2xkUGFydHMuc2hpZnQoKTtcbiAgICBpZiAoY29kZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbmV3UGFydHMuam9pbihcIlwiKTtcbiAgICB9XG4gICAgaXNOdW1iZXIgPSAhaXNOdW1iZXI7XG4gIH1cbn1cblxuY29uc3QgaXNVbnNldEtleXdvcmQgPSAodmFsdWUpID0+IHZhbHVlID09PSBcInVuc2V0XCIgfHwgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgdmFsdWUgPT09IFwibm9uZVwiO1xuZnVuY3Rpb24gaWNvblRvU1ZHKGljb24sIGN1c3RvbWlzYXRpb25zKSB7XG4gIGNvbnN0IGZ1bGxJY29uID0ge1xuICAgIC4uLmRlZmF1bHRJY29uUHJvcHMsXG4gICAgLi4uaWNvblxuICB9O1xuICBjb25zdCBmdWxsQ3VzdG9taXNhdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdEljb25DdXN0b21pc2F0aW9ucyxcbiAgICAuLi5jdXN0b21pc2F0aW9uc1xuICB9O1xuICBjb25zdCBib3ggPSB7XG4gICAgbGVmdDogZnVsbEljb24ubGVmdCxcbiAgICB0b3A6IGZ1bGxJY29uLnRvcCxcbiAgICB3aWR0aDogZnVsbEljb24ud2lkdGgsXG4gICAgaGVpZ2h0OiBmdWxsSWNvbi5oZWlnaHRcbiAgfTtcbiAgbGV0IGJvZHkgPSBmdWxsSWNvbi5ib2R5O1xuICBbZnVsbEljb24sIGZ1bGxDdXN0b21pc2F0aW9uc10uZm9yRWFjaCgocHJvcHMpID0+IHtcbiAgICBjb25zdCB0cmFuc2Zvcm1hdGlvbnMgPSBbXTtcbiAgICBjb25zdCBoRmxpcCA9IHByb3BzLmhGbGlwO1xuICAgIGNvbnN0IHZGbGlwID0gcHJvcHMudkZsaXA7XG4gICAgbGV0IHJvdGF0aW9uID0gcHJvcHMucm90YXRlO1xuICAgIGlmIChoRmxpcCkge1xuICAgICAgaWYgKHZGbGlwKSB7XG4gICAgICAgIHJvdGF0aW9uICs9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaChcbiAgICAgICAgICBcInRyYW5zbGF0ZShcIiArIChib3gud2lkdGggKyBib3gubGVmdCkudG9TdHJpbmcoKSArIFwiIFwiICsgKDAgLSBib3gudG9wKS50b1N0cmluZygpICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgdHJhbnNmb3JtYXRpb25zLnB1c2goXCJzY2FsZSgtMSAxKVwiKTtcbiAgICAgICAgYm94LnRvcCA9IGJveC5sZWZ0ID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZGbGlwKSB7XG4gICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaChcbiAgICAgICAgXCJ0cmFuc2xhdGUoXCIgKyAoMCAtIGJveC5sZWZ0KS50b1N0cmluZygpICsgXCIgXCIgKyAoYm94LmhlaWdodCArIGJveC50b3ApLnRvU3RyaW5nKCkgKyBcIilcIlxuICAgICAgKTtcbiAgICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKFwic2NhbGUoMSAtMSlcIik7XG4gICAgICBib3gudG9wID0gYm94LmxlZnQgPSAwO1xuICAgIH1cbiAgICBsZXQgdGVtcFZhbHVlO1xuICAgIGlmIChyb3RhdGlvbiA8IDApIHtcbiAgICAgIHJvdGF0aW9uIC09IE1hdGguZmxvb3Iocm90YXRpb24gLyA0KSAqIDQ7XG4gICAgfVxuICAgIHJvdGF0aW9uID0gcm90YXRpb24gJSA0O1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdGVtcFZhbHVlID0gYm94LmhlaWdodCAvIDIgKyBib3gudG9wO1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbnMudW5zaGlmdChcbiAgICAgICAgICBcInJvdGF0ZSg5MCBcIiArIHRlbXBWYWx1ZS50b1N0cmluZygpICsgXCIgXCIgKyB0ZW1wVmFsdWUudG9TdHJpbmcoKSArIFwiKVwiXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB0cmFuc2Zvcm1hdGlvbnMudW5zaGlmdChcbiAgICAgICAgICBcInJvdGF0ZSgxODAgXCIgKyAoYm94LndpZHRoIC8gMiArIGJveC5sZWZ0KS50b1N0cmluZygpICsgXCIgXCIgKyAoYm94LmhlaWdodCAvIDIgKyBib3gudG9wKS50b1N0cmluZygpICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHRlbXBWYWx1ZSA9IGJveC53aWR0aCAvIDIgKyBib3gubGVmdDtcbiAgICAgICAgdHJhbnNmb3JtYXRpb25zLnVuc2hpZnQoXG4gICAgICAgICAgXCJyb3RhdGUoLTkwIFwiICsgdGVtcFZhbHVlLnRvU3RyaW5nKCkgKyBcIiBcIiArIHRlbXBWYWx1ZS50b1N0cmluZygpICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChyb3RhdGlvbiAlIDIgPT09IDEpIHtcbiAgICAgIGlmIChib3gubGVmdCAhPT0gYm94LnRvcCkge1xuICAgICAgICB0ZW1wVmFsdWUgPSBib3gubGVmdDtcbiAgICAgICAgYm94LmxlZnQgPSBib3gudG9wO1xuICAgICAgICBib3gudG9wID0gdGVtcFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGJveC53aWR0aCAhPT0gYm94LmhlaWdodCkge1xuICAgICAgICB0ZW1wVmFsdWUgPSBib3gud2lkdGg7XG4gICAgICAgIGJveC53aWR0aCA9IGJveC5oZWlnaHQ7XG4gICAgICAgIGJveC5oZWlnaHQgPSB0ZW1wVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICBib2R5ID0gJzxnIHRyYW5zZm9ybT1cIicgKyB0cmFuc2Zvcm1hdGlvbnMuam9pbihcIiBcIikgKyAnXCI+JyArIGJvZHkgKyBcIjwvZz5cIjtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBjdXN0b21pc2F0aW9uc1dpZHRoID0gZnVsbEN1c3RvbWlzYXRpb25zLndpZHRoO1xuICBjb25zdCBjdXN0b21pc2F0aW9uc0hlaWdodCA9IGZ1bGxDdXN0b21pc2F0aW9ucy5oZWlnaHQ7XG4gIGNvbnN0IGJveFdpZHRoID0gYm94LndpZHRoO1xuICBjb25zdCBib3hIZWlnaHQgPSBib3guaGVpZ2h0O1xuICBsZXQgd2lkdGg7XG4gIGxldCBoZWlnaHQ7XG4gIGlmIChjdXN0b21pc2F0aW9uc1dpZHRoID09PSBudWxsKSB7XG4gICAgaGVpZ2h0ID0gY3VzdG9taXNhdGlvbnNIZWlnaHQgPT09IG51bGwgPyBcIjFlbVwiIDogY3VzdG9taXNhdGlvbnNIZWlnaHQgPT09IFwiYXV0b1wiID8gYm94SGVpZ2h0IDogY3VzdG9taXNhdGlvbnNIZWlnaHQ7XG4gICAgd2lkdGggPSBjYWxjdWxhdGVTaXplKGhlaWdodCwgYm94V2lkdGggLyBib3hIZWlnaHQpO1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gY3VzdG9taXNhdGlvbnNXaWR0aCA9PT0gXCJhdXRvXCIgPyBib3hXaWR0aCA6IGN1c3RvbWlzYXRpb25zV2lkdGg7XG4gICAgaGVpZ2h0ID0gY3VzdG9taXNhdGlvbnNIZWlnaHQgPT09IG51bGwgPyBjYWxjdWxhdGVTaXplKHdpZHRoLCBib3hIZWlnaHQgLyBib3hXaWR0aCkgOiBjdXN0b21pc2F0aW9uc0hlaWdodCA9PT0gXCJhdXRvXCIgPyBib3hIZWlnaHQgOiBjdXN0b21pc2F0aW9uc0hlaWdodDtcbiAgfVxuICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gIGNvbnN0IHNldEF0dHIgPSAocHJvcCwgdmFsdWUpID0+IHtcbiAgICBpZiAoIWlzVW5zZXRLZXl3b3JkKHZhbHVlKSkge1xuICAgICAgYXR0cmlidXRlc1twcm9wXSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9O1xuICBzZXRBdHRyKFwid2lkdGhcIiwgd2lkdGgpO1xuICBzZXRBdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gIGF0dHJpYnV0ZXMudmlld0JveCA9IGJveC5sZWZ0LnRvU3RyaW5nKCkgKyBcIiBcIiArIGJveC50b3AudG9TdHJpbmcoKSArIFwiIFwiICsgYm94V2lkdGgudG9TdHJpbmcoKSArIFwiIFwiICsgYm94SGVpZ2h0LnRvU3RyaW5nKCk7XG4gIHJldHVybiB7XG4gICAgYXR0cmlidXRlcyxcbiAgICBib2R5XG4gIH07XG59XG5cbmNvbnN0IHJlZ2V4ID0gL1xcc2lkPVwiKFxcUyspXCIvZztcbmNvbnN0IHJhbmRvbVByZWZpeCA9IFwiSWNvbmlmeUlkXCIgKyBEYXRlLm5vdygpLnRvU3RyaW5nKDE2KSArIChNYXRoLnJhbmRvbSgpICogMTY3NzcyMTYgfCAwKS50b1N0cmluZygxNik7XG5sZXQgY291bnRlciA9IDA7XG5mdW5jdGlvbiByZXBsYWNlSURzKGJvZHksIHByZWZpeCA9IHJhbmRvbVByZWZpeCkge1xuICBjb25zdCBpZHMgPSBbXTtcbiAgbGV0IG1hdGNoO1xuICB3aGlsZSAobWF0Y2ggPSByZWdleC5leGVjKGJvZHkpKSB7XG4gICAgaWRzLnB1c2gobWF0Y2hbMV0pO1xuICB9XG4gIGlmICghaWRzLmxlbmd0aCkge1xuICAgIHJldHVybiBib2R5O1xuICB9XG4gIGNvbnN0IHN1ZmZpeCA9IFwic3VmZml4XCIgKyAoTWF0aC5yYW5kb20oKSAqIDE2Nzc3MjE2IHwgRGF0ZS5ub3coKSkudG9TdHJpbmcoMTYpO1xuICBpZHMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICBjb25zdCBuZXdJRCA9IHR5cGVvZiBwcmVmaXggPT09IFwiZnVuY3Rpb25cIiA/IHByZWZpeChpZCkgOiBwcmVmaXggKyAoY291bnRlcisrKS50b1N0cmluZygpO1xuICAgIGNvbnN0IGVzY2FwZWRJRCA9IGlkLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbiAgICBib2R5ID0gYm9keS5yZXBsYWNlKFxuICAgICAgLy8gQWxsb3dlZCBjaGFyYWN0ZXJzIGJlZm9yZSBpZDogWyM7XCJdXG4gICAgICAvLyBBbGxvd2VkIGNoYXJhY3RlcnMgYWZ0ZXIgaWQ6IFspXCJdLCAuW2Etel1cbiAgICAgIG5ldyBSZWdFeHAoJyhbIztcIl0pKCcgKyBlc2NhcGVkSUQgKyAnKShbXCIpXXxcXFxcLlthLXpdKScsIFwiZ1wiKSxcbiAgICAgIFwiJDFcIiArIG5ld0lEICsgc3VmZml4ICsgXCIkM1wiXG4gICAgKTtcbiAgfSk7XG4gIGJvZHkgPSBib2R5LnJlcGxhY2UobmV3IFJlZ0V4cChzdWZmaXgsIFwiZ1wiKSwgXCJcIik7XG4gIHJldHVybiBib2R5O1xufVxuXG5jb25zdCBzdG9yYWdlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBzZXRBUElNb2R1bGUocHJvdmlkZXIsIGl0ZW0pIHtcbiAgc3RvcmFnZVtwcm92aWRlcl0gPSBpdGVtO1xufVxuZnVuY3Rpb24gZ2V0QVBJTW9kdWxlKHByb3ZpZGVyKSB7XG4gIHJldHVybiBzdG9yYWdlW3Byb3ZpZGVyXSB8fCBzdG9yYWdlW1wiXCJdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBUElDb25maWcoc291cmNlKSB7XG4gIGxldCByZXNvdXJjZXM7XG4gIGlmICh0eXBlb2Ygc291cmNlLnJlc291cmNlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJlc291cmNlcyA9IFtzb3VyY2UucmVzb3VyY2VzXTtcbiAgfSBlbHNlIHtcbiAgICByZXNvdXJjZXMgPSBzb3VyY2UucmVzb3VyY2VzO1xuICAgIGlmICghKHJlc291cmNlcyBpbnN0YW5jZW9mIEFycmF5KSB8fCAhcmVzb3VyY2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAvLyBBUEkgaG9zdHNcbiAgICByZXNvdXJjZXMsXG4gICAgLy8gUm9vdCBwYXRoXG4gICAgcGF0aDogc291cmNlLnBhdGggfHwgXCIvXCIsXG4gICAgLy8gVVJMIGxlbmd0aCBsaW1pdFxuICAgIG1heFVSTDogc291cmNlLm1heFVSTCB8fCA1MDAsXG4gICAgLy8gVGltZW91dCBiZWZvcmUgbmV4dCBob3N0IGlzIHVzZWQuXG4gICAgcm90YXRlOiBzb3VyY2Uucm90YXRlIHx8IDc1MCxcbiAgICAvLyBUaW1lb3V0IGJlZm9yZSBmYWlsaW5nIHF1ZXJ5LlxuICAgIHRpbWVvdXQ6IHNvdXJjZS50aW1lb3V0IHx8IDVlMyxcbiAgICAvLyBSYW5kb21pc2UgZGVmYXVsdCBBUEkgZW5kIHBvaW50LlxuICAgIHJhbmRvbTogc291cmNlLnJhbmRvbSA9PT0gdHJ1ZSxcbiAgICAvLyBTdGFydCBpbmRleFxuICAgIGluZGV4OiBzb3VyY2UuaW5kZXggfHwgMCxcbiAgICAvLyBSZWNlaXZlIGRhdGEgYWZ0ZXIgdGltZSBvdXQgKHVzZWQgaWYgdGltZSBvdXQga2lja3MgaW4gZmlyc3QsIHRoZW4gQVBJIG1vZHVsZSBzZW5kcyBkYXRhIGFueXdheSkuXG4gICAgZGF0YUFmdGVyVGltZW91dDogc291cmNlLmRhdGFBZnRlclRpbWVvdXQgIT09IGZhbHNlXG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBjb25maWdTdG9yYWdlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBmYWxsQmFja0FQSVNvdXJjZXMgPSBbXG4gIFwiaHR0cHM6Ly9hcGkuc2ltcGxlc3ZnLmNvbVwiLFxuICBcImh0dHBzOi8vYXBpLnVuaXN2Zy5jb21cIlxuXTtcbmNvbnN0IGZhbGxCYWNrQVBJID0gW107XG53aGlsZSAoZmFsbEJhY2tBUElTb3VyY2VzLmxlbmd0aCA+IDApIHtcbiAgaWYgKGZhbGxCYWNrQVBJU291cmNlcy5sZW5ndGggPT09IDEpIHtcbiAgICBmYWxsQmFja0FQSS5wdXNoKGZhbGxCYWNrQVBJU291cmNlcy5zaGlmdCgpKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgZmFsbEJhY2tBUEkucHVzaChmYWxsQmFja0FQSVNvdXJjZXMuc2hpZnQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZhbGxCYWNrQVBJLnB1c2goZmFsbEJhY2tBUElTb3VyY2VzLnBvcCgpKTtcbiAgICB9XG4gIH1cbn1cbmNvbmZpZ1N0b3JhZ2VbXCJcIl0gPSBjcmVhdGVBUElDb25maWcoe1xuICByZXNvdXJjZXM6IFtcImh0dHBzOi8vYXBpLmljb25pZnkuZGVzaWduXCJdLmNvbmNhdChmYWxsQmFja0FQSSlcbn0pO1xuZnVuY3Rpb24gYWRkQVBJUHJvdmlkZXIocHJvdmlkZXIsIGN1c3RvbUNvbmZpZykge1xuICBjb25zdCBjb25maWcgPSBjcmVhdGVBUElDb25maWcoY3VzdG9tQ29uZmlnKTtcbiAgaWYgKGNvbmZpZyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25maWdTdG9yYWdlW3Byb3ZpZGVyXSA9IGNvbmZpZztcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRBUElDb25maWcocHJvdmlkZXIpIHtcbiAgcmV0dXJuIGNvbmZpZ1N0b3JhZ2VbcHJvdmlkZXJdO1xufVxuZnVuY3Rpb24gbGlzdEFQSVByb3ZpZGVycygpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbmZpZ1N0b3JhZ2UpO1xufVxuXG5jb25zdCBkZXRlY3RGZXRjaCA9ICgpID0+IHtcbiAgbGV0IGNhbGxiYWNrO1xuICB0cnkge1xuICAgIGNhbGxiYWNrID0gZmV0Y2g7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgfVxufTtcbmxldCBmZXRjaE1vZHVsZSA9IGRldGVjdEZldGNoKCk7XG5mdW5jdGlvbiBzZXRGZXRjaChmZXRjaDIpIHtcbiAgZmV0Y2hNb2R1bGUgPSBmZXRjaDI7XG59XG5mdW5jdGlvbiBnZXRGZXRjaCgpIHtcbiAgcmV0dXJuIGZldGNoTW9kdWxlO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlTWF4TGVuZ3RoKHByb3ZpZGVyLCBwcmVmaXgpIHtcbiAgY29uc3QgY29uZmlnID0gZ2V0QVBJQ29uZmlnKHByb3ZpZGVyKTtcbiAgaWYgKCFjb25maWcpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgcmVzdWx0O1xuICBpZiAoIWNvbmZpZy5tYXhVUkwpIHtcbiAgICByZXN1bHQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGxldCBtYXhIb3N0TGVuZ3RoID0gMDtcbiAgICBjb25maWcucmVzb3VyY2VzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IGhvc3QgPSBpdGVtO1xuICAgICAgbWF4SG9zdExlbmd0aCA9IE1hdGgubWF4KG1heEhvc3RMZW5ndGgsIGhvc3QubGVuZ3RoKTtcbiAgICB9KTtcbiAgICBjb25zdCB1cmwgPSBwcmVmaXggKyBcIi5qc29uP2ljb25zPVwiO1xuICAgIHJlc3VsdCA9IGNvbmZpZy5tYXhVUkwgLSBtYXhIb3N0TGVuZ3RoIC0gY29uZmlnLnBhdGgubGVuZ3RoIC0gdXJsLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2hvdWxkQWJvcnQoc3RhdHVzKSB7XG4gIHJldHVybiBzdGF0dXMgPT09IDQwNDtcbn1cbmNvbnN0IHByZXBhcmUgPSAocHJvdmlkZXIsIHByZWZpeCwgaWNvbnMpID0+IHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBjb25zdCBtYXhMZW5ndGggPSBjYWxjdWxhdGVNYXhMZW5ndGgocHJvdmlkZXIsIHByZWZpeCk7XG4gIGNvbnN0IHR5cGUgPSBcImljb25zXCI7XG4gIGxldCBpdGVtID0ge1xuICAgIHR5cGUsXG4gICAgcHJvdmlkZXIsXG4gICAgcHJlZml4LFxuICAgIGljb25zOiBbXVxuICB9O1xuICBsZXQgbGVuZ3RoID0gMDtcbiAgaWNvbnMuZm9yRWFjaCgobmFtZSwgaW5kZXgpID0+IHtcbiAgICBsZW5ndGggKz0gbmFtZS5sZW5ndGggKyAxO1xuICAgIGlmIChsZW5ndGggPj0gbWF4TGVuZ3RoICYmIGluZGV4ID4gMCkge1xuICAgICAgcmVzdWx0cy5wdXNoKGl0ZW0pO1xuICAgICAgaXRlbSA9IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgaWNvbnM6IFtdXG4gICAgICB9O1xuICAgICAgbGVuZ3RoID0gbmFtZS5sZW5ndGg7XG4gICAgfVxuICAgIGl0ZW0uaWNvbnMucHVzaChuYW1lKTtcbiAgfSk7XG4gIHJlc3VsdHMucHVzaChpdGVtKTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuZnVuY3Rpb24gZ2V0UGF0aChwcm92aWRlcikge1xuICBpZiAodHlwZW9mIHByb3ZpZGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgY29uZmlnID0gZ2V0QVBJQ29uZmlnKHByb3ZpZGVyKTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICByZXR1cm4gY29uZmlnLnBhdGg7XG4gICAgfVxuICB9XG4gIHJldHVybiBcIi9cIjtcbn1cbmNvbnN0IHNlbmQgPSAoaG9zdCwgcGFyYW1zLCBjYWxsYmFjaykgPT4ge1xuICBpZiAoIWZldGNoTW9kdWxlKSB7XG4gICAgY2FsbGJhY2soXCJhYm9ydFwiLCA0MjQpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgcGF0aCA9IGdldFBhdGgocGFyYW1zLnByb3ZpZGVyKTtcbiAgc3dpdGNoIChwYXJhbXMudHlwZSkge1xuICAgIGNhc2UgXCJpY29uc1wiOiB7XG4gICAgICBjb25zdCBwcmVmaXggPSBwYXJhbXMucHJlZml4O1xuICAgICAgY29uc3QgaWNvbnMgPSBwYXJhbXMuaWNvbnM7XG4gICAgICBjb25zdCBpY29uc0xpc3QgPSBpY29ucy5qb2luKFwiLFwiKTtcbiAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBpY29uczogaWNvbnNMaXN0XG4gICAgICB9KTtcbiAgICAgIHBhdGggKz0gcHJlZml4ICsgXCIuanNvbj9cIiArIHVybFBhcmFtcy50b1N0cmluZygpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJjdXN0b21cIjoge1xuICAgICAgY29uc3QgdXJpID0gcGFyYW1zLnVyaTtcbiAgICAgIHBhdGggKz0gdXJpLnNsaWNlKDAsIDEpID09PSBcIi9cIiA/IHVyaS5zbGljZSgxKSA6IHVyaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgY2FsbGJhY2soXCJhYm9ydFwiLCA0MDApO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIGxldCBkZWZhdWx0RXJyb3IgPSA1MDM7XG4gIGZldGNoTW9kdWxlKGhvc3QgKyBwYXRoKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgIGNvbnN0IHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICBpZiAoc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjYWxsYmFjayhzaG91bGRBYm9ydChzdGF0dXMpID8gXCJhYm9ydFwiIDogXCJuZXh0XCIsIHN0YXR1cyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVmYXVsdEVycm9yID0gNTAxO1xuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH0pLnRoZW4oKGRhdGEpID0+IHtcbiAgICBpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChkYXRhID09PSA0MDQpIHtcbiAgICAgICAgICBjYWxsYmFjayhcImFib3J0XCIsIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKFwibmV4dFwiLCBkZWZhdWx0RXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjYWxsYmFjayhcInN1Y2Nlc3NcIiwgZGF0YSk7XG4gICAgfSk7XG4gIH0pLmNhdGNoKCgpID0+IHtcbiAgICBjYWxsYmFjayhcIm5leHRcIiwgZGVmYXVsdEVycm9yKTtcbiAgfSk7XG59O1xuY29uc3QgZmV0Y2hBUElNb2R1bGUgPSB7XG4gIHByZXBhcmUsXG4gIHNlbmRcbn07XG5cbmZ1bmN0aW9uIHNvcnRJY29ucyhpY29ucykge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgbG9hZGVkOiBbXSxcbiAgICBtaXNzaW5nOiBbXSxcbiAgICBwZW5kaW5nOiBbXVxuICB9O1xuICBjb25zdCBzdG9yYWdlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGljb25zLnNvcnQoKGEsIGIpID0+IHtcbiAgICBpZiAoYS5wcm92aWRlciAhPT0gYi5wcm92aWRlcikge1xuICAgICAgcmV0dXJuIGEucHJvdmlkZXIubG9jYWxlQ29tcGFyZShiLnByb3ZpZGVyKTtcbiAgICB9XG4gICAgaWYgKGEucHJlZml4ICE9PSBiLnByZWZpeCkge1xuICAgICAgcmV0dXJuIGEucHJlZml4LmxvY2FsZUNvbXBhcmUoYi5wcmVmaXgpO1xuICAgIH1cbiAgICByZXR1cm4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKTtcbiAgfSk7XG4gIGxldCBsYXN0SWNvbiA9IHtcbiAgICBwcm92aWRlcjogXCJcIixcbiAgICBwcmVmaXg6IFwiXCIsXG4gICAgbmFtZTogXCJcIlxuICB9O1xuICBpY29ucy5mb3JFYWNoKChpY29uKSA9PiB7XG4gICAgaWYgKGxhc3RJY29uLm5hbWUgPT09IGljb24ubmFtZSAmJiBsYXN0SWNvbi5wcmVmaXggPT09IGljb24ucHJlZml4ICYmIGxhc3RJY29uLnByb3ZpZGVyID09PSBpY29uLnByb3ZpZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxhc3RJY29uID0gaWNvbjtcbiAgICBjb25zdCBwcm92aWRlciA9IGljb24ucHJvdmlkZXI7XG4gICAgY29uc3QgcHJlZml4ID0gaWNvbi5wcmVmaXg7XG4gICAgY29uc3QgbmFtZSA9IGljb24ubmFtZTtcbiAgICBjb25zdCBwcm92aWRlclN0b3JhZ2UgPSBzdG9yYWdlW3Byb3ZpZGVyXSB8fCAoc3RvcmFnZVtwcm92aWRlcl0gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgY29uc3QgbG9jYWxTdG9yYWdlID0gcHJvdmlkZXJTdG9yYWdlW3ByZWZpeF0gfHwgKHByb3ZpZGVyU3RvcmFnZVtwcmVmaXhdID0gZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSk7XG4gICAgbGV0IGxpc3Q7XG4gICAgaWYgKG5hbWUgaW4gbG9jYWxTdG9yYWdlLmljb25zKSB7XG4gICAgICBsaXN0ID0gcmVzdWx0LmxvYWRlZDtcbiAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gXCJcIiB8fCBsb2NhbFN0b3JhZ2UubWlzc2luZy5oYXMobmFtZSkpIHtcbiAgICAgIGxpc3QgPSByZXN1bHQubWlzc2luZztcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdCA9IHJlc3VsdC5wZW5kaW5nO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0ge1xuICAgICAgcHJvdmlkZXIsXG4gICAgICBwcmVmaXgsXG4gICAgICBuYW1lXG4gICAgfTtcbiAgICBsaXN0LnB1c2goaXRlbSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZW1vdmVDYWxsYmFjayhzdG9yYWdlcywgaWQpIHtcbiAgc3RvcmFnZXMuZm9yRWFjaCgoc3RvcmFnZSkgPT4ge1xuICAgIGNvbnN0IGl0ZW1zID0gc3RvcmFnZS5sb2FkZXJDYWxsYmFja3M7XG4gICAgaWYgKGl0ZW1zKSB7XG4gICAgICBzdG9yYWdlLmxvYWRlckNhbGxiYWNrcyA9IGl0ZW1zLmZpbHRlcigocm93KSA9PiByb3cuaWQgIT09IGlkKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FsbGJhY2tzKHN0b3JhZ2UpIHtcbiAgaWYgKCFzdG9yYWdlLnBlbmRpbmdDYWxsYmFja3NGbGFnKSB7XG4gICAgc3RvcmFnZS5wZW5kaW5nQ2FsbGJhY2tzRmxhZyA9IHRydWU7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzdG9yYWdlLnBlbmRpbmdDYWxsYmFja3NGbGFnID0gZmFsc2U7XG4gICAgICBjb25zdCBpdGVtcyA9IHN0b3JhZ2UubG9hZGVyQ2FsbGJhY2tzID8gc3RvcmFnZS5sb2FkZXJDYWxsYmFja3Muc2xpY2UoMCkgOiBbXTtcbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBoYXNQZW5kaW5nID0gZmFsc2U7XG4gICAgICBjb25zdCBwcm92aWRlciA9IHN0b3JhZ2UucHJvdmlkZXI7XG4gICAgICBjb25zdCBwcmVmaXggPSBzdG9yYWdlLnByZWZpeDtcbiAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgaWNvbnMgPSBpdGVtLmljb25zO1xuICAgICAgICBjb25zdCBvbGRMZW5ndGggPSBpY29ucy5wZW5kaW5nLmxlbmd0aDtcbiAgICAgICAgaWNvbnMucGVuZGluZyA9IGljb25zLnBlbmRpbmcuZmlsdGVyKChpY29uKSA9PiB7XG4gICAgICAgICAgaWYgKGljb24ucHJlZml4ICE9PSBwcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBuYW1lID0gaWNvbi5uYW1lO1xuICAgICAgICAgIGlmIChzdG9yYWdlLmljb25zW25hbWVdKSB7XG4gICAgICAgICAgICBpY29ucy5sb2FkZWQucHVzaCh7XG4gICAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RvcmFnZS5taXNzaW5nLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgaWNvbnMubWlzc2luZy5wdXNoKHtcbiAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhc1BlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpY29ucy5wZW5kaW5nLmxlbmd0aCAhPT0gb2xkTGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCFoYXNQZW5kaW5nKSB7XG4gICAgICAgICAgICByZW1vdmVDYWxsYmFjayhbc3RvcmFnZV0sIGl0ZW0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtLmNhbGxiYWNrKFxuICAgICAgICAgICAgaWNvbnMubG9hZGVkLnNsaWNlKDApLFxuICAgICAgICAgICAgaWNvbnMubWlzc2luZy5zbGljZSgwKSxcbiAgICAgICAgICAgIGljb25zLnBlbmRpbmcuc2xpY2UoMCksXG4gICAgICAgICAgICBpdGVtLmFib3J0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmxldCBpZENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gc3RvcmVDYWxsYmFjayhjYWxsYmFjaywgaWNvbnMsIHBlbmRpbmdTb3VyY2VzKSB7XG4gIGNvbnN0IGlkID0gaWRDb3VudGVyKys7XG4gIGNvbnN0IGFib3J0ID0gcmVtb3ZlQ2FsbGJhY2suYmluZChudWxsLCBwZW5kaW5nU291cmNlcywgaWQpO1xuICBpZiAoIWljb25zLnBlbmRpbmcubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFib3J0O1xuICB9XG4gIGNvbnN0IGl0ZW0gPSB7XG4gICAgaWQsXG4gICAgaWNvbnMsXG4gICAgY2FsbGJhY2ssXG4gICAgYWJvcnRcbiAgfTtcbiAgcGVuZGluZ1NvdXJjZXMuZm9yRWFjaCgoc3RvcmFnZSkgPT4ge1xuICAgIChzdG9yYWdlLmxvYWRlckNhbGxiYWNrcyB8fCAoc3RvcmFnZS5sb2FkZXJDYWxsYmFja3MgPSBbXSkpLnB1c2goaXRlbSk7XG4gIH0pO1xuICByZXR1cm4gYWJvcnQ7XG59XG5cbmZ1bmN0aW9uIGxpc3RUb0ljb25zKGxpc3QsIHZhbGlkYXRlID0gdHJ1ZSwgc2ltcGxlTmFtZXMgPSBmYWxzZSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgY29uc3QgaWNvbiA9IHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiID8gc3RyaW5nVG9JY29uKGl0ZW0sIHZhbGlkYXRlLCBzaW1wbGVOYW1lcykgOiBpdGVtO1xuICAgIGlmIChpY29uKSB7XG4gICAgICByZXN1bHQucHVzaChpY29uKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvY29uZmlnLnRzXG52YXIgZGVmYXVsdENvbmZpZyA9IHtcbiAgcmVzb3VyY2VzOiBbXSxcbiAgaW5kZXg6IDAsXG4gIHRpbWVvdXQ6IDJlMyxcbiAgcm90YXRlOiA3NTAsXG4gIHJhbmRvbTogZmFsc2UsXG4gIGRhdGFBZnRlclRpbWVvdXQ6IGZhbHNlXG59O1xuXG4vLyBzcmMvcXVlcnkudHNcbmZ1bmN0aW9uIHNlbmRRdWVyeShjb25maWcsIHBheWxvYWQsIHF1ZXJ5LCBkb25lKSB7XG4gIGNvbnN0IHJlc291cmNlc0NvdW50ID0gY29uZmlnLnJlc291cmNlcy5sZW5ndGg7XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSBjb25maWcucmFuZG9tID8gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcmVzb3VyY2VzQ291bnQpIDogY29uZmlnLmluZGV4O1xuICBsZXQgcmVzb3VyY2VzO1xuICBpZiAoY29uZmlnLnJhbmRvbSkge1xuICAgIGxldCBsaXN0ID0gY29uZmlnLnJlc291cmNlcy5zbGljZSgwKTtcbiAgICByZXNvdXJjZXMgPSBbXTtcbiAgICB3aGlsZSAobGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBuZXh0SW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsaXN0Lmxlbmd0aCk7XG4gICAgICByZXNvdXJjZXMucHVzaChsaXN0W25leHRJbmRleF0pO1xuICAgICAgbGlzdCA9IGxpc3Quc2xpY2UoMCwgbmV4dEluZGV4KS5jb25jYXQobGlzdC5zbGljZShuZXh0SW5kZXggKyAxKSk7XG4gICAgfVxuICAgIHJlc291cmNlcyA9IHJlc291cmNlcy5jb25jYXQobGlzdCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzb3VyY2VzID0gY29uZmlnLnJlc291cmNlcy5zbGljZShzdGFydEluZGV4KS5jb25jYXQoY29uZmlnLnJlc291cmNlcy5zbGljZSgwLCBzdGFydEluZGV4KSk7XG4gIH1cbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgbGV0IHN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICBsZXQgcXVlcmllc1NlbnQgPSAwO1xuICBsZXQgbGFzdEVycm9yO1xuICBsZXQgdGltZXIgPSBudWxsO1xuICBsZXQgcXVldWUgPSBbXTtcbiAgbGV0IGRvbmVDYWxsYmFja3MgPSBbXTtcbiAgaWYgKHR5cGVvZiBkb25lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBkb25lQ2FsbGJhY2tzLnB1c2goZG9uZSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVzZXRUaW1lcigpIHtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIGlmIChzdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICBzdGF0dXMgPSBcImFib3J0ZWRcIjtcbiAgICB9XG4gICAgcmVzZXRUaW1lcigpO1xuICAgIHF1ZXVlLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgaXRlbS5zdGF0dXMgPSBcImFib3J0ZWRcIjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBxdWV1ZSA9IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShjYWxsYmFjaywgb3ZlcndyaXRlKSB7XG4gICAgaWYgKG92ZXJ3cml0ZSkge1xuICAgICAgZG9uZUNhbGxiYWNrcyA9IFtdO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGRvbmVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFF1ZXJ5U3RhdHVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydFRpbWUsXG4gICAgICBwYXlsb2FkLFxuICAgICAgc3RhdHVzLFxuICAgICAgcXVlcmllc1NlbnQsXG4gICAgICBxdWVyaWVzUGVuZGluZzogcXVldWUubGVuZ3RoLFxuICAgICAgc3Vic2NyaWJlLFxuICAgICAgYWJvcnRcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGZhaWxRdWVyeSgpIHtcbiAgICBzdGF0dXMgPSBcImZhaWxlZFwiO1xuICAgIGRvbmVDYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcbiAgICAgIGNhbGxiYWNrKHZvaWQgMCwgbGFzdEVycm9yKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhclF1ZXVlKCkge1xuICAgIHF1ZXVlLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgaXRlbS5zdGF0dXMgPSBcImFib3J0ZWRcIjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBxdWV1ZSA9IFtdO1xuICB9XG4gIGZ1bmN0aW9uIG1vZHVsZVJlc3BvbnNlKGl0ZW0sIHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgY29uc3QgaXNFcnJvciA9IHJlc3BvbnNlICE9PSBcInN1Y2Nlc3NcIjtcbiAgICBxdWV1ZSA9IHF1ZXVlLmZpbHRlcigocXVldWVkKSA9PiBxdWV1ZWQgIT09IGl0ZW0pO1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgaWYgKGlzRXJyb3IgfHwgIWNvbmZpZy5kYXRhQWZ0ZXJUaW1lb3V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UgPT09IFwiYWJvcnRcIikge1xuICAgICAgbGFzdEVycm9yID0gZGF0YTtcbiAgICAgIGZhaWxRdWVyeSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcikge1xuICAgICAgbGFzdEVycm9yID0gZGF0YTtcbiAgICAgIGlmICghcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGlmICghcmVzb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgIGZhaWxRdWVyeSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4ZWNOZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzZXRUaW1lcigpO1xuICAgIGNsZWFyUXVldWUoKTtcbiAgICBpZiAoIWNvbmZpZy5yYW5kb20pIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gY29uZmlnLnJlc291cmNlcy5pbmRleE9mKGl0ZW0ucmVzb3VyY2UpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJiBpbmRleCAhPT0gY29uZmlnLmluZGV4KSB7XG4gICAgICAgIGNvbmZpZy5pbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0dXMgPSBcImNvbXBsZXRlZFwiO1xuICAgIGRvbmVDYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcbiAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGV4ZWNOZXh0KCkge1xuICAgIGlmIChzdGF0dXMgIT09IFwicGVuZGluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc2V0VGltZXIoKTtcbiAgICBjb25zdCByZXNvdXJjZSA9IHJlc291cmNlcy5zaGlmdCgpO1xuICAgIGlmIChyZXNvdXJjZSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcmVzZXRUaW1lcigpO1xuICAgICAgICAgIGlmIChzdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICBjbGVhclF1ZXVlKCk7XG4gICAgICAgICAgICBmYWlsUXVlcnkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGNvbmZpZy50aW1lb3V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZmFpbFF1ZXJ5KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgICAgcmVzb3VyY2UsXG4gICAgICBjYWxsYmFjazogKHN0YXR1czIsIGRhdGEpID0+IHtcbiAgICAgICAgbW9kdWxlUmVzcG9uc2UoaXRlbSwgc3RhdHVzMiwgZGF0YSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBxdWV1ZS5wdXNoKGl0ZW0pO1xuICAgIHF1ZXJpZXNTZW50Kys7XG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWNOZXh0LCBjb25maWcucm90YXRlKTtcbiAgICBxdWVyeShyZXNvdXJjZSwgcGF5bG9hZCwgaXRlbS5jYWxsYmFjayk7XG4gIH1cbiAgc2V0VGltZW91dChleGVjTmV4dCk7XG4gIHJldHVybiBnZXRRdWVyeVN0YXR1cztcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5mdW5jdGlvbiBpbml0UmVkdW5kYW5jeShjZmcpIHtcbiAgY29uc3QgY29uZmlnID0ge1xuICAgIC4uLmRlZmF1bHRDb25maWcsXG4gICAgLi4uY2ZnXG4gIH07XG4gIGxldCBxdWVyaWVzID0gW107XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgcXVlcmllcyA9IHF1ZXJpZXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtKCkuc3RhdHVzID09PSBcInBlbmRpbmdcIik7XG4gIH1cbiAgZnVuY3Rpb24gcXVlcnkocGF5bG9hZCwgcXVlcnlDYWxsYmFjaywgZG9uZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcXVlcnkyID0gc2VuZFF1ZXJ5KFxuICAgICAgY29uZmlnLFxuICAgICAgcGF5bG9hZCxcbiAgICAgIHF1ZXJ5Q2FsbGJhY2ssXG4gICAgICAoZGF0YSwgZXJyb3IpID0+IHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBpZiAoZG9uZUNhbGxiYWNrKSB7XG4gICAgICAgICAgZG9uZUNhbGxiYWNrKGRhdGEsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgcXVlcmllcy5wdXNoKHF1ZXJ5Mik7XG4gICAgcmV0dXJuIHF1ZXJ5MjtcbiAgfVxuICBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHF1ZXJpZXMuZmluZCgodmFsdWUpID0+IHtcbiAgICAgIHJldHVybiBjYWxsYmFjayh2YWx1ZSk7XG4gICAgfSkgfHwgbnVsbDtcbiAgfVxuICBjb25zdCBpbnN0YW5jZSA9IHtcbiAgICBxdWVyeSxcbiAgICBmaW5kLFxuICAgIHNldEluZGV4OiAoaW5kZXgpID0+IHtcbiAgICAgIGNvbmZpZy5pbmRleCA9IGluZGV4O1xuICAgIH0sXG4gICAgZ2V0SW5kZXg6ICgpID0+IGNvbmZpZy5pbmRleCxcbiAgICBjbGVhbnVwXG4gIH07XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gZW1wdHlDYWxsYmFjayQxKCkge1xufVxuY29uc3QgcmVkdW5kYW5jeUNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBnZXRSZWR1bmRhbmN5Q2FjaGUocHJvdmlkZXIpIHtcbiAgaWYgKCFyZWR1bmRhbmN5Q2FjaGVbcHJvdmlkZXJdKSB7XG4gICAgY29uc3QgY29uZmlnID0gZ2V0QVBJQ29uZmlnKHByb3ZpZGVyKTtcbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWR1bmRhbmN5ID0gaW5pdFJlZHVuZGFuY3koY29uZmlnKTtcbiAgICBjb25zdCBjYWNoZWRSZXVuZGFuY3kgPSB7XG4gICAgICBjb25maWcsXG4gICAgICByZWR1bmRhbmN5XG4gICAgfTtcbiAgICByZWR1bmRhbmN5Q2FjaGVbcHJvdmlkZXJdID0gY2FjaGVkUmV1bmRhbmN5O1xuICB9XG4gIHJldHVybiByZWR1bmRhbmN5Q2FjaGVbcHJvdmlkZXJdO1xufVxuZnVuY3Rpb24gc2VuZEFQSVF1ZXJ5KHRhcmdldCwgcXVlcnksIGNhbGxiYWNrKSB7XG4gIGxldCByZWR1bmRhbmN5O1xuICBsZXQgc2VuZDtcbiAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBhcGkgPSBnZXRBUElNb2R1bGUodGFyZ2V0KTtcbiAgICBpZiAoIWFwaSkge1xuICAgICAgY2FsbGJhY2sodm9pZCAwLCA0MjQpO1xuICAgICAgcmV0dXJuIGVtcHR5Q2FsbGJhY2skMTtcbiAgICB9XG4gICAgc2VuZCA9IGFwaS5zZW5kO1xuICAgIGNvbnN0IGNhY2hlZCA9IGdldFJlZHVuZGFuY3lDYWNoZSh0YXJnZXQpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJlZHVuZGFuY3kgPSBjYWNoZWQucmVkdW5kYW5jeTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY29uZmlnID0gY3JlYXRlQVBJQ29uZmlnKHRhcmdldCk7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgcmVkdW5kYW5jeSA9IGluaXRSZWR1bmRhbmN5KGNvbmZpZyk7XG4gICAgICBjb25zdCBtb2R1bGVLZXkgPSB0YXJnZXQucmVzb3VyY2VzID8gdGFyZ2V0LnJlc291cmNlc1swXSA6IFwiXCI7XG4gICAgICBjb25zdCBhcGkgPSBnZXRBUElNb2R1bGUobW9kdWxlS2V5KTtcbiAgICAgIGlmIChhcGkpIHtcbiAgICAgICAgc2VuZCA9IGFwaS5zZW5kO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIXJlZHVuZGFuY3kgfHwgIXNlbmQpIHtcbiAgICBjYWxsYmFjayh2b2lkIDAsIDQyNCk7XG4gICAgcmV0dXJuIGVtcHR5Q2FsbGJhY2skMTtcbiAgfVxuICByZXR1cm4gcmVkdW5kYW5jeS5xdWVyeShxdWVyeSwgc2VuZCwgY2FsbGJhY2spKCkuYWJvcnQ7XG59XG5cbmNvbnN0IGJyb3dzZXJDYWNoZVZlcnNpb24gPSBcImljb25pZnkyXCI7XG5jb25zdCBicm93c2VyQ2FjaGVQcmVmaXggPSBcImljb25pZnlcIjtcbmNvbnN0IGJyb3dzZXJDYWNoZUNvdW50S2V5ID0gYnJvd3NlckNhY2hlUHJlZml4ICsgXCItY291bnRcIjtcbmNvbnN0IGJyb3dzZXJDYWNoZVZlcnNpb25LZXkgPSBicm93c2VyQ2FjaGVQcmVmaXggKyBcIi12ZXJzaW9uXCI7XG5jb25zdCBicm93c2VyU3RvcmFnZUhvdXIgPSAzNmU1O1xuY29uc3QgYnJvd3NlclN0b3JhZ2VDYWNoZUV4cGlyYXRpb24gPSAxNjg7XG5cbmZ1bmN0aW9uIGdldFN0b3JlZEl0ZW0oZnVuYywga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZ1bmMuZ2V0SXRlbShrZXkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgfVxufVxuZnVuY3Rpb24gc2V0U3RvcmVkSXRlbShmdW5jLCBrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgZnVuYy5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlU3RvcmVkSXRlbShmdW5jLCBrZXkpIHtcbiAgdHJ5IHtcbiAgICBmdW5jLnJlbW92ZUl0ZW0oa2V5KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QnJvd3NlclN0b3JhZ2VJdGVtc0NvdW50KHN0b3JhZ2UsIHZhbHVlKSB7XG4gIHJldHVybiBzZXRTdG9yZWRJdGVtKHN0b3JhZ2UsIGJyb3dzZXJDYWNoZUNvdW50S2V5LCB2YWx1ZS50b1N0cmluZygpKTtcbn1cbmZ1bmN0aW9uIGdldEJyb3dzZXJTdG9yYWdlSXRlbXNDb3VudChzdG9yYWdlKSB7XG4gIHJldHVybiBwYXJzZUludChnZXRTdG9yZWRJdGVtKHN0b3JhZ2UsIGJyb3dzZXJDYWNoZUNvdW50S2V5KSkgfHwgMDtcbn1cblxuY29uc3QgYnJvd3NlclN0b3JhZ2VDb25maWcgPSB7XG4gIGxvY2FsOiB0cnVlLFxuICBzZXNzaW9uOiB0cnVlXG59O1xuY29uc3QgYnJvd3NlclN0b3JhZ2VFbXB0eUl0ZW1zID0ge1xuICBsb2NhbDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgc2Vzc2lvbjogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxufTtcbmxldCBicm93c2VyU3RvcmFnZVN0YXR1cyA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0QnJvd3NlclN0b3JhZ2VTdGF0dXMoc3RhdHVzKSB7XG4gIGJyb3dzZXJTdG9yYWdlU3RhdHVzID0gc3RhdHVzO1xufVxuXG5sZXQgX3dpbmRvdyA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyB7fSA6IHdpbmRvdztcbmZ1bmN0aW9uIGdldEJyb3dzZXJTdG9yYWdlKGtleSkge1xuICBjb25zdCBhdHRyID0ga2V5ICsgXCJTdG9yYWdlXCI7XG4gIHRyeSB7XG4gICAgaWYgKF93aW5kb3cgJiYgX3dpbmRvd1thdHRyXSAmJiB0eXBlb2YgX3dpbmRvd1thdHRyXS5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBfd2luZG93W2F0dHJdO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gIH1cbiAgYnJvd3NlclN0b3JhZ2VDb25maWdba2V5XSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpdGVyYXRlQnJvd3NlclN0b3JhZ2Uoa2V5LCBjYWxsYmFjaykge1xuICBjb25zdCBmdW5jID0gZ2V0QnJvd3NlclN0b3JhZ2Uoa2V5KTtcbiAgaWYgKCFmdW5jKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHZlcnNpb24gPSBnZXRTdG9yZWRJdGVtKGZ1bmMsIGJyb3dzZXJDYWNoZVZlcnNpb25LZXkpO1xuICBpZiAodmVyc2lvbiAhPT0gYnJvd3NlckNhY2hlVmVyc2lvbikge1xuICAgIGlmICh2ZXJzaW9uKSB7XG4gICAgICBjb25zdCB0b3RhbDIgPSBnZXRCcm93c2VyU3RvcmFnZUl0ZW1zQ291bnQoZnVuYyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsMjsgaSsrKSB7XG4gICAgICAgIHJlbW92ZVN0b3JlZEl0ZW0oZnVuYywgYnJvd3NlckNhY2hlUHJlZml4ICsgaS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0U3RvcmVkSXRlbShmdW5jLCBicm93c2VyQ2FjaGVWZXJzaW9uS2V5LCBicm93c2VyQ2FjaGVWZXJzaW9uKTtcbiAgICBzZXRCcm93c2VyU3RvcmFnZUl0ZW1zQ291bnQoZnVuYywgMCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG1pblRpbWUgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyBicm93c2VyU3RvcmFnZUhvdXIpIC0gYnJvd3NlclN0b3JhZ2VDYWNoZUV4cGlyYXRpb247XG4gIGNvbnN0IHBhcnNlSXRlbSA9IChpbmRleCkgPT4ge1xuICAgIGNvbnN0IG5hbWUgPSBicm93c2VyQ2FjaGVQcmVmaXggKyBpbmRleC50b1N0cmluZygpO1xuICAgIGNvbnN0IGl0ZW0gPSBnZXRTdG9yZWRJdGVtKGZ1bmMsIG5hbWUpO1xuICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoaXRlbSk7XG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGRhdGEuY2FjaGVkID09PSBcIm51bWJlclwiICYmIGRhdGEuY2FjaGVkID4gbWluVGltZSAmJiB0eXBlb2YgZGF0YS5wcm92aWRlciA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZGF0YS5kYXRhID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBkYXRhLmRhdGEucHJlZml4ID09PSBcInN0cmluZ1wiICYmIC8vIFZhbGlkIGl0ZW06IHJ1biBjYWxsYmFja1xuICAgICAgY2FsbGJhY2soZGF0YSwgaW5kZXgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgIH1cbiAgICByZW1vdmVTdG9yZWRJdGVtKGZ1bmMsIG5hbWUpO1xuICB9O1xuICBsZXQgdG90YWwgPSBnZXRCcm93c2VyU3RvcmFnZUl0ZW1zQ291bnQoZnVuYyk7XG4gIGZvciAobGV0IGkgPSB0b3RhbCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKCFwYXJzZUl0ZW0oaSkpIHtcbiAgICAgIGlmIChpID09PSB0b3RhbCAtIDEpIHtcbiAgICAgICAgdG90YWwtLTtcbiAgICAgICAgc2V0QnJvd3NlclN0b3JhZ2VJdGVtc0NvdW50KGZ1bmMsIHRvdGFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyb3dzZXJTdG9yYWdlRW1wdHlJdGVtc1trZXldLmFkZChpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEJyb3dzZXJTdG9yYWdlKCkge1xuICBpZiAoYnJvd3NlclN0b3JhZ2VTdGF0dXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2V0QnJvd3NlclN0b3JhZ2VTdGF0dXModHJ1ZSk7XG4gIGZvciAoY29uc3Qga2V5IGluIGJyb3dzZXJTdG9yYWdlQ29uZmlnKSB7XG4gICAgaXRlcmF0ZUJyb3dzZXJTdG9yYWdlKGtleSwgKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IGljb25TZXQgPSBpdGVtLmRhdGE7XG4gICAgICBjb25zdCBwcm92aWRlciA9IGl0ZW0ucHJvdmlkZXI7XG4gICAgICBjb25zdCBwcmVmaXggPSBpY29uU2V0LnByZWZpeDtcbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKFxuICAgICAgICBwcm92aWRlcixcbiAgICAgICAgcHJlZml4XG4gICAgICApO1xuICAgICAgaWYgKCFhZGRJY29uU2V0KHN0b3JhZ2UsIGljb25TZXQpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBsYXN0TW9kaWZpZWQgPSBpY29uU2V0Lmxhc3RNb2RpZmllZCB8fCAtMTtcbiAgICAgIHN0b3JhZ2UubGFzdE1vZGlmaWVkQ2FjaGVkID0gc3RvcmFnZS5sYXN0TW9kaWZpZWRDYWNoZWQgPyBNYXRoLm1pbihzdG9yYWdlLmxhc3RNb2RpZmllZENhY2hlZCwgbGFzdE1vZGlmaWVkKSA6IGxhc3RNb2RpZmllZDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxhc3RNb2RpZmllZChzdG9yYWdlLCBsYXN0TW9kaWZpZWQpIHtcbiAgY29uc3QgbGFzdFZhbHVlID0gc3RvcmFnZS5sYXN0TW9kaWZpZWRDYWNoZWQ7XG4gIGlmIChcbiAgICAvLyBNYXRjaGVzIG9yIG5ld2VyXG4gICAgbGFzdFZhbHVlICYmIGxhc3RWYWx1ZSA+PSBsYXN0TW9kaWZpZWRcbiAgKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZSA9PT0gbGFzdE1vZGlmaWVkO1xuICB9XG4gIHN0b3JhZ2UubGFzdE1vZGlmaWVkQ2FjaGVkID0gbGFzdE1vZGlmaWVkO1xuICBpZiAobGFzdFZhbHVlKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYnJvd3NlclN0b3JhZ2VDb25maWcpIHtcbiAgICAgIGl0ZXJhdGVCcm93c2VyU3RvcmFnZShrZXksIChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGljb25TZXQgPSBpdGVtLmRhdGE7XG4gICAgICAgIHJldHVybiBpdGVtLnByb3ZpZGVyICE9PSBzdG9yYWdlLnByb3ZpZGVyIHx8IGljb25TZXQucHJlZml4ICE9PSBzdG9yYWdlLnByZWZpeCB8fCBpY29uU2V0Lmxhc3RNb2RpZmllZCA9PT0gbGFzdE1vZGlmaWVkO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc3RvcmVJbkJyb3dzZXJTdG9yYWdlKHN0b3JhZ2UsIGRhdGEpIHtcbiAgaWYgKCFicm93c2VyU3RvcmFnZVN0YXR1cykge1xuICAgIGluaXRCcm93c2VyU3RvcmFnZSgpO1xuICB9XG4gIGZ1bmN0aW9uIHN0b3JlKGtleSkge1xuICAgIGxldCBmdW5jO1xuICAgIGlmICghYnJvd3NlclN0b3JhZ2VDb25maWdba2V5XSB8fCAhKGZ1bmMgPSBnZXRCcm93c2VyU3RvcmFnZShrZXkpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZXQgPSBicm93c2VyU3RvcmFnZUVtcHR5SXRlbXNba2V5XTtcbiAgICBsZXQgaW5kZXg7XG4gICAgaWYgKHNldC5zaXplKSB7XG4gICAgICBzZXQuZGVsZXRlKGluZGV4ID0gQXJyYXkuZnJvbShzZXQpLnNoaWZ0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleCA9IGdldEJyb3dzZXJTdG9yYWdlSXRlbXNDb3VudChmdW5jKTtcbiAgICAgIGlmICghc2V0QnJvd3NlclN0b3JhZ2VJdGVtc0NvdW50KGZ1bmMsIGluZGV4ICsgMSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpdGVtID0ge1xuICAgICAgY2FjaGVkOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyBicm93c2VyU3RvcmFnZUhvdXIpLFxuICAgICAgcHJvdmlkZXI6IHN0b3JhZ2UucHJvdmlkZXIsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gc2V0U3RvcmVkSXRlbShcbiAgICAgIGZ1bmMsXG4gICAgICBicm93c2VyQ2FjaGVQcmVmaXggKyBpbmRleC50b1N0cmluZygpLFxuICAgICAgSlNPTi5zdHJpbmdpZnkoaXRlbSlcbiAgICApO1xuICB9XG4gIGlmIChkYXRhLmxhc3RNb2RpZmllZCAmJiAhdXBkYXRlTGFzdE1vZGlmaWVkKHN0b3JhZ2UsIGRhdGEubGFzdE1vZGlmaWVkKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIU9iamVjdC5rZXlzKGRhdGEuaWNvbnMpLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZGF0YS5ub3RfZm91bmQpIHtcbiAgICBkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YSk7XG4gICAgZGVsZXRlIGRhdGEubm90X2ZvdW5kO1xuICB9XG4gIGlmICghc3RvcmUoXCJsb2NhbFwiKSkge1xuICAgIHN0b3JlKFwic2Vzc2lvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbXB0eUNhbGxiYWNrKCkge1xufVxuZnVuY3Rpb24gbG9hZGVkTmV3SWNvbnMoc3RvcmFnZSkge1xuICBpZiAoIXN0b3JhZ2UuaWNvbnNMb2FkZXJGbGFnKSB7XG4gICAgc3RvcmFnZS5pY29uc0xvYWRlckZsYWcgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc3RvcmFnZS5pY29uc0xvYWRlckZsYWcgPSBmYWxzZTtcbiAgICAgIHVwZGF0ZUNhbGxiYWNrcyhzdG9yYWdlKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gbG9hZE5ld0ljb25zKHN0b3JhZ2UsIGljb25zKSB7XG4gIGlmICghc3RvcmFnZS5pY29uc1RvTG9hZCkge1xuICAgIHN0b3JhZ2UuaWNvbnNUb0xvYWQgPSBpY29ucztcbiAgfSBlbHNlIHtcbiAgICBzdG9yYWdlLmljb25zVG9Mb2FkID0gc3RvcmFnZS5pY29uc1RvTG9hZC5jb25jYXQoaWNvbnMpLnNvcnQoKTtcbiAgfVxuICBpZiAoIXN0b3JhZ2UuaWNvbnNRdWV1ZUZsYWcpIHtcbiAgICBzdG9yYWdlLmljb25zUXVldWVGbGFnID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHN0b3JhZ2UuaWNvbnNRdWV1ZUZsYWcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHsgcHJvdmlkZXIsIHByZWZpeCB9ID0gc3RvcmFnZTtcbiAgICAgIGNvbnN0IGljb25zMiA9IHN0b3JhZ2UuaWNvbnNUb0xvYWQ7XG4gICAgICBkZWxldGUgc3RvcmFnZS5pY29uc1RvTG9hZDtcbiAgICAgIGxldCBhcGk7XG4gICAgICBpZiAoIWljb25zMiB8fCAhKGFwaSA9IGdldEFQSU1vZHVsZShwcm92aWRlcikpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmFtcyA9IGFwaS5wcmVwYXJlKHByb3ZpZGVyLCBwcmVmaXgsIGljb25zMik7XG4gICAgICBwYXJhbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBzZW5kQVBJUXVlcnkocHJvdmlkZXIsIGl0ZW0sIChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpdGVtLmljb25zLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgc3RvcmFnZS5taXNzaW5nLmFkZChuYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBhZGRJY29uU2V0KFxuICAgICAgICAgICAgICAgIHN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoIXBhcnNlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcGVuZGluZyA9IHN0b3JhZ2UucGVuZGluZ0ljb25zO1xuICAgICAgICAgICAgICBpZiAocGVuZGluZykge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICBwZW5kaW5nLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdG9yZUluQnJvd3NlclN0b3JhZ2Uoc3RvcmFnZSwgZGF0YSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsb2FkZWROZXdJY29ucyhzdG9yYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgbG9hZEljb25zID0gKGljb25zLCBjYWxsYmFjaykgPT4ge1xuICBjb25zdCBjbGVhbmVkSWNvbnMgPSBsaXN0VG9JY29ucyhpY29ucywgdHJ1ZSwgYWxsb3dTaW1wbGVOYW1lcygpKTtcbiAgY29uc3Qgc29ydGVkSWNvbnMgPSBzb3J0SWNvbnMoY2xlYW5lZEljb25zKTtcbiAgaWYgKCFzb3J0ZWRJY29ucy5wZW5kaW5nLmxlbmd0aCkge1xuICAgIGxldCBjYWxsQ2FsbGJhY2sgPSB0cnVlO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChjYWxsQ2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgIHNvcnRlZEljb25zLmxvYWRlZCxcbiAgICAgICAgICAgIHNvcnRlZEljb25zLm1pc3NpbmcsXG4gICAgICAgICAgICBzb3J0ZWRJY29ucy5wZW5kaW5nLFxuICAgICAgICAgICAgZW1wdHlDYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FsbENhbGxiYWNrID0gZmFsc2U7XG4gICAgfTtcbiAgfVxuICBjb25zdCBuZXdJY29ucyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBzb3VyY2VzID0gW107XG4gIGxldCBsYXN0UHJvdmlkZXIsIGxhc3RQcmVmaXg7XG4gIHNvcnRlZEljb25zLnBlbmRpbmcuZm9yRWFjaCgoaWNvbikgPT4ge1xuICAgIGNvbnN0IHsgcHJvdmlkZXIsIHByZWZpeCB9ID0gaWNvbjtcbiAgICBpZiAocHJlZml4ID09PSBsYXN0UHJlZml4ICYmIHByb3ZpZGVyID09PSBsYXN0UHJvdmlkZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGFzdFByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgbGFzdFByZWZpeCA9IHByZWZpeDtcbiAgICBzb3VyY2VzLnB1c2goZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSk7XG4gICAgY29uc3QgcHJvdmlkZXJOZXdJY29ucyA9IG5ld0ljb25zW3Byb3ZpZGVyXSB8fCAobmV3SWNvbnNbcHJvdmlkZXJdID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIGlmICghcHJvdmlkZXJOZXdJY29uc1twcmVmaXhdKSB7XG4gICAgICBwcm92aWRlck5ld0ljb25zW3ByZWZpeF0gPSBbXTtcbiAgICB9XG4gIH0pO1xuICBzb3J0ZWRJY29ucy5wZW5kaW5nLmZvckVhY2goKGljb24pID0+IHtcbiAgICBjb25zdCB7IHByb3ZpZGVyLCBwcmVmaXgsIG5hbWUgfSA9IGljb247XG4gICAgY29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UocHJvdmlkZXIsIHByZWZpeCk7XG4gICAgY29uc3QgcGVuZGluZ1F1ZXVlID0gc3RvcmFnZS5wZW5kaW5nSWNvbnMgfHwgKHN0b3JhZ2UucGVuZGluZ0ljb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgaWYgKCFwZW5kaW5nUXVldWUuaGFzKG5hbWUpKSB7XG4gICAgICBwZW5kaW5nUXVldWUuYWRkKG5hbWUpO1xuICAgICAgbmV3SWNvbnNbcHJvdmlkZXJdW3ByZWZpeF0ucHVzaChuYW1lKTtcbiAgICB9XG4gIH0pO1xuICBzb3VyY2VzLmZvckVhY2goKHN0b3JhZ2UpID0+IHtcbiAgICBjb25zdCB7IHByb3ZpZGVyLCBwcmVmaXggfSA9IHN0b3JhZ2U7XG4gICAgaWYgKG5ld0ljb25zW3Byb3ZpZGVyXVtwcmVmaXhdLmxlbmd0aCkge1xuICAgICAgbG9hZE5ld0ljb25zKHN0b3JhZ2UsIG5ld0ljb25zW3Byb3ZpZGVyXVtwcmVmaXhdKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2FsbGJhY2sgPyBzdG9yZUNhbGxiYWNrKGNhbGxiYWNrLCBzb3J0ZWRJY29ucywgc291cmNlcykgOiBlbXB0eUNhbGxiYWNrO1xufTtcbmNvbnN0IGxvYWRJY29uID0gKGljb24pID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChmdWxmaWxsLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpY29uT2JqID0gdHlwZW9mIGljb24gPT09IFwic3RyaW5nXCIgPyBzdHJpbmdUb0ljb24oaWNvbiwgdHJ1ZSkgOiBpY29uO1xuICAgIGlmICghaWNvbk9iaikge1xuICAgICAgcmVqZWN0KGljb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2FkSWNvbnMoW2ljb25PYmogfHwgaWNvbl0sIChsb2FkZWQpID0+IHtcbiAgICAgIGlmIChsb2FkZWQubGVuZ3RoICYmIGljb25PYmopIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEljb25EYXRhKGljb25PYmopO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIGZ1bGZpbGwoe1xuICAgICAgICAgICAgLi4uZGVmYXVsdEljb25Qcm9wcyxcbiAgICAgICAgICAgIC4uLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlamVjdChpY29uKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiB0b2dnbGVCcm93c2VyQ2FjaGUoc3RvcmFnZSwgdmFsdWUpIHtcbiAgc3dpdGNoIChzdG9yYWdlKSB7XG4gICAgY2FzZSBcImxvY2FsXCI6XG4gICAgY2FzZSBcInNlc3Npb25cIjpcbiAgICAgIGJyb3dzZXJTdG9yYWdlQ29uZmlnW3N0b3JhZ2VdID0gdmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYWxsXCI6XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBicm93c2VyU3RvcmFnZUNvbmZpZykge1xuICAgICAgICBicm93c2VyU3RvcmFnZUNvbmZpZ1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUN1c3RvbWlzYXRpb25zKGRlZmF1bHRzLCBpdGVtKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAuLi5kZWZhdWx0c1xuICB9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBpdGVtKSB7XG4gICAgY29uc3QgdmFsdWUgPSBpdGVtW2tleV07XG4gICAgY29uc3QgdmFsdWVUeXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGlmIChrZXkgaW4gZGVmYXVsdEljb25TaXplQ3VzdG9taXNhdGlvbnMpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSAmJiAodmFsdWVUeXBlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlVHlwZSA9PT0gXCJudW1iZXJcIikpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gdHlwZW9mIHJlc3VsdFtrZXldKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGtleSA9PT0gXCJyb3RhdGVcIiA/IHZhbHVlICUgNCA6IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBzZXBhcmF0b3IgPSAvW1xccyxdKy87XG5mdW5jdGlvbiBmbGlwRnJvbVN0cmluZyhjdXN0b20sIGZsaXApIHtcbiAgZmxpcC5zcGxpdChzZXBhcmF0b3IpLmZvckVhY2goKHN0cikgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gc3RyLnRyaW0oKTtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiaG9yaXpvbnRhbFwiOlxuICAgICAgICBjdXN0b20uaEZsaXAgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgICBjdXN0b20udkZsaXAgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByb3RhdGVGcm9tU3RyaW5nKHZhbHVlLCBkZWZhdWx0VmFsdWUgPSAwKSB7XG4gIGNvbnN0IHVuaXRzID0gdmFsdWUucmVwbGFjZSgvXi0/WzAtOS5dKi8sIFwiXCIpO1xuICBmdW5jdGlvbiBjbGVhbnVwKHZhbHVlMikge1xuICAgIHdoaWxlICh2YWx1ZTIgPCAwKSB7XG4gICAgICB2YWx1ZTIgKz0gNDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlMiAlIDQ7XG4gIH1cbiAgaWYgKHVuaXRzID09PSBcIlwiKSB7XG4gICAgY29uc3QgbnVtID0gcGFyc2VJbnQodmFsdWUpO1xuICAgIHJldHVybiBpc05hTihudW0pID8gMCA6IGNsZWFudXAobnVtKTtcbiAgfSBlbHNlIGlmICh1bml0cyAhPT0gdmFsdWUpIHtcbiAgICBsZXQgc3BsaXQgPSAwO1xuICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgIHNwbGl0ID0gMjU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRlZ1wiOlxuICAgICAgICBzcGxpdCA9IDkwO1xuICAgIH1cbiAgICBpZiAoc3BsaXQpIHtcbiAgICAgIGxldCBudW0gPSBwYXJzZUZsb2F0KHZhbHVlLnNsaWNlKDAsIHZhbHVlLmxlbmd0aCAtIHVuaXRzLmxlbmd0aCkpO1xuICAgICAgaWYgKGlzTmFOKG51bSkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBudW0gPSBudW0gLyBzcGxpdDtcbiAgICAgIHJldHVybiBudW0gJSAxID09PSAwID8gY2xlYW51cChudW0pIDogMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gaWNvblRvSFRNTChib2R5LCBhdHRyaWJ1dGVzKSB7XG4gIGxldCByZW5kZXJBdHRyaWJzSFRNTCA9IGJvZHkuaW5kZXhPZihcInhsaW5rOlwiKSA9PT0gLTEgPyBcIlwiIDogJyB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIic7XG4gIGZvciAoY29uc3QgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgcmVuZGVyQXR0cmlic0hUTUwgKz0gXCIgXCIgKyBhdHRyICsgJz1cIicgKyBhdHRyaWJ1dGVzW2F0dHJdICsgJ1wiJztcbiAgfVxuICByZXR1cm4gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiJyArIHJlbmRlckF0dHJpYnNIVE1MICsgXCI+XCIgKyBib2R5ICsgXCI8L3N2Zz5cIjtcbn1cblxuZnVuY3Rpb24gZW5jb2RlU1ZHZm9yVVJMKHN2Zykge1xuICByZXR1cm4gc3ZnLnJlcGxhY2UoL1wiL2csIFwiJ1wiKS5yZXBsYWNlKC8lL2csIFwiJTI1XCIpLnJlcGxhY2UoLyMvZywgXCIlMjNcIikucmVwbGFjZSgvPC9nLCBcIiUzQ1wiKS5yZXBsYWNlKC8+L2csIFwiJTNFXCIpLnJlcGxhY2UoL1xccysvZywgXCIgXCIpO1xufVxuZnVuY3Rpb24gc3ZnVG9EYXRhKHN2Zykge1xuICByZXR1cm4gXCJkYXRhOmltYWdlL3N2Zyt4bWwsXCIgKyBlbmNvZGVTVkdmb3JVUkwoc3ZnKTtcbn1cbmZ1bmN0aW9uIHN2Z1RvVVJMKHN2Zykge1xuICByZXR1cm4gJ3VybChcIicgKyBzdmdUb0RhdGEoc3ZnKSArICdcIiknO1xufVxuXG5sZXQgcG9saWN5O1xuZnVuY3Rpb24gY3JlYXRlUG9saWN5KCkge1xuICB0cnkge1xuICAgIHBvbGljeSA9IHdpbmRvdy50cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KFwiaWNvbmlmeVwiLCB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgIGNyZWF0ZUhUTUw6IChzKSA9PiBzXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHBvbGljeSA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFuVXBJbm5lckhUTUwoaHRtbCkge1xuICBpZiAocG9saWN5ID09PSB2b2lkIDApIHtcbiAgICBjcmVhdGVQb2xpY3koKTtcbiAgfVxuICByZXR1cm4gcG9saWN5ID8gcG9saWN5LmNyZWF0ZUhUTUwoaHRtbCkgOiBodG1sO1xufVxuXG5jb25zdCBkZWZhdWx0RXh0ZW5kZWRJY29uQ3VzdG9taXNhdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdEljb25DdXN0b21pc2F0aW9ucyxcbiAgICBpbmxpbmU6IGZhbHNlLFxufTtcblxuLyoqXG4gKiBEZWZhdWx0IFNWRyBhdHRyaWJ1dGVzXG4gKi9cbmNvbnN0IHN2Z0RlZmF1bHRzID0ge1xuICAgICd4bWxucyc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gICAgJ3htbG5zWGxpbmsnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAncm9sZSc6ICdpbWcnLFxufTtcbi8qKlxuICogU3R5bGUgbW9kZXNcbiAqL1xuY29uc3QgY29tbW9uUHJvcHMgPSB7XG4gICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG59O1xuY29uc3QgbW9ub3RvbmVQcm9wcyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxufTtcbmNvbnN0IGNvbG9yZWRQcm9wcyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXG59O1xuLy8gRHluYW1pY2FsbHkgYWRkIGNvbW1vbiBwcm9wcyB0byB2YXJpYWJsZXMgYWJvdmVcbmNvbnN0IHByb3BzVG9BZGQgPSB7XG4gICAgSW1hZ2U6ICd2YXIoLS1zdmcpJyxcbiAgICBSZXBlYXQ6ICduby1yZXBlYXQnLFxuICAgIFNpemU6ICcxMDAlIDEwMCUnLFxufTtcbmNvbnN0IHByb3BzVG9BZGRUbyA9IHtcbiAgICBXZWJraXRNYXNrOiBtb25vdG9uZVByb3BzLFxuICAgIG1hc2s6IG1vbm90b25lUHJvcHMsXG4gICAgYmFja2dyb3VuZDogY29sb3JlZFByb3BzLFxufTtcbmZvciAoY29uc3QgcHJlZml4IGluIHByb3BzVG9BZGRUbykge1xuICAgIGNvbnN0IGxpc3QgPSBwcm9wc1RvQWRkVG9bcHJlZml4XTtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHNUb0FkZCkge1xuICAgICAgICBsaXN0W3ByZWZpeCArIHByb3BdID0gcHJvcHNUb0FkZFtwcm9wXTtcbiAgICB9XG59XG4vKipcbiAqIERlZmF1bHQgdmFsdWVzIGZvciBjdXN0b21pc2F0aW9ucyBmb3IgaW5saW5lIGljb25cbiAqL1xuY29uc3QgaW5saW5lRGVmYXVsdHMgPSB7XG4gICAgLi4uZGVmYXVsdEV4dGVuZGVkSWNvbkN1c3RvbWlzYXRpb25zLFxuICAgIGlubGluZTogdHJ1ZSxcbn07XG4vKipcbiAqIEZpeCBzaXplOiBhZGQgJ3B4JyB0byBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIGZpeFNpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgKyAodmFsdWUubWF0Y2goL15bLTAtOS5dKyQvKSA/ICdweCcgOiAnJyk7XG59XG4vKipcbiAqIFJlbmRlciBpY29uXG4gKi9cbmNvbnN0IHJlbmRlciA9IChcbi8vIEljb24gbXVzdCBiZSB2YWxpZGF0ZWQgYmVmb3JlIGNhbGxpbmcgdGhpcyBmdW5jdGlvblxuaWNvbiwgXG4vLyBQYXJ0aWFsIHByb3BlcnRpZXNcbnByb3BzLCBcbi8vIFRydWUgaWYgaWNvbiBzaG91bGQgaGF2ZSB2ZXJ0aWNhbC1hbGlnbiBhZGRlZFxuaW5saW5lLCBcbi8vIE9wdGlvbmFsIHJlZmVyZW5jZSBmb3IgU1ZHL1NQQU4sIGV4dHJhY3RlZCBieSBSZWFjdC5mb3J3YXJkUmVmKClcbnJlZikgPT4ge1xuICAgIC8vIEdldCBkZWZhdWx0IHByb3BlcnRpZXNcbiAgICBjb25zdCBkZWZhdWx0UHJvcHMgPSBpbmxpbmVcbiAgICAgICAgPyBpbmxpbmVEZWZhdWx0c1xuICAgICAgICA6IGRlZmF1bHRFeHRlbmRlZEljb25DdXN0b21pc2F0aW9ucztcbiAgICAvLyBHZXQgYWxsIGN1c3RvbWlzYXRpb25zXG4gICAgY29uc3QgY3VzdG9taXNhdGlvbnMgPSBtZXJnZUN1c3RvbWlzYXRpb25zKGRlZmF1bHRQcm9wcywgcHJvcHMpO1xuICAgIC8vIENoZWNrIG1vZGVcbiAgICBjb25zdCBtb2RlID0gcHJvcHMubW9kZSB8fCAnc3ZnJztcbiAgICAvLyBDcmVhdGUgc3R5bGVcbiAgICBjb25zdCBzdHlsZSA9IHt9O1xuICAgIGNvbnN0IGN1c3RvbVN0eWxlID0gcHJvcHMuc3R5bGUgfHwge307XG4gICAgLy8gQ3JlYXRlIFNWRyBjb21wb25lbnQgcHJvcGVydGllc1xuICAgIGNvbnN0IGNvbXBvbmVudFByb3BzID0ge1xuICAgICAgICAuLi4obW9kZSA9PT0gJ3N2ZycgPyBzdmdEZWZhdWx0cyA6IHt9KSxcbiAgICAgICAgcmVmLFxuICAgIH07XG4gICAgLy8gR2V0IGVsZW1lbnQgcHJvcGVydGllc1xuICAgIGZvciAobGV0IGtleSBpbiBwcm9wcykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3BzW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgLy8gUHJvcGVydGllcyB0byBpZ25vcmVcbiAgICAgICAgICAgIGNhc2UgJ2ljb24nOlxuICAgICAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgICAgY2FzZSAnb25Mb2FkJzpcbiAgICAgICAgICAgIGNhc2UgJ21vZGUnOlxuICAgICAgICAgICAgY2FzZSAnX3JlZic6XG4gICAgICAgICAgICBjYXNlICdfaW5saW5lJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIEJvb2xlYW4gYXR0cmlidXRlc1xuICAgICAgICAgICAgY2FzZSAnaW5saW5lJzpcbiAgICAgICAgICAgIGNhc2UgJ2hGbGlwJzpcbiAgICAgICAgICAgIGNhc2UgJ3ZGbGlwJzpcbiAgICAgICAgICAgICAgICBjdXN0b21pc2F0aW9uc1trZXldID1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIEZsaXAgYXMgc3RyaW5nOiAnaG9yaXpvbnRhbCx2ZXJ0aWNhbCdcbiAgICAgICAgICAgIGNhc2UgJ2ZsaXAnOlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsaXBGcm9tU3RyaW5nKGN1c3RvbWlzYXRpb25zLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gQ29sb3I6IGNvcHkgdG8gc3R5bGVcbiAgICAgICAgICAgIGNhc2UgJ2NvbG9yJzpcbiAgICAgICAgICAgICAgICBzdHlsZS5jb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gUm90YXRpb24gYXMgc3RyaW5nXG4gICAgICAgICAgICBjYXNlICdyb3RhdGUnOlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbWlzYXRpb25zW2tleV0gPSByb3RhdGVGcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21pc2F0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGFyaWEtaGlkZGVuXG4gICAgICAgICAgICBjYXNlICdhcmlhSGlkZGVuJzpcbiAgICAgICAgICAgIGNhc2UgJ2FyaWEtaGlkZGVuJzpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUgJiYgdmFsdWUgIT09ICd0cnVlJykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29tcG9uZW50UHJvcHNbJ2FyaWEtaGlkZGVuJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gQ29weSBtaXNzaW5nIHByb3BlcnR5IGlmIGl0IGRvZXMgbm90IGV4aXN0IGluIGN1c3RvbWlzYXRpb25zXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0UHJvcHNba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFByb3BzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2VuZXJhdGUgaWNvblxuICAgIGNvbnN0IGl0ZW0gPSBpY29uVG9TVkcoaWNvbiwgY3VzdG9taXNhdGlvbnMpO1xuICAgIGNvbnN0IHJlbmRlckF0dHJpYnMgPSBpdGVtLmF0dHJpYnV0ZXM7XG4gICAgLy8gSW5saW5lIGRpc3BsYXlcbiAgICBpZiAoY3VzdG9taXNhdGlvbnMuaW5saW5lKSB7XG4gICAgICAgIHN0eWxlLnZlcnRpY2FsQWxpZ24gPSAnLTAuMTI1ZW0nO1xuICAgIH1cbiAgICBpZiAobW9kZSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgLy8gQWRkIHN0eWxlXG4gICAgICAgIGNvbXBvbmVudFByb3BzLnN0eWxlID0ge1xuICAgICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICAgICAuLi5jdXN0b21TdHlsZSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQWRkIGljb24gc3R1ZmZcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb21wb25lbnRQcm9wcywgcmVuZGVyQXR0cmlicyk7XG4gICAgICAgIC8vIENvdW50ZXIgZm9yIGlkcyBiYXNlZCBvbiBcImlkXCIgcHJvcGVydHkgdG8gcmVuZGVyIGljb25zIGNvbnNpc3RlbnRseSBvbiBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgICAgICBsZXQgbG9jYWxDb3VudGVyID0gMDtcbiAgICAgICAgbGV0IGlkID0gcHJvcHMuaWQ7XG4gICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0ICctJyB0byAnXycgdG8gYXZvaWQgZXJyb3JzIGluIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIGlkID0gaWQucmVwbGFjZSgvLS9nLCAnXycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBpY29uIHN0dWZmXG4gICAgICAgIGNvbXBvbmVudFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID0ge1xuICAgICAgICAgICAgX19odG1sOiBjbGVhblVwSW5uZXJIVE1MKHJlcGxhY2VJRHMoaXRlbS5ib2R5LCBpZCA/ICgpID0+IGlkICsgJ0lEJyArIGxvY2FsQ291bnRlcisrIDogJ2ljb25pZnlSZWFjdCcpKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3N2ZycsIGNvbXBvbmVudFByb3BzKTtcbiAgICB9XG4gICAgLy8gUmVuZGVyIDxzcGFuPiB3aXRoIHN0eWxlXG4gICAgY29uc3QgeyBib2R5LCB3aWR0aCwgaGVpZ2h0IH0gPSBpY29uO1xuICAgIGNvbnN0IHVzZU1hc2sgPSBtb2RlID09PSAnbWFzaycgfHxcbiAgICAgICAgKG1vZGUgPT09ICdiZycgPyBmYWxzZSA6IGJvZHkuaW5kZXhPZignY3VycmVudENvbG9yJykgIT09IC0xKTtcbiAgICAvLyBHZW5lcmF0ZSBTVkdcbiAgICBjb25zdCBodG1sID0gaWNvblRvSFRNTChib2R5LCB7XG4gICAgICAgIC4uLnJlbmRlckF0dHJpYnMsXG4gICAgICAgIHdpZHRoOiB3aWR0aCArICcnLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCArICcnLFxuICAgIH0pO1xuICAgIC8vIEdlbmVyYXRlIHN0eWxlXG4gICAgY29tcG9uZW50UHJvcHMuc3R5bGUgPSB7XG4gICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAnLS1zdmcnOiBzdmdUb1VSTChodG1sKSxcbiAgICAgICAgJ3dpZHRoJzogZml4U2l6ZShyZW5kZXJBdHRyaWJzLndpZHRoKSxcbiAgICAgICAgJ2hlaWdodCc6IGZpeFNpemUocmVuZGVyQXR0cmlicy5oZWlnaHQpLFxuICAgICAgICAuLi5jb21tb25Qcm9wcyxcbiAgICAgICAgLi4uKHVzZU1hc2sgPyBtb25vdG9uZVByb3BzIDogY29sb3JlZFByb3BzKSxcbiAgICAgICAgLi4uY3VzdG9tU3R5bGUsXG4gICAgfTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgnc3BhbicsIGNvbXBvbmVudFByb3BzKTtcbn07XG5cbi8qKlxuICogRW5hYmxlIGNhY2hlXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUNhY2hlKHN0b3JhZ2UpIHtcbiAgICB0b2dnbGVCcm93c2VyQ2FjaGUoc3RvcmFnZSwgdHJ1ZSk7XG59XG4vKipcbiAqIERpc2FibGUgY2FjaGVcbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUNhY2hlKHN0b3JhZ2UpIHtcbiAgICB0b2dnbGVCcm93c2VyQ2FjaGUoc3RvcmFnZSwgZmFsc2UpO1xufVxuLyoqXG4gKiBJbml0aWFsaXNlIHN0dWZmXG4gKi9cbi8vIEVuYWJsZSBzaG9ydCBuYW1lc1xuYWxsb3dTaW1wbGVOYW1lcyh0cnVlKTtcbi8vIFNldCBBUEkgbW9kdWxlXG5zZXRBUElNb2R1bGUoJycsIGZldGNoQVBJTW9kdWxlKTtcbi8qKlxuICogQnJvd3NlciBzdHVmZlxuICovXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIFNldCBjYWNoZSBhbmQgbG9hZCBleGlzdGluZyBjYWNoZVxuICAgIGluaXRCcm93c2VyU3RvcmFnZSgpO1xuICAgIGNvbnN0IF93aW5kb3cgPSB3aW5kb3c7XG4gICAgLy8gTG9hZCBpY29ucyBmcm9tIGdsb2JhbCBcIkljb25pZnlQcmVsb2FkXCJcbiAgICBpZiAoX3dpbmRvdy5JY29uaWZ5UHJlbG9hZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHByZWxvYWQgPSBfd2luZG93Lkljb25pZnlQcmVsb2FkO1xuICAgICAgICBjb25zdCBlcnIgPSAnSW52YWxpZCBJY29uaWZ5UHJlbG9hZCBzeW50YXguJztcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVsb2FkID09PSAnb2JqZWN0JyAmJiBwcmVsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAocHJlbG9hZCBpbnN0YW5jZW9mIEFycmF5ID8gcHJlbG9hZCA6IFtwcmVsb2FkXSkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXRlbSBpcyBhbiBvYmplY3QgYW5kIG5vdCBudWxsL2FycmF5XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSBpbnN0YW5jZW9mIEFycmF5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgJ2ljb25zJyBhbmQgJ3ByZWZpeCdcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVtLmljb25zICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGl0ZW0ucHJlZml4ICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGljb24gc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAhYWRkQ29sbGVjdGlvbihpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTZXQgQVBJIGZyb20gZ2xvYmFsIFwiSWNvbmlmeVByb3ZpZGVyc1wiXG4gICAgaWYgKF93aW5kb3cuSWNvbmlmeVByb3ZpZGVycyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVycyA9IF93aW5kb3cuSWNvbmlmeVByb3ZpZGVycztcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcnMgPT09ICdvYmplY3QnICYmIHByb3ZpZGVycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9ICdJY29uaWZ5UHJvdmlkZXJzWycgKyBrZXkgKyAnXSBpcyBpbnZhbGlkLic7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm92aWRlcnNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICF2YWx1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucmVzb3VyY2VzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWRkQVBJUHJvdmlkZXIoa2V5LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgSWNvbkNvbXBvbmVudCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgLy8gUmVuZGVyIHBsYWNlaG9sZGVyIGJlZm9yZSBjb21wb25lbnQgaXMgbW91bnRlZFxuICAgICAgICAgICAgaWNvbjogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWJvcnQgbG9hZGluZyBpY29uXG4gICAgICovXG4gICAgX2Fib3J0TG9hZGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xvYWRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRpbmcuYWJvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBzdGF0ZVxuICAgICAqL1xuICAgIF9zZXREYXRhKGljb24pIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuaWNvbiAhPT0gaWNvbikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgaWNvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGljb24gc2hvdWxkIGJlIGxvYWRlZFxuICAgICAqL1xuICAgIF9jaGVja0ljb24oY2hhbmdlZCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IGljb24gPSB0aGlzLnByb3BzLmljb247XG4gICAgICAgIC8vIEljb24gaXMgYW4gb2JqZWN0XG4gICAgICAgIGlmICh0eXBlb2YgaWNvbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIGljb24gIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBpY29uLmJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBTdG9wIGxvYWRpbmdcbiAgICAgICAgICAgIHRoaXMuX2ljb24gPSAnJztcbiAgICAgICAgICAgIHRoaXMuX2Fib3J0TG9hZGluZygpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWQgfHwgc3RhdGUuaWNvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFNldCBkYXRhIGlmIGl0IHdhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGljb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW52YWxpZCBpY29uP1xuICAgICAgICBsZXQgaWNvbk5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgaWNvbiAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIChpY29uTmFtZSA9IHN0cmluZ1RvSWNvbihpY29uLCBmYWxzZSwgdHJ1ZSkpID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9hYm9ydExvYWRpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldERhdGEobnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9hZCBpY29uXG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRJY29uRGF0YShpY29uTmFtZSk7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgLy8gSWNvbiBkYXRhIGlzIG5vdCBhdmFpbGFibGVcbiAgICAgICAgICAgIGlmICghdGhpcy5fbG9hZGluZyB8fCB0aGlzLl9sb2FkaW5nLm5hbWUgIT09IGljb24pIHtcbiAgICAgICAgICAgICAgICAvLyBOZXcgaWNvbiB0byBsb2FkXG4gICAgICAgICAgICAgICAgdGhpcy5fYWJvcnRMb2FkaW5nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faWNvbiA9ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldERhdGEobnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWNvbiB3YXMgbm90IGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2FkaW5nID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogaWNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0OiBsb2FkSWNvbnMoW2ljb25OYW1lXSwgdGhpcy5fY2hlY2tJY29uLmJpbmQodGhpcywgZmFsc2UpKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWNvbiBkYXRhIGlzIGF2YWlsYWJsZVxuICAgICAgICBpZiAodGhpcy5faWNvbiAhPT0gaWNvbiB8fCBzdGF0ZS5pY29uID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBOZXcgaWNvbiBvciBpY29uIGhhcyBiZWVuIGxvYWRlZFxuICAgICAgICAgICAgdGhpcy5fYWJvcnRMb2FkaW5nKCk7XG4gICAgICAgICAgICB0aGlzLl9pY29uID0gaWNvbjtcbiAgICAgICAgICAgIC8vIEFkZCBjbGFzc2VzXG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gWydpY29uaWZ5J107XG4gICAgICAgICAgICBpZiAoaWNvbk5hbWUucHJlZml4ICE9PSAnJykge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnaWNvbmlmeS0tJyArIGljb25OYW1lLnByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWNvbk5hbWUucHJvdmlkZXIgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdpY29uaWZ5LS0nICsgaWNvbk5hbWUucHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IGRhdGFcbiAgICAgICAgICAgIHRoaXMuX3NldERhdGEoe1xuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgY2xhc3NlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQoaWNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IG1vdW50ZWRcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tJY29uKGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IHVwZGF0ZWRcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRVcGRhdGUob2xkUHJvcHMpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzLmljb24gIT09IHRoaXMucHJvcHMuaWNvbikge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tJY29uKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFib3J0IGxvYWRpbmdcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5fYWJvcnRMb2FkaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlclxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBpY29uID0gdGhpcy5zdGF0ZS5pY29uO1xuICAgICAgICBpZiAoaWNvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUmVuZGVyIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICAgICAgICA/IHByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICAgICAgOiBSZWFjdC5jcmVhdGVFbGVtZW50KCdzcGFuJywge30pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBjbGFzc2VzXG4gICAgICAgIGxldCBuZXdQcm9wcyA9IHByb3BzO1xuICAgICAgICBpZiAoaWNvbi5jbGFzc2VzKSB7XG4gICAgICAgICAgICBuZXdQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICh0eXBlb2YgcHJvcHMuY2xhc3NOYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IHByb3BzLmNsYXNzTmFtZSArICcgJ1xuICAgICAgICAgICAgICAgICAgICA6ICcnKSArIGljb24uY2xhc3Nlcy5qb2luKCcgJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmRlciBpY29uXG4gICAgICAgIHJldHVybiByZW5kZXIoe1xuICAgICAgICAgICAgLi4uZGVmYXVsdEljb25Qcm9wcyxcbiAgICAgICAgICAgIC4uLmljb24uZGF0YSxcbiAgICAgICAgfSwgbmV3UHJvcHMsIHByb3BzLl9pbmxpbmUsIHByb3BzLl9yZWYpO1xuICAgIH1cbn1cbi8qKlxuICogQmxvY2sgaWNvblxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIENvbXBvbmVudCBwcm9wZXJ0aWVzXG4gKi9cbmNvbnN0IEljb24gPSBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEljb24ocHJvcHMsIHJlZikge1xuICAgIGNvbnN0IG5ld1Byb3BzID0ge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgX3JlZjogcmVmLFxuICAgICAgICBfaW5saW5lOiBmYWxzZSxcbiAgICB9O1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25Db21wb25lbnQsIG5ld1Byb3BzKTtcbn0pO1xuLyoqXG4gKiBJbmxpbmUgaWNvbiAoaGFzIG5lZ2F0aXZlIHZlcnRpY2FsQWxpZ24gdGhhdCBtYWtlcyBpdCBiZWhhdmUgbGlrZSBpY29uIGZvbnQpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gQ29tcG9uZW50IHByb3BlcnRpZXNcbiAqL1xuY29uc3QgSW5saW5lSWNvbiA9IFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gSW5saW5lSWNvbihwcm9wcywgcmVmKSB7XG4gICAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBfcmVmOiByZWYsXG4gICAgICAgIF9pbmxpbmU6IHRydWUsXG4gICAgfTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQ29tcG9uZW50LCBuZXdQcm9wcyk7XG59KTtcbi8qKlxuICogSW50ZXJuYWwgQVBJXG4gKi9cbmNvbnN0IF9hcGkgPSB7XG4gICAgZ2V0QVBJQ29uZmlnLFxuICAgIHNldEFQSU1vZHVsZSxcbiAgICBzZW5kQVBJUXVlcnksXG4gICAgc2V0RmV0Y2gsXG4gICAgZ2V0RmV0Y2gsXG4gICAgbGlzdEFQSVByb3ZpZGVycyxcbn07XG5cbmV4cG9ydHMuSWNvbiA9IEljb247XG5leHBvcnRzLklubGluZUljb24gPSBJbmxpbmVJY29uO1xuZXhwb3J0cy5fYXBpID0gX2FwaTtcbmV4cG9ydHMuYWRkQVBJUHJvdmlkZXIgPSBhZGRBUElQcm92aWRlcjtcbmV4cG9ydHMuYWRkQ29sbGVjdGlvbiA9IGFkZENvbGxlY3Rpb247XG5leHBvcnRzLmFkZEljb24gPSBhZGRJY29uO1xuZXhwb3J0cy5idWlsZEljb24gPSBpY29uVG9TVkc7XG5leHBvcnRzLmNhbGN1bGF0ZVNpemUgPSBjYWxjdWxhdGVTaXplO1xuZXhwb3J0cy5kaXNhYmxlQ2FjaGUgPSBkaXNhYmxlQ2FjaGU7XG5leHBvcnRzLmVuYWJsZUNhY2hlID0gZW5hYmxlQ2FjaGU7XG5leHBvcnRzLmdldEljb24gPSBnZXRJY29uO1xuZXhwb3J0cy5pY29uRXhpc3RzID0gaWNvbkV4aXN0cztcbmV4cG9ydHMubGlzdEljb25zID0gbGlzdEljb25zO1xuZXhwb3J0cy5sb2FkSWNvbiA9IGxvYWRJY29uO1xuZXhwb3J0cy5sb2FkSWNvbnMgPSBsb2FkSWNvbnM7XG5leHBvcnRzLnJlcGxhY2VJRHMgPSByZXBsYWNlSURzO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwicmVxdWlyZSIsIm1hdGNoSWNvbk5hbWUiLCJzdHJpbmdUb0ljb24iLCJ2YWx1ZSIsInZhbGlkYXRlIiwiYWxsb3dTaW1wbGVOYW1lIiwicHJvdmlkZXIiLCJjb2xvblNlcGFyYXRlZCIsInNwbGl0Iiwic2xpY2UiLCJsZW5ndGgiLCJzaGlmdCIsIm5hbWUyIiwicG9wIiwicHJlZml4IiwicmVzdWx0IiwibmFtZSIsInZhbGlkYXRlSWNvbk5hbWUiLCJkYXNoU2VwYXJhdGVkIiwiam9pbiIsImljb24iLCJtYXRjaCIsImRlZmF1bHRJY29uRGltZW5zaW9ucyIsIk9iamVjdCIsImZyZWV6ZSIsImxlZnQiLCJ0b3AiLCJ3aWR0aCIsImhlaWdodCIsImRlZmF1bHRJY29uVHJhbnNmb3JtYXRpb25zIiwicm90YXRlIiwidkZsaXAiLCJoRmxpcCIsImRlZmF1bHRJY29uUHJvcHMiLCJkZWZhdWx0RXh0ZW5kZWRJY29uUHJvcHMiLCJib2R5IiwiaGlkZGVuIiwibWVyZ2VJY29uVHJhbnNmb3JtYXRpb25zIiwib2JqMSIsIm9iajIiLCJtZXJnZUljb25EYXRhIiwicGFyZW50IiwiY2hpbGQiLCJrZXkiLCJnZXRJY29uc1RyZWUiLCJkYXRhIiwibmFtZXMiLCJpY29ucyIsImFsaWFzZXMiLCJjcmVhdGUiLCJyZXNvbHZlZCIsInJlc29sdmUiLCJjb25jYXQiLCJrZXlzIiwiZm9yRWFjaCIsImludGVybmFsR2V0SWNvbkRhdGEiLCJ0cmVlIiwiY3VycmVudFByb3BzIiwicGFyc2UiLCJwYXJzZUljb25TZXQiLCJjYWxsYmFjayIsIm5vdF9mb3VuZCIsIkFycmF5IiwicHVzaCIsIml0ZW0iLCJvcHRpb25hbFByb3BlcnR5RGVmYXVsdHMiLCJjaGVja09wdGlvbmFsUHJvcHMiLCJkZWZhdWx0cyIsInByb3AiLCJxdWlja2x5VmFsaWRhdGVJY29uU2V0Iiwib2JqIiwiZGF0YVN0b3JhZ2UiLCJuZXdTdG9yYWdlIiwibWlzc2luZyIsIlNldCIsImdldFN0b3JhZ2UiLCJwcm92aWRlclN0b3JhZ2UiLCJhZGRJY29uU2V0Iiwic3RvcmFnZSIsImFkZCIsImFkZEljb25Ub1N0b3JhZ2UiLCJlcnIiLCJsaXN0SWNvbnMiLCJhbGxJY29ucyIsInByb3ZpZGVycyIsInByb3ZpZGVyMiIsInByZWZpeGVzIiwicHJlZml4MiIsIm1hcCIsInNpbXBsZU5hbWVzIiwiYWxsb3dTaW1wbGVOYW1lcyIsImFsbG93IiwiZ2V0SWNvbkRhdGEiLCJpY29uTmFtZSIsImhhcyIsImFkZEljb24iLCJhZGRDb2xsZWN0aW9uIiwiYWRkZWQiLCJpY29uRXhpc3RzIiwiZ2V0SWNvbiIsImRlZmF1bHRJY29uU2l6ZUN1c3RvbWlzYXRpb25zIiwiZGVmYXVsdEljb25DdXN0b21pc2F0aW9ucyIsInVuaXRzU3BsaXQiLCJ1bml0c1Rlc3QiLCJjYWxjdWxhdGVTaXplIiwic2l6ZSIsInJhdGlvIiwicHJlY2lzaW9uIiwiTWF0aCIsImNlaWwiLCJvbGRQYXJ0cyIsIm5ld1BhcnRzIiwiY29kZSIsImlzTnVtYmVyIiwidGVzdCIsIm51bSIsInBhcnNlRmxvYXQiLCJpc05hTiIsImlzVW5zZXRLZXl3b3JkIiwiaWNvblRvU1ZHIiwiY3VzdG9taXNhdGlvbnMiLCJmdWxsSWNvbiIsImZ1bGxDdXN0b21pc2F0aW9ucyIsImJveCIsInByb3BzIiwidHJhbnNmb3JtYXRpb25zIiwicm90YXRpb24iLCJ0b1N0cmluZyIsInRlbXBWYWx1ZSIsImZsb29yIiwidW5zaGlmdCIsImN1c3RvbWlzYXRpb25zV2lkdGgiLCJjdXN0b21pc2F0aW9uc0hlaWdodCIsImJveFdpZHRoIiwiYm94SGVpZ2h0IiwiYXR0cmlidXRlcyIsInNldEF0dHIiLCJ2aWV3Qm94IiwicmVnZXgiLCJyYW5kb21QcmVmaXgiLCJEYXRlIiwibm93IiwicmFuZG9tIiwiY291bnRlciIsInJlcGxhY2VJRHMiLCJpZHMiLCJleGVjIiwic3VmZml4IiwiaWQiLCJuZXdJRCIsImVzY2FwZWRJRCIsInJlcGxhY2UiLCJSZWdFeHAiLCJzZXRBUElNb2R1bGUiLCJnZXRBUElNb2R1bGUiLCJjcmVhdGVBUElDb25maWciLCJzb3VyY2UiLCJyZXNvdXJjZXMiLCJwYXRoIiwibWF4VVJMIiwidGltZW91dCIsImluZGV4IiwiZGF0YUFmdGVyVGltZW91dCIsImNvbmZpZ1N0b3JhZ2UiLCJmYWxsQmFja0FQSVNvdXJjZXMiLCJmYWxsQmFja0FQSSIsImFkZEFQSVByb3ZpZGVyIiwiY3VzdG9tQ29uZmlnIiwiY29uZmlnIiwiZ2V0QVBJQ29uZmlnIiwibGlzdEFQSVByb3ZpZGVycyIsImRldGVjdEZldGNoIiwiZmV0Y2giLCJmZXRjaE1vZHVsZSIsInNldEZldGNoIiwiZmV0Y2gyIiwiZ2V0RmV0Y2giLCJjYWxjdWxhdGVNYXhMZW5ndGgiLCJtYXhIb3N0TGVuZ3RoIiwiaG9zdCIsIm1heCIsInVybCIsInNob3VsZEFib3J0Iiwic3RhdHVzIiwicHJlcGFyZSIsInJlc3VsdHMiLCJtYXhMZW5ndGgiLCJ0eXBlIiwiZ2V0UGF0aCIsInNlbmQiLCJwYXJhbXMiLCJpY29uc0xpc3QiLCJ1cmxQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ1cmkiLCJkZWZhdWx0RXJyb3IiLCJ0aGVuIiwicmVzcG9uc2UiLCJzZXRUaW1lb3V0IiwianNvbiIsImNhdGNoIiwiZmV0Y2hBUElNb2R1bGUiLCJzb3J0SWNvbnMiLCJsb2FkZWQiLCJwZW5kaW5nIiwic29ydCIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsImxhc3RJY29uIiwibG9jYWxTdG9yYWdlIiwibGlzdCIsInJlbW92ZUNhbGxiYWNrIiwic3RvcmFnZXMiLCJpdGVtcyIsImxvYWRlckNhbGxiYWNrcyIsImZpbHRlciIsInJvdyIsInVwZGF0ZUNhbGxiYWNrcyIsInBlbmRpbmdDYWxsYmFja3NGbGFnIiwiaGFzUGVuZGluZyIsIm9sZExlbmd0aCIsImFib3J0IiwiaWRDb3VudGVyIiwic3RvcmVDYWxsYmFjayIsInBlbmRpbmdTb3VyY2VzIiwiYmluZCIsImxpc3RUb0ljb25zIiwiZGVmYXVsdENvbmZpZyIsInNlbmRRdWVyeSIsInBheWxvYWQiLCJxdWVyeSIsImRvbmUiLCJyZXNvdXJjZXNDb3VudCIsInN0YXJ0SW5kZXgiLCJuZXh0SW5kZXgiLCJzdGFydFRpbWUiLCJxdWVyaWVzU2VudCIsImxhc3RFcnJvciIsInRpbWVyIiwicXVldWUiLCJkb25lQ2FsbGJhY2tzIiwicmVzZXRUaW1lciIsImNsZWFyVGltZW91dCIsInN1YnNjcmliZSIsIm92ZXJ3cml0ZSIsImdldFF1ZXJ5U3RhdHVzIiwicXVlcmllc1BlbmRpbmciLCJmYWlsUXVlcnkiLCJjbGVhclF1ZXVlIiwibW9kdWxlUmVzcG9uc2UiLCJpc0Vycm9yIiwicXVldWVkIiwiZXhlY05leHQiLCJpbmRleE9mIiwicmVzb3VyY2UiLCJzdGF0dXMyIiwiaW5pdFJlZHVuZGFuY3kiLCJjZmciLCJxdWVyaWVzIiwiY2xlYW51cCIsInF1ZXJ5Q2FsbGJhY2siLCJkb25lQ2FsbGJhY2siLCJxdWVyeTIiLCJlcnJvciIsImZpbmQiLCJpbnN0YW5jZSIsInNldEluZGV4IiwiZ2V0SW5kZXgiLCJlbXB0eUNhbGxiYWNrJDEiLCJyZWR1bmRhbmN5Q2FjaGUiLCJnZXRSZWR1bmRhbmN5Q2FjaGUiLCJyZWR1bmRhbmN5IiwiY2FjaGVkUmV1bmRhbmN5Iiwic2VuZEFQSVF1ZXJ5IiwidGFyZ2V0IiwiYXBpIiwiY2FjaGVkIiwibW9kdWxlS2V5IiwiYnJvd3NlckNhY2hlVmVyc2lvbiIsImJyb3dzZXJDYWNoZVByZWZpeCIsImJyb3dzZXJDYWNoZUNvdW50S2V5IiwiYnJvd3NlckNhY2hlVmVyc2lvbktleSIsImJyb3dzZXJTdG9yYWdlSG91ciIsImJyb3dzZXJTdG9yYWdlQ2FjaGVFeHBpcmF0aW9uIiwiZ2V0U3RvcmVkSXRlbSIsImZ1bmMiLCJnZXRJdGVtIiwic2V0U3RvcmVkSXRlbSIsInNldEl0ZW0iLCJyZW1vdmVTdG9yZWRJdGVtIiwicmVtb3ZlSXRlbSIsInNldEJyb3dzZXJTdG9yYWdlSXRlbXNDb3VudCIsImdldEJyb3dzZXJTdG9yYWdlSXRlbXNDb3VudCIsInBhcnNlSW50IiwiYnJvd3NlclN0b3JhZ2VDb25maWciLCJsb2NhbCIsInNlc3Npb24iLCJicm93c2VyU3RvcmFnZUVtcHR5SXRlbXMiLCJicm93c2VyU3RvcmFnZVN0YXR1cyIsInNldEJyb3dzZXJTdG9yYWdlU3RhdHVzIiwiX3dpbmRvdyIsIndpbmRvdyIsImdldEJyb3dzZXJTdG9yYWdlIiwiYXR0ciIsIml0ZXJhdGVCcm93c2VyU3RvcmFnZSIsInZlcnNpb24iLCJ0b3RhbDIiLCJpIiwibWluVGltZSIsInBhcnNlSXRlbSIsIkpTT04iLCJ0b3RhbCIsImluaXRCcm93c2VyU3RvcmFnZSIsImljb25TZXQiLCJsYXN0TW9kaWZpZWQiLCJsYXN0TW9kaWZpZWRDYWNoZWQiLCJtaW4iLCJ1cGRhdGVMYXN0TW9kaWZpZWQiLCJsYXN0VmFsdWUiLCJzdG9yZUluQnJvd3NlclN0b3JhZ2UiLCJzdG9yZSIsInNldCIsImRlbGV0ZSIsImZyb20iLCJzdHJpbmdpZnkiLCJhc3NpZ24iLCJlbXB0eUNhbGxiYWNrIiwibG9hZGVkTmV3SWNvbnMiLCJpY29uc0xvYWRlckZsYWciLCJsb2FkTmV3SWNvbnMiLCJpY29uc1RvTG9hZCIsImljb25zUXVldWVGbGFnIiwiaWNvbnMyIiwicGFyc2VkIiwicGVuZGluZ0ljb25zIiwiY29uc29sZSIsImxvYWRJY29ucyIsImNsZWFuZWRJY29ucyIsInNvcnRlZEljb25zIiwiY2FsbENhbGxiYWNrIiwibmV3SWNvbnMiLCJzb3VyY2VzIiwibGFzdFByb3ZpZGVyIiwibGFzdFByZWZpeCIsInByb3ZpZGVyTmV3SWNvbnMiLCJwZW5kaW5nUXVldWUiLCJsb2FkSWNvbiIsIlByb21pc2UiLCJmdWxmaWxsIiwicmVqZWN0IiwiaWNvbk9iaiIsInRvZ2dsZUJyb3dzZXJDYWNoZSIsIm1lcmdlQ3VzdG9taXNhdGlvbnMiLCJ2YWx1ZVR5cGUiLCJzZXBhcmF0b3IiLCJmbGlwRnJvbVN0cmluZyIsImN1c3RvbSIsImZsaXAiLCJzdHIiLCJ0cmltIiwicm90YXRlRnJvbVN0cmluZyIsImRlZmF1bHRWYWx1ZSIsInVuaXRzIiwidmFsdWUyIiwiaWNvblRvSFRNTCIsInJlbmRlckF0dHJpYnNIVE1MIiwiZW5jb2RlU1ZHZm9yVVJMIiwic3ZnIiwic3ZnVG9EYXRhIiwic3ZnVG9VUkwiLCJwb2xpY3kiLCJjcmVhdGVQb2xpY3kiLCJ0cnVzdGVkVHlwZXMiLCJjcmVhdGVIVE1MIiwicyIsImNsZWFuVXBJbm5lckhUTUwiLCJodG1sIiwiZGVmYXVsdEV4dGVuZGVkSWNvbkN1c3RvbWlzYXRpb25zIiwiaW5saW5lIiwic3ZnRGVmYXVsdHMiLCJjb21tb25Qcm9wcyIsImRpc3BsYXkiLCJtb25vdG9uZVByb3BzIiwiYmFja2dyb3VuZENvbG9yIiwiY29sb3JlZFByb3BzIiwicHJvcHNUb0FkZCIsIkltYWdlIiwiUmVwZWF0IiwiU2l6ZSIsInByb3BzVG9BZGRUbyIsIldlYmtpdE1hc2siLCJtYXNrIiwiYmFja2dyb3VuZCIsImlubGluZURlZmF1bHRzIiwiZml4U2l6ZSIsInJlbmRlciIsInJlZiIsImRlZmF1bHRQcm9wcyIsIm1vZGUiLCJzdHlsZSIsImN1c3RvbVN0eWxlIiwiY29tcG9uZW50UHJvcHMiLCJjb2xvciIsInJlbmRlckF0dHJpYnMiLCJ2ZXJ0aWNhbEFsaWduIiwibG9jYWxDb3VudGVyIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJfX2h0bWwiLCJjcmVhdGVFbGVtZW50IiwidXNlTWFzayIsImVuYWJsZUNhY2hlIiwiZGlzYWJsZUNhY2hlIiwiZG9jdW1lbnQiLCJJY29uaWZ5UHJlbG9hZCIsInByZWxvYWQiLCJlIiwiSWNvbmlmeVByb3ZpZGVycyIsIkljb25Db21wb25lbnQiLCJzdGF0ZSIsIl9hYm9ydExvYWRpbmciLCJfbG9hZGluZyIsIl9zZXREYXRhIiwic2V0U3RhdGUiLCJfY2hlY2tJY29uIiwiY2hhbmdlZCIsIl9pY29uIiwiY2xhc3NlcyIsIm9uTG9hZCIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50RGlkVXBkYXRlIiwib2xkUHJvcHMiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImNoaWxkcmVuIiwibmV3UHJvcHMiLCJjbGFzc05hbWUiLCJfaW5saW5lIiwiX3JlZiIsIkNvbXBvbmVudCIsIkljb24iLCJmb3J3YXJkUmVmIiwiSW5saW5lSWNvbiIsIl9hcGkiLCJleHBvcnRzIiwiYnVpbGRJY29uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@iconify+react@4.1.1_react@18.3.1/node_modules/@iconify/react/dist/iconify.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSPlugin.js":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSPlugin.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CSSPlugin: function() { return /* binding */ CSSPlugin; },\n/* harmony export */   _createElement: function() { return /* binding */ _createElement; },\n/* harmony export */   _getBBox: function() { return /* binding */ _getBBox; },\n/* harmony export */   checkPrefix: function() { return /* binding */ _checkPropPrefix; },\n/* harmony export */   \"default\": function() { return /* binding */ CSSPlugin; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_type_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_type_of */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_type_of.js\");\n/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/gsap-core.js\");\n/*!\n * CSSPlugin 3.12.5\n * https://gsap.com\n *\n * Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ \n\nvar _win, _doc, _docElement, _pluginInitted, _tempDiv, _tempDivStyler, _recentSetterPlugin, _reverting, _windowExists = function _windowExists() {\n    return typeof window !== \"undefined\";\n}, _transformProps = {}, _RAD2DEG = 180 / Math.PI, _DEG2RAD = Math.PI / 180, _atan2 = Math.atan2, _bigNum = 1e8, _capsExp = /([A-Z])/g, _horizontalExp = /(left|right|width|margin|padding|x)/i, _complexExp = /[\\s,\\(]\\S/, _propertyAliases = {\n    autoAlpha: \"opacity,visibility\",\n    scale: \"scaleX,scaleY\",\n    alpha: \"opacity\"\n}, _renderCSSProp = function _renderCSSProp(ratio, data) {\n    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\n}, _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {\n    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\n}, _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {\n    return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);\n}, //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)\n_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {\n    var value = data.s + data.c * ratio;\n    data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);\n}, _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {\n    return data.set(data.t, data.p, ratio ? data.e : data.b, data);\n}, _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {\n    return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);\n}, _setterCSSStyle = function _setterCSSStyle(target, property, value) {\n    return target.style[property] = value;\n}, _setterCSSProp = function _setterCSSProp(target, property, value) {\n    return target.style.setProperty(property, value);\n}, _setterTransform = function _setterTransform(target, property, value) {\n    return target._gsap[property] = value;\n}, _setterScale = function _setterScale(target, property, value) {\n    return target._gsap.scaleX = target._gsap.scaleY = value;\n}, _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {\n    var cache = target._gsap;\n    cache.scaleX = cache.scaleY = value;\n    cache.renderTransform(ratio, cache);\n}, _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {\n    var cache = target._gsap;\n    cache[property] = value;\n    cache.renderTransform(ratio, cache);\n}, _transformProp = \"transform\", _transformOriginProp = _transformProp + \"Origin\", _saveStyle = function _saveStyle(property, isNotCSS) {\n    var _this = this;\n    var target = this.target, style = target.style, cache = target._gsap;\n    if (property in _transformProps && style) {\n        this.tfm = this.tfm || {};\n        if (property !== \"transform\") {\n            property = _propertyAliases[property] || property;\n            ~property.indexOf(\",\") ? property.split(\",\").forEach(function(a) {\n                return _this.tfm[a] = _get(target, a);\n            }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property); // note: scale would map to \"scaleX,scaleY\", thus we loop and apply them both.\n            property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);\n        } else {\n            return _propertyAliases.transform.split(\",\").forEach(function(p) {\n                return _saveStyle.call(_this, p, isNotCSS);\n            });\n        }\n        if (this.props.indexOf(_transformProp) >= 0) {\n            return;\n        }\n        if (cache.svg) {\n            this.svgo = target.getAttribute(\"data-svg-origin\");\n            this.props.push(_transformOriginProp, isNotCSS, \"\");\n        }\n        property = _transformProp;\n    }\n    (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);\n}, _removeIndependentTransforms = function _removeIndependentTransforms(style) {\n    if (style.translate) {\n        style.removeProperty(\"translate\");\n        style.removeProperty(\"scale\");\n        style.removeProperty(\"rotate\");\n    }\n}, _revertStyle = function _revertStyle() {\n    var props = this.props, target = this.target, style = target.style, cache = target._gsap, i, p;\n    for(i = 0; i < props.length; i += 3){\n        // stored like this: property, isNotCSS, value\n        props[i + 1] ? target[props[i]] = props[i + 2] : props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === \"--\" ? props[i] : props[i].replace(_capsExp, \"-$1\").toLowerCase());\n    }\n    if (this.tfm) {\n        for(p in this.tfm){\n            cache[p] = this.tfm[p];\n        }\n        if (cache.svg) {\n            cache.renderTransform();\n            target.setAttribute(\"data-svg-origin\", this.svgo || \"\");\n        }\n        i = _reverting();\n        if ((!i || !i.isStart) && !style[_transformProp]) {\n            _removeIndependentTransforms(style);\n            if (cache.zOrigin && style[_transformOriginProp]) {\n                style[_transformOriginProp] += \" \" + cache.zOrigin + \"px\"; // since we're uncaching, we must put the zOrigin back into the transformOrigin so that we can pull it out accurately when we parse again. Otherwise, we'd lose the z portion of the origin since we extract it to protect from Safari bugs.\n                cache.zOrigin = 0;\n                cache.renderTransform();\n            }\n            cache.uncache = 1; // if it's a startAt that's being reverted in the _initTween() of the core, we don't need to uncache transforms. This is purely a performance optimization.\n        }\n    }\n}, _getStyleSaver = function _getStyleSaver(target, properties) {\n    var saver = {\n        target: target,\n        props: [],\n        revert: _revertStyle,\n        save: _saveStyle\n    };\n    target._gsap || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.getCache(target); // just make sure there's a _gsap cache defined because we read from it in _saveStyle() and it's more efficient to just check it here once.\n    properties && properties.split(\",\").forEach(function(p) {\n        return saver.save(p);\n    });\n    return saver;\n}, _supports3D, _createElement = function _createElement(type, ns) {\n    var e = _doc.createElementNS ? _doc.createElementNS((ns || \"http://www.w3.org/1999/xhtml\").replace(/^https/, \"http\"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making \"style\" inaccessible.\n    return e && e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://gsap.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).\n}, _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {\n    var cs = getComputedStyle(target);\n    return cs[property] || cs.getPropertyValue(property.replace(_capsExp, \"-$1\").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || \"\"; //css variables may not need caps swapped out for dashes and lowercase.\n}, _prefixes = \"O,Moz,ms,Ms,Webkit\".split(\",\"), _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {\n    var e = element || _tempDiv, s = e.style, i = 5;\n    if (property in s && !preferPrefix) {\n        return property;\n    }\n    property = property.charAt(0).toUpperCase() + property.substr(1);\n    while(i-- && !(_prefixes[i] + property in s)){}\n    return i < 0 ? null : (i === 3 ? \"ms\" : i >= 0 ? _prefixes[i] : \"\") + property;\n}, _initCore = function _initCore() {\n    if (_windowExists() && window.document) {\n        _win = window;\n        _doc = _win.document;\n        _docElement = _doc.documentElement;\n        _tempDiv = _createElement(\"div\") || {\n            style: {}\n        };\n        _tempDivStyler = _createElement(\"div\");\n        _transformProp = _checkPropPrefix(_transformProp);\n        _transformOriginProp = _transformProp + \"Origin\";\n        _tempDiv.style.cssText = \"border-width:0;line-height:0;position:absolute;padding:0\"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.\n        _supports3D = !!_checkPropPrefix(\"perspective\");\n        _reverting = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.reverting;\n        _pluginInitted = 1;\n    }\n}, _getBBoxHack = function _getBBoxHack(swapIfPossible) {\n    //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).\n    var svg = _createElement(\"svg\", this.ownerSVGElement && this.ownerSVGElement.getAttribute(\"xmlns\") || \"http://www.w3.org/2000/svg\"), oldParent = this.parentNode, oldSibling = this.nextSibling, oldCSS = this.style.cssText, bbox;\n    _docElement.appendChild(svg);\n    svg.appendChild(this);\n    this.style.display = \"block\";\n    if (swapIfPossible) {\n        try {\n            bbox = this.getBBox();\n            this._gsapBBox = this.getBBox; //store the original\n            this.getBBox = _getBBoxHack;\n        } catch (e) {}\n    } else if (this._gsapBBox) {\n        bbox = this._gsapBBox();\n    }\n    if (oldParent) {\n        if (oldSibling) {\n            oldParent.insertBefore(this, oldSibling);\n        } else {\n            oldParent.appendChild(this);\n        }\n    }\n    _docElement.removeChild(svg);\n    this.style.cssText = oldCSS;\n    return bbox;\n}, _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {\n    var i = attributesArray.length;\n    while(i--){\n        if (target.hasAttribute(attributesArray[i])) {\n            return target.getAttribute(attributesArray[i]);\n        }\n    }\n}, _getBBox = function _getBBox(target) {\n    var bounds;\n    try {\n        bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118\n    } catch (error) {\n        bounds = _getBBoxHack.call(target, true);\n    }\n    bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.\n    return bounds && !bounds.width && !bounds.x && !bounds.y ? {\n        x: +_getAttributeFallbacks(target, [\n            \"x\",\n            \"cx\",\n            \"x1\"\n        ]) || 0,\n        y: +_getAttributeFallbacks(target, [\n            \"y\",\n            \"cy\",\n            \"y1\"\n        ]) || 0,\n        width: 0,\n        height: 0\n    } : bounds;\n}, _isSVG = function _isSVG(e) {\n    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));\n}, //reports if the element is an SVG on which getBBox() actually works\n_removeProperty = function _removeProperty(target, property) {\n    if (property) {\n        var style = target.style, first2Chars;\n        if (property in _transformProps && property !== _transformOriginProp) {\n            property = _transformProp;\n        }\n        if (style.removeProperty) {\n            first2Chars = property.substr(0, 2);\n            if (first2Chars === \"ms\" || property.substr(0, 6) === \"webkit\") {\n                //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be \"ms-transform\" instead of \"-ms-transform\" for IE9, for example)\n                property = \"-\" + property;\n            }\n            style.removeProperty(first2Chars === \"--\" ? property : property.replace(_capsExp, \"-$1\").toLowerCase());\n        } else {\n            //note: old versions of IE use \"removeAttribute()\" instead of \"removeProperty()\"\n            style.removeAttribute(property);\n        }\n    }\n}, _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {\n    var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);\n    plugin._pt = pt;\n    pt.b = beginning;\n    pt.e = end;\n    plugin._props.push(property);\n    return pt;\n}, _nonConvertibleUnits = {\n    deg: 1,\n    rad: 1,\n    turn: 1\n}, _nonStandardLayouts = {\n    grid: 1,\n    flex: 1\n}, //takes a single value like 20px and converts it to the unit specified, like \"%\", returning only the numeric amount.\n_convertToUnit = function _convertToUnit(target, property, value, unit) {\n    var curValue = parseFloat(value) || 0, curUnit = (value + \"\").trim().substr((curValue + \"\").length) || \"px\", // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()\n    style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === \"svg\", measureProperty = (isRootSVG ? \"client\" : \"offset\") + (horizontal ? \"Width\" : \"Height\"), amount = 100, toPixels = unit === \"px\", toPercent = unit === \"%\", px, parent, cache, isSVG;\n    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {\n        return curValue;\n    }\n    curUnit !== \"px\" && !toPixels && (curValue = _convertToUnit(target, property, value, \"px\"));\n    isSVG = target.getCTM && _isSVG(target);\n    if ((toPercent || curUnit === \"%\") && (_transformProps[property] || ~property.indexOf(\"adius\"))) {\n        px = isSVG ? target.getBBox()[horizontal ? \"width\" : \"height\"] : target[measureProperty];\n        return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPercent ? curValue / px * amount : curValue / 100 * px);\n    }\n    style[horizontal ? \"width\" : \"height\"] = amount + (toPixels ? curUnit : unit);\n    parent = ~property.indexOf(\"adius\") || unit === \"em\" && target.appendChild && !isRootSVG ? target : target.parentNode;\n    if (isSVG) {\n        parent = (target.ownerSVGElement || {}).parentNode;\n    }\n    if (!parent || parent === _doc || !parent.appendChild) {\n        parent = _doc.body;\n    }\n    cache = parent._gsap;\n    if (cache && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time && !cache.uncache) {\n        return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(curValue / cache.width * amount);\n    } else {\n        if (toPercent && (property === \"height\" || property === \"width\")) {\n            // if we're dealing with width/height that's inside a container with padding and/or it's a flexbox/grid container, we must apply it to the target itself rather than the _tempDiv in order to ensure complete accuracy, factoring in the parent's padding.\n            var v = target.style[property];\n            target.style[property] = amount + unit;\n            px = target[measureProperty];\n            v ? target.style[property] = v : _removeProperty(target, property);\n        } else {\n            (toPercent || curUnit === \"%\") && !_nonStandardLayouts[_getComputedProperty(parent, \"display\")] && (style.position = _getComputedProperty(target, \"position\"));\n            parent === target && (style.position = \"static\"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.\n            parent.appendChild(_tempDiv);\n            px = _tempDiv[measureProperty];\n            parent.removeChild(_tempDiv);\n            style.position = \"absolute\";\n        }\n        if (horizontal && toPercent) {\n            cache = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(parent);\n            cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time;\n            cache.width = parent[measureProperty];\n        }\n    }\n    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);\n}, _get = function _get(target, property, unit, uncache) {\n    var value;\n    _pluginInitted || _initCore();\n    if (property in _propertyAliases && property !== \"transform\") {\n        property = _propertyAliases[property];\n        if (~property.indexOf(\",\")) {\n            property = property.split(\",\")[0];\n        }\n    }\n    if (_transformProps[property] && property !== \"transform\") {\n        value = _parseTransform(target, uncache);\n        value = property !== \"transformOrigin\" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + \" \" + value.zOrigin + \"px\";\n    } else {\n        value = target.style[property];\n        if (!value || value === \"auto\" || uncache || ~(value + \"\").indexOf(\"calc(\")) {\n            value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getProperty)(target, property) || (property === \"opacity\" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius\n        }\n    }\n    return unit && !~(value + \"\").trim().indexOf(\" \") ? _convertToUnit(target, property, value, unit) + unit : value;\n}, _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {\n    // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\n    if (!start || start === \"none\") {\n        // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style (\"clipPath\" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as \"none\" whereas WebkitClipPath reports accurately like \"ellipse(100% 0% at 50% 0%)\", so in this case we must SWITCH to using the prefixed property instead. See https://gsap.com/forums/topic/18310-clippath-doesnt-work-on-ios/\n        var p = _checkPropPrefix(prop, target, 1), s = p && _getComputedProperty(target, p, 1);\n        if (s && s !== start) {\n            prop = p;\n            start = s;\n        } else if (prop === \"borderColor\") {\n            start = _getComputedProperty(target, \"borderTopColor\"); // Firefox bug: always reports \"borderColor\" as \"\", so we must fall back to borderTopColor. See https://gsap.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/\n        }\n    }\n    var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._renderComplexString), index = 0, matchIndex = 0, a, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;\n    pt.b = start;\n    pt.e = end;\n    start += \"\"; // ensure values are strings\n    end += \"\";\n    if (end === \"auto\") {\n        startValue = target.style[prop];\n        target.style[prop] = end;\n        end = _getComputedProperty(target, prop) || end;\n        startValue ? target.style[prop] = startValue : _removeProperty(target, prop);\n    }\n    a = [\n        start,\n        end\n    ];\n    (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorStringFilter)(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().\n    start = a[0];\n    end = a[1];\n    startValues = start.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];\n    endValues = end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];\n    if (endValues.length) {\n        while(result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.exec(end)){\n            endValue = result[0];\n            chunk = end.substring(index, result.index);\n            if (color) {\n                color = (color + 1) % 5;\n            } else if (chunk.substr(-5) === \"rgba(\" || chunk.substr(-5) === \"hsla(\") {\n                color = 1;\n            }\n            if (endValue !== (startValue = startValues[matchIndex++] || \"\")) {\n                startNum = parseFloat(startValue) || 0;\n                startUnit = startValue.substr((startNum + \"\").length);\n                endValue.charAt(1) === \"=\" && (endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, endValue) + startUnit);\n                endNum = parseFloat(endValue);\n                endUnit = endValue.substr((endNum + \"\").length);\n                index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.lastIndex - endUnit.length;\n                if (!endUnit) {\n                    //if something like \"perspective:300\" is passed in and we must add a unit to the end\n                    endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[prop] || startUnit;\n                    if (index === end.length) {\n                        end += endUnit;\n                        pt.e += endUnit;\n                    }\n                }\n                if (startUnit !== endUnit) {\n                    startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;\n                } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.\n                pt._pt = {\n                    _next: pt._pt,\n                    p: chunk || matchIndex === 1 ? chunk : \",\",\n                    //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n                    s: startNum,\n                    c: endNum - startNum,\n                    m: color && color < 4 || prop === \"zIndex\" ? Math.round : 0\n                };\n            }\n        }\n        pt.c = index < end.length ? end.substring(index, end.length) : \"\"; //we use the \"c\" of the PropTween to store the final part of the string (after the last number)\n    } else {\n        pt.r = prop === \"display\" && end === \"none\" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;\n    }\n    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).\n    this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus \"this\" would refer to the plugin.\n    return pt;\n}, _keywordToPercent = {\n    top: \"0%\",\n    bottom: \"100%\",\n    left: \"0%\",\n    right: \"100%\",\n    center: \"50%\"\n}, _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {\n    var split = value.split(\" \"), x = split[0], y = split[1] || \"50%\";\n    if (x === \"top\" || x === \"bottom\" || y === \"left\" || y === \"right\") {\n        //the user provided them in the wrong order, so flip them\n        value = x;\n        x = y;\n        y = value;\n    }\n    split[0] = _keywordToPercent[x] || x;\n    split[1] = _keywordToPercent[y] || y;\n    return split.join(\" \");\n}, _renderClearProps = function _renderClearProps(ratio, data) {\n    if (data.tween && data.tween._time === data.tween._dur) {\n        var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i;\n        if (props === \"all\" || props === true) {\n            style.cssText = \"\";\n            clearTransforms = 1;\n        } else {\n            props = props.split(\",\");\n            i = props.length;\n            while(--i > -1){\n                prop = props[i];\n                if (_transformProps[prop]) {\n                    clearTransforms = 1;\n                    prop = prop === \"transformOrigin\" ? _transformOriginProp : _transformProp;\n                }\n                _removeProperty(target, prop);\n            }\n        }\n        if (clearTransforms) {\n            _removeProperty(target, _transformProp);\n            if (cache) {\n                cache.svg && target.removeAttribute(\"transform\");\n                _parseTransform(target, 1); // force all the cached values back to \"normal\"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.\n                cache.uncache = 1;\n                _removeIndependentTransforms(style);\n            }\n        }\n    }\n}, // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.\n_specialProps = {\n    clearProps: function clearProps(plugin, target, property, endValue, tween) {\n        if (tween.data !== \"isFromStart\") {\n            var pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);\n            pt.u = endValue;\n            pt.pr = -10;\n            pt.tween = tween;\n            plugin._props.push(property);\n            return 1;\n        }\n    }\n}, /*\n * --------------------------------------------------------------------------------------\n * TRANSFORMS\n * --------------------------------------------------------------------------------------\n */ _identity2DMatrix = [\n    1,\n    0,\n    0,\n    1,\n    0,\n    0\n], _rotationalProperties = {}, _isNullTransform = function _isNullTransform(value) {\n    return value === \"matrix(1, 0, 0, 1, 0, 0)\" || value === \"none\" || !value;\n}, _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {\n    var matrixString = _getComputedProperty(target, _transformProp);\n    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numExp).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round);\n}, _getMatrix = function _getMatrix(target, force2D) {\n    var cache = target._gsap || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent, nextSibling, temp, addedToDOM;\n    if (cache.svg && target.getAttribute(\"transform\")) {\n        temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like \"translate(50,60) rotate(135,0,0)\" are parsed because it mashes it into a matrix.\n        matrix = [\n            temp.a,\n            temp.b,\n            temp.c,\n            temp.d,\n            temp.e,\n            temp.f\n        ];\n        return matrix.join(\",\") === \"1,0,0,1,0,0\" ? _identity2DMatrix : matrix;\n    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {\n        //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n        //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not \"none\". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).\n        temp = style.display;\n        style.display = \"block\";\n        parent = target.parentNode;\n        if (!parent || !target.offsetParent) {\n            // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375\n            addedToDOM = 1; //flag\n            nextSibling = target.nextElementSibling;\n            _docElement.appendChild(target); //we must add it to the DOM in order to get values properly\n        }\n        matrix = _getComputedTransformMatrixAsArray(target);\n        temp ? style.display = temp : _removeProperty(target, \"display\");\n        if (addedToDOM) {\n            nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);\n        }\n    }\n    return force2D && matrix.length > 6 ? [\n        matrix[0],\n        matrix[1],\n        matrix[4],\n        matrix[5],\n        matrix[12],\n        matrix[13]\n    ] : matrix;\n}, _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {\n    var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a = matrix[0], b = matrix[1], c = matrix[2], d = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(\" \"), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x, y;\n    if (!originIsAbsolute) {\n        bounds = _getBBox(target);\n        xOrigin = bounds.x + (~originSplit[0].indexOf(\"%\") ? xOrigin / 100 * bounds.width : xOrigin);\n        yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf(\"%\") ? yOrigin / 100 * bounds.height : yOrigin); // if (!(\"xOrigin\" in cache) && (xOrigin || yOrigin)) { // added in 3.12.3, reverted in 3.12.4; requires more exploration\n    // \txOrigin -= bounds.x;\n    // \tyOrigin -= bounds.y;\n    // }\n    } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {\n        //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.\n        x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;\n        y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;\n        xOrigin = x;\n        yOrigin = y; // theory: we only had to do this for smoothing and it assumes that the previous one was not originIsAbsolute.\n    }\n    if (smooth || smooth !== false && cache.smooth) {\n        tx = xOrigin - xOriginOld;\n        ty = yOrigin - yOriginOld;\n        cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;\n        cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;\n    } else {\n        cache.xOffset = cache.yOffset = 0;\n    }\n    cache.xOrigin = xOrigin;\n    cache.yOrigin = yOrigin;\n    cache.smooth = !!smooth;\n    cache.origin = origin;\n    cache.originIsAbsolute = !!originIsAbsolute;\n    target.style[_transformOriginProp] = \"0px 0px\"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).\n    if (pluginToAddPropTweensTo) {\n        _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOrigin\", xOriginOld, xOrigin);\n        _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOrigin\", yOriginOld, yOrigin);\n        _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOffset\", xOffsetOld, cache.xOffset);\n        _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOffset\", yOffsetOld, cache.yOffset);\n    }\n    target.setAttribute(\"data-svg-origin\", xOrigin + \" \" + yOrigin);\n}, _parseTransform = function _parseTransform(target, uncache) {\n    var cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.GSCache(target);\n    if (\"x\" in cache && !uncache && !cache.uncache) {\n        return cache;\n    }\n    var style = target.style, invertedScaleX = cache.scaleX < 0, px = \"px\", deg = \"deg\", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || \"0\", x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;\n    x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;\n    scaleX = scaleY = 1;\n    cache.svg = !!(target.getCTM && _isSVG(target));\n    if (cs.translate) {\n        // accommodate independent transforms by combining them into normal ones.\n        if (cs.translate !== \"none\" || cs.scale !== \"none\" || cs.rotate !== \"none\") {\n            style[_transformProp] = (cs.translate !== \"none\" ? \"translate3d(\" + (cs.translate + \" 0 0\").split(\" \").slice(0, 3).join(\", \") + \") \" : \"\") + (cs.rotate !== \"none\" ? \"rotate(\" + cs.rotate + \") \" : \"\") + (cs.scale !== \"none\" ? \"scale(\" + cs.scale.split(\" \").join(\",\") + \") \" : \"\") + (cs[_transformProp] !== \"none\" ? cs[_transformProp] : \"\");\n        }\n        style.scale = style.rotate = style.translate = \"none\";\n    }\n    matrix = _getMatrix(target, cache.svg);\n    if (cache.svg) {\n        if (cache.uncache) {\n            // if cache.uncache is true (and maybe if origin is 0,0), we need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + \"px \" + (cache.yOrigin - bbox.y) + \"px\". Previously we let the data-svg-origin stay instead, but when introducing revert(), it complicated things.\n            t2 = target.getBBox();\n            origin = cache.xOrigin - t2.x + \"px \" + (cache.yOrigin - t2.y) + \"px\";\n            t1 = \"\";\n        } else {\n            t1 = !uncache && target.getAttribute(\"data-svg-origin\"); //  Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.\n        }\n        _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);\n    }\n    xOrigin = cache.xOrigin || 0;\n    yOrigin = cache.yOrigin || 0;\n    if (matrix !== _identity2DMatrix) {\n        a = matrix[0]; //a11\n        b = matrix[1]; //a21\n        c = matrix[2]; //a31\n        d = matrix[3]; //a41\n        x = a12 = matrix[4];\n        y = a22 = matrix[5]; //2D matrix\n        if (matrix.length === 6) {\n            scaleX = Math.sqrt(a * a + b * b);\n            scaleY = Math.sqrt(d * d + c * c);\n            rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).\n            skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;\n            skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));\n            if (cache.svg) {\n                x -= xOrigin - (xOrigin * a + yOrigin * c);\n                y -= yOrigin - (xOrigin * b + yOrigin * d);\n            } //3D matrix\n        } else {\n            a32 = matrix[6];\n            a42 = matrix[7];\n            a13 = matrix[8];\n            a23 = matrix[9];\n            a33 = matrix[10];\n            a43 = matrix[11];\n            x = matrix[12];\n            y = matrix[13];\n            z = matrix[14];\n            angle = _atan2(a32, a33);\n            rotationX = angle * _RAD2DEG; //rotationX\n            if (angle) {\n                cos = Math.cos(-angle);\n                sin = Math.sin(-angle);\n                t1 = a12 * cos + a13 * sin;\n                t2 = a22 * cos + a23 * sin;\n                t3 = a32 * cos + a33 * sin;\n                a13 = a12 * -sin + a13 * cos;\n                a23 = a22 * -sin + a23 * cos;\n                a33 = a32 * -sin + a33 * cos;\n                a43 = a42 * -sin + a43 * cos;\n                a12 = t1;\n                a22 = t2;\n                a32 = t3;\n            } //rotationY\n            angle = _atan2(-c, a33);\n            rotationY = angle * _RAD2DEG;\n            if (angle) {\n                cos = Math.cos(-angle);\n                sin = Math.sin(-angle);\n                t1 = a * cos - a13 * sin;\n                t2 = b * cos - a23 * sin;\n                t3 = c * cos - a33 * sin;\n                a43 = d * sin + a43 * cos;\n                a = t1;\n                b = t2;\n                c = t3;\n            } //rotationZ\n            angle = _atan2(b, a);\n            rotation = angle * _RAD2DEG;\n            if (angle) {\n                cos = Math.cos(angle);\n                sin = Math.sin(angle);\n                t1 = a * cos + b * sin;\n                t2 = a12 * cos + a22 * sin;\n                b = b * cos - a * sin;\n                a22 = a22 * cos - a12 * sin;\n                a = t1;\n                a12 = t2;\n            }\n            if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {\n                //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.\n                rotationX = rotation = 0;\n                rotationY = 180 - rotationY;\n            }\n            scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a * a + b * b + c * c));\n            scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a22 * a22 + a32 * a32));\n            angle = _atan2(a12, a22);\n            skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;\n            perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;\n        }\n        if (cache.svg) {\n            //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).\n            t1 = target.getAttribute(\"transform\");\n            cache.forceCSS = target.setAttribute(\"transform\", \"\") || !_isNullTransform(_getComputedProperty(target, _transformProp));\n            t1 && target.setAttribute(\"transform\", t1);\n        }\n    }\n    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {\n        if (invertedScaleX) {\n            scaleX *= -1;\n            skewX += rotation <= 0 ? 180 : -180;\n            rotation += rotation <= 0 ? 180 : -180;\n        } else {\n            scaleY *= -1;\n            skewX += skewX <= 0 ? 180 : -180;\n        }\n    }\n    uncache = uncache || cache.uncache;\n    cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;\n    cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;\n    cache.z = z + px;\n    cache.scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleX);\n    cache.scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleY);\n    cache.rotation = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotation) + deg;\n    cache.rotationX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationX) + deg;\n    cache.rotationY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationY) + deg;\n    cache.skewX = skewX + deg;\n    cache.skewY = skewY + deg;\n    cache.transformPerspective = perspective + px;\n    if (cache.zOrigin = parseFloat(origin.split(\" \")[2]) || !uncache && cache.zOrigin || 0) {\n        style[_transformOriginProp] = _firstTwoOnly(origin);\n    }\n    cache.xOffset = cache.yOffset = 0;\n    cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.force3D;\n    cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;\n    cache.uncache = 0;\n    return cache;\n}, _firstTwoOnly = function _firstTwoOnly(value) {\n    return (value = value.split(\" \"))[0] + \" \" + value[1];\n}, //for handling transformOrigin values, stripping out the 3rd dimension\n_addPxTranslate = function _addPxTranslate(target, start, value) {\n    var unit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(start);\n    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(parseFloat(start) + parseFloat(_convertToUnit(target, \"x\", value + \"px\", unit))) + unit;\n}, _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {\n    cache.z = \"0px\";\n    cache.rotationY = cache.rotationX = \"0deg\";\n    cache.force3D = 0;\n    _renderCSSTransforms(ratio, cache);\n}, _zeroDeg = \"0deg\", _zeroPx = \"0px\", _endParenthesis = \") \", _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {\n    var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x = _ref.x, y = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = \"\", use3D = force3D === \"auto\" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)\n    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {\n        var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;\n        angle = parseFloat(rotationX) * _DEG2RAD;\n        cos = Math.cos(angle);\n        x = _addPxTranslate(target, x, a13 * cos * -zOrigin);\n        y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);\n        z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);\n    }\n    if (transformPerspective !== _zeroPx) {\n        transforms += \"perspective(\" + transformPerspective + _endParenthesis;\n    }\n    if (xPercent || yPercent) {\n        transforms += \"translate(\" + xPercent + \"%, \" + yPercent + \"%) \";\n    }\n    if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {\n        transforms += z !== _zeroPx || use3D ? \"translate3d(\" + x + \", \" + y + \", \" + z + \") \" : \"translate(\" + x + \", \" + y + _endParenthesis;\n    }\n    if (rotation !== _zeroDeg) {\n        transforms += \"rotate(\" + rotation + _endParenthesis;\n    }\n    if (rotationY !== _zeroDeg) {\n        transforms += \"rotateY(\" + rotationY + _endParenthesis;\n    }\n    if (rotationX !== _zeroDeg) {\n        transforms += \"rotateX(\" + rotationX + _endParenthesis;\n    }\n    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {\n        transforms += \"skew(\" + skewX + \", \" + skewY + _endParenthesis;\n    }\n    if (scaleX !== 1 || scaleY !== 1) {\n        transforms += \"scale(\" + scaleX + \", \" + scaleY + _endParenthesis;\n    }\n    target.style[_transformProp] = transforms || \"translate(0, 0)\";\n}, _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {\n    var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x = _ref2.x, y = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x), ty = parseFloat(y), a11, a21, a12, a22, temp;\n    rotation = parseFloat(rotation);\n    skewX = parseFloat(skewX);\n    skewY = parseFloat(skewY);\n    if (skewY) {\n        //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.\n        skewY = parseFloat(skewY);\n        skewX += skewY;\n        rotation += skewY;\n    }\n    if (rotation || skewX) {\n        rotation *= _DEG2RAD;\n        skewX *= _DEG2RAD;\n        a11 = Math.cos(rotation) * scaleX;\n        a21 = Math.sin(rotation) * scaleX;\n        a12 = Math.sin(rotation - skewX) * -scaleY;\n        a22 = Math.cos(rotation - skewX) * scaleY;\n        if (skewX) {\n            skewY *= _DEG2RAD;\n            temp = Math.tan(skewX - skewY);\n            temp = Math.sqrt(1 + temp * temp);\n            a12 *= temp;\n            a22 *= temp;\n            if (skewY) {\n                temp = Math.tan(skewY);\n                temp = Math.sqrt(1 + temp * temp);\n                a11 *= temp;\n                a21 *= temp;\n            }\n        }\n        a11 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a11);\n        a21 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a21);\n        a12 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a12);\n        a22 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a22);\n    } else {\n        a11 = scaleX;\n        a22 = scaleY;\n        a21 = a12 = 0;\n    }\n    if (tx && !~(x + \"\").indexOf(\"px\") || ty && !~(y + \"\").indexOf(\"px\")) {\n        tx = _convertToUnit(target, \"x\", x, \"px\");\n        ty = _convertToUnit(target, \"y\", y, \"px\");\n    }\n    if (xOrigin || yOrigin || xOffset || yOffset) {\n        tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);\n        ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);\n    }\n    if (xPercent || yPercent) {\n        //The SVG spec doesn't support percentage-based translation in the \"transform\" attribute, so we merge it into the translation to simulate it.\n        temp = target.getBBox();\n        tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xPercent / 100 * temp.width);\n        ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yPercent / 100 * temp.height);\n    }\n    temp = \"matrix(\" + a11 + \",\" + a21 + \",\" + a12 + \",\" + a22 + \",\" + tx + \",\" + ty + \")\";\n    target.setAttribute(\"transform\", temp);\n    forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the transform attribute changes!)\n}, _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {\n    var cap = 360, isString = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf(\"rad\") ? _RAD2DEG : 1), change = endNum - startNum, finalValue = startNum + change + \"deg\", direction, pt;\n    if (isString) {\n        direction = endValue.split(\"_\")[1];\n        if (direction === \"short\") {\n            change %= cap;\n            if (change !== change % (cap / 2)) {\n                change += change < 0 ? cap : -cap;\n            }\n        }\n        if (direction === \"cw\" && change < 0) {\n            change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;\n        } else if (direction === \"ccw\" && change > 0) {\n            change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;\n        }\n    }\n    plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);\n    pt.e = finalValue;\n    pt.u = \"deg\";\n    plugin._props.push(property);\n    return pt;\n}, _assign = function _assign(target, source) {\n    // Internet Explorer doesn't have Object.assign(), so we recreate it here.\n    for(var p in source){\n        target[p] = source[p];\n    }\n    return target;\n}, _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {\n    //for handling cases where someone passes in a whole transform string, like transform: \"scale(2, 3) rotate(20deg) translateY(30em)\"\n    var startCache = _assign({}, target._gsap), exclude = \"perspective,force3D,transformOrigin,svgOrigin\", style = target.style, endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit;\n    if (startCache.svg) {\n        startValue = target.getAttribute(\"transform\");\n        target.setAttribute(\"transform\", \"\");\n        style[_transformProp] = transforms;\n        endCache = _parseTransform(target, 1);\n        _removeProperty(target, _transformProp);\n        target.setAttribute(\"transform\", startValue);\n    } else {\n        startValue = getComputedStyle(target)[_transformProp];\n        style[_transformProp] = transforms;\n        endCache = _parseTransform(target, 1);\n        style[_transformProp] = startValue;\n    }\n    for(p in _transformProps){\n        startValue = startCache[p];\n        endValue = endCache[p];\n        if (startValue !== endValue && exclude.indexOf(p) < 0) {\n            //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.\n            startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);\n            endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);\n            startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);\n            endNum = parseFloat(endValue);\n            plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);\n            plugin._pt.u = endUnit || 0;\n            plugin._props.push(p);\n        }\n    }\n    _assign(endCache, startCache);\n}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.\n(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(\"padding,margin,Width,Radius\", function(name, index) {\n    var t = \"Top\", r = \"Right\", b = \"Bottom\", l = \"Left\", props = (index < 3 ? [\n        t,\n        r,\n        b,\n        l\n    ] : [\n        t + l,\n        t + r,\n        b + r,\n        b + l\n    ]).map(function(side) {\n        return index < 2 ? name + side : \"border\" + side + name;\n    });\n    _specialProps[index > 1 ? \"border\" + name : name] = function(plugin, target, property, endValue, tween) {\n        var a, vars;\n        if (arguments.length < 4) {\n            // getter, passed target, property, and unit (from _get())\n            a = props.map(function(prop) {\n                return _get(plugin, prop, property);\n            });\n            vars = a.join(\" \");\n            return vars.split(a[0]).length === 5 ? a[0] : vars;\n        }\n        a = (endValue + \"\").split(\" \");\n        vars = {};\n        props.forEach(function(prop, i) {\n            return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];\n        });\n        plugin.init(target, vars, tween);\n    };\n});\nvar CSSPlugin = {\n    name: \"css\",\n    register: _initCore,\n    targetTest: function targetTest(target) {\n        return target.style && target.nodeType;\n    },\n    init: function init(target, vars, tween, index, targets) {\n        var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps;\n        _pluginInitted || _initCore(); // we may call init() multiple times on the same plugin instance, like when adding special properties, so make sure we don't overwrite the revert data or inlineProps\n        this.styles = this.styles || _getStyleSaver(target);\n        inlineProps = this.styles.props;\n        this.tween = tween;\n        for(p in vars){\n            if (p === \"autoRound\") {\n                continue;\n            }\n            endValue = vars[p];\n            if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._plugins[p] && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._checkPlugin)(p, vars, tween, index, target, targets)) {\n                continue;\n            }\n            type = typeof endValue === \"undefined\" ? \"undefined\" : (0,_swc_helpers_type_of__WEBPACK_IMPORTED_MODULE_1__._)(endValue);\n            specialProp = _specialProps[p];\n            if (type === \"function\") {\n                endValue = endValue.call(tween, index, target, targets);\n                type = typeof endValue === \"undefined\" ? \"undefined\" : (0,_swc_helpers_type_of__WEBPACK_IMPORTED_MODULE_1__._)(endValue);\n            }\n            if (type === \"string\" && ~endValue.indexOf(\"random(\")) {\n                endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(endValue);\n            }\n            if (specialProp) {\n                specialProp(this, target, p, endValue, tween) && (hasPriority = 1);\n            } else if (p.substr(0, 2) === \"--\") {\n                //CSS variable\n                startValue = (getComputedStyle(target).getPropertyValue(p) + \"\").trim();\n                endValue += \"\";\n                _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.lastIndex = 0;\n                if (!_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.test(startValue)) {\n                    // colors don't have units\n                    startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);\n                    endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);\n                }\n                endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);\n                this.add(style, \"setProperty\", startValue, endValue, index, targets, 0, 0, p);\n                props.push(p);\n                inlineProps.push(p, 0, style[p]);\n            } else if (type !== \"undefined\") {\n                if (startAt && p in startAt) {\n                    // in case someone hard-codes a complex value as the start, like top: \"calc(2vh / 2)\". Without this, it'd use the computed value (always in px)\n                    startValue = typeof startAt[p] === \"function\" ? startAt[p].call(tween, index, target, targets) : startAt[p];\n                    (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(startValue) && ~startValue.indexOf(\"random(\") && (startValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(startValue));\n                    (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue + \"\") || startValue === \"auto\" || (startValue += _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(_get(target, p)) || \"\"); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.\n                    (startValue + \"\").charAt(1) === \"=\" && (startValue = _get(target, p)); // can't work with relative values\n                } else {\n                    startValue = _get(target, p);\n                }\n                startNum = parseFloat(startValue);\n                relative = type === \"string\" && endValue.charAt(1) === \"=\" && endValue.substr(0, 2);\n                relative && (endValue = endValue.substr(2));\n                endNum = parseFloat(endValue);\n                if (p in _propertyAliases) {\n                    if (p === \"autoAlpha\") {\n                        //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.\n                        if (startNum === 1 && _get(target, \"visibility\") === \"hidden\" && endNum) {\n                            //if visibility is initially set to \"hidden\", we should interpret that as intent to make opacity 0 (a convenience)\n                            startNum = 0;\n                        }\n                        inlineProps.push(\"visibility\", 0, style.visibility);\n                        _addNonTweeningPT(this, style, \"visibility\", startNum ? \"inherit\" : \"hidden\", endNum ? \"inherit\" : \"hidden\", !endNum);\n                    }\n                    if (p !== \"scale\" && p !== \"transform\") {\n                        p = _propertyAliases[p];\n                        ~p.indexOf(\",\") && (p = p.split(\",\")[0]);\n                    }\n                }\n                isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---\n                if (isTransformRelated) {\n                    this.styles.save(p);\n                    if (!transformPropTween) {\n                        cache = target._gsap;\n                        cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:\"translateX(50vw)\"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.\n                        smooth = vars.smoothOrigin !== false && cache.smooth;\n                        transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)\n                        transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.\n                    }\n                    if (p === \"scale\") {\n                        this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, cache, \"scaleY\", cache.scaleY, (relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);\n                        this._pt.u = 0;\n                        props.push(\"scaleY\", p);\n                        p += \"X\";\n                    } else if (p === \"transformOrigin\") {\n                        inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);\n                        endValue = _convertKeywordsToPercentages(endValue); //in case something like \"left top\" or \"bottom right\" is passed in. Convert to percentages.\n                        if (cache.svg) {\n                            _applySVGOrigin(target, endValue, 0, smooth, 0, this);\n                        } else {\n                            endUnit = parseFloat(endValue.split(\" \")[2]) || 0; //handle the zOrigin separately!\n                            endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, \"zOrigin\", cache.zOrigin, endUnit);\n                            _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));\n                        }\n                        continue;\n                    } else if (p === \"svgOrigin\") {\n                        _applySVGOrigin(target, endValue, 1, smooth, 0, this);\n                        continue;\n                    } else if (p in _rotationalProperties) {\n                        _addRotationalPropTween(this, cache, p, startNum, relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endValue) : endValue);\n                        continue;\n                    } else if (p === \"smoothOrigin\") {\n                        _addNonTweeningPT(this, cache, \"smooth\", cache.smooth, endValue);\n                        continue;\n                    } else if (p === \"force3D\") {\n                        cache[p] = endValue;\n                        continue;\n                    } else if (p === \"transform\") {\n                        _addRawTransformPTs(this, endValue, target);\n                        continue;\n                    }\n                } else if (!(p in style)) {\n                    p = _checkPropPrefix(p) || p;\n                }\n                if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {\n                    startUnit = (startValue + \"\").substr((startNum + \"\").length);\n                    endNum || (endNum = 0); // protect against NaN\n                    endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] : startUnit);\n                    startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));\n                    this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === \"px\" || p === \"zIndex\") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);\n                    this._pt.u = endUnit || 0;\n                    if (startUnit !== endUnit && endUnit !== \"%\") {\n                        //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a \"b\" (beginning) property and point to a render method that handles that. (performance optimization)\n                        this._pt.b = startValue;\n                        this._pt.r = _renderCSSPropWithBeginning;\n                    }\n                } else if (!(p in style)) {\n                    if (p in target) {\n                        //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.\n                        this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);\n                    } else if (p !== \"parseTransform\") {\n                        (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._missingPlugin)(p, endValue);\n                        continue;\n                    }\n                } else {\n                    _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);\n                }\n                isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p]));\n                props.push(p);\n            }\n        }\n        hasPriority && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._sortPropTweensByPriority)(this);\n    },\n    render: function render(ratio, data) {\n        if (data.tween._time || !_reverting()) {\n            var pt = data._pt;\n            while(pt){\n                pt.r(ratio, pt.d);\n                pt = pt._next;\n            }\n        } else {\n            data.styles.revert();\n        }\n    },\n    get: _get,\n    aliases: _propertyAliases,\n    getSetter: function getSetter(target, property, plugin) {\n        //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like \"x\" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.\n        var p = _propertyAliases[property];\n        p && p.indexOf(\",\") < 0 && (property = p);\n        return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, \"x\")) ? plugin && _recentSetterPlugin === plugin ? property === \"scale\" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === \"scale\" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf(\"-\") ? _setterCSSProp : (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getSetter)(target, property);\n    },\n    core: {\n        _removeProperty: _removeProperty,\n        _getMatrix: _getMatrix\n    }\n};\n_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.utils.checkPrefix = _checkPropPrefix;\n_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.getStyleSaver = _getStyleSaver;\n(function(positionAndScale, rotation, others, aliases) {\n    var all = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(positionAndScale + \",\" + rotation + \",\" + others, function(name) {\n        _transformProps[name] = 1;\n    });\n    (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(rotation, function(name) {\n        _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = \"deg\";\n        _rotationalProperties[name] = 1;\n    });\n    _propertyAliases[all[13]] = positionAndScale + \",\" + rotation;\n    (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(aliases, function(name) {\n        var split = name.split(\":\");\n        _propertyAliases[split[1]] = all[split[0]];\n    });\n})(\"x,y,z,scale,scaleX,scaleY,xPercent,yPercent\", \"rotation,rotationX,rotationY,skewX,skewY\", \"transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective\", \"0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY\");\n(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(\"x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective\", function(name) {\n    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = \"px\";\n});\n_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(CSSPlugin);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9DU1NQbHVnaW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCO0FBRU07QUFFeEIsSUFBSTJCLE1BQ0FDLE1BQ0FDLGFBQ0FDLGdCQUNBQyxVQUNBQyxnQkFDQUMscUJBQ0FDLFlBQ0FDLGdCQUFnQixTQUFTQTtJQUMzQixPQUFPLE9BQU9DLFdBQVc7QUFDM0IsR0FDSUMsa0JBQWtCLENBQUMsR0FDbkJDLFdBQVcsTUFBTUMsS0FBS0MsRUFBRSxFQUN4QkMsV0FBV0YsS0FBS0MsRUFBRSxHQUFHLEtBQ3JCRSxTQUFTSCxLQUFLSSxLQUFLLEVBQ25CQyxVQUFVLEtBQ1ZDLFdBQVcsWUFDWEMsaUJBQWlCLHdDQUNqQkMsY0FBYyxhQUNkQyxtQkFBbUI7SUFDckJDLFdBQVc7SUFDWEMsT0FBTztJQUNQQyxPQUFPO0FBQ1QsR0FDSUMsaUJBQWlCLFNBQVNBLGVBQWVDLEtBQUssRUFBRUMsSUFBSTtJQUN0RCxPQUFPQSxLQUFLQyxHQUFHLENBQUNELEtBQUtFLENBQUMsRUFBRUYsS0FBS0csQ0FBQyxFQUFFbEIsS0FBS21CLEtBQUssQ0FBQyxDQUFDSixLQUFLSyxDQUFDLEdBQUdMLEtBQUtNLENBQUMsR0FBR1AsS0FBSSxJQUFLLFNBQVMsUUFBUUMsS0FBS08sQ0FBQyxFQUFFUDtBQUNsRyxHQUNJUSxxQkFBcUIsU0FBU0EsbUJBQW1CVCxLQUFLLEVBQUVDLElBQUk7SUFDOUQsT0FBT0EsS0FBS0MsR0FBRyxDQUFDRCxLQUFLRSxDQUFDLEVBQUVGLEtBQUtHLENBQUMsRUFBRUosVUFBVSxJQUFJQyxLQUFLUyxDQUFDLEdBQUd4QixLQUFLbUIsS0FBSyxDQUFDLENBQUNKLEtBQUtLLENBQUMsR0FBR0wsS0FBS00sQ0FBQyxHQUFHUCxLQUFJLElBQUssU0FBUyxRQUFRQyxLQUFLTyxDQUFDLEVBQUVQO0FBQ3pILEdBQ0lVLDhCQUE4QixTQUFTQSw0QkFBNEJYLEtBQUssRUFBRUMsSUFBSTtJQUNoRixPQUFPQSxLQUFLQyxHQUFHLENBQUNELEtBQUtFLENBQUMsRUFBRUYsS0FBS0csQ0FBQyxFQUFFSixRQUFRZCxLQUFLbUIsS0FBSyxDQUFDLENBQUNKLEtBQUtLLENBQUMsR0FBR0wsS0FBS00sQ0FBQyxHQUFHUCxLQUFJLElBQUssU0FBUyxRQUFRQyxLQUFLTyxDQUFDLEdBQUdQLEtBQUtXLENBQUMsRUFBRVg7QUFDbkgsR0FDSSxrSUFBa0k7QUFDdElZLHdCQUF3QixTQUFTQSxzQkFBc0JiLEtBQUssRUFBRUMsSUFBSTtJQUNoRSxJQUFJYSxRQUFRYixLQUFLSyxDQUFDLEdBQUdMLEtBQUtNLENBQUMsR0FBR1A7SUFDOUJDLEtBQUtDLEdBQUcsQ0FBQ0QsS0FBS0UsQ0FBQyxFQUFFRixLQUFLRyxDQUFDLEVBQUUsQ0FBQyxDQUFFVSxDQUFBQSxRQUFTQSxDQUFBQSxRQUFRLElBQUksQ0FBQyxLQUFLLEVBQUMsQ0FBQyxJQUFLYixLQUFLTyxDQUFDLEVBQUVQO0FBQ3hFLEdBQ0ljLDBCQUEwQixTQUFTQSx3QkFBd0JmLEtBQUssRUFBRUMsSUFBSTtJQUN4RSxPQUFPQSxLQUFLQyxHQUFHLENBQUNELEtBQUtFLENBQUMsRUFBRUYsS0FBS0csQ0FBQyxFQUFFSixRQUFRQyxLQUFLUyxDQUFDLEdBQUdULEtBQUtXLENBQUMsRUFBRVg7QUFDM0QsR0FDSWUsbUNBQW1DLFNBQVNBLGlDQUFpQ2hCLEtBQUssRUFBRUMsSUFBSTtJQUMxRixPQUFPQSxLQUFLQyxHQUFHLENBQUNELEtBQUtFLENBQUMsRUFBRUYsS0FBS0csQ0FBQyxFQUFFSixVQUFVLElBQUlDLEtBQUtXLENBQUMsR0FBR1gsS0FBS1MsQ0FBQyxFQUFFVDtBQUNqRSxHQUNJZ0Isa0JBQWtCLFNBQVNBLGdCQUFnQkMsTUFBTSxFQUFFQyxRQUFRLEVBQUVMLEtBQUs7SUFDcEUsT0FBT0ksT0FBT0UsS0FBSyxDQUFDRCxTQUFTLEdBQUdMO0FBQ2xDLEdBQ0lPLGlCQUFpQixTQUFTQSxlQUFlSCxNQUFNLEVBQUVDLFFBQVEsRUFBRUwsS0FBSztJQUNsRSxPQUFPSSxPQUFPRSxLQUFLLENBQUNFLFdBQVcsQ0FBQ0gsVUFBVUw7QUFDNUMsR0FDSVMsbUJBQW1CLFNBQVNBLGlCQUFpQkwsTUFBTSxFQUFFQyxRQUFRLEVBQUVMLEtBQUs7SUFDdEUsT0FBT0ksT0FBT00sS0FBSyxDQUFDTCxTQUFTLEdBQUdMO0FBQ2xDLEdBQ0lXLGVBQWUsU0FBU0EsYUFBYVAsTUFBTSxFQUFFQyxRQUFRLEVBQUVMLEtBQUs7SUFDOUQsT0FBT0ksT0FBT00sS0FBSyxDQUFDRSxNQUFNLEdBQUdSLE9BQU9NLEtBQUssQ0FBQ0csTUFBTSxHQUFHYjtBQUNyRCxHQUNJYyx5QkFBeUIsU0FBU0EsdUJBQXVCVixNQUFNLEVBQUVDLFFBQVEsRUFBRUwsS0FBSyxFQUFFYixJQUFJLEVBQUVELEtBQUs7SUFDL0YsSUFBSTZCLFFBQVFYLE9BQU9NLEtBQUs7SUFDeEJLLE1BQU1ILE1BQU0sR0FBR0csTUFBTUYsTUFBTSxHQUFHYjtJQUM5QmUsTUFBTUMsZUFBZSxDQUFDOUIsT0FBTzZCO0FBQy9CLEdBQ0lFLDZCQUE2QixTQUFTQSwyQkFBMkJiLE1BQU0sRUFBRUMsUUFBUSxFQUFFTCxLQUFLLEVBQUViLElBQUksRUFBRUQsS0FBSztJQUN2RyxJQUFJNkIsUUFBUVgsT0FBT00sS0FBSztJQUN4QkssS0FBSyxDQUFDVixTQUFTLEdBQUdMO0lBQ2xCZSxNQUFNQyxlQUFlLENBQUM5QixPQUFPNkI7QUFDL0IsR0FDSUcsaUJBQWlCLGFBQ2pCQyx1QkFBdUJELGlCQUFpQixVQUN4Q0UsYUFBYSxTQUFTQSxXQUFXZixRQUFRLEVBQUVnQixRQUFRO0lBQ3JELElBQUlDLFFBQVEsSUFBSTtJQUVoQixJQUFJbEIsU0FBUyxJQUFJLENBQUNBLE1BQU0sRUFDcEJFLFFBQVFGLE9BQU9FLEtBQUssRUFDcEJTLFFBQVFYLE9BQU9NLEtBQUs7SUFFeEIsSUFBSUwsWUFBWW5DLG1CQUFtQm9DLE9BQU87UUFDeEMsSUFBSSxDQUFDaUIsR0FBRyxHQUFHLElBQUksQ0FBQ0EsR0FBRyxJQUFJLENBQUM7UUFFeEIsSUFBSWxCLGFBQWEsYUFBYTtZQUM1QkEsV0FBV3hCLGdCQUFnQixDQUFDd0IsU0FBUyxJQUFJQTtZQUN6QyxDQUFDQSxTQUFTbUIsT0FBTyxDQUFDLE9BQU9uQixTQUFTb0IsS0FBSyxDQUFDLEtBQUtDLE9BQU8sQ0FBQyxTQUFVQyxDQUFDO2dCQUM5RCxPQUFPTCxNQUFNQyxHQUFHLENBQUNJLEVBQUUsR0FBR0MsS0FBS3hCLFFBQVF1QjtZQUNyQyxLQUFLLElBQUksQ0FBQ0osR0FBRyxDQUFDbEIsU0FBUyxHQUFHVSxNQUFNYyxDQUFDLEdBQUdkLEtBQUssQ0FBQ1YsU0FBUyxHQUFHdUIsS0FBS3hCLFFBQVFDLFdBQVcsOEVBQThFO1lBRTVKQSxhQUFhYyx3QkFBeUIsS0FBSSxDQUFDSSxHQUFHLENBQUNPLE9BQU8sR0FBR2YsTUFBTWUsT0FBTztRQUN4RSxPQUFPO1lBQ0wsT0FBT2pELGlCQUFpQmtELFNBQVMsQ0FBQ04sS0FBSyxDQUFDLEtBQUtDLE9BQU8sQ0FBQyxTQUFVcEMsQ0FBQztnQkFDOUQsT0FBTzhCLFdBQVdZLElBQUksQ0FBQ1YsT0FBT2hDLEdBQUcrQjtZQUNuQztRQUNGO1FBRUEsSUFBSSxJQUFJLENBQUNZLEtBQUssQ0FBQ1QsT0FBTyxDQUFDTixtQkFBbUIsR0FBRztZQUMzQztRQUNGO1FBRUEsSUFBSUgsTUFBTW1CLEdBQUcsRUFBRTtZQUNiLElBQUksQ0FBQ0MsSUFBSSxHQUFHL0IsT0FBT2dDLFlBQVksQ0FBQztZQUNoQyxJQUFJLENBQUNILEtBQUssQ0FBQ0ksSUFBSSxDQUFDbEIsc0JBQXNCRSxVQUFVO1FBQ2xEO1FBRUFoQixXQUFXYTtJQUNiO0lBRUNaLENBQUFBLFNBQVNlLFFBQU8sS0FBTSxJQUFJLENBQUNZLEtBQUssQ0FBQ0ksSUFBSSxDQUFDaEMsVUFBVWdCLFVBQVVmLEtBQUssQ0FBQ0QsU0FBUztBQUM1RSxHQUNJaUMsK0JBQStCLFNBQVNBLDZCQUE2QmhDLEtBQUs7SUFDNUUsSUFBSUEsTUFBTWlDLFNBQVMsRUFBRTtRQUNuQmpDLE1BQU1rQyxjQUFjLENBQUM7UUFDckJsQyxNQUFNa0MsY0FBYyxDQUFDO1FBQ3JCbEMsTUFBTWtDLGNBQWMsQ0FBQztJQUN2QjtBQUNGLEdBQ0lDLGVBQWUsU0FBU0E7SUFDMUIsSUFBSVIsUUFBUSxJQUFJLENBQUNBLEtBQUssRUFDbEI3QixTQUFTLElBQUksQ0FBQ0EsTUFBTSxFQUNwQkUsUUFBUUYsT0FBT0UsS0FBSyxFQUNwQlMsUUFBUVgsT0FBT00sS0FBSyxFQUNwQmdDLEdBQ0FwRDtJQUVKLElBQUtvRCxJQUFJLEdBQUdBLElBQUlULE1BQU1VLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQ3BDLDhDQUE4QztRQUM5Q1QsS0FBSyxDQUFDUyxJQUFJLEVBQUUsR0FBR3RDLE1BQU0sQ0FBQzZCLEtBQUssQ0FBQ1MsRUFBRSxDQUFDLEdBQUdULEtBQUssQ0FBQ1MsSUFBSSxFQUFFLEdBQUdULEtBQUssQ0FBQ1MsSUFBSSxFQUFFLEdBQUdwQyxLQUFLLENBQUMyQixLQUFLLENBQUNTLEVBQUUsQ0FBQyxHQUFHVCxLQUFLLENBQUNTLElBQUksRUFBRSxHQUFHcEMsTUFBTWtDLGNBQWMsQ0FBQ1AsS0FBSyxDQUFDUyxFQUFFLENBQUNFLE1BQU0sQ0FBQyxHQUFHLE9BQU8sT0FBT1gsS0FBSyxDQUFDUyxFQUFFLEdBQUdULEtBQUssQ0FBQ1MsRUFBRSxDQUFDRyxPQUFPLENBQUNuRSxVQUFVLE9BQU9vRSxXQUFXO0lBQ2pOO0lBRUEsSUFBSSxJQUFJLENBQUN2QixHQUFHLEVBQUU7UUFDWixJQUFLakMsS0FBSyxJQUFJLENBQUNpQyxHQUFHLENBQUU7WUFDbEJSLEtBQUssQ0FBQ3pCLEVBQUUsR0FBRyxJQUFJLENBQUNpQyxHQUFHLENBQUNqQyxFQUFFO1FBQ3hCO1FBRUEsSUFBSXlCLE1BQU1tQixHQUFHLEVBQUU7WUFDYm5CLE1BQU1DLGVBQWU7WUFDckJaLE9BQU8yQyxZQUFZLENBQUMsbUJBQW1CLElBQUksQ0FBQ1osSUFBSSxJQUFJO1FBQ3REO1FBRUFPLElBQUkzRTtRQUVKLElBQUksQ0FBQyxDQUFDMkUsS0FBSyxDQUFDQSxFQUFFTSxPQUFPLEtBQUssQ0FBQzFDLEtBQUssQ0FBQ1ksZUFBZSxFQUFFO1lBQ2hEb0IsNkJBQTZCaEM7WUFFN0IsSUFBSVMsTUFBTWUsT0FBTyxJQUFJeEIsS0FBSyxDQUFDYSxxQkFBcUIsRUFBRTtnQkFDaERiLEtBQUssQ0FBQ2EscUJBQXFCLElBQUksTUFBTUosTUFBTWUsT0FBTyxHQUFHLE1BQU0sNE9BQTRPO2dCQUV2U2YsTUFBTWUsT0FBTyxHQUFHO2dCQUNoQmYsTUFBTUMsZUFBZTtZQUN2QjtZQUVBRCxNQUFNa0MsT0FBTyxHQUFHLEdBQUcsMkpBQTJKO1FBQ2hMO0lBQ0Y7QUFDRixHQUNJQyxpQkFBaUIsU0FBU0EsZUFBZTlDLE1BQU0sRUFBRStDLFVBQVU7SUFDN0QsSUFBSUMsUUFBUTtRQUNWaEQsUUFBUUE7UUFDUjZCLE9BQU8sRUFBRTtRQUNUb0IsUUFBUVo7UUFDUmEsTUFBTWxDO0lBQ1I7SUFDQWhCLE9BQU9NLEtBQUssSUFBSTdFLCtDQUFJQSxDQUFDMEgsSUFBSSxDQUFDQyxRQUFRLENBQUNwRCxTQUFTLDJJQUEySTtJQUV2TCtDLGNBQWNBLFdBQVcxQixLQUFLLENBQUMsS0FBS0MsT0FBTyxDQUFDLFNBQVVwQyxDQUFDO1FBQ3JELE9BQU84RCxNQUFNRSxJQUFJLENBQUNoRTtJQUNwQjtJQUNBLE9BQU84RDtBQUNULEdBQ0lLLGFBQ0FDLGlCQUFpQixTQUFTQSxlQUFlQyxJQUFJLEVBQUVDLEVBQUU7SUFDbkQsSUFBSWhFLElBQUluQyxLQUFLb0csZUFBZSxHQUFHcEcsS0FBS29HLGVBQWUsQ0FBQyxDQUFDRCxNQUFNLDhCQUE2QixFQUFHZixPQUFPLENBQUMsVUFBVSxTQUFTYyxRQUFRbEcsS0FBS3FHLGFBQWEsQ0FBQ0gsT0FBTywyR0FBMkc7SUFFblEsT0FBTy9ELEtBQUtBLEVBQUVVLEtBQUssR0FBR1YsSUFBSW5DLEtBQUtxRyxhQUFhLENBQUNILE9BQU8seWNBQXljO0FBQy9mLEdBQ0lJLHVCQUF1QixTQUFTQSxxQkFBcUIzRCxNQUFNLEVBQUVDLFFBQVEsRUFBRTJELGtCQUFrQjtJQUMzRixJQUFJQyxLQUFLQyxpQkFBaUI5RDtJQUMxQixPQUFPNkQsRUFBRSxDQUFDNUQsU0FBUyxJQUFJNEQsR0FBR0UsZ0JBQWdCLENBQUM5RCxTQUFTd0MsT0FBTyxDQUFDbkUsVUFBVSxPQUFPb0UsV0FBVyxPQUFPbUIsR0FBR0UsZ0JBQWdCLENBQUM5RCxhQUFhLENBQUMyRCxzQkFBc0JELHFCQUFxQjNELFFBQVFnRSxpQkFBaUIvRCxhQUFhQSxVQUFVLE1BQU0sSUFBSSx1RUFBdUU7QUFDL1MsR0FDSWdFLFlBQVkscUJBQXFCNUMsS0FBSyxDQUFDLE1BQ3ZDMkMsbUJBQW1CLFNBQVNBLGlCQUFpQi9ELFFBQVEsRUFBRWlFLE9BQU8sRUFBRUMsWUFBWTtJQUM5RSxJQUFJM0UsSUFBSTBFLFdBQVcxRyxVQUNmNEIsSUFBSUksRUFBRVUsS0FBSyxFQUNYb0MsSUFBSTtJQUVSLElBQUlyQyxZQUFZYixLQUFLLENBQUMrRSxjQUFjO1FBQ2xDLE9BQU9sRTtJQUNUO0lBRUFBLFdBQVdBLFNBQVNtRSxNQUFNLENBQUMsR0FBR0MsV0FBVyxLQUFLcEUsU0FBU3VDLE1BQU0sQ0FBQztJQUU5RCxNQUFPRixPQUFPLENBQUUyQixDQUFBQSxTQUFTLENBQUMzQixFQUFFLEdBQUdyQyxZQUFZYixDQUFBQSxFQUFJLENBQUM7SUFFaEQsT0FBT2tELElBQUksSUFBSSxPQUFPLENBQUNBLE1BQU0sSUFBSSxPQUFPQSxLQUFLLElBQUkyQixTQUFTLENBQUMzQixFQUFFLEdBQUcsRUFBQyxJQUFLckM7QUFDeEUsR0FDSXFFLFlBQVksU0FBU0E7SUFDdkIsSUFBSTFHLG1CQUFtQkMsT0FBTzBHLFFBQVEsRUFBRTtRQUN0Q25ILE9BQU9TO1FBQ1BSLE9BQU9ELEtBQUttSCxRQUFRO1FBQ3BCakgsY0FBY0QsS0FBS21ILGVBQWU7UUFDbENoSCxXQUFXOEYsZUFBZSxVQUFVO1lBQ2xDcEQsT0FBTyxDQUFDO1FBQ1Y7UUFDQXpDLGlCQUFpQjZGLGVBQWU7UUFDaEN4QyxpQkFBaUJrRCxpQkFBaUJsRDtRQUNsQ0MsdUJBQXVCRCxpQkFBaUI7UUFDeEN0RCxTQUFTMEMsS0FBSyxDQUFDdUUsT0FBTyxHQUFHLDREQUE0RCw2SEFBNkg7UUFFbE5wQixjQUFjLENBQUMsQ0FBQ1csaUJBQWlCO1FBQ2pDckcsYUFBYWxDLCtDQUFJQSxDQUFDMEgsSUFBSSxDQUFDdUIsU0FBUztRQUNoQ25ILGlCQUFpQjtJQUNuQjtBQUNGLEdBQ0lvSCxlQUFlLFNBQVNBLGFBQWFDLGNBQWM7SUFDckQsK2pCQUErakI7SUFDL2pCLElBQUk5QyxNQUFNd0IsZUFBZSxPQUFPLElBQUksQ0FBQ3VCLGVBQWUsSUFBSSxJQUFJLENBQUNBLGVBQWUsQ0FBQzdDLFlBQVksQ0FBQyxZQUFZLCtCQUNsRzhDLFlBQVksSUFBSSxDQUFDQyxVQUFVLEVBQzNCQyxhQUFhLElBQUksQ0FBQ0MsV0FBVyxFQUM3QkMsU0FBUyxJQUFJLENBQUNoRixLQUFLLENBQUN1RSxPQUFPLEVBQzNCVTtJQUVKN0gsWUFBWThILFdBQVcsQ0FBQ3REO0lBRXhCQSxJQUFJc0QsV0FBVyxDQUFDLElBQUk7SUFDcEIsSUFBSSxDQUFDbEYsS0FBSyxDQUFDbUYsT0FBTyxHQUFHO0lBRXJCLElBQUlULGdCQUFnQjtRQUNsQixJQUFJO1lBQ0ZPLE9BQU8sSUFBSSxDQUFDRyxPQUFPO1lBQ25CLElBQUksQ0FBQ0MsU0FBUyxHQUFHLElBQUksQ0FBQ0QsT0FBTyxFQUFFLG9CQUFvQjtZQUVuRCxJQUFJLENBQUNBLE9BQU8sR0FBR1g7UUFDakIsRUFBRSxPQUFPbkYsR0FBRyxDQUFDO0lBQ2YsT0FBTyxJQUFJLElBQUksQ0FBQytGLFNBQVMsRUFBRTtRQUN6QkosT0FBTyxJQUFJLENBQUNJLFNBQVM7SUFDdkI7SUFFQSxJQUFJVCxXQUFXO1FBQ2IsSUFBSUUsWUFBWTtZQUNkRixVQUFVVSxZQUFZLENBQUMsSUFBSSxFQUFFUjtRQUMvQixPQUFPO1lBQ0xGLFVBQVVNLFdBQVcsQ0FBQyxJQUFJO1FBQzVCO0lBQ0Y7SUFFQTlILFlBQVltSSxXQUFXLENBQUMzRDtJQUV4QixJQUFJLENBQUM1QixLQUFLLENBQUN1RSxPQUFPLEdBQUdTO0lBQ3JCLE9BQU9DO0FBQ1QsR0FDSU8seUJBQXlCLFNBQVNBLHVCQUF1QjFGLE1BQU0sRUFBRTJGLGVBQWU7SUFDbEYsSUFBSXJELElBQUlxRCxnQkFBZ0JwRCxNQUFNO0lBRTlCLE1BQU9ELElBQUs7UUFDVixJQUFJdEMsT0FBTzRGLFlBQVksQ0FBQ0QsZUFBZSxDQUFDckQsRUFBRSxHQUFHO1lBQzNDLE9BQU90QyxPQUFPZ0MsWUFBWSxDQUFDMkQsZUFBZSxDQUFDckQsRUFBRTtRQUMvQztJQUNGO0FBQ0YsR0FDSXVELFdBQVcsU0FBU0EsU0FBUzdGLE1BQU07SUFDckMsSUFBSThGO0lBRUosSUFBSTtRQUNGQSxTQUFTOUYsT0FBT3NGLE9BQU8sSUFBSSw4S0FBOEs7SUFDM00sRUFBRSxPQUFPUyxPQUFPO1FBQ2RELFNBQVNuQixhQUFhL0MsSUFBSSxDQUFDNUIsUUFBUTtJQUNyQztJQUVBOEYsVUFBV0EsQ0FBQUEsT0FBT0UsS0FBSyxJQUFJRixPQUFPRyxNQUFNLEtBQUtqRyxPQUFPc0YsT0FBTyxLQUFLWCxnQkFBaUJtQixDQUFBQSxTQUFTbkIsYUFBYS9DLElBQUksQ0FBQzVCLFFBQVEsS0FBSSxHQUFJLHlMQUF5TDtJQUVyVCxPQUFPOEYsVUFBVSxDQUFDQSxPQUFPRSxLQUFLLElBQUksQ0FBQ0YsT0FBT3JFLENBQUMsSUFBSSxDQUFDcUUsT0FBT0ksQ0FBQyxHQUFHO1FBQ3pEekUsR0FBRyxDQUFDaUUsdUJBQXVCMUYsUUFBUTtZQUFDO1lBQUs7WUFBTTtTQUFLLEtBQUs7UUFDekRrRyxHQUFHLENBQUNSLHVCQUF1QjFGLFFBQVE7WUFBQztZQUFLO1lBQU07U0FBSyxLQUFLO1FBQ3pEZ0csT0FBTztRQUNQQyxRQUFRO0lBQ1YsSUFBSUg7QUFDTixHQUNJSyxTQUFTLFNBQVNBLE9BQU8zRyxDQUFDO0lBQzVCLE9BQU8sQ0FBQyxDQUFFQSxDQUFBQSxFQUFFNEcsTUFBTSxJQUFLLEVBQUM1RyxFQUFFdUYsVUFBVSxJQUFJdkYsRUFBRXFGLGVBQWUsS0FBS2dCLFNBQVNyRyxFQUFDO0FBQzFFLEdBQ0ksb0VBQW9FO0FBQ3hFNkcsa0JBQWtCLFNBQVNBLGdCQUFnQnJHLE1BQU0sRUFBRUMsUUFBUTtJQUN6RCxJQUFJQSxVQUFVO1FBQ1osSUFBSUMsUUFBUUYsT0FBT0UsS0FBSyxFQUNwQm9HO1FBRUosSUFBSXJHLFlBQVluQyxtQkFBbUJtQyxhQUFhYyxzQkFBc0I7WUFDcEVkLFdBQVdhO1FBQ2I7UUFFQSxJQUFJWixNQUFNa0MsY0FBYyxFQUFFO1lBQ3hCa0UsY0FBY3JHLFNBQVN1QyxNQUFNLENBQUMsR0FBRztZQUVqQyxJQUFJOEQsZ0JBQWdCLFFBQVFyRyxTQUFTdUMsTUFBTSxDQUFDLEdBQUcsT0FBTyxVQUFVO2dCQUM5RCx3UUFBd1E7Z0JBQ3hRdkMsV0FBVyxNQUFNQTtZQUNuQjtZQUVBQyxNQUFNa0MsY0FBYyxDQUFDa0UsZ0JBQWdCLE9BQU9yRyxXQUFXQSxTQUFTd0MsT0FBTyxDQUFDbkUsVUFBVSxPQUFPb0UsV0FBVztRQUN0RyxPQUFPO1lBQ0wsZ0ZBQWdGO1lBQ2hGeEMsTUFBTXFHLGVBQWUsQ0FBQ3RHO1FBQ3hCO0lBQ0Y7QUFDRixHQUNJdUcsb0JBQW9CLFNBQVNBLGtCQUFrQkMsTUFBTSxFQUFFekcsTUFBTSxFQUFFQyxRQUFRLEVBQUV5RyxTQUFTLEVBQUVDLEdBQUcsRUFBRUMsWUFBWTtJQUN2RyxJQUFJQyxLQUFLLElBQUlwSyxvREFBU0EsQ0FBQ2dLLE9BQU9LLEdBQUcsRUFBRTlHLFFBQVFDLFVBQVUsR0FBRyxHQUFHMkcsZUFBZTlHLG1DQUFtQ0Q7SUFDN0c0RyxPQUFPSyxHQUFHLEdBQUdEO0lBQ2JBLEdBQUduSCxDQUFDLEdBQUdnSDtJQUNQRyxHQUFHckgsQ0FBQyxHQUFHbUg7SUFFUEYsT0FBT00sTUFBTSxDQUFDOUUsSUFBSSxDQUFDaEM7SUFFbkIsT0FBTzRHO0FBQ1QsR0FDSUcsdUJBQXVCO0lBQ3pCQyxLQUFLO0lBQ0xDLEtBQUs7SUFDTEMsTUFBTTtBQUNSLEdBQ0lDLHNCQUFzQjtJQUN4QkMsTUFBTTtJQUNOQyxNQUFNO0FBQ1IsR0FDSSxvSEFBb0g7QUFDeEhDLGlCQUFpQixTQUFTQSxlQUFldkgsTUFBTSxFQUFFQyxRQUFRLEVBQUVMLEtBQUssRUFBRTRILElBQUk7SUFDcEUsSUFBSUMsV0FBV0MsV0FBVzlILFVBQVUsR0FDaEMrSCxVQUFVLENBQUMvSCxRQUFRLEVBQUMsRUFBR2dJLElBQUksR0FBR3BGLE1BQU0sQ0FBQyxDQUFDaUYsV0FBVyxFQUFDLEVBQUdsRixNQUFNLEtBQUssTUFDaEUsbUdBQW1HO0lBQ3ZHckMsUUFBUTFDLFNBQVMwQyxLQUFLLEVBQ2xCMkgsYUFBYXRKLGVBQWV1SixJQUFJLENBQUM3SCxXQUNqQzhILFlBQVkvSCxPQUFPZ0ksT0FBTyxDQUFDdEYsV0FBVyxPQUFPLE9BQzdDdUYsa0JBQWtCLENBQUNGLFlBQVksV0FBVyxRQUFPLElBQU1GLENBQUFBLGFBQWEsVUFBVSxRQUFPLEdBQ3JGSyxTQUFTLEtBQ1RDLFdBQVdYLFNBQVMsTUFDcEJZLFlBQVlaLFNBQVMsS0FDckJhLElBQ0FDLFFBQ0EzSCxPQUNBNEg7SUFFSixJQUFJZixTQUFTRyxXQUFXLENBQUNGLFlBQVlULG9CQUFvQixDQUFDUSxLQUFLLElBQUlSLG9CQUFvQixDQUFDVyxRQUFRLEVBQUU7UUFDaEcsT0FBT0Y7SUFDVDtJQUVBRSxZQUFZLFFBQVEsQ0FBQ1EsWUFBYVYsQ0FBQUEsV0FBV0YsZUFBZXZILFFBQVFDLFVBQVVMLE9BQU8sS0FBSTtJQUN6RjJJLFFBQVF2SSxPQUFPb0csTUFBTSxJQUFJRCxPQUFPbkc7SUFFaEMsSUFBSSxDQUFDb0ksYUFBYVQsWUFBWSxHQUFFLEtBQU83SixDQUFBQSxlQUFlLENBQUNtQyxTQUFTLElBQUksQ0FBQ0EsU0FBU21CLE9BQU8sQ0FBQyxRQUFPLEdBQUk7UUFDL0ZpSCxLQUFLRSxRQUFRdkksT0FBT3NGLE9BQU8sRUFBRSxDQUFDdUMsYUFBYSxVQUFVLFNBQVMsR0FBRzdILE1BQU0sQ0FBQ2lJLGdCQUFnQjtRQUN4RixPQUFPckwscURBQU1BLENBQUN3TCxZQUFZWCxXQUFXWSxLQUFLSCxTQUFTVCxXQUFXLE1BQU1ZO0lBQ3RFO0lBRUFuSSxLQUFLLENBQUMySCxhQUFhLFVBQVUsU0FBUyxHQUFHSyxTQUFVQyxDQUFBQSxXQUFXUixVQUFVSCxJQUFHO0lBQzNFYyxTQUFTLENBQUNySSxTQUFTbUIsT0FBTyxDQUFDLFlBQVlvRyxTQUFTLFFBQVF4SCxPQUFPb0YsV0FBVyxJQUFJLENBQUMyQyxZQUFZL0gsU0FBU0EsT0FBTytFLFVBQVU7SUFFckgsSUFBSXdELE9BQU87UUFDVEQsU0FBUyxDQUFDdEksT0FBTzZFLGVBQWUsSUFBSSxDQUFDLEdBQUdFLFVBQVU7SUFDcEQ7SUFFQSxJQUFJLENBQUN1RCxVQUFVQSxXQUFXakwsUUFBUSxDQUFDaUwsT0FBT2xELFdBQVcsRUFBRTtRQUNyRGtELFNBQVNqTCxLQUFLbUwsSUFBSTtJQUNwQjtJQUVBN0gsUUFBUTJILE9BQU9oSSxLQUFLO0lBRXBCLElBQUlLLFNBQVN5SCxhQUFhekgsTUFBTXFGLEtBQUssSUFBSTZCLGNBQWNsSCxNQUFNOEgsSUFBSSxLQUFLOUwsa0RBQU9BLENBQUM4TCxJQUFJLElBQUksQ0FBQzlILE1BQU1rQyxPQUFPLEVBQUU7UUFDcEcsT0FBT2pHLHFEQUFNQSxDQUFDNkssV0FBVzlHLE1BQU1xRixLQUFLLEdBQUdrQztJQUN6QyxPQUFPO1FBQ0wsSUFBSUUsYUFBY25JLENBQUFBLGFBQWEsWUFBWUEsYUFBYSxPQUFNLEdBQUk7WUFDaEUsMFBBQTBQO1lBQzFQLElBQUl5SSxJQUFJMUksT0FBT0UsS0FBSyxDQUFDRCxTQUFTO1lBQzlCRCxPQUFPRSxLQUFLLENBQUNELFNBQVMsR0FBR2lJLFNBQVNWO1lBQ2xDYSxLQUFLckksTUFBTSxDQUFDaUksZ0JBQWdCO1lBQzVCUyxJQUFJMUksT0FBT0UsS0FBSyxDQUFDRCxTQUFTLEdBQUd5SSxJQUFJckMsZ0JBQWdCckcsUUFBUUM7UUFDM0QsT0FBTztZQUNKbUksQ0FBQUEsYUFBYVQsWUFBWSxHQUFFLEtBQU0sQ0FBQ1AsbUJBQW1CLENBQUN6RCxxQkFBcUIyRSxRQUFRLFdBQVcsSUFBS3BJLENBQUFBLE1BQU15SSxRQUFRLEdBQUdoRixxQkFBcUIzRCxRQUFRLFdBQVU7WUFDNUpzSSxXQUFXdEksVUFBV0UsQ0FBQUEsTUFBTXlJLFFBQVEsR0FBRyxRQUFPLEdBQUksb1FBQW9RO1lBRXRUTCxPQUFPbEQsV0FBVyxDQUFDNUg7WUFDbkI2SyxLQUFLN0ssUUFBUSxDQUFDeUssZ0JBQWdCO1lBQzlCSyxPQUFPN0MsV0FBVyxDQUFDakk7WUFDbkIwQyxNQUFNeUksUUFBUSxHQUFHO1FBQ25CO1FBRUEsSUFBSWQsY0FBY08sV0FBVztZQUMzQnpILFFBQVE1RCx3REFBU0EsQ0FBQ3VMO1lBQ2xCM0gsTUFBTThILElBQUksR0FBRzlMLGtEQUFPQSxDQUFDOEwsSUFBSTtZQUN6QjlILE1BQU1xRixLQUFLLEdBQUdzQyxNQUFNLENBQUNMLGdCQUFnQjtRQUN2QztJQUNGO0lBRUEsT0FBT3JMLHFEQUFNQSxDQUFDdUwsV0FBV0UsS0FBS1osV0FBV1MsU0FBU0csTUFBTVosV0FBV1MsU0FBU0csS0FBS1osV0FBVztBQUM5RixHQUNJakcsT0FBTyxTQUFTQSxLQUFLeEIsTUFBTSxFQUFFQyxRQUFRLEVBQUV1SCxJQUFJLEVBQUUzRSxPQUFPO0lBQ3RELElBQUlqRDtJQUNKckMsa0JBQWtCK0c7SUFFbEIsSUFBSXJFLFlBQVl4QixvQkFBb0J3QixhQUFhLGFBQWE7UUFDNURBLFdBQVd4QixnQkFBZ0IsQ0FBQ3dCLFNBQVM7UUFFckMsSUFBSSxDQUFDQSxTQUFTbUIsT0FBTyxDQUFDLE1BQU07WUFDMUJuQixXQUFXQSxTQUFTb0IsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ25DO0lBQ0Y7SUFFQSxJQUFJdkQsZUFBZSxDQUFDbUMsU0FBUyxJQUFJQSxhQUFhLGFBQWE7UUFDekRMLFFBQVFnSixnQkFBZ0I1SSxRQUFRNkM7UUFDaENqRCxRQUFRSyxhQUFhLG9CQUFvQkwsS0FBSyxDQUFDSyxTQUFTLEdBQUdMLE1BQU1rQyxHQUFHLEdBQUdsQyxNQUFNaUosTUFBTSxHQUFHQyxjQUFjbkYscUJBQXFCM0QsUUFBUWUseUJBQXlCLE1BQU1uQixNQUFNOEIsT0FBTyxHQUFHO0lBQ2xMLE9BQU87UUFDTDlCLFFBQVFJLE9BQU9FLEtBQUssQ0FBQ0QsU0FBUztRQUU5QixJQUFJLENBQUNMLFNBQVNBLFVBQVUsVUFBVWlELFdBQVcsQ0FBQyxDQUFDakQsUUFBUSxFQUFDLEVBQUd3QixPQUFPLENBQUMsVUFBVTtZQUMzRXhCLFFBQVFtSixhQUFhLENBQUM5SSxTQUFTLElBQUk4SSxhQUFhLENBQUM5SSxTQUFTLENBQUNELFFBQVFDLFVBQVV1SCxTQUFTN0QscUJBQXFCM0QsUUFBUUMsYUFBYXZFLDJEQUFZQSxDQUFDc0UsUUFBUUMsYUFBY0EsQ0FBQUEsYUFBYSxZQUFZLElBQUksSUFBSSwwSUFBMEk7UUFDaFY7SUFDRjtJQUVBLE9BQU91SCxRQUFRLENBQUMsQ0FBQyxDQUFDNUgsUUFBUSxFQUFDLEVBQUdnSSxJQUFJLEdBQUd4RyxPQUFPLENBQUMsT0FBT21HLGVBQWV2SCxRQUFRQyxVQUFVTCxPQUFPNEgsUUFBUUEsT0FBTzVIO0FBQzdHLEdBQ0lvSix5QkFBeUIsU0FBU0EsdUJBQXVCaEosTUFBTSxFQUFFaUosSUFBSSxFQUFFQyxLQUFLLEVBQUV2QyxHQUFHO0lBQ25GLG9MQUFvTDtJQUNwTCxJQUFJLENBQUN1QyxTQUFTQSxVQUFVLFFBQVE7UUFDOUIsNmdCQUE2Z0I7UUFDN2dCLElBQUloSyxJQUFJOEUsaUJBQWlCaUYsTUFBTWpKLFFBQVEsSUFDbkNaLElBQUlGLEtBQUt5RSxxQkFBcUIzRCxRQUFRZCxHQUFHO1FBRTdDLElBQUlFLEtBQUtBLE1BQU04SixPQUFPO1lBQ3BCRCxPQUFPL0o7WUFDUGdLLFFBQVE5SjtRQUNWLE9BQU8sSUFBSTZKLFNBQVMsZUFBZTtZQUNqQ0MsUUFBUXZGLHFCQUFxQjNELFFBQVEsbUJBQW1CLGtMQUFrTDtRQUM1TztJQUNGO0lBRUEsSUFBSTZHLEtBQUssSUFBSXBLLG9EQUFTQSxDQUFDLElBQUksQ0FBQ3FLLEdBQUcsRUFBRTlHLE9BQU9FLEtBQUssRUFBRStJLE1BQU0sR0FBRyxHQUFHak4sK0RBQW9CQSxHQUMzRW1OLFFBQVEsR0FDUkMsYUFBYSxHQUNiN0gsR0FDQThILFFBQ0FDLGFBQ0FDLFVBQ0FDLE9BQ0FDLFlBQ0FDLFVBQ0FDLFFBQ0FDLE9BQ0FDLFNBQ0FDLFdBQ0FDO0lBQ0psRCxHQUFHbkgsQ0FBQyxHQUFHd0o7SUFDUHJDLEdBQUdySCxDQUFDLEdBQUdtSDtJQUNQdUMsU0FBUyxJQUFJLDRCQUE0QjtJQUV6Q3ZDLE9BQU87SUFFUCxJQUFJQSxRQUFRLFFBQVE7UUFDbEI4QyxhQUFhekosT0FBT0UsS0FBSyxDQUFDK0ksS0FBSztRQUMvQmpKLE9BQU9FLEtBQUssQ0FBQytJLEtBQUssR0FBR3RDO1FBQ3JCQSxNQUFNaEQscUJBQXFCM0QsUUFBUWlKLFNBQVN0QztRQUM1QzhDLGFBQWF6SixPQUFPRSxLQUFLLENBQUMrSSxLQUFLLEdBQUdRLGFBQWFwRCxnQkFBZ0JyRyxRQUFRaUo7SUFDekU7SUFFQTFILElBQUk7UUFBQzJIO1FBQU92QztLQUFJO0lBRWhCdkssaUVBQWtCQSxDQUFDbUYsSUFBSSx3WkFBd1o7SUFHL2EySCxRQUFRM0gsQ0FBQyxDQUFDLEVBQUU7SUFDWm9GLE1BQU1wRixDQUFDLENBQUMsRUFBRTtJQUNWK0gsY0FBY0osTUFBTWMsS0FBSyxDQUFDcE8sMERBQWVBLEtBQUssRUFBRTtJQUNoRG1PLFlBQVlwRCxJQUFJcUQsS0FBSyxDQUFDcE8sMERBQWVBLEtBQUssRUFBRTtJQUU1QyxJQUFJbU8sVUFBVXhILE1BQU0sRUFBRTtRQUNwQixNQUFPOEcsU0FBU3pOLDBEQUFlQSxDQUFDcU8sSUFBSSxDQUFDdEQsS0FBTTtZQUN6QytDLFdBQVdMLE1BQU0sQ0FBQyxFQUFFO1lBQ3BCTyxRQUFRakQsSUFBSXVELFNBQVMsQ0FBQ2YsT0FBT0UsT0FBT0YsS0FBSztZQUV6QyxJQUFJSyxPQUFPO2dCQUNUQSxRQUFRLENBQUNBLFFBQVEsS0FBSztZQUN4QixPQUFPLElBQUlJLE1BQU1wSCxNQUFNLENBQUMsQ0FBQyxPQUFPLFdBQVdvSCxNQUFNcEgsTUFBTSxDQUFDLENBQUMsT0FBTyxTQUFTO2dCQUN2RWdILFFBQVE7WUFDVjtZQUVBLElBQUlFLGFBQWNELENBQUFBLGFBQWFILFdBQVcsQ0FBQ0YsYUFBYSxJQUFJLEVBQUMsR0FBSTtnQkFDL0RHLFdBQVc3QixXQUFXK0IsZUFBZTtnQkFDckNLLFlBQVlMLFdBQVdqSCxNQUFNLENBQUMsQ0FBQytHLFdBQVcsRUFBQyxFQUFHaEgsTUFBTTtnQkFDcERtSCxTQUFTdEYsTUFBTSxDQUFDLE9BQU8sT0FBUXNGLENBQUFBLFdBQVd6TSw2REFBY0EsQ0FBQ3NNLFVBQVVHLFlBQVlJLFNBQVE7Z0JBQ3ZGSCxTQUFTakMsV0FBV2dDO2dCQUNwQkcsVUFBVUgsU0FBU2xILE1BQU0sQ0FBQyxDQUFDbUgsU0FBUyxFQUFDLEVBQUdwSCxNQUFNO2dCQUM5QzRHLFFBQVF2TiwwREFBZUEsQ0FBQ3VPLFNBQVMsR0FBR04sUUFBUXRILE1BQU07Z0JBRWxELElBQUksQ0FBQ3NILFNBQVM7b0JBQ1osb0ZBQW9GO29CQUNwRkEsVUFBVUEsV0FBV25OLGtEQUFPQSxDQUFDME4sS0FBSyxDQUFDbkIsS0FBSyxJQUFJYTtvQkFFNUMsSUFBSVgsVUFBVXhDLElBQUlwRSxNQUFNLEVBQUU7d0JBQ3hCb0UsT0FBT2tEO3dCQUNQaEQsR0FBR3JILENBQUMsSUFBSXFLO29CQUNWO2dCQUNGO2dCQUVBLElBQUlDLGNBQWNELFNBQVM7b0JBQ3pCTixXQUFXaEMsZUFBZXZILFFBQVFpSixNQUFNUSxZQUFZSSxZQUFZO2dCQUNsRSxFQUFFLDJNQUEyTTtnQkFHN01oRCxHQUFHQyxHQUFHLEdBQUc7b0JBQ1B1RCxPQUFPeEQsR0FBR0MsR0FBRztvQkFDYjVILEdBQUcwSyxTQUFTUixlQUFlLElBQUlRLFFBQVE7b0JBQ3ZDLHVPQUF1TztvQkFDdk94SyxHQUFHbUs7b0JBQ0hsSyxHQUFHc0ssU0FBU0o7b0JBQ1plLEdBQUdkLFNBQVNBLFFBQVEsS0FBS1AsU0FBUyxXQUFXakwsS0FBS21CLEtBQUssR0FBRztnQkFDNUQ7WUFDRjtRQUNGO1FBRUEwSCxHQUFHeEgsQ0FBQyxHQUFHOEosUUFBUXhDLElBQUlwRSxNQUFNLEdBQUdvRSxJQUFJdUQsU0FBUyxDQUFDZixPQUFPeEMsSUFBSXBFLE1BQU0sSUFBSSxJQUFJLCtGQUErRjtJQUNwSyxPQUFPO1FBQ0xzRSxHQUFHMEQsQ0FBQyxHQUFHdEIsU0FBUyxhQUFhdEMsUUFBUSxTQUFTN0csbUNBQW1DRDtJQUNuRjtJQUVBNUQsa0RBQU9BLENBQUM2TCxJQUFJLENBQUNuQixRQUFTRSxDQUFBQSxHQUFHckgsQ0FBQyxHQUFHLElBQUksa09BQWtPO0lBRW5RLElBQUksQ0FBQ3NILEdBQUcsR0FBR0QsSUFBSSw0T0FBNE87SUFFM1AsT0FBT0E7QUFDVCxHQUNJMkQsb0JBQW9CO0lBQ3RCQyxLQUFLO0lBQ0xDLFFBQVE7SUFDUkMsTUFBTTtJQUNOQyxPQUFPO0lBQ1BDLFFBQVE7QUFDVixHQUNJQyxnQ0FBZ0MsU0FBU0EsOEJBQThCbEwsS0FBSztJQUM5RSxJQUFJeUIsUUFBUXpCLE1BQU15QixLQUFLLENBQUMsTUFDcEJJLElBQUlKLEtBQUssQ0FBQyxFQUFFLEVBQ1o2RSxJQUFJN0UsS0FBSyxDQUFDLEVBQUUsSUFBSTtJQUVwQixJQUFJSSxNQUFNLFNBQVNBLE1BQU0sWUFBWXlFLE1BQU0sVUFBVUEsTUFBTSxTQUFTO1FBQ2xFLHlEQUF5RDtRQUN6RHRHLFFBQVE2QjtRQUNSQSxJQUFJeUU7UUFDSkEsSUFBSXRHO0lBQ047SUFFQXlCLEtBQUssQ0FBQyxFQUFFLEdBQUdtSixpQkFBaUIsQ0FBQy9JLEVBQUUsSUFBSUE7SUFDbkNKLEtBQUssQ0FBQyxFQUFFLEdBQUdtSixpQkFBaUIsQ0FBQ3RFLEVBQUUsSUFBSUE7SUFDbkMsT0FBTzdFLE1BQU0wSixJQUFJLENBQUM7QUFDcEIsR0FDSUMsb0JBQW9CLFNBQVNBLGtCQUFrQmxNLEtBQUssRUFBRUMsSUFBSTtJQUM1RCxJQUFJQSxLQUFLa00sS0FBSyxJQUFJbE0sS0FBS2tNLEtBQUssQ0FBQ0MsS0FBSyxLQUFLbk0sS0FBS2tNLEtBQUssQ0FBQ0UsSUFBSSxFQUFFO1FBQ3RELElBQUluTCxTQUFTakIsS0FBS0UsQ0FBQyxFQUNmaUIsUUFBUUYsT0FBT0UsS0FBSyxFQUNwQjJCLFFBQVE5QyxLQUFLTyxDQUFDLEVBQ2RxQixRQUFRWCxPQUFPTSxLQUFLLEVBQ3BCMkksTUFDQW1DLGlCQUNBOUk7UUFFSixJQUFJVCxVQUFVLFNBQVNBLFVBQVUsTUFBTTtZQUNyQzNCLE1BQU11RSxPQUFPLEdBQUc7WUFDaEIyRyxrQkFBa0I7UUFDcEIsT0FBTztZQUNMdkosUUFBUUEsTUFBTVIsS0FBSyxDQUFDO1lBQ3BCaUIsSUFBSVQsTUFBTVUsTUFBTTtZQUVoQixNQUFPLEVBQUVELElBQUksQ0FBQyxFQUFHO2dCQUNmMkcsT0FBT3BILEtBQUssQ0FBQ1MsRUFBRTtnQkFFZixJQUFJeEUsZUFBZSxDQUFDbUwsS0FBSyxFQUFFO29CQUN6Qm1DLGtCQUFrQjtvQkFDbEJuQyxPQUFPQSxTQUFTLG9CQUFvQmxJLHVCQUF1QkQ7Z0JBQzdEO2dCQUVBdUYsZ0JBQWdCckcsUUFBUWlKO1lBQzFCO1FBQ0Y7UUFFQSxJQUFJbUMsaUJBQWlCO1lBQ25CL0UsZ0JBQWdCckcsUUFBUWM7WUFFeEIsSUFBSUgsT0FBTztnQkFDVEEsTUFBTW1CLEdBQUcsSUFBSTlCLE9BQU91RyxlQUFlLENBQUM7Z0JBRXBDcUMsZ0JBQWdCNUksUUFBUSxJQUFJLHdMQUF3TDtnQkFHcE5XLE1BQU1rQyxPQUFPLEdBQUc7Z0JBRWhCWCw2QkFBNkJoQztZQUMvQjtRQUNGO0lBQ0Y7QUFDRixHQUNJLG1JQUFtSTtBQUN2STZJLGdCQUFnQjtJQUNkc0MsWUFBWSxTQUFTQSxXQUFXNUUsTUFBTSxFQUFFekcsTUFBTSxFQUFFQyxRQUFRLEVBQUV5SixRQUFRLEVBQUV1QixLQUFLO1FBQ3ZFLElBQUlBLE1BQU1sTSxJQUFJLEtBQUssZUFBZTtZQUNoQyxJQUFJOEgsS0FBS0osT0FBT0ssR0FBRyxHQUFHLElBQUlySyxvREFBU0EsQ0FBQ2dLLE9BQU9LLEdBQUcsRUFBRTlHLFFBQVFDLFVBQVUsR0FBRyxHQUFHK0s7WUFDeEVuRSxHQUFHdkgsQ0FBQyxHQUFHb0s7WUFDUDdDLEdBQUd5RSxFQUFFLEdBQUcsQ0FBQztZQUNUekUsR0FBR29FLEtBQUssR0FBR0E7WUFFWHhFLE9BQU9NLE1BQU0sQ0FBQzlFLElBQUksQ0FBQ2hDO1lBRW5CLE9BQU87UUFDVDtJQUNGO0FBaUVGLEdBRUE7Ozs7Q0FJQyxHQUNEc0wsb0JBQW9CO0lBQUM7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0NBQUUsRUFDbENDLHdCQUF3QixDQUFDLEdBQ3pCQyxtQkFBbUIsU0FBU0EsaUJBQWlCN0wsS0FBSztJQUNwRCxPQUFPQSxVQUFVLDhCQUE4QkEsVUFBVSxVQUFVLENBQUNBO0FBQ3RFLEdBQ0k4TCxxQ0FBcUMsU0FBU0EsbUNBQW1DMUwsTUFBTTtJQUN6RixJQUFJMkwsZUFBZWhJLHFCQUFxQjNELFFBQVFjO0lBRWhELE9BQU8ySyxpQkFBaUJFLGdCQUFnQkosb0JBQW9CSSxhQUFhbkosTUFBTSxDQUFDLEdBQUd3SCxLQUFLLENBQUNyTyxrREFBT0EsRUFBRWlRLEdBQUcsQ0FBQ2hQLGlEQUFNQTtBQUM5RyxHQUNJaVAsYUFBYSxTQUFTQSxXQUFXN0wsTUFBTSxFQUFFOEwsT0FBTztJQUNsRCxJQUFJbkwsUUFBUVgsT0FBT00sS0FBSyxJQUFJdkQsd0RBQVNBLENBQUNpRCxTQUNsQ0UsUUFBUUYsT0FBT0UsS0FBSyxFQUNwQjZMLFNBQVNMLG1DQUFtQzFMLFNBQzVDc0ksUUFDQXJELGFBQ0ErRyxNQUNBQztJQUVKLElBQUl0TCxNQUFNbUIsR0FBRyxJQUFJOUIsT0FBT2dDLFlBQVksQ0FBQyxjQUFjO1FBQ2pEZ0ssT0FBT2hNLE9BQU8yQixTQUFTLENBQUN1SyxPQUFPLENBQUNDLFdBQVcsR0FBR0osTUFBTSxFQUFFLHlIQUF5SDtRQUUvS0EsU0FBUztZQUFDQyxLQUFLekssQ0FBQztZQUFFeUssS0FBS3RNLENBQUM7WUFBRXNNLEtBQUszTSxDQUFDO1lBQUUyTSxLQUFLSSxDQUFDO1lBQUVKLEtBQUt4TSxDQUFDO1lBQUV3TSxLQUFLSyxDQUFDO1NBQUM7UUFDekQsT0FBT04sT0FBT2hCLElBQUksQ0FBQyxTQUFTLGdCQUFnQlEsb0JBQW9CUTtJQUNsRSxPQUFPLElBQUlBLFdBQVdSLHFCQUFxQixDQUFDdkwsT0FBT3NNLFlBQVksSUFBSXRNLFdBQVcxQyxlQUFlLENBQUNxRCxNQUFNbUIsR0FBRyxFQUFFO1FBQ3ZHLHVUQUF1VDtRQUN2VCw2VUFBNlU7UUFDN1VrSyxPQUFPOUwsTUFBTW1GLE9BQU87UUFDcEJuRixNQUFNbUYsT0FBTyxHQUFHO1FBQ2hCaUQsU0FBU3RJLE9BQU8rRSxVQUFVO1FBRTFCLElBQUksQ0FBQ3VELFVBQVUsQ0FBQ3RJLE9BQU9zTSxZQUFZLEVBQUU7WUFDbkMsNFhBQTRYO1lBQzVYTCxhQUFhLEdBQUcsTUFBTTtZQUV0QmhILGNBQWNqRixPQUFPdU0sa0JBQWtCO1lBRXZDalAsWUFBWThILFdBQVcsQ0FBQ3BGLFNBQVMsMkRBQTJEO1FBRTlGO1FBRUErTCxTQUFTTCxtQ0FBbUMxTDtRQUM1Q2dNLE9BQU85TCxNQUFNbUYsT0FBTyxHQUFHMkcsT0FBTzNGLGdCQUFnQnJHLFFBQVE7UUFFdEQsSUFBSWlNLFlBQVk7WUFDZGhILGNBQWNxRCxPQUFPOUMsWUFBWSxDQUFDeEYsUUFBUWlGLGVBQWVxRCxTQUFTQSxPQUFPbEQsV0FBVyxDQUFDcEYsVUFBVTFDLFlBQVltSSxXQUFXLENBQUN6RjtRQUN6SDtJQUNGO0lBRUEsT0FBTzhMLFdBQVdDLE9BQU94SixNQUFNLEdBQUcsSUFBSTtRQUFDd0osTUFBTSxDQUFDLEVBQUU7UUFBRUEsTUFBTSxDQUFDLEVBQUU7UUFBRUEsTUFBTSxDQUFDLEVBQUU7UUFBRUEsTUFBTSxDQUFDLEVBQUU7UUFBRUEsTUFBTSxDQUFDLEdBQUc7UUFBRUEsTUFBTSxDQUFDLEdBQUc7S0FBQyxHQUFHQTtBQUMvRyxHQUNJUyxrQkFBa0IsU0FBU0EsZ0JBQWdCeE0sTUFBTSxFQUFFNkksTUFBTSxFQUFFNEQsZ0JBQWdCLEVBQUVDLE1BQU0sRUFBRUMsV0FBVyxFQUFFQyx1QkFBdUI7SUFDM0gsSUFBSWpNLFFBQVFYLE9BQU9NLEtBQUssRUFDcEJ5TCxTQUFTWSxlQUFlZCxXQUFXN0wsUUFBUSxPQUMzQzZNLGFBQWFsTSxNQUFNbU0sT0FBTyxJQUFJLEdBQzlCQyxhQUFhcE0sTUFBTXFNLE9BQU8sSUFBSSxHQUM5QkMsYUFBYXRNLE1BQU11TSxPQUFPLElBQUksR0FDOUJDLGFBQWF4TSxNQUFNeU0sT0FBTyxJQUFJLEdBQzlCN0wsSUFBSXdLLE1BQU0sQ0FBQyxFQUFFLEVBQ2JyTSxJQUFJcU0sTUFBTSxDQUFDLEVBQUUsRUFDYjFNLElBQUkwTSxNQUFNLENBQUMsRUFBRSxFQUNiSyxJQUFJTCxNQUFNLENBQUMsRUFBRSxFQUNic0IsS0FBS3RCLE1BQU0sQ0FBQyxFQUFFLEVBQ2R1QixLQUFLdkIsTUFBTSxDQUFDLEVBQUUsRUFDZHdCLGNBQWMxRSxPQUFPeEgsS0FBSyxDQUFDLE1BQzNCeUwsVUFBVXBGLFdBQVc2RixXQUFXLENBQUMsRUFBRSxLQUFLLEdBQ3hDUCxVQUFVdEYsV0FBVzZGLFdBQVcsQ0FBQyxFQUFFLEtBQUssR0FDeEN6SCxRQUNBMEgsYUFDQS9MLEdBQ0F5RTtJQUVKLElBQUksQ0FBQ3VHLGtCQUFrQjtRQUNyQjNHLFNBQVNELFNBQVM3RjtRQUNsQjhNLFVBQVVoSCxPQUFPckUsQ0FBQyxHQUFJLEVBQUM4TCxXQUFXLENBQUMsRUFBRSxDQUFDbk0sT0FBTyxDQUFDLE9BQU8wTCxVQUFVLE1BQU1oSCxPQUFPRSxLQUFLLEdBQUc4RyxPQUFNO1FBQzFGRSxVQUFVbEgsT0FBT0ksQ0FBQyxHQUFJLEVBQUMsQ0FBQ3FILFdBQVcsQ0FBQyxFQUFFLElBQUlBLFdBQVcsQ0FBQyxFQUFFLEVBQUVuTSxPQUFPLENBQUMsT0FBTzRMLFVBQVUsTUFBTWxILE9BQU9HLE1BQU0sR0FBRytHLE9BQU0sR0FBSSx5SEFBeUg7SUFDNU8sd0JBQXdCO0lBQ3hCLHdCQUF3QjtJQUN4QixJQUFJO0lBQ04sT0FBTyxJQUFJakIsV0FBV1IscUJBQXNCaUMsQ0FBQUEsY0FBY2pNLElBQUk2SyxJQUFJMU0sSUFBSUwsQ0FBQUEsR0FBSTtRQUN4RSxtR0FBbUc7UUFDbkdvQyxJQUFJcUwsVUFBV1YsQ0FBQUEsSUFBSW9CLFdBQVUsSUFBS1IsVUFBVyxFQUFDM04sSUFBSW1PLFdBQVUsSUFBSyxDQUFDbk8sSUFBSWlPLEtBQUtsQixJQUFJaUIsRUFBQyxJQUFLRztRQUNyRnRILElBQUk0RyxVQUFXLEVBQUNwTixJQUFJOE4sV0FBVSxJQUFLUixVQUFXekwsQ0FBQUEsSUFBSWlNLFdBQVUsSUFBSyxDQUFDak0sSUFBSStMLEtBQUs1TixJQUFJMk4sRUFBQyxJQUFLRztRQUNyRlYsVUFBVXJMO1FBQ1Z1TCxVQUFVOUcsR0FBRyw4R0FBOEc7SUFDN0g7SUFFQSxJQUFJd0csVUFBVUEsV0FBVyxTQUFTL0wsTUFBTStMLE1BQU0sRUFBRTtRQUM5Q1csS0FBS1AsVUFBVUQ7UUFDZlMsS0FBS04sVUFBVUQ7UUFDZnBNLE1BQU11TSxPQUFPLEdBQUdELGFBQWNJLENBQUFBLEtBQUs5TCxJQUFJK0wsS0FBS2pPLENBQUFBLElBQUtnTztRQUNqRDFNLE1BQU15TSxPQUFPLEdBQUdELGFBQWNFLENBQUFBLEtBQUszTixJQUFJNE4sS0FBS2xCLENBQUFBLElBQUtrQjtJQUNuRCxPQUFPO1FBQ0wzTSxNQUFNdU0sT0FBTyxHQUFHdk0sTUFBTXlNLE9BQU8sR0FBRztJQUNsQztJQUVBek0sTUFBTW1NLE9BQU8sR0FBR0E7SUFDaEJuTSxNQUFNcU0sT0FBTyxHQUFHQTtJQUNoQnJNLE1BQU0rTCxNQUFNLEdBQUcsQ0FBQyxDQUFDQTtJQUNqQi9MLE1BQU1rSSxNQUFNLEdBQUdBO0lBQ2ZsSSxNQUFNOEwsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDQTtJQUMzQnpNLE9BQU9FLEtBQUssQ0FBQ2EscUJBQXFCLEdBQUcsV0FBVyxvTEFBb0w7SUFFcE8sSUFBSTZMLHlCQUF5QjtRQUMzQnBHLGtCQUFrQm9HLHlCQUF5QmpNLE9BQU8sV0FBV2tNLFlBQVlDO1FBRXpFdEcsa0JBQWtCb0cseUJBQXlCak0sT0FBTyxXQUFXb00sWUFBWUM7UUFFekV4RyxrQkFBa0JvRyx5QkFBeUJqTSxPQUFPLFdBQVdzTSxZQUFZdE0sTUFBTXVNLE9BQU87UUFFdEYxRyxrQkFBa0JvRyx5QkFBeUJqTSxPQUFPLFdBQVd3TSxZQUFZeE0sTUFBTXlNLE9BQU87SUFDeEY7SUFFQXBOLE9BQU8yQyxZQUFZLENBQUMsbUJBQW1CbUssVUFBVSxNQUFNRTtBQUN6RCxHQUNJcEUsa0JBQWtCLFNBQVNBLGdCQUFnQjVJLE1BQU0sRUFBRTZDLE9BQU87SUFDNUQsSUFBSWxDLFFBQVFYLE9BQU9NLEtBQUssSUFBSSxJQUFJOUQsa0RBQU9BLENBQUN3RDtJQUV4QyxJQUFJLE9BQU9XLFNBQVMsQ0FBQ2tDLFdBQVcsQ0FBQ2xDLE1BQU1rQyxPQUFPLEVBQUU7UUFDOUMsT0FBT2xDO0lBQ1Q7SUFFQSxJQUFJVCxRQUFRRixPQUFPRSxLQUFLLEVBQ3BCdU4saUJBQWlCOU0sTUFBTUgsTUFBTSxHQUFHLEdBQ2hDNkgsS0FBSyxNQUNMcEIsTUFBTSxPQUNOcEQsS0FBS0MsaUJBQWlCOUQsU0FDdEI2SSxTQUFTbEYscUJBQXFCM0QsUUFBUWUseUJBQXlCLEtBQy9EVSxHQUNBeUUsR0FDQXdILEdBQ0FsTixRQUNBQyxRQUNBa04sVUFDQUMsV0FDQUMsV0FDQUMsT0FDQUMsT0FDQUMsYUFDQWxCLFNBQ0FFLFNBQ0FqQixRQUNBa0MsT0FDQUMsS0FDQUMsS0FDQTVNLEdBQ0E3QixHQUNBTCxHQUNBK00sR0FDQWdDLEtBQ0FDLEtBQ0FDLElBQ0FDLElBQ0FDLElBQ0FDLEtBQ0FDLEtBQ0FDLEtBQ0FDLEtBQ0FDLEtBQ0FDO0lBQ0pyTixJQUFJeUUsSUFBSXdILElBQUlDLFdBQVdDLFlBQVlDLFlBQVlDLFFBQVFDLFFBQVFDLGNBQWM7SUFDN0V4TixTQUFTQyxTQUFTO0lBQ2xCRSxNQUFNbUIsR0FBRyxHQUFHLENBQUMsQ0FBRTlCLENBQUFBLE9BQU9vRyxNQUFNLElBQUlELE9BQU9uRyxPQUFNO0lBRTdDLElBQUk2RCxHQUFHMUIsU0FBUyxFQUFFO1FBQ2hCLHlFQUF5RTtRQUN6RSxJQUFJMEIsR0FBRzFCLFNBQVMsS0FBSyxVQUFVMEIsR0FBR2xGLEtBQUssS0FBSyxVQUFVa0YsR0FBR2tMLE1BQU0sS0FBSyxRQUFRO1lBQzFFN08sS0FBSyxDQUFDWSxlQUFlLEdBQUcsQ0FBQytDLEdBQUcxQixTQUFTLEtBQUssU0FBUyxpQkFBaUIsQ0FBQzBCLEdBQUcxQixTQUFTLEdBQUcsTUFBSyxFQUFHZCxLQUFLLENBQUMsS0FBSzJOLEtBQUssQ0FBQyxHQUFHLEdBQUdqRSxJQUFJLENBQUMsUUFBUSxPQUFPLEVBQUMsSUFBTWxILENBQUFBLEdBQUdrTCxNQUFNLEtBQUssU0FBUyxZQUFZbEwsR0FBR2tMLE1BQU0sR0FBRyxPQUFPLEVBQUMsSUFBTWxMLENBQUFBLEdBQUdsRixLQUFLLEtBQUssU0FBUyxXQUFXa0YsR0FBR2xGLEtBQUssQ0FBQzBDLEtBQUssQ0FBQyxLQUFLMEosSUFBSSxDQUFDLE9BQU8sT0FBTyxFQUFDLElBQU1sSCxDQUFBQSxFQUFFLENBQUMvQyxlQUFlLEtBQUssU0FBUytDLEVBQUUsQ0FBQy9DLGVBQWUsR0FBRyxFQUFDO1FBQ2xWO1FBRUFaLE1BQU12QixLQUFLLEdBQUd1QixNQUFNNk8sTUFBTSxHQUFHN08sTUFBTWlDLFNBQVMsR0FBRztJQUNqRDtJQUVBNEosU0FBU0YsV0FBVzdMLFFBQVFXLE1BQU1tQixHQUFHO0lBRXJDLElBQUluQixNQUFNbUIsR0FBRyxFQUFFO1FBQ2IsSUFBSW5CLE1BQU1rQyxPQUFPLEVBQUU7WUFDakIsc1JBQXNSO1lBQ3RSMEwsS0FBS3ZPLE9BQU9zRixPQUFPO1lBQ25CdUQsU0FBU2xJLE1BQU1tTSxPQUFPLEdBQUd5QixHQUFHOU0sQ0FBQyxHQUFHLFFBQVNkLENBQUFBLE1BQU1xTSxPQUFPLEdBQUd1QixHQUFHckksQ0FBQyxJQUFJO1lBQ2pFb0ksS0FBSztRQUNQLE9BQU87WUFDTEEsS0FBSyxDQUFDekwsV0FBVzdDLE9BQU9nQyxZQUFZLENBQUMsb0JBQW9CLGlKQUFpSjtRQUM1TTtRQUVBd0ssZ0JBQWdCeE0sUUFBUXNPLE1BQU16RixRQUFRLENBQUMsQ0FBQ3lGLE1BQU0zTixNQUFNOEwsZ0JBQWdCLEVBQUU5TCxNQUFNK0wsTUFBTSxLQUFLLE9BQU9YO0lBQ2hHO0lBRUFlLFVBQVVuTSxNQUFNbU0sT0FBTyxJQUFJO0lBQzNCRSxVQUFVck0sTUFBTXFNLE9BQU8sSUFBSTtJQUUzQixJQUFJakIsV0FBV1IsbUJBQW1CO1FBQ2hDaEssSUFBSXdLLE1BQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSztRQUVwQnJNLElBQUlxTSxNQUFNLENBQUMsRUFBRSxFQUFFLEtBQUs7UUFFcEIxTSxJQUFJME0sTUFBTSxDQUFDLEVBQUUsRUFBRSxLQUFLO1FBRXBCSyxJQUFJTCxNQUFNLENBQUMsRUFBRSxFQUFFLEtBQUs7UUFFcEJ0SyxJQUFJMk0sTUFBTXJDLE1BQU0sQ0FBQyxFQUFFO1FBQ25CN0YsSUFBSW1JLE1BQU10QyxNQUFNLENBQUMsRUFBRSxFQUFFLFdBQVc7UUFFaEMsSUFBSUEsT0FBT3hKLE1BQU0sS0FBSyxHQUFHO1lBQ3ZCL0IsU0FBU3hDLEtBQUtpUixJQUFJLENBQUMxTixJQUFJQSxJQUFJN0IsSUFBSUE7WUFDL0JlLFNBQVN6QyxLQUFLaVIsSUFBSSxDQUFDN0MsSUFBSUEsSUFBSS9NLElBQUlBO1lBQy9Cc08sV0FBV3BNLEtBQUs3QixJQUFJdkIsT0FBT3VCLEdBQUc2QixLQUFLeEQsV0FBVyxHQUFHLHlMQUF5TDtZQUUxTytQLFFBQVF6TyxLQUFLK00sSUFBSWpPLE9BQU9rQixHQUFHK00sS0FBS3JPLFdBQVc0UCxXQUFXO1lBQ3RERyxTQUFVck4sQ0FBQUEsVUFBVXpDLEtBQUtrUixHQUFHLENBQUNsUixLQUFLa1EsR0FBRyxDQUFDSixRQUFRNVAsVUFBUztZQUV2RCxJQUFJeUMsTUFBTW1CLEdBQUcsRUFBRTtnQkFDYkwsS0FBS3FMLFVBQVdBLENBQUFBLFVBQVV2TCxJQUFJeUwsVUFBVTNOLENBQUFBO2dCQUN4QzZHLEtBQUs4RyxVQUFXRixDQUFBQSxVQUFVcE4sSUFBSXNOLFVBQVVaLENBQUFBO1lBQzFDLEVBQUUsV0FBVztRQUVmLE9BQU87WUFDTDBDLE1BQU0vQyxNQUFNLENBQUMsRUFBRTtZQUNmNkMsTUFBTTdDLE1BQU0sQ0FBQyxFQUFFO1lBQ2YwQyxNQUFNMUMsTUFBTSxDQUFDLEVBQUU7WUFDZjJDLE1BQU0zQyxNQUFNLENBQUMsRUFBRTtZQUNmNEMsTUFBTTVDLE1BQU0sQ0FBQyxHQUFHO1lBQ2hCOEMsTUFBTTlDLE1BQU0sQ0FBQyxHQUFHO1lBQ2hCdEssSUFBSXNLLE1BQU0sQ0FBQyxHQUFHO1lBQ2Q3RixJQUFJNkYsTUFBTSxDQUFDLEdBQUc7WUFDZDJCLElBQUkzQixNQUFNLENBQUMsR0FBRztZQUNka0MsUUFBUTlQLE9BQU8yUSxLQUFLSDtZQUNwQmYsWUFBWUssUUFBUWxRLFVBQVUsV0FBVztZQUV6QyxJQUFJa1EsT0FBTztnQkFDVEMsTUFBTWxRLEtBQUtrUSxHQUFHLENBQUMsQ0FBQ0Q7Z0JBQ2hCRSxNQUFNblEsS0FBS21RLEdBQUcsQ0FBQyxDQUFDRjtnQkFDaEJLLEtBQUtGLE1BQU1GLE1BQU1PLE1BQU1OO2dCQUN2QkksS0FBS0YsTUFBTUgsTUFBTVEsTUFBTVA7Z0JBQ3ZCSyxLQUFLTSxNQUFNWixNQUFNUyxNQUFNUjtnQkFDdkJNLE1BQU1MLE1BQU0sQ0FBQ0QsTUFBTU0sTUFBTVA7Z0JBQ3pCUSxNQUFNTCxNQUFNLENBQUNGLE1BQU1PLE1BQU1SO2dCQUN6QlMsTUFBTUcsTUFBTSxDQUFDWCxNQUFNUSxNQUFNVDtnQkFDekJXLE1BQU1ELE1BQU0sQ0FBQ1QsTUFBTVUsTUFBTVg7Z0JBQ3pCRSxNQUFNRTtnQkFDTkQsTUFBTUU7Z0JBQ05PLE1BQU1OO1lBQ1IsRUFBRSxXQUFXO1lBR2JQLFFBQVE5UCxPQUFPLENBQUNrQixHQUFHc1A7WUFDbkJkLFlBQVlJLFFBQVFsUTtZQUVwQixJQUFJa1EsT0FBTztnQkFDVEMsTUFBTWxRLEtBQUtrUSxHQUFHLENBQUMsQ0FBQ0Q7Z0JBQ2hCRSxNQUFNblEsS0FBS21RLEdBQUcsQ0FBQyxDQUFDRjtnQkFDaEJLLEtBQUsvTSxJQUFJMk0sTUFBTU8sTUFBTU47Z0JBQ3JCSSxLQUFLN08sSUFBSXdPLE1BQU1RLE1BQU1QO2dCQUNyQkssS0FBS25QLElBQUk2TyxNQUFNUyxNQUFNUjtnQkFDckJVLE1BQU16QyxJQUFJK0IsTUFBTVUsTUFBTVg7Z0JBQ3RCM00sSUFBSStNO2dCQUNKNU8sSUFBSTZPO2dCQUNKbFAsSUFBSW1QO1lBQ04sRUFBRSxXQUFXO1lBR2JQLFFBQVE5UCxPQUFPdUIsR0FBRzZCO1lBQ2xCb00sV0FBV00sUUFBUWxRO1lBRW5CLElBQUlrUSxPQUFPO2dCQUNUQyxNQUFNbFEsS0FBS2tRLEdBQUcsQ0FBQ0Q7Z0JBQ2ZFLE1BQU1uUSxLQUFLbVEsR0FBRyxDQUFDRjtnQkFDZkssS0FBSy9NLElBQUkyTSxNQUFNeE8sSUFBSXlPO2dCQUNuQkksS0FBS0gsTUFBTUYsTUFBTUcsTUFBTUY7Z0JBQ3ZCek8sSUFBSUEsSUFBSXdPLE1BQU0zTSxJQUFJNE07Z0JBQ2xCRSxNQUFNQSxNQUFNSCxNQUFNRSxNQUFNRDtnQkFDeEI1TSxJQUFJK007Z0JBQ0pGLE1BQU1HO1lBQ1I7WUFFQSxJQUFJWCxhQUFhNVAsS0FBS2tSLEdBQUcsQ0FBQ3RCLGFBQWE1UCxLQUFLa1IsR0FBRyxDQUFDdkIsWUFBWSxPQUFPO2dCQUNqRSx1TEFBdUw7Z0JBQ3ZMQyxZQUFZRCxXQUFXO2dCQUN2QkUsWUFBWSxNQUFNQTtZQUNwQjtZQUVBck4sU0FBUzVELHFEQUFNQSxDQUFDb0IsS0FBS2lSLElBQUksQ0FBQzFOLElBQUlBLElBQUk3QixJQUFJQSxJQUFJTCxJQUFJQTtZQUM5Q29CLFNBQVM3RCxxREFBTUEsQ0FBQ29CLEtBQUtpUixJQUFJLENBQUNaLE1BQU1BLE1BQU1TLE1BQU1BO1lBQzVDYixRQUFROVAsT0FBT2lRLEtBQUtDO1lBQ3BCUCxRQUFROVAsS0FBS2tSLEdBQUcsQ0FBQ2pCLFNBQVMsU0FBU0EsUUFBUWxRLFdBQVc7WUFDdERpUSxjQUFjYSxNQUFNLElBQUtBLENBQUFBLE1BQU0sSUFBSSxDQUFDQSxNQUFNQSxHQUFFLElBQUs7UUFDbkQ7UUFFQSxJQUFJbE8sTUFBTW1CLEdBQUcsRUFBRTtZQUNiLHVSQUF1UjtZQUN2UndNLEtBQUt0TyxPQUFPZ0MsWUFBWSxDQUFDO1lBQ3pCckIsTUFBTXdPLFFBQVEsR0FBR25QLE9BQU8yQyxZQUFZLENBQUMsYUFBYSxPQUFPLENBQUM4SSxpQkFBaUI5SCxxQkFBcUIzRCxRQUFRYztZQUN4R3dOLE1BQU10TyxPQUFPMkMsWUFBWSxDQUFDLGFBQWEyTDtRQUN6QztJQUNGO0lBRUEsSUFBSXRRLEtBQUtrUixHQUFHLENBQUNwQixTQUFTLE1BQU05UCxLQUFLa1IsR0FBRyxDQUFDcEIsU0FBUyxLQUFLO1FBQ2pELElBQUlMLGdCQUFnQjtZQUNsQmpOLFVBQVUsQ0FBQztZQUNYc04sU0FBU0gsWUFBWSxJQUFJLE1BQU0sQ0FBQztZQUNoQ0EsWUFBWUEsWUFBWSxJQUFJLE1BQU0sQ0FBQztRQUNyQyxPQUFPO1lBQ0xsTixVQUFVLENBQUM7WUFDWHFOLFNBQVNBLFNBQVMsSUFBSSxNQUFNLENBQUM7UUFDL0I7SUFDRjtJQUVBakwsVUFBVUEsV0FBV2xDLE1BQU1rQyxPQUFPO0lBQ2xDbEMsTUFBTWMsQ0FBQyxHQUFHQSxJQUFLLEVBQUNkLE1BQU15TyxRQUFRLEdBQUczTixLQUFNLEVBQUNvQixXQUFXbEMsTUFBTXlPLFFBQVEsSUFBS3BSLENBQUFBLEtBQUttQixLQUFLLENBQUNhLE9BQU9xUCxXQUFXLEdBQUcsT0FBT3JSLEtBQUttQixLQUFLLENBQUMsQ0FBQ3NDLEtBQUssQ0FBQyxLQUFLLEVBQUMsQ0FBQyxJQUFLekIsT0FBT3FQLFdBQVcsR0FBRzFPLE1BQU15TyxRQUFRLEdBQUcsTUFBTSxLQUFLL0c7SUFDNUwxSCxNQUFNdUYsQ0FBQyxHQUFHQSxJQUFLLEVBQUN2RixNQUFNMk8sUUFBUSxHQUFHcEosS0FBTSxFQUFDckQsV0FBV2xDLE1BQU0yTyxRQUFRLElBQUt0UixDQUFBQSxLQUFLbUIsS0FBSyxDQUFDYSxPQUFPdVAsWUFBWSxHQUFHLE9BQU92UixLQUFLbUIsS0FBSyxDQUFDLENBQUMrRyxLQUFLLENBQUMsS0FBSyxFQUFDLENBQUMsSUFBS2xHLE9BQU91UCxZQUFZLEdBQUc1TyxNQUFNMk8sUUFBUSxHQUFHLE1BQU0sS0FBS2pIO0lBQzlMMUgsTUFBTStNLENBQUMsR0FBR0EsSUFBSXJGO0lBQ2QxSCxNQUFNSCxNQUFNLEdBQUc1RCxxREFBTUEsQ0FBQzREO0lBQ3RCRyxNQUFNRixNQUFNLEdBQUc3RCxxREFBTUEsQ0FBQzZEO0lBQ3RCRSxNQUFNZ04sUUFBUSxHQUFHL1EscURBQU1BLENBQUMrUSxZQUFZMUc7SUFDcEN0RyxNQUFNaU4sU0FBUyxHQUFHaFIscURBQU1BLENBQUNnUixhQUFhM0c7SUFDdEN0RyxNQUFNa04sU0FBUyxHQUFHalIscURBQU1BLENBQUNpUixhQUFhNUc7SUFDdEN0RyxNQUFNbU4sS0FBSyxHQUFHQSxRQUFRN0c7SUFDdEJ0RyxNQUFNb04sS0FBSyxHQUFHQSxRQUFROUc7SUFDdEJ0RyxNQUFNNk8sb0JBQW9CLEdBQUd4QixjQUFjM0Y7SUFFM0MsSUFBSTFILE1BQU1lLE9BQU8sR0FBR2dHLFdBQVdtQixPQUFPeEgsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssQ0FBQ3dCLFdBQVdsQyxNQUFNZSxPQUFPLElBQUksR0FBRztRQUN0RnhCLEtBQUssQ0FBQ2EscUJBQXFCLEdBQUcrSCxjQUFjRDtJQUM5QztJQUVBbEksTUFBTXVNLE9BQU8sR0FBR3ZNLE1BQU15TSxPQUFPLEdBQUc7SUFDaEN6TSxNQUFNOE8sT0FBTyxHQUFHL1Msa0RBQU9BLENBQUMrUyxPQUFPO0lBQy9COU8sTUFBTUMsZUFBZSxHQUFHRCxNQUFNbUIsR0FBRyxHQUFHNE4sdUJBQXVCck0sY0FBY3NNLHVCQUF1QkM7SUFDaEdqUCxNQUFNa0MsT0FBTyxHQUFHO0lBQ2hCLE9BQU9sQztBQUNULEdBQ0ltSSxnQkFBZ0IsU0FBU0EsY0FBY2xKLEtBQUs7SUFDOUMsT0FBTyxDQUFDQSxRQUFRQSxNQUFNeUIsS0FBSyxDQUFDLElBQUcsQ0FBRSxDQUFDLEVBQUUsR0FBRyxNQUFNekIsS0FBSyxDQUFDLEVBQUU7QUFDdkQsR0FDSSxzRUFBc0U7QUFDMUVpUSxrQkFBa0IsU0FBU0EsZ0JBQWdCN1AsTUFBTSxFQUFFa0osS0FBSyxFQUFFdEosS0FBSztJQUM3RCxJQUFJNEgsT0FBTzNMLHNEQUFPQSxDQUFDcU47SUFDbkIsT0FBT3RNLHFEQUFNQSxDQUFDOEssV0FBV3dCLFNBQVN4QixXQUFXSCxlQUFldkgsUUFBUSxLQUFLSixRQUFRLE1BQU00SCxVQUFVQTtBQUNuRyxHQUNJb0kseUJBQXlCLFNBQVNBLHVCQUF1QjlRLEtBQUssRUFBRTZCLEtBQUs7SUFDdkVBLE1BQU0rTSxDQUFDLEdBQUc7SUFDVi9NLE1BQU1rTixTQUFTLEdBQUdsTixNQUFNaU4sU0FBUyxHQUFHO0lBQ3BDak4sTUFBTThPLE9BQU8sR0FBRztJQUVoQkUscUJBQXFCN1EsT0FBTzZCO0FBQzlCLEdBQ0ltUCxXQUFXLFFBQ1hDLFVBQVUsT0FDVkMsa0JBQWtCLE1BQ2xCTCx1QkFBdUIsU0FBU0EscUJBQXFCN1EsS0FBSyxFQUFFNkIsS0FBSztJQUNuRSxJQUFJc1AsT0FBT3RQLFNBQVMsSUFBSSxFQUNwQnlPLFdBQVdhLEtBQUtiLFFBQVEsRUFDeEJFLFdBQVdXLEtBQUtYLFFBQVEsRUFDeEI3TixJQUFJd08sS0FBS3hPLENBQUMsRUFDVnlFLElBQUkrSixLQUFLL0osQ0FBQyxFQUNWd0gsSUFBSXVDLEtBQUt2QyxDQUFDLEVBQ1ZDLFdBQVdzQyxLQUFLdEMsUUFBUSxFQUN4QkUsWUFBWW9DLEtBQUtwQyxTQUFTLEVBQzFCRCxZQUFZcUMsS0FBS3JDLFNBQVMsRUFDMUJFLFFBQVFtQyxLQUFLbkMsS0FBSyxFQUNsQkMsUUFBUWtDLEtBQUtsQyxLQUFLLEVBQ2xCdk4sU0FBU3lQLEtBQUt6UCxNQUFNLEVBQ3BCQyxTQUFTd1AsS0FBS3hQLE1BQU0sRUFDcEIrTyx1QkFBdUJTLEtBQUtULG9CQUFvQixFQUNoREMsVUFBVVEsS0FBS1IsT0FBTyxFQUN0QnpQLFNBQVNpUSxLQUFLalEsTUFBTSxFQUNwQjBCLFVBQVV1TyxLQUFLdk8sT0FBTyxFQUN0QndPLGFBQWEsSUFDYkMsUUFBUVYsWUFBWSxVQUFVM1EsU0FBU0EsVUFBVSxLQUFLMlEsWUFBWSxNQUFNLHNRQUFzUTtJQUdsVixJQUFJL04sV0FBWWtNLENBQUFBLGNBQWNrQyxZQUFZakMsY0FBY2lDLFFBQU8sR0FBSTtRQUNqRSxJQUFJN0IsUUFBUXZHLFdBQVdtRyxhQUFhM1AsVUFDaEN1USxNQUFNelEsS0FBS21RLEdBQUcsQ0FBQ0YsUUFDZlUsTUFBTTNRLEtBQUtrUSxHQUFHLENBQUNELFFBQ2ZDO1FBRUpELFFBQVF2RyxXQUFXa0csYUFBYTFQO1FBQ2hDZ1EsTUFBTWxRLEtBQUtrUSxHQUFHLENBQUNEO1FBQ2Z4TSxJQUFJb08sZ0JBQWdCN1AsUUFBUXlCLEdBQUdnTixNQUFNUCxNQUFNLENBQUN4TTtRQUM1Q3dFLElBQUkySixnQkFBZ0I3UCxRQUFRa0csR0FBRyxDQUFDbEksS0FBS21RLEdBQUcsQ0FBQ0YsU0FBUyxDQUFDdk07UUFDbkRnTSxJQUFJbUMsZ0JBQWdCN1AsUUFBUTBOLEdBQUdpQixNQUFNVCxNQUFNLENBQUN4TSxVQUFVQTtJQUN4RDtJQUVBLElBQUk4Tix5QkFBeUJPLFNBQVM7UUFDcENHLGNBQWMsaUJBQWlCVix1QkFBdUJRO0lBQ3hEO0lBRUEsSUFBSVosWUFBWUUsVUFBVTtRQUN4QlksY0FBYyxlQUFlZCxXQUFXLFFBQVFFLFdBQVc7SUFDN0Q7SUFFQSxJQUFJYSxTQUFTMU8sTUFBTXNPLFdBQVc3SixNQUFNNkosV0FBV3JDLE1BQU1xQyxTQUFTO1FBQzVERyxjQUFjeEMsTUFBTXFDLFdBQVdJLFFBQVEsaUJBQWlCMU8sSUFBSSxPQUFPeUUsSUFBSSxPQUFPd0gsSUFBSSxPQUFPLGVBQWVqTSxJQUFJLE9BQU95RSxJQUFJOEo7SUFDekg7SUFFQSxJQUFJckMsYUFBYW1DLFVBQVU7UUFDekJJLGNBQWMsWUFBWXZDLFdBQVdxQztJQUN2QztJQUVBLElBQUluQyxjQUFjaUMsVUFBVTtRQUMxQkksY0FBYyxhQUFhckMsWUFBWW1DO0lBQ3pDO0lBRUEsSUFBSXBDLGNBQWNrQyxVQUFVO1FBQzFCSSxjQUFjLGFBQWF0QyxZQUFZb0M7SUFDekM7SUFFQSxJQUFJbEMsVUFBVWdDLFlBQVkvQixVQUFVK0IsVUFBVTtRQUM1Q0ksY0FBYyxVQUFVcEMsUUFBUSxPQUFPQyxRQUFRaUM7SUFDakQ7SUFFQSxJQUFJeFAsV0FBVyxLQUFLQyxXQUFXLEdBQUc7UUFDaEN5UCxjQUFjLFdBQVcxUCxTQUFTLE9BQU9DLFNBQVN1UDtJQUNwRDtJQUVBaFEsT0FBT0UsS0FBSyxDQUFDWSxlQUFlLEdBQUdvUCxjQUFjO0FBQy9DLEdBQ0lSLHVCQUF1QixTQUFTQSxxQkFBcUI1USxLQUFLLEVBQUU2QixLQUFLO0lBQ25FLElBQUl5UCxRQUFRelAsU0FBUyxJQUFJLEVBQ3JCeU8sV0FBV2dCLE1BQU1oQixRQUFRLEVBQ3pCRSxXQUFXYyxNQUFNZCxRQUFRLEVBQ3pCN04sSUFBSTJPLE1BQU0zTyxDQUFDLEVBQ1h5RSxJQUFJa0ssTUFBTWxLLENBQUMsRUFDWHlILFdBQVd5QyxNQUFNekMsUUFBUSxFQUN6QkcsUUFBUXNDLE1BQU10QyxLQUFLLEVBQ25CQyxRQUFRcUMsTUFBTXJDLEtBQUssRUFDbkJ2TixTQUFTNFAsTUFBTTVQLE1BQU0sRUFDckJDLFNBQVMyUCxNQUFNM1AsTUFBTSxFQUNyQlQsU0FBU29RLE1BQU1wUSxNQUFNLEVBQ3JCOE0sVUFBVXNELE1BQU10RCxPQUFPLEVBQ3ZCRSxVQUFVb0QsTUFBTXBELE9BQU8sRUFDdkJFLFVBQVVrRCxNQUFNbEQsT0FBTyxFQUN2QkUsVUFBVWdELE1BQU1oRCxPQUFPLEVBQ3ZCK0IsV0FBV2lCLE1BQU1qQixRQUFRLEVBQ3pCOUIsS0FBSzNGLFdBQVdqRyxJQUNoQjZMLEtBQUs1RixXQUFXeEIsSUFDaEJtSyxLQUNBQyxLQUNBbEMsS0FDQUMsS0FDQXJDO0lBRUoyQixXQUFXakcsV0FBV2lHO0lBQ3RCRyxRQUFRcEcsV0FBV29HO0lBQ25CQyxRQUFRckcsV0FBV3FHO0lBRW5CLElBQUlBLE9BQU87UUFDVCw0TEFBNEw7UUFDNUxBLFFBQVFyRyxXQUFXcUc7UUFDbkJELFNBQVNDO1FBQ1RKLFlBQVlJO0lBQ2Q7SUFFQSxJQUFJSixZQUFZRyxPQUFPO1FBQ3JCSCxZQUFZelA7UUFDWjRQLFNBQVM1UDtRQUNUbVMsTUFBTXJTLEtBQUtrUSxHQUFHLENBQUNQLFlBQVluTjtRQUMzQjhQLE1BQU10UyxLQUFLbVEsR0FBRyxDQUFDUixZQUFZbk47UUFDM0I0TixNQUFNcFEsS0FBS21RLEdBQUcsQ0FBQ1IsV0FBV0csU0FBUyxDQUFDck47UUFDcEM0TixNQUFNclEsS0FBS2tRLEdBQUcsQ0FBQ1AsV0FBV0csU0FBU3JOO1FBRW5DLElBQUlxTixPQUFPO1lBQ1RDLFNBQVM3UDtZQUNUOE4sT0FBT2hPLEtBQUt1UyxHQUFHLENBQUN6QyxRQUFRQztZQUN4Qi9CLE9BQU9oTyxLQUFLaVIsSUFBSSxDQUFDLElBQUlqRCxPQUFPQTtZQUM1Qm9DLE9BQU9wQztZQUNQcUMsT0FBT3JDO1lBRVAsSUFBSStCLE9BQU87Z0JBQ1QvQixPQUFPaE8sS0FBS3VTLEdBQUcsQ0FBQ3hDO2dCQUNoQi9CLE9BQU9oTyxLQUFLaVIsSUFBSSxDQUFDLElBQUlqRCxPQUFPQTtnQkFDNUJxRSxPQUFPckU7Z0JBQ1BzRSxPQUFPdEU7WUFDVDtRQUNGO1FBRUFxRSxNQUFNelQscURBQU1BLENBQUN5VDtRQUNiQyxNQUFNMVQscURBQU1BLENBQUMwVDtRQUNibEMsTUFBTXhSLHFEQUFNQSxDQUFDd1I7UUFDYkMsTUFBTXpSLHFEQUFNQSxDQUFDeVI7SUFDZixPQUFPO1FBQ0xnQyxNQUFNN1A7UUFDTjZOLE1BQU01TjtRQUNONlAsTUFBTWxDLE1BQU07SUFDZDtJQUVBLElBQUlmLE1BQU0sQ0FBQyxDQUFDLENBQUM1TCxJQUFJLEVBQUMsRUFBR0wsT0FBTyxDQUFDLFNBQVNrTSxNQUFNLENBQUMsQ0FBQyxDQUFDcEgsSUFBSSxFQUFDLEVBQUc5RSxPQUFPLENBQUMsT0FBTztRQUNwRWlNLEtBQUs5RixlQUFldkgsUUFBUSxLQUFLeUIsR0FBRztRQUNwQzZMLEtBQUsvRixlQUFldkgsUUFBUSxLQUFLa0csR0FBRztJQUN0QztJQUVBLElBQUk0RyxXQUFXRSxXQUFXRSxXQUFXRSxTQUFTO1FBQzVDQyxLQUFLelEscURBQU1BLENBQUN5USxLQUFLUCxVQUFXQSxDQUFBQSxVQUFVdUQsTUFBTXJELFVBQVVvQixHQUFFLElBQUtsQjtRQUM3REksS0FBSzFRLHFEQUFNQSxDQUFDMFEsS0FBS04sVUFBV0YsQ0FBQUEsVUFBVXdELE1BQU10RCxVQUFVcUIsR0FBRSxJQUFLakI7SUFDL0Q7SUFFQSxJQUFJZ0MsWUFBWUUsVUFBVTtRQUN4Qiw2SUFBNkk7UUFDN0l0RCxPQUFPaE0sT0FBT3NGLE9BQU87UUFDckIrSCxLQUFLelEscURBQU1BLENBQUN5USxLQUFLK0IsV0FBVyxNQUFNcEQsS0FBS2hHLEtBQUs7UUFDNUNzSCxLQUFLMVEscURBQU1BLENBQUMwUSxLQUFLZ0MsV0FBVyxNQUFNdEQsS0FBSy9GLE1BQU07SUFDL0M7SUFFQStGLE9BQU8sWUFBWXFFLE1BQU0sTUFBTUMsTUFBTSxNQUFNbEMsTUFBTSxNQUFNQyxNQUFNLE1BQU1oQixLQUFLLE1BQU1DLEtBQUs7SUFDbkZ0TixPQUFPMkMsWUFBWSxDQUFDLGFBQWFxSjtJQUNqQ21ELFlBQWFuUCxDQUFBQSxPQUFPRSxLQUFLLENBQUNZLGVBQWUsR0FBR2tMLElBQUcsR0FBSSw2T0FBNk87QUFDbFMsR0FDSXdFLDBCQUEwQixTQUFTQSx3QkFBd0IvSixNQUFNLEVBQUV6RyxNQUFNLEVBQUVDLFFBQVEsRUFBRXNKLFFBQVEsRUFBRUcsUUFBUTtJQUN6RyxJQUFJK0csTUFBTSxLQUNOQyxXQUFXNVUsd0RBQVNBLENBQUM0TixXQUNyQkMsU0FBU2pDLFdBQVdnQyxZQUFhZ0gsQ0FBQUEsWUFBWSxDQUFDaEgsU0FBU3RJLE9BQU8sQ0FBQyxTQUFTckQsV0FBVyxJQUNuRjRTLFNBQVNoSCxTQUFTSixVQUNsQnFILGFBQWFySCxXQUFXb0gsU0FBUyxPQUNqQ0UsV0FDQWhLO0lBRUosSUFBSTZKLFVBQVU7UUFDWkcsWUFBWW5ILFNBQVNySSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFFbEMsSUFBSXdQLGNBQWMsU0FBUztZQUN6QkYsVUFBVUY7WUFFVixJQUFJRSxXQUFXQSxTQUFVRixDQUFBQSxNQUFNLElBQUk7Z0JBQ2pDRSxVQUFVQSxTQUFTLElBQUlGLE1BQU0sQ0FBQ0E7WUFDaEM7UUFDRjtRQUVBLElBQUlJLGNBQWMsUUFBUUYsU0FBUyxHQUFHO1lBQ3BDQSxTQUFTLENBQUNBLFNBQVNGLE1BQU1wUyxPQUFNLElBQUtvUyxNQUFNLENBQUMsQ0FBRUUsQ0FBQUEsU0FBU0YsR0FBRSxJQUFLQTtRQUMvRCxPQUFPLElBQUlJLGNBQWMsU0FBU0YsU0FBUyxHQUFHO1lBQzVDQSxTQUFTLENBQUNBLFNBQVNGLE1BQU1wUyxPQUFNLElBQUtvUyxNQUFNLENBQUMsQ0FBRUUsQ0FBQUEsU0FBU0YsR0FBRSxJQUFLQTtRQUMvRDtJQUNGO0lBRUFoSyxPQUFPSyxHQUFHLEdBQUdELEtBQUssSUFBSXBLLG9EQUFTQSxDQUFDZ0ssT0FBT0ssR0FBRyxFQUFFOUcsUUFBUUMsVUFBVXNKLFVBQVVvSCxRQUFRcFI7SUFDaEZzSCxHQUFHckgsQ0FBQyxHQUFHb1I7SUFDUC9KLEdBQUd2SCxDQUFDLEdBQUc7SUFFUG1ILE9BQU9NLE1BQU0sQ0FBQzlFLElBQUksQ0FBQ2hDO0lBRW5CLE9BQU80RztBQUNULEdBQ0lpSyxVQUFVLFNBQVNBLFFBQVE5USxNQUFNLEVBQUUrUSxNQUFNO0lBQzNDLDBFQUEwRTtJQUMxRSxJQUFLLElBQUk3UixLQUFLNlIsT0FBUTtRQUNwQi9RLE1BQU0sQ0FBQ2QsRUFBRSxHQUFHNlIsTUFBTSxDQUFDN1IsRUFBRTtJQUN2QjtJQUVBLE9BQU9jO0FBQ1QsR0FDSWdSLHNCQUFzQixTQUFTQSxvQkFBb0J2SyxNQUFNLEVBQUV5SixVQUFVLEVBQUVsUSxNQUFNO0lBQy9FLG1JQUFtSTtJQUNuSSxJQUFJaVIsYUFBYUgsUUFBUSxDQUFDLEdBQUc5USxPQUFPTSxLQUFLLEdBQ3JDNFEsVUFBVSxpREFDVmhSLFFBQVFGLE9BQU9FLEtBQUssRUFDcEJpUixVQUNBalMsR0FDQXVLLFlBQ0FDLFVBQ0FILFVBQ0FJLFFBQ0FHLFdBQ0FEO0lBRUosSUFBSW9ILFdBQVduUCxHQUFHLEVBQUU7UUFDbEIySCxhQUFhekosT0FBT2dDLFlBQVksQ0FBQztRQUNqQ2hDLE9BQU8yQyxZQUFZLENBQUMsYUFBYTtRQUNqQ3pDLEtBQUssQ0FBQ1ksZUFBZSxHQUFHb1A7UUFDeEJpQixXQUFXdkksZ0JBQWdCNUksUUFBUTtRQUVuQ3FHLGdCQUFnQnJHLFFBQVFjO1FBRXhCZCxPQUFPMkMsWUFBWSxDQUFDLGFBQWE4RztJQUNuQyxPQUFPO1FBQ0xBLGFBQWEzRixpQkFBaUI5RCxPQUFPLENBQUNjLGVBQWU7UUFDckRaLEtBQUssQ0FBQ1ksZUFBZSxHQUFHb1A7UUFDeEJpQixXQUFXdkksZ0JBQWdCNUksUUFBUTtRQUNuQ0UsS0FBSyxDQUFDWSxlQUFlLEdBQUcySTtJQUMxQjtJQUVBLElBQUt2SyxLQUFLcEIsZ0JBQWlCO1FBQ3pCMkwsYUFBYXdILFVBQVUsQ0FBQy9SLEVBQUU7UUFDMUJ3SyxXQUFXeUgsUUFBUSxDQUFDalMsRUFBRTtRQUV0QixJQUFJdUssZUFBZUMsWUFBWXdILFFBQVE5UCxPQUFPLENBQUNsQyxLQUFLLEdBQUc7WUFDckQsMEdBQTBHO1lBQzFHNEssWUFBWWpPLHNEQUFPQSxDQUFDNE47WUFDcEJJLFVBQVVoTyxzREFBT0EsQ0FBQzZOO1lBQ2xCSCxXQUFXTyxjQUFjRCxVQUFVdEMsZUFBZXZILFFBQVFkLEdBQUd1SyxZQUFZSSxXQUFXbkMsV0FBVytCO1lBQy9GRSxTQUFTakMsV0FBV2dDO1lBQ3BCakQsT0FBT0ssR0FBRyxHQUFHLElBQUlySyxvREFBU0EsQ0FBQ2dLLE9BQU9LLEdBQUcsRUFBRXFLLFVBQVVqUyxHQUFHcUssVUFBVUksU0FBU0osVUFBVTFLO1lBQ2pGNEgsT0FBT0ssR0FBRyxDQUFDeEgsQ0FBQyxHQUFHdUssV0FBVztZQUUxQnBELE9BQU9NLE1BQU0sQ0FBQzlFLElBQUksQ0FBQy9DO1FBQ3JCO0lBQ0Y7SUFFQTRSLFFBQVFLLFVBQVVGO0FBQ3BCLEdBQUcsOFJBQThSO0FBR2pTL1UsMkRBQVlBLENBQUMsK0JBQStCLFNBQVVrVixJQUFJLEVBQUVqSSxLQUFLO0lBQy9ELElBQUlsSyxJQUFJLE9BQ0pzTCxJQUFJLFNBQ0o3SyxJQUFJLFVBQ0oyUixJQUFJLFFBQ0p4UCxRQUFRLENBQUNzSCxRQUFRLElBQUk7UUFBQ2xLO1FBQUdzTDtRQUFHN0s7UUFBRzJSO0tBQUUsR0FBRztRQUFDcFMsSUFBSW9TO1FBQUdwUyxJQUFJc0w7UUFBRzdLLElBQUk2SztRQUFHN0ssSUFBSTJSO0tBQUUsRUFBRXpGLEdBQUcsQ0FBQyxTQUFVMEYsSUFBSTtRQUN0RixPQUFPbkksUUFBUSxJQUFJaUksT0FBT0UsT0FBTyxXQUFXQSxPQUFPRjtJQUNyRDtJQUVBckksYUFBYSxDQUFDSSxRQUFRLElBQUksV0FBV2lJLE9BQU9BLEtBQUssR0FBRyxTQUFVM0ssTUFBTSxFQUFFekcsTUFBTSxFQUFFQyxRQUFRLEVBQUV5SixRQUFRLEVBQUV1QixLQUFLO1FBQ3JHLElBQUkxSixHQUFHZ1E7UUFFUCxJQUFJQyxVQUFValAsTUFBTSxHQUFHLEdBQUc7WUFDeEIsMERBQTBEO1lBQzFEaEIsSUFBSU0sTUFBTStKLEdBQUcsQ0FBQyxTQUFVM0MsSUFBSTtnQkFDMUIsT0FBT3pILEtBQUtpRixRQUFRd0MsTUFBTWhKO1lBQzVCO1lBQ0FzUixPQUFPaFEsRUFBRXdKLElBQUksQ0FBQztZQUNkLE9BQU93RyxLQUFLbFEsS0FBSyxDQUFDRSxDQUFDLENBQUMsRUFBRSxFQUFFZ0IsTUFBTSxLQUFLLElBQUloQixDQUFDLENBQUMsRUFBRSxHQUFHZ1E7UUFDaEQ7UUFFQWhRLElBQUksQ0FBQ21JLFdBQVcsRUFBQyxFQUFHckksS0FBSyxDQUFDO1FBQzFCa1EsT0FBTyxDQUFDO1FBQ1IxUCxNQUFNUCxPQUFPLENBQUMsU0FBVTJILElBQUksRUFBRTNHLENBQUM7WUFDN0IsT0FBT2lQLElBQUksQ0FBQ3RJLEtBQUssR0FBRzFILENBQUMsQ0FBQ2UsRUFBRSxHQUFHZixDQUFDLENBQUNlLEVBQUUsSUFBSWYsQ0FBQyxDQUFDLENBQUNlLElBQUksS0FBSyxJQUFJLEVBQUU7UUFDdkQ7UUFDQW1FLE9BQU9nTCxJQUFJLENBQUN6UixRQUFRdVIsTUFBTXRHO0lBQzVCO0FBQ0Y7QUFFTyxJQUFJeUcsWUFBWTtJQUNyQk4sTUFBTTtJQUNOTyxVQUFVck47SUFDVnNOLFlBQVksU0FBU0EsV0FBVzVSLE1BQU07UUFDcEMsT0FBT0EsT0FBT0UsS0FBSyxJQUFJRixPQUFPNlIsUUFBUTtJQUN4QztJQUNBSixNQUFNLFNBQVNBLEtBQUt6UixNQUFNLEVBQUV1UixJQUFJLEVBQUV0RyxLQUFLLEVBQUU5QixLQUFLLEVBQUUySSxPQUFPO1FBQ3JELElBQUlqUSxRQUFRLElBQUksQ0FBQ2tGLE1BQU0sRUFDbkI3RyxRQUFRRixPQUFPRSxLQUFLLEVBQ3BCNlIsVUFBVTlHLE1BQU1zRyxJQUFJLENBQUNRLE9BQU8sRUFDNUJ0SSxZQUNBQyxVQUNBQyxRQUNBSixVQUNBaEcsTUFDQXlPLGFBQ0E5UyxHQUNBNEssV0FDQUQsU0FDQW9JLFVBQ0FDLG9CQUNBQyxvQkFDQXhSLE9BQ0ErTCxRQUNBMEYsYUFDQUM7UUFDSjlVLGtCQUFrQitHLGFBQWEscUtBQXFLO1FBRXBNLElBQUksQ0FBQ2dPLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU0sSUFBSXhQLGVBQWU5QztRQUM1Q3FTLGNBQWMsSUFBSSxDQUFDQyxNQUFNLENBQUN6USxLQUFLO1FBQy9CLElBQUksQ0FBQ29KLEtBQUssR0FBR0E7UUFFYixJQUFLL0wsS0FBS3FTLEtBQU07WUFDZCxJQUFJclMsTUFBTSxhQUFhO2dCQUNyQjtZQUNGO1lBRUF3SyxXQUFXNkgsSUFBSSxDQUFDclMsRUFBRTtZQUVsQixJQUFJM0MsbURBQVEsQ0FBQzJDLEVBQUUsSUFBSTdDLDJEQUFZQSxDQUFDNkMsR0FBR3FTLE1BQU10RyxPQUFPOUIsT0FBT25KLFFBQVE4UixVQUFVO2dCQUV2RTtZQUNGO1lBRUF2TyxPQUFPLE9BQU9tRyx5Q0FBUCx3REFBT0E7WUFDZHNJLGNBQWNqSixhQUFhLENBQUM3SixFQUFFO1lBRTlCLElBQUlxRSxTQUFTLFlBQVk7Z0JBQ3ZCbUcsV0FBV0EsU0FBUzlILElBQUksQ0FBQ3FKLE9BQU85QixPQUFPbkosUUFBUThSO2dCQUMvQ3ZPLE9BQU8sT0FBT21HLHlDQUFQLHdEQUFPQTtZQUNoQjtZQUVBLElBQUluRyxTQUFTLFlBQVksQ0FBQ21HLFNBQVN0SSxPQUFPLENBQUMsWUFBWTtnQkFDckRzSSxXQUFXcE4sNkRBQWNBLENBQUNvTjtZQUM1QjtZQUVBLElBQUlzSSxhQUFhO2dCQUNmQSxZQUFZLElBQUksRUFBRWhTLFFBQVFkLEdBQUd3SyxVQUFVdUIsVUFBV21ILENBQUFBLGNBQWM7WUFDbEUsT0FBTyxJQUFJbFQsRUFBRXNELE1BQU0sQ0FBQyxHQUFHLE9BQU8sTUFBTTtnQkFDbEMsY0FBYztnQkFDZGlILGFBQWEsQ0FBQzNGLGlCQUFpQjlELFFBQVErRCxnQkFBZ0IsQ0FBQzdFLEtBQUssRUFBQyxFQUFHMEksSUFBSTtnQkFDckU4QixZQUFZO2dCQUNaMU0sb0RBQVNBLENBQUNtTixTQUFTLEdBQUc7Z0JBRXRCLElBQUksQ0FBQ25OLG9EQUFTQSxDQUFDOEssSUFBSSxDQUFDMkIsYUFBYTtvQkFDL0IsMEJBQTBCO29CQUMxQkssWUFBWWpPLHNEQUFPQSxDQUFDNE47b0JBQ3BCSSxVQUFVaE8sc0RBQU9BLENBQUM2TjtnQkFDcEI7Z0JBRUFHLFVBQVVDLGNBQWNELFdBQVlKLENBQUFBLGFBQWFsQyxlQUFldkgsUUFBUWQsR0FBR3VLLFlBQVlJLFdBQVdBLE9BQU0sSUFBS0MsYUFBY0osQ0FBQUEsWUFBWUksU0FBUTtnQkFDL0ksSUFBSSxDQUFDeUksR0FBRyxDQUFDclMsT0FBTyxlQUFldUosWUFBWUMsVUFBVVAsT0FBTzJJLFNBQVMsR0FBRyxHQUFHNVM7Z0JBQzNFMkMsTUFBTUksSUFBSSxDQUFDL0M7Z0JBQ1htVCxZQUFZcFEsSUFBSSxDQUFDL0MsR0FBRyxHQUFHZ0IsS0FBSyxDQUFDaEIsRUFBRTtZQUNqQyxPQUFPLElBQUlxRSxTQUFTLGFBQWE7Z0JBQy9CLElBQUl3TyxXQUFXN1MsS0FBSzZTLFNBQVM7b0JBQzNCLCtJQUErSTtvQkFDL0l0SSxhQUFhLE9BQU9zSSxPQUFPLENBQUM3UyxFQUFFLEtBQUssYUFBYTZTLE9BQU8sQ0FBQzdTLEVBQUUsQ0FBQzBDLElBQUksQ0FBQ3FKLE9BQU85QixPQUFPbkosUUFBUThSLFdBQVdDLE9BQU8sQ0FBQzdTLEVBQUU7b0JBQzNHcEQsd0RBQVNBLENBQUMyTixlQUFlLENBQUNBLFdBQVdySSxPQUFPLENBQUMsY0FBZXFJLENBQUFBLGFBQWFuTiw2REFBY0EsQ0FBQ21OLFdBQVU7b0JBQ2xHNU4sc0RBQU9BLENBQUM0TixhQUFhLE9BQU9BLGVBQWUsVUFBV0EsQ0FBQUEsY0FBYy9NLGtEQUFPQSxDQUFDME4sS0FBSyxDQUFDbEwsRUFBRSxJQUFJckQsc0RBQU9BLENBQUMyRixLQUFLeEIsUUFBUWQsT0FBTyxFQUFDLEdBQUksd0hBQXdIO29CQUVoUHVLLENBQUFBLGFBQWEsRUFBQyxFQUFHckYsTUFBTSxDQUFDLE9BQU8sT0FBUXFGLENBQUFBLGFBQWFqSSxLQUFLeEIsUUFBUWQsRUFBQyxHQUFJLGtDQUFrQztnQkFDM0csT0FBTztvQkFDTHVLLGFBQWFqSSxLQUFLeEIsUUFBUWQ7Z0JBQzVCO2dCQUVBcUssV0FBVzdCLFdBQVcrQjtnQkFDdEJ3SSxXQUFXMU8sU0FBUyxZQUFZbUcsU0FBU3RGLE1BQU0sQ0FBQyxPQUFPLE9BQU9zRixTQUFTbEgsTUFBTSxDQUFDLEdBQUc7Z0JBQ2pGeVAsWUFBYXZJLENBQUFBLFdBQVdBLFNBQVNsSCxNQUFNLENBQUMsRUFBQztnQkFDekNtSCxTQUFTakMsV0FBV2dDO2dCQUVwQixJQUFJeEssS0FBS1Qsa0JBQWtCO29CQUN6QixJQUFJUyxNQUFNLGFBQWE7d0JBQ3JCLG9JQUFvSTt3QkFDcEksSUFBSXFLLGFBQWEsS0FBSy9ILEtBQUt4QixRQUFRLGtCQUFrQixZQUFZMkosUUFBUTs0QkFDdkUsa0hBQWtIOzRCQUNsSEosV0FBVzt3QkFDYjt3QkFFQThJLFlBQVlwUSxJQUFJLENBQUMsY0FBYyxHQUFHL0IsTUFBTXNTLFVBQVU7d0JBRWxEaE0sa0JBQWtCLElBQUksRUFBRXRHLE9BQU8sY0FBY3FKLFdBQVcsWUFBWSxVQUFVSSxTQUFTLFlBQVksVUFBVSxDQUFDQTtvQkFDaEg7b0JBRUEsSUFBSXpLLE1BQU0sV0FBV0EsTUFBTSxhQUFhO3dCQUN0Q0EsSUFBSVQsZ0JBQWdCLENBQUNTLEVBQUU7d0JBQ3ZCLENBQUNBLEVBQUVrQyxPQUFPLENBQUMsUUFBU2xDLENBQUFBLElBQUlBLEVBQUVtQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7b0JBQ3pDO2dCQUNGO2dCQUVBNlEscUJBQXFCaFQsS0FBS3BCLGlCQUFpQiwyQkFBMkI7Z0JBRXRFLElBQUlvVSxvQkFBb0I7b0JBQ3RCLElBQUksQ0FBQ0ksTUFBTSxDQUFDcFAsSUFBSSxDQUFDaEU7b0JBRWpCLElBQUksQ0FBQ2lULG9CQUFvQjt3QkFDdkJ4UixRQUFRWCxPQUFPTSxLQUFLO3dCQUNwQkssTUFBTUMsZUFBZSxJQUFJLENBQUMyUSxLQUFLa0IsY0FBYyxJQUFJN0osZ0JBQWdCNUksUUFBUXVSLEtBQUtrQixjQUFjLEdBQUcsc01BQXNNO3dCQUVyUy9GLFNBQVM2RSxLQUFLbUIsWUFBWSxLQUFLLFNBQVMvUixNQUFNK0wsTUFBTTt3QkFDcER5RixxQkFBcUIsSUFBSSxDQUFDckwsR0FBRyxHQUFHLElBQUlySyxvREFBU0EsQ0FBQyxJQUFJLENBQUNxSyxHQUFHLEVBQUU1RyxPQUFPWSxnQkFBZ0IsR0FBRyxHQUFHSCxNQUFNQyxlQUFlLEVBQUVELE9BQU8sR0FBRyxDQUFDLElBQUksbUlBQW1JO3dCQUU5UHdSLG1CQUFtQlEsR0FBRyxHQUFHLEdBQUcsd0lBQXdJO29CQUN0SztvQkFFQSxJQUFJelQsTUFBTSxTQUFTO3dCQUNqQixJQUFJLENBQUM0SCxHQUFHLEdBQUcsSUFBSXJLLG9EQUFTQSxDQUFDLElBQUksQ0FBQ3FLLEdBQUcsRUFBRW5HLE9BQU8sVUFBVUEsTUFBTUYsTUFBTSxFQUFFLENBQUN3UixXQUFXaFYsNkRBQWNBLENBQUMwRCxNQUFNRixNQUFNLEVBQUV3UixXQUFXdEksVUFBVUEsTUFBSyxJQUFLaEosTUFBTUYsTUFBTSxJQUFJLEdBQUc1Qjt3QkFDN0osSUFBSSxDQUFDaUksR0FBRyxDQUFDeEgsQ0FBQyxHQUFHO3dCQUNidUMsTUFBTUksSUFBSSxDQUFDLFVBQVUvQzt3QkFDckJBLEtBQUs7b0JBQ1AsT0FBTyxJQUFJQSxNQUFNLG1CQUFtQjt3QkFDbENtVCxZQUFZcFEsSUFBSSxDQUFDbEIsc0JBQXNCLEdBQUdiLEtBQUssQ0FBQ2EscUJBQXFCO3dCQUNyRTJJLFdBQVdvQiw4QkFBOEJwQixXQUFXLDJGQUEyRjt3QkFFL0ksSUFBSS9JLE1BQU1tQixHQUFHLEVBQUU7NEJBQ2IwSyxnQkFBZ0J4TSxRQUFRMEosVUFBVSxHQUFHZ0QsUUFBUSxHQUFHLElBQUk7d0JBQ3RELE9BQU87NEJBQ0w3QyxVQUFVbkMsV0FBV2dDLFNBQVNySSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxHQUFHLGdDQUFnQzs0QkFFbkZ3SSxZQUFZbEosTUFBTWUsT0FBTyxJQUFJOEUsa0JBQWtCLElBQUksRUFBRTdGLE9BQU8sV0FBV0EsTUFBTWUsT0FBTyxFQUFFbUk7NEJBRXRGckQsa0JBQWtCLElBQUksRUFBRXRHLE9BQU9oQixHQUFHNEosY0FBY1csYUFBYVgsY0FBY1k7d0JBQzdFO3dCQUVBO29CQUNGLE9BQU8sSUFBSXhLLE1BQU0sYUFBYTt3QkFDNUJzTixnQkFBZ0J4TSxRQUFRMEosVUFBVSxHQUFHZ0QsUUFBUSxHQUFHLElBQUk7d0JBRXBEO29CQUNGLE9BQU8sSUFBSXhOLEtBQUtzTSx1QkFBdUI7d0JBQ3JDZ0Ysd0JBQXdCLElBQUksRUFBRTdQLE9BQU96QixHQUFHcUssVUFBVTBJLFdBQVdoViw2REFBY0EsQ0FBQ3NNLFVBQVUwSSxXQUFXdkksWUFBWUE7d0JBRTdHO29CQUNGLE9BQU8sSUFBSXhLLE1BQU0sZ0JBQWdCO3dCQUMvQnNILGtCQUFrQixJQUFJLEVBQUU3RixPQUFPLFVBQVVBLE1BQU0rTCxNQUFNLEVBQUVoRDt3QkFFdkQ7b0JBQ0YsT0FBTyxJQUFJeEssTUFBTSxXQUFXO3dCQUMxQnlCLEtBQUssQ0FBQ3pCLEVBQUUsR0FBR3dLO3dCQUNYO29CQUNGLE9BQU8sSUFBSXhLLE1BQU0sYUFBYTt3QkFDNUI4UixvQkFBb0IsSUFBSSxFQUFFdEgsVUFBVTFKO3dCQUVwQztvQkFDRjtnQkFDRixPQUFPLElBQUksQ0FBRWQsQ0FBQUEsS0FBS2dCLEtBQUksR0FBSTtvQkFDeEJoQixJQUFJOEUsaUJBQWlCOUUsTUFBTUE7Z0JBQzdCO2dCQUVBLElBQUlnVCxzQkFBc0IsQ0FBQ3ZJLFVBQVVBLFdBQVcsTUFBT0osQ0FBQUEsWUFBWUEsYUFBYSxNQUFNLENBQUMvSyxZQUFZc0osSUFBSSxDQUFDNEIsYUFBYXhLLEtBQUtnQixPQUFPO29CQUMvSDRKLFlBQVksQ0FBQ0wsYUFBYSxFQUFDLEVBQUdqSCxNQUFNLENBQUMsQ0FBQytHLFdBQVcsRUFBQyxFQUFHaEgsTUFBTTtvQkFDM0RvSCxVQUFXQSxDQUFBQSxTQUFTLElBQUksc0JBQXNCO29CQUU5Q0UsVUFBVWhPLHNEQUFPQSxDQUFDNk4sYUFBY3hLLENBQUFBLEtBQUt4QyxrREFBT0EsQ0FBQzBOLEtBQUssR0FBRzFOLGtEQUFPQSxDQUFDME4sS0FBSyxDQUFDbEwsRUFBRSxHQUFHNEssU0FBUTtvQkFDaEZBLGNBQWNELFdBQVlOLENBQUFBLFdBQVdoQyxlQUFldkgsUUFBUWQsR0FBR3VLLFlBQVlJLFFBQU87b0JBQ2xGLElBQUksQ0FBQy9DLEdBQUcsR0FBRyxJQUFJckssb0RBQVNBLENBQUMsSUFBSSxDQUFDcUssR0FBRyxFQUFFb0wscUJBQXFCdlIsUUFBUVQsT0FBT2hCLEdBQUdxSyxVQUFVLENBQUMwSSxXQUFXaFYsNkRBQWNBLENBQUNzTSxVQUFVMEksV0FBV3RJLFVBQVVBLE1BQUssSUFBS0osVUFBVSxDQUFDMkksc0JBQXVCckksQ0FBQUEsWUFBWSxRQUFRM0ssTUFBTSxRQUFPLEtBQU1xUyxLQUFLcUIsU0FBUyxLQUFLLFFBQVFqVCx3QkFBd0JkO29CQUNwUixJQUFJLENBQUNpSSxHQUFHLENBQUN4SCxDQUFDLEdBQUd1SyxXQUFXO29CQUV4QixJQUFJQyxjQUFjRCxXQUFXQSxZQUFZLEtBQUs7d0JBQzVDLG1QQUFtUDt3QkFDblAsSUFBSSxDQUFDL0MsR0FBRyxDQUFDcEgsQ0FBQyxHQUFHK0o7d0JBQ2IsSUFBSSxDQUFDM0MsR0FBRyxDQUFDeUQsQ0FBQyxHQUFHOUs7b0JBQ2Y7Z0JBQ0YsT0FBTyxJQUFJLENBQUVQLENBQUFBLEtBQUtnQixLQUFJLEdBQUk7b0JBQ3hCLElBQUloQixLQUFLYyxRQUFRO3dCQUNmLHVIQUF1SDt3QkFDdkgsSUFBSSxDQUFDdVMsR0FBRyxDQUFDdlMsUUFBUWQsR0FBR3VLLGNBQWN6SixNQUFNLENBQUNkLEVBQUUsRUFBRStTLFdBQVdBLFdBQVd2SSxXQUFXQSxVQUFVUCxPQUFPMkk7b0JBQ2pHLE9BQU8sSUFBSTVTLE1BQU0sa0JBQWtCO3dCQUNqQ3JDLDZEQUFjQSxDQUFDcUMsR0FBR3dLO3dCQUVsQjtvQkFDRjtnQkFDRixPQUFPO29CQUNMVix1QkFBdUJwSCxJQUFJLENBQUMsSUFBSSxFQUFFNUIsUUFBUWQsR0FBR3VLLFlBQVl3SSxXQUFXQSxXQUFXdkksV0FBV0E7Z0JBQzVGO2dCQUVBd0ksc0JBQXVCaFQsQ0FBQUEsS0FBS2dCLFFBQVFtUyxZQUFZcFEsSUFBSSxDQUFDL0MsR0FBRyxHQUFHZ0IsS0FBSyxDQUFDaEIsRUFBRSxJQUFJbVQsWUFBWXBRLElBQUksQ0FBQy9DLEdBQUcsR0FBR3VLLGNBQWN6SixNQUFNLENBQUNkLEVBQUU7Z0JBQ3JIMkMsTUFBTUksSUFBSSxDQUFDL0M7WUFDYjtRQUNGO1FBRUFrVCxlQUFlalcsd0VBQXlCQSxDQUFDLElBQUk7SUFDL0M7SUFDQTBXLFFBQVEsU0FBU0EsT0FBTy9ULEtBQUssRUFBRUMsSUFBSTtRQUNqQyxJQUFJQSxLQUFLa00sS0FBSyxDQUFDQyxLQUFLLElBQUksQ0FBQ3ZOLGNBQWM7WUFDckMsSUFBSWtKLEtBQUs5SCxLQUFLK0gsR0FBRztZQUVqQixNQUFPRCxHQUFJO2dCQUNUQSxHQUFHMEQsQ0FBQyxDQUFDekwsT0FBTytILEdBQUd1RixDQUFDO2dCQUNoQnZGLEtBQUtBLEdBQUd3RCxLQUFLO1lBQ2Y7UUFDRixPQUFPO1lBQ0x0TCxLQUFLdVQsTUFBTSxDQUFDclAsTUFBTTtRQUNwQjtJQUNGO0lBQ0E2UCxLQUFLdFI7SUFDTHVSLFNBQVN0VTtJQUNUdVUsV0FBVyxTQUFTQSxVQUFVaFQsTUFBTSxFQUFFQyxRQUFRLEVBQUV3RyxNQUFNO1FBQ3BELHVSQUF1UjtRQUN2UixJQUFJdkgsSUFBSVQsZ0JBQWdCLENBQUN3QixTQUFTO1FBQ2xDZixLQUFLQSxFQUFFa0MsT0FBTyxDQUFDLE9BQU8sS0FBTW5CLENBQUFBLFdBQVdmLENBQUFBO1FBQ3ZDLE9BQU9lLFlBQVluQyxtQkFBbUJtQyxhQUFhYyx3QkFBeUJmLENBQUFBLE9BQU9NLEtBQUssQ0FBQ21CLENBQUMsSUFBSUQsS0FBS3hCLFFBQVEsSUFBRyxJQUFLeUcsVUFBVS9JLHdCQUF3QitJLFNBQVN4RyxhQUFhLFVBQVVNLGVBQWVGLG1CQUFtQixDQUFDM0Msc0JBQXNCK0ksVUFBVSxDQUFDLE1BQU94RyxDQUFBQSxhQUFhLFVBQVVTLHlCQUF5QkcsMEJBQXlCLElBQUtiLE9BQU9FLEtBQUssSUFBSSxDQUFDbkUsMkRBQVlBLENBQUNpRSxPQUFPRSxLQUFLLENBQUNELFNBQVMsSUFBSUYsa0JBQWtCLENBQUNFLFNBQVNtQixPQUFPLENBQUMsT0FBT2pCLGlCQUFpQnJELHlEQUFVQSxDQUFDa0QsUUFBUUM7SUFDdmQ7SUFDQWtELE1BQU07UUFDSmtELGlCQUFpQkE7UUFDakJ3RixZQUFZQTtJQUNkO0FBQ0YsRUFBRTtBQUNGcFEsK0NBQUlBLENBQUN3WCxLQUFLLENBQUNDLFdBQVcsR0FBR2xQO0FBQ3pCdkksK0NBQUlBLENBQUMwSCxJQUFJLENBQUNnUSxhQUFhLEdBQUdyUTtBQUV6QixVQUFVc1EsZ0JBQWdCLEVBQUV6RixRQUFRLEVBQUUwRixNQUFNLEVBQUVOLE9BQU87SUFDcEQsSUFBSU8sTUFBTXBYLDJEQUFZQSxDQUFDa1gsbUJBQW1CLE1BQU16RixXQUFXLE1BQU0wRixRQUFRLFNBQVVqQyxJQUFJO1FBQ3JGdFQsZUFBZSxDQUFDc1QsS0FBSyxHQUFHO0lBQzFCO0lBRUFsViwyREFBWUEsQ0FBQ3lSLFVBQVUsU0FBVXlELElBQUk7UUFDbkMxVSxrREFBT0EsQ0FBQzBOLEtBQUssQ0FBQ2dILEtBQUssR0FBRztRQUN0QjVGLHFCQUFxQixDQUFDNEYsS0FBSyxHQUFHO0lBQ2hDO0lBRUEzUyxnQkFBZ0IsQ0FBQzZVLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBR0YsbUJBQW1CLE1BQU16RjtJQUVyRHpSLDJEQUFZQSxDQUFDNlcsU0FBUyxTQUFVM0IsSUFBSTtRQUNsQyxJQUFJL1AsUUFBUStQLEtBQUsvUCxLQUFLLENBQUM7UUFDdkI1QyxnQkFBZ0IsQ0FBQzRDLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBR2lTLEdBQUcsQ0FBQ2pTLEtBQUssQ0FBQyxFQUFFLENBQUM7SUFDNUM7QUFDRixHQUFHLCtDQUErQyw0Q0FBNEMsaUZBQWlGO0FBRS9LbkYsMkRBQVlBLENBQUMsZ0ZBQWdGLFNBQVVrVixJQUFJO0lBQ3pHMVUsa0RBQU9BLENBQUMwTixLQUFLLENBQUNnSCxLQUFLLEdBQUc7QUFDeEI7QUFFQTNWLCtDQUFJQSxDQUFDOFgsY0FBYyxDQUFDN0I7QUFDdUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dzYXBAMy4xMi41L25vZGVfbW9kdWxlcy9nc2FwL0NTU1BsdWdpbi5qcz8yZDdkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ1NTUGx1Z2luIDMuMTIuNVxuICogaHR0cHM6Ly9nc2FwLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDA4LTIwMjQsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3NhcC5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR1NBUCBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCB7IGdzYXAsIF9nZXRQcm9wZXJ0eSwgX251bUV4cCwgX251bVdpdGhVbml0RXhwLCBnZXRVbml0LCBfaXNTdHJpbmcsIF9pc1VuZGVmaW5lZCwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIF9yZWxFeHAsIF9mb3JFYWNoTmFtZSwgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSwgX2NvbG9yU3RyaW5nRmlsdGVyLCBfY2hlY2tQbHVnaW4sIF9yZXBsYWNlUmFuZG9tLCBfcGx1Z2lucywgR1NDYWNoZSwgUHJvcFR3ZWVuLCBfY29uZmlnLCBfdGlja2VyLCBfcm91bmQsIF9taXNzaW5nUGx1Z2luLCBfZ2V0U2V0dGVyLCBfZ2V0Q2FjaGUsIF9jb2xvckV4cCwgX3BhcnNlUmVsYXRpdmUsIF9zZXREZWZhdWx0cywgX3JlbW92ZUxpbmtlZExpc3RJdGVtIC8vZm9yIHRoZSBjb21tZW50ZWQtb3V0IGNsYXNzTmFtZSBmZWF0dXJlLlxufSBmcm9tIFwiLi9nc2FwLWNvcmUuanNcIjtcblxudmFyIF93aW4sXG4gICAgX2RvYyxcbiAgICBfZG9jRWxlbWVudCxcbiAgICBfcGx1Z2luSW5pdHRlZCxcbiAgICBfdGVtcERpdixcbiAgICBfdGVtcERpdlN0eWxlcixcbiAgICBfcmVjZW50U2V0dGVyUGx1Z2luLFxuICAgIF9yZXZlcnRpbmcsXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfdHJhbnNmb3JtUHJvcHMgPSB7fSxcbiAgICBfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG4gICAgX0RFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLFxuICAgIF9hdGFuMiA9IE1hdGguYXRhbjIsXG4gICAgX2JpZ051bSA9IDFlOCxcbiAgICBfY2Fwc0V4cCA9IC8oW0EtWl0pL2csXG4gICAgX2hvcml6b250YWxFeHAgPSAvKGxlZnR8cmlnaHR8d2lkdGh8bWFyZ2lufHBhZGRpbmd8eCkvaSxcbiAgICBfY29tcGxleEV4cCA9IC9bXFxzLFxcKF1cXFMvLFxuICAgIF9wcm9wZXJ0eUFsaWFzZXMgPSB7XG4gIGF1dG9BbHBoYTogXCJvcGFjaXR5LHZpc2liaWxpdHlcIixcbiAgc2NhbGU6IFwic2NhbGVYLHNjYWxlWVwiLFxuICBhbHBoYTogXCJvcGFjaXR5XCJcbn0sXG4gICAgX3JlbmRlckNTU1Byb3AgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTUHJvcChyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwICsgZGF0YS51LCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlclByb3BXaXRoRW5kID0gZnVuY3Rpb24gX3JlbmRlclByb3BXaXRoRW5kKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPT09IDEgPyBkYXRhLmUgOiBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCArIGRhdGEudSwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZyA9IGZ1bmN0aW9uIF9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZyhyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvID8gTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDAgKyBkYXRhLnUgOiBkYXRhLmIsIGRhdGEpO1xufSxcbiAgICAvL2lmIHVuaXRzIGNoYW5nZSwgd2UgbmVlZCBhIHdheSB0byByZW5kZXIgdGhlIG9yaWdpbmFsIHVuaXQvdmFsdWUgd2hlbiB0aGUgdHdlZW4gZ29lcyBhbGwgdGhlIHdheSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgKHJhdGlvOjApXG5fcmVuZGVyUm91bmRlZENTU1Byb3AgPSBmdW5jdGlvbiBfcmVuZGVyUm91bmRlZENTU1Byb3AocmF0aW8sIGRhdGEpIHtcbiAgdmFyIHZhbHVlID0gZGF0YS5zICsgZGF0YS5jICogcmF0aW87XG4gIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCB+fih2YWx1ZSArICh2YWx1ZSA8IDAgPyAtLjUgOiAuNSkpICsgZGF0YS51LCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlck5vblR3ZWVuaW5nVmFsdWUgPSBmdW5jdGlvbiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZShyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvID8gZGF0YS5lIDogZGF0YS5iLCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQgPSBmdW5jdGlvbiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZChyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvICE9PSAxID8gZGF0YS5iIDogZGF0YS5lLCBkYXRhKTtcbn0sXG4gICAgX3NldHRlckNTU1N0eWxlID0gZnVuY3Rpb24gX3NldHRlckNTU1N0eWxlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG59LFxuICAgIF9zZXR0ZXJDU1NQcm9wID0gZnVuY3Rpb24gX3NldHRlckNTU1Byb3AodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xufSxcbiAgICBfc2V0dGVyVHJhbnNmb3JtID0gZnVuY3Rpb24gX3NldHRlclRyYW5zZm9ybSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0Ll9nc2FwW3Byb3BlcnR5XSA9IHZhbHVlO1xufSxcbiAgICBfc2V0dGVyU2NhbGUgPSBmdW5jdGlvbiBfc2V0dGVyU2NhbGUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5fZ3NhcC5zY2FsZVggPSB0YXJnZXQuX2dzYXAuc2NhbGVZID0gdmFsdWU7XG59LFxuICAgIF9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIgPSBmdW5jdGlvbiBfc2V0dGVyU2NhbGVXaXRoUmVuZGVyKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhLCByYXRpbykge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXA7XG4gIGNhY2hlLnNjYWxlWCA9IGNhY2hlLnNjYWxlWSA9IHZhbHVlO1xuICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0ocmF0aW8sIGNhY2hlKTtcbn0sXG4gICAgX3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIgPSBmdW5jdGlvbiBfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlcih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSwgcmF0aW8pIHtcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuICBjYWNoZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgY2FjaGUucmVuZGVyVHJhbnNmb3JtKHJhdGlvLCBjYWNoZSk7XG59LFxuICAgIF90cmFuc2Zvcm1Qcm9wID0gXCJ0cmFuc2Zvcm1cIixcbiAgICBfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF90cmFuc2Zvcm1Qcm9wICsgXCJPcmlnaW5cIixcbiAgICBfc2F2ZVN0eWxlID0gZnVuY3Rpb24gX3NhdmVTdHlsZShwcm9wZXJ0eSwgaXNOb3RDU1MpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQsXG4gICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuXG4gIGlmIChwcm9wZXJ0eSBpbiBfdHJhbnNmb3JtUHJvcHMgJiYgc3R5bGUpIHtcbiAgICB0aGlzLnRmbSA9IHRoaXMudGZtIHx8IHt9O1xuXG4gICAgaWYgKHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICBwcm9wZXJ0eSA9IF9wcm9wZXJ0eUFsaWFzZXNbcHJvcGVydHldIHx8IHByb3BlcnR5O1xuICAgICAgfnByb3BlcnR5LmluZGV4T2YoXCIsXCIpID8gcHJvcGVydHkuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnRmbVthXSA9IF9nZXQodGFyZ2V0LCBhKTtcbiAgICAgIH0pIDogdGhpcy50Zm1bcHJvcGVydHldID0gY2FjaGUueCA/IGNhY2hlW3Byb3BlcnR5XSA6IF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSk7IC8vIG5vdGU6IHNjYWxlIHdvdWxkIG1hcCB0byBcInNjYWxlWCxzY2FsZVlcIiwgdGh1cyB3ZSBsb29wIGFuZCBhcHBseSB0aGVtIGJvdGguXG5cbiAgICAgIHByb3BlcnR5ID09PSBfdHJhbnNmb3JtT3JpZ2luUHJvcCAmJiAodGhpcy50Zm0uek9yaWdpbiA9IGNhY2hlLnpPcmlnaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX3Byb3BlcnR5QWxpYXNlcy50cmFuc2Zvcm0uc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIF9zYXZlU3R5bGUuY2FsbChfdGhpcywgcCwgaXNOb3RDU1MpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMuaW5kZXhPZihfdHJhbnNmb3JtUHJvcCkgPj0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgIHRoaXMuc3ZnbyA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIik7XG4gICAgICB0aGlzLnByb3BzLnB1c2goX3RyYW5zZm9ybU9yaWdpblByb3AsIGlzTm90Q1NTLCBcIlwiKTtcbiAgICB9XG5cbiAgICBwcm9wZXJ0eSA9IF90cmFuc2Zvcm1Qcm9wO1xuICB9XG5cbiAgKHN0eWxlIHx8IGlzTm90Q1NTKSAmJiB0aGlzLnByb3BzLnB1c2gocHJvcGVydHksIGlzTm90Q1NTLCBzdHlsZVtwcm9wZXJ0eV0pO1xufSxcbiAgICBfcmVtb3ZlSW5kZXBlbmRlbnRUcmFuc2Zvcm1zID0gZnVuY3Rpb24gX3JlbW92ZUluZGVwZW5kZW50VHJhbnNmb3JtcyhzdHlsZSkge1xuICBpZiAoc3R5bGUudHJhbnNsYXRlKSB7XG4gICAgc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0cmFuc2xhdGVcIik7XG4gICAgc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJzY2FsZVwiKTtcbiAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eShcInJvdGF0ZVwiKTtcbiAgfVxufSxcbiAgICBfcmV2ZXJ0U3R5bGUgPSBmdW5jdGlvbiBfcmV2ZXJ0U3R5bGUoKSB7XG4gIHZhciBwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldCxcbiAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICBpLFxuICAgICAgcDtcblxuICBmb3IgKGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAvLyBzdG9yZWQgbGlrZSB0aGlzOiBwcm9wZXJ0eSwgaXNOb3RDU1MsIHZhbHVlXG4gICAgcHJvcHNbaSArIDFdID8gdGFyZ2V0W3Byb3BzW2ldXSA9IHByb3BzW2kgKyAyXSA6IHByb3BzW2kgKyAyXSA/IHN0eWxlW3Byb3BzW2ldXSA9IHByb3BzW2kgKyAyXSA6IHN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3BzW2ldLnN1YnN0cigwLCAyKSA9PT0gXCItLVwiID8gcHJvcHNbaV0gOiBwcm9wc1tpXS5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIGlmICh0aGlzLnRmbSkge1xuICAgIGZvciAocCBpbiB0aGlzLnRmbSkge1xuICAgICAgY2FjaGVbcF0gPSB0aGlzLnRmbVtwXTtcbiAgICB9XG5cbiAgICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0oKTtcbiAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIiwgdGhpcy5zdmdvIHx8IFwiXCIpO1xuICAgIH1cblxuICAgIGkgPSBfcmV2ZXJ0aW5nKCk7XG5cbiAgICBpZiAoKCFpIHx8ICFpLmlzU3RhcnQpICYmICFzdHlsZVtfdHJhbnNmb3JtUHJvcF0pIHtcbiAgICAgIF9yZW1vdmVJbmRlcGVuZGVudFRyYW5zZm9ybXMoc3R5bGUpO1xuXG4gICAgICBpZiAoY2FjaGUuek9yaWdpbiAmJiBzdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0pIHtcbiAgICAgICAgc3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdICs9IFwiIFwiICsgY2FjaGUuek9yaWdpbiArIFwicHhcIjsgLy8gc2luY2Ugd2UncmUgdW5jYWNoaW5nLCB3ZSBtdXN0IHB1dCB0aGUgek9yaWdpbiBiYWNrIGludG8gdGhlIHRyYW5zZm9ybU9yaWdpbiBzbyB0aGF0IHdlIGNhbiBwdWxsIGl0IG91dCBhY2N1cmF0ZWx5IHdoZW4gd2UgcGFyc2UgYWdhaW4uIE90aGVyd2lzZSwgd2UnZCBsb3NlIHRoZSB6IHBvcnRpb24gb2YgdGhlIG9yaWdpbiBzaW5jZSB3ZSBleHRyYWN0IGl0IHRvIHByb3RlY3QgZnJvbSBTYWZhcmkgYnVncy5cblxuICAgICAgICBjYWNoZS56T3JpZ2luID0gMDtcbiAgICAgICAgY2FjaGUucmVuZGVyVHJhbnNmb3JtKCk7XG4gICAgICB9XG5cbiAgICAgIGNhY2hlLnVuY2FjaGUgPSAxOyAvLyBpZiBpdCdzIGEgc3RhcnRBdCB0aGF0J3MgYmVpbmcgcmV2ZXJ0ZWQgaW4gdGhlIF9pbml0VHdlZW4oKSBvZiB0aGUgY29yZSwgd2UgZG9uJ3QgbmVlZCB0byB1bmNhY2hlIHRyYW5zZm9ybXMuIFRoaXMgaXMgcHVyZWx5IGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLlxuICAgIH1cbiAgfVxufSxcbiAgICBfZ2V0U3R5bGVTYXZlciA9IGZ1bmN0aW9uIF9nZXRTdHlsZVNhdmVyKHRhcmdldCwgcHJvcGVydGllcykge1xuICB2YXIgc2F2ZXIgPSB7XG4gICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgcHJvcHM6IFtdLFxuICAgIHJldmVydDogX3JldmVydFN0eWxlLFxuICAgIHNhdmU6IF9zYXZlU3R5bGVcbiAgfTtcbiAgdGFyZ2V0Ll9nc2FwIHx8IGdzYXAuY29yZS5nZXRDYWNoZSh0YXJnZXQpOyAvLyBqdXN0IG1ha2Ugc3VyZSB0aGVyZSdzIGEgX2dzYXAgY2FjaGUgZGVmaW5lZCBiZWNhdXNlIHdlIHJlYWQgZnJvbSBpdCBpbiBfc2F2ZVN0eWxlKCkgYW5kIGl0J3MgbW9yZSBlZmZpY2llbnQgdG8ganVzdCBjaGVjayBpdCBoZXJlIG9uY2UuXG5cbiAgcHJvcGVydGllcyAmJiBwcm9wZXJ0aWVzLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHNhdmVyLnNhdmUocCk7XG4gIH0pO1xuICByZXR1cm4gc2F2ZXI7XG59LFxuICAgIF9zdXBwb3J0czNELFxuICAgIF9jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQodHlwZSwgbnMpIHtcbiAgdmFyIGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyA/IF9kb2MuY3JlYXRlRWxlbWVudE5TKChucyB8fCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIikucmVwbGFjZSgvXmh0dHBzLywgXCJodHRwXCIpLCB0eXBlKSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIHNlcnZlcnMgc3dhcCBpbiBodHRwcyBmb3IgaHR0cCBpbiB0aGUgbmFtZXNwYWNlIHdoaWNoIGNhbiBicmVhayB0aGluZ3MsIG1ha2luZyBcInN0eWxlXCIgaW5hY2Nlc3NpYmxlLlxuXG4gIHJldHVybiBlICYmIGUuc3R5bGUgPyBlIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpOyAvL3NvbWUgZW52aXJvbm1lbnRzIHdvbid0IGFsbG93IGFjY2VzcyB0byB0aGUgZWxlbWVudCdzIHN0eWxlIHdoZW4gY3JlYXRlZCB3aXRoIGEgbmFtZXNwYWNlIGluIHdoaWNoIGNhc2Ugd2UgZGVmYXVsdCB0byB0aGUgc3RhbmRhcmQgY3JlYXRlRWxlbWVudCgpIHRvIHdvcmsgYXJvdW5kIHRoZSBpc3N1ZS4gQWxzbyBub3RlIHRoYXQgd2hlbiBHU0FQIGlzIGVtYmVkZGVkIGRpcmVjdGx5IGluc2lkZSBhbiBTVkcgZmlsZSwgY3JlYXRlRWxlbWVudCgpIHdvbid0IGFsbG93IGFjY2VzcyB0byB0aGUgc3R5bGUgb2JqZWN0IGluIEZpcmVmb3ggKHNlZSBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8yMDIxNS1wcm9ibGVtLXVzaW5nLXR3ZWVubWF4LWluLXN0YW5kYWxvbmUtc2VsZi1jb250YWluaW5nLXN2Zy1maWxlLWVyci1jYW5ub3Qtc2V0LXByb3BlcnR5LWNzc3RleHQtb2YtdW5kZWZpbmVkLykuXG59LFxuICAgIF9nZXRDb21wdXRlZFByb3BlcnR5ID0gZnVuY3Rpb24gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgc2tpcFByZWZpeEZhbGxiYWNrKSB7XG4gIHZhciBjcyA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgcmV0dXJuIGNzW3Byb3BlcnR5XSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5LnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpIHx8IGNzLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpIHx8ICFza2lwUHJlZml4RmFsbGJhY2sgJiYgX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfY2hlY2tQcm9wUHJlZml4KHByb3BlcnR5KSB8fCBwcm9wZXJ0eSwgMSkgfHwgXCJcIjsgLy9jc3MgdmFyaWFibGVzIG1heSBub3QgbmVlZCBjYXBzIHN3YXBwZWQgb3V0IGZvciBkYXNoZXMgYW5kIGxvd2VyY2FzZS5cbn0sXG4gICAgX3ByZWZpeGVzID0gXCJPLE1veixtcyxNcyxXZWJraXRcIi5zcGxpdChcIixcIiksXG4gICAgX2NoZWNrUHJvcFByZWZpeCA9IGZ1bmN0aW9uIF9jaGVja1Byb3BQcmVmaXgocHJvcGVydHksIGVsZW1lbnQsIHByZWZlclByZWZpeCkge1xuICB2YXIgZSA9IGVsZW1lbnQgfHwgX3RlbXBEaXYsXG4gICAgICBzID0gZS5zdHlsZSxcbiAgICAgIGkgPSA1O1xuXG4gIGlmIChwcm9wZXJ0eSBpbiBzICYmICFwcmVmZXJQcmVmaXgpIHtcbiAgICByZXR1cm4gcHJvcGVydHk7XG4gIH1cblxuICBwcm9wZXJ0eSA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc3Vic3RyKDEpO1xuXG4gIHdoaWxlIChpLS0gJiYgIShfcHJlZml4ZXNbaV0gKyBwcm9wZXJ0eSBpbiBzKSkge31cblxuICByZXR1cm4gaSA8IDAgPyBudWxsIDogKGkgPT09IDMgPyBcIm1zXCIgOiBpID49IDAgPyBfcHJlZml4ZXNbaV0gOiBcIlwiKSArIHByb3BlcnR5O1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoKSB7XG4gIGlmIChfd2luZG93RXhpc3RzKCkgJiYgd2luZG93LmRvY3VtZW50KSB7XG4gICAgX3dpbiA9IHdpbmRvdztcbiAgICBfZG9jID0gX3dpbi5kb2N1bWVudDtcbiAgICBfZG9jRWxlbWVudCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIF90ZW1wRGl2ID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIikgfHwge1xuICAgICAgc3R5bGU6IHt9XG4gICAgfTtcbiAgICBfdGVtcERpdlN0eWxlciA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIF90cmFuc2Zvcm1Qcm9wID0gX2NoZWNrUHJvcFByZWZpeChfdHJhbnNmb3JtUHJvcCk7XG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfdHJhbnNmb3JtUHJvcCArIFwiT3JpZ2luXCI7XG4gICAgX3RlbXBEaXYuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyLXdpZHRoOjA7bGluZS1oZWlnaHQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtwYWRkaW5nOjBcIjsgLy9tYWtlIHN1cmUgdG8gb3ZlcnJpZGUgY2VydGFpbiBwcm9wZXJ0aWVzIHRoYXQgbWF5IGNvbnRhbWluYXRlIG1lYXN1cmVtZW50cywgaW4gY2FzZSB0aGUgdXNlciBoYXMgb3ZlcnJlYWNoaW5nIHN0eWxlIHNoZWV0cy5cblxuICAgIF9zdXBwb3J0czNEID0gISFfY2hlY2tQcm9wUHJlZml4KFwicGVyc3BlY3RpdmVcIik7XG4gICAgX3JldmVydGluZyA9IGdzYXAuY29yZS5yZXZlcnRpbmc7XG4gICAgX3BsdWdpbkluaXR0ZWQgPSAxO1xuICB9XG59LFxuICAgIF9nZXRCQm94SGFjayA9IGZ1bmN0aW9uIF9nZXRCQm94SGFjayhzd2FwSWZQb3NzaWJsZSkge1xuICAvL3dvcmtzIGFyb3VuZCBpc3N1ZXMgaW4gc29tZSBicm93c2VycyAobGlrZSBGaXJlZm94KSB0aGF0IGRvbid0IGNvcnJlY3RseSByZXBvcnQgZ2V0QkJveCgpIG9uIFNWRyBlbGVtZW50cyBpbnNpZGUgYSA8ZGVmcz4gZWxlbWVudCBhbmQvb3IgPG1hc2s+LiBXZSB0cnkgY3JlYXRpbmcgYW4gU1ZHLCBhZGRpbmcgaXQgdG8gdGhlIGRvY3VtZW50RWxlbWVudCBhbmQgdG9zcyB0aGUgZWxlbWVudCBpbiB0aGVyZSBzbyB0aGF0IGl0J3MgZGVmaW5pdGVseSBwYXJ0IG9mIHRoZSByZW5kZXJpbmcgdHJlZSwgdGhlbiBncmFiIHRoZSBiYm94IGFuZCBpZiBpdCB3b3Jrcywgd2UgYWN0dWFsbHkgc3dhcCBvdXQgdGhlIG9yaWdpbmFsIGdldEJCb3goKSBtZXRob2QgZm9yIG91ciBvd24gdGhhdCBkb2VzIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW5ldmVyIGdldEJCb3ggaXMgbmVlZGVkLiBUaGlzIGhlbHBzIGVuc3VyZSB0aGF0IHBlcmZvcm1hbmNlIGlzIG9wdGltYWwgKG9ubHkgZG8gYWxsIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW4gYWJzb2x1dGVseSBuZWNlc3NhcnkuLi5tb3N0IGVsZW1lbnRzIGRvbid0IG5lZWQgaXQpLlxuICB2YXIgc3ZnID0gX2NyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgdGhpcy5vd25lclNWR0VsZW1lbnQgJiYgdGhpcy5vd25lclNWR0VsZW1lbnQuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKSxcbiAgICAgIG9sZFBhcmVudCA9IHRoaXMucGFyZW50Tm9kZSxcbiAgICAgIG9sZFNpYmxpbmcgPSB0aGlzLm5leHRTaWJsaW5nLFxuICAgICAgb2xkQ1NTID0gdGhpcy5zdHlsZS5jc3NUZXh0LFxuICAgICAgYmJveDtcblxuICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZChzdmcpO1xuXG4gIHN2Zy5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gIGlmIChzd2FwSWZQb3NzaWJsZSkge1xuICAgIHRyeSB7XG4gICAgICBiYm94ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgICB0aGlzLl9nc2FwQkJveCA9IHRoaXMuZ2V0QkJveDsgLy9zdG9yZSB0aGUgb3JpZ2luYWxcblxuICAgICAgdGhpcy5nZXRCQm94ID0gX2dldEJCb3hIYWNrO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0gZWxzZSBpZiAodGhpcy5fZ3NhcEJCb3gpIHtcbiAgICBiYm94ID0gdGhpcy5fZ3NhcEJCb3goKTtcbiAgfVxuXG4gIGlmIChvbGRQYXJlbnQpIHtcbiAgICBpZiAob2xkU2libGluZykge1xuICAgICAgb2xkUGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBvbGRTaWJsaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkUGFyZW50LmFwcGVuZENoaWxkKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHN2Zyk7XG5cbiAgdGhpcy5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTO1xuICByZXR1cm4gYmJveDtcbn0sXG4gICAgX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyA9IGZ1bmN0aW9uIF9nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBhdHRyaWJ1dGVzQXJyYXkpIHtcbiAgdmFyIGkgPSBhdHRyaWJ1dGVzQXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVzQXJyYXlbaV0pKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVzQXJyYXlbaV0pO1xuICAgIH1cbiAgfVxufSxcbiAgICBfZ2V0QkJveCA9IGZ1bmN0aW9uIF9nZXRCQm94KHRhcmdldCkge1xuICB2YXIgYm91bmRzO1xuXG4gIHRyeSB7XG4gICAgYm91bmRzID0gdGFyZ2V0LmdldEJCb3goKTsgLy9GaXJlZm94IHRocm93cyBlcnJvcnMgaWYgeW91IHRyeSBjYWxsaW5nIGdldEJCb3goKSBvbiBhbiBTVkcgZWxlbWVudCB0aGF0J3Mgbm90IHJlbmRlcmVkIChsaWtlIGluIGEgPHN5bWJvbD4gb3IgPGRlZnM+KS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjEyMTE4XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgYm91bmRzID0gX2dldEJCb3hIYWNrLmNhbGwodGFyZ2V0LCB0cnVlKTtcbiAgfVxuXG4gIGJvdW5kcyAmJiAoYm91bmRzLndpZHRoIHx8IGJvdW5kcy5oZWlnaHQpIHx8IHRhcmdldC5nZXRCQm94ID09PSBfZ2V0QkJveEhhY2sgfHwgKGJvdW5kcyA9IF9nZXRCQm94SGFjay5jYWxsKHRhcmdldCwgdHJ1ZSkpOyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgbWlzcmVwb3J0IHRoZSBib3VuZHMgaWYgdGhlIGVsZW1lbnQgaGFzIHplcm8gd2lkdGggYW5kIGhlaWdodCAoaXQganVzdCBhc3N1bWVzIGl0J3MgYXQgeDowLCB5OjApLCB0aHVzIHdlIG5lZWQgdG8gbWFudWFsbHkgZ3JhYiB0aGUgcG9zaXRpb24gaW4gdGhhdCBjYXNlLlxuXG4gIHJldHVybiBib3VuZHMgJiYgIWJvdW5kcy53aWR0aCAmJiAhYm91bmRzLnggJiYgIWJvdW5kcy55ID8ge1xuICAgIHg6ICtfZ2V0QXR0cmlidXRlRmFsbGJhY2tzKHRhcmdldCwgW1wieFwiLCBcImN4XCIsIFwieDFcIl0pIHx8IDAsXG4gICAgeTogK19nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBbXCJ5XCIsIFwiY3lcIiwgXCJ5MVwiXSkgfHwgMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSA6IGJvdW5kcztcbn0sXG4gICAgX2lzU1ZHID0gZnVuY3Rpb24gX2lzU1ZHKGUpIHtcbiAgcmV0dXJuICEhKGUuZ2V0Q1RNICYmICghZS5wYXJlbnROb2RlIHx8IGUub3duZXJTVkdFbGVtZW50KSAmJiBfZ2V0QkJveChlKSk7XG59LFxuICAgIC8vcmVwb3J0cyBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkcgb24gd2hpY2ggZ2V0QkJveCgpIGFjdHVhbGx5IHdvcmtzXG5fcmVtb3ZlUHJvcGVydHkgPSBmdW5jdGlvbiBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkpIHtcbiAgICB2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgIGZpcnN0MkNoYXJzO1xuXG4gICAgaWYgKHByb3BlcnR5IGluIF90cmFuc2Zvcm1Qcm9wcyAmJiBwcm9wZXJ0eSAhPT0gX3RyYW5zZm9ybU9yaWdpblByb3ApIHtcbiAgICAgIHByb3BlcnR5ID0gX3RyYW5zZm9ybVByb3A7XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlLnJlbW92ZVByb3BlcnR5KSB7XG4gICAgICBmaXJzdDJDaGFycyA9IHByb3BlcnR5LnN1YnN0cigwLCAyKTtcblxuICAgICAgaWYgKGZpcnN0MkNoYXJzID09PSBcIm1zXCIgfHwgcHJvcGVydHkuc3Vic3RyKDAsIDYpID09PSBcIndlYmtpdFwiKSB7XG4gICAgICAgIC8vTWljcm9zb2Z0IGFuZCBzb21lIFdlYmtpdCBicm93c2VycyBkb24ndCBjb25mb3JtIHRvIHRoZSBzdGFuZGFyZCBvZiBjYXBpdGFsaXppbmcgdGhlIGZpcnN0IHByZWZpeCBjaGFyYWN0ZXIsIHNvIHdlIGFkanVzdCBzbyB0aGF0IHdoZW4gd2UgcHJlZml4IHRoZSBjYXBzIHdpdGggYSBkYXNoLCBpdCdzIGNvcnJlY3QgKG90aGVyd2lzZSBpdCdkIGJlIFwibXMtdHJhbnNmb3JtXCIgaW5zdGVhZCBvZiBcIi1tcy10cmFuc2Zvcm1cIiBmb3IgSUU5LCBmb3IgZXhhbXBsZSlcbiAgICAgICAgcHJvcGVydHkgPSBcIi1cIiArIHByb3BlcnR5O1xuICAgICAgfVxuXG4gICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eShmaXJzdDJDaGFycyA9PT0gXCItLVwiID8gcHJvcGVydHkgOiBwcm9wZXJ0eS5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy9ub3RlOiBvbGQgdmVyc2lvbnMgb2YgSUUgdXNlIFwicmVtb3ZlQXR0cmlidXRlKClcIiBpbnN0ZWFkIG9mIFwicmVtb3ZlUHJvcGVydHkoKVwiXG4gICAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUocHJvcGVydHkpO1xuICAgIH1cbiAgfVxufSxcbiAgICBfYWRkTm9uVHdlZW5pbmdQVCA9IGZ1bmN0aW9uIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgYmVnaW5uaW5nLCBlbmQsIG9ubHlTZXRBdEVuZCkge1xuICB2YXIgcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIDAsIDEsIG9ubHlTZXRBdEVuZCA/IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kIDogX3JlbmRlck5vblR3ZWVuaW5nVmFsdWUpO1xuICBwbHVnaW4uX3B0ID0gcHQ7XG4gIHB0LmIgPSBiZWdpbm5pbmc7XG4gIHB0LmUgPSBlbmQ7XG5cbiAgcGx1Z2luLl9wcm9wcy5wdXNoKHByb3BlcnR5KTtcblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9ub25Db252ZXJ0aWJsZVVuaXRzID0ge1xuICBkZWc6IDEsXG4gIHJhZDogMSxcbiAgdHVybjogMVxufSxcbiAgICBfbm9uU3RhbmRhcmRMYXlvdXRzID0ge1xuICBncmlkOiAxLFxuICBmbGV4OiAxXG59LFxuICAgIC8vdGFrZXMgYSBzaW5nbGUgdmFsdWUgbGlrZSAyMHB4IGFuZCBjb252ZXJ0cyBpdCB0byB0aGUgdW5pdCBzcGVjaWZpZWQsIGxpa2UgXCIlXCIsIHJldHVybmluZyBvbmx5IHRoZSBudW1lcmljIGFtb3VudC5cbl9jb252ZXJ0VG9Vbml0ID0gZnVuY3Rpb24gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHVuaXQpIHtcbiAgdmFyIGN1clZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMCxcbiAgICAgIGN1clVuaXQgPSAodmFsdWUgKyBcIlwiKS50cmltKCkuc3Vic3RyKChjdXJWYWx1ZSArIFwiXCIpLmxlbmd0aCkgfHwgXCJweFwiLFxuICAgICAgLy8gc29tZSBicm93c2VycyBsZWF2ZSBleHRyYSB3aGl0ZXNwYWNlIGF0IHRoZSBiZWdpbm5pbmcgb2YgQ1NTIHZhcmlhYmxlcywgaGVuY2UgdGhlIG5lZWQgdG8gdHJpbSgpXG4gIHN0eWxlID0gX3RlbXBEaXYuc3R5bGUsXG4gICAgICBob3Jpem9udGFsID0gX2hvcml6b250YWxFeHAudGVzdChwcm9wZXJ0eSksXG4gICAgICBpc1Jvb3RTVkcgPSB0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiLFxuICAgICAgbWVhc3VyZVByb3BlcnR5ID0gKGlzUm9vdFNWRyA/IFwiY2xpZW50XCIgOiBcIm9mZnNldFwiKSArIChob3Jpem9udGFsID8gXCJXaWR0aFwiIDogXCJIZWlnaHRcIiksXG4gICAgICBhbW91bnQgPSAxMDAsXG4gICAgICB0b1BpeGVscyA9IHVuaXQgPT09IFwicHhcIixcbiAgICAgIHRvUGVyY2VudCA9IHVuaXQgPT09IFwiJVwiLFxuICAgICAgcHgsXG4gICAgICBwYXJlbnQsXG4gICAgICBjYWNoZSxcbiAgICAgIGlzU1ZHO1xuXG4gIGlmICh1bml0ID09PSBjdXJVbml0IHx8ICFjdXJWYWx1ZSB8fCBfbm9uQ29udmVydGlibGVVbml0c1t1bml0XSB8fCBfbm9uQ29udmVydGlibGVVbml0c1tjdXJVbml0XSkge1xuICAgIHJldHVybiBjdXJWYWx1ZTtcbiAgfVxuXG4gIGN1clVuaXQgIT09IFwicHhcIiAmJiAhdG9QaXhlbHMgJiYgKGN1clZhbHVlID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIFwicHhcIikpO1xuICBpc1NWRyA9IHRhcmdldC5nZXRDVE0gJiYgX2lzU1ZHKHRhcmdldCk7XG5cbiAgaWYgKCh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldIHx8IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikpKSB7XG4gICAgcHggPSBpc1NWRyA/IHRhcmdldC5nZXRCQm94KClbaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdIDogdGFyZ2V0W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgcmV0dXJuIF9yb3VuZCh0b1BlcmNlbnQgPyBjdXJWYWx1ZSAvIHB4ICogYW1vdW50IDogY3VyVmFsdWUgLyAxMDAgKiBweCk7XG4gIH1cblxuICBzdHlsZVtob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gPSBhbW91bnQgKyAodG9QaXhlbHMgPyBjdXJVbml0IDogdW5pdCk7XG4gIHBhcmVudCA9IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikgfHwgdW5pdCA9PT0gXCJlbVwiICYmIHRhcmdldC5hcHBlbmRDaGlsZCAmJiAhaXNSb290U1ZHID8gdGFyZ2V0IDogdGFyZ2V0LnBhcmVudE5vZGU7XG5cbiAgaWYgKGlzU1ZHKSB7XG4gICAgcGFyZW50ID0gKHRhcmdldC5vd25lclNWR0VsZW1lbnQgfHwge30pLnBhcmVudE5vZGU7XG4gIH1cblxuICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT09IF9kb2MgfHwgIXBhcmVudC5hcHBlbmRDaGlsZCkge1xuICAgIHBhcmVudCA9IF9kb2MuYm9keTtcbiAgfVxuXG4gIGNhY2hlID0gcGFyZW50Ll9nc2FwO1xuXG4gIGlmIChjYWNoZSAmJiB0b1BlcmNlbnQgJiYgY2FjaGUud2lkdGggJiYgaG9yaXpvbnRhbCAmJiBjYWNoZS50aW1lID09PSBfdGlja2VyLnRpbWUgJiYgIWNhY2hlLnVuY2FjaGUpIHtcbiAgICByZXR1cm4gX3JvdW5kKGN1clZhbHVlIC8gY2FjaGUud2lkdGggKiBhbW91bnQpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0b1BlcmNlbnQgJiYgKHByb3BlcnR5ID09PSBcImhlaWdodFwiIHx8IHByb3BlcnR5ID09PSBcIndpZHRoXCIpKSB7XG4gICAgICAvLyBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggd2lkdGgvaGVpZ2h0IHRoYXQncyBpbnNpZGUgYSBjb250YWluZXIgd2l0aCBwYWRkaW5nIGFuZC9vciBpdCdzIGEgZmxleGJveC9ncmlkIGNvbnRhaW5lciwgd2UgbXVzdCBhcHBseSBpdCB0byB0aGUgdGFyZ2V0IGl0c2VsZiByYXRoZXIgdGhhbiB0aGUgX3RlbXBEaXYgaW4gb3JkZXIgdG8gZW5zdXJlIGNvbXBsZXRlIGFjY3VyYWN5LCBmYWN0b3JpbmcgaW4gdGhlIHBhcmVudCdzIHBhZGRpbmcuXG4gICAgICB2YXIgdiA9IHRhcmdldC5zdHlsZVtwcm9wZXJ0eV07XG4gICAgICB0YXJnZXQuc3R5bGVbcHJvcGVydHldID0gYW1vdW50ICsgdW5pdDtcbiAgICAgIHB4ID0gdGFyZ2V0W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgICB2ID8gdGFyZ2V0LnN0eWxlW3Byb3BlcnR5XSA9IHYgOiBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmICFfbm9uU3RhbmRhcmRMYXlvdXRzW19nZXRDb21wdXRlZFByb3BlcnR5KHBhcmVudCwgXCJkaXNwbGF5XCIpXSAmJiAoc3R5bGUucG9zaXRpb24gPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIFwicG9zaXRpb25cIikpO1xuICAgICAgcGFyZW50ID09PSB0YXJnZXQgJiYgKHN0eWxlLnBvc2l0aW9uID0gXCJzdGF0aWNcIik7IC8vIGxpa2UgZm9yIGJvcmRlclJhZGl1cywgaWYgaXQncyBhICUgd2UgbXVzdCBoYXZlIGl0IHJlbGF0aXZlIHRvIHRoZSB0YXJnZXQgaXRzZWxmIGJ1dCB0aGF0IG1heSBub3QgaGF2ZSBwb3NpdGlvbjogcmVsYXRpdmUgb3IgcG9zaXRpb246IGFic29sdXRlIGluIHdoaWNoIGNhc2UgaXQnZCBnbyB1cCB0aGUgY2hhaW4gdW50aWwgaXQgZmluZHMgaXRzIG9mZnNldFBhcmVudCAoYmFkKS4gcG9zaXRpb246IHN0YXRpYyBwcm90ZWN0cyBhZ2FpbnN0IHRoYXQuXG5cbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChfdGVtcERpdik7XG4gICAgICBweCA9IF90ZW1wRGl2W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoX3RlbXBEaXYpO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgfVxuXG4gICAgaWYgKGhvcml6b250YWwgJiYgdG9QZXJjZW50KSB7XG4gICAgICBjYWNoZSA9IF9nZXRDYWNoZShwYXJlbnQpO1xuICAgICAgY2FjaGUudGltZSA9IF90aWNrZXIudGltZTtcbiAgICAgIGNhY2hlLndpZHRoID0gcGFyZW50W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9yb3VuZCh0b1BpeGVscyA/IHB4ICogY3VyVmFsdWUgLyBhbW91bnQgOiBweCAmJiBjdXJWYWx1ZSA/IGFtb3VudCAvIHB4ICogY3VyVmFsdWUgOiAwKTtcbn0sXG4gICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICB2YXIgdmFsdWU7XG4gIF9wbHVnaW5Jbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuXG4gIGlmIChwcm9wZXJ0eSBpbiBfcHJvcGVydHlBbGlhc2VzICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgcHJvcGVydHkgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XTtcblxuICAgIGlmICh+cHJvcGVydHkuaW5kZXhPZihcIixcIikpIHtcbiAgICAgIHByb3BlcnR5ID0gcHJvcGVydHkuc3BsaXQoXCIsXCIpWzBdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgdmFsdWUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB1bmNhY2hlKTtcbiAgICB2YWx1ZSA9IHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybU9yaWdpblwiID8gdmFsdWVbcHJvcGVydHldIDogdmFsdWUuc3ZnID8gdmFsdWUub3JpZ2luIDogX2ZpcnN0VHdvT25seShfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSkgKyBcIiBcIiArIHZhbHVlLnpPcmlnaW4gKyBcInB4XCI7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0YXJnZXQuc3R5bGVbcHJvcGVydHldO1xuXG4gICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJhdXRvXCIgfHwgdW5jYWNoZSB8fCB+KHZhbHVlICsgXCJcIikuaW5kZXhPZihcImNhbGMoXCIpKSB7XG4gICAgICB2YWx1ZSA9IF9zcGVjaWFsUHJvcHNbcHJvcGVydHldICYmIF9zcGVjaWFsUHJvcHNbcHJvcGVydHldKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHx8IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHx8IF9nZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSB8fCAocHJvcGVydHkgPT09IFwib3BhY2l0eVwiID8gMSA6IDApOyAvLyBub3RlOiBzb21lIGJyb3dzZXJzLCBsaWtlIEZpcmVmb3gsIGRvbid0IHJlcG9ydCBib3JkZXJSYWRpdXMgY29ycmVjdGx5ISBJbnN0ZWFkLCBpdCBvbmx5IHJlcG9ydHMgZXZlcnkgY29ybmVyIGxpa2UgIGJvcmRlclRvcExlZnRSYWRpdXNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5pdCAmJiAhfih2YWx1ZSArIFwiXCIpLnRyaW0oKS5pbmRleE9mKFwiIFwiKSA/IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCB1bml0KSArIHVuaXQgOiB2YWx1ZTtcbn0sXG4gICAgX3R3ZWVuQ29tcGxleENTU1N0cmluZyA9IGZ1bmN0aW9uIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcodGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kKSB7XG4gIC8vIG5vdGU6IHdlIGNhbGwgX3R3ZWVuQ29tcGxleENTU1N0cmluZy5jYWxsKHBsdWdpbkluc3RhbmNlLi4uKSB0byBlbnN1cmUgdGhhdCBpdCdzIHNjb3BlZCBwcm9wZXJseS4gV2UgbWF5IGNhbGwgaXQgZnJvbSB3aXRoaW4gYSBwbHVnaW4gdG9vLCB0aHVzIFwidGhpc1wiIHdvdWxkIHJlZmVyIHRvIHRoZSBwbHVnaW4uXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPT09IFwibm9uZVwiKSB7XG4gICAgLy8gc29tZSBicm93c2VycyBsaWtlIFNhZmFyaSBhY3R1YWxseSBQUkVGRVIgdGhlIHByZWZpeGVkIHByb3BlcnR5IGFuZCBtaXMtcmVwb3J0IHRoZSB1bnByZWZpeGVkIHZhbHVlIGxpa2UgY2xpcFBhdGggKEJVRykuIEluIG90aGVyIHdvcmRzLCBldmVuIHRob3VnaCBjbGlwUGF0aCBleGlzdHMgaW4gdGhlIHN0eWxlIChcImNsaXBQYXRoXCIgaW4gdGFyZ2V0LnN0eWxlKSBhbmQgaXQncyBzZXQgaW4gdGhlIENTUyBwcm9wZXJseSAoYWxvbmcgd2l0aCAtd2Via2l0LWNsaXAtcGF0aCksIFNhZmFyaSByZXBvcnRzIGNsaXBQYXRoIGFzIFwibm9uZVwiIHdoZXJlYXMgV2Via2l0Q2xpcFBhdGggcmVwb3J0cyBhY2N1cmF0ZWx5IGxpa2UgXCJlbGxpcHNlKDEwMCUgMCUgYXQgNTAlIDAlKVwiLCBzbyBpbiB0aGlzIGNhc2Ugd2UgbXVzdCBTV0lUQ0ggdG8gdXNpbmcgdGhlIHByZWZpeGVkIHByb3BlcnR5IGluc3RlYWQuIFNlZSBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8xODMxMC1jbGlwcGF0aC1kb2VzbnQtd29yay1vbi1pb3MvXG4gICAgdmFyIHAgPSBfY2hlY2tQcm9wUHJlZml4KHByb3AsIHRhcmdldCwgMSksXG4gICAgICAgIHMgPSBwICYmIF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcCwgMSk7XG5cbiAgICBpZiAocyAmJiBzICE9PSBzdGFydCkge1xuICAgICAgcHJvcCA9IHA7XG4gICAgICBzdGFydCA9IHM7XG4gICAgfSBlbHNlIGlmIChwcm9wID09PSBcImJvcmRlckNvbG9yXCIpIHtcbiAgICAgIHN0YXJ0ID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBcImJvcmRlclRvcENvbG9yXCIpOyAvLyBGaXJlZm94IGJ1ZzogYWx3YXlzIHJlcG9ydHMgXCJib3JkZXJDb2xvclwiIGFzIFwiXCIsIHNvIHdlIG11c3QgZmFsbCBiYWNrIHRvIGJvcmRlclRvcENvbG9yLiBTZWUgaHR0cHM6Ly9nc2FwLmNvbS9mb3J1bXMvdG9waWMvMjQ1ODMtaG93LXRvLXJldHVybi1jb2xvcnMtdGhhdC1pLWhhZC1hZnRlci1yZXZlcnNlL1xuICAgIH1cbiAgfVxuXG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldC5zdHlsZSwgcHJvcCwgMCwgMSwgX3JlbmRlckNvbXBsZXhTdHJpbmcpLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgbWF0Y2hJbmRleCA9IDAsXG4gICAgICBhLFxuICAgICAgcmVzdWx0LFxuICAgICAgc3RhcnRWYWx1ZXMsXG4gICAgICBzdGFydE51bSxcbiAgICAgIGNvbG9yLFxuICAgICAgc3RhcnRWYWx1ZSxcbiAgICAgIGVuZFZhbHVlLFxuICAgICAgZW5kTnVtLFxuICAgICAgY2h1bmssXG4gICAgICBlbmRVbml0LFxuICAgICAgc3RhcnRVbml0LFxuICAgICAgZW5kVmFsdWVzO1xuICBwdC5iID0gc3RhcnQ7XG4gIHB0LmUgPSBlbmQ7XG4gIHN0YXJ0ICs9IFwiXCI7IC8vIGVuc3VyZSB2YWx1ZXMgYXJlIHN0cmluZ3NcblxuICBlbmQgKz0gXCJcIjtcblxuICBpZiAoZW5kID09PSBcImF1dG9cIikge1xuICAgIHN0YXJ0VmFsdWUgPSB0YXJnZXQuc3R5bGVbcHJvcF07XG4gICAgdGFyZ2V0LnN0eWxlW3Byb3BdID0gZW5kO1xuICAgIGVuZCA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcHJvcCkgfHwgZW5kO1xuICAgIHN0YXJ0VmFsdWUgPyB0YXJnZXQuc3R5bGVbcHJvcF0gPSBzdGFydFZhbHVlIDogX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcHJvcCk7XG4gIH1cblxuICBhID0gW3N0YXJ0LCBlbmRdO1xuXG4gIF9jb2xvclN0cmluZ0ZpbHRlcihhKTsgLy8gcGFzcyBhbiBhcnJheSB3aXRoIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHZhbHVlcyBhbmQgbGV0IHRoZSBmaWx0ZXIgZG8gd2hhdGV2ZXIgaXQgbmVlZHMgdG8gdGhlIHZhbHVlcy4gSWYgY29sb3JzIGFyZSBmb3VuZCwgaXQgcmV0dXJucyB0cnVlIGFuZCB0aGVuIHdlIG11c3QgbWF0Y2ggd2hlcmUgdGhlIGNvbG9yIHNob3dzIHVwIG9yZGVyLXdpc2UgYmVjYXVzZSBmb3IgdGhpbmdzIGxpa2UgYm94U2hhZG93LCBzb21ldGltZXMgdGhlIGJyb3dzZXIgcHJvdmlkZXMgdGhlIGNvbXB1dGVkIHZhbHVlcyB3aXRoIHRoZSBjb2xvciBGSVJTVCwgYnV0IHRoZSB1c2VyIHByb3ZpZGVzIGl0IHdpdGggdGhlIGNvbG9yIExBU1QsIHNvIGZsaXAgdGhlbSBpZiBuZWNlc3NhcnkuIFNhbWUgZm9yIGRyb3Atc2hhZG93KCkuXG5cblxuICBzdGFydCA9IGFbMF07XG4gIGVuZCA9IGFbMV07XG4gIHN0YXJ0VmFsdWVzID0gc3RhcnQubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcbiAgZW5kVmFsdWVzID0gZW5kLm1hdGNoKF9udW1XaXRoVW5pdEV4cCkgfHwgW107XG5cbiAgaWYgKGVuZFZhbHVlcy5sZW5ndGgpIHtcbiAgICB3aGlsZSAocmVzdWx0ID0gX251bVdpdGhVbml0RXhwLmV4ZWMoZW5kKSkge1xuICAgICAgZW5kVmFsdWUgPSByZXN1bHRbMF07XG4gICAgICBjaHVuayA9IGVuZC5zdWJzdHJpbmcoaW5kZXgsIHJlc3VsdC5pbmRleCk7XG5cbiAgICAgIGlmIChjb2xvcikge1xuICAgICAgICBjb2xvciA9IChjb2xvciArIDEpICUgNTtcbiAgICAgIH0gZWxzZSBpZiAoY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJyZ2JhKFwiIHx8IGNodW5rLnN1YnN0cigtNSkgPT09IFwiaHNsYShcIikge1xuICAgICAgICBjb2xvciA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRWYWx1ZSAhPT0gKHN0YXJ0VmFsdWUgPSBzdGFydFZhbHVlc1ttYXRjaEluZGV4KytdIHx8IFwiXCIpKSB7XG4gICAgICAgIHN0YXJ0TnVtID0gcGFyc2VGbG9hdChzdGFydFZhbHVlKSB8fCAwO1xuICAgICAgICBzdGFydFVuaXQgPSBzdGFydFZhbHVlLnN1YnN0cigoc3RhcnROdW0gKyBcIlwiKS5sZW5ndGgpO1xuICAgICAgICBlbmRWYWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiICYmIChlbmRWYWx1ZSA9IF9wYXJzZVJlbGF0aXZlKHN0YXJ0TnVtLCBlbmRWYWx1ZSkgKyBzdGFydFVuaXQpO1xuICAgICAgICBlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKTtcbiAgICAgICAgZW5kVW5pdCA9IGVuZFZhbHVlLnN1YnN0cigoZW5kTnVtICsgXCJcIikubGVuZ3RoKTtcbiAgICAgICAgaW5kZXggPSBfbnVtV2l0aFVuaXRFeHAubGFzdEluZGV4IC0gZW5kVW5pdC5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCFlbmRVbml0KSB7XG4gICAgICAgICAgLy9pZiBzb21ldGhpbmcgbGlrZSBcInBlcnNwZWN0aXZlOjMwMFwiIGlzIHBhc3NlZCBpbiBhbmQgd2UgbXVzdCBhZGQgYSB1bml0IHRvIHRoZSBlbmRcbiAgICAgICAgICBlbmRVbml0ID0gZW5kVW5pdCB8fCBfY29uZmlnLnVuaXRzW3Byb3BdIHx8IHN0YXJ0VW5pdDtcblxuICAgICAgICAgIGlmIChpbmRleCA9PT0gZW5kLmxlbmd0aCkge1xuICAgICAgICAgICAgZW5kICs9IGVuZFVuaXQ7XG4gICAgICAgICAgICBwdC5lICs9IGVuZFVuaXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCkge1xuICAgICAgICAgIHN0YXJ0TnVtID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wLCBzdGFydFZhbHVlLCBlbmRVbml0KSB8fCAwO1xuICAgICAgICB9IC8vIHRoZXNlIG5lc3RlZCBQcm9wVHdlZW5zIGFyZSBoYW5kbGVkIGluIGEgc3BlY2lhbCB3YXkgLSB3ZSdsbCBuZXZlciBhY3R1YWxseSBjYWxsIGEgcmVuZGVyIG9yIHNldHRlciBtZXRob2Qgb24gdGhlbS4gV2UnbGwganVzdCBsb29wIHRocm91Z2ggdGhlbSBpbiB0aGUgcGFyZW50IGNvbXBsZXggc3RyaW5nIFByb3BUd2VlbidzIHJlbmRlciBtZXRob2QuXG5cblxuICAgICAgICBwdC5fcHQgPSB7XG4gICAgICAgICAgX25leHQ6IHB0Ll9wdCxcbiAgICAgICAgICBwOiBjaHVuayB8fCBtYXRjaEluZGV4ID09PSAxID8gY2h1bmsgOiBcIixcIixcbiAgICAgICAgICAvL25vdGU6IFNWRyBzcGVjIGFsbG93cyBvbWlzc2lvbiBvZiBjb21tYS9zcGFjZSB3aGVuIGEgbmVnYXRpdmUgc2lnbiBpcyB3ZWRnZWQgYmV0d2VlbiB0d28gbnVtYmVycywgbGlrZSAyLjUtNS4zIGluc3RlYWQgb2YgMi41LC01LjMgYnV0IHdoZW4gdHdlZW5pbmcsIHRoZSBuZWdhdGl2ZSB2YWx1ZSBtYXkgc3dpdGNoIHRvIHBvc2l0aXZlLCBzbyB3ZSBpbnNlcnQgdGhlIGNvbW1hIGp1c3QgaW4gY2FzZS5cbiAgICAgICAgICBzOiBzdGFydE51bSxcbiAgICAgICAgICBjOiBlbmROdW0gLSBzdGFydE51bSxcbiAgICAgICAgICBtOiBjb2xvciAmJiBjb2xvciA8IDQgfHwgcHJvcCA9PT0gXCJ6SW5kZXhcIiA/IE1hdGgucm91bmQgOiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHQuYyA9IGluZGV4IDwgZW5kLmxlbmd0aCA/IGVuZC5zdWJzdHJpbmcoaW5kZXgsIGVuZC5sZW5ndGgpIDogXCJcIjsgLy93ZSB1c2UgdGhlIFwiY1wiIG9mIHRoZSBQcm9wVHdlZW4gdG8gc3RvcmUgdGhlIGZpbmFsIHBhcnQgb2YgdGhlIHN0cmluZyAoYWZ0ZXIgdGhlIGxhc3QgbnVtYmVyKVxuICB9IGVsc2Uge1xuICAgIHB0LnIgPSBwcm9wID09PSBcImRpc3BsYXlcIiAmJiBlbmQgPT09IFwibm9uZVwiID8gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQgOiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZTtcbiAgfVxuXG4gIF9yZWxFeHAudGVzdChlbmQpICYmIChwdC5lID0gMCk7IC8vaWYgdGhlIGVuZCBzdHJpbmcgY29udGFpbnMgcmVsYXRpdmUgdmFsdWVzIG9yIGR5bmFtaWMgcmFuZG9tKC4uLikgdmFsdWVzLCBkZWxldGUgdGhlIGVuZCBpdCBzbyB0aGF0IG9uIHRoZSBmaW5hbCByZW5kZXIgd2UgZG9uJ3QgYWN0dWFsbHkgc2V0IGl0IHRvIHRoZSBzdHJpbmcgd2l0aCArPSBvciAtPSBjaGFyYWN0ZXJzIChmb3JjZXMgaXQgdG8gdXNlIHRoZSBjYWxjdWxhdGVkIHZhbHVlKS5cblxuICB0aGlzLl9wdCA9IHB0OyAvL3N0YXJ0IHRoZSBsaW5rZWQgbGlzdCB3aXRoIHRoaXMgbmV3IFByb3BUd2Vlbi4gUmVtZW1iZXIsIHdlIGNhbGwgX3R3ZWVuQ29tcGxleENTU1N0cmluZy5jYWxsKHBsdWdpbkluc3RhbmNlLi4uKSB0byBlbnN1cmUgdGhhdCBpdCdzIHNjb3BlZCBwcm9wZXJseS4gV2UgbWF5IGNhbGwgaXQgZnJvbSB3aXRoaW4gYW5vdGhlciBwbHVnaW4gdG9vLCB0aHVzIFwidGhpc1wiIHdvdWxkIHJlZmVyIHRvIHRoZSBwbHVnaW4uXG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfa2V5d29yZFRvUGVyY2VudCA9IHtcbiAgdG9wOiBcIjAlXCIsXG4gIGJvdHRvbTogXCIxMDAlXCIsXG4gIGxlZnQ6IFwiMCVcIixcbiAgcmlnaHQ6IFwiMTAwJVwiLFxuICBjZW50ZXI6IFwiNTAlXCJcbn0sXG4gICAgX2NvbnZlcnRLZXl3b3Jkc1RvUGVyY2VudGFnZXMgPSBmdW5jdGlvbiBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyh2YWx1ZSkge1xuICB2YXIgc3BsaXQgPSB2YWx1ZS5zcGxpdChcIiBcIiksXG4gICAgICB4ID0gc3BsaXRbMF0sXG4gICAgICB5ID0gc3BsaXRbMV0gfHwgXCI1MCVcIjtcblxuICBpZiAoeCA9PT0gXCJ0b3BcIiB8fCB4ID09PSBcImJvdHRvbVwiIHx8IHkgPT09IFwibGVmdFwiIHx8IHkgPT09IFwicmlnaHRcIikge1xuICAgIC8vdGhlIHVzZXIgcHJvdmlkZWQgdGhlbSBpbiB0aGUgd3Jvbmcgb3JkZXIsIHNvIGZsaXAgdGhlbVxuICAgIHZhbHVlID0geDtcbiAgICB4ID0geTtcbiAgICB5ID0gdmFsdWU7XG4gIH1cblxuICBzcGxpdFswXSA9IF9rZXl3b3JkVG9QZXJjZW50W3hdIHx8IHg7XG4gIHNwbGl0WzFdID0gX2tleXdvcmRUb1BlcmNlbnRbeV0gfHwgeTtcbiAgcmV0dXJuIHNwbGl0LmpvaW4oXCIgXCIpO1xufSxcbiAgICBfcmVuZGVyQ2xlYXJQcm9wcyA9IGZ1bmN0aW9uIF9yZW5kZXJDbGVhclByb3BzKHJhdGlvLCBkYXRhKSB7XG4gIGlmIChkYXRhLnR3ZWVuICYmIGRhdGEudHdlZW4uX3RpbWUgPT09IGRhdGEudHdlZW4uX2R1cikge1xuICAgIHZhciB0YXJnZXQgPSBkYXRhLnQsXG4gICAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgICBwcm9wcyA9IGRhdGEudSxcbiAgICAgICAgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICAgIHByb3AsXG4gICAgICAgIGNsZWFyVHJhbnNmb3JtcyxcbiAgICAgICAgaTtcblxuICAgIGlmIChwcm9wcyA9PT0gXCJhbGxcIiB8fCBwcm9wcyA9PT0gdHJ1ZSkge1xuICAgICAgc3R5bGUuY3NzVGV4dCA9IFwiXCI7XG4gICAgICBjbGVhclRyYW5zZm9ybXMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wcyA9IHByb3BzLnNwbGl0KFwiLFwiKTtcbiAgICAgIGkgPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICBwcm9wID0gcHJvcHNbaV07XG5cbiAgICAgICAgaWYgKF90cmFuc2Zvcm1Qcm9wc1twcm9wXSkge1xuICAgICAgICAgIGNsZWFyVHJhbnNmb3JtcyA9IDE7XG4gICAgICAgICAgcHJvcCA9IHByb3AgPT09IFwidHJhbnNmb3JtT3JpZ2luXCIgPyBfdHJhbnNmb3JtT3JpZ2luUHJvcCA6IF90cmFuc2Zvcm1Qcm9wO1xuICAgICAgICB9XG5cbiAgICAgICAgX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcHJvcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNsZWFyVHJhbnNmb3Jtcykge1xuICAgICAgX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApO1xuXG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgY2FjaGUuc3ZnICYmIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG5cbiAgICAgICAgX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSk7IC8vIGZvcmNlIGFsbCB0aGUgY2FjaGVkIHZhbHVlcyBiYWNrIHRvIFwibm9ybWFsXCIvaWRlbnRpdHksIG90aGVyd2lzZSBpZiB0aGVyZSdzIGFub3RoZXIgdHdlZW4gdGhhdCdzIGFscmVhZHkgc2V0IHRvIHJlbmRlciB0cmFuc2Zvcm1zIG9uIHRoaXMgZWxlbWVudCwgaXQgY291bGQgZGlzcGxheSB0aGUgd3JvbmcgdmFsdWVzLlxuXG5cbiAgICAgICAgY2FjaGUudW5jYWNoZSA9IDE7XG5cbiAgICAgICAgX3JlbW92ZUluZGVwZW5kZW50VHJhbnNmb3JtcyhzdHlsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59LFxuICAgIC8vIG5vdGU6IHNwZWNpYWxQcm9wcyBzaG91bGQgcmV0dXJuIDEgaWYgKGFuZCBvbmx5IGlmKSB0aGV5IGhhdmUgYSBub24temVybyBwcmlvcml0eS4gSXQgaW5kaWNhdGVzIHdlIG5lZWQgdG8gc29ydCB0aGUgbGlua2VkIGxpc3QuXG5fc3BlY2lhbFByb3BzID0ge1xuICBjbGVhclByb3BzOiBmdW5jdGlvbiBjbGVhclByb3BzKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgZW5kVmFsdWUsIHR3ZWVuKSB7XG4gICAgaWYgKHR3ZWVuLmRhdGEgIT09IFwiaXNGcm9tU3RhcnRcIikge1xuICAgICAgdmFyIHB0ID0gcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgMCwgMCwgX3JlbmRlckNsZWFyUHJvcHMpO1xuICAgICAgcHQudSA9IGVuZFZhbHVlO1xuICAgICAgcHQucHIgPSAtMTA7XG4gICAgICBwdC50d2VlbiA9IHR3ZWVuO1xuXG4gICAgICBwbHVnaW4uX3Byb3BzLnB1c2gocHJvcGVydHkpO1xuXG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH1cbiAgLyogY2xhc3NOYW1lIGZlYXR1cmUgKGFib3V0IDAuNGtiIGd6aXBwZWQpLlxuICAsIGNsYXNzTmFtZShwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGVuZFZhbHVlLCB0d2Vlbikge1xuICBcdGxldCBfcmVuZGVyQ2xhc3NOYW1lID0gKHJhdGlvLCBkYXRhKSA9PiB7XG4gIFx0XHRcdGRhdGEuY3NzLnJlbmRlcihyYXRpbywgZGF0YS5jc3MpO1xuICBcdFx0XHRpZiAoIXJhdGlvIHx8IHJhdGlvID09PSAxKSB7XG4gIFx0XHRcdFx0bGV0IGlubGluZSA9IGRhdGEucm12LFxuICBcdFx0XHRcdFx0dGFyZ2V0ID0gZGF0YS50LFxuICBcdFx0XHRcdFx0cDtcbiAgXHRcdFx0XHR0YXJnZXQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgcmF0aW8gPyBkYXRhLmUgOiBkYXRhLmIpO1xuICBcdFx0XHRcdGZvciAocCBpbiBpbmxpbmUpIHtcbiAgXHRcdFx0XHRcdF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIHApO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSxcbiAgXHRcdF9nZXRBbGxTdHlsZXMgPSAodGFyZ2V0KSA9PiB7XG4gIFx0XHRcdGxldCBzdHlsZXMgPSB7fSxcbiAgXHRcdFx0XHRjb21wdXRlZCA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KSxcbiAgXHRcdFx0XHRwO1xuICBcdFx0XHRmb3IgKHAgaW4gY29tcHV0ZWQpIHtcbiAgXHRcdFx0XHRpZiAoaXNOYU4ocCkgJiYgcCAhPT0gXCJjc3NUZXh0XCIgJiYgcCAhPT0gXCJsZW5ndGhcIikge1xuICBcdFx0XHRcdFx0c3R5bGVzW3BdID0gY29tcHV0ZWRbcF07XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHRcdF9zZXREZWZhdWx0cyhzdHlsZXMsIF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpKTtcbiAgXHRcdFx0cmV0dXJuIHN0eWxlcztcbiAgXHRcdH0sXG4gIFx0XHRzdGFydENsYXNzTGlzdCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSxcbiAgXHRcdHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICBcdFx0Y3NzVGV4dCA9IHN0eWxlLmNzc1RleHQsXG4gIFx0XHRjYWNoZSA9IHRhcmdldC5fZ3NhcCxcbiAgXHRcdGNsYXNzUFQgPSBjYWNoZS5jbGFzc1BULFxuICBcdFx0aW5saW5lVG9SZW1vdmVBdEVuZCA9IHt9LFxuICBcdFx0ZGF0YSA9IHt0OnRhcmdldCwgcGx1Z2luOnBsdWdpbiwgcm12OmlubGluZVRvUmVtb3ZlQXRFbmQsIGI6c3RhcnRDbGFzc0xpc3QsIGU6KGVuZFZhbHVlLmNoYXJBdCgxKSAhPT0gXCI9XCIpID8gZW5kVmFsdWUgOiBzdGFydENsYXNzTGlzdC5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoPzpcXFxcc3xeKVwiICsgZW5kVmFsdWUuc3Vic3RyKDIpICsgXCIoPyFbXFxcXHctXSlcIiksIFwiXCIpICsgKChlbmRWYWx1ZS5jaGFyQXQoMCkgPT09IFwiK1wiKSA/IFwiIFwiICsgZW5kVmFsdWUuc3Vic3RyKDIpIDogXCJcIil9LFxuICBcdFx0Y2hhbmdpbmdWYXJzID0ge30sXG4gIFx0XHRzdGFydFZhcnMgPSBfZ2V0QWxsU3R5bGVzKHRhcmdldCksXG4gIFx0XHR0cmFuc2Zvcm1SZWxhdGVkID0gLyh0cmFuc2Zvcm18cGVyc3BlY3RpdmUpL2ksXG4gIFx0XHRlbmRWYXJzLCBwO1xuICBcdGlmIChjbGFzc1BUKSB7XG4gIFx0XHRjbGFzc1BULnIoMSwgY2xhc3NQVC5kKTtcbiAgXHRcdF9yZW1vdmVMaW5rZWRMaXN0SXRlbShjbGFzc1BULmQucGx1Z2luLCBjbGFzc1BULCBcIl9wdFwiKTtcbiAgXHR9XG4gIFx0dGFyZ2V0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGRhdGEuZSk7XG4gIFx0ZW5kVmFycyA9IF9nZXRBbGxTdHlsZXModGFyZ2V0LCB0cnVlKTtcbiAgXHR0YXJnZXQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgc3RhcnRDbGFzc0xpc3QpO1xuICBcdGZvciAocCBpbiBlbmRWYXJzKSB7XG4gIFx0XHRpZiAoZW5kVmFyc1twXSAhPT0gc3RhcnRWYXJzW3BdICYmICF0cmFuc2Zvcm1SZWxhdGVkLnRlc3QocCkpIHtcbiAgXHRcdFx0Y2hhbmdpbmdWYXJzW3BdID0gZW5kVmFyc1twXTtcbiAgXHRcdFx0aWYgKCFzdHlsZVtwXSAmJiBzdHlsZVtwXSAhPT0gXCIwXCIpIHtcbiAgXHRcdFx0XHRpbmxpbmVUb1JlbW92ZUF0RW5kW3BdID0gMTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgXHRjYWNoZS5jbGFzc1BUID0gcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBcImNsYXNzTmFtZVwiLCAwLCAwLCBfcmVuZGVyQ2xhc3NOYW1lLCBkYXRhLCAwLCAtMTEpO1xuICBcdGlmIChzdHlsZS5jc3NUZXh0ICE9PSBjc3NUZXh0KSB7IC8vb25seSBhcHBseSBpZiB0aGluZ3MgY2hhbmdlLiBPdGhlcndpc2UsIGluIGNhc2VzIGxpa2UgYSBiYWNrZ3JvdW5kLWltYWdlIHRoYXQncyBwdWxsZWQgZHluYW1pY2FsbHksIGl0IGNvdWxkIGNhdXNlIGEgcmVmcmVzaC4gU2VlIGh0dHBzOi8vZ3NhcC5jb20vZm9ydW1zL3RvcGljLzIwMzY4LXBvc3NpYmxlLWdzYXAtYnVnLXN3aXRjaGluZy1jbGFzc25hbWVzLWluLWNocm9tZS8uXG4gIFx0XHRzdHlsZS5jc3NUZXh0ID0gY3NzVGV4dDsgLy93ZSByZWNvcmRlZCBjc3NUZXh0IGJlZm9yZSB3ZSBzd2FwcGVkIGNsYXNzZXMgYW5kIHJhbiBfZ2V0QWxsU3R5bGVzKCkgYmVjYXVzZSBpbiBjYXNlcyB3aGVuIGEgY2xhc3NOYW1lIHR3ZWVuIGlzIG92ZXJ3cml0dGVuLCB3ZSByZW1vdmUgYWxsIHRoZSByZWxhdGVkIHR3ZWVuaW5nIHByb3BlcnRpZXMgZnJvbSB0aGF0IGNsYXNzIGNoYW5nZSAob3RoZXJ3aXNlIGNsYXNzLXNwZWNpZmljIHN0dWZmIGNhbid0IG92ZXJyaWRlIHByb3BlcnRpZXMgd2UndmUgZGlyZWN0bHkgc2V0IG9uIHRoZSB0YXJnZXQncyBzdHlsZSBvYmplY3QgZHVlIHRvIHNwZWNpZmljaXR5KS5cbiAgXHR9XG4gIFx0X3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgdHJ1ZSk7IC8vdG8gY2xlYXIgdGhlIGNhY2hpbmcgb2YgdHJhbnNmb3Jtc1xuICBcdGRhdGEuY3NzID0gbmV3IGdzYXAucGx1Z2lucy5jc3MoKTtcbiAgXHRkYXRhLmNzcy5pbml0KHRhcmdldCwgY2hhbmdpbmdWYXJzLCB0d2Vlbik7XG4gIFx0cGx1Z2luLl9wcm9wcy5wdXNoKC4uLmRhdGEuY3NzLl9wcm9wcyk7XG4gIFx0cmV0dXJuIDE7XG4gIH1cbiAgKi9cblxufSxcblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUUkFOU0ZPUk1TXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5faWRlbnRpdHkyRE1hdHJpeCA9IFsxLCAwLCAwLCAxLCAwLCAwXSxcbiAgICBfcm90YXRpb25hbFByb3BlcnRpZXMgPSB7fSxcbiAgICBfaXNOdWxsVHJhbnNmb3JtID0gZnVuY3Rpb24gX2lzTnVsbFRyYW5zZm9ybSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IFwibWF0cml4KDEsIDAsIDAsIDEsIDAsIDApXCIgfHwgdmFsdWUgPT09IFwibm9uZVwiIHx8ICF2YWx1ZTtcbn0sXG4gICAgX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSA9IGZ1bmN0aW9uIF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkodGFyZ2V0KSB7XG4gIHZhciBtYXRyaXhTdHJpbmcgPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKTtcblxuICByZXR1cm4gX2lzTnVsbFRyYW5zZm9ybShtYXRyaXhTdHJpbmcpID8gX2lkZW50aXR5MkRNYXRyaXggOiBtYXRyaXhTdHJpbmcuc3Vic3RyKDcpLm1hdGNoKF9udW1FeHApLm1hcChfcm91bmQpO1xufSxcbiAgICBfZ2V0TWF0cml4ID0gZnVuY3Rpb24gX2dldE1hdHJpeCh0YXJnZXQsIGZvcmNlMkQpIHtcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwIHx8IF9nZXRDYWNoZSh0YXJnZXQpLFxuICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICBtYXRyaXggPSBfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5KHRhcmdldCksXG4gICAgICBwYXJlbnQsXG4gICAgICBuZXh0U2libGluZyxcbiAgICAgIHRlbXAsXG4gICAgICBhZGRlZFRvRE9NO1xuXG4gIGlmIChjYWNoZS5zdmcgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKSkge1xuICAgIHRlbXAgPSB0YXJnZXQudHJhbnNmb3JtLmJhc2VWYWwuY29uc29saWRhdGUoKS5tYXRyaXg7IC8vZW5zdXJlcyB0aGF0IGV2ZW4gY29tcGxleCB2YWx1ZXMgbGlrZSBcInRyYW5zbGF0ZSg1MCw2MCkgcm90YXRlKDEzNSwwLDApXCIgYXJlIHBhcnNlZCBiZWNhdXNlIGl0IG1hc2hlcyBpdCBpbnRvIGEgbWF0cml4LlxuXG4gICAgbWF0cml4ID0gW3RlbXAuYSwgdGVtcC5iLCB0ZW1wLmMsIHRlbXAuZCwgdGVtcC5lLCB0ZW1wLmZdO1xuICAgIHJldHVybiBtYXRyaXguam9pbihcIixcIikgPT09IFwiMSwwLDAsMSwwLDBcIiA/IF9pZGVudGl0eTJETWF0cml4IDogbWF0cml4O1xuICB9IGVsc2UgaWYgKG1hdHJpeCA9PT0gX2lkZW50aXR5MkRNYXRyaXggJiYgIXRhcmdldC5vZmZzZXRQYXJlbnQgJiYgdGFyZ2V0ICE9PSBfZG9jRWxlbWVudCAmJiAhY2FjaGUuc3ZnKSB7XG4gICAgLy9ub3RlOiBpZiBvZmZzZXRQYXJlbnQgaXMgbnVsbCwgdGhhdCBtZWFucyB0aGUgZWxlbWVudCBpc24ndCBpbiB0aGUgbm9ybWFsIGRvY3VtZW50IGZsb3csIGxpa2UgaWYgaXQgaGFzIGRpc3BsYXk6bm9uZSBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBoYXMgZGlzcGxheTpub25lKS4gRmlyZWZveCByZXR1cm5zIG51bGwgZm9yIGdldENvbXB1dGVkU3R5bGUoKSBpZiB0aGUgZWxlbWVudCBpcyBpbiBhbiBpZnJhbWUgdGhhdCBoYXMgZGlzcGxheTpub25lLiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NDgzOTdcbiAgICAvL2Jyb3dzZXJzIGRvbid0IHJlcG9ydCB0cmFuc2Zvcm1zIGFjY3VyYXRlbHkgdW5sZXNzIHRoZSBlbGVtZW50IGlzIGluIHRoZSBET00gYW5kIGhhcyBhIGRpc3BsYXkgdmFsdWUgdGhhdCdzIG5vdCBcIm5vbmVcIi4gRmlyZWZveCBhbmQgTWljcm9zb2Z0IGJyb3dzZXJzIGhhdmUgYSBwYXJ0aWFsIGJ1ZyB3aGVyZSB0aGV5J2xsIHJlcG9ydCB0cmFuc2Zvcm1zIGV2ZW4gaWYgZGlzcGxheTpub25lIEJVVCBub3QgYW55IHBlcmNlbnRhZ2UtYmFzZWQgdmFsdWVzIGxpa2UgdHJhbnNsYXRlKC01MCUsIDhweCkgd2lsbCBiZSByZXBvcnRlZCBhcyBpZiBpdCdzIHRyYW5zbGF0ZSgwLCA4cHgpLlxuICAgIHRlbXAgPSBzdHlsZS5kaXNwbGF5O1xuICAgIHN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgcGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG5cbiAgICBpZiAoIXBhcmVudCB8fCAhdGFyZ2V0Lm9mZnNldFBhcmVudCkge1xuICAgICAgLy8gbm90ZTogaW4gMy4zLjAgd2Ugc3dpdGNoZWQgdGFyZ2V0Lm9mZnNldFBhcmVudCB0byBfZG9jLmJvZHkuY29udGFpbnModGFyZ2V0KSB0byBhdm9pZCBbc29tZXRpbWVzIHVubmVjZXNzYXJ5XSBNdXRhdGlvbk9ic2VydmVyIGNhbGxzIGJ1dCB0aGF0IHdhc24ndCBhZGVxdWF0ZSBiZWNhdXNlIHRoZXJlIGFyZSBlZGdlIGNhc2VzIHdoZXJlIG5lc3RlZCBwb3NpdGlvbjogZml4ZWQgZWxlbWVudHMgbmVlZCB0byBnZXQgcmVwYXJlbnRlZCB0byBhY2N1cmF0ZWx5IHNlbnNlIHRyYW5zZm9ybXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JlZW5zb2NrL0dTQVAvaXNzdWVzLzM4OCBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2dyZWVuc29jay9HU0FQL2lzc3Vlcy8zNzVcbiAgICAgIGFkZGVkVG9ET00gPSAxOyAvL2ZsYWdcblxuICAgICAgbmV4dFNpYmxpbmcgPSB0YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nO1xuXG4gICAgICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZCh0YXJnZXQpOyAvL3dlIG11c3QgYWRkIGl0IHRvIHRoZSBET00gaW4gb3JkZXIgdG8gZ2V0IHZhbHVlcyBwcm9wZXJseVxuXG4gICAgfVxuXG4gICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpO1xuICAgIHRlbXAgPyBzdHlsZS5kaXNwbGF5ID0gdGVtcCA6IF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIFwiZGlzcGxheVwiKTtcblxuICAgIGlmIChhZGRlZFRvRE9NKSB7XG4gICAgICBuZXh0U2libGluZyA/IHBhcmVudC5pbnNlcnRCZWZvcmUodGFyZ2V0LCBuZXh0U2libGluZykgOiBwYXJlbnQgPyBwYXJlbnQuYXBwZW5kQ2hpbGQodGFyZ2V0KSA6IF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcmNlMkQgJiYgbWF0cml4Lmxlbmd0aCA+IDYgPyBbbWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFs0XSwgbWF0cml4WzVdLCBtYXRyaXhbMTJdLCBtYXRyaXhbMTNdXSA6IG1hdHJpeDtcbn0sXG4gICAgX2FwcGx5U1ZHT3JpZ2luID0gZnVuY3Rpb24gX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgb3JpZ2luLCBvcmlnaW5Jc0Fic29sdXRlLCBzbW9vdGgsIG1hdHJpeEFycmF5LCBwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbykge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICBtYXRyaXggPSBtYXRyaXhBcnJheSB8fCBfZ2V0TWF0cml4KHRhcmdldCwgdHJ1ZSksXG4gICAgICB4T3JpZ2luT2xkID0gY2FjaGUueE9yaWdpbiB8fCAwLFxuICAgICAgeU9yaWdpbk9sZCA9IGNhY2hlLnlPcmlnaW4gfHwgMCxcbiAgICAgIHhPZmZzZXRPbGQgPSBjYWNoZS54T2Zmc2V0IHx8IDAsXG4gICAgICB5T2Zmc2V0T2xkID0gY2FjaGUueU9mZnNldCB8fCAwLFxuICAgICAgYSA9IG1hdHJpeFswXSxcbiAgICAgIGIgPSBtYXRyaXhbMV0sXG4gICAgICBjID0gbWF0cml4WzJdLFxuICAgICAgZCA9IG1hdHJpeFszXSxcbiAgICAgIHR4ID0gbWF0cml4WzRdLFxuICAgICAgdHkgPSBtYXRyaXhbNV0sXG4gICAgICBvcmlnaW5TcGxpdCA9IG9yaWdpbi5zcGxpdChcIiBcIiksXG4gICAgICB4T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW5TcGxpdFswXSkgfHwgMCxcbiAgICAgIHlPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpblNwbGl0WzFdKSB8fCAwLFxuICAgICAgYm91bmRzLFxuICAgICAgZGV0ZXJtaW5hbnQsXG4gICAgICB4LFxuICAgICAgeTtcblxuICBpZiAoIW9yaWdpbklzQWJzb2x1dGUpIHtcbiAgICBib3VuZHMgPSBfZ2V0QkJveCh0YXJnZXQpO1xuICAgIHhPcmlnaW4gPSBib3VuZHMueCArICh+b3JpZ2luU3BsaXRbMF0uaW5kZXhPZihcIiVcIikgPyB4T3JpZ2luIC8gMTAwICogYm91bmRzLndpZHRoIDogeE9yaWdpbik7XG4gICAgeU9yaWdpbiA9IGJvdW5kcy55ICsgKH4ob3JpZ2luU3BsaXRbMV0gfHwgb3JpZ2luU3BsaXRbMF0pLmluZGV4T2YoXCIlXCIpID8geU9yaWdpbiAvIDEwMCAqIGJvdW5kcy5oZWlnaHQgOiB5T3JpZ2luKTsgLy8gaWYgKCEoXCJ4T3JpZ2luXCIgaW4gY2FjaGUpICYmICh4T3JpZ2luIHx8IHlPcmlnaW4pKSB7IC8vIGFkZGVkIGluIDMuMTIuMywgcmV2ZXJ0ZWQgaW4gMy4xMi40OyByZXF1aXJlcyBtb3JlIGV4cGxvcmF0aW9uXG4gICAgLy8gXHR4T3JpZ2luIC09IGJvdW5kcy54O1xuICAgIC8vIFx0eU9yaWdpbiAtPSBib3VuZHMueTtcbiAgICAvLyB9XG4gIH0gZWxzZSBpZiAobWF0cml4ICE9PSBfaWRlbnRpdHkyRE1hdHJpeCAmJiAoZGV0ZXJtaW5hbnQgPSBhICogZCAtIGIgKiBjKSkge1xuICAgIC8vaWYgaXQncyB6ZXJvIChsaWtlIGlmIHNjYWxlWCBhbmQgc2NhbGVZIGFyZSB6ZXJvKSwgc2tpcCBpdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBkaXZpZGluZyBieSB6ZXJvLlxuICAgIHggPSB4T3JpZ2luICogKGQgLyBkZXRlcm1pbmFudCkgKyB5T3JpZ2luICogKC1jIC8gZGV0ZXJtaW5hbnQpICsgKGMgKiB0eSAtIGQgKiB0eCkgLyBkZXRlcm1pbmFudDtcbiAgICB5ID0geE9yaWdpbiAqICgtYiAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoYSAvIGRldGVybWluYW50KSAtIChhICogdHkgLSBiICogdHgpIC8gZGV0ZXJtaW5hbnQ7XG4gICAgeE9yaWdpbiA9IHg7XG4gICAgeU9yaWdpbiA9IHk7IC8vIHRoZW9yeTogd2Ugb25seSBoYWQgdG8gZG8gdGhpcyBmb3Igc21vb3RoaW5nIGFuZCBpdCBhc3N1bWVzIHRoYXQgdGhlIHByZXZpb3VzIG9uZSB3YXMgbm90IG9yaWdpbklzQWJzb2x1dGUuXG4gIH1cblxuICBpZiAoc21vb3RoIHx8IHNtb290aCAhPT0gZmFsc2UgJiYgY2FjaGUuc21vb3RoKSB7XG4gICAgdHggPSB4T3JpZ2luIC0geE9yaWdpbk9sZDtcbiAgICB0eSA9IHlPcmlnaW4gLSB5T3JpZ2luT2xkO1xuICAgIGNhY2hlLnhPZmZzZXQgPSB4T2Zmc2V0T2xkICsgKHR4ICogYSArIHR5ICogYykgLSB0eDtcbiAgICBjYWNoZS55T2Zmc2V0ID0geU9mZnNldE9sZCArICh0eCAqIGIgKyB0eSAqIGQpIC0gdHk7XG4gIH0gZWxzZSB7XG4gICAgY2FjaGUueE9mZnNldCA9IGNhY2hlLnlPZmZzZXQgPSAwO1xuICB9XG5cbiAgY2FjaGUueE9yaWdpbiA9IHhPcmlnaW47XG4gIGNhY2hlLnlPcmlnaW4gPSB5T3JpZ2luO1xuICBjYWNoZS5zbW9vdGggPSAhIXNtb290aDtcbiAgY2FjaGUub3JpZ2luID0gb3JpZ2luO1xuICBjYWNoZS5vcmlnaW5Jc0Fic29sdXRlID0gISFvcmlnaW5Jc0Fic29sdXRlO1xuICB0YXJnZXQuc3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdID0gXCIwcHggMHB4XCI7IC8vb3RoZXJ3aXNlLCBpZiBzb21lb25lIHNldHMgIGFuIG9yaWdpbiB2aWEgQ1NTLCBpdCB3aWxsIGxpa2VseSBpbnRlcmZlcmUgd2l0aCB0aGUgU1ZHIHRyYW5zZm9ybSBhdHRyaWJ1dGUgb25lcyAoYmVjYXVzZSByZW1lbWJlciwgd2UncmUgYmFraW5nIHRoZSBvcmlnaW4gaW50byB0aGUgbWF0cml4KCkgdmFsdWUpLlxuXG4gIGlmIChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbykge1xuICAgIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ4T3JpZ2luXCIsIHhPcmlnaW5PbGQsIHhPcmlnaW4pO1xuXG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInlPcmlnaW5cIiwgeU9yaWdpbk9sZCwgeU9yaWdpbik7XG5cbiAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieE9mZnNldFwiLCB4T2Zmc2V0T2xkLCBjYWNoZS54T2Zmc2V0KTtcblxuICAgIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ5T2Zmc2V0XCIsIHlPZmZzZXRPbGQsIGNhY2hlLnlPZmZzZXQpO1xuICB9XG5cbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiLCB4T3JpZ2luICsgXCIgXCIgKyB5T3JpZ2luKTtcbn0sXG4gICAgX3BhcnNlVHJhbnNmb3JtID0gZnVuY3Rpb24gX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgdW5jYWNoZSkge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXAgfHwgbmV3IEdTQ2FjaGUodGFyZ2V0KTtcblxuICBpZiAoXCJ4XCIgaW4gY2FjaGUgJiYgIXVuY2FjaGUgJiYgIWNhY2hlLnVuY2FjaGUpIHtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH1cblxuICB2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICBpbnZlcnRlZFNjYWxlWCA9IGNhY2hlLnNjYWxlWCA8IDAsXG4gICAgICBweCA9IFwicHhcIixcbiAgICAgIGRlZyA9IFwiZGVnXCIsXG4gICAgICBjcyA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KSxcbiAgICAgIG9yaWdpbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybU9yaWdpblByb3ApIHx8IFwiMFwiLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB6LFxuICAgICAgc2NhbGVYLFxuICAgICAgc2NhbGVZLFxuICAgICAgcm90YXRpb24sXG4gICAgICByb3RhdGlvblgsXG4gICAgICByb3RhdGlvblksXG4gICAgICBza2V3WCxcbiAgICAgIHNrZXdZLFxuICAgICAgcGVyc3BlY3RpdmUsXG4gICAgICB4T3JpZ2luLFxuICAgICAgeU9yaWdpbixcbiAgICAgIG1hdHJpeCxcbiAgICAgIGFuZ2xlLFxuICAgICAgY29zLFxuICAgICAgc2luLFxuICAgICAgYSxcbiAgICAgIGIsXG4gICAgICBjLFxuICAgICAgZCxcbiAgICAgIGExMixcbiAgICAgIGEyMixcbiAgICAgIHQxLFxuICAgICAgdDIsXG4gICAgICB0MyxcbiAgICAgIGExMyxcbiAgICAgIGEyMyxcbiAgICAgIGEzMyxcbiAgICAgIGE0MixcbiAgICAgIGE0MyxcbiAgICAgIGEzMjtcbiAgeCA9IHkgPSB6ID0gcm90YXRpb24gPSByb3RhdGlvblggPSByb3RhdGlvblkgPSBza2V3WCA9IHNrZXdZID0gcGVyc3BlY3RpdmUgPSAwO1xuICBzY2FsZVggPSBzY2FsZVkgPSAxO1xuICBjYWNoZS5zdmcgPSAhISh0YXJnZXQuZ2V0Q1RNICYmIF9pc1NWRyh0YXJnZXQpKTtcblxuICBpZiAoY3MudHJhbnNsYXRlKSB7XG4gICAgLy8gYWNjb21tb2RhdGUgaW5kZXBlbmRlbnQgdHJhbnNmb3JtcyBieSBjb21iaW5pbmcgdGhlbSBpbnRvIG5vcm1hbCBvbmVzLlxuICAgIGlmIChjcy50cmFuc2xhdGUgIT09IFwibm9uZVwiIHx8IGNzLnNjYWxlICE9PSBcIm5vbmVcIiB8fCBjcy5yb3RhdGUgIT09IFwibm9uZVwiKSB7XG4gICAgICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSAoY3MudHJhbnNsYXRlICE9PSBcIm5vbmVcIiA/IFwidHJhbnNsYXRlM2QoXCIgKyAoY3MudHJhbnNsYXRlICsgXCIgMCAwXCIpLnNwbGl0KFwiIFwiKS5zbGljZSgwLCAzKS5qb2luKFwiLCBcIikgKyBcIikgXCIgOiBcIlwiKSArIChjcy5yb3RhdGUgIT09IFwibm9uZVwiID8gXCJyb3RhdGUoXCIgKyBjcy5yb3RhdGUgKyBcIikgXCIgOiBcIlwiKSArIChjcy5zY2FsZSAhPT0gXCJub25lXCIgPyBcInNjYWxlKFwiICsgY3Muc2NhbGUuc3BsaXQoXCIgXCIpLmpvaW4oXCIsXCIpICsgXCIpIFwiIDogXCJcIikgKyAoY3NbX3RyYW5zZm9ybVByb3BdICE9PSBcIm5vbmVcIiA/IGNzW190cmFuc2Zvcm1Qcm9wXSA6IFwiXCIpO1xuICAgIH1cblxuICAgIHN0eWxlLnNjYWxlID0gc3R5bGUucm90YXRlID0gc3R5bGUudHJhbnNsYXRlID0gXCJub25lXCI7XG4gIH1cblxuICBtYXRyaXggPSBfZ2V0TWF0cml4KHRhcmdldCwgY2FjaGUuc3ZnKTtcblxuICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgaWYgKGNhY2hlLnVuY2FjaGUpIHtcbiAgICAgIC8vIGlmIGNhY2hlLnVuY2FjaGUgaXMgdHJ1ZSAoYW5kIG1heWJlIGlmIG9yaWdpbiBpcyAwLDApLCB3ZSBuZWVkIHRvIHNldCBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IChjYWNoZS54T3JpZ2luIC0gYmJveC54KSArIFwicHggXCIgKyAoY2FjaGUueU9yaWdpbiAtIGJib3gueSkgKyBcInB4XCIuIFByZXZpb3VzbHkgd2UgbGV0IHRoZSBkYXRhLXN2Zy1vcmlnaW4gc3RheSBpbnN0ZWFkLCBidXQgd2hlbiBpbnRyb2R1Y2luZyByZXZlcnQoKSwgaXQgY29tcGxpY2F0ZWQgdGhpbmdzLlxuICAgICAgdDIgPSB0YXJnZXQuZ2V0QkJveCgpO1xuICAgICAgb3JpZ2luID0gY2FjaGUueE9yaWdpbiAtIHQyLnggKyBcInB4IFwiICsgKGNhY2hlLnlPcmlnaW4gLSB0Mi55KSArIFwicHhcIjtcbiAgICAgIHQxID0gXCJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdDEgPSAhdW5jYWNoZSAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIpOyAvLyAgUmVtZW1iZXIsIHRvIHdvcmsgYXJvdW5kIGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzIHdlIGFsd2F5cyBmb3JjZSBTVkcgZWxlbWVudHMnIHRyYW5zZm9ybU9yaWdpbiB0byAwLDAgYW5kIG9mZnNldCB0aGUgdHJhbnNsYXRpb24gYWNjb3JkaW5nbHkuXG4gICAgfVxuXG4gICAgX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgdDEgfHwgb3JpZ2luLCAhIXQxIHx8IGNhY2hlLm9yaWdpbklzQWJzb2x1dGUsIGNhY2hlLnNtb290aCAhPT0gZmFsc2UsIG1hdHJpeCk7XG4gIH1cblxuICB4T3JpZ2luID0gY2FjaGUueE9yaWdpbiB8fCAwO1xuICB5T3JpZ2luID0gY2FjaGUueU9yaWdpbiB8fCAwO1xuXG4gIGlmIChtYXRyaXggIT09IF9pZGVudGl0eTJETWF0cml4KSB7XG4gICAgYSA9IG1hdHJpeFswXTsgLy9hMTFcblxuICAgIGIgPSBtYXRyaXhbMV07IC8vYTIxXG5cbiAgICBjID0gbWF0cml4WzJdOyAvL2EzMVxuXG4gICAgZCA9IG1hdHJpeFszXTsgLy9hNDFcblxuICAgIHggPSBhMTIgPSBtYXRyaXhbNF07XG4gICAgeSA9IGEyMiA9IG1hdHJpeFs1XTsgLy8yRCBtYXRyaXhcblxuICAgIGlmIChtYXRyaXgubGVuZ3RoID09PSA2KSB7XG4gICAgICBzY2FsZVggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gICAgICBzY2FsZVkgPSBNYXRoLnNxcnQoZCAqIGQgKyBjICogYyk7XG4gICAgICByb3RhdGlvbiA9IGEgfHwgYiA/IF9hdGFuMihiLCBhKSAqIF9SQUQyREVHIDogMDsgLy9ub3RlOiBpZiBzY2FsZVggaXMgMCwgd2UgY2Fubm90IGFjY3VyYXRlbHkgbWVhc3VyZSByb3RhdGlvbi4gU2FtZSBmb3Igc2tld1ggd2l0aCBhIHNjYWxlWSBvZiAwLiBUaGVyZWZvcmUsIHdlIGRlZmF1bHQgdG8gdGhlIHByZXZpb3VzbHkgcmVjb3JkZWQgdmFsdWUgKG9yIHplcm8gaWYgdGhhdCBkb2Vzbid0IGV4aXN0KS5cblxuICAgICAgc2tld1ggPSBjIHx8IGQgPyBfYXRhbjIoYywgZCkgKiBfUkFEMkRFRyArIHJvdGF0aW9uIDogMDtcbiAgICAgIHNrZXdYICYmIChzY2FsZVkgKj0gTWF0aC5hYnMoTWF0aC5jb3Moc2tld1ggKiBfREVHMlJBRCkpKTtcblxuICAgICAgaWYgKGNhY2hlLnN2Zykge1xuICAgICAgICB4IC09IHhPcmlnaW4gLSAoeE9yaWdpbiAqIGEgKyB5T3JpZ2luICogYyk7XG4gICAgICAgIHkgLT0geU9yaWdpbiAtICh4T3JpZ2luICogYiArIHlPcmlnaW4gKiBkKTtcbiAgICAgIH0gLy8zRCBtYXRyaXhcblxuICAgIH0gZWxzZSB7XG4gICAgICBhMzIgPSBtYXRyaXhbNl07XG4gICAgICBhNDIgPSBtYXRyaXhbN107XG4gICAgICBhMTMgPSBtYXRyaXhbOF07XG4gICAgICBhMjMgPSBtYXRyaXhbOV07XG4gICAgICBhMzMgPSBtYXRyaXhbMTBdO1xuICAgICAgYTQzID0gbWF0cml4WzExXTtcbiAgICAgIHggPSBtYXRyaXhbMTJdO1xuICAgICAgeSA9IG1hdHJpeFsxM107XG4gICAgICB6ID0gbWF0cml4WzE0XTtcbiAgICAgIGFuZ2xlID0gX2F0YW4yKGEzMiwgYTMzKTtcbiAgICAgIHJvdGF0aW9uWCA9IGFuZ2xlICogX1JBRDJERUc7IC8vcm90YXRpb25YXG5cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICBjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuICAgICAgICBzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuICAgICAgICB0MSA9IGExMiAqIGNvcyArIGExMyAqIHNpbjtcbiAgICAgICAgdDIgPSBhMjIgKiBjb3MgKyBhMjMgKiBzaW47XG4gICAgICAgIHQzID0gYTMyICogY29zICsgYTMzICogc2luO1xuICAgICAgICBhMTMgPSBhMTIgKiAtc2luICsgYTEzICogY29zO1xuICAgICAgICBhMjMgPSBhMjIgKiAtc2luICsgYTIzICogY29zO1xuICAgICAgICBhMzMgPSBhMzIgKiAtc2luICsgYTMzICogY29zO1xuICAgICAgICBhNDMgPSBhNDIgKiAtc2luICsgYTQzICogY29zO1xuICAgICAgICBhMTIgPSB0MTtcbiAgICAgICAgYTIyID0gdDI7XG4gICAgICAgIGEzMiA9IHQzO1xuICAgICAgfSAvL3JvdGF0aW9uWVxuXG5cbiAgICAgIGFuZ2xlID0gX2F0YW4yKC1jLCBhMzMpO1xuICAgICAgcm90YXRpb25ZID0gYW5nbGUgKiBfUkFEMkRFRztcblxuICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gICAgICAgIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG4gICAgICAgIHQxID0gYSAqIGNvcyAtIGExMyAqIHNpbjtcbiAgICAgICAgdDIgPSBiICogY29zIC0gYTIzICogc2luO1xuICAgICAgICB0MyA9IGMgKiBjb3MgLSBhMzMgKiBzaW47XG4gICAgICAgIGE0MyA9IGQgKiBzaW4gKyBhNDMgKiBjb3M7XG4gICAgICAgIGEgPSB0MTtcbiAgICAgICAgYiA9IHQyO1xuICAgICAgICBjID0gdDM7XG4gICAgICB9IC8vcm90YXRpb25aXG5cblxuICAgICAgYW5nbGUgPSBfYXRhbjIoYiwgYSk7XG4gICAgICByb3RhdGlvbiA9IGFuZ2xlICogX1JBRDJERUc7XG5cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdDEgPSBhICogY29zICsgYiAqIHNpbjtcbiAgICAgICAgdDIgPSBhMTIgKiBjb3MgKyBhMjIgKiBzaW47XG4gICAgICAgIGIgPSBiICogY29zIC0gYSAqIHNpbjtcbiAgICAgICAgYTIyID0gYTIyICogY29zIC0gYTEyICogc2luO1xuICAgICAgICBhID0gdDE7XG4gICAgICAgIGExMiA9IHQyO1xuICAgICAgfVxuXG4gICAgICBpZiAocm90YXRpb25YICYmIE1hdGguYWJzKHJvdGF0aW9uWCkgKyBNYXRoLmFicyhyb3RhdGlvbikgPiAzNTkuOSkge1xuICAgICAgICAvL3doZW4gcm90YXRpb25ZIGlzIHNldCwgaXQgd2lsbCBvZnRlbiBiZSBwYXJzZWQgYXMgMTgwIGRlZ3JlZXMgZGlmZmVyZW50IHRoYW4gaXQgc2hvdWxkIGJlLCBhbmQgcm90YXRpb25YIGFuZCByb3RhdGlvbiBib3RoIGJlaW5nIDE4MCAoaXQgbG9va3MgdGhlIHNhbWUpLCBzbyB3ZSBhZGp1c3QgZm9yIHRoYXQgaGVyZS5cbiAgICAgICAgcm90YXRpb25YID0gcm90YXRpb24gPSAwO1xuICAgICAgICByb3RhdGlvblkgPSAxODAgLSByb3RhdGlvblk7XG4gICAgICB9XG5cbiAgICAgIHNjYWxlWCA9IF9yb3VuZChNYXRoLnNxcnQoYSAqIGEgKyBiICogYiArIGMgKiBjKSk7XG4gICAgICBzY2FsZVkgPSBfcm91bmQoTWF0aC5zcXJ0KGEyMiAqIGEyMiArIGEzMiAqIGEzMikpO1xuICAgICAgYW5nbGUgPSBfYXRhbjIoYTEyLCBhMjIpO1xuICAgICAgc2tld1ggPSBNYXRoLmFicyhhbmdsZSkgPiAwLjAwMDIgPyBhbmdsZSAqIF9SQUQyREVHIDogMDtcbiAgICAgIHBlcnNwZWN0aXZlID0gYTQzID8gMSAvIChhNDMgPCAwID8gLWE0MyA6IGE0MykgOiAwO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgIC8vc2Vuc2UgaWYgdGhlcmUgYXJlIENTUyB0cmFuc2Zvcm1zIGFwcGxpZWQgb24gYW4gU1ZHIGVsZW1lbnQgaW4gd2hpY2ggY2FzZSB3ZSBtdXN0IG92ZXJ3cml0ZSB0aGVtIHdoZW4gcmVuZGVyaW5nLiBUaGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSBpcyBtb3JlIHJlbGlhYmxlIGNyb3NzLWJyb3dzZXIsIGJ1dCB3ZSBjYW4ndCBqdXN0IHJlbW92ZSB0aGUgQ1NTIG9uZXMgYmVjYXVzZSB0aGV5IG1heSBiZSBhcHBsaWVkIGluIGEgQ1NTIHJ1bGUgc29tZXdoZXJlIChub3QganVzdCBpbmxpbmUpLlxuICAgICAgdDEgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuICAgICAgY2FjaGUuZm9yY2VDU1MgPSB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwiXCIpIHx8ICFfaXNOdWxsVHJhbnNmb3JtKF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApKTtcbiAgICAgIHQxICYmIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdDEpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChNYXRoLmFicyhza2V3WCkgPiA5MCAmJiBNYXRoLmFicyhza2V3WCkgPCAyNzApIHtcbiAgICBpZiAoaW52ZXJ0ZWRTY2FsZVgpIHtcbiAgICAgIHNjYWxlWCAqPSAtMTtcbiAgICAgIHNrZXdYICs9IHJvdGF0aW9uIDw9IDAgPyAxODAgOiAtMTgwO1xuICAgICAgcm90YXRpb24gKz0gcm90YXRpb24gPD0gMCA/IDE4MCA6IC0xODA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlWSAqPSAtMTtcbiAgICAgIHNrZXdYICs9IHNrZXdYIDw9IDAgPyAxODAgOiAtMTgwO1xuICAgIH1cbiAgfVxuXG4gIHVuY2FjaGUgPSB1bmNhY2hlIHx8IGNhY2hlLnVuY2FjaGU7XG4gIGNhY2hlLnggPSB4IC0gKChjYWNoZS54UGVyY2VudCA9IHggJiYgKCF1bmNhY2hlICYmIGNhY2hlLnhQZXJjZW50IHx8IChNYXRoLnJvdW5kKHRhcmdldC5vZmZzZXRXaWR0aCAvIDIpID09PSBNYXRoLnJvdW5kKC14KSA/IC01MCA6IDApKSkgPyB0YXJnZXQub2Zmc2V0V2lkdGggKiBjYWNoZS54UGVyY2VudCAvIDEwMCA6IDApICsgcHg7XG4gIGNhY2hlLnkgPSB5IC0gKChjYWNoZS55UGVyY2VudCA9IHkgJiYgKCF1bmNhY2hlICYmIGNhY2hlLnlQZXJjZW50IHx8IChNYXRoLnJvdW5kKHRhcmdldC5vZmZzZXRIZWlnaHQgLyAyKSA9PT0gTWF0aC5yb3VuZCgteSkgPyAtNTAgOiAwKSkpID8gdGFyZ2V0Lm9mZnNldEhlaWdodCAqIGNhY2hlLnlQZXJjZW50IC8gMTAwIDogMCkgKyBweDtcbiAgY2FjaGUueiA9IHogKyBweDtcbiAgY2FjaGUuc2NhbGVYID0gX3JvdW5kKHNjYWxlWCk7XG4gIGNhY2hlLnNjYWxlWSA9IF9yb3VuZChzY2FsZVkpO1xuICBjYWNoZS5yb3RhdGlvbiA9IF9yb3VuZChyb3RhdGlvbikgKyBkZWc7XG4gIGNhY2hlLnJvdGF0aW9uWCA9IF9yb3VuZChyb3RhdGlvblgpICsgZGVnO1xuICBjYWNoZS5yb3RhdGlvblkgPSBfcm91bmQocm90YXRpb25ZKSArIGRlZztcbiAgY2FjaGUuc2tld1ggPSBza2V3WCArIGRlZztcbiAgY2FjaGUuc2tld1kgPSBza2V3WSArIGRlZztcbiAgY2FjaGUudHJhbnNmb3JtUGVyc3BlY3RpdmUgPSBwZXJzcGVjdGl2ZSArIHB4O1xuXG4gIGlmIChjYWNoZS56T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW4uc3BsaXQoXCIgXCIpWzJdKSB8fCAhdW5jYWNoZSAmJiBjYWNoZS56T3JpZ2luIHx8IDApIHtcbiAgICBzdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBfZmlyc3RUd29Pbmx5KG9yaWdpbik7XG4gIH1cblxuICBjYWNoZS54T2Zmc2V0ID0gY2FjaGUueU9mZnNldCA9IDA7XG4gIGNhY2hlLmZvcmNlM0QgPSBfY29uZmlnLmZvcmNlM0Q7XG4gIGNhY2hlLnJlbmRlclRyYW5zZm9ybSA9IGNhY2hlLnN2ZyA/IF9yZW5kZXJTVkdUcmFuc2Zvcm1zIDogX3N1cHBvcnRzM0QgPyBfcmVuZGVyQ1NTVHJhbnNmb3JtcyA6IF9yZW5kZXJOb24zRFRyYW5zZm9ybXM7XG4gIGNhY2hlLnVuY2FjaGUgPSAwO1xuICByZXR1cm4gY2FjaGU7XG59LFxuICAgIF9maXJzdFR3b09ubHkgPSBmdW5jdGlvbiBfZmlyc3RUd29Pbmx5KHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgPSB2YWx1ZS5zcGxpdChcIiBcIikpWzBdICsgXCIgXCIgKyB2YWx1ZVsxXTtcbn0sXG4gICAgLy9mb3IgaGFuZGxpbmcgdHJhbnNmb3JtT3JpZ2luIHZhbHVlcywgc3RyaXBwaW5nIG91dCB0aGUgM3JkIGRpbWVuc2lvblxuX2FkZFB4VHJhbnNsYXRlID0gZnVuY3Rpb24gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgc3RhcnQsIHZhbHVlKSB7XG4gIHZhciB1bml0ID0gZ2V0VW5pdChzdGFydCk7XG4gIHJldHVybiBfcm91bmQocGFyc2VGbG9hdChzdGFydCkgKyBwYXJzZUZsb2F0KF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ4XCIsIHZhbHVlICsgXCJweFwiLCB1bml0KSkpICsgdW5pdDtcbn0sXG4gICAgX3JlbmRlck5vbjNEVHJhbnNmb3JtcyA9IGZ1bmN0aW9uIF9yZW5kZXJOb24zRFRyYW5zZm9ybXMocmF0aW8sIGNhY2hlKSB7XG4gIGNhY2hlLnogPSBcIjBweFwiO1xuICBjYWNoZS5yb3RhdGlvblkgPSBjYWNoZS5yb3RhdGlvblggPSBcIjBkZWdcIjtcbiAgY2FjaGUuZm9yY2UzRCA9IDA7XG5cbiAgX3JlbmRlckNTU1RyYW5zZm9ybXMocmF0aW8sIGNhY2hlKTtcbn0sXG4gICAgX3plcm9EZWcgPSBcIjBkZWdcIixcbiAgICBfemVyb1B4ID0gXCIwcHhcIixcbiAgICBfZW5kUGFyZW50aGVzaXMgPSBcIikgXCIsXG4gICAgX3JlbmRlckNTU1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgdmFyIF9yZWYgPSBjYWNoZSB8fCB0aGlzLFxuICAgICAgeFBlcmNlbnQgPSBfcmVmLnhQZXJjZW50LFxuICAgICAgeVBlcmNlbnQgPSBfcmVmLnlQZXJjZW50LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICB6ID0gX3JlZi56LFxuICAgICAgcm90YXRpb24gPSBfcmVmLnJvdGF0aW9uLFxuICAgICAgcm90YXRpb25ZID0gX3JlZi5yb3RhdGlvblksXG4gICAgICByb3RhdGlvblggPSBfcmVmLnJvdGF0aW9uWCxcbiAgICAgIHNrZXdYID0gX3JlZi5za2V3WCxcbiAgICAgIHNrZXdZID0gX3JlZi5za2V3WSxcbiAgICAgIHNjYWxlWCA9IF9yZWYuc2NhbGVYLFxuICAgICAgc2NhbGVZID0gX3JlZi5zY2FsZVksXG4gICAgICB0cmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IF9yZWYudHJhbnNmb3JtUGVyc3BlY3RpdmUsXG4gICAgICBmb3JjZTNEID0gX3JlZi5mb3JjZTNELFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB6T3JpZ2luID0gX3JlZi56T3JpZ2luLFxuICAgICAgdHJhbnNmb3JtcyA9IFwiXCIsXG4gICAgICB1c2UzRCA9IGZvcmNlM0QgPT09IFwiYXV0b1wiICYmIHJhdGlvICYmIHJhdGlvICE9PSAxIHx8IGZvcmNlM0QgPT09IHRydWU7IC8vIFNhZmFyaSBoYXMgYSBidWcgdGhhdCBjYXVzZXMgaXQgbm90IHRvIHJlbmRlciAzRCB0cmFuc2Zvcm0tb3JpZ2luIHZhbHVlcyBwcm9wZXJseSwgc28gd2UgZm9yY2UgdGhlIHogb3JpZ2luIHRvIDAsIHJlY29yZCBpdCBpbiB0aGUgY2FjaGUsIGFuZCB0aGVuIGRvIHRoZSBtYXRoIGhlcmUgdG8gb2Zmc2V0IHRoZSB0cmFuc2xhdGUgdmFsdWVzIGFjY29yZGluZ2x5IChiYXNpY2FsbHkgZG8gdGhlIDNEIHRyYW5zZm9ybS1vcmlnaW4gcGFydCBtYW51YWxseSlcblxuXG4gIGlmICh6T3JpZ2luICYmIChyb3RhdGlvblggIT09IF96ZXJvRGVnIHx8IHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpKSB7XG4gICAgdmFyIGFuZ2xlID0gcGFyc2VGbG9hdChyb3RhdGlvblkpICogX0RFRzJSQUQsXG4gICAgICAgIGExMyA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgYTMzID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICBjb3M7XG5cbiAgICBhbmdsZSA9IHBhcnNlRmxvYXQocm90YXRpb25YKSAqIF9ERUcyUkFEO1xuICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICB4ID0gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgeCwgYTEzICogY29zICogLXpPcmlnaW4pO1xuICAgIHkgPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB5LCAtTWF0aC5zaW4oYW5nbGUpICogLXpPcmlnaW4pO1xuICAgIHogPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB6LCBhMzMgKiBjb3MgKiAtek9yaWdpbiArIHpPcmlnaW4pO1xuICB9XG5cbiAgaWYgKHRyYW5zZm9ybVBlcnNwZWN0aXZlICE9PSBfemVyb1B4KSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInBlcnNwZWN0aXZlKFwiICsgdHJhbnNmb3JtUGVyc3BlY3RpdmUgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAoeFBlcmNlbnQgfHwgeVBlcmNlbnQpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwidHJhbnNsYXRlKFwiICsgeFBlcmNlbnQgKyBcIiUsIFwiICsgeVBlcmNlbnQgKyBcIiUpIFwiO1xuICB9XG5cbiAgaWYgKHVzZTNEIHx8IHggIT09IF96ZXJvUHggfHwgeSAhPT0gX3plcm9QeCB8fCB6ICE9PSBfemVyb1B4KSB7XG4gICAgdHJhbnNmb3JtcyArPSB6ICE9PSBfemVyb1B4IHx8IHVzZTNEID8gXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcIiwgXCIgKyB5ICsgXCIsIFwiICsgeiArIFwiKSBcIiA6IFwidHJhbnNsYXRlKFwiICsgeCArIFwiLCBcIiArIHkgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAocm90YXRpb24gIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZShcIiArIHJvdGF0aW9uICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwicm90YXRlWShcIiArIHJvdGF0aW9uWSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChyb3RhdGlvblggIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZVgoXCIgKyByb3RhdGlvblggKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAoc2tld1ggIT09IF96ZXJvRGVnIHx8IHNrZXdZICE9PSBfemVyb0RlZykge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJza2V3KFwiICsgc2tld1ggKyBcIiwgXCIgKyBza2V3WSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInNjYWxlKFwiICsgc2NhbGVYICsgXCIsIFwiICsgc2NhbGVZICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgdGFyZ2V0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXMgfHwgXCJ0cmFuc2xhdGUoMCwgMClcIjtcbn0sXG4gICAgX3JlbmRlclNWR1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyU1ZHVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgdmFyIF9yZWYyID0gY2FjaGUgfHwgdGhpcyxcbiAgICAgIHhQZXJjZW50ID0gX3JlZjIueFBlcmNlbnQsXG4gICAgICB5UGVyY2VudCA9IF9yZWYyLnlQZXJjZW50LFxuICAgICAgeCA9IF9yZWYyLngsXG4gICAgICB5ID0gX3JlZjIueSxcbiAgICAgIHJvdGF0aW9uID0gX3JlZjIucm90YXRpb24sXG4gICAgICBza2V3WCA9IF9yZWYyLnNrZXdYLFxuICAgICAgc2tld1kgPSBfcmVmMi5za2V3WSxcbiAgICAgIHNjYWxlWCA9IF9yZWYyLnNjYWxlWCxcbiAgICAgIHNjYWxlWSA9IF9yZWYyLnNjYWxlWSxcbiAgICAgIHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHhPcmlnaW4gPSBfcmVmMi54T3JpZ2luLFxuICAgICAgeU9yaWdpbiA9IF9yZWYyLnlPcmlnaW4sXG4gICAgICB4T2Zmc2V0ID0gX3JlZjIueE9mZnNldCxcbiAgICAgIHlPZmZzZXQgPSBfcmVmMi55T2Zmc2V0LFxuICAgICAgZm9yY2VDU1MgPSBfcmVmMi5mb3JjZUNTUyxcbiAgICAgIHR4ID0gcGFyc2VGbG9hdCh4KSxcbiAgICAgIHR5ID0gcGFyc2VGbG9hdCh5KSxcbiAgICAgIGExMSxcbiAgICAgIGEyMSxcbiAgICAgIGExMixcbiAgICAgIGEyMixcbiAgICAgIHRlbXA7XG5cbiAgcm90YXRpb24gPSBwYXJzZUZsb2F0KHJvdGF0aW9uKTtcbiAgc2tld1ggPSBwYXJzZUZsb2F0KHNrZXdYKTtcbiAgc2tld1kgPSBwYXJzZUZsb2F0KHNrZXdZKTtcblxuICBpZiAoc2tld1kpIHtcbiAgICAvL2ZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBjb21iaW5lIGFsbCBza2V3aW5nIGludG8gdGhlIHNrZXdYIGFuZCByb3RhdGlvbiB2YWx1ZXMuIFJlbWVtYmVyLCBhIHNrZXdZIG9mIDEwIGRlZ3JlZXMgbG9va3MgdGhlIHNhbWUgYXMgYSByb3RhdGlvbiBvZiAxMCBkZWdyZWVzIHBsdXMgYSBza2V3WCBvZiAxMCBkZWdyZWVzLlxuICAgIHNrZXdZID0gcGFyc2VGbG9hdChza2V3WSk7XG4gICAgc2tld1ggKz0gc2tld1k7XG4gICAgcm90YXRpb24gKz0gc2tld1k7XG4gIH1cblxuICBpZiAocm90YXRpb24gfHwgc2tld1gpIHtcbiAgICByb3RhdGlvbiAqPSBfREVHMlJBRDtcbiAgICBza2V3WCAqPSBfREVHMlJBRDtcbiAgICBhMTEgPSBNYXRoLmNvcyhyb3RhdGlvbikgKiBzY2FsZVg7XG4gICAgYTIxID0gTWF0aC5zaW4ocm90YXRpb24pICogc2NhbGVYO1xuICAgIGExMiA9IE1hdGguc2luKHJvdGF0aW9uIC0gc2tld1gpICogLXNjYWxlWTtcbiAgICBhMjIgPSBNYXRoLmNvcyhyb3RhdGlvbiAtIHNrZXdYKSAqIHNjYWxlWTtcblxuICAgIGlmIChza2V3WCkge1xuICAgICAgc2tld1kgKj0gX0RFRzJSQUQ7XG4gICAgICB0ZW1wID0gTWF0aC50YW4oc2tld1ggLSBza2V3WSk7XG4gICAgICB0ZW1wID0gTWF0aC5zcXJ0KDEgKyB0ZW1wICogdGVtcCk7XG4gICAgICBhMTIgKj0gdGVtcDtcbiAgICAgIGEyMiAqPSB0ZW1wO1xuXG4gICAgICBpZiAoc2tld1kpIHtcbiAgICAgICAgdGVtcCA9IE1hdGgudGFuKHNrZXdZKTtcbiAgICAgICAgdGVtcCA9IE1hdGguc3FydCgxICsgdGVtcCAqIHRlbXApO1xuICAgICAgICBhMTEgKj0gdGVtcDtcbiAgICAgICAgYTIxICo9IHRlbXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYTExID0gX3JvdW5kKGExMSk7XG4gICAgYTIxID0gX3JvdW5kKGEyMSk7XG4gICAgYTEyID0gX3JvdW5kKGExMik7XG4gICAgYTIyID0gX3JvdW5kKGEyMik7XG4gIH0gZWxzZSB7XG4gICAgYTExID0gc2NhbGVYO1xuICAgIGEyMiA9IHNjYWxlWTtcbiAgICBhMjEgPSBhMTIgPSAwO1xuICB9XG5cbiAgaWYgKHR4ICYmICF+KHggKyBcIlwiKS5pbmRleE9mKFwicHhcIikgfHwgdHkgJiYgIX4oeSArIFwiXCIpLmluZGV4T2YoXCJweFwiKSkge1xuICAgIHR4ID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBcInhcIiwgeCwgXCJweFwiKTtcbiAgICB0eSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ5XCIsIHksIFwicHhcIik7XG4gIH1cblxuICBpZiAoeE9yaWdpbiB8fCB5T3JpZ2luIHx8IHhPZmZzZXQgfHwgeU9mZnNldCkge1xuICAgIHR4ID0gX3JvdW5kKHR4ICsgeE9yaWdpbiAtICh4T3JpZ2luICogYTExICsgeU9yaWdpbiAqIGExMikgKyB4T2Zmc2V0KTtcbiAgICB0eSA9IF9yb3VuZCh0eSArIHlPcmlnaW4gLSAoeE9yaWdpbiAqIGEyMSArIHlPcmlnaW4gKiBhMjIpICsgeU9mZnNldCk7XG4gIH1cblxuICBpZiAoeFBlcmNlbnQgfHwgeVBlcmNlbnQpIHtcbiAgICAvL1RoZSBTVkcgc3BlYyBkb2Vzbid0IHN1cHBvcnQgcGVyY2VudGFnZS1iYXNlZCB0cmFuc2xhdGlvbiBpbiB0aGUgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUsIHNvIHdlIG1lcmdlIGl0IGludG8gdGhlIHRyYW5zbGF0aW9uIHRvIHNpbXVsYXRlIGl0LlxuICAgIHRlbXAgPSB0YXJnZXQuZ2V0QkJveCgpO1xuICAgIHR4ID0gX3JvdW5kKHR4ICsgeFBlcmNlbnQgLyAxMDAgKiB0ZW1wLndpZHRoKTtcbiAgICB0eSA9IF9yb3VuZCh0eSArIHlQZXJjZW50IC8gMTAwICogdGVtcC5oZWlnaHQpO1xuICB9XG5cbiAgdGVtcCA9IFwibWF0cml4KFwiICsgYTExICsgXCIsXCIgKyBhMjEgKyBcIixcIiArIGExMiArIFwiLFwiICsgYTIyICsgXCIsXCIgKyB0eCArIFwiLFwiICsgdHkgKyBcIilcIjtcbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0ZW1wKTtcbiAgZm9yY2VDU1MgJiYgKHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0ZW1wKTsgLy9zb21lIGJyb3dzZXJzIHByaW9yaXRpemUgQ1NTIHRyYW5zZm9ybXMgb3ZlciB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZS4gV2hlbiB3ZSBzZW5zZSB0aGF0IHRoZSB1c2VyIGhhcyBDU1MgdHJhbnNmb3JtcyBhcHBsaWVkLCB3ZSBtdXN0IG92ZXJ3cml0ZSB0aGVtIHRoaXMgd2F5IChvdGhlcndpc2Ugc29tZSBicm93c2VyIHNpbXBseSB3b24ndCByZW5kZXIgdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUgY2hhbmdlcyEpXG59LFxuICAgIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4ocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBzdGFydE51bSwgZW5kVmFsdWUpIHtcbiAgdmFyIGNhcCA9IDM2MCxcbiAgICAgIGlzU3RyaW5nID0gX2lzU3RyaW5nKGVuZFZhbHVlKSxcbiAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpICogKGlzU3RyaW5nICYmIH5lbmRWYWx1ZS5pbmRleE9mKFwicmFkXCIpID8gX1JBRDJERUcgOiAxKSxcbiAgICAgIGNoYW5nZSA9IGVuZE51bSAtIHN0YXJ0TnVtLFxuICAgICAgZmluYWxWYWx1ZSA9IHN0YXJ0TnVtICsgY2hhbmdlICsgXCJkZWdcIixcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHB0O1xuXG4gIGlmIChpc1N0cmluZykge1xuICAgIGRpcmVjdGlvbiA9IGVuZFZhbHVlLnNwbGl0KFwiX1wiKVsxXTtcblxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwic2hvcnRcIikge1xuICAgICAgY2hhbmdlICU9IGNhcDtcblxuICAgICAgaWYgKGNoYW5nZSAhPT0gY2hhbmdlICUgKGNhcCAvIDIpKSB7XG4gICAgICAgIGNoYW5nZSArPSBjaGFuZ2UgPCAwID8gY2FwIDogLWNhcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uID09PSBcImN3XCIgJiYgY2hhbmdlIDwgMCkge1xuICAgICAgY2hhbmdlID0gKGNoYW5nZSArIGNhcCAqIF9iaWdOdW0pICUgY2FwIC0gfn4oY2hhbmdlIC8gY2FwKSAqIGNhcDtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gXCJjY3dcIiAmJiBjaGFuZ2UgPiAwKSB7XG4gICAgICBjaGFuZ2UgPSAoY2hhbmdlIC0gY2FwICogX2JpZ051bSkgJSBjYXAgLSB+fihjaGFuZ2UgLyBjYXApICogY2FwO1xuICAgIH1cbiAgfVxuXG4gIHBsdWdpbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnROdW0sIGNoYW5nZSwgX3JlbmRlclByb3BXaXRoRW5kKTtcbiAgcHQuZSA9IGZpbmFsVmFsdWU7XG4gIHB0LnUgPSBcImRlZ1wiO1xuXG4gIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfYXNzaWduID0gZnVuY3Rpb24gX2Fzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAvLyBJbnRlcm5ldCBFeHBsb3JlciBkb2Vzbid0IGhhdmUgT2JqZWN0LmFzc2lnbigpLCBzbyB3ZSByZWNyZWF0ZSBpdCBoZXJlLlxuICBmb3IgKHZhciBwIGluIHNvdXJjZSkge1xuICAgIHRhcmdldFtwXSA9IHNvdXJjZVtwXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59LFxuICAgIF9hZGRSYXdUcmFuc2Zvcm1QVHMgPSBmdW5jdGlvbiBfYWRkUmF3VHJhbnNmb3JtUFRzKHBsdWdpbiwgdHJhbnNmb3JtcywgdGFyZ2V0KSB7XG4gIC8vZm9yIGhhbmRsaW5nIGNhc2VzIHdoZXJlIHNvbWVvbmUgcGFzc2VzIGluIGEgd2hvbGUgdHJhbnNmb3JtIHN0cmluZywgbGlrZSB0cmFuc2Zvcm06IFwic2NhbGUoMiwgMykgcm90YXRlKDIwZGVnKSB0cmFuc2xhdGVZKDMwZW0pXCJcbiAgdmFyIHN0YXJ0Q2FjaGUgPSBfYXNzaWduKHt9LCB0YXJnZXQuX2dzYXApLFxuICAgICAgZXhjbHVkZSA9IFwicGVyc3BlY3RpdmUsZm9yY2UzRCx0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luXCIsXG4gICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgIGVuZENhY2hlLFxuICAgICAgcCxcbiAgICAgIHN0YXJ0VmFsdWUsXG4gICAgICBlbmRWYWx1ZSxcbiAgICAgIHN0YXJ0TnVtLFxuICAgICAgZW5kTnVtLFxuICAgICAgc3RhcnRVbml0LFxuICAgICAgZW5kVW5pdDtcblxuICBpZiAoc3RhcnRDYWNoZS5zdmcpIHtcbiAgICBzdGFydFZhbHVlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwiXCIpO1xuICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXM7XG4gICAgZW5kQ2FjaGUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKTtcblxuICAgIF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKTtcblxuICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgc3RhcnRWYWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRWYWx1ZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KVtfdHJhbnNmb3JtUHJvcF07XG4gICAgc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtcztcbiAgICBlbmRDYWNoZSA9IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpO1xuICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHN0YXJ0VmFsdWU7XG4gIH1cblxuICBmb3IgKHAgaW4gX3RyYW5zZm9ybVByb3BzKSB7XG4gICAgc3RhcnRWYWx1ZSA9IHN0YXJ0Q2FjaGVbcF07XG4gICAgZW5kVmFsdWUgPSBlbmRDYWNoZVtwXTtcblxuICAgIGlmIChzdGFydFZhbHVlICE9PSBlbmRWYWx1ZSAmJiBleGNsdWRlLmluZGV4T2YocCkgPCAwKSB7XG4gICAgICAvL3R3ZWVuaW5nIHRvIG5vIHBlcnNwZWN0aXZlIGdpdmVzIHZlcnkgdW5pbnR1aXRpdmUgcmVzdWx0cyAtIGp1c3Qga2VlcCB0aGUgc2FtZSBwZXJzcGVjdGl2ZSBpbiB0aGF0IGNhc2UuXG4gICAgICBzdGFydFVuaXQgPSBnZXRVbml0KHN0YXJ0VmFsdWUpO1xuICAgICAgZW5kVW5pdCA9IGdldFVuaXQoZW5kVmFsdWUpO1xuICAgICAgc3RhcnROdW0gPSBzdGFydFVuaXQgIT09IGVuZFVuaXQgPyBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpIDogcGFyc2VGbG9hdChzdGFydFZhbHVlKTtcbiAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xuICAgICAgcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgZW5kQ2FjaGUsIHAsIHN0YXJ0TnVtLCBlbmROdW0gLSBzdGFydE51bSwgX3JlbmRlckNTU1Byb3ApO1xuICAgICAgcGx1Z2luLl9wdC51ID0gZW5kVW5pdCB8fCAwO1xuXG4gICAgICBwbHVnaW4uX3Byb3BzLnB1c2gocCk7XG4gICAgfVxuICB9XG5cbiAgX2Fzc2lnbihlbmRDYWNoZSwgc3RhcnRDYWNoZSk7XG59OyAvLyBoYW5kbGUgc3BsaXR0aW5nIGFwYXJ0IHBhZGRpbmcsIG1hcmdpbiwgYm9yZGVyV2lkdGgsIGFuZCBib3JkZXJSYWRpdXMgaW50byB0aGVpciA0IGNvbXBvbmVudHMuIEZpcmVmb3gsIGZvciBleGFtcGxlLCB3b24ndCByZXBvcnQgYm9yZGVyUmFkaXVzIGNvcnJlY3RseSAtIGl0IHdpbGwgb25seSBkbyBib3JkZXJUb3BMZWZ0UmFkaXVzIGFuZCB0aGUgb3RoZXIgY29ybmVycy4gV2UgYWxzbyB3YW50IHRvIGhhbmRsZSBwYWRkaW5nVG9wLCBtYXJnaW5MZWZ0LCBib3JkZXJSaWdodFdpZHRoLCBldGMuXG5cblxuX2ZvckVhY2hOYW1lKFwicGFkZGluZyxtYXJnaW4sV2lkdGgsUmFkaXVzXCIsIGZ1bmN0aW9uIChuYW1lLCBpbmRleCkge1xuICB2YXIgdCA9IFwiVG9wXCIsXG4gICAgICByID0gXCJSaWdodFwiLFxuICAgICAgYiA9IFwiQm90dG9tXCIsXG4gICAgICBsID0gXCJMZWZ0XCIsXG4gICAgICBwcm9wcyA9IChpbmRleCA8IDMgPyBbdCwgciwgYiwgbF0gOiBbdCArIGwsIHQgKyByLCBiICsgciwgYiArIGxdKS5tYXAoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gaW5kZXggPCAyID8gbmFtZSArIHNpZGUgOiBcImJvcmRlclwiICsgc2lkZSArIG5hbWU7XG4gIH0pO1xuXG4gIF9zcGVjaWFsUHJvcHNbaW5kZXggPiAxID8gXCJib3JkZXJcIiArIG5hbWUgOiBuYW1lXSA9IGZ1bmN0aW9uIChwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGVuZFZhbHVlLCB0d2Vlbikge1xuICAgIHZhciBhLCB2YXJzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSB7XG4gICAgICAvLyBnZXR0ZXIsIHBhc3NlZCB0YXJnZXQsIHByb3BlcnR5LCBhbmQgdW5pdCAoZnJvbSBfZ2V0KCkpXG4gICAgICBhID0gcHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KHBsdWdpbiwgcHJvcCwgcHJvcGVydHkpO1xuICAgICAgfSk7XG4gICAgICB2YXJzID0gYS5qb2luKFwiIFwiKTtcbiAgICAgIHJldHVybiB2YXJzLnNwbGl0KGFbMF0pLmxlbmd0aCA9PT0gNSA/IGFbMF0gOiB2YXJzO1xuICAgIH1cblxuICAgIGEgPSAoZW5kVmFsdWUgKyBcIlwiKS5zcGxpdChcIiBcIik7XG4gICAgdmFycyA9IHt9O1xuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3AsIGkpIHtcbiAgICAgIHJldHVybiB2YXJzW3Byb3BdID0gYVtpXSA9IGFbaV0gfHwgYVsoaSAtIDEpIC8gMiB8IDBdO1xuICAgIH0pO1xuICAgIHBsdWdpbi5pbml0KHRhcmdldCwgdmFycywgdHdlZW4pO1xuICB9O1xufSk7XG5cbmV4cG9ydCB2YXIgQ1NTUGx1Z2luID0ge1xuICBuYW1lOiBcImNzc1wiLFxuICByZWdpc3RlcjogX2luaXRDb3JlLFxuICB0YXJnZXRUZXN0OiBmdW5jdGlvbiB0YXJnZXRUZXN0KHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQuc3R5bGUgJiYgdGFyZ2V0Lm5vZGVUeXBlO1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5fcHJvcHMsXG4gICAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgICBzdGFydEF0ID0gdHdlZW4udmFycy5zdGFydEF0LFxuICAgICAgICBzdGFydFZhbHVlLFxuICAgICAgICBlbmRWYWx1ZSxcbiAgICAgICAgZW5kTnVtLFxuICAgICAgICBzdGFydE51bSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc3BlY2lhbFByb3AsXG4gICAgICAgIHAsXG4gICAgICAgIHN0YXJ0VW5pdCxcbiAgICAgICAgZW5kVW5pdCxcbiAgICAgICAgcmVsYXRpdmUsXG4gICAgICAgIGlzVHJhbnNmb3JtUmVsYXRlZCxcbiAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuLFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgc21vb3RoLFxuICAgICAgICBoYXNQcmlvcml0eSxcbiAgICAgICAgaW5saW5lUHJvcHM7XG4gICAgX3BsdWdpbkluaXR0ZWQgfHwgX2luaXRDb3JlKCk7IC8vIHdlIG1heSBjYWxsIGluaXQoKSBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSBwbHVnaW4gaW5zdGFuY2UsIGxpa2Ugd2hlbiBhZGRpbmcgc3BlY2lhbCBwcm9wZXJ0aWVzLCBzbyBtYWtlIHN1cmUgd2UgZG9uJ3Qgb3ZlcndyaXRlIHRoZSByZXZlcnQgZGF0YSBvciBpbmxpbmVQcm9wc1xuXG4gICAgdGhpcy5zdHlsZXMgPSB0aGlzLnN0eWxlcyB8fCBfZ2V0U3R5bGVTYXZlcih0YXJnZXQpO1xuICAgIGlubGluZVByb3BzID0gdGhpcy5zdHlsZXMucHJvcHM7XG4gICAgdGhpcy50d2VlbiA9IHR3ZWVuO1xuXG4gICAgZm9yIChwIGluIHZhcnMpIHtcbiAgICAgIGlmIChwID09PSBcImF1dG9Sb3VuZFwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBlbmRWYWx1ZSA9IHZhcnNbcF07XG5cbiAgICAgIGlmIChfcGx1Z2luc1twXSAmJiBfY2hlY2tQbHVnaW4ocCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpKSB7XG4gICAgICAgIC8vIHBsdWdpbnNcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHR5cGUgPSB0eXBlb2YgZW5kVmFsdWU7XG4gICAgICBzcGVjaWFsUHJvcCA9IF9zcGVjaWFsUHJvcHNbcF07XG5cbiAgICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZW5kVmFsdWUgPSBlbmRWYWx1ZS5jYWxsKHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKTtcbiAgICAgICAgdHlwZSA9IHR5cGVvZiBlbmRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgfmVuZFZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG4gICAgICAgIGVuZFZhbHVlID0gX3JlcGxhY2VSYW5kb20oZW5kVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BlY2lhbFByb3ApIHtcbiAgICAgICAgc3BlY2lhbFByb3AodGhpcywgdGFyZ2V0LCBwLCBlbmRWYWx1ZSwgdHdlZW4pICYmIChoYXNQcmlvcml0eSA9IDEpO1xuICAgICAgfSBlbHNlIGlmIChwLnN1YnN0cigwLCAyKSA9PT0gXCItLVwiKSB7XG4gICAgICAgIC8vQ1NTIHZhcmlhYmxlXG4gICAgICAgIHN0YXJ0VmFsdWUgPSAoZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmdldFByb3BlcnR5VmFsdWUocCkgKyBcIlwiKS50cmltKCk7XG4gICAgICAgIGVuZFZhbHVlICs9IFwiXCI7XG4gICAgICAgIF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xuXG4gICAgICAgIGlmICghX2NvbG9yRXhwLnRlc3Qoc3RhcnRWYWx1ZSkpIHtcbiAgICAgICAgICAvLyBjb2xvcnMgZG9uJ3QgaGF2ZSB1bml0c1xuICAgICAgICAgIHN0YXJ0VW5pdCA9IGdldFVuaXQoc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgZW5kVW5pdCA9IGdldFVuaXQoZW5kVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5kVW5pdCA/IHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCAmJiAoc3RhcnRWYWx1ZSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkgKyBlbmRVbml0KSA6IHN0YXJ0VW5pdCAmJiAoZW5kVmFsdWUgKz0gc3RhcnRVbml0KTtcbiAgICAgICAgdGhpcy5hZGQoc3R5bGUsIFwic2V0UHJvcGVydHlcIiwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGluZGV4LCB0YXJnZXRzLCAwLCAwLCBwKTtcbiAgICAgICAgcHJvcHMucHVzaChwKTtcbiAgICAgICAgaW5saW5lUHJvcHMucHVzaChwLCAwLCBzdHlsZVtwXSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHN0YXJ0QXQgJiYgcCBpbiBzdGFydEF0KSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSBzb21lb25lIGhhcmQtY29kZXMgYSBjb21wbGV4IHZhbHVlIGFzIHRoZSBzdGFydCwgbGlrZSB0b3A6IFwiY2FsYygydmggLyAyKVwiLiBXaXRob3V0IHRoaXMsIGl0J2QgdXNlIHRoZSBjb21wdXRlZCB2YWx1ZSAoYWx3YXlzIGluIHB4KVxuICAgICAgICAgIHN0YXJ0VmFsdWUgPSB0eXBlb2Ygc3RhcnRBdFtwXSA9PT0gXCJmdW5jdGlvblwiID8gc3RhcnRBdFtwXS5jYWxsKHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSA6IHN0YXJ0QXRbcF07XG4gICAgICAgICAgX2lzU3RyaW5nKHN0YXJ0VmFsdWUpICYmIH5zdGFydFZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpICYmIChzdGFydFZhbHVlID0gX3JlcGxhY2VSYW5kb20oc3RhcnRWYWx1ZSkpO1xuICAgICAgICAgIGdldFVuaXQoc3RhcnRWYWx1ZSArIFwiXCIpIHx8IHN0YXJ0VmFsdWUgPT09IFwiYXV0b1wiIHx8IChzdGFydFZhbHVlICs9IF9jb25maWcudW5pdHNbcF0gfHwgZ2V0VW5pdChfZ2V0KHRhcmdldCwgcCkpIHx8IFwiXCIpOyAvLyBmb3IgY2FzZXMgd2hlbiBzb21lb25lIHBhc3NlcyBpbiBhIHVuaXRsZXNzIHZhbHVlIGxpa2Uge3g6IDEwMH07IGlmIHdlIHRyeSBzZXR0aW5nIHRyYW5zbGF0ZSgxMDAsIDBweCkgaXQgd29uJ3Qgd29yay5cblxuICAgICAgICAgIChzdGFydFZhbHVlICsgXCJcIikuY2hhckF0KDEpID09PSBcIj1cIiAmJiAoc3RhcnRWYWx1ZSA9IF9nZXQodGFyZ2V0LCBwKSk7IC8vIGNhbid0IHdvcmsgd2l0aCByZWxhdGl2ZSB2YWx1ZXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydFZhbHVlID0gX2dldCh0YXJnZXQsIHApO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpO1xuICAgICAgICByZWxhdGl2ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgJiYgZW5kVmFsdWUuY2hhckF0KDEpID09PSBcIj1cIiAmJiBlbmRWYWx1ZS5zdWJzdHIoMCwgMik7XG4gICAgICAgIHJlbGF0aXZlICYmIChlbmRWYWx1ZSA9IGVuZFZhbHVlLnN1YnN0cigyKSk7XG4gICAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xuXG4gICAgICAgIGlmIChwIGluIF9wcm9wZXJ0eUFsaWFzZXMpIHtcbiAgICAgICAgICBpZiAocCA9PT0gXCJhdXRvQWxwaGFcIikge1xuICAgICAgICAgICAgLy9zcGVjaWFsIGNhc2Ugd2hlcmUgd2UgY29udHJvbCB0aGUgdmlzaWJpbGl0eSBhbG9uZyB3aXRoIG9wYWNpdHkuIFdlIHN0aWxsIGFsbG93IHRoZSBvcGFjaXR5IHZhbHVlIHRvIHBhc3MgdGhyb3VnaCBhbmQgZ2V0IHR3ZWVuZWQuXG4gICAgICAgICAgICBpZiAoc3RhcnROdW0gPT09IDEgJiYgX2dldCh0YXJnZXQsIFwidmlzaWJpbGl0eVwiKSA9PT0gXCJoaWRkZW5cIiAmJiBlbmROdW0pIHtcbiAgICAgICAgICAgICAgLy9pZiB2aXNpYmlsaXR5IGlzIGluaXRpYWxseSBzZXQgdG8gXCJoaWRkZW5cIiwgd2Ugc2hvdWxkIGludGVycHJldCB0aGF0IGFzIGludGVudCB0byBtYWtlIG9wYWNpdHkgMCAoYSBjb252ZW5pZW5jZSlcbiAgICAgICAgICAgICAgc3RhcnROdW0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbmxpbmVQcm9wcy5wdXNoKFwidmlzaWJpbGl0eVwiLCAwLCBzdHlsZS52aXNpYmlsaXR5KTtcblxuICAgICAgICAgICAgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgc3R5bGUsIFwidmlzaWJpbGl0eVwiLCBzdGFydE51bSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIiwgZW5kTnVtID8gXCJpbmhlcml0XCIgOiBcImhpZGRlblwiLCAhZW5kTnVtKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocCAhPT0gXCJzY2FsZVwiICYmIHAgIT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICAgICAgICAgIHAgPSBfcHJvcGVydHlBbGlhc2VzW3BdO1xuICAgICAgICAgICAgfnAuaW5kZXhPZihcIixcIikgJiYgKHAgPSBwLnNwbGl0KFwiLFwiKVswXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaXNUcmFuc2Zvcm1SZWxhdGVkID0gcCBpbiBfdHJhbnNmb3JtUHJvcHM7IC8vLS0tIFRSQU5TRk9STS1SRUxBVEVEIC0tLVxuXG4gICAgICAgIGlmIChpc1RyYW5zZm9ybVJlbGF0ZWQpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlcy5zYXZlKHApO1xuXG4gICAgICAgICAgaWYgKCF0cmFuc2Zvcm1Qcm9wVHdlZW4pIHtcbiAgICAgICAgICAgIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuICAgICAgICAgICAgY2FjaGUucmVuZGVyVHJhbnNmb3JtICYmICF2YXJzLnBhcnNlVHJhbnNmb3JtIHx8IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHZhcnMucGFyc2VUcmFuc2Zvcm0pOyAvLyBpZiwgZm9yIGV4YW1wbGUsIGdzYXAuc2V0KC4uLiB7dHJhbnNmb3JtOlwidHJhbnNsYXRlWCg1MHZ3KVwifSksIHRoZSBfZ2V0KCkgY2FsbCBkb2Vzbid0IHBhcnNlIHRoZSB0cmFuc2Zvcm0sIHRodXMgY2FjaGUucmVuZGVyVHJhbnNmb3JtIHdvbid0IGJlIHNldCB5ZXQgc28gZm9yY2UgdGhlIHBhcnNpbmcgb2YgdGhlIHRyYW5zZm9ybSBoZXJlLlxuXG4gICAgICAgICAgICBzbW9vdGggPSB2YXJzLnNtb290aE9yaWdpbiAhPT0gZmFsc2UgJiYgY2FjaGUuc21vb3RoO1xuICAgICAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuID0gdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBzdHlsZSwgX3RyYW5zZm9ybVByb3AsIDAsIDEsIGNhY2hlLnJlbmRlclRyYW5zZm9ybSwgY2FjaGUsIDAsIC0xKTsgLy90aGUgZmlyc3QgdGltZSB0aHJvdWdoLCBjcmVhdGUgdGhlIHJlbmRlcmluZyBQcm9wVHdlZW4gc28gdGhhdCBpdCBydW5zIExBU1QgKGluIHRoZSBsaW5rZWQgbGlzdCwgd2Uga2VlcCBhZGRpbmcgdG8gdGhlIGJlZ2lubmluZylcblxuICAgICAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuLmRlcCA9IDE7IC8vZmxhZyBpdCBhcyBkZXBlbmRlbnQgc28gdGhhdCBpZiB0aGluZ3MgZ2V0IGtpbGxlZC9vdmVyd3JpdHRlbiBhbmQgdGhpcyBpcyB0aGUgb25seSBQcm9wVHdlZW4gbGVmdCwgd2UgY2FuIHNhZmVseSBraWxsIHRoZSB3aG9sZSB0d2Vlbi5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocCA9PT0gXCJzY2FsZVwiKSB7XG4gICAgICAgICAgICB0aGlzLl9wdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIGNhY2hlLCBcInNjYWxlWVwiLCBjYWNoZS5zY2FsZVksIChyZWxhdGl2ZSA/IF9wYXJzZVJlbGF0aXZlKGNhY2hlLnNjYWxlWSwgcmVsYXRpdmUgKyBlbmROdW0pIDogZW5kTnVtKSAtIGNhY2hlLnNjYWxlWSB8fCAwLCBfcmVuZGVyQ1NTUHJvcCk7XG4gICAgICAgICAgICB0aGlzLl9wdC51ID0gMDtcbiAgICAgICAgICAgIHByb3BzLnB1c2goXCJzY2FsZVlcIiwgcCk7XG4gICAgICAgICAgICBwICs9IFwiWFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIikge1xuICAgICAgICAgICAgaW5saW5lUHJvcHMucHVzaChfdHJhbnNmb3JtT3JpZ2luUHJvcCwgMCwgc3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdKTtcbiAgICAgICAgICAgIGVuZFZhbHVlID0gX2NvbnZlcnRLZXl3b3Jkc1RvUGVyY2VudGFnZXMoZW5kVmFsdWUpOyAvL2luIGNhc2Ugc29tZXRoaW5nIGxpa2UgXCJsZWZ0IHRvcFwiIG9yIFwiYm90dG9tIHJpZ2h0XCIgaXMgcGFzc2VkIGluLiBDb252ZXJ0IHRvIHBlcmNlbnRhZ2VzLlxuXG4gICAgICAgICAgICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgICAgICAgICAgIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIGVuZFZhbHVlLCAwLCBzbW9vdGgsIDAsIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZW5kVW5pdCA9IHBhcnNlRmxvYXQoZW5kVmFsdWUuc3BsaXQoXCIgXCIpWzJdKSB8fCAwOyAvL2hhbmRsZSB0aGUgek9yaWdpbiBzZXBhcmF0ZWx5IVxuXG4gICAgICAgICAgICAgIGVuZFVuaXQgIT09IGNhY2hlLnpPcmlnaW4gJiYgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgY2FjaGUsIFwiek9yaWdpblwiLCBjYWNoZS56T3JpZ2luLCBlbmRVbml0KTtcblxuICAgICAgICAgICAgICBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBzdHlsZSwgcCwgX2ZpcnN0VHdvT25seShzdGFydFZhbHVlKSwgX2ZpcnN0VHdvT25seShlbmRWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwic3ZnT3JpZ2luXCIpIHtcbiAgICAgICAgICAgIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIGVuZFZhbHVlLCAxLCBzbW9vdGgsIDAsIHRoaXMpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgaW4gX3JvdGF0aW9uYWxQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBfYWRkUm90YXRpb25hbFByb3BUd2Vlbih0aGlzLCBjYWNoZSwgcCwgc3RhcnROdW0sIHJlbGF0aXZlID8gX3BhcnNlUmVsYXRpdmUoc3RhcnROdW0sIHJlbGF0aXZlICsgZW5kVmFsdWUpIDogZW5kVmFsdWUpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwic21vb3RoT3JpZ2luXCIpIHtcbiAgICAgICAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIGNhY2hlLCBcInNtb290aFwiLCBjYWNoZS5zbW9vdGgsIGVuZFZhbHVlKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcImZvcmNlM0RcIikge1xuICAgICAgICAgICAgY2FjaGVbcF0gPSBlbmRWYWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgX2FkZFJhd1RyYW5zZm9ybVBUcyh0aGlzLCBlbmRWYWx1ZSwgdGFyZ2V0KTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEocCBpbiBzdHlsZSkpIHtcbiAgICAgICAgICBwID0gX2NoZWNrUHJvcFByZWZpeChwKSB8fCBwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzVHJhbnNmb3JtUmVsYXRlZCB8fCAoZW5kTnVtIHx8IGVuZE51bSA9PT0gMCkgJiYgKHN0YXJ0TnVtIHx8IHN0YXJ0TnVtID09PSAwKSAmJiAhX2NvbXBsZXhFeHAudGVzdChlbmRWYWx1ZSkgJiYgcCBpbiBzdHlsZSkge1xuICAgICAgICAgIHN0YXJ0VW5pdCA9IChzdGFydFZhbHVlICsgXCJcIikuc3Vic3RyKChzdGFydE51bSArIFwiXCIpLmxlbmd0aCk7XG4gICAgICAgICAgZW5kTnVtIHx8IChlbmROdW0gPSAwKTsgLy8gcHJvdGVjdCBhZ2FpbnN0IE5hTlxuXG4gICAgICAgICAgZW5kVW5pdCA9IGdldFVuaXQoZW5kVmFsdWUpIHx8IChwIGluIF9jb25maWcudW5pdHMgPyBfY29uZmlnLnVuaXRzW3BdIDogc3RhcnRVbml0KTtcbiAgICAgICAgICBzdGFydFVuaXQgIT09IGVuZFVuaXQgJiYgKHN0YXJ0TnVtID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwLCBzdGFydFZhbHVlLCBlbmRVbml0KSk7XG4gICAgICAgICAgdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBpc1RyYW5zZm9ybVJlbGF0ZWQgPyBjYWNoZSA6IHN0eWxlLCBwLCBzdGFydE51bSwgKHJlbGF0aXZlID8gX3BhcnNlUmVsYXRpdmUoc3RhcnROdW0sIHJlbGF0aXZlICsgZW5kTnVtKSA6IGVuZE51bSkgLSBzdGFydE51bSwgIWlzVHJhbnNmb3JtUmVsYXRlZCAmJiAoZW5kVW5pdCA9PT0gXCJweFwiIHx8IHAgPT09IFwiekluZGV4XCIpICYmIHZhcnMuYXV0b1JvdW5kICE9PSBmYWxzZSA/IF9yZW5kZXJSb3VuZGVkQ1NTUHJvcCA6IF9yZW5kZXJDU1NQcm9wKTtcbiAgICAgICAgICB0aGlzLl9wdC51ID0gZW5kVW5pdCB8fCAwO1xuXG4gICAgICAgICAgaWYgKHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCAmJiBlbmRVbml0ICE9PSBcIiVcIikge1xuICAgICAgICAgICAgLy93aGVuIHRoZSB0d2VlbiBnb2VzIGFsbCB0aGUgd2F5IGJhY2sgdG8gdGhlIGJlZ2lubmluZywgd2UgbmVlZCB0byByZXZlcnQgaXQgdG8gdGhlIE9MRC9PUklHSU5BTCB2YWx1ZSAod2l0aCB0aG9zZSB1bml0cykuIFdlIHJlY29yZCB0aGF0IGFzIGEgXCJiXCIgKGJlZ2lubmluZykgcHJvcGVydHkgYW5kIHBvaW50IHRvIGEgcmVuZGVyIG1ldGhvZCB0aGF0IGhhbmRsZXMgdGhhdC4gKHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbilcbiAgICAgICAgICAgIHRoaXMuX3B0LmIgPSBzdGFydFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcHQuciA9IF9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIShwIGluIHN0eWxlKSkge1xuICAgICAgICAgIGlmIChwIGluIHRhcmdldCkge1xuICAgICAgICAgICAgLy9tYXliZSBpdCdzIG5vdCBhIHN0eWxlIC0gaXQgY291bGQgYmUgYSBwcm9wZXJ0eSBhZGRlZCBkaXJlY3RseSB0byBhbiBlbGVtZW50IGluIHdoaWNoIGNhc2Ugd2UnbGwgdHJ5IHRvIGFuaW1hdGUgdGhhdC5cbiAgICAgICAgICAgIHRoaXMuYWRkKHRhcmdldCwgcCwgc3RhcnRWYWx1ZSB8fCB0YXJnZXRbcF0sIHJlbGF0aXZlID8gcmVsYXRpdmUgKyBlbmRWYWx1ZSA6IGVuZFZhbHVlLCBpbmRleCwgdGFyZ2V0cyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwICE9PSBcInBhcnNlVHJhbnNmb3JtXCIpIHtcbiAgICAgICAgICAgIF9taXNzaW5nUGx1Z2luKHAsIGVuZFZhbHVlKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcuY2FsbCh0aGlzLCB0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIHJlbGF0aXZlID8gcmVsYXRpdmUgKyBlbmRWYWx1ZSA6IGVuZFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzVHJhbnNmb3JtUmVsYXRlZCB8fCAocCBpbiBzdHlsZSA/IGlubGluZVByb3BzLnB1c2gocCwgMCwgc3R5bGVbcF0pIDogaW5saW5lUHJvcHMucHVzaChwLCAxLCBzdGFydFZhbHVlIHx8IHRhcmdldFtwXSkpO1xuICAgICAgICBwcm9wcy5wdXNoKHApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhc1ByaW9yaXR5ICYmIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkodGhpcyk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHJhdGlvLCBkYXRhKSB7XG4gICAgaWYgKGRhdGEudHdlZW4uX3RpbWUgfHwgIV9yZXZlcnRpbmcoKSkge1xuICAgICAgdmFyIHB0ID0gZGF0YS5fcHQ7XG5cbiAgICAgIHdoaWxlIChwdCkge1xuICAgICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5zdHlsZXMucmV2ZXJ0KCk7XG4gICAgfVxuICB9LFxuICBnZXQ6IF9nZXQsXG4gIGFsaWFzZXM6IF9wcm9wZXJ0eUFsaWFzZXMsXG4gIGdldFNldHRlcjogZnVuY3Rpb24gZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHksIHBsdWdpbikge1xuICAgIC8vcmV0dXJucyBhIHNldHRlciBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUgYW5kIGFwcGxpZXMgaXQgYWNjb3JkaW5nbHkuIFJlbWVtYmVyLCBwcm9wZXJ0aWVzIGxpa2UgXCJ4XCIgYXJlbid0IGFzIHNpbXBsZSBhcyB0YXJnZXQuc3R5bGUucHJvcGVydHkgPSB2YWx1ZSBiZWNhdXNlIHRoZXkndmUgZ290IHRvIGJlIGFwcGxpZWQgdG8gYSBwcm94eSBvYmplY3QgYW5kIHRoZW4gbWVyZ2VkIGludG8gYSB0cmFuc2Zvcm0gc3RyaW5nIGluIGEgcmVuZGVyZXIuXG4gICAgdmFyIHAgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XTtcbiAgICBwICYmIHAuaW5kZXhPZihcIixcIikgPCAwICYmIChwcm9wZXJ0eSA9IHApO1xuICAgIHJldHVybiBwcm9wZXJ0eSBpbiBfdHJhbnNmb3JtUHJvcHMgJiYgcHJvcGVydHkgIT09IF90cmFuc2Zvcm1PcmlnaW5Qcm9wICYmICh0YXJnZXQuX2dzYXAueCB8fCBfZ2V0KHRhcmdldCwgXCJ4XCIpKSA/IHBsdWdpbiAmJiBfcmVjZW50U2V0dGVyUGx1Z2luID09PSBwbHVnaW4gPyBwcm9wZXJ0eSA9PT0gXCJzY2FsZVwiID8gX3NldHRlclNjYWxlIDogX3NldHRlclRyYW5zZm9ybSA6IChfcmVjZW50U2V0dGVyUGx1Z2luID0gcGx1Z2luIHx8IHt9KSAmJiAocHJvcGVydHkgPT09IFwic2NhbGVcIiA/IF9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIgOiBfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlcikgOiB0YXJnZXQuc3R5bGUgJiYgIV9pc1VuZGVmaW5lZCh0YXJnZXQuc3R5bGVbcHJvcGVydHldKSA/IF9zZXR0ZXJDU1NTdHlsZSA6IH5wcm9wZXJ0eS5pbmRleE9mKFwiLVwiKSA/IF9zZXR0ZXJDU1NQcm9wIDogX2dldFNldHRlcih0YXJnZXQsIHByb3BlcnR5KTtcbiAgfSxcbiAgY29yZToge1xuICAgIF9yZW1vdmVQcm9wZXJ0eTogX3JlbW92ZVByb3BlcnR5LFxuICAgIF9nZXRNYXRyaXg6IF9nZXRNYXRyaXhcbiAgfVxufTtcbmdzYXAudXRpbHMuY2hlY2tQcmVmaXggPSBfY2hlY2tQcm9wUHJlZml4O1xuZ3NhcC5jb3JlLmdldFN0eWxlU2F2ZXIgPSBfZ2V0U3R5bGVTYXZlcjtcblxuKGZ1bmN0aW9uIChwb3NpdGlvbkFuZFNjYWxlLCByb3RhdGlvbiwgb3RoZXJzLCBhbGlhc2VzKSB7XG4gIHZhciBhbGwgPSBfZm9yRWFjaE5hbWUocG9zaXRpb25BbmRTY2FsZSArIFwiLFwiICsgcm90YXRpb24gKyBcIixcIiArIG90aGVycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBfdHJhbnNmb3JtUHJvcHNbbmFtZV0gPSAxO1xuICB9KTtcblxuICBfZm9yRWFjaE5hbWUocm90YXRpb24sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgX2NvbmZpZy51bml0c1tuYW1lXSA9IFwiZGVnXCI7XG4gICAgX3JvdGF0aW9uYWxQcm9wZXJ0aWVzW25hbWVdID0gMTtcbiAgfSk7XG5cbiAgX3Byb3BlcnR5QWxpYXNlc1thbGxbMTNdXSA9IHBvc2l0aW9uQW5kU2NhbGUgKyBcIixcIiArIHJvdGF0aW9uO1xuXG4gIF9mb3JFYWNoTmFtZShhbGlhc2VzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzcGxpdCA9IG5hbWUuc3BsaXQoXCI6XCIpO1xuICAgIF9wcm9wZXJ0eUFsaWFzZXNbc3BsaXRbMV1dID0gYWxsW3NwbGl0WzBdXTtcbiAgfSk7XG59KShcIngseSx6LHNjYWxlLHNjYWxlWCxzY2FsZVkseFBlcmNlbnQseVBlcmNlbnRcIiwgXCJyb3RhdGlvbixyb3RhdGlvblgscm90YXRpb25ZLHNrZXdYLHNrZXdZXCIsIFwidHJhbnNmb3JtLHRyYW5zZm9ybU9yaWdpbixzdmdPcmlnaW4sZm9yY2UzRCxzbW9vdGhPcmlnaW4sdHJhbnNmb3JtUGVyc3BlY3RpdmVcIiwgXCIwOnRyYW5zbGF0ZVgsMTp0cmFuc2xhdGVZLDI6dHJhbnNsYXRlWiw4OnJvdGF0ZSw4OnJvdGF0aW9uWiw4OnJvdGF0ZVosOTpyb3RhdGVYLDEwOnJvdGF0ZVlcIik7XG5cbl9mb3JFYWNoTmFtZShcIngseSx6LHRvcCxyaWdodCxib3R0b20sbGVmdCx3aWR0aCxoZWlnaHQsZm9udFNpemUscGFkZGluZyxtYXJnaW4scGVyc3BlY3RpdmVcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgX2NvbmZpZy51bml0c1tuYW1lXSA9IFwicHhcIjtcbn0pO1xuXG5nc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1BsdWdpbik7XG5leHBvcnQgeyBDU1NQbHVnaW4gYXMgZGVmYXVsdCwgX2dldEJCb3gsIF9jcmVhdGVFbGVtZW50LCBfY2hlY2tQcm9wUHJlZml4IGFzIGNoZWNrUHJlZml4IH07Il0sIm5hbWVzIjpbImdzYXAiLCJfZ2V0UHJvcGVydHkiLCJfbnVtRXhwIiwiX251bVdpdGhVbml0RXhwIiwiZ2V0VW5pdCIsIl9pc1N0cmluZyIsIl9pc1VuZGVmaW5lZCIsIl9yZW5kZXJDb21wbGV4U3RyaW5nIiwiX3JlbEV4cCIsIl9mb3JFYWNoTmFtZSIsIl9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkiLCJfY29sb3JTdHJpbmdGaWx0ZXIiLCJfY2hlY2tQbHVnaW4iLCJfcmVwbGFjZVJhbmRvbSIsIl9wbHVnaW5zIiwiR1NDYWNoZSIsIlByb3BUd2VlbiIsIl9jb25maWciLCJfdGlja2VyIiwiX3JvdW5kIiwiX21pc3NpbmdQbHVnaW4iLCJfZ2V0U2V0dGVyIiwiX2dldENhY2hlIiwiX2NvbG9yRXhwIiwiX3BhcnNlUmVsYXRpdmUiLCJfc2V0RGVmYXVsdHMiLCJfcmVtb3ZlTGlua2VkTGlzdEl0ZW0iLCJfd2luIiwiX2RvYyIsIl9kb2NFbGVtZW50IiwiX3BsdWdpbkluaXR0ZWQiLCJfdGVtcERpdiIsIl90ZW1wRGl2U3R5bGVyIiwiX3JlY2VudFNldHRlclBsdWdpbiIsIl9yZXZlcnRpbmciLCJfd2luZG93RXhpc3RzIiwid2luZG93IiwiX3RyYW5zZm9ybVByb3BzIiwiX1JBRDJERUciLCJNYXRoIiwiUEkiLCJfREVHMlJBRCIsIl9hdGFuMiIsImF0YW4yIiwiX2JpZ051bSIsIl9jYXBzRXhwIiwiX2hvcml6b250YWxFeHAiLCJfY29tcGxleEV4cCIsIl9wcm9wZXJ0eUFsaWFzZXMiLCJhdXRvQWxwaGEiLCJzY2FsZSIsImFscGhhIiwiX3JlbmRlckNTU1Byb3AiLCJyYXRpbyIsImRhdGEiLCJzZXQiLCJ0IiwicCIsInJvdW5kIiwicyIsImMiLCJ1IiwiX3JlbmRlclByb3BXaXRoRW5kIiwiZSIsIl9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZyIsImIiLCJfcmVuZGVyUm91bmRlZENTU1Byb3AiLCJ2YWx1ZSIsIl9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlIiwiX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQiLCJfc2V0dGVyQ1NTU3R5bGUiLCJ0YXJnZXQiLCJwcm9wZXJ0eSIsInN0eWxlIiwiX3NldHRlckNTU1Byb3AiLCJzZXRQcm9wZXJ0eSIsIl9zZXR0ZXJUcmFuc2Zvcm0iLCJfZ3NhcCIsIl9zZXR0ZXJTY2FsZSIsInNjYWxlWCIsInNjYWxlWSIsIl9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIiLCJjYWNoZSIsInJlbmRlclRyYW5zZm9ybSIsIl9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyIiwiX3RyYW5zZm9ybVByb3AiLCJfdHJhbnNmb3JtT3JpZ2luUHJvcCIsIl9zYXZlU3R5bGUiLCJpc05vdENTUyIsIl90aGlzIiwidGZtIiwiaW5kZXhPZiIsInNwbGl0IiwiZm9yRWFjaCIsImEiLCJfZ2V0IiwieCIsInpPcmlnaW4iLCJ0cmFuc2Zvcm0iLCJjYWxsIiwicHJvcHMiLCJzdmciLCJzdmdvIiwiZ2V0QXR0cmlidXRlIiwicHVzaCIsIl9yZW1vdmVJbmRlcGVuZGVudFRyYW5zZm9ybXMiLCJ0cmFuc2xhdGUiLCJyZW1vdmVQcm9wZXJ0eSIsIl9yZXZlcnRTdHlsZSIsImkiLCJsZW5ndGgiLCJzdWJzdHIiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJzZXRBdHRyaWJ1dGUiLCJpc1N0YXJ0IiwidW5jYWNoZSIsIl9nZXRTdHlsZVNhdmVyIiwicHJvcGVydGllcyIsInNhdmVyIiwicmV2ZXJ0Iiwic2F2ZSIsImNvcmUiLCJnZXRDYWNoZSIsIl9zdXBwb3J0czNEIiwiX2NyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwibnMiLCJjcmVhdGVFbGVtZW50TlMiLCJjcmVhdGVFbGVtZW50IiwiX2dldENvbXB1dGVkUHJvcGVydHkiLCJza2lwUHJlZml4RmFsbGJhY2siLCJjcyIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiX2NoZWNrUHJvcFByZWZpeCIsIl9wcmVmaXhlcyIsImVsZW1lbnQiLCJwcmVmZXJQcmVmaXgiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsIl9pbml0Q29yZSIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY3NzVGV4dCIsInJldmVydGluZyIsIl9nZXRCQm94SGFjayIsInN3YXBJZlBvc3NpYmxlIiwib3duZXJTVkdFbGVtZW50Iiwib2xkUGFyZW50IiwicGFyZW50Tm9kZSIsIm9sZFNpYmxpbmciLCJuZXh0U2libGluZyIsIm9sZENTUyIsImJib3giLCJhcHBlbmRDaGlsZCIsImRpc3BsYXkiLCJnZXRCQm94IiwiX2dzYXBCQm94IiwiaW5zZXJ0QmVmb3JlIiwicmVtb3ZlQ2hpbGQiLCJfZ2V0QXR0cmlidXRlRmFsbGJhY2tzIiwiYXR0cmlidXRlc0FycmF5IiwiaGFzQXR0cmlidXRlIiwiX2dldEJCb3giLCJib3VuZHMiLCJlcnJvciIsIndpZHRoIiwiaGVpZ2h0IiwieSIsIl9pc1NWRyIsImdldENUTSIsIl9yZW1vdmVQcm9wZXJ0eSIsImZpcnN0MkNoYXJzIiwicmVtb3ZlQXR0cmlidXRlIiwiX2FkZE5vblR3ZWVuaW5nUFQiLCJwbHVnaW4iLCJiZWdpbm5pbmciLCJlbmQiLCJvbmx5U2V0QXRFbmQiLCJwdCIsIl9wdCIsIl9wcm9wcyIsIl9ub25Db252ZXJ0aWJsZVVuaXRzIiwiZGVnIiwicmFkIiwidHVybiIsIl9ub25TdGFuZGFyZExheW91dHMiLCJncmlkIiwiZmxleCIsIl9jb252ZXJ0VG9Vbml0IiwidW5pdCIsImN1clZhbHVlIiwicGFyc2VGbG9hdCIsImN1clVuaXQiLCJ0cmltIiwiaG9yaXpvbnRhbCIsInRlc3QiLCJpc1Jvb3RTVkciLCJ0YWdOYW1lIiwibWVhc3VyZVByb3BlcnR5IiwiYW1vdW50IiwidG9QaXhlbHMiLCJ0b1BlcmNlbnQiLCJweCIsInBhcmVudCIsImlzU1ZHIiwiYm9keSIsInRpbWUiLCJ2IiwicG9zaXRpb24iLCJfcGFyc2VUcmFuc2Zvcm0iLCJvcmlnaW4iLCJfZmlyc3RUd29Pbmx5IiwiX3NwZWNpYWxQcm9wcyIsIl90d2VlbkNvbXBsZXhDU1NTdHJpbmciLCJwcm9wIiwic3RhcnQiLCJpbmRleCIsIm1hdGNoSW5kZXgiLCJyZXN1bHQiLCJzdGFydFZhbHVlcyIsInN0YXJ0TnVtIiwiY29sb3IiLCJzdGFydFZhbHVlIiwiZW5kVmFsdWUiLCJlbmROdW0iLCJjaHVuayIsImVuZFVuaXQiLCJzdGFydFVuaXQiLCJlbmRWYWx1ZXMiLCJtYXRjaCIsImV4ZWMiLCJzdWJzdHJpbmciLCJsYXN0SW5kZXgiLCJ1bml0cyIsIl9uZXh0IiwibSIsInIiLCJfa2V5d29yZFRvUGVyY2VudCIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsImNlbnRlciIsIl9jb252ZXJ0S2V5d29yZHNUb1BlcmNlbnRhZ2VzIiwiam9pbiIsIl9yZW5kZXJDbGVhclByb3BzIiwidHdlZW4iLCJfdGltZSIsIl9kdXIiLCJjbGVhclRyYW5zZm9ybXMiLCJjbGVhclByb3BzIiwicHIiLCJfaWRlbnRpdHkyRE1hdHJpeCIsIl9yb3RhdGlvbmFsUHJvcGVydGllcyIsIl9pc051bGxUcmFuc2Zvcm0iLCJfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5IiwibWF0cml4U3RyaW5nIiwibWFwIiwiX2dldE1hdHJpeCIsImZvcmNlMkQiLCJtYXRyaXgiLCJ0ZW1wIiwiYWRkZWRUb0RPTSIsImJhc2VWYWwiLCJjb25zb2xpZGF0ZSIsImQiLCJmIiwib2Zmc2V0UGFyZW50IiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiX2FwcGx5U1ZHT3JpZ2luIiwib3JpZ2luSXNBYnNvbHV0ZSIsInNtb290aCIsIm1hdHJpeEFycmF5IiwicGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8iLCJ4T3JpZ2luT2xkIiwieE9yaWdpbiIsInlPcmlnaW5PbGQiLCJ5T3JpZ2luIiwieE9mZnNldE9sZCIsInhPZmZzZXQiLCJ5T2Zmc2V0T2xkIiwieU9mZnNldCIsInR4IiwidHkiLCJvcmlnaW5TcGxpdCIsImRldGVybWluYW50IiwiaW52ZXJ0ZWRTY2FsZVgiLCJ6Iiwicm90YXRpb24iLCJyb3RhdGlvblgiLCJyb3RhdGlvblkiLCJza2V3WCIsInNrZXdZIiwicGVyc3BlY3RpdmUiLCJhbmdsZSIsImNvcyIsInNpbiIsImExMiIsImEyMiIsInQxIiwidDIiLCJ0MyIsImExMyIsImEyMyIsImEzMyIsImE0MiIsImE0MyIsImEzMiIsInJvdGF0ZSIsInNsaWNlIiwic3FydCIsImFicyIsImZvcmNlQ1NTIiwieFBlcmNlbnQiLCJvZmZzZXRXaWR0aCIsInlQZXJjZW50Iiwib2Zmc2V0SGVpZ2h0IiwidHJhbnNmb3JtUGVyc3BlY3RpdmUiLCJmb3JjZTNEIiwiX3JlbmRlclNWR1RyYW5zZm9ybXMiLCJfcmVuZGVyQ1NTVHJhbnNmb3JtcyIsIl9yZW5kZXJOb24zRFRyYW5zZm9ybXMiLCJfYWRkUHhUcmFuc2xhdGUiLCJfemVyb0RlZyIsIl96ZXJvUHgiLCJfZW5kUGFyZW50aGVzaXMiLCJfcmVmIiwidHJhbnNmb3JtcyIsInVzZTNEIiwiX3JlZjIiLCJhMTEiLCJhMjEiLCJ0YW4iLCJfYWRkUm90YXRpb25hbFByb3BUd2VlbiIsImNhcCIsImlzU3RyaW5nIiwiY2hhbmdlIiwiZmluYWxWYWx1ZSIsImRpcmVjdGlvbiIsIl9hc3NpZ24iLCJzb3VyY2UiLCJfYWRkUmF3VHJhbnNmb3JtUFRzIiwic3RhcnRDYWNoZSIsImV4Y2x1ZGUiLCJlbmRDYWNoZSIsIm5hbWUiLCJsIiwic2lkZSIsInZhcnMiLCJhcmd1bWVudHMiLCJpbml0IiwiQ1NTUGx1Z2luIiwicmVnaXN0ZXIiLCJ0YXJnZXRUZXN0Iiwibm9kZVR5cGUiLCJ0YXJnZXRzIiwic3RhcnRBdCIsInNwZWNpYWxQcm9wIiwicmVsYXRpdmUiLCJpc1RyYW5zZm9ybVJlbGF0ZWQiLCJ0cmFuc2Zvcm1Qcm9wVHdlZW4iLCJoYXNQcmlvcml0eSIsImlubGluZVByb3BzIiwic3R5bGVzIiwiYWRkIiwidmlzaWJpbGl0eSIsInBhcnNlVHJhbnNmb3JtIiwic21vb3RoT3JpZ2luIiwiZGVwIiwiYXV0b1JvdW5kIiwicmVuZGVyIiwiZ2V0IiwiYWxpYXNlcyIsImdldFNldHRlciIsInV0aWxzIiwiY2hlY2tQcmVmaXgiLCJnZXRTdHlsZVNhdmVyIiwicG9zaXRpb25BbmRTY2FsZSIsIm90aGVycyIsImFsbCIsInJlZ2lzdGVyUGx1Z2luIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSRulePlugin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSRulePlugin.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CSSRulePlugin: function() { return /* binding */ CSSRulePlugin; },\n/* harmony export */   \"default\": function() { return /* binding */ CSSRulePlugin; }\n/* harmony export */ });\n/*!\n * CSSRulePlugin 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var gsap, _coreInitted, _win, _doc, CSSPlugin, _windowExists = function _windowExists() {\n    return typeof window !== \"undefined\";\n}, _getGSAP = function _getGSAP() {\n    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _checkRegister = function _checkRegister() {\n    if (!_coreInitted) {\n        _initCore();\n        if (!CSSPlugin) {\n            console.warn(\"Please gsap.registerPlugin(CSSPlugin, CSSRulePlugin)\");\n        }\n    }\n    return _coreInitted;\n}, _initCore = function _initCore(core) {\n    gsap = core || _getGSAP();\n    if (_windowExists()) {\n        _win = window;\n        _doc = document;\n    }\n    if (gsap) {\n        CSSPlugin = gsap.plugins.css;\n        if (CSSPlugin) {\n            _coreInitted = 1;\n        }\n    }\n};\nvar CSSRulePlugin = {\n    version: \"3.12.5\",\n    name: \"cssRule\",\n    init: function init(target, value, tween, index, targets) {\n        if (!_checkRegister() || typeof target.cssText === \"undefined\") {\n            return false;\n        }\n        var div = target._gsProxy = target._gsProxy || _doc.createElement(\"div\");\n        this.ss = target;\n        this.style = div.style;\n        div.style.cssText = target.cssText;\n        CSSPlugin.prototype.init.call(this, div, value, tween, index, targets); //we just offload all the work to the regular CSSPlugin and then copy the cssText back over to the rule in the render() method. This allows us to have all of the updates to CSSPlugin automatically flow through to CSSRulePlugin instead of having to maintain both\n    },\n    render: function render(ratio, data) {\n        var pt = data._pt, style = data.style, ss = data.ss, i;\n        while(pt){\n            pt.r(ratio, pt.d);\n            pt = pt._next;\n        }\n        i = style.length;\n        while(--i > -1){\n            ss[style[i]] = style[style[i]];\n        }\n    },\n    getRule: function getRule(selector) {\n        _checkRegister();\n        var ruleProp = _doc.all ? \"rules\" : \"cssRules\", styleSheets = _doc.styleSheets, i = styleSheets.length, pseudo = selector.charAt(0) === \":\", j, curSS, cs, a;\n        selector = (pseudo ? \"\" : \",\") + selector.split(\"::\").join(\":\").toLowerCase() + \",\"; //note: old versions of IE report tag name selectors as upper case, so we just change everything to lowercase.\n        if (pseudo) {\n            a = [];\n        }\n        while(i--){\n            //Firefox may throw insecure operation errors when css is loaded from other domains, so try/catch.\n            try {\n                curSS = styleSheets[i][ruleProp];\n                if (!curSS) {\n                    continue;\n                }\n                j = curSS.length;\n            } catch (e) {\n                console.warn(e);\n                continue;\n            }\n            while(--j > -1){\n                cs = curSS[j];\n                if (cs.selectorText && (\",\" + cs.selectorText.split(\"::\").join(\":\").toLowerCase() + \",\").indexOf(selector) !== -1) {\n                    //note: IE adds an extra \":\" to pseudo selectors, so .myClass:after becomes .myClass::after, so we need to strip the extra one out.\n                    if (pseudo) {\n                        a.push(cs.style);\n                    } else {\n                        return cs.style;\n                    }\n                }\n            }\n        }\n        return a;\n    },\n    register: _initCore\n};\n_getGSAP() && gsap.registerPlugin(CSSRulePlugin);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9DU1NSdWxlUGx1Z2luLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7O0FBUUEsR0FFQSxrQkFBa0IsR0FDbEIsSUFBSUEsTUFDQUMsY0FDQUMsTUFDQUMsTUFDQUMsV0FDQUMsZ0JBQWdCLFNBQVNBO0lBQzNCLE9BQU8sT0FBT0MsV0FBVztBQUMzQixHQUNJQyxXQUFXLFNBQVNBO0lBQ3RCLE9BQU9QLFFBQVFLLG1CQUFvQkwsQ0FBQUEsT0FBT00sT0FBT04sSUFBSSxLQUFLQSxLQUFLUSxjQUFjLElBQUlSO0FBQ25GLEdBQ0lTLGlCQUFpQixTQUFTQTtJQUM1QixJQUFJLENBQUNSLGNBQWM7UUFDakJTO1FBRUEsSUFBSSxDQUFDTixXQUFXO1lBQ2RPLFFBQVFDLElBQUksQ0FBQztRQUNmO0lBQ0Y7SUFFQSxPQUFPWDtBQUNULEdBQ0lTLFlBQVksU0FBU0EsVUFBVUcsSUFBSTtJQUNyQ2IsT0FBT2EsUUFBUU47SUFFZixJQUFJRixpQkFBaUI7UUFDbkJILE9BQU9JO1FBQ1BILE9BQU9XO0lBQ1Q7SUFFQSxJQUFJZCxNQUFNO1FBQ1JJLFlBQVlKLEtBQUtlLE9BQU8sQ0FBQ0MsR0FBRztRQUU1QixJQUFJWixXQUFXO1lBQ2JILGVBQWU7UUFDakI7SUFDRjtBQUNGO0FBRU8sSUFBSWdCLGdCQUFnQjtJQUN6QkMsU0FBUztJQUNUQyxNQUFNO0lBQ05DLE1BQU0sU0FBU0EsS0FBS0MsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxPQUFPO1FBQ3RELElBQUksQ0FBQ2hCLG9CQUFvQixPQUFPWSxPQUFPSyxPQUFPLEtBQUssYUFBYTtZQUM5RCxPQUFPO1FBQ1Q7UUFFQSxJQUFJQyxNQUFNTixPQUFPTyxRQUFRLEdBQUdQLE9BQU9PLFFBQVEsSUFBSXpCLEtBQUswQixhQUFhLENBQUM7UUFFbEUsSUFBSSxDQUFDQyxFQUFFLEdBQUdUO1FBQ1YsSUFBSSxDQUFDVSxLQUFLLEdBQUdKLElBQUlJLEtBQUs7UUFDdEJKLElBQUlJLEtBQUssQ0FBQ0wsT0FBTyxHQUFHTCxPQUFPSyxPQUFPO1FBQ2xDdEIsVUFBVTRCLFNBQVMsQ0FBQ1osSUFBSSxDQUFDYSxJQUFJLENBQUMsSUFBSSxFQUFFTixLQUFLTCxPQUFPQyxPQUFPQyxPQUFPQyxVQUFVLHFRQUFxUTtJQUMvVTtJQUNBUyxRQUFRLFNBQVNBLE9BQU9DLEtBQUssRUFBRUMsSUFBSTtRQUNqQyxJQUFJQyxLQUFLRCxLQUFLRSxHQUFHLEVBQ2JQLFFBQVFLLEtBQUtMLEtBQUssRUFDbEJELEtBQUtNLEtBQUtOLEVBQUUsRUFDWlM7UUFFSixNQUFPRixHQUFJO1lBQ1RBLEdBQUdHLENBQUMsQ0FBQ0wsT0FBT0UsR0FBR0ksQ0FBQztZQUNoQkosS0FBS0EsR0FBR0ssS0FBSztRQUNmO1FBRUFILElBQUlSLE1BQU1ZLE1BQU07UUFFaEIsTUFBTyxFQUFFSixJQUFJLENBQUMsRUFBRztZQUNmVCxFQUFFLENBQUNDLEtBQUssQ0FBQ1EsRUFBRSxDQUFDLEdBQUdSLEtBQUssQ0FBQ0EsS0FBSyxDQUFDUSxFQUFFLENBQUM7UUFDaEM7SUFDRjtJQUNBSyxTQUFTLFNBQVNBLFFBQVFDLFFBQVE7UUFDaENwQztRQUVBLElBQUlxQyxXQUFXM0MsS0FBSzRDLEdBQUcsR0FBRyxVQUFVLFlBQ2hDQyxjQUFjN0MsS0FBSzZDLFdBQVcsRUFDOUJULElBQUlTLFlBQVlMLE1BQU0sRUFDdEJNLFNBQVNKLFNBQVNLLE1BQU0sQ0FBQyxPQUFPLEtBQ2hDQyxHQUNBQyxPQUNBQyxJQUNBQztRQUNKVCxXQUFXLENBQUNJLFNBQVMsS0FBSyxHQUFFLElBQUtKLFNBQVNVLEtBQUssQ0FBQyxNQUFNQyxJQUFJLENBQUMsS0FBS0MsV0FBVyxLQUFLLEtBQUssOEdBQThHO1FBRW5NLElBQUlSLFFBQVE7WUFDVkssSUFBSSxFQUFFO1FBQ1I7UUFFQSxNQUFPZixJQUFLO1lBQ1Ysa0dBQWtHO1lBQ2xHLElBQUk7Z0JBQ0ZhLFFBQVFKLFdBQVcsQ0FBQ1QsRUFBRSxDQUFDTyxTQUFTO2dCQUVoQyxJQUFJLENBQUNNLE9BQU87b0JBQ1Y7Z0JBQ0Y7Z0JBRUFELElBQUlDLE1BQU1ULE1BQU07WUFDbEIsRUFBRSxPQUFPZSxHQUFHO2dCQUNWL0MsUUFBUUMsSUFBSSxDQUFDOEM7Z0JBQ2I7WUFDRjtZQUVBLE1BQU8sRUFBRVAsSUFBSSxDQUFDLEVBQUc7Z0JBQ2ZFLEtBQUtELEtBQUssQ0FBQ0QsRUFBRTtnQkFFYixJQUFJRSxHQUFHTSxZQUFZLElBQUksQ0FBQyxNQUFNTixHQUFHTSxZQUFZLENBQUNKLEtBQUssQ0FBQyxNQUFNQyxJQUFJLENBQUMsS0FBS0MsV0FBVyxLQUFLLEdBQUUsRUFBR0csT0FBTyxDQUFDZixjQUFjLENBQUMsR0FBRztvQkFDakgsbUlBQW1JO29CQUNuSSxJQUFJSSxRQUFRO3dCQUNWSyxFQUFFTyxJQUFJLENBQUNSLEdBQUd0QixLQUFLO29CQUNqQixPQUFPO3dCQUNMLE9BQU9zQixHQUFHdEIsS0FBSztvQkFDakI7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsT0FBT3VCO0lBQ1Q7SUFDQVEsVUFBVXBEO0FBQ1osRUFBRTtBQUNGSCxjQUFjUCxLQUFLUSxjQUFjLENBQUNTO0FBQ0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dzYXBAMy4xMi41L25vZGVfbW9kdWxlcy9nc2FwL0NTU1J1bGVQbHVnaW4uanM/ZDNhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENTU1J1bGVQbHVnaW4gMy4xMi41XG4gKiBodHRwczovL2dzYXAuY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyNCwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9nc2FwLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHU0FQIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIGdzYXAsXG4gICAgX2NvcmVJbml0dGVkLFxuICAgIF93aW4sXG4gICAgX2RvYyxcbiAgICBDU1NQbHVnaW4sXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCBfd2luZG93RXhpc3RzKCkgJiYgKGdzYXAgPSB3aW5kb3cuZ3NhcCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbiAmJiBnc2FwO1xufSxcbiAgICBfY2hlY2tSZWdpc3RlciA9IGZ1bmN0aW9uIF9jaGVja1JlZ2lzdGVyKCkge1xuICBpZiAoIV9jb3JlSW5pdHRlZCkge1xuICAgIF9pbml0Q29yZSgpO1xuXG4gICAgaWYgKCFDU1NQbHVnaW4pIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlBsZWFzZSBnc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1BsdWdpbiwgQ1NTUnVsZVBsdWdpbilcIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9jb3JlSW5pdHRlZDtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKGNvcmUpIHtcbiAgZ3NhcCA9IGNvcmUgfHwgX2dldEdTQVAoKTtcblxuICBpZiAoX3dpbmRvd0V4aXN0cygpKSB7XG4gICAgX3dpbiA9IHdpbmRvdztcbiAgICBfZG9jID0gZG9jdW1lbnQ7XG4gIH1cblxuICBpZiAoZ3NhcCkge1xuICAgIENTU1BsdWdpbiA9IGdzYXAucGx1Z2lucy5jc3M7XG5cbiAgICBpZiAoQ1NTUGx1Z2luKSB7XG4gICAgICBfY29yZUluaXR0ZWQgPSAxO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IHZhciBDU1NSdWxlUGx1Z2luID0ge1xuICB2ZXJzaW9uOiBcIjMuMTIuNVwiLFxuICBuYW1lOiBcImNzc1J1bGVcIixcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhbHVlLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcbiAgICBpZiAoIV9jaGVja1JlZ2lzdGVyKCkgfHwgdHlwZW9mIHRhcmdldC5jc3NUZXh0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGRpdiA9IHRhcmdldC5fZ3NQcm94eSA9IHRhcmdldC5fZ3NQcm94eSB8fCBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICB0aGlzLnNzID0gdGFyZ2V0O1xuICAgIHRoaXMuc3R5bGUgPSBkaXYuc3R5bGU7XG4gICAgZGl2LnN0eWxlLmNzc1RleHQgPSB0YXJnZXQuY3NzVGV4dDtcbiAgICBDU1NQbHVnaW4ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBkaXYsIHZhbHVlLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpOyAvL3dlIGp1c3Qgb2ZmbG9hZCBhbGwgdGhlIHdvcmsgdG8gdGhlIHJlZ3VsYXIgQ1NTUGx1Z2luIGFuZCB0aGVuIGNvcHkgdGhlIGNzc1RleHQgYmFjayBvdmVyIHRvIHRoZSBydWxlIGluIHRoZSByZW5kZXIoKSBtZXRob2QuIFRoaXMgYWxsb3dzIHVzIHRvIGhhdmUgYWxsIG9mIHRoZSB1cGRhdGVzIHRvIENTU1BsdWdpbiBhdXRvbWF0aWNhbGx5IGZsb3cgdGhyb3VnaCB0byBDU1NSdWxlUGx1Z2luIGluc3RlYWQgb2YgaGF2aW5nIHRvIG1haW50YWluIGJvdGhcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocmF0aW8sIGRhdGEpIHtcbiAgICB2YXIgcHQgPSBkYXRhLl9wdCxcbiAgICAgICAgc3R5bGUgPSBkYXRhLnN0eWxlLFxuICAgICAgICBzcyA9IGRhdGEuc3MsXG4gICAgICAgIGk7XG5cbiAgICB3aGlsZSAocHQpIHtcbiAgICAgIHB0LnIocmF0aW8sIHB0LmQpO1xuICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICB9XG5cbiAgICBpID0gc3R5bGUubGVuZ3RoO1xuXG4gICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICBzc1tzdHlsZVtpXV0gPSBzdHlsZVtzdHlsZVtpXV07XG4gICAgfVxuICB9LFxuICBnZXRSdWxlOiBmdW5jdGlvbiBnZXRSdWxlKHNlbGVjdG9yKSB7XG4gICAgX2NoZWNrUmVnaXN0ZXIoKTtcblxuICAgIHZhciBydWxlUHJvcCA9IF9kb2MuYWxsID8gXCJydWxlc1wiIDogXCJjc3NSdWxlc1wiLFxuICAgICAgICBzdHlsZVNoZWV0cyA9IF9kb2Muc3R5bGVTaGVldHMsXG4gICAgICAgIGkgPSBzdHlsZVNoZWV0cy5sZW5ndGgsXG4gICAgICAgIHBzZXVkbyA9IHNlbGVjdG9yLmNoYXJBdCgwKSA9PT0gXCI6XCIsXG4gICAgICAgIGosXG4gICAgICAgIGN1clNTLFxuICAgICAgICBjcyxcbiAgICAgICAgYTtcbiAgICBzZWxlY3RvciA9IChwc2V1ZG8gPyBcIlwiIDogXCIsXCIpICsgc2VsZWN0b3Iuc3BsaXQoXCI6OlwiKS5qb2luKFwiOlwiKS50b0xvd2VyQ2FzZSgpICsgXCIsXCI7IC8vbm90ZTogb2xkIHZlcnNpb25zIG9mIElFIHJlcG9ydCB0YWcgbmFtZSBzZWxlY3RvcnMgYXMgdXBwZXIgY2FzZSwgc28gd2UganVzdCBjaGFuZ2UgZXZlcnl0aGluZyB0byBsb3dlcmNhc2UuXG5cbiAgICBpZiAocHNldWRvKSB7XG4gICAgICBhID0gW107XG4gICAgfVxuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgLy9GaXJlZm94IG1heSB0aHJvdyBpbnNlY3VyZSBvcGVyYXRpb24gZXJyb3JzIHdoZW4gY3NzIGlzIGxvYWRlZCBmcm9tIG90aGVyIGRvbWFpbnMsIHNvIHRyeS9jYXRjaC5cbiAgICAgIHRyeSB7XG4gICAgICAgIGN1clNTID0gc3R5bGVTaGVldHNbaV1bcnVsZVByb3BdO1xuXG4gICAgICAgIGlmICghY3VyU1MpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGogPSBjdXJTUy5sZW5ndGg7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICgtLWogPiAtMSkge1xuICAgICAgICBjcyA9IGN1clNTW2pdO1xuXG4gICAgICAgIGlmIChjcy5zZWxlY3RvclRleHQgJiYgKFwiLFwiICsgY3Muc2VsZWN0b3JUZXh0LnNwbGl0KFwiOjpcIikuam9pbihcIjpcIikudG9Mb3dlckNhc2UoKSArIFwiLFwiKS5pbmRleE9mKHNlbGVjdG9yKSAhPT0gLTEpIHtcbiAgICAgICAgICAvL25vdGU6IElFIGFkZHMgYW4gZXh0cmEgXCI6XCIgdG8gcHNldWRvIHNlbGVjdG9ycywgc28gLm15Q2xhc3M6YWZ0ZXIgYmVjb21lcyAubXlDbGFzczo6YWZ0ZXIsIHNvIHdlIG5lZWQgdG8gc3RyaXAgdGhlIGV4dHJhIG9uZSBvdXQuXG4gICAgICAgICAgaWYgKHBzZXVkbykge1xuICAgICAgICAgICAgYS5wdXNoKGNzLnN0eWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNzLnN0eWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9LFxuICByZWdpc3RlcjogX2luaXRDb3JlXG59O1xuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1J1bGVQbHVnaW4pO1xuZXhwb3J0IHsgQ1NTUnVsZVBsdWdpbiBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbImdzYXAiLCJfY29yZUluaXR0ZWQiLCJfd2luIiwiX2RvYyIsIkNTU1BsdWdpbiIsIl93aW5kb3dFeGlzdHMiLCJ3aW5kb3ciLCJfZ2V0R1NBUCIsInJlZ2lzdGVyUGx1Z2luIiwiX2NoZWNrUmVnaXN0ZXIiLCJfaW5pdENvcmUiLCJjb25zb2xlIiwid2FybiIsImNvcmUiLCJkb2N1bWVudCIsInBsdWdpbnMiLCJjc3MiLCJDU1NSdWxlUGx1Z2luIiwidmVyc2lvbiIsIm5hbWUiLCJpbml0IiwidGFyZ2V0IiwidmFsdWUiLCJ0d2VlbiIsImluZGV4IiwidGFyZ2V0cyIsImNzc1RleHQiLCJkaXYiLCJfZ3NQcm94eSIsImNyZWF0ZUVsZW1lbnQiLCJzcyIsInN0eWxlIiwicHJvdG90eXBlIiwiY2FsbCIsInJlbmRlciIsInJhdGlvIiwiZGF0YSIsInB0IiwiX3B0IiwiaSIsInIiLCJkIiwiX25leHQiLCJsZW5ndGgiLCJnZXRSdWxlIiwic2VsZWN0b3IiLCJydWxlUHJvcCIsImFsbCIsInN0eWxlU2hlZXRzIiwicHNldWRvIiwiY2hhckF0IiwiaiIsImN1clNTIiwiY3MiLCJhIiwic3BsaXQiLCJqb2luIiwidG9Mb3dlckNhc2UiLCJlIiwic2VsZWN0b3JUZXh0IiwiaW5kZXhPZiIsInB1c2giLCJyZWdpc3RlciIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSRulePlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CustomEase.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CustomEase.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomEase: function() { return /* binding */ CustomEase; },\n/* harmony export */   \"default\": function() { return /* binding */ CustomEase; }\n/* harmony export */ });\n/* harmony import */ var _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/paths.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/paths.js\");\n/*!\n * CustomEase 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ \nvar gsap, _coreInitted, _getGSAP = function _getGSAP() {\n    return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _initCore = function _initCore() {\n    gsap = _getGSAP();\n    if (gsap) {\n        gsap.registerEase(\"_CE\", CustomEase.create);\n        _coreInitted = 1;\n    } else {\n        console.warn(\"Please gsap.registerPlugin(CustomEase)\");\n    }\n}, _bigNum = 1e20, _round = function _round(value) {\n    return ~~(value * 1000 + (value < 0 ? -.5 : .5)) / 1000;\n}, _bonusValidated = 1, //<name>CustomEase</name>\n_numExp = /[-+=.]*\\d+[.e\\-+]*\\d*[e\\-+]*\\d*/gi, //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\n_needsParsingExp = /[cLlsSaAhHvVtTqQ]/g, _findMinimum = function _findMinimum(values) {\n    var l = values.length, min = _bigNum, i;\n    for(i = 1; i < l; i += 6){\n        +values[i] < min && (min = +values[i]);\n    }\n    return min;\n}, //takes all the points and translates/scales them so that the x starts at 0 and ends at 1.\n_normalize = function _normalize(values, height, originY) {\n    if (!originY && originY !== 0) {\n        originY = Math.max(+values[values.length - 1], +values[1]);\n    }\n    var tx = +values[0] * -1, ty = -originY, l = values.length, sx = 1 / (+values[l - 2] + tx), sy = -height || (Math.abs(+values[l - 1] - +values[1]) < 0.01 * (+values[l - 2] - +values[0]) ? _findMinimum(values) + ty : +values[l - 1] + ty), i;\n    if (sy) {\n        //typically y ends at 1 (so that the end values are reached)\n        sy = 1 / sy;\n    } else {\n        //in case the ease returns to its beginning value, scale everything proportionally\n        sy = -sx;\n    }\n    for(i = 0; i < l; i += 2){\n        values[i] = (+values[i] + tx) * sx;\n        values[i + 1] = (+values[i + 1] + ty) * sy;\n    }\n}, //note that this function returns point objects like {x, y} rather than working with segments which are arrays with alternating x, y values as in the similar function in paths.js\n_bezierToPoints = function _bezierToPoints(x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {\n    var x12 = (x1 + x2) / 2, y12 = (y1 + y2) / 2, x23 = (x2 + x3) / 2, y23 = (y2 + y3) / 2, x34 = (x3 + x4) / 2, y34 = (y3 + y4) / 2, x123 = (x12 + x23) / 2, y123 = (y12 + y23) / 2, x234 = (x23 + x34) / 2, y234 = (y23 + y34) / 2, x1234 = (x123 + x234) / 2, y1234 = (y123 + y234) / 2, dx = x4 - x1, dy = y4 - y1, d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx), d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx), length;\n    if (!points) {\n        points = [\n            {\n                x: x1,\n                y: y1\n            },\n            {\n                x: x4,\n                y: y4\n            }\n        ];\n        index = 1;\n    }\n    points.splice(index || points.length - 1, 0, {\n        x: x1234,\n        y: y1234\n    });\n    if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {\n        length = points.length;\n        _bezierToPoints(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);\n        _bezierToPoints(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 1 + (points.length - length));\n    }\n    return points;\n};\nvar CustomEase = /*#__PURE__*/ function() {\n    function CustomEase(id, data, config) {\n        _coreInitted || _initCore();\n        this.id = id;\n        _bonusValidated && this.setData(data, config);\n    }\n    var _proto = CustomEase.prototype;\n    _proto.setData = function setData(data, config) {\n        config = config || {};\n        data = data || \"0,0,1,1\";\n        var values = data.match(_numExp), closest = 1, points = [], lookup = [], precision = config.precision || 1, fast = precision <= 1, l, a1, a2, i, inc, j, point, prevPoint, p;\n        this.data = data;\n        if (_needsParsingExp.test(data) || ~data.indexOf(\"M\") && data.indexOf(\"C\") < 0) {\n            values = (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.stringToRawPath)(data)[0];\n        }\n        l = values.length;\n        if (l === 4) {\n            values.unshift(0, 0);\n            values.push(1, 1);\n            l = 8;\n        } else if ((l - 2) % 6) {\n            throw \"Invalid CustomEase\";\n        }\n        if (+values[0] !== 0 || +values[l - 2] !== 1) {\n            _normalize(values, config.height, config.originY);\n        }\n        this.segment = values;\n        for(i = 2; i < l; i += 6){\n            a1 = {\n                x: +values[i - 2],\n                y: +values[i - 1]\n            };\n            a2 = {\n                x: +values[i + 4],\n                y: +values[i + 5]\n            };\n            points.push(a1, a2);\n            _bezierToPoints(a1.x, a1.y, +values[i], +values[i + 1], +values[i + 2], +values[i + 3], a2.x, a2.y, 1 / (precision * 200000), points, points.length - 1);\n        }\n        l = points.length;\n        for(i = 0; i < l; i++){\n            point = points[i];\n            prevPoint = points[i - 1] || point;\n            if ((point.x > prevPoint.x || prevPoint.y !== point.y && prevPoint.x === point.x || point === prevPoint) && point.x <= 1) {\n                //if a point goes BACKWARD in time or is a duplicate, just drop it. Also it shouldn't go past 1 on the x axis, as could happen in a string like \"M0,0 C0,0 0.12,0.68 0.18,0.788 0.195,0.845 0.308,1 0.32,1 0.403,1.005 0.398,1 0.5,1 0.602,1 0.816,1.005 0.9,1 0.91,1 0.948,0.69 0.962,0.615 1.003,0.376 1,0 1,0\".\n                prevPoint.cx = point.x - prevPoint.x; //change in x between this point and the next point (performance optimization)\n                prevPoint.cy = point.y - prevPoint.y;\n                prevPoint.n = point;\n                prevPoint.nx = point.x; //next point's x value (performance optimization, making lookups faster in getRatio()). Remember, the lookup will always land on a spot where it's either this point or the very next one (never beyond that)\n                if (fast && i > 1 && Math.abs(prevPoint.cy / prevPoint.cx - points[i - 2].cy / points[i - 2].cx) > 2) {\n                    //if there's a sudden change in direction, prioritize accuracy over speed. Like a bounce ease - you don't want to risk the sampling chunks landing on each side of the bounce anchor and having it clipped off.\n                    fast = 0;\n                }\n                if (prevPoint.cx < closest) {\n                    if (!prevPoint.cx) {\n                        prevPoint.cx = 0.001; //avoids math problems in getRatio() (dividing by zero)\n                        if (i === l - 1) {\n                            //in case the final segment goes vertical RIGHT at the end, make sure we end at the end.\n                            prevPoint.x -= 0.001;\n                            closest = Math.min(closest, 0.001);\n                            fast = 0;\n                        }\n                    } else {\n                        closest = prevPoint.cx;\n                    }\n                }\n            } else {\n                points.splice(i--, 1);\n                l--;\n            }\n        }\n        l = 1 / closest + 1 | 0;\n        inc = 1 / l;\n        j = 0;\n        point = points[0];\n        if (fast) {\n            for(i = 0; i < l; i++){\n                //for fastest lookups, we just sample along the path at equal x (time) distance. Uses more memory and is slightly less accurate for anchors that don't land on the sampling points, but for the vast majority of eases it's excellent (and fast).\n                p = i * inc;\n                if (point.nx < p) {\n                    point = points[++j];\n                }\n                a1 = point.y + (p - point.x) / point.cx * point.cy;\n                lookup[i] = {\n                    x: p,\n                    cx: inc,\n                    y: a1,\n                    cy: 0,\n                    nx: 9\n                };\n                if (i) {\n                    lookup[i - 1].cy = a1 - lookup[i - 1].y;\n                }\n            }\n            lookup[l - 1].cy = points[points.length - 1].y - a1;\n        } else {\n            //this option is more accurate, ensuring that EVERY anchor is hit perfectly. Clipping across a bounce, for example, would never happen.\n            for(i = 0; i < l; i++){\n                //build a lookup table based on the smallest distance so that we can instantly find the appropriate point (well, it'll either be that point or the very next one). We'll look up based on the linear progress. So it's it's 0.5 and the lookup table has 100 elements, it'd be like lookup[Math.floor(0.5 * 100)]\n                if (point.nx < i * inc) {\n                    point = points[++j];\n                }\n                lookup[i] = point;\n            }\n            if (j < points.length - 1) {\n                lookup[i - 1] = points[points.length - 2];\n            }\n        } //this._calcEnd = (points[points.length-1].y !== 1 || points[0].y !== 0); //ensures that we don't run into floating point errors. As long as we're starting at 0 and ending at 1, tell GSAP to skip the final calculation and use 0/1 as the factor.\n        this.ease = function(p) {\n            var point = lookup[p * l | 0] || lookup[l - 1];\n            if (point.nx < p) {\n                point = point.n;\n            }\n            return point.y + (p - point.x) / point.cx * point.cy;\n        };\n        this.ease.custom = this;\n        this.id && gsap && gsap.registerEase(this.id, this.ease);\n        return this;\n    };\n    _proto.getSVGData = function getSVGData(config) {\n        return CustomEase.getSVGData(this, config);\n    };\n    CustomEase.create = function create(id, data, config) {\n        return new CustomEase(id, data, config).ease;\n    };\n    CustomEase.register = function register(core) {\n        gsap = core;\n        _initCore();\n    };\n    CustomEase.get = function get(id) {\n        return gsap.parseEase(id);\n    };\n    CustomEase.getSVGData = function getSVGData(ease, config) {\n        config = config || {};\n        var width = config.width || 100, height = config.height || 100, x = config.x || 0, y = (config.y || 0) + height, e = gsap.utils.toArray(config.path)[0], a, slope, i, inc, tx, ty, precision, threshold, prevX, prevY;\n        if (config.invert) {\n            height = -height;\n            y = 0;\n        }\n        if (typeof ease === \"string\") {\n            ease = gsap.parseEase(ease);\n        }\n        if (ease.custom) {\n            ease = ease.custom;\n        }\n        if (ease instanceof CustomEase) {\n            a = (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.rawPathToString)((0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)([\n                ease.segment\n            ], width, 0, 0, -height, x, y));\n        } else {\n            a = [\n                x,\n                y\n            ];\n            precision = Math.max(5, (config.precision || 1) * 200);\n            inc = 1 / precision;\n            precision += 2;\n            threshold = 5 / precision;\n            prevX = _round(x + inc * width);\n            prevY = _round(y + ease(inc) * -height);\n            slope = (prevY - y) / (prevX - x);\n            for(i = 2; i < precision; i++){\n                tx = _round(x + i * inc * width);\n                ty = _round(y + ease(i * inc) * -height);\n                if (Math.abs((ty - prevY) / (tx - prevX) - slope) > threshold || i === precision - 1) {\n                    //only add points when the slope changes beyond the threshold\n                    a.push(prevX, prevY);\n                    slope = (ty - prevY) / (tx - prevX);\n                }\n                prevX = tx;\n                prevY = ty;\n            }\n            a = \"M\" + a.join(\",\");\n        }\n        e && e.setAttribute(\"d\", a);\n        return a;\n    };\n    return CustomEase;\n}();\n_getGSAP() && gsap.registerPlugin(CustomEase);\nCustomEase.version = \"3.12.5\";\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9DdXN0b21FYXNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCLEdBQ29FO0FBRXRGLElBQUlHLE1BQ0FDLGNBQ0FDLFdBQVcsU0FBU0E7SUFDdEIsT0FBT0YsUUFBUSxPQUFPRyxXQUFXLGVBQWdCSCxDQUFBQSxPQUFPRyxPQUFPSCxJQUFJLEtBQUtBLEtBQUtJLGNBQWMsSUFBSUo7QUFDakcsR0FDSUssWUFBWSxTQUFTQTtJQUN2QkwsT0FBT0U7SUFFUCxJQUFJRixNQUFNO1FBQ1JBLEtBQUtNLFlBQVksQ0FBQyxPQUFPQyxXQUFXQyxNQUFNO1FBQzFDUCxlQUFlO0lBQ2pCLE9BQU87UUFDTFEsUUFBUUMsSUFBSSxDQUFDO0lBQ2Y7QUFDRixHQUNJQyxVQUFVLE1BQ1ZDLFNBQVMsU0FBU0EsT0FBT0MsS0FBSztJQUNoQyxPQUFPLENBQUMsQ0FBRUEsQ0FBQUEsUUFBUSxPQUFRQSxDQUFBQSxRQUFRLElBQUksQ0FBQyxLQUFLLEVBQUMsQ0FBQyxJQUFLO0FBQ3JELEdBQ0lDLGtCQUFrQixHQUNsQix5QkFBeUI7QUFDN0JDLFVBQVUscUNBQ04sMEhBQTBIO0FBQzlIQyxtQkFBbUIsc0JBQ2ZDLGVBQWUsU0FBU0EsYUFBYUMsTUFBTTtJQUM3QyxJQUFJQyxJQUFJRCxPQUFPRSxNQUFNLEVBQ2pCQyxNQUFNVixTQUNOVztJQUVKLElBQUtBLElBQUksR0FBR0EsSUFBSUgsR0FBR0csS0FBSyxFQUFHO1FBQ3pCLENBQUNKLE1BQU0sQ0FBQ0ksRUFBRSxHQUFHRCxPQUFRQSxDQUFBQSxNQUFNLENBQUNILE1BQU0sQ0FBQ0ksRUFBRTtJQUN2QztJQUVBLE9BQU9EO0FBQ1QsR0FDSSwwRkFBMEY7QUFDOUZFLGFBQWEsU0FBU0EsV0FBV0wsTUFBTSxFQUFFTSxNQUFNLEVBQUVDLE9BQU87SUFDdEQsSUFB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Z3NhcEAzLjEyLjUvbm9kZV9tb2R1bGVzL2dzYXAvQ3VzdG9tRWFzZS5qcz8xYzZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ3VzdG9tRWFzZSAzLjEyLjVcbiAqIGh0dHBzOi8vZ3NhcC5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDI0LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dzYXAuY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdTQVAgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgeyBzdHJpbmdUb1Jhd1BhdGgsIHJhd1BhdGhUb1N0cmluZywgdHJhbnNmb3JtUmF3UGF0aCB9IGZyb20gXCIuL3V0aWxzL3BhdGhzLmpzXCI7XG5cbnZhciBnc2FwLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKCkge1xuICBnc2FwID0gX2dldEdTQVAoKTtcblxuICBpZiAoZ3NhcCkge1xuICAgIGdzYXAucmVnaXN0ZXJFYXNlKFwiX0NFXCIsIEN1c3RvbUVhc2UuY3JlYXRlKTtcbiAgICBfY29yZUluaXR0ZWQgPSAxO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybihcIlBsZWFzZSBnc2FwLnJlZ2lzdGVyUGx1Z2luKEN1c3RvbUVhc2UpXCIpO1xuICB9XG59LFxuICAgIF9iaWdOdW0gPSAxZTIwLFxuICAgIF9yb3VuZCA9IGZ1bmN0aW9uIF9yb3VuZCh2YWx1ZSkge1xuICByZXR1cm4gfn4odmFsdWUgKiAxMDAwICsgKHZhbHVlIDwgMCA/IC0uNSA6IC41KSkgLyAxMDAwO1xufSxcbiAgICBfYm9udXNWYWxpZGF0ZWQgPSAxLFxuICAgIC8vPG5hbWU+Q3VzdG9tRWFzZTwvbmFtZT5cbl9udW1FeHAgPSAvWy0rPS5dKlxcZCtbLmVcXC0rXSpcXGQqW2VcXC0rXSpcXGQqL2dpLFxuICAgIC8vZmluZHMgYW55IG51bWJlcnMsIGluY2x1ZGluZyBvbmVzIHRoYXQgc3RhcnQgd2l0aCArPSBvciAtPSwgbmVnYXRpdmUgbnVtYmVycywgYW5kIG9uZXMgaW4gc2NpZW50aWZpYyBub3RhdGlvbiBsaWtlIDFlLTguXG5fbmVlZHNQYXJzaW5nRXhwID0gL1tjTGxzU2FBaEh2VnRUcVFdL2csXG4gICAgX2ZpbmRNaW5pbXVtID0gZnVuY3Rpb24gX2ZpbmRNaW5pbXVtKHZhbHVlcykge1xuICB2YXIgbCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBtaW4gPSBfYmlnTnVtLFxuICAgICAgaTtcblxuICBmb3IgKGkgPSAxOyBpIDwgbDsgaSArPSA2KSB7XG4gICAgK3ZhbHVlc1tpXSA8IG1pbiAmJiAobWluID0gK3ZhbHVlc1tpXSk7XG4gIH1cblxuICByZXR1cm4gbWluO1xufSxcbiAgICAvL3Rha2VzIGFsbCB0aGUgcG9pbnRzIGFuZCB0cmFuc2xhdGVzL3NjYWxlcyB0aGVtIHNvIHRoYXQgdGhlIHggc3RhcnRzIGF0IDAgYW5kIGVuZHMgYXQgMS5cbl9ub3JtYWxpemUgPSBmdW5jdGlvbiBfbm9ybWFsaXplKHZhbHVlcywgaGVpZ2h0LCBvcmlnaW5ZKSB7XG4gIGlmICghb3JpZ2luWSAmJiBvcmlnaW5ZICE9PSAwKSB7XG4gICAgb3JpZ2luWSA9IE1hdGgubWF4KCt2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdLCArdmFsdWVzWzFdKTtcbiAgfVxuXG4gIHZhciB0eCA9ICt2YWx1ZXNbMF0gKiAtMSxcbiAgICAgIHR5ID0gLW9yaWdpblksXG4gICAgICBsID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIHN4ID0gMSAvICgrdmFsdWVzW2wgLSAyXSArIHR4KSxcbiAgICAgIHN5ID0gLWhlaWdodCB8fCAoTWF0aC5hYnMoK3ZhbHVlc1tsIC0gMV0gLSArdmFsdWVzWzFdKSA8IDAuMDEgKiAoK3ZhbHVlc1tsIC0gMl0gLSArdmFsdWVzWzBdKSA/IF9maW5kTWluaW11bSh2YWx1ZXMpICsgdHkgOiArdmFsdWVzW2wgLSAxXSArIHR5KSxcbiAgICAgIGk7XG5cbiAgaWYgKHN5KSB7XG4gICAgLy90eXBpY2FsbHkgeSBlbmRzIGF0IDEgKHNvIHRoYXQgdGhlIGVuZCB2YWx1ZXMgYXJlIHJlYWNoZWQpXG4gICAgc3kgPSAxIC8gc3k7XG4gIH0gZWxzZSB7XG4gICAgLy9pbiBjYXNlIHRoZSBlYXNlIHJldHVybnMgdG8gaXRzIGJlZ2lubmluZyB2YWx1ZSwgc2NhbGUgZXZlcnl0aGluZyBwcm9wb3J0aW9uYWxseVxuICAgIHN5ID0gLXN4O1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHZhbHVlc1tpXSA9ICgrdmFsdWVzW2ldICsgdHgpICogc3g7XG4gICAgdmFsdWVzW2kgKyAxXSA9ICgrdmFsdWVzW2kgKyAxXSArIHR5KSAqIHN5O1xuICB9XG59LFxuICAgIC8vbm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBwb2ludCBvYmplY3RzIGxpa2Uge3gsIHl9IHJhdGhlciB0aGFuIHdvcmtpbmcgd2l0aCBzZWdtZW50cyB3aGljaCBhcmUgYXJyYXlzIHdpdGggYWx0ZXJuYXRpbmcgeCwgeSB2YWx1ZXMgYXMgaW4gdGhlIHNpbWlsYXIgZnVuY3Rpb24gaW4gcGF0aHMuanNcbl9iZXppZXJUb1BvaW50cyA9IGZ1bmN0aW9uIF9iZXppZXJUb1BvaW50cyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIHRocmVzaG9sZCwgcG9pbnRzLCBpbmRleCkge1xuICB2YXIgeDEyID0gKHgxICsgeDIpIC8gMixcbiAgICAgIHkxMiA9ICh5MSArIHkyKSAvIDIsXG4gICAgICB4MjMgPSAoeDIgKyB4MykgLyAyLFxuICAgICAgeTIzID0gKHkyICsgeTMpIC8gMixcbiAgICAgIHgzNCA9ICh4MyArIHg0KSAvIDIsXG4gICAgICB5MzQgPSAoeTMgKyB5NCkgLyAyLFxuICAgICAgeDEyMyA9ICh4MTIgKyB4MjMpIC8gMixcbiAgICAgIHkxMjMgPSAoeTEyICsgeTIzKSAvIDIsXG4gICAgICB4MjM0ID0gKHgyMyArIHgzNCkgLyAyLFxuICAgICAgeTIzNCA9ICh5MjMgKyB5MzQpIC8gMixcbiAgICAgIHgxMjM0ID0gKHgxMjMgKyB4MjM0KSAvIDIsXG4gICAgICB5MTIzNCA9ICh5MTIzICsgeTIzNCkgLyAyLFxuICAgICAgZHggPSB4NCAtIHgxLFxuICAgICAgZHkgPSB5NCAtIHkxLFxuICAgICAgZDIgPSBNYXRoLmFicygoeDIgLSB4NCkgKiBkeSAtICh5MiAtIHk0KSAqIGR4KSxcbiAgICAgIGQzID0gTWF0aC5hYnMoKHgzIC0geDQpICogZHkgLSAoeTMgLSB5NCkgKiBkeCksXG4gICAgICBsZW5ndGg7XG5cbiAgaWYgKCFwb2ludHMpIHtcbiAgICBwb2ludHMgPSBbe1xuICAgICAgeDogeDEsXG4gICAgICB5OiB5MVxuICAgIH0sIHtcbiAgICAgIHg6IHg0LFxuICAgICAgeTogeTRcbiAgICB9XTtcbiAgICBpbmRleCA9IDE7XG4gIH1cblxuICBwb2ludHMuc3BsaWNlKGluZGV4IHx8IHBvaW50cy5sZW5ndGggLSAxLCAwLCB7XG4gICAgeDogeDEyMzQsXG4gICAgeTogeTEyMzRcbiAgfSk7XG5cbiAgaWYgKChkMiArIGQzKSAqIChkMiArIGQzKSA+IHRocmVzaG9sZCAqIChkeCAqIGR4ICsgZHkgKiBkeSkpIHtcbiAgICBsZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgX2JlemllclRvUG9pbnRzKHgxLCB5MSwgeDEyLCB5MTIsIHgxMjMsIHkxMjMsIHgxMjM0LCB5MTIzNCwgdGhyZXNob2xkLCBwb2ludHMsIGluZGV4KTtcblxuICAgIF9iZXppZXJUb1BvaW50cyh4MTIzNCwgeTEyMzQsIHgyMzQsIHkyMzQsIHgzNCwgeTM0LCB4NCwgeTQsIHRocmVzaG9sZCwgcG9pbnRzLCBpbmRleCArIDEgKyAocG9pbnRzLmxlbmd0aCAtIGxlbmd0aCkpO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn07XG5cbmV4cG9ydCB2YXIgQ3VzdG9tRWFzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEN1c3RvbUVhc2UoaWQsIGRhdGEsIGNvbmZpZykge1xuICAgIF9jb3JlSW5pdHRlZCB8fCBfaW5pdENvcmUoKTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgX2JvbnVzVmFsaWRhdGVkICYmIHRoaXMuc2V0RGF0YShkYXRhLCBjb25maWcpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEN1c3RvbUVhc2UucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXREYXRhID0gZnVuY3Rpb24gc2V0RGF0YShkYXRhLCBjb25maWcpIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgZGF0YSA9IGRhdGEgfHwgXCIwLDAsMSwxXCI7XG4gICAgdmFyIHZhbHVlcyA9IGRhdGEubWF0Y2goX251bUV4cCksXG4gICAgICAgIGNsb3Nlc3QgPSAxLFxuICAgICAgICBwb2ludHMgPSBbXSxcbiAgICAgICAgbG9va3VwID0gW10sXG4gICAgICAgIHByZWNpc2lvbiA9IGNvbmZpZy5wcmVjaXNpb24gfHwgMSxcbiAgICAgICAgZmFzdCA9IHByZWNpc2lvbiA8PSAxLFxuICAgICAgICBsLFxuICAgICAgICBhMSxcbiAgICAgICAgYTIsXG4gICAgICAgIGksXG4gICAgICAgIGluYyxcbiAgICAgICAgaixcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHByZXZQb2ludCxcbiAgICAgICAgcDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuXG4gICAgaWYgKF9uZWVkc1BhcnNpbmdFeHAudGVzdChkYXRhKSB8fCB+ZGF0YS5pbmRleE9mKFwiTVwiKSAmJiBkYXRhLmluZGV4T2YoXCJDXCIpIDwgMCkge1xuICAgICAgdmFsdWVzID0gc3RyaW5nVG9SYXdQYXRoKGRhdGEpWzBdO1xuICAgIH1cblxuICAgIGwgPSB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgaWYgKGwgPT09IDQpIHtcbiAgICAgIHZhbHVlcy51bnNoaWZ0KDAsIDApO1xuICAgICAgdmFsdWVzLnB1c2goMSwgMSk7XG4gICAgICBsID0gODtcbiAgICB9IGVsc2UgaWYgKChsIC0gMikgJSA2KSB7XG4gICAgICB0aHJvdyBcIkludmFsaWQgQ3VzdG9tRWFzZVwiO1xuICAgIH1cblxuICAgIGlmICgrdmFsdWVzWzBdICE9PSAwIHx8ICt2YWx1ZXNbbCAtIDJdICE9PSAxKSB7XG4gICAgICBfbm9ybWFsaXplKHZhbHVlcywgY29uZmlnLmhlaWdodCwgY29uZmlnLm9yaWdpblkpO1xuICAgIH1cblxuICAgIHRoaXMuc2VnbWVudCA9IHZhbHVlcztcblxuICAgIGZvciAoaSA9IDI7IGkgPCBsOyBpICs9IDYpIHtcbiAgICAgIGExID0ge1xuICAgICAgICB4OiArdmFsdWVzW2kgLSAyXSxcbiAgICAgICAgeTogK3ZhbHVlc1tpIC0gMV1cbiAgICAgIH07XG4gICAgICBhMiA9IHtcbiAgICAgICAgeDogK3ZhbHVlc1tpICsgNF0sXG4gICAgICAgIHk6ICt2YWx1ZXNbaSArIDVdXG4gICAgICB9O1xuICAgICAgcG9pbnRzLnB1c2goYTEsIGEyKTtcblxuICAgICAgX2JlemllclRvUG9pbnRzKGExLngsIGExLnksICt2YWx1ZXNbaV0sICt2YWx1ZXNbaSArIDFdLCArdmFsdWVzW2kgKyAyXSwgK3ZhbHVlc1tpICsgM10sIGEyLngsIGEyLnksIDEgLyAocHJlY2lzaW9uICogMjAwMDAwKSwgcG9pbnRzLCBwb2ludHMubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgbCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIHByZXZQb2ludCA9IHBvaW50c1tpIC0gMV0gfHwgcG9pbnQ7XG5cbiAgICAgIGlmICgocG9pbnQueCA+IHByZXZQb2ludC54IHx8IHByZXZQb2ludC55ICE9PSBwb2ludC55ICYmIHByZXZQb2ludC54ID09PSBwb2ludC54IHx8IHBvaW50ID09PSBwcmV2UG9pbnQpICYmIHBvaW50LnggPD0gMSkge1xuICAgICAgICAvL2lmIGEgcG9pbnQgZ29lcyBCQUNLV0FSRCBpbiB0aW1lIG9yIGlzIGEgZHVwbGljYXRlLCBqdXN0IGRyb3AgaXQuIEFsc28gaXQgc2hvdWxkbid0IGdvIHBhc3QgMSBvbiB0aGUgeCBheGlzLCBhcyBjb3VsZCBoYXBwZW4gaW4gYSBzdHJpbmcgbGlrZSBcIk0wLDAgQzAsMCAwLjEyLDAuNjggMC4xOCwwLjc4OCAwLjE5NSwwLjg0NSAwLjMwOCwxIDAuMzIsMSAwLjQwMywxLjAwNSAwLjM5OCwxIDAuNSwxIDAuNjAyLDEgMC44MTYsMS4wMDUgMC45LDEgMC45MSwxIDAuOTQ4LDAuNjkgMC45NjIsMC42MTUgMS4wMDMsMC4zNzYgMSwwIDEsMFwiLlxuICAgICAgICBwcmV2UG9pbnQuY3ggPSBwb2ludC54IC0gcHJldlBvaW50Lng7IC8vY2hhbmdlIGluIHggYmV0d2VlbiB0aGlzIHBvaW50IGFuZCB0aGUgbmV4dCBwb2ludCAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uKVxuXG4gICAgICAgIHByZXZQb2ludC5jeSA9IHBvaW50LnkgLSBwcmV2UG9pbnQueTtcbiAgICAgICAgcHJldlBvaW50Lm4gPSBwb2ludDtcbiAgICAgICAgcHJldlBvaW50Lm54ID0gcG9pbnQueDsgLy9uZXh0IHBvaW50J3MgeCB2YWx1ZSAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLCBtYWtpbmcgbG9va3VwcyBmYXN0ZXIgaW4gZ2V0UmF0aW8oKSkuIFJlbWVtYmVyLCB0aGUgbG9va3VwIHdpbGwgYWx3YXlzIGxhbmQgb24gYSBzcG90IHdoZXJlIGl0J3MgZWl0aGVyIHRoaXMgcG9pbnQgb3IgdGhlIHZlcnkgbmV4dCBvbmUgKG5ldmVyIGJleW9uZCB0aGF0KVxuXG4gICAgICAgIGlmIChmYXN0ICYmIGkgPiAxICYmIE1hdGguYWJzKHByZXZQb2ludC5jeSAvIHByZXZQb2ludC5jeCAtIHBvaW50c1tpIC0gMl0uY3kgLyBwb2ludHNbaSAtIDJdLmN4KSA+IDIpIHtcbiAgICAgICAgICAvL2lmIHRoZXJlJ3MgYSBzdWRkZW4gY2hhbmdlIGluIGRpcmVjdGlvbiwgcHJpb3JpdGl6ZSBhY2N1cmFjeSBvdmVyIHNwZWVkLiBMaWtlIGEgYm91bmNlIGVhc2UgLSB5b3UgZG9uJ3Qgd2FudCB0byByaXNrIHRoZSBzYW1wbGluZyBjaHVua3MgbGFuZGluZyBvbiBlYWNoIHNpZGUgb2YgdGhlIGJvdW5jZSBhbmNob3IgYW5kIGhhdmluZyBpdCBjbGlwcGVkIG9mZi5cbiAgICAgICAgICBmYXN0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2UG9pbnQuY3ggPCBjbG9zZXN0KSB7XG4gICAgICAgICAgaWYgKCFwcmV2UG9pbnQuY3gpIHtcbiAgICAgICAgICAgIHByZXZQb2ludC5jeCA9IDAuMDAxOyAvL2F2b2lkcyBtYXRoIHByb2JsZW1zIGluIGdldFJhdGlvKCkgKGRpdmlkaW5nIGJ5IHplcm8pXG5cbiAgICAgICAgICAgIGlmIChpID09PSBsIC0gMSkge1xuICAgICAgICAgICAgICAvL2luIGNhc2UgdGhlIGZpbmFsIHNlZ21lbnQgZ29lcyB2ZXJ0aWNhbCBSSUdIVCBhdCB0aGUgZW5kLCBtYWtlIHN1cmUgd2UgZW5kIGF0IHRoZSBlbmQuXG4gICAgICAgICAgICAgIHByZXZQb2ludC54IC09IDAuMDAxO1xuICAgICAgICAgICAgICBjbG9zZXN0ID0gTWF0aC5taW4oY2xvc2VzdCwgMC4wMDEpO1xuICAgICAgICAgICAgICBmYXN0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xvc2VzdCA9IHByZXZQb2ludC5jeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50cy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgbC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIGwgPSAxIC8gY2xvc2VzdCArIDEgfCAwO1xuICAgIGluYyA9IDEgLyBsO1xuICAgIGogPSAwO1xuICAgIHBvaW50ID0gcG9pbnRzWzBdO1xuXG4gICAgaWYgKGZhc3QpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgLy9mb3IgZmFzdGVzdCBsb29rdXBzLCB3ZSBqdXN0IHNhbXBsZSBhbG9uZyB0aGUgcGF0aCBhdCBlcXVhbCB4ICh0aW1lKSBkaXN0YW5jZS4gVXNlcyBtb3JlIG1lbW9yeSBhbmQgaXMgc2xpZ2h0bHkgbGVzcyBhY2N1cmF0ZSBmb3IgYW5jaG9ycyB0aGF0IGRvbid0IGxhbmQgb24gdGhlIHNhbXBsaW5nIHBvaW50cywgYnV0IGZvciB0aGUgdmFzdCBtYWpvcml0eSBvZiBlYXNlcyBpdCdzIGV4Y2VsbGVudCAoYW5kIGZhc3QpLlxuICAgICAgICBwID0gaSAqIGluYztcblxuICAgICAgICBpZiAocG9pbnQubnggPCBwKSB7XG4gICAgICAgICAgcG9pbnQgPSBwb2ludHNbKytqXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGExID0gcG9pbnQueSArIChwIC0gcG9pbnQueCkgLyBwb2ludC5jeCAqIHBvaW50LmN5O1xuICAgICAgICBsb29rdXBbaV0gPSB7XG4gICAgICAgICAgeDogcCxcbiAgICAgICAgICBjeDogaW5jLFxuICAgICAgICAgIHk6IGExLFxuICAgICAgICAgIGN5OiAwLFxuICAgICAgICAgIG54OiA5XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICBsb29rdXBbaSAtIDFdLmN5ID0gYTEgLSBsb29rdXBbaSAtIDFdLnk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbG9va3VwW2wgLSAxXS5jeSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0ueSAtIGExO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL3RoaXMgb3B0aW9uIGlzIG1vcmUgYWNjdXJhdGUsIGVuc3VyaW5nIHRoYXQgRVZFUlkgYW5jaG9yIGlzIGhpdCBwZXJmZWN0bHkuIENsaXBwaW5nIGFjcm9zcyBhIGJvdW5jZSwgZm9yIGV4YW1wbGUsIHdvdWxkIG5ldmVyIGhhcHBlbi5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgLy9idWlsZCBhIGxvb2t1cCB0YWJsZSBiYXNlZCBvbiB0aGUgc21hbGxlc3QgZGlzdGFuY2Ugc28gdGhhdCB3ZSBjYW4gaW5zdGFudGx5IGZpbmQgdGhlIGFwcHJvcHJpYXRlIHBvaW50ICh3ZWxsLCBpdCdsbCBlaXRoZXIgYmUgdGhhdCBwb2ludCBvciB0aGUgdmVyeSBuZXh0IG9uZSkuIFdlJ2xsIGxvb2sgdXAgYmFzZWQgb24gdGhlIGxpbmVhciBwcm9ncmVzcy4gU28gaXQncyBpdCdzIDAuNSBhbmQgdGhlIGxvb2t1cCB0YWJsZSBoYXMgMTAwIGVsZW1lbnRzLCBpdCdkIGJlIGxpa2UgbG9va3VwW01hdGguZmxvb3IoMC41ICogMTAwKV1cbiAgICAgICAgaWYgKHBvaW50Lm54IDwgaSAqIGluYykge1xuICAgICAgICAgIHBvaW50ID0gcG9pbnRzWysral07XG4gICAgICAgIH1cblxuICAgICAgICBsb29rdXBbaV0gPSBwb2ludDtcbiAgICAgIH1cblxuICAgICAgaWYgKGogPCBwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICBsb29rdXBbaSAtIDFdID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcbiAgICAgIH1cbiAgICB9IC8vdGhpcy5fY2FsY0VuZCA9IChwb2ludHNbcG9pbnRzLmxlbmd0aC0xXS55ICE9PSAxIHx8IHBvaW50c1swXS55ICE9PSAwKTsgLy9lbnN1cmVzIHRoYXQgd2UgZG9uJ3QgcnVuIGludG8gZmxvYXRpbmcgcG9pbnQgZXJyb3JzLiBBcyBsb25nIGFzIHdlJ3JlIHN0YXJ0aW5nIGF0IDAgYW5kIGVuZGluZyBhdCAxLCB0ZWxsIEdTQVAgdG8gc2tpcCB0aGUgZmluYWwgY2FsY3VsYXRpb24gYW5kIHVzZSAwLzEgYXMgdGhlIGZhY3Rvci5cblxuXG4gICAgdGhpcy5lYXNlID0gZnVuY3Rpb24gKHApIHtcbiAgICAgIHZhciBwb2ludCA9IGxvb2t1cFtwICogbCB8IDBdIHx8IGxvb2t1cFtsIC0gMV07XG5cbiAgICAgIGlmIChwb2ludC5ueCA8IHApIHtcbiAgICAgICAgcG9pbnQgPSBwb2ludC5uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9pbnQueSArIChwIC0gcG9pbnQueCkgLyBwb2ludC5jeCAqIHBvaW50LmN5O1xuICAgIH07XG5cbiAgICB0aGlzLmVhc2UuY3VzdG9tID0gdGhpcztcbiAgICB0aGlzLmlkICYmIGdzYXAgJiYgZ3NhcC5yZWdpc3RlckVhc2UodGhpcy5pZCwgdGhpcy5lYXNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZ2V0U1ZHRGF0YSA9IGZ1bmN0aW9uIGdldFNWR0RhdGEoY29uZmlnKSB7XG4gICAgcmV0dXJuIEN1c3RvbUVhc2UuZ2V0U1ZHRGF0YSh0aGlzLCBjb25maWcpO1xuICB9O1xuXG4gIEN1c3RvbUVhc2UuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGlkLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gbmV3IEN1c3RvbUVhc2UoaWQsIGRhdGEsIGNvbmZpZykuZWFzZTtcbiAgfTtcblxuICBDdXN0b21FYXNlLnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoY29yZSkge1xuICAgIGdzYXAgPSBjb3JlO1xuXG4gICAgX2luaXRDb3JlKCk7XG4gIH07XG5cbiAgQ3VzdG9tRWFzZS5nZXQgPSBmdW5jdGlvbiBnZXQoaWQpIHtcbiAgICByZXR1cm4gZ3NhcC5wYXJzZUVhc2UoaWQpO1xuICB9O1xuXG4gIEN1c3RvbUVhc2UuZ2V0U1ZHRGF0YSA9IGZ1bmN0aW9uIGdldFNWR0RhdGEoZWFzZSwgY29uZmlnKSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIHZhciB3aWR0aCA9IGNvbmZpZy53aWR0aCB8fCAxMDAsXG4gICAgICAgIGhlaWdodCA9IGNvbmZpZy5oZWlnaHQgfHwgMTAwLFxuICAgICAgICB4ID0gY29uZmlnLnggfHwgMCxcbiAgICAgICAgeSA9IChjb25maWcueSB8fCAwKSArIGhlaWdodCxcbiAgICAgICAgZSA9IGdzYXAudXRpbHMudG9BcnJheShjb25maWcucGF0aClbMF0sXG4gICAgICAgIGEsXG4gICAgICAgIHNsb3BlLFxuICAgICAgICBpLFxuICAgICAgICBpbmMsXG4gICAgICAgIHR4LFxuICAgICAgICB0eSxcbiAgICAgICAgcHJlY2lzaW9uLFxuICAgICAgICB0aHJlc2hvbGQsXG4gICAgICAgIHByZXZYLFxuICAgICAgICBwcmV2WTtcblxuICAgIGlmIChjb25maWcuaW52ZXJ0KSB7XG4gICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgeSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBlYXNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBlYXNlID0gZ3NhcC5wYXJzZUVhc2UoZWFzZSk7XG4gICAgfVxuXG4gICAgaWYgKGVhc2UuY3VzdG9tKSB7XG4gICAgICBlYXNlID0gZWFzZS5jdXN0b207XG4gICAgfVxuXG4gICAgaWYgKGVhc2UgaW5zdGFuY2VvZiBDdXN0b21FYXNlKSB7XG4gICAgICBhID0gcmF3UGF0aFRvU3RyaW5nKHRyYW5zZm9ybVJhd1BhdGgoW2Vhc2Uuc2VnbWVudF0sIHdpZHRoLCAwLCAwLCAtaGVpZ2h0LCB4LCB5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBbeCwgeV07XG4gICAgICBwcmVjaXNpb24gPSBNYXRoLm1heCg1LCAoY29uZmlnLnByZWNpc2lvbiB8fCAxKSAqIDIwMCk7XG4gICAgICBpbmMgPSAxIC8gcHJlY2lzaW9uO1xuICAgICAgcHJlY2lzaW9uICs9IDI7XG4gICAgICB0aHJlc2hvbGQgPSA1IC8gcHJlY2lzaW9uO1xuICAgICAgcHJldlggPSBfcm91bmQoeCArIGluYyAqIHdpZHRoKTtcbiAgICAgIHByZXZZID0gX3JvdW5kKHkgKyBlYXNlKGluYykgKiAtaGVpZ2h0KTtcbiAgICAgIHNsb3BlID0gKHByZXZZIC0geSkgLyAocHJldlggLSB4KTtcblxuICAgICAgZm9yIChpID0gMjsgaSA8IHByZWNpc2lvbjsgaSsrKSB7XG4gICAgICAgIHR4ID0gX3JvdW5kKHggKyBpICogaW5jICogd2lkdGgpO1xuICAgICAgICB0eSA9IF9yb3VuZCh5ICsgZWFzZShpICogaW5jKSAqIC1oZWlnaHQpO1xuXG4gICAgICAgIGlmIChNYXRoLmFicygodHkgLSBwcmV2WSkgLyAodHggLSBwcmV2WCkgLSBzbG9wZSkgPiB0aHJlc2hvbGQgfHwgaSA9PT0gcHJlY2lzaW9uIC0gMSkge1xuICAgICAgICAgIC8vb25seSBhZGQgcG9pbnRzIHdoZW4gdGhlIHNsb3BlIGNoYW5nZXMgYmV5b25kIHRoZSB0aHJlc2hvbGRcbiAgICAgICAgICBhLnB1c2gocHJldlgsIHByZXZZKTtcbiAgICAgICAgICBzbG9wZSA9ICh0eSAtIHByZXZZKSAvICh0eCAtIHByZXZYKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZYID0gdHg7XG4gICAgICAgIHByZXZZID0gdHk7XG4gICAgICB9XG5cbiAgICAgIGEgPSBcIk1cIiArIGEuam9pbihcIixcIik7XG4gICAgfVxuXG4gICAgZSAmJiBlLnNldEF0dHJpYnV0ZShcImRcIiwgYSk7XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgcmV0dXJuIEN1c3RvbUVhc2U7XG59KCk7XG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oQ3VzdG9tRWFzZSk7XG5DdXN0b21FYXNlLnZlcnNpb24gPSBcIjMuMTIuNVwiO1xuZXhwb3J0IHsgQ3VzdG9tRWFzZSBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbInN0cmluZ1RvUmF3UGF0aCIsInJhd1BhdGhUb1N0cmluZyIsInRyYW5zZm9ybVJhd1BhdGgiLCJnc2FwIiwiX2NvcmVJbml0dGVkIiwiX2dldEdTQVAiLCJ3aW5kb3ciLCJyZWdpc3RlclBsdWdpbiIsIl9pbml0Q29yZSIsInJlZ2lzdGVyRWFzZSIsIkN1c3RvbUVhc2UiLCJjcmVhdGUiLCJjb25zb2xlIiwid2FybiIsIl9iaWdOdW0iLCJfcm91bmQiLCJ2YWx1ZSIsIl9ib251c1ZhbGlkYXRlZCIsIl9udW1FeHAiLCJfbmVlZHNQYXJzaW5nRXhwIiwiX2ZpbmRNaW5pbXVtIiwidmFsdWVzIiwibCIsImxlbmd0aCIsIm1pbiIsImkiLCJfbm9ybWFsaXplIiwiaGVpZ2h0Iiwib3JpZ2luWSIsIk1hdGgiLCJtYXgiLCJ0eCIsInR5Iiwic3giLCJzeSIsImFicyIsIl9iZXppZXJUb1BvaW50cyIsIngxIiwieTEiLCJ4MiIsInkyIiwieDMiLCJ5MyIsIng0IiwieTQiLCJ0aHJlc2hvbGQiLCJwb2ludHMiLCJpbmRleCIsIngxMiIsInkxMiIsIngyMyIsInkyMyIsIngzNCIsInkzNCIsIngxMjMiLCJ5MTIzIiwieDIzNCIsInkyMzQiLCJ4MTIzNCIsInkxMjM0IiwiZHgiLCJkeSIsImQyIiwiZDMiLCJ4IiwieSIsInNwbGljZSIsImlkIiwiZGF0YSIsImNvbmZpZyIsInNldERhdGEiLCJfcHJvdG8iLCJwcm90b3R5cGUiLCJtYXRjaCIsImNsb3Nlc3QiLCJsb29rdXAiLCJwcmVjaXNpb24iLCJmYXN0IiwiYTEiLCJhMiIsImluYyIsImoiLCJwb2ludCIsInByZXZQb2ludCIsInAiLCJ0ZXN0IiwiaW5kZXhPZiIsInVuc2hpZnQiLCJwdXNoIiwic2VnbWVudCIsImN4IiwiY3kiLCJuIiwibngiLCJlYXNlIiwiY3VzdG9tIiwiZ2V0U1ZHRGF0YSIsInJlZ2lzdGVyIiwiY29yZSIsImdldCIsInBhcnNlRWFzZSIsIndpZHRoIiwiZSIsInV0aWxzIiwidG9BcnJheSIsInBhdGgiLCJhIiwic2xvcGUiLCJwcmV2WCIsInByZXZZIiwiaW52ZXJ0Iiwiam9pbiIsInNldEF0dHJpYnV0ZSIsInZlcnNpb24iLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CustomEase.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Draggable.js":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Draggable.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Draggable: function() { return /* binding */ Draggable; },\n/* harmony export */   \"default\": function() { return /* binding */ Draggable; }\n/* harmony export */ });\n/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/matrix.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/matrix.js\");\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n}\n/*!\n * Draggable 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n */ /* eslint-disable */ \nvar gsap, _win, _doc, _docElement, _body, _tempDiv, _placeholderDiv, _coreInitted, _checkPrefix, _toArray, _supportsPassive, _isTouchDevice, _touchEventLookup, _isMultiTouching, _isAndroid, InertiaPlugin, _defaultCursor, _supportsPointer, _context, _getStyleSaver, _dragCount = 0, _windowExists = function _windowExists() {\n    return typeof window !== \"undefined\";\n}, _getGSAP = function _getGSAP() {\n    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _isFunction = function _isFunction(value) {\n    return typeof value === \"function\";\n}, _isObject = function _isObject(value) {\n    return typeof value === \"object\";\n}, _isUndefined = function _isUndefined(value) {\n    return typeof value === \"undefined\";\n}, _emptyFunc = function _emptyFunc() {\n    return false;\n}, _transformProp = \"transform\", _transformOriginProp = \"transformOrigin\", _round = function _round(value) {\n    return Math.round(value * 10000) / 10000;\n}, _isArray = Array.isArray, _createElement = function _createElement(type, ns) {\n    var e = _doc.createElementNS ? _doc.createElementNS((ns || \"http://www.w3.org/1999/xhtml\").replace(/^https/, \"http\"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making \"style\" inaccessible.\n    return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://gsap.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).\n}, _RAD2DEG = 180 / Math.PI, _bigNum = 1e20, _identityMatrix = new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D(), _getTime = Date.now || function() {\n    return new Date().getTime();\n}, _renderQueue = [], _lookup = {}, //when a Draggable is created, the target gets a unique _gsDragID property that allows gets associated with the Draggable instance for quick lookups in Draggable.get(). This avoids circular references that could cause gc problems.\n_lookupCount = 0, _clickableTagExp = /^(?:a|input|textarea|button|select)$/i, _lastDragTime = 0, _temp1 = {}, // a simple object we reuse and populate (usually x/y properties) to conserve memory and improve performance.\n_windowProxy = {}, //memory/performance optimization - we reuse this object during autoScroll to store window-related bounds/offsets.\n_copy = function _copy(obj, factor) {\n    var copy = {}, p;\n    for(p in obj){\n        copy[p] = factor ? obj[p] * factor : obj[p];\n    }\n    return copy;\n}, _extend = function _extend(obj, defaults) {\n    for(var p in defaults){\n        if (!(p in obj)) {\n            obj[p] = defaults[p];\n        }\n    }\n    return obj;\n}, _setTouchActionForAllDescendants = function _setTouchActionForAllDescendants(elements, value) {\n    var i = elements.length, children;\n    while(i--){\n        value ? elements[i].style.touchAction = value : elements[i].style.removeProperty(\"touch-action\");\n        children = elements[i].children;\n        children && children.length && _setTouchActionForAllDescendants(children, value);\n    }\n}, _renderQueueTick = function _renderQueueTick() {\n    return _renderQueue.forEach(function(func) {\n        return func();\n    });\n}, _addToRenderQueue = function _addToRenderQueue(func) {\n    _renderQueue.push(func);\n    if (_renderQueue.length === 1) {\n        gsap.ticker.add(_renderQueueTick);\n    }\n}, _renderQueueTimeout = function _renderQueueTimeout() {\n    return !_renderQueue.length && gsap.ticker.remove(_renderQueueTick);\n}, _removeFromRenderQueue = function _removeFromRenderQueue(func) {\n    var i = _renderQueue.length;\n    while(i--){\n        if (_renderQueue[i] === func) {\n            _renderQueue.splice(i, 1);\n        }\n    }\n    gsap.to(_renderQueueTimeout, {\n        overwrite: true,\n        delay: 15,\n        duration: 0,\n        onComplete: _renderQueueTimeout,\n        data: \"_draggable\"\n    }); //remove the \"tick\" listener only after the render queue is empty for 15 seconds (to improve performance). Adding/removing it constantly for every click/touch wouldn't deliver optimal speed, and we also don't want the ticker to keep calling the render method when things are idle for long periods of time (we want to improve battery life on mobile devices).\n}, _setDefaults = function _setDefaults(obj, defaults) {\n    for(var p in defaults){\n        if (!(p in obj)) {\n            obj[p] = defaults[p];\n        }\n    }\n    return obj;\n}, _addListener = function _addListener(element, type, func, capture) {\n    if (element.addEventListener) {\n        var touchType = _touchEventLookup[type];\n        capture = capture || (_supportsPassive ? {\n            passive: false\n        } : null);\n        element.addEventListener(touchType || type, func, capture);\n        touchType && type !== touchType && element.addEventListener(type, func, capture); //some browsers actually support both, so must we. But pointer events cover all.\n    }\n}, _removeListener = function _removeListener(element, type, func, capture) {\n    if (element.removeEventListener) {\n        var touchType = _touchEventLookup[type];\n        element.removeEventListener(touchType || type, func, capture);\n        touchType && type !== touchType && element.removeEventListener(type, func, capture);\n    }\n}, _preventDefault = function _preventDefault(event) {\n    event.preventDefault && event.preventDefault();\n    event.preventManipulation && event.preventManipulation(); //for some Microsoft browsers\n}, _hasTouchID = function _hasTouchID(list, ID) {\n    var i = list.length;\n    while(i--){\n        if (list[i].identifier === ID) {\n            return true;\n        }\n    }\n}, _onMultiTouchDocumentEnd = function _onMultiTouchDocumentEnd(event) {\n    _isMultiTouching = event.touches && _dragCount < event.touches.length;\n    _removeListener(event.target, \"touchend\", _onMultiTouchDocumentEnd);\n}, _onMultiTouchDocument = function _onMultiTouchDocument(event) {\n    _isMultiTouching = event.touches && _dragCount < event.touches.length;\n    _addListener(event.target, \"touchend\", _onMultiTouchDocumentEnd);\n}, _getDocScrollTop = function _getDocScrollTop(doc) {\n    return _win.pageYOffset || doc.scrollTop || doc.documentElement.scrollTop || doc.body.scrollTop || 0;\n}, _getDocScrollLeft = function _getDocScrollLeft(doc) {\n    return _win.pageXOffset || doc.scrollLeft || doc.documentElement.scrollLeft || doc.body.scrollLeft || 0;\n}, _addScrollListener = function _addScrollListener(e, callback) {\n    _addListener(e, \"scroll\", callback);\n    if (!_isRoot(e.parentNode)) {\n        _addScrollListener(e.parentNode, callback);\n    }\n}, _removeScrollListener = function _removeScrollListener(e, callback) {\n    _removeListener(e, \"scroll\", callback);\n    if (!_isRoot(e.parentNode)) {\n        _removeScrollListener(e.parentNode, callback);\n    }\n}, _isRoot = function _isRoot(e) {\n    return !!(!e || e === _docElement || e.nodeType === 9 || e === _doc.body || e === _win || !e.nodeType || !e.parentNode);\n}, _getMaxScroll = function _getMaxScroll(element, axis) {\n    var dim = axis === \"x\" ? \"Width\" : \"Height\", scroll = \"scroll\" + dim, client = \"client\" + dim;\n    return Math.max(0, _isRoot(element) ? Math.max(_docElement[scroll], _body[scroll]) - (_win[\"inner\" + dim] || _docElement[client] || _body[client]) : element[scroll] - element[client]);\n}, _recordMaxScrolls = function _recordMaxScrolls(e, skipCurrent) {\n    //records _gsMaxScrollX and _gsMaxScrollY properties for the element and all ancestors up the chain so that we can cap it, otherwise dragging beyond the edges with autoScroll on can endlessly scroll.\n    var x = _getMaxScroll(e, \"x\"), y = _getMaxScroll(e, \"y\");\n    if (_isRoot(e)) {\n        e = _windowProxy;\n    } else {\n        _recordMaxScrolls(e.parentNode, skipCurrent);\n    }\n    e._gsMaxScrollX = x;\n    e._gsMaxScrollY = y;\n    if (!skipCurrent) {\n        e._gsScrollX = e.scrollLeft || 0;\n        e._gsScrollY = e.scrollTop || 0;\n    }\n}, _setStyle = function _setStyle(element, property, value) {\n    var style = element.style;\n    if (!style) {\n        return;\n    }\n    if (_isUndefined(style[property])) {\n        property = _checkPrefix(property, element) || property;\n    }\n    if (value == null) {\n        style.removeProperty && style.removeProperty(property.replace(/([A-Z])/g, \"-$1\").toLowerCase());\n    } else {\n        style[property] = value;\n    }\n}, _getComputedStyle = function _getComputedStyle(element) {\n    return _win.getComputedStyle(element instanceof Element ? element : element.host || (element.parentNode || {}).host || element);\n}, //the \"host\" stuff helps to accommodate ShadowDom objects.\n_tempRect = {}, //reuse to reduce garbage collection tasks\n_parseRect = function _parseRect(e) {\n    //accepts a DOM element, a mouse event, or a rectangle object and returns the corresponding rectangle with left, right, width, height, top, and bottom properties\n    if (e === _win) {\n        _tempRect.left = _tempRect.top = 0;\n        _tempRect.width = _tempRect.right = _docElement.clientWidth || e.innerWidth || _body.clientWidth || 0;\n        _tempRect.height = _tempRect.bottom = (e.innerHeight || 0) - 20 < _docElement.clientHeight ? _docElement.clientHeight : e.innerHeight || _body.clientHeight || 0;\n        return _tempRect;\n    }\n    var doc = e.ownerDocument || _doc, r = !_isUndefined(e.pageX) ? {\n        left: e.pageX - _getDocScrollLeft(doc),\n        top: e.pageY - _getDocScrollTop(doc),\n        right: e.pageX - _getDocScrollLeft(doc) + 1,\n        bottom: e.pageY - _getDocScrollTop(doc) + 1\n    } : !e.nodeType && !_isUndefined(e.left) && !_isUndefined(e.top) ? e : _toArray(e)[0].getBoundingClientRect();\n    if (_isUndefined(r.right) && !_isUndefined(r.width)) {\n        r.right = r.left + r.width;\n        r.bottom = r.top + r.height;\n    } else if (_isUndefined(r.width)) {\n        //some browsers don't include width and height properties. We can't just set them directly on r because some browsers throw errors, so create a new generic object.\n        r = {\n            width: r.right - r.left,\n            height: r.bottom - r.top,\n            right: r.right,\n            left: r.left,\n            bottom: r.bottom,\n            top: r.top\n        };\n    }\n    return r;\n}, _dispatchEvent = function _dispatchEvent(target, type, callbackName) {\n    var vars = target.vars, callback = vars[callbackName], listeners = target._listeners[type], result;\n    if (_isFunction(callback)) {\n        result = callback.apply(vars.callbackScope || target, vars[callbackName + \"Params\"] || [\n            target.pointerEvent\n        ]);\n    }\n    if (listeners && target.dispatchEvent(type) === false) {\n        result = false;\n    }\n    return result;\n}, _getBounds = function _getBounds(target, context) {\n    //accepts any of the following: a DOM element, jQuery object, selector text, or an object defining bounds as {top, left, width, height} or {minX, maxX, minY, maxY}. Returns an object with left, top, width, and height properties.\n    var e = _toArray(target)[0], top, left, offset;\n    if (!e.nodeType && e !== _win) {\n        if (!_isUndefined(target.left)) {\n            offset = {\n                x: 0,\n                y: 0\n            }; //_getOffsetTransformOrigin(context); //the bounds should be relative to the origin\n            return {\n                left: target.left - offset.x,\n                top: target.top - offset.y,\n                width: target.width,\n                height: target.height\n            };\n        }\n        left = target.min || target.minX || target.minRotation || 0;\n        top = target.min || target.minY || 0;\n        return {\n            left: left,\n            top: top,\n            width: (target.max || target.maxX || target.maxRotation || 0) - left,\n            height: (target.max || target.maxY || 0) - top\n        };\n    }\n    return _getElementBounds(e, context);\n}, _point1 = {}, //we reuse to minimize garbage collection tasks.\n_getElementBounds = function _getElementBounds(element, context) {\n    context = _toArray(context)[0];\n    var isSVG = element.getBBox && element.ownerSVGElement, doc = element.ownerDocument || _doc, left, right, top, bottom, matrix, p1, p2, p3, p4, bbox, width, height, cs;\n    if (element === _win) {\n        top = _getDocScrollTop(doc);\n        left = _getDocScrollLeft(doc);\n        right = left + (doc.documentElement.clientWidth || element.innerWidth || doc.body.clientWidth || 0);\n        bottom = top + ((element.innerHeight || 0) - 20 < doc.documentElement.clientHeight ? doc.documentElement.clientHeight : element.innerHeight || doc.body.clientHeight || 0); //some browsers (like Firefox) ignore absolutely positioned elements, and collapse the height of the documentElement, so it could be 8px, for example, if you have just an absolutely positioned div. In that case, we use the innerHeight to resolve this.\n    } else if (context === _win || _isUndefined(context)) {\n        return element.getBoundingClientRect();\n    } else {\n        left = top = 0;\n        if (isSVG) {\n            bbox = element.getBBox();\n            width = bbox.width;\n            height = bbox.height;\n        } else {\n            if (element.viewBox && (bbox = element.viewBox.baseVal)) {\n                left = bbox.x || 0;\n                top = bbox.y || 0;\n                width = bbox.width;\n                height = bbox.height;\n            }\n            if (!width) {\n                cs = _getComputedStyle(element);\n                bbox = cs.boxSizing === \"border-box\";\n                width = (parseFloat(cs.width) || element.clientWidth || 0) + (bbox ? 0 : parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth));\n                height = (parseFloat(cs.height) || element.clientHeight || 0) + (bbox ? 0 : parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth));\n            }\n        }\n        right = width;\n        bottom = height;\n    }\n    if (element === context) {\n        return {\n            left: left,\n            top: top,\n            width: right - left,\n            height: bottom - top\n        };\n    }\n    matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(context, true).multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(element));\n    p1 = matrix.apply({\n        x: left,\n        y: top\n    });\n    p2 = matrix.apply({\n        x: right,\n        y: top\n    });\n    p3 = matrix.apply({\n        x: right,\n        y: bottom\n    });\n    p4 = matrix.apply({\n        x: left,\n        y: bottom\n    });\n    left = Math.min(p1.x, p2.x, p3.x, p4.x);\n    top = Math.min(p1.y, p2.y, p3.y, p4.y);\n    return {\n        left: left,\n        top: top,\n        width: Math.max(p1.x, p2.x, p3.x, p4.x) - left,\n        height: Math.max(p1.y, p2.y, p3.y, p4.y) - top\n    };\n}, _parseInertia = function _parseInertia(draggable, snap, max, min, factor, forceZeroVelocity) {\n    var vars = {}, a, i, l;\n    if (snap) {\n        if (factor !== 1 && snap instanceof Array) {\n            //some data must be altered to make sense, like if the user passes in an array of rotational values in degrees, we must convert it to radians. Or for scrollLeft and scrollTop, we invert the values.\n            vars.end = a = [];\n            l = snap.length;\n            if (_isObject(snap[0])) {\n                //if the array is populated with objects, like points ({x:100, y:200}), make copies before multiplying by the factor, otherwise we'll mess up the originals and the user may reuse it elsewhere.\n                for(i = 0; i < l; i++){\n                    a[i] = _copy(snap[i], factor);\n                }\n            } else {\n                for(i = 0; i < l; i++){\n                    a[i] = snap[i] * factor;\n                }\n            }\n            max += 1.1; //allow 1.1 pixels of wiggle room when snapping in order to work around some browser inconsistencies in the way bounds are reported which can make them roughly a pixel off. For example, if \"snap:[-$('#menu').width(), 0]\" was defined and #menu had a wrapper that was used as the bounds, some browsers would be one pixel off, making the minimum -752 for example when snap was [-753,0], thus instead of snapping to -753, it would snap to 0 since -753 was below the minimum.\n            min -= 1.1;\n        } else if (_isFunction(snap)) {\n            vars.end = function(value) {\n                var result = snap.call(draggable, value), copy, p;\n                if (factor !== 1) {\n                    if (_isObject(result)) {\n                        copy = {};\n                        for(p in result){\n                            copy[p] = result[p] * factor;\n                        }\n                        result = copy;\n                    } else {\n                        result *= factor;\n                    }\n                }\n                return result; //we need to ensure that we can scope the function call to the Draggable instance itself so that users can access important values like maxX, minX, maxY, minY, x, and y from within that function.\n            };\n        } else {\n            vars.end = snap;\n        }\n    }\n    if (max || max === 0) {\n        vars.max = max;\n    }\n    if (min || min === 0) {\n        vars.min = min;\n    }\n    if (forceZeroVelocity) {\n        vars.velocity = 0;\n    }\n    return vars;\n}, _isClickable = function _isClickable(element) {\n    //sometimes it's convenient to mark an element as clickable by adding a data-clickable=\"true\" attribute (in which case we won't preventDefault() the mouse/touch event). This method checks if the element is an <a>, <input>, or <button> or has the data-clickable or contentEditable attribute set to true (or any of its parent elements).\n    var data;\n    return !element || !element.getAttribute || element === _body ? false : (data = element.getAttribute(\"data-clickable\")) === \"true\" || data !== \"false\" && (_clickableTagExp.test(element.nodeName + \"\") || element.getAttribute(\"contentEditable\") === \"true\") ? true : _isClickable(element.parentNode);\n}, _setSelectable = function _setSelectable(elements, selectable) {\n    var i = elements.length, e;\n    while(i--){\n        e = elements[i];\n        e.ondragstart = e.onselectstart = selectable ? null : _emptyFunc;\n        gsap.set(e, {\n            lazy: true,\n            userSelect: selectable ? \"text\" : \"none\"\n        });\n    }\n}, _isFixed = function _isFixed(element) {\n    if (_getComputedStyle(element).position === \"fixed\") {\n        return true;\n    }\n    element = element.parentNode;\n    if (element && element.nodeType === 1) {\n        // avoid document fragments which will throw an error.\n        return _isFixed(element);\n    }\n}, _supports3D, _addPaddingBR, //The ScrollProxy class wraps an element's contents into another div (we call it \"content\") that we either add padding when necessary or apply a translate3d() transform in order to overscroll (scroll past the boundaries). This allows us to simply set the scrollTop/scrollLeft (or top/left for easier reverse-axis orientation, which is what we do in Draggable) and it'll do all the work for us. For example, if we tried setting scrollTop to -100 on a normal DOM element, it wouldn't work - it'd look the same as setting it to 0, but if we set scrollTop of a ScrollProxy to -100, it'll give the correct appearance by either setting paddingTop of the wrapper to 100 or applying a 100-pixel translateY.\nScrollProxy = function ScrollProxy(element, vars) {\n    element = gsap.utils.toArray(element)[0];\n    vars = vars || {};\n    var content = document.createElement(\"div\"), style = content.style, node = element.firstChild, offsetTop = 0, offsetLeft = 0, prevTop = element.scrollTop, prevLeft = element.scrollLeft, scrollWidth = element.scrollWidth, scrollHeight = element.scrollHeight, extraPadRight = 0, maxLeft = 0, maxTop = 0, elementWidth, elementHeight, contentHeight, nextNode, transformStart, transformEnd;\n    if (_supports3D && vars.force3D !== false) {\n        transformStart = \"translate3d(\";\n        transformEnd = \"px,0px)\";\n    } else if (_transformProp) {\n        transformStart = \"translate(\";\n        transformEnd = \"px)\";\n    }\n    this.scrollTop = function(value, force) {\n        if (!arguments.length) {\n            return -this.top();\n        }\n        this.top(-value, force);\n    };\n    this.scrollLeft = function(value, force) {\n        if (!arguments.length) {\n            return -this.left();\n        }\n        this.left(-value, force);\n    };\n    this.left = function(value, force) {\n        if (!arguments.length) {\n            return -(element.scrollLeft + offsetLeft);\n        }\n        var dif = element.scrollLeft - prevLeft, oldOffset = offsetLeft;\n        if ((dif > 2 || dif < -2) && !force) {\n            //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.\n            prevLeft = element.scrollLeft;\n            gsap.killTweensOf(this, {\n                left: 1,\n                scrollLeft: 1\n            });\n            this.left(-prevLeft);\n            if (vars.onKill) {\n                vars.onKill();\n            }\n            return;\n        }\n        value = -value; //invert because scrolling works in the opposite direction\n        if (value < 0) {\n            offsetLeft = value - 0.5 | 0;\n            value = 0;\n        } else if (value > maxLeft) {\n            offsetLeft = value - maxLeft | 0;\n            value = maxLeft;\n        } else {\n            offsetLeft = 0;\n        }\n        if (offsetLeft || oldOffset) {\n            if (!this._skip) {\n                style[_transformProp] = transformStart + -offsetLeft + \"px,\" + -offsetTop + transformEnd;\n            }\n            if (offsetLeft + extraPadRight >= 0) {\n                style.paddingRight = offsetLeft + extraPadRight + \"px\";\n            }\n        }\n        element.scrollLeft = value | 0;\n        prevLeft = element.scrollLeft; //don't merge this with the line above because some browsers adjust the scrollLeft after it's set, so in order to be 100% accurate in tracking it, we need to ask the browser to report it.\n    };\n    this.top = function(value, force) {\n        if (!arguments.length) {\n            return -(element.scrollTop + offsetTop);\n        }\n        var dif = element.scrollTop - prevTop, oldOffset = offsetTop;\n        if ((dif > 2 || dif < -2) && !force) {\n            //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.\n            prevTop = element.scrollTop;\n            gsap.killTweensOf(this, {\n                top: 1,\n                scrollTop: 1\n            });\n            this.top(-prevTop);\n            if (vars.onKill) {\n                vars.onKill();\n            }\n            return;\n        }\n        value = -value; //invert because scrolling works in the opposite direction\n        if (value < 0) {\n            offsetTop = value - 0.5 | 0;\n            value = 0;\n        } else if (value > maxTop) {\n            offsetTop = value - maxTop | 0;\n            value = maxTop;\n        } else {\n            offsetTop = 0;\n        }\n        if (offsetTop || oldOffset) {\n            if (!this._skip) {\n                style[_transformProp] = transformStart + -offsetLeft + \"px,\" + -offsetTop + transformEnd;\n            }\n        }\n        element.scrollTop = value | 0;\n        prevTop = element.scrollTop;\n    };\n    this.maxScrollTop = function() {\n        return maxTop;\n    };\n    this.maxScrollLeft = function() {\n        return maxLeft;\n    };\n    this.disable = function() {\n        node = content.firstChild;\n        while(node){\n            nextNode = node.nextSibling;\n            element.appendChild(node);\n            node = nextNode;\n        }\n        if (element === content.parentNode) {\n            //in case disable() is called when it's already disabled.\n            element.removeChild(content);\n        }\n    };\n    this.enable = function() {\n        node = element.firstChild;\n        if (node === content) {\n            return;\n        }\n        while(node){\n            nextNode = node.nextSibling;\n            content.appendChild(node);\n            node = nextNode;\n        }\n        element.appendChild(content);\n        this.calibrate();\n    };\n    this.calibrate = function(force) {\n        var widthMatches = element.clientWidth === elementWidth, cs, x, y;\n        prevTop = element.scrollTop;\n        prevLeft = element.scrollLeft;\n        if (widthMatches && element.clientHeight === elementHeight && content.offsetHeight === contentHeight && scrollWidth === element.scrollWidth && scrollHeight === element.scrollHeight && !force) {\n            return; //no need to recalculate things if the width and height haven't changed.\n        }\n        if (offsetTop || offsetLeft) {\n            x = this.left();\n            y = this.top();\n            this.left(-element.scrollLeft);\n            this.top(-element.scrollTop);\n        }\n        cs = _getComputedStyle(element); //first, we need to remove any width constraints to see how the content naturally flows so that we can see if it's wider than the containing element. If so, we've got to record the amount of overage so that we can apply that as padding in order for browsers to correctly handle things. Then we switch back to a width of 100% (without that, some browsers don't flow the content correctly)\n        if (!widthMatches || force) {\n            style.display = \"block\";\n            style.width = \"auto\";\n            style.paddingRight = \"0px\";\n            extraPadRight = Math.max(0, element.scrollWidth - element.clientWidth); //if the content is wider than the container, we need to add the paddingLeft and paddingRight in order for things to behave correctly.\n            if (extraPadRight) {\n                extraPadRight += parseFloat(cs.paddingLeft) + (_addPaddingBR ? parseFloat(cs.paddingRight) : 0);\n            }\n        }\n        style.display = \"inline-block\";\n        style.position = \"relative\";\n        style.overflow = \"visible\";\n        style.verticalAlign = \"top\";\n        style.boxSizing = \"content-box\";\n        style.width = \"100%\";\n        style.paddingRight = extraPadRight + \"px\"; //some browsers neglect to factor in the bottom padding when calculating the scrollHeight, so we need to add that padding to the content when that happens. Allow a 2px margin for error\n        if (_addPaddingBR) {\n            style.paddingBottom = cs.paddingBottom;\n        }\n        elementWidth = element.clientWidth;\n        elementHeight = element.clientHeight;\n        scrollWidth = element.scrollWidth;\n        scrollHeight = element.scrollHeight;\n        maxLeft = element.scrollWidth - elementWidth;\n        maxTop = element.scrollHeight - elementHeight;\n        contentHeight = content.offsetHeight;\n        style.display = \"block\";\n        if (x || y) {\n            this.left(x);\n            this.top(y);\n        }\n    };\n    this.content = content;\n    this.element = element;\n    this._skip = false;\n    this.enable();\n}, _initCore = function _initCore(required) {\n    if (_windowExists() && document.body) {\n        var nav = window && window.navigator;\n        _win = window;\n        _doc = document;\n        _docElement = _doc.documentElement;\n        _body = _doc.body;\n        _tempDiv = _createElement(\"div\");\n        _supportsPointer = !!window.PointerEvent;\n        _placeholderDiv = _createElement(\"div\");\n        _placeholderDiv.style.cssText = \"visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;cursor:grab\";\n        _defaultCursor = _placeholderDiv.style.cursor === \"grab\" ? \"grab\" : \"move\";\n        _isAndroid = nav && nav.userAgent.toLowerCase().indexOf(\"android\") !== -1; //Android handles touch events in an odd way and it's virtually impossible to \"feature test\" so we resort to UA sniffing\n        _isTouchDevice = \"ontouchstart\" in _docElement && \"orientation\" in _win || nav && (nav.MaxTouchPoints > 0 || nav.msMaxTouchPoints > 0);\n        _addPaddingBR = function() {\n            //this function is in charge of analyzing browser behavior related to padding. It sets the _addPaddingBR to true if the browser doesn't normally factor in the bottom or right padding on the element inside the scrolling area, and it sets _addPaddingLeft to true if it's a browser that requires the extra offset (offsetLeft) to be added to the paddingRight (like Opera).\n            var div = _createElement(\"div\"), child = _createElement(\"div\"), childStyle = child.style, parent = _body, val;\n            childStyle.display = \"inline-block\";\n            childStyle.position = \"relative\";\n            div.style.cssText = \"width:90px;height:40px;padding:10px;overflow:auto;visibility:hidden\";\n            div.appendChild(child);\n            parent.appendChild(div);\n            val = child.offsetHeight + 18 > div.scrollHeight; //div.scrollHeight should be child.offsetHeight + 20 because of the 10px of padding on each side, but some browsers ignore one side. We allow a 2px margin of error.\n            parent.removeChild(div);\n            return val;\n        }();\n        _touchEventLookup = function(types) {\n            //we create an object that makes it easy to translate touch event types into their \"pointer\" counterparts if we're in a browser that uses those instead. Like IE10 uses \"MSPointerDown\" instead of \"touchstart\", for example.\n            var standard = types.split(\",\"), converted = (\"onpointerdown\" in _tempDiv ? \"pointerdown,pointermove,pointerup,pointercancel\" : \"onmspointerdown\" in _tempDiv ? \"MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel\" : types).split(\",\"), obj = {}, i = 4;\n            while(--i > -1){\n                obj[standard[i]] = converted[i];\n                obj[converted[i]] = standard[i];\n            } //to avoid problems in iOS 9, test to see if the browser supports the \"passive\" option on addEventListener().\n            try {\n                _docElement.addEventListener(\"test\", null, Object.defineProperty({}, \"passive\", {\n                    get: function get() {\n                        _supportsPassive = 1;\n                    }\n                }));\n            } catch (e) {}\n            return obj;\n        }(\"touchstart,touchmove,touchend,touchcancel\");\n        _addListener(_doc, \"touchcancel\", _emptyFunc); //some older Android devices intermittently stop dispatching \"touchmove\" events if we don't listen for \"touchcancel\" on the document. Very strange indeed.\n        _addListener(_win, \"touchmove\", _emptyFunc); //works around Safari bugs that still allow the page to scroll even when we preventDefault() on the touchmove event.\n        _body && _body.addEventListener(\"touchstart\", _emptyFunc); //works around Safari bug: https://gsap.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n        _addListener(_doc, \"contextmenu\", function() {\n            for(var p in _lookup){\n                if (_lookup[p].isPressed) {\n                    _lookup[p].endDrag();\n                }\n            }\n        });\n        gsap = _coreInitted = _getGSAP();\n    }\n    if (gsap) {\n        InertiaPlugin = gsap.plugins.inertia;\n        _context = gsap.core.context || function() {};\n        _checkPrefix = gsap.utils.checkPrefix;\n        _transformProp = _checkPrefix(_transformProp);\n        _transformOriginProp = _checkPrefix(_transformOriginProp);\n        _toArray = gsap.utils.toArray;\n        _getStyleSaver = gsap.core.getStyleSaver;\n        _supports3D = !!_checkPrefix(\"perspective\");\n    } else if (required) {\n        console.warn(\"Please gsap.registerPlugin(Draggable)\");\n    }\n};\nvar EventDispatcher = /*#__PURE__*/ function() {\n    function EventDispatcher(target) {\n        this._listeners = {};\n        this.target = target || this;\n    }\n    var _proto = EventDispatcher.prototype;\n    _proto.addEventListener = function addEventListener(type, callback) {\n        var list = this._listeners[type] || (this._listeners[type] = []);\n        if (!~list.indexOf(callback)) {\n            list.push(callback);\n        }\n    };\n    _proto.removeEventListener = function removeEventListener(type, callback) {\n        var list = this._listeners[type], i = list && list.indexOf(callback);\n        i >= 0 && list.splice(i, 1);\n    };\n    _proto.dispatchEvent = function dispatchEvent(type) {\n        var _this = this;\n        var result;\n        (this._listeners[type] || []).forEach(function(callback) {\n            return callback.call(_this, {\n                type: type,\n                target: _this.target\n            }) === false && (result = false);\n        });\n        return result; //if any of the callbacks return false, pass that along.\n    };\n    return EventDispatcher;\n}();\nvar Draggable = /*#__PURE__*/ function(_EventDispatcher) {\n    _inheritsLoose(Draggable, _EventDispatcher);\n    function Draggable(target, vars) {\n        var _this2;\n        _this2 = _EventDispatcher.call(this) || this;\n        _coreInitted || _initCore(1);\n        target = _toArray(target)[0]; //in case the target is a selector object or selector text\n        _this2.styles = _getStyleSaver && _getStyleSaver(target, \"transform,left,top\");\n        if (!InertiaPlugin) {\n            InertiaPlugin = gsap.plugins.inertia;\n        }\n        _this2.vars = vars = _copy(vars || {});\n        _this2.target = target;\n        _this2.x = _this2.y = _this2.rotation = 0;\n        _this2.dragResistance = parseFloat(vars.dragResistance) || 0;\n        _this2.edgeResistance = isNaN(vars.edgeResistance) ? 1 : parseFloat(vars.edgeResistance) || 0;\n        _this2.lockAxis = vars.lockAxis;\n        _this2.autoScroll = vars.autoScroll || 0;\n        _this2.lockedAxis = null;\n        _this2.allowEventDefault = !!vars.allowEventDefault;\n        gsap.getProperty(target, \"x\"); // to ensure that transforms are instantiated.\n        var type = (vars.type || \"x,y\").toLowerCase(), xyMode = ~type.indexOf(\"x\") || ~type.indexOf(\"y\"), rotationMode = type.indexOf(\"rotation\") !== -1, xProp = rotationMode ? \"rotation\" : xyMode ? \"x\" : \"left\", yProp = xyMode ? \"y\" : \"top\", allowX = !!(~type.indexOf(\"x\") || ~type.indexOf(\"left\") || type === \"scroll\"), allowY = !!(~type.indexOf(\"y\") || ~type.indexOf(\"top\") || type === \"scroll\"), minimumMovement = vars.minimumMovement || 2, self = _assertThisInitialized(_this2), triggers = _toArray(vars.trigger || vars.handle || target), killProps = {}, dragEndTime = 0, checkAutoScrollBounds = false, autoScrollMarginTop = vars.autoScrollMarginTop || 40, autoScrollMarginRight = vars.autoScrollMarginRight || 40, autoScrollMarginBottom = vars.autoScrollMarginBottom || 40, autoScrollMarginLeft = vars.autoScrollMarginLeft || 40, isClickable = vars.clickableTest || _isClickable, clickTime = 0, gsCache = target._gsap || gsap.core.getCache(target), isFixed = _isFixed(target), getPropAsNum = function getPropAsNum(property, unit) {\n            return parseFloat(gsCache.get(target, property, unit));\n        }, ownerDoc = target.ownerDocument || _doc, enabled, scrollProxy, startPointerX, startPointerY, startElementX, startElementY, hasBounds, hasDragCallback, hasMoveCallback, maxX, minX, maxY, minY, touch, touchID, rotationOrigin, dirty, old, snapX, snapY, snapXY, isClicking, touchEventTarget, matrix, interrupted, allowNativeTouchScrolling, touchDragAxis, isDispatching, clickDispatch, trustedClickDispatch, isPreventingDefault, innerMatrix, dragged, onContextMenu = function onContextMenu(e) {\n            //used to prevent long-touch from triggering a context menu.\n            // (self.isPressed && e.which < 2) && self.endDrag() // previously ended drag when context menu was triggered, but instead we should just stop propagation and prevent the default event behavior.\n            _preventDefault(e);\n            e.stopImmediatePropagation && e.stopImmediatePropagation();\n            return false;\n        }, //this method gets called on every tick of TweenLite.ticker which allows us to synchronize the renders to the core engine (which is typically synchronized with the display refresh via requestAnimationFrame). This is an optimization - it's better than applying the values inside the \"mousemove\" or \"touchmove\" event handler which may get called many times inbetween refreshes.\n        render = function render(suppressEvents) {\n            if (self.autoScroll && self.isDragging && (checkAutoScrollBounds || dirty)) {\n                var e = target, autoScrollFactor = self.autoScroll * 15, //multiplying by 15 just gives us a better \"feel\" speed-wise.\n                parent, isRoot, rect, pointerX, pointerY, changeX, changeY, gap;\n                checkAutoScrollBounds = false;\n                _windowProxy.scrollTop = _win.pageYOffset != null ? _win.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;\n                _windowProxy.scrollLeft = _win.pageXOffset != null ? _win.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;\n                pointerX = self.pointerX - _windowProxy.scrollLeft;\n                pointerY = self.pointerY - _windowProxy.scrollTop;\n                while(e && !isRoot){\n                    //walk up the chain and sense wherever the pointer is within 40px of an edge that's scrollable.\n                    isRoot = _isRoot(e.parentNode);\n                    parent = isRoot ? _windowProxy : e.parentNode;\n                    rect = isRoot ? {\n                        bottom: Math.max(_docElement.clientHeight, _win.innerHeight || 0),\n                        right: Math.max(_docElement.clientWidth, _win.innerWidth || 0),\n                        left: 0,\n                        top: 0\n                    } : parent.getBoundingClientRect();\n                    changeX = changeY = 0;\n                    if (allowY) {\n                        gap = parent._gsMaxScrollY - parent.scrollTop;\n                        if (gap < 0) {\n                            changeY = gap;\n                        } else if (pointerY > rect.bottom - autoScrollMarginBottom && gap) {\n                            checkAutoScrollBounds = true;\n                            changeY = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.bottom - pointerY) / autoScrollMarginBottom) | 0);\n                        } else if (pointerY < rect.top + autoScrollMarginTop && parent.scrollTop) {\n                            checkAutoScrollBounds = true;\n                            changeY = -Math.min(parent.scrollTop, autoScrollFactor * (1 - Math.max(0, pointerY - rect.top) / autoScrollMarginTop) | 0);\n                        }\n                        if (changeY) {\n                            parent.scrollTop += changeY;\n                        }\n                    }\n                    if (allowX) {\n                        gap = parent._gsMaxScrollX - parent.scrollLeft;\n                        if (gap < 0) {\n                            changeX = gap;\n                        } else if (pointerX > rect.right - autoScrollMarginRight && gap) {\n                            checkAutoScrollBounds = true;\n                            changeX = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.right - pointerX) / autoScrollMarginRight) | 0);\n                        } else if (pointerX < rect.left + autoScrollMarginLeft && parent.scrollLeft) {\n                            checkAutoScrollBounds = true;\n                            changeX = -Math.min(parent.scrollLeft, autoScrollFactor * (1 - Math.max(0, pointerX - rect.left) / autoScrollMarginLeft) | 0);\n                        }\n                        if (changeX) {\n                            parent.scrollLeft += changeX;\n                        }\n                    }\n                    if (isRoot && (changeX || changeY)) {\n                        _win.scrollTo(parent.scrollLeft, parent.scrollTop);\n                        setPointerPosition(self.pointerX + changeX, self.pointerY + changeY);\n                    }\n                    e = parent;\n                }\n            }\n            if (dirty) {\n                var x = self.x, y = self.y;\n                if (rotationMode) {\n                    self.deltaX = x - parseFloat(gsCache.rotation);\n                    self.rotation = x;\n                    gsCache.rotation = x + \"deg\";\n                    gsCache.renderTransform(1, gsCache);\n                } else {\n                    if (scrollProxy) {\n                        if (allowY) {\n                            self.deltaY = y - scrollProxy.top();\n                            scrollProxy.top(y);\n                        }\n                        if (allowX) {\n                            self.deltaX = x - scrollProxy.left();\n                            scrollProxy.left(x);\n                        }\n                    } else if (xyMode) {\n                        if (allowY) {\n                            self.deltaY = y - parseFloat(gsCache.y);\n                            gsCache.y = y + \"px\";\n                        }\n                        if (allowX) {\n                            self.deltaX = x - parseFloat(gsCache.x);\n                            gsCache.x = x + \"px\";\n                        }\n                        gsCache.renderTransform(1, gsCache);\n                    } else {\n                        if (allowY) {\n                            self.deltaY = y - parseFloat(target.style.top || 0);\n                            target.style.top = y + \"px\";\n                        }\n                        if (allowX) {\n                            self.deltaX = x - parseFloat(target.style.left || 0);\n                            target.style.left = x + \"px\";\n                        }\n                    }\n                }\n                if (hasDragCallback && !suppressEvents && !isDispatching) {\n                    isDispatching = true; //in case onDrag has an update() call (avoid endless loop)\n                    if (_dispatchEvent(self, \"drag\", \"onDrag\") === false) {\n                        if (allowX) {\n                            self.x -= self.deltaX;\n                        }\n                        if (allowY) {\n                            self.y -= self.deltaY;\n                        }\n                        render(true);\n                    }\n                    isDispatching = false;\n                }\n            }\n            dirty = false;\n        }, //copies the x/y from the element (whether that be transforms, top/left, or ScrollProxy's top/left) to the Draggable's x and y (and rotation if necessary) properties so that they reflect reality and it also (optionally) applies any snapping necessary. This is used by the InertiaPlugin tween in an onUpdate to ensure things are synced and snapped.\n        syncXY = function syncXY(skipOnUpdate, skipSnap) {\n            var x = self.x, y = self.y, snappedValue, cs;\n            if (!target._gsap) {\n                //just in case the _gsap cache got wiped, like if the user called clearProps on the transform or something (very rare).\n                gsCache = gsap.core.getCache(target);\n            }\n            gsCache.uncache && gsap.getProperty(target, \"x\"); // trigger a re-cache\n            if (xyMode) {\n                self.x = parseFloat(gsCache.x);\n                self.y = parseFloat(gsCache.y);\n            } else if (rotationMode) {\n                self.x = self.rotation = parseFloat(gsCache.rotation);\n            } else if (scrollProxy) {\n                self.y = scrollProxy.top();\n                self.x = scrollProxy.left();\n            } else {\n                self.y = parseFloat(target.style.top || (cs = _getComputedStyle(target)) && cs.top) || 0;\n                self.x = parseFloat(target.style.left || (cs || {}).left) || 0;\n            }\n            if ((snapX || snapY || snapXY) && !skipSnap && (self.isDragging || self.isThrowing)) {\n                if (snapXY) {\n                    _temp1.x = self.x;\n                    _temp1.y = self.y;\n                    snappedValue = snapXY(_temp1);\n                    if (snappedValue.x !== self.x) {\n                        self.x = snappedValue.x;\n                        dirty = true;\n                    }\n                    if (snappedValue.y !== self.y) {\n                        self.y = snappedValue.y;\n                        dirty = true;\n                    }\n                }\n                if (snapX) {\n                    snappedValue = snapX(self.x);\n                    if (snappedValue !== self.x) {\n                        self.x = snappedValue;\n                        if (rotationMode) {\n                            self.rotation = snappedValue;\n                        }\n                        dirty = true;\n                    }\n                }\n                if (snapY) {\n                    snappedValue = snapY(self.y);\n                    if (snappedValue !== self.y) {\n                        self.y = snappedValue;\n                    }\n                    dirty = true;\n                }\n            }\n            dirty && render(true);\n            if (!skipOnUpdate) {\n                self.deltaX = self.x - x;\n                self.deltaY = self.y - y;\n                _dispatchEvent(self, \"throwupdate\", \"onThrowUpdate\");\n            }\n        }, buildSnapFunc = function buildSnapFunc(snap, min, max, factor) {\n            if (min == null) {\n                min = -_bigNum;\n            }\n            if (max == null) {\n                max = _bigNum;\n            }\n            if (_isFunction(snap)) {\n                return function(n) {\n                    var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)\n                    return snap.call(self, (n > max ? max + (n - max) * edgeTolerance : n < min ? min + (n - min) * edgeTolerance : n) * factor) * factor;\n                };\n            }\n            if (_isArray(snap)) {\n                return function(n) {\n                    var i = snap.length, closest = 0, absDif = _bigNum, val, dif;\n                    while(--i > -1){\n                        val = snap[i];\n                        dif = val - n;\n                        if (dif < 0) {\n                            dif = -dif;\n                        }\n                        if (dif < absDif && val >= min && val <= max) {\n                            closest = i;\n                            absDif = dif;\n                        }\n                    }\n                    return snap[closest];\n                };\n            }\n            return isNaN(snap) ? function(n) {\n                return n;\n            } : function() {\n                return snap * factor;\n            };\n        }, buildPointSnapFunc = function buildPointSnapFunc(snap, minX, maxX, minY, maxY, radius, factor) {\n            radius = radius && radius < _bigNum ? radius * radius : _bigNum; //so we don't have to Math.sqrt() in the functions. Performance optimization.\n            if (_isFunction(snap)) {\n                return function(point) {\n                    var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance, x = point.x, y = point.y, result, dx, dy; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)\n                    point.x = x = x > maxX ? maxX + (x - maxX) * edgeTolerance : x < minX ? minX + (x - minX) * edgeTolerance : x;\n                    point.y = y = y > maxY ? maxY + (y - maxY) * edgeTolerance : y < minY ? minY + (y - minY) * edgeTolerance : y;\n                    result = snap.call(self, point);\n                    if (result !== point) {\n                        point.x = result.x;\n                        point.y = result.y;\n                    }\n                    if (factor !== 1) {\n                        point.x *= factor;\n                        point.y *= factor;\n                    }\n                    if (radius < _bigNum) {\n                        dx = point.x - x;\n                        dy = point.y - y;\n                        if (dx * dx + dy * dy > radius) {\n                            point.x = x;\n                            point.y = y;\n                        }\n                    }\n                    return point;\n                };\n            }\n            if (_isArray(snap)) {\n                return function(p) {\n                    var i = snap.length, closest = 0, minDist = _bigNum, x, y, point, dist;\n                    while(--i > -1){\n                        point = snap[i];\n                        x = point.x - p.x;\n                        y = point.y - p.y;\n                        dist = x * x + y * y;\n                        if (dist < minDist) {\n                            closest = i;\n                            minDist = dist;\n                        }\n                    }\n                    return minDist <= radius ? snap[closest] : p;\n                };\n            }\n            return function(n) {\n                return n;\n            };\n        }, calculateBounds = function calculateBounds() {\n            var bounds, targetBounds, snap, snapIsRaw;\n            hasBounds = false;\n            if (scrollProxy) {\n                scrollProxy.calibrate();\n                self.minX = minX = -scrollProxy.maxScrollLeft();\n                self.minY = minY = -scrollProxy.maxScrollTop();\n                self.maxX = maxX = self.maxY = maxY = 0;\n                hasBounds = true;\n            } else if (!!vars.bounds) {\n                bounds = _getBounds(vars.bounds, target.parentNode); //could be a selector/jQuery object or a DOM element or a generic object like {top:0, left:100, width:1000, height:800} or {minX:100, maxX:1100, minY:0, maxY:800}\n                if (rotationMode) {\n                    self.minX = minX = bounds.left;\n                    self.maxX = maxX = bounds.left + bounds.width;\n                    self.minY = minY = self.maxY = maxY = 0;\n                } else if (!_isUndefined(vars.bounds.maxX) || !_isUndefined(vars.bounds.maxY)) {\n                    bounds = vars.bounds;\n                    self.minX = minX = bounds.minX;\n                    self.minY = minY = bounds.minY;\n                    self.maxX = maxX = bounds.maxX;\n                    self.maxY = maxY = bounds.maxY;\n                } else {\n                    targetBounds = _getBounds(target, target.parentNode);\n                    self.minX = minX = Math.round(getPropAsNum(xProp, \"px\") + bounds.left - targetBounds.left);\n                    self.minY = minY = Math.round(getPropAsNum(yProp, \"px\") + bounds.top - targetBounds.top);\n                    self.maxX = maxX = Math.round(minX + (bounds.width - targetBounds.width));\n                    self.maxY = maxY = Math.round(minY + (bounds.height - targetBounds.height));\n                }\n                if (minX > maxX) {\n                    self.minX = maxX;\n                    self.maxX = maxX = minX;\n                    minX = self.minX;\n                }\n                if (minY > maxY) {\n                    self.minY = maxY;\n                    self.maxY = maxY = minY;\n                    minY = self.minY;\n                }\n                if (rotationMode) {\n                    self.minRotation = minX;\n                    self.maxRotation = maxX;\n                }\n                hasBounds = true;\n            }\n            if (vars.liveSnap) {\n                snap = vars.liveSnap === true ? vars.snap || {} : vars.liveSnap;\n                snapIsRaw = _isArray(snap) || _isFunction(snap);\n                if (rotationMode) {\n                    snapX = buildSnapFunc(snapIsRaw ? snap : snap.rotation, minX, maxX, 1);\n                    snapY = null;\n                } else {\n                    if (snap.points) {\n                        snapXY = buildPointSnapFunc(snapIsRaw ? snap : snap.points, minX, maxX, minY, maxY, snap.radius, scrollProxy ? -1 : 1);\n                    } else {\n                        if (allowX) {\n                            snapX = buildSnapFunc(snapIsRaw ? snap : snap.x || snap.left || snap.scrollLeft, minX, maxX, scrollProxy ? -1 : 1);\n                        }\n                        if (allowY) {\n                            snapY = buildSnapFunc(snapIsRaw ? snap : snap.y || snap.top || snap.scrollTop, minY, maxY, scrollProxy ? -1 : 1);\n                        }\n                    }\n                }\n            }\n        }, onThrowComplete = function onThrowComplete() {\n            self.isThrowing = false;\n            _dispatchEvent(self, \"throwcomplete\", \"onThrowComplete\");\n        }, onThrowInterrupt = function onThrowInterrupt() {\n            self.isThrowing = false;\n        }, animate = function animate(inertia, forceZeroVelocity) {\n            var snap, snapIsRaw, tween, overshootTolerance;\n            if (inertia && InertiaPlugin) {\n                if (inertia === true) {\n                    snap = vars.snap || vars.liveSnap || {};\n                    snapIsRaw = _isArray(snap) || _isFunction(snap);\n                    inertia = {\n                        resistance: (vars.throwResistance || vars.resistance || 1000) / (rotationMode ? 10 : 1)\n                    };\n                    if (rotationMode) {\n                        inertia.rotation = _parseInertia(self, snapIsRaw ? snap : snap.rotation, maxX, minX, 1, forceZeroVelocity);\n                    } else {\n                        if (allowX) {\n                            inertia[xProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.x || snap.left, maxX, minX, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === \"x\");\n                        }\n                        if (allowY) {\n                            inertia[yProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.y || snap.top, maxY, minY, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === \"y\");\n                        }\n                        if (snap.points || _isArray(snap) && _isObject(snap[0])) {\n                            inertia.linkedProps = xProp + \",\" + yProp;\n                            inertia.radius = snap.radius; //note: we also disable liveSnapping while throwing if there's a \"radius\" defined, otherwise it looks weird to have the item thrown past a snapping point but live-snapping mid-tween. We do this by altering the onUpdateParams so that \"skipSnap\" parameter is true for syncXY.\n                        }\n                    }\n                }\n                self.isThrowing = true;\n                overshootTolerance = !isNaN(vars.overshootTolerance) ? vars.overshootTolerance : vars.edgeResistance === 1 ? 0 : 1 - self.edgeResistance + 0.2;\n                if (!inertia.duration) {\n                    inertia.duration = {\n                        max: Math.max(vars.minDuration || 0, \"maxDuration\" in vars ? vars.maxDuration : 2),\n                        min: !isNaN(vars.minDuration) ? vars.minDuration : overshootTolerance === 0 || _isObject(inertia) && inertia.resistance > 1000 ? 0 : 0.5,\n                        overshoot: overshootTolerance\n                    };\n                }\n                self.tween = tween = gsap.to(scrollProxy || target, {\n                    inertia: inertia,\n                    data: \"_draggable\",\n                    inherit: false,\n                    onComplete: onThrowComplete,\n                    onInterrupt: onThrowInterrupt,\n                    onUpdate: vars.fastMode ? _dispatchEvent : syncXY,\n                    onUpdateParams: vars.fastMode ? [\n                        self,\n                        \"onthrowupdate\",\n                        \"onThrowUpdate\"\n                    ] : snap && snap.radius ? [\n                        false,\n                        true\n                    ] : []\n                });\n                if (!vars.fastMode) {\n                    if (scrollProxy) {\n                        scrollProxy._skip = true; // Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.\n                    }\n                    tween.render(1e9, true, true); // force to the end. Remember, the duration will likely change upon initting because that's when InertiaPlugin calculates it.\n                    syncXY(true, true);\n                    self.endX = self.x;\n                    self.endY = self.y;\n                    if (rotationMode) {\n                        self.endRotation = self.x;\n                    }\n                    tween.play(0);\n                    syncXY(true, true);\n                    if (scrollProxy) {\n                        scrollProxy._skip = false; //Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.\n                    }\n                }\n            } else if (hasBounds) {\n                self.applyBounds();\n            }\n        }, updateMatrix = function updateMatrix(shiftStart) {\n            var start = matrix, p;\n            matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target.parentNode, true);\n            if (shiftStart && self.isPressed && !matrix.equals(start || new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D())) {\n                //if the matrix changes WHILE the element is pressed, we must adjust the startPointerX and startPointerY accordingly, so we invert the original matrix and figure out where the pointerX and pointerY were in the global space, then apply the new matrix to get the updated coordinates.\n                p = start.inverse().apply({\n                    x: startPointerX,\n                    y: startPointerY\n                });\n                matrix.apply(p, p);\n                startPointerX = p.x;\n                startPointerY = p.y;\n            }\n            if (matrix.equals(_identityMatrix)) {\n                //if there are no transforms, we can optimize performance by not factoring in the matrix\n                matrix = null;\n            }\n        }, recordStartPositions = function recordStartPositions() {\n            var edgeTolerance = 1 - self.edgeResistance, offsetX = isFixed ? _getDocScrollLeft(ownerDoc) : 0, offsetY = isFixed ? _getDocScrollTop(ownerDoc) : 0, parsedOrigin, x, y;\n            if (xyMode) {\n                // in case the user set it as a different unit, like animating the x to \"100%\". We must convert it back to px!\n                gsCache.x = getPropAsNum(xProp, \"px\") + \"px\";\n                gsCache.y = getPropAsNum(yProp, \"px\") + \"px\";\n                gsCache.renderTransform();\n            }\n            updateMatrix(false);\n            _point1.x = self.pointerX - offsetX;\n            _point1.y = self.pointerY - offsetY;\n            matrix && matrix.apply(_point1, _point1);\n            startPointerX = _point1.x; //translate to local coordinate system\n            startPointerY = _point1.y;\n            if (dirty) {\n                setPointerPosition(self.pointerX, self.pointerY);\n                render(true);\n            }\n            innerMatrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target);\n            if (scrollProxy) {\n                calculateBounds();\n                startElementY = scrollProxy.top();\n                startElementX = scrollProxy.left();\n            } else {\n                //if the element is in the process of tweening, don't force snapping to occur because it could make it jump. Imagine the user throwing, then before it's done, clicking on the element in its inbetween state.\n                if (isTweening()) {\n                    syncXY(true, true);\n                    calculateBounds();\n                } else {\n                    self.applyBounds();\n                }\n                if (rotationMode) {\n                    parsedOrigin = target.ownerSVGElement ? [\n                        gsCache.xOrigin - target.getBBox().x,\n                        gsCache.yOrigin - target.getBBox().y\n                    ] : (_getComputedStyle(target)[_transformOriginProp] || \"0 0\").split(\" \");\n                    rotationOrigin = self.rotationOrigin = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target).apply({\n                        x: parseFloat(parsedOrigin[0]) || 0,\n                        y: parseFloat(parsedOrigin[1]) || 0\n                    });\n                    syncXY(true, true);\n                    x = self.pointerX - rotationOrigin.x - offsetX;\n                    y = rotationOrigin.y - self.pointerY + offsetY;\n                    startElementX = self.x; //starting rotation (x always refers to rotation in type:\"rotation\", measured in degrees)\n                    startElementY = self.y = Math.atan2(y, x) * _RAD2DEG;\n                } else {\n                    //parent = !isFixed && target.parentNode;\n                    //startScrollTop = parent ? parent.scrollTop || 0 : 0;\n                    //startScrollLeft = parent ? parent.scrollLeft || 0 : 0;\n                    startElementY = getPropAsNum(yProp, \"px\"); //record the starting top and left values so that we can just add the mouse's movement to them later.\n                    startElementX = getPropAsNum(xProp, \"px\");\n                }\n            }\n            if (hasBounds && edgeTolerance) {\n                if (startElementX > maxX) {\n                    startElementX = maxX + (startElementX - maxX) / edgeTolerance;\n                } else if (startElementX < minX) {\n                    startElementX = minX - (minX - startElementX) / edgeTolerance;\n                }\n                if (!rotationMode) {\n                    if (startElementY > maxY) {\n                        startElementY = maxY + (startElementY - maxY) / edgeTolerance;\n                    } else if (startElementY < minY) {\n                        startElementY = minY - (minY - startElementY) / edgeTolerance;\n                    }\n                }\n            }\n            self.startX = startElementX = _round(startElementX);\n            self.startY = startElementY = _round(startElementY);\n        }, isTweening = function isTweening() {\n            return self.tween && self.tween.isActive();\n        }, removePlaceholder = function removePlaceholder() {\n            if (_placeholderDiv.parentNode && !isTweening() && !self.isDragging) {\n                //_placeholderDiv just props open auto-scrolling containers so they don't collapse as the user drags left/up. We remove it after dragging (and throwing, if necessary) finishes.\n                _placeholderDiv.parentNode.removeChild(_placeholderDiv);\n            }\n        }, //called when the mouse is pressed (or touch starts)\n        onPress = function onPress(e, force) {\n            var i;\n            if (!enabled || self.isPressed || !e || (e.type === \"mousedown\" || e.type === \"pointerdown\") && !force && _getTime() - clickTime < 30 && _touchEventLookup[self.pointerEvent.type]) {\n                //when we DON'T preventDefault() in order to accommodate touch-scrolling and the user just taps, many browsers also fire a mousedown/mouseup sequence AFTER the touchstart/touchend sequence, thus it'd result in two quick \"click\" events being dispatched. This line senses that condition and halts it on the subsequent mousedown.\n                isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchstart, pointerdown, mousedown. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.\n                return;\n            }\n            interrupted = isTweening();\n            dragged = false; // we need to track whether or not it was dragged in this interaction so that if, for example, the user calls .endDrag() to FORCE it to stop and then they keep the mouse pressed down and eventually release, that would normally cause an onClick but we have to skip it in that case if there was dragging that occurred.\n            self.pointerEvent = e;\n            if (_touchEventLookup[e.type]) {\n                //note: on iOS, BOTH touchmove and mousemove are dispatched, but the mousemove has pageY and pageX of 0 which would mess up the calculations and needlessly hurt performance.\n                touchEventTarget = ~e.type.indexOf(\"touch\") ? e.currentTarget || e.target : ownerDoc; //pointer-based touches (for Microsoft browsers) don't remain locked to the original target like other browsers, so we must use the document instead. The event type would be \"MSPointerDown\" or \"pointerdown\".\n                _addListener(touchEventTarget, \"touchend\", onRelease);\n                _addListener(touchEventTarget, \"touchmove\", onMove); // possible future change if PointerEvents are more standardized: https://developer.mozilla.org/en-US/docs/Web/API/Element/setPointerCapture\n                _addListener(touchEventTarget, \"touchcancel\", onRelease);\n                _addListener(ownerDoc, \"touchstart\", _onMultiTouchDocument);\n            } else {\n                touchEventTarget = null;\n                _addListener(ownerDoc, \"mousemove\", onMove); //attach these to the document instead of the box itself so that if the user's mouse moves too quickly (and off of the box), things still work.\n            }\n            touchDragAxis = null;\n            if (!_supportsPointer || !touchEventTarget) {\n                _addListener(ownerDoc, \"mouseup\", onRelease);\n                e && e.target && _addListener(e.target, \"mouseup\", onRelease); //we also have to listen directly on the element because some browsers don't bubble up the event to the _doc on elements with contentEditable=\"true\"\n            }\n            isClicking = isClickable.call(self, e.target) && vars.dragClickables === false && !force;\n            if (isClicking) {\n                _addListener(e.target, \"change\", onRelease); //in some browsers, when you mousedown on a <select> element, no mouseup gets dispatched! So we listen for a \"change\" event instead.\n                _dispatchEvent(self, \"pressInit\", \"onPressInit\");\n                _dispatchEvent(self, \"press\", \"onPress\");\n                _setSelectable(triggers, true); //accommodates things like inputs and elements with contentEditable=\"true\" (otherwise user couldn't drag to select text)\n                isPreventingDefault = false;\n                return;\n            }\n            allowNativeTouchScrolling = !touchEventTarget || allowX === allowY || self.vars.allowNativeTouchScrolling === false || self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2) ? false : allowX ? \"y\" : \"x\"; //note: in Chrome, right-clicking (for a context menu) fires onPress and it doesn't have the event.which set properly, so we must look for event.ctrlKey. If the user wants to allow context menus we should of course sense it here and not allow native touch scrolling.\n            isPreventingDefault = !allowNativeTouchScrolling && !self.allowEventDefault;\n            if (isPreventingDefault) {\n                _preventDefault(e);\n                _addListener(_win, \"touchforcechange\", _preventDefault); //works around safari bug: https://gsap.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n            }\n            if (e.changedTouches) {\n                //touch events store the data slightly differently\n                e = touch = e.changedTouches[0];\n                touchID = e.identifier;\n            } else if (e.pointerId) {\n                touchID = e.pointerId; //for some Microsoft browsers\n            } else {\n                touch = touchID = null;\n            }\n            _dragCount++;\n            _addToRenderQueue(render); //causes the Draggable to render on each \"tick\" of gsap.ticker (performance optimization - updating values in a mousemove can cause them to happen too frequently, like multiple times between frame redraws which is wasteful, and it also prevents values from updating properly in IE8)\n            startPointerY = self.pointerY = e.pageY; //record the starting x and y so that we can calculate the movement from the original in _onMouseMove\n            startPointerX = self.pointerX = e.pageX;\n            _dispatchEvent(self, \"pressInit\", \"onPressInit\");\n            if (allowNativeTouchScrolling || self.autoScroll) {\n                _recordMaxScrolls(target.parentNode);\n            }\n            if (target.parentNode && self.autoScroll && !scrollProxy && !rotationMode && target.parentNode._gsMaxScrollX && !_placeholderDiv.parentNode && !target.getBBox) {\n                //add a placeholder div to prevent the parent container from collapsing when the user drags the element left.\n                _placeholderDiv.style.width = target.parentNode.scrollWidth + \"px\";\n                target.parentNode.appendChild(_placeholderDiv);\n            }\n            recordStartPositions();\n            self.tween && self.tween.kill();\n            self.isThrowing = false;\n            gsap.killTweensOf(scrollProxy || target, killProps, true); //in case the user tries to drag it before the last tween is done.\n            scrollProxy && gsap.killTweensOf(target, {\n                scrollTo: 1\n            }, true); //just in case the original target's scroll position is being tweened somewhere else.\n            self.tween = self.lockedAxis = null;\n            if (vars.zIndexBoost || !rotationMode && !scrollProxy && vars.zIndexBoost !== false) {\n                target.style.zIndex = Draggable.zIndex++;\n            }\n            self.isPressed = true;\n            hasDragCallback = !!(vars.onDrag || self._listeners.drag);\n            hasMoveCallback = !!(vars.onMove || self._listeners.move);\n            if (vars.cursor !== false || vars.activeCursor) {\n                i = triggers.length;\n                while(--i > -1){\n                    gsap.set(triggers[i], {\n                        cursor: vars.activeCursor || vars.cursor || (_defaultCursor === \"grab\" ? \"grabbing\" : _defaultCursor)\n                    });\n                }\n            }\n            _dispatchEvent(self, \"press\", \"onPress\");\n        }, //called every time the mouse/touch moves\n        onMove = function onMove(e) {\n            var originalEvent = e, touches, pointerX, pointerY, i, dx, dy;\n            if (!enabled || _isMultiTouching || !self.isPressed || !e) {\n                isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchmove, pointermove, mousemove. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.\n                return;\n            }\n            self.pointerEvent = e;\n            touches = e.changedTouches;\n            if (touches) {\n                //touch events store the data slightly differently\n                e = touches[0];\n                if (e !== touch && e.identifier !== touchID) {\n                    //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)\n                    i = touches.length;\n                    while(--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target){} // Some Android devices dispatch a touchstart AND pointerdown initially, and then only pointermove thus the touchID may not match because it was grabbed from the touchstart event whereas the pointer event is the one that the browser dispatches for move, so if the event target matches this Draggable's target, let it through.\n                    if (i < 0) {\n                        return;\n                    }\n                }\n            } else if (e.pointerId && touchID && e.pointerId !== touchID) {\n                //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)\n                return;\n            }\n            if (touchEventTarget && allowNativeTouchScrolling && !touchDragAxis) {\n                //Android browsers force us to decide on the first \"touchmove\" event if we should allow the default (scrolling) behavior or preventDefault(). Otherwise, a \"touchcancel\" will be fired and then no \"touchmove\" or \"touchend\" will fire during the scrolling (no good).\n                _point1.x = e.pageX - (isFixed ? _getDocScrollLeft(ownerDoc) : 0);\n                _point1.y = e.pageY - (isFixed ? _getDocScrollTop(ownerDoc) : 0);\n                matrix && matrix.apply(_point1, _point1);\n                pointerX = _point1.x;\n                pointerY = _point1.y;\n                dx = Math.abs(pointerX - startPointerX);\n                dy = Math.abs(pointerY - startPointerY);\n                if (dx !== dy && (dx > minimumMovement || dy > minimumMovement) || _isAndroid && allowNativeTouchScrolling === touchDragAxis) {\n                    touchDragAxis = dx > dy && allowX ? \"x\" : \"y\";\n                    if (allowNativeTouchScrolling && touchDragAxis !== allowNativeTouchScrolling) {\n                        _addListener(_win, \"touchforcechange\", _preventDefault); // prevents native touch scrolling from taking over if the user started dragging in the other direction in iOS Safari\n                    }\n                    if (self.vars.lockAxisOnTouchScroll !== false && allowX && allowY) {\n                        self.lockedAxis = touchDragAxis === \"x\" ? \"y\" : \"x\";\n                        _isFunction(self.vars.onLockAxis) && self.vars.onLockAxis.call(self, originalEvent);\n                    }\n                    if (_isAndroid && allowNativeTouchScrolling === touchDragAxis) {\n                        onRelease(originalEvent);\n                        return;\n                    }\n                }\n            }\n            if (!self.allowEventDefault && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling !== touchDragAxis) && originalEvent.cancelable !== false) {\n                _preventDefault(originalEvent);\n                isPreventingDefault = true;\n            } else if (isPreventingDefault) {\n                isPreventingDefault = false;\n            }\n            if (self.autoScroll) {\n                checkAutoScrollBounds = true;\n            }\n            setPointerPosition(e.pageX, e.pageY, hasMoveCallback);\n        }, setPointerPosition = function setPointerPosition(pointerX, pointerY, invokeOnMove) {\n            var dragTolerance = 1 - self.dragResistance, edgeTolerance = 1 - self.edgeResistance, prevPointerX = self.pointerX, prevPointerY = self.pointerY, prevStartElementY = startElementY, prevX = self.x, prevY = self.y, prevEndX = self.endX, prevEndY = self.endY, prevEndRotation = self.endRotation, prevDirty = dirty, xChange, yChange, x, y, dif, temp;\n            self.pointerX = pointerX;\n            self.pointerY = pointerY;\n            if (isFixed) {\n                pointerX -= _getDocScrollLeft(ownerDoc);\n                pointerY -= _getDocScrollTop(ownerDoc);\n            }\n            if (rotationMode) {\n                y = Math.atan2(rotationOrigin.y - pointerY, pointerX - rotationOrigin.x) * _RAD2DEG;\n                dif = self.y - y;\n                if (dif > 180) {\n                    startElementY -= 360;\n                    self.y = y;\n                } else if (dif < -180) {\n                    startElementY += 360;\n                    self.y = y;\n                }\n                if (self.x !== startElementX || Math.abs(startElementY - y) > minimumMovement) {\n                    self.y = y;\n                    x = startElementX + (startElementY - y) * dragTolerance;\n                } else {\n                    x = startElementX;\n                }\n            } else {\n                if (matrix) {\n                    temp = pointerX * matrix.a + pointerY * matrix.c + matrix.e;\n                    pointerY = pointerX * matrix.b + pointerY * matrix.d + matrix.f;\n                    pointerX = temp;\n                }\n                yChange = pointerY - startPointerY;\n                xChange = pointerX - startPointerX;\n                if (yChange < minimumMovement && yChange > -minimumMovement) {\n                    yChange = 0;\n                }\n                if (xChange < minimumMovement && xChange > -minimumMovement) {\n                    xChange = 0;\n                }\n                if ((self.lockAxis || self.lockedAxis) && (xChange || yChange)) {\n                    temp = self.lockedAxis;\n                    if (!temp) {\n                        self.lockedAxis = temp = allowX && Math.abs(xChange) > Math.abs(yChange) ? \"y\" : allowY ? \"x\" : null;\n                        if (temp && _isFunction(self.vars.onLockAxis)) {\n                            self.vars.onLockAxis.call(self, self.pointerEvent);\n                        }\n                    }\n                    if (temp === \"y\") {\n                        yChange = 0;\n                    } else if (temp === \"x\") {\n                        xChange = 0;\n                    }\n                }\n                x = _round(startElementX + xChange * dragTolerance);\n                y = _round(startElementY + yChange * dragTolerance);\n            }\n            if ((snapX || snapY || snapXY) && (self.x !== x || self.y !== y && !rotationMode)) {\n                if (snapXY) {\n                    _temp1.x = x;\n                    _temp1.y = y;\n                    temp = snapXY(_temp1);\n                    x = _round(temp.x);\n                    y = _round(temp.y);\n                }\n                if (snapX) {\n                    x = _round(snapX(x));\n                }\n                if (snapY) {\n                    y = _round(snapY(y));\n                }\n            }\n            if (hasBounds) {\n                if (x > maxX) {\n                    x = maxX + Math.round((x - maxX) * edgeTolerance);\n                } else if (x < minX) {\n                    x = minX + Math.round((x - minX) * edgeTolerance);\n                }\n                if (!rotationMode) {\n                    if (y > maxY) {\n                        y = Math.round(maxY + (y - maxY) * edgeTolerance);\n                    } else if (y < minY) {\n                        y = Math.round(minY + (y - minY) * edgeTolerance);\n                    }\n                }\n            }\n            if (self.x !== x || self.y !== y && !rotationMode) {\n                if (rotationMode) {\n                    self.endRotation = self.x = self.endX = x;\n                    dirty = true;\n                } else {\n                    if (allowY) {\n                        self.y = self.endY = y;\n                        dirty = true; //a flag that indicates we need to render the target next time the TweenLite.ticker dispatches a \"tick\" event (typically on a requestAnimationFrame) - this is a performance optimization (we shouldn't render on every move because sometimes many move events can get dispatched between screen refreshes, and that'd be wasteful to render every time)\n                    }\n                    if (allowX) {\n                        self.x = self.endX = x;\n                        dirty = true;\n                    }\n                }\n                if (!invokeOnMove || _dispatchEvent(self, \"move\", \"onMove\") !== false) {\n                    if (!self.isDragging && self.isPressed) {\n                        self.isDragging = dragged = true;\n                        _dispatchEvent(self, \"dragstart\", \"onDragStart\");\n                    }\n                } else {\n                    //revert because the onMove returned false!\n                    self.pointerX = prevPointerX;\n                    self.pointerY = prevPointerY;\n                    startElementY = prevStartElementY;\n                    self.x = prevX;\n                    self.y = prevY;\n                    self.endX = prevEndX;\n                    self.endY = prevEndY;\n                    self.endRotation = prevEndRotation;\n                    dirty = prevDirty;\n                }\n            }\n        }, //called when the mouse/touch is released\n        onRelease = function onRelease(e, force) {\n            if (!enabled || !self.isPressed || e && touchID != null && !force && (e.pointerId && e.pointerId !== touchID && e.target !== target || e.changedTouches && !_hasTouchID(e.changedTouches, touchID))) {\n                //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)\n                isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchend, pointerup, mouseup. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.\n                return;\n            }\n            self.isPressed = false;\n            var originalEvent = e, wasDragging = self.isDragging, isContextMenuRelease = self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2), placeholderDelayedCall = gsap.delayedCall(0.001, removePlaceholder), touches, i, syntheticEvent, eventTarget, syntheticClick;\n            if (touchEventTarget) {\n                _removeListener(touchEventTarget, \"touchend\", onRelease);\n                _removeListener(touchEventTarget, \"touchmove\", onMove);\n                _removeListener(touchEventTarget, \"touchcancel\", onRelease);\n                _removeListener(ownerDoc, \"touchstart\", _onMultiTouchDocument);\n            } else {\n                _removeListener(ownerDoc, \"mousemove\", onMove);\n            }\n            _removeListener(_win, \"touchforcechange\", _preventDefault);\n            if (!_supportsPointer || !touchEventTarget) {\n                _removeListener(ownerDoc, \"mouseup\", onRelease);\n                e && e.target && _removeListener(e.target, \"mouseup\", onRelease);\n            }\n            dirty = false;\n            if (wasDragging) {\n                dragEndTime = _lastDragTime = _getTime();\n                self.isDragging = false;\n            }\n            _removeFromRenderQueue(render);\n            if (isClicking && !isContextMenuRelease) {\n                if (e) {\n                    _removeListener(e.target, \"change\", onRelease);\n                    self.pointerEvent = originalEvent;\n                }\n                _setSelectable(triggers, false);\n                _dispatchEvent(self, \"release\", \"onRelease\");\n                _dispatchEvent(self, \"click\", \"onClick\");\n                isClicking = false;\n                return;\n            }\n            i = triggers.length;\n            while(--i > -1){\n                _setStyle(triggers[i], \"cursor\", vars.cursor || (vars.cursor !== false ? _defaultCursor : null));\n            }\n            _dragCount--;\n            if (e) {\n                touches = e.changedTouches;\n                if (touches) {\n                    //touch events store the data slightly differently\n                    e = touches[0];\n                    if (e !== touch && e.identifier !== touchID) {\n                        //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)\n                        i = touches.length;\n                        while(--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target){}\n                        if (i < 0 && !force) {\n                            return;\n                        }\n                    }\n                }\n                self.pointerEvent = originalEvent;\n                self.pointerX = e.pageX;\n                self.pointerY = e.pageY;\n            }\n            if (isContextMenuRelease && originalEvent) {\n                _preventDefault(originalEvent);\n                isPreventingDefault = true;\n                _dispatchEvent(self, \"release\", \"onRelease\");\n            } else if (originalEvent && !wasDragging) {\n                isPreventingDefault = false;\n                if (interrupted && (vars.snap || vars.bounds)) {\n                    //otherwise, if the user clicks on the object while it's animating to a snapped position, and then releases without moving 3 pixels, it will just stay there (it should animate/snap)\n                    animate(vars.inertia || vars.throwProps);\n                }\n                _dispatchEvent(self, \"release\", \"onRelease\");\n                if ((!_isAndroid || originalEvent.type !== \"touchmove\") && originalEvent.type.indexOf(\"cancel\") === -1) {\n                    //to accommodate native scrolling on Android devices, we have to immediately call onRelease() on the first touchmove event, but that shouldn't trigger a \"click\".\n                    _dispatchEvent(self, \"click\", \"onClick\");\n                    if (_getTime() - clickTime < 300) {\n                        _dispatchEvent(self, \"doubleclick\", \"onDoubleClick\");\n                    }\n                    eventTarget = originalEvent.target || target; //old IE uses srcElement\n                    clickTime = _getTime();\n                    syntheticClick = function syntheticClick() {\n                        // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular \"click\" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the \"real\"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the \"real\" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.\n                        if (clickTime !== clickDispatch && self.enabled() && !self.isPressed && !originalEvent.defaultPrevented) {\n                            if (eventTarget.click) {\n                                //some browsers (like mobile Safari) don't properly trigger the click event\n                                eventTarget.click();\n                            } else if (ownerDoc.createEvent) {\n                                syntheticEvent = ownerDoc.createEvent(\"MouseEvents\");\n                                syntheticEvent.initMouseEvent(\"click\", true, true, _win, 1, self.pointerEvent.screenX, self.pointerEvent.screenY, self.pointerX, self.pointerY, false, false, false, false, 0, null);\n                                eventTarget.dispatchEvent(syntheticEvent);\n                            }\n                        }\n                    };\n                    if (!_isAndroid && !originalEvent.defaultPrevented) {\n                        //iOS Safari requires the synthetic click to happen immediately or else it simply won't work, but Android doesn't play nice.\n                        gsap.delayedCall(0.05, syntheticClick); //in addition to the iOS bug workaround, there's a Firefox issue with clicking on things like a video to play, so we must fake a click event in a slightly delayed fashion. Previously, we listened for the \"click\" event with \"capture\" false which solved the video-click-to-play issue, but it would allow the \"click\" event to be dispatched twice like if you were using a jQuery.click() because that was handled in the capture phase, thus we had to switch to the capture phase to avoid the double-dispatching, but do the delayed synthetic click. Don't fire it too fast (like 0.00001) because we want to give the native event a chance to fire first as it's \"trusted\".\n                    }\n                }\n            } else {\n                animate(vars.inertia || vars.throwProps); //will skip if inertia/throwProps isn't defined or InertiaPlugin isn't loaded.\n                if (!self.allowEventDefault && originalEvent && (vars.dragClickables !== false || !isClickable.call(self, originalEvent.target)) && wasDragging && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling === touchDragAxis) && originalEvent.cancelable !== false) {\n                    isPreventingDefault = true;\n                    _preventDefault(originalEvent);\n                } else {\n                    isPreventingDefault = false;\n                }\n                _dispatchEvent(self, \"release\", \"onRelease\");\n            }\n            isTweening() && placeholderDelayedCall.duration(self.tween.duration()); //sync the timing so that the placeholder DIV gets\n            wasDragging && _dispatchEvent(self, \"dragend\", \"onDragEnd\");\n            return true;\n        }, updateScroll = function updateScroll(e) {\n            if (e && self.isDragging && !scrollProxy) {\n                var parent = e.target || target.parentNode, deltaX = parent.scrollLeft - parent._gsScrollX, deltaY = parent.scrollTop - parent._gsScrollY;\n                if (deltaX || deltaY) {\n                    if (matrix) {\n                        startPointerX -= deltaX * matrix.a + deltaY * matrix.c;\n                        startPointerY -= deltaY * matrix.d + deltaX * matrix.b;\n                    } else {\n                        startPointerX -= deltaX;\n                        startPointerY -= deltaY;\n                    }\n                    parent._gsScrollX += deltaX;\n                    parent._gsScrollY += deltaY;\n                    setPointerPosition(self.pointerX, self.pointerY);\n                }\n            }\n        }, onClick = function onClick(e) {\n            //this was a huge pain in the neck to align all the various browsers and their behaviors. Chrome, Firefox, Safari, Opera, Android, and Microsoft Edge all handle events differently! Some will only trigger native behavior (like checkbox toggling) from trusted events. Others don't even support isTrusted, but require 2 events to flow through before triggering native behavior. Edge treats everything as trusted but also mandates that 2 flow through to trigger the correct native behavior.\n            var time = _getTime(), recentlyClicked = time - clickTime < 100, recentlyDragged = time - dragEndTime < 50, alreadyDispatched = recentlyClicked && clickDispatch === clickTime, defaultPrevented = self.pointerEvent && self.pointerEvent.defaultPrevented, alreadyDispatchedTrusted = recentlyClicked && trustedClickDispatch === clickTime, trusted = e.isTrusted || e.isTrusted == null && recentlyClicked && alreadyDispatched; //note: Safari doesn't support isTrusted, and it won't properly execute native behavior (like toggling checkboxes) on the first synthetic \"click\" event - we must wait for the 2nd and treat it as trusted (but stop propagation at that point). Confusing, I know. Don't you love cross-browser compatibility challenges?\n            if ((alreadyDispatched || recentlyDragged && self.vars.suppressClickOnDrag !== false) && e.stopImmediatePropagation) {\n                e.stopImmediatePropagation();\n            }\n            if (recentlyClicked && !(self.pointerEvent && self.pointerEvent.defaultPrevented) && (!alreadyDispatched || trusted && !alreadyDispatchedTrusted)) {\n                //let the first click pass through unhindered. Let the next one only if it's trusted, then no more (stop quick-succession ones)\n                if (trusted && alreadyDispatched) {\n                    trustedClickDispatch = clickTime;\n                }\n                clickDispatch = clickTime;\n                return;\n            }\n            if (self.isPressed || recentlyDragged || recentlyClicked) {\n                if (!trusted || !e.detail || !recentlyClicked || defaultPrevented) {\n                    _preventDefault(e);\n                }\n            }\n            if (!recentlyClicked && !recentlyDragged && !dragged) {\n                // for script-triggered event dispatches, like element.click()\n                e && e.target && (self.pointerEvent = e);\n                _dispatchEvent(self, \"click\", \"onClick\");\n            }\n        }, localizePoint = function localizePoint(p) {\n            return matrix ? {\n                x: p.x * matrix.a + p.y * matrix.c + matrix.e,\n                y: p.x * matrix.b + p.y * matrix.d + matrix.f\n            } : {\n                x: p.x,\n                y: p.y\n            };\n        };\n        old = Draggable.get(target);\n        old && old.kill(); // avoids duplicates (an element can only be controlled by one Draggable)\n        //give the user access to start/stop dragging...\n        _this2.startDrag = function(event, align) {\n            var r1, r2, p1, p2;\n            onPress(event || self.pointerEvent, true); //if the pointer isn't on top of the element, adjust things accordingly\n            if (align && !self.hitTest(event || self.pointerEvent)) {\n                r1 = _parseRect(event || self.pointerEvent);\n                r2 = _parseRect(target);\n                p1 = localizePoint({\n                    x: r1.left + r1.width / 2,\n                    y: r1.top + r1.height / 2\n                });\n                p2 = localizePoint({\n                    x: r2.left + r2.width / 2,\n                    y: r2.top + r2.height / 2\n                });\n                startPointerX -= p1.x - p2.x;\n                startPointerY -= p1.y - p2.y;\n            }\n            if (!self.isDragging) {\n                self.isDragging = dragged = true;\n                _dispatchEvent(self, \"dragstart\", \"onDragStart\");\n            }\n        };\n        _this2.drag = onMove;\n        _this2.endDrag = function(e) {\n            return onRelease(e || self.pointerEvent, true);\n        };\n        _this2.timeSinceDrag = function() {\n            return self.isDragging ? 0 : (_getTime() - dragEndTime) / 1000;\n        };\n        _this2.timeSinceClick = function() {\n            return (_getTime() - clickTime) / 1000;\n        };\n        _this2.hitTest = function(target, threshold) {\n            return Draggable.hitTest(self.target, target, threshold);\n        };\n        _this2.getDirection = function(from, diagonalThreshold) {\n            //from can be \"start\" (default), \"velocity\", or an element\n            var mode = from === \"velocity\" && InertiaPlugin ? from : _isObject(from) && !rotationMode ? \"element\" : \"start\", xChange, yChange, ratio, direction, r1, r2;\n            if (mode === \"element\") {\n                r1 = _parseRect(self.target);\n                r2 = _parseRect(from);\n            }\n            xChange = mode === \"start\" ? self.x - startElementX : mode === \"velocity\" ? InertiaPlugin.getVelocity(target, xProp) : r1.left + r1.width / 2 - (r2.left + r2.width / 2);\n            if (rotationMode) {\n                return xChange < 0 ? \"counter-clockwise\" : \"clockwise\";\n            } else {\n                diagonalThreshold = diagonalThreshold || 2;\n                yChange = mode === \"start\" ? self.y - startElementY : mode === \"velocity\" ? InertiaPlugin.getVelocity(target, yProp) : r1.top + r1.height / 2 - (r2.top + r2.height / 2);\n                ratio = Math.abs(xChange / yChange);\n                direction = ratio < 1 / diagonalThreshold ? \"\" : xChange < 0 ? \"left\" : \"right\";\n                if (ratio < diagonalThreshold) {\n                    if (direction !== \"\") {\n                        direction += \"-\";\n                    }\n                    direction += yChange < 0 ? \"up\" : \"down\";\n                }\n            }\n            return direction;\n        };\n        _this2.applyBounds = function(newBounds, sticky) {\n            var x, y, forceZeroVelocity, e, parent, isRoot;\n            if (newBounds && vars.bounds !== newBounds) {\n                vars.bounds = newBounds;\n                return self.update(true, sticky);\n            }\n            syncXY(true);\n            calculateBounds();\n            if (hasBounds && !isTweening()) {\n                x = self.x;\n                y = self.y;\n                if (x > maxX) {\n                    x = maxX;\n                } else if (x < minX) {\n                    x = minX;\n                }\n                if (y > maxY) {\n                    y = maxY;\n                } else if (y < minY) {\n                    y = minY;\n                }\n                if (self.x !== x || self.y !== y) {\n                    forceZeroVelocity = true;\n                    self.x = self.endX = x;\n                    if (rotationMode) {\n                        self.endRotation = x;\n                    } else {\n                        self.y = self.endY = y;\n                    }\n                    dirty = true;\n                    render(true);\n                    if (self.autoScroll && !self.isDragging) {\n                        _recordMaxScrolls(target.parentNode);\n                        e = target;\n                        _windowProxy.scrollTop = _win.pageYOffset != null ? _win.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;\n                        _windowProxy.scrollLeft = _win.pageXOffset != null ? _win.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;\n                        while(e && !isRoot){\n                            //walk up the chain and sense wherever the scrollTop/scrollLeft exceeds the maximum.\n                            isRoot = _isRoot(e.parentNode);\n                            parent = isRoot ? _windowProxy : e.parentNode;\n                            if (allowY && parent.scrollTop > parent._gsMaxScrollY) {\n                                parent.scrollTop = parent._gsMaxScrollY;\n                            }\n                            if (allowX && parent.scrollLeft > parent._gsMaxScrollX) {\n                                parent.scrollLeft = parent._gsMaxScrollX;\n                            }\n                            e = parent;\n                        }\n                    }\n                }\n                if (self.isThrowing && (forceZeroVelocity || self.endX > maxX || self.endX < minX || self.endY > maxY || self.endY < minY)) {\n                    animate(vars.inertia || vars.throwProps, forceZeroVelocity);\n                }\n            }\n            return self;\n        };\n        _this2.update = function(applyBounds, sticky, ignoreExternalChanges) {\n            if (sticky && self.isPressed) {\n                // in case the element was repositioned in the document flow, thus its x/y may be identical but its position is actually quite different.\n                var m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target), p = innerMatrix.apply({\n                    x: self.x - startElementX,\n                    y: self.y - startElementY\n                }), m2 = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target.parentNode, true);\n                m2.apply({\n                    x: m.e - p.x,\n                    y: m.f - p.y\n                }, p);\n                self.x -= p.x - m2.e;\n                self.y -= p.y - m2.f;\n                render(true);\n                recordStartPositions();\n            }\n            var x = self.x, y = self.y;\n            updateMatrix(!sticky);\n            if (applyBounds) {\n                self.applyBounds();\n            } else {\n                dirty && ignoreExternalChanges && render(true);\n                syncXY(true);\n            }\n            if (sticky) {\n                setPointerPosition(self.pointerX, self.pointerY);\n                dirty && render(true);\n            }\n            if (self.isPressed && !sticky && (allowX && Math.abs(x - self.x) > 0.01 || allowY && Math.abs(y - self.y) > 0.01 && !rotationMode)) {\n                recordStartPositions();\n            }\n            if (self.autoScroll) {\n                _recordMaxScrolls(target.parentNode, self.isDragging);\n                checkAutoScrollBounds = self.isDragging;\n                render(true); //in case reparenting occurred.\n                _removeScrollListener(target, updateScroll);\n                _addScrollListener(target, updateScroll);\n            }\n            return self;\n        };\n        _this2.enable = function(type) {\n            var setVars = {\n                lazy: true\n            }, id, i, trigger;\n            if (vars.cursor !== false) {\n                setVars.cursor = vars.cursor || _defaultCursor;\n            }\n            if (gsap.utils.checkPrefix(\"touchCallout\")) {\n                setVars.touchCallout = \"none\";\n            }\n            if (type !== \"soft\") {\n                _setTouchActionForAllDescendants(triggers, allowX === allowY ? \"none\" : vars.allowNativeTouchScrolling && target.scrollHeight === target.clientHeight === (target.scrollWidth === target.clientHeight) || vars.allowEventDefault ? \"manipulation\" : allowX ? \"pan-y\" : \"pan-x\"); // Some browsers like Internet Explorer will fire a pointercancel event when the user attempts to drag when touchAction is \"manipulate\" because it's perceived as a pan. If the element has scrollable content in only one direction, we should use pan-x or pan-y accordingly so that the pointercancel doesn't prevent dragging.\n                i = triggers.length;\n                while(--i > -1){\n                    trigger = triggers[i];\n                    _supportsPointer || _addListener(trigger, \"mousedown\", onPress);\n                    _addListener(trigger, \"touchstart\", onPress);\n                    _addListener(trigger, \"click\", onClick, true); // note: used to pass true for capture but it prevented click-to-play-video functionality in Firefox.\n                    gsap.set(trigger, setVars);\n                    if (trigger.getBBox && trigger.ownerSVGElement && allowX !== allowY) {\n                        // a bug in chrome doesn't respect touch-action on SVG elements - it only works if we set it on the parent SVG.\n                        gsap.set(trigger.ownerSVGElement, {\n                            touchAction: vars.allowNativeTouchScrolling || vars.allowEventDefault ? \"manipulation\" : allowX ? \"pan-y\" : \"pan-x\"\n                        });\n                    }\n                    vars.allowContextMenu || _addListener(trigger, \"contextmenu\", onContextMenu);\n                }\n                _setSelectable(triggers, false);\n            }\n            _addScrollListener(target, updateScroll);\n            enabled = true;\n            if (InertiaPlugin && type !== \"soft\") {\n                InertiaPlugin.track(scrollProxy || target, xyMode ? \"x,y\" : rotationMode ? \"rotation\" : \"top,left\");\n            }\n            target._gsDragID = id = \"d\" + _lookupCount++;\n            _lookup[id] = self;\n            if (scrollProxy) {\n                scrollProxy.enable();\n                scrollProxy.element._gsDragID = id;\n            }\n            (vars.bounds || rotationMode) && recordStartPositions();\n            vars.bounds && self.applyBounds();\n            return self;\n        };\n        _this2.disable = function(type) {\n            var dragging = self.isDragging, i = triggers.length, trigger;\n            while(--i > -1){\n                _setStyle(triggers[i], \"cursor\", null);\n            }\n            if (type !== \"soft\") {\n                _setTouchActionForAllDescendants(triggers, null);\n                i = triggers.length;\n                while(--i > -1){\n                    trigger = triggers[i];\n                    _setStyle(trigger, \"touchCallout\", null);\n                    _removeListener(trigger, \"mousedown\", onPress);\n                    _removeListener(trigger, \"touchstart\", onPress);\n                    _removeListener(trigger, \"click\", onClick, true);\n                    _removeListener(trigger, \"contextmenu\", onContextMenu);\n                }\n                _setSelectable(triggers, true);\n                if (touchEventTarget) {\n                    _removeListener(touchEventTarget, \"touchcancel\", onRelease);\n                    _removeListener(touchEventTarget, \"touchend\", onRelease);\n                    _removeListener(touchEventTarget, \"touchmove\", onMove);\n                }\n                _removeListener(ownerDoc, \"mouseup\", onRelease);\n                _removeListener(ownerDoc, \"mousemove\", onMove);\n            }\n            _removeScrollListener(target, updateScroll);\n            enabled = false;\n            if (InertiaPlugin && type !== \"soft\") {\n                InertiaPlugin.untrack(scrollProxy || target, xyMode ? \"x,y\" : rotationMode ? \"rotation\" : \"top,left\");\n                self.tween && self.tween.kill();\n            }\n            scrollProxy && scrollProxy.disable();\n            _removeFromRenderQueue(render);\n            self.isDragging = self.isPressed = isClicking = false;\n            dragging && _dispatchEvent(self, \"dragend\", \"onDragEnd\");\n            return self;\n        };\n        _this2.enabled = function(value, type) {\n            return arguments.length ? value ? self.enable(type) : self.disable(type) : enabled;\n        };\n        _this2.kill = function() {\n            self.isThrowing = false;\n            self.tween && self.tween.kill();\n            self.disable();\n            gsap.set(triggers, {\n                clearProps: \"userSelect\"\n            });\n            delete _lookup[target._gsDragID];\n            return self;\n        };\n        _this2.revert = function() {\n            this.kill();\n            this.styles && this.styles.revert();\n        };\n        if (~type.indexOf(\"scroll\")) {\n            scrollProxy = _this2.scrollProxy = new ScrollProxy(target, _extend({\n                onKill: function onKill() {\n                    //ScrollProxy's onKill() gets called if/when the ScrollProxy senses that the user interacted with the scroll position manually (like using the scrollbar). IE9 doesn't fire the \"mouseup\" properly when users drag the scrollbar of an element, so this works around that issue.\n                    self.isPressed && onRelease(null);\n                }\n            }, vars)); //a bug in many Android devices' stock browser causes scrollTop to get forced back to 0 after it is altered via JS, so we set overflow to \"hidden\" on mobile/touch devices (they hide the scroll bar anyway). That works around the bug. (This bug is discussed at https://code.google.com/p/android/issues/detail?id=19625)\n            target.style.overflowY = allowY && !_isTouchDevice ? \"auto\" : \"hidden\";\n            target.style.overflowX = allowX && !_isTouchDevice ? \"auto\" : \"hidden\";\n            target = scrollProxy.content;\n        }\n        if (rotationMode) {\n            killProps.rotation = 1;\n        } else {\n            if (allowX) {\n                killProps[xProp] = 1;\n            }\n            if (allowY) {\n                killProps[yProp] = 1;\n            }\n        }\n        gsCache.force3D = \"force3D\" in vars ? vars.force3D : true; //otherwise, normal dragging would be in 2D and then as soon as it's released and there's an inertia tween, it'd jump to 3D which can create an initial jump due to the work the browser must to do layerize it.\n        _context(_assertThisInitialized(_this2));\n        _this2.enable();\n        return _this2;\n    }\n    Draggable.register = function register(core) {\n        gsap = core;\n        _initCore();\n    };\n    Draggable.create = function create(targets, vars) {\n        _coreInitted || _initCore(true);\n        return _toArray(targets).map(function(target) {\n            return new Draggable(target, vars);\n        });\n    };\n    Draggable.get = function get(target) {\n        return _lookup[(_toArray(target)[0] || {})._gsDragID];\n    };\n    Draggable.timeSinceDrag = function timeSinceDrag() {\n        return (_getTime() - _lastDragTime) / 1000;\n    };\n    Draggable.hitTest = function hitTest(obj1, obj2, threshold) {\n        if (obj1 === obj2) {\n            return false;\n        }\n        var r1 = _parseRect(obj1), r2 = _parseRect(obj2), top = r1.top, left = r1.left, right = r1.right, bottom = r1.bottom, width = r1.width, height = r1.height, isOutside = r2.left > right || r2.right < left || r2.top > bottom || r2.bottom < top, overlap, area, isRatio;\n        if (isOutside || !threshold) {\n            return !isOutside;\n        }\n        isRatio = (threshold + \"\").indexOf(\"%\") !== -1;\n        threshold = parseFloat(threshold) || 0;\n        overlap = {\n            left: Math.max(left, r2.left),\n            top: Math.max(top, r2.top)\n        };\n        overlap.width = Math.min(right, r2.right) - overlap.left;\n        overlap.height = Math.min(bottom, r2.bottom) - overlap.top;\n        if (overlap.width < 0 || overlap.height < 0) {\n            return false;\n        }\n        if (isRatio) {\n            threshold *= 0.01;\n            area = overlap.width * overlap.height;\n            return area >= width * height * threshold || area >= r2.width * r2.height * threshold;\n        }\n        return overlap.width > threshold && overlap.height > threshold;\n    };\n    return Draggable;\n}(EventDispatcher);\n_setDefaults(Draggable.prototype, {\n    pointerX: 0,\n    pointerY: 0,\n    startX: 0,\n    startY: 0,\n    deltaX: 0,\n    deltaY: 0,\n    isDragging: false,\n    isPressed: false\n});\nDraggable.zIndex = 1000;\nDraggable.version = \"3.12.5\";\n_getGSAP() && gsap.registerPlugin(Draggable);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9EcmFnZ2FibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsU0FBU0EsdUJBQXVCQyxJQUFJO0lBQUksSUFBSUEsU0FBUyxLQUFLLEdBQUc7UUFBRSxNQUFNLElBQUlDLGVBQWU7SUFBOEQ7SUFBRSxPQUFPRDtBQUFNO0FBRXJLLFNBQVNFLGVBQWVDLFFBQVEsRUFBRUMsVUFBVTtJQUFJRCxTQUFTRSxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0gsV0FBV0MsU0FBUztJQUFHRixTQUFTRSxTQUFTLENBQUNHLFdBQVcsR0FBR0w7SUFBVUEsU0FBU00sU0FBUyxHQUFHTDtBQUFZO0FBRXRMOzs7Ozs7OztDQVFDLEdBRUQsa0JBQWtCLEdBQzRDO0FBRTlELElBQUlRLE1BQ0FDLE1BQ0FDLE1BQ0FDLGFBQ0FDLE9BQ0FDLFVBQ0FDLGlCQUNBQyxjQUNBQyxjQUNBQyxVQUNBQyxrQkFDQUMsZ0JBQ0FDLG1CQUNBQyxrQkFDQUMsWUFDQUMsZUFDQUMsZ0JBQ0FDLGtCQUNBQyxVQUNBQyxnQkFDQUMsYUFBYSxHQUNiQyxnQkFBZ0IsU0FBU0E7SUFDM0IsT0FBTyxPQUFPQyxXQUFXO0FBQzNCLEdBQ0lDLFdBQVcsU0FBU0E7SUFDdEIsT0FBT3ZCLFFBQVFxQixtQkFBb0JyQixDQUFBQSxPQUFPc0IsT0FBT3RCLElBQUksS0FBS0EsS0FBS3dCLGNBQWMsSUFBSXhCO0FBQ25GLEdBQ0l5QixjQUFjLFNBQVNBLFlBQVlDLEtBQUs7SUFDMUMsT0FBTyxPQUFPQSxVQUFVO0FBQzFCLEdBQ0lDLFlBQVksU0FBU0EsVUFBVUQsS0FBSztJQUN0QyxPQUFPLE9BQU9BLFVBQVU7QUFDMUIsR0FDSUUsZUFBZSxTQUFTQSxhQUFhRixLQUFLO0lBQzVDLE9BQU8sT0FBT0EsVUFBVTtBQUMxQixHQUNJRyxhQUFhLFNBQVNBO0lBQ3hCLE9BQU87QUFDVCxHQUNJ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QVE1WixJQUFJO1FBQ3hENFosUUFBUXRaLE1BQU0sR0FBRzVILEtBQUtrSixHQUFHLENBQUNyQixRQUFRa1gsR0FBR2xYLE1BQU0sSUFBSXFaLFFBQVEzWixHQUFHO1FBRTFELElBQUkyWixRQUFRMVosS0FBSyxHQUFHLEtBQUswWixRQUFRdFosTUFBTSxHQUFHLEdBQUc7WUFDM0MsT0FBTztRQUNUO1FBRUEsSUFBSXdaLFNBQVM7WUFDWGpDLGFBQWE7WUFDYmdDLE9BQU9ELFFBQVExWixLQUFLLEdBQUcwWixRQUFRdFosTUFBTTtZQUNyQyxPQUFPdVosUUFBUTNaLFFBQVFJLFNBQVN1WCxhQUFhZ0MsUUFBUXBDLEdBQUd2WCxLQUFLLEdBQUd1WCxHQUFHblgsTUFBTSxHQUFHdVg7UUFDOUU7UUFFQSxPQUFPK0IsUUFBUTFaLEtBQUssR0FBRzJYLGFBQWErQixRQUFRdFosTUFBTSxHQUFHdVg7SUFDdkQ7SUFFQSxPQUFPN047QUFDVCxFQUFFSCxpQkFBaUI7QUFFbkJ4TixhQUFhMk4sVUFBVTlULFNBQVMsRUFBRTtJQUNoQzBZLFVBQVU7SUFDVkMsVUFBVTtJQUNWbUUsUUFBUTtJQUNSQyxRQUFRO0lBQ1I5RCxRQUFRO0lBQ1JFLFFBQVE7SUFDUmIsWUFBWTtJQUNacEYsV0FBVztBQUNiO0FBRUFZLFVBQVVnSyxNQUFNLEdBQUc7QUFDbkJoSyxVQUFVK1AsT0FBTyxHQUFHO0FBQ3BCL2hCLGNBQWN2QixLQUFLd0IsY0FBYyxDQUFDK1I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vZ3NhcEAzLjEyLjUvbm9kZV9tb2R1bGVzL2dzYXAvRHJhZ2dhYmxlLmpzP2FmZjciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKiFcbiAqIERyYWdnYWJsZSAzLjEyLjVcbiAqIGh0dHBzOi8vZ3NhcC5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDI0LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dzYXAuY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdTQVAgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IHsgZ2V0R2xvYmFsTWF0cml4LCBNYXRyaXgyRCB9IGZyb20gXCIuL3V0aWxzL21hdHJpeC5qc1wiO1xuXG52YXIgZ3NhcCxcbiAgICBfd2luLFxuICAgIF9kb2MsXG4gICAgX2RvY0VsZW1lbnQsXG4gICAgX2JvZHksXG4gICAgX3RlbXBEaXYsXG4gICAgX3BsYWNlaG9sZGVyRGl2LFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfY2hlY2tQcmVmaXgsXG4gICAgX3RvQXJyYXksXG4gICAgX3N1cHBvcnRzUGFzc2l2ZSxcbiAgICBfaXNUb3VjaERldmljZSxcbiAgICBfdG91Y2hFdmVudExvb2t1cCxcbiAgICBfaXNNdWx0aVRvdWNoaW5nLFxuICAgIF9pc0FuZHJvaWQsXG4gICAgSW5lcnRpYVBsdWdpbixcbiAgICBfZGVmYXVsdEN1cnNvcixcbiAgICBfc3VwcG9ydHNQb2ludGVyLFxuICAgIF9jb250ZXh0LFxuICAgIF9nZXRTdHlsZVNhdmVyLFxuICAgIF9kcmFnQ291bnQgPSAwLFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgX3dpbmRvd0V4aXN0cygpICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX2lzRnVuY3Rpb24gPSBmdW5jdGlvbiBfaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59LFxuICAgIF9pc09iamVjdCA9IGZ1bmN0aW9uIF9pc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufSxcbiAgICBfaXNVbmRlZmluZWQgPSBmdW5jdGlvbiBfaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2VtcHR5RnVuYyA9IGZ1bmN0aW9uIF9lbXB0eUZ1bmMoKSB7XG4gIHJldHVybiBmYWxzZTtcbn0sXG4gICAgX3RyYW5zZm9ybVByb3AgPSBcInRyYW5zZm9ybVwiLFxuICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gXCJ0cmFuc2Zvcm1PcmlnaW5cIixcbiAgICBfcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMCkgLyAxMDAwMDtcbn0sXG4gICAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5LFxuICAgIF9jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQodHlwZSwgbnMpIHtcbiAgdmFyIGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyA/IF9kb2MuY3JlYXRlRWxlbWVudE5TKChucyB8fCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIikucmVwbGFjZSgvXmh0dHBzLywgXCJodHRwXCIpLCB0eXBlKSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIHNlcnZlcnMgc3dhcCBpbiBodHRwcyBmb3IgaHR0cCBpbiB0aGUgbmFtZXNwYWNlIHdoaWNoIGNhbiBicmVhayB0aGluZ3MsIG1ha2luZyBcInN0eWxlXCIgaW5hY2Nlc3NpYmxlLlxuXG4gIHJldHVybiBlLnN0eWxlID8gZSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIGVudmlyb25tZW50cyB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIGVsZW1lbnQncyBzdHlsZSB3aGVuIGNyZWF0ZWQgd2l0aCBhIG5hbWVzcGFjZSBpbiB3aGljaCBjYXNlIHdlIGRlZmF1bHQgdG8gdGhlIHN0YW5kYXJkIGNyZWF0ZUVsZW1lbnQoKSB0byB3b3JrIGFyb3VuZCB0aGUgaXNzdWUuIEFsc28gbm90ZSB0aGF0IHdoZW4gR1NBUCBpcyBlbWJlZGRlZCBkaXJlY3RseSBpbnNpZGUgYW4gU1ZHIGZpbGUsIGNyZWF0ZUVsZW1lbnQoKSB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIHN0eWxlIG9iamVjdCBpbiBGaXJlZm94IChzZWUgaHR0cHM6Ly9nc2FwLmNvbS9mb3J1bXMvdG9waWMvMjAyMTUtcHJvYmxlbS11c2luZy10d2Vlbm1heC1pbi1zdGFuZGFsb25lLXNlbGYtY29udGFpbmluZy1zdmctZmlsZS1lcnItY2Fubm90LXNldC1wcm9wZXJ0eS1jc3N0ZXh0LW9mLXVuZGVmaW5lZC8pLlxufSxcbiAgICBfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG4gICAgX2JpZ051bSA9IDFlMjAsXG4gICAgX2lkZW50aXR5TWF0cml4ID0gbmV3IE1hdHJpeDJEKCksXG4gICAgX2dldFRpbWUgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbn0sXG4gICAgX3JlbmRlclF1ZXVlID0gW10sXG4gICAgX2xvb2t1cCA9IHt9LFxuICAgIC8vd2hlbiBhIERyYWdnYWJsZSBpcyBjcmVhdGVkLCB0aGUgdGFyZ2V0IGdldHMgYSB1bmlxdWUgX2dzRHJhZ0lEIHByb3BlcnR5IHRoYXQgYWxsb3dzIGdldHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBEcmFnZ2FibGUgaW5zdGFuY2UgZm9yIHF1aWNrIGxvb2t1cHMgaW4gRHJhZ2dhYmxlLmdldCgpLiBUaGlzIGF2b2lkcyBjaXJjdWxhciByZWZlcmVuY2VzIHRoYXQgY291bGQgY2F1c2UgZ2MgcHJvYmxlbXMuXG5fbG9va3VwQ291bnQgPSAwLFxuICAgIF9jbGlja2FibGVUYWdFeHAgPSAvXig/OmF8aW5wdXR8dGV4dGFyZWF8YnV0dG9ufHNlbGVjdCkkL2ksXG4gICAgX2xhc3REcmFnVGltZSA9IDAsXG4gICAgX3RlbXAxID0ge30sXG4gICAgLy8gYSBzaW1wbGUgb2JqZWN0IHdlIHJldXNlIGFuZCBwb3B1bGF0ZSAodXN1YWxseSB4L3kgcHJvcGVydGllcykgdG8gY29uc2VydmUgbWVtb3J5IGFuZCBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuX3dpbmRvd1Byb3h5ID0ge30sXG4gICAgLy9tZW1vcnkvcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIC0gd2UgcmV1c2UgdGhpcyBvYmplY3QgZHVyaW5nIGF1dG9TY3JvbGwgdG8gc3RvcmUgd2luZG93LXJlbGF0ZWQgYm91bmRzL29mZnNldHMuXG5fY29weSA9IGZ1bmN0aW9uIF9jb3B5KG9iaiwgZmFjdG9yKSB7XG4gIHZhciBjb3B5ID0ge30sXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiBvYmopIHtcbiAgICBjb3B5W3BdID0gZmFjdG9yID8gb2JqW3BdICogZmFjdG9yIDogb2JqW3BdO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIF9leHRlbmQgPSBmdW5jdGlvbiBfZXh0ZW5kKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIGlmICghKHAgaW4gb2JqKSkge1xuICAgICAgb2JqW3BdID0gZGVmYXVsdHNbcF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0sXG4gICAgX3NldFRvdWNoQWN0aW9uRm9yQWxsRGVzY2VuZGFudHMgPSBmdW5jdGlvbiBfc2V0VG91Y2hBY3Rpb25Gb3JBbGxEZXNjZW5kYW50cyhlbGVtZW50cywgdmFsdWUpIHtcbiAgdmFyIGkgPSBlbGVtZW50cy5sZW5ndGgsXG4gICAgICBjaGlsZHJlbjtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFsdWUgPyBlbGVtZW50c1tpXS5zdHlsZS50b3VjaEFjdGlvbiA9IHZhbHVlIDogZWxlbWVudHNbaV0uc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0b3VjaC1hY3Rpb25cIik7XG4gICAgY2hpbGRyZW4gPSBlbGVtZW50c1tpXS5jaGlsZHJlbjtcbiAgICBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggJiYgX3NldFRvdWNoQWN0aW9uRm9yQWxsRGVzY2VuZGFudHMoY2hpbGRyZW4sIHZhbHVlKTtcbiAgfVxufSxcbiAgICBfcmVuZGVyUXVldWVUaWNrID0gZnVuY3Rpb24gX3JlbmRlclF1ZXVlVGljaygpIHtcbiAgcmV0dXJuIF9yZW5kZXJRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmMoKTtcbiAgfSk7XG59LFxuICAgIF9hZGRUb1JlbmRlclF1ZXVlID0gZnVuY3Rpb24gX2FkZFRvUmVuZGVyUXVldWUoZnVuYykge1xuICBfcmVuZGVyUXVldWUucHVzaChmdW5jKTtcblxuICBpZiAoX3JlbmRlclF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgIGdzYXAudGlja2VyLmFkZChfcmVuZGVyUXVldWVUaWNrKTtcbiAgfVxufSxcbiAgICBfcmVuZGVyUXVldWVUaW1lb3V0ID0gZnVuY3Rpb24gX3JlbmRlclF1ZXVlVGltZW91dCgpIHtcbiAgcmV0dXJuICFfcmVuZGVyUXVldWUubGVuZ3RoICYmIGdzYXAudGlja2VyLnJlbW92ZShfcmVuZGVyUXVldWVUaWNrKTtcbn0sXG4gICAgX3JlbW92ZUZyb21SZW5kZXJRdWV1ZSA9IGZ1bmN0aW9uIF9yZW1vdmVGcm9tUmVuZGVyUXVldWUoZnVuYykge1xuICB2YXIgaSA9IF9yZW5kZXJRdWV1ZS5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChfcmVuZGVyUXVldWVbaV0gPT09IGZ1bmMpIHtcbiAgICAgIF9yZW5kZXJRdWV1ZS5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG5cbiAgZ3NhcC50byhfcmVuZGVyUXVldWVUaW1lb3V0LCB7XG4gICAgb3ZlcndyaXRlOiB0cnVlLFxuICAgIGRlbGF5OiAxNSxcbiAgICBkdXJhdGlvbjogMCxcbiAgICBvbkNvbXBsZXRlOiBfcmVuZGVyUXVldWVUaW1lb3V0LFxuICAgIGRhdGE6IFwiX2RyYWdnYWJsZVwiXG4gIH0pOyAvL3JlbW92ZSB0aGUgXCJ0aWNrXCIgbGlzdGVuZXIgb25seSBhZnRlciB0aGUgcmVuZGVyIHF1ZXVlIGlzIGVtcHR5IGZvciAxNSBzZWNvbmRzICh0byBpbXByb3ZlIHBlcmZvcm1hbmNlKS4gQWRkaW5nL3JlbW92aW5nIGl0IGNvbnN0YW50bHkgZm9yIGV2ZXJ5IGNsaWNrL3RvdWNoIHdvdWxkbid0IGRlbGl2ZXIgb3B0aW1hbCBzcGVlZCwgYW5kIHdlIGFsc28gZG9uJ3Qgd2FudCB0aGUgdGlja2VyIHRvIGtlZXAgY2FsbGluZyB0aGUgcmVuZGVyIG1ldGhvZCB3aGVuIHRoaW5ncyBhcmUgaWRsZSBmb3IgbG9uZyBwZXJpb2RzIG9mIHRpbWUgKHdlIHdhbnQgdG8gaW1wcm92ZSBiYXR0ZXJ5IGxpZmUgb24gbW9iaWxlIGRldmljZXMpLlxufSxcbiAgICBfc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiBfc2V0RGVmYXVsdHMob2JqLCBkZWZhdWx0cykge1xuICBmb3IgKHZhciBwIGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKCEocCBpbiBvYmopKSB7XG4gICAgICBvYmpbcF0gPSBkZWZhdWx0c1twXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBfYWRkTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgZnVuYywgY2FwdHVyZSkge1xuICBpZiAoZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgdmFyIHRvdWNoVHlwZSA9IF90b3VjaEV2ZW50TG9va3VwW3R5cGVdO1xuICAgIGNhcHR1cmUgPSBjYXB0dXJlIHx8IChfc3VwcG9ydHNQYXNzaXZlID8ge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9IDogbnVsbCk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRvdWNoVHlwZSB8fCB0eXBlLCBmdW5jLCBjYXB0dXJlKTtcbiAgICB0b3VjaFR5cGUgJiYgdHlwZSAhPT0gdG91Y2hUeXBlICYmIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jLCBjYXB0dXJlKTsgLy9zb21lIGJyb3dzZXJzIGFjdHVhbGx5IHN1cHBvcnQgYm90aCwgc28gbXVzdCB3ZS4gQnV0IHBvaW50ZXIgZXZlbnRzIGNvdmVyIGFsbC5cbiAgfVxufSxcbiAgICBfcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiBfcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgZnVuYywgY2FwdHVyZSkge1xuICBpZiAoZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgdmFyIHRvdWNoVHlwZSA9IF90b3VjaEV2ZW50TG9va3VwW3R5cGVdO1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0b3VjaFR5cGUgfHwgdHlwZSwgZnVuYywgY2FwdHVyZSk7XG4gICAgdG91Y2hUeXBlICYmIHR5cGUgIT09IHRvdWNoVHlwZSAmJiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZnVuYywgY2FwdHVyZSk7XG4gIH1cbn0sXG4gICAgX3ByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gX3ByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0ICYmIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnByZXZlbnRNYW5pcHVsYXRpb24gJiYgZXZlbnQucHJldmVudE1hbmlwdWxhdGlvbigpOyAvL2ZvciBzb21lIE1pY3Jvc29mdCBicm93c2Vyc1xufSxcbiAgICBfaGFzVG91Y2hJRCA9IGZ1bmN0aW9uIF9oYXNUb3VjaElEKGxpc3QsIElEKSB7XG4gIHZhciBpID0gbGlzdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChsaXN0W2ldLmlkZW50aWZpZXIgPT09IElEKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX29uTXVsdGlUb3VjaERvY3VtZW50RW5kID0gZnVuY3Rpb24gX29uTXVsdGlUb3VjaERvY3VtZW50RW5kKGV2ZW50KSB7XG4gIF9pc011bHRpVG91Y2hpbmcgPSBldmVudC50b3VjaGVzICYmIF9kcmFnQ291bnQgPCBldmVudC50b3VjaGVzLmxlbmd0aDtcblxuICBfcmVtb3ZlTGlzdGVuZXIoZXZlbnQudGFyZ2V0LCBcInRvdWNoZW5kXCIsIF9vbk11bHRpVG91Y2hEb2N1bWVudEVuZCk7XG59LFxuICAgIF9vbk11bHRpVG91Y2hEb2N1bWVudCA9IGZ1bmN0aW9uIF9vbk11bHRpVG91Y2hEb2N1bWVudChldmVudCkge1xuICBfaXNNdWx0aVRvdWNoaW5nID0gZXZlbnQudG91Y2hlcyAmJiBfZHJhZ0NvdW50IDwgZXZlbnQudG91Y2hlcy5sZW5ndGg7XG5cbiAgX2FkZExpc3RlbmVyKGV2ZW50LnRhcmdldCwgXCJ0b3VjaGVuZFwiLCBfb25NdWx0aVRvdWNoRG9jdW1lbnRFbmQpO1xufSxcbiAgICBfZ2V0RG9jU2Nyb2xsVG9wID0gZnVuY3Rpb24gX2dldERvY1Njcm9sbFRvcChkb2MpIHtcbiAgcmV0dXJuIF93aW4ucGFnZVlPZmZzZXQgfHwgZG9jLnNjcm9sbFRvcCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2MuYm9keS5zY3JvbGxUb3AgfHwgMDtcbn0sXG4gICAgX2dldERvY1Njcm9sbExlZnQgPSBmdW5jdGlvbiBfZ2V0RG9jU2Nyb2xsTGVmdChkb2MpIHtcbiAgcmV0dXJuIF93aW4ucGFnZVhPZmZzZXQgfHwgZG9jLnNjcm9sbExlZnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvYy5ib2R5LnNjcm9sbExlZnQgfHwgMDtcbn0sXG4gICAgX2FkZFNjcm9sbExpc3RlbmVyID0gZnVuY3Rpb24gX2FkZFNjcm9sbExpc3RlbmVyKGUsIGNhbGxiYWNrKSB7XG4gIF9hZGRMaXN0ZW5lcihlLCBcInNjcm9sbFwiLCBjYWxsYmFjayk7XG5cbiAgaWYgKCFfaXNSb290KGUucGFyZW50Tm9kZSkpIHtcbiAgICBfYWRkU2Nyb2xsTGlzdGVuZXIoZS5wYXJlbnROb2RlLCBjYWxsYmFjayk7XG4gIH1cbn0sXG4gICAgX3JlbW92ZVNjcm9sbExpc3RlbmVyID0gZnVuY3Rpb24gX3JlbW92ZVNjcm9sbExpc3RlbmVyKGUsIGNhbGxiYWNrKSB7XG4gIF9yZW1vdmVMaXN0ZW5lcihlLCBcInNjcm9sbFwiLCBjYWxsYmFjayk7XG5cbiAgaWYgKCFfaXNSb290KGUucGFyZW50Tm9kZSkpIHtcbiAgICBfcmVtb3ZlU2Nyb2xsTGlzdGVuZXIoZS5wYXJlbnROb2RlLCBjYWxsYmFjayk7XG4gIH1cbn0sXG4gICAgX2lzUm9vdCA9IGZ1bmN0aW9uIF9pc1Jvb3QoZSkge1xuICByZXR1cm4gISEoIWUgfHwgZSA9PT0gX2RvY0VsZW1lbnQgfHwgZS5ub2RlVHlwZSA9PT0gOSB8fCBlID09PSBfZG9jLmJvZHkgfHwgZSA9PT0gX3dpbiB8fCAhZS5ub2RlVHlwZSB8fCAhZS5wYXJlbnROb2RlKTtcbn0sXG4gICAgX2dldE1heFNjcm9sbCA9IGZ1bmN0aW9uIF9nZXRNYXhTY3JvbGwoZWxlbWVudCwgYXhpcykge1xuICB2YXIgZGltID0gYXhpcyA9PT0gXCJ4XCIgPyBcIldpZHRoXCIgOiBcIkhlaWdodFwiLFxuICAgICAgc2Nyb2xsID0gXCJzY3JvbGxcIiArIGRpbSxcbiAgICAgIGNsaWVudCA9IFwiY2xpZW50XCIgKyBkaW07XG4gIHJldHVybiBNYXRoLm1heCgwLCBfaXNSb290KGVsZW1lbnQpID8gTWF0aC5tYXgoX2RvY0VsZW1lbnRbc2Nyb2xsXSwgX2JvZHlbc2Nyb2xsXSkgLSAoX3dpbltcImlubmVyXCIgKyBkaW1dIHx8IF9kb2NFbGVtZW50W2NsaWVudF0gfHwgX2JvZHlbY2xpZW50XSkgOiBlbGVtZW50W3Njcm9sbF0gLSBlbGVtZW50W2NsaWVudF0pO1xufSxcbiAgICBfcmVjb3JkTWF4U2Nyb2xscyA9IGZ1bmN0aW9uIF9yZWNvcmRNYXhTY3JvbGxzKGUsIHNraXBDdXJyZW50KSB7XG4gIC8vcmVjb3JkcyBfZ3NNYXhTY3JvbGxYIGFuZCBfZ3NNYXhTY3JvbGxZIHByb3BlcnRpZXMgZm9yIHRoZSBlbGVtZW50IGFuZCBhbGwgYW5jZXN0b3JzIHVwIHRoZSBjaGFpbiBzbyB0aGF0IHdlIGNhbiBjYXAgaXQsIG90aGVyd2lzZSBkcmFnZ2luZyBiZXlvbmQgdGhlIGVkZ2VzIHdpdGggYXV0b1Njcm9sbCBvbiBjYW4gZW5kbGVzc2x5IHNjcm9sbC5cbiAgdmFyIHggPSBfZ2V0TWF4U2Nyb2xsKGUsIFwieFwiKSxcbiAgICAgIHkgPSBfZ2V0TWF4U2Nyb2xsKGUsIFwieVwiKTtcblxuICBpZiAoX2lzUm9vdChlKSkge1xuICAgIGUgPSBfd2luZG93UHJveHk7XG4gIH0gZWxzZSB7XG4gICAgX3JlY29yZE1heFNjcm9sbHMoZS5wYXJlbnROb2RlLCBza2lwQ3VycmVudCk7XG4gIH1cblxuICBlLl9nc01heFNjcm9sbFggPSB4O1xuICBlLl9nc01heFNjcm9sbFkgPSB5O1xuXG4gIGlmICghc2tpcEN1cnJlbnQpIHtcbiAgICBlLl9nc1Njcm9sbFggPSBlLnNjcm9sbExlZnQgfHwgMDtcbiAgICBlLl9nc1Njcm9sbFkgPSBlLnNjcm9sbFRvcCB8fCAwO1xuICB9XG59LFxuICAgIF9zZXRTdHlsZSA9IGZ1bmN0aW9uIF9zZXRTdHlsZShlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcblxuICBpZiAoIXN0eWxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKF9pc1VuZGVmaW5lZChzdHlsZVtwcm9wZXJ0eV0pKSB7XG4gICAgcHJvcGVydHkgPSBfY2hlY2tQcmVmaXgocHJvcGVydHksIGVsZW1lbnQpIHx8IHByb3BlcnR5O1xuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eSAmJiBzdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eS5yZXBsYWNlKC8oW0EtWl0pL2csIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICB9XG59LFxuICAgIF9nZXRDb21wdXRlZFN0eWxlID0gZnVuY3Rpb24gX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gX3dpbi5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50ID8gZWxlbWVudCA6IGVsZW1lbnQuaG9zdCB8fCAoZWxlbWVudC5wYXJlbnROb2RlIHx8IHt9KS5ob3N0IHx8IGVsZW1lbnQpO1xufSxcbiAgICAvL3RoZSBcImhvc3RcIiBzdHVmZiBoZWxwcyB0byBhY2NvbW1vZGF0ZSBTaGFkb3dEb20gb2JqZWN0cy5cbl90ZW1wUmVjdCA9IHt9LFxuICAgIC8vcmV1c2UgdG8gcmVkdWNlIGdhcmJhZ2UgY29sbGVjdGlvbiB0YXNrc1xuX3BhcnNlUmVjdCA9IGZ1bmN0aW9uIF9wYXJzZVJlY3QoZSkge1xuICAvL2FjY2VwdHMgYSBET00gZWxlbWVudCwgYSBtb3VzZSBldmVudCwgb3IgYSByZWN0YW5nbGUgb2JqZWN0IGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlY3RhbmdsZSB3aXRoIGxlZnQsIHJpZ2h0LCB3aWR0aCwgaGVpZ2h0LCB0b3AsIGFuZCBib3R0b20gcHJvcGVydGllc1xuICBpZiAoZSA9PT0gX3dpbikge1xuICAgIF90ZW1wUmVjdC5sZWZ0ID0gX3RlbXBSZWN0LnRvcCA9IDA7XG4gICAgX3RlbXBSZWN0LndpZHRoID0gX3RlbXBSZWN0LnJpZ2h0ID0gX2RvY0VsZW1lbnQuY2xpZW50V2lkdGggfHwgZS5pbm5lcldpZHRoIHx8IF9ib2R5LmNsaWVudFdpZHRoIHx8IDA7XG4gICAgX3RlbXBSZWN0LmhlaWdodCA9IF90ZW1wUmVjdC5ib3R0b20gPSAoZS5pbm5lckhlaWdodCB8fCAwKSAtIDIwIDwgX2RvY0VsZW1lbnQuY2xpZW50SGVpZ2h0ID8gX2RvY0VsZW1lbnQuY2xpZW50SGVpZ2h0IDogZS5pbm5lckhlaWdodCB8fCBfYm9keS5jbGllbnRIZWlnaHQgfHwgMDtcbiAgICByZXR1cm4gX3RlbXBSZWN0O1xuICB9XG5cbiAgdmFyIGRvYyA9IGUub3duZXJEb2N1bWVudCB8fCBfZG9jLFxuICAgICAgciA9ICFfaXNVbmRlZmluZWQoZS5wYWdlWCkgPyB7XG4gICAgbGVmdDogZS5wYWdlWCAtIF9nZXREb2NTY3JvbGxMZWZ0KGRvYyksXG4gICAgdG9wOiBlLnBhZ2VZIC0gX2dldERvY1Njcm9sbFRvcChkb2MpLFxuICAgIHJpZ2h0OiBlLnBhZ2VYIC0gX2dldERvY1Njcm9sbExlZnQoZG9jKSArIDEsXG4gICAgYm90dG9tOiBlLnBhZ2VZIC0gX2dldERvY1Njcm9sbFRvcChkb2MpICsgMVxuICB9IDogIWUubm9kZVR5cGUgJiYgIV9pc1VuZGVmaW5lZChlLmxlZnQpICYmICFfaXNVbmRlZmluZWQoZS50b3ApID8gZSA6IF90b0FycmF5KGUpWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gIGlmIChfaXNVbmRlZmluZWQoci5yaWdodCkgJiYgIV9pc1VuZGVmaW5lZChyLndpZHRoKSkge1xuICAgIHIucmlnaHQgPSByLmxlZnQgKyByLndpZHRoO1xuICAgIHIuYm90dG9tID0gci50b3AgKyByLmhlaWdodDtcbiAgfSBlbHNlIGlmIChfaXNVbmRlZmluZWQoci53aWR0aCkpIHtcbiAgICAvL3NvbWUgYnJvd3NlcnMgZG9uJ3QgaW5jbHVkZSB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXMuIFdlIGNhbid0IGp1c3Qgc2V0IHRoZW0gZGlyZWN0bHkgb24gciBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgdGhyb3cgZXJyb3JzLCBzbyBjcmVhdGUgYSBuZXcgZ2VuZXJpYyBvYmplY3QuXG4gICAgciA9IHtcbiAgICAgIHdpZHRoOiByLnJpZ2h0IC0gci5sZWZ0LFxuICAgICAgaGVpZ2h0OiByLmJvdHRvbSAtIHIudG9wLFxuICAgICAgcmlnaHQ6IHIucmlnaHQsXG4gICAgICBsZWZ0OiByLmxlZnQsXG4gICAgICBib3R0b206IHIuYm90dG9tLFxuICAgICAgdG9wOiByLnRvcFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gcjtcbn0sXG4gICAgX2Rpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiBfZGlzcGF0Y2hFdmVudCh0YXJnZXQsIHR5cGUsIGNhbGxiYWNrTmFtZSkge1xuICB2YXIgdmFycyA9IHRhcmdldC52YXJzLFxuICAgICAgY2FsbGJhY2sgPSB2YXJzW2NhbGxiYWNrTmFtZV0sXG4gICAgICBsaXN0ZW5lcnMgPSB0YXJnZXQuX2xpc3RlbmVyc1t0eXBlXSxcbiAgICAgIHJlc3VsdDtcblxuICBpZiAoX2lzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgcmVzdWx0ID0gY2FsbGJhY2suYXBwbHkodmFycy5jYWxsYmFja1Njb3BlIHx8IHRhcmdldCwgdmFyc1tjYWxsYmFja05hbWUgKyBcIlBhcmFtc1wiXSB8fCBbdGFyZ2V0LnBvaW50ZXJFdmVudF0pO1xuICB9XG5cbiAgaWYgKGxpc3RlbmVycyAmJiB0YXJnZXQuZGlzcGF0Y2hFdmVudCh0eXBlKSA9PT0gZmFsc2UpIHtcbiAgICByZXN1bHQgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59LFxuICAgIF9nZXRCb3VuZHMgPSBmdW5jdGlvbiBfZ2V0Qm91bmRzKHRhcmdldCwgY29udGV4dCkge1xuICAvL2FjY2VwdHMgYW55IG9mIHRoZSBmb2xsb3dpbmc6IGEgRE9NIGVsZW1lbnQsIGpRdWVyeSBvYmplY3QsIHNlbGVjdG9yIHRleHQsIG9yIGFuIG9iamVjdCBkZWZpbmluZyBib3VuZHMgYXMge3RvcCwgbGVmdCwgd2lkdGgsIGhlaWdodH0gb3Ige21pblgsIG1heFgsIG1pblksIG1heFl9LiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGxlZnQsIHRvcCwgd2lkdGgsIGFuZCBoZWlnaHQgcHJvcGVydGllcy5cbiAgdmFyIGUgPSBfdG9BcnJheSh0YXJnZXQpWzBdLFxuICAgICAgdG9wLFxuICAgICAgbGVmdCxcbiAgICAgIG9mZnNldDtcblxuICBpZiAoIWUubm9kZVR5cGUgJiYgZSAhPT0gX3dpbikge1xuICAgIGlmICghX2lzVW5kZWZpbmVkKHRhcmdldC5sZWZ0KSkge1xuICAgICAgb2Zmc2V0ID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9OyAvL19nZXRPZmZzZXRUcmFuc2Zvcm1PcmlnaW4oY29udGV4dCk7IC8vdGhlIGJvdW5kcyBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIG9yaWdpblxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiB0YXJnZXQubGVmdCAtIG9mZnNldC54LFxuICAgICAgICB0b3A6IHRhcmdldC50b3AgLSBvZmZzZXQueSxcbiAgICAgICAgd2lkdGg6IHRhcmdldC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0YXJnZXQuaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cblxuICAgIGxlZnQgPSB0YXJnZXQubWluIHx8IHRhcmdldC5taW5YIHx8IHRhcmdldC5taW5Sb3RhdGlvbiB8fCAwO1xuICAgIHRvcCA9IHRhcmdldC5taW4gfHwgdGFyZ2V0Lm1pblkgfHwgMDtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogbGVmdCxcbiAgICAgIHRvcDogdG9wLFxuICAgICAgd2lkdGg6ICh0YXJnZXQubWF4IHx8IHRhcmdldC5tYXhYIHx8IHRhcmdldC5tYXhSb3RhdGlvbiB8fCAwKSAtIGxlZnQsXG4gICAgICBoZWlnaHQ6ICh0YXJnZXQubWF4IHx8IHRhcmdldC5tYXhZIHx8IDApIC0gdG9wXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfZ2V0RWxlbWVudEJvdW5kcyhlLCBjb250ZXh0KTtcbn0sXG4gICAgX3BvaW50MSA9IHt9LFxuICAgIC8vd2UgcmV1c2UgdG8gbWluaW1pemUgZ2FyYmFnZSBjb2xsZWN0aW9uIHRhc2tzLlxuX2dldEVsZW1lbnRCb3VuZHMgPSBmdW5jdGlvbiBfZ2V0RWxlbWVudEJvdW5kcyhlbGVtZW50LCBjb250ZXh0KSB7XG4gIGNvbnRleHQgPSBfdG9BcnJheShjb250ZXh0KVswXTtcbiAgdmFyIGlzU1ZHID0gZWxlbWVudC5nZXRCQm94ICYmIGVsZW1lbnQub3duZXJTVkdFbGVtZW50LFxuICAgICAgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IF9kb2MsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHQsXG4gICAgICB0b3AsXG4gICAgICBib3R0b20sXG4gICAgICBtYXRyaXgsXG4gICAgICBwMSxcbiAgICAgIHAyLFxuICAgICAgcDMsXG4gICAgICBwNCxcbiAgICAgIGJib3gsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGNzO1xuXG4gIGlmIChlbGVtZW50ID09PSBfd2luKSB7XG4gICAgdG9wID0gX2dldERvY1Njcm9sbFRvcChkb2MpO1xuICAgIGxlZnQgPSBfZ2V0RG9jU2Nyb2xsTGVmdChkb2MpO1xuICAgIHJpZ2h0ID0gbGVmdCArIChkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IGVsZW1lbnQuaW5uZXJXaWR0aCB8fCBkb2MuYm9keS5jbGllbnRXaWR0aCB8fCAwKTtcbiAgICBib3R0b20gPSB0b3AgKyAoKGVsZW1lbnQuaW5uZXJIZWlnaHQgfHwgMCkgLSAyMCA8IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ID8gZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgOiBlbGVtZW50LmlubmVySGVpZ2h0IHx8IGRvYy5ib2R5LmNsaWVudEhlaWdodCB8fCAwKTsgLy9zb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpIGlnbm9yZSBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgZWxlbWVudHMsIGFuZCBjb2xsYXBzZSB0aGUgaGVpZ2h0IG9mIHRoZSBkb2N1bWVudEVsZW1lbnQsIHNvIGl0IGNvdWxkIGJlIDhweCwgZm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIGp1c3QgYW4gYWJzb2x1dGVseSBwb3NpdGlvbmVkIGRpdi4gSW4gdGhhdCBjYXNlLCB3ZSB1c2UgdGhlIGlubmVySGVpZ2h0IHRvIHJlc29sdmUgdGhpcy5cbiAgfSBlbHNlIGlmIChjb250ZXh0ID09PSBfd2luIHx8IF9pc1VuZGVmaW5lZChjb250ZXh0KSkge1xuICAgIHJldHVybiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9IGVsc2Uge1xuICAgIGxlZnQgPSB0b3AgPSAwO1xuXG4gICAgaWYgKGlzU1ZHKSB7XG4gICAgICBiYm94ID0gZWxlbWVudC5nZXRCQm94KCk7XG4gICAgICB3aWR0aCA9IGJib3gud2lkdGg7XG4gICAgICBoZWlnaHQgPSBiYm94LmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVsZW1lbnQudmlld0JveCAmJiAoYmJveCA9IGVsZW1lbnQudmlld0JveC5iYXNlVmFsKSkge1xuICAgICAgICBsZWZ0ID0gYmJveC54IHx8IDA7XG4gICAgICAgIHRvcCA9IGJib3gueSB8fCAwO1xuICAgICAgICB3aWR0aCA9IGJib3gud2lkdGg7XG4gICAgICAgIGhlaWdodCA9IGJib3guaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXdpZHRoKSB7XG4gICAgICAgIGNzID0gX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgICAgIGJib3ggPSBjcy5ib3hTaXppbmcgPT09IFwiYm9yZGVyLWJveFwiO1xuICAgICAgICB3aWR0aCA9IChwYXJzZUZsb2F0KGNzLndpZHRoKSB8fCBlbGVtZW50LmNsaWVudFdpZHRoIHx8IDApICsgKGJib3ggPyAwIDogcGFyc2VGbG9hdChjcy5ib3JkZXJMZWZ0V2lkdGgpICsgcGFyc2VGbG9hdChjcy5ib3JkZXJSaWdodFdpZHRoKSk7XG4gICAgICAgIGhlaWdodCA9IChwYXJzZUZsb2F0KGNzLmhlaWdodCkgfHwgZWxlbWVudC5jbGllbnRIZWlnaHQgfHwgMCkgKyAoYmJveCA/IDAgOiBwYXJzZUZsb2F0KGNzLmJvcmRlclRvcFdpZHRoKSArIHBhcnNlRmxvYXQoY3MuYm9yZGVyQm90dG9tV2lkdGgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByaWdodCA9IHdpZHRoO1xuICAgIGJvdHRvbSA9IGhlaWdodDtcbiAgfVxuXG4gIGlmIChlbGVtZW50ID09PSBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICB0b3A6IHRvcCxcbiAgICAgIHdpZHRoOiByaWdodCAtIGxlZnQsXG4gICAgICBoZWlnaHQ6IGJvdHRvbSAtIHRvcFxuICAgIH07XG4gIH1cblxuICBtYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoY29udGV4dCwgdHJ1ZSkubXVsdGlwbHkoZ2V0R2xvYmFsTWF0cml4KGVsZW1lbnQpKTtcbiAgcDEgPSBtYXRyaXguYXBwbHkoe1xuICAgIHg6IGxlZnQsXG4gICAgeTogdG9wXG4gIH0pO1xuICBwMiA9IG1hdHJpeC5hcHBseSh7XG4gICAgeDogcmlnaHQsXG4gICAgeTogdG9wXG4gIH0pO1xuICBwMyA9IG1hdHJpeC5hcHBseSh7XG4gICAgeDogcmlnaHQsXG4gICAgeTogYm90dG9tXG4gIH0pO1xuICBwNCA9IG1hdHJpeC5hcHBseSh7XG4gICAgeDogbGVmdCxcbiAgICB5OiBib3R0b21cbiAgfSk7XG4gIGxlZnQgPSBNYXRoLm1pbihwMS54LCBwMi54LCBwMy54LCBwNC54KTtcbiAgdG9wID0gTWF0aC5taW4ocDEueSwgcDIueSwgcDMueSwgcDQueSk7XG4gIHJldHVybiB7XG4gICAgbGVmdDogbGVmdCxcbiAgICB0b3A6IHRvcCxcbiAgICB3aWR0aDogTWF0aC5tYXgocDEueCwgcDIueCwgcDMueCwgcDQueCkgLSBsZWZ0LFxuICAgIGhlaWdodDogTWF0aC5tYXgocDEueSwgcDIueSwgcDMueSwgcDQueSkgLSB0b3BcbiAgfTtcbn0sXG4gICAgX3BhcnNlSW5lcnRpYSA9IGZ1bmN0aW9uIF9wYXJzZUluZXJ0aWEoZHJhZ2dhYmxlLCBzbmFwLCBtYXgsIG1pbiwgZmFjdG9yLCBmb3JjZVplcm9WZWxvY2l0eSkge1xuICB2YXIgdmFycyA9IHt9LFxuICAgICAgYSxcbiAgICAgIGksXG4gICAgICBsO1xuXG4gIGlmIChzbmFwKSB7XG4gICAgaWYgKGZhY3RvciAhPT0gMSAmJiBzbmFwIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIC8vc29tZSBkYXRhIG11c3QgYmUgYWx0ZXJlZCB0byBtYWtlIHNlbnNlLCBsaWtlIGlmIHRoZSB1c2VyIHBhc3NlcyBpbiBhbiBhcnJheSBvZiByb3RhdGlvbmFsIHZhbHVlcyBpbiBkZWdyZWVzLCB3ZSBtdXN0IGNvbnZlcnQgaXQgdG8gcmFkaWFucy4gT3IgZm9yIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCwgd2UgaW52ZXJ0IHRoZSB2YWx1ZXMuXG4gICAgICB2YXJzLmVuZCA9IGEgPSBbXTtcbiAgICAgIGwgPSBzbmFwLmxlbmd0aDtcblxuICAgICAgaWYgKF9pc09iamVjdChzbmFwWzBdKSkge1xuICAgICAgICAvL2lmIHRoZSBhcnJheSBpcyBwb3B1bGF0ZWQgd2l0aCBvYmplY3RzLCBsaWtlIHBvaW50cyAoe3g6MTAwLCB5OjIwMH0pLCBtYWtlIGNvcGllcyBiZWZvcmUgbXVsdGlwbHlpbmcgYnkgdGhlIGZhY3Rvciwgb3RoZXJ3aXNlIHdlJ2xsIG1lc3MgdXAgdGhlIG9yaWdpbmFscyBhbmQgdGhlIHVzZXIgbWF5IHJldXNlIGl0IGVsc2V3aGVyZS5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGFbaV0gPSBfY29weShzbmFwW2ldLCBmYWN0b3IpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgYVtpXSA9IHNuYXBbaV0gKiBmYWN0b3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWF4ICs9IDEuMTsgLy9hbGxvdyAxLjEgcGl4ZWxzIG9mIHdpZ2dsZSByb29tIHdoZW4gc25hcHBpbmcgaW4gb3JkZXIgdG8gd29yayBhcm91bmQgc29tZSBicm93c2VyIGluY29uc2lzdGVuY2llcyBpbiB0aGUgd2F5IGJvdW5kcyBhcmUgcmVwb3J0ZWQgd2hpY2ggY2FuIG1ha2UgdGhlbSByb3VnaGx5IGEgcGl4ZWwgb2ZmLiBGb3IgZXhhbXBsZSwgaWYgXCJzbmFwOlstJCgnI21lbnUnKS53aWR0aCgpLCAwXVwiIHdhcyBkZWZpbmVkIGFuZCAjbWVudSBoYWQgYSB3cmFwcGVyIHRoYXQgd2FzIHVzZWQgYXMgdGhlIGJvdW5kcywgc29tZSBicm93c2VycyB3b3VsZCBiZSBvbmUgcGl4ZWwgb2ZmLCBtYWtpbmcgdGhlIG1pbmltdW0gLTc1MiBmb3IgZXhhbXBsZSB3aGVuIHNuYXAgd2FzIFstNzUzLDBdLCB0aHVzIGluc3RlYWQgb2Ygc25hcHBpbmcgdG8gLTc1MywgaXQgd291bGQgc25hcCB0byAwIHNpbmNlIC03NTMgd2FzIGJlbG93IHRoZSBtaW5pbXVtLlxuXG4gICAgICBtaW4gLT0gMS4xO1xuICAgIH0gZWxzZSBpZiAoX2lzRnVuY3Rpb24oc25hcCkpIHtcbiAgICAgIHZhcnMuZW5kID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBzbmFwLmNhbGwoZHJhZ2dhYmxlLCB2YWx1ZSksXG4gICAgICAgICAgICBjb3B5LFxuICAgICAgICAgICAgcDtcblxuICAgICAgICBpZiAoZmFjdG9yICE9PSAxKSB7XG4gICAgICAgICAgaWYgKF9pc09iamVjdChyZXN1bHQpKSB7XG4gICAgICAgICAgICBjb3B5ID0ge307XG5cbiAgICAgICAgICAgIGZvciAocCBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgY29weVtwXSA9IHJlc3VsdFtwXSAqIGZhY3RvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gY29weTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICo9IGZhY3RvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0OyAvL3dlIG5lZWQgdG8gZW5zdXJlIHRoYXQgd2UgY2FuIHNjb3BlIHRoZSBmdW5jdGlvbiBjYWxsIHRvIHRoZSBEcmFnZ2FibGUgaW5zdGFuY2UgaXRzZWxmIHNvIHRoYXQgdXNlcnMgY2FuIGFjY2VzcyBpbXBvcnRhbnQgdmFsdWVzIGxpa2UgbWF4WCwgbWluWCwgbWF4WSwgbWluWSwgeCwgYW5kIHkgZnJvbSB3aXRoaW4gdGhhdCBmdW5jdGlvbi5cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhcnMuZW5kID0gc25hcDtcbiAgICB9XG4gIH1cblxuICBpZiAobWF4IHx8IG1heCA9PT0gMCkge1xuICAgIHZhcnMubWF4ID0gbWF4O1xuICB9XG5cbiAgaWYgKG1pbiB8fCBtaW4gPT09IDApIHtcbiAgICB2YXJzLm1pbiA9IG1pbjtcbiAgfVxuXG4gIGlmIChmb3JjZVplcm9WZWxvY2l0eSkge1xuICAgIHZhcnMudmVsb2NpdHkgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHZhcnM7XG59LFxuICAgIF9pc0NsaWNrYWJsZSA9IGZ1bmN0aW9uIF9pc0NsaWNrYWJsZShlbGVtZW50KSB7XG4gIC8vc29tZXRpbWVzIGl0J3MgY29udmVuaWVudCB0byBtYXJrIGFuIGVsZW1lbnQgYXMgY2xpY2thYmxlIGJ5IGFkZGluZyBhIGRhdGEtY2xpY2thYmxlPVwidHJ1ZVwiIGF0dHJpYnV0ZSAoaW4gd2hpY2ggY2FzZSB3ZSB3b24ndCBwcmV2ZW50RGVmYXVsdCgpIHRoZSBtb3VzZS90b3VjaCBldmVudCkuIFRoaXMgbWV0aG9kIGNoZWNrcyBpZiB0aGUgZWxlbWVudCBpcyBhbiA8YT4sIDxpbnB1dD4sIG9yIDxidXR0b24+IG9yIGhhcyB0aGUgZGF0YS1jbGlja2FibGUgb3IgY29udGVudEVkaXRhYmxlIGF0dHJpYnV0ZSBzZXQgdG8gdHJ1ZSAob3IgYW55IG9mIGl0cyBwYXJlbnQgZWxlbWVudHMpLlxuICB2YXIgZGF0YTtcbiAgcmV0dXJuICFlbGVtZW50IHx8ICFlbGVtZW50LmdldEF0dHJpYnV0ZSB8fCBlbGVtZW50ID09PSBfYm9keSA/IGZhbHNlIDogKGRhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY2xpY2thYmxlXCIpKSA9PT0gXCJ0cnVlXCIgfHwgZGF0YSAhPT0gXCJmYWxzZVwiICYmIChfY2xpY2thYmxlVGFnRXhwLnRlc3QoZWxlbWVudC5ub2RlTmFtZSArIFwiXCIpIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIpID09PSBcInRydWVcIikgPyB0cnVlIDogX2lzQ2xpY2thYmxlKGVsZW1lbnQucGFyZW50Tm9kZSk7XG59LFxuICAgIF9zZXRTZWxlY3RhYmxlID0gZnVuY3Rpb24gX3NldFNlbGVjdGFibGUoZWxlbWVudHMsIHNlbGVjdGFibGUpIHtcbiAgdmFyIGkgPSBlbGVtZW50cy5sZW5ndGgsXG4gICAgICBlO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBlID0gZWxlbWVudHNbaV07XG4gICAgZS5vbmRyYWdzdGFydCA9IGUub25zZWxlY3RzdGFydCA9IHNlbGVjdGFibGUgPyBudWxsIDogX2VtcHR5RnVuYztcbiAgICBnc2FwLnNldChlLCB7XG4gICAgICBsYXp5OiB0cnVlLFxuICAgICAgdXNlclNlbGVjdDogc2VsZWN0YWJsZSA/IFwidGV4dFwiIDogXCJub25lXCJcbiAgICB9KTtcbiAgfVxufSxcbiAgICBfaXNGaXhlZCA9IGZ1bmN0aW9uIF9pc0ZpeGVkKGVsZW1lbnQpIHtcbiAgaWYgKF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSBcImZpeGVkXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIC8vIGF2b2lkIGRvY3VtZW50IGZyYWdtZW50cyB3aGljaCB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIHJldHVybiBfaXNGaXhlZChlbGVtZW50KTtcbiAgfVxufSxcbiAgICBfc3VwcG9ydHMzRCxcbiAgICBfYWRkUGFkZGluZ0JSLFxuICAgIC8vVGhlIFNjcm9sbFByb3h5IGNsYXNzIHdyYXBzIGFuIGVsZW1lbnQncyBjb250ZW50cyBpbnRvIGFub3RoZXIgZGl2ICh3ZSBjYWxsIGl0IFwiY29udGVudFwiKSB0aGF0IHdlIGVpdGhlciBhZGQgcGFkZGluZyB3aGVuIG5lY2Vzc2FyeSBvciBhcHBseSBhIHRyYW5zbGF0ZTNkKCkgdHJhbnNmb3JtIGluIG9yZGVyIHRvIG92ZXJzY3JvbGwgKHNjcm9sbCBwYXN0IHRoZSBib3VuZGFyaWVzKS4gVGhpcyBhbGxvd3MgdXMgdG8gc2ltcGx5IHNldCB0aGUgc2Nyb2xsVG9wL3Njcm9sbExlZnQgKG9yIHRvcC9sZWZ0IGZvciBlYXNpZXIgcmV2ZXJzZS1heGlzIG9yaWVudGF0aW9uLCB3aGljaCBpcyB3aGF0IHdlIGRvIGluIERyYWdnYWJsZSkgYW5kIGl0J2xsIGRvIGFsbCB0aGUgd29yayBmb3IgdXMuIEZvciBleGFtcGxlLCBpZiB3ZSB0cmllZCBzZXR0aW5nIHNjcm9sbFRvcCB0byAtMTAwIG9uIGEgbm9ybWFsIERPTSBlbGVtZW50LCBpdCB3b3VsZG4ndCB3b3JrIC0gaXQnZCBsb29rIHRoZSBzYW1lIGFzIHNldHRpbmcgaXQgdG8gMCwgYnV0IGlmIHdlIHNldCBzY3JvbGxUb3Agb2YgYSBTY3JvbGxQcm94eSB0byAtMTAwLCBpdCdsbCBnaXZlIHRoZSBjb3JyZWN0IGFwcGVhcmFuY2UgYnkgZWl0aGVyIHNldHRpbmcgcGFkZGluZ1RvcCBvZiB0aGUgd3JhcHBlciB0byAxMDAgb3IgYXBwbHlpbmcgYSAxMDAtcGl4ZWwgdHJhbnNsYXRlWS5cblNjcm9sbFByb3h5ID0gZnVuY3Rpb24gU2Nyb2xsUHJveHkoZWxlbWVudCwgdmFycykge1xuICBlbGVtZW50ID0gZ3NhcC51dGlscy50b0FycmF5KGVsZW1lbnQpWzBdO1xuICB2YXJzID0gdmFycyB8fCB7fTtcbiAgdmFyIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgc3R5bGUgPSBjb250ZW50LnN0eWxlLFxuICAgICAgbm9kZSA9IGVsZW1lbnQuZmlyc3RDaGlsZCxcbiAgICAgIG9mZnNldFRvcCA9IDAsXG4gICAgICBvZmZzZXRMZWZ0ID0gMCxcbiAgICAgIHByZXZUb3AgPSBlbGVtZW50LnNjcm9sbFRvcCxcbiAgICAgIHByZXZMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsV2lkdGggPSBlbGVtZW50LnNjcm9sbFdpZHRoLFxuICAgICAgc2Nyb2xsSGVpZ2h0ID0gZWxlbWVudC5zY3JvbGxIZWlnaHQsXG4gICAgICBleHRyYVBhZFJpZ2h0ID0gMCxcbiAgICAgIG1heExlZnQgPSAwLFxuICAgICAgbWF4VG9wID0gMCxcbiAgICAgIGVsZW1lbnRXaWR0aCxcbiAgICAgIGVsZW1lbnRIZWlnaHQsXG4gICAgICBjb250ZW50SGVpZ2h0LFxuICAgICAgbmV4dE5vZGUsXG4gICAgICB0cmFuc2Zvcm1TdGFydCxcbiAgICAgIHRyYW5zZm9ybUVuZDtcblxuICBpZiAoX3N1cHBvcnRzM0QgJiYgdmFycy5mb3JjZTNEICE9PSBmYWxzZSkge1xuICAgIHRyYW5zZm9ybVN0YXJ0ID0gXCJ0cmFuc2xhdGUzZChcIjtcbiAgICB0cmFuc2Zvcm1FbmQgPSBcInB4LDBweClcIjtcbiAgfSBlbHNlIGlmIChfdHJhbnNmb3JtUHJvcCkge1xuICAgIHRyYW5zZm9ybVN0YXJ0ID0gXCJ0cmFuc2xhdGUoXCI7XG4gICAgdHJhbnNmb3JtRW5kID0gXCJweClcIjtcbiAgfVxuXG4gIHRoaXMuc2Nyb2xsVG9wID0gZnVuY3Rpb24gKHZhbHVlLCBmb3JjZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC10aGlzLnRvcCgpO1xuICAgIH1cblxuICAgIHRoaXMudG9wKC12YWx1ZSwgZm9yY2UpO1xuICB9O1xuXG4gIHRoaXMuc2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9yY2UpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtdGhpcy5sZWZ0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5sZWZ0KC12YWx1ZSwgZm9yY2UpO1xuICB9O1xuXG4gIHRoaXMubGVmdCA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9yY2UpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtKGVsZW1lbnQuc2Nyb2xsTGVmdCArIG9mZnNldExlZnQpO1xuICAgIH1cblxuICAgIHZhciBkaWYgPSBlbGVtZW50LnNjcm9sbExlZnQgLSBwcmV2TGVmdCxcbiAgICAgICAgb2xkT2Zmc2V0ID0gb2Zmc2V0TGVmdDtcblxuICAgIGlmICgoZGlmID4gMiB8fCBkaWYgPCAtMikgJiYgIWZvcmNlKSB7XG4gICAgICAvL2lmIHRoZSB1c2VyIGludGVyYWN0cyB3aXRoIHRoZSBzY3JvbGxiYXIgKG9yIHNvbWV0aGluZyBlbHNlIHNjcm9sbHMgaXQsIGxpa2UgdGhlIG1vdXNlIHdoZWVsKSwgd2Ugc2hvdWxkIGtpbGwgYW55IHR3ZWVucyBvZiB0aGUgU2Nyb2xsUHJveHkuXG4gICAgICBwcmV2TGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgIGdzYXAua2lsbFR3ZWVuc09mKHRoaXMsIHtcbiAgICAgICAgbGVmdDogMSxcbiAgICAgICAgc2Nyb2xsTGVmdDogMVxuICAgICAgfSk7XG4gICAgICB0aGlzLmxlZnQoLXByZXZMZWZ0KTtcblxuICAgICAgaWYgKHZhcnMub25LaWxsKSB7XG4gICAgICAgIHZhcnMub25LaWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IC12YWx1ZTsgLy9pbnZlcnQgYmVjYXVzZSBzY3JvbGxpbmcgd29ya3MgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuXG4gICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgb2Zmc2V0TGVmdCA9IHZhbHVlIC0gMC41IHwgMDtcbiAgICAgIHZhbHVlID0gMDtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID4gbWF4TGVmdCkge1xuICAgICAgb2Zmc2V0TGVmdCA9IHZhbHVlIC0gbWF4TGVmdCB8IDA7XG4gICAgICB2YWx1ZSA9IG1heExlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldExlZnQgPSAwO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXRMZWZ0IHx8IG9sZE9mZnNldCkge1xuICAgICAgaWYgKCF0aGlzLl9za2lwKSB7XG4gICAgICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybVN0YXJ0ICsgLW9mZnNldExlZnQgKyBcInB4LFwiICsgLW9mZnNldFRvcCArIHRyYW5zZm9ybUVuZDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9mZnNldExlZnQgKyBleHRyYVBhZFJpZ2h0ID49IDApIHtcbiAgICAgICAgc3R5bGUucGFkZGluZ1JpZ2h0ID0gb2Zmc2V0TGVmdCArIGV4dHJhUGFkUmlnaHQgKyBcInB4XCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gdmFsdWUgfCAwO1xuICAgIHByZXZMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0OyAvL2Rvbid0IG1lcmdlIHRoaXMgd2l0aCB0aGUgbGluZSBhYm92ZSBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgYWRqdXN0IHRoZSBzY3JvbGxMZWZ0IGFmdGVyIGl0J3Mgc2V0LCBzbyBpbiBvcmRlciB0byBiZSAxMDAlIGFjY3VyYXRlIGluIHRyYWNraW5nIGl0LCB3ZSBuZWVkIHRvIGFzayB0aGUgYnJvd3NlciB0byByZXBvcnQgaXQuXG4gIH07XG5cbiAgdGhpcy50b3AgPSBmdW5jdGlvbiAodmFsdWUsIGZvcmNlKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLShlbGVtZW50LnNjcm9sbFRvcCArIG9mZnNldFRvcCk7XG4gICAgfVxuXG4gICAgdmFyIGRpZiA9IGVsZW1lbnQuc2Nyb2xsVG9wIC0gcHJldlRvcCxcbiAgICAgICAgb2xkT2Zmc2V0ID0gb2Zmc2V0VG9wO1xuXG4gICAgaWYgKChkaWYgPiAyIHx8IGRpZiA8IC0yKSAmJiAhZm9yY2UpIHtcbiAgICAgIC8vaWYgdGhlIHVzZXIgaW50ZXJhY3RzIHdpdGggdGhlIHNjcm9sbGJhciAob3Igc29tZXRoaW5nIGVsc2Ugc2Nyb2xscyBpdCwgbGlrZSB0aGUgbW91c2Ugd2hlZWwpLCB3ZSBzaG91bGQga2lsbCBhbnkgdHdlZW5zIG9mIHRoZSBTY3JvbGxQcm94eS5cbiAgICAgIHByZXZUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgIGdzYXAua2lsbFR3ZWVuc09mKHRoaXMsIHtcbiAgICAgICAgdG9wOiAxLFxuICAgICAgICBzY3JvbGxUb3A6IDFcbiAgICAgIH0pO1xuICAgICAgdGhpcy50b3AoLXByZXZUb3ApO1xuXG4gICAgICBpZiAodmFycy5vbktpbGwpIHtcbiAgICAgICAgdmFycy5vbktpbGwoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhbHVlID0gLXZhbHVlOyAvL2ludmVydCBiZWNhdXNlIHNjcm9sbGluZyB3b3JrcyBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG5cbiAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICBvZmZzZXRUb3AgPSB2YWx1ZSAtIDAuNSB8IDA7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA+IG1heFRvcCkge1xuICAgICAgb2Zmc2V0VG9wID0gdmFsdWUgLSBtYXhUb3AgfCAwO1xuICAgICAgdmFsdWUgPSBtYXhUb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldFRvcCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldFRvcCB8fCBvbGRPZmZzZXQpIHtcbiAgICAgIGlmICghdGhpcy5fc2tpcCkge1xuICAgICAgICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1TdGFydCArIC1vZmZzZXRMZWZ0ICsgXCJweCxcIiArIC1vZmZzZXRUb3AgKyB0cmFuc2Zvcm1FbmQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxlbWVudC5zY3JvbGxUb3AgPSB2YWx1ZSB8IDA7XG4gICAgcHJldlRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICB9O1xuXG4gIHRoaXMubWF4U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtYXhUb3A7XG4gIH07XG5cbiAgdGhpcy5tYXhTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtYXhMZWZ0O1xuICB9O1xuXG4gIHRoaXMuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBub2RlID0gY29udGVudC5maXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICBub2RlID0gbmV4dE5vZGU7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQgPT09IGNvbnRlbnQucGFyZW50Tm9kZSkge1xuICAgICAgLy9pbiBjYXNlIGRpc2FibGUoKSBpcyBjYWxsZWQgd2hlbiBpdCdzIGFscmVhZHkgZGlzYWJsZWQuXG4gICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGNvbnRlbnQpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBub2RlID0gZWxlbWVudC5maXJzdENoaWxkO1xuXG4gICAgaWYgKG5vZGUgPT09IGNvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgbmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgY29udGVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgICB9XG5cbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIHRoaXMuY2FsaWJyYXRlKCk7XG4gIH07XG5cbiAgdGhpcy5jYWxpYnJhdGUgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICB2YXIgd2lkdGhNYXRjaGVzID0gZWxlbWVudC5jbGllbnRXaWR0aCA9PT0gZWxlbWVudFdpZHRoLFxuICAgICAgICBjcyxcbiAgICAgICAgeCxcbiAgICAgICAgeTtcbiAgICBwcmV2VG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgcHJldkxlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XG5cbiAgICBpZiAod2lkdGhNYXRjaGVzICYmIGVsZW1lbnQuY2xpZW50SGVpZ2h0ID09PSBlbGVtZW50SGVpZ2h0ICYmIGNvbnRlbnQub2Zmc2V0SGVpZ2h0ID09PSBjb250ZW50SGVpZ2h0ICYmIHNjcm9sbFdpZHRoID09PSBlbGVtZW50LnNjcm9sbFdpZHRoICYmIHNjcm9sbEhlaWdodCA9PT0gZWxlbWVudC5zY3JvbGxIZWlnaHQgJiYgIWZvcmNlKSB7XG4gICAgICByZXR1cm47IC8vbm8gbmVlZCB0byByZWNhbGN1bGF0ZSB0aGluZ3MgaWYgdGhlIHdpZHRoIGFuZCBoZWlnaHQgaGF2ZW4ndCBjaGFuZ2VkLlxuICAgIH1cblxuICAgIGlmIChvZmZzZXRUb3AgfHwgb2Zmc2V0TGVmdCkge1xuICAgICAgeCA9IHRoaXMubGVmdCgpO1xuICAgICAgeSA9IHRoaXMudG9wKCk7XG4gICAgICB0aGlzLmxlZnQoLWVsZW1lbnQuc2Nyb2xsTGVmdCk7XG4gICAgICB0aGlzLnRvcCgtZWxlbWVudC5zY3JvbGxUb3ApO1xuICAgIH1cblxuICAgIGNzID0gX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7IC8vZmlyc3QsIHdlIG5lZWQgdG8gcmVtb3ZlIGFueSB3aWR0aCBjb25zdHJhaW50cyB0byBzZWUgaG93IHRoZSBjb250ZW50IG5hdHVyYWxseSBmbG93cyBzbyB0aGF0IHdlIGNhbiBzZWUgaWYgaXQncyB3aWRlciB0aGFuIHRoZSBjb250YWluaW5nIGVsZW1lbnQuIElmIHNvLCB3ZSd2ZSBnb3QgdG8gcmVjb3JkIHRoZSBhbW91bnQgb2Ygb3ZlcmFnZSBzbyB0aGF0IHdlIGNhbiBhcHBseSB0aGF0IGFzIHBhZGRpbmcgaW4gb3JkZXIgZm9yIGJyb3dzZXJzIHRvIGNvcnJlY3RseSBoYW5kbGUgdGhpbmdzLiBUaGVuIHdlIHN3aXRjaCBiYWNrIHRvIGEgd2lkdGggb2YgMTAwJSAod2l0aG91dCB0aGF0LCBzb21lIGJyb3dzZXJzIGRvbid0IGZsb3cgdGhlIGNvbnRlbnQgY29ycmVjdGx5KVxuXG4gICAgaWYgKCF3aWR0aE1hdGNoZXMgfHwgZm9yY2UpIHtcbiAgICAgIHN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBzdHlsZS53aWR0aCA9IFwiYXV0b1wiO1xuICAgICAgc3R5bGUucGFkZGluZ1JpZ2h0ID0gXCIwcHhcIjtcbiAgICAgIGV4dHJhUGFkUmlnaHQgPSBNYXRoLm1heCgwLCBlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudC5jbGllbnRXaWR0aCk7IC8vaWYgdGhlIGNvbnRlbnQgaXMgd2lkZXIgdGhhbiB0aGUgY29udGFpbmVyLCB3ZSBuZWVkIHRvIGFkZCB0aGUgcGFkZGluZ0xlZnQgYW5kIHBhZGRpbmdSaWdodCBpbiBvcmRlciBmb3IgdGhpbmdzIHRvIGJlaGF2ZSBjb3JyZWN0bHkuXG5cbiAgICAgIGlmIChleHRyYVBhZFJpZ2h0KSB7XG4gICAgICAgIGV4dHJhUGFkUmlnaHQgKz0gcGFyc2VGbG9hdChjcy5wYWRkaW5nTGVmdCkgKyAoX2FkZFBhZGRpbmdCUiA/IHBhcnNlRmxvYXQoY3MucGFkZGluZ1JpZ2h0KSA6IDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgIHN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgIHN0eWxlLm92ZXJmbG93ID0gXCJ2aXNpYmxlXCI7XG4gICAgc3R5bGUudmVydGljYWxBbGlnbiA9IFwidG9wXCI7XG4gICAgc3R5bGUuYm94U2l6aW5nID0gXCJjb250ZW50LWJveFwiO1xuICAgIHN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgc3R5bGUucGFkZGluZ1JpZ2h0ID0gZXh0cmFQYWRSaWdodCArIFwicHhcIjsgLy9zb21lIGJyb3dzZXJzIG5lZ2xlY3QgdG8gZmFjdG9yIGluIHRoZSBib3R0b20gcGFkZGluZyB3aGVuIGNhbGN1bGF0aW5nIHRoZSBzY3JvbGxIZWlnaHQsIHNvIHdlIG5lZWQgdG8gYWRkIHRoYXQgcGFkZGluZyB0byB0aGUgY29udGVudCB3aGVuIHRoYXQgaGFwcGVucy4gQWxsb3cgYSAycHggbWFyZ2luIGZvciBlcnJvclxuXG4gICAgaWYgKF9hZGRQYWRkaW5nQlIpIHtcbiAgICAgIHN0eWxlLnBhZGRpbmdCb3R0b20gPSBjcy5wYWRkaW5nQm90dG9tO1xuICAgIH1cblxuICAgIGVsZW1lbnRXaWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgZWxlbWVudEhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIHNjcm9sbFdpZHRoID0gZWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICBzY3JvbGxIZWlnaHQgPSBlbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgICBtYXhMZWZ0ID0gZWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnRXaWR0aDtcbiAgICBtYXhUb3AgPSBlbGVtZW50LnNjcm9sbEhlaWdodCAtIGVsZW1lbnRIZWlnaHQ7XG4gICAgY29udGVudEhlaWdodCA9IGNvbnRlbnQub2Zmc2V0SGVpZ2h0O1xuICAgIHN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cbiAgICBpZiAoeCB8fCB5KSB7XG4gICAgICB0aGlzLmxlZnQoeCk7XG4gICAgICB0aGlzLnRvcCh5KTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgdGhpcy5fc2tpcCA9IGZhbHNlO1xuICB0aGlzLmVuYWJsZSgpO1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUocmVxdWlyZWQpIHtcbiAgaWYgKF93aW5kb3dFeGlzdHMoKSAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgdmFyIG5hdiA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xuICAgIF93aW4gPSB3aW5kb3c7XG4gICAgX2RvYyA9IGRvY3VtZW50O1xuICAgIF9kb2NFbGVtZW50ID0gX2RvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgX2JvZHkgPSBfZG9jLmJvZHk7XG4gICAgX3RlbXBEaXYgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBfc3VwcG9ydHNQb2ludGVyID0gISF3aW5kb3cuUG9pbnRlckV2ZW50O1xuICAgIF9wbGFjZWhvbGRlckRpdiA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIF9wbGFjZWhvbGRlckRpdi5zdHlsZS5jc3NUZXh0ID0gXCJ2aXNpYmlsaXR5OmhpZGRlbjtoZWlnaHQ6MXB4O3RvcDotMXB4O3BvaW50ZXItZXZlbnRzOm5vbmU7cG9zaXRpb246cmVsYXRpdmU7Y2xlYXI6Ym90aDtjdXJzb3I6Z3JhYlwiO1xuICAgIF9kZWZhdWx0Q3Vyc29yID0gX3BsYWNlaG9sZGVyRGl2LnN0eWxlLmN1cnNvciA9PT0gXCJncmFiXCIgPyBcImdyYWJcIiA6IFwibW92ZVwiO1xuICAgIF9pc0FuZHJvaWQgPSBuYXYgJiYgbmF2LnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJhbmRyb2lkXCIpICE9PSAtMTsgLy9BbmRyb2lkIGhhbmRsZXMgdG91Y2ggZXZlbnRzIGluIGFuIG9kZCB3YXkgYW5kIGl0J3MgdmlydHVhbGx5IGltcG9zc2libGUgdG8gXCJmZWF0dXJlIHRlc3RcIiBzbyB3ZSByZXNvcnQgdG8gVUEgc25pZmZpbmdcblxuICAgIF9pc1RvdWNoRGV2aWNlID0gXCJvbnRvdWNoc3RhcnRcIiBpbiBfZG9jRWxlbWVudCAmJiBcIm9yaWVudGF0aW9uXCIgaW4gX3dpbiB8fCBuYXYgJiYgKG5hdi5NYXhUb3VjaFBvaW50cyA+IDAgfHwgbmF2Lm1zTWF4VG91Y2hQb2ludHMgPiAwKTtcblxuICAgIF9hZGRQYWRkaW5nQlIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvL3RoaXMgZnVuY3Rpb24gaXMgaW4gY2hhcmdlIG9mIGFuYWx5emluZyBicm93c2VyIGJlaGF2aW9yIHJlbGF0ZWQgdG8gcGFkZGluZy4gSXQgc2V0cyB0aGUgX2FkZFBhZGRpbmdCUiB0byB0cnVlIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgbm9ybWFsbHkgZmFjdG9yIGluIHRoZSBib3R0b20gb3IgcmlnaHQgcGFkZGluZyBvbiB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIHNjcm9sbGluZyBhcmVhLCBhbmQgaXQgc2V0cyBfYWRkUGFkZGluZ0xlZnQgdG8gdHJ1ZSBpZiBpdCdzIGEgYnJvd3NlciB0aGF0IHJlcXVpcmVzIHRoZSBleHRyYSBvZmZzZXQgKG9mZnNldExlZnQpIHRvIGJlIGFkZGVkIHRvIHRoZSBwYWRkaW5nUmlnaHQgKGxpa2UgT3BlcmEpLlxuICAgICAgdmFyIGRpdiA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICAgIGNoaWxkID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgY2hpbGRTdHlsZSA9IGNoaWxkLnN0eWxlLFxuICAgICAgICAgIHBhcmVudCA9IF9ib2R5LFxuICAgICAgICAgIHZhbDtcblxuICAgICAgY2hpbGRTdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgIGNoaWxkU3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICBkaXYuc3R5bGUuY3NzVGV4dCA9IFwid2lkdGg6OTBweDtoZWlnaHQ6NDBweDtwYWRkaW5nOjEwcHg7b3ZlcmZsb3c6YXV0bzt2aXNpYmlsaXR5OmhpZGRlblwiO1xuICAgICAgZGl2LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgdmFsID0gY2hpbGQub2Zmc2V0SGVpZ2h0ICsgMTggPiBkaXYuc2Nyb2xsSGVpZ2h0OyAvL2Rpdi5zY3JvbGxIZWlnaHQgc2hvdWxkIGJlIGNoaWxkLm9mZnNldEhlaWdodCArIDIwIGJlY2F1c2Ugb2YgdGhlIDEwcHggb2YgcGFkZGluZyBvbiBlYWNoIHNpZGUsIGJ1dCBzb21lIGJyb3dzZXJzIGlnbm9yZSBvbmUgc2lkZS4gV2UgYWxsb3cgYSAycHggbWFyZ2luIG9mIGVycm9yLlxuXG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSgpO1xuXG4gICAgX3RvdWNoRXZlbnRMb29rdXAgPSBmdW5jdGlvbiAodHlwZXMpIHtcbiAgICAgIC8vd2UgY3JlYXRlIGFuIG9iamVjdCB0aGF0IG1ha2VzIGl0IGVhc3kgdG8gdHJhbnNsYXRlIHRvdWNoIGV2ZW50IHR5cGVzIGludG8gdGhlaXIgXCJwb2ludGVyXCIgY291bnRlcnBhcnRzIGlmIHdlJ3JlIGluIGEgYnJvd3NlciB0aGF0IHVzZXMgdGhvc2UgaW5zdGVhZC4gTGlrZSBJRTEwIHVzZXMgXCJNU1BvaW50ZXJEb3duXCIgaW5zdGVhZCBvZiBcInRvdWNoc3RhcnRcIiwgZm9yIGV4YW1wbGUuXG4gICAgICB2YXIgc3RhbmRhcmQgPSB0eXBlcy5zcGxpdChcIixcIiksXG4gICAgICAgICAgY29udmVydGVkID0gKFwib25wb2ludGVyZG93blwiIGluIF90ZW1wRGl2ID8gXCJwb2ludGVyZG93bixwb2ludGVybW92ZSxwb2ludGVydXAscG9pbnRlcmNhbmNlbFwiIDogXCJvbm1zcG9pbnRlcmRvd25cIiBpbiBfdGVtcERpdiA/IFwiTVNQb2ludGVyRG93bixNU1BvaW50ZXJNb3ZlLE1TUG9pbnRlclVwLE1TUG9pbnRlckNhbmNlbFwiIDogdHlwZXMpLnNwbGl0KFwiLFwiKSxcbiAgICAgICAgICBvYmogPSB7fSxcbiAgICAgICAgICBpID0gNDtcblxuICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICAgIG9ialtzdGFuZGFyZFtpXV0gPSBjb252ZXJ0ZWRbaV07XG4gICAgICAgIG9ialtjb252ZXJ0ZWRbaV1dID0gc3RhbmRhcmRbaV07XG4gICAgICB9IC8vdG8gYXZvaWQgcHJvYmxlbXMgaW4gaU9TIDksIHRlc3QgdG8gc2VlIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBcInBhc3NpdmVcIiBvcHRpb24gb24gYWRkRXZlbnRMaXN0ZW5lcigpLlxuXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIF9kb2NFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsIG51bGwsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJwYXNzaXZlXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIF9zdXBwb3J0c1Bhc3NpdmUgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9KFwidG91Y2hzdGFydCx0b3VjaG1vdmUsdG91Y2hlbmQsdG91Y2hjYW5jZWxcIik7XG5cbiAgICBfYWRkTGlzdGVuZXIoX2RvYywgXCJ0b3VjaGNhbmNlbFwiLCBfZW1wdHlGdW5jKTsgLy9zb21lIG9sZGVyIEFuZHJvaWQgZGV2aWNlcyBpbnRlcm1pdHRlbnRseSBzdG9wIGRpc3BhdGNoaW5nIFwidG91Y2htb3ZlXCIgZXZlbnRzIGlmIHdlIGRvbid0IGxpc3RlbiBmb3IgXCJ0b3VjaGNhbmNlbFwiIG9uIHRoZSBkb2N1bWVudC4gVmVyeSBzdHJhbmdlIGluZGVlZC5cblxuXG4gICAgX2FkZExpc3RlbmVyKF93aW4sIFwidG91Y2htb3ZlXCIsIF9lbXB0eUZ1bmMpOyAvL3dvcmtzIGFyb3VuZCBTYWZhcmkgYnVncyB0aGF0IHN0aWxsIGFsbG93IHRoZSBwYWdlIHRvIHNjcm9sbCBldmVuIHdoZW4gd2UgcHJldmVudERlZmF1bHQoKSBvbiB0aGUgdG91Y2htb3ZlIGV2ZW50LlxuXG5cbiAgICBfYm9keSAmJiBfYm9keS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBfZW1wdHlGdW5jKTsgLy93b3JrcyBhcm91bmQgU2FmYXJpIGJ1ZzogaHR0cHM6Ly9nc2FwLmNvbS9mb3J1bXMvdG9waWMvMjE0NTAtZHJhZ2dhYmxlLWluLWlmcmFtZS1vbi1tb2JpbGUtaXMtYnVnZ3kvXG5cbiAgICBfYWRkTGlzdGVuZXIoX2RvYywgXCJjb250ZXh0bWVudVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBwIGluIF9sb29rdXApIHtcbiAgICAgICAgaWYgKF9sb29rdXBbcF0uaXNQcmVzc2VkKSB7XG4gICAgICAgICAgX2xvb2t1cFtwXS5lbmREcmFnKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGdzYXAgPSBfY29yZUluaXR0ZWQgPSBfZ2V0R1NBUCgpO1xuICB9XG5cbiAgaWYgKGdzYXApIHtcbiAgICBJbmVydGlhUGx1Z2luID0gZ3NhcC5wbHVnaW5zLmluZXJ0aWE7XG5cbiAgICBfY29udGV4dCA9IGdzYXAuY29yZS5jb250ZXh0IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgX2NoZWNrUHJlZml4ID0gZ3NhcC51dGlscy5jaGVja1ByZWZpeDtcbiAgICBfdHJhbnNmb3JtUHJvcCA9IF9jaGVja1ByZWZpeChfdHJhbnNmb3JtUHJvcCk7XG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfY2hlY2tQcmVmaXgoX3RyYW5zZm9ybU9yaWdpblByb3ApO1xuICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgIF9nZXRTdHlsZVNhdmVyID0gZ3NhcC5jb3JlLmdldFN0eWxlU2F2ZXI7XG4gICAgX3N1cHBvcnRzM0QgPSAhIV9jaGVja1ByZWZpeChcInBlcnNwZWN0aXZlXCIpO1xuICB9IGVsc2UgaWYgKHJlcXVpcmVkKSB7XG4gICAgY29uc29sZS53YXJuKFwiUGxlYXNlIGdzYXAucmVnaXN0ZXJQbHVnaW4oRHJhZ2dhYmxlKVwiKTtcbiAgfVxufTtcblxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcih0YXJnZXQpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldCB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0gfHwgKHRoaXMuX2xpc3RlbmVyc1t0eXBlXSA9IFtdKTtcblxuICAgIGlmICghfmxpc3QuaW5kZXhPZihjYWxsYmFjaykpIHtcbiAgICAgIGxpc3QucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaykge1xuICAgIHZhciBsaXN0ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdLFxuICAgICAgICBpID0gbGlzdCAmJiBsaXN0LmluZGV4T2YoY2FsbGJhY2spO1xuICAgIGkgPj0gMCAmJiBsaXN0LnNwbGljZShpLCAxKTtcbiAgfTtcblxuICBfcHJvdG8uZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodHlwZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgcmVzdWx0O1xuICAgICh0aGlzLl9saXN0ZW5lcnNbdHlwZV0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChfdGhpcywge1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB0YXJnZXQ6IF90aGlzLnRhcmdldFxuICAgICAgfSkgPT09IGZhbHNlICYmIChyZXN1bHQgPSBmYWxzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDsgLy9pZiBhbnkgb2YgdGhlIGNhbGxiYWNrcyByZXR1cm4gZmFsc2UsIHBhc3MgdGhhdCBhbG9uZy5cbiAgfTtcblxuICByZXR1cm4gRXZlbnREaXNwYXRjaGVyO1xufSgpO1xuXG5leHBvcnQgdmFyIERyYWdnYWJsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50RGlzcGF0Y2hlcikge1xuICBfaW5oZXJpdHNMb29zZShEcmFnZ2FibGUsIF9FdmVudERpc3BhdGNoZXIpO1xuXG4gIGZ1bmN0aW9uIERyYWdnYWJsZSh0YXJnZXQsIHZhcnMpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgX3RoaXMyID0gX0V2ZW50RGlzcGF0Y2hlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX2NvcmVJbml0dGVkIHx8IF9pbml0Q29yZSgxKTtcbiAgICB0YXJnZXQgPSBfdG9BcnJheSh0YXJnZXQpWzBdOyAvL2luIGNhc2UgdGhlIHRhcmdldCBpcyBhIHNlbGVjdG9yIG9iamVjdCBvciBzZWxlY3RvciB0ZXh0XG5cbiAgICBfdGhpczIuc3R5bGVzID0gX2dldFN0eWxlU2F2ZXIgJiYgX2dldFN0eWxlU2F2ZXIodGFyZ2V0LCBcInRyYW5zZm9ybSxsZWZ0LHRvcFwiKTtcblxuICAgIGlmICghSW5lcnRpYVBsdWdpbikge1xuICAgICAgSW5lcnRpYVBsdWdpbiA9IGdzYXAucGx1Z2lucy5pbmVydGlhO1xuICAgIH1cblxuICAgIF90aGlzMi52YXJzID0gdmFycyA9IF9jb3B5KHZhcnMgfHwge30pO1xuICAgIF90aGlzMi50YXJnZXQgPSB0YXJnZXQ7XG4gICAgX3RoaXMyLnggPSBfdGhpczIueSA9IF90aGlzMi5yb3RhdGlvbiA9IDA7XG4gICAgX3RoaXMyLmRyYWdSZXNpc3RhbmNlID0gcGFyc2VGbG9hdCh2YXJzLmRyYWdSZXNpc3RhbmNlKSB8fCAwO1xuICAgIF90aGlzMi5lZGdlUmVzaXN0YW5jZSA9IGlzTmFOKHZhcnMuZWRnZVJlc2lzdGFuY2UpID8gMSA6IHBhcnNlRmxvYXQodmFycy5lZGdlUmVzaXN0YW5jZSkgfHwgMDtcbiAgICBfdGhpczIubG9ja0F4aXMgPSB2YXJzLmxvY2tBeGlzO1xuICAgIF90aGlzMi5hdXRvU2Nyb2xsID0gdmFycy5hdXRvU2Nyb2xsIHx8IDA7XG4gICAgX3RoaXMyLmxvY2tlZEF4aXMgPSBudWxsO1xuICAgIF90aGlzMi5hbGxvd0V2ZW50RGVmYXVsdCA9ICEhdmFycy5hbGxvd0V2ZW50RGVmYXVsdDtcbiAgICBnc2FwLmdldFByb3BlcnR5KHRhcmdldCwgXCJ4XCIpOyAvLyB0byBlbnN1cmUgdGhhdCB0cmFuc2Zvcm1zIGFyZSBpbnN0YW50aWF0ZWQuXG5cbiAgICB2YXIgdHlwZSA9ICh2YXJzLnR5cGUgfHwgXCJ4LHlcIikudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgeHlNb2RlID0gfnR5cGUuaW5kZXhPZihcInhcIikgfHwgfnR5cGUuaW5kZXhPZihcInlcIiksXG4gICAgICAgIHJvdGF0aW9uTW9kZSA9IHR5cGUuaW5kZXhPZihcInJvdGF0aW9uXCIpICE9PSAtMSxcbiAgICAgICAgeFByb3AgPSByb3RhdGlvbk1vZGUgPyBcInJvdGF0aW9uXCIgOiB4eU1vZGUgPyBcInhcIiA6IFwibGVmdFwiLFxuICAgICAgICB5UHJvcCA9IHh5TW9kZSA/IFwieVwiIDogXCJ0b3BcIixcbiAgICAgICAgYWxsb3dYID0gISEofnR5cGUuaW5kZXhPZihcInhcIikgfHwgfnR5cGUuaW5kZXhPZihcImxlZnRcIikgfHwgdHlwZSA9PT0gXCJzY3JvbGxcIiksXG4gICAgICAgIGFsbG93WSA9ICEhKH50eXBlLmluZGV4T2YoXCJ5XCIpIHx8IH50eXBlLmluZGV4T2YoXCJ0b3BcIikgfHwgdHlwZSA9PT0gXCJzY3JvbGxcIiksXG4gICAgICAgIG1pbmltdW1Nb3ZlbWVudCA9IHZhcnMubWluaW11bU1vdmVtZW50IHx8IDIsXG4gICAgICAgIHNlbGYgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMiksXG4gICAgICAgIHRyaWdnZXJzID0gX3RvQXJyYXkodmFycy50cmlnZ2VyIHx8IHZhcnMuaGFuZGxlIHx8IHRhcmdldCksXG4gICAgICAgIGtpbGxQcm9wcyA9IHt9LFxuICAgICAgICBkcmFnRW5kVGltZSA9IDAsXG4gICAgICAgIGNoZWNrQXV0b1Njcm9sbEJvdW5kcyA9IGZhbHNlLFxuICAgICAgICBhdXRvU2Nyb2xsTWFyZ2luVG9wID0gdmFycy5hdXRvU2Nyb2xsTWFyZ2luVG9wIHx8IDQwLFxuICAgICAgICBhdXRvU2Nyb2xsTWFyZ2luUmlnaHQgPSB2YXJzLmF1dG9TY3JvbGxNYXJnaW5SaWdodCB8fCA0MCxcbiAgICAgICAgYXV0b1Njcm9sbE1hcmdpbkJvdHRvbSA9IHZhcnMuYXV0b1Njcm9sbE1hcmdpbkJvdHRvbSB8fCA0MCxcbiAgICAgICAgYXV0b1Njcm9sbE1hcmdpbkxlZnQgPSB2YXJzLmF1dG9TY3JvbGxNYXJnaW5MZWZ0IHx8IDQwLFxuICAgICAgICBpc0NsaWNrYWJsZSA9IHZhcnMuY2xpY2thYmxlVGVzdCB8fCBfaXNDbGlja2FibGUsXG4gICAgICAgIGNsaWNrVGltZSA9IDAsXG4gICAgICAgIGdzQ2FjaGUgPSB0YXJnZXQuX2dzYXAgfHwgZ3NhcC5jb3JlLmdldENhY2hlKHRhcmdldCksXG4gICAgICAgIGlzRml4ZWQgPSBfaXNGaXhlZCh0YXJnZXQpLFxuICAgICAgICBnZXRQcm9wQXNOdW0gPSBmdW5jdGlvbiBnZXRQcm9wQXNOdW0ocHJvcGVydHksIHVuaXQpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KGdzQ2FjaGUuZ2V0KHRhcmdldCwgcHJvcGVydHksIHVuaXQpKTtcbiAgICB9LFxuICAgICAgICBvd25lckRvYyA9IHRhcmdldC5vd25lckRvY3VtZW50IHx8IF9kb2MsXG4gICAgICAgIGVuYWJsZWQsXG4gICAgICAgIHNjcm9sbFByb3h5LFxuICAgICAgICBzdGFydFBvaW50ZXJYLFxuICAgICAgICBzdGFydFBvaW50ZXJZLFxuICAgICAgICBzdGFydEVsZW1lbnRYLFxuICAgICAgICBzdGFydEVsZW1lbnRZLFxuICAgICAgICBoYXNCb3VuZHMsXG4gICAgICAgIGhhc0RyYWdDYWxsYmFjayxcbiAgICAgICAgaGFzTW92ZUNhbGxiYWNrLFxuICAgICAgICBtYXhYLFxuICAgICAgICBtaW5YLFxuICAgICAgICBtYXhZLFxuICAgICAgICBtaW5ZLFxuICAgICAgICB0b3VjaCxcbiAgICAgICAgdG91Y2hJRCxcbiAgICAgICAgcm90YXRpb25PcmlnaW4sXG4gICAgICAgIGRpcnR5LFxuICAgICAgICBvbGQsXG4gICAgICAgIHNuYXBYLFxuICAgICAgICBzbmFwWSxcbiAgICAgICAgc25hcFhZLFxuICAgICAgICBpc0NsaWNraW5nLFxuICAgICAgICB0b3VjaEV2ZW50VGFyZ2V0LFxuICAgICAgICBtYXRyaXgsXG4gICAgICAgIGludGVycnVwdGVkLFxuICAgICAgICBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nLFxuICAgICAgICB0b3VjaERyYWdBeGlzLFxuICAgICAgICBpc0Rpc3BhdGNoaW5nLFxuICAgICAgICBjbGlja0Rpc3BhdGNoLFxuICAgICAgICB0cnVzdGVkQ2xpY2tEaXNwYXRjaCxcbiAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCxcbiAgICAgICAgaW5uZXJNYXRyaXgsXG4gICAgICAgIGRyYWdnZWQsXG4gICAgICAgIG9uQ29udGV4dE1lbnUgPSBmdW5jdGlvbiBvbkNvbnRleHRNZW51KGUpIHtcbiAgICAgIC8vdXNlZCB0byBwcmV2ZW50IGxvbmctdG91Y2ggZnJvbSB0cmlnZ2VyaW5nIGEgY29udGV4dCBtZW51LlxuICAgICAgLy8gKHNlbGYuaXNQcmVzc2VkICYmIGUud2hpY2ggPCAyKSAmJiBzZWxmLmVuZERyYWcoKSAvLyBwcmV2aW91c2x5IGVuZGVkIGRyYWcgd2hlbiBjb250ZXh0IG1lbnUgd2FzIHRyaWdnZXJlZCwgYnV0IGluc3RlYWQgd2Ugc2hvdWxkIGp1c3Qgc3RvcCBwcm9wYWdhdGlvbiBhbmQgcHJldmVudCB0aGUgZGVmYXVsdCBldmVudCBiZWhhdmlvci5cbiAgICAgIF9wcmV2ZW50RGVmYXVsdChlKTtcblxuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gJiYgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgICAgICAvL3RoaXMgbWV0aG9kIGdldHMgY2FsbGVkIG9uIGV2ZXJ5IHRpY2sgb2YgVHdlZW5MaXRlLnRpY2tlciB3aGljaCBhbGxvd3MgdXMgdG8gc3luY2hyb25pemUgdGhlIHJlbmRlcnMgdG8gdGhlIGNvcmUgZW5naW5lICh3aGljaCBpcyB0eXBpY2FsbHkgc3luY2hyb25pemVkIHdpdGggdGhlIGRpc3BsYXkgcmVmcmVzaCB2aWEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKS4gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gLSBpdCdzIGJldHRlciB0aGFuIGFwcGx5aW5nIHRoZSB2YWx1ZXMgaW5zaWRlIHRoZSBcIm1vdXNlbW92ZVwiIG9yIFwidG91Y2htb3ZlXCIgZXZlbnQgaGFuZGxlciB3aGljaCBtYXkgZ2V0IGNhbGxlZCBtYW55IHRpbWVzIGluYmV0d2VlbiByZWZyZXNoZXMuXG4gICAgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHN1cHByZXNzRXZlbnRzKSB7XG4gICAgICBpZiAoc2VsZi5hdXRvU2Nyb2xsICYmIHNlbGYuaXNEcmFnZ2luZyAmJiAoY2hlY2tBdXRvU2Nyb2xsQm91bmRzIHx8IGRpcnR5KSkge1xuICAgICAgICB2YXIgZSA9IHRhcmdldCxcbiAgICAgICAgICAgIGF1dG9TY3JvbGxGYWN0b3IgPSBzZWxmLmF1dG9TY3JvbGwgKiAxNSxcbiAgICAgICAgICAgIC8vbXVsdGlwbHlpbmcgYnkgMTUganVzdCBnaXZlcyB1cyBhIGJldHRlciBcImZlZWxcIiBzcGVlZC13aXNlLlxuICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgICBpc1Jvb3QsXG4gICAgICAgICAgICByZWN0LFxuICAgICAgICAgICAgcG9pbnRlclgsXG4gICAgICAgICAgICBwb2ludGVyWSxcbiAgICAgICAgICAgIGNoYW5nZVgsXG4gICAgICAgICAgICBjaGFuZ2VZLFxuICAgICAgICAgICAgZ2FwO1xuICAgICAgICBjaGVja0F1dG9TY3JvbGxCb3VuZHMgPSBmYWxzZTtcbiAgICAgICAgX3dpbmRvd1Byb3h5LnNjcm9sbFRvcCA9IF93aW4ucGFnZVlPZmZzZXQgIT0gbnVsbCA/IF93aW4ucGFnZVlPZmZzZXQgOiBvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wICE9IG51bGwgPyBvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIDogb3duZXJEb2MuYm9keS5zY3JvbGxUb3A7XG4gICAgICAgIF93aW5kb3dQcm94eS5zY3JvbGxMZWZ0ID0gX3dpbi5wYWdlWE9mZnNldCAhPSBudWxsID8gX3dpbi5wYWdlWE9mZnNldCA6IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0ICE9IG51bGwgPyBvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCA6IG93bmVyRG9jLmJvZHkuc2Nyb2xsTGVmdDtcbiAgICAgICAgcG9pbnRlclggPSBzZWxmLnBvaW50ZXJYIC0gX3dpbmRvd1Byb3h5LnNjcm9sbExlZnQ7XG4gICAgICAgIHBvaW50ZXJZID0gc2VsZi5wb2ludGVyWSAtIF93aW5kb3dQcm94eS5zY3JvbGxUb3A7XG5cbiAgICAgICAgd2hpbGUgKGUgJiYgIWlzUm9vdCkge1xuICAgICAgICAgIC8vd2FsayB1cCB0aGUgY2hhaW4gYW5kIHNlbnNlIHdoZXJldmVyIHRoZSBwb2ludGVyIGlzIHdpdGhpbiA0MHB4IG9mIGFuIGVkZ2UgdGhhdCdzIHNjcm9sbGFibGUuXG4gICAgICAgICAgaXNSb290ID0gX2lzUm9vdChlLnBhcmVudE5vZGUpO1xuICAgICAgICAgIHBhcmVudCA9IGlzUm9vdCA/IF93aW5kb3dQcm94eSA6IGUucGFyZW50Tm9kZTtcbiAgICAgICAgICByZWN0ID0gaXNSb290ID8ge1xuICAgICAgICAgICAgYm90dG9tOiBNYXRoLm1heChfZG9jRWxlbWVudC5jbGllbnRIZWlnaHQsIF93aW4uaW5uZXJIZWlnaHQgfHwgMCksXG4gICAgICAgICAgICByaWdodDogTWF0aC5tYXgoX2RvY0VsZW1lbnQuY2xpZW50V2lkdGgsIF93aW4uaW5uZXJXaWR0aCB8fCAwKSxcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgICB9IDogcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIGNoYW5nZVggPSBjaGFuZ2VZID0gMDtcblxuICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgIGdhcCA9IHBhcmVudC5fZ3NNYXhTY3JvbGxZIC0gcGFyZW50LnNjcm9sbFRvcDtcblxuICAgICAgICAgICAgaWYgKGdhcCA8IDApIHtcbiAgICAgICAgICAgICAgY2hhbmdlWSA9IGdhcDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRlclkgPiByZWN0LmJvdHRvbSAtIGF1dG9TY3JvbGxNYXJnaW5Cb3R0b20gJiYgZ2FwKSB7XG4gICAgICAgICAgICAgIGNoZWNrQXV0b1Njcm9sbEJvdW5kcyA9IHRydWU7XG4gICAgICAgICAgICAgIGNoYW5nZVkgPSBNYXRoLm1pbihnYXAsIGF1dG9TY3JvbGxGYWN0b3IgKiAoMSAtIE1hdGgubWF4KDAsIHJlY3QuYm90dG9tIC0gcG9pbnRlclkpIC8gYXV0b1Njcm9sbE1hcmdpbkJvdHRvbSkgfCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRlclkgPCByZWN0LnRvcCArIGF1dG9TY3JvbGxNYXJnaW5Ub3AgJiYgcGFyZW50LnNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICBjaGVja0F1dG9TY3JvbGxCb3VuZHMgPSB0cnVlO1xuICAgICAgICAgICAgICBjaGFuZ2VZID0gLU1hdGgubWluKHBhcmVudC5zY3JvbGxUb3AsIGF1dG9TY3JvbGxGYWN0b3IgKiAoMSAtIE1hdGgubWF4KDAsIHBvaW50ZXJZIC0gcmVjdC50b3ApIC8gYXV0b1Njcm9sbE1hcmdpblRvcCkgfCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoYW5nZVkpIHtcbiAgICAgICAgICAgICAgcGFyZW50LnNjcm9sbFRvcCArPSBjaGFuZ2VZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAgICAgIGdhcCA9IHBhcmVudC5fZ3NNYXhTY3JvbGxYIC0gcGFyZW50LnNjcm9sbExlZnQ7XG5cbiAgICAgICAgICAgIGlmIChnYXAgPCAwKSB7XG4gICAgICAgICAgICAgIGNoYW5nZVggPSBnYXA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvaW50ZXJYID4gcmVjdC5yaWdodCAtIGF1dG9TY3JvbGxNYXJnaW5SaWdodCAmJiBnYXApIHtcbiAgICAgICAgICAgICAgY2hlY2tBdXRvU2Nyb2xsQm91bmRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY2hhbmdlWCA9IE1hdGgubWluKGdhcCwgYXV0b1Njcm9sbEZhY3RvciAqICgxIC0gTWF0aC5tYXgoMCwgcmVjdC5yaWdodCAtIHBvaW50ZXJYKSAvIGF1dG9TY3JvbGxNYXJnaW5SaWdodCkgfCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRlclggPCByZWN0LmxlZnQgKyBhdXRvU2Nyb2xsTWFyZ2luTGVmdCAmJiBwYXJlbnQuc2Nyb2xsTGVmdCkge1xuICAgICAgICAgICAgICBjaGVja0F1dG9TY3JvbGxCb3VuZHMgPSB0cnVlO1xuICAgICAgICAgICAgICBjaGFuZ2VYID0gLU1hdGgubWluKHBhcmVudC5zY3JvbGxMZWZ0LCBhdXRvU2Nyb2xsRmFjdG9yICogKDEgLSBNYXRoLm1heCgwLCBwb2ludGVyWCAtIHJlY3QubGVmdCkgLyBhdXRvU2Nyb2xsTWFyZ2luTGVmdCkgfCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoYW5nZVgpIHtcbiAgICAgICAgICAgICAgcGFyZW50LnNjcm9sbExlZnQgKz0gY2hhbmdlWDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNSb290ICYmIChjaGFuZ2VYIHx8IGNoYW5nZVkpKSB7XG4gICAgICAgICAgICBfd2luLnNjcm9sbFRvKHBhcmVudC5zY3JvbGxMZWZ0LCBwYXJlbnQuc2Nyb2xsVG9wKTtcblxuICAgICAgICAgICAgc2V0UG9pbnRlclBvc2l0aW9uKHNlbGYucG9pbnRlclggKyBjaGFuZ2VYLCBzZWxmLnBvaW50ZXJZICsgY2hhbmdlWSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgdmFyIHggPSBzZWxmLngsXG4gICAgICAgICAgICB5ID0gc2VsZi55O1xuXG4gICAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBzZWxmLmRlbHRhWCA9IHggLSBwYXJzZUZsb2F0KGdzQ2FjaGUucm90YXRpb24pO1xuICAgICAgICAgIHNlbGYucm90YXRpb24gPSB4O1xuICAgICAgICAgIGdzQ2FjaGUucm90YXRpb24gPSB4ICsgXCJkZWdcIjtcbiAgICAgICAgICBnc0NhY2hlLnJlbmRlclRyYW5zZm9ybSgxLCBnc0NhY2hlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2Nyb2xsUHJveHkpIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgICAgc2VsZi5kZWx0YVkgPSB5IC0gc2Nyb2xsUHJveHkudG9wKCk7XG4gICAgICAgICAgICAgIHNjcm9sbFByb3h5LnRvcCh5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgICBzZWxmLmRlbHRhWCA9IHggLSBzY3JvbGxQcm94eS5sZWZ0KCk7XG4gICAgICAgICAgICAgIHNjcm9sbFByb3h5LmxlZnQoeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh4eU1vZGUpIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgICAgc2VsZi5kZWx0YVkgPSB5IC0gcGFyc2VGbG9hdChnc0NhY2hlLnkpO1xuICAgICAgICAgICAgICBnc0NhY2hlLnkgPSB5ICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxsb3dYKSB7XG4gICAgICAgICAgICAgIHNlbGYuZGVsdGFYID0geCAtIHBhcnNlRmxvYXQoZ3NDYWNoZS54KTtcbiAgICAgICAgICAgICAgZ3NDYWNoZS54ID0geCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3NDYWNoZS5yZW5kZXJUcmFuc2Zvcm0oMSwgZ3NDYWNoZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgICAgc2VsZi5kZWx0YVkgPSB5IC0gcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUudG9wIHx8IDApO1xuICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUudG9wID0geSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgICBzZWxmLmRlbHRhWCA9IHggLSBwYXJzZUZsb2F0KHRhcmdldC5zdHlsZS5sZWZ0IHx8IDApO1xuICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUubGVmdCA9IHggKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0RyYWdDYWxsYmFjayAmJiAhc3VwcHJlc3NFdmVudHMgJiYgIWlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTsgLy9pbiBjYXNlIG9uRHJhZyBoYXMgYW4gdXBkYXRlKCkgY2FsbCAoYXZvaWQgZW5kbGVzcyBsb29wKVxuXG4gICAgICAgICAgaWYgKF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiZHJhZ1wiLCBcIm9uRHJhZ1wiKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAgICAgICAgc2VsZi54IC09IHNlbGYuZGVsdGFYO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxsb3dZKSB7XG4gICAgICAgICAgICAgIHNlbGYueSAtPSBzZWxmLmRlbHRhWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyKHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkaXJ0eSA9IGZhbHNlO1xuICAgIH0sXG4gICAgICAgIC8vY29waWVzIHRoZSB4L3kgZnJvbSB0aGUgZWxlbWVudCAod2hldGhlciB0aGF0IGJlIHRyYW5zZm9ybXMsIHRvcC9sZWZ0LCBvciBTY3JvbGxQcm94eSdzIHRvcC9sZWZ0KSB0byB0aGUgRHJhZ2dhYmxlJ3MgeCBhbmQgeSAoYW5kIHJvdGF0aW9uIGlmIG5lY2Vzc2FyeSkgcHJvcGVydGllcyBzbyB0aGF0IHRoZXkgcmVmbGVjdCByZWFsaXR5IGFuZCBpdCBhbHNvIChvcHRpb25hbGx5KSBhcHBsaWVzIGFueSBzbmFwcGluZyBuZWNlc3NhcnkuIFRoaXMgaXMgdXNlZCBieSB0aGUgSW5lcnRpYVBsdWdpbiB0d2VlbiBpbiBhbiBvblVwZGF0ZSB0byBlbnN1cmUgdGhpbmdzIGFyZSBzeW5jZWQgYW5kIHNuYXBwZWQuXG4gICAgc3luY1hZID0gZnVuY3Rpb24gc3luY1hZKHNraXBPblVwZGF0ZSwgc2tpcFNuYXApIHtcbiAgICAgIHZhciB4ID0gc2VsZi54LFxuICAgICAgICAgIHkgPSBzZWxmLnksXG4gICAgICAgICAgc25hcHBlZFZhbHVlLFxuICAgICAgICAgIGNzO1xuXG4gICAgICBpZiAoIXRhcmdldC5fZ3NhcCkge1xuICAgICAgICAvL2p1c3QgaW4gY2FzZSB0aGUgX2dzYXAgY2FjaGUgZ290IHdpcGVkLCBsaWtlIGlmIHRoZSB1c2VyIGNhbGxlZCBjbGVhclByb3BzIG9uIHRoZSB0cmFuc2Zvcm0gb3Igc29tZXRoaW5nICh2ZXJ5IHJhcmUpLlxuICAgICAgICBnc0NhY2hlID0gZ3NhcC5jb3JlLmdldENhY2hlKHRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIGdzQ2FjaGUudW5jYWNoZSAmJiBnc2FwLmdldFByb3BlcnR5KHRhcmdldCwgXCJ4XCIpOyAvLyB0cmlnZ2VyIGEgcmUtY2FjaGVcblxuICAgICAgaWYgKHh5TW9kZSkge1xuICAgICAgICBzZWxmLnggPSBwYXJzZUZsb2F0KGdzQ2FjaGUueCk7XG4gICAgICAgIHNlbGYueSA9IHBhcnNlRmxvYXQoZ3NDYWNoZS55KTtcbiAgICAgIH0gZWxzZSBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgIHNlbGYueCA9IHNlbGYucm90YXRpb24gPSBwYXJzZUZsb2F0KGdzQ2FjaGUucm90YXRpb24pO1xuICAgICAgfSBlbHNlIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICBzZWxmLnkgPSBzY3JvbGxQcm94eS50b3AoKTtcbiAgICAgICAgc2VsZi54ID0gc2Nyb2xsUHJveHkubGVmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi55ID0gcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUudG9wIHx8IChjcyA9IF9nZXRDb21wdXRlZFN0eWxlKHRhcmdldCkpICYmIGNzLnRvcCkgfHwgMDtcbiAgICAgICAgc2VsZi54ID0gcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUubGVmdCB8fCAoY3MgfHwge30pLmxlZnQpIHx8IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICgoc25hcFggfHwgc25hcFkgfHwgc25hcFhZKSAmJiAhc2tpcFNuYXAgJiYgKHNlbGYuaXNEcmFnZ2luZyB8fCBzZWxmLmlzVGhyb3dpbmcpKSB7XG4gICAgICAgIGlmIChzbmFwWFkpIHtcbiAgICAgICAgICBfdGVtcDEueCA9IHNlbGYueDtcbiAgICAgICAgICBfdGVtcDEueSA9IHNlbGYueTtcbiAgICAgICAgICBzbmFwcGVkVmFsdWUgPSBzbmFwWFkoX3RlbXAxKTtcblxuICAgICAgICAgIGlmIChzbmFwcGVkVmFsdWUueCAhPT0gc2VsZi54KSB7XG4gICAgICAgICAgICBzZWxmLnggPSBzbmFwcGVkVmFsdWUueDtcbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc25hcHBlZFZhbHVlLnkgIT09IHNlbGYueSkge1xuICAgICAgICAgICAgc2VsZi55ID0gc25hcHBlZFZhbHVlLnk7XG4gICAgICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNuYXBYKSB7XG4gICAgICAgICAgc25hcHBlZFZhbHVlID0gc25hcFgoc2VsZi54KTtcblxuICAgICAgICAgIGlmIChzbmFwcGVkVmFsdWUgIT09IHNlbGYueCkge1xuICAgICAgICAgICAgc2VsZi54ID0gc25hcHBlZFZhbHVlO1xuXG4gICAgICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgICAgIHNlbGYucm90YXRpb24gPSBzbmFwcGVkVmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc25hcFkpIHtcbiAgICAgICAgICBzbmFwcGVkVmFsdWUgPSBzbmFwWShzZWxmLnkpO1xuXG4gICAgICAgICAgaWYgKHNuYXBwZWRWYWx1ZSAhPT0gc2VsZi55KSB7XG4gICAgICAgICAgICBzZWxmLnkgPSBzbmFwcGVkVmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRpcnR5ICYmIHJlbmRlcih0cnVlKTtcblxuICAgICAgaWYgKCFza2lwT25VcGRhdGUpIHtcbiAgICAgICAgc2VsZi5kZWx0YVggPSBzZWxmLnggLSB4O1xuICAgICAgICBzZWxmLmRlbHRhWSA9IHNlbGYueSAtIHk7XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJ0aHJvd3VwZGF0ZVwiLCBcIm9uVGhyb3dVcGRhdGVcIik7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgYnVpbGRTbmFwRnVuYyA9IGZ1bmN0aW9uIGJ1aWxkU25hcEZ1bmMoc25hcCwgbWluLCBtYXgsIGZhY3Rvcikge1xuICAgICAgaWYgKG1pbiA9PSBudWxsKSB7XG4gICAgICAgIG1pbiA9IC1fYmlnTnVtO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgICAgbWF4ID0gX2JpZ051bTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9pc0Z1bmN0aW9uKHNuYXApKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobikge1xuICAgICAgICAgIHZhciBlZGdlVG9sZXJhbmNlID0gIXNlbGYuaXNQcmVzc2VkID8gMSA6IDEgLSBzZWxmLmVkZ2VSZXNpc3RhbmNlOyAvL2lmIHdlJ3JlIHR3ZWVuaW5nLCBkaXNhYmxlIHRoZSBlZGdlVG9sZXJhbmNlIGJlY2F1c2UgaXQncyBhbHJlYWR5IGZhY3RvcmVkIGludG8gdGhlIHR3ZWVuaW5nIHZhbHVlcyAod2UgZG9uJ3Qgd2FudCB0byBhcHBseSBpdCBtdWx0aXBsZSB0aW1lcylcblxuICAgICAgICAgIHJldHVybiBzbmFwLmNhbGwoc2VsZiwgKG4gPiBtYXggPyBtYXggKyAobiAtIG1heCkgKiBlZGdlVG9sZXJhbmNlIDogbiA8IG1pbiA/IG1pbiArIChuIC0gbWluKSAqIGVkZ2VUb2xlcmFuY2UgOiBuKSAqIGZhY3RvcikgKiBmYWN0b3I7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNBcnJheShzbmFwKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICB2YXIgaSA9IHNuYXAubGVuZ3RoLFxuICAgICAgICAgICAgICBjbG9zZXN0ID0gMCxcbiAgICAgICAgICAgICAgYWJzRGlmID0gX2JpZ051bSxcbiAgICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgICBkaWY7XG5cbiAgICAgICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgICAgIHZhbCA9IHNuYXBbaV07XG4gICAgICAgICAgICBkaWYgPSB2YWwgLSBuO1xuXG4gICAgICAgICAgICBpZiAoZGlmIDwgMCkge1xuICAgICAgICAgICAgICBkaWYgPSAtZGlmO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGlmIDwgYWJzRGlmICYmIHZhbCA+PSBtaW4gJiYgdmFsIDw9IG1heCkge1xuICAgICAgICAgICAgICBjbG9zZXN0ID0gaTtcbiAgICAgICAgICAgICAgYWJzRGlmID0gZGlmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzbmFwW2Nsb3Nlc3RdO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNOYU4oc25hcCkgPyBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzbmFwICogZmFjdG9yO1xuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBidWlsZFBvaW50U25hcEZ1bmMgPSBmdW5jdGlvbiBidWlsZFBvaW50U25hcEZ1bmMoc25hcCwgbWluWCwgbWF4WCwgbWluWSwgbWF4WSwgcmFkaXVzLCBmYWN0b3IpIHtcbiAgICAgIHJhZGl1cyA9IHJhZGl1cyAmJiByYWRpdXMgPCBfYmlnTnVtID8gcmFkaXVzICogcmFkaXVzIDogX2JpZ051bTsgLy9zbyB3ZSBkb24ndCBoYXZlIHRvIE1hdGguc3FydCgpIGluIHRoZSBmdW5jdGlvbnMuIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cblxuICAgICAgaWYgKF9pc0Z1bmN0aW9uKHNuYXApKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICB2YXIgZWRnZVRvbGVyYW5jZSA9ICFzZWxmLmlzUHJlc3NlZCA/IDEgOiAxIC0gc2VsZi5lZGdlUmVzaXN0YW5jZSxcbiAgICAgICAgICAgICAgeCA9IHBvaW50LngsXG4gICAgICAgICAgICAgIHkgPSBwb2ludC55LFxuICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgIGR4LFxuICAgICAgICAgICAgICBkeTsgLy9pZiB3ZSdyZSB0d2VlbmluZywgZGlzYWJsZSB0aGUgZWRnZVRvbGVyYW5jZSBiZWNhdXNlIGl0J3MgYWxyZWFkeSBmYWN0b3JlZCBpbnRvIHRoZSB0d2VlbmluZyB2YWx1ZXMgKHdlIGRvbid0IHdhbnQgdG8gYXBwbHkgaXQgbXVsdGlwbGUgdGltZXMpXG5cbiAgICAgICAgICBwb2ludC54ID0geCA9IHggPiBtYXhYID8gbWF4WCArICh4IC0gbWF4WCkgKiBlZGdlVG9sZXJhbmNlIDogeCA8IG1pblggPyBtaW5YICsgKHggLSBtaW5YKSAqIGVkZ2VUb2xlcmFuY2UgOiB4O1xuICAgICAgICAgIHBvaW50LnkgPSB5ID0geSA+IG1heFkgPyBtYXhZICsgKHkgLSBtYXhZKSAqIGVkZ2VUb2xlcmFuY2UgOiB5IDwgbWluWSA/IG1pblkgKyAoeSAtIG1pblkpICogZWRnZVRvbGVyYW5jZSA6IHk7XG4gICAgICAgICAgcmVzdWx0ID0gc25hcC5jYWxsKHNlbGYsIHBvaW50KTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgIT09IHBvaW50KSB7XG4gICAgICAgICAgICBwb2ludC54ID0gcmVzdWx0Lng7XG4gICAgICAgICAgICBwb2ludC55ID0gcmVzdWx0Lnk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZhY3RvciAhPT0gMSkge1xuICAgICAgICAgICAgcG9pbnQueCAqPSBmYWN0b3I7XG4gICAgICAgICAgICBwb2ludC55ICo9IGZhY3RvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmFkaXVzIDwgX2JpZ051bSkge1xuICAgICAgICAgICAgZHggPSBwb2ludC54IC0geDtcbiAgICAgICAgICAgIGR5ID0gcG9pbnQueSAtIHk7XG5cbiAgICAgICAgICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA+IHJhZGl1cykge1xuICAgICAgICAgICAgICBwb2ludC54ID0geDtcbiAgICAgICAgICAgICAgcG9pbnQueSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoX2lzQXJyYXkoc25hcCkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgdmFyIGkgPSBzbmFwLmxlbmd0aCxcbiAgICAgICAgICAgICAgY2xvc2VzdCA9IDAsXG4gICAgICAgICAgICAgIG1pbkRpc3QgPSBfYmlnTnVtLFxuICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgICAgZGlzdDtcblxuICAgICAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICAgICAgcG9pbnQgPSBzbmFwW2ldO1xuICAgICAgICAgICAgeCA9IHBvaW50LnggLSBwLng7XG4gICAgICAgICAgICB5ID0gcG9pbnQueSAtIHAueTtcbiAgICAgICAgICAgIGRpc3QgPSB4ICogeCArIHkgKiB5O1xuXG4gICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgICAgICAgY2xvc2VzdCA9IGk7XG4gICAgICAgICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBtaW5EaXN0IDw9IHJhZGl1cyA/IHNuYXBbY2xvc2VzdF0gOiBwO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9O1xuICAgIH0sXG4gICAgICAgIGNhbGN1bGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICAgIHZhciBib3VuZHMsIHRhcmdldEJvdW5kcywgc25hcCwgc25hcElzUmF3O1xuICAgICAgaGFzQm91bmRzID0gZmFsc2U7XG5cbiAgICAgIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICBzY3JvbGxQcm94eS5jYWxpYnJhdGUoKTtcbiAgICAgICAgc2VsZi5taW5YID0gbWluWCA9IC1zY3JvbGxQcm94eS5tYXhTY3JvbGxMZWZ0KCk7XG4gICAgICAgIHNlbGYubWluWSA9IG1pblkgPSAtc2Nyb2xsUHJveHkubWF4U2Nyb2xsVG9wKCk7XG4gICAgICAgIHNlbGYubWF4WCA9IG1heFggPSBzZWxmLm1heFkgPSBtYXhZID0gMDtcbiAgICAgICAgaGFzQm91bmRzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoISF2YXJzLmJvdW5kcykge1xuICAgICAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKHZhcnMuYm91bmRzLCB0YXJnZXQucGFyZW50Tm9kZSk7IC8vY291bGQgYmUgYSBzZWxlY3Rvci9qUXVlcnkgb2JqZWN0IG9yIGEgRE9NIGVsZW1lbnQgb3IgYSBnZW5lcmljIG9iamVjdCBsaWtlIHt0b3A6MCwgbGVmdDoxMDAsIHdpZHRoOjEwMDAsIGhlaWdodDo4MDB9IG9yIHttaW5YOjEwMCwgbWF4WDoxMTAwLCBtaW5ZOjAsIG1heFk6ODAwfVxuXG4gICAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBzZWxmLm1pblggPSBtaW5YID0gYm91bmRzLmxlZnQ7XG4gICAgICAgICAgc2VsZi5tYXhYID0gbWF4WCA9IGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoO1xuICAgICAgICAgIHNlbGYubWluWSA9IG1pblkgPSBzZWxmLm1heFkgPSBtYXhZID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICghX2lzVW5kZWZpbmVkKHZhcnMuYm91bmRzLm1heFgpIHx8ICFfaXNVbmRlZmluZWQodmFycy5ib3VuZHMubWF4WSkpIHtcbiAgICAgICAgICBib3VuZHMgPSB2YXJzLmJvdW5kcztcbiAgICAgICAgICBzZWxmLm1pblggPSBtaW5YID0gYm91bmRzLm1pblg7XG4gICAgICAgICAgc2VsZi5taW5ZID0gbWluWSA9IGJvdW5kcy5taW5ZO1xuICAgICAgICAgIHNlbGYubWF4WCA9IG1heFggPSBib3VuZHMubWF4WDtcbiAgICAgICAgICBzZWxmLm1heFkgPSBtYXhZID0gYm91bmRzLm1heFk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0Qm91bmRzID0gX2dldEJvdW5kcyh0YXJnZXQsIHRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgICAgICBzZWxmLm1pblggPSBtaW5YID0gTWF0aC5yb3VuZChnZXRQcm9wQXNOdW0oeFByb3AsIFwicHhcIikgKyBib3VuZHMubGVmdCAtIHRhcmdldEJvdW5kcy5sZWZ0KTtcbiAgICAgICAgICBzZWxmLm1pblkgPSBtaW5ZID0gTWF0aC5yb3VuZChnZXRQcm9wQXNOdW0oeVByb3AsIFwicHhcIikgKyBib3VuZHMudG9wIC0gdGFyZ2V0Qm91bmRzLnRvcCk7XG4gICAgICAgICAgc2VsZi5tYXhYID0gbWF4WCA9IE1hdGgucm91bmQobWluWCArIChib3VuZHMud2lkdGggLSB0YXJnZXRCb3VuZHMud2lkdGgpKTtcbiAgICAgICAgICBzZWxmLm1heFkgPSBtYXhZID0gTWF0aC5yb3VuZChtaW5ZICsgKGJvdW5kcy5oZWlnaHQgLSB0YXJnZXRCb3VuZHMuaGVpZ2h0KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWluWCA+IG1heFgpIHtcbiAgICAgICAgICBzZWxmLm1pblggPSBtYXhYO1xuICAgICAgICAgIHNlbGYubWF4WCA9IG1heFggPSBtaW5YO1xuICAgICAgICAgIG1pblggPSBzZWxmLm1pblg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWluWSA+IG1heFkpIHtcbiAgICAgICAgICBzZWxmLm1pblkgPSBtYXhZO1xuICAgICAgICAgIHNlbGYubWF4WSA9IG1heFkgPSBtaW5ZO1xuICAgICAgICAgIG1pblkgPSBzZWxmLm1pblk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgc2VsZi5taW5Sb3RhdGlvbiA9IG1pblg7XG4gICAgICAgICAgc2VsZi5tYXhSb3RhdGlvbiA9IG1heFg7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNCb3VuZHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFycy5saXZlU25hcCkge1xuICAgICAgICBzbmFwID0gdmFycy5saXZlU25hcCA9PT0gdHJ1ZSA/IHZhcnMuc25hcCB8fCB7fSA6IHZhcnMubGl2ZVNuYXA7XG4gICAgICAgIHNuYXBJc1JhdyA9IF9pc0FycmF5KHNuYXApIHx8IF9pc0Z1bmN0aW9uKHNuYXApO1xuXG4gICAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBzbmFwWCA9IGJ1aWxkU25hcEZ1bmMoc25hcElzUmF3ID8gc25hcCA6IHNuYXAucm90YXRpb24sIG1pblgsIG1heFgsIDEpO1xuICAgICAgICAgIHNuYXBZID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc25hcC5wb2ludHMpIHtcbiAgICAgICAgICAgIHNuYXBYWSA9IGJ1aWxkUG9pbnRTbmFwRnVuYyhzbmFwSXNSYXcgPyBzbmFwIDogc25hcC5wb2ludHMsIG1pblgsIG1heFgsIG1pblksIG1heFksIHNuYXAucmFkaXVzLCBzY3JvbGxQcm94eSA/IC0xIDogMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAgICAgICAgc25hcFggPSBidWlsZFNuYXBGdW5jKHNuYXBJc1JhdyA/IHNuYXAgOiBzbmFwLnggfHwgc25hcC5sZWZ0IHx8IHNuYXAuc2Nyb2xsTGVmdCwgbWluWCwgbWF4WCwgc2Nyb2xsUHJveHkgPyAtMSA6IDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxsb3dZKSB7XG4gICAgICAgICAgICAgIHNuYXBZID0gYnVpbGRTbmFwRnVuYyhzbmFwSXNSYXcgPyBzbmFwIDogc25hcC55IHx8IHNuYXAudG9wIHx8IHNuYXAuc2Nyb2xsVG9wLCBtaW5ZLCBtYXhZLCBzY3JvbGxQcm94eSA/IC0xIDogMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgb25UaHJvd0NvbXBsZXRlID0gZnVuY3Rpb24gb25UaHJvd0NvbXBsZXRlKCkge1xuICAgICAgc2VsZi5pc1Rocm93aW5nID0gZmFsc2U7XG5cbiAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwidGhyb3djb21wbGV0ZVwiLCBcIm9uVGhyb3dDb21wbGV0ZVwiKTtcbiAgICB9LFxuICAgICAgICBvblRocm93SW50ZXJydXB0ID0gZnVuY3Rpb24gb25UaHJvd0ludGVycnVwdCgpIHtcbiAgICAgIHNlbGYuaXNUaHJvd2luZyA9IGZhbHNlO1xuICAgIH0sXG4gICAgICAgIGFuaW1hdGUgPSBmdW5jdGlvbiBhbmltYXRlKGluZXJ0aWEsIGZvcmNlWmVyb1ZlbG9jaXR5KSB7XG4gICAgICB2YXIgc25hcCwgc25hcElzUmF3LCB0d2Vlbiwgb3ZlcnNob290VG9sZXJhbmNlO1xuXG4gICAgICBpZiAoaW5lcnRpYSAmJiBJbmVydGlhUGx1Z2luKSB7XG4gICAgICAgIGlmIChpbmVydGlhID09PSB0cnVlKSB7XG4gICAgICAgICAgc25hcCA9IHZhcnMuc25hcCB8fCB2YXJzLmxpdmVTbmFwIHx8IHt9O1xuICAgICAgICAgIHNuYXBJc1JhdyA9IF9pc0FycmF5KHNuYXApIHx8IF9pc0Z1bmN0aW9uKHNuYXApO1xuICAgICAgICAgIGluZXJ0aWEgPSB7XG4gICAgICAgICAgICByZXNpc3RhbmNlOiAodmFycy50aHJvd1Jlc2lzdGFuY2UgfHwgdmFycy5yZXNpc3RhbmNlIHx8IDEwMDApIC8gKHJvdGF0aW9uTW9kZSA/IDEwIDogMSlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICAgICAgaW5lcnRpYS5yb3RhdGlvbiA9IF9wYXJzZUluZXJ0aWEoc2VsZiwgc25hcElzUmF3ID8gc25hcCA6IHNuYXAucm90YXRpb24sIG1heFgsIG1pblgsIDEsIGZvcmNlWmVyb1ZlbG9jaXR5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgICBpbmVydGlhW3hQcm9wXSA9IF9wYXJzZUluZXJ0aWEoc2VsZiwgc25hcElzUmF3ID8gc25hcCA6IHNuYXAucG9pbnRzIHx8IHNuYXAueCB8fCBzbmFwLmxlZnQsIG1heFgsIG1pblgsIHNjcm9sbFByb3h5ID8gLTEgOiAxLCBmb3JjZVplcm9WZWxvY2l0eSB8fCBzZWxmLmxvY2tlZEF4aXMgPT09IFwieFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFsbG93WSkge1xuICAgICAgICAgICAgICBpbmVydGlhW3lQcm9wXSA9IF9wYXJzZUluZXJ0aWEoc2VsZiwgc25hcElzUmF3ID8gc25hcCA6IHNuYXAucG9pbnRzIHx8IHNuYXAueSB8fCBzbmFwLnRvcCwgbWF4WSwgbWluWSwgc2Nyb2xsUHJveHkgPyAtMSA6IDEsIGZvcmNlWmVyb1ZlbG9jaXR5IHx8IHNlbGYubG9ja2VkQXhpcyA9PT0gXCJ5XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc25hcC5wb2ludHMgfHwgX2lzQXJyYXkoc25hcCkgJiYgX2lzT2JqZWN0KHNuYXBbMF0pKSB7XG4gICAgICAgICAgICAgIGluZXJ0aWEubGlua2VkUHJvcHMgPSB4UHJvcCArIFwiLFwiICsgeVByb3A7XG4gICAgICAgICAgICAgIGluZXJ0aWEucmFkaXVzID0gc25hcC5yYWRpdXM7IC8vbm90ZTogd2UgYWxzbyBkaXNhYmxlIGxpdmVTbmFwcGluZyB3aGlsZSB0aHJvd2luZyBpZiB0aGVyZSdzIGEgXCJyYWRpdXNcIiBkZWZpbmVkLCBvdGhlcndpc2UgaXQgbG9va3Mgd2VpcmQgdG8gaGF2ZSB0aGUgaXRlbSB0aHJvd24gcGFzdCBhIHNuYXBwaW5nIHBvaW50IGJ1dCBsaXZlLXNuYXBwaW5nIG1pZC10d2Vlbi4gV2UgZG8gdGhpcyBieSBhbHRlcmluZyB0aGUgb25VcGRhdGVQYXJhbXMgc28gdGhhdCBcInNraXBTbmFwXCIgcGFyYW1ldGVyIGlzIHRydWUgZm9yIHN5bmNYWS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmlzVGhyb3dpbmcgPSB0cnVlO1xuICAgICAgICBvdmVyc2hvb3RUb2xlcmFuY2UgPSAhaXNOYU4odmFycy5vdmVyc2hvb3RUb2xlcmFuY2UpID8gdmFycy5vdmVyc2hvb3RUb2xlcmFuY2UgOiB2YXJzLmVkZ2VSZXNpc3RhbmNlID09PSAxID8gMCA6IDEgLSBzZWxmLmVkZ2VSZXNpc3RhbmNlICsgMC4yO1xuXG4gICAgICAgIGlmICghaW5lcnRpYS5kdXJhdGlvbikge1xuICAgICAgICAgIGluZXJ0aWEuZHVyYXRpb24gPSB7XG4gICAgICAgICAgICBtYXg6IE1hdGgubWF4KHZhcnMubWluRHVyYXRpb24gfHwgMCwgXCJtYXhEdXJhdGlvblwiIGluIHZhcnMgPyB2YXJzLm1heER1cmF0aW9uIDogMiksXG4gICAgICAgICAgICBtaW46ICFpc05hTih2YXJzLm1pbkR1cmF0aW9uKSA/IHZhcnMubWluRHVyYXRpb24gOiBvdmVyc2hvb3RUb2xlcmFuY2UgPT09IDAgfHwgX2lzT2JqZWN0KGluZXJ0aWEpICYmIGluZXJ0aWEucmVzaXN0YW5jZSA+IDEwMDAgPyAwIDogMC41LFxuICAgICAgICAgICAgb3ZlcnNob290OiBvdmVyc2hvb3RUb2xlcmFuY2VcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi50d2VlbiA9IHR3ZWVuID0gZ3NhcC50byhzY3JvbGxQcm94eSB8fCB0YXJnZXQsIHtcbiAgICAgICAgICBpbmVydGlhOiBpbmVydGlhLFxuICAgICAgICAgIGRhdGE6IFwiX2RyYWdnYWJsZVwiLFxuICAgICAgICAgIGluaGVyaXQ6IGZhbHNlLFxuICAgICAgICAgIG9uQ29tcGxldGU6IG9uVGhyb3dDb21wbGV0ZSxcbiAgICAgICAgICBvbkludGVycnVwdDogb25UaHJvd0ludGVycnVwdCxcbiAgICAgICAgICBvblVwZGF0ZTogdmFycy5mYXN0TW9kZSA/IF9kaXNwYXRjaEV2ZW50IDogc3luY1hZLFxuICAgICAgICAgIG9uVXBkYXRlUGFyYW1zOiB2YXJzLmZhc3RNb2RlID8gW3NlbGYsIFwib250aHJvd3VwZGF0ZVwiLCBcIm9uVGhyb3dVcGRhdGVcIl0gOiBzbmFwICYmIHNuYXAucmFkaXVzID8gW2ZhbHNlLCB0cnVlXSA6IFtdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghdmFycy5mYXN0TW9kZSkge1xuICAgICAgICAgIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICAgICAgc2Nyb2xsUHJveHkuX3NraXAgPSB0cnVlOyAvLyBNaWNyb3NvZnQgYnJvd3NlcnMgaGF2ZSBhIGJ1ZyB0aGF0IGNhdXNlcyB0aGVtIHRvIGJyaWVmbHkgcmVuZGVyIHRoZSBwb3NpdGlvbiBpbmNvcnJlY3RseSAoaXQgZmxhc2hlcyB0byB0aGUgZW5kIHN0YXRlIHdoZW4gd2Ugc2VlaygpIHRoZSB0d2VlbiBldmVuIHRob3VnaCB3ZSBqdW1wIHJpZ2h0IGJhY2sgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24sIGFuZCB0aGlzIG9ubHkgc2VlbXMgdG8gaGFwcGVuIHdoZW4gd2UncmUgYWZmZWN0aW5nIGJvdGggdG9wIGFuZCBsZWZ0KSwgc28gd2Ugc2V0IGEgX3N1c3BlbmRUcmFuc2Zvcm1zIGZsYWcgdG8gcHJldmVudCBpdCBmcm9tIGFjdHVhbGx5IGFwcGx5aW5nIHRoZSB2YWx1ZXMgaW4gdGhlIFNjcm9sbFByb3h5LlxuICAgICAgICAgIH1cblxuICAgICAgICAgIHR3ZWVuLnJlbmRlcigxZTksIHRydWUsIHRydWUpOyAvLyBmb3JjZSB0byB0aGUgZW5kLiBSZW1lbWJlciwgdGhlIGR1cmF0aW9uIHdpbGwgbGlrZWx5IGNoYW5nZSB1cG9uIGluaXR0aW5nIGJlY2F1c2UgdGhhdCdzIHdoZW4gSW5lcnRpYVBsdWdpbiBjYWxjdWxhdGVzIGl0LlxuXG4gICAgICAgICAgc3luY1hZKHRydWUsIHRydWUpO1xuICAgICAgICAgIHNlbGYuZW5kWCA9IHNlbGYueDtcbiAgICAgICAgICBzZWxmLmVuZFkgPSBzZWxmLnk7XG5cbiAgICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgICBzZWxmLmVuZFJvdGF0aW9uID0gc2VsZi54O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHR3ZWVuLnBsYXkoMCk7XG4gICAgICAgICAgc3luY1hZKHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKHNjcm9sbFByb3h5KSB7XG4gICAgICAgICAgICBzY3JvbGxQcm94eS5fc2tpcCA9IGZhbHNlOyAvL01pY3Jvc29mdCBicm93c2VycyBoYXZlIGEgYnVnIHRoYXQgY2F1c2VzIHRoZW0gdG8gYnJpZWZseSByZW5kZXIgdGhlIHBvc2l0aW9uIGluY29ycmVjdGx5IChpdCBmbGFzaGVzIHRvIHRoZSBlbmQgc3RhdGUgd2hlbiB3ZSBzZWVrKCkgdGhlIHR3ZWVuIGV2ZW4gdGhvdWdoIHdlIGp1bXAgcmlnaHQgYmFjayB0byB0aGUgY3VycmVudCBwb3NpdGlvbiwgYW5kIHRoaXMgb25seSBzZWVtcyB0byBoYXBwZW4gd2hlbiB3ZSdyZSBhZmZlY3RpbmcgYm90aCB0b3AgYW5kIGxlZnQpLCBzbyB3ZSBzZXQgYSBfc3VzcGVuZFRyYW5zZm9ybXMgZmxhZyB0byBwcmV2ZW50IGl0IGZyb20gYWN0dWFsbHkgYXBwbHlpbmcgdGhlIHZhbHVlcyBpbiB0aGUgU2Nyb2xsUHJveHkuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhhc0JvdW5kcykge1xuICAgICAgICBzZWxmLmFwcGx5Qm91bmRzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgdXBkYXRlTWF0cml4ID0gZnVuY3Rpb24gdXBkYXRlTWF0cml4KHNoaWZ0U3RhcnQpIHtcbiAgICAgIHZhciBzdGFydCA9IG1hdHJpeCxcbiAgICAgICAgICBwO1xuICAgICAgbWF0cml4ID0gZ2V0R2xvYmFsTWF0cml4KHRhcmdldC5wYXJlbnROb2RlLCB0cnVlKTtcblxuICAgICAgaWYgKHNoaWZ0U3RhcnQgJiYgc2VsZi5pc1ByZXNzZWQgJiYgIW1hdHJpeC5lcXVhbHMoc3RhcnQgfHwgbmV3IE1hdHJpeDJEKCkpKSB7XG4gICAgICAgIC8vaWYgdGhlIG1hdHJpeCBjaGFuZ2VzIFdISUxFIHRoZSBlbGVtZW50IGlzIHByZXNzZWQsIHdlIG11c3QgYWRqdXN0IHRoZSBzdGFydFBvaW50ZXJYIGFuZCBzdGFydFBvaW50ZXJZIGFjY29yZGluZ2x5LCBzbyB3ZSBpbnZlcnQgdGhlIG9yaWdpbmFsIG1hdHJpeCBhbmQgZmlndXJlIG91dCB3aGVyZSB0aGUgcG9pbnRlclggYW5kIHBvaW50ZXJZIHdlcmUgaW4gdGhlIGdsb2JhbCBzcGFjZSwgdGhlbiBhcHBseSB0aGUgbmV3IG1hdHJpeCB0byBnZXQgdGhlIHVwZGF0ZWQgY29vcmRpbmF0ZXMuXG4gICAgICAgIHAgPSBzdGFydC5pbnZlcnNlKCkuYXBwbHkoe1xuICAgICAgICAgIHg6IHN0YXJ0UG9pbnRlclgsXG4gICAgICAgICAgeTogc3RhcnRQb2ludGVyWVxuICAgICAgICB9KTtcbiAgICAgICAgbWF0cml4LmFwcGx5KHAsIHApO1xuICAgICAgICBzdGFydFBvaW50ZXJYID0gcC54O1xuICAgICAgICBzdGFydFBvaW50ZXJZID0gcC55O1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0cml4LmVxdWFscyhfaWRlbnRpdHlNYXRyaXgpKSB7XG4gICAgICAgIC8vaWYgdGhlcmUgYXJlIG5vIHRyYW5zZm9ybXMsIHdlIGNhbiBvcHRpbWl6ZSBwZXJmb3JtYW5jZSBieSBub3QgZmFjdG9yaW5nIGluIHRoZSBtYXRyaXhcbiAgICAgICAgbWF0cml4ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICByZWNvcmRTdGFydFBvc2l0aW9ucyA9IGZ1bmN0aW9uIHJlY29yZFN0YXJ0UG9zaXRpb25zKCkge1xuICAgICAgdmFyIGVkZ2VUb2xlcmFuY2UgPSAxIC0gc2VsZi5lZGdlUmVzaXN0YW5jZSxcbiAgICAgICAgICBvZmZzZXRYID0gaXNGaXhlZCA/IF9nZXREb2NTY3JvbGxMZWZ0KG93bmVyRG9jKSA6IDAsXG4gICAgICAgICAgb2Zmc2V0WSA9IGlzRml4ZWQgPyBfZ2V0RG9jU2Nyb2xsVG9wKG93bmVyRG9jKSA6IDAsXG4gICAgICAgICAgcGFyc2VkT3JpZ2luLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeTtcblxuICAgICAgaWYgKHh5TW9kZSkge1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSB1c2VyIHNldCBpdCBhcyBhIGRpZmZlcmVudCB1bml0LCBsaWtlIGFuaW1hdGluZyB0aGUgeCB0byBcIjEwMCVcIi4gV2UgbXVzdCBjb252ZXJ0IGl0IGJhY2sgdG8gcHghXG4gICAgICAgIGdzQ2FjaGUueCA9IGdldFByb3BBc051bSh4UHJvcCwgXCJweFwiKSArIFwicHhcIjtcbiAgICAgICAgZ3NDYWNoZS55ID0gZ2V0UHJvcEFzTnVtKHlQcm9wLCBcInB4XCIpICsgXCJweFwiO1xuICAgICAgICBnc0NhY2hlLnJlbmRlclRyYW5zZm9ybSgpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVNYXRyaXgoZmFsc2UpO1xuICAgICAgX3BvaW50MS54ID0gc2VsZi5wb2ludGVyWCAtIG9mZnNldFg7XG4gICAgICBfcG9pbnQxLnkgPSBzZWxmLnBvaW50ZXJZIC0gb2Zmc2V0WTtcbiAgICAgIG1hdHJpeCAmJiBtYXRyaXguYXBwbHkoX3BvaW50MSwgX3BvaW50MSk7XG4gICAgICBzdGFydFBvaW50ZXJYID0gX3BvaW50MS54OyAvL3RyYW5zbGF0ZSB0byBsb2NhbCBjb29yZGluYXRlIHN5c3RlbVxuXG4gICAgICBzdGFydFBvaW50ZXJZID0gX3BvaW50MS55O1xuXG4gICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgc2V0UG9pbnRlclBvc2l0aW9uKHNlbGYucG9pbnRlclgsIHNlbGYucG9pbnRlclkpO1xuICAgICAgICByZW5kZXIodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlubmVyTWF0cml4ID0gZ2V0R2xvYmFsTWF0cml4KHRhcmdldCk7XG5cbiAgICAgIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICBjYWxjdWxhdGVCb3VuZHMoKTtcbiAgICAgICAgc3RhcnRFbGVtZW50WSA9IHNjcm9sbFByb3h5LnRvcCgpO1xuICAgICAgICBzdGFydEVsZW1lbnRYID0gc2Nyb2xsUHJveHkubGVmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9pZiB0aGUgZWxlbWVudCBpcyBpbiB0aGUgcHJvY2VzcyBvZiB0d2VlbmluZywgZG9uJ3QgZm9yY2Ugc25hcHBpbmcgdG8gb2NjdXIgYmVjYXVzZSBpdCBjb3VsZCBtYWtlIGl0IGp1bXAuIEltYWdpbmUgdGhlIHVzZXIgdGhyb3dpbmcsIHRoZW4gYmVmb3JlIGl0J3MgZG9uZSwgY2xpY2tpbmcgb24gdGhlIGVsZW1lbnQgaW4gaXRzIGluYmV0d2VlbiBzdGF0ZS5cbiAgICAgICAgaWYgKGlzVHdlZW5pbmcoKSkge1xuICAgICAgICAgIHN5bmNYWSh0cnVlLCB0cnVlKTtcbiAgICAgICAgICBjYWxjdWxhdGVCb3VuZHMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLmFwcGx5Qm91bmRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgcGFyc2VkT3JpZ2luID0gdGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCA/IFtnc0NhY2hlLnhPcmlnaW4gLSB0YXJnZXQuZ2V0QkJveCgpLngsIGdzQ2FjaGUueU9yaWdpbiAtIHRhcmdldC5nZXRCQm94KCkueV0gOiAoX2dldENvbXB1dGVkU3R5bGUodGFyZ2V0KVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gfHwgXCIwIDBcIikuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgIHJvdGF0aW9uT3JpZ2luID0gc2VsZi5yb3RhdGlvbk9yaWdpbiA9IGdldEdsb2JhbE1hdHJpeCh0YXJnZXQpLmFwcGx5KHtcbiAgICAgICAgICAgIHg6IHBhcnNlRmxvYXQocGFyc2VkT3JpZ2luWzBdKSB8fCAwLFxuICAgICAgICAgICAgeTogcGFyc2VGbG9hdChwYXJzZWRPcmlnaW5bMV0pIHx8IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzeW5jWFkodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgeCA9IHNlbGYucG9pbnRlclggLSByb3RhdGlvbk9yaWdpbi54IC0gb2Zmc2V0WDtcbiAgICAgICAgICB5ID0gcm90YXRpb25PcmlnaW4ueSAtIHNlbGYucG9pbnRlclkgKyBvZmZzZXRZO1xuICAgICAgICAgIHN0YXJ0RWxlbWVudFggPSBzZWxmLng7IC8vc3RhcnRpbmcgcm90YXRpb24gKHggYWx3YXlzIHJlZmVycyB0byByb3RhdGlvbiBpbiB0eXBlOlwicm90YXRpb25cIiwgbWVhc3VyZWQgaW4gZGVncmVlcylcblxuICAgICAgICAgIHN0YXJ0RWxlbWVudFkgPSBzZWxmLnkgPSBNYXRoLmF0YW4yKHksIHgpICogX1JBRDJERUc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9wYXJlbnQgPSAhaXNGaXhlZCAmJiB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgICAvL3N0YXJ0U2Nyb2xsVG9wID0gcGFyZW50ID8gcGFyZW50LnNjcm9sbFRvcCB8fCAwIDogMDtcbiAgICAgICAgICAvL3N0YXJ0U2Nyb2xsTGVmdCA9IHBhcmVudCA/IHBhcmVudC5zY3JvbGxMZWZ0IHx8IDAgOiAwO1xuICAgICAgICAgIHN0YXJ0RWxlbWVudFkgPSBnZXRQcm9wQXNOdW0oeVByb3AsIFwicHhcIik7IC8vcmVjb3JkIHRoZSBzdGFydGluZyB0b3AgYW5kIGxlZnQgdmFsdWVzIHNvIHRoYXQgd2UgY2FuIGp1c3QgYWRkIHRoZSBtb3VzZSdzIG1vdmVtZW50IHRvIHRoZW0gbGF0ZXIuXG5cbiAgICAgICAgICBzdGFydEVsZW1lbnRYID0gZ2V0UHJvcEFzTnVtKHhQcm9wLCBcInB4XCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNCb3VuZHMgJiYgZWRnZVRvbGVyYW5jZSkge1xuICAgICAgICBpZiAoc3RhcnRFbGVtZW50WCA+IG1heFgpIHtcbiAgICAgICAgICBzdGFydEVsZW1lbnRYID0gbWF4WCArIChzdGFydEVsZW1lbnRYIC0gbWF4WCkgLyBlZGdlVG9sZXJhbmNlO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0RWxlbWVudFggPCBtaW5YKSB7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WCA9IG1pblggLSAobWluWCAtIHN0YXJ0RWxlbWVudFgpIC8gZWRnZVRvbGVyYW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0RWxlbWVudFkgPiBtYXhZKSB7XG4gICAgICAgICAgICBzdGFydEVsZW1lbnRZID0gbWF4WSArIChzdGFydEVsZW1lbnRZIC0gbWF4WSkgLyBlZGdlVG9sZXJhbmNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRFbGVtZW50WSA8IG1pblkpIHtcbiAgICAgICAgICAgIHN0YXJ0RWxlbWVudFkgPSBtaW5ZIC0gKG1pblkgLSBzdGFydEVsZW1lbnRZKSAvIGVkZ2VUb2xlcmFuY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuc3RhcnRYID0gc3RhcnRFbGVtZW50WCA9IF9yb3VuZChzdGFydEVsZW1lbnRYKTtcbiAgICAgIHNlbGYuc3RhcnRZID0gc3RhcnRFbGVtZW50WSA9IF9yb3VuZChzdGFydEVsZW1lbnRZKTtcbiAgICB9LFxuICAgICAgICBpc1R3ZWVuaW5nID0gZnVuY3Rpb24gaXNUd2VlbmluZygpIHtcbiAgICAgIHJldHVybiBzZWxmLnR3ZWVuICYmIHNlbGYudHdlZW4uaXNBY3RpdmUoKTtcbiAgICB9LFxuICAgICAgICByZW1vdmVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIHJlbW92ZVBsYWNlaG9sZGVyKCkge1xuICAgICAgaWYgKF9wbGFjZWhvbGRlckRpdi5wYXJlbnROb2RlICYmICFpc1R3ZWVuaW5nKCkgJiYgIXNlbGYuaXNEcmFnZ2luZykge1xuICAgICAgICAvL19wbGFjZWhvbGRlckRpdiBqdXN0IHByb3BzIG9wZW4gYXV0by1zY3JvbGxpbmcgY29udGFpbmVycyBzbyB0aGV5IGRvbid0IGNvbGxhcHNlIGFzIHRoZSB1c2VyIGRyYWdzIGxlZnQvdXAuIFdlIHJlbW92ZSBpdCBhZnRlciBkcmFnZ2luZyAoYW5kIHRocm93aW5nLCBpZiBuZWNlc3NhcnkpIGZpbmlzaGVzLlxuICAgICAgICBfcGxhY2Vob2xkZXJEaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfcGxhY2Vob2xkZXJEaXYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIC8vY2FsbGVkIHdoZW4gdGhlIG1vdXNlIGlzIHByZXNzZWQgKG9yIHRvdWNoIHN0YXJ0cylcbiAgICBvblByZXNzID0gZnVuY3Rpb24gb25QcmVzcyhlLCBmb3JjZSkge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGlmICghZW5hYmxlZCB8fCBzZWxmLmlzUHJlc3NlZCB8fCAhZSB8fCAoZS50eXBlID09PSBcIm1vdXNlZG93blwiIHx8IGUudHlwZSA9PT0gXCJwb2ludGVyZG93blwiKSAmJiAhZm9yY2UgJiYgX2dldFRpbWUoKSAtIGNsaWNrVGltZSA8IDMwICYmIF90b3VjaEV2ZW50TG9va3VwW3NlbGYucG9pbnRlckV2ZW50LnR5cGVdKSB7XG4gICAgICAgIC8vd2hlbiB3ZSBET04nVCBwcmV2ZW50RGVmYXVsdCgpIGluIG9yZGVyIHRvIGFjY29tbW9kYXRlIHRvdWNoLXNjcm9sbGluZyBhbmQgdGhlIHVzZXIganVzdCB0YXBzLCBtYW55IGJyb3dzZXJzIGFsc28gZmlyZSBhIG1vdXNlZG93bi9tb3VzZXVwIHNlcXVlbmNlIEFGVEVSIHRoZSB0b3VjaHN0YXJ0L3RvdWNoZW5kIHNlcXVlbmNlLCB0aHVzIGl0J2QgcmVzdWx0IGluIHR3byBxdWljayBcImNsaWNrXCIgZXZlbnRzIGJlaW5nIGRpc3BhdGNoZWQuIFRoaXMgbGluZSBzZW5zZXMgdGhhdCBjb25kaXRpb24gYW5kIGhhbHRzIGl0IG9uIHRoZSBzdWJzZXF1ZW50IG1vdXNlZG93bi5cbiAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCAmJiBlICYmIGVuYWJsZWQgJiYgX3ByZXZlbnREZWZhdWx0KGUpOyAvLyBpbiBzb21lIGJyb3dzZXJzLCB3ZSBtdXN0IGxpc3RlbiBmb3IgbXVsdGlwbGUgZXZlbnQgdHlwZXMgbGlrZSB0b3VjaHN0YXJ0LCBwb2ludGVyZG93biwgbW91c2Vkb3duLiBUaGUgZmlyc3QgdGltZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCwgd2UgcmVjb3JkIHdoZXRoZXIgb3Igbm90IHdlIF9wcmV2ZW50RGVmYXVsdCgpIHNvIHRoYXQgb24gZHVwbGljYXRlIGNhbGxzLCB3ZSBjYW4gZG8gdGhlIHNhbWUgaWYgbmVjZXNzYXJ5LlxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaW50ZXJydXB0ZWQgPSBpc1R3ZWVuaW5nKCk7XG4gICAgICBkcmFnZ2VkID0gZmFsc2U7IC8vIHdlIG5lZWQgdG8gdHJhY2sgd2hldGhlciBvciBub3QgaXQgd2FzIGRyYWdnZWQgaW4gdGhpcyBpbnRlcmFjdGlvbiBzbyB0aGF0IGlmLCBmb3IgZXhhbXBsZSwgdGhlIHVzZXIgY2FsbHMgLmVuZERyYWcoKSB0byBGT1JDRSBpdCB0byBzdG9wIGFuZCB0aGVuIHRoZXkga2VlcCB0aGUgbW91c2UgcHJlc3NlZCBkb3duIGFuZCBldmVudHVhbGx5IHJlbGVhc2UsIHRoYXQgd291bGQgbm9ybWFsbHkgY2F1c2UgYW4gb25DbGljayBidXQgd2UgaGF2ZSB0byBza2lwIGl0IGluIHRoYXQgY2FzZSBpZiB0aGVyZSB3YXMgZHJhZ2dpbmcgdGhhdCBvY2N1cnJlZC5cblxuICAgICAgc2VsZi5wb2ludGVyRXZlbnQgPSBlO1xuXG4gICAgICBpZiAoX3RvdWNoRXZlbnRMb29rdXBbZS50eXBlXSkge1xuICAgICAgICAvL25vdGU6IG9uIGlPUywgQk9USCB0b3VjaG1vdmUgYW5kIG1vdXNlbW92ZSBhcmUgZGlzcGF0Y2hlZCwgYnV0IHRoZSBtb3VzZW1vdmUgaGFzIHBhZ2VZIGFuZCBwYWdlWCBvZiAwIHdoaWNoIHdvdWxkIG1lc3MgdXAgdGhlIGNhbGN1bGF0aW9ucyBhbmQgbmVlZGxlc3NseSBodXJ0IHBlcmZvcm1hbmNlLlxuICAgICAgICB0b3VjaEV2ZW50VGFyZ2V0ID0gfmUudHlwZS5pbmRleE9mKFwidG91Y2hcIikgPyBlLmN1cnJlbnRUYXJnZXQgfHwgZS50YXJnZXQgOiBvd25lckRvYzsgLy9wb2ludGVyLWJhc2VkIHRvdWNoZXMgKGZvciBNaWNyb3NvZnQgYnJvd3NlcnMpIGRvbid0IHJlbWFpbiBsb2NrZWQgdG8gdGhlIG9yaWdpbmFsIHRhcmdldCBsaWtlIG90aGVyIGJyb3dzZXJzLCBzbyB3ZSBtdXN0IHVzZSB0aGUgZG9jdW1lbnQgaW5zdGVhZC4gVGhlIGV2ZW50IHR5cGUgd291bGQgYmUgXCJNU1BvaW50ZXJEb3duXCIgb3IgXCJwb2ludGVyZG93blwiLlxuXG4gICAgICAgIF9hZGRMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNoZW5kXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2htb3ZlXCIsIG9uTW92ZSk7IC8vIHBvc3NpYmxlIGZ1dHVyZSBjaGFuZ2UgaWYgUG9pbnRlckV2ZW50cyBhcmUgbW9yZSBzdGFuZGFyZGl6ZWQ6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L3NldFBvaW50ZXJDYXB0dXJlXG5cblxuICAgICAgICBfYWRkTGlzdGVuZXIodG91Y2hFdmVudFRhcmdldCwgXCJ0b3VjaGNhbmNlbFwiLCBvblJlbGVhc2UpO1xuXG4gICAgICAgIF9hZGRMaXN0ZW5lcihvd25lckRvYywgXCJ0b3VjaHN0YXJ0XCIsIF9vbk11bHRpVG91Y2hEb2N1bWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3VjaEV2ZW50VGFyZ2V0ID0gbnVsbDtcblxuICAgICAgICBfYWRkTGlzdGVuZXIob3duZXJEb2MsIFwibW91c2Vtb3ZlXCIsIG9uTW92ZSk7IC8vYXR0YWNoIHRoZXNlIHRvIHRoZSBkb2N1bWVudCBpbnN0ZWFkIG9mIHRoZSBib3ggaXRzZWxmIHNvIHRoYXQgaWYgdGhlIHVzZXIncyBtb3VzZSBtb3ZlcyB0b28gcXVpY2tseSAoYW5kIG9mZiBvZiB0aGUgYm94KSwgdGhpbmdzIHN0aWxsIHdvcmsuXG5cbiAgICAgIH1cblxuICAgICAgdG91Y2hEcmFnQXhpcyA9IG51bGw7XG5cbiAgICAgIGlmICghX3N1cHBvcnRzUG9pbnRlciB8fCAhdG91Y2hFdmVudFRhcmdldCkge1xuICAgICAgICBfYWRkTGlzdGVuZXIob3duZXJEb2MsIFwibW91c2V1cFwiLCBvblJlbGVhc2UpO1xuXG4gICAgICAgIGUgJiYgZS50YXJnZXQgJiYgX2FkZExpc3RlbmVyKGUudGFyZ2V0LCBcIm1vdXNldXBcIiwgb25SZWxlYXNlKTsgLy93ZSBhbHNvIGhhdmUgdG8gbGlzdGVuIGRpcmVjdGx5IG9uIHRoZSBlbGVtZW50IGJlY2F1c2Ugc29tZSBicm93c2VycyBkb24ndCBidWJibGUgdXAgdGhlIGV2ZW50IHRvIHRoZSBfZG9jIG9uIGVsZW1lbnRzIHdpdGggY29udGVudEVkaXRhYmxlPVwidHJ1ZVwiXG4gICAgICB9XG5cbiAgICAgIGlzQ2xpY2tpbmcgPSBpc0NsaWNrYWJsZS5jYWxsKHNlbGYsIGUudGFyZ2V0KSAmJiB2YXJzLmRyYWdDbGlja2FibGVzID09PSBmYWxzZSAmJiAhZm9yY2U7XG5cbiAgICAgIGlmIChpc0NsaWNraW5nKSB7XG4gICAgICAgIF9hZGRMaXN0ZW5lcihlLnRhcmdldCwgXCJjaGFuZ2VcIiwgb25SZWxlYXNlKTsgLy9pbiBzb21lIGJyb3dzZXJzLCB3aGVuIHlvdSBtb3VzZWRvd24gb24gYSA8c2VsZWN0PiBlbGVtZW50LCBubyBtb3VzZXVwIGdldHMgZGlzcGF0Y2hlZCEgU28gd2UgbGlzdGVuIGZvciBhIFwiY2hhbmdlXCIgZXZlbnQgaW5zdGVhZC5cblxuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwicHJlc3NJbml0XCIsIFwib25QcmVzc0luaXRcIik7XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJwcmVzc1wiLCBcIm9uUHJlc3NcIik7XG5cbiAgICAgICAgX3NldFNlbGVjdGFibGUodHJpZ2dlcnMsIHRydWUpOyAvL2FjY29tbW9kYXRlcyB0aGluZ3MgbGlrZSBpbnB1dHMgYW5kIGVsZW1lbnRzIHdpdGggY29udGVudEVkaXRhYmxlPVwidHJ1ZVwiIChvdGhlcndpc2UgdXNlciBjb3VsZG4ndCBkcmFnIHRvIHNlbGVjdCB0ZXh0KVxuXG5cbiAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgPSAhdG91Y2hFdmVudFRhcmdldCB8fCBhbGxvd1ggPT09IGFsbG93WSB8fCBzZWxmLnZhcnMuYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyA9PT0gZmFsc2UgfHwgc2VsZi52YXJzLmFsbG93Q29udGV4dE1lbnUgJiYgZSAmJiAoZS5jdHJsS2V5IHx8IGUud2hpY2ggPiAyKSA/IGZhbHNlIDogYWxsb3dYID8gXCJ5XCIgOiBcInhcIjsgLy9ub3RlOiBpbiBDaHJvbWUsIHJpZ2h0LWNsaWNraW5nIChmb3IgYSBjb250ZXh0IG1lbnUpIGZpcmVzIG9uUHJlc3MgYW5kIGl0IGRvZXNuJ3QgaGF2ZSB0aGUgZXZlbnQud2hpY2ggc2V0IHByb3Blcmx5LCBzbyB3ZSBtdXN0IGxvb2sgZm9yIGV2ZW50LmN0cmxLZXkuIElmIHRoZSB1c2VyIHdhbnRzIHRvIGFsbG93IGNvbnRleHQgbWVudXMgd2Ugc2hvdWxkIG9mIGNvdXJzZSBzZW5zZSBpdCBoZXJlIGFuZCBub3QgYWxsb3cgbmF0aXZlIHRvdWNoIHNjcm9sbGluZy5cblxuICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCA9ICFhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nICYmICFzZWxmLmFsbG93RXZlbnREZWZhdWx0O1xuXG4gICAgICBpZiAoaXNQcmV2ZW50aW5nRGVmYXVsdCkge1xuICAgICAgICBfcHJldmVudERlZmF1bHQoZSk7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKF93aW4sIFwidG91Y2hmb3JjZWNoYW5nZVwiLCBfcHJldmVudERlZmF1bHQpOyAvL3dvcmtzIGFyb3VuZCBzYWZhcmkgYnVnOiBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8yMTQ1MC1kcmFnZ2FibGUtaW4taWZyYW1lLW9uLW1vYmlsZS1pcy1idWdneS9cblxuICAgICAgfVxuXG4gICAgICBpZiAoZS5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgICAvL3RvdWNoIGV2ZW50cyBzdG9yZSB0aGUgZGF0YSBzbGlnaHRseSBkaWZmZXJlbnRseVxuICAgICAgICBlID0gdG91Y2ggPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICB0b3VjaElEID0gZS5pZGVudGlmaWVyO1xuICAgICAgfSBlbHNlIGlmIChlLnBvaW50ZXJJZCkge1xuICAgICAgICB0b3VjaElEID0gZS5wb2ludGVySWQ7IC8vZm9yIHNvbWUgTWljcm9zb2Z0IGJyb3dzZXJzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3VjaCA9IHRvdWNoSUQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBfZHJhZ0NvdW50Kys7XG5cbiAgICAgIF9hZGRUb1JlbmRlclF1ZXVlKHJlbmRlcik7IC8vY2F1c2VzIHRoZSBEcmFnZ2FibGUgdG8gcmVuZGVyIG9uIGVhY2ggXCJ0aWNrXCIgb2YgZ3NhcC50aWNrZXIgKHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiAtIHVwZGF0aW5nIHZhbHVlcyBpbiBhIG1vdXNlbW92ZSBjYW4gY2F1c2UgdGhlbSB0byBoYXBwZW4gdG9vIGZyZXF1ZW50bHksIGxpa2UgbXVsdGlwbGUgdGltZXMgYmV0d2VlbiBmcmFtZSByZWRyYXdzIHdoaWNoIGlzIHdhc3RlZnVsLCBhbmQgaXQgYWxzbyBwcmV2ZW50cyB2YWx1ZXMgZnJvbSB1cGRhdGluZyBwcm9wZXJseSBpbiBJRTgpXG5cblxuICAgICAgc3RhcnRQb2ludGVyWSA9IHNlbGYucG9pbnRlclkgPSBlLnBhZ2VZOyAvL3JlY29yZCB0aGUgc3RhcnRpbmcgeCBhbmQgeSBzbyB0aGF0IHdlIGNhbiBjYWxjdWxhdGUgdGhlIG1vdmVtZW50IGZyb20gdGhlIG9yaWdpbmFsIGluIF9vbk1vdXNlTW92ZVxuXG4gICAgICBzdGFydFBvaW50ZXJYID0gc2VsZi5wb2ludGVyWCA9IGUucGFnZVg7XG5cbiAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwicHJlc3NJbml0XCIsIFwib25QcmVzc0luaXRcIik7XG5cbiAgICAgIGlmIChhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nIHx8IHNlbGYuYXV0b1Njcm9sbCkge1xuICAgICAgICBfcmVjb3JkTWF4U2Nyb2xscyh0YXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXQucGFyZW50Tm9kZSAmJiBzZWxmLmF1dG9TY3JvbGwgJiYgIXNjcm9sbFByb3h5ICYmICFyb3RhdGlvbk1vZGUgJiYgdGFyZ2V0LnBhcmVudE5vZGUuX2dzTWF4U2Nyb2xsWCAmJiAhX3BsYWNlaG9sZGVyRGl2LnBhcmVudE5vZGUgJiYgIXRhcmdldC5nZXRCQm94KSB7XG4gICAgICAgIC8vYWRkIGEgcGxhY2Vob2xkZXIgZGl2IHRvIHByZXZlbnQgdGhlIHBhcmVudCBjb250YWluZXIgZnJvbSBjb2xsYXBzaW5nIHdoZW4gdGhlIHVzZXIgZHJhZ3MgdGhlIGVsZW1lbnQgbGVmdC5cbiAgICAgICAgX3BsYWNlaG9sZGVyRGl2LnN0eWxlLndpZHRoID0gdGFyZ2V0LnBhcmVudE5vZGUuc2Nyb2xsV2lkdGggKyBcInB4XCI7XG4gICAgICAgIHRhcmdldC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKF9wbGFjZWhvbGRlckRpdik7XG4gICAgICB9XG5cbiAgICAgIHJlY29yZFN0YXJ0UG9zaXRpb25zKCk7XG4gICAgICBzZWxmLnR3ZWVuICYmIHNlbGYudHdlZW4ua2lsbCgpO1xuICAgICAgc2VsZi5pc1Rocm93aW5nID0gZmFsc2U7XG4gICAgICBnc2FwLmtpbGxUd2VlbnNPZihzY3JvbGxQcm94eSB8fCB0YXJnZXQsIGtpbGxQcm9wcywgdHJ1ZSk7IC8vaW4gY2FzZSB0aGUgdXNlciB0cmllcyB0byBkcmFnIGl0IGJlZm9yZSB0aGUgbGFzdCB0d2VlbiBpcyBkb25lLlxuXG4gICAgICBzY3JvbGxQcm94eSAmJiBnc2FwLmtpbGxUd2VlbnNPZih0YXJnZXQsIHtcbiAgICAgICAgc2Nyb2xsVG86IDFcbiAgICAgIH0sIHRydWUpOyAvL2p1c3QgaW4gY2FzZSB0aGUgb3JpZ2luYWwgdGFyZ2V0J3Mgc2Nyb2xsIHBvc2l0aW9uIGlzIGJlaW5nIHR3ZWVuZWQgc29tZXdoZXJlIGVsc2UuXG5cbiAgICAgIHNlbGYudHdlZW4gPSBzZWxmLmxvY2tlZEF4aXMgPSBudWxsO1xuXG4gICAgICBpZiAodmFycy56SW5kZXhCb29zdCB8fCAhcm90YXRpb25Nb2RlICYmICFzY3JvbGxQcm94eSAmJiB2YXJzLnpJbmRleEJvb3N0ICE9PSBmYWxzZSkge1xuICAgICAgICB0YXJnZXQuc3R5bGUuekluZGV4ID0gRHJhZ2dhYmxlLnpJbmRleCsrO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmlzUHJlc3NlZCA9IHRydWU7XG4gICAgICBoYXNEcmFnQ2FsbGJhY2sgPSAhISh2YXJzLm9uRHJhZyB8fCBzZWxmLl9saXN0ZW5lcnMuZHJhZyk7XG4gICAgICBoYXNNb3ZlQ2FsbGJhY2sgPSAhISh2YXJzLm9uTW92ZSB8fCBzZWxmLl9saXN0ZW5lcnMubW92ZSk7XG5cbiAgICAgIGlmICh2YXJzLmN1cnNvciAhPT0gZmFsc2UgfHwgdmFycy5hY3RpdmVDdXJzb3IpIHtcbiAgICAgICAgaSA9IHRyaWdnZXJzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgICBnc2FwLnNldCh0cmlnZ2Vyc1tpXSwge1xuICAgICAgICAgICAgY3Vyc29yOiB2YXJzLmFjdGl2ZUN1cnNvciB8fCB2YXJzLmN1cnNvciB8fCAoX2RlZmF1bHRDdXJzb3IgPT09IFwiZ3JhYlwiID8gXCJncmFiYmluZ1wiIDogX2RlZmF1bHRDdXJzb3IpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJwcmVzc1wiLCBcIm9uUHJlc3NcIik7XG4gICAgfSxcbiAgICAgICAgLy9jYWxsZWQgZXZlcnkgdGltZSB0aGUgbW91c2UvdG91Y2ggbW92ZXNcbiAgICBvbk1vdmUgPSBmdW5jdGlvbiBvbk1vdmUoZSkge1xuICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBlLFxuICAgICAgICAgIHRvdWNoZXMsXG4gICAgICAgICAgcG9pbnRlclgsXG4gICAgICAgICAgcG9pbnRlclksXG4gICAgICAgICAgaSxcbiAgICAgICAgICBkeCxcbiAgICAgICAgICBkeTtcblxuICAgICAgaWYgKCFlbmFibGVkIHx8IF9pc011bHRpVG91Y2hpbmcgfHwgIXNlbGYuaXNQcmVzc2VkIHx8ICFlKSB7XG4gICAgICAgIGlzUHJldmVudGluZ0RlZmF1bHQgJiYgZSAmJiBlbmFibGVkICYmIF9wcmV2ZW50RGVmYXVsdChlKTsgLy8gaW4gc29tZSBicm93c2Vycywgd2UgbXVzdCBsaXN0ZW4gZm9yIG11bHRpcGxlIGV2ZW50IHR5cGVzIGxpa2UgdG91Y2htb3ZlLCBwb2ludGVybW92ZSwgbW91c2Vtb3ZlLiBUaGUgZmlyc3QgdGltZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCwgd2UgcmVjb3JkIHdoZXRoZXIgb3Igbm90IHdlIF9wcmV2ZW50RGVmYXVsdCgpIHNvIHRoYXQgb24gZHVwbGljYXRlIGNhbGxzLCB3ZSBjYW4gZG8gdGhlIHNhbWUgaWYgbmVjZXNzYXJ5LlxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5wb2ludGVyRXZlbnQgPSBlO1xuICAgICAgdG91Y2hlcyA9IGUuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICAgIGlmICh0b3VjaGVzKSB7XG4gICAgICAgIC8vdG91Y2ggZXZlbnRzIHN0b3JlIHRoZSBkYXRhIHNsaWdodGx5IGRpZmZlcmVudGx5XG4gICAgICAgIGUgPSB0b3VjaGVzWzBdO1xuXG4gICAgICAgIGlmIChlICE9PSB0b3VjaCAmJiBlLmlkZW50aWZpZXIgIT09IHRvdWNoSUQpIHtcbiAgICAgICAgICAvL1VzdWFsbHkgY2hhbmdlZFRvdWNoZXNbMF0gd2lsbCBiZSB3aGF0IHdlJ3JlIGxvb2tpbmcgZm9yLCBidXQgaW4gY2FzZSBpdCdzIG5vdCwgbG9vayB0aHJvdWdoIHRoZSByZXN0IG9mIHRoZSBhcnJheS4uLihhbmQgQW5kcm9pZCBicm93c2VycyBkb24ndCByZXVzZSB0aGUgZXZlbnQgbGlrZSBpT1MpXG4gICAgICAgICAgaSA9IHRvdWNoZXMubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKC0taSA+IC0xICYmIChlID0gdG91Y2hlc1tpXSkuaWRlbnRpZmllciAhPT0gdG91Y2hJRCAmJiBlLnRhcmdldCAhPT0gdGFyZ2V0KSB7fSAvLyBTb21lIEFuZHJvaWQgZGV2aWNlcyBkaXNwYXRjaCBhIHRvdWNoc3RhcnQgQU5EIHBvaW50ZXJkb3duIGluaXRpYWxseSwgYW5kIHRoZW4gb25seSBwb2ludGVybW92ZSB0aHVzIHRoZSB0b3VjaElEIG1heSBub3QgbWF0Y2ggYmVjYXVzZSBpdCB3YXMgZ3JhYmJlZCBmcm9tIHRoZSB0b3VjaHN0YXJ0IGV2ZW50IHdoZXJlYXMgdGhlIHBvaW50ZXIgZXZlbnQgaXMgdGhlIG9uZSB0aGF0IHRoZSBicm93c2VyIGRpc3BhdGNoZXMgZm9yIG1vdmUsIHNvIGlmIHRoZSBldmVudCB0YXJnZXQgbWF0Y2hlcyB0aGlzIERyYWdnYWJsZSdzIHRhcmdldCwgbGV0IGl0IHRocm91Z2guXG5cblxuICAgICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlLnBvaW50ZXJJZCAmJiB0b3VjaElEICYmIGUucG9pbnRlcklkICE9PSB0b3VjaElEKSB7XG4gICAgICAgIC8vZm9yIHNvbWUgTWljcm9zb2Z0IGJyb3dzZXJzLCB3ZSBtdXN0IGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8gdGhlIGRvYyByYXRoZXIgdGhhbiB0aGUgdHJpZ2dlciBzbyB0aGF0IHdoZW4gdGhlIGZpbmdlciBtb3ZlcyBvdXRzaWRlIHRoZSBib3VuZHMgb2YgdGhlIHRyaWdnZXIsIHRoaW5ncyBzdGlsbCB3b3JrLiBTbyBpZiB0aGUgZXZlbnQgd2UncmUgcmVjZWl2aW5nIGhhcyBhIHBvaW50ZXJJZCB0aGF0IGRvZXNuJ3QgbWF0Y2ggdGhlIHRvdWNoSUQsIGlnbm9yZSBpdCAoZm9yIG11bHRpLXRvdWNoKVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0b3VjaEV2ZW50VGFyZ2V0ICYmIGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgJiYgIXRvdWNoRHJhZ0F4aXMpIHtcbiAgICAgICAgLy9BbmRyb2lkIGJyb3dzZXJzIGZvcmNlIHVzIHRvIGRlY2lkZSBvbiB0aGUgZmlyc3QgXCJ0b3VjaG1vdmVcIiBldmVudCBpZiB3ZSBzaG91bGQgYWxsb3cgdGhlIGRlZmF1bHQgKHNjcm9sbGluZykgYmVoYXZpb3Igb3IgcHJldmVudERlZmF1bHQoKS4gT3RoZXJ3aXNlLCBhIFwidG91Y2hjYW5jZWxcIiB3aWxsIGJlIGZpcmVkIGFuZCB0aGVuIG5vIFwidG91Y2htb3ZlXCIgb3IgXCJ0b3VjaGVuZFwiIHdpbGwgZmlyZSBkdXJpbmcgdGhlIHNjcm9sbGluZyAobm8gZ29vZCkuXG4gICAgICAgIF9wb2ludDEueCA9IGUucGFnZVggLSAoaXNGaXhlZCA/IF9nZXREb2NTY3JvbGxMZWZ0KG93bmVyRG9jKSA6IDApO1xuICAgICAgICBfcG9pbnQxLnkgPSBlLnBhZ2VZIC0gKGlzRml4ZWQgPyBfZ2V0RG9jU2Nyb2xsVG9wKG93bmVyRG9jKSA6IDApO1xuICAgICAgICBtYXRyaXggJiYgbWF0cml4LmFwcGx5KF9wb2ludDEsIF9wb2ludDEpO1xuICAgICAgICBwb2ludGVyWCA9IF9wb2ludDEueDtcbiAgICAgICAgcG9pbnRlclkgPSBfcG9pbnQxLnk7XG4gICAgICAgIGR4ID0gTWF0aC5hYnMocG9pbnRlclggLSBzdGFydFBvaW50ZXJYKTtcbiAgICAgICAgZHkgPSBNYXRoLmFicyhwb2ludGVyWSAtIHN0YXJ0UG9pbnRlclkpO1xuXG4gICAgICAgIGlmIChkeCAhPT0gZHkgJiYgKGR4ID4gbWluaW11bU1vdmVtZW50IHx8IGR5ID4gbWluaW11bU1vdmVtZW50KSB8fCBfaXNBbmRyb2lkICYmIGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgPT09IHRvdWNoRHJhZ0F4aXMpIHtcbiAgICAgICAgICB0b3VjaERyYWdBeGlzID0gZHggPiBkeSAmJiBhbGxvd1ggPyBcInhcIiA6IFwieVwiO1xuXG4gICAgICAgICAgaWYgKGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgJiYgdG91Y2hEcmFnQXhpcyAhPT0gYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZykge1xuICAgICAgICAgICAgX2FkZExpc3RlbmVyKF93aW4sIFwidG91Y2hmb3JjZWNoYW5nZVwiLCBfcHJldmVudERlZmF1bHQpOyAvLyBwcmV2ZW50cyBuYXRpdmUgdG91Y2ggc2Nyb2xsaW5nIGZyb20gdGFraW5nIG92ZXIgaWYgdGhlIHVzZXIgc3RhcnRlZCBkcmFnZ2luZyBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uIGluIGlPUyBTYWZhcmlcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxmLnZhcnMubG9ja0F4aXNPblRvdWNoU2Nyb2xsICE9PSBmYWxzZSAmJiBhbGxvd1ggJiYgYWxsb3dZKSB7XG4gICAgICAgICAgICBzZWxmLmxvY2tlZEF4aXMgPSB0b3VjaERyYWdBeGlzID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCI7XG4gICAgICAgICAgICBfaXNGdW5jdGlvbihzZWxmLnZhcnMub25Mb2NrQXhpcykgJiYgc2VsZi52YXJzLm9uTG9ja0F4aXMuY2FsbChzZWxmLCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2lzQW5kcm9pZCAmJiBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nID09PSB0b3VjaERyYWdBeGlzKSB7XG4gICAgICAgICAgICBvblJlbGVhc2Uob3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi5hbGxvd0V2ZW50RGVmYXVsdCAmJiAoIWFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgfHwgdG91Y2hEcmFnQXhpcyAmJiBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nICE9PSB0b3VjaERyYWdBeGlzKSAmJiBvcmlnaW5hbEV2ZW50LmNhbmNlbGFibGUgIT09IGZhbHNlKSB7XG4gICAgICAgIF9wcmV2ZW50RGVmYXVsdChvcmlnaW5hbEV2ZW50KTtcblxuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNQcmV2ZW50aW5nRGVmYXVsdCkge1xuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLmF1dG9TY3JvbGwpIHtcbiAgICAgICAgY2hlY2tBdXRvU2Nyb2xsQm91bmRzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc2V0UG9pbnRlclBvc2l0aW9uKGUucGFnZVgsIGUucGFnZVksIGhhc01vdmVDYWxsYmFjayk7XG4gICAgfSxcbiAgICAgICAgc2V0UG9pbnRlclBvc2l0aW9uID0gZnVuY3Rpb24gc2V0UG9pbnRlclBvc2l0aW9uKHBvaW50ZXJYLCBwb2ludGVyWSwgaW52b2tlT25Nb3ZlKSB7XG4gICAgICB2YXIgZHJhZ1RvbGVyYW5jZSA9IDEgLSBzZWxmLmRyYWdSZXNpc3RhbmNlLFxuICAgICAgICAgIGVkZ2VUb2xlcmFuY2UgPSAxIC0gc2VsZi5lZGdlUmVzaXN0YW5jZSxcbiAgICAgICAgICBwcmV2UG9pbnRlclggPSBzZWxmLnBvaW50ZXJYLFxuICAgICAgICAgIHByZXZQb2ludGVyWSA9IHNlbGYucG9pbnRlclksXG4gICAgICAgICAgcHJldlN0YXJ0RWxlbWVudFkgPSBzdGFydEVsZW1lbnRZLFxuICAgICAgICAgIHByZXZYID0gc2VsZi54LFxuICAgICAgICAgIHByZXZZID0gc2VsZi55LFxuICAgICAgICAgIHByZXZFbmRYID0gc2VsZi5lbmRYLFxuICAgICAgICAgIHByZXZFbmRZID0gc2VsZi5lbmRZLFxuICAgICAgICAgIHByZXZFbmRSb3RhdGlvbiA9IHNlbGYuZW5kUm90YXRpb24sXG4gICAgICAgICAgcHJldkRpcnR5ID0gZGlydHksXG4gICAgICAgICAgeENoYW5nZSxcbiAgICAgICAgICB5Q2hhbmdlLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBkaWYsXG4gICAgICAgICAgdGVtcDtcbiAgICAgIHNlbGYucG9pbnRlclggPSBwb2ludGVyWDtcbiAgICAgIHNlbGYucG9pbnRlclkgPSBwb2ludGVyWTtcblxuICAgICAgaWYgKGlzRml4ZWQpIHtcbiAgICAgICAgcG9pbnRlclggLT0gX2dldERvY1Njcm9sbExlZnQob3duZXJEb2MpO1xuICAgICAgICBwb2ludGVyWSAtPSBfZ2V0RG9jU2Nyb2xsVG9wKG93bmVyRG9jKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICB5ID0gTWF0aC5hdGFuMihyb3RhdGlvbk9yaWdpbi55IC0gcG9pbnRlclksIHBvaW50ZXJYIC0gcm90YXRpb25PcmlnaW4ueCkgKiBfUkFEMkRFRztcbiAgICAgICAgZGlmID0gc2VsZi55IC0geTtcblxuICAgICAgICBpZiAoZGlmID4gMTgwKSB7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WSAtPSAzNjA7XG4gICAgICAgICAgc2VsZi55ID0geTtcbiAgICAgICAgfSBlbHNlIGlmIChkaWYgPCAtMTgwKSB7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WSArPSAzNjA7XG4gICAgICAgICAgc2VsZi55ID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnggIT09IHN0YXJ0RWxlbWVudFggfHwgTWF0aC5hYnMoc3RhcnRFbGVtZW50WSAtIHkpID4gbWluaW11bU1vdmVtZW50KSB7XG4gICAgICAgICAgc2VsZi55ID0geTtcbiAgICAgICAgICB4ID0gc3RhcnRFbGVtZW50WCArIChzdGFydEVsZW1lbnRZIC0geSkgKiBkcmFnVG9sZXJhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSBzdGFydEVsZW1lbnRYO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgdGVtcCA9IHBvaW50ZXJYICogbWF0cml4LmEgKyBwb2ludGVyWSAqIG1hdHJpeC5jICsgbWF0cml4LmU7XG4gICAgICAgICAgcG9pbnRlclkgPSBwb2ludGVyWCAqIG1hdHJpeC5iICsgcG9pbnRlclkgKiBtYXRyaXguZCArIG1hdHJpeC5mO1xuICAgICAgICAgIHBvaW50ZXJYID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHlDaGFuZ2UgPSBwb2ludGVyWSAtIHN0YXJ0UG9pbnRlclk7XG4gICAgICAgIHhDaGFuZ2UgPSBwb2ludGVyWCAtIHN0YXJ0UG9pbnRlclg7XG5cbiAgICAgICAgaWYgKHlDaGFuZ2UgPCBtaW5pbXVtTW92ZW1lbnQgJiYgeUNoYW5nZSA+IC1taW5pbXVtTW92ZW1lbnQpIHtcbiAgICAgICAgICB5Q2hhbmdlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4Q2hhbmdlIDwgbWluaW11bU1vdmVtZW50ICYmIHhDaGFuZ2UgPiAtbWluaW11bU1vdmVtZW50KSB7XG4gICAgICAgICAgeENoYW5nZSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHNlbGYubG9ja0F4aXMgfHwgc2VsZi5sb2NrZWRBeGlzKSAmJiAoeENoYW5nZSB8fCB5Q2hhbmdlKSkge1xuICAgICAgICAgIHRlbXAgPSBzZWxmLmxvY2tlZEF4aXM7XG5cbiAgICAgICAgICBpZiAoIXRlbXApIHtcbiAgICAgICAgICAgIHNlbGYubG9ja2VkQXhpcyA9IHRlbXAgPSBhbGxvd1ggJiYgTWF0aC5hYnMoeENoYW5nZSkgPiBNYXRoLmFicyh5Q2hhbmdlKSA/IFwieVwiIDogYWxsb3dZID8gXCJ4XCIgOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAodGVtcCAmJiBfaXNGdW5jdGlvbihzZWxmLnZhcnMub25Mb2NrQXhpcykpIHtcbiAgICAgICAgICAgICAgc2VsZi52YXJzLm9uTG9ja0F4aXMuY2FsbChzZWxmLCBzZWxmLnBvaW50ZXJFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRlbXAgPT09IFwieVwiKSB7XG4gICAgICAgICAgICB5Q2hhbmdlID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRlbXAgPT09IFwieFwiKSB7XG4gICAgICAgICAgICB4Q2hhbmdlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB4ID0gX3JvdW5kKHN0YXJ0RWxlbWVudFggKyB4Q2hhbmdlICogZHJhZ1RvbGVyYW5jZSk7XG4gICAgICAgIHkgPSBfcm91bmQoc3RhcnRFbGVtZW50WSArIHlDaGFuZ2UgKiBkcmFnVG9sZXJhbmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChzbmFwWCB8fCBzbmFwWSB8fCBzbmFwWFkpICYmIChzZWxmLnggIT09IHggfHwgc2VsZi55ICE9PSB5ICYmICFyb3RhdGlvbk1vZGUpKSB7XG4gICAgICAgIGlmIChzbmFwWFkpIHtcbiAgICAgICAgICBfdGVtcDEueCA9IHg7XG4gICAgICAgICAgX3RlbXAxLnkgPSB5O1xuICAgICAgICAgIHRlbXAgPSBzbmFwWFkoX3RlbXAxKTtcbiAgICAgICAgICB4ID0gX3JvdW5kKHRlbXAueCk7XG4gICAgICAgICAgeSA9IF9yb3VuZCh0ZW1wLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNuYXBYKSB7XG4gICAgICAgICAgeCA9IF9yb3VuZChzbmFwWCh4KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc25hcFkpIHtcbiAgICAgICAgICB5ID0gX3JvdW5kKHNuYXBZKHkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGFzQm91bmRzKSB7XG4gICAgICAgIGlmICh4ID4gbWF4WCkge1xuICAgICAgICAgIHggPSBtYXhYICsgTWF0aC5yb3VuZCgoeCAtIG1heFgpICogZWRnZVRvbGVyYW5jZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoeCA8IG1pblgpIHtcbiAgICAgICAgICB4ID0gbWluWCArIE1hdGgucm91bmQoKHggLSBtaW5YKSAqIGVkZ2VUb2xlcmFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgICAgIHkgPSBNYXRoLnJvdW5kKG1heFkgKyAoeSAtIG1heFkpICogZWRnZVRvbGVyYW5jZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh5IDwgbWluWSkge1xuICAgICAgICAgICAgeSA9IE1hdGgucm91bmQobWluWSArICh5IC0gbWluWSkgKiBlZGdlVG9sZXJhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYueCAhPT0geCB8fCBzZWxmLnkgIT09IHkgJiYgIXJvdGF0aW9uTW9kZSkge1xuICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgc2VsZi5lbmRSb3RhdGlvbiA9IHNlbGYueCA9IHNlbGYuZW5kWCA9IHg7XG4gICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgIHNlbGYueSA9IHNlbGYuZW5kWSA9IHk7XG4gICAgICAgICAgICBkaXJ0eSA9IHRydWU7IC8vYSBmbGFnIHRoYXQgaW5kaWNhdGVzIHdlIG5lZWQgdG8gcmVuZGVyIHRoZSB0YXJnZXQgbmV4dCB0aW1lIHRoZSBUd2VlbkxpdGUudGlja2VyIGRpc3BhdGNoZXMgYSBcInRpY2tcIiBldmVudCAodHlwaWNhbGx5IG9uIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSAtIHRoaXMgaXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gKHdlIHNob3VsZG4ndCByZW5kZXIgb24gZXZlcnkgbW92ZSBiZWNhdXNlIHNvbWV0aW1lcyBtYW55IG1vdmUgZXZlbnRzIGNhbiBnZXQgZGlzcGF0Y2hlZCBiZXR3ZWVuIHNjcmVlbiByZWZyZXNoZXMsIGFuZCB0aGF0J2QgYmUgd2FzdGVmdWwgdG8gcmVuZGVyIGV2ZXJ5IHRpbWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgc2VsZi54ID0gc2VsZi5lbmRYID0geDtcbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWludm9rZU9uTW92ZSB8fCBfZGlzcGF0Y2hFdmVudChzZWxmLCBcIm1vdmVcIiwgXCJvbk1vdmVcIikgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKCFzZWxmLmlzRHJhZ2dpbmcgJiYgc2VsZi5pc1ByZXNzZWQpIHtcbiAgICAgICAgICAgIHNlbGYuaXNEcmFnZ2luZyA9IGRyYWdnZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRyYWdzdGFydFwiLCBcIm9uRHJhZ1N0YXJ0XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL3JldmVydCBiZWNhdXNlIHRoZSBvbk1vdmUgcmV0dXJuZWQgZmFsc2UhXG4gICAgICAgICAgc2VsZi5wb2ludGVyWCA9IHByZXZQb2ludGVyWDtcbiAgICAgICAgICBzZWxmLnBvaW50ZXJZID0gcHJldlBvaW50ZXJZO1xuICAgICAgICAgIHN0YXJ0RWxlbWVudFkgPSBwcmV2U3RhcnRFbGVtZW50WTtcbiAgICAgICAgICBzZWxmLnggPSBwcmV2WDtcbiAgICAgICAgICBzZWxmLnkgPSBwcmV2WTtcbiAgICAgICAgICBzZWxmLmVuZFggPSBwcmV2RW5kWDtcbiAgICAgICAgICBzZWxmLmVuZFkgPSBwcmV2RW5kWTtcbiAgICAgICAgICBzZWxmLmVuZFJvdGF0aW9uID0gcHJldkVuZFJvdGF0aW9uO1xuICAgICAgICAgIGRpcnR5ID0gcHJldkRpcnR5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgLy9jYWxsZWQgd2hlbiB0aGUgbW91c2UvdG91Y2ggaXMgcmVsZWFzZWRcbiAgICBvblJlbGVhc2UgPSBmdW5jdGlvbiBvblJlbGVhc2UoZSwgZm9yY2UpIHtcbiAgICAgIGlmICghZW5hYmxlZCB8fCAhc2VsZi5pc1ByZXNzZWQgfHwgZSAmJiB0b3VjaElEICE9IG51bGwgJiYgIWZvcmNlICYmIChlLnBvaW50ZXJJZCAmJiBlLnBvaW50ZXJJZCAhPT0gdG91Y2hJRCAmJiBlLnRhcmdldCAhPT0gdGFyZ2V0IHx8IGUuY2hhbmdlZFRvdWNoZXMgJiYgIV9oYXNUb3VjaElEKGUuY2hhbmdlZFRvdWNoZXMsIHRvdWNoSUQpKSkge1xuICAgICAgICAvL2ZvciBzb21lIE1pY3Jvc29mdCBicm93c2Vycywgd2UgbXVzdCBhdHRhY2ggdGhlIGxpc3RlbmVyIHRvIHRoZSBkb2MgcmF0aGVyIHRoYW4gdGhlIHRyaWdnZXIgc28gdGhhdCB3aGVuIHRoZSBmaW5nZXIgbW92ZXMgb3V0c2lkZSB0aGUgYm91bmRzIG9mIHRoZSB0cmlnZ2VyLCB0aGluZ3Mgc3RpbGwgd29yay4gU28gaWYgdGhlIGV2ZW50IHdlJ3JlIHJlY2VpdmluZyBoYXMgYSBwb2ludGVySWQgdGhhdCBkb2Vzbid0IG1hdGNoIHRoZSB0b3VjaElELCBpZ25vcmUgaXQgKGZvciBtdWx0aS10b3VjaClcbiAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCAmJiBlICYmIGVuYWJsZWQgJiYgX3ByZXZlbnREZWZhdWx0KGUpOyAvLyBpbiBzb21lIGJyb3dzZXJzLCB3ZSBtdXN0IGxpc3RlbiBmb3IgbXVsdGlwbGUgZXZlbnQgdHlwZXMgbGlrZSB0b3VjaGVuZCwgcG9pbnRlcnVwLCBtb3VzZXVwLiBUaGUgZmlyc3QgdGltZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCwgd2UgcmVjb3JkIHdoZXRoZXIgb3Igbm90IHdlIF9wcmV2ZW50RGVmYXVsdCgpIHNvIHRoYXQgb24gZHVwbGljYXRlIGNhbGxzLCB3ZSBjYW4gZG8gdGhlIHNhbWUgaWYgbmVjZXNzYXJ5LlxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5pc1ByZXNzZWQgPSBmYWxzZTtcbiAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gZSxcbiAgICAgICAgICB3YXNEcmFnZ2luZyA9IHNlbGYuaXNEcmFnZ2luZyxcbiAgICAgICAgICBpc0NvbnRleHRNZW51UmVsZWFzZSA9IHNlbGYudmFycy5hbGxvd0NvbnRleHRNZW51ICYmIGUgJiYgKGUuY3RybEtleSB8fCBlLndoaWNoID4gMiksXG4gICAgICAgICAgcGxhY2Vob2xkZXJEZWxheWVkQ2FsbCA9IGdzYXAuZGVsYXllZENhbGwoMC4wMDEsIHJlbW92ZVBsYWNlaG9sZGVyKSxcbiAgICAgICAgICB0b3VjaGVzLFxuICAgICAgICAgIGksXG4gICAgICAgICAgc3ludGhldGljRXZlbnQsXG4gICAgICAgICAgZXZlbnRUYXJnZXQsXG4gICAgICAgICAgc3ludGhldGljQ2xpY2s7XG5cbiAgICAgIGlmICh0b3VjaEV2ZW50VGFyZ2V0KSB7XG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNoZW5kXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2htb3ZlXCIsIG9uTW92ZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2hjYW5jZWxcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIFwidG91Y2hzdGFydFwiLCBfb25NdWx0aVRvdWNoRG9jdW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBcIm1vdXNlbW92ZVwiLCBvbk1vdmUpO1xuICAgICAgfVxuXG4gICAgICBfcmVtb3ZlTGlzdGVuZXIoX3dpbiwgXCJ0b3VjaGZvcmNlY2hhbmdlXCIsIF9wcmV2ZW50RGVmYXVsdCk7XG5cbiAgICAgIGlmICghX3N1cHBvcnRzUG9pbnRlciB8fCAhdG91Y2hFdmVudFRhcmdldCkge1xuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIFwibW91c2V1cFwiLCBvblJlbGVhc2UpO1xuXG4gICAgICAgIGUgJiYgZS50YXJnZXQgJiYgX3JlbW92ZUxpc3RlbmVyKGUudGFyZ2V0LCBcIm1vdXNldXBcIiwgb25SZWxlYXNlKTtcbiAgICAgIH1cblxuICAgICAgZGlydHkgPSBmYWxzZTtcblxuICAgICAgaWYgKHdhc0RyYWdnaW5nKSB7XG4gICAgICAgIGRyYWdFbmRUaW1lID0gX2xhc3REcmFnVGltZSA9IF9nZXRUaW1lKCk7XG4gICAgICAgIHNlbGYuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBfcmVtb3ZlRnJvbVJlbmRlclF1ZXVlKHJlbmRlcik7XG5cbiAgICAgIGlmIChpc0NsaWNraW5nICYmICFpc0NvbnRleHRNZW51UmVsZWFzZSkge1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcihlLnRhcmdldCwgXCJjaGFuZ2VcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICAgIHNlbGYucG9pbnRlckV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zZXRTZWxlY3RhYmxlKHRyaWdnZXJzLCBmYWxzZSk7XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJyZWxlYXNlXCIsIFwib25SZWxlYXNlXCIpO1xuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiY2xpY2tcIiwgXCJvbkNsaWNrXCIpO1xuXG4gICAgICAgIGlzQ2xpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpID0gdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgX3NldFN0eWxlKHRyaWdnZXJzW2ldLCBcImN1cnNvclwiLCB2YXJzLmN1cnNvciB8fCAodmFycy5jdXJzb3IgIT09IGZhbHNlID8gX2RlZmF1bHRDdXJzb3IgOiBudWxsKSk7XG4gICAgICB9XG5cbiAgICAgIF9kcmFnQ291bnQtLTtcblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgdG91Y2hlcyA9IGUuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICAgICAgaWYgKHRvdWNoZXMpIHtcbiAgICAgICAgICAvL3RvdWNoIGV2ZW50cyBzdG9yZSB0aGUgZGF0YSBzbGlnaHRseSBkaWZmZXJlbnRseVxuICAgICAgICAgIGUgPSB0b3VjaGVzWzBdO1xuXG4gICAgICAgICAgaWYgKGUgIT09IHRvdWNoICYmIGUuaWRlbnRpZmllciAhPT0gdG91Y2hJRCkge1xuICAgICAgICAgICAgLy9Vc3VhbGx5IGNoYW5nZWRUb3VjaGVzWzBdIHdpbGwgYmUgd2hhdCB3ZSdyZSBsb29raW5nIGZvciwgYnV0IGluIGNhc2UgaXQncyBub3QsIGxvb2sgdGhyb3VnaCB0aGUgcmVzdCBvZiB0aGUgYXJyYXkuLi4oYW5kIEFuZHJvaWQgYnJvd3NlcnMgZG9uJ3QgcmV1c2UgdGhlIGV2ZW50IGxpa2UgaU9TKVxuICAgICAgICAgICAgaSA9IHRvdWNoZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICB3aGlsZSAoLS1pID4gLTEgJiYgKGUgPSB0b3VjaGVzW2ldKS5pZGVudGlmaWVyICE9PSB0b3VjaElEICYmIGUudGFyZ2V0ICE9PSB0YXJnZXQpIHt9XG5cbiAgICAgICAgICAgIGlmIChpIDwgMCAmJiAhZm9yY2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYucG9pbnRlckV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICAgICAgc2VsZi5wb2ludGVyWCA9IGUucGFnZVg7XG4gICAgICAgIHNlbGYucG9pbnRlclkgPSBlLnBhZ2VZO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNDb250ZXh0TWVudVJlbGVhc2UgJiYgb3JpZ2luYWxFdmVudCkge1xuICAgICAgICBfcHJldmVudERlZmF1bHQob3JpZ2luYWxFdmVudCk7XG5cbiAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCA9IHRydWU7XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJyZWxlYXNlXCIsIFwib25SZWxlYXNlXCIpO1xuICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbEV2ZW50ICYmICF3YXNEcmFnZ2luZykge1xuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGludGVycnVwdGVkICYmICh2YXJzLnNuYXAgfHwgdmFycy5ib3VuZHMpKSB7XG4gICAgICAgICAgLy9vdGhlcndpc2UsIGlmIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgb2JqZWN0IHdoaWxlIGl0J3MgYW5pbWF0aW5nIHRvIGEgc25hcHBlZCBwb3NpdGlvbiwgYW5kIHRoZW4gcmVsZWFzZXMgd2l0aG91dCBtb3ZpbmcgMyBwaXhlbHMsIGl0IHdpbGwganVzdCBzdGF5IHRoZXJlIChpdCBzaG91bGQgYW5pbWF0ZS9zbmFwKVxuICAgICAgICAgIGFuaW1hdGUodmFycy5pbmVydGlhIHx8IHZhcnMudGhyb3dQcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcInJlbGVhc2VcIiwgXCJvblJlbGVhc2VcIik7XG5cbiAgICAgICAgaWYgKCghX2lzQW5kcm9pZCB8fCBvcmlnaW5hbEV2ZW50LnR5cGUgIT09IFwidG91Y2htb3ZlXCIpICYmIG9yaWdpbmFsRXZlbnQudHlwZS5pbmRleE9mKFwiY2FuY2VsXCIpID09PSAtMSkge1xuICAgICAgICAgIC8vdG8gYWNjb21tb2RhdGUgbmF0aXZlIHNjcm9sbGluZyBvbiBBbmRyb2lkIGRldmljZXMsIHdlIGhhdmUgdG8gaW1tZWRpYXRlbHkgY2FsbCBvblJlbGVhc2UoKSBvbiB0aGUgZmlyc3QgdG91Y2htb3ZlIGV2ZW50LCBidXQgdGhhdCBzaG91bGRuJ3QgdHJpZ2dlciBhIFwiY2xpY2tcIi5cbiAgICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImNsaWNrXCIsIFwib25DbGlja1wiKTtcblxuICAgICAgICAgIGlmIChfZ2V0VGltZSgpIC0gY2xpY2tUaW1lIDwgMzAwKSB7XG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRvdWJsZWNsaWNrXCIsIFwib25Eb3VibGVDbGlja1wiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBldmVudFRhcmdldCA9IG9yaWdpbmFsRXZlbnQudGFyZ2V0IHx8IHRhcmdldDsgLy9vbGQgSUUgdXNlcyBzcmNFbGVtZW50XG5cbiAgICAgICAgICBjbGlja1RpbWUgPSBfZ2V0VGltZSgpO1xuXG4gICAgICAgICAgc3ludGhldGljQ2xpY2sgPSBmdW5jdGlvbiBzeW50aGV0aWNDbGljaygpIHtcbiAgICAgICAgICAgIC8vIHNvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgd29uJ3QgdHJ1c3Qgc2NyaXB0LWdlbmVyYXRlZCBjbGlja3MsIHNvIGlmIHRoZSB1c2VyIHRyaWVzIHRvIGNsaWNrIG9uIGEgdmlkZW8gdG8gcGxheSBpdCwgZm9yIGV4YW1wbGUsIGl0IHNpbXBseSB3b24ndCB3b3JrLiBTaW5jZSBhIHJlZ3VsYXIgXCJjbGlja1wiIGV2ZW50IHdpbGwgbW9zdCBsaWtlbHkgYmUgZ2VuZXJhdGVkIGFueXdheSAob25lIHRoYXQgaGFzIGl0cyBpc1RydXN0ZWQgZmxhZyBzZXQgdG8gdHJ1ZSksIHdlIG11c3Qgc2xpZ2h0bHkgZGVsYXkgb3VyIHNjcmlwdC1nZW5lcmF0ZWQgY2xpY2sgc28gdGhhdCB0aGUgXCJyZWFsXCIvdHJ1c3RlZCBvbmUgaXMgcHJpb3JpdGl6ZWQuIFJlbWVtYmVyLCB3aGVuIHRoZXJlIGFyZSBkdXBsaWNhdGUgZXZlbnRzIGluIHF1aWNrIHN1Y2Nlc3Npb24sIHdlIHN1cHByZXNzIGFsbCBidXQgdGhlIGZpcnN0IG9uZS4gU29tZSBicm93c2VycyBkb24ndCBldmVuIHRyaWdnZXIgdGhlIFwicmVhbFwiIG9uZSBhdCBhbGwsIHNvIG91ciBzeW50aGV0aWMgb25lIGlzIGEgc2FmZXR5IHZhbHZlIHRoYXQgZW5zdXJlcyB0aGF0IG5vIG1hdHRlciB3aGF0LCBhIGNsaWNrIGV2ZW50IGRvZXMgZ2V0IGRpc3BhdGNoZWQuXG4gICAgICAgICAgICBpZiAoY2xpY2tUaW1lICE9PSBjbGlja0Rpc3BhdGNoICYmIHNlbGYuZW5hYmxlZCgpICYmICFzZWxmLmlzUHJlc3NlZCAmJiAhb3JpZ2luYWxFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgIGlmIChldmVudFRhcmdldC5jbGljaykge1xuICAgICAgICAgICAgICAgIC8vc29tZSBicm93c2VycyAobGlrZSBtb2JpbGUgU2FmYXJpKSBkb24ndCBwcm9wZXJseSB0cmlnZ2VyIHRoZSBjbGljayBldmVudFxuICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmNsaWNrKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3duZXJEb2MuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBzeW50aGV0aWNFdmVudCA9IG93bmVyRG9jLmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7XG4gICAgICAgICAgICAgICAgc3ludGhldGljRXZlbnQuaW5pdE1vdXNlRXZlbnQoXCJjbGlja1wiLCB0cnVlLCB0cnVlLCBfd2luLCAxLCBzZWxmLnBvaW50ZXJFdmVudC5zY3JlZW5YLCBzZWxmLnBvaW50ZXJFdmVudC5zY3JlZW5ZLCBzZWxmLnBvaW50ZXJYLCBzZWxmLnBvaW50ZXJZLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgZXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudChzeW50aGV0aWNFdmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKCFfaXNBbmRyb2lkICYmICFvcmlnaW5hbEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIC8vaU9TIFNhZmFyaSByZXF1aXJlcyB0aGUgc3ludGhldGljIGNsaWNrIHRvIGhhcHBlbiBpbW1lZGlhdGVseSBvciBlbHNlIGl0IHNpbXBseSB3b24ndCB3b3JrLCBidXQgQW5kcm9pZCBkb2Vzbid0IHBsYXkgbmljZS5cbiAgICAgICAgICAgIGdzYXAuZGVsYXllZENhbGwoMC4wNSwgc3ludGhldGljQ2xpY2spOyAvL2luIGFkZGl0aW9uIHRvIHRoZSBpT1MgYnVnIHdvcmthcm91bmQsIHRoZXJlJ3MgYSBGaXJlZm94IGlzc3VlIHdpdGggY2xpY2tpbmcgb24gdGhpbmdzIGxpa2UgYSB2aWRlbyB0byBwbGF5LCBzbyB3ZSBtdXN0IGZha2UgYSBjbGljayBldmVudCBpbiBhIHNsaWdodGx5IGRlbGF5ZWQgZmFzaGlvbi4gUHJldmlvdXNseSwgd2UgbGlzdGVuZWQgZm9yIHRoZSBcImNsaWNrXCIgZXZlbnQgd2l0aCBcImNhcHR1cmVcIiBmYWxzZSB3aGljaCBzb2x2ZWQgdGhlIHZpZGVvLWNsaWNrLXRvLXBsYXkgaXNzdWUsIGJ1dCBpdCB3b3VsZCBhbGxvdyB0aGUgXCJjbGlja1wiIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQgdHdpY2UgbGlrZSBpZiB5b3Ugd2VyZSB1c2luZyBhIGpRdWVyeS5jbGljaygpIGJlY2F1c2UgdGhhdCB3YXMgaGFuZGxlZCBpbiB0aGUgY2FwdHVyZSBwaGFzZSwgdGh1cyB3ZSBoYWQgdG8gc3dpdGNoIHRvIHRoZSBjYXB0dXJlIHBoYXNlIHRvIGF2b2lkIHRoZSBkb3VibGUtZGlzcGF0Y2hpbmcsIGJ1dCBkbyB0aGUgZGVsYXllZCBzeW50aGV0aWMgY2xpY2suIERvbid0IGZpcmUgaXQgdG9vIGZhc3QgKGxpa2UgMC4wMDAwMSkgYmVjYXVzZSB3ZSB3YW50IHRvIGdpdmUgdGhlIG5hdGl2ZSBldmVudCBhIGNoYW5jZSB0byBmaXJlIGZpcnN0IGFzIGl0J3MgXCJ0cnVzdGVkXCIuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmltYXRlKHZhcnMuaW5lcnRpYSB8fCB2YXJzLnRocm93UHJvcHMpOyAvL3dpbGwgc2tpcCBpZiBpbmVydGlhL3Rocm93UHJvcHMgaXNuJ3QgZGVmaW5lZCBvciBJbmVydGlhUGx1Z2luIGlzbid0IGxvYWRlZC5cblxuICAgICAgICBpZiAoIXNlbGYuYWxsb3dFdmVudERlZmF1bHQgJiYgb3JpZ2luYWxFdmVudCAmJiAodmFycy5kcmFnQ2xpY2thYmxlcyAhPT0gZmFsc2UgfHwgIWlzQ2xpY2thYmxlLmNhbGwoc2VsZiwgb3JpZ2luYWxFdmVudC50YXJnZXQpKSAmJiB3YXNEcmFnZ2luZyAmJiAoIWFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgfHwgdG91Y2hEcmFnQXhpcyAmJiBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nID09PSB0b3VjaERyYWdBeGlzKSAmJiBvcmlnaW5hbEV2ZW50LmNhbmNlbGFibGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCA9IHRydWU7XG5cbiAgICAgICAgICBfcHJldmVudERlZmF1bHQob3JpZ2luYWxFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJyZWxlYXNlXCIsIFwib25SZWxlYXNlXCIpO1xuICAgICAgfVxuXG4gICAgICBpc1R3ZWVuaW5nKCkgJiYgcGxhY2Vob2xkZXJEZWxheWVkQ2FsbC5kdXJhdGlvbihzZWxmLnR3ZWVuLmR1cmF0aW9uKCkpOyAvL3N5bmMgdGhlIHRpbWluZyBzbyB0aGF0IHRoZSBwbGFjZWhvbGRlciBESVYgZ2V0c1xuXG4gICAgICB3YXNEcmFnZ2luZyAmJiBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRyYWdlbmRcIiwgXCJvbkRyYWdFbmRcIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgICAgICB1cGRhdGVTY3JvbGwgPSBmdW5jdGlvbiB1cGRhdGVTY3JvbGwoZSkge1xuICAgICAgaWYgKGUgJiYgc2VsZi5pc0RyYWdnaW5nICYmICFzY3JvbGxQcm94eSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gZS50YXJnZXQgfHwgdGFyZ2V0LnBhcmVudE5vZGUsXG4gICAgICAgICAgICBkZWx0YVggPSBwYXJlbnQuc2Nyb2xsTGVmdCAtIHBhcmVudC5fZ3NTY3JvbGxYLFxuICAgICAgICAgICAgZGVsdGFZID0gcGFyZW50LnNjcm9sbFRvcCAtIHBhcmVudC5fZ3NTY3JvbGxZO1xuXG4gICAgICAgIGlmIChkZWx0YVggfHwgZGVsdGFZKSB7XG4gICAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgc3RhcnRQb2ludGVyWCAtPSBkZWx0YVggKiBtYXRyaXguYSArIGRlbHRhWSAqIG1hdHJpeC5jO1xuICAgICAgICAgICAgc3RhcnRQb2ludGVyWSAtPSBkZWx0YVkgKiBtYXRyaXguZCArIGRlbHRhWCAqIG1hdHJpeC5iO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydFBvaW50ZXJYIC09IGRlbHRhWDtcbiAgICAgICAgICAgIHN0YXJ0UG9pbnRlclkgLT0gZGVsdGFZO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudC5fZ3NTY3JvbGxYICs9IGRlbHRhWDtcbiAgICAgICAgICBwYXJlbnQuX2dzU2Nyb2xsWSArPSBkZWx0YVk7XG4gICAgICAgICAgc2V0UG9pbnRlclBvc2l0aW9uKHNlbGYucG9pbnRlclgsIHNlbGYucG9pbnRlclkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgb25DbGljayA9IGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgLy90aGlzIHdhcyBhIGh1Z2UgcGFpbiBpbiB0aGUgbmVjayB0byBhbGlnbiBhbGwgdGhlIHZhcmlvdXMgYnJvd3NlcnMgYW5kIHRoZWlyIGJlaGF2aW9ycy4gQ2hyb21lLCBGaXJlZm94LCBTYWZhcmksIE9wZXJhLCBBbmRyb2lkLCBhbmQgTWljcm9zb2Z0IEVkZ2UgYWxsIGhhbmRsZSBldmVudHMgZGlmZmVyZW50bHkhIFNvbWUgd2lsbCBvbmx5IHRyaWdnZXIgbmF0aXZlIGJlaGF2aW9yIChsaWtlIGNoZWNrYm94IHRvZ2dsaW5nKSBmcm9tIHRydXN0ZWQgZXZlbnRzLiBPdGhlcnMgZG9uJ3QgZXZlbiBzdXBwb3J0IGlzVHJ1c3RlZCwgYnV0IHJlcXVpcmUgMiBldmVudHMgdG8gZmxvdyB0aHJvdWdoIGJlZm9yZSB0cmlnZ2VyaW5nIG5hdGl2ZSBiZWhhdmlvci4gRWRnZSB0cmVhdHMgZXZlcnl0aGluZyBhcyB0cnVzdGVkIGJ1dCBhbHNvIG1hbmRhdGVzIHRoYXQgMiBmbG93IHRocm91Z2ggdG8gdHJpZ2dlciB0aGUgY29ycmVjdCBuYXRpdmUgYmVoYXZpb3IuXG4gICAgICB2YXIgdGltZSA9IF9nZXRUaW1lKCksXG4gICAgICAgICAgcmVjZW50bHlDbGlja2VkID0gdGltZSAtIGNsaWNrVGltZSA8IDEwMCxcbiAgICAgICAgICByZWNlbnRseURyYWdnZWQgPSB0aW1lIC0gZHJhZ0VuZFRpbWUgPCA1MCxcbiAgICAgICAgICBhbHJlYWR5RGlzcGF0Y2hlZCA9IHJlY2VudGx5Q2xpY2tlZCAmJiBjbGlja0Rpc3BhdGNoID09PSBjbGlja1RpbWUsXG4gICAgICAgICAgZGVmYXVsdFByZXZlbnRlZCA9IHNlbGYucG9pbnRlckV2ZW50ICYmIHNlbGYucG9pbnRlckV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQsXG4gICAgICAgICAgYWxyZWFkeURpc3BhdGNoZWRUcnVzdGVkID0gcmVjZW50bHlDbGlja2VkICYmIHRydXN0ZWRDbGlja0Rpc3BhdGNoID09PSBjbGlja1RpbWUsXG4gICAgICAgICAgdHJ1c3RlZCA9IGUuaXNUcnVzdGVkIHx8IGUuaXNUcnVzdGVkID09IG51bGwgJiYgcmVjZW50bHlDbGlja2VkICYmIGFscmVhZHlEaXNwYXRjaGVkOyAvL25vdGU6IFNhZmFyaSBkb2Vzbid0IHN1cHBvcnQgaXNUcnVzdGVkLCBhbmQgaXQgd29uJ3QgcHJvcGVybHkgZXhlY3V0ZSBuYXRpdmUgYmVoYXZpb3IgKGxpa2UgdG9nZ2xpbmcgY2hlY2tib3hlcykgb24gdGhlIGZpcnN0IHN5bnRoZXRpYyBcImNsaWNrXCIgZXZlbnQgLSB3ZSBtdXN0IHdhaXQgZm9yIHRoZSAybmQgYW5kIHRyZWF0IGl0IGFzIHRydXN0ZWQgKGJ1dCBzdG9wIHByb3BhZ2F0aW9uIGF0IHRoYXQgcG9pbnQpLiBDb25mdXNpbmcsIEkga25vdy4gRG9uJ3QgeW91IGxvdmUgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmlsaXR5IGNoYWxsZW5nZXM/XG5cblxuICAgICAgaWYgKChhbHJlYWR5RGlzcGF0Y2hlZCB8fCByZWNlbnRseURyYWdnZWQgJiYgc2VsZi52YXJzLnN1cHByZXNzQ2xpY2tPbkRyYWcgIT09IGZhbHNlKSAmJiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjZW50bHlDbGlja2VkICYmICEoc2VsZi5wb2ludGVyRXZlbnQgJiYgc2VsZi5wb2ludGVyRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgJiYgKCFhbHJlYWR5RGlzcGF0Y2hlZCB8fCB0cnVzdGVkICYmICFhbHJlYWR5RGlzcGF0Y2hlZFRydXN0ZWQpKSB7XG4gICAgICAgIC8vbGV0IHRoZSBmaXJzdCBjbGljayBwYXNzIHRocm91Z2ggdW5oaW5kZXJlZC4gTGV0IHRoZSBuZXh0IG9uZSBvbmx5IGlmIGl0J3MgdHJ1c3RlZCwgdGhlbiBubyBtb3JlIChzdG9wIHF1aWNrLXN1Y2Nlc3Npb24gb25lcylcbiAgICAgICAgaWYgKHRydXN0ZWQgJiYgYWxyZWFkeURpc3BhdGNoZWQpIHtcbiAgICAgICAgICB0cnVzdGVkQ2xpY2tEaXNwYXRjaCA9IGNsaWNrVGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsaWNrRGlzcGF0Y2ggPSBjbGlja1RpbWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuaXNQcmVzc2VkIHx8IHJlY2VudGx5RHJhZ2dlZCB8fCByZWNlbnRseUNsaWNrZWQpIHtcbiAgICAgICAgaWYgKCF0cnVzdGVkIHx8ICFlLmRldGFpbCB8fCAhcmVjZW50bHlDbGlja2VkIHx8IGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICBfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFyZWNlbnRseUNsaWNrZWQgJiYgIXJlY2VudGx5RHJhZ2dlZCAmJiAhZHJhZ2dlZCkge1xuICAgICAgICAvLyBmb3Igc2NyaXB0LXRyaWdnZXJlZCBldmVudCBkaXNwYXRjaGVzLCBsaWtlIGVsZW1lbnQuY2xpY2soKVxuICAgICAgICBlICYmIGUudGFyZ2V0ICYmIChzZWxmLnBvaW50ZXJFdmVudCA9IGUpO1xuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiY2xpY2tcIiwgXCJvbkNsaWNrXCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIGxvY2FsaXplUG9pbnQgPSBmdW5jdGlvbiBsb2NhbGl6ZVBvaW50KHApIHtcbiAgICAgIHJldHVybiBtYXRyaXggPyB7XG4gICAgICAgIHg6IHAueCAqIG1hdHJpeC5hICsgcC55ICogbWF0cml4LmMgKyBtYXRyaXguZSxcbiAgICAgICAgeTogcC54ICogbWF0cml4LmIgKyBwLnkgKiBtYXRyaXguZCArIG1hdHJpeC5mXG4gICAgICB9IDoge1xuICAgICAgICB4OiBwLngsXG4gICAgICAgIHk6IHAueVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgb2xkID0gRHJhZ2dhYmxlLmdldCh0YXJnZXQpO1xuICAgIG9sZCAmJiBvbGQua2lsbCgpOyAvLyBhdm9pZHMgZHVwbGljYXRlcyAoYW4gZWxlbWVudCBjYW4gb25seSBiZSBjb250cm9sbGVkIGJ5IG9uZSBEcmFnZ2FibGUpXG4gICAgLy9naXZlIHRoZSB1c2VyIGFjY2VzcyB0byBzdGFydC9zdG9wIGRyYWdnaW5nLi4uXG5cbiAgICBfdGhpczIuc3RhcnREcmFnID0gZnVuY3Rpb24gKGV2ZW50LCBhbGlnbikge1xuICAgICAgdmFyIHIxLCByMiwgcDEsIHAyO1xuICAgICAgb25QcmVzcyhldmVudCB8fCBzZWxmLnBvaW50ZXJFdmVudCwgdHJ1ZSk7IC8vaWYgdGhlIHBvaW50ZXIgaXNuJ3Qgb24gdG9wIG9mIHRoZSBlbGVtZW50LCBhZGp1c3QgdGhpbmdzIGFjY29yZGluZ2x5XG5cbiAgICAgIGlmIChhbGlnbiAmJiAhc2VsZi5oaXRUZXN0KGV2ZW50IHx8IHNlbGYucG9pbnRlckV2ZW50KSkge1xuICAgICAgICByMSA9IF9wYXJzZVJlY3QoZXZlbnQgfHwgc2VsZi5wb2ludGVyRXZlbnQpO1xuICAgICAgICByMiA9IF9wYXJzZVJlY3QodGFyZ2V0KTtcbiAgICAgICAgcDEgPSBsb2NhbGl6ZVBvaW50KHtcbiAgICAgICAgICB4OiByMS5sZWZ0ICsgcjEud2lkdGggLyAyLFxuICAgICAgICAgIHk6IHIxLnRvcCArIHIxLmhlaWdodCAvIDJcbiAgICAgICAgfSk7XG4gICAgICAgIHAyID0gbG9jYWxpemVQb2ludCh7XG4gICAgICAgICAgeDogcjIubGVmdCArIHIyLndpZHRoIC8gMixcbiAgICAgICAgICB5OiByMi50b3AgKyByMi5oZWlnaHQgLyAyXG4gICAgICAgIH0pO1xuICAgICAgICBzdGFydFBvaW50ZXJYIC09IHAxLnggLSBwMi54O1xuICAgICAgICBzdGFydFBvaW50ZXJZIC09IHAxLnkgLSBwMi55O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGYuaXNEcmFnZ2luZykge1xuICAgICAgICBzZWxmLmlzRHJhZ2dpbmcgPSBkcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRyYWdzdGFydFwiLCBcIm9uRHJhZ1N0YXJ0XCIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpczIuZHJhZyA9IG9uTW92ZTtcblxuICAgIF90aGlzMi5lbmREcmFnID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBvblJlbGVhc2UoZSB8fCBzZWxmLnBvaW50ZXJFdmVudCwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIF90aGlzMi50aW1lU2luY2VEcmFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNlbGYuaXNEcmFnZ2luZyA/IDAgOiAoX2dldFRpbWUoKSAtIGRyYWdFbmRUaW1lKSAvIDEwMDA7XG4gICAgfTtcblxuICAgIF90aGlzMi50aW1lU2luY2VDbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX2dldFRpbWUoKSAtIGNsaWNrVGltZSkgLyAxMDAwO1xuICAgIH07XG5cbiAgICBfdGhpczIuaGl0VGVzdCA9IGZ1bmN0aW9uICh0YXJnZXQsIHRocmVzaG9sZCkge1xuICAgICAgcmV0dXJuIERyYWdnYWJsZS5oaXRUZXN0KHNlbGYudGFyZ2V0LCB0YXJnZXQsIHRocmVzaG9sZCk7XG4gICAgfTtcblxuICAgIF90aGlzMi5nZXREaXJlY3Rpb24gPSBmdW5jdGlvbiAoZnJvbSwgZGlhZ29uYWxUaHJlc2hvbGQpIHtcbiAgICAgIC8vZnJvbSBjYW4gYmUgXCJzdGFydFwiIChkZWZhdWx0KSwgXCJ2ZWxvY2l0eVwiLCBvciBhbiBlbGVtZW50XG4gICAgICB2YXIgbW9kZSA9IGZyb20gPT09IFwidmVsb2NpdHlcIiAmJiBJbmVydGlhUGx1Z2luID8gZnJvbSA6IF9pc09iamVjdChmcm9tKSAmJiAhcm90YXRpb25Nb2RlID8gXCJlbGVtZW50XCIgOiBcInN0YXJ0XCIsXG4gICAgICAgICAgeENoYW5nZSxcbiAgICAgICAgICB5Q2hhbmdlLFxuICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICByMSxcbiAgICAgICAgICByMjtcblxuICAgICAgaWYgKG1vZGUgPT09IFwiZWxlbWVudFwiKSB7XG4gICAgICAgIHIxID0gX3BhcnNlUmVjdChzZWxmLnRhcmdldCk7XG4gICAgICAgIHIyID0gX3BhcnNlUmVjdChmcm9tKTtcbiAgICAgIH1cblxuICAgICAgeENoYW5nZSA9IG1vZGUgPT09IFwic3RhcnRcIiA/IHNlbGYueCAtIHN0YXJ0RWxlbWVudFggOiBtb2RlID09PSBcInZlbG9jaXR5XCIgPyBJbmVydGlhUGx1Z2luLmdldFZlbG9jaXR5KHRhcmdldCwgeFByb3ApIDogcjEubGVmdCArIHIxLndpZHRoIC8gMiAtIChyMi5sZWZ0ICsgcjIud2lkdGggLyAyKTtcblxuICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICByZXR1cm4geENoYW5nZSA8IDAgPyBcImNvdW50ZXItY2xvY2t3aXNlXCIgOiBcImNsb2Nrd2lzZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlhZ29uYWxUaHJlc2hvbGQgPSBkaWFnb25hbFRocmVzaG9sZCB8fCAyO1xuICAgICAgICB5Q2hhbmdlID0gbW9kZSA9PT0gXCJzdGFydFwiID8gc2VsZi55IC0gc3RhcnRFbGVtZW50WSA6IG1vZGUgPT09IFwidmVsb2NpdHlcIiA/IEluZXJ0aWFQbHVnaW4uZ2V0VmVsb2NpdHkodGFyZ2V0LCB5UHJvcCkgOiByMS50b3AgKyByMS5oZWlnaHQgLyAyIC0gKHIyLnRvcCArIHIyLmhlaWdodCAvIDIpO1xuICAgICAgICByYXRpbyA9IE1hdGguYWJzKHhDaGFuZ2UgLyB5Q2hhbmdlKTtcbiAgICAgICAgZGlyZWN0aW9uID0gcmF0aW8gPCAxIC8gZGlhZ29uYWxUaHJlc2hvbGQgPyBcIlwiIDogeENoYW5nZSA8IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcblxuICAgICAgICBpZiAocmF0aW8gPCBkaWFnb25hbFRocmVzaG9sZCkge1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiArPSBcIi1cIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXJlY3Rpb24gKz0geUNoYW5nZSA8IDAgPyBcInVwXCIgOiBcImRvd25cIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlyZWN0aW9uO1xuICAgIH07XG5cbiAgICBfdGhpczIuYXBwbHlCb3VuZHMgPSBmdW5jdGlvbiAobmV3Qm91bmRzLCBzdGlja3kpIHtcbiAgICAgIHZhciB4LCB5LCBmb3JjZVplcm9WZWxvY2l0eSwgZSwgcGFyZW50LCBpc1Jvb3Q7XG5cbiAgICAgIGlmIChuZXdCb3VuZHMgJiYgdmFycy5ib3VuZHMgIT09IG5ld0JvdW5kcykge1xuICAgICAgICB2YXJzLmJvdW5kcyA9IG5ld0JvdW5kcztcbiAgICAgICAgcmV0dXJuIHNlbGYudXBkYXRlKHRydWUsIHN0aWNreSk7XG4gICAgICB9XG5cbiAgICAgIHN5bmNYWSh0cnVlKTtcbiAgICAgIGNhbGN1bGF0ZUJvdW5kcygpO1xuXG4gICAgICBpZiAoaGFzQm91bmRzICYmICFpc1R3ZWVuaW5nKCkpIHtcbiAgICAgICAgeCA9IHNlbGYueDtcbiAgICAgICAgeSA9IHNlbGYueTtcblxuICAgICAgICBpZiAoeCA+IG1heFgpIHtcbiAgICAgICAgICB4ID0gbWF4WDtcbiAgICAgICAgfSBlbHNlIGlmICh4IDwgbWluWCkge1xuICAgICAgICAgIHggPSBtaW5YO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgICAgeSA9IG1heFk7XG4gICAgICAgIH0gZWxzZSBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgICB5ID0gbWluWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnggIT09IHggfHwgc2VsZi55ICE9PSB5KSB7XG4gICAgICAgICAgZm9yY2VaZXJvVmVsb2NpdHkgPSB0cnVlO1xuICAgICAgICAgIHNlbGYueCA9IHNlbGYuZW5kWCA9IHg7XG5cbiAgICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgICBzZWxmLmVuZFJvdGF0aW9uID0geDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi55ID0gc2VsZi5lbmRZID0geTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgICAgcmVuZGVyKHRydWUpO1xuXG4gICAgICAgICAgaWYgKHNlbGYuYXV0b1Njcm9sbCAmJiAhc2VsZi5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICBfcmVjb3JkTWF4U2Nyb2xscyh0YXJnZXQucGFyZW50Tm9kZSk7XG5cbiAgICAgICAgICAgIGUgPSB0YXJnZXQ7XG4gICAgICAgICAgICBfd2luZG93UHJveHkuc2Nyb2xsVG9wID0gX3dpbi5wYWdlWU9mZnNldCAhPSBudWxsID8gX3dpbi5wYWdlWU9mZnNldCA6IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgIT0gbnVsbCA/IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgOiBvd25lckRvYy5ib2R5LnNjcm9sbFRvcDtcbiAgICAgICAgICAgIF93aW5kb3dQcm94eS5zY3JvbGxMZWZ0ID0gX3dpbi5wYWdlWE9mZnNldCAhPSBudWxsID8gX3dpbi5wYWdlWE9mZnNldCA6IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0ICE9IG51bGwgPyBvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCA6IG93bmVyRG9jLmJvZHkuc2Nyb2xsTGVmdDtcblxuICAgICAgICAgICAgd2hpbGUgKGUgJiYgIWlzUm9vdCkge1xuICAgICAgICAgICAgICAvL3dhbGsgdXAgdGhlIGNoYWluIGFuZCBzZW5zZSB3aGVyZXZlciB0aGUgc2Nyb2xsVG9wL3Njcm9sbExlZnQgZXhjZWVkcyB0aGUgbWF4aW11bS5cbiAgICAgICAgICAgICAgaXNSb290ID0gX2lzUm9vdChlLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICBwYXJlbnQgPSBpc1Jvb3QgPyBfd2luZG93UHJveHkgOiBlLnBhcmVudE5vZGU7XG5cbiAgICAgICAgICAgICAgaWYgKGFsbG93WSAmJiBwYXJlbnQuc2Nyb2xsVG9wID4gcGFyZW50Ll9nc01heFNjcm9sbFkpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc2Nyb2xsVG9wID0gcGFyZW50Ll9nc01heFNjcm9sbFk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYWxsb3dYICYmIHBhcmVudC5zY3JvbGxMZWZ0ID4gcGFyZW50Ll9nc01heFNjcm9sbFgpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc2Nyb2xsTGVmdCA9IHBhcmVudC5fZ3NNYXhTY3JvbGxYO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5pc1Rocm93aW5nICYmIChmb3JjZVplcm9WZWxvY2l0eSB8fCBzZWxmLmVuZFggPiBtYXhYIHx8IHNlbGYuZW5kWCA8IG1pblggfHwgc2VsZi5lbmRZID4gbWF4WSB8fCBzZWxmLmVuZFkgPCBtaW5ZKSkge1xuICAgICAgICAgIGFuaW1hdGUodmFycy5pbmVydGlhIHx8IHZhcnMudGhyb3dQcm9wcywgZm9yY2VaZXJvVmVsb2NpdHkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICBfdGhpczIudXBkYXRlID0gZnVuY3Rpb24gKGFwcGx5Qm91bmRzLCBzdGlja3ksIGlnbm9yZUV4dGVybmFsQ2hhbmdlcykge1xuICAgICAgaWYgKHN0aWNreSAmJiBzZWxmLmlzUHJlc3NlZCkge1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSBlbGVtZW50IHdhcyByZXBvc2l0aW9uZWQgaW4gdGhlIGRvY3VtZW50IGZsb3csIHRodXMgaXRzIHgveSBtYXkgYmUgaWRlbnRpY2FsIGJ1dCBpdHMgcG9zaXRpb24gaXMgYWN0dWFsbHkgcXVpdGUgZGlmZmVyZW50LlxuICAgICAgICB2YXIgbSA9IGdldEdsb2JhbE1hdHJpeCh0YXJnZXQpLFxuICAgICAgICAgICAgcCA9IGlubmVyTWF0cml4LmFwcGx5KHtcbiAgICAgICAgICB4OiBzZWxmLnggLSBzdGFydEVsZW1lbnRYLFxuICAgICAgICAgIHk6IHNlbGYueSAtIHN0YXJ0RWxlbWVudFlcbiAgICAgICAgfSksXG4gICAgICAgICAgICBtMiA9IGdldEdsb2JhbE1hdHJpeCh0YXJnZXQucGFyZW50Tm9kZSwgdHJ1ZSk7XG4gICAgICAgIG0yLmFwcGx5KHtcbiAgICAgICAgICB4OiBtLmUgLSBwLngsXG4gICAgICAgICAgeTogbS5mIC0gcC55XG4gICAgICAgIH0sIHApO1xuICAgICAgICBzZWxmLnggLT0gcC54IC0gbTIuZTtcbiAgICAgICAgc2VsZi55IC09IHAueSAtIG0yLmY7XG4gICAgICAgIHJlbmRlcih0cnVlKTtcbiAgICAgICAgcmVjb3JkU3RhcnRQb3NpdGlvbnMoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHggPSBzZWxmLngsXG4gICAgICAgICAgeSA9IHNlbGYueTtcbiAgICAgIHVwZGF0ZU1hdHJpeCghc3RpY2t5KTtcblxuICAgICAgaWYgKGFwcGx5Qm91bmRzKSB7XG4gICAgICAgIHNlbGYuYXBwbHlCb3VuZHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcnR5ICYmIGlnbm9yZUV4dGVybmFsQ2hhbmdlcyAmJiByZW5kZXIodHJ1ZSk7XG4gICAgICAgIHN5bmNYWSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0aWNreSkge1xuICAgICAgICBzZXRQb2ludGVyUG9zaXRpb24oc2VsZi5wb2ludGVyWCwgc2VsZi5wb2ludGVyWSk7XG4gICAgICAgIGRpcnR5ICYmIHJlbmRlcih0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuaXNQcmVzc2VkICYmICFzdGlja3kgJiYgKGFsbG93WCAmJiBNYXRoLmFicyh4IC0gc2VsZi54KSA+IDAuMDEgfHwgYWxsb3dZICYmIE1hdGguYWJzKHkgLSBzZWxmLnkpID4gMC4wMSAmJiAhcm90YXRpb25Nb2RlKSkge1xuICAgICAgICByZWNvcmRTdGFydFBvc2l0aW9ucygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5hdXRvU2Nyb2xsKSB7XG4gICAgICAgIF9yZWNvcmRNYXhTY3JvbGxzKHRhcmdldC5wYXJlbnROb2RlLCBzZWxmLmlzRHJhZ2dpbmcpO1xuXG4gICAgICAgIGNoZWNrQXV0b1Njcm9sbEJvdW5kcyA9IHNlbGYuaXNEcmFnZ2luZztcbiAgICAgICAgcmVuZGVyKHRydWUpOyAvL2luIGNhc2UgcmVwYXJlbnRpbmcgb2NjdXJyZWQuXG5cbiAgICAgICAgX3JlbW92ZVNjcm9sbExpc3RlbmVyKHRhcmdldCwgdXBkYXRlU2Nyb2xsKTtcblxuICAgICAgICBfYWRkU2Nyb2xsTGlzdGVuZXIodGFyZ2V0LCB1cGRhdGVTY3JvbGwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgX3RoaXMyLmVuYWJsZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgc2V0VmFycyA9IHtcbiAgICAgICAgbGF6eTogdHJ1ZVxuICAgICAgfSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHRyaWdnZXI7XG5cbiAgICAgIGlmICh2YXJzLmN1cnNvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgc2V0VmFycy5jdXJzb3IgPSB2YXJzLmN1cnNvciB8fCBfZGVmYXVsdEN1cnNvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGdzYXAudXRpbHMuY2hlY2tQcmVmaXgoXCJ0b3VjaENhbGxvdXRcIikpIHtcbiAgICAgICAgc2V0VmFycy50b3VjaENhbGxvdXQgPSBcIm5vbmVcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgIT09IFwic29mdFwiKSB7XG4gICAgICAgIF9zZXRUb3VjaEFjdGlvbkZvckFsbERlc2NlbmRhbnRzKHRyaWdnZXJzLCBhbGxvd1ggPT09IGFsbG93WSA/IFwibm9uZVwiIDogdmFycy5hbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nICYmIHRhcmdldC5zY3JvbGxIZWlnaHQgPT09IHRhcmdldC5jbGllbnRIZWlnaHQgPT09ICh0YXJnZXQuc2Nyb2xsV2lkdGggPT09IHRhcmdldC5jbGllbnRIZWlnaHQpIHx8IHZhcnMuYWxsb3dFdmVudERlZmF1bHQgPyBcIm1hbmlwdWxhdGlvblwiIDogYWxsb3dYID8gXCJwYW4teVwiIDogXCJwYW4teFwiKTsgLy8gU29tZSBicm93c2VycyBsaWtlIEludGVybmV0IEV4cGxvcmVyIHdpbGwgZmlyZSBhIHBvaW50ZXJjYW5jZWwgZXZlbnQgd2hlbiB0aGUgdXNlciBhdHRlbXB0cyB0byBkcmFnIHdoZW4gdG91Y2hBY3Rpb24gaXMgXCJtYW5pcHVsYXRlXCIgYmVjYXVzZSBpdCdzIHBlcmNlaXZlZCBhcyBhIHBhbi4gSWYgdGhlIGVsZW1lbnQgaGFzIHNjcm9sbGFibGUgY29udGVudCBpbiBvbmx5IG9uZSBkaXJlY3Rpb24sIHdlIHNob3VsZCB1c2UgcGFuLXggb3IgcGFuLXkgYWNjb3JkaW5nbHkgc28gdGhhdCB0aGUgcG9pbnRlcmNhbmNlbCBkb2Vzbid0IHByZXZlbnQgZHJhZ2dpbmcuXG5cblxuICAgICAgICBpID0gdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICAgIHRyaWdnZXIgPSB0cmlnZ2Vyc1tpXTtcbiAgICAgICAgICBfc3VwcG9ydHNQb2ludGVyIHx8IF9hZGRMaXN0ZW5lcih0cmlnZ2VyLCBcIm1vdXNlZG93blwiLCBvblByZXNzKTtcblxuICAgICAgICAgIF9hZGRMaXN0ZW5lcih0cmlnZ2VyLCBcInRvdWNoc3RhcnRcIiwgb25QcmVzcyk7XG5cbiAgICAgICAgICBfYWRkTGlzdGVuZXIodHJpZ2dlciwgXCJjbGlja1wiLCBvbkNsaWNrLCB0cnVlKTsgLy8gbm90ZTogdXNlZCB0byBwYXNzIHRydWUgZm9yIGNhcHR1cmUgYnV0IGl0IHByZXZlbnRlZCBjbGljay10by1wbGF5LXZpZGVvIGZ1bmN0aW9uYWxpdHkgaW4gRmlyZWZveC5cblxuXG4gICAgICAgICAgZ3NhcC5zZXQodHJpZ2dlciwgc2V0VmFycyk7XG5cbiAgICAgICAgICBpZiAodHJpZ2dlci5nZXRCQm94ICYmIHRyaWdnZXIub3duZXJTVkdFbGVtZW50ICYmIGFsbG93WCAhPT0gYWxsb3dZKSB7XG4gICAgICAgICAgICAvLyBhIGJ1ZyBpbiBjaHJvbWUgZG9lc24ndCByZXNwZWN0IHRvdWNoLWFjdGlvbiBvbiBTVkcgZWxlbWVudHMgLSBpdCBvbmx5IHdvcmtzIGlmIHdlIHNldCBpdCBvbiB0aGUgcGFyZW50IFNWRy5cbiAgICAgICAgICAgIGdzYXAuc2V0KHRyaWdnZXIub3duZXJTVkdFbGVtZW50LCB7XG4gICAgICAgICAgICAgIHRvdWNoQWN0aW9uOiB2YXJzLmFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgfHwgdmFycy5hbGxvd0V2ZW50RGVmYXVsdCA/IFwibWFuaXB1bGF0aW9uXCIgOiBhbGxvd1ggPyBcInBhbi15XCIgOiBcInBhbi14XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhcnMuYWxsb3dDb250ZXh0TWVudSB8fCBfYWRkTGlzdGVuZXIodHJpZ2dlciwgXCJjb250ZXh0bWVudVwiLCBvbkNvbnRleHRNZW51KTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zZXRTZWxlY3RhYmxlKHRyaWdnZXJzLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIF9hZGRTY3JvbGxMaXN0ZW5lcih0YXJnZXQsIHVwZGF0ZVNjcm9sbCk7XG5cbiAgICAgIGVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoSW5lcnRpYVBsdWdpbiAmJiB0eXBlICE9PSBcInNvZnRcIikge1xuICAgICAgICBJbmVydGlhUGx1Z2luLnRyYWNrKHNjcm9sbFByb3h5IHx8IHRhcmdldCwgeHlNb2RlID8gXCJ4LHlcIiA6IHJvdGF0aW9uTW9kZSA/IFwicm90YXRpb25cIiA6IFwidG9wLGxlZnRcIik7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5fZ3NEcmFnSUQgPSBpZCA9IFwiZFwiICsgX2xvb2t1cENvdW50Kys7XG4gICAgICBfbG9va3VwW2lkXSA9IHNlbGY7XG5cbiAgICAgIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICBzY3JvbGxQcm94eS5lbmFibGUoKTtcbiAgICAgICAgc2Nyb2xsUHJveHkuZWxlbWVudC5fZ3NEcmFnSUQgPSBpZDtcbiAgICAgIH1cblxuICAgICAgKHZhcnMuYm91bmRzIHx8IHJvdGF0aW9uTW9kZSkgJiYgcmVjb3JkU3RhcnRQb3NpdGlvbnMoKTtcbiAgICAgIHZhcnMuYm91bmRzICYmIHNlbGYuYXBwbHlCb3VuZHMoKTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICBfdGhpczIuZGlzYWJsZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgZHJhZ2dpbmcgPSBzZWxmLmlzRHJhZ2dpbmcsXG4gICAgICAgICAgaSA9IHRyaWdnZXJzLmxlbmd0aCxcbiAgICAgICAgICB0cmlnZ2VyO1xuXG4gICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgX3NldFN0eWxlKHRyaWdnZXJzW2ldLCBcImN1cnNvclwiLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgIT09IFwic29mdFwiKSB7XG4gICAgICAgIF9zZXRUb3VjaEFjdGlvbkZvckFsbERlc2NlbmRhbnRzKHRyaWdnZXJzLCBudWxsKTtcblxuICAgICAgICBpID0gdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICAgIHRyaWdnZXIgPSB0cmlnZ2Vyc1tpXTtcblxuICAgICAgICAgIF9zZXRTdHlsZSh0cmlnZ2VyLCBcInRvdWNoQ2FsbG91dFwiLCBudWxsKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0cmlnZ2VyLCBcIm1vdXNlZG93blwiLCBvblByZXNzKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0cmlnZ2VyLCBcInRvdWNoc3RhcnRcIiwgb25QcmVzcyk7XG5cbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodHJpZ2dlciwgXCJjbGlja1wiLCBvbkNsaWNrLCB0cnVlKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0cmlnZ2VyLCBcImNvbnRleHRtZW51XCIsIG9uQ29udGV4dE1lbnUpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3NldFNlbGVjdGFibGUodHJpZ2dlcnMsIHRydWUpO1xuXG4gICAgICAgIGlmICh0b3VjaEV2ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2hjYW5jZWxcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNoZW5kXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodG91Y2hFdmVudFRhcmdldCwgXCJ0b3VjaG1vdmVcIiwgb25Nb3ZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgXCJtb3VzZXVwXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBcIm1vdXNlbW92ZVwiLCBvbk1vdmUpO1xuICAgICAgfVxuXG4gICAgICBfcmVtb3ZlU2Nyb2xsTGlzdGVuZXIodGFyZ2V0LCB1cGRhdGVTY3JvbGwpO1xuXG4gICAgICBlbmFibGVkID0gZmFsc2U7XG5cbiAgICAgIGlmIChJbmVydGlhUGx1Z2luICYmIHR5cGUgIT09IFwic29mdFwiKSB7XG4gICAgICAgIEluZXJ0aWFQbHVnaW4udW50cmFjayhzY3JvbGxQcm94eSB8fCB0YXJnZXQsIHh5TW9kZSA/IFwieCx5XCIgOiByb3RhdGlvbk1vZGUgPyBcInJvdGF0aW9uXCIgOiBcInRvcCxsZWZ0XCIpO1xuICAgICAgICBzZWxmLnR3ZWVuICYmIHNlbGYudHdlZW4ua2lsbCgpO1xuICAgICAgfVxuXG4gICAgICBzY3JvbGxQcm94eSAmJiBzY3JvbGxQcm94eS5kaXNhYmxlKCk7XG5cbiAgICAgIF9yZW1vdmVGcm9tUmVuZGVyUXVldWUocmVuZGVyKTtcblxuICAgICAgc2VsZi5pc0RyYWdnaW5nID0gc2VsZi5pc1ByZXNzZWQgPSBpc0NsaWNraW5nID0gZmFsc2U7XG4gICAgICBkcmFnZ2luZyAmJiBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRyYWdlbmRcIiwgXCJvbkRyYWdFbmRcIik7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgX3RoaXMyLmVuYWJsZWQgPSBmdW5jdGlvbiAodmFsdWUsIHR5cGUpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdmFsdWUgPyBzZWxmLmVuYWJsZSh0eXBlKSA6IHNlbGYuZGlzYWJsZSh0eXBlKSA6IGVuYWJsZWQ7XG4gICAgfTtcblxuICAgIF90aGlzMi5raWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5pc1Rocm93aW5nID0gZmFsc2U7XG4gICAgICBzZWxmLnR3ZWVuICYmIHNlbGYudHdlZW4ua2lsbCgpO1xuICAgICAgc2VsZi5kaXNhYmxlKCk7XG4gICAgICBnc2FwLnNldCh0cmlnZ2Vycywge1xuICAgICAgICBjbGVhclByb3BzOiBcInVzZXJTZWxlY3RcIlxuICAgICAgfSk7XG4gICAgICBkZWxldGUgX2xvb2t1cFt0YXJnZXQuX2dzRHJhZ0lEXTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICBfdGhpczIucmV2ZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5raWxsKCk7XG4gICAgICB0aGlzLnN0eWxlcyAmJiB0aGlzLnN0eWxlcy5yZXZlcnQoKTtcbiAgICB9O1xuXG4gICAgaWYgKH50eXBlLmluZGV4T2YoXCJzY3JvbGxcIikpIHtcbiAgICAgIHNjcm9sbFByb3h5ID0gX3RoaXMyLnNjcm9sbFByb3h5ID0gbmV3IFNjcm9sbFByb3h5KHRhcmdldCwgX2V4dGVuZCh7XG4gICAgICAgIG9uS2lsbDogZnVuY3Rpb24gb25LaWxsKCkge1xuICAgICAgICAgIC8vU2Nyb2xsUHJveHkncyBvbktpbGwoKSBnZXRzIGNhbGxlZCBpZi93aGVuIHRoZSBTY3JvbGxQcm94eSBzZW5zZXMgdGhhdCB0aGUgdXNlciBpbnRlcmFjdGVkIHdpdGggdGhlIHNjcm9sbCBwb3NpdGlvbiBtYW51YWxseSAobGlrZSB1c2luZyB0aGUgc2Nyb2xsYmFyKS4gSUU5IGRvZXNuJ3QgZmlyZSB0aGUgXCJtb3VzZXVwXCIgcHJvcGVybHkgd2hlbiB1c2VycyBkcmFnIHRoZSBzY3JvbGxiYXIgb2YgYW4gZWxlbWVudCwgc28gdGhpcyB3b3JrcyBhcm91bmQgdGhhdCBpc3N1ZS5cbiAgICAgICAgICBzZWxmLmlzUHJlc3NlZCAmJiBvblJlbGVhc2UobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHZhcnMpKTsgLy9hIGJ1ZyBpbiBtYW55IEFuZHJvaWQgZGV2aWNlcycgc3RvY2sgYnJvd3NlciBjYXVzZXMgc2Nyb2xsVG9wIHRvIGdldCBmb3JjZWQgYmFjayB0byAwIGFmdGVyIGl0IGlzIGFsdGVyZWQgdmlhIEpTLCBzbyB3ZSBzZXQgb3ZlcmZsb3cgdG8gXCJoaWRkZW5cIiBvbiBtb2JpbGUvdG91Y2ggZGV2aWNlcyAodGhleSBoaWRlIHRoZSBzY3JvbGwgYmFyIGFueXdheSkuIFRoYXQgd29ya3MgYXJvdW5kIHRoZSBidWcuIChUaGlzIGJ1ZyBpcyBkaXNjdXNzZWQgYXQgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9hbmRyb2lkL2lzc3Vlcy9kZXRhaWw/aWQ9MTk2MjUpXG5cbiAgICAgIHRhcmdldC5zdHlsZS5vdmVyZmxvd1kgPSBhbGxvd1kgJiYgIV9pc1RvdWNoRGV2aWNlID8gXCJhdXRvXCIgOiBcImhpZGRlblwiO1xuICAgICAgdGFyZ2V0LnN0eWxlLm92ZXJmbG93WCA9IGFsbG93WCAmJiAhX2lzVG91Y2hEZXZpY2UgPyBcImF1dG9cIiA6IFwiaGlkZGVuXCI7XG4gICAgICB0YXJnZXQgPSBzY3JvbGxQcm94eS5jb250ZW50O1xuICAgIH1cblxuICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgIGtpbGxQcm9wcy5yb3RhdGlvbiA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAga2lsbFByb3BzW3hQcm9wXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAga2lsbFByb3BzW3lQcm9wXSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ3NDYWNoZS5mb3JjZTNEID0gXCJmb3JjZTNEXCIgaW4gdmFycyA/IHZhcnMuZm9yY2UzRCA6IHRydWU7IC8vb3RoZXJ3aXNlLCBub3JtYWwgZHJhZ2dpbmcgd291bGQgYmUgaW4gMkQgYW5kIHRoZW4gYXMgc29vbiBhcyBpdCdzIHJlbGVhc2VkIGFuZCB0aGVyZSdzIGFuIGluZXJ0aWEgdHdlZW4sIGl0J2QganVtcCB0byAzRCB3aGljaCBjYW4gY3JlYXRlIGFuIGluaXRpYWwganVtcCBkdWUgdG8gdGhlIHdvcmsgdGhlIGJyb3dzZXIgbXVzdCB0byBkbyBsYXllcml6ZSBpdC5cblxuICAgIF9jb250ZXh0KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMyKSk7XG5cbiAgICBfdGhpczIuZW5hYmxlKCk7XG5cbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgRHJhZ2dhYmxlLnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoY29yZSkge1xuICAgIGdzYXAgPSBjb3JlO1xuXG4gICAgX2luaXRDb3JlKCk7XG4gIH07XG5cbiAgRHJhZ2dhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSh0YXJnZXRzLCB2YXJzKSB7XG4gICAgX2NvcmVJbml0dGVkIHx8IF9pbml0Q29yZSh0cnVlKTtcbiAgICByZXR1cm4gX3RvQXJyYXkodGFyZ2V0cykubWFwKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBuZXcgRHJhZ2dhYmxlKHRhcmdldCwgdmFycyk7XG4gICAgfSk7XG4gIH07XG5cbiAgRHJhZ2dhYmxlLmdldCA9IGZ1bmN0aW9uIGdldCh0YXJnZXQpIHtcbiAgICByZXR1cm4gX2xvb2t1cFsoX3RvQXJyYXkodGFyZ2V0KVswXSB8fCB7fSkuX2dzRHJhZ0lEXTtcbiAgfTtcblxuICBEcmFnZ2FibGUudGltZVNpbmNlRHJhZyA9IGZ1bmN0aW9uIHRpbWVTaW5jZURyYWcoKSB7XG4gICAgcmV0dXJuIChfZ2V0VGltZSgpIC0gX2xhc3REcmFnVGltZSkgLyAxMDAwO1xuICB9O1xuXG4gIERyYWdnYWJsZS5oaXRUZXN0ID0gZnVuY3Rpb24gaGl0VGVzdChvYmoxLCBvYmoyLCB0aHJlc2hvbGQpIHtcbiAgICBpZiAob2JqMSA9PT0gb2JqMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciByMSA9IF9wYXJzZVJlY3Qob2JqMSksXG4gICAgICAgIHIyID0gX3BhcnNlUmVjdChvYmoyKSxcbiAgICAgICAgdG9wID0gcjEudG9wLFxuICAgICAgICBsZWZ0ID0gcjEubGVmdCxcbiAgICAgICAgcmlnaHQgPSByMS5yaWdodCxcbiAgICAgICAgYm90dG9tID0gcjEuYm90dG9tLFxuICAgICAgICB3aWR0aCA9IHIxLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSByMS5oZWlnaHQsXG4gICAgICAgIGlzT3V0c2lkZSA9IHIyLmxlZnQgPiByaWdodCB8fCByMi5yaWdodCA8IGxlZnQgfHwgcjIudG9wID4gYm90dG9tIHx8IHIyLmJvdHRvbSA8IHRvcCxcbiAgICAgICAgb3ZlcmxhcCxcbiAgICAgICAgYXJlYSxcbiAgICAgICAgaXNSYXRpbztcblxuICAgIGlmIChpc091dHNpZGUgfHwgIXRocmVzaG9sZCkge1xuICAgICAgcmV0dXJuICFpc091dHNpZGU7XG4gICAgfVxuXG4gICAgaXNSYXRpbyA9ICh0aHJlc2hvbGQgKyBcIlwiKS5pbmRleE9mKFwiJVwiKSAhPT0gLTE7XG4gICAgdGhyZXNob2xkID0gcGFyc2VGbG9hdCh0aHJlc2hvbGQpIHx8IDA7XG4gICAgb3ZlcmxhcCA9IHtcbiAgICAgIGxlZnQ6IE1hdGgubWF4KGxlZnQsIHIyLmxlZnQpLFxuICAgICAgdG9wOiBNYXRoLm1heCh0b3AsIHIyLnRvcClcbiAgICB9O1xuICAgIG92ZXJsYXAud2lkdGggPSBNYXRoLm1pbihyaWdodCwgcjIucmlnaHQpIC0gb3ZlcmxhcC5sZWZ0O1xuICAgIG92ZXJsYXAuaGVpZ2h0ID0gTWF0aC5taW4oYm90dG9tLCByMi5ib3R0b20pIC0gb3ZlcmxhcC50b3A7XG5cbiAgICBpZiAob3ZlcmxhcC53aWR0aCA8IDAgfHwgb3ZlcmxhcC5oZWlnaHQgPCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzUmF0aW8pIHtcbiAgICAgIHRocmVzaG9sZCAqPSAwLjAxO1xuICAgICAgYXJlYSA9IG92ZXJsYXAud2lkdGggKiBvdmVybGFwLmhlaWdodDtcbiAgICAgIHJldHVybiBhcmVhID49IHdpZHRoICogaGVpZ2h0ICogdGhyZXNob2xkIHx8IGFyZWEgPj0gcjIud2lkdGggKiByMi5oZWlnaHQgKiB0aHJlc2hvbGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG92ZXJsYXAud2lkdGggPiB0aHJlc2hvbGQgJiYgb3ZlcmxhcC5oZWlnaHQgPiB0aHJlc2hvbGQ7XG4gIH07XG5cbiAgcmV0dXJuIERyYWdnYWJsZTtcbn0oRXZlbnREaXNwYXRjaGVyKTtcblxuX3NldERlZmF1bHRzKERyYWdnYWJsZS5wcm90b3R5cGUsIHtcbiAgcG9pbnRlclg6IDAsXG4gIHBvaW50ZXJZOiAwLFxuICBzdGFydFg6IDAsXG4gIHN0YXJ0WTogMCxcbiAgZGVsdGFYOiAwLFxuICBkZWx0YVk6IDAsXG4gIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICBpc1ByZXNzZWQ6IGZhbHNlXG59KTtcblxuRHJhZ2dhYmxlLnpJbmRleCA9IDEwMDA7XG5EcmFnZ2FibGUudmVyc2lvbiA9IFwiMy4xMi41XCI7XG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oRHJhZ2dhYmxlKTtcbmV4cG9ydCB7IERyYWdnYWJsZSBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJfaW5oZXJpdHNMb29zZSIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiX19wcm90b19fIiwiZ2V0R2xvYmFsTWF0cml4IiwiTWF0cml4MkQiLCJnc2FwIiwiX3dpbiIsIl9kb2MiLCJfZG9jRWxlbWVudCIsIl9ib2R5IiwiX3RlbXBEaXYiLCJfcGxhY2Vob2xkZXJEaXYiLCJfY29yZUluaXR0ZWQiLCJfY2hlY2tQcmVmaXgiLCJfdG9BcnJheSIsIl9zdXBwb3J0c1Bhc3NpdmUiLCJfaXNUb3VjaERldmljZSIsIl90b3VjaEV2ZW50TG9va3VwIiwiX2lzTXVsdGlUb3VjaGluZyIsIl9pc0FuZHJvaWQiLCJJbmVydGlhUGx1Z2luIiwiX2RlZmF1bHRDdXJzb3IiLCJfc3VwcG9ydHNQb2ludGVyIiwiX2NvbnRleHQiLCJfZ2V0U3R5bGVTYXZlciIsIl9kcmFnQ291bnQiLCJfd2luZG93RXhpc3RzIiwid2luZG93IiwiX2dldEdTQVAiLCJyZWdpc3RlclBsdWdpbiIsIl9pc0Z1bmN0aW9uIiwidmFsdWUiLCJfaXNPYmplY3QiLCJfaXNVbmRlZmluZWQiLCJfZW1wdHlGdW5jIiwiX3RyYW5zZm9ybVByb3AiLCJfdHJhbnNmb3JtT3JpZ2luUHJvcCIsIl9yb3VuZCIsIk1hdGgiLCJyb3VuZCIsIl9pc0FycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiX2NyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwibnMiLCJlIiwiY3JlYXRlRWxlbWVudE5TIiwicmVwbGFjZSIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsIl9SQUQyREVHIiwiUEkiLCJfYmlnTnVtIiwiX2lkZW50aXR5TWF0cml4IiwiX2dldFRpbWUiLCJEYXRlIiwibm93IiwiZ2V0VGltZSIsIl9yZW5kZXJRdWV1ZSIsIl9sb29rdXAiLCJfbG9va3VwQ291bnQiLCJfY2xpY2thYmxlVGFnRXhwIiwiX2xhc3REcmFnVGltZSIsIl90ZW1wMSIsIl93aW5kb3dQcm94eSIsIl9jb3B5Iiwib2JqIiwiZmFjdG9yIiwiY29weSIsInAiLCJfZXh0ZW5kIiwiZGVmYXVsdHMiLCJfc2V0VG91Y2hBY3Rpb25Gb3JBbGxEZXNjZW5kYW50cyIsImVsZW1lbnRzIiwiaSIsImxlbmd0aCIsImNoaWxkcmVuIiwidG91Y2hBY3Rpb24iLCJyZW1vdmVQcm9wZXJ0eSIsIl9yZW5kZXJRdWV1ZVRpY2siLCJmb3JFYWNoIiwiZnVuYyIsIl9hZGRUb1JlbmRlclF1ZXVlIiwicHVzaCIsInRpY2tlciIsImFkZCIsIl9yZW5kZXJRdWV1ZVRpbWVvdXQiLCJyZW1vdmUiLCJfcmVtb3ZlRnJvbVJlbmRlclF1ZXVlIiwic3BsaWNlIiwidG8iLCJvdmVyd3JpdGUiLCJkZWxheSIsImR1cmF0aW9uIiwib25Db21wbGV0ZSIsImRhdGEiLCJfc2V0RGVmYXVsdHMiLCJfYWRkTGlzdGVuZXIiLCJlbGVtZW50IiwiY2FwdHVyZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJ0b3VjaFR5cGUiLCJwYXNzaXZlIiwiX3JlbW92ZUxpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIl9wcmV2ZW50RGVmYXVsdCIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJwcmV2ZW50TWFuaXB1bGF0aW9uIiwiX2hhc1RvdWNoSUQiLCJsaXN0IiwiSUQiLCJpZGVudGlmaWVyIiwiX29uTXVsdGlUb3VjaERvY3VtZW50RW5kIiwidG91Y2hlcyIsInRhcmdldCIsIl9vbk11bHRpVG91Y2hEb2N1bWVudCIsIl9nZXREb2NTY3JvbGxUb3AiLCJkb2MiLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsImRvY3VtZW50RWxlbWVudCIsImJvZHkiLCJfZ2V0RG9jU2Nyb2xsTGVmdCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsTGVmdCIsIl9hZGRTY3JvbGxMaXN0ZW5lciIsImNhbGxiYWNrIiwiX2lzUm9vdCIsInBhcmVudE5vZGUiLCJfcmVtb3ZlU2Nyb2xsTGlzdGVuZXIiLCJub2RlVHlwZSIsIl9nZXRNYXhTY3JvbGwiLCJheGlzIiwiZGltIiwic2Nyb2xsIiwiY2xpZW50IiwibWF4IiwiX3JlY29yZE1heFNjcm9sbHMiLCJza2lwQ3VycmVudCIsIngiLCJ5IiwiX2dzTWF4U2Nyb2xsWCIsIl9nc01heFNjcm9sbFkiLCJfZ3NTY3JvbGxYIiwiX2dzU2Nyb2xsWSIsIl9zZXRTdHlsZSIsInByb3BlcnR5IiwidG9Mb3dlckNhc2UiLCJfZ2V0Q29tcHV0ZWRTdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJFbGVtZW50IiwiaG9zdCIsIl90ZW1wUmVjdCIsIl9wYXJzZVJlY3QiLCJsZWZ0IiwidG9wIiwid2lkdGgiLCJyaWdodCIsImNsaWVudFdpZHRoIiwiaW5uZXJXaWR0aCIsImhlaWdodCIsImJvdHRvbSIsImlubmVySGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwib3duZXJEb2N1bWVudCIsInIiLCJwYWdlWCIsInBhZ2VZIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiX2Rpc3BhdGNoRXZlbnQiLCJjYWxsYmFja05hbWUiLCJ2YXJzIiwibGlzdGVuZXJzIiwiX2xpc3RlbmVycyIsInJlc3VsdCIsImFwcGx5IiwiY2FsbGJhY2tTY29wZSIsInBvaW50ZXJFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJfZ2V0Qm91bmRzIiwiY29udGV4dCIsIm9mZnNldCIsIm1pbiIsIm1pblgiLCJtaW5Sb3RhdGlvbiIsIm1pblkiLCJtYXhYIiwibWF4Um90YXRpb24iLCJtYXhZIiwiX2dldEVsZW1lbnRCb3VuZHMiLCJfcG9pbnQxIiwiaXNTVkciLCJnZXRCQm94Iiwib3duZXJTVkdFbGVtZW50IiwibWF0cml4IiwicDEiLCJwMiIsInAzIiwicDQiLCJiYm94IiwiY3MiLCJ2aWV3Qm94IiwiYmFzZVZhbCIsImJveFNpemluZyIsInBhcnNlRmxvYXQiLCJib3JkZXJMZWZ0V2lkdGgiLCJib3JkZXJSaWdodFdpZHRoIiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJCb3R0b21XaWR0aCIsIm11bHRpcGx5IiwiX3BhcnNlSW5lcnRpYSIsImRyYWdnYWJsZSIsInNuYXAiLCJmb3JjZVplcm9WZWxvY2l0eSIsImEiLCJsIiwiZW5kIiwiY2FsbCIsInZlbG9jaXR5IiwiX2lzQ2xpY2thYmxlIiwiZ2V0QXR0cmlidXRlIiwidGVzdCIsIm5vZGVOYW1lIiwiX3NldFNlbGVjdGFibGUiLCJzZWxlY3RhYmxlIiwib25kcmFnc3RhcnQiLCJvbnNlbGVjdHN0YXJ0Iiwic2V0IiwibGF6eSIsInVzZXJTZWxlY3QiLCJfaXNGaXhlZCIsInBvc2l0aW9uIiwiX3N1cHBvcnRzM0QiLCJfYWRkUGFkZGluZ0JSIiwiU2Nyb2xsUHJveHkiLCJ1dGlscyIsInRvQXJyYXkiLCJjb250ZW50IiwiZG9jdW1lbnQiLCJub2RlIiwiZmlyc3RDaGlsZCIsIm9mZnNldFRvcCIsIm9mZnNldExlZnQiLCJwcmV2VG9wIiwicHJldkxlZnQiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsImV4dHJhUGFkUmlnaHQiLCJtYXhMZWZ0IiwibWF4VG9wIiwiZWxlbWVudFdpZHRoIiwiZWxlbWVudEhlaWdodCIsImNvbnRlbnRIZWlnaHQiLCJuZXh0Tm9kZSIsInRyYW5zZm9ybVN0YXJ0IiwidHJhbnNmb3JtRW5kIiwiZm9yY2UzRCIsImZvcmNlIiwiYXJndW1lbnRzIiwiZGlmIiwib2xkT2Zmc2V0Iiwia2lsbFR3ZWVuc09mIiwib25LaWxsIiwiX3NraXAiLCJwYWRkaW5nUmlnaHQiLCJtYXhTY3JvbGxUb3AiLCJtYXhTY3JvbGxMZWZ0IiwiZGlzYWJsZSIsIm5leHRTaWJsaW5nIiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVDaGlsZCIsImVuYWJsZSIsImNhbGlicmF0ZSIsIndpZHRoTWF0Y2hlcyIsIm9mZnNldEhlaWdodCIsImRpc3BsYXkiLCJwYWRkaW5nTGVmdCIsIm92ZXJmbG93IiwidmVydGljYWxBbGlnbiIsInBhZGRpbmdCb3R0b20iLCJfaW5pdENvcmUiLCJyZXF1aXJlZCIsIm5hdiIsIm5hdmlnYXRvciIsIlBvaW50ZXJFdmVudCIsImNzc1RleHQiLCJjdXJzb3IiLCJ1c2VyQWdlbnQiLCJpbmRleE9mIiwiTWF4VG91Y2hQb2ludHMiLCJtc01heFRvdWNoUG9pbnRzIiwiZGl2IiwiY2hpbGQiLCJjaGlsZFN0eWxlIiwicGFyZW50IiwidmFsIiwidHlwZXMiLCJzdGFuZGFyZCIsInNwbGl0IiwiY29udmVydGVkIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJpc1ByZXNzZWQiLCJlbmREcmFnIiwicGx1Z2lucyIsImluZXJ0aWEiLCJjb3JlIiwiY2hlY2tQcmVmaXgiLCJnZXRTdHlsZVNhdmVyIiwiY29uc29sZSIsIndhcm4iLCJFdmVudERpc3BhdGNoZXIiLCJfcHJvdG8iLCJfdGhpcyIsIkRyYWdnYWJsZSIsIl9FdmVudERpc3BhdGNoZXIiLCJfdGhpczIiLCJzdHlsZXMiLCJyb3RhdGlvbiIsImRyYWdSZXNpc3RhbmNlIiwiZWRnZVJlc2lzdGFuY2UiLCJpc05hTiIsImxvY2tBeGlzIiwiYXV0b1Njcm9sbCIsImxvY2tlZEF4aXMiLCJhbGxvd0V2ZW50RGVmYXVsdCIsImdldFByb3BlcnR5IiwieHlNb2RlIiwicm90YXRpb25Nb2RlIiwieFByb3AiLCJ5UHJvcCIsImFsbG93WCIsImFsbG93WSIsIm1pbmltdW1Nb3ZlbWVudCIsInRyaWdnZXJzIiwidHJpZ2dlciIsImhhbmRsZSIsImtpbGxQcm9wcyIsImRyYWdFbmRUaW1lIiwiY2hlY2tBdXRvU2Nyb2xsQm91bmRzIiwiYXV0b1Njcm9sbE1hcmdpblRvcCIsImF1dG9TY3JvbGxNYXJnaW5SaWdodCIsImF1dG9TY3JvbGxNYXJnaW5Cb3R0b20iLCJhdXRvU2Nyb2xsTWFyZ2luTGVmdCIsImlzQ2xpY2thYmxlIiwiY2xpY2thYmxlVGVzdCIsImNsaWNrVGltZSIsImdzQ2FjaGUiLCJfZ3NhcCIsImdldENhY2hlIiwiaXNGaXhlZCIsImdldFByb3BBc051bSIsInVuaXQiLCJvd25lckRvYyIsImVuYWJsZWQiLCJzY3JvbGxQcm94eSIsInN0YXJ0UG9pbnRlclgiLCJzdGFydFBvaW50ZXJZIiwic3RhcnRFbGVtZW50WCIsInN0YXJ0RWxlbWVudFkiLCJoYXNCb3VuZHMiLCJoYXNEcmFnQ2FsbGJhY2siLCJoYXNNb3ZlQ2FsbGJhY2siLCJ0b3VjaCIsInRvdWNoSUQiLCJyb3RhdGlvbk9yaWdpbiIsImRpcnR5Iiwib2xkIiwic25hcFgiLCJzbmFwWSIsInNuYXBYWSIsImlzQ2xpY2tpbmciLCJ0b3VjaEV2ZW50VGFyZ2V0IiwiaW50ZXJydXB0ZWQiLCJhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nIiwidG91Y2hEcmFnQXhpcyIsImlzRGlzcGF0Y2hpbmciLCJjbGlja0Rpc3BhdGNoIiwidHJ1c3RlZENsaWNrRGlzcGF0Y2giLCJpc1ByZXZlbnRpbmdEZWZhdWx0IiwiaW5uZXJNYXRyaXgiLCJkcmFnZ2VkIiwib25Db250ZXh0TWVudSIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInJlbmRlciIsInN1cHByZXNzRXZlbnRzIiwiaXNEcmFnZ2luZyIsImF1dG9TY3JvbGxGYWN0b3IiLCJpc1Jvb3QiLCJyZWN0IiwicG9pbnRlclgiLCJwb2ludGVyWSIsImNoYW5nZVgiLCJjaGFuZ2VZIiwiZ2FwIiwic2Nyb2xsVG8iLCJzZXRQb2ludGVyUG9zaXRpb24iLCJkZWx0YVgiLCJyZW5kZXJUcmFuc2Zvcm0iLCJkZWx0YVkiLCJzeW5jWFkiLCJza2lwT25VcGRhdGUiLCJza2lwU25hcCIsInNuYXBwZWRWYWx1ZSIsInVuY2FjaGUiLCJpc1Rocm93aW5nIiwiYnVpbGRTbmFwRnVuYyIsIm4iLCJlZGdlVG9sZXJhbmNlIiwiY2xvc2VzdCIsImFic0RpZiIsImJ1aWxkUG9pbnRTbmFwRnVuYyIsInJhZGl1cyIsInBvaW50IiwiZHgiLCJkeSIsIm1pbkRpc3QiLCJkaXN0IiwiY2FsY3VsYXRlQm91bmRzIiwiYm91bmRzIiwidGFyZ2V0Qm91bmRzIiwic25hcElzUmF3IiwibGl2ZVNuYXAiLCJwb2ludHMiLCJvblRocm93Q29tcGxldGUiLCJvblRocm93SW50ZXJydXB0IiwiYW5pbWF0ZSIsInR3ZWVuIiwib3ZlcnNob290VG9sZXJhbmNlIiwicmVzaXN0YW5jZSIsInRocm93UmVzaXN0YW5jZSIsImxpbmtlZFByb3BzIiwibWluRHVyYXRpb24iLCJtYXhEdXJhdGlvbiIsIm92ZXJzaG9vdCIsImluaGVyaXQiLCJvbkludGVycnVwdCIsIm9uVXBkYXRlIiwiZmFzdE1vZGUiLCJvblVwZGF0ZVBhcmFtcyIsImVuZFgiLCJlbmRZIiwiZW5kUm90YXRpb24iLCJwbGF5IiwiYXBwbHlCb3VuZHMiLCJ1cGRhdGVNYXRyaXgiLCJzaGlmdFN0YXJ0Iiwic3RhcnQiLCJlcXVhbHMiLCJpbnZlcnNlIiwicmVjb3JkU3RhcnRQb3NpdGlvbnMiLCJvZmZzZXRYIiwib2Zmc2V0WSIsInBhcnNlZE9yaWdpbiIsImlzVHdlZW5pbmciLCJ4T3JpZ2luIiwieU9yaWdpbiIsImF0YW4yIiwic3RhcnRYIiwic3RhcnRZIiwiaXNBY3RpdmUiLCJyZW1vdmVQbGFjZWhvbGRlciIsIm9uUHJlc3MiLCJjdXJyZW50VGFyZ2V0Iiwib25SZWxlYXNlIiwib25Nb3ZlIiwiZHJhZ0NsaWNrYWJsZXMiLCJhbGxvd0NvbnRleHRNZW51IiwiY3RybEtleSIsIndoaWNoIiwiY2hhbmdlZFRvdWNoZXMiLCJwb2ludGVySWQiLCJraWxsIiwiekluZGV4Qm9vc3QiLCJ6SW5kZXgiLCJvbkRyYWciLCJkcmFnIiwibW92ZSIsImFjdGl2ZUN1cnNvciIsIm9yaWdpbmFsRXZlbnQiLCJhYnMiLCJsb2NrQXhpc09uVG91Y2hTY3JvbGwiLCJvbkxvY2tBeGlzIiwiY2FuY2VsYWJsZSIsImludm9rZU9uTW92ZSIsImRyYWdUb2xlcmFuY2UiLCJwcmV2UG9pbnRlclgiLCJwcmV2UG9pbnRlclkiLCJwcmV2U3RhcnRFbGVtZW50WSIsInByZXZYIiwicHJldlkiLCJwcmV2RW5kWCIsInByZXZFbmRZIiwicHJldkVuZFJvdGF0aW9uIiwicHJldkRpcnR5IiwieENoYW5nZSIsInlDaGFuZ2UiLCJ0ZW1wIiwiYyIsImIiLCJkIiwiZiIsIndhc0RyYWdnaW5nIiwiaXNDb250ZXh0TWVudVJlbGVhc2UiLCJwbGFjZWhvbGRlckRlbGF5ZWRDYWxsIiwiZGVsYXllZENhbGwiLCJzeW50aGV0aWNFdmVudCIsImV2ZW50VGFyZ2V0Iiwic3ludGhldGljQ2xpY2siLCJ0aHJvd1Byb3BzIiwiZGVmYXVsdFByZXZlbnRlZCIsImNsaWNrIiwiY3JlYXRlRXZlbnQiLCJpbml0TW91c2VFdmVudCIsInNjcmVlblgiLCJzY3JlZW5ZIiwidXBkYXRlU2Nyb2xsIiwib25DbGljayIsInRpbWUiLCJyZWNlbnRseUNsaWNrZWQiLCJyZWNlbnRseURyYWdnZWQiLCJhbHJlYWR5RGlzcGF0Y2hlZCIsImFscmVhZHlEaXNwYXRjaGVkVHJ1c3RlZCIsInRydXN0ZWQiLCJpc1RydXN0ZWQiLCJzdXBwcmVzc0NsaWNrT25EcmFnIiwiZGV0YWlsIiwibG9jYWxpemVQb2ludCIsInN0YXJ0RHJhZyIsImFsaWduIiwicjEiLCJyMiIsImhpdFRlc3QiLCJ0aW1lU2luY2VEcmFnIiwidGltZVNpbmNlQ2xpY2siLCJ0aHJlc2hvbGQiLCJnZXREaXJlY3Rpb24iLCJmcm9tIiwiZGlhZ29uYWxUaHJlc2hvbGQiLCJtb2RlIiwicmF0aW8iLCJkaXJlY3Rpb24iLCJnZXRWZWxvY2l0eSIsIm5ld0JvdW5kcyIsInN0aWNreSIsInVwZGF0ZSIsImlnbm9yZUV4dGVybmFsQ2hhbmdlcyIsIm0iLCJtMiIsInNldFZhcnMiLCJpZCIsInRvdWNoQ2FsbG91dCIsInRyYWNrIiwiX2dzRHJhZ0lEIiwiZHJhZ2dpbmciLCJ1bnRyYWNrIiwiY2xlYXJQcm9wcyIsInJldmVydCIsIm92ZXJmbG93WSIsIm92ZXJmbG93WCIsInJlZ2lzdGVyIiwidGFyZ2V0cyIsIm1hcCIsIm9iajEiLCJvYmoyIiwiaXNPdXRzaWRlIiwib3ZlcmxhcCIsImFyZWEiLCJpc1JhdGlvIiwidmVyc2lvbiIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Draggable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/EasePack.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/EasePack.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EasePack: function() { return /* binding */ EasePack; },\n/* harmony export */   ExpoScaleEase: function() { return /* binding */ ExpoScaleEase; },\n/* harmony export */   RoughEase: function() { return /* binding */ RoughEase; },\n/* harmony export */   SlowMo: function() { return /* binding */ SlowMo; },\n/* harmony export */   \"default\": function() { return /* binding */ EasePack; }\n/* harmony export */ });\n/*!\n * EasePack 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var gsap, _coreInitted, _registerEase, _getGSAP = function _getGSAP() {\n    return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _boolean = function _boolean(value, defaultValue) {\n    return !!(typeof value === \"undefined\" ? defaultValue : value && !~(value + \"\").indexOf(\"false\"));\n}, _initCore = function _initCore(core) {\n    gsap = core || _getGSAP();\n    if (gsap) {\n        _registerEase = gsap.registerEase; //add weighted ease capabilities to standard eases so users can do \"power2.inOut(0.8)\" for example to push everything toward the \"out\", or (-0.8) to push it toward the \"in\" (0 is neutral)\n        var eases = gsap.parseEase(), createConfig = function createConfig(ease) {\n            return function(ratio) {\n                var y = 0.5 + ratio / 2;\n                ease.config = function(p) {\n                    return ease(2 * (1 - p) * p * y + p * p);\n                };\n            };\n        }, p;\n        for(p in eases){\n            if (!eases[p].config) {\n                createConfig(eases[p]);\n            }\n        }\n        _registerEase(\"slow\", SlowMo);\n        _registerEase(\"expoScale\", ExpoScaleEase);\n        _registerEase(\"rough\", RoughEase);\n        for(p in EasePack){\n            p !== \"version\" && gsap.core.globals(p, EasePack[p]);\n        }\n        _coreInitted = 1;\n    }\n}, _createSlowMo = function _createSlowMo(linearRatio, power, yoyoMode) {\n    linearRatio = Math.min(1, linearRatio || 0.7);\n    var pow = linearRatio < 1 ? power || power === 0 ? power : 0.7 : 0, p1 = (1 - linearRatio) / 2, p3 = p1 + linearRatio, calcEnd = _boolean(yoyoMode);\n    return function(p) {\n        var r = p + (0.5 - p) * pow;\n        return p < p1 ? calcEnd ? 1 - (p = 1 - p / p1) * p : r - (p = 1 - p / p1) * p * p * p * r : p > p3 ? calcEnd ? p === 1 ? 0 : 1 - (p = (p - p3) / p1) * p : r + (p - r) * (p = (p - p3) / p1) * p * p * p : calcEnd ? 1 : r;\n    };\n}, _createExpoScale = function _createExpoScale(start, end, ease) {\n    var p1 = Math.log(end / start), p2 = end - start;\n    ease && (ease = gsap.parseEase(ease));\n    return function(p) {\n        return (start * Math.exp(p1 * (ease ? ease(p) : p)) - start) / p2;\n    };\n}, EasePoint = function EasePoint(time, value, next) {\n    this.t = time;\n    this.v = value;\n    if (next) {\n        this.next = next;\n        next.prev = this;\n        this.c = next.v - value;\n        this.gap = next.t - time;\n    }\n}, _createRoughEase = function _createRoughEase(vars) {\n    if (typeof vars !== \"object\") {\n        //users may pass in via a string, like \"rough(30)\"\n        vars = {\n            points: +vars || 20\n        };\n    }\n    var taper = vars.taper || \"none\", a = [], cnt = 0, points = (+vars.points || 20) | 0, i = points, randomize = _boolean(vars.randomize, true), clamp = _boolean(vars.clamp), template = gsap ? gsap.parseEase(vars.template) : 0, strength = (+vars.strength || 1) * 0.4, x, y, bump, invX, obj, pnt, recent;\n    while(--i > -1){\n        x = randomize ? Math.random() : 1 / points * i;\n        y = template ? template(x) : x;\n        if (taper === \"none\") {\n            bump = strength;\n        } else if (taper === \"out\") {\n            invX = 1 - x;\n            bump = invX * invX * strength;\n        } else if (taper === \"in\") {\n            bump = x * x * strength;\n        } else if (x < 0.5) {\n            //\"both\" (start)\n            invX = x * 2;\n            bump = invX * invX * 0.5 * strength;\n        } else {\n            //\"both\" (end)\n            invX = (1 - x) * 2;\n            bump = invX * invX * 0.5 * strength;\n        }\n        if (randomize) {\n            y += Math.random() * bump - bump * 0.5;\n        } else if (i % 2) {\n            y += bump * 0.5;\n        } else {\n            y -= bump * 0.5;\n        }\n        if (clamp) {\n            if (y > 1) {\n                y = 1;\n            } else if (y < 0) {\n                y = 0;\n            }\n        }\n        a[cnt++] = {\n            x: x,\n            y: y\n        };\n    }\n    a.sort(function(a, b) {\n        return a.x - b.x;\n    });\n    pnt = new EasePoint(1, 1, null);\n    i = points;\n    while(i--){\n        obj = a[i];\n        pnt = new EasePoint(obj.x, obj.y, pnt);\n    }\n    recent = new EasePoint(0, 0, pnt.t ? pnt : pnt.next);\n    return function(p) {\n        var pnt = recent;\n        if (p > pnt.t) {\n            while(pnt.next && p >= pnt.t){\n                pnt = pnt.next;\n            }\n            pnt = pnt.prev;\n        } else {\n            while(pnt.prev && p <= pnt.t){\n                pnt = pnt.prev;\n            }\n        }\n        recent = pnt;\n        return pnt.v + (p - pnt.t) / pnt.gap * pnt.c;\n    };\n};\nvar SlowMo = _createSlowMo(0.7);\nSlowMo.ease = SlowMo; //for backward compatibility\nSlowMo.config = _createSlowMo;\nvar ExpoScaleEase = _createExpoScale(1, 2);\nExpoScaleEase.config = _createExpoScale;\nvar RoughEase = _createRoughEase();\nRoughEase.ease = RoughEase; //for backward compatibility\nRoughEase.config = _createRoughEase;\nvar EasePack = {\n    SlowMo: SlowMo,\n    RoughEase: RoughEase,\n    ExpoScaleEase: ExpoScaleEase\n};\nfor(var p in EasePack){\n    EasePack[p].register = _initCore;\n    EasePack[p].version = \"3.12.5\";\n}\n_getGSAP() && gsap.registerPlugin(SlowMo);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9FYXNlUGFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCLEdBQ2xCLElBQUlBLE1BQ0FDLGNBQ0FDLGVBQ0FDLFdBQVcsU0FBU0E7SUFDdEIsT0FBT0gsUUFBUSxPQUFPSSxXQUFXLGVBQWdCSixDQUFBQSxPQUFPSSxPQUFPSixJQUFJLEtBQUtBLEtBQUtLLGNBQWMsSUFBSUw7QUFDakcsR0FDSU0sV0FBVyxTQUFTQSxTQUFTQyxLQUFLLEVBQUVDLFlBQVk7SUFDbEQsT0FBTyxDQUFDLENBQUUsUUFBT0QsVUFBVSxjQUFjQyxlQUFlRCxTQUFTLENBQUMsQ0FBQyxDQUFDQSxRQUFRLEVBQUMsRUFBR0UsT0FBTyxDQUFDLFFBQU87QUFDakcsR0FDSUMsWUFBWSxTQUFTQSxVQUFVQyxJQUFJO0lBQ3JDWCxPQUFPVyxRQUFRUjtJQUVmLElBQUlILE1BQU07UUFDUkUsZ0JBQWdCRixLQUFLWSxZQUFZLEVBQUUsMkxBQTJMO1FBRTlOLElBQUlDLFFBQVFiLEtBQUtjLFNBQVMsSUFDdEJDLGVBQWUsU0FBU0EsYUFBYUMsSUFBSTtZQUMzQyxPQUFPLFNBQVVDLEtBQUs7Z0JBQ3BCLElBQUlDLElBQUksTUFBTUQsUUFBUTtnQkFFdEJELEtBQUtHLE1BQU0sR0FBRyxTQUFVQyxDQUFDO29CQUN2QixPQUFPSixLQUFLLElBQUssS0FBSUksQ0FBQUEsSUFBS0EsSUFBSUYsSUFBSUUsSUFBSUE7Z0JBQ3hDO1lBQ0Y7UUFDRixHQUNJQTtRQUVKLElBQUtBLEtBQUtQLE1BQU87WUFDZixJQUFJLENBQUNBLEtBQUssQ0FBQ08sRUFBRSxDQUFDRCxNQUFNLEVBQUU7Z0JBQ3BCSixhQUFhRixLQUFLLENBQUNPLEVBQUU7WUFDdkI7UUFDRjtRQUVBbEIsY0FBYyxRQUFRbUI7UUFFdEJuQixjQUFjLGFBQWFvQjtR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QUtJLFNBQVU7SUFDdEJBLFFBQVEsQ0FBQ0osRUFBRSxDQUFDbUQsUUFBUSxHQUFHN0Q7SUFDdkJjLFFBQVEsQ0FBQ0osRUFBRSxDQUFDb0QsT0FBTyxHQUFHO0FBQ3hCO0FBRUFyRSxjQUFjSCxLQUFLSyxjQUFjLENBQUNnQjtBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9FYXNlUGFjay5qcz9kZTczIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRWFzZVBhY2sgMy4xMi41XG4gKiBodHRwczovL2dzYXAuY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyNCwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9nc2FwLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHU0FQIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIGdzYXAsXG4gICAgX2NvcmVJbml0dGVkLFxuICAgIF9yZWdpc3RlckVhc2UsXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9ib29sZWFuID0gZnVuY3Rpb24gX2Jvb2xlYW4odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gISEodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiID8gZGVmYXVsdFZhbHVlIDogdmFsdWUgJiYgIX4odmFsdWUgKyBcIlwiKS5pbmRleE9mKFwiZmFsc2VcIikpO1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoY29yZSkge1xuICBnc2FwID0gY29yZSB8fCBfZ2V0R1NBUCgpO1xuXG4gIGlmIChnc2FwKSB7XG4gICAgX3JlZ2lzdGVyRWFzZSA9IGdzYXAucmVnaXN0ZXJFYXNlOyAvL2FkZCB3ZWlnaHRlZCBlYXNlIGNhcGFiaWxpdGllcyB0byBzdGFuZGFyZCBlYXNlcyBzbyB1c2VycyBjYW4gZG8gXCJwb3dlcjIuaW5PdXQoMC44KVwiIGZvciBleGFtcGxlIHRvIHB1c2ggZXZlcnl0aGluZyB0b3dhcmQgdGhlIFwib3V0XCIsIG9yICgtMC44KSB0byBwdXNoIGl0IHRvd2FyZCB0aGUgXCJpblwiICgwIGlzIG5ldXRyYWwpXG5cbiAgICB2YXIgZWFzZXMgPSBnc2FwLnBhcnNlRWFzZSgpLFxuICAgICAgICBjcmVhdGVDb25maWcgPSBmdW5jdGlvbiBjcmVhdGVDb25maWcoZWFzZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyYXRpbykge1xuICAgICAgICB2YXIgeSA9IDAuNSArIHJhdGlvIC8gMjtcblxuICAgICAgICBlYXNlLmNvbmZpZyA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgcmV0dXJuIGVhc2UoMiAqICgxIC0gcCkgKiBwICogeSArIHAgKiBwKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgcDtcblxuICAgIGZvciAocCBpbiBlYXNlcykge1xuICAgICAgaWYgKCFlYXNlc1twXS5jb25maWcpIHtcbiAgICAgICAgY3JlYXRlQ29uZmlnKGVhc2VzW3BdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVnaXN0ZXJFYXNlKFwic2xvd1wiLCBTbG93TW8pO1xuXG4gICAgX3JlZ2lzdGVyRWFzZShcImV4cG9TY2FsZVwiLCBFeHBvU2NhbGVFYXNlKTtcblxuICAgIF9yZWdpc3RlckVhc2UoXCJyb3VnaFwiLCBSb3VnaEVhc2UpO1xuXG4gICAgZm9yIChwIGluIEVhc2VQYWNrKSB7XG4gICAgICBwICE9PSBcInZlcnNpb25cIiAmJiBnc2FwLmNvcmUuZ2xvYmFscyhwLCBFYXNlUGFja1twXSk7XG4gICAgfVxuXG4gICAgX2NvcmVJbml0dGVkID0gMTtcbiAgfVxufSxcbiAgICBfY3JlYXRlU2xvd01vID0gZnVuY3Rpb24gX2NyZWF0ZVNsb3dNbyhsaW5lYXJSYXRpbywgcG93ZXIsIHlveW9Nb2RlKSB7XG4gIGxpbmVhclJhdGlvID0gTWF0aC5taW4oMSwgbGluZWFyUmF0aW8gfHwgMC43KTtcblxuICB2YXIgcG93ID0gbGluZWFyUmF0aW8gPCAxID8gcG93ZXIgfHwgcG93ZXIgPT09IDAgPyBwb3dlciA6IDAuNyA6IDAsXG4gICAgICBwMSA9ICgxIC0gbGluZWFyUmF0aW8pIC8gMixcbiAgICAgIHAzID0gcDEgKyBsaW5lYXJSYXRpbyxcbiAgICAgIGNhbGNFbmQgPSBfYm9vbGVhbih5b3lvTW9kZSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgdmFyIHIgPSBwICsgKDAuNSAtIHApICogcG93O1xuICAgIHJldHVybiBwIDwgcDEgPyBjYWxjRW5kID8gMSAtIChwID0gMSAtIHAgLyBwMSkgKiBwIDogciAtIChwID0gMSAtIHAgLyBwMSkgKiBwICogcCAqIHAgKiByIDogcCA+IHAzID8gY2FsY0VuZCA/IHAgPT09IDEgPyAwIDogMSAtIChwID0gKHAgLSBwMykgLyBwMSkgKiBwIDogciArIChwIC0gcikgKiAocCA9IChwIC0gcDMpIC8gcDEpICogcCAqIHAgKiBwIDogY2FsY0VuZCA/IDEgOiByO1xuICB9O1xufSxcbiAgICBfY3JlYXRlRXhwb1NjYWxlID0gZnVuY3Rpb24gX2NyZWF0ZUV4cG9TY2FsZShzdGFydCwgZW5kLCBlYXNlKSB7XG4gIHZhciBwMSA9IE1hdGgubG9nKGVuZCAvIHN0YXJ0KSxcbiAgICAgIHAyID0gZW5kIC0gc3RhcnQ7XG4gIGVhc2UgJiYgKGVhc2UgPSBnc2FwLnBhcnNlRWFzZShlYXNlKSk7XG4gIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAoc3RhcnQgKiBNYXRoLmV4cChwMSAqIChlYXNlID8gZWFzZShwKSA6IHApKSAtIHN0YXJ0KSAvIHAyO1xuICB9O1xufSxcbiAgICBFYXNlUG9pbnQgPSBmdW5jdGlvbiBFYXNlUG9pbnQodGltZSwgdmFsdWUsIG5leHQpIHtcbiAgdGhpcy50ID0gdGltZTtcbiAgdGhpcy52ID0gdmFsdWU7XG5cbiAgaWYgKG5leHQpIHtcbiAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIG5leHQucHJldiA9IHRoaXM7XG4gICAgdGhpcy5jID0gbmV4dC52IC0gdmFsdWU7XG4gICAgdGhpcy5nYXAgPSBuZXh0LnQgLSB0aW1lO1xuICB9XG59LFxuICAgIF9jcmVhdGVSb3VnaEVhc2UgPSBmdW5jdGlvbiBfY3JlYXRlUm91Z2hFYXNlKHZhcnMpIHtcbiAgaWYgKHR5cGVvZiB2YXJzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgLy91c2VycyBtYXkgcGFzcyBpbiB2aWEgYSBzdHJpbmcsIGxpa2UgXCJyb3VnaCgzMClcIlxuICAgIHZhcnMgPSB7XG4gICAgICBwb2ludHM6ICt2YXJzIHx8IDIwXG4gICAgfTtcbiAgfVxuXG4gIHZhciB0YXBlciA9IHZhcnMudGFwZXIgfHwgXCJub25lXCIsXG4gICAgICBhID0gW10sXG4gICAgICBjbnQgPSAwLFxuICAgICAgcG9pbnRzID0gKCt2YXJzLnBvaW50cyB8fCAyMCkgfCAwLFxuICAgICAgaSA9IHBvaW50cyxcbiAgICAgIHJhbmRvbWl6ZSA9IF9ib29sZWFuKHZhcnMucmFuZG9taXplLCB0cnVlKSxcbiAgICAgIGNsYW1wID0gX2Jvb2xlYW4odmFycy5jbGFtcCksXG4gICAgICB0ZW1wbGF0ZSA9IGdzYXAgPyBnc2FwLnBhcnNlRWFzZSh2YXJzLnRlbXBsYXRlKSA6IDAsXG4gICAgICBzdHJlbmd0aCA9ICgrdmFycy5zdHJlbmd0aCB8fCAxKSAqIDAuNCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgYnVtcCxcbiAgICAgIGludlgsXG4gICAgICBvYmosXG4gICAgICBwbnQsXG4gICAgICByZWNlbnQ7XG5cbiAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgeCA9IHJhbmRvbWl6ZSA/IE1hdGgucmFuZG9tKCkgOiAxIC8gcG9pbnRzICogaTtcbiAgICB5ID0gdGVtcGxhdGUgPyB0ZW1wbGF0ZSh4KSA6IHg7XG5cbiAgICBpZiAodGFwZXIgPT09IFwibm9uZVwiKSB7XG4gICAgICBidW1wID0gc3RyZW5ndGg7XG4gICAgfSBlbHNlIGlmICh0YXBlciA9PT0gXCJvdXRcIikge1xuICAgICAgaW52WCA9IDEgLSB4O1xuICAgICAgYnVtcCA9IGludlggKiBpbnZYICogc3RyZW5ndGg7XG4gICAgfSBlbHNlIGlmICh0YXBlciA9PT0gXCJpblwiKSB7XG4gICAgICBidW1wID0geCAqIHggKiBzdHJlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHggPCAwLjUpIHtcbiAgICAgIC8vXCJib3RoXCIgKHN0YXJ0KVxuICAgICAgaW52WCA9IHggKiAyO1xuICAgICAgYnVtcCA9IGludlggKiBpbnZYICogMC41ICogc3RyZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXCJib3RoXCIgKGVuZClcbiAgICAgIGludlggPSAoMSAtIHgpICogMjtcbiAgICAgIGJ1bXAgPSBpbnZYICogaW52WCAqIDAuNSAqIHN0cmVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChyYW5kb21pemUpIHtcbiAgICAgIHkgKz0gTWF0aC5yYW5kb20oKSAqIGJ1bXAgLSBidW1wICogMC41O1xuICAgIH0gZWxzZSBpZiAoaSAlIDIpIHtcbiAgICAgIHkgKz0gYnVtcCAqIDAuNTtcbiAgICB9IGVsc2Uge1xuICAgICAgeSAtPSBidW1wICogMC41O1xuICAgIH1cblxuICAgIGlmIChjbGFtcCkge1xuICAgICAgaWYgKHkgPiAxKSB7XG4gICAgICAgIHkgPSAxO1xuICAgICAgfSBlbHNlIGlmICh5IDwgMCkge1xuICAgICAgICB5ID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhW2NudCsrXSA9IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcbiAgfVxuXG4gIGEuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLnggLSBiLng7XG4gIH0pO1xuICBwbnQgPSBuZXcgRWFzZVBvaW50KDEsIDEsIG51bGwpO1xuICBpID0gcG9pbnRzO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBvYmogPSBhW2ldO1xuICAgIHBudCA9IG5ldyBFYXNlUG9pbnQob2JqLngsIG9iai55LCBwbnQpO1xuICB9XG5cbiAgcmVjZW50ID0gbmV3IEVhc2VQb2ludCgwLCAwLCBwbnQudCA/IHBudCA6IHBudC5uZXh0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgdmFyIHBudCA9IHJlY2VudDtcblxuICAgIGlmIChwID4gcG50LnQpIHtcbiAgICAgIHdoaWxlIChwbnQubmV4dCAmJiBwID49IHBudC50KSB7XG4gICAgICAgIHBudCA9IHBudC5uZXh0O1xuICAgICAgfVxuXG4gICAgICBwbnQgPSBwbnQucHJldjtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKHBudC5wcmV2ICYmIHAgPD0gcG50LnQpIHtcbiAgICAgICAgcG50ID0gcG50LnByZXY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVjZW50ID0gcG50O1xuICAgIHJldHVybiBwbnQudiArIChwIC0gcG50LnQpIC8gcG50LmdhcCAqIHBudC5jO1xuICB9O1xufTtcblxuZXhwb3J0IHZhciBTbG93TW8gPSBfY3JlYXRlU2xvd01vKDAuNyk7XG5TbG93TW8uZWFzZSA9IFNsb3dNbzsgLy9mb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXG5TbG93TW8uY29uZmlnID0gX2NyZWF0ZVNsb3dNbztcbmV4cG9ydCB2YXIgRXhwb1NjYWxlRWFzZSA9IF9jcmVhdGVFeHBvU2NhbGUoMSwgMik7XG5FeHBvU2NhbGVFYXNlLmNvbmZpZyA9IF9jcmVhdGVFeHBvU2NhbGU7XG5leHBvcnQgdmFyIFJvdWdoRWFzZSA9IF9jcmVhdGVSb3VnaEVhc2UoKTtcblJvdWdoRWFzZS5lYXNlID0gUm91Z2hFYXNlOyAvL2ZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cblJvdWdoRWFzZS5jb25maWcgPSBfY3JlYXRlUm91Z2hFYXNlO1xuZXhwb3J0IHZhciBFYXNlUGFjayA9IHtcbiAgU2xvd01vOiBTbG93TW8sXG4gIFJvdWdoRWFzZTogUm91Z2hFYXNlLFxuICBFeHBvU2NhbGVFYXNlOiBFeHBvU2NhbGVFYXNlXG59O1xuXG5mb3IgKHZhciBwIGluIEVhc2VQYWNrKSB7XG4gIEVhc2VQYWNrW3BdLnJlZ2lzdGVyID0gX2luaXRDb3JlO1xuICBFYXNlUGFja1twXS52ZXJzaW9uID0gXCIzLjEyLjVcIjtcbn1cblxuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKFNsb3dNbyk7XG5leHBvcnQgeyBFYXNlUGFjayBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbImdzYXAiLCJfY29yZUluaXR0ZWQiLCJfcmVnaXN0ZXJFYXNlIiwiX2dldEdTQVAiLCJ3aW5kb3ciLCJyZWdpc3RlclBsdWdpbiIsIl9ib29sZWFuIiwidmFsdWUiLCJkZWZhdWx0VmFsdWUiLCJpbmRleE9mIiwiX2luaXRDb3JlIiwiY29yZSIsInJlZ2lzdGVyRWFzZSIsImVhc2VzIiwicGFyc2VFYXNlIiwiY3JlYXRlQ29uZmlnIiwiZWFzZSIsInJhdGlvIiwieSIsImNvbmZpZyIsInAiLCJTbG93TW8iLCJFeHBvU2NhbGVFYXNlIiwiUm91Z2hFYXNlIiwiRWFzZVBhY2siLCJnbG9iYWxzIiwiX2NyZWF0ZVNsb3dNbyIsImxpbmVhclJhdGlvIiwicG93ZXIiLCJ5b3lvTW9kZSIsIk1hdGgiLCJtaW4iLCJwb3ciLCJwMSIsInAzIiwiY2FsY0VuZCIsInIiLCJfY3JlYXRlRXhwb1NjYWxlIiwic3RhcnQiLCJlbmQiLCJsb2ciLCJwMiIsImV4cCIsIkVhc2VQb2ludCIsInRpbWUiLCJuZXh0IiwidCIsInYiLCJwcmV2IiwiYyIsImdhcCIsIl9jcmVhdGVSb3VnaEVhc2UiLCJ2YXJzIiwicG9pbnRzIiwidGFwZXIiLCJhIiwiY250IiwiaSIsInJhbmRvbWl6ZSIsImNsYW1wIiwidGVtcGxhdGUiLCJzdHJlbmd0aCIsIngiLCJidW1wIiwiaW52WCIsIm9iaiIsInBudCIsInJlY2VudCIsInJhbmRvbSIsInNvcnQiLCJiIiwicmVnaXN0ZXIiLCJ2ZXJzaW9uIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/EasePack.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/EaselPlugin.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/EaselPlugin.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EaselPlugin: function() { return /* binding */ EaselPlugin; },\n/* harmony export */   \"default\": function() { return /* binding */ EaselPlugin; }\n/* harmony export */ });\n/*!\n * EaselPlugin 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var gsap, _coreInitted, _win, _createJS, _ColorFilter, _ColorMatrixFilter, _colorProps = \"redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier,redOffset,greenOffset,blueOffset,alphaOffset\".split(\",\"), _windowExists = function _windowExists() {\n    return typeof window !== \"undefined\";\n}, _getGSAP = function _getGSAP() {\n    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _getCreateJS = function _getCreateJS() {\n    return _createJS || _win && _win.createjs || _win || {};\n}, _warn = function _warn(message) {\n    return console.warn(message);\n}, _cache = function _cache(target) {\n    var b = target.getBounds && target.getBounds();\n    if (!b) {\n        b = target.nominalBounds || {\n            x: 0,\n            y: 0,\n            width: 100,\n            height: 100\n        };\n        target.setBounds && target.setBounds(b.x, b.y, b.width, b.height);\n    }\n    target.cache && target.cache(b.x, b.y, b.width, b.height);\n    _warn(\"EaselPlugin: for filters to display in EaselJS, you must call the object's cache() method first. GSAP attempted to use the target's getBounds() for the cache but that may not be completely accurate. \" + target);\n}, _parseColorFilter = function _parseColorFilter(target, v, plugin) {\n    if (!_ColorFilter) {\n        _ColorFilter = _getCreateJS().ColorFilter;\n        if (!_ColorFilter) {\n            _warn(\"EaselPlugin error: The EaselJS ColorFilter JavaScript file wasn't loaded.\");\n        }\n    }\n    var filters = target.filters || [], i = filters.length, c, s, e, a, p, pt;\n    while(i--){\n        if (filters[i] instanceof _ColorFilter) {\n            s = filters[i];\n            break;\n        }\n    }\n    if (!s) {\n        s = new _ColorFilter();\n        filters.push(s);\n        target.filters = filters;\n    }\n    e = s.clone();\n    if (v.tint != null) {\n        c = gsap.utils.splitColor(v.tint);\n        a = v.tintAmount != null ? +v.tintAmount : 1;\n        e.redOffset = +c[0] * a;\n        e.greenOffset = +c[1] * a;\n        e.blueOffset = +c[2] * a;\n        e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1 - a;\n    } else {\n        for(p in v){\n            if (p !== \"exposure\") {\n                if (p !== \"brightness\") {\n                    e[p] = +v[p];\n                }\n            }\n        }\n    }\n    if (v.exposure != null) {\n        e.redOffset = e.greenOffset = e.blueOffset = 255 * (+v.exposure - 1);\n        e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1;\n    } else if (v.brightness != null) {\n        a = +v.brightness - 1;\n        e.redOffset = e.greenOffset = e.blueOffset = a > 0 ? a * 255 : 0;\n        e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1 - Math.abs(a);\n    }\n    i = 8;\n    while(i--){\n        p = _colorProps[i];\n        if (s[p] !== e[p]) {\n            pt = plugin.add(s, p, s[p], e[p], 0, 0, 0, 0, 0, 1);\n            if (pt) {\n                pt.op = \"easel_colorFilter\";\n            }\n        }\n    }\n    plugin._props.push(\"easel_colorFilter\");\n    if (!target.cacheID) {\n        _cache(target);\n    }\n}, _idMatrix = [\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0\n], _lumR = 0.212671, _lumG = 0.715160, _lumB = 0.072169, _applyMatrix = function _applyMatrix(m, m2) {\n    if (!(m instanceof Array) || !(m2 instanceof Array)) {\n        return m2;\n    }\n    var temp = [], i = 0, z = 0, y, x;\n    for(y = 0; y < 4; y++){\n        for(x = 0; x < 5; x++){\n            z = x === 4 ? m[i + 4] : 0;\n            temp[i + x] = m[i] * m2[x] + m[i + 1] * m2[x + 5] + m[i + 2] * m2[x + 10] + m[i + 3] * m2[x + 15] + z;\n        }\n        i += 5;\n    }\n    return temp;\n}, _setSaturation = function _setSaturation(m, n) {\n    if (isNaN(n)) {\n        return m;\n    }\n    var inv = 1 - n, r = inv * _lumR, g = inv * _lumG, b = inv * _lumB;\n    return _applyMatrix([\n        r + n,\n        g,\n        b,\n        0,\n        0,\n        r,\n        g + n,\n        b,\n        0,\n        0,\n        r,\n        g,\n        b + n,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n    ], m);\n}, _colorize = function _colorize(m, color, amount) {\n    if (isNaN(amount)) {\n        amount = 1;\n    }\n    var c = gsap.utils.splitColor(color), r = c[0] / 255, g = c[1] / 255, b = c[2] / 255, inv = 1 - amount;\n    return _applyMatrix([\n        inv + amount * r * _lumR,\n        amount * r * _lumG,\n        amount * r * _lumB,\n        0,\n        0,\n        amount * g * _lumR,\n        inv + amount * g * _lumG,\n        amount * g * _lumB,\n        0,\n        0,\n        amount * b * _lumR,\n        amount * b * _lumG,\n        inv + amount * b * _lumB,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n    ], m);\n}, _setHue = function _setHue(m, n) {\n    if (isNaN(n)) {\n        return m;\n    }\n    n *= Math.PI / 180;\n    var c = Math.cos(n), s = Math.sin(n);\n    return _applyMatrix([\n        _lumR + c * (1 - _lumR) + s * -_lumR,\n        _lumG + c * -_lumG + s * -_lumG,\n        _lumB + c * -_lumB + s * (1 - _lumB),\n        0,\n        0,\n        _lumR + c * -_lumR + s * 0.143,\n        _lumG + c * (1 - _lumG) + s * 0.14,\n        _lumB + c * -_lumB + s * -0.283,\n        0,\n        0,\n        _lumR + c * -_lumR + s * -(1 - _lumR),\n        _lumG + c * -_lumG + s * _lumG,\n        _lumB + c * (1 - _lumB) + s * _lumB,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1\n    ], m);\n}, _setContrast = function _setContrast(m, n) {\n    if (isNaN(n)) {\n        return m;\n    }\n    n += 0.01;\n    return _applyMatrix([\n        n,\n        0,\n        0,\n        0,\n        128 * (1 - n),\n        0,\n        n,\n        0,\n        0,\n        128 * (1 - n),\n        0,\n        0,\n        n,\n        0,\n        128 * (1 - n),\n        0,\n        0,\n        0,\n        1,\n        0\n    ], m);\n}, _parseColorMatrixFilter = function _parseColorMatrixFilter(target, v, plugin) {\n    if (!_ColorMatrixFilter) {\n        _ColorMatrixFilter = _getCreateJS().ColorMatrixFilter;\n        if (!_ColorMatrixFilter) {\n            _warn(\"EaselPlugin: The EaselJS ColorMatrixFilter JavaScript file wasn't loaded.\");\n        }\n    }\n    var filters = target.filters || [], i = filters.length, matrix, startMatrix, s, pg;\n    while(--i > -1){\n        if (filters[i] instanceof _ColorMatrixFilter) {\n            s = filters[i];\n            break;\n        }\n    }\n    if (!s) {\n        s = new _ColorMatrixFilter(_idMatrix.slice());\n        filters.push(s);\n        target.filters = filters;\n    }\n    startMatrix = s.matrix;\n    matrix = _idMatrix.slice();\n    if (v.colorize != null) {\n        matrix = _colorize(matrix, v.colorize, Number(v.colorizeAmount));\n    }\n    if (v.contrast != null) {\n        matrix = _setContrast(matrix, Number(v.contrast));\n    }\n    if (v.hue != null) {\n        matrix = _setHue(matrix, Number(v.hue));\n    }\n    if (v.saturation != null) {\n        matrix = _setSaturation(matrix, Number(v.saturation));\n    }\n    i = matrix.length;\n    while(--i > -1){\n        if (matrix[i] !== startMatrix[i]) {\n            pg = plugin.add(startMatrix, i, startMatrix[i], matrix[i], 0, 0, 0, 0, 0, 1);\n            if (pg) {\n                pg.op = \"easel_colorMatrixFilter\";\n            }\n        }\n    }\n    plugin._props.push(\"easel_colorMatrixFilter\");\n    if (!target.cacheID) {\n        _cache();\n    }\n    plugin._matrix = startMatrix;\n}, _initCore = function _initCore(core) {\n    gsap = core || _getGSAP();\n    if (_windowExists()) {\n        _win = window;\n    }\n    if (gsap) {\n        _coreInitted = 1;\n    }\n};\nvar EaselPlugin = {\n    version: \"3.12.5\",\n    name: \"easel\",\n    init: function init(target, value, tween, index, targets) {\n        if (!_coreInitted) {\n            _initCore();\n            if (!gsap) {\n                _warn(\"Please gsap.registerPlugin(EaselPlugin)\");\n            }\n        }\n        this.target = target;\n        var p, pt, tint, colorMatrix, end, labels, i;\n        for(p in value){\n            end = value[p];\n            if (p === \"colorFilter\" || p === \"tint\" || p === \"tintAmount\" || p === \"exposure\" || p === \"brightness\") {\n                if (!tint) {\n                    _parseColorFilter(target, value.colorFilter || value, this);\n                    tint = true;\n                }\n            } else if (p === \"saturation\" || p === \"contrast\" || p === \"hue\" || p === \"colorize\" || p === \"colorizeAmount\") {\n                if (!colorMatrix) {\n                    _parseColorMatrixFilter(target, value.colorMatrixFilter || value, this);\n                    colorMatrix = true;\n                }\n            } else if (p === \"frame\") {\n                if (typeof end === \"string\" && end.charAt(1) !== \"=\" && (labels = target.labels)) {\n                    for(i = 0; i < labels.length; i++){\n                        if (labels[i].label === end) {\n                            end = labels[i].position;\n                        }\n                    }\n                }\n                pt = this.add(target, \"gotoAndStop\", target.currentFrame, end, index, targets, Math.round, 0, 0, 1);\n                if (pt) {\n                    pt.op = p;\n                }\n            } else if (target[p] != null) {\n                this.add(target, p, \"get\", end);\n            }\n        }\n    },\n    render: function render(ratio, data) {\n        var pt = data._pt;\n        while(pt){\n            pt.r(ratio, pt.d);\n            pt = pt._next;\n        }\n        if (data.target.cacheID) {\n            data.target.updateCache();\n        }\n    },\n    register: _initCore\n};\nEaselPlugin.registerCreateJS = function(createjs) {\n    _createJS = createjs;\n};\n_getGSAP() && gsap.registerPlugin(EaselPlugin);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9FYXNlbFBsdWdpbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCLEdBQ2xCLElBQUlBLE1BQ0FDLGNBQ0FDLE1BQ0FDLFdBQ0FDLGNBQ0FDLG9CQUNBQyxjQUFjLDRHQUE0R0MsS0FBSyxDQUFDLE1BQ2hJQyxnQkFBZ0IsU0FBU0E7SUFDM0IsT0FBTyxPQUFPQyxXQUFXO0FBQzNCLEdBQ0lDLFdBQVcsU0FBU0E7SUFDdEIsT0FBT1YsUUFBUVEsbUJBQW9CUixDQUFBQSxPQUFPUyxPQUFPVCxJQUFJLEtBQUtBLEtBQUtXLGNBQWMsSUFBSVg7QUFDbkYsR0FDSVksZUFBZSxTQUFTQTtJQUMxQixPQUFPVCxhQUFhRCxRQUFRQSxLQUFLVyxRQUFRLElBQUlYLFFBQVEsQ0FBQztBQUN4RCxHQUNJWSxRQUFRLFNBQVNBLE1BQU1DLE9BQU87SUFDaEMsT0FBT0MsUUFBUUMsSUFBSSxDQUFDRjtBQUN0QixHQUNJRyxTQUFTLFNBQVNBLE9BQU9DLE1BQU07SUFDakMsSUFBSUMsSUFBSUQsT0FBT0UsU0FBUyxJQUFJRixPQUFPRSxTQUFTO0lBRTVDLElBQUksQ0FBQ0QsR0FBRztRQUNOQSxJQUFJRCxPQUFPRyxhQUFhLElBQUk7WUFDMUJDLEdBQUc7WUFDSEMsR0FBRztZQUNIQyxPQUFPO1lBQ1BDLFFBQVE7UUFDVjtRQUNBUCxPQUFPUSxTQUFTLElBQUlSLE9BQU9RLFNBQVMsQ0FBQ1AsRUFBRUcsQ0FBQyxFQUFFSCxFQUFFSSxDQUFDLEVBQUVKLEVBQUVLLEtBQUssRUFBRUwsRUFBRU0sTUFBTTtJQUNsRTtJQUVBUCxPQUFPUyxLQUFLLElBQUlULE9BQU9TLEtBQUssQ0FBQ1IsRUFBRUcsQ0FBQyxFQUFFSCxFQUFFSSxDQUFDLEVBQUVKLEVBQUVLLEtBQUssRUFBRUwsRUFBRU0sTUFBTTtJQUV4RFosTUFB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QyxPQUFPLEVBQUU7WUFDdkI0RCxLQUFLdEcsTUFBTSxDQUFDMEcsV0FBVztRQUN6QjtJQUNGO0lBQ0FDLFVBQVUzQjtBQUNaLEVBQUU7QUFFRkUsWUFBWTBCLGdCQUFnQixHQUFHLFNBQVVsSCxRQUFRO0lBQy9DVixZQUFZVTtBQUNkO0FBRUFILGNBQWNWLEtBQUtXLGNBQWMsQ0FBQzBGO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dzYXBAMy4xMi41L25vZGVfbW9kdWxlcy9nc2FwL0Vhc2VsUGx1Z2luLmpzP2U5YjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBFYXNlbFBsdWdpbiAzLjEyLjVcbiAqIGh0dHBzOi8vZ3NhcC5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDI0LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dzYXAuY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdTQVAgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgZ3NhcCxcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX3dpbixcbiAgICBfY3JlYXRlSlMsXG4gICAgX0NvbG9yRmlsdGVyLFxuICAgIF9Db2xvck1hdHJpeEZpbHRlcixcbiAgICBfY29sb3JQcm9wcyA9IFwicmVkTXVsdGlwbGllcixncmVlbk11bHRpcGxpZXIsYmx1ZU11bHRpcGxpZXIsYWxwaGFNdWx0aXBsaWVyLHJlZE9mZnNldCxncmVlbk9mZnNldCxibHVlT2Zmc2V0LGFscGhhT2Zmc2V0XCIuc3BsaXQoXCIsXCIpLFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgX3dpbmRvd0V4aXN0cygpICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX2dldENyZWF0ZUpTID0gZnVuY3Rpb24gX2dldENyZWF0ZUpTKCkge1xuICByZXR1cm4gX2NyZWF0ZUpTIHx8IF93aW4gJiYgX3dpbi5jcmVhdGVqcyB8fCBfd2luIHx8IHt9O1xufSxcbiAgICBfd2FybiA9IGZ1bmN0aW9uIF93YXJuKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbn0sXG4gICAgX2NhY2hlID0gZnVuY3Rpb24gX2NhY2hlKHRhcmdldCkge1xuICB2YXIgYiA9IHRhcmdldC5nZXRCb3VuZHMgJiYgdGFyZ2V0LmdldEJvdW5kcygpO1xuXG4gIGlmICghYikge1xuICAgIGIgPSB0YXJnZXQubm9taW5hbEJvdW5kcyB8fCB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiAxMDAsXG4gICAgICBoZWlnaHQ6IDEwMFxuICAgIH07XG4gICAgdGFyZ2V0LnNldEJvdW5kcyAmJiB0YXJnZXQuc2V0Qm91bmRzKGIueCwgYi55LCBiLndpZHRoLCBiLmhlaWdodCk7XG4gIH1cblxuICB0YXJnZXQuY2FjaGUgJiYgdGFyZ2V0LmNhY2hlKGIueCwgYi55LCBiLndpZHRoLCBiLmhlaWdodCk7XG5cbiAgX3dhcm4oXCJFYXNlbFBsdWdpbjogZm9yIGZpbHRlcnMgdG8gZGlzcGxheSBpbiBFYXNlbEpTLCB5b3UgbXVzdCBjYWxsIHRoZSBvYmplY3QncyBjYWNoZSgpIG1ldGhvZCBmaXJzdC4gR1NBUCBhdHRlbXB0ZWQgdG8gdXNlIHRoZSB0YXJnZXQncyBnZXRCb3VuZHMoKSBmb3IgdGhlIGNhY2hlIGJ1dCB0aGF0IG1heSBub3QgYmUgY29tcGxldGVseSBhY2N1cmF0ZS4gXCIgKyB0YXJnZXQpO1xufSxcbiAgICBfcGFyc2VDb2xvckZpbHRlciA9IGZ1bmN0aW9uIF9wYXJzZUNvbG9yRmlsdGVyKHRhcmdldCwgdiwgcGx1Z2luKSB7XG4gIGlmICghX0NvbG9yRmlsdGVyKSB7XG4gICAgX0NvbG9yRmlsdGVyID0gX2dldENyZWF0ZUpTKCkuQ29sb3JGaWx0ZXI7XG5cbiAgICBpZiAoIV9Db2xvckZpbHRlcikge1xuICAgICAgX3dhcm4oXCJFYXNlbFBsdWdpbiBlcnJvcjogVGhlIEVhc2VsSlMgQ29sb3JGaWx0ZXIgSmF2YVNjcmlwdCBmaWxlIHdhc24ndCBsb2FkZWQuXCIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWx0ZXJzID0gdGFyZ2V0LmZpbHRlcnMgfHwgW10sXG4gICAgICBpID0gZmlsdGVycy5sZW5ndGgsXG4gICAgICBjLFxuICAgICAgcyxcbiAgICAgIGUsXG4gICAgICBhLFxuICAgICAgcCxcbiAgICAgIHB0O1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoZmlsdGVyc1tpXSBpbnN0YW5jZW9mIF9Db2xvckZpbHRlcikge1xuICAgICAgcyA9IGZpbHRlcnNbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoIXMpIHtcbiAgICBzID0gbmV3IF9Db2xvckZpbHRlcigpO1xuICAgIGZpbHRlcnMucHVzaChzKTtcbiAgICB0YXJnZXQuZmlsdGVycyA9IGZpbHRlcnM7XG4gIH1cblxuICBlID0gcy5jbG9uZSgpO1xuXG4gIGlmICh2LnRpbnQgIT0gbnVsbCkge1xuICAgIGMgPSBnc2FwLnV0aWxzLnNwbGl0Q29sb3Iodi50aW50KTtcbiAgICBhID0gdi50aW50QW1vdW50ICE9IG51bGwgPyArdi50aW50QW1vdW50IDogMTtcbiAgICBlLnJlZE9mZnNldCA9ICtjWzBdICogYTtcbiAgICBlLmdyZWVuT2Zmc2V0ID0gK2NbMV0gKiBhO1xuICAgIGUuYmx1ZU9mZnNldCA9ICtjWzJdICogYTtcbiAgICBlLnJlZE11bHRpcGxpZXIgPSBlLmdyZWVuTXVsdGlwbGllciA9IGUuYmx1ZU11bHRpcGxpZXIgPSAxIC0gYTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHAgaW4gdikge1xuICAgICAgaWYgKHAgIT09IFwiZXhwb3N1cmVcIikgaWYgKHAgIT09IFwiYnJpZ2h0bmVzc1wiKSB7XG4gICAgICAgIGVbcF0gPSArdltwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodi5leHBvc3VyZSAhPSBudWxsKSB7XG4gICAgZS5yZWRPZmZzZXQgPSBlLmdyZWVuT2Zmc2V0ID0gZS5ibHVlT2Zmc2V0ID0gMjU1ICogKCt2LmV4cG9zdXJlIC0gMSk7XG4gICAgZS5yZWRNdWx0aXBsaWVyID0gZS5ncmVlbk11bHRpcGxpZXIgPSBlLmJsdWVNdWx0aXBsaWVyID0gMTtcbiAgfSBlbHNlIGlmICh2LmJyaWdodG5lc3MgIT0gbnVsbCkge1xuICAgIGEgPSArdi5icmlnaHRuZXNzIC0gMTtcbiAgICBlLnJlZE9mZnNldCA9IGUuZ3JlZW5PZmZzZXQgPSBlLmJsdWVPZmZzZXQgPSBhID4gMCA/IGEgKiAyNTUgOiAwO1xuICAgIGUucmVkTXVsdGlwbGllciA9IGUuZ3JlZW5NdWx0aXBsaWVyID0gZS5ibHVlTXVsdGlwbGllciA9IDEgLSBNYXRoLmFicyhhKTtcbiAgfVxuXG4gIGkgPSA4O1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBwID0gX2NvbG9yUHJvcHNbaV07XG5cbiAgICBpZiAoc1twXSAhPT0gZVtwXSkge1xuICAgICAgcHQgPSBwbHVnaW4uYWRkKHMsIHAsIHNbcF0sIGVbcF0sIDAsIDAsIDAsIDAsIDAsIDEpO1xuXG4gICAgICBpZiAocHQpIHtcbiAgICAgICAgcHQub3AgPSBcImVhc2VsX2NvbG9yRmlsdGVyXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcGx1Z2luLl9wcm9wcy5wdXNoKFwiZWFzZWxfY29sb3JGaWx0ZXJcIik7XG5cbiAgaWYgKCF0YXJnZXQuY2FjaGVJRCkge1xuICAgIF9jYWNoZSh0YXJnZXQpO1xuICB9XG59LFxuICAgIF9pZE1hdHJpeCA9IFsxLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxLCAwXSxcbiAgICBfbHVtUiA9IDAuMjEyNjcxLFxuICAgIF9sdW1HID0gMC43MTUxNjAsXG4gICAgX2x1bUIgPSAwLjA3MjE2OSxcbiAgICBfYXBwbHlNYXRyaXggPSBmdW5jdGlvbiBfYXBwbHlNYXRyaXgobSwgbTIpIHtcbiAgaWYgKCEobSBpbnN0YW5jZW9mIEFycmF5KSB8fCAhKG0yIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgcmV0dXJuIG0yO1xuICB9XG5cbiAgdmFyIHRlbXAgPSBbXSxcbiAgICAgIGkgPSAwLFxuICAgICAgeiA9IDAsXG4gICAgICB5LFxuICAgICAgeDtcblxuICBmb3IgKHkgPSAwOyB5IDwgNDsgeSsrKSB7XG4gICAgZm9yICh4ID0gMDsgeCA8IDU7IHgrKykge1xuICAgICAgeiA9IHggPT09IDQgPyBtW2kgKyA0XSA6IDA7XG4gICAgICB0ZW1wW2kgKyB4XSA9IG1baV0gKiBtMlt4XSArIG1baSArIDFdICogbTJbeCArIDVdICsgbVtpICsgMl0gKiBtMlt4ICsgMTBdICsgbVtpICsgM10gKiBtMlt4ICsgMTVdICsgejtcbiAgICB9XG5cbiAgICBpICs9IDU7XG4gIH1cblxuICByZXR1cm4gdGVtcDtcbn0sXG4gICAgX3NldFNhdHVyYXRpb24gPSBmdW5jdGlvbiBfc2V0U2F0dXJhdGlvbihtLCBuKSB7XG4gIGlmIChpc05hTihuKSkge1xuICAgIHJldHVybiBtO1xuICB9XG5cbiAgdmFyIGludiA9IDEgLSBuLFxuICAgICAgciA9IGludiAqIF9sdW1SLFxuICAgICAgZyA9IGludiAqIF9sdW1HLFxuICAgICAgYiA9IGludiAqIF9sdW1CO1xuICByZXR1cm4gX2FwcGx5TWF0cml4KFtyICsgbiwgZywgYiwgMCwgMCwgciwgZyArIG4sIGIsIDAsIDAsIHIsIGcsIGIgKyBuLCAwLCAwLCAwLCAwLCAwLCAxLCAwXSwgbSk7XG59LFxuICAgIF9jb2xvcml6ZSA9IGZ1bmN0aW9uIF9jb2xvcml6ZShtLCBjb2xvciwgYW1vdW50KSB7XG4gIGlmIChpc05hTihhbW91bnQpKSB7XG4gICAgYW1vdW50ID0gMTtcbiAgfVxuXG4gIHZhciBjID0gZ3NhcC51dGlscy5zcGxpdENvbG9yKGNvbG9yKSxcbiAgICAgIHIgPSBjWzBdIC8gMjU1LFxuICAgICAgZyA9IGNbMV0gLyAyNTUsXG4gICAgICBiID0gY1syXSAvIDI1NSxcbiAgICAgIGludiA9IDEgLSBhbW91bnQ7XG4gIHJldHVybiBfYXBwbHlNYXRyaXgoW2ludiArIGFtb3VudCAqIHIgKiBfbHVtUiwgYW1vdW50ICogciAqIF9sdW1HLCBhbW91bnQgKiByICogX2x1bUIsIDAsIDAsIGFtb3VudCAqIGcgKiBfbHVtUiwgaW52ICsgYW1vdW50ICogZyAqIF9sdW1HLCBhbW91bnQgKiBnICogX2x1bUIsIDAsIDAsIGFtb3VudCAqIGIgKiBfbHVtUiwgYW1vdW50ICogYiAqIF9sdW1HLCBpbnYgKyBhbW91bnQgKiBiICogX2x1bUIsIDAsIDAsIDAsIDAsIDAsIDEsIDBdLCBtKTtcbn0sXG4gICAgX3NldEh1ZSA9IGZ1bmN0aW9uIF9zZXRIdWUobSwgbikge1xuICBpZiAoaXNOYU4obikpIHtcbiAgICByZXR1cm4gbTtcbiAgfVxuXG4gIG4gKj0gTWF0aC5QSSAvIDE4MDtcbiAgdmFyIGMgPSBNYXRoLmNvcyhuKSxcbiAgICAgIHMgPSBNYXRoLnNpbihuKTtcbiAgcmV0dXJuIF9hcHBseU1hdHJpeChbX2x1bVIgKyBjICogKDEgLSBfbHVtUikgKyBzICogLV9sdW1SLCBfbHVtRyArIGMgKiAtX2x1bUcgKyBzICogLV9sdW1HLCBfbHVtQiArIGMgKiAtX2x1bUIgKyBzICogKDEgLSBfbHVtQiksIDAsIDAsIF9sdW1SICsgYyAqIC1fbHVtUiArIHMgKiAwLjE0MywgX2x1bUcgKyBjICogKDEgLSBfbHVtRykgKyBzICogMC4xNCwgX2x1bUIgKyBjICogLV9sdW1CICsgcyAqIC0wLjI4MywgMCwgMCwgX2x1bVIgKyBjICogLV9sdW1SICsgcyAqIC0oMSAtIF9sdW1SKSwgX2x1bUcgKyBjICogLV9sdW1HICsgcyAqIF9sdW1HLCBfbHVtQiArIGMgKiAoMSAtIF9sdW1CKSArIHMgKiBfbHVtQiwgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMV0sIG0pO1xufSxcbiAgICBfc2V0Q29udHJhc3QgPSBmdW5jdGlvbiBfc2V0Q29udHJhc3QobSwgbikge1xuICBpZiAoaXNOYU4obikpIHtcbiAgICByZXR1cm4gbTtcbiAgfVxuXG4gIG4gKz0gMC4wMTtcbiAgcmV0dXJuIF9hcHBseU1hdHJpeChbbiwgMCwgMCwgMCwgMTI4ICogKDEgLSBuKSwgMCwgbiwgMCwgMCwgMTI4ICogKDEgLSBuKSwgMCwgMCwgbiwgMCwgMTI4ICogKDEgLSBuKSwgMCwgMCwgMCwgMSwgMF0sIG0pO1xufSxcbiAgICBfcGFyc2VDb2xvck1hdHJpeEZpbHRlciA9IGZ1bmN0aW9uIF9wYXJzZUNvbG9yTWF0cml4RmlsdGVyKHRhcmdldCwgdiwgcGx1Z2luKSB7XG4gIGlmICghX0NvbG9yTWF0cml4RmlsdGVyKSB7XG4gICAgX0NvbG9yTWF0cml4RmlsdGVyID0gX2dldENyZWF0ZUpTKCkuQ29sb3JNYXRyaXhGaWx0ZXI7XG5cbiAgICBpZiAoIV9Db2xvck1hdHJpeEZpbHRlcikge1xuICAgICAgX3dhcm4oXCJFYXNlbFBsdWdpbjogVGhlIEVhc2VsSlMgQ29sb3JNYXRyaXhGaWx0ZXIgSmF2YVNjcmlwdCBmaWxlIHdhc24ndCBsb2FkZWQuXCIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWx0ZXJzID0gdGFyZ2V0LmZpbHRlcnMgfHwgW10sXG4gICAgICBpID0gZmlsdGVycy5sZW5ndGgsXG4gICAgICBtYXRyaXgsXG4gICAgICBzdGFydE1hdHJpeCxcbiAgICAgIHMsXG4gICAgICBwZztcblxuICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICBpZiAoZmlsdGVyc1tpXSBpbnN0YW5jZW9mIF9Db2xvck1hdHJpeEZpbHRlcikge1xuICAgICAgcyA9IGZpbHRlcnNbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoIXMpIHtcbiAgICBzID0gbmV3IF9Db2xvck1hdHJpeEZpbHRlcihfaWRNYXRyaXguc2xpY2UoKSk7XG4gICAgZmlsdGVycy5wdXNoKHMpO1xuICAgIHRhcmdldC5maWx0ZXJzID0gZmlsdGVycztcbiAgfVxuXG4gIHN0YXJ0TWF0cml4ID0gcy5tYXRyaXg7XG4gIG1hdHJpeCA9IF9pZE1hdHJpeC5zbGljZSgpO1xuXG4gIGlmICh2LmNvbG9yaXplICE9IG51bGwpIHtcbiAgICBtYXRyaXggPSBfY29sb3JpemUobWF0cml4LCB2LmNvbG9yaXplLCBOdW1iZXIodi5jb2xvcml6ZUFtb3VudCkpO1xuICB9XG5cbiAgaWYgKHYuY29udHJhc3QgIT0gbnVsbCkge1xuICAgIG1hdHJpeCA9IF9zZXRDb250cmFzdChtYXRyaXgsIE51bWJlcih2LmNvbnRyYXN0KSk7XG4gIH1cblxuICBpZiAodi5odWUgIT0gbnVsbCkge1xuICAgIG1hdHJpeCA9IF9zZXRIdWUobWF0cml4LCBOdW1iZXIodi5odWUpKTtcbiAgfVxuXG4gIGlmICh2LnNhdHVyYXRpb24gIT0gbnVsbCkge1xuICAgIG1hdHJpeCA9IF9zZXRTYXR1cmF0aW9uKG1hdHJpeCwgTnVtYmVyKHYuc2F0dXJhdGlvbikpO1xuICB9XG5cbiAgaSA9IG1hdHJpeC5sZW5ndGg7XG5cbiAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgaWYgKG1hdHJpeFtpXSAhPT0gc3RhcnRNYXRyaXhbaV0pIHtcbiAgICAgIHBnID0gcGx1Z2luLmFkZChzdGFydE1hdHJpeCwgaSwgc3RhcnRNYXRyaXhbaV0sIG1hdHJpeFtpXSwgMCwgMCwgMCwgMCwgMCwgMSk7XG5cbiAgICAgIGlmIChwZykge1xuICAgICAgICBwZy5vcCA9IFwiZWFzZWxfY29sb3JNYXRyaXhGaWx0ZXJcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwbHVnaW4uX3Byb3BzLnB1c2goXCJlYXNlbF9jb2xvck1hdHJpeEZpbHRlclwiKTtcblxuICBpZiAoIXRhcmdldC5jYWNoZUlEKSB7XG4gICAgX2NhY2hlKCk7XG4gIH1cblxuICBwbHVnaW4uX21hdHJpeCA9IHN0YXJ0TWF0cml4O1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoY29yZSkge1xuICBnc2FwID0gY29yZSB8fCBfZ2V0R1NBUCgpO1xuXG4gIGlmIChfd2luZG93RXhpc3RzKCkpIHtcbiAgICBfd2luID0gd2luZG93O1xuICB9XG5cbiAgaWYgKGdzYXApIHtcbiAgICBfY29yZUluaXR0ZWQgPSAxO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIEVhc2VsUGx1Z2luID0ge1xuICB2ZXJzaW9uOiBcIjMuMTIuNVwiLFxuICBuYW1lOiBcImVhc2VsXCIsXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YWx1ZSwgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgaWYgKCFfY29yZUluaXR0ZWQpIHtcbiAgICAgIF9pbml0Q29yZSgpO1xuXG4gICAgICBpZiAoIWdzYXApIHtcbiAgICAgICAgX3dhcm4oXCJQbGVhc2UgZ3NhcC5yZWdpc3RlclBsdWdpbihFYXNlbFBsdWdpbilcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdmFyIHAsIHB0LCB0aW50LCBjb2xvck1hdHJpeCwgZW5kLCBsYWJlbHMsIGk7XG5cbiAgICBmb3IgKHAgaW4gdmFsdWUpIHtcbiAgICAgIGVuZCA9IHZhbHVlW3BdO1xuXG4gICAgICBpZiAocCA9PT0gXCJjb2xvckZpbHRlclwiIHx8IHAgPT09IFwidGludFwiIHx8IHAgPT09IFwidGludEFtb3VudFwiIHx8IHAgPT09IFwiZXhwb3N1cmVcIiB8fCBwID09PSBcImJyaWdodG5lc3NcIikge1xuICAgICAgICBpZiAoIXRpbnQpIHtcbiAgICAgICAgICBfcGFyc2VDb2xvckZpbHRlcih0YXJnZXQsIHZhbHVlLmNvbG9yRmlsdGVyIHx8IHZhbHVlLCB0aGlzKTtcblxuICAgICAgICAgIHRpbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHAgPT09IFwic2F0dXJhdGlvblwiIHx8IHAgPT09IFwiY29udHJhc3RcIiB8fCBwID09PSBcImh1ZVwiIHx8IHAgPT09IFwiY29sb3JpemVcIiB8fCBwID09PSBcImNvbG9yaXplQW1vdW50XCIpIHtcbiAgICAgICAgaWYgKCFjb2xvck1hdHJpeCkge1xuICAgICAgICAgIF9wYXJzZUNvbG9yTWF0cml4RmlsdGVyKHRhcmdldCwgdmFsdWUuY29sb3JNYXRyaXhGaWx0ZXIgfHwgdmFsdWUsIHRoaXMpO1xuXG4gICAgICAgICAgY29sb3JNYXRyaXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHAgPT09IFwiZnJhbWVcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gXCJzdHJpbmdcIiAmJiBlbmQuY2hhckF0KDEpICE9PSBcIj1cIiAmJiAobGFiZWxzID0gdGFyZ2V0LmxhYmVscykpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobGFiZWxzW2ldLmxhYmVsID09PSBlbmQpIHtcbiAgICAgICAgICAgICAgZW5kID0gbGFiZWxzW2ldLnBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHB0ID0gdGhpcy5hZGQodGFyZ2V0LCBcImdvdG9BbmRTdG9wXCIsIHRhcmdldC5jdXJyZW50RnJhbWUsIGVuZCwgaW5kZXgsIHRhcmdldHMsIE1hdGgucm91bmQsIDAsIDAsIDEpO1xuXG4gICAgICAgIGlmIChwdCkge1xuICAgICAgICAgIHB0Lm9wID0gcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXRbcF0gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmFkZCh0YXJnZXQsIHAsIFwiZ2V0XCIsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyYXRpbywgZGF0YSkge1xuICAgIHZhciBwdCA9IGRhdGEuX3B0O1xuXG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEudGFyZ2V0LmNhY2hlSUQpIHtcbiAgICAgIGRhdGEudGFyZ2V0LnVwZGF0ZUNhY2hlKCk7XG4gICAgfVxuICB9LFxuICByZWdpc3RlcjogX2luaXRDb3JlXG59O1xuXG5FYXNlbFBsdWdpbi5yZWdpc3RlckNyZWF0ZUpTID0gZnVuY3Rpb24gKGNyZWF0ZWpzKSB7XG4gIF9jcmVhdGVKUyA9IGNyZWF0ZWpzO1xufTtcblxuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKEVhc2VsUGx1Z2luKTtcbmV4cG9ydCB7IEVhc2VsUGx1Z2luIGFzIGRlZmF1bHQgfTsiXSwibmFtZXMiOlsiZ3NhcCIsIl9jb3JlSW5pdHRlZCIsIl93aW4iLCJfY3JlYXRlSlMiLCJfQ29sb3JGaWx0ZXIiLCJfQ29sb3JNYXRyaXhGaWx0ZXIiLCJfY29sb3JQcm9wcyIsInNwbGl0IiwiX3dpbmRvd0V4aXN0cyIsIndpbmRvdyIsIl9nZXRHU0FQIiwicmVnaXN0ZXJQbHVnaW4iLCJfZ2V0Q3JlYXRlSlMiLCJjcmVhdGVqcyIsIl93YXJuIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwiX2NhY2hlIiwidGFyZ2V0IiwiYiIsImdldEJvdW5kcyIsIm5vbWluYWxCb3VuZHMiLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0Iiwic2V0Qm91bmRzIiwiY2FjaGUiLCJfcGFyc2VDb2xvckZpbHRlciIsInYiLCJwbHVnaW4iLCJDb2xvckZpbHRlciIsImZpbHRlcnMiLCJpIiwibGVuZ3RoIiwiYyIsInMiLCJlIiwiYSIsInAiLCJwdCIsInB1c2giLCJjbG9uZSIsInRpbnQiLCJ1dGlscyIsInNwbGl0Q29sb3IiLCJ0aW50QW1vdW50IiwicmVkT2Zmc2V0IiwiZ3JlZW5PZmZzZXQiLCJibHVlT2Zmc2V0IiwicmVkTXVsdGlwbGllciIsImdyZWVuTXVsdGlwbGllciIsImJsdWVNdWx0aXBsaWVyIiwiZXhwb3N1cmUiLCJicmlnaHRuZXNzIiwiTWF0aCIsImFicyIsImFkZCIsIm9wIiwiX3Byb3BzIiwiY2FjaGVJRCIsIl9pZE1hdHJpeCIsIl9sdW1SIiwiX2x1bUciLCJfbHVtQiIsIl9hcHBseU1hdHJpeCIsIm0iLCJtMiIsIkFycmF5IiwidGVtcCIsInoiLCJfc2V0U2F0dXJhdGlvbiIsIm4iLCJpc05hTiIsImludiIsInIiLCJnIiwiX2NvbG9yaXplIiwiY29sb3IiLCJhbW91bnQiLCJfc2V0SHVlIiwiUEkiLCJjb3MiLCJzaW4iLCJfc2V0Q29udHJhc3QiLCJfcGFyc2VDb2xvck1hdHJpeEZpbHRlciIsIkNvbG9yTWF0cml4RmlsdGVyIiwibWF0cml4Iiwic3RhcnRNYXRyaXgiLCJwZyIsInNsaWNlIiwiY29sb3JpemUiLCJOdW1iZXIiLCJjb2xvcml6ZUFtb3VudCIsImNvbnRyYXN0IiwiaHVlIiwic2F0dXJhdGlvbiIsIl9tYXRyaXgiLCJfaW5pdENvcmUiLCJjb3JlIiwiRWFzZWxQbHVnaW4iLCJ2ZXJzaW9uIiwibmFtZSIsImluaXQiLCJ2YWx1ZSIsInR3ZWVuIiwiaW5kZXgiLCJ0YXJnZXRzIiwiY29sb3JNYXRyaXgiLCJlbmQiLCJsYWJlbHMiLCJjb2xvckZpbHRlciIsImNvbG9yTWF0cml4RmlsdGVyIiwiY2hhckF0IiwibGFiZWwiLCJwb3NpdGlvbiIsImN1cnJlbnRGcmFtZSIsInJvdW5kIiwicmVuZGVyIiwicmF0aW8iLCJkYXRhIiwiX3B0IiwiZCIsIl9uZXh0IiwidXBkYXRlQ2FjaGUiLCJyZWdpc3RlciIsInJlZ2lzdGVyQ3JlYXRlSlMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/EaselPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Flip.js":
/*!******************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Flip.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Flip: function() { return /* binding */ Flip; },\n/* harmony export */   \"default\": function() { return /* binding */ Flip; }\n/* harmony export */ });\n/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/matrix.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/matrix.js\");\n/*!\n * Flip 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ \nvar _id = 1, _toArray, gsap, _batch, _batchAction, _body, _closestTenth, _getStyleSaver, _forEachBatch = function _forEachBatch(batch, name) {\n    return batch.actions.forEach(function(a) {\n        return a.vars[name] && a.vars[name](a);\n    });\n}, _batchLookup = {}, _RAD2DEG = 180 / Math.PI, _DEG2RAD = Math.PI / 180, _emptyObj = {}, _dashedNameLookup = {}, _memoizedRemoveProps = {}, _listToArray = function _listToArray(list) {\n    return typeof list === \"string\" ? list.split(\" \").join(\"\").split(\",\") : list;\n}, // removes extra spaces contaminating the names, returns an Array.\n_callbacks = _listToArray(\"onStart,onUpdate,onComplete,onReverseComplete,onInterrupt\"), _removeProps = _listToArray(\"transform,transformOrigin,width,height,position,top,left,opacity,zIndex,maxWidth,maxHeight,minWidth,minHeight\"), _getEl = function _getEl(target) {\n    return _toArray(target)[0] || console.warn(\"Element not found:\", target);\n}, _round = function _round(value) {\n    return Math.round(value * 10000) / 10000 || 0;\n}, _toggleClass = function _toggleClass(targets, className, action) {\n    return targets.forEach(function(el) {\n        return el.classList[action](className);\n    });\n}, _reserved = {\n    zIndex: 1,\n    kill: 1,\n    simple: 1,\n    spin: 1,\n    clearProps: 1,\n    targets: 1,\n    toggleClass: 1,\n    onComplete: 1,\n    onUpdate: 1,\n    onInterrupt: 1,\n    onStart: 1,\n    delay: 1,\n    repeat: 1,\n    repeatDelay: 1,\n    yoyo: 1,\n    scale: 1,\n    fade: 1,\n    absolute: 1,\n    props: 1,\n    onEnter: 1,\n    onLeave: 1,\n    custom: 1,\n    paused: 1,\n    nested: 1,\n    prune: 1,\n    absoluteOnLeave: 1\n}, _fitReserved = {\n    zIndex: 1,\n    simple: 1,\n    clearProps: 1,\n    scale: 1,\n    absolute: 1,\n    fitChild: 1,\n    getVars: 1,\n    props: 1\n}, _camelToDashed = function _camelToDashed(p) {\n    return p.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n}, _copy = function _copy(obj, exclude) {\n    var result = {}, p;\n    for(p in obj){\n        exclude[p] || (result[p] = obj[p]);\n    }\n    return result;\n}, _memoizedProps = {}, _memoizeProps = function _memoizeProps(props) {\n    var p = _memoizedProps[props] = _listToArray(props);\n    _memoizedRemoveProps[props] = p.concat(_removeProps);\n    return p;\n}, _getInverseGlobalMatrix = function _getInverseGlobalMatrix(el) {\n    // integrates caching for improved performance\n    var cache = el._gsap || gsap.core.getCache(el);\n    if (cache.gmCache === gsap.ticker.frame) {\n        return cache.gMatrix;\n    }\n    cache.gmCache = gsap.ticker.frame;\n    return cache.gMatrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(el, true, false, true);\n}, _getDOMDepth = function _getDOMDepth(el, invert, level) {\n    if (level === void 0) {\n        level = 0;\n    }\n    // In invert is true, the sibling depth is increments of 1, and parent/nesting depth is increments of 1000. This lets us order elements in an Array to reflect document flow.\n    var parent = el.parentNode, inc = 1000 * Math.pow(10, level) * (invert ? -1 : 1), l = invert ? -inc * 900 : 0;\n    while(el){\n        l += inc;\n        el = el.previousSibling;\n    }\n    return parent ? l + _getDOMDepth(parent, invert, level + 1) : l;\n}, _orderByDOMDepth = function _orderByDOMDepth(comps, invert, isElStates) {\n    comps.forEach(function(comp) {\n        return comp.d = _getDOMDepth(isElStates ? comp.element : comp.t, invert);\n    });\n    comps.sort(function(c1, c2) {\n        return c1.d - c2.d;\n    });\n    return comps;\n}, _recordInlineStyles = function _recordInlineStyles(elState, props) {\n    // records the current inline CSS properties into an Array in alternating name/value pairs that's stored in a \"css\" property on the state object so that we can revert later.\n    var style = elState.element.style, a = elState.css = elState.css || [], i = props.length, p, v;\n    while(i--){\n        p = props[i];\n        v = style[p] || style.getPropertyValue(p);\n        a.push(v ? p : _dashedNameLookup[p] || (_dashedNameLookup[p] = _camelToDashed(p)), v);\n    }\n    return style;\n}, _applyInlineStyles = function _applyInlineStyles(state) {\n    var css = state.css, style = state.element.style, i = 0;\n    state.cache.uncache = 1;\n    for(; i < css.length; i += 2){\n        css[i + 1] ? style[css[i]] = css[i + 1] : style.removeProperty(css[i]);\n    }\n    if (!css[css.indexOf(\"transform\") + 1] && style.translate) {\n        // CSSPlugin adds scale, translate, and rotate inline CSS as \"none\" in order to keep CSS rules from contaminating transforms.\n        style.removeProperty(\"translate\");\n        style.removeProperty(\"scale\");\n        style.removeProperty(\"rotate\");\n    }\n}, _setFinalStates = function _setFinalStates(comps, onlyTransforms) {\n    comps.forEach(function(c) {\n        return c.a.cache.uncache = 1;\n    });\n    onlyTransforms || comps.finalStates.forEach(_applyInlineStyles);\n}, _absoluteProps = \"paddingTop,paddingRight,paddingBottom,paddingLeft,gridArea,transition\".split(\",\"), // properties that we must record just\n_makeAbsolute = function _makeAbsolute(elState, fallbackNode, ignoreBatch) {\n    var element = elState.element, width = elState.width, height = elState.height, uncache = elState.uncache, getProp = elState.getProp, style = element.style, i = 4, result, displayIsNone, cs;\n    typeof fallbackNode !== \"object\" && (fallbackNode = elState);\n    if (_batch && ignoreBatch !== 1) {\n        _batch._abs.push({\n            t: element,\n            b: elState,\n            a: elState,\n            sd: 0\n        });\n        _batch._final.push(function() {\n            return (elState.cache.uncache = 1) && _applyInlineStyles(elState);\n        });\n        return element;\n    }\n    displayIsNone = getProp(\"display\") === \"none\";\n    if (!elState.isVisible || displayIsNone) {\n        displayIsNone && (_recordInlineStyles(elState, [\n            \"display\"\n        ]).display = fallbackNode.display);\n        elState.matrix = fallbackNode.matrix;\n        elState.width = width = elState.width || fallbackNode.width;\n        elState.height = height = elState.height || fallbackNode.height;\n    }\n    _recordInlineStyles(elState, _absoluteProps);\n    cs = window.getComputedStyle(element);\n    while(i--){\n        style[_absoluteProps[i]] = cs[_absoluteProps[i]]; // record paddings as px-based because if removed from grid, percentage-based ones could be altered.\n    }\n    style.gridArea = \"1 / 1 / 1 / 1\";\n    style.transition = \"none\";\n    style.position = \"absolute\";\n    style.width = width + \"px\";\n    style.height = height + \"px\";\n    style.top || (style.top = \"0px\");\n    style.left || (style.left = \"0px\");\n    if (uncache) {\n        result = new ElementState(element);\n    } else {\n        // better performance\n        result = _copy(elState, _emptyObj);\n        result.position = \"absolute\";\n        if (elState.simple) {\n            var bounds = element.getBoundingClientRect();\n            result.matrix = new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D(1, 0, 0, 1, bounds.left + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollLeft)(), bounds.top + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollTop)());\n        } else {\n            result.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(element, false, false, true);\n        }\n    }\n    result = _fit(result, elState, true);\n    elState.x = _closestTenth(result.x, 0.01);\n    elState.y = _closestTenth(result.y, 0.01);\n    return element;\n}, _filterComps = function _filterComps(comps, targets) {\n    if (targets !== true) {\n        targets = _toArray(targets);\n        comps = comps.filter(function(c) {\n            if (targets.indexOf((c.sd < 0 ? c.b : c.a).element) !== -1) {\n                return true;\n            } else {\n                c.t._gsap.renderTransform(1); // we must force transforms to render on anything that isn't being made position: absolute, otherwise the absolute position happens and then when animation begins it applies transforms which can create a new stacking context, throwing off positioning!\n                if (c.b.isVisible) {\n                    c.t.style.width = c.b.width + \"px\"; // otherwise things can collapse when contents are made position: absolute.\n                    c.t.style.height = c.b.height + \"px\";\n                }\n            }\n        });\n    }\n    return comps;\n}, _makeCompsAbsolute = function _makeCompsAbsolute(comps) {\n    return _orderByDOMDepth(comps, true).forEach(function(c) {\n        return (c.a.isVisible || c.b.isVisible) && _makeAbsolute(c.sd < 0 ? c.b : c.a, c.b, 1);\n    });\n}, _findElStateInState = function _findElStateInState(state, other) {\n    return other && state.idLookup[_parseElementState(other).id] || state.elementStates[0];\n}, _parseElementState = function _parseElementState(elOrNode, props, simple, other) {\n    return elOrNode instanceof ElementState ? elOrNode : elOrNode instanceof FlipState ? _findElStateInState(elOrNode, other) : new ElementState(typeof elOrNode === \"string\" ? _getEl(elOrNode) || console.warn(elOrNode + \" not found\") : elOrNode, props, simple);\n}, _recordProps = function _recordProps(elState, props) {\n    var getProp = gsap.getProperty(elState.element, null, \"native\"), obj = elState.props = {}, i = props.length;\n    while(i--){\n        obj[props[i]] = (getProp(props[i]) + \"\").trim();\n    }\n    obj.zIndex && (obj.zIndex = parseFloat(obj.zIndex) || 0);\n    return elState;\n}, _applyProps = function _applyProps(element, props) {\n    var style = element.style || element, // could pass in a vars object.\n    p;\n    for(p in props){\n        style[p] = props[p];\n    }\n}, _getID = function _getID(el) {\n    var id = el.getAttribute(\"data-flip-id\");\n    id || el.setAttribute(\"data-flip-id\", id = \"auto-\" + _id++);\n    return id;\n}, _elementsFromElementStates = function _elementsFromElementStates(elStates) {\n    return elStates.map(function(elState) {\n        return elState.element;\n    });\n}, _handleCallback = function _handleCallback(callback, elStates, tl) {\n    return callback && elStates.length && tl.add(callback(_elementsFromElementStates(elStates), tl, new FlipState(elStates, 0, true)), 0);\n}, _fit = function _fit(fromState, toState, scale, applyProps, fitChild, vars) {\n    var element = fromState.element, cache = fromState.cache, parent = fromState.parent, x = fromState.x, y = fromState.y, width = toState.width, height = toState.height, scaleX = toState.scaleX, scaleY = toState.scaleY, rotation = toState.rotation, bounds = toState.bounds, styles = vars && _getStyleSaver && _getStyleSaver(element, \"transform\"), dimensionState = fromState, _toState$matrix = toState.matrix, e = _toState$matrix.e, f = _toState$matrix.f, deep = fromState.bounds.width !== bounds.width || fromState.bounds.height !== bounds.height || fromState.scaleX !== scaleX || fromState.scaleY !== scaleY || fromState.rotation !== rotation, simple = !deep && fromState.simple && toState.simple && !fitChild, skewX, fromPoint, toPoint, getProp, parentMatrix, matrix, bbox;\n    if (simple || !parent) {\n        scaleX = scaleY = 1;\n        rotation = skewX = 0;\n    } else {\n        parentMatrix = _getInverseGlobalMatrix(parent);\n        matrix = parentMatrix.clone().multiply(toState.ctm ? toState.matrix.clone().multiply(toState.ctm) : toState.matrix); // root SVG elements have a ctm that we must factor out (for example, viewBox:\"0 0 94 94\" with a width of 200px would scale the internals by 2.127 but when we're matching the size of the root <svg> element itself, that scaling shouldn't factor in!)\n        rotation = _round(Math.atan2(matrix.b, matrix.a) * _RAD2DEG);\n        skewX = _round(Math.atan2(matrix.c, matrix.d) * _RAD2DEG + rotation) % 360; // in very rare cases, minor rounding might end up with 360 which should be 0.\n        scaleX = Math.sqrt(Math.pow(matrix.a, 2) + Math.pow(matrix.b, 2));\n        scaleY = Math.sqrt(Math.pow(matrix.c, 2) + Math.pow(matrix.d, 2)) * Math.cos(skewX * _DEG2RAD);\n        if (fitChild) {\n            fitChild = _toArray(fitChild)[0];\n            getProp = gsap.getProperty(fitChild);\n            bbox = fitChild.getBBox && typeof fitChild.getBBox === \"function\" && fitChild.getBBox();\n            dimensionState = {\n                scaleX: getProp(\"scaleX\"),\n                scaleY: getProp(\"scaleY\"),\n                width: bbox ? bbox.width : Math.ceil(parseFloat(getProp(\"width\", \"px\"))),\n                height: bbox ? bbox.height : parseFloat(getProp(\"height\", \"px\"))\n            };\n        }\n        cache.rotation = rotation + \"deg\";\n        cache.skewX = skewX + \"deg\";\n    }\n    if (scale) {\n        scaleX *= width === dimensionState.width || !dimensionState.width ? 1 : width / dimensionState.width; // note if widths are both 0, we should make scaleX 1 - some elements have box-sizing that incorporates padding, etc. and we don't want it to collapse in that case.\n        scaleY *= height === dimensionState.height || !dimensionState.height ? 1 : height / dimensionState.height;\n        cache.scaleX = scaleX;\n        cache.scaleY = scaleY;\n    } else {\n        width = _closestTenth(width * scaleX / dimensionState.scaleX, 0);\n        height = _closestTenth(height * scaleY / dimensionState.scaleY, 0);\n        element.style.width = width + \"px\";\n        element.style.height = height + \"px\";\n    } // if (fromState.isFixed) { // commented out because it's now taken care of in getGlobalMatrix() with a flag at the end.\n    // \te -= _getDocScrollLeft();\n    // \tf -= _getDocScrollTop();\n    // }\n    applyProps && _applyProps(element, toState.props);\n    if (simple || !parent) {\n        x += e - fromState.matrix.e;\n        y += f - fromState.matrix.f;\n    } else if (deep || parent !== toState.parent) {\n        cache.renderTransform(1, cache);\n        matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fitChild || element, false, false, true);\n        fromPoint = parentMatrix.apply({\n            x: matrix.e,\n            y: matrix.f\n        });\n        toPoint = parentMatrix.apply({\n            x: e,\n            y: f\n        });\n        x += toPoint.x - fromPoint.x;\n        y += toPoint.y - fromPoint.y;\n    } else {\n        // use a faster/cheaper algorithm if we're just moving x/y\n        parentMatrix.e = parentMatrix.f = 0;\n        toPoint = parentMatrix.apply({\n            x: e - fromState.matrix.e,\n            y: f - fromState.matrix.f\n        });\n        x += toPoint.x;\n        y += toPoint.y;\n    }\n    x = _closestTenth(x, 0.02);\n    y = _closestTenth(y, 0.02);\n    if (vars && !(vars instanceof ElementState)) {\n        // revert\n        styles && styles.revert();\n    } else {\n        // or apply the transform immediately\n        cache.x = x + \"px\";\n        cache.y = y + \"px\";\n        cache.renderTransform(1, cache);\n    }\n    if (vars) {\n        vars.x = x;\n        vars.y = y;\n        vars.rotation = rotation;\n        vars.skewX = skewX;\n        if (scale) {\n            vars.scaleX = scaleX;\n            vars.scaleY = scaleY;\n        } else {\n            vars.width = width;\n            vars.height = height;\n        }\n    }\n    return vars || cache;\n}, _parseState = function _parseState(targetsOrState, vars) {\n    return targetsOrState instanceof FlipState ? targetsOrState : new FlipState(targetsOrState, vars);\n}, _getChangingElState = function _getChangingElState(toState, fromState, id) {\n    var to1 = toState.idLookup[id], to2 = toState.alt[id];\n    return to2.isVisible && (!(fromState.getElementState(to2.element) || to2).isVisible || !to1.isVisible) ? to2 : to1;\n}, _bodyMetrics = [], _bodyProps = \"width,height,overflowX,overflowY\".split(\",\"), _bodyLocked, _lockBodyScroll = function _lockBodyScroll(lock) {\n    // if there's no scrollbar, we should lock that so that measurements don't get affected by temporary repositioning, like if something is centered in the window.\n    if (lock !== _bodyLocked) {\n        var s = _body.style, w = _body.clientWidth === window.outerWidth, h = _body.clientHeight === window.outerHeight, i = 4;\n        if (lock && (w || h)) {\n            while(i--){\n                _bodyMetrics[i] = s[_bodyProps[i]];\n            }\n            if (w) {\n                s.width = _body.clientWidth + \"px\";\n                s.overflowY = \"hidden\";\n            }\n            if (h) {\n                s.height = _body.clientHeight + \"px\";\n                s.overflowX = \"hidden\";\n            }\n            _bodyLocked = lock;\n        } else if (_bodyLocked) {\n            while(i--){\n                _bodyMetrics[i] ? s[_bodyProps[i]] = _bodyMetrics[i] : s.removeProperty(_camelToDashed(_bodyProps[i]));\n            }\n            _bodyLocked = lock;\n        }\n    }\n}, _fromTo = function _fromTo(fromState, toState, vars, relative) {\n    // relative is -1 if \"from()\", and 1 if \"to()\"\n    fromState instanceof FlipState && toState instanceof FlipState || console.warn(\"Not a valid state object.\");\n    vars = vars || {};\n    var _vars = vars, clearProps = _vars.clearProps, onEnter = _vars.onEnter, onLeave = _vars.onLeave, absolute = _vars.absolute, absoluteOnLeave = _vars.absoluteOnLeave, custom = _vars.custom, delay = _vars.delay, paused = _vars.paused, repeat = _vars.repeat, repeatDelay = _vars.repeatDelay, yoyo = _vars.yoyo, toggleClass = _vars.toggleClass, nested = _vars.nested, _zIndex = _vars.zIndex, scale = _vars.scale, fade = _vars.fade, stagger = _vars.stagger, spin = _vars.spin, prune = _vars.prune, props = (\"props\" in vars ? vars : fromState).props, tweenVars = _copy(vars, _reserved), animation = gsap.timeline({\n        delay: delay,\n        paused: paused,\n        repeat: repeat,\n        repeatDelay: repeatDelay,\n        yoyo: yoyo,\n        data: \"isFlip\"\n    }), remainingProps = tweenVars, entering = [], leaving = [], comps = [], swapOutTargets = [], spinNum = spin === true ? 1 : spin || 0, spinFunc = typeof spin === \"function\" ? spin : function spinFunc() {\n        return spinNum;\n    }, interrupted = fromState.interrupted || toState.interrupted, addFunc = animation[relative !== 1 ? \"to\" : \"from\"], v, p, endTime, i, el, comp, state, targets, finalStates, fromNode, toNode, run, a, b; //relative || (toState = (new FlipState(toState.targets, {props: props})).fit(toState, scale));\n    for(p in toState.idLookup){\n        toNode = !toState.alt[p] ? toState.idLookup[p] : _getChangingElState(toState, fromState, p);\n        el = toNode.element;\n        fromNode = fromState.idLookup[p];\n        fromState.alt[p] && el === fromNode.element && (fromState.alt[p].isVisible || !toNode.isVisible) && (fromNode = fromState.alt[p]);\n        if (fromNode) {\n            comp = {\n                t: el,\n                b: fromNode,\n                a: toNode,\n                sd: fromNode.element === el ? 0 : toNode.isVisible ? 1 : -1\n            };\n            comps.push(comp);\n            if (comp.sd) {\n                if (comp.sd < 0) {\n                    comp.b = toNode;\n                    comp.a = fromNode;\n                } // for swapping elements that got interrupted, we must re-record the inline styles to ensure they're not tainted. Remember, .batch() permits getState() not to force in-progress flips to their end state.\n                interrupted && _recordInlineStyles(comp.b, props ? _memoizedRemoveProps[props] : _removeProps);\n                fade && comps.push(comp.swap = {\n                    t: fromNode.element,\n                    b: comp.b,\n                    a: comp.a,\n                    sd: -comp.sd,\n                    swap: comp\n                });\n            }\n            el._flip = fromNode.element._flip = _batch ? _batch.timeline : animation;\n        } else if (toNode.isVisible) {\n            comps.push({\n                t: el,\n                b: _copy(toNode, {\n                    isVisible: 1\n                }),\n                a: toNode,\n                sd: 0,\n                entering: 1\n            }); // to include it in the \"entering\" Array and do absolute positioning if necessary\n            el._flip = _batch ? _batch.timeline : animation;\n        }\n    }\n    props && (_memoizedProps[props] || _memoizeProps(props)).forEach(function(p) {\n        return tweenVars[p] = function(i) {\n            return comps[i].a.props[p];\n        };\n    });\n    comps.finalStates = finalStates = [];\n    run = function run() {\n        _orderByDOMDepth(comps);\n        _lockBodyScroll(true); // otherwise, measurements may get thrown off when things get fit.\n        // TODO: cache the matrix, especially for parent because it'll probably get reused quite a bit, but lock it to a particular cycle(?).\n        for(i = 0; i < comps.length; i++){\n            comp = comps[i];\n            a = comp.a;\n            b = comp.b;\n            if (prune && !a.isDifferent(b) && !comp.entering) {\n                // only flip if things changed! Don't omit it from comps initially because that'd prevent the element from being positioned absolutely (if necessary)\n                comps.splice(i--, 1);\n            } else {\n                el = comp.t;\n                nested && !(comp.sd < 0) && i && (a.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(el, false, false, true)); // moving a parent affects the position of children\n                if (b.isVisible && a.isVisible) {\n                    if (comp.sd < 0) {\n                        // swapping OUT (swap direction of -1 is out)\n                        state = new ElementState(el, props, fromState.simple);\n                        _fit(state, a, scale, 0, 0, state);\n                        state.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(el, false, false, true);\n                        state.css = comp.b.css;\n                        comp.a = a = state;\n                        fade && (el.style.opacity = interrupted ? b.opacity : a.opacity);\n                        stagger && swapOutTargets.push(el);\n                    } else if (comp.sd > 0 && fade) {\n                        // swapping IN (swap direction of 1 is in)\n                        el.style.opacity = interrupted ? a.opacity - b.opacity : \"0\";\n                    }\n                    _fit(a, b, scale, props);\n                } else if (b.isVisible !== a.isVisible) {\n                    // either entering or leaving (one side is invisible)\n                    if (!b.isVisible) {\n                        // entering\n                        a.isVisible && entering.push(a);\n                        comps.splice(i--, 1);\n                    } else if (!a.isVisible) {\n                        // leaving\n                        b.css = a.css;\n                        leaving.push(b);\n                        comps.splice(i--, 1);\n                        absolute && nested && _fit(a, b, scale, props);\n                    }\n                }\n                if (!scale) {\n                    el.style.maxWidth = Math.max(a.width, b.width) + \"px\";\n                    el.style.maxHeight = Math.max(a.height, b.height) + \"px\";\n                    el.style.minWidth = Math.min(a.width, b.width) + \"px\";\n                    el.style.minHeight = Math.min(a.height, b.height) + \"px\";\n                }\n                nested && toggleClass && el.classList.add(toggleClass);\n            }\n            finalStates.push(a);\n        }\n        var classTargets;\n        if (toggleClass) {\n            classTargets = finalStates.map(function(s) {\n                return s.element;\n            });\n            nested && classTargets.forEach(function(e) {\n                return e.classList.remove(toggleClass);\n            }); // there could be a delay, so don't leave the classes applied (we'll do it in a timeline callback)\n        }\n        _lockBodyScroll(false);\n        if (scale) {\n            tweenVars.scaleX = function(i) {\n                return comps[i].a.scaleX;\n            };\n            tweenVars.scaleY = function(i) {\n                return comps[i].a.scaleY;\n            };\n        } else {\n            tweenVars.width = function(i) {\n                return comps[i].a.width + \"px\";\n            };\n            tweenVars.height = function(i) {\n                return comps[i].a.height + \"px\";\n            };\n            tweenVars.autoRound = vars.autoRound || false;\n        }\n        tweenVars.x = function(i) {\n            return comps[i].a.x + \"px\";\n        };\n        tweenVars.y = function(i) {\n            return comps[i].a.y + \"px\";\n        };\n        tweenVars.rotation = function(i) {\n            return comps[i].a.rotation + (spin ? spinFunc(i, targets[i], targets) * 360 : 0);\n        };\n        tweenVars.skewX = function(i) {\n            return comps[i].a.skewX;\n        };\n        targets = comps.map(function(c) {\n            return c.t;\n        });\n        if (_zIndex || _zIndex === 0) {\n            tweenVars.modifiers = {\n                zIndex: function zIndex() {\n                    return _zIndex;\n                }\n            };\n            tweenVars.zIndex = _zIndex;\n            tweenVars.immediateRender = vars.immediateRender !== false;\n        }\n        fade && (tweenVars.opacity = function(i) {\n            return comps[i].sd < 0 ? 0 : comps[i].sd > 0 ? comps[i].a.opacity : \"+=0\";\n        });\n        if (swapOutTargets.length) {\n            stagger = gsap.utils.distribute(stagger);\n            var dummyArray = targets.slice(swapOutTargets.length);\n            tweenVars.stagger = function(i, el) {\n                return stagger(~swapOutTargets.indexOf(el) ? targets.indexOf(comps[i].swap.t) : i, el, dummyArray);\n            };\n        } // // for testing...\n        // gsap.delayedCall(vars.data ? 50 : 1, function() {\n        // \tanimation.eventCallback(\"onComplete\", () => _setFinalStates(comps, !clearProps));\n        // \taddFunc.call(animation, targets, tweenVars, 0).play();\n        // });\n        // return;\n        _callbacks.forEach(function(name) {\n            return vars[name] && animation.eventCallback(name, vars[name], vars[name + \"Params\"]);\n        }); // apply callbacks to the timeline, not tweens (because \"custom\" timing can make multiple tweens)\n        if (custom && targets.length) {\n            // bust out the custom properties as their own tweens so they can use different eases, durations, etc.\n            remainingProps = _copy(tweenVars, _reserved);\n            if (\"scale\" in custom) {\n                custom.scaleX = custom.scaleY = custom.scale;\n                delete custom.scale;\n            }\n            for(p in custom){\n                v = _copy(custom[p], _fitReserved);\n                v[p] = tweenVars[p];\n                !(\"duration\" in v) && \"duration\" in tweenVars && (v.duration = tweenVars.duration);\n                v.stagger = tweenVars.stagger;\n                addFunc.call(animation, targets, v, 0);\n                delete remainingProps[p];\n            }\n        }\n        if (targets.length || leaving.length || entering.length) {\n            toggleClass && animation.add(function() {\n                return _toggleClass(classTargets, toggleClass, animation._zTime < 0 ? \"remove\" : \"add\");\n            }, 0) && !paused && _toggleClass(classTargets, toggleClass, \"add\");\n            targets.length && addFunc.call(animation, targets, remainingProps, 0);\n        }\n        _handleCallback(onEnter, entering, animation);\n        _handleCallback(onLeave, leaving, animation);\n        var batchTl = _batch && _batch.timeline;\n        if (batchTl) {\n            batchTl.add(animation, 0);\n            _batch._final.push(function() {\n                return _setFinalStates(comps, !clearProps);\n            });\n        }\n        endTime = animation.duration();\n        animation.call(function() {\n            var forward = animation.time() >= endTime;\n            forward && !batchTl && _setFinalStates(comps, !clearProps);\n            toggleClass && _toggleClass(classTargets, toggleClass, forward ? \"remove\" : \"add\");\n        });\n    };\n    absoluteOnLeave && (absolute = comps.filter(function(comp) {\n        return !comp.sd && !comp.a.isVisible && comp.b.isVisible;\n    }).map(function(comp) {\n        return comp.a.element;\n    }));\n    if (_batch) {\n        var _batch$_abs;\n        absolute && (_batch$_abs = _batch._abs).push.apply(_batch$_abs, _filterComps(comps, absolute));\n        _batch._run.push(run);\n    } else {\n        absolute && _makeCompsAbsolute(_filterComps(comps, absolute)); // when making absolute, we must go in a very particular order so that document flow changes don't affect things. Don't make it visible if both the before and after states are invisible! There's no point, and it could make things appear visible during the flip that shouldn't be.\n        run();\n    }\n    var anim = _batch ? _batch.timeline : animation;\n    anim.revert = function() {\n        return _killFlip(anim, 1, 1);\n    }; // a Flip timeline should behave very different when reverting - it should actually jump to the end so that styles get cleared out.\n    return anim;\n}, _interrupt = function _interrupt(tl) {\n    tl.vars.onInterrupt && tl.vars.onInterrupt.apply(tl, tl.vars.onInterruptParams || []);\n    tl.getChildren(true, false, true).forEach(_interrupt);\n}, _killFlip = function _killFlip(tl, action, force) {\n    // action: 0 = nothing, 1 = complete, 2 = only kill (don't complete)\n    if (tl && tl.progress() < 1 && (!tl.paused() || force)) {\n        if (action) {\n            _interrupt(tl);\n            action < 2 && tl.progress(1); // we should also kill it in case it was added to a parent timeline.\n            tl.kill();\n        }\n        return true;\n    }\n}, _createLookup = function _createLookup(state) {\n    var lookup = state.idLookup = {}, alt = state.alt = {}, elStates = state.elementStates, i = elStates.length, elState;\n    while(i--){\n        elState = elStates[i];\n        lookup[elState.id] ? alt[elState.id] = elState : lookup[elState.id] = elState;\n    }\n};\nvar FlipState = /*#__PURE__*/ function() {\n    function FlipState(targets, vars, targetsAreElementStates) {\n        this.props = vars && vars.props;\n        this.simple = !!(vars && vars.simple);\n        if (targetsAreElementStates) {\n            this.targets = _elementsFromElementStates(targets);\n            this.elementStates = targets;\n            _createLookup(this);\n        } else {\n            this.targets = _toArray(targets);\n            var soft = vars && (vars.kill === false || vars.batch && !vars.kill);\n            _batch && !soft && _batch._kill.push(this);\n            this.update(soft || !!_batch); // when batching, don't force in-progress flips to their end; we need to do that AFTER all getStates() are called.\n        }\n    }\n    var _proto = FlipState.prototype;\n    _proto.update = function update(soft) {\n        var _this = this;\n        this.elementStates = this.targets.map(function(el) {\n            return new ElementState(el, _this.props, _this.simple);\n        });\n        _createLookup(this);\n        this.interrupt(soft);\n        this.recordInlineStyles();\n        return this;\n    };\n    _proto.clear = function clear() {\n        this.targets.length = this.elementStates.length = 0;\n        _createLookup(this);\n        return this;\n    };\n    _proto.fit = function fit(state, scale, nested) {\n        var elStatesInOrder = _orderByDOMDepth(this.elementStates.slice(0), false, true), toElStates = (state || this).idLookup, i = 0, fromNode, toNode;\n        for(; i < elStatesInOrder.length; i++){\n            fromNode = elStatesInOrder[i];\n            nested && (fromNode.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fromNode.element, false, false, true)); // moving a parent affects the position of children\n            toNode = toElStates[fromNode.id];\n            toNode && _fit(fromNode, toNode, scale, true, 0, fromNode);\n            fromNode.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fromNode.element, false, false, true);\n        }\n        return this;\n    };\n    _proto.getProperty = function getProperty(element, property) {\n        var es = this.getElementState(element) || _emptyObj;\n        return (property in es ? es : es.props || _emptyObj)[property];\n    };\n    _proto.add = function add(state) {\n        var i = state.targets.length, lookup = this.idLookup, alt = this.alt, index, es, es2;\n        while(i--){\n            es = state.elementStates[i];\n            es2 = lookup[es.id];\n            if (es2 && (es.element === es2.element || alt[es.id] && alt[es.id].element === es.element)) {\n                // if the flip id is already in this FlipState, replace it!\n                index = this.elementStates.indexOf(es.element === es2.element ? es2 : alt[es.id]);\n                this.targets.splice(index, 1, state.targets[i]);\n                this.elementStates.splice(index, 1, es);\n            } else {\n                this.targets.push(state.targets[i]);\n                this.elementStates.push(es);\n            }\n        }\n        state.interrupted && (this.interrupted = true);\n        state.simple || (this.simple = false);\n        _createLookup(this);\n        return this;\n    };\n    _proto.compare = function compare(state) {\n        var l1 = state.idLookup, l2 = this.idLookup, unchanged = [], changed = [], enter = [], leave = [], targets = [], a1 = state.alt, a2 = this.alt, place = function place(s1, s2, el) {\n            return (s1.isVisible !== s2.isVisible ? s1.isVisible ? enter : leave : s1.isVisible ? changed : unchanged).push(el) && targets.push(el);\n        }, placeIfDoesNotExist = function placeIfDoesNotExist(s1, s2, el) {\n            return targets.indexOf(el) < 0 && place(s1, s2, el);\n        }, s1, s2, p, el, s1Alt, s2Alt, c1, c2;\n        for(p in l1){\n            s1Alt = a1[p];\n            s2Alt = a2[p];\n            s1 = !s1Alt ? l1[p] : _getChangingElState(state, this, p);\n            el = s1.element;\n            s2 = l2[p];\n            if (s2Alt) {\n                c2 = s2.isVisible || !s2Alt.isVisible && el === s2.element ? s2 : s2Alt;\n                c1 = s1Alt && !s1.isVisible && !s1Alt.isVisible && c2.element === s1Alt.element ? s1Alt : s1; //c1.element !== c2.element && c1.element === s2.element && (c2 = s2);\n                if (c1.isVisible && c2.isVisible && c1.element !== c2.element) {\n                    // swapping, so force into \"changed\" array\n                    (c1.isDifferent(c2) ? changed : unchanged).push(c1.element, c2.element);\n                    targets.push(c1.element, c2.element);\n                } else {\n                    place(c1, c2, c1.element);\n                }\n                s1Alt && c1.element === s1Alt.element && (s1Alt = l1[p]);\n                placeIfDoesNotExist(c1.element !== s2.element && s1Alt ? s1Alt : c1, s2, s2.element);\n                placeIfDoesNotExist(s1Alt && s1Alt.element === s2Alt.element ? s1Alt : c1, s2Alt, s2Alt.element);\n                s1Alt && placeIfDoesNotExist(s1Alt, s2Alt.element === s1Alt.element ? s2Alt : s2, s1Alt.element);\n            } else {\n                !s2 ? enter.push(el) : !s2.isDifferent(s1) ? unchanged.push(el) : place(s1, s2, el);\n                s1Alt && placeIfDoesNotExist(s1Alt, s2, s1Alt.element);\n            }\n        }\n        for(p in l2){\n            if (!l1[p]) {\n                leave.push(l2[p].element);\n                a2[p] && leave.push(a2[p].element);\n            }\n        }\n        return {\n            changed: changed,\n            unchanged: unchanged,\n            enter: enter,\n            leave: leave\n        };\n    };\n    _proto.recordInlineStyles = function recordInlineStyles() {\n        var props = _memoizedRemoveProps[this.props] || _removeProps, i = this.elementStates.length;\n        while(i--){\n            _recordInlineStyles(this.elementStates[i], props);\n        }\n    };\n    _proto.interrupt = function interrupt(soft) {\n        var _this2 = this;\n        // soft = DON'T force in-progress flip animations to completion (like when running a batch, we can't immediately kill flips when getting states because it could contaminate positioning and other .getState() calls that will run in the batch (we kill AFTER all the .getState() calls complete).\n        var timelines = [];\n        this.targets.forEach(function(t) {\n            var tl = t._flip, foundInProgress = _killFlip(tl, soft ? 0 : 1);\n            soft && foundInProgress && timelines.indexOf(tl) < 0 && tl.add(function() {\n                return _this2.updateVisibility();\n            });\n            foundInProgress && timelines.push(tl);\n        });\n        !soft && timelines.length && this.updateVisibility(); // if we found an in-progress Flip animation, we must record all the values in their current state at that point BUT we should update the isVisible value AFTER pushing that flip to completion so that elements that are entering or leaving will populate those Arrays properly.\n        this.interrupted || (this.interrupted = !!timelines.length);\n    };\n    _proto.updateVisibility = function updateVisibility() {\n        this.elementStates.forEach(function(es) {\n            var b = es.element.getBoundingClientRect();\n            es.isVisible = !!(b.width || b.height || b.top || b.left);\n            es.uncache = 1;\n        });\n    };\n    _proto.getElementState = function getElementState(element) {\n        return this.elementStates[this.targets.indexOf(_getEl(element))];\n    };\n    _proto.makeAbsolute = function makeAbsolute() {\n        return _orderByDOMDepth(this.elementStates.slice(0), true, true).map(_makeAbsolute);\n    };\n    return FlipState;\n}();\nvar ElementState = /*#__PURE__*/ function() {\n    function ElementState(element, props, simple) {\n        this.element = element;\n        this.update(props, simple);\n    }\n    var _proto2 = ElementState.prototype;\n    _proto2.isDifferent = function isDifferent(state) {\n        var b1 = this.bounds, b2 = state.bounds;\n        return b1.top !== b2.top || b1.left !== b2.left || b1.width !== b2.width || b1.height !== b2.height || !this.matrix.equals(state.matrix) || this.opacity !== state.opacity || this.props && state.props && JSON.stringify(this.props) !== JSON.stringify(state.props);\n    };\n    _proto2.update = function update(props, simple) {\n        var self = this, element = self.element, getProp = gsap.getProperty(element), cache = gsap.core.getCache(element), bounds = element.getBoundingClientRect(), bbox = element.getBBox && typeof element.getBBox === \"function\" && element.nodeName.toLowerCase() !== \"svg\" && element.getBBox(), m = simple ? new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D(1, 0, 0, 1, bounds.left + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollLeft)(), bounds.top + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollTop)()) : (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(element, false, false, true);\n        self.getProp = getProp;\n        self.element = element;\n        self.id = _getID(element);\n        self.matrix = m;\n        self.cache = cache;\n        self.bounds = bounds;\n        self.isVisible = !!(bounds.width || bounds.height || bounds.left || bounds.top);\n        self.display = getProp(\"display\");\n        self.position = getProp(\"position\");\n        self.parent = element.parentNode;\n        self.x = getProp(\"x\");\n        self.y = getProp(\"y\");\n        self.scaleX = cache.scaleX;\n        self.scaleY = cache.scaleY;\n        self.rotation = getProp(\"rotation\");\n        self.skewX = getProp(\"skewX\");\n        self.opacity = getProp(\"opacity\");\n        self.width = bbox ? bbox.width : _closestTenth(getProp(\"width\", \"px\"), 0.04); // round up to the closest 0.1 so that text doesn't wrap.\n        self.height = bbox ? bbox.height : _closestTenth(getProp(\"height\", \"px\"), 0.04);\n        props && _recordProps(self, _memoizedProps[props] || _memoizeProps(props));\n        self.ctm = element.getCTM && element.nodeName.toLowerCase() === \"svg\" && (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getCTM)(element).inverse();\n        self.simple = simple || _round(m.a) === 1 && !_round(m.b) && !_round(m.c) && _round(m.d) === 1; // allows us to speed through some other tasks if it's not scale/rotated\n        self.uncache = 0;\n    };\n    return ElementState;\n}();\nvar FlipAction = /*#__PURE__*/ function() {\n    function FlipAction(vars, batch) {\n        this.vars = vars;\n        this.batch = batch;\n        this.states = [];\n        this.timeline = batch.timeline;\n    }\n    var _proto3 = FlipAction.prototype;\n    _proto3.getStateById = function getStateById(id) {\n        var i = this.states.length;\n        while(i--){\n            if (this.states[i].idLookup[id]) {\n                return this.states[i];\n            }\n        }\n    };\n    _proto3.kill = function kill() {\n        this.batch.remove(this);\n    };\n    return FlipAction;\n}();\nvar FlipBatch = /*#__PURE__*/ function() {\n    function FlipBatch(id) {\n        this.id = id;\n        this.actions = [];\n        this._kill = [];\n        this._final = [];\n        this._abs = [];\n        this._run = [];\n        this.data = {};\n        this.state = new FlipState();\n        this.timeline = gsap.timeline();\n    }\n    var _proto4 = FlipBatch.prototype;\n    _proto4.add = function add(config) {\n        var result = this.actions.filter(function(action) {\n            return action.vars === config;\n        });\n        if (result.length) {\n            return result[0];\n        }\n        result = new FlipAction(typeof config === \"function\" ? {\n            animate: config\n        } : config, this);\n        this.actions.push(result);\n        return result;\n    };\n    _proto4.remove = function remove(action) {\n        var i = this.actions.indexOf(action);\n        i >= 0 && this.actions.splice(i, 1);\n        return this;\n    };\n    _proto4.getState = function getState(merge) {\n        var _this3 = this;\n        var prevBatch = _batch, prevAction = _batchAction;\n        _batch = this;\n        this.state.clear();\n        this._kill.length = 0;\n        this.actions.forEach(function(action) {\n            if (action.vars.getState) {\n                action.states.length = 0;\n                _batchAction = action;\n                action.state = action.vars.getState(action);\n            }\n            merge && action.states.forEach(function(s) {\n                return _this3.state.add(s);\n            });\n        });\n        _batchAction = prevAction;\n        _batch = prevBatch;\n        this.killConflicts();\n        return this;\n    };\n    _proto4.animate = function animate() {\n        var _this4 = this;\n        var prevBatch = _batch, tl = this.timeline, i = this.actions.length, finalStates, endTime;\n        _batch = this;\n        tl.clear();\n        this._abs.length = this._final.length = this._run.length = 0;\n        this.actions.forEach(function(a) {\n            a.vars.animate && a.vars.animate(a);\n            var onEnter = a.vars.onEnter, onLeave = a.vars.onLeave, targets = a.targets, s, result;\n            if (targets && targets.length && (onEnter || onLeave)) {\n                s = new FlipState();\n                a.states.forEach(function(state) {\n                    return s.add(state);\n                });\n                result = s.compare(Flip.getState(targets));\n                result.enter.length && onEnter && onEnter(result.enter);\n                result.leave.length && onLeave && onLeave(result.leave);\n            }\n        });\n        _makeCompsAbsolute(this._abs);\n        this._run.forEach(function(f) {\n            return f();\n        });\n        endTime = tl.duration();\n        finalStates = this._final.slice(0);\n        tl.add(function() {\n            if (endTime <= tl.time()) {\n                // only call if moving forward in the timeline (in case it's nested in a timeline that gets reversed)\n                finalStates.forEach(function(f) {\n                    return f();\n                });\n                _forEachBatch(_this4, \"onComplete\");\n            }\n        });\n        _batch = prevBatch;\n        while(i--){\n            this.actions[i].vars.once && this.actions[i].kill();\n        }\n        _forEachBatch(this, \"onStart\");\n        tl.restart();\n        return this;\n    };\n    _proto4.loadState = function loadState(done) {\n        done || (done = function done() {\n            return 0;\n        });\n        var queue = [];\n        this.actions.forEach(function(c) {\n            if (c.vars.loadState) {\n                var i, f = function f(targets) {\n                    targets && (c.targets = targets);\n                    i = queue.indexOf(f);\n                    if (~i) {\n                        queue.splice(i, 1);\n                        queue.length || done();\n                    }\n                };\n                queue.push(f);\n                c.vars.loadState(f);\n            }\n        });\n        queue.length || done();\n        return this;\n    };\n    _proto4.setState = function setState() {\n        this.actions.forEach(function(c) {\n            return c.targets = c.vars.setState && c.vars.setState(c);\n        });\n        return this;\n    };\n    _proto4.killConflicts = function killConflicts(soft) {\n        this.state.interrupt(soft);\n        this._kill.forEach(function(state) {\n            return state.interrupt(soft);\n        });\n        return this;\n    };\n    _proto4.run = function run(skipGetState, merge) {\n        var _this5 = this;\n        if (this !== _batch) {\n            skipGetState || this.getState(merge);\n            this.loadState(function() {\n                if (!_this5._killed) {\n                    _this5.setState();\n                    _this5.animate();\n                }\n            });\n        }\n        return this;\n    };\n    _proto4.clear = function clear(stateOnly) {\n        this.state.clear();\n        stateOnly || (this.actions.length = 0);\n    };\n    _proto4.getStateById = function getStateById(id) {\n        var i = this.actions.length, s;\n        while(i--){\n            s = this.actions[i].getStateById(id);\n            if (s) {\n                return s;\n            }\n        }\n        return this.state.idLookup[id] && this.state;\n    };\n    _proto4.kill = function kill() {\n        this._killed = 1;\n        this.clear();\n        delete _batchLookup[this.id];\n    };\n    return FlipBatch;\n}();\nvar Flip = /*#__PURE__*/ function() {\n    function Flip() {}\n    Flip.getState = function getState(targets, vars) {\n        var state = _parseState(targets, vars);\n        _batchAction && _batchAction.states.push(state);\n        vars && vars.batch && Flip.batch(vars.batch).state.add(state);\n        return state;\n    };\n    Flip.from = function from(state, vars) {\n        vars = vars || {};\n        \"clearProps\" in vars || (vars.clearProps = true);\n        return _fromTo(state, _parseState(vars.targets || state.targets, {\n            props: vars.props || state.props,\n            simple: vars.simple,\n            kill: !!vars.kill\n        }), vars, -1);\n    };\n    Flip.to = function to(state, vars) {\n        return _fromTo(state, _parseState(vars.targets || state.targets, {\n            props: vars.props || state.props,\n            simple: vars.simple,\n            kill: !!vars.kill\n        }), vars, 1);\n    };\n    Flip.fromTo = function fromTo(fromState, toState, vars) {\n        return _fromTo(fromState, toState, vars);\n    };\n    Flip.fit = function fit(fromEl, toEl, vars) {\n        var v = vars ? _copy(vars, _fitReserved) : {}, _ref = vars || v, absolute = _ref.absolute, scale = _ref.scale, getVars = _ref.getVars, props = _ref.props, runBackwards = _ref.runBackwards, onComplete = _ref.onComplete, simple = _ref.simple, fitChild = vars && vars.fitChild && _getEl(vars.fitChild), before = _parseElementState(toEl, props, simple, fromEl), after = _parseElementState(fromEl, 0, simple, before), inlineProps = props ? _memoizedRemoveProps[props] : _removeProps, ctx = gsap.context();\n        props && _applyProps(v, before.props);\n        _recordInlineStyles(after, inlineProps);\n        if (runBackwards) {\n            \"immediateRender\" in v || (v.immediateRender = true);\n            v.onComplete = function() {\n                _applyInlineStyles(after);\n                onComplete && onComplete.apply(this, arguments);\n            };\n        }\n        absolute && _makeAbsolute(after, before);\n        v = _fit(after, before, scale || fitChild, props, fitChild, v.duration || getVars ? v : 0);\n        ctx && !getVars && ctx.add(function() {\n            return function() {\n                return _applyInlineStyles(after);\n            };\n        });\n        return getVars ? v : v.duration ? gsap.to(after.element, v) : null;\n    };\n    Flip.makeAbsolute = function makeAbsolute(targetsOrStates, vars) {\n        return (targetsOrStates instanceof FlipState ? targetsOrStates : new FlipState(targetsOrStates, vars)).makeAbsolute();\n    };\n    Flip.batch = function batch(id) {\n        id || (id = \"default\");\n        return _batchLookup[id] || (_batchLookup[id] = new FlipBatch(id));\n    };\n    Flip.killFlipsOf = function killFlipsOf(targets, complete) {\n        (targets instanceof FlipState ? targets.targets : _toArray(targets)).forEach(function(t) {\n            return t && _killFlip(t._flip, complete !== false ? 1 : 2);\n        });\n    };\n    Flip.isFlipping = function isFlipping(target) {\n        var f = Flip.getByTarget(target);\n        return !!f && f.isActive();\n    };\n    Flip.getByTarget = function getByTarget(target) {\n        return (_getEl(target) || _emptyObj)._flip;\n    };\n    Flip.getElementState = function getElementState(target, props) {\n        return new ElementState(_getEl(target), props);\n    };\n    Flip.convertCoordinates = function convertCoordinates(fromElement, toElement, point) {\n        var m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(toElement, true, true).multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fromElement));\n        return point ? m.apply(point) : m;\n    };\n    Flip.register = function register(core) {\n        _body = typeof document !== \"undefined\" && document.body;\n        if (_body) {\n            gsap = core;\n            (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._setDoc)(_body);\n            _toArray = gsap.utils.toArray;\n            _getStyleSaver = gsap.core.getStyleSaver;\n            var snap = gsap.utils.snap(0.1);\n            _closestTenth = function _closestTenth(value, add) {\n                return snap(parseFloat(value) + add);\n            };\n        }\n    };\n    return Flip;\n}();\nFlip.version = \"3.12.5\"; // function whenImagesLoad(el, func) {\n// \tlet pending = [],\n// \t\tonLoad = e => {\n// \t\t\tpending.splice(pending.indexOf(e.target), 1);\n// \t\t\te.target.removeEventListener(\"load\", onLoad);\n// \t\t\tpending.length || func();\n// \t\t};\n// \tgsap.utils.toArray(el.tagName.toLowerCase() === \"img\" ? el : el.querySelectorAll(\"img\")).forEach(img => img.complete || img.addEventListener(\"load\", onLoad) || pending.push(img));\n// \tpending.length || func();\n// }\ntypeof window !== \"undefined\" && window.gsap && window.gsap.registerPlugin(Flip);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9GbGlwLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCLEdBQ21HO0FBRXJILElBQUlNLE1BQU0sR0FDTkMsVUFDQUMsTUFDQUMsUUFDQUMsY0FDQUMsT0FDQUMsZUFDQUMsZ0JBQ0FDLGdCQUFnQixTQUFTQSxjQUFjQyxLQUFLLEVBQUVDLElBQUk7SUFDcEQsT0FBT0QsTUFBTUUsT0FBTyxDQUFDQyxPQUFPLENBQUMsU0FBVUMsQ0FBQztRQUN0QyxPQUFPQSxFQUFFQyxJQUFJLENBQUNKLEtBQUssSUFBSUcsRUFBRUMsSUFBSSxDQUFDSixLQUFLLENBQUNHO0lBQ3RDO0FBQ0YsR0FDSUUsZUFBZSxDQUFDLEdBQ2hCQyxXQUFXLE1BQU1DLEtBQUtDLEVBQUUsRUFDeEJDLFdBQVdGLEtBQUtDLEVBQUUsR0FBRyxLQUNyQkUsWUFBWSxDQUFDLEdBQ2JDLG9CQUFvQixDQUFDLEdBQ3JCQyx1QkFBdUIsQ0FBQyxHQUN4QkMsZUFBZSxTQUFTQSxhQUFhQyxJQUFJO0lBQzNDLE9BQU8sT0FBT0EsU0FBUyxXQUFXQSxLQUFLQyxLQUFLLENBQUMsS0FBS0MsSUFBSSxDQUFDLElBQUlELEtBQUssQ0FBQyxPQUFPRDtBQUMxRSxHQUNJLGtFQUFrRTtBQUN0RUcsYUFBYUosYUFBYSw4REFDdEJLLGVBQWVMLGFBQWEsa0hBQzVCTSxTQUFTLFNBQVNBLE9BQU9DLE1BQU07SUFDakMsT0FBTzdCLFNBQVM2QixPQUFPLENBQUMsRUFBRSxJQUFJQyxRQUFRQyxJQUFJLENBQUMsc0JBQXNCRjtBQUNuRSxHQUNJRyxTQUFTLFNBQVNBLE9BQU9DLEtBQUs7SUFDaEMsT0FBT2pCLEtBQUtrQixLQUFLLENBQUNELFFBQVEsU0FBUyxTQUFTO0FBQzlDLEdBQ0lFLGVBQWUsU0FBU0EsYUFBYUMsT0FBTyxFQUFFQyxTQUFTLEVB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b0I7QUFDcEIsbURBQW1EO0FBQ25ELG1EQUFtRDtBQUNuRCwrQkFBK0I7QUFDL0IsT0FBTztBQUNQLHVMQUF1TDtBQUN2TCw2QkFBNkI7QUFDN0IsSUFBSTtBQUVKLE9BQU8xUCxXQUFXLGVBQWVBLE9BQU8vSSxJQUFJLElBQUkrSSxPQUFPL0ksSUFBSSxDQUFDMFksY0FBYyxDQUFDekM7QUFDaEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dzYXBAMy4xMi41L25vZGVfbW9kdWxlcy9nc2FwL0ZsaXAuanM/NTk5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEZsaXAgMy4xMi41XG4gKiBodHRwczovL2dzYXAuY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyNCwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9nc2FwLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHU0FQIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IHsgZ2V0R2xvYmFsTWF0cml4LCBfZ2V0RG9jU2Nyb2xsVG9wLCBfZ2V0RG9jU2Nyb2xsTGVmdCwgTWF0cml4MkQsIF9zZXREb2MsIF9nZXRDVE0gfSBmcm9tIFwiLi91dGlscy9tYXRyaXguanNcIjtcblxudmFyIF9pZCA9IDEsXG4gICAgX3RvQXJyYXksXG4gICAgZ3NhcCxcbiAgICBfYmF0Y2gsXG4gICAgX2JhdGNoQWN0aW9uLFxuICAgIF9ib2R5LFxuICAgIF9jbG9zZXN0VGVudGgsXG4gICAgX2dldFN0eWxlU2F2ZXIsXG4gICAgX2ZvckVhY2hCYXRjaCA9IGZ1bmN0aW9uIF9mb3JFYWNoQmF0Y2goYmF0Y2gsIG5hbWUpIHtcbiAgcmV0dXJuIGJhdGNoLmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBhLnZhcnNbbmFtZV0gJiYgYS52YXJzW25hbWVdKGEpO1xuICB9KTtcbn0sXG4gICAgX2JhdGNoTG9va3VwID0ge30sXG4gICAgX1JBRDJERUcgPSAxODAgLyBNYXRoLlBJLFxuICAgIF9ERUcyUkFEID0gTWF0aC5QSSAvIDE4MCxcbiAgICBfZW1wdHlPYmogPSB7fSxcbiAgICBfZGFzaGVkTmFtZUxvb2t1cCA9IHt9LFxuICAgIF9tZW1vaXplZFJlbW92ZVByb3BzID0ge30sXG4gICAgX2xpc3RUb0FycmF5ID0gZnVuY3Rpb24gX2xpc3RUb0FycmF5KGxpc3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBsaXN0ID09PSBcInN0cmluZ1wiID8gbGlzdC5zcGxpdChcIiBcIikuam9pbihcIlwiKS5zcGxpdChcIixcIikgOiBsaXN0O1xufSxcbiAgICAvLyByZW1vdmVzIGV4dHJhIHNwYWNlcyBjb250YW1pbmF0aW5nIHRoZSBuYW1lcywgcmV0dXJucyBhbiBBcnJheS5cbl9jYWxsYmFja3MgPSBfbGlzdFRvQXJyYXkoXCJvblN0YXJ0LG9uVXBkYXRlLG9uQ29tcGxldGUsb25SZXZlcnNlQ29tcGxldGUsb25JbnRlcnJ1cHRcIiksXG4gICAgX3JlbW92ZVByb3BzID0gX2xpc3RUb0FycmF5KFwidHJhbnNmb3JtLHRyYW5zZm9ybU9yaWdpbix3aWR0aCxoZWlnaHQscG9zaXRpb24sdG9wLGxlZnQsb3BhY2l0eSx6SW5kZXgsbWF4V2lkdGgsbWF4SGVpZ2h0LG1pbldpZHRoLG1pbkhlaWdodFwiKSxcbiAgICBfZ2V0RWwgPSBmdW5jdGlvbiBfZ2V0RWwodGFyZ2V0KSB7XG4gIHJldHVybiBfdG9BcnJheSh0YXJnZXQpWzBdIHx8IGNvbnNvbGUud2FybihcIkVsZW1lbnQgbm90IGZvdW5kOlwiLCB0YXJnZXQpO1xufSxcbiAgICBfcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMCkgLyAxMDAwMCB8fCAwO1xufSxcbiAgICBfdG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbiBfdG9nZ2xlQ2xhc3ModGFyZ2V0cywgY2xhc3NOYW1lLCBhY3Rpb24pIHtcbiAgcmV0dXJuIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWwuY2xhc3NMaXN0W2FjdGlvbl0oY2xhc3NOYW1lKTtcbiAgfSk7XG59LFxuICAgIF9yZXNlcnZlZCA9IHtcbiAgekluZGV4OiAxLFxuICBraWxsOiAxLFxuICBzaW1wbGU6IDEsXG4gIHNwaW46IDEsXG4gIGNsZWFyUHJvcHM6IDEsXG4gIHRhcmdldHM6IDEsXG4gIHRvZ2dsZUNsYXNzOiAxLFxuICBvbkNvbXBsZXRlOiAxLFxuICBvblVwZGF0ZTogMSxcbiAgb25JbnRlcnJ1cHQ6IDEsXG4gIG9uU3RhcnQ6IDEsXG4gIGRlbGF5OiAxLFxuICByZXBlYXQ6IDEsXG4gIHJlcGVhdERlbGF5OiAxLFxuICB5b3lvOiAxLFxuICBzY2FsZTogMSxcbiAgZmFkZTogMSxcbiAgYWJzb2x1dGU6IDEsXG4gIHByb3BzOiAxLFxuICBvbkVudGVyOiAxLFxuICBvbkxlYXZlOiAxLFxuICBjdXN0b206IDEsXG4gIHBhdXNlZDogMSxcbiAgbmVzdGVkOiAxLFxuICBwcnVuZTogMSxcbiAgYWJzb2x1dGVPbkxlYXZlOiAxXG59LFxuICAgIF9maXRSZXNlcnZlZCA9IHtcbiAgekluZGV4OiAxLFxuICBzaW1wbGU6IDEsXG4gIGNsZWFyUHJvcHM6IDEsXG4gIHNjYWxlOiAxLFxuICBhYnNvbHV0ZTogMSxcbiAgZml0Q2hpbGQ6IDEsXG4gIGdldFZhcnM6IDEsXG4gIHByb3BzOiAxXG59LFxuICAgIF9jYW1lbFRvRGFzaGVkID0gZnVuY3Rpb24gX2NhbWVsVG9EYXNoZWQocCkge1xuICByZXR1cm4gcC5yZXBsYWNlKC8oW0EtWl0pL2csIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCk7XG59LFxuICAgIF9jb3B5ID0gZnVuY3Rpb24gX2NvcHkob2JqLCBleGNsdWRlKSB7XG4gIHZhciByZXN1bHQgPSB7fSxcbiAgICAgIHA7XG5cbiAgZm9yIChwIGluIG9iaikge1xuICAgIGV4Y2x1ZGVbcF0gfHwgKHJlc3VsdFtwXSA9IG9ialtwXSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSxcbiAgICBfbWVtb2l6ZWRQcm9wcyA9IHt9LFxuICAgIF9tZW1vaXplUHJvcHMgPSBmdW5jdGlvbiBfbWVtb2l6ZVByb3BzKHByb3BzKSB7XG4gIHZhciBwID0gX21lbW9pemVkUHJvcHNbcHJvcHNdID0gX2xpc3RUb0FycmF5KHByb3BzKTtcblxuICBfbWVtb2l6ZWRSZW1vdmVQcm9wc1twcm9wc10gPSBwLmNvbmNhdChfcmVtb3ZlUHJvcHMpO1xuICByZXR1cm4gcDtcbn0sXG4gICAgX2dldEludmVyc2VHbG9iYWxNYXRyaXggPSBmdW5jdGlvbiBfZ2V0SW52ZXJzZUdsb2JhbE1hdHJpeChlbCkge1xuICAvLyBpbnRlZ3JhdGVzIGNhY2hpbmcgZm9yIGltcHJvdmVkIHBlcmZvcm1hbmNlXG4gIHZhciBjYWNoZSA9IGVsLl9nc2FwIHx8IGdzYXAuY29yZS5nZXRDYWNoZShlbCk7XG5cbiAgaWYgKGNhY2hlLmdtQ2FjaGUgPT09IGdzYXAudGlja2VyLmZyYW1lKSB7XG4gICAgcmV0dXJuIGNhY2hlLmdNYXRyaXg7XG4gIH1cblxuICBjYWNoZS5nbUNhY2hlID0gZ3NhcC50aWNrZXIuZnJhbWU7XG4gIHJldHVybiBjYWNoZS5nTWF0cml4ID0gZ2V0R2xvYmFsTWF0cml4KGVsLCB0cnVlLCBmYWxzZSwgdHJ1ZSk7XG59LFxuICAgIF9nZXRET01EZXB0aCA9IGZ1bmN0aW9uIF9nZXRET01EZXB0aChlbCwgaW52ZXJ0LCBsZXZlbCkge1xuICBpZiAobGV2ZWwgPT09IHZvaWQgMCkge1xuICAgIGxldmVsID0gMDtcbiAgfVxuXG4gIC8vIEluIGludmVydCBpcyB0cnVlLCB0aGUgc2libGluZyBkZXB0aCBpcyBpbmNyZW1lbnRzIG9mIDEsIGFuZCBwYXJlbnQvbmVzdGluZyBkZXB0aCBpcyBpbmNyZW1lbnRzIG9mIDEwMDAuIFRoaXMgbGV0cyB1cyBvcmRlciBlbGVtZW50cyBpbiBhbiBBcnJheSB0byByZWZsZWN0IGRvY3VtZW50IGZsb3cuXG4gIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlLFxuICAgICAgaW5jID0gMTAwMCAqIE1hdGgucG93KDEwLCBsZXZlbCkgKiAoaW52ZXJ0ID8gLTEgOiAxKSxcbiAgICAgIGwgPSBpbnZlcnQgPyAtaW5jICogOTAwIDogMDtcblxuICB3aGlsZSAoZWwpIHtcbiAgICBsICs9IGluYztcbiAgICBlbCA9IGVsLnByZXZpb3VzU2libGluZztcbiAgfVxuXG4gIHJldHVybiBwYXJlbnQgPyBsICsgX2dldERPTURlcHRoKHBhcmVudCwgaW52ZXJ0LCBsZXZlbCArIDEpIDogbDtcbn0sXG4gICAgX29yZGVyQnlET01EZXB0aCA9IGZ1bmN0aW9uIF9vcmRlckJ5RE9NRGVwdGgoY29tcHMsIGludmVydCwgaXNFbFN0YXRlcykge1xuICBjb21wcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wKSB7XG4gICAgcmV0dXJuIGNvbXAuZCA9IF9nZXRET01EZXB0aChpc0VsU3RhdGVzID8gY29tcC5lbGVtZW50IDogY29tcC50LCBpbnZlcnQpO1xuICB9KTtcbiAgY29tcHMuc29ydChmdW5jdGlvbiAoYzEsIGMyKSB7XG4gICAgcmV0dXJuIGMxLmQgLSBjMi5kO1xuICB9KTtcbiAgcmV0dXJuIGNvbXBzO1xufSxcbiAgICBfcmVjb3JkSW5saW5lU3R5bGVzID0gZnVuY3Rpb24gX3JlY29yZElubGluZVN0eWxlcyhlbFN0YXRlLCBwcm9wcykge1xuICAvLyByZWNvcmRzIHRoZSBjdXJyZW50IGlubGluZSBDU1MgcHJvcGVydGllcyBpbnRvIGFuIEFycmF5IGluIGFsdGVybmF0aW5nIG5hbWUvdmFsdWUgcGFpcnMgdGhhdCdzIHN0b3JlZCBpbiBhIFwiY3NzXCIgcHJvcGVydHkgb24gdGhlIHN0YXRlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiByZXZlcnQgbGF0ZXIuXG4gIHZhciBzdHlsZSA9IGVsU3RhdGUuZWxlbWVudC5zdHlsZSxcbiAgICAgIGEgPSBlbFN0YXRlLmNzcyA9IGVsU3RhdGUuY3NzIHx8IFtdLFxuICAgICAgaSA9IHByb3BzLmxlbmd0aCxcbiAgICAgIHAsXG4gICAgICB2O1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBwID0gcHJvcHNbaV07XG4gICAgdiA9IHN0eWxlW3BdIHx8IHN0eWxlLmdldFByb3BlcnR5VmFsdWUocCk7XG4gICAgYS5wdXNoKHYgPyBwIDogX2Rhc2hlZE5hbWVMb29rdXBbcF0gfHwgKF9kYXNoZWROYW1lTG9va3VwW3BdID0gX2NhbWVsVG9EYXNoZWQocCkpLCB2KTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn0sXG4gICAgX2FwcGx5SW5saW5lU3R5bGVzID0gZnVuY3Rpb24gX2FwcGx5SW5saW5lU3R5bGVzKHN0YXRlKSB7XG4gIHZhciBjc3MgPSBzdGF0ZS5jc3MsXG4gICAgICBzdHlsZSA9IHN0YXRlLmVsZW1lbnQuc3R5bGUsXG4gICAgICBpID0gMDtcbiAgc3RhdGUuY2FjaGUudW5jYWNoZSA9IDE7XG5cbiAgZm9yICg7IGkgPCBjc3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBjc3NbaSArIDFdID8gc3R5bGVbY3NzW2ldXSA9IGNzc1tpICsgMV0gOiBzdHlsZS5yZW1vdmVQcm9wZXJ0eShjc3NbaV0pO1xuICB9XG5cbiAgaWYgKCFjc3NbY3NzLmluZGV4T2YoXCJ0cmFuc2Zvcm1cIikgKyAxXSAmJiBzdHlsZS50cmFuc2xhdGUpIHtcbiAgICAvLyBDU1NQbHVnaW4gYWRkcyBzY2FsZSwgdHJhbnNsYXRlLCBhbmQgcm90YXRlIGlubGluZSBDU1MgYXMgXCJub25lXCIgaW4gb3JkZXIgdG8ga2VlcCBDU1MgcnVsZXMgZnJvbSBjb250YW1pbmF0aW5nIHRyYW5zZm9ybXMuXG4gICAgc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0cmFuc2xhdGVcIik7XG4gICAgc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJzY2FsZVwiKTtcbiAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eShcInJvdGF0ZVwiKTtcbiAgfVxufSxcbiAgICBfc2V0RmluYWxTdGF0ZXMgPSBmdW5jdGlvbiBfc2V0RmluYWxTdGF0ZXMoY29tcHMsIG9ubHlUcmFuc2Zvcm1zKSB7XG4gIGNvbXBzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gYy5hLmNhY2hlLnVuY2FjaGUgPSAxO1xuICB9KTtcbiAgb25seVRyYW5zZm9ybXMgfHwgY29tcHMuZmluYWxTdGF0ZXMuZm9yRWFjaChfYXBwbHlJbmxpbmVTdHlsZXMpO1xufSxcbiAgICBfYWJzb2x1dGVQcm9wcyA9IFwicGFkZGluZ1RvcCxwYWRkaW5nUmlnaHQscGFkZGluZ0JvdHRvbSxwYWRkaW5nTGVmdCxncmlkQXJlYSx0cmFuc2l0aW9uXCIuc3BsaXQoXCIsXCIpLFxuICAgIC8vIHByb3BlcnRpZXMgdGhhdCB3ZSBtdXN0IHJlY29yZCBqdXN0XG5fbWFrZUFic29sdXRlID0gZnVuY3Rpb24gX21ha2VBYnNvbHV0ZShlbFN0YXRlLCBmYWxsYmFja05vZGUsIGlnbm9yZUJhdGNoKSB7XG4gIHZhciBlbGVtZW50ID0gZWxTdGF0ZS5lbGVtZW50LFxuICAgICAgd2lkdGggPSBlbFN0YXRlLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gZWxTdGF0ZS5oZWlnaHQsXG4gICAgICB1bmNhY2hlID0gZWxTdGF0ZS51bmNhY2hlLFxuICAgICAgZ2V0UHJvcCA9IGVsU3RhdGUuZ2V0UHJvcCxcbiAgICAgIHN0eWxlID0gZWxlbWVudC5zdHlsZSxcbiAgICAgIGkgPSA0LFxuICAgICAgcmVzdWx0LFxuICAgICAgZGlzcGxheUlzTm9uZSxcbiAgICAgIGNzO1xuICB0eXBlb2YgZmFsbGJhY2tOb2RlICE9PSBcIm9iamVjdFwiICYmIChmYWxsYmFja05vZGUgPSBlbFN0YXRlKTtcblxuICBpZiAoX2JhdGNoICYmIGlnbm9yZUJhdGNoICE9PSAxKSB7XG4gICAgX2JhdGNoLl9hYnMucHVzaCh7XG4gICAgICB0OiBlbGVtZW50LFxuICAgICAgYjogZWxTdGF0ZSxcbiAgICAgIGE6IGVsU3RhdGUsXG4gICAgICBzZDogMFxuICAgIH0pO1xuXG4gICAgX2JhdGNoLl9maW5hbC5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoZWxTdGF0ZS5jYWNoZS51bmNhY2hlID0gMSkgJiYgX2FwcGx5SW5saW5lU3R5bGVzKGVsU3RhdGUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBkaXNwbGF5SXNOb25lID0gZ2V0UHJvcChcImRpc3BsYXlcIikgPT09IFwibm9uZVwiO1xuXG4gIGlmICghZWxTdGF0ZS5pc1Zpc2libGUgfHwgZGlzcGxheUlzTm9uZSkge1xuICAgIGRpc3BsYXlJc05vbmUgJiYgKF9yZWNvcmRJbmxpbmVTdHlsZXMoZWxTdGF0ZSwgW1wiZGlzcGxheVwiXSkuZGlzcGxheSA9IGZhbGxiYWNrTm9kZS5kaXNwbGF5KTtcbiAgICBlbFN0YXRlLm1hdHJpeCA9IGZhbGxiYWNrTm9kZS5tYXRyaXg7XG4gICAgZWxTdGF0ZS53aWR0aCA9IHdpZHRoID0gZWxTdGF0ZS53aWR0aCB8fCBmYWxsYmFja05vZGUud2lkdGg7XG4gICAgZWxTdGF0ZS5oZWlnaHQgPSBoZWlnaHQgPSBlbFN0YXRlLmhlaWdodCB8fCBmYWxsYmFja05vZGUuaGVpZ2h0O1xuICB9XG5cbiAgX3JlY29yZElubGluZVN0eWxlcyhlbFN0YXRlLCBfYWJzb2x1dGVQcm9wcyk7XG5cbiAgY3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgc3R5bGVbX2Fic29sdXRlUHJvcHNbaV1dID0gY3NbX2Fic29sdXRlUHJvcHNbaV1dOyAvLyByZWNvcmQgcGFkZGluZ3MgYXMgcHgtYmFzZWQgYmVjYXVzZSBpZiByZW1vdmVkIGZyb20gZ3JpZCwgcGVyY2VudGFnZS1iYXNlZCBvbmVzIGNvdWxkIGJlIGFsdGVyZWQuXG4gIH1cblxuICBzdHlsZS5ncmlkQXJlYSA9IFwiMSAvIDEgLyAxIC8gMVwiO1xuICBzdHlsZS50cmFuc2l0aW9uID0gXCJub25lXCI7XG4gIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICBzdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICBzdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gIHN0eWxlLnRvcCB8fCAoc3R5bGUudG9wID0gXCIwcHhcIik7XG4gIHN0eWxlLmxlZnQgfHwgKHN0eWxlLmxlZnQgPSBcIjBweFwiKTtcblxuICBpZiAodW5jYWNoZSkge1xuICAgIHJlc3VsdCA9IG5ldyBFbGVtZW50U3RhdGUoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYmV0dGVyIHBlcmZvcm1hbmNlXG4gICAgcmVzdWx0ID0gX2NvcHkoZWxTdGF0ZSwgX2VtcHR5T2JqKTtcbiAgICByZXN1bHQucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cbiAgICBpZiAoZWxTdGF0ZS5zaW1wbGUpIHtcbiAgICAgIHZhciBib3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmVzdWx0Lm1hdHJpeCA9IG5ldyBNYXRyaXgyRCgxLCAwLCAwLCAxLCBib3VuZHMubGVmdCArIF9nZXREb2NTY3JvbGxMZWZ0KCksIGJvdW5kcy50b3AgKyBfZ2V0RG9jU2Nyb2xsVG9wKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQubWF0cml4ID0gZ2V0R2xvYmFsTWF0cml4KGVsZW1lbnQsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmVzdWx0ID0gX2ZpdChyZXN1bHQsIGVsU3RhdGUsIHRydWUpO1xuICBlbFN0YXRlLnggPSBfY2xvc2VzdFRlbnRoKHJlc3VsdC54LCAwLjAxKTtcbiAgZWxTdGF0ZS55ID0gX2Nsb3Nlc3RUZW50aChyZXN1bHQueSwgMC4wMSk7XG4gIHJldHVybiBlbGVtZW50O1xufSxcbiAgICBfZmlsdGVyQ29tcHMgPSBmdW5jdGlvbiBfZmlsdGVyQ29tcHMoY29tcHMsIHRhcmdldHMpIHtcbiAgaWYgKHRhcmdldHMgIT09IHRydWUpIHtcbiAgICB0YXJnZXRzID0gX3RvQXJyYXkodGFyZ2V0cyk7XG4gICAgY29tcHMgPSBjb21wcy5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmICh0YXJnZXRzLmluZGV4T2YoKGMuc2QgPCAwID8gYy5iIDogYy5hKS5lbGVtZW50KSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjLnQuX2dzYXAucmVuZGVyVHJhbnNmb3JtKDEpOyAvLyB3ZSBtdXN0IGZvcmNlIHRyYW5zZm9ybXMgdG8gcmVuZGVyIG9uIGFueXRoaW5nIHRoYXQgaXNuJ3QgYmVpbmcgbWFkZSBwb3NpdGlvbjogYWJzb2x1dGUsIG90aGVyd2lzZSB0aGUgYWJzb2x1dGUgcG9zaXRpb24gaGFwcGVucyBhbmQgdGhlbiB3aGVuIGFuaW1hdGlvbiBiZWdpbnMgaXQgYXBwbGllcyB0cmFuc2Zvcm1zIHdoaWNoIGNhbiBjcmVhdGUgYSBuZXcgc3RhY2tpbmcgY29udGV4dCwgdGhyb3dpbmcgb2ZmIHBvc2l0aW9uaW5nIVxuXG5cbiAgICAgICAgaWYgKGMuYi5pc1Zpc2libGUpIHtcbiAgICAgICAgICBjLnQuc3R5bGUud2lkdGggPSBjLmIud2lkdGggKyBcInB4XCI7IC8vIG90aGVyd2lzZSB0aGluZ3MgY2FuIGNvbGxhcHNlIHdoZW4gY29udGVudHMgYXJlIG1hZGUgcG9zaXRpb246IGFic29sdXRlLlxuXG4gICAgICAgICAgYy50LnN0eWxlLmhlaWdodCA9IGMuYi5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjb21wcztcbn0sXG4gICAgX21ha2VDb21wc0Fic29sdXRlID0gZnVuY3Rpb24gX21ha2VDb21wc0Fic29sdXRlKGNvbXBzKSB7XG4gIHJldHVybiBfb3JkZXJCeURPTURlcHRoKGNvbXBzLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIChjLmEuaXNWaXNpYmxlIHx8IGMuYi5pc1Zpc2libGUpICYmIF9tYWtlQWJzb2x1dGUoYy5zZCA8IDAgPyBjLmIgOiBjLmEsIGMuYiwgMSk7XG4gIH0pO1xufSxcbiAgICBfZmluZEVsU3RhdGVJblN0YXRlID0gZnVuY3Rpb24gX2ZpbmRFbFN0YXRlSW5TdGF0ZShzdGF0ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIG90aGVyICYmIHN0YXRlLmlkTG9va3VwW19wYXJzZUVsZW1lbnRTdGF0ZShvdGhlcikuaWRdIHx8IHN0YXRlLmVsZW1lbnRTdGF0ZXNbMF07XG59LFxuICAgIF9wYXJzZUVsZW1lbnRTdGF0ZSA9IGZ1bmN0aW9uIF9wYXJzZUVsZW1lbnRTdGF0ZShlbE9yTm9kZSwgcHJvcHMsIHNpbXBsZSwgb3RoZXIpIHtcbiAgcmV0dXJuIGVsT3JOb2RlIGluc3RhbmNlb2YgRWxlbWVudFN0YXRlID8gZWxPck5vZGUgOiBlbE9yTm9kZSBpbnN0YW5jZW9mIEZsaXBTdGF0ZSA/IF9maW5kRWxTdGF0ZUluU3RhdGUoZWxPck5vZGUsIG90aGVyKSA6IG5ldyBFbGVtZW50U3RhdGUodHlwZW9mIGVsT3JOb2RlID09PSBcInN0cmluZ1wiID8gX2dldEVsKGVsT3JOb2RlKSB8fCBjb25zb2xlLndhcm4oZWxPck5vZGUgKyBcIiBub3QgZm91bmRcIikgOiBlbE9yTm9kZSwgcHJvcHMsIHNpbXBsZSk7XG59LFxuICAgIF9yZWNvcmRQcm9wcyA9IGZ1bmN0aW9uIF9yZWNvcmRQcm9wcyhlbFN0YXRlLCBwcm9wcykge1xuICB2YXIgZ2V0UHJvcCA9IGdzYXAuZ2V0UHJvcGVydHkoZWxTdGF0ZS5lbGVtZW50LCBudWxsLCBcIm5hdGl2ZVwiKSxcbiAgICAgIG9iaiA9IGVsU3RhdGUucHJvcHMgPSB7fSxcbiAgICAgIGkgPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIG9ialtwcm9wc1tpXV0gPSAoZ2V0UHJvcChwcm9wc1tpXSkgKyBcIlwiKS50cmltKCk7XG4gIH1cblxuICBvYmouekluZGV4ICYmIChvYmouekluZGV4ID0gcGFyc2VGbG9hdChvYmouekluZGV4KSB8fCAwKTtcbiAgcmV0dXJuIGVsU3RhdGU7XG59LFxuICAgIF9hcHBseVByb3BzID0gZnVuY3Rpb24gX2FwcGx5UHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZSB8fCBlbGVtZW50LFxuICAgICAgLy8gY291bGQgcGFzcyBpbiBhIHZhcnMgb2JqZWN0LlxuICBwO1xuXG4gIGZvciAocCBpbiBwcm9wcykge1xuICAgIHN0eWxlW3BdID0gcHJvcHNbcF07XG4gIH1cbn0sXG4gICAgX2dldElEID0gZnVuY3Rpb24gX2dldElEKGVsKSB7XG4gIHZhciBpZCA9IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtZmxpcC1pZFwiKTtcbiAgaWQgfHwgZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1mbGlwLWlkXCIsIGlkID0gXCJhdXRvLVwiICsgX2lkKyspO1xuICByZXR1cm4gaWQ7XG59LFxuICAgIF9lbGVtZW50c0Zyb21FbGVtZW50U3RhdGVzID0gZnVuY3Rpb24gX2VsZW1lbnRzRnJvbUVsZW1lbnRTdGF0ZXMoZWxTdGF0ZXMpIHtcbiAgcmV0dXJuIGVsU3RhdGVzLm1hcChmdW5jdGlvbiAoZWxTdGF0ZSkge1xuICAgIHJldHVybiBlbFN0YXRlLmVsZW1lbnQ7XG4gIH0pO1xufSxcbiAgICBfaGFuZGxlQ2FsbGJhY2sgPSBmdW5jdGlvbiBfaGFuZGxlQ2FsbGJhY2soY2FsbGJhY2ssIGVsU3RhdGVzLCB0bCkge1xuICByZXR1cm4gY2FsbGJhY2sgJiYgZWxTdGF0ZXMubGVuZ3RoICYmIHRsLmFkZChjYWxsYmFjayhfZWxlbWVudHNGcm9tRWxlbWVudFN0YXRlcyhlbFN0YXRlcyksIHRsLCBuZXcgRmxpcFN0YXRlKGVsU3RhdGVzLCAwLCB0cnVlKSksIDApO1xufSxcbiAgICBfZml0ID0gZnVuY3Rpb24gX2ZpdChmcm9tU3RhdGUsIHRvU3RhdGUsIHNjYWxlLCBhcHBseVByb3BzLCBmaXRDaGlsZCwgdmFycykge1xuICB2YXIgZWxlbWVudCA9IGZyb21TdGF0ZS5lbGVtZW50LFxuICAgICAgY2FjaGUgPSBmcm9tU3RhdGUuY2FjaGUsXG4gICAgICBwYXJlbnQgPSBmcm9tU3RhdGUucGFyZW50LFxuICAgICAgeCA9IGZyb21TdGF0ZS54LFxuICAgICAgeSA9IGZyb21TdGF0ZS55LFxuICAgICAgd2lkdGggPSB0b1N0YXRlLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gdG9TdGF0ZS5oZWlnaHQsXG4gICAgICBzY2FsZVggPSB0b1N0YXRlLnNjYWxlWCxcbiAgICAgIHNjYWxlWSA9IHRvU3RhdGUuc2NhbGVZLFxuICAgICAgcm90YXRpb24gPSB0b1N0YXRlLnJvdGF0aW9uLFxuICAgICAgYm91bmRzID0gdG9TdGF0ZS5ib3VuZHMsXG4gICAgICBzdHlsZXMgPSB2YXJzICYmIF9nZXRTdHlsZVNhdmVyICYmIF9nZXRTdHlsZVNhdmVyKGVsZW1lbnQsIFwidHJhbnNmb3JtXCIpLFxuICAgICAgZGltZW5zaW9uU3RhdGUgPSBmcm9tU3RhdGUsXG4gICAgICBfdG9TdGF0ZSRtYXRyaXggPSB0b1N0YXRlLm1hdHJpeCxcbiAgICAgIGUgPSBfdG9TdGF0ZSRtYXRyaXguZSxcbiAgICAgIGYgPSBfdG9TdGF0ZSRtYXRyaXguZixcbiAgICAgIGRlZXAgPSBmcm9tU3RhdGUuYm91bmRzLndpZHRoICE9PSBib3VuZHMud2lkdGggfHwgZnJvbVN0YXRlLmJvdW5kcy5oZWlnaHQgIT09IGJvdW5kcy5oZWlnaHQgfHwgZnJvbVN0YXRlLnNjYWxlWCAhPT0gc2NhbGVYIHx8IGZyb21TdGF0ZS5zY2FsZVkgIT09IHNjYWxlWSB8fCBmcm9tU3RhdGUucm90YXRpb24gIT09IHJvdGF0aW9uLFxuICAgICAgc2ltcGxlID0gIWRlZXAgJiYgZnJvbVN0YXRlLnNpbXBsZSAmJiB0b1N0YXRlLnNpbXBsZSAmJiAhZml0Q2hpbGQsXG4gICAgICBza2V3WCxcbiAgICAgIGZyb21Qb2ludCxcbiAgICAgIHRvUG9pbnQsXG4gICAgICBnZXRQcm9wLFxuICAgICAgcGFyZW50TWF0cml4LFxuICAgICAgbWF0cml4LFxuICAgICAgYmJveDtcblxuICBpZiAoc2ltcGxlIHx8ICFwYXJlbnQpIHtcbiAgICBzY2FsZVggPSBzY2FsZVkgPSAxO1xuICAgIHJvdGF0aW9uID0gc2tld1ggPSAwO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudE1hdHJpeCA9IF9nZXRJbnZlcnNlR2xvYmFsTWF0cml4KHBhcmVudCk7XG4gICAgbWF0cml4ID0gcGFyZW50TWF0cml4LmNsb25lKCkubXVsdGlwbHkodG9TdGF0ZS5jdG0gPyB0b1N0YXRlLm1hdHJpeC5jbG9uZSgpLm11bHRpcGx5KHRvU3RhdGUuY3RtKSA6IHRvU3RhdGUubWF0cml4KTsgLy8gcm9vdCBTVkcgZWxlbWVudHMgaGF2ZSBhIGN0bSB0aGF0IHdlIG11c3QgZmFjdG9yIG91dCAoZm9yIGV4YW1wbGUsIHZpZXdCb3g6XCIwIDAgOTQgOTRcIiB3aXRoIGEgd2lkdGggb2YgMjAwcHggd291bGQgc2NhbGUgdGhlIGludGVybmFscyBieSAyLjEyNyBidXQgd2hlbiB3ZSdyZSBtYXRjaGluZyB0aGUgc2l6ZSBvZiB0aGUgcm9vdCA8c3ZnPiBlbGVtZW50IGl0c2VsZiwgdGhhdCBzY2FsaW5nIHNob3VsZG4ndCBmYWN0b3IgaW4hKVxuXG4gICAgcm90YXRpb24gPSBfcm91bmQoTWF0aC5hdGFuMihtYXRyaXguYiwgbWF0cml4LmEpICogX1JBRDJERUcpO1xuICAgIHNrZXdYID0gX3JvdW5kKE1hdGguYXRhbjIobWF0cml4LmMsIG1hdHJpeC5kKSAqIF9SQUQyREVHICsgcm90YXRpb24pICUgMzYwOyAvLyBpbiB2ZXJ5IHJhcmUgY2FzZXMsIG1pbm9yIHJvdW5kaW5nIG1pZ2h0IGVuZCB1cCB3aXRoIDM2MCB3aGljaCBzaG91bGQgYmUgMC5cblxuICAgIHNjYWxlWCA9IE1hdGguc3FydChNYXRoLnBvdyhtYXRyaXguYSwgMikgKyBNYXRoLnBvdyhtYXRyaXguYiwgMikpO1xuICAgIHNjYWxlWSA9IE1hdGguc3FydChNYXRoLnBvdyhtYXRyaXguYywgMikgKyBNYXRoLnBvdyhtYXRyaXguZCwgMikpICogTWF0aC5jb3Moc2tld1ggKiBfREVHMlJBRCk7XG5cbiAgICBpZiAoZml0Q2hpbGQpIHtcbiAgICAgIGZpdENoaWxkID0gX3RvQXJyYXkoZml0Q2hpbGQpWzBdO1xuICAgICAgZ2V0UHJvcCA9IGdzYXAuZ2V0UHJvcGVydHkoZml0Q2hpbGQpO1xuICAgICAgYmJveCA9IGZpdENoaWxkLmdldEJCb3ggJiYgdHlwZW9mIGZpdENoaWxkLmdldEJCb3ggPT09IFwiZnVuY3Rpb25cIiAmJiBmaXRDaGlsZC5nZXRCQm94KCk7XG4gICAgICBkaW1lbnNpb25TdGF0ZSA9IHtcbiAgICAgICAgc2NhbGVYOiBnZXRQcm9wKFwic2NhbGVYXCIpLFxuICAgICAgICBzY2FsZVk6IGdldFByb3AoXCJzY2FsZVlcIiksXG4gICAgICAgIHdpZHRoOiBiYm94ID8gYmJveC53aWR0aCA6IE1hdGguY2VpbChwYXJzZUZsb2F0KGdldFByb3AoXCJ3aWR0aFwiLCBcInB4XCIpKSksXG4gICAgICAgIGhlaWdodDogYmJveCA/IGJib3guaGVpZ2h0IDogcGFyc2VGbG9hdChnZXRQcm9wKFwiaGVpZ2h0XCIsIFwicHhcIikpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNhY2hlLnJvdGF0aW9uID0gcm90YXRpb24gKyBcImRlZ1wiO1xuICAgIGNhY2hlLnNrZXdYID0gc2tld1ggKyBcImRlZ1wiO1xuICB9XG5cbiAgaWYgKHNjYWxlKSB7XG4gICAgc2NhbGVYICo9IHdpZHRoID09PSBkaW1lbnNpb25TdGF0ZS53aWR0aCB8fCAhZGltZW5zaW9uU3RhdGUud2lkdGggPyAxIDogd2lkdGggLyBkaW1lbnNpb25TdGF0ZS53aWR0aDsgLy8gbm90ZSBpZiB3aWR0aHMgYXJlIGJvdGggMCwgd2Ugc2hvdWxkIG1ha2Ugc2NhbGVYIDEgLSBzb21lIGVsZW1lbnRzIGhhdmUgYm94LXNpemluZyB0aGF0IGluY29ycG9yYXRlcyBwYWRkaW5nLCBldGMuIGFuZCB3ZSBkb24ndCB3YW50IGl0IHRvIGNvbGxhcHNlIGluIHRoYXQgY2FzZS5cblxuICAgIHNjYWxlWSAqPSBoZWlnaHQgPT09IGRpbWVuc2lvblN0YXRlLmhlaWdodCB8fCAhZGltZW5zaW9uU3RhdGUuaGVpZ2h0ID8gMSA6IGhlaWdodCAvIGRpbWVuc2lvblN0YXRlLmhlaWdodDtcbiAgICBjYWNoZS5zY2FsZVggPSBzY2FsZVg7XG4gICAgY2FjaGUuc2NhbGVZID0gc2NhbGVZO1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gX2Nsb3Nlc3RUZW50aCh3aWR0aCAqIHNjYWxlWCAvIGRpbWVuc2lvblN0YXRlLnNjYWxlWCwgMCk7XG4gICAgaGVpZ2h0ID0gX2Nsb3Nlc3RUZW50aChoZWlnaHQgKiBzY2FsZVkgLyBkaW1lbnNpb25TdGF0ZS5zY2FsZVksIDApO1xuICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgfSAvLyBpZiAoZnJvbVN0YXRlLmlzRml4ZWQpIHsgLy8gY29tbWVudGVkIG91dCBiZWNhdXNlIGl0J3Mgbm93IHRha2VuIGNhcmUgb2YgaW4gZ2V0R2xvYmFsTWF0cml4KCkgd2l0aCBhIGZsYWcgYXQgdGhlIGVuZC5cbiAgLy8gXHRlIC09IF9nZXREb2NTY3JvbGxMZWZ0KCk7XG4gIC8vIFx0ZiAtPSBfZ2V0RG9jU2Nyb2xsVG9wKCk7XG4gIC8vIH1cblxuXG4gIGFwcGx5UHJvcHMgJiYgX2FwcGx5UHJvcHMoZWxlbWVudCwgdG9TdGF0ZS5wcm9wcyk7XG5cbiAgaWYgKHNpbXBsZSB8fCAhcGFyZW50KSB7XG4gICAgeCArPSBlIC0gZnJvbVN0YXRlLm1hdHJpeC5lO1xuICAgIHkgKz0gZiAtIGZyb21TdGF0ZS5tYXRyaXguZjtcbiAgfSBlbHNlIGlmIChkZWVwIHx8IHBhcmVudCAhPT0gdG9TdGF0ZS5wYXJlbnQpIHtcbiAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0oMSwgY2FjaGUpO1xuICAgIG1hdHJpeCA9IGdldEdsb2JhbE1hdHJpeChmaXRDaGlsZCB8fCBlbGVtZW50LCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgIGZyb21Qb2ludCA9IHBhcmVudE1hdHJpeC5hcHBseSh7XG4gICAgICB4OiBtYXRyaXguZSxcbiAgICAgIHk6IG1hdHJpeC5mXG4gICAgfSk7XG4gICAgdG9Qb2ludCA9IHBhcmVudE1hdHJpeC5hcHBseSh7XG4gICAgICB4OiBlLFxuICAgICAgeTogZlxuICAgIH0pO1xuICAgIHggKz0gdG9Qb2ludC54IC0gZnJvbVBvaW50Lng7XG4gICAgeSArPSB0b1BvaW50LnkgLSBmcm9tUG9pbnQueTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgYSBmYXN0ZXIvY2hlYXBlciBhbGdvcml0aG0gaWYgd2UncmUganVzdCBtb3ZpbmcgeC95XG4gICAgcGFyZW50TWF0cml4LmUgPSBwYXJlbnRNYXRyaXguZiA9IDA7XG4gICAgdG9Qb2ludCA9IHBhcmVudE1hdHJpeC5hcHBseSh7XG4gICAgICB4OiBlIC0gZnJvbVN0YXRlLm1hdHJpeC5lLFxuICAgICAgeTogZiAtIGZyb21TdGF0ZS5tYXRyaXguZlxuICAgIH0pO1xuICAgIHggKz0gdG9Qb2ludC54O1xuICAgIHkgKz0gdG9Qb2ludC55O1xuICB9XG5cbiAgeCA9IF9jbG9zZXN0VGVudGgoeCwgMC4wMik7XG4gIHkgPSBfY2xvc2VzdFRlbnRoKHksIDAuMDIpO1xuXG4gIGlmICh2YXJzICYmICEodmFycyBpbnN0YW5jZW9mIEVsZW1lbnRTdGF0ZSkpIHtcbiAgICAvLyByZXZlcnRcbiAgICBzdHlsZXMgJiYgc3R5bGVzLnJldmVydCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIG9yIGFwcGx5IHRoZSB0cmFuc2Zvcm0gaW1tZWRpYXRlbHlcbiAgICBjYWNoZS54ID0geCArIFwicHhcIjtcbiAgICBjYWNoZS55ID0geSArIFwicHhcIjtcbiAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0oMSwgY2FjaGUpO1xuICB9XG5cbiAgaWYgKHZhcnMpIHtcbiAgICB2YXJzLnggPSB4O1xuICAgIHZhcnMueSA9IHk7XG4gICAgdmFycy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHZhcnMuc2tld1ggPSBza2V3WDtcblxuICAgIGlmIChzY2FsZSkge1xuICAgICAgdmFycy5zY2FsZVggPSBzY2FsZVg7XG4gICAgICB2YXJzLnNjYWxlWSA9IHNjYWxlWTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFycy53aWR0aCA9IHdpZHRoO1xuICAgICAgdmFycy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhcnMgfHwgY2FjaGU7XG59LFxuICAgIF9wYXJzZVN0YXRlID0gZnVuY3Rpb24gX3BhcnNlU3RhdGUodGFyZ2V0c09yU3RhdGUsIHZhcnMpIHtcbiAgcmV0dXJuIHRhcmdldHNPclN0YXRlIGluc3RhbmNlb2YgRmxpcFN0YXRlID8gdGFyZ2V0c09yU3RhdGUgOiBuZXcgRmxpcFN0YXRlKHRhcmdldHNPclN0YXRlLCB2YXJzKTtcbn0sXG4gICAgX2dldENoYW5naW5nRWxTdGF0ZSA9IGZ1bmN0aW9uIF9nZXRDaGFuZ2luZ0VsU3RhdGUodG9TdGF0ZSwgZnJvbVN0YXRlLCBpZCkge1xuICB2YXIgdG8xID0gdG9TdGF0ZS5pZExvb2t1cFtpZF0sXG4gICAgICB0bzIgPSB0b1N0YXRlLmFsdFtpZF07XG4gIHJldHVybiB0bzIuaXNWaXNpYmxlICYmICghKGZyb21TdGF0ZS5nZXRFbGVtZW50U3RhdGUodG8yLmVsZW1lbnQpIHx8IHRvMikuaXNWaXNpYmxlIHx8ICF0bzEuaXNWaXNpYmxlKSA/IHRvMiA6IHRvMTtcbn0sXG4gICAgX2JvZHlNZXRyaWNzID0gW10sXG4gICAgX2JvZHlQcm9wcyA9IFwid2lkdGgsaGVpZ2h0LG92ZXJmbG93WCxvdmVyZmxvd1lcIi5zcGxpdChcIixcIiksXG4gICAgX2JvZHlMb2NrZWQsXG4gICAgX2xvY2tCb2R5U2Nyb2xsID0gZnVuY3Rpb24gX2xvY2tCb2R5U2Nyb2xsKGxvY2spIHtcbiAgLy8gaWYgdGhlcmUncyBubyBzY3JvbGxiYXIsIHdlIHNob3VsZCBsb2NrIHRoYXQgc28gdGhhdCBtZWFzdXJlbWVudHMgZG9uJ3QgZ2V0IGFmZmVjdGVkIGJ5IHRlbXBvcmFyeSByZXBvc2l0aW9uaW5nLCBsaWtlIGlmIHNvbWV0aGluZyBpcyBjZW50ZXJlZCBpbiB0aGUgd2luZG93LlxuICBpZiAobG9jayAhPT0gX2JvZHlMb2NrZWQpIHtcbiAgICB2YXIgcyA9IF9ib2R5LnN0eWxlLFxuICAgICAgICB3ID0gX2JvZHkuY2xpZW50V2lkdGggPT09IHdpbmRvdy5vdXRlcldpZHRoLFxuICAgICAgICBoID0gX2JvZHkuY2xpZW50SGVpZ2h0ID09PSB3aW5kb3cub3V0ZXJIZWlnaHQsXG4gICAgICAgIGkgPSA0O1xuXG4gICAgaWYgKGxvY2sgJiYgKHcgfHwgaCkpIHtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgX2JvZHlNZXRyaWNzW2ldID0gc1tfYm9keVByb3BzW2ldXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcpIHtcbiAgICAgICAgcy53aWR0aCA9IF9ib2R5LmNsaWVudFdpZHRoICsgXCJweFwiO1xuICAgICAgICBzLm92ZXJmbG93WSA9IFwiaGlkZGVuXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChoKSB7XG4gICAgICAgIHMuaGVpZ2h0ID0gX2JvZHkuY2xpZW50SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICBzLm92ZXJmbG93WCA9IFwiaGlkZGVuXCI7XG4gICAgICB9XG5cbiAgICAgIF9ib2R5TG9ja2VkID0gbG9jaztcbiAgICB9IGVsc2UgaWYgKF9ib2R5TG9ja2VkKSB7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIF9ib2R5TWV0cmljc1tpXSA/IHNbX2JvZHlQcm9wc1tpXV0gPSBfYm9keU1ldHJpY3NbaV0gOiBzLnJlbW92ZVByb3BlcnR5KF9jYW1lbFRvRGFzaGVkKF9ib2R5UHJvcHNbaV0pKTtcbiAgICAgIH1cblxuICAgICAgX2JvZHlMb2NrZWQgPSBsb2NrO1xuICAgIH1cbiAgfVxufSxcbiAgICBfZnJvbVRvID0gZnVuY3Rpb24gX2Zyb21Ubyhmcm9tU3RhdGUsIHRvU3RhdGUsIHZhcnMsIHJlbGF0aXZlKSB7XG4gIC8vIHJlbGF0aXZlIGlzIC0xIGlmIFwiZnJvbSgpXCIsIGFuZCAxIGlmIFwidG8oKVwiXG4gIGZyb21TdGF0ZSBpbnN0YW5jZW9mIEZsaXBTdGF0ZSAmJiB0b1N0YXRlIGluc3RhbmNlb2YgRmxpcFN0YXRlIHx8IGNvbnNvbGUud2FybihcIk5vdCBhIHZhbGlkIHN0YXRlIG9iamVjdC5cIik7XG4gIHZhcnMgPSB2YXJzIHx8IHt9O1xuXG4gIHZhciBfdmFycyA9IHZhcnMsXG4gICAgICBjbGVhclByb3BzID0gX3ZhcnMuY2xlYXJQcm9wcyxcbiAgICAgIG9uRW50ZXIgPSBfdmFycy5vbkVudGVyLFxuICAgICAgb25MZWF2ZSA9IF92YXJzLm9uTGVhdmUsXG4gICAgICBhYnNvbHV0ZSA9IF92YXJzLmFic29sdXRlLFxuICAgICAgYWJzb2x1dGVPbkxlYXZlID0gX3ZhcnMuYWJzb2x1dGVPbkxlYXZlLFxuICAgICAgY3VzdG9tID0gX3ZhcnMuY3VzdG9tLFxuICAgICAgZGVsYXkgPSBfdmFycy5kZWxheSxcbiAgICAgIHBhdXNlZCA9IF92YXJzLnBhdXNlZCxcbiAgICAgIHJlcGVhdCA9IF92YXJzLnJlcGVhdCxcbiAgICAgIHJlcGVhdERlbGF5ID0gX3ZhcnMucmVwZWF0RGVsYXksXG4gICAgICB5b3lvID0gX3ZhcnMueW95byxcbiAgICAgIHRvZ2dsZUNsYXNzID0gX3ZhcnMudG9nZ2xlQ2xhc3MsXG4gICAgICBuZXN0ZWQgPSBfdmFycy5uZXN0ZWQsXG4gICAgICBfekluZGV4ID0gX3ZhcnMuekluZGV4LFxuICAgICAgc2NhbGUgPSBfdmFycy5zY2FsZSxcbiAgICAgIGZhZGUgPSBfdmFycy5mYWRlLFxuICAgICAgc3RhZ2dlciA9IF92YXJzLnN0YWdnZXIsXG4gICAgICBzcGluID0gX3ZhcnMuc3BpbixcbiAgICAgIHBydW5lID0gX3ZhcnMucHJ1bmUsXG4gICAgICBwcm9wcyA9IChcInByb3BzXCIgaW4gdmFycyA/IHZhcnMgOiBmcm9tU3RhdGUpLnByb3BzLFxuICAgICAgdHdlZW5WYXJzID0gX2NvcHkodmFycywgX3Jlc2VydmVkKSxcbiAgICAgIGFuaW1hdGlvbiA9IGdzYXAudGltZWxpbmUoe1xuICAgIGRlbGF5OiBkZWxheSxcbiAgICBwYXVzZWQ6IHBhdXNlZCxcbiAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICByZXBlYXREZWxheTogcmVwZWF0RGVsYXksXG4gICAgeW95bzogeW95byxcbiAgICBkYXRhOiBcImlzRmxpcFwiXG4gIH0pLFxuICAgICAgcmVtYWluaW5nUHJvcHMgPSB0d2VlblZhcnMsXG4gICAgICBlbnRlcmluZyA9IFtdLFxuICAgICAgbGVhdmluZyA9IFtdLFxuICAgICAgY29tcHMgPSBbXSxcbiAgICAgIHN3YXBPdXRUYXJnZXRzID0gW10sXG4gICAgICBzcGluTnVtID0gc3BpbiA9PT0gdHJ1ZSA/IDEgOiBzcGluIHx8IDAsXG4gICAgICBzcGluRnVuYyA9IHR5cGVvZiBzcGluID09PSBcImZ1bmN0aW9uXCIgPyBzcGluIDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzcGluTnVtO1xuICB9LFxuICAgICAgaW50ZXJydXB0ZWQgPSBmcm9tU3RhdGUuaW50ZXJydXB0ZWQgfHwgdG9TdGF0ZS5pbnRlcnJ1cHRlZCxcbiAgICAgIGFkZEZ1bmMgPSBhbmltYXRpb25bcmVsYXRpdmUgIT09IDEgPyBcInRvXCIgOiBcImZyb21cIl0sXG4gICAgICB2LFxuICAgICAgcCxcbiAgICAgIGVuZFRpbWUsXG4gICAgICBpLFxuICAgICAgZWwsXG4gICAgICBjb21wLFxuICAgICAgc3RhdGUsXG4gICAgICB0YXJnZXRzLFxuICAgICAgZmluYWxTdGF0ZXMsXG4gICAgICBmcm9tTm9kZSxcbiAgICAgIHRvTm9kZSxcbiAgICAgIHJ1bixcbiAgICAgIGEsXG4gICAgICBiOyAvL3JlbGF0aXZlIHx8ICh0b1N0YXRlID0gKG5ldyBGbGlwU3RhdGUodG9TdGF0ZS50YXJnZXRzLCB7cHJvcHM6IHByb3BzfSkpLmZpdCh0b1N0YXRlLCBzY2FsZSkpO1xuXG5cbiAgZm9yIChwIGluIHRvU3RhdGUuaWRMb29rdXApIHtcbiAgICB0b05vZGUgPSAhdG9TdGF0ZS5hbHRbcF0gPyB0b1N0YXRlLmlkTG9va3VwW3BdIDogX2dldENoYW5naW5nRWxTdGF0ZSh0b1N0YXRlLCBmcm9tU3RhdGUsIHApO1xuICAgIGVsID0gdG9Ob2RlLmVsZW1lbnQ7XG4gICAgZnJvbU5vZGUgPSBmcm9tU3RhdGUuaWRMb29rdXBbcF07XG4gICAgZnJvbVN0YXRlLmFsdFtwXSAmJiBlbCA9PT0gZnJvbU5vZGUuZWxlbWVudCAmJiAoZnJvbVN0YXRlLmFsdFtwXS5pc1Zpc2libGUgfHwgIXRvTm9kZS5pc1Zpc2libGUpICYmIChmcm9tTm9kZSA9IGZyb21TdGF0ZS5hbHRbcF0pO1xuXG4gICAgaWYgKGZyb21Ob2RlKSB7XG4gICAgICBjb21wID0ge1xuICAgICAgICB0OiBlbCxcbiAgICAgICAgYjogZnJvbU5vZGUsXG4gICAgICAgIGE6IHRvTm9kZSxcbiAgICAgICAgc2Q6IGZyb21Ob2RlLmVsZW1lbnQgPT09IGVsID8gMCA6IHRvTm9kZS5pc1Zpc2libGUgPyAxIDogLTFcbiAgICAgIH07XG4gICAgICBjb21wcy5wdXNoKGNvbXApO1xuXG4gICAgICBpZiAoY29tcC5zZCkge1xuICAgICAgICBpZiAoY29tcC5zZCA8IDApIHtcbiAgICAgICAgICBjb21wLmIgPSB0b05vZGU7XG4gICAgICAgICAgY29tcC5hID0gZnJvbU5vZGU7XG4gICAgICAgIH0gLy8gZm9yIHN3YXBwaW5nIGVsZW1lbnRzIHRoYXQgZ290IGludGVycnVwdGVkLCB3ZSBtdXN0IHJlLXJlY29yZCB0aGUgaW5saW5lIHN0eWxlcyB0byBlbnN1cmUgdGhleSdyZSBub3QgdGFpbnRlZC4gUmVtZW1iZXIsIC5iYXRjaCgpIHBlcm1pdHMgZ2V0U3RhdGUoKSBub3QgdG8gZm9yY2UgaW4tcHJvZ3Jlc3MgZmxpcHMgdG8gdGhlaXIgZW5kIHN0YXRlLlxuXG5cbiAgICAgICAgaW50ZXJydXB0ZWQgJiYgX3JlY29yZElubGluZVN0eWxlcyhjb21wLmIsIHByb3BzID8gX21lbW9pemVkUmVtb3ZlUHJvcHNbcHJvcHNdIDogX3JlbW92ZVByb3BzKTtcbiAgICAgICAgZmFkZSAmJiBjb21wcy5wdXNoKGNvbXAuc3dhcCA9IHtcbiAgICAgICAgICB0OiBmcm9tTm9kZS5lbGVtZW50LFxuICAgICAgICAgIGI6IGNvbXAuYixcbiAgICAgICAgICBhOiBjb21wLmEsXG4gICAgICAgICAgc2Q6IC1jb21wLnNkLFxuICAgICAgICAgIHN3YXA6IGNvbXBcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGVsLl9mbGlwID0gZnJvbU5vZGUuZWxlbWVudC5fZmxpcCA9IF9iYXRjaCA/IF9iYXRjaC50aW1lbGluZSA6IGFuaW1hdGlvbjtcbiAgICB9IGVsc2UgaWYgKHRvTm9kZS5pc1Zpc2libGUpIHtcbiAgICAgIGNvbXBzLnB1c2goe1xuICAgICAgICB0OiBlbCxcbiAgICAgICAgYjogX2NvcHkodG9Ob2RlLCB7XG4gICAgICAgICAgaXNWaXNpYmxlOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBhOiB0b05vZGUsXG4gICAgICAgIHNkOiAwLFxuICAgICAgICBlbnRlcmluZzogMVxuICAgICAgfSk7IC8vIHRvIGluY2x1ZGUgaXQgaW4gdGhlIFwiZW50ZXJpbmdcIiBBcnJheSBhbmQgZG8gYWJzb2x1dGUgcG9zaXRpb25pbmcgaWYgbmVjZXNzYXJ5XG5cbiAgICAgIGVsLl9mbGlwID0gX2JhdGNoID8gX2JhdGNoLnRpbWVsaW5lIDogYW5pbWF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHByb3BzICYmIChfbWVtb2l6ZWRQcm9wc1twcm9wc10gfHwgX21lbW9pemVQcm9wcyhwcm9wcykpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gdHdlZW5WYXJzW3BdID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBjb21wc1tpXS5hLnByb3BzW3BdO1xuICAgIH07XG4gIH0pO1xuICBjb21wcy5maW5hbFN0YXRlcyA9IGZpbmFsU3RhdGVzID0gW107XG5cbiAgcnVuID0gZnVuY3Rpb24gcnVuKCkge1xuICAgIF9vcmRlckJ5RE9NRGVwdGgoY29tcHMpO1xuXG4gICAgX2xvY2tCb2R5U2Nyb2xsKHRydWUpOyAvLyBvdGhlcndpc2UsIG1lYXN1cmVtZW50cyBtYXkgZ2V0IHRocm93biBvZmYgd2hlbiB0aGluZ3MgZ2V0IGZpdC5cbiAgICAvLyBUT0RPOiBjYWNoZSB0aGUgbWF0cml4LCBlc3BlY2lhbGx5IGZvciBwYXJlbnQgYmVjYXVzZSBpdCdsbCBwcm9iYWJseSBnZXQgcmV1c2VkIHF1aXRlIGEgYml0LCBidXQgbG9jayBpdCB0byBhIHBhcnRpY3VsYXIgY3ljbGUoPykuXG5cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb21wcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29tcCA9IGNvbXBzW2ldO1xuICAgICAgYSA9IGNvbXAuYTtcbiAgICAgIGIgPSBjb21wLmI7XG5cbiAgICAgIGlmIChwcnVuZSAmJiAhYS5pc0RpZmZlcmVudChiKSAmJiAhY29tcC5lbnRlcmluZykge1xuICAgICAgICAvLyBvbmx5IGZsaXAgaWYgdGhpbmdzIGNoYW5nZWQhIERvbid0IG9taXQgaXQgZnJvbSBjb21wcyBpbml0aWFsbHkgYmVjYXVzZSB0aGF0J2QgcHJldmVudCB0aGUgZWxlbWVudCBmcm9tIGJlaW5nIHBvc2l0aW9uZWQgYWJzb2x1dGVseSAoaWYgbmVjZXNzYXJ5KVxuICAgICAgICBjb21wcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gY29tcC50O1xuICAgICAgICBuZXN0ZWQgJiYgIShjb21wLnNkIDwgMCkgJiYgaSAmJiAoYS5tYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZWwsIGZhbHNlLCBmYWxzZSwgdHJ1ZSkpOyAvLyBtb3ZpbmcgYSBwYXJlbnQgYWZmZWN0cyB0aGUgcG9zaXRpb24gb2YgY2hpbGRyZW5cblxuICAgICAgICBpZiAoYi5pc1Zpc2libGUgJiYgYS5pc1Zpc2libGUpIHtcbiAgICAgICAgICBpZiAoY29tcC5zZCA8IDApIHtcbiAgICAgICAgICAgIC8vIHN3YXBwaW5nIE9VVCAoc3dhcCBkaXJlY3Rpb24gb2YgLTEgaXMgb3V0KVxuICAgICAgICAgICAgc3RhdGUgPSBuZXcgRWxlbWVudFN0YXRlKGVsLCBwcm9wcywgZnJvbVN0YXRlLnNpbXBsZSk7XG5cbiAgICAgICAgICAgIF9maXQoc3RhdGUsIGEsIHNjYWxlLCAwLCAwLCBzdGF0ZSk7XG5cbiAgICAgICAgICAgIHN0YXRlLm1hdHJpeCA9IGdldEdsb2JhbE1hdHJpeChlbCwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIHN0YXRlLmNzcyA9IGNvbXAuYi5jc3M7XG4gICAgICAgICAgICBjb21wLmEgPSBhID0gc3RhdGU7XG4gICAgICAgICAgICBmYWRlICYmIChlbC5zdHlsZS5vcGFjaXR5ID0gaW50ZXJydXB0ZWQgPyBiLm9wYWNpdHkgOiBhLm9wYWNpdHkpO1xuICAgICAgICAgICAgc3RhZ2dlciAmJiBzd2FwT3V0VGFyZ2V0cy5wdXNoKGVsKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbXAuc2QgPiAwICYmIGZhZGUpIHtcbiAgICAgICAgICAgIC8vIHN3YXBwaW5nIElOIChzd2FwIGRpcmVjdGlvbiBvZiAxIGlzIGluKVxuICAgICAgICAgICAgZWwuc3R5bGUub3BhY2l0eSA9IGludGVycnVwdGVkID8gYS5vcGFjaXR5IC0gYi5vcGFjaXR5IDogXCIwXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2ZpdChhLCBiLCBzY2FsZSwgcHJvcHMpO1xuICAgICAgICB9IGVsc2UgaWYgKGIuaXNWaXNpYmxlICE9PSBhLmlzVmlzaWJsZSkge1xuICAgICAgICAgIC8vIGVpdGhlciBlbnRlcmluZyBvciBsZWF2aW5nIChvbmUgc2lkZSBpcyBpbnZpc2libGUpXG4gICAgICAgICAgaWYgKCFiLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgLy8gZW50ZXJpbmdcbiAgICAgICAgICAgIGEuaXNWaXNpYmxlICYmIGVudGVyaW5nLnB1c2goYSk7XG4gICAgICAgICAgICBjb21wcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFhLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgLy8gbGVhdmluZ1xuICAgICAgICAgICAgYi5jc3MgPSBhLmNzcztcbiAgICAgICAgICAgIGxlYXZpbmcucHVzaChiKTtcbiAgICAgICAgICAgIGNvbXBzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgYWJzb2x1dGUgJiYgbmVzdGVkICYmIF9maXQoYSwgYiwgc2NhbGUsIHByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNjYWxlKSB7XG4gICAgICAgICAgZWwuc3R5bGUubWF4V2lkdGggPSBNYXRoLm1heChhLndpZHRoLCBiLndpZHRoKSArIFwicHhcIjtcbiAgICAgICAgICBlbC5zdHlsZS5tYXhIZWlnaHQgPSBNYXRoLm1heChhLmhlaWdodCwgYi5oZWlnaHQpICsgXCJweFwiO1xuICAgICAgICAgIGVsLnN0eWxlLm1pbldpZHRoID0gTWF0aC5taW4oYS53aWR0aCwgYi53aWR0aCkgKyBcInB4XCI7XG4gICAgICAgICAgZWwuc3R5bGUubWluSGVpZ2h0ID0gTWF0aC5taW4oYS5oZWlnaHQsIGIuaGVpZ2h0KSArIFwicHhcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5lc3RlZCAmJiB0b2dnbGVDbGFzcyAmJiBlbC5jbGFzc0xpc3QuYWRkKHRvZ2dsZUNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgZmluYWxTdGF0ZXMucHVzaChhKTtcbiAgICB9XG5cbiAgICB2YXIgY2xhc3NUYXJnZXRzO1xuXG4gICAgaWYgKHRvZ2dsZUNsYXNzKSB7XG4gICAgICBjbGFzc1RhcmdldHMgPSBmaW5hbFN0YXRlcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHMuZWxlbWVudDtcbiAgICAgIH0pO1xuICAgICAgbmVzdGVkICYmIGNsYXNzVGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLmNsYXNzTGlzdC5yZW1vdmUodG9nZ2xlQ2xhc3MpO1xuICAgICAgfSk7IC8vIHRoZXJlIGNvdWxkIGJlIGEgZGVsYXksIHNvIGRvbid0IGxlYXZlIHRoZSBjbGFzc2VzIGFwcGxpZWQgKHdlJ2xsIGRvIGl0IGluIGEgdGltZWxpbmUgY2FsbGJhY2spXG4gICAgfVxuXG4gICAgX2xvY2tCb2R5U2Nyb2xsKGZhbHNlKTtcblxuICAgIGlmIChzY2FsZSkge1xuICAgICAgdHdlZW5WYXJzLnNjYWxlWCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBjb21wc1tpXS5hLnNjYWxlWDtcbiAgICAgIH07XG5cbiAgICAgIHR3ZWVuVmFycy5zY2FsZVkgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gY29tcHNbaV0uYS5zY2FsZVk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0d2VlblZhcnMud2lkdGggPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gY29tcHNbaV0uYS53aWR0aCArIFwicHhcIjtcbiAgICAgIH07XG5cbiAgICAgIHR3ZWVuVmFycy5oZWlnaHQgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gY29tcHNbaV0uYS5oZWlnaHQgKyBcInB4XCI7XG4gICAgICB9O1xuXG4gICAgICB0d2VlblZhcnMuYXV0b1JvdW5kID0gdmFycy5hdXRvUm91bmQgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgdHdlZW5WYXJzLnggPSBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGNvbXBzW2ldLmEueCArIFwicHhcIjtcbiAgICB9O1xuXG4gICAgdHdlZW5WYXJzLnkgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGNvbXBzW2ldLmEueSArIFwicHhcIjtcbiAgICB9O1xuXG4gICAgdHdlZW5WYXJzLnJvdGF0aW9uID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBjb21wc1tpXS5hLnJvdGF0aW9uICsgKHNwaW4gPyBzcGluRnVuYyhpLCB0YXJnZXRzW2ldLCB0YXJnZXRzKSAqIDM2MCA6IDApO1xuICAgIH07XG5cbiAgICB0d2VlblZhcnMuc2tld1ggPSBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGNvbXBzW2ldLmEuc2tld1g7XG4gICAgfTtcblxuICAgIHRhcmdldHMgPSBjb21wcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjLnQ7XG4gICAgfSk7XG5cbiAgICBpZiAoX3pJbmRleCB8fCBfekluZGV4ID09PSAwKSB7XG4gICAgICB0d2VlblZhcnMubW9kaWZpZXJzID0ge1xuICAgICAgICB6SW5kZXg6IGZ1bmN0aW9uIHpJbmRleCgpIHtcbiAgICAgICAgICByZXR1cm4gX3pJbmRleDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHR3ZWVuVmFycy56SW5kZXggPSBfekluZGV4O1xuICAgICAgdHdlZW5WYXJzLmltbWVkaWF0ZVJlbmRlciA9IHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZTtcbiAgICB9XG5cbiAgICBmYWRlICYmICh0d2VlblZhcnMub3BhY2l0eSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gY29tcHNbaV0uc2QgPCAwID8gMCA6IGNvbXBzW2ldLnNkID4gMCA/IGNvbXBzW2ldLmEub3BhY2l0eSA6IFwiKz0wXCI7XG4gICAgfSk7XG5cbiAgICBpZiAoc3dhcE91dFRhcmdldHMubGVuZ3RoKSB7XG4gICAgICBzdGFnZ2VyID0gZ3NhcC51dGlscy5kaXN0cmlidXRlKHN0YWdnZXIpO1xuICAgICAgdmFyIGR1bW15QXJyYXkgPSB0YXJnZXRzLnNsaWNlKHN3YXBPdXRUYXJnZXRzLmxlbmd0aCk7XG5cbiAgICAgIHR3ZWVuVmFycy5zdGFnZ2VyID0gZnVuY3Rpb24gKGksIGVsKSB7XG4gICAgICAgIHJldHVybiBzdGFnZ2VyKH5zd2FwT3V0VGFyZ2V0cy5pbmRleE9mKGVsKSA/IHRhcmdldHMuaW5kZXhPZihjb21wc1tpXS5zd2FwLnQpIDogaSwgZWwsIGR1bW15QXJyYXkpO1xuICAgICAgfTtcbiAgICB9IC8vIC8vIGZvciB0ZXN0aW5nLi4uXG4gICAgLy8gZ3NhcC5kZWxheWVkQ2FsbCh2YXJzLmRhdGEgPyA1MCA6IDEsIGZ1bmN0aW9uKCkge1xuICAgIC8vIFx0YW5pbWF0aW9uLmV2ZW50Q2FsbGJhY2soXCJvbkNvbXBsZXRlXCIsICgpID0+IF9zZXRGaW5hbFN0YXRlcyhjb21wcywgIWNsZWFyUHJvcHMpKTtcbiAgICAvLyBcdGFkZEZ1bmMuY2FsbChhbmltYXRpb24sIHRhcmdldHMsIHR3ZWVuVmFycywgMCkucGxheSgpO1xuICAgIC8vIH0pO1xuICAgIC8vIHJldHVybjtcblxuXG4gICAgX2NhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gdmFyc1tuYW1lXSAmJiBhbmltYXRpb24uZXZlbnRDYWxsYmFjayhuYW1lLCB2YXJzW25hbWVdLCB2YXJzW25hbWUgKyBcIlBhcmFtc1wiXSk7XG4gICAgfSk7IC8vIGFwcGx5IGNhbGxiYWNrcyB0byB0aGUgdGltZWxpbmUsIG5vdCB0d2VlbnMgKGJlY2F1c2UgXCJjdXN0b21cIiB0aW1pbmcgY2FuIG1ha2UgbXVsdGlwbGUgdHdlZW5zKVxuXG5cbiAgICBpZiAoY3VzdG9tICYmIHRhcmdldHMubGVuZ3RoKSB7XG4gICAgICAvLyBidXN0IG91dCB0aGUgY3VzdG9tIHByb3BlcnRpZXMgYXMgdGhlaXIgb3duIHR3ZWVucyBzbyB0aGV5IGNhbiB1c2UgZGlmZmVyZW50IGVhc2VzLCBkdXJhdGlvbnMsIGV0Yy5cbiAgICAgIHJlbWFpbmluZ1Byb3BzID0gX2NvcHkodHdlZW5WYXJzLCBfcmVzZXJ2ZWQpO1xuXG4gICAgICBpZiAoXCJzY2FsZVwiIGluIGN1c3RvbSkge1xuICAgICAgICBjdXN0b20uc2NhbGVYID0gY3VzdG9tLnNjYWxlWSA9IGN1c3RvbS5zY2FsZTtcbiAgICAgICAgZGVsZXRlIGN1c3RvbS5zY2FsZTtcbiAgICAgIH1cblxuICAgICAgZm9yIChwIGluIGN1c3RvbSkge1xuICAgICAgICB2ID0gX2NvcHkoY3VzdG9tW3BdLCBfZml0UmVzZXJ2ZWQpO1xuICAgICAgICB2W3BdID0gdHdlZW5WYXJzW3BdO1xuICAgICAgICAhKFwiZHVyYXRpb25cIiBpbiB2KSAmJiBcImR1cmF0aW9uXCIgaW4gdHdlZW5WYXJzICYmICh2LmR1cmF0aW9uID0gdHdlZW5WYXJzLmR1cmF0aW9uKTtcbiAgICAgICAgdi5zdGFnZ2VyID0gdHdlZW5WYXJzLnN0YWdnZXI7XG4gICAgICAgIGFkZEZ1bmMuY2FsbChhbmltYXRpb24sIHRhcmdldHMsIHYsIDApO1xuICAgICAgICBkZWxldGUgcmVtYWluaW5nUHJvcHNbcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldHMubGVuZ3RoIHx8IGxlYXZpbmcubGVuZ3RoIHx8IGVudGVyaW5nLmxlbmd0aCkge1xuICAgICAgdG9nZ2xlQ2xhc3MgJiYgYW5pbWF0aW9uLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdG9nZ2xlQ2xhc3MoY2xhc3NUYXJnZXRzLCB0b2dnbGVDbGFzcywgYW5pbWF0aW9uLl96VGltZSA8IDAgPyBcInJlbW92ZVwiIDogXCJhZGRcIik7XG4gICAgICB9LCAwKSAmJiAhcGF1c2VkICYmIF90b2dnbGVDbGFzcyhjbGFzc1RhcmdldHMsIHRvZ2dsZUNsYXNzLCBcImFkZFwiKTtcbiAgICAgIHRhcmdldHMubGVuZ3RoICYmIGFkZEZ1bmMuY2FsbChhbmltYXRpb24sIHRhcmdldHMsIHJlbWFpbmluZ1Byb3BzLCAwKTtcbiAgICB9XG5cbiAgICBfaGFuZGxlQ2FsbGJhY2sob25FbnRlciwgZW50ZXJpbmcsIGFuaW1hdGlvbik7XG5cbiAgICBfaGFuZGxlQ2FsbGJhY2sob25MZWF2ZSwgbGVhdmluZywgYW5pbWF0aW9uKTtcblxuICAgIHZhciBiYXRjaFRsID0gX2JhdGNoICYmIF9iYXRjaC50aW1lbGluZTtcblxuICAgIGlmIChiYXRjaFRsKSB7XG4gICAgICBiYXRjaFRsLmFkZChhbmltYXRpb24sIDApO1xuXG4gICAgICBfYmF0Y2guX2ZpbmFsLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3NldEZpbmFsU3RhdGVzKGNvbXBzLCAhY2xlYXJQcm9wcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBlbmRUaW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uKCk7XG4gICAgYW5pbWF0aW9uLmNhbGwoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZvcndhcmQgPSBhbmltYXRpb24udGltZSgpID49IGVuZFRpbWU7XG4gICAgICBmb3J3YXJkICYmICFiYXRjaFRsICYmIF9zZXRGaW5hbFN0YXRlcyhjb21wcywgIWNsZWFyUHJvcHMpO1xuICAgICAgdG9nZ2xlQ2xhc3MgJiYgX3RvZ2dsZUNsYXNzKGNsYXNzVGFyZ2V0cywgdG9nZ2xlQ2xhc3MsIGZvcndhcmQgPyBcInJlbW92ZVwiIDogXCJhZGRcIik7XG4gICAgfSk7XG4gIH07XG5cbiAgYWJzb2x1dGVPbkxlYXZlICYmIChhYnNvbHV0ZSA9IGNvbXBzLmZpbHRlcihmdW5jdGlvbiAoY29tcCkge1xuICAgIHJldHVybiAhY29tcC5zZCAmJiAhY29tcC5hLmlzVmlzaWJsZSAmJiBjb21wLmIuaXNWaXNpYmxlO1xuICB9KS5tYXAoZnVuY3Rpb24gKGNvbXApIHtcbiAgICByZXR1cm4gY29tcC5hLmVsZW1lbnQ7XG4gIH0pKTtcblxuICBpZiAoX2JhdGNoKSB7XG4gICAgdmFyIF9iYXRjaCRfYWJzO1xuXG4gICAgYWJzb2x1dGUgJiYgKF9iYXRjaCRfYWJzID0gX2JhdGNoLl9hYnMpLnB1c2guYXBwbHkoX2JhdGNoJF9hYnMsIF9maWx0ZXJDb21wcyhjb21wcywgYWJzb2x1dGUpKTtcblxuICAgIF9iYXRjaC5fcnVuLnB1c2gocnVuKTtcbiAgfSBlbHNlIHtcbiAgICBhYnNvbHV0ZSAmJiBfbWFrZUNvbXBzQWJzb2x1dGUoX2ZpbHRlckNvbXBzKGNvbXBzLCBhYnNvbHV0ZSkpOyAvLyB3aGVuIG1ha2luZyBhYnNvbHV0ZSwgd2UgbXVzdCBnbyBpbiBhIHZlcnkgcGFydGljdWxhciBvcmRlciBzbyB0aGF0IGRvY3VtZW50IGZsb3cgY2hhbmdlcyBkb24ndCBhZmZlY3QgdGhpbmdzLiBEb24ndCBtYWtlIGl0IHZpc2libGUgaWYgYm90aCB0aGUgYmVmb3JlIGFuZCBhZnRlciBzdGF0ZXMgYXJlIGludmlzaWJsZSEgVGhlcmUncyBubyBwb2ludCwgYW5kIGl0IGNvdWxkIG1ha2UgdGhpbmdzIGFwcGVhciB2aXNpYmxlIGR1cmluZyB0aGUgZmxpcCB0aGF0IHNob3VsZG4ndCBiZS5cblxuICAgIHJ1bigpO1xuICB9XG5cbiAgdmFyIGFuaW0gPSBfYmF0Y2ggPyBfYmF0Y2gudGltZWxpbmUgOiBhbmltYXRpb247XG5cbiAgYW5pbS5yZXZlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9raWxsRmxpcChhbmltLCAxLCAxKTtcbiAgfTsgLy8gYSBGbGlwIHRpbWVsaW5lIHNob3VsZCBiZWhhdmUgdmVyeSBkaWZmZXJlbnQgd2hlbiByZXZlcnRpbmcgLSBpdCBzaG91bGQgYWN0dWFsbHkganVtcCB0byB0aGUgZW5kIHNvIHRoYXQgc3R5bGVzIGdldCBjbGVhcmVkIG91dC5cblxuXG4gIHJldHVybiBhbmltO1xufSxcbiAgICBfaW50ZXJydXB0ID0gZnVuY3Rpb24gX2ludGVycnVwdCh0bCkge1xuICB0bC52YXJzLm9uSW50ZXJydXB0ICYmIHRsLnZhcnMub25JbnRlcnJ1cHQuYXBwbHkodGwsIHRsLnZhcnMub25JbnRlcnJ1cHRQYXJhbXMgfHwgW10pO1xuICB0bC5nZXRDaGlsZHJlbih0cnVlLCBmYWxzZSwgdHJ1ZSkuZm9yRWFjaChfaW50ZXJydXB0KTtcbn0sXG4gICAgX2tpbGxGbGlwID0gZnVuY3Rpb24gX2tpbGxGbGlwKHRsLCBhY3Rpb24sIGZvcmNlKSB7XG4gIC8vIGFjdGlvbjogMCA9IG5vdGhpbmcsIDEgPSBjb21wbGV0ZSwgMiA9IG9ubHkga2lsbCAoZG9uJ3QgY29tcGxldGUpXG4gIGlmICh0bCAmJiB0bC5wcm9ncmVzcygpIDwgMSAmJiAoIXRsLnBhdXNlZCgpIHx8IGZvcmNlKSkge1xuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgIF9pbnRlcnJ1cHQodGwpO1xuXG4gICAgICBhY3Rpb24gPCAyICYmIHRsLnByb2dyZXNzKDEpOyAvLyB3ZSBzaG91bGQgYWxzbyBraWxsIGl0IGluIGNhc2UgaXQgd2FzIGFkZGVkIHRvIGEgcGFyZW50IHRpbWVsaW5lLlxuXG4gICAgICB0bC5raWxsKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0sXG4gICAgX2NyZWF0ZUxvb2t1cCA9IGZ1bmN0aW9uIF9jcmVhdGVMb29rdXAoc3RhdGUpIHtcbiAgdmFyIGxvb2t1cCA9IHN0YXRlLmlkTG9va3VwID0ge30sXG4gICAgICBhbHQgPSBzdGF0ZS5hbHQgPSB7fSxcbiAgICAgIGVsU3RhdGVzID0gc3RhdGUuZWxlbWVudFN0YXRlcyxcbiAgICAgIGkgPSBlbFN0YXRlcy5sZW5ndGgsXG4gICAgICBlbFN0YXRlO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBlbFN0YXRlID0gZWxTdGF0ZXNbaV07XG4gICAgbG9va3VwW2VsU3RhdGUuaWRdID8gYWx0W2VsU3RhdGUuaWRdID0gZWxTdGF0ZSA6IGxvb2t1cFtlbFN0YXRlLmlkXSA9IGVsU3RhdGU7XG4gIH1cbn07XG5cbnZhciBGbGlwU3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGbGlwU3RhdGUodGFyZ2V0cywgdmFycywgdGFyZ2V0c0FyZUVsZW1lbnRTdGF0ZXMpIHtcbiAgICB0aGlzLnByb3BzID0gdmFycyAmJiB2YXJzLnByb3BzO1xuICAgIHRoaXMuc2ltcGxlID0gISEodmFycyAmJiB2YXJzLnNpbXBsZSk7XG5cbiAgICBpZiAodGFyZ2V0c0FyZUVsZW1lbnRTdGF0ZXMpIHtcbiAgICAgIHRoaXMudGFyZ2V0cyA9IF9lbGVtZW50c0Zyb21FbGVtZW50U3RhdGVzKHRhcmdldHMpO1xuICAgICAgdGhpcy5lbGVtZW50U3RhdGVzID0gdGFyZ2V0cztcblxuICAgICAgX2NyZWF0ZUxvb2t1cCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YXJnZXRzID0gX3RvQXJyYXkodGFyZ2V0cyk7XG4gICAgICB2YXIgc29mdCA9IHZhcnMgJiYgKHZhcnMua2lsbCA9PT0gZmFsc2UgfHwgdmFycy5iYXRjaCAmJiAhdmFycy5raWxsKTtcbiAgICAgIF9iYXRjaCAmJiAhc29mdCAmJiBfYmF0Y2guX2tpbGwucHVzaCh0aGlzKTtcbiAgICAgIHRoaXMudXBkYXRlKHNvZnQgfHwgISFfYmF0Y2gpOyAvLyB3aGVuIGJhdGNoaW5nLCBkb24ndCBmb3JjZSBpbi1wcm9ncmVzcyBmbGlwcyB0byB0aGVpciBlbmQ7IHdlIG5lZWQgdG8gZG8gdGhhdCBBRlRFUiBhbGwgZ2V0U3RhdGVzKCkgYXJlIGNhbGxlZC5cbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRmxpcFN0YXRlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNvZnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5lbGVtZW50U3RhdGVzID0gdGhpcy50YXJnZXRzLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBuZXcgRWxlbWVudFN0YXRlKGVsLCBfdGhpcy5wcm9wcywgX3RoaXMuc2ltcGxlKTtcbiAgICB9KTtcblxuICAgIF9jcmVhdGVMb29rdXAodGhpcyk7XG5cbiAgICB0aGlzLmludGVycnVwdChzb2Z0KTtcbiAgICB0aGlzLnJlY29yZElubGluZVN0eWxlcygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMudGFyZ2V0cy5sZW5ndGggPSB0aGlzLmVsZW1lbnRTdGF0ZXMubGVuZ3RoID0gMDtcblxuICAgIF9jcmVhdGVMb29rdXAodGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZml0ID0gZnVuY3Rpb24gZml0KHN0YXRlLCBzY2FsZSwgbmVzdGVkKSB7XG4gICAgdmFyIGVsU3RhdGVzSW5PcmRlciA9IF9vcmRlckJ5RE9NRGVwdGgodGhpcy5lbGVtZW50U3RhdGVzLnNsaWNlKDApLCBmYWxzZSwgdHJ1ZSksXG4gICAgICAgIHRvRWxTdGF0ZXMgPSAoc3RhdGUgfHwgdGhpcykuaWRMb29rdXAsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBmcm9tTm9kZSxcbiAgICAgICAgdG9Ob2RlO1xuXG4gICAgZm9yICg7IGkgPCBlbFN0YXRlc0luT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZyb21Ob2RlID0gZWxTdGF0ZXNJbk9yZGVyW2ldO1xuICAgICAgbmVzdGVkICYmIChmcm9tTm9kZS5tYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZnJvbU5vZGUuZWxlbWVudCwgZmFsc2UsIGZhbHNlLCB0cnVlKSk7IC8vIG1vdmluZyBhIHBhcmVudCBhZmZlY3RzIHRoZSBwb3NpdGlvbiBvZiBjaGlsZHJlblxuXG4gICAgICB0b05vZGUgPSB0b0VsU3RhdGVzW2Zyb21Ob2RlLmlkXTtcbiAgICAgIHRvTm9kZSAmJiBfZml0KGZyb21Ob2RlLCB0b05vZGUsIHNjYWxlLCB0cnVlLCAwLCBmcm9tTm9kZSk7XG4gICAgICBmcm9tTm9kZS5tYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZnJvbU5vZGUuZWxlbWVudCwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICAgIHZhciBlcyA9IHRoaXMuZ2V0RWxlbWVudFN0YXRlKGVsZW1lbnQpIHx8IF9lbXB0eU9iajtcblxuICAgIHJldHVybiAocHJvcGVydHkgaW4gZXMgPyBlcyA6IGVzLnByb3BzIHx8IF9lbXB0eU9iailbcHJvcGVydHldO1xuICB9O1xuXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQoc3RhdGUpIHtcbiAgICB2YXIgaSA9IHN0YXRlLnRhcmdldHMubGVuZ3RoLFxuICAgICAgICBsb29rdXAgPSB0aGlzLmlkTG9va3VwLFxuICAgICAgICBhbHQgPSB0aGlzLmFsdCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGVzLFxuICAgICAgICBlczI7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBlcyA9IHN0YXRlLmVsZW1lbnRTdGF0ZXNbaV07XG4gICAgICBlczIgPSBsb29rdXBbZXMuaWRdO1xuXG4gICAgICBpZiAoZXMyICYmIChlcy5lbGVtZW50ID09PSBlczIuZWxlbWVudCB8fCBhbHRbZXMuaWRdICYmIGFsdFtlcy5pZF0uZWxlbWVudCA9PT0gZXMuZWxlbWVudCkpIHtcbiAgICAgICAgLy8gaWYgdGhlIGZsaXAgaWQgaXMgYWxyZWFkeSBpbiB0aGlzIEZsaXBTdGF0ZSwgcmVwbGFjZSBpdCFcbiAgICAgICAgaW5kZXggPSB0aGlzLmVsZW1lbnRTdGF0ZXMuaW5kZXhPZihlcy5lbGVtZW50ID09PSBlczIuZWxlbWVudCA/IGVzMiA6IGFsdFtlcy5pZF0pO1xuICAgICAgICB0aGlzLnRhcmdldHMuc3BsaWNlKGluZGV4LCAxLCBzdGF0ZS50YXJnZXRzW2ldKTtcbiAgICAgICAgdGhpcy5lbGVtZW50U3RhdGVzLnNwbGljZShpbmRleCwgMSwgZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50YXJnZXRzLnB1c2goc3RhdGUudGFyZ2V0c1tpXSk7XG4gICAgICAgIHRoaXMuZWxlbWVudFN0YXRlcy5wdXNoKGVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5pbnRlcnJ1cHRlZCAmJiAodGhpcy5pbnRlcnJ1cHRlZCA9IHRydWUpO1xuICAgIHN0YXRlLnNpbXBsZSB8fCAodGhpcy5zaW1wbGUgPSBmYWxzZSk7XG5cbiAgICBfY3JlYXRlTG9va3VwKHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKHN0YXRlKSB7XG4gICAgdmFyIGwxID0gc3RhdGUuaWRMb29rdXAsXG4gICAgICAgIGwyID0gdGhpcy5pZExvb2t1cCxcbiAgICAgICAgdW5jaGFuZ2VkID0gW10sXG4gICAgICAgIGNoYW5nZWQgPSBbXSxcbiAgICAgICAgZW50ZXIgPSBbXSxcbiAgICAgICAgbGVhdmUgPSBbXSxcbiAgICAgICAgdGFyZ2V0cyA9IFtdLFxuICAgICAgICBhMSA9IHN0YXRlLmFsdCxcbiAgICAgICAgYTIgPSB0aGlzLmFsdCxcbiAgICAgICAgcGxhY2UgPSBmdW5jdGlvbiBwbGFjZShzMSwgczIsIGVsKSB7XG4gICAgICByZXR1cm4gKHMxLmlzVmlzaWJsZSAhPT0gczIuaXNWaXNpYmxlID8gczEuaXNWaXNpYmxlID8gZW50ZXIgOiBsZWF2ZSA6IHMxLmlzVmlzaWJsZSA/IGNoYW5nZWQgOiB1bmNoYW5nZWQpLnB1c2goZWwpICYmIHRhcmdldHMucHVzaChlbCk7XG4gICAgfSxcbiAgICAgICAgcGxhY2VJZkRvZXNOb3RFeGlzdCA9IGZ1bmN0aW9uIHBsYWNlSWZEb2VzTm90RXhpc3QoczEsIHMyLCBlbCkge1xuICAgICAgcmV0dXJuIHRhcmdldHMuaW5kZXhPZihlbCkgPCAwICYmIHBsYWNlKHMxLCBzMiwgZWwpO1xuICAgIH0sXG4gICAgICAgIHMxLFxuICAgICAgICBzMixcbiAgICAgICAgcCxcbiAgICAgICAgZWwsXG4gICAgICAgIHMxQWx0LFxuICAgICAgICBzMkFsdCxcbiAgICAgICAgYzEsXG4gICAgICAgIGMyO1xuXG4gICAgZm9yIChwIGluIGwxKSB7XG4gICAgICBzMUFsdCA9IGExW3BdO1xuICAgICAgczJBbHQgPSBhMltwXTtcbiAgICAgIHMxID0gIXMxQWx0ID8gbDFbcF0gOiBfZ2V0Q2hhbmdpbmdFbFN0YXRlKHN0YXRlLCB0aGlzLCBwKTtcbiAgICAgIGVsID0gczEuZWxlbWVudDtcbiAgICAgIHMyID0gbDJbcF07XG5cbiAgICAgIGlmIChzMkFsdCkge1xuICAgICAgICBjMiA9IHMyLmlzVmlzaWJsZSB8fCAhczJBbHQuaXNWaXNpYmxlICYmIGVsID09PSBzMi5lbGVtZW50ID8gczIgOiBzMkFsdDtcbiAgICAgICAgYzEgPSBzMUFsdCAmJiAhczEuaXNWaXNpYmxlICYmICFzMUFsdC5pc1Zpc2libGUgJiYgYzIuZWxlbWVudCA9PT0gczFBbHQuZWxlbWVudCA/IHMxQWx0IDogczE7IC8vYzEuZWxlbWVudCAhPT0gYzIuZWxlbWVudCAmJiBjMS5lbGVtZW50ID09PSBzMi5lbGVtZW50ICYmIChjMiA9IHMyKTtcblxuICAgICAgICBpZiAoYzEuaXNWaXNpYmxlICYmIGMyLmlzVmlzaWJsZSAmJiBjMS5lbGVtZW50ICE9PSBjMi5lbGVtZW50KSB7XG4gICAgICAgICAgLy8gc3dhcHBpbmcsIHNvIGZvcmNlIGludG8gXCJjaGFuZ2VkXCIgYXJyYXlcbiAgICAgICAgICAoYzEuaXNEaWZmZXJlbnQoYzIpID8gY2hhbmdlZCA6IHVuY2hhbmdlZCkucHVzaChjMS5lbGVtZW50LCBjMi5lbGVtZW50KTtcbiAgICAgICAgICB0YXJnZXRzLnB1c2goYzEuZWxlbWVudCwgYzIuZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGxhY2UoYzEsIGMyLCBjMS5lbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHMxQWx0ICYmIGMxLmVsZW1lbnQgPT09IHMxQWx0LmVsZW1lbnQgJiYgKHMxQWx0ID0gbDFbcF0pO1xuICAgICAgICBwbGFjZUlmRG9lc05vdEV4aXN0KGMxLmVsZW1lbnQgIT09IHMyLmVsZW1lbnQgJiYgczFBbHQgPyBzMUFsdCA6IGMxLCBzMiwgczIuZWxlbWVudCk7XG4gICAgICAgIHBsYWNlSWZEb2VzTm90RXhpc3QoczFBbHQgJiYgczFBbHQuZWxlbWVudCA9PT0gczJBbHQuZWxlbWVudCA/IHMxQWx0IDogYzEsIHMyQWx0LCBzMkFsdC5lbGVtZW50KTtcbiAgICAgICAgczFBbHQgJiYgcGxhY2VJZkRvZXNOb3RFeGlzdChzMUFsdCwgczJBbHQuZWxlbWVudCA9PT0gczFBbHQuZWxlbWVudCA/IHMyQWx0IDogczIsIHMxQWx0LmVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIXMyID8gZW50ZXIucHVzaChlbCkgOiAhczIuaXNEaWZmZXJlbnQoczEpID8gdW5jaGFuZ2VkLnB1c2goZWwpIDogcGxhY2UoczEsIHMyLCBlbCk7XG4gICAgICAgIHMxQWx0ICYmIHBsYWNlSWZEb2VzTm90RXhpc3QoczFBbHQsIHMyLCBzMUFsdC5lbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHAgaW4gbDIpIHtcbiAgICAgIGlmICghbDFbcF0pIHtcbiAgICAgICAgbGVhdmUucHVzaChsMltwXS5lbGVtZW50KTtcbiAgICAgICAgYTJbcF0gJiYgbGVhdmUucHVzaChhMltwXS5lbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2hhbmdlZDogY2hhbmdlZCxcbiAgICAgIHVuY2hhbmdlZDogdW5jaGFuZ2VkLFxuICAgICAgZW50ZXI6IGVudGVyLFxuICAgICAgbGVhdmU6IGxlYXZlXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8ucmVjb3JkSW5saW5lU3R5bGVzID0gZnVuY3Rpb24gcmVjb3JkSW5saW5lU3R5bGVzKCkge1xuICAgIHZhciBwcm9wcyA9IF9tZW1vaXplZFJlbW92ZVByb3BzW3RoaXMucHJvcHNdIHx8IF9yZW1vdmVQcm9wcyxcbiAgICAgICAgaSA9IHRoaXMuZWxlbWVudFN0YXRlcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBfcmVjb3JkSW5saW5lU3R5bGVzKHRoaXMuZWxlbWVudFN0YXRlc1tpXSwgcHJvcHMpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaW50ZXJydXB0ID0gZnVuY3Rpb24gaW50ZXJydXB0KHNvZnQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIC8vIHNvZnQgPSBET04nVCBmb3JjZSBpbi1wcm9ncmVzcyBmbGlwIGFuaW1hdGlvbnMgdG8gY29tcGxldGlvbiAobGlrZSB3aGVuIHJ1bm5pbmcgYSBiYXRjaCwgd2UgY2FuJ3QgaW1tZWRpYXRlbHkga2lsbCBmbGlwcyB3aGVuIGdldHRpbmcgc3RhdGVzIGJlY2F1c2UgaXQgY291bGQgY29udGFtaW5hdGUgcG9zaXRpb25pbmcgYW5kIG90aGVyIC5nZXRTdGF0ZSgpIGNhbGxzIHRoYXQgd2lsbCBydW4gaW4gdGhlIGJhdGNoICh3ZSBraWxsIEFGVEVSIGFsbCB0aGUgLmdldFN0YXRlKCkgY2FsbHMgY29tcGxldGUpLlxuICAgIHZhciB0aW1lbGluZXMgPSBbXTtcbiAgICB0aGlzLnRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIHRsID0gdC5fZmxpcCxcbiAgICAgICAgICBmb3VuZEluUHJvZ3Jlc3MgPSBfa2lsbEZsaXAodGwsIHNvZnQgPyAwIDogMSk7XG5cbiAgICAgIHNvZnQgJiYgZm91bmRJblByb2dyZXNzICYmIHRpbWVsaW5lcy5pbmRleE9mKHRsKSA8IDAgJiYgdGwuYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgICB9KTtcbiAgICAgIGZvdW5kSW5Qcm9ncmVzcyAmJiB0aW1lbGluZXMucHVzaCh0bCk7XG4gICAgfSk7XG4gICAgIXNvZnQgJiYgdGltZWxpbmVzLmxlbmd0aCAmJiB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTsgLy8gaWYgd2UgZm91bmQgYW4gaW4tcHJvZ3Jlc3MgRmxpcCBhbmltYXRpb24sIHdlIG11c3QgcmVjb3JkIGFsbCB0aGUgdmFsdWVzIGluIHRoZWlyIGN1cnJlbnQgc3RhdGUgYXQgdGhhdCBwb2ludCBCVVQgd2Ugc2hvdWxkIHVwZGF0ZSB0aGUgaXNWaXNpYmxlIHZhbHVlIEFGVEVSIHB1c2hpbmcgdGhhdCBmbGlwIHRvIGNvbXBsZXRpb24gc28gdGhhdCBlbGVtZW50cyB0aGF0IGFyZSBlbnRlcmluZyBvciBsZWF2aW5nIHdpbGwgcG9wdWxhdGUgdGhvc2UgQXJyYXlzIHByb3Blcmx5LlxuXG4gICAgdGhpcy5pbnRlcnJ1cHRlZCB8fCAodGhpcy5pbnRlcnJ1cHRlZCA9ICEhdGltZWxpbmVzLmxlbmd0aCk7XG4gIH07XG5cbiAgX3Byb3RvLnVwZGF0ZVZpc2liaWxpdHkgPSBmdW5jdGlvbiB1cGRhdGVWaXNpYmlsaXR5KCkge1xuICAgIHRoaXMuZWxlbWVudFN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChlcykge1xuICAgICAgdmFyIGIgPSBlcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgZXMuaXNWaXNpYmxlID0gISEoYi53aWR0aCB8fCBiLmhlaWdodCB8fCBiLnRvcCB8fCBiLmxlZnQpO1xuICAgICAgZXMudW5jYWNoZSA9IDE7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldEVsZW1lbnRTdGF0ZSA9IGZ1bmN0aW9uIGdldEVsZW1lbnRTdGF0ZShlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudFN0YXRlc1t0aGlzLnRhcmdldHMuaW5kZXhPZihfZ2V0RWwoZWxlbWVudCkpXTtcbiAgfTtcblxuICBfcHJvdG8ubWFrZUFic29sdXRlID0gZnVuY3Rpb24gbWFrZUFic29sdXRlKCkge1xuICAgIHJldHVybiBfb3JkZXJCeURPTURlcHRoKHRoaXMuZWxlbWVudFN0YXRlcy5zbGljZSgwKSwgdHJ1ZSwgdHJ1ZSkubWFwKF9tYWtlQWJzb2x1dGUpO1xuICB9O1xuXG4gIHJldHVybiBGbGlwU3RhdGU7XG59KCk7XG5cbnZhciBFbGVtZW50U3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbGVtZW50U3RhdGUoZWxlbWVudCwgcHJvcHMsIHNpbXBsZSkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy51cGRhdGUocHJvcHMsIHNpbXBsZSk7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IEVsZW1lbnRTdGF0ZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5pc0RpZmZlcmVudCA9IGZ1bmN0aW9uIGlzRGlmZmVyZW50KHN0YXRlKSB7XG4gICAgdmFyIGIxID0gdGhpcy5ib3VuZHMsXG4gICAgICAgIGIyID0gc3RhdGUuYm91bmRzO1xuICAgIHJldHVybiBiMS50b3AgIT09IGIyLnRvcCB8fCBiMS5sZWZ0ICE9PSBiMi5sZWZ0IHx8IGIxLndpZHRoICE9PSBiMi53aWR0aCB8fCBiMS5oZWlnaHQgIT09IGIyLmhlaWdodCB8fCAhdGhpcy5tYXRyaXguZXF1YWxzKHN0YXRlLm1hdHJpeCkgfHwgdGhpcy5vcGFjaXR5ICE9PSBzdGF0ZS5vcGFjaXR5IHx8IHRoaXMucHJvcHMgJiYgc3RhdGUucHJvcHMgJiYgSlNPTi5zdHJpbmdpZnkodGhpcy5wcm9wcykgIT09IEpTT04uc3RyaW5naWZ5KHN0YXRlLnByb3BzKTtcbiAgfTtcblxuICBfcHJvdG8yLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShwcm9wcywgc2ltcGxlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBlbGVtZW50ID0gc2VsZi5lbGVtZW50LFxuICAgICAgICBnZXRQcm9wID0gZ3NhcC5nZXRQcm9wZXJ0eShlbGVtZW50KSxcbiAgICAgICAgY2FjaGUgPSBnc2FwLmNvcmUuZ2V0Q2FjaGUoZWxlbWVudCksXG4gICAgICAgIGJvdW5kcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGJib3ggPSBlbGVtZW50LmdldEJCb3ggJiYgdHlwZW9mIGVsZW1lbnQuZ2V0QkJveCA9PT0gXCJmdW5jdGlvblwiICYmIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJzdmdcIiAmJiBlbGVtZW50LmdldEJCb3goKSxcbiAgICAgICAgbSA9IHNpbXBsZSA/IG5ldyBNYXRyaXgyRCgxLCAwLCAwLCAxLCBib3VuZHMubGVmdCArIF9nZXREb2NTY3JvbGxMZWZ0KCksIGJvdW5kcy50b3AgKyBfZ2V0RG9jU2Nyb2xsVG9wKCkpIDogZ2V0R2xvYmFsTWF0cml4KGVsZW1lbnQsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgc2VsZi5nZXRQcm9wID0gZ2V0UHJvcDtcbiAgICBzZWxmLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHNlbGYuaWQgPSBfZ2V0SUQoZWxlbWVudCk7XG4gICAgc2VsZi5tYXRyaXggPSBtO1xuICAgIHNlbGYuY2FjaGUgPSBjYWNoZTtcbiAgICBzZWxmLmJvdW5kcyA9IGJvdW5kcztcbiAgICBzZWxmLmlzVmlzaWJsZSA9ICEhKGJvdW5kcy53aWR0aCB8fCBib3VuZHMuaGVpZ2h0IHx8IGJvdW5kcy5sZWZ0IHx8IGJvdW5kcy50b3ApO1xuICAgIHNlbGYuZGlzcGxheSA9IGdldFByb3AoXCJkaXNwbGF5XCIpO1xuICAgIHNlbGYucG9zaXRpb24gPSBnZXRQcm9wKFwicG9zaXRpb25cIik7XG4gICAgc2VsZi5wYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgc2VsZi54ID0gZ2V0UHJvcChcInhcIik7XG4gICAgc2VsZi55ID0gZ2V0UHJvcChcInlcIik7XG4gICAgc2VsZi5zY2FsZVggPSBjYWNoZS5zY2FsZVg7XG4gICAgc2VsZi5zY2FsZVkgPSBjYWNoZS5zY2FsZVk7XG4gICAgc2VsZi5yb3RhdGlvbiA9IGdldFByb3AoXCJyb3RhdGlvblwiKTtcbiAgICBzZWxmLnNrZXdYID0gZ2V0UHJvcChcInNrZXdYXCIpO1xuICAgIHNlbGYub3BhY2l0eSA9IGdldFByb3AoXCJvcGFjaXR5XCIpO1xuICAgIHNlbGYud2lkdGggPSBiYm94ID8gYmJveC53aWR0aCA6IF9jbG9zZXN0VGVudGgoZ2V0UHJvcChcIndpZHRoXCIsIFwicHhcIiksIDAuMDQpOyAvLyByb3VuZCB1cCB0byB0aGUgY2xvc2VzdCAwLjEgc28gdGhhdCB0ZXh0IGRvZXNuJ3Qgd3JhcC5cblxuICAgIHNlbGYuaGVpZ2h0ID0gYmJveCA/IGJib3guaGVpZ2h0IDogX2Nsb3Nlc3RUZW50aChnZXRQcm9wKFwiaGVpZ2h0XCIsIFwicHhcIiksIDAuMDQpO1xuICAgIHByb3BzICYmIF9yZWNvcmRQcm9wcyhzZWxmLCBfbWVtb2l6ZWRQcm9wc1twcm9wc10gfHwgX21lbW9pemVQcm9wcyhwcm9wcykpO1xuICAgIHNlbGYuY3RtID0gZWxlbWVudC5nZXRDVE0gJiYgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiICYmIF9nZXRDVE0oZWxlbWVudCkuaW52ZXJzZSgpO1xuICAgIHNlbGYuc2ltcGxlID0gc2ltcGxlIHx8IF9yb3VuZChtLmEpID09PSAxICYmICFfcm91bmQobS5iKSAmJiAhX3JvdW5kKG0uYykgJiYgX3JvdW5kKG0uZCkgPT09IDE7IC8vIGFsbG93cyB1cyB0byBzcGVlZCB0aHJvdWdoIHNvbWUgb3RoZXIgdGFza3MgaWYgaXQncyBub3Qgc2NhbGUvcm90YXRlZFxuXG4gICAgc2VsZi51bmNhY2hlID0gMDtcbiAgfTtcblxuICByZXR1cm4gRWxlbWVudFN0YXRlO1xufSgpO1xuXG52YXIgRmxpcEFjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZsaXBBY3Rpb24odmFycywgYmF0Y2gpIHtcbiAgICB0aGlzLnZhcnMgPSB2YXJzO1xuICAgIHRoaXMuYmF0Y2ggPSBiYXRjaDtcbiAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgIHRoaXMudGltZWxpbmUgPSBiYXRjaC50aW1lbGluZTtcbiAgfVxuXG4gIHZhciBfcHJvdG8zID0gRmxpcEFjdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMy5nZXRTdGF0ZUJ5SWQgPSBmdW5jdGlvbiBnZXRTdGF0ZUJ5SWQoaWQpIHtcbiAgICB2YXIgaSA9IHRoaXMuc3RhdGVzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlc1tpXS5pZExvb2t1cFtpZF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8zLmtpbGwgPSBmdW5jdGlvbiBraWxsKCkge1xuICAgIHRoaXMuYmF0Y2gucmVtb3ZlKHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBGbGlwQWN0aW9uO1xufSgpO1xuXG52YXIgRmxpcEJhdGNoID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmxpcEJhdGNoKGlkKSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgIHRoaXMuX2tpbGwgPSBbXTtcbiAgICB0aGlzLl9maW5hbCA9IFtdO1xuICAgIHRoaXMuX2FicyA9IFtdO1xuICAgIHRoaXMuX3J1biA9IFtdO1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIHRoaXMuc3RhdGUgPSBuZXcgRmxpcFN0YXRlKCk7XG4gICAgdGhpcy50aW1lbGluZSA9IGdzYXAudGltZWxpbmUoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG80ID0gRmxpcEJhdGNoLnByb3RvdHlwZTtcblxuICBfcHJvdG80LmFkZCA9IGZ1bmN0aW9uIGFkZChjb25maWcpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5hY3Rpb25zLmZpbHRlcihmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICByZXR1cm4gYWN0aW9uLnZhcnMgPT09IGNvbmZpZztcbiAgICB9KTtcblxuICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IG5ldyBGbGlwQWN0aW9uKHR5cGVvZiBjb25maWcgPT09IFwiZnVuY3Rpb25cIiA/IHtcbiAgICAgIGFuaW1hdGU6IGNvbmZpZ1xuICAgIH0gOiBjb25maWcsIHRoaXMpO1xuICAgIHRoaXMuYWN0aW9ucy5wdXNoKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG80LnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShhY3Rpb24pIHtcbiAgICB2YXIgaSA9IHRoaXMuYWN0aW9ucy5pbmRleE9mKGFjdGlvbik7XG4gICAgaSA+PSAwICYmIHRoaXMuYWN0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvNC5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlKG1lcmdlKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgcHJldkJhdGNoID0gX2JhdGNoLFxuICAgICAgICBwcmV2QWN0aW9uID0gX2JhdGNoQWN0aW9uO1xuICAgIF9iYXRjaCA9IHRoaXM7XG4gICAgdGhpcy5zdGF0ZS5jbGVhcigpO1xuICAgIHRoaXMuX2tpbGwubGVuZ3RoID0gMDtcbiAgICB0aGlzLmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBpZiAoYWN0aW9uLnZhcnMuZ2V0U3RhdGUpIHtcbiAgICAgICAgYWN0aW9uLnN0YXRlcy5sZW5ndGggPSAwO1xuICAgICAgICBfYmF0Y2hBY3Rpb24gPSBhY3Rpb247XG4gICAgICAgIGFjdGlvbi5zdGF0ZSA9IGFjdGlvbi52YXJzLmdldFN0YXRlKGFjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIG1lcmdlICYmIGFjdGlvbi5zdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gX3RoaXMzLnN0YXRlLmFkZChzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9iYXRjaEFjdGlvbiA9IHByZXZBY3Rpb247XG4gICAgX2JhdGNoID0gcHJldkJhdGNoO1xuICAgIHRoaXMua2lsbENvbmZsaWN0cygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzQuYW5pbWF0ZSA9IGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgcHJldkJhdGNoID0gX2JhdGNoLFxuICAgICAgICB0bCA9IHRoaXMudGltZWxpbmUsXG4gICAgICAgIGkgPSB0aGlzLmFjdGlvbnMubGVuZ3RoLFxuICAgICAgICBmaW5hbFN0YXRlcyxcbiAgICAgICAgZW5kVGltZTtcbiAgICBfYmF0Y2ggPSB0aGlzO1xuICAgIHRsLmNsZWFyKCk7XG4gICAgdGhpcy5fYWJzLmxlbmd0aCA9IHRoaXMuX2ZpbmFsLmxlbmd0aCA9IHRoaXMuX3J1bi5sZW5ndGggPSAwO1xuICAgIHRoaXMuYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICBhLnZhcnMuYW5pbWF0ZSAmJiBhLnZhcnMuYW5pbWF0ZShhKTtcbiAgICAgIHZhciBvbkVudGVyID0gYS52YXJzLm9uRW50ZXIsXG4gICAgICAgICAgb25MZWF2ZSA9IGEudmFycy5vbkxlYXZlLFxuICAgICAgICAgIHRhcmdldHMgPSBhLnRhcmdldHMsXG4gICAgICAgICAgcyxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGlmICh0YXJnZXRzICYmIHRhcmdldHMubGVuZ3RoICYmIChvbkVudGVyIHx8IG9uTGVhdmUpKSB7XG4gICAgICAgIHMgPSBuZXcgRmxpcFN0YXRlKCk7XG4gICAgICAgIGEuc3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHMuYWRkKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdCA9IHMuY29tcGFyZShGbGlwLmdldFN0YXRlKHRhcmdldHMpKTtcbiAgICAgICAgcmVzdWx0LmVudGVyLmxlbmd0aCAmJiBvbkVudGVyICYmIG9uRW50ZXIocmVzdWx0LmVudGVyKTtcbiAgICAgICAgcmVzdWx0LmxlYXZlLmxlbmd0aCAmJiBvbkxlYXZlICYmIG9uTGVhdmUocmVzdWx0LmxlYXZlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9tYWtlQ29tcHNBYnNvbHV0ZSh0aGlzLl9hYnMpO1xuXG4gICAgdGhpcy5fcnVuLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJldHVybiBmKCk7XG4gICAgfSk7XG5cbiAgICBlbmRUaW1lID0gdGwuZHVyYXRpb24oKTtcbiAgICBmaW5hbFN0YXRlcyA9IHRoaXMuX2ZpbmFsLnNsaWNlKDApO1xuICAgIHRsLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZW5kVGltZSA8PSB0bC50aW1lKCkpIHtcbiAgICAgICAgLy8gb25seSBjYWxsIGlmIG1vdmluZyBmb3J3YXJkIGluIHRoZSB0aW1lbGluZSAoaW4gY2FzZSBpdCdzIG5lc3RlZCBpbiBhIHRpbWVsaW5lIHRoYXQgZ2V0cyByZXZlcnNlZClcbiAgICAgICAgZmluYWxTdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9mb3JFYWNoQmF0Y2goX3RoaXM0LCBcIm9uQ29tcGxldGVcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2JhdGNoID0gcHJldkJhdGNoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5hY3Rpb25zW2ldLnZhcnMub25jZSAmJiB0aGlzLmFjdGlvbnNbaV0ua2lsbCgpO1xuICAgIH1cblxuICAgIF9mb3JFYWNoQmF0Y2godGhpcywgXCJvblN0YXJ0XCIpO1xuXG4gICAgdGwucmVzdGFydCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzQubG9hZFN0YXRlID0gZnVuY3Rpb24gbG9hZFN0YXRlKGRvbmUpIHtcbiAgICBkb25lIHx8IChkb25lID0gZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIHRoaXMuYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy52YXJzLmxvYWRTdGF0ZSkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGYgPSBmdW5jdGlvbiBmKHRhcmdldHMpIHtcbiAgICAgICAgICB0YXJnZXRzICYmIChjLnRhcmdldHMgPSB0YXJnZXRzKTtcbiAgICAgICAgICBpID0gcXVldWUuaW5kZXhPZihmKTtcblxuICAgICAgICAgIGlmICh+aSkge1xuICAgICAgICAgICAgcXVldWUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcXVldWUubGVuZ3RoIHx8IGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcXVldWUucHVzaChmKTtcbiAgICAgICAgYy52YXJzLmxvYWRTdGF0ZShmKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBxdWV1ZS5sZW5ndGggfHwgZG9uZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzQuc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZSgpIHtcbiAgICB0aGlzLmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMudGFyZ2V0cyA9IGMudmFycy5zZXRTdGF0ZSAmJiBjLnZhcnMuc2V0U3RhdGUoYyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvNC5raWxsQ29uZmxpY3RzID0gZnVuY3Rpb24ga2lsbENvbmZsaWN0cyhzb2Z0KSB7XG4gICAgdGhpcy5zdGF0ZS5pbnRlcnJ1cHQoc29mdCk7XG5cbiAgICB0aGlzLl9raWxsLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGUuaW50ZXJydXB0KHNvZnQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvNC5ydW4gPSBmdW5jdGlvbiBydW4oc2tpcEdldFN0YXRlLCBtZXJnZSkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMgIT09IF9iYXRjaCkge1xuICAgICAgc2tpcEdldFN0YXRlIHx8IHRoaXMuZ2V0U3RhdGUobWVyZ2UpO1xuICAgICAgdGhpcy5sb2FkU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIV90aGlzNS5fa2lsbGVkKSB7XG4gICAgICAgICAgX3RoaXM1LnNldFN0YXRlKCk7XG5cbiAgICAgICAgICBfdGhpczUuYW5pbWF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG80LmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoc3RhdGVPbmx5KSB7XG4gICAgdGhpcy5zdGF0ZS5jbGVhcigpO1xuICAgIHN0YXRlT25seSB8fCAodGhpcy5hY3Rpb25zLmxlbmd0aCA9IDApO1xuICB9O1xuXG4gIF9wcm90bzQuZ2V0U3RhdGVCeUlkID0gZnVuY3Rpb24gZ2V0U3RhdGVCeUlkKGlkKSB7XG4gICAgdmFyIGkgPSB0aGlzLmFjdGlvbnMubGVuZ3RoLFxuICAgICAgICBzO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcyA9IHRoaXMuYWN0aW9uc1tpXS5nZXRTdGF0ZUJ5SWQoaWQpO1xuXG4gICAgICBpZiAocykge1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5pZExvb2t1cFtpZF0gJiYgdGhpcy5zdGF0ZTtcbiAgfTtcblxuICBfcHJvdG80LmtpbGwgPSBmdW5jdGlvbiBraWxsKCkge1xuICAgIHRoaXMuX2tpbGxlZCA9IDE7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIGRlbGV0ZSBfYmF0Y2hMb29rdXBbdGhpcy5pZF07XG4gIH07XG5cbiAgcmV0dXJuIEZsaXBCYXRjaDtcbn0oKTtcblxuZXhwb3J0IHZhciBGbGlwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmxpcCgpIHt9XG5cbiAgRmxpcC5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlKHRhcmdldHMsIHZhcnMpIHtcbiAgICB2YXIgc3RhdGUgPSBfcGFyc2VTdGF0ZSh0YXJnZXRzLCB2YXJzKTtcblxuICAgIF9iYXRjaEFjdGlvbiAmJiBfYmF0Y2hBY3Rpb24uc3RhdGVzLnB1c2goc3RhdGUpO1xuICAgIHZhcnMgJiYgdmFycy5iYXRjaCAmJiBGbGlwLmJhdGNoKHZhcnMuYmF0Y2gpLnN0YXRlLmFkZChzdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9O1xuXG4gIEZsaXAuZnJvbSA9IGZ1bmN0aW9uIGZyb20oc3RhdGUsIHZhcnMpIHtcbiAgICB2YXJzID0gdmFycyB8fCB7fTtcbiAgICBcImNsZWFyUHJvcHNcIiBpbiB2YXJzIHx8ICh2YXJzLmNsZWFyUHJvcHMgPSB0cnVlKTtcbiAgICByZXR1cm4gX2Zyb21UbyhzdGF0ZSwgX3BhcnNlU3RhdGUodmFycy50YXJnZXRzIHx8IHN0YXRlLnRhcmdldHMsIHtcbiAgICAgIHByb3BzOiB2YXJzLnByb3BzIHx8IHN0YXRlLnByb3BzLFxuICAgICAgc2ltcGxlOiB2YXJzLnNpbXBsZSxcbiAgICAgIGtpbGw6ICEhdmFycy5raWxsXG4gICAgfSksIHZhcnMsIC0xKTtcbiAgfTtcblxuICBGbGlwLnRvID0gZnVuY3Rpb24gdG8oc3RhdGUsIHZhcnMpIHtcbiAgICByZXR1cm4gX2Zyb21UbyhzdGF0ZSwgX3BhcnNlU3RhdGUodmFycy50YXJnZXRzIHx8IHN0YXRlLnRhcmdldHMsIHtcbiAgICAgIHByb3BzOiB2YXJzLnByb3BzIHx8IHN0YXRlLnByb3BzLFxuICAgICAgc2ltcGxlOiB2YXJzLnNpbXBsZSxcbiAgICAgIGtpbGw6ICEhdmFycy5raWxsXG4gICAgfSksIHZhcnMsIDEpO1xuICB9O1xuXG4gIEZsaXAuZnJvbVRvID0gZnVuY3Rpb24gZnJvbVRvKGZyb21TdGF0ZSwgdG9TdGF0ZSwgdmFycykge1xuICAgIHJldHVybiBfZnJvbVRvKGZyb21TdGF0ZSwgdG9TdGF0ZSwgdmFycyk7XG4gIH07XG5cbiAgRmxpcC5maXQgPSBmdW5jdGlvbiBmaXQoZnJvbUVsLCB0b0VsLCB2YXJzKSB7XG4gICAgdmFyIHYgPSB2YXJzID8gX2NvcHkodmFycywgX2ZpdFJlc2VydmVkKSA6IHt9LFxuICAgICAgICBfcmVmID0gdmFycyB8fCB2LFxuICAgICAgICBhYnNvbHV0ZSA9IF9yZWYuYWJzb2x1dGUsXG4gICAgICAgIHNjYWxlID0gX3JlZi5zY2FsZSxcbiAgICAgICAgZ2V0VmFycyA9IF9yZWYuZ2V0VmFycyxcbiAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICBydW5CYWNrd2FyZHMgPSBfcmVmLnJ1bkJhY2t3YXJkcyxcbiAgICAgICAgb25Db21wbGV0ZSA9IF9yZWYub25Db21wbGV0ZSxcbiAgICAgICAgc2ltcGxlID0gX3JlZi5zaW1wbGUsXG4gICAgICAgIGZpdENoaWxkID0gdmFycyAmJiB2YXJzLmZpdENoaWxkICYmIF9nZXRFbCh2YXJzLmZpdENoaWxkKSxcbiAgICAgICAgYmVmb3JlID0gX3BhcnNlRWxlbWVudFN0YXRlKHRvRWwsIHByb3BzLCBzaW1wbGUsIGZyb21FbCksXG4gICAgICAgIGFmdGVyID0gX3BhcnNlRWxlbWVudFN0YXRlKGZyb21FbCwgMCwgc2ltcGxlLCBiZWZvcmUpLFxuICAgICAgICBpbmxpbmVQcm9wcyA9IHByb3BzID8gX21lbW9pemVkUmVtb3ZlUHJvcHNbcHJvcHNdIDogX3JlbW92ZVByb3BzLFxuICAgICAgICBjdHggPSBnc2FwLmNvbnRleHQoKTtcblxuICAgIHByb3BzICYmIF9hcHBseVByb3BzKHYsIGJlZm9yZS5wcm9wcyk7XG5cbiAgICBfcmVjb3JkSW5saW5lU3R5bGVzKGFmdGVyLCBpbmxpbmVQcm9wcyk7XG5cbiAgICBpZiAocnVuQmFja3dhcmRzKSB7XG4gICAgICBcImltbWVkaWF0ZVJlbmRlclwiIGluIHYgfHwgKHYuaW1tZWRpYXRlUmVuZGVyID0gdHJ1ZSk7XG5cbiAgICAgIHYub25Db21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX2FwcGx5SW5saW5lU3R5bGVzKGFmdGVyKTtcblxuICAgICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgYWJzb2x1dGUgJiYgX21ha2VBYnNvbHV0ZShhZnRlciwgYmVmb3JlKTtcbiAgICB2ID0gX2ZpdChhZnRlciwgYmVmb3JlLCBzY2FsZSB8fCBmaXRDaGlsZCwgcHJvcHMsIGZpdENoaWxkLCB2LmR1cmF0aW9uIHx8IGdldFZhcnMgPyB2IDogMCk7XG4gICAgY3R4ICYmICFnZXRWYXJzICYmIGN0eC5hZGQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9hcHBseUlubGluZVN0eWxlcyhhZnRlcik7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBnZXRWYXJzID8gdiA6IHYuZHVyYXRpb24gPyBnc2FwLnRvKGFmdGVyLmVsZW1lbnQsIHYpIDogbnVsbDtcbiAgfTtcblxuICBGbGlwLm1ha2VBYnNvbHV0ZSA9IGZ1bmN0aW9uIG1ha2VBYnNvbHV0ZSh0YXJnZXRzT3JTdGF0ZXMsIHZhcnMpIHtcbiAgICByZXR1cm4gKHRhcmdldHNPclN0YXRlcyBpbnN0YW5jZW9mIEZsaXBTdGF0ZSA/IHRhcmdldHNPclN0YXRlcyA6IG5ldyBGbGlwU3RhdGUodGFyZ2V0c09yU3RhdGVzLCB2YXJzKSkubWFrZUFic29sdXRlKCk7XG4gIH07XG5cbiAgRmxpcC5iYXRjaCA9IGZ1bmN0aW9uIGJhdGNoKGlkKSB7XG4gICAgaWQgfHwgKGlkID0gXCJkZWZhdWx0XCIpO1xuICAgIHJldHVybiBfYmF0Y2hMb29rdXBbaWRdIHx8IChfYmF0Y2hMb29rdXBbaWRdID0gbmV3IEZsaXBCYXRjaChpZCkpO1xuICB9O1xuXG4gIEZsaXAua2lsbEZsaXBzT2YgPSBmdW5jdGlvbiBraWxsRmxpcHNPZih0YXJnZXRzLCBjb21wbGV0ZSkge1xuICAgICh0YXJnZXRzIGluc3RhbmNlb2YgRmxpcFN0YXRlID8gdGFyZ2V0cy50YXJnZXRzIDogX3RvQXJyYXkodGFyZ2V0cykpLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0ICYmIF9raWxsRmxpcCh0Ll9mbGlwLCBjb21wbGV0ZSAhPT0gZmFsc2UgPyAxIDogMik7XG4gICAgfSk7XG4gIH07XG5cbiAgRmxpcC5pc0ZsaXBwaW5nID0gZnVuY3Rpb24gaXNGbGlwcGluZyh0YXJnZXQpIHtcbiAgICB2YXIgZiA9IEZsaXAuZ2V0QnlUYXJnZXQodGFyZ2V0KTtcbiAgICByZXR1cm4gISFmICYmIGYuaXNBY3RpdmUoKTtcbiAgfTtcblxuICBGbGlwLmdldEJ5VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0QnlUYXJnZXQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIChfZ2V0RWwodGFyZ2V0KSB8fCBfZW1wdHlPYmopLl9mbGlwO1xuICB9O1xuXG4gIEZsaXAuZ2V0RWxlbWVudFN0YXRlID0gZnVuY3Rpb24gZ2V0RWxlbWVudFN0YXRlKHRhcmdldCwgcHJvcHMpIHtcbiAgICByZXR1cm4gbmV3IEVsZW1lbnRTdGF0ZShfZ2V0RWwodGFyZ2V0KSwgcHJvcHMpO1xuICB9O1xuXG4gIEZsaXAuY29udmVydENvb3JkaW5hdGVzID0gZnVuY3Rpb24gY29udmVydENvb3JkaW5hdGVzKGZyb21FbGVtZW50LCB0b0VsZW1lbnQsIHBvaW50KSB7XG4gICAgdmFyIG0gPSBnZXRHbG9iYWxNYXRyaXgodG9FbGVtZW50LCB0cnVlLCB0cnVlKS5tdWx0aXBseShnZXRHbG9iYWxNYXRyaXgoZnJvbUVsZW1lbnQpKTtcbiAgICByZXR1cm4gcG9pbnQgPyBtLmFwcGx5KHBvaW50KSA6IG07XG4gIH07XG5cbiAgRmxpcC5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvcmUpIHtcbiAgICBfYm9keSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5ib2R5O1xuXG4gICAgaWYgKF9ib2R5KSB7XG4gICAgICBnc2FwID0gY29yZTtcblxuICAgICAgX3NldERvYyhfYm9keSk7XG5cbiAgICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgICAgX2dldFN0eWxlU2F2ZXIgPSBnc2FwLmNvcmUuZ2V0U3R5bGVTYXZlcjtcbiAgICAgIHZhciBzbmFwID0gZ3NhcC51dGlscy5zbmFwKDAuMSk7XG5cbiAgICAgIF9jbG9zZXN0VGVudGggPSBmdW5jdGlvbiBfY2xvc2VzdFRlbnRoKHZhbHVlLCBhZGQpIHtcbiAgICAgICAgcmV0dXJuIHNuYXAocGFyc2VGbG9hdCh2YWx1ZSkgKyBhZGQpO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEZsaXA7XG59KCk7XG5GbGlwLnZlcnNpb24gPSBcIjMuMTIuNVwiOyAvLyBmdW5jdGlvbiB3aGVuSW1hZ2VzTG9hZChlbCwgZnVuYykge1xuLy8gXHRsZXQgcGVuZGluZyA9IFtdLFxuLy8gXHRcdG9uTG9hZCA9IGUgPT4ge1xuLy8gXHRcdFx0cGVuZGluZy5zcGxpY2UocGVuZGluZy5pbmRleE9mKGUudGFyZ2V0KSwgMSk7XG4vLyBcdFx0XHRlLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBvbkxvYWQpO1xuLy8gXHRcdFx0cGVuZGluZy5sZW5ndGggfHwgZnVuYygpO1xuLy8gXHRcdH07XG4vLyBcdGdzYXAudXRpbHMudG9BcnJheShlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW1nXCIgPyBlbCA6IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbWdcIikpLmZvckVhY2goaW1nID0+IGltZy5jb21wbGV0ZSB8fCBpbWcuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgb25Mb2FkKSB8fCBwZW5kaW5nLnB1c2goaW1nKSk7XG4vLyBcdHBlbmRpbmcubGVuZ3RoIHx8IGZ1bmMoKTtcbi8vIH1cblxudHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZ3NhcCAmJiB3aW5kb3cuZ3NhcC5yZWdpc3RlclBsdWdpbihGbGlwKTtcbmV4cG9ydCB7IEZsaXAgYXMgZGVmYXVsdCB9OyJdLCJuYW1lcyI6WyJnZXRHbG9iYWxNYXRyaXgiLCJfZ2V0RG9jU2Nyb2xsVG9wIiwiX2dldERvY1Njcm9sbExlZnQiLCJNYXRyaXgyRCIsIl9zZXREb2MiLCJfZ2V0Q1RNIiwiX2lkIiwiX3RvQXJyYXkiLCJnc2FwIiwiX2JhdGNoIiwiX2JhdGNoQWN0aW9uIiwiX2JvZHkiLCJfY2xvc2VzdFRlbnRoIiwiX2dldFN0eWxlU2F2ZXIiLCJfZm9yRWFjaEJhdGNoIiwiYmF0Y2giLCJuYW1lIiwiYWN0aW9ucyIsImZvckVhY2giLCJhIiwidmFycyIsIl9iYXRjaExvb2t1cCIsIl9SQUQyREVHIiwiTWF0aCIsIlBJIiwiX0RFRzJSQUQiLCJfZW1wdHlPYmoiLCJfZGFzaGVkTmFtZUxvb2t1cCIsIl9tZW1vaXplZFJlbW92ZVByb3BzIiwiX2xpc3RUb0FycmF5IiwibGlzdCIsInNwbGl0Iiwiam9pbiIsIl9jYWxsYmFja3MiLCJfcmVtb3ZlUHJvcHMiLCJfZ2V0RWwiLCJ0YXJnZXQiLCJjb25zb2xlIiwid2FybiIsIl9yb3VuZCIsInZhbHVlIiwicm91bmQiLCJfdG9nZ2xlQ2xhc3MiLCJ0YXJnZXRzIiwiY2xhc3NOYW1lIiwiYWN0aW9uIiwiZWwiLCJjbGFzc0xpc3QiLCJfcmVzZXJ2ZWQiLCJ6SW5kZXgiLCJraWxsIiwic2ltcGxlIiwic3BpbiIsImNsZWFyUHJvcHMiLCJ0b2dnbGVDbGFzcyIsIm9uQ29tcGxldGUiLCJvblVwZGF0ZSIsIm9uSW50ZXJydXB0Iiwib25TdGFydCIsImRlbGF5IiwicmVwZWF0IiwicmVwZWF0RGVsYXkiLCJ5b3lvIiwic2NhbGUiLCJmYWRlIiwiYWJzb2x1dGUiLCJwcm9wcyIsIm9uRW50ZXIiLCJvbkxlYXZlIiwiY3VzdG9tIiwicGF1c2VkIiwibmVzdGVkIiwicHJ1bmUiLCJhYnNvbHV0ZU9uTGVhdmUiLCJfZml0UmVzZXJ2ZWQiLCJmaXRDaGlsZCIsImdldFZhcnMiLCJfY2FtZWxUb0Rhc2hlZCIsInAiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJfY29weSIsIm9iaiIsImV4Y2x1ZGUiLCJyZXN1bHQiLCJfbWVtb2l6ZWRQcm9wcyIsIl9tZW1vaXplUHJvcHMiLCJjb25jYXQiLCJfZ2V0SW52ZXJzZUdsb2JhbE1hdHJpeCIsImNhY2hlIiwiX2dzYXAiLCJjb3JlIiwiZ2V0Q2FjaGUiLCJnbUNhY2hlIiwidGlja2VyIiwiZnJhbWUiLCJnTWF0cml4IiwiX2dldERPTURlcHRoIiwiaW52ZXJ0IiwibGV2ZWwiLCJwYXJlbnQiLCJwYXJlbnROb2RlIiwiaW5jIiwicG93IiwibCIsInByZXZpb3VzU2libGluZyIsIl9vcmRlckJ5RE9NRGVwdGgiLCJjb21wcyIsImlzRWxTdGF0ZXMiLCJjb21wIiwiZCIsImVsZW1lbnQiLCJ0Iiwic29ydCIsImMxIiwiYzIiLCJfcmVjb3JkSW5saW5lU3R5bGVzIiwiZWxTdGF0ZSIsInN0eWxlIiwiY3NzIiwiaSIsImxlbmd0aCIsInYiLCJnZXRQcm9wZXJ0eVZhbHVlIiwicHVzaCIsIl9hcHBseUlubGluZVN0eWxlcyIsInN0YXRlIiwidW5jYWNoZSIsInJlbW92ZVByb3BlcnR5IiwiaW5kZXhPZiIsInRyYW5zbGF0ZSIsIl9zZXRGaW5hbFN0YXRlcyIsIm9ubHlUcmFuc2Zvcm1zIiwiYyIsImZpbmFsU3RhdGVzIiwiX2Fic29sdXRlUHJvcHMiLCJfbWFrZUFic29sdXRlIiwiZmFsbGJhY2tOb2RlIiwiaWdub3JlQmF0Y2giLCJ3aWR0aCIsImhlaWdodCIsImdldFByb3AiLCJkaXNwbGF5SXNOb25lIiwiY3MiLCJfYWJzIiwiYiIsInNkIiwiX2ZpbmFsIiwiaXNWaXNpYmxlIiwiZGlzcGxheSIsIm1hdHJpeCIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJncmlkQXJlYSIsInRyYW5zaXRpb24iLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJFbGVtZW50U3RhdGUiLCJib3VuZHMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJfZml0IiwieCIsInkiLCJfZmlsdGVyQ29tcHMiLCJmaWx0ZXIiLCJyZW5kZXJUcmFuc2Zvcm0iLCJfbWFrZUNvbXBzQWJzb2x1dGUiLCJfZmluZEVsU3RhdGVJblN0YXRlIiwib3RoZXIiLCJpZExvb2t1cCIsIl9wYXJzZUVsZW1lbnRTdGF0ZSIsImlkIiwiZWxlbWVudFN0YXRlcyIsImVsT3JOb2RlIiwiRmxpcFN0YXRlIiwiX3JlY29yZFByb3BzIiwiZ2V0UHJvcGVydHkiLCJ0cmltIiwicGFyc2VGbG9hdCIsIl9hcHBseVByb3BzIiwiX2dldElEIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiX2VsZW1lbnRzRnJvbUVsZW1lbnRTdGF0ZXMiLCJlbFN0YXRlcyIsIm1hcCIsIl9oYW5kbGVDYWxsYmFjayIsImNhbGxiYWNrIiwidGwiLCJhZGQiLCJmcm9tU3RhdGUiLCJ0b1N0YXRlIiwiYXBwbHlQcm9wcyIsInNjYWxlWCIsInNjYWxlWSIsInJvdGF0aW9uIiwic3R5bGVzIiwiZGltZW5zaW9uU3RhdGUiLCJfdG9TdGF0ZSRtYXRyaXgiLCJlIiwiZiIsImRlZXAiLCJza2V3WCIsImZyb21Qb2ludCIsInRvUG9pbnQiLCJwYXJlbnRNYXRyaXgiLCJiYm94IiwiY2xvbmUiLCJtdWx0aXBseSIsImN0bSIsImF0YW4yIiwic3FydCIsImNvcyIsImdldEJCb3giLCJjZWlsIiwiYXBwbHkiLCJyZXZlcnQiLCJfcGFyc2VTdGF0ZSIsInRhcmdldHNPclN0YXRlIiwiX2dldENoYW5naW5nRWxTdGF0ZSIsInRvMSIsInRvMiIsImFsdCIsImdldEVsZW1lbnRTdGF0ZSIsIl9ib2R5TWV0cmljcyIsIl9ib2R5UHJvcHMiLCJfYm9keUxvY2tlZCIsIl9sb2NrQm9keVNjcm9sbCIsImxvY2siLCJzIiwidyIsImNsaWVudFdpZHRoIiwib3V0ZXJXaWR0aCIsImgiLCJjbGllbnRIZWlnaHQiLCJvdXRlckhlaWdodCIsIm92ZXJmbG93WSIsIm92ZXJmbG93WCIsIl9mcm9tVG8iLCJyZWxhdGl2ZSIsIl92YXJzIiwiX3pJbmRleCIsInN0YWdnZXIiLCJ0d2VlblZhcnMiLCJhbmltYXRpb24iLCJ0aW1lbGluZSIsImRhdGEiLCJyZW1haW5pbmdQcm9wcyIsImVudGVyaW5nIiwibGVhdmluZyIsInN3YXBPdXRUYXJnZXRzIiwic3Bpbk51bSIsInNwaW5GdW5jIiwiaW50ZXJydXB0ZWQiLCJhZGRGdW5jIiwiZW5kVGltZSIsImZyb21Ob2RlIiwidG9Ob2RlIiwicnVuIiwic3dhcCIsIl9mbGlwIiwiaXNEaWZmZXJlbnQiLCJzcGxpY2UiLCJvcGFjaXR5IiwibWF4V2lkdGgiLCJtYXgiLCJtYXhIZWlnaHQiLCJtaW5XaWR0aCIsIm1pbiIsIm1pbkhlaWdodCIsImNsYXNzVGFyZ2V0cyIsInJlbW92ZSIsImF1dG9Sb3VuZCIsIm1vZGlmaWVycyIsImltbWVkaWF0ZVJlbmRlciIsInV0aWxzIiwiZGlzdHJpYnV0ZSIsImR1bW15QXJyYXkiLCJzbGljZSIsImV2ZW50Q2FsbGJhY2siLCJkdXJhdGlvbiIsImNhbGwiLCJfelRpbWUiLCJiYXRjaFRsIiwiZm9yd2FyZCIsInRpbWUiLCJfYmF0Y2gkX2FicyIsIl9ydW4iLCJhbmltIiwiX2tpbGxGbGlwIiwiX2ludGVycnVwdCIsIm9uSW50ZXJydXB0UGFyYW1zIiwiZ2V0Q2hpbGRyZW4iLCJmb3JjZSIsInByb2dyZXNzIiwiX2NyZWF0ZUxvb2t1cCIsImxvb2t1cCIsInRhcmdldHNBcmVFbGVtZW50U3RhdGVzIiwic29mdCIsIl9raWxsIiwidXBkYXRlIiwiX3Byb3RvIiwicHJvdG90eXBlIiwiX3RoaXMiLCJpbnRlcnJ1cHQiLCJyZWNvcmRJbmxpbmVTdHlsZXMiLCJjbGVhciIsImZpdCIsImVsU3RhdGVzSW5PcmRlciIsInRvRWxTdGF0ZXMiLCJwcm9wZXJ0eSIsImVzIiwiaW5kZXgiLCJlczIiLCJjb21wYXJlIiwibDEiLCJsMiIsInVuY2hhbmdlZCIsImNoYW5nZWQiLCJlbnRlciIsImxlYXZlIiwiYTEiLCJhMiIsInBsYWNlIiwiczEiLCJzMiIsInBsYWNlSWZEb2VzTm90RXhpc3QiLCJzMUFsdCIsInMyQWx0IiwiX3RoaXMyIiwidGltZWxpbmVzIiwiZm91bmRJblByb2dyZXNzIiwidXBkYXRlVmlzaWJpbGl0eSIsIm1ha2VBYnNvbHV0ZSIsIl9wcm90bzIiLCJiMSIsImIyIiwiZXF1YWxzIiwiSlNPTiIsInN0cmluZ2lmeSIsInNlbGYiLCJub2RlTmFtZSIsIm0iLCJnZXRDVE0iLCJpbnZlcnNlIiwiRmxpcEFjdGlvbiIsInN0YXRlcyIsIl9wcm90bzMiLCJnZXRTdGF0ZUJ5SWQiLCJGbGlwQmF0Y2giLCJfcHJvdG80IiwiY29uZmlnIiwiYW5pbWF0ZSIsImdldFN0YXRlIiwibWVyZ2UiLCJfdGhpczMiLCJwcmV2QmF0Y2giLCJwcmV2QWN0aW9uIiwia2lsbENvbmZsaWN0cyIsIl90aGlzNCIsIkZsaXAiLCJvbmNlIiwicmVzdGFydCIsImxvYWRTdGF0ZSIsImRvbmUiLCJxdWV1ZSIsInNldFN0YXRlIiwic2tpcEdldFN0YXRlIiwiX3RoaXM1IiwiX2tpbGxlZCIsInN0YXRlT25seSIsImZyb20iLCJ0byIsImZyb21UbyIsImZyb21FbCIsInRvRWwiLCJfcmVmIiwicnVuQmFja3dhcmRzIiwiYmVmb3JlIiwiYWZ0ZXIiLCJpbmxpbmVQcm9wcyIsImN0eCIsImNvbnRleHQiLCJhcmd1bWVudHMiLCJ0YXJnZXRzT3JTdGF0ZXMiLCJraWxsRmxpcHNPZiIsImNvbXBsZXRlIiwiaXNGbGlwcGluZyIsImdldEJ5VGFyZ2V0IiwiaXNBY3RpdmUiLCJjb252ZXJ0Q29vcmRpbmF0ZXMiLCJmcm9tRWxlbWVudCIsInRvRWxlbWVudCIsInBvaW50IiwicmVnaXN0ZXIiLCJkb2N1bWVudCIsImJvZHkiLCJ0b0FycmF5IiwiZ2V0U3R5bGVTYXZlciIsInNuYXAiLCJ2ZXJzaW9uIiwicmVnaXN0ZXJQbHVnaW4iLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Flip.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/MotionPathPlugin.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/MotionPathPlugin.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MotionPathPlugin: function() { return /* binding */ MotionPathPlugin; },\n/* harmony export */   \"default\": function() { return /* binding */ MotionPathPlugin; }\n/* harmony export */ });\n/* harmony import */ var _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/paths.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/paths.js\");\n/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/matrix.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/matrix.js\");\n/*!\n * MotionPathPlugin 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ \n\nvar _xProps = \"x,translateX,left,marginLeft,xPercent\".split(\",\"), _yProps = \"y,translateY,top,marginTop,yPercent\".split(\",\"), _DEG2RAD = Math.PI / 180, gsap, PropTween, _getUnit, _toArray, _getStyleSaver, _reverting, _getGSAP = function _getGSAP() {\n    return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _populateSegmentFromArray = function _populateSegmentFromArray(segment, values, property, mode) {\n    //mode: 0 = x but don't fill y yet, 1 = y, 2 = x and fill y with 0.\n    var l = values.length, si = mode === 2 ? 0 : mode, i = 0, v;\n    for(; i < l; i++){\n        segment[si] = v = parseFloat(values[i][property]);\n        mode === 2 && (segment[si + 1] = 0);\n        si += 2;\n    }\n    return segment;\n}, _getPropNum = function _getPropNum(target, prop, unit) {\n    return parseFloat(target._gsap.get(target, prop, unit || \"px\")) || 0;\n}, _relativize = function _relativize(segment) {\n    var x = segment[0], y = segment[1], i;\n    for(i = 2; i < segment.length; i += 2){\n        x = segment[i] += x;\n        y = segment[i + 1] += y;\n    }\n}, // feed in an array of quadratic bezier points like [{x: 0, y: 0}, ...] and it'll convert it to cubic bezier\n// _quadToCubic = points => {\n// \tlet cubic = [],\n// \t\tl = points.length - 1,\n// \t\ti = 1,\n// \t\ta, b, c;\n// \tfor (; i < l; i+=2) {\n// \t\ta = points[i-1];\n// \t\tb = points[i];\n// \t\tc = points[i+1];\n// \t\tcubic.push(a, {x: (2 * b.x + a.x) / 3, y: (2 * b.y + a.y) / 3}, {x: (2 * b.x + c.x) / 3, y: (2 * b.y + c.y) / 3});\n// \t}\n// \tcubic.push(points[l]);\n// \treturn cubic;\n// },\n_segmentToRawPath = function _segmentToRawPath(plugin, segment, target, x, y, slicer, vars, unitX, unitY) {\n    if (vars.type === \"cubic\") {\n        segment = [\n            segment\n        ];\n    } else {\n        vars.fromCurrent !== false && segment.unshift(_getPropNum(target, x, unitX), y ? _getPropNum(target, y, unitY) : 0);\n        vars.relative && _relativize(segment);\n        var pointFunc = y ? _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment : _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.flatPointsToSegment;\n        segment = [\n            pointFunc(segment, vars.curviness)\n        ];\n    }\n    segment = slicer(_align(segment, target, vars));\n    _addDimensionalPropTween(plugin, target, x, segment, \"x\", unitX);\n    y && _addDimensionalPropTween(plugin, target, y, segment, \"y\", unitY);\n    return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements)(segment, vars.resolution || (vars.curviness === 0 ? 20 : 12)); //when curviness is 0, it creates control points right on top of the anchors which makes it more sensitive to resolution, thus we change the default accordingly.\n}, _emptyFunc = function _emptyFunc(v) {\n    return v;\n}, _numExp = /[-+\\.]*\\d+\\.?(?:e-|e\\+)?\\d*/g, _originToPoint = function _originToPoint(element, origin, parentMatrix) {\n    // origin is an array of normalized values (0-1) in relation to the width/height, so [0.5, 0.5] would be the center. It can also be \"auto\" in which case it will be the top left unless it's a <path>, when it will start at the beginning of the path itself.\n    var m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(element), x = 0, y = 0, svg;\n    if ((element.tagName + \"\").toLowerCase() === \"svg\") {\n        svg = element.viewBox.baseVal;\n        svg.width || (svg = {\n            width: +element.getAttribute(\"width\"),\n            height: +element.getAttribute(\"height\")\n        });\n    } else {\n        svg = origin && element.getBBox && element.getBBox();\n    }\n    if (origin && origin !== \"auto\") {\n        x = origin.push ? origin[0] * (svg ? svg.width : element.offsetWidth || 0) : origin.x;\n        y = origin.push ? origin[1] * (svg ? svg.height : element.offsetHeight || 0) : origin.y;\n    }\n    return parentMatrix.apply(x || y ? m.apply({\n        x: x,\n        y: y\n    }) : {\n        x: m.e,\n        y: m.f\n    });\n}, _getAlignMatrix = function _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin) {\n    var parentMatrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(fromElement.parentNode, true, true), m = parentMatrix.clone().multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(toElement)), fromPoint = _originToPoint(fromElement, fromOrigin, parentMatrix), _originToPoint2 = _originToPoint(toElement, toOrigin, parentMatrix), x = _originToPoint2.x, y = _originToPoint2.y, p;\n    m.e = m.f = 0;\n    if (toOrigin === \"auto\" && toElement.getTotalLength && toElement.tagName.toLowerCase() === \"path\") {\n        p = toElement.getAttribute(\"d\").match(_numExp) || [];\n        p = m.apply({\n            x: +p[0],\n            y: +p[1]\n        });\n        x += p.x;\n        y += p.y;\n    } //if (p || (toElement.getBBox && fromElement.getBBox && toElement.ownerSVGElement === fromElement.ownerSVGElement)) {\n    if (p) {\n        p = m.apply(toElement.getBBox());\n        x -= p.x;\n        y -= p.y;\n    }\n    m.e = x - fromPoint.x;\n    m.f = y - fromPoint.y;\n    return m;\n}, _align = function _align(rawPath, target, _ref) {\n    var align = _ref.align, matrix = _ref.matrix, offsetX = _ref.offsetX, offsetY = _ref.offsetY, alignOrigin = _ref.alignOrigin;\n    var x = rawPath[0][0], y = rawPath[0][1], curX = _getPropNum(target, \"x\"), curY = _getPropNum(target, \"y\"), alignTarget, m, p;\n    if (!rawPath || !rawPath.length) {\n        return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath)(\"M0,0L0,0\");\n    }\n    if (align) {\n        if (align === \"self\" || (alignTarget = _toArray(align)[0] || target) === target) {\n            (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, 1, 0, 0, 1, curX - x, curY - y);\n        } else {\n            if (alignOrigin && alignOrigin[2] !== false) {\n                gsap.set(target, {\n                    transformOrigin: alignOrigin[0] * 100 + \"% \" + alignOrigin[1] * 100 + \"%\"\n                });\n            } else {\n                alignOrigin = [\n                    _getPropNum(target, \"xPercent\") / -100,\n                    _getPropNum(target, \"yPercent\") / -100\n                ];\n            }\n            m = _getAlignMatrix(target, alignTarget, alignOrigin, \"auto\");\n            p = m.apply({\n                x: x,\n                y: y\n            });\n            (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, m.a, m.b, m.c, m.d, curX + m.e - (p.x - m.e), curY + m.f - (p.y - m.f));\n        }\n    }\n    if (matrix) {\n        (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);\n    } else if (offsetX || offsetY) {\n        (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, 1, 0, 0, 1, offsetX || 0, offsetY || 0);\n    }\n    return rawPath;\n}, _addDimensionalPropTween = function _addDimensionalPropTween(plugin, target, property, rawPath, pathProperty, forceUnit) {\n    var cache = target._gsap, harness = cache.harness, alias = harness && harness.aliases && harness.aliases[property], prop = alias && alias.indexOf(\",\") < 0 ? alias : property, pt = plugin._pt = new PropTween(plugin._pt, target, prop, 0, 0, _emptyFunc, 0, cache.set(target, prop, plugin));\n    pt.u = _getUnit(cache.get(target, prop, forceUnit)) || 0;\n    pt.path = rawPath;\n    pt.pp = pathProperty;\n    plugin._props.push(prop);\n}, _sliceModifier = function _sliceModifier(start, end) {\n    return function(rawPath) {\n        return start || end !== 1 ? (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.sliceRawPath)(rawPath, start, end) : rawPath;\n    };\n};\nvar MotionPathPlugin = {\n    version: \"3.12.5\",\n    name: \"motionPath\",\n    register: function register(core, Plugin, propTween) {\n        gsap = core;\n        _getUnit = gsap.utils.getUnit;\n        _toArray = gsap.utils.toArray;\n        _getStyleSaver = gsap.core.getStyleSaver;\n        _reverting = gsap.core.reverting || function() {};\n        PropTween = propTween;\n    },\n    init: function init(target, vars, tween) {\n        if (!gsap) {\n            console.warn(\"Please gsap.registerPlugin(MotionPathPlugin)\");\n            return false;\n        }\n        if (!(typeof vars === \"object\" && !vars.style) || !vars.path) {\n            vars = {\n                path: vars\n            };\n        }\n        var rawPaths = [], _vars = vars, path = _vars.path, autoRotate = _vars.autoRotate, unitX = _vars.unitX, unitY = _vars.unitY, x = _vars.x, y = _vars.y, firstObj = path[0], slicer = _sliceModifier(vars.start, \"end\" in vars ? vars.end : 1), rawPath, p;\n        this.rawPaths = rawPaths;\n        this.target = target;\n        this.tween = tween;\n        this.styles = _getStyleSaver && _getStyleSaver(target, \"transform\");\n        if (this.rotate = autoRotate || autoRotate === 0) {\n            //get the rotational data FIRST so that the setTransform() method is called in the correct order in the render() loop - rotation gets set last.\n            this.rOffset = parseFloat(autoRotate) || 0;\n            this.radians = !!vars.useRadians;\n            this.rProp = vars.rotation || \"rotation\"; // rotation property\n            this.rSet = target._gsap.set(target, this.rProp, this); // rotation setter\n            this.ru = _getUnit(target._gsap.get(target, this.rProp)) || 0; // rotation units\n        }\n        if (Array.isArray(path) && !(\"closed\" in path) && typeof firstObj !== \"number\") {\n            for(p in firstObj){\n                if (!x && ~_xProps.indexOf(p)) {\n                    x = p;\n                } else if (!y && ~_yProps.indexOf(p)) {\n                    y = p;\n                }\n            }\n            if (x && y) {\n                //correlated values\n                rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray(_populateSegmentFromArray([], path, x, 0), path, y, 1), target, x, y, slicer, vars, unitX || _getUnit(path[0][x]), unitY || _getUnit(path[0][y])));\n            } else {\n                x = y = 0;\n            }\n            for(p in firstObj){\n                p !== x && p !== y && rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray([], path, p, 2), target, p, 0, slicer, vars, _getUnit(path[0][p])));\n            }\n        } else {\n            rawPath = slicer(_align((0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath)(vars.path), target, vars));\n            (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements)(rawPath, vars.resolution);\n            rawPaths.push(rawPath);\n            _addDimensionalPropTween(this, target, vars.x || \"x\", rawPath, \"x\", vars.unitX || \"px\");\n            _addDimensionalPropTween(this, target, vars.y || \"y\", rawPath, \"y\", vars.unitY || \"px\");\n        }\n    },\n    render: function render(ratio, data) {\n        var rawPaths = data.rawPaths, i = rawPaths.length, pt = data._pt;\n        if (data.tween._time || !_reverting()) {\n            if (ratio > 1) {\n                ratio = 1;\n            } else if (ratio < 0) {\n                ratio = 0;\n            }\n            while(i--){\n                (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getPositionOnPath)(rawPaths[i], ratio, !i && data.rotate, rawPaths[i]);\n            }\n            while(pt){\n                pt.set(pt.t, pt.p, pt.path[pt.pp] + pt.u, pt.d, ratio);\n                pt = pt._next;\n            }\n            data.rotate && data.rSet(data.target, data.rProp, rawPaths[0].angle * (data.radians ? _DEG2RAD : 1) + data.rOffset + data.ru, data, ratio);\n        } else {\n            data.styles.revert();\n        }\n    },\n    getLength: function getLength(path) {\n        return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements)((0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath)(path)).totalLength;\n    },\n    sliceRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.sliceRawPath,\n    getRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath,\n    pointsToSegment: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment,\n    stringToRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.stringToRawPath,\n    rawPathToString: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.rawPathToString,\n    transformRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath,\n    getGlobalMatrix: _utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix,\n    getPositionOnPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getPositionOnPath,\n    cacheRawPathMeasurements: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements,\n    convertToPath: function convertToPath(targets, swap) {\n        return _toArray(targets).map(function(target) {\n            return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.convertToPath)(target, swap !== false);\n        });\n    },\n    convertCoordinates: function convertCoordinates(fromElement, toElement, point) {\n        var m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(toElement, true, true).multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(fromElement));\n        return point ? m.apply(point) : m;\n    },\n    getAlignMatrix: _getAlignMatrix,\n    getRelativePosition: function getRelativePosition(fromElement, toElement, fromOrigin, toOrigin) {\n        var m = _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin);\n        return {\n            x: m.e,\n            y: m.f\n        };\n    },\n    arrayToRawPath: function arrayToRawPath(value, vars) {\n        vars = vars || {};\n        var segment = _populateSegmentFromArray(_populateSegmentFromArray([], value, vars.x || \"x\", 0), value, vars.y || \"y\", 1);\n        vars.relative && _relativize(segment);\n        return [\n            vars.type === \"cubic\" ? segment : (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment)(segment, vars.curviness)\n        ];\n    }\n};\n_getGSAP() && gsap.registerPlugin(MotionPathPlugin);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9Nb3Rpb25QYXRoUGx1Z2luLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFRQSxHQUVBLGtCQUFrQixHQUNrTjtBQUNoTDtBQUVwRCxJQUFJWSxVQUFVLHdDQUF3Q0MsS0FBSyxDQUFDLE1BQ3hEQyxVQUFVLHNDQUFzQ0QsS0FBSyxDQUFDLE1BQ3RERSxXQUFXQyxLQUFLQyxFQUFFLEdBQUcsS0FDckJDLE1BQ0FDLFdBQ0FDLFVBQ0FDLFVBQ0FDLGdCQUNBQyxZQUNBQyxXQUFXLFNBQVNBO0lBQ3RCLE9BQU9OLFFBQVEsT0FBT08sV0FBVyxlQUFnQlAsQ0FBQUEsT0FBT08sT0FBT1AsSUFBSSxLQUFLQSxLQUFLUSxjQUFjLElBQUlSO0FBQ2pHLEdBQ0lTLDRCQUE0QixTQUFTQSwwQkFBMEJDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLElBQUk7SUFDaEcsbUVBQW1FO0lBQ25FLElBQUlDLElBQUlILE9BQU9JLE1BQU0sRUFDakJDLEtBQUtILFNBQVMsSUFBSSxJQUFJQSxNQUN0QkksSUFBSSxHQUNKQztJQUVKLE1BQU9ELElBQUlILEdBQUdHLElBQUs7UUFDakJQLE9BQU8sQ0FBQ00sR0FBRyxHQUFHRSxJQUFJQyxXQUFXUixNQUFNLENBQUNNLEVBQUUsQ0FBQ0wsU0FBUztRQUNoREMsU0FBUyxLQUFNSCxDQUFBQSxPQUFPLENBQUNNLEtBQUssRUFBRSxHQUFHO1FBQ2pDQSxNQUFNO0lBQ1I7SUFFQSxPQUFPTjtBQUNULEdBQ0lVLGNBQWMsU0FBU0EsWUFBWUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLElBQUk7SUFDdkQsT0FBT0osV0FBV0UsT0FBT0csS0FBSyxDQUFDQyxHQUFHLENBQUNKLFFBQVFDLE1BQU1DLFFBQVEsVUFBVTtBQUNyRSxHQUNJRyxjQUFjLFNBQVNBLFlBQVloQixPQUFPO0lBQzVD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QUNSO0lBQ0Y7SUFDQStGLGdCQUFnQixTQUFTQSxlQUFlQyxLQUFLLEVBQUVqSSxJQUFJO1FBQ2pEQSxPQUFPQSxRQUFRLENBQUM7UUFFaEIsSUFBSXRCLFVBQVVELDBCQUEwQkEsMEJBQTBCLEVBQUUsRUFBRXdKLE9BQU9qSSxLQUFLTCxDQUFDLElBQUksS0FBSyxJQUFJc0ksT0FBT2pJLEtBQUtKLENBQUMsSUFBSSxLQUFLO1FBRXRISSxLQUFLTSxRQUFRLElBQUlaLFlBQVloQjtRQUM3QixPQUFPO1lBQUNzQixLQUFLRyxJQUFJLEtBQUssVUFBVXpCLFVBQVV6QixnRUFBZUEsQ0FBQ3lCLFNBQVNzQixLQUFLUSxTQUFTO1NBQUU7SUFDckY7QUFDRixFQUFFO0FBQ0ZsQyxjQUFjTixLQUFLUSxjQUFjLENBQUN1RztBQUNLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9Nb3Rpb25QYXRoUGx1Z2luLmpzP2I0MWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb3Rpb25QYXRoUGx1Z2luIDMuMTIuNVxuICogaHR0cHM6Ly9nc2FwLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjQsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3NhcC5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR1NBUCBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCB7IGdldFJhd1BhdGgsIGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cywgZ2V0UG9zaXRpb25PblBhdGgsIHBvaW50c1RvU2VnbWVudCwgZmxhdFBvaW50c1RvU2VnbWVudCwgc2xpY2VSYXdQYXRoLCBzdHJpbmdUb1Jhd1BhdGgsIHJhd1BhdGhUb1N0cmluZywgdHJhbnNmb3JtUmF3UGF0aCwgY29udmVydFRvUGF0aCBhcyBfY29udmVydFRvUGF0aCB9IGZyb20gXCIuL3V0aWxzL3BhdGhzLmpzXCI7XG5pbXBvcnQgeyBnZXRHbG9iYWxNYXRyaXggfSBmcm9tIFwiLi91dGlscy9tYXRyaXguanNcIjtcblxudmFyIF94UHJvcHMgPSBcIngsdHJhbnNsYXRlWCxsZWZ0LG1hcmdpbkxlZnQseFBlcmNlbnRcIi5zcGxpdChcIixcIiksXG4gICAgX3lQcm9wcyA9IFwieSx0cmFuc2xhdGVZLHRvcCxtYXJnaW5Ub3AseVBlcmNlbnRcIi5zcGxpdChcIixcIiksXG4gICAgX0RFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLFxuICAgIGdzYXAsXG4gICAgUHJvcFR3ZWVuLFxuICAgIF9nZXRVbml0LFxuICAgIF90b0FycmF5LFxuICAgIF9nZXRTdHlsZVNhdmVyLFxuICAgIF9yZXZlcnRpbmcsXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9wb3B1bGF0ZVNlZ21lbnRGcm9tQXJyYXkgPSBmdW5jdGlvbiBfcG9wdWxhdGVTZWdtZW50RnJvbUFycmF5KHNlZ21lbnQsIHZhbHVlcywgcHJvcGVydHksIG1vZGUpIHtcbiAgLy9tb2RlOiAwID0geCBidXQgZG9uJ3QgZmlsbCB5IHlldCwgMSA9IHksIDIgPSB4IGFuZCBmaWxsIHkgd2l0aCAwLlxuICB2YXIgbCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBzaSA9IG1vZGUgPT09IDIgPyAwIDogbW9kZSxcbiAgICAgIGkgPSAwLFxuICAgICAgdjtcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIHNlZ21lbnRbc2ldID0gdiA9IHBhcnNlRmxvYXQodmFsdWVzW2ldW3Byb3BlcnR5XSk7XG4gICAgbW9kZSA9PT0gMiAmJiAoc2VnbWVudFtzaSArIDFdID0gMCk7XG4gICAgc2kgKz0gMjtcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50O1xufSxcbiAgICBfZ2V0UHJvcE51bSA9IGZ1bmN0aW9uIF9nZXRQcm9wTnVtKHRhcmdldCwgcHJvcCwgdW5pdCkge1xuICByZXR1cm4gcGFyc2VGbG9hdCh0YXJnZXQuX2dzYXAuZ2V0KHRhcmdldCwgcHJvcCwgdW5pdCB8fCBcInB4XCIpKSB8fCAwO1xufSxcbiAgICBfcmVsYXRpdml6ZSA9IGZ1bmN0aW9uIF9yZWxhdGl2aXplKHNlZ21lbnQpIHtcbiAgdmFyIHggPSBzZWdtZW50WzBdLFxuICAgICAgeSA9IHNlZ21lbnRbMV0sXG4gICAgICBpO1xuXG4gIGZvciAoaSA9IDI7IGkgPCBzZWdtZW50Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgeCA9IHNlZ21lbnRbaV0gKz0geDtcbiAgICB5ID0gc2VnbWVudFtpICsgMV0gKz0geTtcbiAgfVxufSxcbiAgICAvLyBmZWVkIGluIGFuIGFycmF5IG9mIHF1YWRyYXRpYyBiZXppZXIgcG9pbnRzIGxpa2UgW3t4OiAwLCB5OiAwfSwgLi4uXSBhbmQgaXQnbGwgY29udmVydCBpdCB0byBjdWJpYyBiZXppZXJcbi8vIF9xdWFkVG9DdWJpYyA9IHBvaW50cyA9PiB7XG4vLyBcdGxldCBjdWJpYyA9IFtdLFxuLy8gXHRcdGwgPSBwb2ludHMubGVuZ3RoIC0gMSxcbi8vIFx0XHRpID0gMSxcbi8vIFx0XHRhLCBiLCBjO1xuLy8gXHRmb3IgKDsgaSA8IGw7IGkrPTIpIHtcbi8vIFx0XHRhID0gcG9pbnRzW2ktMV07XG4vLyBcdFx0YiA9IHBvaW50c1tpXTtcbi8vIFx0XHRjID0gcG9pbnRzW2krMV07XG4vLyBcdFx0Y3ViaWMucHVzaChhLCB7eDogKDIgKiBiLnggKyBhLngpIC8gMywgeTogKDIgKiBiLnkgKyBhLnkpIC8gM30sIHt4OiAoMiAqIGIueCArIGMueCkgLyAzLCB5OiAoMiAqIGIueSArIGMueSkgLyAzfSk7XG4vLyBcdH1cbi8vIFx0Y3ViaWMucHVzaChwb2ludHNbbF0pO1xuLy8gXHRyZXR1cm4gY3ViaWM7XG4vLyB9LFxuX3NlZ21lbnRUb1Jhd1BhdGggPSBmdW5jdGlvbiBfc2VnbWVudFRvUmF3UGF0aChwbHVnaW4sIHNlZ21lbnQsIHRhcmdldCwgeCwgeSwgc2xpY2VyLCB2YXJzLCB1bml0WCwgdW5pdFkpIHtcbiAgaWYgKHZhcnMudHlwZSA9PT0gXCJjdWJpY1wiKSB7XG4gICAgc2VnbWVudCA9IFtzZWdtZW50XTtcbiAgfSBlbHNlIHtcbiAgICB2YXJzLmZyb21DdXJyZW50ICE9PSBmYWxzZSAmJiBzZWdtZW50LnVuc2hpZnQoX2dldFByb3BOdW0odGFyZ2V0LCB4LCB1bml0WCksIHkgPyBfZ2V0UHJvcE51bSh0YXJnZXQsIHksIHVuaXRZKSA6IDApO1xuICAgIHZhcnMucmVsYXRpdmUgJiYgX3JlbGF0aXZpemUoc2VnbWVudCk7XG4gICAgdmFyIHBvaW50RnVuYyA9IHkgPyBwb2ludHNUb1NlZ21lbnQgOiBmbGF0UG9pbnRzVG9TZWdtZW50O1xuICAgIHNlZ21lbnQgPSBbcG9pbnRGdW5jKHNlZ21lbnQsIHZhcnMuY3VydmluZXNzKV07XG4gIH1cblxuICBzZWdtZW50ID0gc2xpY2VyKF9hbGlnbihzZWdtZW50LCB0YXJnZXQsIHZhcnMpKTtcblxuICBfYWRkRGltZW5zaW9uYWxQcm9wVHdlZW4ocGx1Z2luLCB0YXJnZXQsIHgsIHNlZ21lbnQsIFwieFwiLCB1bml0WCk7XG5cbiAgeSAmJiBfYWRkRGltZW5zaW9uYWxQcm9wVHdlZW4ocGx1Z2luLCB0YXJnZXQsIHksIHNlZ21lbnQsIFwieVwiLCB1bml0WSk7XG4gIHJldHVybiBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMoc2VnbWVudCwgdmFycy5yZXNvbHV0aW9uIHx8ICh2YXJzLmN1cnZpbmVzcyA9PT0gMCA/IDIwIDogMTIpKTsgLy93aGVuIGN1cnZpbmVzcyBpcyAwLCBpdCBjcmVhdGVzIGNvbnRyb2wgcG9pbnRzIHJpZ2h0IG9uIHRvcCBvZiB0aGUgYW5jaG9ycyB3aGljaCBtYWtlcyBpdCBtb3JlIHNlbnNpdGl2ZSB0byByZXNvbHV0aW9uLCB0aHVzIHdlIGNoYW5nZSB0aGUgZGVmYXVsdCBhY2NvcmRpbmdseS5cbn0sXG4gICAgX2VtcHR5RnVuYyA9IGZ1bmN0aW9uIF9lbXB0eUZ1bmModikge1xuICByZXR1cm4gdjtcbn0sXG4gICAgX251bUV4cCA9IC9bLStcXC5dKlxcZCtcXC4/KD86ZS18ZVxcKyk/XFxkKi9nLFxuICAgIF9vcmlnaW5Ub1BvaW50ID0gZnVuY3Rpb24gX29yaWdpblRvUG9pbnQoZWxlbWVudCwgb3JpZ2luLCBwYXJlbnRNYXRyaXgpIHtcbiAgLy8gb3JpZ2luIGlzIGFuIGFycmF5IG9mIG5vcm1hbGl6ZWQgdmFsdWVzICgwLTEpIGluIHJlbGF0aW9uIHRvIHRoZSB3aWR0aC9oZWlnaHQsIHNvIFswLjUsIDAuNV0gd291bGQgYmUgdGhlIGNlbnRlci4gSXQgY2FuIGFsc28gYmUgXCJhdXRvXCIgaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGJlIHRoZSB0b3AgbGVmdCB1bmxlc3MgaXQncyBhIDxwYXRoPiwgd2hlbiBpdCB3aWxsIHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHBhdGggaXRzZWxmLlxuICB2YXIgbSA9IGdldEdsb2JhbE1hdHJpeChlbGVtZW50KSxcbiAgICAgIHggPSAwLFxuICAgICAgeSA9IDAsXG4gICAgICBzdmc7XG5cbiAgaWYgKChlbGVtZW50LnRhZ05hbWUgKyBcIlwiKS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiKSB7XG4gICAgc3ZnID0gZWxlbWVudC52aWV3Qm94LmJhc2VWYWw7XG4gICAgc3ZnLndpZHRoIHx8IChzdmcgPSB7XG4gICAgICB3aWR0aDogK2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwid2lkdGhcIiksXG4gICAgICBoZWlnaHQ6ICtlbGVtZW50LmdldEF0dHJpYnV0ZShcImhlaWdodFwiKVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHN2ZyA9IG9yaWdpbiAmJiBlbGVtZW50LmdldEJCb3ggJiYgZWxlbWVudC5nZXRCQm94KCk7XG4gIH1cblxuICBpZiAob3JpZ2luICYmIG9yaWdpbiAhPT0gXCJhdXRvXCIpIHtcbiAgICB4ID0gb3JpZ2luLnB1c2ggPyBvcmlnaW5bMF0gKiAoc3ZnID8gc3ZnLndpZHRoIDogZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAwKSA6IG9yaWdpbi54O1xuICAgIHkgPSBvcmlnaW4ucHVzaCA/IG9yaWdpblsxXSAqIChzdmcgPyBzdmcuaGVpZ2h0IDogZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMCkgOiBvcmlnaW4ueTtcbiAgfVxuXG4gIHJldHVybiBwYXJlbnRNYXRyaXguYXBwbHkoeCB8fCB5ID8gbS5hcHBseSh7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0pIDoge1xuICAgIHg6IG0uZSxcbiAgICB5OiBtLmZcbiAgfSk7XG59LFxuICAgIF9nZXRBbGlnbk1hdHJpeCA9IGZ1bmN0aW9uIF9nZXRBbGlnbk1hdHJpeChmcm9tRWxlbWVudCwgdG9FbGVtZW50LCBmcm9tT3JpZ2luLCB0b09yaWdpbikge1xuICB2YXIgcGFyZW50TWF0cml4ID0gZ2V0R2xvYmFsTWF0cml4KGZyb21FbGVtZW50LnBhcmVudE5vZGUsIHRydWUsIHRydWUpLFxuICAgICAgbSA9IHBhcmVudE1hdHJpeC5jbG9uZSgpLm11bHRpcGx5KGdldEdsb2JhbE1hdHJpeCh0b0VsZW1lbnQpKSxcbiAgICAgIGZyb21Qb2ludCA9IF9vcmlnaW5Ub1BvaW50KGZyb21FbGVtZW50LCBmcm9tT3JpZ2luLCBwYXJlbnRNYXRyaXgpLFxuICAgICAgX29yaWdpblRvUG9pbnQyID0gX29yaWdpblRvUG9pbnQodG9FbGVtZW50LCB0b09yaWdpbiwgcGFyZW50TWF0cml4KSxcbiAgICAgIHggPSBfb3JpZ2luVG9Qb2ludDIueCxcbiAgICAgIHkgPSBfb3JpZ2luVG9Qb2ludDIueSxcbiAgICAgIHA7XG5cbiAgbS5lID0gbS5mID0gMDtcblxuICBpZiAodG9PcmlnaW4gPT09IFwiYXV0b1wiICYmIHRvRWxlbWVudC5nZXRUb3RhbExlbmd0aCAmJiB0b0VsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInBhdGhcIikge1xuICAgIHAgPSB0b0VsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZFwiKS5tYXRjaChfbnVtRXhwKSB8fCBbXTtcbiAgICBwID0gbS5hcHBseSh7XG4gICAgICB4OiArcFswXSxcbiAgICAgIHk6ICtwWzFdXG4gICAgfSk7XG4gICAgeCArPSBwLng7XG4gICAgeSArPSBwLnk7XG4gIH0gLy9pZiAocCB8fCAodG9FbGVtZW50LmdldEJCb3ggJiYgZnJvbUVsZW1lbnQuZ2V0QkJveCAmJiB0b0VsZW1lbnQub3duZXJTVkdFbGVtZW50ID09PSBmcm9tRWxlbWVudC5vd25lclNWR0VsZW1lbnQpKSB7XG5cblxuICBpZiAocCkge1xuICAgIHAgPSBtLmFwcGx5KHRvRWxlbWVudC5nZXRCQm94KCkpO1xuICAgIHggLT0gcC54O1xuICAgIHkgLT0gcC55O1xuICB9XG5cbiAgbS5lID0geCAtIGZyb21Qb2ludC54O1xuICBtLmYgPSB5IC0gZnJvbVBvaW50Lnk7XG4gIHJldHVybiBtO1xufSxcbiAgICBfYWxpZ24gPSBmdW5jdGlvbiBfYWxpZ24ocmF3UGF0aCwgdGFyZ2V0LCBfcmVmKSB7XG4gIHZhciBhbGlnbiA9IF9yZWYuYWxpZ24sXG4gICAgICBtYXRyaXggPSBfcmVmLm1hdHJpeCxcbiAgICAgIG9mZnNldFggPSBfcmVmLm9mZnNldFgsXG4gICAgICBvZmZzZXRZID0gX3JlZi5vZmZzZXRZLFxuICAgICAgYWxpZ25PcmlnaW4gPSBfcmVmLmFsaWduT3JpZ2luO1xuXG4gIHZhciB4ID0gcmF3UGF0aFswXVswXSxcbiAgICAgIHkgPSByYXdQYXRoWzBdWzFdLFxuICAgICAgY3VyWCA9IF9nZXRQcm9wTnVtKHRhcmdldCwgXCJ4XCIpLFxuICAgICAgY3VyWSA9IF9nZXRQcm9wTnVtKHRhcmdldCwgXCJ5XCIpLFxuICAgICAgYWxpZ25UYXJnZXQsXG4gICAgICBtLFxuICAgICAgcDtcblxuICBpZiAoIXJhd1BhdGggfHwgIXJhd1BhdGgubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGdldFJhd1BhdGgoXCJNMCwwTDAsMFwiKTtcbiAgfVxuXG4gIGlmIChhbGlnbikge1xuICAgIGlmIChhbGlnbiA9PT0gXCJzZWxmXCIgfHwgKGFsaWduVGFyZ2V0ID0gX3RvQXJyYXkoYWxpZ24pWzBdIHx8IHRhcmdldCkgPT09IHRhcmdldCkge1xuICAgICAgdHJhbnNmb3JtUmF3UGF0aChyYXdQYXRoLCAxLCAwLCAwLCAxLCBjdXJYIC0geCwgY3VyWSAtIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYWxpZ25PcmlnaW4gJiYgYWxpZ25PcmlnaW5bMl0gIT09IGZhbHNlKSB7XG4gICAgICAgIGdzYXAuc2V0KHRhcmdldCwge1xuICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogYWxpZ25PcmlnaW5bMF0gKiAxMDAgKyBcIiUgXCIgKyBhbGlnbk9yaWdpblsxXSAqIDEwMCArIFwiJVwiXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxpZ25PcmlnaW4gPSBbX2dldFByb3BOdW0odGFyZ2V0LCBcInhQZXJjZW50XCIpIC8gLTEwMCwgX2dldFByb3BOdW0odGFyZ2V0LCBcInlQZXJjZW50XCIpIC8gLTEwMF07XG4gICAgICB9XG5cbiAgICAgIG0gPSBfZ2V0QWxpZ25NYXRyaXgodGFyZ2V0LCBhbGlnblRhcmdldCwgYWxpZ25PcmlnaW4sIFwiYXV0b1wiKTtcbiAgICAgIHAgPSBtLmFwcGx5KHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfSk7XG4gICAgICB0cmFuc2Zvcm1SYXdQYXRoKHJhd1BhdGgsIG0uYSwgbS5iLCBtLmMsIG0uZCwgY3VyWCArIG0uZSAtIChwLnggLSBtLmUpLCBjdXJZICsgbS5mIC0gKHAueSAtIG0uZikpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtYXRyaXgpIHtcbiAgICB0cmFuc2Zvcm1SYXdQYXRoKHJhd1BhdGgsIG1hdHJpeC5hLCBtYXRyaXguYiwgbWF0cml4LmMsIG1hdHJpeC5kLCBtYXRyaXguZSwgbWF0cml4LmYpO1xuICB9IGVsc2UgaWYgKG9mZnNldFggfHwgb2Zmc2V0WSkge1xuICAgIHRyYW5zZm9ybVJhd1BhdGgocmF3UGF0aCwgMSwgMCwgMCwgMSwgb2Zmc2V0WCB8fCAwLCBvZmZzZXRZIHx8IDApO1xuICB9XG5cbiAgcmV0dXJuIHJhd1BhdGg7XG59LFxuICAgIF9hZGREaW1lbnNpb25hbFByb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGREaW1lbnNpb25hbFByb3BUd2VlbihwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIHJhd1BhdGgsIHBhdGhQcm9wZXJ0eSwgZm9yY2VVbml0KSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCxcbiAgICAgIGhhcm5lc3MgPSBjYWNoZS5oYXJuZXNzLFxuICAgICAgYWxpYXMgPSBoYXJuZXNzICYmIGhhcm5lc3MuYWxpYXNlcyAmJiBoYXJuZXNzLmFsaWFzZXNbcHJvcGVydHldLFxuICAgICAgcHJvcCA9IGFsaWFzICYmIGFsaWFzLmluZGV4T2YoXCIsXCIpIDwgMCA/IGFsaWFzIDogcHJvcGVydHksXG4gICAgICBwdCA9IHBsdWdpbi5fcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgcHJvcCwgMCwgMCwgX2VtcHR5RnVuYywgMCwgY2FjaGUuc2V0KHRhcmdldCwgcHJvcCwgcGx1Z2luKSk7XG4gIHB0LnUgPSBfZ2V0VW5pdChjYWNoZS5nZXQodGFyZ2V0LCBwcm9wLCBmb3JjZVVuaXQpKSB8fCAwO1xuICBwdC5wYXRoID0gcmF3UGF0aDtcbiAgcHQucHAgPSBwYXRoUHJvcGVydHk7XG5cbiAgcGx1Z2luLl9wcm9wcy5wdXNoKHByb3ApO1xufSxcbiAgICBfc2xpY2VNb2RpZmllciA9IGZ1bmN0aW9uIF9zbGljZU1vZGlmaWVyKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyYXdQYXRoKSB7XG4gICAgcmV0dXJuIHN0YXJ0IHx8IGVuZCAhPT0gMSA/IHNsaWNlUmF3UGF0aChyYXdQYXRoLCBzdGFydCwgZW5kKSA6IHJhd1BhdGg7XG4gIH07XG59O1xuXG5leHBvcnQgdmFyIE1vdGlvblBhdGhQbHVnaW4gPSB7XG4gIHZlcnNpb246IFwiMy4xMi41XCIsXG4gIG5hbWU6IFwibW90aW9uUGF0aFwiLFxuICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoY29yZSwgUGx1Z2luLCBwcm9wVHdlZW4pIHtcbiAgICBnc2FwID0gY29yZTtcbiAgICBfZ2V0VW5pdCA9IGdzYXAudXRpbHMuZ2V0VW5pdDtcbiAgICBfdG9BcnJheSA9IGdzYXAudXRpbHMudG9BcnJheTtcbiAgICBfZ2V0U3R5bGVTYXZlciA9IGdzYXAuY29yZS5nZXRTdHlsZVNhdmVyO1xuXG4gICAgX3JldmVydGluZyA9IGdzYXAuY29yZS5yZXZlcnRpbmcgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICBQcm9wVHdlZW4gPSBwcm9wVHdlZW47XG4gIH0sXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YXJzLCB0d2Vlbikge1xuICAgIGlmICghZ3NhcCkge1xuICAgICAgY29uc29sZS53YXJuKFwiUGxlYXNlIGdzYXAucmVnaXN0ZXJQbHVnaW4oTW90aW9uUGF0aFBsdWdpbilcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCEodHlwZW9mIHZhcnMgPT09IFwib2JqZWN0XCIgJiYgIXZhcnMuc3R5bGUpIHx8ICF2YXJzLnBhdGgpIHtcbiAgICAgIHZhcnMgPSB7XG4gICAgICAgIHBhdGg6IHZhcnNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHJhd1BhdGhzID0gW10sXG4gICAgICAgIF92YXJzID0gdmFycyxcbiAgICAgICAgcGF0aCA9IF92YXJzLnBhdGgsXG4gICAgICAgIGF1dG9Sb3RhdGUgPSBfdmFycy5hdXRvUm90YXRlLFxuICAgICAgICB1bml0WCA9IF92YXJzLnVuaXRYLFxuICAgICAgICB1bml0WSA9IF92YXJzLnVuaXRZLFxuICAgICAgICB4ID0gX3ZhcnMueCxcbiAgICAgICAgeSA9IF92YXJzLnksXG4gICAgICAgIGZpcnN0T2JqID0gcGF0aFswXSxcbiAgICAgICAgc2xpY2VyID0gX3NsaWNlTW9kaWZpZXIodmFycy5zdGFydCwgXCJlbmRcIiBpbiB2YXJzID8gdmFycy5lbmQgOiAxKSxcbiAgICAgICAgcmF3UGF0aCxcbiAgICAgICAgcDtcblxuICAgIHRoaXMucmF3UGF0aHMgPSByYXdQYXRocztcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLnR3ZWVuID0gdHdlZW47XG4gICAgdGhpcy5zdHlsZXMgPSBfZ2V0U3R5bGVTYXZlciAmJiBfZ2V0U3R5bGVTYXZlcih0YXJnZXQsIFwidHJhbnNmb3JtXCIpO1xuXG4gICAgaWYgKHRoaXMucm90YXRlID0gYXV0b1JvdGF0ZSB8fCBhdXRvUm90YXRlID09PSAwKSB7XG4gICAgICAvL2dldCB0aGUgcm90YXRpb25hbCBkYXRhIEZJUlNUIHNvIHRoYXQgdGhlIHNldFRyYW5zZm9ybSgpIG1ldGhvZCBpcyBjYWxsZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIgaW4gdGhlIHJlbmRlcigpIGxvb3AgLSByb3RhdGlvbiBnZXRzIHNldCBsYXN0LlxuICAgICAgdGhpcy5yT2Zmc2V0ID0gcGFyc2VGbG9hdChhdXRvUm90YXRlKSB8fCAwO1xuICAgICAgdGhpcy5yYWRpYW5zID0gISF2YXJzLnVzZVJhZGlhbnM7XG4gICAgICB0aGlzLnJQcm9wID0gdmFycy5yb3RhdGlvbiB8fCBcInJvdGF0aW9uXCI7IC8vIHJvdGF0aW9uIHByb3BlcnR5XG5cbiAgICAgIHRoaXMuclNldCA9IHRhcmdldC5fZ3NhcC5zZXQodGFyZ2V0LCB0aGlzLnJQcm9wLCB0aGlzKTsgLy8gcm90YXRpb24gc2V0dGVyXG5cbiAgICAgIHRoaXMucnUgPSBfZ2V0VW5pdCh0YXJnZXQuX2dzYXAuZ2V0KHRhcmdldCwgdGhpcy5yUHJvcCkpIHx8IDA7IC8vIHJvdGF0aW9uIHVuaXRzXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkgJiYgIShcImNsb3NlZFwiIGluIHBhdGgpICYmIHR5cGVvZiBmaXJzdE9iaiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgZm9yIChwIGluIGZpcnN0T2JqKSB7XG4gICAgICAgIGlmICgheCAmJiB+X3hQcm9wcy5pbmRleE9mKHApKSB7XG4gICAgICAgICAgeCA9IHA7XG4gICAgICAgIH0gZWxzZSBpZiAoIXkgJiYgfl95UHJvcHMuaW5kZXhPZihwKSkge1xuICAgICAgICAgIHkgPSBwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh4ICYmIHkpIHtcbiAgICAgICAgLy9jb3JyZWxhdGVkIHZhbHVlc1xuICAgICAgICByYXdQYXRocy5wdXNoKF9zZWdtZW50VG9SYXdQYXRoKHRoaXMsIF9wb3B1bGF0ZVNlZ21lbnRGcm9tQXJyYXkoX3BvcHVsYXRlU2VnbWVudEZyb21BcnJheShbXSwgcGF0aCwgeCwgMCksIHBhdGgsIHksIDEpLCB0YXJnZXQsIHgsIHksIHNsaWNlciwgdmFycywgdW5pdFggfHwgX2dldFVuaXQocGF0aFswXVt4XSksIHVuaXRZIHx8IF9nZXRVbml0KHBhdGhbMF1beV0pKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0geSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAocCBpbiBmaXJzdE9iaikge1xuICAgICAgICBwICE9PSB4ICYmIHAgIT09IHkgJiYgcmF3UGF0aHMucHVzaChfc2VnbWVudFRvUmF3UGF0aCh0aGlzLCBfcG9wdWxhdGVTZWdtZW50RnJvbUFycmF5KFtdLCBwYXRoLCBwLCAyKSwgdGFyZ2V0LCBwLCAwLCBzbGljZXIsIHZhcnMsIF9nZXRVbml0KHBhdGhbMF1bcF0pKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhd1BhdGggPSBzbGljZXIoX2FsaWduKGdldFJhd1BhdGgodmFycy5wYXRoKSwgdGFyZ2V0LCB2YXJzKSk7XG4gICAgICBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMocmF3UGF0aCwgdmFycy5yZXNvbHV0aW9uKTtcbiAgICAgIHJhd1BhdGhzLnB1c2gocmF3UGF0aCk7XG5cbiAgICAgIF9hZGREaW1lbnNpb25hbFByb3BUd2Vlbih0aGlzLCB0YXJnZXQsIHZhcnMueCB8fCBcInhcIiwgcmF3UGF0aCwgXCJ4XCIsIHZhcnMudW5pdFggfHwgXCJweFwiKTtcblxuICAgICAgX2FkZERpbWVuc2lvbmFsUHJvcFR3ZWVuKHRoaXMsIHRhcmdldCwgdmFycy55IHx8IFwieVwiLCByYXdQYXRoLCBcInlcIiwgdmFycy51bml0WSB8fCBcInB4XCIpO1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocmF0aW8sIGRhdGEpIHtcbiAgICB2YXIgcmF3UGF0aHMgPSBkYXRhLnJhd1BhdGhzLFxuICAgICAgICBpID0gcmF3UGF0aHMubGVuZ3RoLFxuICAgICAgICBwdCA9IGRhdGEuX3B0O1xuXG4gICAgaWYgKGRhdGEudHdlZW4uX3RpbWUgfHwgIV9yZXZlcnRpbmcoKSkge1xuICAgICAgaWYgKHJhdGlvID4gMSkge1xuICAgICAgICByYXRpbyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHJhdGlvIDwgMCkge1xuICAgICAgICByYXRpbyA9IDA7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgZ2V0UG9zaXRpb25PblBhdGgocmF3UGF0aHNbaV0sIHJhdGlvLCAhaSAmJiBkYXRhLnJvdGF0ZSwgcmF3UGF0aHNbaV0pO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAocHQpIHtcbiAgICAgICAgcHQuc2V0KHB0LnQsIHB0LnAsIHB0LnBhdGhbcHQucHBdICsgcHQudSwgcHQuZCwgcmF0aW8pO1xuICAgICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgICAgfVxuXG4gICAgICBkYXRhLnJvdGF0ZSAmJiBkYXRhLnJTZXQoZGF0YS50YXJnZXQsIGRhdGEuclByb3AsIHJhd1BhdGhzWzBdLmFuZ2xlICogKGRhdGEucmFkaWFucyA/IF9ERUcyUkFEIDogMSkgKyBkYXRhLnJPZmZzZXQgKyBkYXRhLnJ1LCBkYXRhLCByYXRpbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEuc3R5bGVzLnJldmVydCgpO1xuICAgIH1cbiAgfSxcbiAgZ2V0TGVuZ3RoOiBmdW5jdGlvbiBnZXRMZW5ndGgocGF0aCkge1xuICAgIHJldHVybiBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMoZ2V0UmF3UGF0aChwYXRoKSkudG90YWxMZW5ndGg7XG4gIH0sXG4gIHNsaWNlUmF3UGF0aDogc2xpY2VSYXdQYXRoLFxuICBnZXRSYXdQYXRoOiBnZXRSYXdQYXRoLFxuICBwb2ludHNUb1NlZ21lbnQ6IHBvaW50c1RvU2VnbWVudCxcbiAgc3RyaW5nVG9SYXdQYXRoOiBzdHJpbmdUb1Jhd1BhdGgsXG4gIHJhd1BhdGhUb1N0cmluZzogcmF3UGF0aFRvU3RyaW5nLFxuICB0cmFuc2Zvcm1SYXdQYXRoOiB0cmFuc2Zvcm1SYXdQYXRoLFxuICBnZXRHbG9iYWxNYXRyaXg6IGdldEdsb2JhbE1hdHJpeCxcbiAgZ2V0UG9zaXRpb25PblBhdGg6IGdldFBvc2l0aW9uT25QYXRoLFxuICBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHM6IGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyxcbiAgY29udmVydFRvUGF0aDogZnVuY3Rpb24gY29udmVydFRvUGF0aCh0YXJnZXRzLCBzd2FwKSB7XG4gICAgcmV0dXJuIF90b0FycmF5KHRhcmdldHMpLm1hcChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gX2NvbnZlcnRUb1BhdGgodGFyZ2V0LCBzd2FwICE9PSBmYWxzZSk7XG4gICAgfSk7XG4gIH0sXG4gIGNvbnZlcnRDb29yZGluYXRlczogZnVuY3Rpb24gY29udmVydENvb3JkaW5hdGVzKGZyb21FbGVtZW50LCB0b0VsZW1lbnQsIHBvaW50KSB7XG4gICAgdmFyIG0gPSBnZXRHbG9iYWxNYXRyaXgodG9FbGVtZW50LCB0cnVlLCB0cnVlKS5tdWx0aXBseShnZXRHbG9iYWxNYXRyaXgoZnJvbUVsZW1lbnQpKTtcbiAgICByZXR1cm4gcG9pbnQgPyBtLmFwcGx5KHBvaW50KSA6IG07XG4gIH0sXG4gIGdldEFsaWduTWF0cml4OiBfZ2V0QWxpZ25NYXRyaXgsXG4gIGdldFJlbGF0aXZlUG9zaXRpb246IGZ1bmN0aW9uIGdldFJlbGF0aXZlUG9zaXRpb24oZnJvbUVsZW1lbnQsIHRvRWxlbWVudCwgZnJvbU9yaWdpbiwgdG9PcmlnaW4pIHtcbiAgICB2YXIgbSA9IF9nZXRBbGlnbk1hdHJpeChmcm9tRWxlbWVudCwgdG9FbGVtZW50LCBmcm9tT3JpZ2luLCB0b09yaWdpbik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogbS5lLFxuICAgICAgeTogbS5mXG4gICAgfTtcbiAgfSxcbiAgYXJyYXlUb1Jhd1BhdGg6IGZ1bmN0aW9uIGFycmF5VG9SYXdQYXRoKHZhbHVlLCB2YXJzKSB7XG4gICAgdmFycyA9IHZhcnMgfHwge307XG5cbiAgICB2YXIgc2VnbWVudCA9IF9wb3B1bGF0ZVNlZ21lbnRGcm9tQXJyYXkoX3BvcHVsYXRlU2VnbWVudEZyb21BcnJheShbXSwgdmFsdWUsIHZhcnMueCB8fCBcInhcIiwgMCksIHZhbHVlLCB2YXJzLnkgfHwgXCJ5XCIsIDEpO1xuXG4gICAgdmFycy5yZWxhdGl2ZSAmJiBfcmVsYXRpdml6ZShzZWdtZW50KTtcbiAgICByZXR1cm4gW3ZhcnMudHlwZSA9PT0gXCJjdWJpY1wiID8gc2VnbWVudCA6IHBvaW50c1RvU2VnbWVudChzZWdtZW50LCB2YXJzLmN1cnZpbmVzcyldO1xuICB9XG59O1xuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKE1vdGlvblBhdGhQbHVnaW4pO1xuZXhwb3J0IHsgTW90aW9uUGF0aFBsdWdpbiBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbImdldFJhd1BhdGgiLCJjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMiLCJnZXRQb3NpdGlvbk9uUGF0aCIsInBvaW50c1RvU2VnbWVudCIsImZsYXRQb2ludHNUb1NlZ21lbnQiLCJzbGljZVJhd1BhdGgiLCJzdHJpbmdUb1Jhd1BhdGgiLCJyYXdQYXRoVG9TdHJpbmciLCJ0cmFuc2Zvcm1SYXdQYXRoIiwiY29udmVydFRvUGF0aCIsIl9jb252ZXJ0VG9QYXRoIiwiZ2V0R2xvYmFsTWF0cml4IiwiX3hQcm9wcyIsInNwbGl0IiwiX3lQcm9wcyIsIl9ERUcyUkFEIiwiTWF0aCIsIlBJIiwiZ3NhcCIsIlByb3BUd2VlbiIsIl9nZXRVbml0IiwiX3RvQXJyYXkiLCJfZ2V0U3R5bGVTYXZlciIsIl9yZXZlcnRpbmciLCJfZ2V0R1NBUCIsIndpbmRvdyIsInJlZ2lzdGVyUGx1Z2luIiwiX3BvcHVsYXRlU2VnbWVudEZyb21BcnJheSIsInNlZ21lbnQiLCJ2YWx1ZXMiLCJwcm9wZXJ0eSIsIm1vZGUiLCJsIiwibGVuZ3RoIiwic2kiLCJpIiwidiIsInBhcnNlRmxvYXQiLCJfZ2V0UHJvcE51bSIsInRhcmdldCIsInByb3AiLCJ1bml0IiwiX2dzYXAiLCJnZXQiLCJfcmVsYXRpdml6ZSIsIngiLCJ5IiwiX3NlZ21lbnRUb1Jhd1BhdGgiLCJwbHVnaW4iLCJzbGljZXIiLCJ2YXJzIiwidW5pdFgiLCJ1bml0WSIsInR5cGUiLCJmcm9tQ3VycmVudCIsInVuc2hpZnQiLCJyZWxhdGl2ZSIsInBvaW50RnVuYyIsImN1cnZpbmVzcyIsIl9hbGlnbiIsIl9hZGREaW1lbnNpb25hbFByb3BUd2VlbiIsInJlc29sdXRpb24iLCJfZW1wdHlGdW5jIiwiX251bUV4cCIsIl9vcmlnaW5Ub1BvaW50IiwiZWxlbWVudCIsIm9yaWdpbiIsInBhcmVudE1hdHJpeCIsIm0iLCJzdmciLCJ0YWdOYW1lIiwidG9Mb3dlckNhc2UiLCJ2aWV3Qm94IiwiYmFzZVZhbCIsIndpZHRoIiwiZ2V0QXR0cmlidXRlIiwiaGVpZ2h0IiwiZ2V0QkJveCIsInB1c2giLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImFwcGx5IiwiZSIsImYiLCJfZ2V0QWxpZ25NYXRyaXgiLCJmcm9tRWxlbWVudCIsInRvRWxlbWVudCIsImZyb21PcmlnaW4iLCJ0b09yaWdpbiIsInBhcmVudE5vZGUiLCJjbG9uZSIsIm11bHRpcGx5IiwiZnJvbVBvaW50IiwiX29yaWdpblRvUG9pbnQyIiwicCIsImdldFRvdGFsTGVuZ3RoIiwibWF0Y2giLCJyYXdQYXRoIiwiX3JlZiIsImFsaWduIiwibWF0cml4Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJhbGlnbk9yaWdpbiIsImN1clgiLCJjdXJZIiwiYWxpZ25UYXJnZXQiLCJzZXQiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJhIiwiYiIsImMiLCJkIiwicGF0aFByb3BlcnR5IiwiZm9yY2VVbml0IiwiY2FjaGUiLCJoYXJuZXNzIiwiYWxpYXMiLCJhbGlhc2VzIiwiaW5kZXhPZiIsInB0IiwiX3B0IiwidSIsInBhdGgiLCJwcCIsIl9wcm9wcyIsIl9zbGljZU1vZGlmaWVyIiwic3RhcnQiLCJlbmQiLCJNb3Rpb25QYXRoUGx1Z2luIiwidmVyc2lvbiIsIm5hbWUiLCJyZWdpc3RlciIsImNvcmUiLCJQbHVnaW4iLCJwcm9wVHdlZW4iLCJ1dGlscyIsImdldFVuaXQiLCJ0b0FycmF5IiwiZ2V0U3R5bGVTYXZlciIsInJldmVydGluZyIsImluaXQiLCJ0d2VlbiIsImNvbnNvbGUiLCJ3YXJuIiwic3R5bGUiLCJyYXdQYXRocyIsIl92YXJzIiwiYXV0b1JvdGF0ZSIsImZpcnN0T2JqIiwic3R5bGVzIiwicm90YXRlIiwick9mZnNldCIsInJhZGlhbnMiLCJ1c2VSYWRpYW5zIiwiclByb3AiLCJyb3RhdGlvbiIsInJTZXQiLCJydSIsIkFycmF5IiwiaXNBcnJheSIsInJlbmRlciIsInJhdGlvIiwiZGF0YSIsIl90aW1lIiwidCIsIl9uZXh0IiwiYW5nbGUiLCJyZXZlcnQiLCJnZXRMZW5ndGgiLCJ0b3RhbExlbmd0aCIsInRhcmdldHMiLCJzd2FwIiwibWFwIiwiY29udmVydENvb3JkaW5hdGVzIiwicG9pbnQiLCJnZXRBbGlnbk1hdHJpeCIsImdldFJlbGF0aXZlUG9zaXRpb24iLCJhcnJheVRvUmF3UGF0aCIsInZhbHVlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/MotionPathPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Observer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Observer.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Observer: function() { return /* binding */ Observer; },\n/* harmony export */   _getProxyProp: function() { return /* binding */ _getProxyProp; },\n/* harmony export */   _getScrollFunc: function() { return /* binding */ _getScrollFunc; },\n/* harmony export */   _getTarget: function() { return /* binding */ _getTarget; },\n/* harmony export */   _getVelocityProp: function() { return /* binding */ _getVelocityProp; },\n/* harmony export */   _horizontal: function() { return /* binding */ _horizontal; },\n/* harmony export */   _isViewport: function() { return /* binding */ _isViewport; },\n/* harmony export */   _proxies: function() { return /* binding */ _proxies; },\n/* harmony export */   _scrollers: function() { return /* binding */ _scrollers; },\n/* harmony export */   _vertical: function() { return /* binding */ _vertical; },\n/* harmony export */   \"default\": function() { return /* binding */ Observer; }\n/* harmony export */ });\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\n/*!\n * Observer 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var gsap, _coreInitted, _clamp, _win, _doc, _docEl, _body, _isTouch, _pointerType, ScrollTrigger, _root, _normalizer, _eventTypes, _context, _getGSAP = function _getGSAP() {\n    return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _startup = 1, _observers = [], _scrollers = [], _proxies = [], _getTime = Date.now, _bridge = function _bridge(name, value) {\n    return value;\n}, _integrate = function _integrate() {\n    var core = ScrollTrigger.core, data = core.bridge || {}, scrollers = core._scrollers, proxies = core._proxies;\n    scrollers.push.apply(scrollers, _scrollers);\n    proxies.push.apply(proxies, _proxies);\n    _scrollers = scrollers;\n    _proxies = proxies;\n    _bridge = function _bridge(name, value) {\n        return data[name](value);\n    };\n}, _getProxyProp = function _getProxyProp(element, property) {\n    return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];\n}, _isViewport = function _isViewport(el) {\n    return !!~_root.indexOf(el);\n}, _addListener = function _addListener(element, type, func, passive, capture) {\n    return element.addEventListener(type, func, {\n        passive: passive !== false,\n        capture: !!capture\n    });\n}, _removeListener = function _removeListener(element, type, func, capture) {\n    return element.removeEventListener(type, func, !!capture);\n}, _scrollLeft = \"scrollLeft\", _scrollTop = \"scrollTop\", _onScroll = function _onScroll() {\n    return _normalizer && _normalizer.isPressed || _scrollers.cache++;\n}, _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {\n    var cachingFunc = function cachingFunc(value) {\n        // since reading the scrollTop/scrollLeft/pageOffsetY/pageOffsetX can trigger a layout, this function allows us to cache the value so it only gets read fresh after a \"scroll\" event fires (or while we're refreshing because that can lengthen the page and alter the scroll position). when \"soft\" is true, that means don't actually set the scroll, but cache the new value instead (useful in ScrollSmoother)\n        if (value || value === 0) {\n            _startup && (_win.history.scrollRestoration = \"manual\"); // otherwise the new position will get overwritten by the browser onload.\n            var isNormalizing = _normalizer && _normalizer.isPressed;\n            value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0); //TODO: iOS Bug: if you allow it to go to 0, Safari can start to report super strange (wildly inaccurate) touch positions!\n            f(value);\n            cachingFunc.cacheID = _scrollers.cache;\n            isNormalizing && _bridge(\"ss\", value); // set scroll (notify ScrollTrigger so it can dispatch a \"scrollStart\" event if necessary\n        } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge(\"ref\")) {\n            cachingFunc.cacheID = _scrollers.cache;\n            cachingFunc.v = f();\n        }\n        return cachingFunc.v + cachingFunc.offset;\n    };\n    cachingFunc.offset = 0;\n    return f && cachingFunc;\n}, _horizontal = {\n    s: _scrollLeft,\n    p: \"left\",\n    p2: \"Left\",\n    os: \"right\",\n    os2: \"Right\",\n    d: \"width\",\n    d2: \"Width\",\n    a: \"x\",\n    sc: _scrollCacheFunc(function(value) {\n        return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;\n    })\n}, _vertical = {\n    s: _scrollTop,\n    p: \"top\",\n    p2: \"Top\",\n    os: \"bottom\",\n    os2: \"Bottom\",\n    d: \"height\",\n    d2: \"Height\",\n    a: \"y\",\n    op: _horizontal,\n    sc: _scrollCacheFunc(function(value) {\n        return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;\n    })\n}, _getTarget = function _getTarget(t, self) {\n    return (self && self._ctx && self._ctx.selector || gsap.utils.toArray)(t)[0] || (typeof t === \"string\" && gsap.config().nullTargetWarn !== false ? console.warn(\"Element not found:\", t) : null);\n}, _getScrollFunc = function _getScrollFunc(element, _ref) {\n    var s = _ref.s, sc = _ref.sc;\n    // we store the scroller functions in an alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a \".rec\" property in order to revert to that after refreshing to ensure things don't shift around.\n    _isViewport(element) && (element = _doc.scrollingElement || _docEl);\n    var i = _scrollers.indexOf(element), offset = sc === _vertical.sc ? 1 : 2;\n    !~i && (i = _scrollers.push(element) - 1);\n    _scrollers[i + offset] || _addListener(element, \"scroll\", _onScroll); // clear the cache when a scroll occurs\n    var prev = _scrollers[i + offset], func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function(value) {\n        return arguments.length ? element[s] = value : element[s];\n    })));\n    func.target = element;\n    prev || (func.smooth = gsap.getProperty(element, \"scrollBehavior\") === \"smooth\"); // only set it the first time (don't reset every time a scrollFunc is requested because perhaps it happens during a refresh() when it's disabled in ScrollTrigger.\n    return func;\n}, _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {\n    var v1 = value, v2 = value, t1 = _getTime(), t2 = t1, min = minTimeRefresh || 50, dropToZeroTime = Math.max(500, min * 3), update = function update(value, force) {\n        var t = _getTime();\n        if (force || t - t1 > min) {\n            v2 = v1;\n            v1 = value;\n            t2 = t1;\n            t1 = t;\n        } else if (useDelta) {\n            v1 += value;\n        } else {\n            // not totally necessary, but makes it a bit more accurate by adjusting the v1 value according to the new slope. This way we're not just ignoring the incoming data. Removing for now because it doesn't seem to make much practical difference and it's probably not worth the kb.\n            v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);\n        }\n    }, reset = function reset() {\n        v2 = v1 = useDelta ? 0 : v1;\n        t2 = t1 = 0;\n    }, getVelocity = function getVelocity(latestValue) {\n        var tOld = t2, vOld = v2, t = _getTime();\n        (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);\n        return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;\n    };\n    return {\n        update: update,\n        reset: reset,\n        getVelocity: getVelocity\n    };\n}, _getEvent = function _getEvent(e, preventDefault) {\n    preventDefault && !e._gsapAllow && e.preventDefault();\n    return e.changedTouches ? e.changedTouches[0] : e;\n}, _getAbsoluteMax = function _getAbsoluteMax(a) {\n    var max = Math.max.apply(Math, a), min = Math.min.apply(Math, a);\n    return Math.abs(max) >= Math.abs(min) ? max : min;\n}, _setScrollTrigger = function _setScrollTrigger() {\n    ScrollTrigger = gsap.core.globals().ScrollTrigger;\n    ScrollTrigger && ScrollTrigger.core && _integrate();\n}, _initCore = function _initCore(core) {\n    gsap = core || _getGSAP();\n    if (!_coreInitted && gsap && typeof document !== \"undefined\" && document.body) {\n        _win = window;\n        _doc = document;\n        _docEl = _doc.documentElement;\n        _body = _doc.body;\n        _root = [\n            _win,\n            _doc,\n            _docEl,\n            _body\n        ];\n        _clamp = gsap.utils.clamp;\n        _context = gsap.core.context || function() {};\n        _pointerType = \"onpointerenter\" in _body ? \"pointer\" : \"mouse\"; // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.\n        _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia(\"(hover: none), (pointer: coarse)\").matches ? 1 : \"ontouchstart\" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;\n        _eventTypes = Observer.eventTypes = (\"ontouchstart\" in _docEl ? \"touchstart,touchmove,touchcancel,touchend\" : !(\"onpointerdown\" in _docEl) ? \"mousedown,mousemove,mouseup,mouseup\" : \"pointerdown,pointermove,pointercancel,pointerup\").split(\",\");\n        setTimeout(function() {\n            return _startup = 0;\n        }, 500);\n        _setScrollTrigger();\n        _coreInitted = 1;\n    }\n    return _coreInitted;\n};\n_horizontal.op = _vertical;\n_scrollers.cache = 0;\nvar Observer = /*#__PURE__*/ function() {\n    function Observer(vars) {\n        this.init(vars);\n    }\n    var _proto = Observer.prototype;\n    _proto.init = function init(vars) {\n        _coreInitted || _initCore(gsap) || console.warn(\"Please gsap.registerPlugin(Observer)\");\n        ScrollTrigger || _setScrollTrigger();\n        var tolerance = vars.tolerance, dragMinimum = vars.dragMinimum, type = vars.type, target = vars.target, lineHeight = vars.lineHeight, debounce = vars.debounce, preventDefault = vars.preventDefault, onStop = vars.onStop, onStopDelay = vars.onStopDelay, ignore = vars.ignore, wheelSpeed = vars.wheelSpeed, event = vars.event, onDragStart = vars.onDragStart, onDragEnd = vars.onDragEnd, onDrag = vars.onDrag, onPress = vars.onPress, onRelease = vars.onRelease, onRight = vars.onRight, onLeft = vars.onLeft, onUp = vars.onUp, onDown = vars.onDown, onChangeX = vars.onChangeX, onChangeY = vars.onChangeY, onChange = vars.onChange, onToggleX = vars.onToggleX, onToggleY = vars.onToggleY, onHover = vars.onHover, onHoverEnd = vars.onHoverEnd, onMove = vars.onMove, ignoreCheck = vars.ignoreCheck, isNormalizer = vars.isNormalizer, onGestureStart = vars.onGestureStart, onGestureEnd = vars.onGestureEnd, onWheel = vars.onWheel, onEnable = vars.onEnable, onDisable = vars.onDisable, onClick = vars.onClick, scrollSpeed = vars.scrollSpeed, capture = vars.capture, allowClicks = vars.allowClicks, lockAxis = vars.lockAxis, onLockAxis = vars.onLockAxis;\n        this.target = target = _getTarget(target) || _docEl;\n        this.vars = vars;\n        ignore && (ignore = gsap.utils.toArray(ignore));\n        tolerance = tolerance || 1e-9;\n        dragMinimum = dragMinimum || 0;\n        wheelSpeed = wheelSpeed || 1;\n        scrollSpeed = scrollSpeed || 1;\n        type = type || \"wheel,touch,pointer\";\n        debounce = debounce !== false;\n        lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22); // note: browser may report \"normal\", so default to 22.\n        var id, onStopDelayedCall, dragged, moved, wheeled, locked, axis, self = this, prevDeltaX = 0, prevDeltaY = 0, passive = vars.passive || !preventDefault, scrollFuncX = _getScrollFunc(target, _horizontal), scrollFuncY = _getScrollFunc(target, _vertical), scrollX = scrollFuncX(), scrollY = scrollFuncY(), limitToTouch = ~type.indexOf(\"touch\") && !~type.indexOf(\"pointer\") && _eventTypes[0] === \"pointerdown\", // for devices that accommodate mouse events and touch events, we need to distinguish.\n        isViewport = _isViewport(target), ownerDoc = target.ownerDocument || _doc, deltaX = [\n            0,\n            0,\n            0\n        ], // wheel, scroll, pointer/touch\n        deltaY = [\n            0,\n            0,\n            0\n        ], onClickTime = 0, clickCapture = function clickCapture() {\n            return onClickTime = _getTime();\n        }, _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {\n            return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== \"touch\" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);\n        }, onStopFunc = function onStopFunc() {\n            self._vx.reset();\n            self._vy.reset();\n            onStopDelayedCall.pause();\n            onStop && onStop(self);\n        }, update = function update() {\n            var dx = self.deltaX = _getAbsoluteMax(deltaX), dy = self.deltaY = _getAbsoluteMax(deltaY), changedX = Math.abs(dx) >= tolerance, changedY = Math.abs(dy) >= tolerance;\n            onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY); // in ScrollTrigger.normalizeScroll(), we need to know if it was touch/pointer so we need access to the deltaX/deltaY Arrays before we clear them out.\n            if (changedX) {\n                onRight && self.deltaX > 0 && onRight(self);\n                onLeft && self.deltaX < 0 && onLeft(self);\n                onChangeX && onChangeX(self);\n                onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);\n                prevDeltaX = self.deltaX;\n                deltaX[0] = deltaX[1] = deltaX[2] = 0;\n            }\n            if (changedY) {\n                onDown && self.deltaY > 0 && onDown(self);\n                onUp && self.deltaY < 0 && onUp(self);\n                onChangeY && onChangeY(self);\n                onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);\n                prevDeltaY = self.deltaY;\n                deltaY[0] = deltaY[1] = deltaY[2] = 0;\n            }\n            if (moved || dragged) {\n                onMove && onMove(self);\n                if (dragged) {\n                    onDrag(self);\n                    dragged = false;\n                }\n                moved = false;\n            }\n            locked && !(locked = false) && onLockAxis && onLockAxis(self);\n            if (wheeled) {\n                onWheel(self);\n                wheeled = false;\n            }\n            id = 0;\n        }, onDelta = function onDelta(x, y, index) {\n            deltaX[index] += x;\n            deltaY[index] += y;\n            self._vx.update(x);\n            self._vy.update(y);\n            debounce ? id || (id = requestAnimationFrame(update)) : update();\n        }, onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {\n            if (lockAxis && !axis) {\n                self.axis = axis = Math.abs(x) > Math.abs(y) ? \"x\" : \"y\";\n                locked = true;\n            }\n            if (axis !== \"y\") {\n                deltaX[2] += x;\n                self._vx.update(x, true); // update the velocity as frequently as possible instead of in the debounced function so that very quick touch-scrolls (flicks) feel natural. If it's the mouse/touch/pointer, force it so that we get snappy/accurate momentum scroll.\n            }\n            if (axis !== \"x\") {\n                deltaY[2] += y;\n                self._vy.update(y, true);\n            }\n            debounce ? id || (id = requestAnimationFrame(update)) : update();\n        }, _onDrag = function _onDrag(e) {\n            if (_ignoreCheck(e, 1)) {\n                return;\n            }\n            e = _getEvent(e, preventDefault);\n            var x = e.clientX, y = e.clientY, dx = x - self.x, dy = y - self.y, isDragging = self.isDragging;\n            self.x = x;\n            self.y = y;\n            if (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) {\n                onDrag && (dragged = true);\n                isDragging || (self.isDragging = true);\n                onTouchOrPointerDelta(dx, dy);\n                isDragging || onDragStart && onDragStart(self);\n            }\n        }, _onPress = self.onPress = function _onPress(e) {\n            if (_ignoreCheck(e, 1) || e && e.button) {\n                return;\n            }\n            self.axis = axis = null;\n            onStopDelayedCall.pause();\n            self.isPressed = true;\n            e = _getEvent(e); // note: may need to preventDefault(?) Won't side-scroll on iOS Safari if we do, though.\n            prevDeltaX = prevDeltaY = 0;\n            self.startX = self.x = e.clientX;\n            self.startY = self.y = e.clientY;\n            self._vx.reset(); // otherwise the t2 may be stale if the user touches and flicks super fast and releases in less than 2 requestAnimationFrame ticks, causing velocity to be 0.\n            self._vy.reset();\n            _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, passive, true);\n            self.deltaX = self.deltaY = 0;\n            onPress && onPress(self);\n        }, _onRelease = self.onRelease = function _onRelease(e) {\n            if (_ignoreCheck(e, 1)) {\n                return;\n            }\n            _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n            var isTrackingDrag = !isNaN(self.y - self.startY), wasDragging = self.isDragging, isDragNotClick = wasDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3), // some touch devices need some wiggle room in terms of sensing clicks - the finger may move a few pixels.\n            eventData = _getEvent(e);\n            if (!isDragNotClick && isTrackingDrag) {\n                self._vx.reset();\n                self._vy.reset(); //if (preventDefault && allowClicks && self.isPressed) { // check isPressed because in a rare edge case, the inputObserver in ScrollTrigger may stopPropagation() on the press/drag, so the onRelease may get fired without the onPress/onDrag ever getting called, thus it could trigger a click to occur on a link after scroll-dragging it.\n                if (preventDefault && allowClicks) {\n                    gsap.delayedCall(0.08, function() {\n                        // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular \"click\" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the \"real\"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the \"real\" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.\n                        if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {\n                            if (e.target.click) {\n                                //some browsers (like mobile Safari) don't properly trigger the click event\n                                e.target.click();\n                            } else if (ownerDoc.createEvent) {\n                                var syntheticEvent = ownerDoc.createEvent(\"MouseEvents\");\n                                syntheticEvent.initMouseEvent(\"click\", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);\n                                e.target.dispatchEvent(syntheticEvent);\n                            }\n                        }\n                    });\n                }\n            }\n            self.isDragging = self.isGesturing = self.isPressed = false;\n            onStop && wasDragging && !isNormalizer && onStopDelayedCall.restart(true);\n            onDragEnd && wasDragging && onDragEnd(self);\n            onRelease && onRelease(self, isDragNotClick);\n        }, _onGestureStart = function _onGestureStart(e) {\n            return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);\n        }, _onGestureEnd = function _onGestureEnd() {\n            return (self.isGesturing = false) || onGestureEnd(self);\n        }, onScroll = function onScroll(e) {\n            if (_ignoreCheck(e)) {\n                return;\n            }\n            var x = scrollFuncX(), y = scrollFuncY();\n            onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);\n            scrollX = x;\n            scrollY = y;\n            onStop && onStopDelayedCall.restart(true);\n        }, _onWheel = function _onWheel(e) {\n            if (_ignoreCheck(e)) {\n                return;\n            }\n            e = _getEvent(e, preventDefault);\n            onWheel && (wheeled = true);\n            var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;\n            onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);\n            onStop && !isNormalizer && onStopDelayedCall.restart(true);\n        }, _onMove = function _onMove(e) {\n            if (_ignoreCheck(e)) {\n                return;\n            }\n            var x = e.clientX, y = e.clientY, dx = x - self.x, dy = y - self.y;\n            self.x = x;\n            self.y = y;\n            moved = true;\n            onStop && onStopDelayedCall.restart(true);\n            (dx || dy) && onTouchOrPointerDelta(dx, dy);\n        }, _onHover = function _onHover(e) {\n            self.event = e;\n            onHover(self);\n        }, _onHoverEnd = function _onHoverEnd(e) {\n            self.event = e;\n            onHoverEnd(self);\n        }, _onClick = function _onClick(e) {\n            return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);\n        };\n        onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();\n        self.deltaX = self.deltaY = 0;\n        self._vx = _getVelocityProp(0, 50, true);\n        self._vy = _getVelocityProp(0, 50, true);\n        self.scrollX = scrollFuncX;\n        self.scrollY = scrollFuncY;\n        self.isDragging = self.isGesturing = self.isPressed = false;\n        _context(this);\n        self.enable = function(e) {\n            if (!self.isEnabled) {\n                _addListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n                type.indexOf(\"scroll\") >= 0 && _addListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, passive, capture);\n                type.indexOf(\"wheel\") >= 0 && _addListener(target, \"wheel\", _onWheel, passive, capture);\n                if (type.indexOf(\"touch\") >= 0 && _isTouch || type.indexOf(\"pointer\") >= 0) {\n                    _addListener(target, _eventTypes[0], _onPress, passive, capture);\n                    _addListener(ownerDoc, _eventTypes[2], _onRelease);\n                    _addListener(ownerDoc, _eventTypes[3], _onRelease);\n                    allowClicks && _addListener(target, \"click\", clickCapture, true, true);\n                    onClick && _addListener(target, \"click\", _onClick);\n                    onGestureStart && _addListener(ownerDoc, \"gesturestart\", _onGestureStart);\n                    onGestureEnd && _addListener(ownerDoc, \"gestureend\", _onGestureEnd);\n                    onHover && _addListener(target, _pointerType + \"enter\", _onHover);\n                    onHoverEnd && _addListener(target, _pointerType + \"leave\", _onHoverEnd);\n                    onMove && _addListener(target, _pointerType + \"move\", _onMove);\n                }\n                self.isEnabled = true;\n                e && e.type && _onPress(e);\n                onEnable && onEnable(self);\n            }\n            return self;\n        };\n        self.disable = function() {\n            if (self.isEnabled) {\n                // only remove the _onScroll listener if there aren't any others that rely on the functionality.\n                _observers.filter(function(o) {\n                    return o !== self && _isViewport(o.target);\n                }).length || _removeListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n                if (self.isPressed) {\n                    self._vx.reset();\n                    self._vy.reset();\n                    _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n                }\n                _removeListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, capture);\n                _removeListener(target, \"wheel\", _onWheel, capture);\n                _removeListener(target, _eventTypes[0], _onPress, capture);\n                _removeListener(ownerDoc, _eventTypes[2], _onRelease);\n                _removeListener(ownerDoc, _eventTypes[3], _onRelease);\n                _removeListener(target, \"click\", clickCapture, true);\n                _removeListener(target, \"click\", _onClick);\n                _removeListener(ownerDoc, \"gesturestart\", _onGestureStart);\n                _removeListener(ownerDoc, \"gestureend\", _onGestureEnd);\n                _removeListener(target, _pointerType + \"enter\", _onHover);\n                _removeListener(target, _pointerType + \"leave\", _onHoverEnd);\n                _removeListener(target, _pointerType + \"move\", _onMove);\n                self.isEnabled = self.isPressed = self.isDragging = false;\n                onDisable && onDisable(self);\n            }\n        };\n        self.kill = self.revert = function() {\n            self.disable();\n            var i = _observers.indexOf(self);\n            i >= 0 && _observers.splice(i, 1);\n            _normalizer === self && (_normalizer = 0);\n        };\n        _observers.push(self);\n        isNormalizer && _isViewport(target) && (_normalizer = self);\n        self.enable(event);\n    };\n    _createClass(Observer, [\n        {\n            key: \"velocityX\",\n            get: function get() {\n                return this._vx.getVelocity();\n            }\n        },\n        {\n            key: \"velocityY\",\n            get: function get() {\n                return this._vy.getVelocity();\n            }\n        }\n    ]);\n    return Observer;\n}();\nObserver.version = \"3.12.5\";\nObserver.create = function(vars) {\n    return new Observer(vars);\n};\nObserver.register = _initCore;\nObserver.getAll = function() {\n    return _observers.slice();\n};\nObserver.getById = function(id) {\n    return _observers.filter(function(o) {\n        return o.vars.id === id;\n    })[0];\n};\n_getGSAP() && gsap.registerPlugin(Observer);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9PYnNlcnZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBLGtCQUFrQkMsTUFBTSxFQUFFQyxLQUFLO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELE1BQU1FLE1BQU0sRUFBRUQsSUFBSztRQUFFLElBQUlFLGFBQWFILEtBQUssQ0FBQ0MsRUFBRTtRQUFFRSxXQUFXQyxVQUFVLEdBQUdELFdBQVdDLFVBQVUsSUFBSTtRQUFPRCxXQUFXRSxZQUFZLEdBQUc7UUFBTSxJQUFJLFdBQVdGLFlBQVlBLFdBQVdHLFFBQVEsR0FBRztRQUFNQyxPQUFPQyxjQUFjLENBQUNULFFBQVFJLFdBQVdNLEdBQUcsRUFBRU47SUFBYTtBQUFFO0FBRTVULFNBQVNPLGFBQWFDLFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxXQUFXO0lBQUksSUFBSUQsWUFBWWQsa0JBQWtCYSxZQUFZRyxTQUFTLEVBQUVGO0lBQWEsSUFBSUMsYUFBYWYsa0JBQWtCYSxhQUFhRTtJQUFjLE9BQU9GO0FBQWE7QUFFdE47Ozs7Ozs7O0FBUUEsR0FFQSxrQkFBa0IsR0FDbEIsSUFBSUksTUFDQUMsY0FDQUMsUUFDQUMsTUFDQUMsTUFDQUMsUUFDQUMsT0FDQUMsVUFDQUMsY0FDQUMsZUFDQUMsT0FDQUMsYUFDQUMsYUFDQUMsVUFDQUMsV0FBVyxTQUFTQTtJQUN0QixPQUFPZCxRQUFRLE9BQU9lLFdBQVcsZUFBZ0JmLENBQUFBLE9BQU9lLE9BQU9mLElBQUksS0FBS0EsS0FBS2dCLGNBQWMsSUFBSWhCO0FBQ2pHLEdBQ0lpQixXQUFXLEdBQ1hDLGFBQWEsRUFBRSxFQUNmQyxhQUFhLEVBQUUsRUFDZkMsV0FBVyxFQUFFLEVBQ2JDLFdBQVdDLEtBQUtDLEdBQUcsRUFDbkJDLFVBQVUsU0FBU0EsUUFBUUMsSUFBSSxFQUFFQyxLQUFLO0lBQ3hDLE9B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LEtBQUs7QUFDekI7QUFFQTlJLFNBQVMrSSxPQUFPLEdBQUcsU0FBVTFGLEVBQUU7SUFDN0IsT0FBT3ZLLFdBQVdzUCxNQUFNLENBQUMsU0FBVUMsQ0FBQztRQUNsQyxPQUFPQSxFQUFFM0gsSUFBSSxDQUFDMkMsRUFBRSxLQUFLQTtJQUN2QixFQUFFLENBQUMsRUFBRTtBQUNQO0FBRUEzSyxjQUFjZCxLQUFLZ0IsY0FBYyxDQUFDb0g7QUFDcUgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dzYXBAMy4xMi41L25vZGVfbW9kdWxlcy9nc2FwL09ic2VydmVyLmpzPzQ0NGUiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKiFcbiAqIE9ic2VydmVyIDMuMTIuNVxuICogaHR0cHM6Ly9nc2FwLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjQsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3NhcC5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR1NBUCBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBnc2FwLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfY2xhbXAsXG4gICAgX3dpbixcbiAgICBfZG9jLFxuICAgIF9kb2NFbCxcbiAgICBfYm9keSxcbiAgICBfaXNUb3VjaCxcbiAgICBfcG9pbnRlclR5cGUsXG4gICAgU2Nyb2xsVHJpZ2dlcixcbiAgICBfcm9vdCxcbiAgICBfbm9ybWFsaXplcixcbiAgICBfZXZlbnRUeXBlcyxcbiAgICBfY29udGV4dCxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX3N0YXJ0dXAgPSAxLFxuICAgIF9vYnNlcnZlcnMgPSBbXSxcbiAgICBfc2Nyb2xsZXJzID0gW10sXG4gICAgX3Byb3hpZXMgPSBbXSxcbiAgICBfZ2V0VGltZSA9IERhdGUubm93LFxuICAgIF9icmlkZ2UgPSBmdW5jdGlvbiBfYnJpZGdlKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn0sXG4gICAgX2ludGVncmF0ZSA9IGZ1bmN0aW9uIF9pbnRlZ3JhdGUoKSB7XG4gIHZhciBjb3JlID0gU2Nyb2xsVHJpZ2dlci5jb3JlLFxuICAgICAgZGF0YSA9IGNvcmUuYnJpZGdlIHx8IHt9LFxuICAgICAgc2Nyb2xsZXJzID0gY29yZS5fc2Nyb2xsZXJzLFxuICAgICAgcHJveGllcyA9IGNvcmUuX3Byb3hpZXM7XG4gIHNjcm9sbGVycy5wdXNoLmFwcGx5KHNjcm9sbGVycywgX3Njcm9sbGVycyk7XG4gIHByb3hpZXMucHVzaC5hcHBseShwcm94aWVzLCBfcHJveGllcyk7XG4gIF9zY3JvbGxlcnMgPSBzY3JvbGxlcnM7XG4gIF9wcm94aWVzID0gcHJveGllcztcblxuICBfYnJpZGdlID0gZnVuY3Rpb24gX2JyaWRnZShuYW1lLCB2YWx1ZSkge1xuICAgIHJldHVybiBkYXRhW25hbWVdKHZhbHVlKTtcbiAgfTtcbn0sXG4gICAgX2dldFByb3h5UHJvcCA9IGZ1bmN0aW9uIF9nZXRQcm94eVByb3AoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIH5fcHJveGllcy5pbmRleE9mKGVsZW1lbnQpICYmIF9wcm94aWVzW19wcm94aWVzLmluZGV4T2YoZWxlbWVudCkgKyAxXVtwcm9wZXJ0eV07XG59LFxuICAgIF9pc1ZpZXdwb3J0ID0gZnVuY3Rpb24gX2lzVmlld3BvcnQoZWwpIHtcbiAgcmV0dXJuICEhfl9yb290LmluZGV4T2YoZWwpO1xufSxcbiAgICBfYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBfYWRkTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgZnVuYywgcGFzc2l2ZSwgY2FwdHVyZSkge1xuICByZXR1cm4gZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmMsIHtcbiAgICBwYXNzaXZlOiBwYXNzaXZlICE9PSBmYWxzZSxcbiAgICBjYXB0dXJlOiAhIWNhcHR1cmVcbiAgfSk7XG59LFxuICAgIF9yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIF9yZW1vdmVMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBmdW5jLCBjYXB0dXJlKSB7XG4gIHJldHVybiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZnVuYywgISFjYXB0dXJlKTtcbn0sXG4gICAgX3Njcm9sbExlZnQgPSBcInNjcm9sbExlZnRcIixcbiAgICBfc2Nyb2xsVG9wID0gXCJzY3JvbGxUb3BcIixcbiAgICBfb25TY3JvbGwgPSBmdW5jdGlvbiBfb25TY3JvbGwoKSB7XG4gIHJldHVybiBfbm9ybWFsaXplciAmJiBfbm9ybWFsaXplci5pc1ByZXNzZWQgfHwgX3Njcm9sbGVycy5jYWNoZSsrO1xufSxcbiAgICBfc2Nyb2xsQ2FjaGVGdW5jID0gZnVuY3Rpb24gX3Njcm9sbENhY2hlRnVuYyhmLCBkb05vdENhY2hlKSB7XG4gIHZhciBjYWNoaW5nRnVuYyA9IGZ1bmN0aW9uIGNhY2hpbmdGdW5jKHZhbHVlKSB7XG4gICAgLy8gc2luY2UgcmVhZGluZyB0aGUgc2Nyb2xsVG9wL3Njcm9sbExlZnQvcGFnZU9mZnNldFkvcGFnZU9mZnNldFggY2FuIHRyaWdnZXIgYSBsYXlvdXQsIHRoaXMgZnVuY3Rpb24gYWxsb3dzIHVzIHRvIGNhY2hlIHRoZSB2YWx1ZSBzbyBpdCBvbmx5IGdldHMgcmVhZCBmcmVzaCBhZnRlciBhIFwic2Nyb2xsXCIgZXZlbnQgZmlyZXMgKG9yIHdoaWxlIHdlJ3JlIHJlZnJlc2hpbmcgYmVjYXVzZSB0aGF0IGNhbiBsZW5ndGhlbiB0aGUgcGFnZSBhbmQgYWx0ZXIgdGhlIHNjcm9sbCBwb3NpdGlvbikuIHdoZW4gXCJzb2Z0XCIgaXMgdHJ1ZSwgdGhhdCBtZWFucyBkb24ndCBhY3R1YWxseSBzZXQgdGhlIHNjcm9sbCwgYnV0IGNhY2hlIHRoZSBuZXcgdmFsdWUgaW5zdGVhZCAodXNlZnVsIGluIFNjcm9sbFNtb290aGVyKVxuICAgIGlmICh2YWx1ZSB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgX3N0YXJ0dXAgJiYgKF93aW4uaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCIpOyAvLyBvdGhlcndpc2UgdGhlIG5ldyBwb3NpdGlvbiB3aWxsIGdldCBvdmVyd3JpdHRlbiBieSB0aGUgYnJvd3NlciBvbmxvYWQuXG5cbiAgICAgIHZhciBpc05vcm1hbGl6aW5nID0gX25vcm1hbGl6ZXIgJiYgX25vcm1hbGl6ZXIuaXNQcmVzc2VkO1xuICAgICAgdmFsdWUgPSBjYWNoaW5nRnVuYy52ID0gTWF0aC5yb3VuZCh2YWx1ZSkgfHwgKF9ub3JtYWxpemVyICYmIF9ub3JtYWxpemVyLmlPUyA/IDEgOiAwKTsgLy9UT0RPOiBpT1MgQnVnOiBpZiB5b3UgYWxsb3cgaXQgdG8gZ28gdG8gMCwgU2FmYXJpIGNhbiBzdGFydCB0byByZXBvcnQgc3VwZXIgc3RyYW5nZSAod2lsZGx5IGluYWNjdXJhdGUpIHRvdWNoIHBvc2l0aW9ucyFcblxuICAgICAgZih2YWx1ZSk7XG4gICAgICBjYWNoaW5nRnVuYy5jYWNoZUlEID0gX3Njcm9sbGVycy5jYWNoZTtcbiAgICAgIGlzTm9ybWFsaXppbmcgJiYgX2JyaWRnZShcInNzXCIsIHZhbHVlKTsgLy8gc2V0IHNjcm9sbCAobm90aWZ5IFNjcm9sbFRyaWdnZXIgc28gaXQgY2FuIGRpc3BhdGNoIGEgXCJzY3JvbGxTdGFydFwiIGV2ZW50IGlmIG5lY2Vzc2FyeVxuICAgIH0gZWxzZSBpZiAoZG9Ob3RDYWNoZSB8fCBfc2Nyb2xsZXJzLmNhY2hlICE9PSBjYWNoaW5nRnVuYy5jYWNoZUlEIHx8IF9icmlkZ2UoXCJyZWZcIikpIHtcbiAgICAgIGNhY2hpbmdGdW5jLmNhY2hlSUQgPSBfc2Nyb2xsZXJzLmNhY2hlO1xuICAgICAgY2FjaGluZ0Z1bmMudiA9IGYoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGluZ0Z1bmMudiArIGNhY2hpbmdGdW5jLm9mZnNldDtcbiAgfTtcblxuICBjYWNoaW5nRnVuYy5vZmZzZXQgPSAwO1xuICByZXR1cm4gZiAmJiBjYWNoaW5nRnVuYztcbn0sXG4gICAgX2hvcml6b250YWwgPSB7XG4gIHM6IF9zY3JvbGxMZWZ0LFxuICBwOiBcImxlZnRcIixcbiAgcDI6IFwiTGVmdFwiLFxuICBvczogXCJyaWdodFwiLFxuICBvczI6IFwiUmlnaHRcIixcbiAgZDogXCJ3aWR0aFwiLFxuICBkMjogXCJXaWR0aFwiLFxuICBhOiBcInhcIixcbiAgc2M6IF9zY3JvbGxDYWNoZUZ1bmMoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBfd2luLnNjcm9sbFRvKHZhbHVlLCBfdmVydGljYWwuc2MoKSkgOiBfd2luLnBhZ2VYT2Zmc2V0IHx8IF9kb2NbX3Njcm9sbExlZnRdIHx8IF9kb2NFbFtfc2Nyb2xsTGVmdF0gfHwgX2JvZHlbX3Njcm9sbExlZnRdIHx8IDA7XG4gIH0pXG59LFxuICAgIF92ZXJ0aWNhbCA9IHtcbiAgczogX3Njcm9sbFRvcCxcbiAgcDogXCJ0b3BcIixcbiAgcDI6IFwiVG9wXCIsXG4gIG9zOiBcImJvdHRvbVwiLFxuICBvczI6IFwiQm90dG9tXCIsXG4gIGQ6IFwiaGVpZ2h0XCIsXG4gIGQyOiBcIkhlaWdodFwiLFxuICBhOiBcInlcIixcbiAgb3A6IF9ob3Jpem9udGFsLFxuICBzYzogX3Njcm9sbENhY2hlRnVuYyhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IF93aW4uc2Nyb2xsVG8oX2hvcml6b250YWwuc2MoKSwgdmFsdWUpIDogX3dpbi5wYWdlWU9mZnNldCB8fCBfZG9jW19zY3JvbGxUb3BdIHx8IF9kb2NFbFtfc2Nyb2xsVG9wXSB8fCBfYm9keVtfc2Nyb2xsVG9wXSB8fCAwO1xuICB9KVxufSxcbiAgICBfZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gX2dldFRhcmdldCh0LCBzZWxmKSB7XG4gIHJldHVybiAoc2VsZiAmJiBzZWxmLl9jdHggJiYgc2VsZi5fY3R4LnNlbGVjdG9yIHx8IGdzYXAudXRpbHMudG9BcnJheSkodClbMF0gfHwgKHR5cGVvZiB0ID09PSBcInN0cmluZ1wiICYmIGdzYXAuY29uZmlnKCkubnVsbFRhcmdldFdhcm4gIT09IGZhbHNlID8gY29uc29sZS53YXJuKFwiRWxlbWVudCBub3QgZm91bmQ6XCIsIHQpIDogbnVsbCk7XG59LFxuICAgIF9nZXRTY3JvbGxGdW5jID0gZnVuY3Rpb24gX2dldFNjcm9sbEZ1bmMoZWxlbWVudCwgX3JlZikge1xuICB2YXIgcyA9IF9yZWYucyxcbiAgICAgIHNjID0gX3JlZi5zYztcbiAgLy8gd2Ugc3RvcmUgdGhlIHNjcm9sbGVyIGZ1bmN0aW9ucyBpbiBhbiBhbHRlcm5hdGluZyBzZXF1ZW5jZWQgQXJyYXkgbGlrZSBbZWxlbWVudCwgdmVydGljYWxTY3JvbGxGdW5jLCBob3Jpem9udGFsU2Nyb2xsRnVuYywgLi4uXSBzbyB0aGF0IHdlIGNhbiBtaW5pbWl6ZSBtZW1vcnksIG1heGltaXplIHBlcmZvcm1hbmNlLCBhbmQgd2UgYWxzbyByZWNvcmQgdGhlIGxhc3QgcG9zaXRpb24gYXMgYSBcIi5yZWNcIiBwcm9wZXJ0eSBpbiBvcmRlciB0byByZXZlcnQgdG8gdGhhdCBhZnRlciByZWZyZXNoaW5nIHRvIGVuc3VyZSB0aGluZ3MgZG9uJ3Qgc2hpZnQgYXJvdW5kLlxuICBfaXNWaWV3cG9ydChlbGVtZW50KSAmJiAoZWxlbWVudCA9IF9kb2Muc2Nyb2xsaW5nRWxlbWVudCB8fCBfZG9jRWwpO1xuXG4gIHZhciBpID0gX3Njcm9sbGVycy5pbmRleE9mKGVsZW1lbnQpLFxuICAgICAgb2Zmc2V0ID0gc2MgPT09IF92ZXJ0aWNhbC5zYyA/IDEgOiAyO1xuXG4gICF+aSAmJiAoaSA9IF9zY3JvbGxlcnMucHVzaChlbGVtZW50KSAtIDEpO1xuICBfc2Nyb2xsZXJzW2kgKyBvZmZzZXRdIHx8IF9hZGRMaXN0ZW5lcihlbGVtZW50LCBcInNjcm9sbFwiLCBfb25TY3JvbGwpOyAvLyBjbGVhciB0aGUgY2FjaGUgd2hlbiBhIHNjcm9sbCBvY2N1cnNcblxuICB2YXIgcHJldiA9IF9zY3JvbGxlcnNbaSArIG9mZnNldF0sXG4gICAgICBmdW5jID0gcHJldiB8fCAoX3Njcm9sbGVyc1tpICsgb2Zmc2V0XSA9IF9zY3JvbGxDYWNoZUZ1bmMoX2dldFByb3h5UHJvcChlbGVtZW50LCBzKSwgdHJ1ZSkgfHwgKF9pc1ZpZXdwb3J0KGVsZW1lbnQpID8gc2MgOiBfc2Nyb2xsQ2FjaGVGdW5jKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gZWxlbWVudFtzXSA9IHZhbHVlIDogZWxlbWVudFtzXTtcbiAgfSkpKTtcbiAgZnVuYy50YXJnZXQgPSBlbGVtZW50O1xuICBwcmV2IHx8IChmdW5jLnNtb290aCA9IGdzYXAuZ2V0UHJvcGVydHkoZWxlbWVudCwgXCJzY3JvbGxCZWhhdmlvclwiKSA9PT0gXCJzbW9vdGhcIik7IC8vIG9ubHkgc2V0IGl0IHRoZSBmaXJzdCB0aW1lIChkb24ndCByZXNldCBldmVyeSB0aW1lIGEgc2Nyb2xsRnVuYyBpcyByZXF1ZXN0ZWQgYmVjYXVzZSBwZXJoYXBzIGl0IGhhcHBlbnMgZHVyaW5nIGEgcmVmcmVzaCgpIHdoZW4gaXQncyBkaXNhYmxlZCBpbiBTY3JvbGxUcmlnZ2VyLlxuXG4gIHJldHVybiBmdW5jO1xufSxcbiAgICBfZ2V0VmVsb2NpdHlQcm9wID0gZnVuY3Rpb24gX2dldFZlbG9jaXR5UHJvcCh2YWx1ZSwgbWluVGltZVJlZnJlc2gsIHVzZURlbHRhKSB7XG4gIHZhciB2MSA9IHZhbHVlLFxuICAgICAgdjIgPSB2YWx1ZSxcbiAgICAgIHQxID0gX2dldFRpbWUoKSxcbiAgICAgIHQyID0gdDEsXG4gICAgICBtaW4gPSBtaW5UaW1lUmVmcmVzaCB8fCA1MCxcbiAgICAgIGRyb3BUb1plcm9UaW1lID0gTWF0aC5tYXgoNTAwLCBtaW4gKiAzKSxcbiAgICAgIHVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSwgZm9yY2UpIHtcbiAgICB2YXIgdCA9IF9nZXRUaW1lKCk7XG5cbiAgICBpZiAoZm9yY2UgfHwgdCAtIHQxID4gbWluKSB7XG4gICAgICB2MiA9IHYxO1xuICAgICAgdjEgPSB2YWx1ZTtcbiAgICAgIHQyID0gdDE7XG4gICAgICB0MSA9IHQ7XG4gICAgfSBlbHNlIGlmICh1c2VEZWx0YSkge1xuICAgICAgdjEgKz0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vdCB0b3RhbGx5IG5lY2Vzc2FyeSwgYnV0IG1ha2VzIGl0IGEgYml0IG1vcmUgYWNjdXJhdGUgYnkgYWRqdXN0aW5nIHRoZSB2MSB2YWx1ZSBhY2NvcmRpbmcgdG8gdGhlIG5ldyBzbG9wZS4gVGhpcyB3YXkgd2UncmUgbm90IGp1c3QgaWdub3JpbmcgdGhlIGluY29taW5nIGRhdGEuIFJlbW92aW5nIGZvciBub3cgYmVjYXVzZSBpdCBkb2Vzbid0IHNlZW0gdG8gbWFrZSBtdWNoIHByYWN0aWNhbCBkaWZmZXJlbmNlIGFuZCBpdCdzIHByb2JhYmx5IG5vdCB3b3J0aCB0aGUga2IuXG4gICAgICB2MSA9IHYyICsgKHZhbHVlIC0gdjIpIC8gKHQgLSB0MikgKiAodDEgLSB0Mik7XG4gICAgfVxuICB9LFxuICAgICAgcmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB2MiA9IHYxID0gdXNlRGVsdGEgPyAwIDogdjE7XG4gICAgdDIgPSB0MSA9IDA7XG4gIH0sXG4gICAgICBnZXRWZWxvY2l0eSA9IGZ1bmN0aW9uIGdldFZlbG9jaXR5KGxhdGVzdFZhbHVlKSB7XG4gICAgdmFyIHRPbGQgPSB0MixcbiAgICAgICAgdk9sZCA9IHYyLFxuICAgICAgICB0ID0gX2dldFRpbWUoKTtcblxuICAgIChsYXRlc3RWYWx1ZSB8fCBsYXRlc3RWYWx1ZSA9PT0gMCkgJiYgbGF0ZXN0VmFsdWUgIT09IHYxICYmIHVwZGF0ZShsYXRlc3RWYWx1ZSk7XG4gICAgcmV0dXJuIHQxID09PSB0MiB8fCB0IC0gdDIgPiBkcm9wVG9aZXJvVGltZSA/IDAgOiAodjEgKyAodXNlRGVsdGEgPyB2T2xkIDogLXZPbGQpKSAvICgodXNlRGVsdGEgPyB0IDogdDEpIC0gdE9sZCkgKiAxMDAwO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiB1cGRhdGUsXG4gICAgcmVzZXQ6IHJlc2V0LFxuICAgIGdldFZlbG9jaXR5OiBnZXRWZWxvY2l0eVxuICB9O1xufSxcbiAgICBfZ2V0RXZlbnQgPSBmdW5jdGlvbiBfZ2V0RXZlbnQoZSwgcHJldmVudERlZmF1bHQpIHtcbiAgcHJldmVudERlZmF1bHQgJiYgIWUuX2dzYXBBbGxvdyAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gIHJldHVybiBlLmNoYW5nZWRUb3VjaGVzID8gZS5jaGFuZ2VkVG91Y2hlc1swXSA6IGU7XG59LFxuICAgIF9nZXRBYnNvbHV0ZU1heCA9IGZ1bmN0aW9uIF9nZXRBYnNvbHV0ZU1heChhKSB7XG4gIHZhciBtYXggPSBNYXRoLm1heC5hcHBseShNYXRoLCBhKSxcbiAgICAgIG1pbiA9IE1hdGgubWluLmFwcGx5KE1hdGgsIGEpO1xuICByZXR1cm4gTWF0aC5hYnMobWF4KSA+PSBNYXRoLmFicyhtaW4pID8gbWF4IDogbWluO1xufSxcbiAgICBfc2V0U2Nyb2xsVHJpZ2dlciA9IGZ1bmN0aW9uIF9zZXRTY3JvbGxUcmlnZ2VyKCkge1xuICBTY3JvbGxUcmlnZ2VyID0gZ3NhcC5jb3JlLmdsb2JhbHMoKS5TY3JvbGxUcmlnZ2VyO1xuICBTY3JvbGxUcmlnZ2VyICYmIFNjcm9sbFRyaWdnZXIuY29yZSAmJiBfaW50ZWdyYXRlKCk7XG59LFxuICAgIF9pbml0Q29yZSA9IGZ1bmN0aW9uIF9pbml0Q29yZShjb3JlKSB7XG4gIGdzYXAgPSBjb3JlIHx8IF9nZXRHU0FQKCk7XG5cbiAgaWYgKCFfY29yZUluaXR0ZWQgJiYgZ3NhcCAmJiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgIF93aW4gPSB3aW5kb3c7XG4gICAgX2RvYyA9IGRvY3VtZW50O1xuICAgIF9kb2NFbCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIF9ib2R5ID0gX2RvYy5ib2R5O1xuICAgIF9yb290ID0gW193aW4sIF9kb2MsIF9kb2NFbCwgX2JvZHldO1xuICAgIF9jbGFtcCA9IGdzYXAudXRpbHMuY2xhbXA7XG5cbiAgICBfY29udGV4dCA9IGdzYXAuY29yZS5jb250ZXh0IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgX3BvaW50ZXJUeXBlID0gXCJvbnBvaW50ZXJlbnRlclwiIGluIF9ib2R5ID8gXCJwb2ludGVyXCIgOiBcIm1vdXNlXCI7IC8vIGlzVG91Y2ggaXMgMCBpZiBubyB0b3VjaCwgMSBpZiBPTkxZIHRvdWNoLCBhbmQgMiBpZiBpdCBjYW4gYWNjb21tb2RhdGUgdG91Y2ggYnV0IGFsc28gb3RoZXIgdHlwZXMgbGlrZSBtb3VzZS9wb2ludGVyLlxuXG4gICAgX2lzVG91Y2ggPSBPYnNlcnZlci5pc1RvdWNoID0gX3dpbi5tYXRjaE1lZGlhICYmIF93aW4ubWF0Y2hNZWRpYShcIihob3Zlcjogbm9uZSksIChwb2ludGVyOiBjb2Fyc2UpXCIpLm1hdGNoZXMgPyAxIDogXCJvbnRvdWNoc3RhcnRcIiBpbiBfd2luIHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDAgfHwgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgPiAwID8gMiA6IDA7XG4gICAgX2V2ZW50VHlwZXMgPSBPYnNlcnZlci5ldmVudFR5cGVzID0gKFwib250b3VjaHN0YXJ0XCIgaW4gX2RvY0VsID8gXCJ0b3VjaHN0YXJ0LHRvdWNobW92ZSx0b3VjaGNhbmNlbCx0b3VjaGVuZFwiIDogIShcIm9ucG9pbnRlcmRvd25cIiBpbiBfZG9jRWwpID8gXCJtb3VzZWRvd24sbW91c2Vtb3ZlLG1vdXNldXAsbW91c2V1cFwiIDogXCJwb2ludGVyZG93bixwb2ludGVybW92ZSxwb2ludGVyY2FuY2VsLHBvaW50ZXJ1cFwiKS5zcGxpdChcIixcIik7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3N0YXJ0dXAgPSAwO1xuICAgIH0sIDUwMCk7XG5cbiAgICBfc2V0U2Nyb2xsVHJpZ2dlcigpO1xuXG4gICAgX2NvcmVJbml0dGVkID0gMTtcbiAgfVxuXG4gIHJldHVybiBfY29yZUluaXR0ZWQ7XG59O1xuXG5faG9yaXpvbnRhbC5vcCA9IF92ZXJ0aWNhbDtcbl9zY3JvbGxlcnMuY2FjaGUgPSAwO1xuZXhwb3J0IHZhciBPYnNlcnZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmVyKHZhcnMpIHtcbiAgICB0aGlzLmluaXQodmFycyk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JzZXJ2ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCh2YXJzKSB7XG4gICAgX2NvcmVJbml0dGVkIHx8IF9pbml0Q29yZShnc2FwKSB8fCBjb25zb2xlLndhcm4oXCJQbGVhc2UgZ3NhcC5yZWdpc3RlclBsdWdpbihPYnNlcnZlcilcIik7XG4gICAgU2Nyb2xsVHJpZ2dlciB8fCBfc2V0U2Nyb2xsVHJpZ2dlcigpO1xuICAgIHZhciB0b2xlcmFuY2UgPSB2YXJzLnRvbGVyYW5jZSxcbiAgICAgICAgZHJhZ01pbmltdW0gPSB2YXJzLmRyYWdNaW5pbXVtLFxuICAgICAgICB0eXBlID0gdmFycy50eXBlLFxuICAgICAgICB0YXJnZXQgPSB2YXJzLnRhcmdldCxcbiAgICAgICAgbGluZUhlaWdodCA9IHZhcnMubGluZUhlaWdodCxcbiAgICAgICAgZGVib3VuY2UgPSB2YXJzLmRlYm91bmNlLFxuICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHZhcnMucHJldmVudERlZmF1bHQsXG4gICAgICAgIG9uU3RvcCA9IHZhcnMub25TdG9wLFxuICAgICAgICBvblN0b3BEZWxheSA9IHZhcnMub25TdG9wRGVsYXksXG4gICAgICAgIGlnbm9yZSA9IHZhcnMuaWdub3JlLFxuICAgICAgICB3aGVlbFNwZWVkID0gdmFycy53aGVlbFNwZWVkLFxuICAgICAgICBldmVudCA9IHZhcnMuZXZlbnQsXG4gICAgICAgIG9uRHJhZ1N0YXJ0ID0gdmFycy5vbkRyYWdTdGFydCxcbiAgICAgICAgb25EcmFnRW5kID0gdmFycy5vbkRyYWdFbmQsXG4gICAgICAgIG9uRHJhZyA9IHZhcnMub25EcmFnLFxuICAgICAgICBvblByZXNzID0gdmFycy5vblByZXNzLFxuICAgICAgICBvblJlbGVhc2UgPSB2YXJzLm9uUmVsZWFzZSxcbiAgICAgICAgb25SaWdodCA9IHZhcnMub25SaWdodCxcbiAgICAgICAgb25MZWZ0ID0gdmFycy5vbkxlZnQsXG4gICAgICAgIG9uVXAgPSB2YXJzLm9uVXAsXG4gICAgICAgIG9uRG93biA9IHZhcnMub25Eb3duLFxuICAgICAgICBvbkNoYW5nZVggPSB2YXJzLm9uQ2hhbmdlWCxcbiAgICAgICAgb25DaGFuZ2VZID0gdmFycy5vbkNoYW5nZVksXG4gICAgICAgIG9uQ2hhbmdlID0gdmFycy5vbkNoYW5nZSxcbiAgICAgICAgb25Ub2dnbGVYID0gdmFycy5vblRvZ2dsZVgsXG4gICAgICAgIG9uVG9nZ2xlWSA9IHZhcnMub25Ub2dnbGVZLFxuICAgICAgICBvbkhvdmVyID0gdmFycy5vbkhvdmVyLFxuICAgICAgICBvbkhvdmVyRW5kID0gdmFycy5vbkhvdmVyRW5kLFxuICAgICAgICBvbk1vdmUgPSB2YXJzLm9uTW92ZSxcbiAgICAgICAgaWdub3JlQ2hlY2sgPSB2YXJzLmlnbm9yZUNoZWNrLFxuICAgICAgICBpc05vcm1hbGl6ZXIgPSB2YXJzLmlzTm9ybWFsaXplcixcbiAgICAgICAgb25HZXN0dXJlU3RhcnQgPSB2YXJzLm9uR2VzdHVyZVN0YXJ0LFxuICAgICAgICBvbkdlc3R1cmVFbmQgPSB2YXJzLm9uR2VzdHVyZUVuZCxcbiAgICAgICAgb25XaGVlbCA9IHZhcnMub25XaGVlbCxcbiAgICAgICAgb25FbmFibGUgPSB2YXJzLm9uRW5hYmxlLFxuICAgICAgICBvbkRpc2FibGUgPSB2YXJzLm9uRGlzYWJsZSxcbiAgICAgICAgb25DbGljayA9IHZhcnMub25DbGljayxcbiAgICAgICAgc2Nyb2xsU3BlZWQgPSB2YXJzLnNjcm9sbFNwZWVkLFxuICAgICAgICBjYXB0dXJlID0gdmFycy5jYXB0dXJlLFxuICAgICAgICBhbGxvd0NsaWNrcyA9IHZhcnMuYWxsb3dDbGlja3MsXG4gICAgICAgIGxvY2tBeGlzID0gdmFycy5sb2NrQXhpcyxcbiAgICAgICAgb25Mb2NrQXhpcyA9IHZhcnMub25Mb2NrQXhpcztcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldCA9IF9nZXRUYXJnZXQodGFyZ2V0KSB8fCBfZG9jRWw7XG4gICAgdGhpcy52YXJzID0gdmFycztcbiAgICBpZ25vcmUgJiYgKGlnbm9yZSA9IGdzYXAudXRpbHMudG9BcnJheShpZ25vcmUpKTtcbiAgICB0b2xlcmFuY2UgPSB0b2xlcmFuY2UgfHwgMWUtOTtcbiAgICBkcmFnTWluaW11bSA9IGRyYWdNaW5pbXVtIHx8IDA7XG4gICAgd2hlZWxTcGVlZCA9IHdoZWVsU3BlZWQgfHwgMTtcbiAgICBzY3JvbGxTcGVlZCA9IHNjcm9sbFNwZWVkIHx8IDE7XG4gICAgdHlwZSA9IHR5cGUgfHwgXCJ3aGVlbCx0b3VjaCxwb2ludGVyXCI7XG4gICAgZGVib3VuY2UgPSBkZWJvdW5jZSAhPT0gZmFsc2U7XG4gICAgbGluZUhlaWdodCB8fCAobGluZUhlaWdodCA9IHBhcnNlRmxvYXQoX3dpbi5nZXRDb21wdXRlZFN0eWxlKF9ib2R5KS5saW5lSGVpZ2h0KSB8fCAyMik7IC8vIG5vdGU6IGJyb3dzZXIgbWF5IHJlcG9ydCBcIm5vcm1hbFwiLCBzbyBkZWZhdWx0IHRvIDIyLlxuXG4gICAgdmFyIGlkLFxuICAgICAgICBvblN0b3BEZWxheWVkQ2FsbCxcbiAgICAgICAgZHJhZ2dlZCxcbiAgICAgICAgbW92ZWQsXG4gICAgICAgIHdoZWVsZWQsXG4gICAgICAgIGxvY2tlZCxcbiAgICAgICAgYXhpcyxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIHByZXZEZWx0YVggPSAwLFxuICAgICAgICBwcmV2RGVsdGFZID0gMCxcbiAgICAgICAgcGFzc2l2ZSA9IHZhcnMucGFzc2l2ZSB8fCAhcHJldmVudERlZmF1bHQsXG4gICAgICAgIHNjcm9sbEZ1bmNYID0gX2dldFNjcm9sbEZ1bmModGFyZ2V0LCBfaG9yaXpvbnRhbCksXG4gICAgICAgIHNjcm9sbEZ1bmNZID0gX2dldFNjcm9sbEZ1bmModGFyZ2V0LCBfdmVydGljYWwpLFxuICAgICAgICBzY3JvbGxYID0gc2Nyb2xsRnVuY1goKSxcbiAgICAgICAgc2Nyb2xsWSA9IHNjcm9sbEZ1bmNZKCksXG4gICAgICAgIGxpbWl0VG9Ub3VjaCA9IH50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSAmJiAhfnR5cGUuaW5kZXhPZihcInBvaW50ZXJcIikgJiYgX2V2ZW50VHlwZXNbMF0gPT09IFwicG9pbnRlcmRvd25cIixcbiAgICAgICAgLy8gZm9yIGRldmljZXMgdGhhdCBhY2NvbW1vZGF0ZSBtb3VzZSBldmVudHMgYW5kIHRvdWNoIGV2ZW50cywgd2UgbmVlZCB0byBkaXN0aW5ndWlzaC5cbiAgICBpc1ZpZXdwb3J0ID0gX2lzVmlld3BvcnQodGFyZ2V0KSxcbiAgICAgICAgb3duZXJEb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudCB8fCBfZG9jLFxuICAgICAgICBkZWx0YVggPSBbMCwgMCwgMF0sXG4gICAgICAgIC8vIHdoZWVsLCBzY3JvbGwsIHBvaW50ZXIvdG91Y2hcbiAgICBkZWx0YVkgPSBbMCwgMCwgMF0sXG4gICAgICAgIG9uQ2xpY2tUaW1lID0gMCxcbiAgICAgICAgY2xpY2tDYXB0dXJlID0gZnVuY3Rpb24gY2xpY2tDYXB0dXJlKCkge1xuICAgICAgcmV0dXJuIG9uQ2xpY2tUaW1lID0gX2dldFRpbWUoKTtcbiAgICB9LFxuICAgICAgICBfaWdub3JlQ2hlY2sgPSBmdW5jdGlvbiBfaWdub3JlQ2hlY2soZSwgaXNQb2ludGVyT3JUb3VjaCkge1xuICAgICAgcmV0dXJuIChzZWxmLmV2ZW50ID0gZSkgJiYgaWdub3JlICYmIH5pZ25vcmUuaW5kZXhPZihlLnRhcmdldCkgfHwgaXNQb2ludGVyT3JUb3VjaCAmJiBsaW1pdFRvVG91Y2ggJiYgZS5wb2ludGVyVHlwZSAhPT0gXCJ0b3VjaFwiIHx8IGlnbm9yZUNoZWNrICYmIGlnbm9yZUNoZWNrKGUsIGlzUG9pbnRlck9yVG91Y2gpO1xuICAgIH0sXG4gICAgICAgIG9uU3RvcEZ1bmMgPSBmdW5jdGlvbiBvblN0b3BGdW5jKCkge1xuICAgICAgc2VsZi5fdngucmVzZXQoKTtcblxuICAgICAgc2VsZi5fdnkucmVzZXQoKTtcblxuICAgICAgb25TdG9wRGVsYXllZENhbGwucGF1c2UoKTtcbiAgICAgIG9uU3RvcCAmJiBvblN0b3Aoc2VsZik7XG4gICAgfSxcbiAgICAgICAgdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdmFyIGR4ID0gc2VsZi5kZWx0YVggPSBfZ2V0QWJzb2x1dGVNYXgoZGVsdGFYKSxcbiAgICAgICAgICBkeSA9IHNlbGYuZGVsdGFZID0gX2dldEFic29sdXRlTWF4KGRlbHRhWSksXG4gICAgICAgICAgY2hhbmdlZFggPSBNYXRoLmFicyhkeCkgPj0gdG9sZXJhbmNlLFxuICAgICAgICAgIGNoYW5nZWRZID0gTWF0aC5hYnMoZHkpID49IHRvbGVyYW5jZTtcblxuICAgICAgb25DaGFuZ2UgJiYgKGNoYW5nZWRYIHx8IGNoYW5nZWRZKSAmJiBvbkNoYW5nZShzZWxmLCBkeCwgZHksIGRlbHRhWCwgZGVsdGFZKTsgLy8gaW4gU2Nyb2xsVHJpZ2dlci5ub3JtYWxpemVTY3JvbGwoKSwgd2UgbmVlZCB0byBrbm93IGlmIGl0IHdhcyB0b3VjaC9wb2ludGVyIHNvIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBkZWx0YVgvZGVsdGFZIEFycmF5cyBiZWZvcmUgd2UgY2xlYXIgdGhlbSBvdXQuXG5cbiAgICAgIGlmIChjaGFuZ2VkWCkge1xuICAgICAgICBvblJpZ2h0ICYmIHNlbGYuZGVsdGFYID4gMCAmJiBvblJpZ2h0KHNlbGYpO1xuICAgICAgICBvbkxlZnQgJiYgc2VsZi5kZWx0YVggPCAwICYmIG9uTGVmdChzZWxmKTtcbiAgICAgICAgb25DaGFuZ2VYICYmIG9uQ2hhbmdlWChzZWxmKTtcbiAgICAgICAgb25Ub2dnbGVYICYmIHNlbGYuZGVsdGFYIDwgMCAhPT0gcHJldkRlbHRhWCA8IDAgJiYgb25Ub2dnbGVYKHNlbGYpO1xuICAgICAgICBwcmV2RGVsdGFYID0gc2VsZi5kZWx0YVg7XG4gICAgICAgIGRlbHRhWFswXSA9IGRlbHRhWFsxXSA9IGRlbHRhWFsyXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VkWSkge1xuICAgICAgICBvbkRvd24gJiYgc2VsZi5kZWx0YVkgPiAwICYmIG9uRG93bihzZWxmKTtcbiAgICAgICAgb25VcCAmJiBzZWxmLmRlbHRhWSA8IDAgJiYgb25VcChzZWxmKTtcbiAgICAgICAgb25DaGFuZ2VZICYmIG9uQ2hhbmdlWShzZWxmKTtcbiAgICAgICAgb25Ub2dnbGVZICYmIHNlbGYuZGVsdGFZIDwgMCAhPT0gcHJldkRlbHRhWSA8IDAgJiYgb25Ub2dnbGVZKHNlbGYpO1xuICAgICAgICBwcmV2RGVsdGFZID0gc2VsZi5kZWx0YVk7XG4gICAgICAgIGRlbHRhWVswXSA9IGRlbHRhWVsxXSA9IGRlbHRhWVsyXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb3ZlZCB8fCBkcmFnZ2VkKSB7XG4gICAgICAgIG9uTW92ZSAmJiBvbk1vdmUoc2VsZik7XG5cbiAgICAgICAgaWYgKGRyYWdnZWQpIHtcbiAgICAgICAgICBvbkRyYWcoc2VsZik7XG4gICAgICAgICAgZHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbW92ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbG9ja2VkICYmICEobG9ja2VkID0gZmFsc2UpICYmIG9uTG9ja0F4aXMgJiYgb25Mb2NrQXhpcyhzZWxmKTtcblxuICAgICAgaWYgKHdoZWVsZWQpIHtcbiAgICAgICAgb25XaGVlbChzZWxmKTtcbiAgICAgICAgd2hlZWxlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZCA9IDA7XG4gICAgfSxcbiAgICAgICAgb25EZWx0YSA9IGZ1bmN0aW9uIG9uRGVsdGEoeCwgeSwgaW5kZXgpIHtcbiAgICAgIGRlbHRhWFtpbmRleF0gKz0geDtcbiAgICAgIGRlbHRhWVtpbmRleF0gKz0geTtcblxuICAgICAgc2VsZi5fdngudXBkYXRlKHgpO1xuXG4gICAgICBzZWxmLl92eS51cGRhdGUoeSk7XG5cbiAgICAgIGRlYm91bmNlID8gaWQgfHwgKGlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZSkpIDogdXBkYXRlKCk7XG4gICAgfSxcbiAgICAgICAgb25Ub3VjaE9yUG9pbnRlckRlbHRhID0gZnVuY3Rpb24gb25Ub3VjaE9yUG9pbnRlckRlbHRhKHgsIHkpIHtcbiAgICAgIGlmIChsb2NrQXhpcyAmJiAhYXhpcykge1xuICAgICAgICBzZWxmLmF4aXMgPSBheGlzID0gTWF0aC5hYnMoeCkgPiBNYXRoLmFicyh5KSA/IFwieFwiIDogXCJ5XCI7XG4gICAgICAgIGxvY2tlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChheGlzICE9PSBcInlcIikge1xuICAgICAgICBkZWx0YVhbMl0gKz0geDtcblxuICAgICAgICBzZWxmLl92eC51cGRhdGUoeCwgdHJ1ZSk7IC8vIHVwZGF0ZSB0aGUgdmVsb2NpdHkgYXMgZnJlcXVlbnRseSBhcyBwb3NzaWJsZSBpbnN0ZWFkIG9mIGluIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gc28gdGhhdCB2ZXJ5IHF1aWNrIHRvdWNoLXNjcm9sbHMgKGZsaWNrcykgZmVlbCBuYXR1cmFsLiBJZiBpdCdzIHRoZSBtb3VzZS90b3VjaC9wb2ludGVyLCBmb3JjZSBpdCBzbyB0aGF0IHdlIGdldCBzbmFwcHkvYWNjdXJhdGUgbW9tZW50dW0gc2Nyb2xsLlxuXG4gICAgICB9XG5cbiAgICAgIGlmIChheGlzICE9PSBcInhcIikge1xuICAgICAgICBkZWx0YVlbMl0gKz0geTtcblxuICAgICAgICBzZWxmLl92eS51cGRhdGUoeSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGRlYm91bmNlID8gaWQgfHwgKGlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZSkpIDogdXBkYXRlKCk7XG4gICAgfSxcbiAgICAgICAgX29uRHJhZyA9IGZ1bmN0aW9uIF9vbkRyYWcoZSkge1xuICAgICAgaWYgKF9pZ25vcmVDaGVjayhlLCAxKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGUgPSBfZ2V0RXZlbnQoZSwgcHJldmVudERlZmF1bHQpO1xuICAgICAgdmFyIHggPSBlLmNsaWVudFgsXG4gICAgICAgICAgeSA9IGUuY2xpZW50WSxcbiAgICAgICAgICBkeCA9IHggLSBzZWxmLngsXG4gICAgICAgICAgZHkgPSB5IC0gc2VsZi55LFxuICAgICAgICAgIGlzRHJhZ2dpbmcgPSBzZWxmLmlzRHJhZ2dpbmc7XG4gICAgICBzZWxmLnggPSB4O1xuICAgICAgc2VsZi55ID0geTtcblxuICAgICAgaWYgKGlzRHJhZ2dpbmcgfHwgTWF0aC5hYnMoc2VsZi5zdGFydFggLSB4KSA+PSBkcmFnTWluaW11bSB8fCBNYXRoLmFicyhzZWxmLnN0YXJ0WSAtIHkpID49IGRyYWdNaW5pbXVtKSB7XG4gICAgICAgIG9uRHJhZyAmJiAoZHJhZ2dlZCA9IHRydWUpO1xuICAgICAgICBpc0RyYWdnaW5nIHx8IChzZWxmLmlzRHJhZ2dpbmcgPSB0cnVlKTtcbiAgICAgICAgb25Ub3VjaE9yUG9pbnRlckRlbHRhKGR4LCBkeSk7XG4gICAgICAgIGlzRHJhZ2dpbmcgfHwgb25EcmFnU3RhcnQgJiYgb25EcmFnU3RhcnQoc2VsZik7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgX29uUHJlc3MgPSBzZWxmLm9uUHJlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKF9pZ25vcmVDaGVjayhlLCAxKSB8fCBlICYmIGUuYnV0dG9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5heGlzID0gYXhpcyA9IG51bGw7XG4gICAgICBvblN0b3BEZWxheWVkQ2FsbC5wYXVzZSgpO1xuICAgICAgc2VsZi5pc1ByZXNzZWQgPSB0cnVlO1xuICAgICAgZSA9IF9nZXRFdmVudChlKTsgLy8gbm90ZTogbWF5IG5lZWQgdG8gcHJldmVudERlZmF1bHQoPykgV29uJ3Qgc2lkZS1zY3JvbGwgb24gaU9TIFNhZmFyaSBpZiB3ZSBkbywgdGhvdWdoLlxuXG4gICAgICBwcmV2RGVsdGFYID0gcHJldkRlbHRhWSA9IDA7XG4gICAgICBzZWxmLnN0YXJ0WCA9IHNlbGYueCA9IGUuY2xpZW50WDtcbiAgICAgIHNlbGYuc3RhcnRZID0gc2VsZi55ID0gZS5jbGllbnRZO1xuXG4gICAgICBzZWxmLl92eC5yZXNldCgpOyAvLyBvdGhlcndpc2UgdGhlIHQyIG1heSBiZSBzdGFsZSBpZiB0aGUgdXNlciB0b3VjaGVzIGFuZCBmbGlja3Mgc3VwZXIgZmFzdCBhbmQgcmVsZWFzZXMgaW4gbGVzcyB0aGFuIDIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRpY2tzLCBjYXVzaW5nIHZlbG9jaXR5IHRvIGJlIDAuXG5cblxuICAgICAgc2VsZi5fdnkucmVzZXQoKTtcblxuICAgICAgX2FkZExpc3RlbmVyKGlzTm9ybWFsaXplciA/IHRhcmdldCA6IG93bmVyRG9jLCBfZXZlbnRUeXBlc1sxXSwgX29uRHJhZywgcGFzc2l2ZSwgdHJ1ZSk7XG5cbiAgICAgIHNlbGYuZGVsdGFYID0gc2VsZi5kZWx0YVkgPSAwO1xuICAgICAgb25QcmVzcyAmJiBvblByZXNzKHNlbGYpO1xuICAgIH0sXG4gICAgICAgIF9vblJlbGVhc2UgPSBzZWxmLm9uUmVsZWFzZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoX2lnbm9yZUNoZWNrKGUsIDEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3JlbW92ZUxpc3RlbmVyKGlzTm9ybWFsaXplciA/IHRhcmdldCA6IG93bmVyRG9jLCBfZXZlbnRUeXBlc1sxXSwgX29uRHJhZywgdHJ1ZSk7XG5cbiAgICAgIHZhciBpc1RyYWNraW5nRHJhZyA9ICFpc05hTihzZWxmLnkgLSBzZWxmLnN0YXJ0WSksXG4gICAgICAgICAgd2FzRHJhZ2dpbmcgPSBzZWxmLmlzRHJhZ2dpbmcsXG4gICAgICAgICAgaXNEcmFnTm90Q2xpY2sgPSB3YXNEcmFnZ2luZyAmJiAoTWF0aC5hYnMoc2VsZi54IC0gc2VsZi5zdGFydFgpID4gMyB8fCBNYXRoLmFicyhzZWxmLnkgLSBzZWxmLnN0YXJ0WSkgPiAzKSxcbiAgICAgICAgICAvLyBzb21lIHRvdWNoIGRldmljZXMgbmVlZCBzb21lIHdpZ2dsZSByb29tIGluIHRlcm1zIG9mIHNlbnNpbmcgY2xpY2tzIC0gdGhlIGZpbmdlciBtYXkgbW92ZSBhIGZldyBwaXhlbHMuXG4gICAgICBldmVudERhdGEgPSBfZ2V0RXZlbnQoZSk7XG5cbiAgICAgIGlmICghaXNEcmFnTm90Q2xpY2sgJiYgaXNUcmFja2luZ0RyYWcpIHtcbiAgICAgICAgc2VsZi5fdngucmVzZXQoKTtcblxuICAgICAgICBzZWxmLl92eS5yZXNldCgpOyAvL2lmIChwcmV2ZW50RGVmYXVsdCAmJiBhbGxvd0NsaWNrcyAmJiBzZWxmLmlzUHJlc3NlZCkgeyAvLyBjaGVjayBpc1ByZXNzZWQgYmVjYXVzZSBpbiBhIHJhcmUgZWRnZSBjYXNlLCB0aGUgaW5wdXRPYnNlcnZlciBpbiBTY3JvbGxUcmlnZ2VyIG1heSBzdG9wUHJvcGFnYXRpb24oKSBvbiB0aGUgcHJlc3MvZHJhZywgc28gdGhlIG9uUmVsZWFzZSBtYXkgZ2V0IGZpcmVkIHdpdGhvdXQgdGhlIG9uUHJlc3Mvb25EcmFnIGV2ZXIgZ2V0dGluZyBjYWxsZWQsIHRodXMgaXQgY291bGQgdHJpZ2dlciBhIGNsaWNrIHRvIG9jY3VyIG9uIGEgbGluayBhZnRlciBzY3JvbGwtZHJhZ2dpbmcgaXQuXG5cblxuICAgICAgICBpZiAocHJldmVudERlZmF1bHQgJiYgYWxsb3dDbGlja3MpIHtcbiAgICAgICAgICBnc2FwLmRlbGF5ZWRDYWxsKDAuMDgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHNvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgd29uJ3QgdHJ1c3Qgc2NyaXB0LWdlbmVyYXRlZCBjbGlja3MsIHNvIGlmIHRoZSB1c2VyIHRyaWVzIHRvIGNsaWNrIG9uIGEgdmlkZW8gdG8gcGxheSBpdCwgZm9yIGV4YW1wbGUsIGl0IHNpbXBseSB3b24ndCB3b3JrLiBTaW5jZSBhIHJlZ3VsYXIgXCJjbGlja1wiIGV2ZW50IHdpbGwgbW9zdCBsaWtlbHkgYmUgZ2VuZXJhdGVkIGFueXdheSAob25lIHRoYXQgaGFzIGl0cyBpc1RydXN0ZWQgZmxhZyBzZXQgdG8gdHJ1ZSksIHdlIG11c3Qgc2xpZ2h0bHkgZGVsYXkgb3VyIHNjcmlwdC1nZW5lcmF0ZWQgY2xpY2sgc28gdGhhdCB0aGUgXCJyZWFsXCIvdHJ1c3RlZCBvbmUgaXMgcHJpb3JpdGl6ZWQuIFJlbWVtYmVyLCB3aGVuIHRoZXJlIGFyZSBkdXBsaWNhdGUgZXZlbnRzIGluIHF1aWNrIHN1Y2Nlc3Npb24sIHdlIHN1cHByZXNzIGFsbCBidXQgdGhlIGZpcnN0IG9uZS4gU29tZSBicm93c2VycyBkb24ndCBldmVuIHRyaWdnZXIgdGhlIFwicmVhbFwiIG9uZSBhdCBhbGwsIHNvIG91ciBzeW50aGV0aWMgb25lIGlzIGEgc2FmZXR5IHZhbHZlIHRoYXQgZW5zdXJlcyB0aGF0IG5vIG1hdHRlciB3aGF0LCBhIGNsaWNrIGV2ZW50IGRvZXMgZ2V0IGRpc3BhdGNoZWQuXG4gICAgICAgICAgICBpZiAoX2dldFRpbWUoKSAtIG9uQ2xpY2tUaW1lID4gMzAwICYmICFlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0LmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgLy9zb21lIGJyb3dzZXJzIChsaWtlIG1vYmlsZSBTYWZhcmkpIGRvbid0IHByb3Blcmx5IHRyaWdnZXIgdGhlIGNsaWNrIGV2ZW50XG4gICAgICAgICAgICAgICAgZS50YXJnZXQuY2xpY2soKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChvd25lckRvYy5jcmVhdGVFdmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBzeW50aGV0aWNFdmVudCA9IG93bmVyRG9jLmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7XG4gICAgICAgICAgICAgICAgc3ludGhldGljRXZlbnQuaW5pdE1vdXNlRXZlbnQoXCJjbGlja1wiLCB0cnVlLCB0cnVlLCBfd2luLCAxLCBldmVudERhdGEuc2NyZWVuWCwgZXZlbnREYXRhLnNjcmVlblksIGV2ZW50RGF0YS5jbGllbnRYLCBldmVudERhdGEuY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgICAgICAgIGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc3ludGhldGljRXZlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi5pc0RyYWdnaW5nID0gc2VsZi5pc0dlc3R1cmluZyA9IHNlbGYuaXNQcmVzc2VkID0gZmFsc2U7XG4gICAgICBvblN0b3AgJiYgd2FzRHJhZ2dpbmcgJiYgIWlzTm9ybWFsaXplciAmJiBvblN0b3BEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpO1xuICAgICAgb25EcmFnRW5kICYmIHdhc0RyYWdnaW5nICYmIG9uRHJhZ0VuZChzZWxmKTtcbiAgICAgIG9uUmVsZWFzZSAmJiBvblJlbGVhc2Uoc2VsZiwgaXNEcmFnTm90Q2xpY2spO1xuICAgIH0sXG4gICAgICAgIF9vbkdlc3R1cmVTdGFydCA9IGZ1bmN0aW9uIF9vbkdlc3R1cmVTdGFydChlKSB7XG4gICAgICByZXR1cm4gZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxICYmIChzZWxmLmlzR2VzdHVyaW5nID0gdHJ1ZSkgJiYgb25HZXN0dXJlU3RhcnQoZSwgc2VsZi5pc0RyYWdnaW5nKTtcbiAgICB9LFxuICAgICAgICBfb25HZXN0dXJlRW5kID0gZnVuY3Rpb24gX29uR2VzdHVyZUVuZCgpIHtcbiAgICAgIHJldHVybiAoc2VsZi5pc0dlc3R1cmluZyA9IGZhbHNlKSB8fCBvbkdlc3R1cmVFbmQoc2VsZik7XG4gICAgfSxcbiAgICAgICAgb25TY3JvbGwgPSBmdW5jdGlvbiBvblNjcm9sbChlKSB7XG4gICAgICBpZiAoX2lnbm9yZUNoZWNrKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHggPSBzY3JvbGxGdW5jWCgpLFxuICAgICAgICAgIHkgPSBzY3JvbGxGdW5jWSgpO1xuICAgICAgb25EZWx0YSgoeCAtIHNjcm9sbFgpICogc2Nyb2xsU3BlZWQsICh5IC0gc2Nyb2xsWSkgKiBzY3JvbGxTcGVlZCwgMSk7XG4gICAgICBzY3JvbGxYID0geDtcbiAgICAgIHNjcm9sbFkgPSB5O1xuICAgICAgb25TdG9wICYmIG9uU3RvcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgfSxcbiAgICAgICAgX29uV2hlZWwgPSBmdW5jdGlvbiBfb25XaGVlbChlKSB7XG4gICAgICBpZiAoX2lnbm9yZUNoZWNrKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZSA9IF9nZXRFdmVudChlLCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgICBvbldoZWVsICYmICh3aGVlbGVkID0gdHJ1ZSk7XG4gICAgICB2YXIgbXVsdGlwbGllciA9IChlLmRlbHRhTW9kZSA9PT0gMSA/IGxpbmVIZWlnaHQgOiBlLmRlbHRhTW9kZSA9PT0gMiA/IF93aW4uaW5uZXJIZWlnaHQgOiAxKSAqIHdoZWVsU3BlZWQ7XG4gICAgICBvbkRlbHRhKGUuZGVsdGFYICogbXVsdGlwbGllciwgZS5kZWx0YVkgKiBtdWx0aXBsaWVyLCAwKTtcbiAgICAgIG9uU3RvcCAmJiAhaXNOb3JtYWxpemVyICYmIG9uU3RvcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgfSxcbiAgICAgICAgX29uTW92ZSA9IGZ1bmN0aW9uIF9vbk1vdmUoZSkge1xuICAgICAgaWYgKF9pZ25vcmVDaGVjayhlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB4ID0gZS5jbGllbnRYLFxuICAgICAgICAgIHkgPSBlLmNsaWVudFksXG4gICAgICAgICAgZHggPSB4IC0gc2VsZi54LFxuICAgICAgICAgIGR5ID0geSAtIHNlbGYueTtcbiAgICAgIHNlbGYueCA9IHg7XG4gICAgICBzZWxmLnkgPSB5O1xuICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgb25TdG9wICYmIG9uU3RvcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgICAoZHggfHwgZHkpICYmIG9uVG91Y2hPclBvaW50ZXJEZWx0YShkeCwgZHkpO1xuICAgIH0sXG4gICAgICAgIF9vbkhvdmVyID0gZnVuY3Rpb24gX29uSG92ZXIoZSkge1xuICAgICAgc2VsZi5ldmVudCA9IGU7XG4gICAgICBvbkhvdmVyKHNlbGYpO1xuICAgIH0sXG4gICAgICAgIF9vbkhvdmVyRW5kID0gZnVuY3Rpb24gX29uSG92ZXJFbmQoZSkge1xuICAgICAgc2VsZi5ldmVudCA9IGU7XG4gICAgICBvbkhvdmVyRW5kKHNlbGYpO1xuICAgIH0sXG4gICAgICAgIF9vbkNsaWNrID0gZnVuY3Rpb24gX29uQ2xpY2soZSkge1xuICAgICAgcmV0dXJuIF9pZ25vcmVDaGVjayhlKSB8fCBfZ2V0RXZlbnQoZSwgcHJldmVudERlZmF1bHQpICYmIG9uQ2xpY2soc2VsZik7XG4gICAgfTtcblxuICAgIG9uU3RvcERlbGF5ZWRDYWxsID0gc2VsZi5fZGMgPSBnc2FwLmRlbGF5ZWRDYWxsKG9uU3RvcERlbGF5IHx8IDAuMjUsIG9uU3RvcEZ1bmMpLnBhdXNlKCk7XG4gICAgc2VsZi5kZWx0YVggPSBzZWxmLmRlbHRhWSA9IDA7XG4gICAgc2VsZi5fdnggPSBfZ2V0VmVsb2NpdHlQcm9wKDAsIDUwLCB0cnVlKTtcbiAgICBzZWxmLl92eSA9IF9nZXRWZWxvY2l0eVByb3AoMCwgNTAsIHRydWUpO1xuICAgIHNlbGYuc2Nyb2xsWCA9IHNjcm9sbEZ1bmNYO1xuICAgIHNlbGYuc2Nyb2xsWSA9IHNjcm9sbEZ1bmNZO1xuICAgIHNlbGYuaXNEcmFnZ2luZyA9IHNlbGYuaXNHZXN0dXJpbmcgPSBzZWxmLmlzUHJlc3NlZCA9IGZhbHNlO1xuXG4gICAgX2NvbnRleHQodGhpcyk7XG5cbiAgICBzZWxmLmVuYWJsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIXNlbGYuaXNFbmFibGVkKSB7XG4gICAgICAgIF9hZGRMaXN0ZW5lcihpc1ZpZXdwb3J0ID8gb3duZXJEb2MgOiB0YXJnZXQsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG5cbiAgICAgICAgdHlwZS5pbmRleE9mKFwic2Nyb2xsXCIpID49IDAgJiYgX2FkZExpc3RlbmVyKGlzVmlld3BvcnQgPyBvd25lckRvYyA6IHRhcmdldCwgXCJzY3JvbGxcIiwgb25TY3JvbGwsIHBhc3NpdmUsIGNhcHR1cmUpO1xuICAgICAgICB0eXBlLmluZGV4T2YoXCJ3aGVlbFwiKSA+PSAwICYmIF9hZGRMaXN0ZW5lcih0YXJnZXQsIFwid2hlZWxcIiwgX29uV2hlZWwsIHBhc3NpdmUsIGNhcHR1cmUpO1xuXG4gICAgICAgIGlmICh0eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSA+PSAwICYmIF9pc1RvdWNoIHx8IHR5cGUuaW5kZXhPZihcInBvaW50ZXJcIikgPj0gMCkge1xuICAgICAgICAgIF9hZGRMaXN0ZW5lcih0YXJnZXQsIF9ldmVudFR5cGVzWzBdLCBfb25QcmVzcywgcGFzc2l2ZSwgY2FwdHVyZSk7XG5cbiAgICAgICAgICBfYWRkTGlzdGVuZXIob3duZXJEb2MsIF9ldmVudFR5cGVzWzJdLCBfb25SZWxlYXNlKTtcblxuICAgICAgICAgIF9hZGRMaXN0ZW5lcihvd25lckRvYywgX2V2ZW50VHlwZXNbM10sIF9vblJlbGVhc2UpO1xuXG4gICAgICAgICAgYWxsb3dDbGlja3MgJiYgX2FkZExpc3RlbmVyKHRhcmdldCwgXCJjbGlja1wiLCBjbGlja0NhcHR1cmUsIHRydWUsIHRydWUpO1xuICAgICAgICAgIG9uQ2xpY2sgJiYgX2FkZExpc3RlbmVyKHRhcmdldCwgXCJjbGlja1wiLCBfb25DbGljayk7XG4gICAgICAgICAgb25HZXN0dXJlU3RhcnQgJiYgX2FkZExpc3RlbmVyKG93bmVyRG9jLCBcImdlc3R1cmVzdGFydFwiLCBfb25HZXN0dXJlU3RhcnQpO1xuICAgICAgICAgIG9uR2VzdHVyZUVuZCAmJiBfYWRkTGlzdGVuZXIob3duZXJEb2MsIFwiZ2VzdHVyZWVuZFwiLCBfb25HZXN0dXJlRW5kKTtcbiAgICAgICAgICBvbkhvdmVyICYmIF9hZGRMaXN0ZW5lcih0YXJnZXQsIF9wb2ludGVyVHlwZSArIFwiZW50ZXJcIiwgX29uSG92ZXIpO1xuICAgICAgICAgIG9uSG92ZXJFbmQgJiYgX2FkZExpc3RlbmVyKHRhcmdldCwgX3BvaW50ZXJUeXBlICsgXCJsZWF2ZVwiLCBfb25Ib3ZlckVuZCk7XG4gICAgICAgICAgb25Nb3ZlICYmIF9hZGRMaXN0ZW5lcih0YXJnZXQsIF9wb2ludGVyVHlwZSArIFwibW92ZVwiLCBfb25Nb3ZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgZSAmJiBlLnR5cGUgJiYgX29uUHJlc3MoZSk7XG4gICAgICAgIG9uRW5hYmxlICYmIG9uRW5hYmxlKHNlbGYpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgc2VsZi5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaXNFbmFibGVkKSB7XG4gICAgICAgIC8vIG9ubHkgcmVtb3ZlIHRoZSBfb25TY3JvbGwgbGlzdGVuZXIgaWYgdGhlcmUgYXJlbid0IGFueSBvdGhlcnMgdGhhdCByZWx5IG9uIHRoZSBmdW5jdGlvbmFsaXR5LlxuICAgICAgICBfb2JzZXJ2ZXJzLmZpbHRlcihmdW5jdGlvbiAobykge1xuICAgICAgICAgIHJldHVybiBvICE9PSBzZWxmICYmIF9pc1ZpZXdwb3J0KG8udGFyZ2V0KTtcbiAgICAgICAgfSkubGVuZ3RoIHx8IF9yZW1vdmVMaXN0ZW5lcihpc1ZpZXdwb3J0ID8gb3duZXJEb2MgOiB0YXJnZXQsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG5cbiAgICAgICAgaWYgKHNlbGYuaXNQcmVzc2VkKSB7XG4gICAgICAgICAgc2VsZi5fdngucmVzZXQoKTtcblxuICAgICAgICAgIHNlbGYuX3Z5LnJlc2V0KCk7XG5cbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIoaXNOb3JtYWxpemVyID8gdGFyZ2V0IDogb3duZXJEb2MsIF9ldmVudFR5cGVzWzFdLCBfb25EcmFnLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihpc1ZpZXdwb3J0ID8gb3duZXJEb2MgOiB0YXJnZXQsIFwic2Nyb2xsXCIsIG9uU2Nyb2xsLCBjYXB0dXJlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBcIndoZWVsXCIsIF9vbldoZWVsLCBjYXB0dXJlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBfZXZlbnRUeXBlc1swXSwgX29uUHJlc3MsIGNhcHR1cmUpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgX2V2ZW50VHlwZXNbMl0sIF9vblJlbGVhc2UpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgX2V2ZW50VHlwZXNbM10sIF9vblJlbGVhc2UpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0YXJnZXQsIFwiY2xpY2tcIiwgY2xpY2tDYXB0dXJlLCB0cnVlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBcImNsaWNrXCIsIF9vbkNsaWNrKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIFwiZ2VzdHVyZXN0YXJ0XCIsIF9vbkdlc3R1cmVTdGFydCk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBcImdlc3R1cmVlbmRcIiwgX29uR2VzdHVyZUVuZCk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRhcmdldCwgX3BvaW50ZXJUeXBlICsgXCJlbnRlclwiLCBfb25Ib3Zlcik7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRhcmdldCwgX3BvaW50ZXJUeXBlICsgXCJsZWF2ZVwiLCBfb25Ib3ZlckVuZCk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRhcmdldCwgX3BvaW50ZXJUeXBlICsgXCJtb3ZlXCIsIF9vbk1vdmUpO1xuXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gc2VsZi5pc1ByZXNzZWQgPSBzZWxmLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgb25EaXNhYmxlICYmIG9uRGlzYWJsZShzZWxmKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5raWxsID0gc2VsZi5yZXZlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmRpc2FibGUoKTtcblxuICAgICAgdmFyIGkgPSBfb2JzZXJ2ZXJzLmluZGV4T2Yoc2VsZik7XG5cbiAgICAgIGkgPj0gMCAmJiBfb2JzZXJ2ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIF9ub3JtYWxpemVyID09PSBzZWxmICYmIChfbm9ybWFsaXplciA9IDApO1xuICAgIH07XG5cbiAgICBfb2JzZXJ2ZXJzLnB1c2goc2VsZik7XG5cbiAgICBpc05vcm1hbGl6ZXIgJiYgX2lzVmlld3BvcnQodGFyZ2V0KSAmJiAoX25vcm1hbGl6ZXIgPSBzZWxmKTtcbiAgICBzZWxmLmVuYWJsZShldmVudCk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKE9ic2VydmVyLCBbe1xuICAgIGtleTogXCJ2ZWxvY2l0eVhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92eC5nZXRWZWxvY2l0eSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2ZWxvY2l0eVlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92eS5nZXRWZWxvY2l0eSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPYnNlcnZlcjtcbn0oKTtcbk9ic2VydmVyLnZlcnNpb24gPSBcIjMuMTIuNVwiO1xuXG5PYnNlcnZlci5jcmVhdGUgPSBmdW5jdGlvbiAodmFycykge1xuICByZXR1cm4gbmV3IE9ic2VydmVyKHZhcnMpO1xufTtcblxuT2JzZXJ2ZXIucmVnaXN0ZXIgPSBfaW5pdENvcmU7XG5cbk9ic2VydmVyLmdldEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9vYnNlcnZlcnMuc2xpY2UoKTtcbn07XG5cbk9ic2VydmVyLmdldEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIF9vYnNlcnZlcnMuZmlsdGVyKGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8udmFycy5pZCA9PT0gaWQ7XG4gIH0pWzBdO1xufTtcblxuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKE9ic2VydmVyKTtcbmV4cG9ydCB7IE9ic2VydmVyIGFzIGRlZmF1bHQsIF9pc1ZpZXdwb3J0LCBfc2Nyb2xsZXJzLCBfZ2V0U2Nyb2xsRnVuYywgX2dldFByb3h5UHJvcCwgX3Byb3hpZXMsIF9nZXRWZWxvY2l0eVByb3AsIF92ZXJ0aWNhbCwgX2hvcml6b250YWwsIF9nZXRUYXJnZXQgfTsiXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsImdzYXAiLCJfY29yZUluaXR0ZWQiLCJfY2xhbXAiLCJfd2luIiwiX2RvYyIsIl9kb2NFbCIsIl9ib2R5IiwiX2lzVG91Y2giLCJfcG9pbnRlclR5cGUiLCJTY3JvbGxUcmlnZ2VyIiwiX3Jvb3QiLCJfbm9ybWFsaXplciIsIl9ldmVudFR5cGVzIiwiX2NvbnRleHQiLCJfZ2V0R1NBUCIsIndpbmRvdyIsInJlZ2lzdGVyUGx1Z2luIiwiX3N0YXJ0dXAiLCJfb2JzZXJ2ZXJzIiwiX3Njcm9sbGVycyIsIl9wcm94aWVzIiwiX2dldFRpbWUiLCJEYXRlIiwibm93IiwiX2JyaWRnZSIsIm5hbWUiLCJ2YWx1ZSIsIl9pbnRlZ3JhdGUiLCJjb3JlIiwiZGF0YSIsImJyaWRnZSIsInNjcm9sbGVycyIsInByb3hpZXMiLCJwdXNoIiwiYXBwbHkiLCJfZ2V0UHJveHlQcm9wIiwiZWxlbWVudCIsInByb3BlcnR5IiwiaW5kZXhPZiIsIl9pc1ZpZXdwb3J0IiwiZWwiLCJfYWRkTGlzdGVuZXIiLCJ0eXBlIiwiZnVuYyIsInBhc3NpdmUiLCJjYXB0dXJlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9yZW1vdmVMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJfc2Nyb2xsTGVmdCIsIl9zY3JvbGxUb3AiLCJfb25TY3JvbGwiLCJpc1ByZXNzZWQiLCJjYWNoZSIsIl9zY3JvbGxDYWNoZUZ1bmMiLCJmIiwiZG9Ob3RDYWNoZSIsImNhY2hpbmdGdW5jIiwiaGlzdG9yeSIsInNjcm9sbFJlc3RvcmF0aW9uIiwiaXNOb3JtYWxpemluZyIsInYiLCJNYXRoIiwicm91bmQiLCJpT1MiLCJjYWNoZUlEIiwib2Zmc2V0IiwiX2hvcml6b250YWwiLCJzIiwicCIsInAyIiwib3MiLCJvczIiLCJkIiwiZDIiLCJhIiwic2MiLCJhcmd1bWVudHMiLCJzY3JvbGxUbyIsIl92ZXJ0aWNhbCIsInBhZ2VYT2Zmc2V0Iiwib3AiLCJwYWdlWU9mZnNldCIsIl9nZXRUYXJnZXQiLCJ0Iiwic2VsZiIsIl9jdHgiLCJzZWxlY3RvciIsInV0aWxzIiwidG9BcnJheSIsImNvbmZpZyIsIm51bGxUYXJnZXRXYXJuIiwiY29uc29sZSIsIndhcm4iLCJfZ2V0U2Nyb2xsRnVuYyIsIl9yZWYiLCJzY3JvbGxpbmdFbGVtZW50IiwicHJldiIsInNtb290aCIsImdldFByb3BlcnR5IiwiX2dldFZlbG9jaXR5UHJvcCIsIm1pblRpbWVSZWZyZXNoIiwidXNlRGVsdGEiLCJ2MSIsInYyIiwidDEiLCJ0MiIsIm1pbiIsImRyb3BUb1plcm9UaW1lIiwibWF4IiwidXBkYXRlIiwiZm9yY2UiLCJyZXNldCIsImdldFZlbG9jaXR5IiwibGF0ZXN0VmFsdWUiLCJ0T2xkIiwidk9sZCIsIl9nZXRFdmVudCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsIl9nc2FwQWxsb3ciLCJjaGFuZ2VkVG91Y2hlcyIsIl9nZXRBYnNvbHV0ZU1heCIsImFicyIsIl9zZXRTY3JvbGxUcmlnZ2VyIiwiZ2xvYmFscyIsIl9pbml0Q29yZSIsImRvY3VtZW50IiwiYm9keSIsImRvY3VtZW50RWxlbWVudCIsImNsYW1wIiwiY29udGV4dCIsIk9ic2VydmVyIiwiaXNUb3VjaCIsIm1hdGNoTWVkaWEiLCJtYXRjaGVzIiwibmF2aWdhdG9yIiwibWF4VG91Y2hQb2ludHMiLCJtc01heFRvdWNoUG9pbnRzIiwiZXZlbnRUeXBlcyIsInNwbGl0Iiwic2V0VGltZW91dCIsInZhcnMiLCJpbml0IiwiX3Byb3RvIiwidG9sZXJhbmNlIiwiZHJhZ01pbmltdW0iLCJsaW5lSGVpZ2h0IiwiZGVib3VuY2UiLCJvblN0b3AiLCJvblN0b3BEZWxheSIsImlnbm9yZSIsIndoZWVsU3BlZWQiLCJldmVudCIsIm9uRHJhZ1N0YXJ0Iiwib25EcmFnRW5kIiwib25EcmFnIiwib25QcmVzcyIsIm9uUmVsZWFzZSIsIm9uUmlnaHQiLCJvbkxlZnQiLCJvblVwIiwib25Eb3duIiwib25DaGFuZ2VYIiwib25DaGFuZ2VZIiwib25DaGFuZ2UiLCJvblRvZ2dsZVgiLCJvblRvZ2dsZVkiLCJvbkhvdmVyIiwib25Ib3ZlckVuZCIsIm9uTW92ZSIsImlnbm9yZUNoZWNrIiwiaXNOb3JtYWxpemVyIiwib25HZXN0dXJlU3RhcnQiLCJvbkdlc3R1cmVFbmQiLCJvbldoZWVsIiwib25FbmFibGUiLCJvbkRpc2FibGUiLCJvbkNsaWNrIiwic2Nyb2xsU3BlZWQiLCJhbGxvd0NsaWNrcyIsImxvY2tBeGlzIiwib25Mb2NrQXhpcyIsInBhcnNlRmxvYXQiLCJnZXRDb21wdXRlZFN0eWxlIiwiaWQiLCJvblN0b3BEZWxheWVkQ2FsbCIsImRyYWdnZWQiLCJtb3ZlZCIsIndoZWVsZWQiLCJsb2NrZWQiLCJheGlzIiwicHJldkRlbHRhWCIsInByZXZEZWx0YVkiLCJzY3JvbGxGdW5jWCIsInNjcm9sbEZ1bmNZIiwic2Nyb2xsWCIsInNjcm9sbFkiLCJsaW1pdFRvVG91Y2giLCJpc1ZpZXdwb3J0Iiwib3duZXJEb2MiLCJvd25lckRvY3VtZW50IiwiZGVsdGFYIiwiZGVsdGFZIiwib25DbGlja1RpbWUiLCJjbGlja0NhcHR1cmUiLCJfaWdub3JlQ2hlY2siLCJpc1BvaW50ZXJPclRvdWNoIiwicG9pbnRlclR5cGUiLCJvblN0b3BGdW5jIiwiX3Z4IiwiX3Z5IiwicGF1c2UiLCJkeCIsImR5IiwiY2hhbmdlZFgiLCJjaGFuZ2VkWSIsIm9uRGVsdGEiLCJ4IiwieSIsImluZGV4IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib25Ub3VjaE9yUG9pbnRlckRlbHRhIiwiX29uRHJhZyIsImNsaWVudFgiLCJjbGllbnRZIiwiaXNEcmFnZ2luZyIsInN0YXJ0WCIsInN0YXJ0WSIsIl9vblByZXNzIiwiYnV0dG9uIiwiX29uUmVsZWFzZSIsImlzVHJhY2tpbmdEcmFnIiwiaXNOYU4iLCJ3YXNEcmFnZ2luZyIsImlzRHJhZ05vdENsaWNrIiwiZXZlbnREYXRhIiwiZGVsYXllZENhbGwiLCJkZWZhdWx0UHJldmVudGVkIiwiY2xpY2siLCJjcmVhdGVFdmVudCIsInN5bnRoZXRpY0V2ZW50IiwiaW5pdE1vdXNlRXZlbnQiLCJzY3JlZW5YIiwic2NyZWVuWSIsImRpc3BhdGNoRXZlbnQiLCJpc0dlc3R1cmluZyIsInJlc3RhcnQiLCJfb25HZXN0dXJlU3RhcnQiLCJ0b3VjaGVzIiwiX29uR2VzdHVyZUVuZCIsIm9uU2Nyb2xsIiwiX29uV2hlZWwiLCJtdWx0aXBsaWVyIiwiZGVsdGFNb2RlIiwiaW5uZXJIZWlnaHQiLCJfb25Nb3ZlIiwiX29uSG92ZXIiLCJfb25Ib3ZlckVuZCIsIl9vbkNsaWNrIiwiX2RjIiwiZW5hYmxlIiwiaXNFbmFibGVkIiwiZGlzYWJsZSIsImZpbHRlciIsIm8iLCJraWxsIiwicmV2ZXJ0Iiwic3BsaWNlIiwiZ2V0IiwidmVyc2lvbiIsImNyZWF0ZSIsInJlZ2lzdGVyIiwiZ2V0QWxsIiwic2xpY2UiLCJnZXRCeUlkIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Observer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/PixiPlugin.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/PixiPlugin.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PixiPlugin: function() { return /* binding */ PixiPlugin; },\n/* harmony export */   \"default\": function() { return /* binding */ PixiPlugin; }\n/* harmony export */ });\n/*!\n * PixiPlugin 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var gsap, _splitColor, _coreInitted, _PIXI, PropTween, _getSetter, _isV4, _windowExists = function _windowExists() {\n    return typeof window !== \"undefined\";\n}, _getGSAP = function _getGSAP() {\n    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _isFunction = function _isFunction(value) {\n    return typeof value === \"function\";\n}, _warn = function _warn(message) {\n    return console.warn(message);\n}, _idMatrix = [\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0\n], _lumR = 0.212671, _lumG = 0.715160, _lumB = 0.072169, _filterClass = function _filterClass(name) {\n    return _isFunction(_PIXI[name]) ? _PIXI[name] : _PIXI.filters[name];\n}, // in PIXI 7.1, filters moved from PIXI.filters to just PIXI\n_applyMatrix = function _applyMatrix(m, m2) {\n    var temp = [], i = 0, z = 0, y, x;\n    for(y = 0; y < 4; y++){\n        for(x = 0; x < 5; x++){\n            z = x === 4 ? m[i + 4] : 0;\n            temp[i + x] = m[i] * m2[x] + m[i + 1] * m2[x + 5] + m[i + 2] * m2[x + 10] + m[i + 3] * m2[x + 15] + z;\n        }\n        i += 5;\n    }\n    return temp;\n}, _setSaturation = function _setSaturation(m, n) {\n    var inv = 1 - n, r = inv * _lumR, g = inv * _lumG, b = inv * _lumB;\n    return _applyMatrix([\n        r + n,\n        g,\n        b,\n        0,\n        0,\n        r,\n        g + n,\n        b,\n        0,\n        0,\n        r,\n        g,\n        b + n,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n    ], m);\n}, _colorize = function _colorize(m, color, amount) {\n    var c = _splitColor(color), r = c[0] / 255, g = c[1] / 255, b = c[2] / 255, inv = 1 - amount;\n    return _applyMatrix([\n        inv + amount * r * _lumR,\n        amount * r * _lumG,\n        amount * r * _lumB,\n        0,\n        0,\n        amount * g * _lumR,\n        inv + amount * g * _lumG,\n        amount * g * _lumB,\n        0,\n        0,\n        amount * b * _lumR,\n        amount * b * _lumG,\n        inv + amount * b * _lumB,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n    ], m);\n}, _setHue = function _setHue(m, n) {\n    n *= Math.PI / 180;\n    var c = Math.cos(n), s = Math.sin(n);\n    return _applyMatrix([\n        _lumR + c * (1 - _lumR) + s * -_lumR,\n        _lumG + c * -_lumG + s * -_lumG,\n        _lumB + c * -_lumB + s * (1 - _lumB),\n        0,\n        0,\n        _lumR + c * -_lumR + s * 0.143,\n        _lumG + c * (1 - _lumG) + s * 0.14,\n        _lumB + c * -_lumB + s * -0.283,\n        0,\n        0,\n        _lumR + c * -_lumR + s * -(1 - _lumR),\n        _lumG + c * -_lumG + s * _lumG,\n        _lumB + c * (1 - _lumB) + s * _lumB,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1\n    ], m);\n}, _setContrast = function _setContrast(m, n) {\n    return _applyMatrix([\n        n,\n        0,\n        0,\n        0,\n        0.5 * (1 - n),\n        0,\n        n,\n        0,\n        0,\n        0.5 * (1 - n),\n        0,\n        0,\n        n,\n        0,\n        0.5 * (1 - n),\n        0,\n        0,\n        0,\n        1,\n        0\n    ], m);\n}, _getFilter = function _getFilter(target, type) {\n    var filterClass = _filterClass(type), filters = target.filters || [], i = filters.length, filter;\n    filterClass || _warn(type + \" not found. PixiPlugin.registerPIXI(PIXI)\");\n    while(--i > -1){\n        if (filters[i] instanceof filterClass) {\n            return filters[i];\n        }\n    }\n    filter = new filterClass();\n    if (type === \"BlurFilter\") {\n        filter.blur = 0;\n    }\n    filters.push(filter);\n    target.filters = filters;\n    return filter;\n}, _addColorMatrixFilterCacheTween = function _addColorMatrixFilterCacheTween(p, plugin, cache, vars) {\n    //we cache the ColorMatrixFilter components in a _gsColorMatrixFilter object attached to the target object so that it's easy to grab the current value at any time.\n    plugin.add(cache, p, cache[p], vars[p]);\n    plugin._props.push(p);\n}, _applyBrightnessToMatrix = function _applyBrightnessToMatrix(brightness, matrix) {\n    var filterClass = _filterClass(\"ColorMatrixFilter\"), temp = new filterClass();\n    temp.matrix = matrix;\n    temp.brightness(brightness, true);\n    return temp.matrix;\n}, _copy = function _copy(obj) {\n    var copy = {}, p;\n    for(p in obj){\n        copy[p] = obj[p];\n    }\n    return copy;\n}, _CMFdefaults = {\n    contrast: 1,\n    saturation: 1,\n    colorizeAmount: 0,\n    colorize: \"rgb(255,255,255)\",\n    hue: 0,\n    brightness: 1\n}, _parseColorMatrixFilter = function _parseColorMatrixFilter(target, v, pg) {\n    var filter = _getFilter(target, \"ColorMatrixFilter\"), cache = target._gsColorMatrixFilter = target._gsColorMatrixFilter || _copy(_CMFdefaults), combine = v.combineCMF && !(\"colorMatrixFilter\" in v && !v.colorMatrixFilter), i, matrix, startMatrix;\n    startMatrix = filter.matrix;\n    if (v.resolution) {\n        filter.resolution = v.resolution;\n    }\n    if (v.matrix && v.matrix.length === startMatrix.length) {\n        matrix = v.matrix;\n        if (cache.contrast !== 1) {\n            _addColorMatrixFilterCacheTween(\"contrast\", pg, cache, _CMFdefaults);\n        }\n        if (cache.hue) {\n            _addColorMatrixFilterCacheTween(\"hue\", pg, cache, _CMFdefaults);\n        }\n        if (cache.brightness !== 1) {\n            _addColorMatrixFilterCacheTween(\"brightness\", pg, cache, _CMFdefaults);\n        }\n        if (cache.colorizeAmount) {\n            _addColorMatrixFilterCacheTween(\"colorize\", pg, cache, _CMFdefaults);\n            _addColorMatrixFilterCacheTween(\"colorizeAmount\", pg, cache, _CMFdefaults);\n        }\n        if (cache.saturation !== 1) {\n            _addColorMatrixFilterCacheTween(\"saturation\", pg, cache, _CMFdefaults);\n        }\n    } else {\n        matrix = _idMatrix.slice();\n        if (v.contrast != null) {\n            matrix = _setContrast(matrix, +v.contrast);\n            _addColorMatrixFilterCacheTween(\"contrast\", pg, cache, v);\n        } else if (cache.contrast !== 1) {\n            if (combine) {\n                matrix = _setContrast(matrix, cache.contrast);\n            } else {\n                _addColorMatrixFilterCacheTween(\"contrast\", pg, cache, _CMFdefaults);\n            }\n        }\n        if (v.hue != null) {\n            matrix = _setHue(matrix, +v.hue);\n            _addColorMatrixFilterCacheTween(\"hue\", pg, cache, v);\n        } else if (cache.hue) {\n            if (combine) {\n                matrix = _setHue(matrix, cache.hue);\n            } else {\n                _addColorMatrixFilterCacheTween(\"hue\", pg, cache, _CMFdefaults);\n            }\n        }\n        if (v.brightness != null) {\n            matrix = _applyBrightnessToMatrix(+v.brightness, matrix);\n            _addColorMatrixFilterCacheTween(\"brightness\", pg, cache, v);\n        } else if (cache.brightness !== 1) {\n            if (combine) {\n                matrix = _applyBrightnessToMatrix(cache.brightness, matrix);\n            } else {\n                _addColorMatrixFilterCacheTween(\"brightness\", pg, cache, _CMFdefaults);\n            }\n        }\n        if (v.colorize != null) {\n            v.colorizeAmount = \"colorizeAmount\" in v ? +v.colorizeAmount : 1;\n            matrix = _colorize(matrix, v.colorize, v.colorizeAmount);\n            _addColorMatrixFilterCacheTween(\"colorize\", pg, cache, v);\n            _addColorMatrixFilterCacheTween(\"colorizeAmount\", pg, cache, v);\n        } else if (cache.colorizeAmount) {\n            if (combine) {\n                matrix = _colorize(matrix, cache.colorize, cache.colorizeAmount);\n            } else {\n                _addColorMatrixFilterCacheTween(\"colorize\", pg, cache, _CMFdefaults);\n                _addColorMatrixFilterCacheTween(\"colorizeAmount\", pg, cache, _CMFdefaults);\n            }\n        }\n        if (v.saturation != null) {\n            matrix = _setSaturation(matrix, +v.saturation);\n            _addColorMatrixFilterCacheTween(\"saturation\", pg, cache, v);\n        } else if (cache.saturation !== 1) {\n            if (combine) {\n                matrix = _setSaturation(matrix, cache.saturation);\n            } else {\n                _addColorMatrixFilterCacheTween(\"saturation\", pg, cache, _CMFdefaults);\n            }\n        }\n    }\n    i = matrix.length;\n    while(--i > -1){\n        if (matrix[i] !== startMatrix[i]) {\n            pg.add(startMatrix, i, startMatrix[i], matrix[i], \"colorMatrixFilter\");\n        }\n    }\n    pg._props.push(\"colorMatrixFilter\");\n}, _renderColor = function _renderColor(ratio, _ref) {\n    var t = _ref.t, p = _ref.p, color = _ref.color, set = _ref.set;\n    set(t, p, color[0] << 16 | color[1] << 8 | color[2]);\n}, _renderDirtyCache = function _renderDirtyCache(ratio, _ref2) {\n    var g = _ref2.g;\n    if (g) {\n        //in order for PixiJS to actually redraw GraphicsData, we've gotta increment the \"dirty\" and \"clearDirty\" values. If we don't do this, the values will be tween properly, but not rendered.\n        g.dirty++;\n        g.clearDirty++;\n    }\n}, _renderAutoAlpha = function _renderAutoAlpha(ratio, data) {\n    data.t.visible = !!data.t.alpha;\n}, _addColorTween = function _addColorTween(target, p, value, plugin) {\n    var currentValue = target[p], startColor = _splitColor(_isFunction(currentValue) ? target[p.indexOf(\"set\") || !_isFunction(target[\"get\" + p.substr(3)]) ? p : \"get\" + p.substr(3)]() : currentValue), endColor = _splitColor(value);\n    plugin._pt = new PropTween(plugin._pt, target, p, 0, 0, _renderColor, {\n        t: target,\n        p: p,\n        color: startColor,\n        set: _getSetter(target, p)\n    });\n    plugin.add(startColor, 0, startColor[0], endColor[0]);\n    plugin.add(startColor, 1, startColor[1], endColor[1]);\n    plugin.add(startColor, 2, startColor[2], endColor[2]);\n}, _colorProps = {\n    tint: 1,\n    lineColor: 1,\n    fillColor: 1\n}, _xyContexts = \"position,scale,skew,pivot,anchor,tilePosition,tileScale\".split(\",\"), _contexts = {\n    x: \"position\",\n    y: \"position\",\n    tileX: \"tilePosition\",\n    tileY: \"tilePosition\"\n}, _colorMatrixFilterProps = {\n    colorMatrixFilter: 1,\n    saturation: 1,\n    contrast: 1,\n    hue: 1,\n    colorize: 1,\n    colorizeAmount: 1,\n    brightness: 1,\n    combineCMF: 1\n}, _DEG2RAD = Math.PI / 180, _isString = function _isString(value) {\n    return typeof value === \"string\";\n}, _degreesToRadians = function _degreesToRadians(value) {\n    return _isString(value) && value.charAt(1) === \"=\" ? value.substr(0, 2) + parseFloat(value.substr(2)) * _DEG2RAD : value * _DEG2RAD;\n}, _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {\n    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 100000) / 100000, data);\n}, _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue, radians) {\n    var cap = 360 * (radians ? _DEG2RAD : 1), isString = _isString(endValue), relative = isString && endValue.charAt(1) === \"=\" ? +(endValue.charAt(0) + \"1\") : 0, endNum = parseFloat(relative ? endValue.substr(2) : endValue) * (radians ? _DEG2RAD : 1), change = relative ? endNum * relative : endNum - startNum, finalValue = startNum + change, direction, pt;\n    if (isString) {\n        direction = endValue.split(\"_\")[1];\n        if (direction === \"short\") {\n            change %= cap;\n            if (change !== change % (cap / 2)) {\n                change += change < 0 ? cap : -cap;\n            }\n        }\n        if (direction === \"cw\" && change < 0) {\n            change = (change + cap * 1e10) % cap - ~~(change / cap) * cap;\n        } else if (direction === \"ccw\" && change > 0) {\n            change = (change - cap * 1e10) % cap - ~~(change / cap) * cap;\n        }\n    }\n    plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);\n    pt.e = finalValue;\n    return pt;\n}, _initCore = function _initCore() {\n    if (!_coreInitted) {\n        gsap = _getGSAP();\n        _PIXI = _coreInitted = _PIXI || _windowExists() && window.PIXI;\n        _isV4 = _PIXI && _PIXI.VERSION && _PIXI.VERSION.charAt(0) === \"4\";\n        _splitColor = function _splitColor(color) {\n            return gsap.utils.splitColor((color + \"\").substr(0, 2) === \"0x\" ? \"#\" + color.substr(2) : color);\n        }; // some colors in PIXI are reported as \"0xFF4421\" instead of \"#FF4421\".\n    }\n}, i, p; //context setup...\nfor(i = 0; i < _xyContexts.length; i++){\n    p = _xyContexts[i];\n    _contexts[p + \"X\"] = p;\n    _contexts[p + \"Y\"] = p;\n}\nvar PixiPlugin = {\n    version: \"3.12.5\",\n    name: \"pixi\",\n    register: function register(core, Plugin, propTween) {\n        gsap = core;\n        PropTween = propTween;\n        _getSetter = Plugin.getSetter;\n        _initCore();\n    },\n    headless: true,\n    // doesn't need window\n    registerPIXI: function registerPIXI(pixi) {\n        _PIXI = pixi;\n    },\n    init: function init(target, values, tween, index, targets) {\n        _PIXI || _initCore();\n        if (!_PIXI) {\n            _warn(\"PIXI was not found. PixiPlugin.registerPIXI(PIXI);\");\n            return false;\n        }\n        var context, axis, value, colorMatrix, filter, p, padding, i, data;\n        for(p in values){\n            context = _contexts[p];\n            value = values[p];\n            if (context) {\n                axis = ~p.charAt(p.length - 1).toLowerCase().indexOf(\"x\") ? \"x\" : \"y\";\n                this.add(target[context], axis, target[context][axis], context === \"skew\" ? _degreesToRadians(value) : value, 0, 0, 0, 0, 0, 1);\n            } else if (p === \"scale\" || p === \"anchor\" || p === \"pivot\" || p === \"tileScale\") {\n                this.add(target[p], \"x\", target[p].x, value);\n                this.add(target[p], \"y\", target[p].y, value);\n            } else if (p === \"rotation\" || p === \"angle\") {\n                //PIXI expects rotation in radians, but as a convenience we let folks define it in degrees and we do the conversion.\n                _addRotationalPropTween(this, target, p, target[p], value, p === \"rotation\");\n            } else if (_colorMatrixFilterProps[p]) {\n                if (!colorMatrix) {\n                    _parseColorMatrixFilter(target, values.colorMatrixFilter || values, this);\n                    colorMatrix = true;\n                }\n            } else if (p === \"blur\" || p === \"blurX\" || p === \"blurY\" || p === \"blurPadding\") {\n                filter = _getFilter(target, \"BlurFilter\");\n                this.add(filter, p, filter[p], value);\n                if (values.blurPadding !== 0) {\n                    padding = values.blurPadding || Math.max(filter[p], value) * 2;\n                    i = target.filters.length;\n                    while(--i > -1){\n                        target.filters[i].padding = Math.max(target.filters[i].padding, padding); //if we don't expand the padding on all the filters, it can look clipped.\n                    }\n                }\n            } else if (_colorProps[p]) {\n                if ((p === \"lineColor\" || p === \"fillColor\") && target instanceof _PIXI.Graphics) {\n                    data = (target.geometry || target).graphicsData; //\"geometry\" was introduced in PIXI version 5\n                    this._pt = new PropTween(this._pt, target, p, 0, 0, _renderDirtyCache, {\n                        g: target.geometry || target\n                    });\n                    i = data.length;\n                    while(--i > -1){\n                        _addColorTween(_isV4 ? data[i] : data[i][p.substr(0, 4) + \"Style\"], _isV4 ? p : \"color\", value, this);\n                    }\n                } else {\n                    _addColorTween(target, p, value, this);\n                }\n            } else if (p === \"autoAlpha\") {\n                this._pt = new PropTween(this._pt, target, \"visible\", 0, 0, _renderAutoAlpha);\n                this.add(target, \"alpha\", target.alpha, value);\n                this._props.push(\"alpha\", \"visible\");\n            } else if (p !== \"resolution\") {\n                this.add(target, p, \"get\", value);\n            }\n            this._props.push(p);\n        }\n    }\n};\n_getGSAP() && gsap.registerPlugin(PixiPlugin);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9QaXhpUGx1Z2luLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7O0FBUUEsR0FFQSxrQkFBa0IsR0FDbEIsSUFBSUEsTUFDQUMsYUFDQUMsY0FDQUMsT0FDQUMsV0FDQUMsWUFDQUMsT0FDQUMsZ0JBQWdCLFNBQVNBO0lBQzNCLE9BQU8sT0FBT0MsV0FBVztBQUMzQixHQUNJQyxXQUFXLFNBQVNBO0lBQ3RCLE9BQU9ULFFBQVFPLG1CQUFvQlAsQ0FBQUEsT0FBT1EsT0FBT1IsSUFBSSxLQUFLQSxLQUFLVSxjQUFjLElBQUlWO0FBQ25GLEdBQ0lXLGNBQWMsU0FBU0EsWUFBWUMsS0FBSztJQUMxQyxPQUFPLE9BQU9BLFVBQVU7QUFDMUIsR0FDSUMsUUFBUSxTQUFTQSxNQUFNQyxPQUFPO0lBQ2hDLE9BQU9DLFFBQVFDLElBQUksQ0FBQ0Y7QUFDdEIsR0FDSUcsWUFBWTtJQUFDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7Q0FBRSxFQUN4RUMsUUFBUSxVQUNSQyxRQUFRLFVBQ1JDLFFBQVEsVUFDUkMsZUFBZSxTQUFTQSxhQUFhQyxJQUFJO0lBQzNDLE9BQU9YLFlBQVlSLEtBQUssQ0FBQ21CLEtBQUssSUFBSW5CLEtBQUssQ0FBQ21CLEtBQUssR0FBR25CLE1BQU1vQixPQUFPLENBQUNELEtBQUs7QUFDckUsR0FDSSw0REFBNEQ7QUFDaEVFLGVBQWUsU0FBU0EsYUFBYUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3hDLElBQUlDLE9BQU8sRUFBRSxFQUNUQyxJQUFJLEdBQ0pDLElBQUksR0FDSkMsR0FDQUM7SUFFSixJQUFLRCxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBSztRQUN0QixJQUFLQyxJQUFJLEdB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Olsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vZ3NhcEAzLjEyLjUvbm9kZV9tb2R1bGVzL2dzYXAvUGl4aVBsdWdpbi5qcz9iMDZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogUGl4aVBsdWdpbiAzLjEyLjVcbiAqIGh0dHBzOi8vZ3NhcC5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDI0LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dzYXAuY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdTQVAgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgZ3NhcCxcbiAgICBfc3BsaXRDb2xvcixcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX1BJWEksXG4gICAgUHJvcFR3ZWVuLFxuICAgIF9nZXRTZXR0ZXIsXG4gICAgX2lzVjQsXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCBfd2luZG93RXhpc3RzKCkgJiYgKGdzYXAgPSB3aW5kb3cuZ3NhcCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbiAmJiBnc2FwO1xufSxcbiAgICBfaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIF9pc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn0sXG4gICAgX3dhcm4gPSBmdW5jdGlvbiBfd2FybihtZXNzYWdlKSB7XG4gIHJldHVybiBjb25zb2xlLndhcm4obWVzc2FnZSk7XG59LFxuICAgIF9pZE1hdHJpeCA9IFsxLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxLCAwXSxcbiAgICBfbHVtUiA9IDAuMjEyNjcxLFxuICAgIF9sdW1HID0gMC43MTUxNjAsXG4gICAgX2x1bUIgPSAwLjA3MjE2OSxcbiAgICBfZmlsdGVyQ2xhc3MgPSBmdW5jdGlvbiBfZmlsdGVyQ2xhc3MobmFtZSkge1xuICByZXR1cm4gX2lzRnVuY3Rpb24oX1BJWElbbmFtZV0pID8gX1BJWElbbmFtZV0gOiBfUElYSS5maWx0ZXJzW25hbWVdO1xufSxcbiAgICAvLyBpbiBQSVhJIDcuMSwgZmlsdGVycyBtb3ZlZCBmcm9tIFBJWEkuZmlsdGVycyB0byBqdXN0IFBJWElcbl9hcHBseU1hdHJpeCA9IGZ1bmN0aW9uIF9hcHBseU1hdHJpeChtLCBtMikge1xuICB2YXIgdGVtcCA9IFtdLFxuICAgICAgaSA9IDAsXG4gICAgICB6ID0gMCxcbiAgICAgIHksXG4gICAgICB4O1xuXG4gIGZvciAoeSA9IDA7IHkgPCA0OyB5KyspIHtcbiAgICBmb3IgKHggPSAwOyB4IDwgNTsgeCsrKSB7XG4gICAgICB6ID0geCA9PT0gNCA/IG1baSArIDRdIDogMDtcbiAgICAgIHRlbXBbaSArIHhdID0gbVtpXSAqIG0yW3hdICsgbVtpICsgMV0gKiBtMlt4ICsgNV0gKyBtW2kgKyAyXSAqIG0yW3ggKyAxMF0gKyBtW2kgKyAzXSAqIG0yW3ggKyAxNV0gKyB6O1xuICAgIH1cblxuICAgIGkgKz0gNTtcbiAgfVxuXG4gIHJldHVybiB0ZW1wO1xufSxcbiAgICBfc2V0U2F0dXJhdGlvbiA9IGZ1bmN0aW9uIF9zZXRTYXR1cmF0aW9uKG0sIG4pIHtcbiAgdmFyIGludiA9IDEgLSBuLFxuICAgICAgciA9IGludiAqIF9sdW1SLFxuICAgICAgZyA9IGludiAqIF9sdW1HLFxuICAgICAgYiA9IGludiAqIF9sdW1CO1xuICByZXR1cm4gX2FwcGx5TWF0cml4KFtyICsgbiwgZywgYiwgMCwgMCwgciwgZyArIG4sIGIsIDAsIDAsIHIsIGcsIGIgKyBuLCAwLCAwLCAwLCAwLCAwLCAxLCAwXSwgbSk7XG59LFxuICAgIF9jb2xvcml6ZSA9IGZ1bmN0aW9uIF9jb2xvcml6ZShtLCBjb2xvciwgYW1vdW50KSB7XG4gIHZhciBjID0gX3NwbGl0Q29sb3IoY29sb3IpLFxuICAgICAgciA9IGNbMF0gLyAyNTUsXG4gICAgICBnID0gY1sxXSAvIDI1NSxcbiAgICAgIGIgPSBjWzJdIC8gMjU1LFxuICAgICAgaW52ID0gMSAtIGFtb3VudDtcblxuICByZXR1cm4gX2FwcGx5TWF0cml4KFtpbnYgKyBhbW91bnQgKiByICogX2x1bVIsIGFtb3VudCAqIHIgKiBfbHVtRywgYW1vdW50ICogciAqIF9sdW1CLCAwLCAwLCBhbW91bnQgKiBnICogX2x1bVIsIGludiArIGFtb3VudCAqIGcgKiBfbHVtRywgYW1vdW50ICogZyAqIF9sdW1CLCAwLCAwLCBhbW91bnQgKiBiICogX2x1bVIsIGFtb3VudCAqIGIgKiBfbHVtRywgaW52ICsgYW1vdW50ICogYiAqIF9sdW1CLCAwLCAwLCAwLCAwLCAwLCAxLCAwXSwgbSk7XG59LFxuICAgIF9zZXRIdWUgPSBmdW5jdGlvbiBfc2V0SHVlKG0sIG4pIHtcbiAgbiAqPSBNYXRoLlBJIC8gMTgwO1xuICB2YXIgYyA9IE1hdGguY29zKG4pLFxuICAgICAgcyA9IE1hdGguc2luKG4pO1xuICByZXR1cm4gX2FwcGx5TWF0cml4KFtfbHVtUiArIGMgKiAoMSAtIF9sdW1SKSArIHMgKiAtX2x1bVIsIF9sdW1HICsgYyAqIC1fbHVtRyArIHMgKiAtX2x1bUcsIF9sdW1CICsgYyAqIC1fbHVtQiArIHMgKiAoMSAtIF9sdW1CKSwgMCwgMCwgX2x1bVIgKyBjICogLV9sdW1SICsgcyAqIDAuMTQzLCBfbHVtRyArIGMgKiAoMSAtIF9sdW1HKSArIHMgKiAwLjE0LCBfbHVtQiArIGMgKiAtX2x1bUIgKyBzICogLTAuMjgzLCAwLCAwLCBfbHVtUiArIGMgKiAtX2x1bVIgKyBzICogLSgxIC0gX2x1bVIpLCBfbHVtRyArIGMgKiAtX2x1bUcgKyBzICogX2x1bUcsIF9sdW1CICsgYyAqICgxIC0gX2x1bUIpICsgcyAqIF9sdW1CLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxXSwgbSk7XG59LFxuICAgIF9zZXRDb250cmFzdCA9IGZ1bmN0aW9uIF9zZXRDb250cmFzdChtLCBuKSB7XG4gIHJldHVybiBfYXBwbHlNYXRyaXgoW24sIDAsIDAsIDAsIDAuNSAqICgxIC0gbiksIDAsIG4sIDAsIDAsIDAuNSAqICgxIC0gbiksIDAsIDAsIG4sIDAsIDAuNSAqICgxIC0gbiksIDAsIDAsIDAsIDEsIDBdLCBtKTtcbn0sXG4gICAgX2dldEZpbHRlciA9IGZ1bmN0aW9uIF9nZXRGaWx0ZXIodGFyZ2V0LCB0eXBlKSB7XG4gIHZhciBmaWx0ZXJDbGFzcyA9IF9maWx0ZXJDbGFzcyh0eXBlKSxcbiAgICAgIGZpbHRlcnMgPSB0YXJnZXQuZmlsdGVycyB8fCBbXSxcbiAgICAgIGkgPSBmaWx0ZXJzLmxlbmd0aCxcbiAgICAgIGZpbHRlcjtcblxuICBmaWx0ZXJDbGFzcyB8fCBfd2Fybih0eXBlICsgXCIgbm90IGZvdW5kLiBQaXhpUGx1Z2luLnJlZ2lzdGVyUElYSShQSVhJKVwiKTtcblxuICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICBpZiAoZmlsdGVyc1tpXSBpbnN0YW5jZW9mIGZpbHRlckNsYXNzKSB7XG4gICAgICByZXR1cm4gZmlsdGVyc1tpXTtcbiAgICB9XG4gIH1cblxuICBmaWx0ZXIgPSBuZXcgZmlsdGVyQ2xhc3MoKTtcblxuICBpZiAodHlwZSA9PT0gXCJCbHVyRmlsdGVyXCIpIHtcbiAgICBmaWx0ZXIuYmx1ciA9IDA7XG4gIH1cblxuICBmaWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgdGFyZ2V0LmZpbHRlcnMgPSBmaWx0ZXJzO1xuICByZXR1cm4gZmlsdGVyO1xufSxcbiAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuID0gZnVuY3Rpb24gX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihwLCBwbHVnaW4sIGNhY2hlLCB2YXJzKSB7XG4gIC8vd2UgY2FjaGUgdGhlIENvbG9yTWF0cml4RmlsdGVyIGNvbXBvbmVudHMgaW4gYSBfZ3NDb2xvck1hdHJpeEZpbHRlciBvYmplY3QgYXR0YWNoZWQgdG8gdGhlIHRhcmdldCBvYmplY3Qgc28gdGhhdCBpdCdzIGVhc3kgdG8gZ3JhYiB0aGUgY3VycmVudCB2YWx1ZSBhdCBhbnkgdGltZS5cbiAgcGx1Z2luLmFkZChjYWNoZSwgcCwgY2FjaGVbcF0sIHZhcnNbcF0pO1xuXG4gIHBsdWdpbi5fcHJvcHMucHVzaChwKTtcbn0sXG4gICAgX2FwcGx5QnJpZ2h0bmVzc1RvTWF0cml4ID0gZnVuY3Rpb24gX2FwcGx5QnJpZ2h0bmVzc1RvTWF0cml4KGJyaWdodG5lc3MsIG1hdHJpeCkge1xuICB2YXIgZmlsdGVyQ2xhc3MgPSBfZmlsdGVyQ2xhc3MoXCJDb2xvck1hdHJpeEZpbHRlclwiKSxcbiAgICAgIHRlbXAgPSBuZXcgZmlsdGVyQ2xhc3MoKTtcblxuICB0ZW1wLm1hdHJpeCA9IG1hdHJpeDtcbiAgdGVtcC5icmlnaHRuZXNzKGJyaWdodG5lc3MsIHRydWUpO1xuICByZXR1cm4gdGVtcC5tYXRyaXg7XG59LFxuICAgIF9jb3B5ID0gZnVuY3Rpb24gX2NvcHkob2JqKSB7XG4gIHZhciBjb3B5ID0ge30sXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiBvYmopIHtcbiAgICBjb3B5W3BdID0gb2JqW3BdO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIF9DTUZkZWZhdWx0cyA9IHtcbiAgY29udHJhc3Q6IDEsXG4gIHNhdHVyYXRpb246IDEsXG4gIGNvbG9yaXplQW1vdW50OiAwLFxuICBjb2xvcml6ZTogXCJyZ2IoMjU1LDI1NSwyNTUpXCIsXG4gIGh1ZTogMCxcbiAgYnJpZ2h0bmVzczogMVxufSxcbiAgICBfcGFyc2VDb2xvck1hdHJpeEZpbHRlciA9IGZ1bmN0aW9uIF9wYXJzZUNvbG9yTWF0cml4RmlsdGVyKHRhcmdldCwgdiwgcGcpIHtcbiAgdmFyIGZpbHRlciA9IF9nZXRGaWx0ZXIodGFyZ2V0LCBcIkNvbG9yTWF0cml4RmlsdGVyXCIpLFxuICAgICAgY2FjaGUgPSB0YXJnZXQuX2dzQ29sb3JNYXRyaXhGaWx0ZXIgPSB0YXJnZXQuX2dzQ29sb3JNYXRyaXhGaWx0ZXIgfHwgX2NvcHkoX0NNRmRlZmF1bHRzKSxcbiAgICAgIGNvbWJpbmUgPSB2LmNvbWJpbmVDTUYgJiYgIShcImNvbG9yTWF0cml4RmlsdGVyXCIgaW4gdiAmJiAhdi5jb2xvck1hdHJpeEZpbHRlciksXG4gICAgICBpLFxuICAgICAgbWF0cml4LFxuICAgICAgc3RhcnRNYXRyaXg7XG5cbiAgc3RhcnRNYXRyaXggPSBmaWx0ZXIubWF0cml4O1xuXG4gIGlmICh2LnJlc29sdXRpb24pIHtcbiAgICBmaWx0ZXIucmVzb2x1dGlvbiA9IHYucmVzb2x1dGlvbjtcbiAgfVxuXG4gIGlmICh2Lm1hdHJpeCAmJiB2Lm1hdHJpeC5sZW5ndGggPT09IHN0YXJ0TWF0cml4Lmxlbmd0aCkge1xuICAgIG1hdHJpeCA9IHYubWF0cml4O1xuXG4gICAgaWYgKGNhY2hlLmNvbnRyYXN0ICE9PSAxKSB7XG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiY29udHJhc3RcIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5odWUpIHtcbiAgICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJodWVcIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5icmlnaHRuZXNzICE9PSAxKSB7XG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiYnJpZ2h0bmVzc1wiLCBwZywgY2FjaGUsIF9DTUZkZWZhdWx0cyk7XG4gICAgfVxuXG4gICAgaWYgKGNhY2hlLmNvbG9yaXplQW1vdW50KSB7XG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiY29sb3JpemVcIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuXG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiY29sb3JpemVBbW91bnRcIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5zYXR1cmF0aW9uICE9PSAxKSB7XG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwic2F0dXJhdGlvblwiLCBwZywgY2FjaGUsIF9DTUZkZWZhdWx0cyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hdHJpeCA9IF9pZE1hdHJpeC5zbGljZSgpO1xuXG4gICAgaWYgKHYuY29udHJhc3QgIT0gbnVsbCkge1xuICAgICAgbWF0cml4ID0gX3NldENvbnRyYXN0KG1hdHJpeCwgK3YuY29udHJhc3QpO1xuXG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiY29udHJhc3RcIiwgcGcsIGNhY2hlLCB2KTtcbiAgICB9IGVsc2UgaWYgKGNhY2hlLmNvbnRyYXN0ICE9PSAxKSB7XG4gICAgICBpZiAoY29tYmluZSkge1xuICAgICAgICBtYXRyaXggPSBfc2V0Q29udHJhc3QobWF0cml4LCBjYWNoZS5jb250cmFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiY29udHJhc3RcIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2Lmh1ZSAhPSBudWxsKSB7XG4gICAgICBtYXRyaXggPSBfc2V0SHVlKG1hdHJpeCwgK3YuaHVlKTtcblxuICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImh1ZVwiLCBwZywgY2FjaGUsIHYpO1xuICAgIH0gZWxzZSBpZiAoY2FjaGUuaHVlKSB7XG4gICAgICBpZiAoY29tYmluZSkge1xuICAgICAgICBtYXRyaXggPSBfc2V0SHVlKG1hdHJpeCwgY2FjaGUuaHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJodWVcIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2LmJyaWdodG5lc3MgIT0gbnVsbCkge1xuICAgICAgbWF0cml4ID0gX2FwcGx5QnJpZ2h0bmVzc1RvTWF0cml4KCt2LmJyaWdodG5lc3MsIG1hdHJpeCk7XG5cbiAgICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJicmlnaHRuZXNzXCIsIHBnLCBjYWNoZSwgdik7XG4gICAgfSBlbHNlIGlmIChjYWNoZS5icmlnaHRuZXNzICE9PSAxKSB7XG4gICAgICBpZiAoY29tYmluZSkge1xuICAgICAgICBtYXRyaXggPSBfYXBwbHlCcmlnaHRuZXNzVG9NYXRyaXgoY2FjaGUuYnJpZ2h0bmVzcywgbWF0cml4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJicmlnaHRuZXNzXCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodi5jb2xvcml6ZSAhPSBudWxsKSB7XG4gICAgICB2LmNvbG9yaXplQW1vdW50ID0gXCJjb2xvcml6ZUFtb3VudFwiIGluIHYgPyArdi5jb2xvcml6ZUFtb3VudCA6IDE7XG4gICAgICBtYXRyaXggPSBfY29sb3JpemUobWF0cml4LCB2LmNvbG9yaXplLCB2LmNvbG9yaXplQW1vdW50KTtcblxuICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImNvbG9yaXplXCIsIHBnLCBjYWNoZSwgdik7XG5cbiAgICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJjb2xvcml6ZUFtb3VudFwiLCBwZywgY2FjaGUsIHYpO1xuICAgIH0gZWxzZSBpZiAoY2FjaGUuY29sb3JpemVBbW91bnQpIHtcbiAgICAgIGlmIChjb21iaW5lKSB7XG4gICAgICAgIG1hdHJpeCA9IF9jb2xvcml6ZShtYXRyaXgsIGNhY2hlLmNvbG9yaXplLCBjYWNoZS5jb2xvcml6ZUFtb3VudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiY29sb3JpemVcIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuXG4gICAgICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJjb2xvcml6ZUFtb3VudFwiLCBwZywgY2FjaGUsIF9DTUZkZWZhdWx0cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHYuc2F0dXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICBtYXRyaXggPSBfc2V0U2F0dXJhdGlvbihtYXRyaXgsICt2LnNhdHVyYXRpb24pO1xuXG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwic2F0dXJhdGlvblwiLCBwZywgY2FjaGUsIHYpO1xuICAgIH0gZWxzZSBpZiAoY2FjaGUuc2F0dXJhdGlvbiAhPT0gMSkge1xuICAgICAgaWYgKGNvbWJpbmUpIHtcbiAgICAgICAgbWF0cml4ID0gX3NldFNhdHVyYXRpb24obWF0cml4LCBjYWNoZS5zYXR1cmF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJzYXR1cmF0aW9uXCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpID0gbWF0cml4Lmxlbmd0aDtcblxuICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICBpZiAobWF0cml4W2ldICE9PSBzdGFydE1hdHJpeFtpXSkge1xuICAgICAgcGcuYWRkKHN0YXJ0TWF0cml4LCBpLCBzdGFydE1hdHJpeFtpXSwgbWF0cml4W2ldLCBcImNvbG9yTWF0cml4RmlsdGVyXCIpO1xuICAgIH1cbiAgfVxuXG4gIHBnLl9wcm9wcy5wdXNoKFwiY29sb3JNYXRyaXhGaWx0ZXJcIik7XG59LFxuICAgIF9yZW5kZXJDb2xvciA9IGZ1bmN0aW9uIF9yZW5kZXJDb2xvcihyYXRpbywgX3JlZikge1xuICB2YXIgdCA9IF9yZWYudCxcbiAgICAgIHAgPSBfcmVmLnAsXG4gICAgICBjb2xvciA9IF9yZWYuY29sb3IsXG4gICAgICBzZXQgPSBfcmVmLnNldDtcbiAgc2V0KHQsIHAsIGNvbG9yWzBdIDw8IDE2IHwgY29sb3JbMV0gPDwgOCB8IGNvbG9yWzJdKTtcbn0sXG4gICAgX3JlbmRlckRpcnR5Q2FjaGUgPSBmdW5jdGlvbiBfcmVuZGVyRGlydHlDYWNoZShyYXRpbywgX3JlZjIpIHtcbiAgdmFyIGcgPSBfcmVmMi5nO1xuXG4gIGlmIChnKSB7XG4gICAgLy9pbiBvcmRlciBmb3IgUGl4aUpTIHRvIGFjdHVhbGx5IHJlZHJhdyBHcmFwaGljc0RhdGEsIHdlJ3ZlIGdvdHRhIGluY3JlbWVudCB0aGUgXCJkaXJ0eVwiIGFuZCBcImNsZWFyRGlydHlcIiB2YWx1ZXMuIElmIHdlIGRvbid0IGRvIHRoaXMsIHRoZSB2YWx1ZXMgd2lsbCBiZSB0d2VlbiBwcm9wZXJseSwgYnV0IG5vdCByZW5kZXJlZC5cbiAgICBnLmRpcnR5Kys7XG4gICAgZy5jbGVhckRpcnR5Kys7XG4gIH1cbn0sXG4gICAgX3JlbmRlckF1dG9BbHBoYSA9IGZ1bmN0aW9uIF9yZW5kZXJBdXRvQWxwaGEocmF0aW8sIGRhdGEpIHtcbiAgZGF0YS50LnZpc2libGUgPSAhIWRhdGEudC5hbHBoYTtcbn0sXG4gICAgX2FkZENvbG9yVHdlZW4gPSBmdW5jdGlvbiBfYWRkQ29sb3JUd2Vlbih0YXJnZXQsIHAsIHZhbHVlLCBwbHVnaW4pIHtcbiAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRhcmdldFtwXSxcbiAgICAgIHN0YXJ0Q29sb3IgPSBfc3BsaXRDb2xvcihfaXNGdW5jdGlvbihjdXJyZW50VmFsdWUpID8gdGFyZ2V0W3AuaW5kZXhPZihcInNldFwiKSB8fCAhX2lzRnVuY3Rpb24odGFyZ2V0W1wiZ2V0XCIgKyBwLnN1YnN0cigzKV0pID8gcCA6IFwiZ2V0XCIgKyBwLnN1YnN0cigzKV0oKSA6IGN1cnJlbnRWYWx1ZSksXG4gICAgICBlbmRDb2xvciA9IF9zcGxpdENvbG9yKHZhbHVlKTtcblxuICBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHAsIDAsIDAsIF9yZW5kZXJDb2xvciwge1xuICAgIHQ6IHRhcmdldCxcbiAgICBwOiBwLFxuICAgIGNvbG9yOiBzdGFydENvbG9yLFxuICAgIHNldDogX2dldFNldHRlcih0YXJnZXQsIHApXG4gIH0pO1xuICBwbHVnaW4uYWRkKHN0YXJ0Q29sb3IsIDAsIHN0YXJ0Q29sb3JbMF0sIGVuZENvbG9yWzBdKTtcbiAgcGx1Z2luLmFkZChzdGFydENvbG9yLCAxLCBzdGFydENvbG9yWzFdLCBlbmRDb2xvclsxXSk7XG4gIHBsdWdpbi5hZGQoc3RhcnRDb2xvciwgMiwgc3RhcnRDb2xvclsyXSwgZW5kQ29sb3JbMl0pO1xufSxcbiAgICBfY29sb3JQcm9wcyA9IHtcbiAgdGludDogMSxcbiAgbGluZUNvbG9yOiAxLFxuICBmaWxsQ29sb3I6IDFcbn0sXG4gICAgX3h5Q29udGV4dHMgPSBcInBvc2l0aW9uLHNjYWxlLHNrZXcscGl2b3QsYW5jaG9yLHRpbGVQb3NpdGlvbix0aWxlU2NhbGVcIi5zcGxpdChcIixcIiksXG4gICAgX2NvbnRleHRzID0ge1xuICB4OiBcInBvc2l0aW9uXCIsXG4gIHk6IFwicG9zaXRpb25cIixcbiAgdGlsZVg6IFwidGlsZVBvc2l0aW9uXCIsXG4gIHRpbGVZOiBcInRpbGVQb3NpdGlvblwiXG59LFxuICAgIF9jb2xvck1hdHJpeEZpbHRlclByb3BzID0ge1xuICBjb2xvck1hdHJpeEZpbHRlcjogMSxcbiAgc2F0dXJhdGlvbjogMSxcbiAgY29udHJhc3Q6IDEsXG4gIGh1ZTogMSxcbiAgY29sb3JpemU6IDEsXG4gIGNvbG9yaXplQW1vdW50OiAxLFxuICBicmlnaHRuZXNzOiAxLFxuICBjb21iaW5lQ01GOiAxXG59LFxuICAgIF9ERUcyUkFEID0gTWF0aC5QSSAvIDE4MCxcbiAgICBfaXNTdHJpbmcgPSBmdW5jdGlvbiBfaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbn0sXG4gICAgX2RlZ3JlZXNUb1JhZGlhbnMgPSBmdW5jdGlvbiBfZGVncmVlc1RvUmFkaWFucyh2YWx1ZSkge1xuICByZXR1cm4gX2lzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiID8gdmFsdWUuc3Vic3RyKDAsIDIpICsgcGFyc2VGbG9hdCh2YWx1ZS5zdWJzdHIoMikpICogX0RFRzJSQUQgOiB2YWx1ZSAqIF9ERUcyUkFEO1xufSxcbiAgICBfcmVuZGVyUHJvcFdpdGhFbmQgPSBmdW5jdGlvbiBfcmVuZGVyUHJvcFdpdGhFbmQocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA9PT0gMSA/IGRhdGEuZSA6IE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwMCkgLyAxMDAwMDAsIGRhdGEpO1xufSxcbiAgICBfYWRkUm90YXRpb25hbFByb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnROdW0sIGVuZFZhbHVlLCByYWRpYW5zKSB7XG4gIHZhciBjYXAgPSAzNjAgKiAocmFkaWFucyA/IF9ERUcyUkFEIDogMSksXG4gICAgICBpc1N0cmluZyA9IF9pc1N0cmluZyhlbmRWYWx1ZSksXG4gICAgICByZWxhdGl2ZSA9IGlzU3RyaW5nICYmIGVuZFZhbHVlLmNoYXJBdCgxKSA9PT0gXCI9XCIgPyArKGVuZFZhbHVlLmNoYXJBdCgwKSArIFwiMVwiKSA6IDAsXG4gICAgICBlbmROdW0gPSBwYXJzZUZsb2F0KHJlbGF0aXZlID8gZW5kVmFsdWUuc3Vic3RyKDIpIDogZW5kVmFsdWUpICogKHJhZGlhbnMgPyBfREVHMlJBRCA6IDEpLFxuICAgICAgY2hhbmdlID0gcmVsYXRpdmUgPyBlbmROdW0gKiByZWxhdGl2ZSA6IGVuZE51bSAtIHN0YXJ0TnVtLFxuICAgICAgZmluYWxWYWx1ZSA9IHN0YXJ0TnVtICsgY2hhbmdlLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgcHQ7XG5cbiAgaWYgKGlzU3RyaW5nKSB7XG4gICAgZGlyZWN0aW9uID0gZW5kVmFsdWUuc3BsaXQoXCJfXCIpWzFdO1xuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJzaG9ydFwiKSB7XG4gICAgICBjaGFuZ2UgJT0gY2FwO1xuXG4gICAgICBpZiAoY2hhbmdlICE9PSBjaGFuZ2UgJSAoY2FwIC8gMikpIHtcbiAgICAgICAgY2hhbmdlICs9IGNoYW5nZSA8IDAgPyBjYXAgOiAtY2FwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwiY3dcIiAmJiBjaGFuZ2UgPCAwKSB7XG4gICAgICBjaGFuZ2UgPSAoY2hhbmdlICsgY2FwICogMWUxMCkgJSBjYXAgLSB+fihjaGFuZ2UgLyBjYXApICogY2FwO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBcImNjd1wiICYmIGNoYW5nZSA+IDApIHtcbiAgICAgIGNoYW5nZSA9IChjaGFuZ2UgLSBjYXAgKiAxZTEwKSAlIGNhcCAtIH5+KGNoYW5nZSAvIGNhcCkgKiBjYXA7XG4gICAgfVxuICB9XG5cbiAgcGx1Z2luLl9wdCA9IHB0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCBzdGFydE51bSwgY2hhbmdlLCBfcmVuZGVyUHJvcFdpdGhFbmQpO1xuICBwdC5lID0gZmluYWxWYWx1ZTtcbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoKSB7XG4gIGlmICghX2NvcmVJbml0dGVkKSB7XG4gICAgZ3NhcCA9IF9nZXRHU0FQKCk7XG4gICAgX1BJWEkgPSBfY29yZUluaXR0ZWQgPSBfUElYSSB8fCBfd2luZG93RXhpc3RzKCkgJiYgd2luZG93LlBJWEk7XG4gICAgX2lzVjQgPSBfUElYSSAmJiBfUElYSS5WRVJTSU9OICYmIF9QSVhJLlZFUlNJT04uY2hhckF0KDApID09PSBcIjRcIjtcblxuICAgIF9zcGxpdENvbG9yID0gZnVuY3Rpb24gX3NwbGl0Q29sb3IoY29sb3IpIHtcbiAgICAgIHJldHVybiBnc2FwLnV0aWxzLnNwbGl0Q29sb3IoKGNvbG9yICsgXCJcIikuc3Vic3RyKDAsIDIpID09PSBcIjB4XCIgPyBcIiNcIiArIGNvbG9yLnN1YnN0cigyKSA6IGNvbG9yKTtcbiAgICB9OyAvLyBzb21lIGNvbG9ycyBpbiBQSVhJIGFyZSByZXBvcnRlZCBhcyBcIjB4RkY0NDIxXCIgaW5zdGVhZCBvZiBcIiNGRjQ0MjFcIi5cblxuICB9XG59LFxuICAgIGksXG4gICAgcDsgLy9jb250ZXh0IHNldHVwLi4uXG5cblxuZm9yIChpID0gMDsgaSA8IF94eUNvbnRleHRzLmxlbmd0aDsgaSsrKSB7XG4gIHAgPSBfeHlDb250ZXh0c1tpXTtcbiAgX2NvbnRleHRzW3AgKyBcIlhcIl0gPSBwO1xuICBfY29udGV4dHNbcCArIFwiWVwiXSA9IHA7XG59XG5cbmV4cG9ydCB2YXIgUGl4aVBsdWdpbiA9IHtcbiAgdmVyc2lvbjogXCIzLjEyLjVcIixcbiAgbmFtZTogXCJwaXhpXCIsXG4gIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3Rlcihjb3JlLCBQbHVnaW4sIHByb3BUd2Vlbikge1xuICAgIGdzYXAgPSBjb3JlO1xuICAgIFByb3BUd2VlbiA9IHByb3BUd2VlbjtcbiAgICBfZ2V0U2V0dGVyID0gUGx1Z2luLmdldFNldHRlcjtcblxuICAgIF9pbml0Q29yZSgpO1xuICB9LFxuICBoZWFkbGVzczogdHJ1ZSxcbiAgLy8gZG9lc24ndCBuZWVkIHdpbmRvd1xuICByZWdpc3RlclBJWEk6IGZ1bmN0aW9uIHJlZ2lzdGVyUElYSShwaXhpKSB7XG4gICAgX1BJWEkgPSBwaXhpO1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFsdWVzLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcbiAgICBfUElYSSB8fCBfaW5pdENvcmUoKTtcblxuICAgIGlmICghX1BJWEkpIHtcbiAgICAgIF93YXJuKFwiUElYSSB3YXMgbm90IGZvdW5kLiBQaXhpUGx1Z2luLnJlZ2lzdGVyUElYSShQSVhJKTtcIik7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY29udGV4dCwgYXhpcywgdmFsdWUsIGNvbG9yTWF0cml4LCBmaWx0ZXIsIHAsIHBhZGRpbmcsIGksIGRhdGE7XG5cbiAgICBmb3IgKHAgaW4gdmFsdWVzKSB7XG4gICAgICBjb250ZXh0ID0gX2NvbnRleHRzW3BdO1xuICAgICAgdmFsdWUgPSB2YWx1ZXNbcF07XG5cbiAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGF4aXMgPSB+cC5jaGFyQXQocC5sZW5ndGggLSAxKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJ4XCIpID8gXCJ4XCIgOiBcInlcIjtcbiAgICAgICAgdGhpcy5hZGQodGFyZ2V0W2NvbnRleHRdLCBheGlzLCB0YXJnZXRbY29udGV4dF1bYXhpc10sIGNvbnRleHQgPT09IFwic2tld1wiID8gX2RlZ3JlZXNUb1JhZGlhbnModmFsdWUpIDogdmFsdWUsIDAsIDAsIDAsIDAsIDAsIDEpO1xuICAgICAgfSBlbHNlIGlmIChwID09PSBcInNjYWxlXCIgfHwgcCA9PT0gXCJhbmNob3JcIiB8fCBwID09PSBcInBpdm90XCIgfHwgcCA9PT0gXCJ0aWxlU2NhbGVcIikge1xuICAgICAgICB0aGlzLmFkZCh0YXJnZXRbcF0sIFwieFwiLCB0YXJnZXRbcF0ueCwgdmFsdWUpO1xuICAgICAgICB0aGlzLmFkZCh0YXJnZXRbcF0sIFwieVwiLCB0YXJnZXRbcF0ueSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChwID09PSBcInJvdGF0aW9uXCIgfHwgcCA9PT0gXCJhbmdsZVwiKSB7XG4gICAgICAgIC8vUElYSSBleHBlY3RzIHJvdGF0aW9uIGluIHJhZGlhbnMsIGJ1dCBhcyBhIGNvbnZlbmllbmNlIHdlIGxldCBmb2xrcyBkZWZpbmUgaXQgaW4gZGVncmVlcyBhbmQgd2UgZG8gdGhlIGNvbnZlcnNpb24uXG4gICAgICAgIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuKHRoaXMsIHRhcmdldCwgcCwgdGFyZ2V0W3BdLCB2YWx1ZSwgcCA9PT0gXCJyb3RhdGlvblwiKTtcbiAgICAgIH0gZWxzZSBpZiAoX2NvbG9yTWF0cml4RmlsdGVyUHJvcHNbcF0pIHtcbiAgICAgICAgaWYgKCFjb2xvck1hdHJpeCkge1xuICAgICAgICAgIF9wYXJzZUNvbG9yTWF0cml4RmlsdGVyKHRhcmdldCwgdmFsdWVzLmNvbG9yTWF0cml4RmlsdGVyIHx8IHZhbHVlcywgdGhpcyk7XG5cbiAgICAgICAgICBjb2xvck1hdHJpeCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJibHVyXCIgfHwgcCA9PT0gXCJibHVyWFwiIHx8IHAgPT09IFwiYmx1cllcIiB8fCBwID09PSBcImJsdXJQYWRkaW5nXCIpIHtcbiAgICAgICAgZmlsdGVyID0gX2dldEZpbHRlcih0YXJnZXQsIFwiQmx1ckZpbHRlclwiKTtcbiAgICAgICAgdGhpcy5hZGQoZmlsdGVyLCBwLCBmaWx0ZXJbcF0sIHZhbHVlKTtcblxuICAgICAgICBpZiAodmFsdWVzLmJsdXJQYWRkaW5nICE9PSAwKSB7XG4gICAgICAgICAgcGFkZGluZyA9IHZhbHVlcy5ibHVyUGFkZGluZyB8fCBNYXRoLm1heChmaWx0ZXJbcF0sIHZhbHVlKSAqIDI7XG4gICAgICAgICAgaSA9IHRhcmdldC5maWx0ZXJzLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICAgICAgdGFyZ2V0LmZpbHRlcnNbaV0ucGFkZGluZyA9IE1hdGgubWF4KHRhcmdldC5maWx0ZXJzW2ldLnBhZGRpbmcsIHBhZGRpbmcpOyAvL2lmIHdlIGRvbid0IGV4cGFuZCB0aGUgcGFkZGluZyBvbiBhbGwgdGhlIGZpbHRlcnMsIGl0IGNhbiBsb29rIGNsaXBwZWQuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF9jb2xvclByb3BzW3BdKSB7XG4gICAgICAgIGlmICgocCA9PT0gXCJsaW5lQ29sb3JcIiB8fCBwID09PSBcImZpbGxDb2xvclwiKSAmJiB0YXJnZXQgaW5zdGFuY2VvZiBfUElYSS5HcmFwaGljcykge1xuICAgICAgICAgIGRhdGEgPSAodGFyZ2V0Lmdlb21ldHJ5IHx8IHRhcmdldCkuZ3JhcGhpY3NEYXRhOyAvL1wiZ2VvbWV0cnlcIiB3YXMgaW50cm9kdWNlZCBpbiBQSVhJIHZlcnNpb24gNVxuXG4gICAgICAgICAgdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCB0YXJnZXQsIHAsIDAsIDAsIF9yZW5kZXJEaXJ0eUNhY2hlLCB7XG4gICAgICAgICAgICBnOiB0YXJnZXQuZ2VvbWV0cnkgfHwgdGFyZ2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaSA9IGRhdGEubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICAgICAgICBfYWRkQ29sb3JUd2VlbihfaXNWNCA/IGRhdGFbaV0gOiBkYXRhW2ldW3Auc3Vic3RyKDAsIDQpICsgXCJTdHlsZVwiXSwgX2lzVjQgPyBwIDogXCJjb2xvclwiLCB2YWx1ZSwgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9hZGRDb2xvclR3ZWVuKHRhcmdldCwgcCwgdmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHAgPT09IFwiYXV0b0FscGhhXCIpIHtcbiAgICAgICAgdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCB0YXJnZXQsIFwidmlzaWJsZVwiLCAwLCAwLCBfcmVuZGVyQXV0b0FscGhhKTtcbiAgICAgICAgdGhpcy5hZGQodGFyZ2V0LCBcImFscGhhXCIsIHRhcmdldC5hbHBoYSwgdmFsdWUpO1xuXG4gICAgICAgIHRoaXMuX3Byb3BzLnB1c2goXCJhbHBoYVwiLCBcInZpc2libGVcIik7XG4gICAgICB9IGVsc2UgaWYgKHAgIT09IFwicmVzb2x1dGlvblwiKSB7XG4gICAgICAgIHRoaXMuYWRkKHRhcmdldCwgcCwgXCJnZXRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wcm9wcy5wdXNoKHApO1xuICAgIH1cbiAgfVxufTtcbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihQaXhpUGx1Z2luKTtcbmV4cG9ydCB7IFBpeGlQbHVnaW4gYXMgZGVmYXVsdCB9OyJdLCJuYW1lcyI6WyJnc2FwIiwiX3NwbGl0Q29sb3IiLCJfY29yZUluaXR0ZWQiLCJfUElYSSIsIlByb3BUd2VlbiIsIl9nZXRTZXR0ZXIiLCJfaXNWNCIsIl93aW5kb3dFeGlzdHMiLCJ3aW5kb3ciLCJfZ2V0R1NBUCIsInJlZ2lzdGVyUGx1Z2luIiwiX2lzRnVuY3Rpb24iLCJ2YWx1ZSIsIl93YXJuIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwiX2lkTWF0cml4IiwiX2x1bVIiLCJfbHVtRyIsIl9sdW1CIiwiX2ZpbHRlckNsYXNzIiwibmFtZSIsImZpbHRlcnMiLCJfYXBwbHlNYXRyaXgiLCJtIiwibTIiLCJ0ZW1wIiwiaSIsInoiLCJ5IiwieCIsIl9zZXRTYXR1cmF0aW9uIiwibiIsImludiIsInIiLCJnIiwiYiIsIl9jb2xvcml6ZSIsImNvbG9yIiwiYW1vdW50IiwiYyIsIl9zZXRIdWUiLCJNYXRoIiwiUEkiLCJjb3MiLCJzIiwic2luIiwiX3NldENvbnRyYXN0IiwiX2dldEZpbHRlciIsInRhcmdldCIsInR5cGUiLCJmaWx0ZXJDbGFzcyIsImxlbmd0aCIsImZpbHRlciIsImJsdXIiLCJwdXNoIiwiX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbiIsInAiLCJwbHVnaW4iLCJjYWNoZSIsInZhcnMiLCJhZGQiLCJfcHJvcHMiLCJfYXBwbHlCcmlnaHRuZXNzVG9NYXRyaXgiLCJicmlnaHRuZXNzIiwibWF0cml4IiwiX2NvcHkiLCJvYmoiLCJjb3B5IiwiX0NNRmRlZmF1bHRzIiwiY29udHJhc3QiLCJzYXR1cmF0aW9uIiwiY29sb3JpemVBbW91bnQiLCJjb2xvcml6ZSIsImh1ZSIsIl9wYXJzZUNvbG9yTWF0cml4RmlsdGVyIiwidiIsInBnIiwiX2dzQ29sb3JNYXRyaXhGaWx0ZXIiLCJjb21iaW5lIiwiY29tYmluZUNNRiIsImNvbG9yTWF0cml4RmlsdGVyIiwic3RhcnRNYXRyaXgiLCJyZXNvbHV0aW9uIiwic2xpY2UiLCJfcmVuZGVyQ29sb3IiLCJyYXRpbyIsIl9yZWYiLCJ0Iiwic2V0IiwiX3JlbmRlckRpcnR5Q2FjaGUiLCJfcmVmMiIsImRpcnR5IiwiY2xlYXJEaXJ0eSIsIl9yZW5kZXJBdXRvQWxwaGEiLCJkYXRhIiwidmlzaWJsZSIsImFscGhhIiwiX2FkZENvbG9yVHdlZW4iLCJjdXJyZW50VmFsdWUiLCJzdGFydENvbG9yIiwiaW5kZXhPZiIsInN1YnN0ciIsImVuZENvbG9yIiwiX3B0IiwiX2NvbG9yUHJvcHMiLCJ0aW50IiwibGluZUNvbG9yIiwiZmlsbENvbG9yIiwiX3h5Q29udGV4dHMiLCJzcGxpdCIsIl9jb250ZXh0cyIsInRpbGVYIiwidGlsZVkiLCJfY29sb3JNYXRyaXhGaWx0ZXJQcm9wcyIsIl9ERUcyUkFEIiwiX2lzU3RyaW5nIiwiX2RlZ3JlZXNUb1JhZGlhbnMiLCJjaGFyQXQiLCJwYXJzZUZsb2F0IiwiX3JlbmRlclByb3BXaXRoRW5kIiwiZSIsInJvdW5kIiwiX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4iLCJwcm9wZXJ0eSIsInN0YXJ0TnVtIiwiZW5kVmFsdWUiLCJyYWRpYW5zIiwiY2FwIiwiaXNTdHJpbmciLCJyZWxhdGl2ZSIsImVuZE51bSIsImNoYW5nZSIsImZpbmFsVmFsdWUiLCJkaXJlY3Rpb24iLCJwdCIsIl9pbml0Q29yZSIsIlBJWEkiLCJWRVJTSU9OIiwidXRpbHMiLCJzcGxpdENvbG9yIiwiUGl4aVBsdWdpbiIsInZlcnNpb24iLCJyZWdpc3RlciIsImNvcmUiLCJQbHVnaW4iLCJwcm9wVHdlZW4iLCJnZXRTZXR0ZXIiLCJoZWFkbGVzcyIsInJlZ2lzdGVyUElYSSIsInBpeGkiLCJpbml0IiwidmFsdWVzIiwidHdlZW4iLCJpbmRleCIsInRhcmdldHMiLCJjb250ZXh0IiwiYXhpcyIsImNvbG9yTWF0cml4IiwicGFkZGluZyIsInRvTG93ZXJDYXNlIiwiYmx1clBhZGRpbmciLCJtYXgiLCJHcmFwaGljcyIsImdlb21ldHJ5IiwiZ3JhcGhpY3NEYXRhIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/PixiPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollToPlugin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollToPlugin.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrollToPlugin: function() { return /* binding */ ScrollToPlugin; },\n/* harmony export */   \"default\": function() { return /* binding */ ScrollToPlugin; }\n/* harmony export */ });\n/*!\n * ScrollToPlugin 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var gsap, _coreInitted, _window, _docEl, _body, _toArray, _config, ScrollTrigger, _windowExists = function _windowExists() {\n    return typeof window !== \"undefined\";\n}, _getGSAP = function _getGSAP() {\n    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _isString = function _isString(value) {\n    return typeof value === \"string\";\n}, _isFunction = function _isFunction(value) {\n    return typeof value === \"function\";\n}, _max = function _max(element, axis) {\n    var dim = axis === \"x\" ? \"Width\" : \"Height\", scroll = \"scroll\" + dim, client = \"client\" + dim;\n    return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window[\"inner\" + dim] || _docEl[client] || _body[client]) : element[scroll] - element[\"offset\" + dim];\n}, _buildGetter = function _buildGetter(e, axis) {\n    //pass in an element and an axis (\"x\" or \"y\") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.\n    var p = \"scroll\" + (axis === \"x\" ? \"Left\" : \"Top\");\n    if (e === _window) {\n        if (e.pageXOffset != null) {\n            p = \"page\" + axis.toUpperCase() + \"Offset\";\n        } else {\n            e = _docEl[p] != null ? _docEl : _body;\n        }\n    }\n    return function() {\n        return e[p];\n    };\n}, _clean = function _clean(value, index, target, targets) {\n    _isFunction(value) && (value = value(index, target, targets));\n    if (typeof value !== \"object\") {\n        return _isString(value) && value !== \"max\" && value.charAt(1) !== \"=\" ? {\n            x: value,\n            y: value\n        } : {\n            y: value\n        }; //if we don't receive an object as the parameter, assume the user intends \"y\".\n    } else if (value.nodeType) {\n        return {\n            y: value,\n            x: value\n        };\n    } else {\n        var result = {}, p;\n        for(p in value){\n            result[p] = p !== \"onAutoKill\" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];\n        }\n        return result;\n    }\n}, _getOffset = function _getOffset(element, container) {\n    element = _toArray(element)[0];\n    if (!element || !element.getBoundingClientRect) {\n        return console.warn(\"scrollTo target doesn't exist. Using 0\") || {\n            x: 0,\n            y: 0\n        };\n    }\n    var rect = element.getBoundingClientRect(), isRoot = !container || container === _window || container === _body, cRect = isRoot ? {\n        top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),\n        left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)\n    } : container.getBoundingClientRect(), offsets = {\n        x: rect.left - cRect.left,\n        y: rect.top - cRect.top\n    };\n    if (!isRoot && container) {\n        //only add the current scroll position if it's not the window/body.\n        offsets.x += _buildGetter(container, \"x\")();\n        offsets.y += _buildGetter(container, \"y\")();\n    }\n    return offsets;\n}, _parseVal = function _parseVal(value, target, axis, currentVal, offset) {\n    return !isNaN(value) && typeof value !== \"object\" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === \"=\" ? parseFloat(value.substr(2)) * (value.charAt(0) === \"-\" ? -1 : 1) + currentVal - offset : value === \"max\" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);\n}, _initCore = function _initCore() {\n    gsap = _getGSAP();\n    if (_windowExists() && gsap && typeof document !== \"undefined\" && document.body) {\n        _window = window;\n        _body = document.body;\n        _docEl = document.documentElement;\n        _toArray = gsap.utils.toArray;\n        gsap.config({\n            autoKillThreshold: 7\n        });\n        _config = gsap.config();\n        _coreInitted = 1;\n    }\n};\nvar ScrollToPlugin = {\n    version: \"3.12.5\",\n    name: \"scrollTo\",\n    rawVars: 1,\n    register: function register(core) {\n        gsap = core;\n        _initCore();\n    },\n    init: function init(target, value, tween, index, targets) {\n        _coreInitted || _initCore();\n        var data = this, snapType = gsap.getProperty(target, \"scrollSnapType\");\n        data.isWin = target === _window;\n        data.target = target;\n        data.tween = tween;\n        value = _clean(value, index, target, targets);\n        data.vars = value;\n        data.autoKill = !!value.autoKill;\n        data.getX = _buildGetter(target, \"x\");\n        data.getY = _buildGetter(target, \"y\");\n        data.x = data.xPrev = data.getX();\n        data.y = data.yPrev = data.getY();\n        ScrollTrigger || (ScrollTrigger = gsap.core.globals().ScrollTrigger);\n        gsap.getProperty(target, \"scrollBehavior\") === \"smooth\" && gsap.set(target, {\n            scrollBehavior: \"auto\"\n        });\n        if (snapType && snapType !== \"none\") {\n            // disable scroll snapping to avoid strange behavior\n            data.snap = 1;\n            data.snapInline = target.style.scrollSnapType;\n            target.style.scrollSnapType = \"none\";\n        }\n        if (value.x != null) {\n            data.add(data, \"x\", data.x, _parseVal(value.x, target, \"x\", data.x, value.offsetX || 0), index, targets);\n            data._props.push(\"scrollTo_x\");\n        } else {\n            data.skipX = 1;\n        }\n        if (value.y != null) {\n            data.add(data, \"y\", data.y, _parseVal(value.y, target, \"y\", data.y, value.offsetY || 0), index, targets);\n            data._props.push(\"scrollTo_y\");\n        } else {\n            data.skipY = 1;\n        }\n    },\n    render: function render(ratio, data) {\n        var pt = data._pt, target = data.target, tween = data.tween, autoKill = data.autoKill, xPrev = data.xPrev, yPrev = data.yPrev, isWin = data.isWin, snap = data.snap, snapInline = data.snapInline, x, y, yDif, xDif, threshold;\n        while(pt){\n            pt.r(ratio, pt.d);\n            pt = pt._next;\n        }\n        x = isWin || !data.skipX ? data.getX() : xPrev;\n        y = isWin || !data.skipY ? data.getY() : yPrev;\n        yDif = y - yPrev;\n        xDif = x - xPrev;\n        threshold = _config.autoKillThreshold;\n        if (data.x < 0) {\n            //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)\n            data.x = 0;\n        }\n        if (data.y < 0) {\n            data.y = 0;\n        }\n        if (autoKill) {\n            //note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.\n            if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, \"x\")) {\n                data.skipX = 1; //if the user scrolls separately, we should stop tweening!\n            }\n            if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, \"y\")) {\n                data.skipY = 1; //if the user scrolls separately, we should stop tweening!\n            }\n            if (data.skipX && data.skipY) {\n                tween.kill();\n                data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);\n            }\n        }\n        if (isWin) {\n            _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);\n        } else {\n            data.skipY || (target.scrollTop = data.y);\n            data.skipX || (target.scrollLeft = data.x);\n        }\n        if (snap && (ratio === 1 || ratio === 0)) {\n            y = target.scrollTop;\n            x = target.scrollLeft;\n            snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty(\"scroll-snap-type\");\n            target.scrollTop = y + 1; // bug in Safari causes the element to totally reset its scroll position when scroll-snap-type changes, so we need to set it to a slightly different value and then back again to work around this bug.\n            target.scrollLeft = x + 1;\n            target.scrollTop = y;\n            target.scrollLeft = x;\n        }\n        data.xPrev = data.x;\n        data.yPrev = data.y;\n        ScrollTrigger && ScrollTrigger.update();\n    },\n    kill: function kill(property) {\n        var both = property === \"scrollTo\", i = this._props.indexOf(property);\n        if (both || property === \"scrollTo_x\") {\n            this.skipX = 1;\n        }\n        if (both || property === \"scrollTo_y\") {\n            this.skipY = 1;\n        }\n        i > -1 && this._props.splice(i, 1);\n        return !this._props.length;\n    }\n};\nScrollToPlugin.max = _max;\nScrollToPlugin.getOffset = _getOffset;\nScrollToPlugin.buildGetter = _buildGetter;\n_getGSAP() && gsap.registerPlugin(ScrollToPlugin);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9TY3JvbGxUb1BsdWdpbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCLEdBQ2xCLElBQUlBLE1BQ0FDLGNBQ0FDLFNBQ0FDLFFBQ0FDLE9BQ0FDLFVBQ0FDLFNBQ0FDLGVBQ0FDLGdCQUFnQixTQUFTQTtJQUMzQixPQUFPLE9BQU9DLFdBQVc7QUFDM0IsR0FDSUMsV0FBVyxTQUFTQTtJQUN0QixPQUFPVixRQUFRUSxtQkFBb0JSLENBQUFBLE9BQU9TLE9BQU9ULElBQUksS0FBS0EsS0FBS1csY0FBYyxJQUFJWDtBQUNuRixHQUNJWSxZQUFZLFNBQVNBLFVBQVVDLEtBQUs7SUFDdEMsT0FBTyxPQUFPQSxVQUFVO0FBQzFCLEdBQ0lDLGNBQWMsU0FBU0EsWUFBWUQsS0FBSztJQUMxQyxPQUFPLE9BQU9BLFVBQVU7QUFDMUIsR0FDSUUsT0FBTyxTQUFTQSxLQUFLQyxPQUFPLEVBQUVDLElBQUk7SUFDcEMsSUFBSUMsTUFBTUQsU0FBUyxNQUFNLFVBQVUsVUFDL0JFLFNBQVMsV0FBV0QsS0FDcEJFLFNBQVMsV0FBV0Y7SUFDeEIsT0FBT0YsWUFBWWQsV0FBV2MsWUFBWWIsVUFBVWEsWUFBWVosUUFBUWlCLEtBQUtDLEdBQUcsQ0FBQ25CLE1BQU0sQ0FBQ2dCLE9BQU8sRUFBRWYsS0FBSyxDQUFDZSxPQUFPLElBQUtqQixDQUFBQSxPQUFPLENBQUMsVUFBVWdCLElBQUksSUFBSWYsTUFBTSxDQUFDaUIsT0FBTyxJQUFJaEIsS0FBSyxDQUFDZ0IsT0FBTyxJQUFJSixPQUFPLENBQUNHLE9BQU8sR0FBR0gsT0FBTyxDQUFDLFdBQVdFLElBQUk7QUFDM04sR0FDSUssZUFBZSxTQUFTQSxhQUFhQyxDQUFDLEVBQUVQLElBQUk7SUFDOUMsc1hBQXNYO0lBQ3RYLElBQUlRLElBQUksV0FBWVIsQ0FBQUEsU0FB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QUFPcUIsVUFBVSxHQUFHbEIsSUFBSTtZQUN4QkgsT0FBT2tCLFNBQVMsR0FBR2Q7WUFDbkJKLE9BQU9xQixVQUFVLEdBQUdsQjtRQUN0QjtRQUVBMkMsS0FBS1EsS0FBSyxHQUFHUixLQUFLM0MsQ0FBQztRQUNuQjJDLEtBQUtTLEtBQUssR0FBR1QsS0FBSzFDLENBQUM7UUFDbkIzQixpQkFBaUJBLGNBQWM2RyxNQUFNO0lBQ3ZDO0lBQ0FOLE1BQU0sU0FBU0EsS0FBS08sUUFBUTtRQUMxQixJQUFJQyxPQUFPRCxhQUFhLFlBQ3BCRSxJQUFJLElBQUksQ0FBQ3hCLE1BQU0sQ0FBQ3lCLE9BQU8sQ0FBQ0g7UUFFNUIsSUFBSUMsUUFBUUQsYUFBYSxjQUFjO1lBQ3JDLElBQUksQ0FBQ3BCLEtBQUssR0FBRztRQUNmO1FBRUEsSUFBSXFCLFFBQVFELGFBQWEsY0FBYztZQUNyQyxJQUFJLENBQUNsQixLQUFLLEdBQUc7UUFDZjtRQUVBb0IsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDeEIsTUFBTSxDQUFDMEIsTUFBTSxDQUFDRixHQUFHO1FBQ2hDLE9BQU8sQ0FBQyxJQUFJLENBQUN4QixNQUFNLENBQUMyQixNQUFNO0lBQzVCO0FBQ0YsRUFBRTtBQUNGdEQsZUFBZTlDLEdBQUcsR0FBR1A7QUFDckJxRCxlQUFldUQsU0FBUyxHQUFHdEY7QUFDM0IrQixlQUFld0QsV0FBVyxHQUFHckc7QUFDN0JiLGNBQWNWLEtBQUtXLGNBQWMsQ0FBQ3lEO0FBQ0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dzYXBAMy4xMi41L25vZGVfbW9kdWxlcy9nc2FwL1Njcm9sbFRvUGx1Z2luLmpzPzhkMjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBTY3JvbGxUb1BsdWdpbiAzLjEyLjVcbiAqIGh0dHBzOi8vZ3NhcC5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDI0LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dzYXAuY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdTQVAgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgZ3NhcCxcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX3dpbmRvdyxcbiAgICBfZG9jRWwsXG4gICAgX2JvZHksXG4gICAgX3RvQXJyYXksXG4gICAgX2NvbmZpZyxcbiAgICBTY3JvbGxUcmlnZ2VyLFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgX3dpbmRvd0V4aXN0cygpICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX2lzU3RyaW5nID0gZnVuY3Rpb24gX2lzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59LFxuICAgIF9pc0Z1bmN0aW9uID0gZnVuY3Rpb24gX2lzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufSxcbiAgICBfbWF4ID0gZnVuY3Rpb24gX21heChlbGVtZW50LCBheGlzKSB7XG4gIHZhciBkaW0gPSBheGlzID09PSBcInhcIiA/IFwiV2lkdGhcIiA6IFwiSGVpZ2h0XCIsXG4gICAgICBzY3JvbGwgPSBcInNjcm9sbFwiICsgZGltLFxuICAgICAgY2xpZW50ID0gXCJjbGllbnRcIiArIGRpbTtcbiAgcmV0dXJuIGVsZW1lbnQgPT09IF93aW5kb3cgfHwgZWxlbWVudCA9PT0gX2RvY0VsIHx8IGVsZW1lbnQgPT09IF9ib2R5ID8gTWF0aC5tYXgoX2RvY0VsW3Njcm9sbF0sIF9ib2R5W3Njcm9sbF0pIC0gKF93aW5kb3dbXCJpbm5lclwiICsgZGltXSB8fCBfZG9jRWxbY2xpZW50XSB8fCBfYm9keVtjbGllbnRdKSA6IGVsZW1lbnRbc2Nyb2xsXSAtIGVsZW1lbnRbXCJvZmZzZXRcIiArIGRpbV07XG59LFxuICAgIF9idWlsZEdldHRlciA9IGZ1bmN0aW9uIF9idWlsZEdldHRlcihlLCBheGlzKSB7XG4gIC8vcGFzcyBpbiBhbiBlbGVtZW50IGFuZCBhbiBheGlzIChcInhcIiBvciBcInlcIikgYW5kIGl0J2xsIHJldHVybiBhIGdldHRlciBmdW5jdGlvbiBmb3IgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGF0IGVsZW1lbnQgKGxpa2Ugc2Nyb2xsVG9wIG9yIHNjcm9sbExlZnQsIGFsdGhvdWdoIGlmIHRoZSBlbGVtZW50IGlzIHRoZSB3aW5kb3csIGl0J2xsIHVzZSB0aGUgcGFnZVhPZmZzZXQvcGFnZVlPZmZzZXQgb3IgdGhlIGRvY3VtZW50RWxlbWVudCdzIHNjcm9sbFRvcC9zY3JvbGxMZWZ0IG9yIGRvY3VtZW50LmJvZHkncy4gQmFzaWNhbGx5IHRoaXMgc3RyZWFtbGluZXMgdGhpbmdzIGFuZCBtYWtlcyBhIHZlcnkgZmFzdCBnZXR0ZXIgYWNyb3NzIGJyb3dzZXJzLlxuICB2YXIgcCA9IFwic2Nyb2xsXCIgKyAoYXhpcyA9PT0gXCJ4XCIgPyBcIkxlZnRcIiA6IFwiVG9wXCIpO1xuXG4gIGlmIChlID09PSBfd2luZG93KSB7XG4gICAgaWYgKGUucGFnZVhPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgcCA9IFwicGFnZVwiICsgYXhpcy50b1VwcGVyQ2FzZSgpICsgXCJPZmZzZXRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZSA9IF9kb2NFbFtwXSAhPSBudWxsID8gX2RvY0VsIDogX2JvZHk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZVtwXTtcbiAgfTtcbn0sXG4gICAgX2NsZWFuID0gZnVuY3Rpb24gX2NsZWFuKHZhbHVlLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSB7XG4gIF9pc0Z1bmN0aW9uKHZhbHVlKSAmJiAodmFsdWUgPSB2YWx1ZShpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSk7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBfaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlICE9PSBcIm1heFwiICYmIHZhbHVlLmNoYXJBdCgxKSAhPT0gXCI9XCIgPyB7XG4gICAgICB4OiB2YWx1ZSxcbiAgICAgIHk6IHZhbHVlXG4gICAgfSA6IHtcbiAgICAgIHk6IHZhbHVlXG4gICAgfTsgLy9pZiB3ZSBkb24ndCByZWNlaXZlIGFuIG9iamVjdCBhcyB0aGUgcGFyYW1ldGVyLCBhc3N1bWUgdGhlIHVzZXIgaW50ZW5kcyBcInlcIi5cbiAgfSBlbHNlIGlmICh2YWx1ZS5ub2RlVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICB5OiB2YWx1ZSxcbiAgICAgIHg6IHZhbHVlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sXG4gICAgICAgIHA7XG5cbiAgICBmb3IgKHAgaW4gdmFsdWUpIHtcbiAgICAgIHJlc3VsdFtwXSA9IHAgIT09IFwib25BdXRvS2lsbFwiICYmIF9pc0Z1bmN0aW9uKHZhbHVlW3BdKSA/IHZhbHVlW3BdKGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIDogdmFsdWVbcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSxcbiAgICBfZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gX2dldE9mZnNldChlbGVtZW50LCBjb250YWluZXIpIHtcbiAgZWxlbWVudCA9IF90b0FycmF5KGVsZW1lbnQpWzBdO1xuXG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICByZXR1cm4gY29uc29sZS53YXJuKFwic2Nyb2xsVG8gdGFyZ2V0IGRvZXNuJ3QgZXhpc3QuIFVzaW5nIDBcIikgfHwge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgaXNSb290ID0gIWNvbnRhaW5lciB8fCBjb250YWluZXIgPT09IF93aW5kb3cgfHwgY29udGFpbmVyID09PSBfYm9keSxcbiAgICAgIGNSZWN0ID0gaXNSb290ID8ge1xuICAgIHRvcDogX2RvY0VsLmNsaWVudFRvcCAtIChfd2luZG93LnBhZ2VZT2Zmc2V0IHx8IF9kb2NFbC5zY3JvbGxUb3AgfHwgX2JvZHkuc2Nyb2xsVG9wIHx8IDApLFxuICAgIGxlZnQ6IF9kb2NFbC5jbGllbnRMZWZ0IC0gKF93aW5kb3cucGFnZVhPZmZzZXQgfHwgX2RvY0VsLnNjcm9sbExlZnQgfHwgX2JvZHkuc2Nyb2xsTGVmdCB8fCAwKVxuICB9IDogY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICB4OiByZWN0LmxlZnQgLSBjUmVjdC5sZWZ0LFxuICAgIHk6IHJlY3QudG9wIC0gY1JlY3QudG9wXG4gIH07XG5cbiAgaWYgKCFpc1Jvb3QgJiYgY29udGFpbmVyKSB7XG4gICAgLy9vbmx5IGFkZCB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gaWYgaXQncyBub3QgdGhlIHdpbmRvdy9ib2R5LlxuICAgIG9mZnNldHMueCArPSBfYnVpbGRHZXR0ZXIoY29udGFpbmVyLCBcInhcIikoKTtcbiAgICBvZmZzZXRzLnkgKz0gX2J1aWxkR2V0dGVyKGNvbnRhaW5lciwgXCJ5XCIpKCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn0sXG4gICAgX3BhcnNlVmFsID0gZnVuY3Rpb24gX3BhcnNlVmFsKHZhbHVlLCB0YXJnZXQsIGF4aXMsIGN1cnJlbnRWYWwsIG9mZnNldCkge1xuICByZXR1cm4gIWlzTmFOKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgPyBwYXJzZUZsb2F0KHZhbHVlKSAtIG9mZnNldCA6IF9pc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuY2hhckF0KDEpID09PSBcIj1cIiA/IHBhcnNlRmxvYXQodmFsdWUuc3Vic3RyKDIpKSAqICh2YWx1ZS5jaGFyQXQoMCkgPT09IFwiLVwiID8gLTEgOiAxKSArIGN1cnJlbnRWYWwgLSBvZmZzZXQgOiB2YWx1ZSA9PT0gXCJtYXhcIiA/IF9tYXgodGFyZ2V0LCBheGlzKSAtIG9mZnNldCA6IE1hdGgubWluKF9tYXgodGFyZ2V0LCBheGlzKSwgX2dldE9mZnNldCh2YWx1ZSwgdGFyZ2V0KVtheGlzXSAtIG9mZnNldCk7XG59LFxuICAgIF9pbml0Q29yZSA9IGZ1bmN0aW9uIF9pbml0Q29yZSgpIHtcbiAgZ3NhcCA9IF9nZXRHU0FQKCk7XG5cbiAgaWYgKF93aW5kb3dFeGlzdHMoKSAmJiBnc2FwICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgX3dpbmRvdyA9IHdpbmRvdztcbiAgICBfYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgX2RvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgIGdzYXAuY29uZmlnKHtcbiAgICAgIGF1dG9LaWxsVGhyZXNob2xkOiA3XG4gICAgfSk7XG4gICAgX2NvbmZpZyA9IGdzYXAuY29uZmlnKCk7XG4gICAgX2NvcmVJbml0dGVkID0gMTtcbiAgfVxufTtcblxuZXhwb3J0IHZhciBTY3JvbGxUb1BsdWdpbiA9IHtcbiAgdmVyc2lvbjogXCIzLjEyLjVcIixcbiAgbmFtZTogXCJzY3JvbGxUb1wiLFxuICByYXdWYXJzOiAxLFxuICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoY29yZSkge1xuICAgIGdzYXAgPSBjb3JlO1xuXG4gICAgX2luaXRDb3JlKCk7XG4gIH0sXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YWx1ZSwgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgX2NvcmVJbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuICAgIHZhciBkYXRhID0gdGhpcyxcbiAgICAgICAgc25hcFR5cGUgPSBnc2FwLmdldFByb3BlcnR5KHRhcmdldCwgXCJzY3JvbGxTbmFwVHlwZVwiKTtcbiAgICBkYXRhLmlzV2luID0gdGFyZ2V0ID09PSBfd2luZG93O1xuICAgIGRhdGEudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGRhdGEudHdlZW4gPSB0d2VlbjtcbiAgICB2YWx1ZSA9IF9jbGVhbih2YWx1ZSwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cyk7XG4gICAgZGF0YS52YXJzID0gdmFsdWU7XG4gICAgZGF0YS5hdXRvS2lsbCA9ICEhdmFsdWUuYXV0b0tpbGw7XG4gICAgZGF0YS5nZXRYID0gX2J1aWxkR2V0dGVyKHRhcmdldCwgXCJ4XCIpO1xuICAgIGRhdGEuZ2V0WSA9IF9idWlsZEdldHRlcih0YXJnZXQsIFwieVwiKTtcbiAgICBkYXRhLnggPSBkYXRhLnhQcmV2ID0gZGF0YS5nZXRYKCk7XG4gICAgZGF0YS55ID0gZGF0YS55UHJldiA9IGRhdGEuZ2V0WSgpO1xuICAgIFNjcm9sbFRyaWdnZXIgfHwgKFNjcm9sbFRyaWdnZXIgPSBnc2FwLmNvcmUuZ2xvYmFscygpLlNjcm9sbFRyaWdnZXIpO1xuICAgIGdzYXAuZ2V0UHJvcGVydHkodGFyZ2V0LCBcInNjcm9sbEJlaGF2aW9yXCIpID09PSBcInNtb290aFwiICYmIGdzYXAuc2V0KHRhcmdldCwge1xuICAgICAgc2Nyb2xsQmVoYXZpb3I6IFwiYXV0b1wiXG4gICAgfSk7XG5cbiAgICBpZiAoc25hcFR5cGUgJiYgc25hcFR5cGUgIT09IFwibm9uZVwiKSB7XG4gICAgICAvLyBkaXNhYmxlIHNjcm9sbCBzbmFwcGluZyB0byBhdm9pZCBzdHJhbmdlIGJlaGF2aW9yXG4gICAgICBkYXRhLnNuYXAgPSAxO1xuICAgICAgZGF0YS5zbmFwSW5saW5lID0gdGFyZ2V0LnN0eWxlLnNjcm9sbFNuYXBUeXBlO1xuICAgICAgdGFyZ2V0LnN0eWxlLnNjcm9sbFNuYXBUeXBlID0gXCJub25lXCI7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLnggIT0gbnVsbCkge1xuICAgICAgZGF0YS5hZGQoZGF0YSwgXCJ4XCIsIGRhdGEueCwgX3BhcnNlVmFsKHZhbHVlLngsIHRhcmdldCwgXCJ4XCIsIGRhdGEueCwgdmFsdWUub2Zmc2V0WCB8fCAwKSwgaW5kZXgsIHRhcmdldHMpO1xuXG4gICAgICBkYXRhLl9wcm9wcy5wdXNoKFwic2Nyb2xsVG9feFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5za2lwWCA9IDE7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLnkgIT0gbnVsbCkge1xuICAgICAgZGF0YS5hZGQoZGF0YSwgXCJ5XCIsIGRhdGEueSwgX3BhcnNlVmFsKHZhbHVlLnksIHRhcmdldCwgXCJ5XCIsIGRhdGEueSwgdmFsdWUub2Zmc2V0WSB8fCAwKSwgaW5kZXgsIHRhcmdldHMpO1xuXG4gICAgICBkYXRhLl9wcm9wcy5wdXNoKFwic2Nyb2xsVG9feVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5za2lwWSA9IDE7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyYXRpbywgZGF0YSkge1xuICAgIHZhciBwdCA9IGRhdGEuX3B0LFxuICAgICAgICB0YXJnZXQgPSBkYXRhLnRhcmdldCxcbiAgICAgICAgdHdlZW4gPSBkYXRhLnR3ZWVuLFxuICAgICAgICBhdXRvS2lsbCA9IGRhdGEuYXV0b0tpbGwsXG4gICAgICAgIHhQcmV2ID0gZGF0YS54UHJldixcbiAgICAgICAgeVByZXYgPSBkYXRhLnlQcmV2LFxuICAgICAgICBpc1dpbiA9IGRhdGEuaXNXaW4sXG4gICAgICAgIHNuYXAgPSBkYXRhLnNuYXAsXG4gICAgICAgIHNuYXBJbmxpbmUgPSBkYXRhLnNuYXBJbmxpbmUsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHlEaWYsXG4gICAgICAgIHhEaWYsXG4gICAgICAgIHRocmVzaG9sZDtcblxuICAgIHdoaWxlIChwdCkge1xuICAgICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cblxuICAgIHggPSBpc1dpbiB8fCAhZGF0YS5za2lwWCA/IGRhdGEuZ2V0WCgpIDogeFByZXY7XG4gICAgeSA9IGlzV2luIHx8ICFkYXRhLnNraXBZID8gZGF0YS5nZXRZKCkgOiB5UHJldjtcbiAgICB5RGlmID0geSAtIHlQcmV2O1xuICAgIHhEaWYgPSB4IC0geFByZXY7XG4gICAgdGhyZXNob2xkID0gX2NvbmZpZy5hdXRvS2lsbFRocmVzaG9sZDtcblxuICAgIGlmIChkYXRhLnggPCAwKSB7XG4gICAgICAvL2Nhbid0IHNjcm9sbCB0byBhIHBvc2l0aW9uIGxlc3MgdGhhbiAwISBNaWdodCBoYXBwZW4gaWYgc29tZW9uZSB1c2VzIGEgQmFjay5lYXNlT3V0IG9yIEVsYXN0aWMuZWFzZU91dCB3aGVuIHNjcm9sbGluZyBiYWNrIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UgKGZvciBleGFtcGxlKVxuICAgICAgZGF0YS54ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS55IDwgMCkge1xuICAgICAgZGF0YS55ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoYXV0b0tpbGwpIHtcbiAgICAgIC8vbm90ZTogaU9TIGhhcyBhIGJ1ZyB0aGF0IHRocm93cyBvZmYgdGhlIHNjcm9sbCBieSBzZXZlcmFsIHBpeGVscywgc28gd2UgbmVlZCB0byBjaGVjayBpZiBpdCdzIHdpdGhpbiA3IHBpeGVscyBvZiB0aGUgcHJldmlvdXMgb25lIHRoYXQgd2Ugc2V0IGluc3RlYWQgb2YganVzdCBsb29raW5nIGZvciBhbiBleGFjdCBtYXRjaC5cbiAgICAgIGlmICghZGF0YS5za2lwWCAmJiAoeERpZiA+IHRocmVzaG9sZCB8fCB4RGlmIDwgLXRocmVzaG9sZCkgJiYgeCA8IF9tYXgodGFyZ2V0LCBcInhcIikpIHtcbiAgICAgICAgZGF0YS5za2lwWCA9IDE7IC8vaWYgdGhlIHVzZXIgc2Nyb2xscyBzZXBhcmF0ZWx5LCB3ZSBzaG91bGQgc3RvcCB0d2VlbmluZyFcbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhLnNraXBZICYmICh5RGlmID4gdGhyZXNob2xkIHx8IHlEaWYgPCAtdGhyZXNob2xkKSAmJiB5IDwgX21heCh0YXJnZXQsIFwieVwiKSkge1xuICAgICAgICBkYXRhLnNraXBZID0gMTsgLy9pZiB0aGUgdXNlciBzY3JvbGxzIHNlcGFyYXRlbHksIHdlIHNob3VsZCBzdG9wIHR3ZWVuaW5nIVxuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5za2lwWCAmJiBkYXRhLnNraXBZKSB7XG4gICAgICAgIHR3ZWVuLmtpbGwoKTtcbiAgICAgICAgZGF0YS52YXJzLm9uQXV0b0tpbGwgJiYgZGF0YS52YXJzLm9uQXV0b0tpbGwuYXBwbHkodHdlZW4sIGRhdGEudmFycy5vbkF1dG9LaWxsUGFyYW1zIHx8IFtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNXaW4pIHtcbiAgICAgIF93aW5kb3cuc2Nyb2xsVG8oIWRhdGEuc2tpcFggPyBkYXRhLnggOiB4LCAhZGF0YS5za2lwWSA/IGRhdGEueSA6IHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLnNraXBZIHx8ICh0YXJnZXQuc2Nyb2xsVG9wID0gZGF0YS55KTtcbiAgICAgIGRhdGEuc2tpcFggfHwgKHRhcmdldC5zY3JvbGxMZWZ0ID0gZGF0YS54KTtcbiAgICB9XG5cbiAgICBpZiAoc25hcCAmJiAocmF0aW8gPT09IDEgfHwgcmF0aW8gPT09IDApKSB7XG4gICAgICB5ID0gdGFyZ2V0LnNjcm9sbFRvcDtcbiAgICAgIHggPSB0YXJnZXQuc2Nyb2xsTGVmdDtcbiAgICAgIHNuYXBJbmxpbmUgPyB0YXJnZXQuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSBzbmFwSW5saW5lIDogdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwic2Nyb2xsLXNuYXAtdHlwZVwiKTtcbiAgICAgIHRhcmdldC5zY3JvbGxUb3AgPSB5ICsgMTsgLy8gYnVnIGluIFNhZmFyaSBjYXVzZXMgdGhlIGVsZW1lbnQgdG8gdG90YWxseSByZXNldCBpdHMgc2Nyb2xsIHBvc2l0aW9uIHdoZW4gc2Nyb2xsLXNuYXAtdHlwZSBjaGFuZ2VzLCBzbyB3ZSBuZWVkIHRvIHNldCBpdCB0byBhIHNsaWdodGx5IGRpZmZlcmVudCB2YWx1ZSBhbmQgdGhlbiBiYWNrIGFnYWluIHRvIHdvcmsgYXJvdW5kIHRoaXMgYnVnLlxuXG4gICAgICB0YXJnZXQuc2Nyb2xsTGVmdCA9IHggKyAxO1xuICAgICAgdGFyZ2V0LnNjcm9sbFRvcCA9IHk7XG4gICAgICB0YXJnZXQuc2Nyb2xsTGVmdCA9IHg7XG4gICAgfVxuXG4gICAgZGF0YS54UHJldiA9IGRhdGEueDtcbiAgICBkYXRhLnlQcmV2ID0gZGF0YS55O1xuICAgIFNjcm9sbFRyaWdnZXIgJiYgU2Nyb2xsVHJpZ2dlci51cGRhdGUoKTtcbiAgfSxcbiAga2lsbDogZnVuY3Rpb24ga2lsbChwcm9wZXJ0eSkge1xuICAgIHZhciBib3RoID0gcHJvcGVydHkgPT09IFwic2Nyb2xsVG9cIixcbiAgICAgICAgaSA9IHRoaXMuX3Byb3BzLmluZGV4T2YocHJvcGVydHkpO1xuXG4gICAgaWYgKGJvdGggfHwgcHJvcGVydHkgPT09IFwic2Nyb2xsVG9feFwiKSB7XG4gICAgICB0aGlzLnNraXBYID0gMTtcbiAgICB9XG5cbiAgICBpZiAoYm90aCB8fCBwcm9wZXJ0eSA9PT0gXCJzY3JvbGxUb195XCIpIHtcbiAgICAgIHRoaXMuc2tpcFkgPSAxO1xuICAgIH1cblxuICAgIGkgPiAtMSAmJiB0aGlzLl9wcm9wcy5zcGxpY2UoaSwgMSk7XG4gICAgcmV0dXJuICF0aGlzLl9wcm9wcy5sZW5ndGg7XG4gIH1cbn07XG5TY3JvbGxUb1BsdWdpbi5tYXggPSBfbWF4O1xuU2Nyb2xsVG9QbHVnaW4uZ2V0T2Zmc2V0ID0gX2dldE9mZnNldDtcblNjcm9sbFRvUGx1Z2luLmJ1aWxkR2V0dGVyID0gX2J1aWxkR2V0dGVyO1xuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRvUGx1Z2luKTtcbmV4cG9ydCB7IFNjcm9sbFRvUGx1Z2luIGFzIGRlZmF1bHQgfTsiXSwibmFtZXMiOlsiZ3NhcCIsIl9jb3JlSW5pdHRlZCIsIl93aW5kb3ciLCJfZG9jRWwiLCJfYm9keSIsIl90b0FycmF5IiwiX2NvbmZpZyIsIlNjcm9sbFRyaWdnZXIiLCJfd2luZG93RXhpc3RzIiwid2luZG93IiwiX2dldEdTQVAiLCJyZWdpc3RlclBsdWdpbiIsIl9pc1N0cmluZyIsInZhbHVlIiwiX2lzRnVuY3Rpb24iLCJfbWF4IiwiZWxlbWVudCIsImF4aXMiLCJkaW0iLCJzY3JvbGwiLCJjbGllbnQiLCJNYXRoIiwibWF4IiwiX2J1aWxkR2V0dGVyIiwiZSIsInAiLCJwYWdlWE9mZnNldCIsInRvVXBwZXJDYXNlIiwiX2NsZWFuIiwiaW5kZXgiLCJ0YXJnZXQiLCJ0YXJnZXRzIiwiY2hhckF0IiwieCIsInkiLCJub2RlVHlwZSIsInJlc3VsdCIsIl9nZXRPZmZzZXQiLCJjb250YWluZXIiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjb25zb2xlIiwid2FybiIsInJlY3QiLCJpc1Jvb3QiLCJjUmVjdCIsInRvcCIsImNsaWVudFRvcCIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG9wIiwibGVmdCIsImNsaWVudExlZnQiLCJzY3JvbGxMZWZ0Iiwib2Zmc2V0cyIsIl9wYXJzZVZhbCIsImN1cnJlbnRWYWwiLCJvZmZzZXQiLCJpc05hTiIsInBhcnNlRmxvYXQiLCJzdWJzdHIiLCJtaW4iLCJfaW5pdENvcmUiLCJkb2N1bWVudCIsImJvZHkiLCJkb2N1bWVudEVsZW1lbnQiLCJ1dGlscyIsInRvQXJyYXkiLCJjb25maWciLCJhdXRvS2lsbFRocmVzaG9sZCIsIlNjcm9sbFRvUGx1Z2luIiwidmVyc2lvbiIsIm5hbWUiLCJyYXdWYXJzIiwicmVnaXN0ZXIiLCJjb3JlIiwiaW5pdCIsInR3ZWVuIiwiZGF0YSIsInNuYXBUeXBlIiwiZ2V0UHJvcGVydHkiLCJpc1dpbiIsInZhcnMiLCJhdXRvS2lsbCIsImdldFgiLCJnZXRZIiwieFByZXYiLCJ5UHJldiIsImdsb2JhbHMiLCJzZXQiLCJzY3JvbGxCZWhhdmlvciIsInNuYXAiLCJzbmFwSW5saW5lIiwic3R5bGUiLCJzY3JvbGxTbmFwVHlwZSIsImFkZCIsIm9mZnNldFgiLCJfcHJvcHMiLCJwdXNoIiwic2tpcFgiLCJvZmZzZXRZIiwic2tpcFkiLCJyZW5kZXIiLCJyYXRpbyIsInB0IiwiX3B0IiwieURpZiIsInhEaWYiLCJ0aHJlc2hvbGQiLCJyIiwiZCIsIl9uZXh0Iiwia2lsbCIsIm9uQXV0b0tpbGwiLCJhcHBseSIsIm9uQXV0b0tpbGxQYXJhbXMiLCJzY3JvbGxUbyIsInJlbW92ZVByb3BlcnR5IiwidXBkYXRlIiwicHJvcGVydHkiLCJib3RoIiwiaSIsImluZGV4T2YiLCJzcGxpY2UiLCJsZW5ndGgiLCJnZXRPZmZzZXQiLCJidWlsZEdldHRlciIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollToPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollTrigger.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollTrigger.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrollTrigger: function() { return /* binding */ ScrollTrigger; },\n/* harmony export */   \"default\": function() { return /* binding */ ScrollTrigger; }\n/* harmony export */ });\n/* harmony import */ var _Observer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Observer.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Observer.js\");\n/*!\n * ScrollTrigger 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ \nvar gsap, _coreInitted, _win, _doc, _docEl, _body, _root, _resizeDelay, _toArray, _clamp, _time2, _syncInterval, _refreshing, _pointerIsDown, _transformProp, _i, _prevWidth, _prevHeight, _autoRefresh, _sort, _suppressOverwrites, _ignoreResize, _normalizer, _ignoreMobileResize, _baseScreenHeight, _baseScreenWidth, _fixIOSBug, _context, _scrollRestoration, _div100vh, _100vh, _isReverted, _clampingMax, _limitCallbacks, // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.\n_startup = 1, _getTime = Date.now, _time1 = _getTime(), _lastScrollTime = 0, _enabled = 0, _parseClamp = function _parseClamp(value, type, self) {\n    var clamp = _isString(value) && (value.substr(0, 6) === \"clamp(\" || value.indexOf(\"max\") > -1);\n    self[\"_\" + type + \"Clamp\"] = clamp;\n    return clamp ? value.substr(6, value.length - 7) : value;\n}, _keepClamp = function _keepClamp(value, clamp) {\n    return clamp && (!_isString(value) || value.substr(0, 6) !== \"clamp(\") ? \"clamp(\" + value + \")\" : value;\n}, _rafBugFix = function _rafBugFix() {\n    return _enabled && requestAnimationFrame(_rafBugFix);\n}, // in some browsers (like Firefox), screen repaints weren't consistent unless we had SOMETHING queued up in requestAnimationFrame()! So this just creates a super simple loop to keep it alive and smooth out repaints.\n_pointerDownHandler = function _pointerDownHandler() {\n    return _pointerIsDown = 1;\n}, _pointerUpHandler = function _pointerUpHandler() {\n    return _pointerIsDown = 0;\n}, _passThrough = function _passThrough(v) {\n    return v;\n}, _round = function _round(value) {\n    return Math.round(value * 100000) / 100000 || 0;\n}, _windowExists = function _windowExists() {\n    return typeof window !== \"undefined\";\n}, _getGSAP = function _getGSAP() {\n    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _isViewport = function _isViewport(e) {\n    return !!~_root.indexOf(e);\n}, _getViewportDimension = function _getViewportDimension(dimensionProperty) {\n    return (dimensionProperty === \"Height\" ? _100vh : _win[\"inner\" + dimensionProperty]) || _docEl[\"client\" + dimensionProperty] || _body[\"client\" + dimensionProperty];\n}, _getBoundsFunc = function _getBoundsFunc(element) {\n    return (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(element, \"getBoundingClientRect\") || (_isViewport(element) ? function() {\n        _winOffsets.width = _win.innerWidth;\n        _winOffsets.height = _100vh;\n        return _winOffsets;\n    } : function() {\n        return _getBounds(element);\n    });\n}, _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {\n    var d = _ref.d, d2 = _ref.d2, a = _ref.a;\n    return (a = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"getBoundingClientRect\")) ? function() {\n        return a()[d];\n    } : function() {\n        return (isViewport ? _getViewportDimension(d2) : scroller[\"client\" + d2]) || 0;\n    };\n}, _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {\n    return !isViewport || ~_Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.indexOf(element) ? _getBoundsFunc(element) : function() {\n        return _winOffsets;\n    };\n}, _maxScroll = function _maxScroll(element, _ref2) {\n    var s = _ref2.s, d2 = _ref2.d2, d = _ref2.d, a = _ref2.a;\n    return Math.max(0, (s = \"scroll\" + d2) && (a = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_docEl[s] || _body[s]) - _getViewportDimension(d2) : element[s] - element[\"offset\" + d2]);\n}, _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {\n    for(var i = 0; i < _autoRefresh.length; i += 3){\n        (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);\n    }\n}, _isString = function _isString(value) {\n    return typeof value === \"string\";\n}, _isFunction = function _isFunction(value) {\n    return typeof value === \"function\";\n}, _isNumber = function _isNumber(value) {\n    return typeof value === \"number\";\n}, _isObject = function _isObject(value) {\n    return typeof value === \"object\";\n}, _endAnimation = function _endAnimation(animation, reversed, pause) {\n    return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();\n}, _callback = function _callback(self, func) {\n    if (self.enabled) {\n        var result = self._ctx ? self._ctx.add(function() {\n            return func(self);\n        }) : func(self);\n        result && result.totalTime && (self.callbackAnimation = result);\n    }\n}, _abs = Math.abs, _left = \"left\", _top = \"top\", _right = \"right\", _bottom = \"bottom\", _width = \"width\", _height = \"height\", _Right = \"Right\", _Left = \"Left\", _Top = \"Top\", _Bottom = \"Bottom\", _padding = \"padding\", _margin = \"margin\", _Width = \"Width\", _Height = \"Height\", _px = \"px\", _getComputedStyle = function _getComputedStyle(element) {\n    return _win.getComputedStyle(element);\n}, _makePositionable = function _makePositionable(element) {\n    // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative\n    var position = _getComputedStyle(element).position;\n    element.style.position = position === \"absolute\" || position === \"fixed\" ? position : \"relative\";\n}, _setDefaults = function _setDefaults(obj, defaults) {\n    for(var p in defaults){\n        p in obj || (obj[p] = defaults[p]);\n    }\n    return obj;\n}, _getBounds = function _getBounds(element, withoutTransforms) {\n    var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== \"matrix(1, 0, 0, 1, 0, 0)\" && gsap.to(element, {\n        x: 0,\n        y: 0,\n        xPercent: 0,\n        yPercent: 0,\n        rotation: 0,\n        rotationX: 0,\n        rotationY: 0,\n        scale: 1,\n        skewX: 0,\n        skewY: 0\n    }).progress(1), bounds = element.getBoundingClientRect();\n    tween && tween.progress(0).kill();\n    return bounds;\n}, _getSize = function _getSize(element, _ref3) {\n    var d2 = _ref3.d2;\n    return element[\"offset\" + d2] || element[\"client\" + d2] || 0;\n}, _getLabelRatioArray = function _getLabelRatioArray(timeline) {\n    var a = [], labels = timeline.labels, duration = timeline.duration(), p;\n    for(p in labels){\n        a.push(labels[p] / duration);\n    }\n    return a;\n}, _getClosestLabel = function _getClosestLabel(animation) {\n    return function(value) {\n        return gsap.utils.snap(_getLabelRatioArray(animation), value);\n    };\n}, _snapDirectional = function _snapDirectional(snapIncrementOrArray) {\n    var snap = gsap.utils.snap(snapIncrementOrArray), a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function(a, b) {\n        return a - b;\n    });\n    return a ? function(value, direction, threshold) {\n        if (threshold === void 0) {\n            threshold = 1e-3;\n        }\n        var i;\n        if (!direction) {\n            return snap(value);\n        }\n        if (direction > 0) {\n            value -= threshold; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.\n            for(i = 0; i < a.length; i++){\n                if (a[i] >= value) {\n                    return a[i];\n                }\n            }\n            return a[i - 1];\n        } else {\n            i = a.length;\n            value += threshold;\n            while(i--){\n                if (a[i] <= value) {\n                    return a[i];\n                }\n            }\n        }\n        return a[0];\n    } : function(value, direction, threshold) {\n        if (threshold === void 0) {\n            threshold = 1e-3;\n        }\n        var snapped = snap(value);\n        return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);\n    };\n}, _getLabelAtDirection = function _getLabelAtDirection(timeline) {\n    return function(value, st) {\n        return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);\n    };\n}, _multiListener = function _multiListener(func, element, types, callback) {\n    return types.split(\",\").forEach(function(type) {\n        return func(element, type, callback);\n    });\n}, _addListener = function _addListener(element, type, func, nonPassive, capture) {\n    return element.addEventListener(type, func, {\n        passive: !nonPassive,\n        capture: !!capture\n    });\n}, _removeListener = function _removeListener(element, type, func, capture) {\n    return element.removeEventListener(type, func, !!capture);\n}, _wheelListener = function _wheelListener(func, el, scrollFunc) {\n    scrollFunc = scrollFunc && scrollFunc.wheelHandler;\n    if (scrollFunc) {\n        func(el, \"wheel\", scrollFunc);\n        func(el, \"touchmove\", scrollFunc);\n    }\n}, _markerDefaults = {\n    startColor: \"green\",\n    endColor: \"red\",\n    indent: 0,\n    fontSize: \"16px\",\n    fontWeight: \"normal\"\n}, _defaults = {\n    toggleActions: \"play\",\n    anticipatePin: 0\n}, _keywords = {\n    top: 0,\n    left: 0,\n    center: 0.5,\n    bottom: 1,\n    right: 1\n}, _offsetToPx = function _offsetToPx(value, size) {\n    if (_isString(value)) {\n        var eqIndex = value.indexOf(\"=\"), relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;\n        if (~eqIndex) {\n            value.indexOf(\"%\") > eqIndex && (relative *= size / 100);\n            value = value.substr(0, eqIndex - 1);\n        }\n        value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf(\"%\") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);\n    }\n    return value;\n}, _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {\n    var startColor = _ref4.startColor, endColor = _ref4.endColor, fontSize = _ref4.fontSize, indent = _ref4.indent, fontWeight = _ref4.fontWeight;\n    var e = _doc.createElement(\"div\"), useFixedPosition = _isViewport(container) || (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(container, \"pinType\") === \"fixed\", isScroller = type.indexOf(\"scroller\") !== -1, parent = useFixedPosition ? _body : container, isStart = type.indexOf(\"start\") !== -1, color = isStart ? startColor : endColor, css = \"border-color:\" + color + \";font-size:\" + fontSize + \";color:\" + color + \";font-weight:\" + fontWeight + \";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;\";\n    css += \"position:\" + ((isScroller || containerAnimation) && useFixedPosition ? \"fixed;\" : \"absolute;\");\n    (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? _right : _bottom) + \":\" + (offset + parseFloat(indent)) + \"px;\");\n    matchWidthEl && (css += \"box-sizing:border-box;text-align:left;width:\" + matchWidthEl.offsetWidth + \"px;\");\n    e._isStart = isStart;\n    e.setAttribute(\"class\", \"gsap-marker-\" + type + (name ? \" marker-\" + name : \"\"));\n    e.style.cssText = css;\n    e.innerText = name || name === 0 ? type + \"-\" + name : type;\n    parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);\n    e._offset = e[\"offset\" + direction.op.d2];\n    _positionMarker(e, 0, direction, isStart);\n    return e;\n}, _positionMarker = function _positionMarker(marker, start, direction, flipped) {\n    var vars = {\n        display: \"block\"\n    }, side = direction[flipped ? \"os2\" : \"p2\"], oppositeSide = direction[flipped ? \"p2\" : \"os2\"];\n    marker._isFlipped = flipped;\n    vars[direction.a + \"Percent\"] = flipped ? -100 : 0;\n    vars[direction.a] = flipped ? \"1px\" : 0;\n    vars[\"border\" + side + _Width] = 1;\n    vars[\"border\" + oppositeSide + _Width] = 0;\n    vars[direction.p] = start + \"px\";\n    gsap.set(marker, vars);\n}, _triggers = [], _ids = {}, _rafID, _sync = function _sync() {\n    return _getTime() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)));\n}, _onScroll = function _onScroll() {\n    // previously, we tried to optimize performance by batching/deferring to the next requestAnimationFrame(), but discovered that Safari has a few bugs that make this unworkable (especially on iOS). See https://codepen.io/GreenSock/pen/16c435b12ef09c38125204818e7b45fc?editors=0010 and https://codepen.io/GreenSock/pen/JjOxYpQ/3dd65ccec5a60f1d862c355d84d14562?editors=0010 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503?editors=0010\n    if (!_normalizer || !_normalizer.isPressed || _normalizer.startX > _body.clientWidth) {\n        // if the user is dragging the scrollbar, allow it.\n        _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\n        if (_normalizer) {\n            _rafID || (_rafID = requestAnimationFrame(_updateAll));\n        } else {\n            _updateAll(); // Safari in particular (on desktop) NEEDS the immediate update rather than waiting for a requestAnimationFrame() whereas iOS seems to benefit from waiting for the requestAnimationFrame() tick, at least when normalizing. See https://codepen.io/GreenSock/pen/qBYozqO?editors=0110\n        }\n        _lastScrollTime || _dispatch(\"scrollStart\");\n        _lastScrollTime = _getTime();\n    }\n}, _setBaseDimensions = function _setBaseDimensions() {\n    _baseScreenWidth = _win.innerWidth;\n    _baseScreenHeight = _win.innerHeight;\n}, _onResize = function _onResize() {\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\n    !_refreshing && !_ignoreResize && !_doc.fullscreenElement && !_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win.innerWidth || Math.abs(_win.innerHeight - _baseScreenHeight) > _win.innerHeight * 0.25) && _resizeDelay.restart(true);\n}, // ignore resizes triggered by refresh()\n_listeners = {}, _emptyArray = [], _softRefresh = function _softRefresh() {\n    return _removeListener(ScrollTrigger, \"scrollEnd\", _softRefresh) || _refreshAll(true);\n}, _dispatch = function _dispatch(type) {\n    return _listeners[type] && _listeners[type].map(function(f) {\n        return f();\n    }) || _emptyArray;\n}, _savedStyles = [], // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.\n_revertRecorded = function _revertRecorded(media) {\n    for(var i = 0; i < _savedStyles.length; i += 5){\n        if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {\n            _savedStyles[i].style.cssText = _savedStyles[i + 1];\n            _savedStyles[i].getBBox && _savedStyles[i].setAttribute(\"transform\", _savedStyles[i + 2] || \"\");\n            _savedStyles[i + 3].uncache = 1;\n        }\n    }\n}, _revertAll = function _revertAll(kill, media) {\n    var trigger;\n    for(_i = 0; _i < _triggers.length; _i++){\n        trigger = _triggers[_i];\n        if (trigger && (!media || trigger._ctx === media)) {\n            if (kill) {\n                trigger.kill(1);\n            } else {\n                trigger.revert(true, true);\n            }\n        }\n    }\n    _isReverted = true;\n    media && _revertRecorded(media);\n    media || _dispatch(\"revert\");\n}, _clearScrollMemory = function _clearScrollMemory(scrollRestoration, force) {\n    // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\n    (force || !_refreshingAll) && _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {\n        return _isFunction(obj) && obj.cacheID++ && (obj.rec = 0);\n    });\n    _isString(scrollRestoration) && (_win.history.scrollRestoration = _scrollRestoration = scrollRestoration);\n}, _refreshingAll, _refreshID = 0, _queueRefreshID, _queueRefreshAll = function _queueRefreshAll() {\n    // we don't want to call _refreshAll() every time we create a new ScrollTrigger (for performance reasons) - it's better to batch them. Some frameworks dynamically load content and we can't rely on the window's \"load\" or \"DOMContentLoaded\" events to trigger it.\n    if (_queueRefreshID !== _refreshID) {\n        var id = _queueRefreshID = _refreshID;\n        requestAnimationFrame(function() {\n            return id === _refreshID && _refreshAll(true);\n        });\n    }\n}, _refresh100vh = function _refresh100vh() {\n    _body.appendChild(_div100vh);\n    _100vh = !_normalizer && _div100vh.offsetHeight || _win.innerHeight;\n    _body.removeChild(_div100vh);\n}, _hideAllMarkers = function _hideAllMarkers(hide) {\n    return _toArray(\".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end\").forEach(function(el) {\n        return el.style.display = hide ? \"none\" : \"block\";\n    });\n}, _refreshAll = function _refreshAll(force, skipRevert) {\n    if (_lastScrollTime && !force && !_isReverted) {\n        _addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n        return;\n    }\n    _refresh100vh();\n    _refreshingAll = ScrollTrigger.isRefreshing = true;\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {\n        return _isFunction(obj) && ++obj.cacheID && (obj.rec = obj());\n    }); // force the clearing of the cache because some browsers take a little while to dispatch the \"scroll\" event and the user may have changed the scroll position and then called ScrollTrigger.refresh() right away\n    var refreshInits = _dispatch(\"refreshInit\");\n    _sort && ScrollTrigger.sort();\n    skipRevert || _revertAll();\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {\n        if (_isFunction(obj)) {\n            obj.smooth && (obj.target.style.scrollBehavior = \"auto\"); // smooth scrolling interferes\n            obj(0);\n        }\n    });\n    _triggers.slice(0).forEach(function(t) {\n        return t.refresh();\n    }); // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.\n    _isReverted = false;\n    _triggers.forEach(function(t) {\n        // nested pins (pinnedContainer) with pinSpacing may expand the container, so we must accommodate that here.\n        if (t._subPinOffset && t.pin) {\n            var prop = t.vars.horizontal ? \"offsetWidth\" : \"offsetHeight\", original = t.pin[prop];\n            t.revert(true, 1);\n            t.adjustPinSpacing(t.pin[prop] - original);\n            t.refresh();\n        }\n    });\n    _clampingMax = 1; // pinSpacing might be propping a page open, thus when we .setPositions() to clamp a ScrollTrigger's end we should leave the pinSpacing alone. That's what this flag is for.\n    _hideAllMarkers(true);\n    _triggers.forEach(function(t) {\n        // the scroller's max scroll position may change after all the ScrollTriggers refreshed (like pinning could push it down), so we need to loop back and correct any with end: \"max\". Same for anything with a clamped end\n        var max = _maxScroll(t.scroller, t._dir), endClamp = t.vars.end === \"max\" || t._endClamp && t.end > max, startClamp = t._startClamp && t.start >= max;\n        (endClamp || startClamp) && t.setPositions(startClamp ? max - 1 : t.start, endClamp ? Math.max(startClamp ? max : t.start + 1, max) : t.end, true);\n    });\n    _hideAllMarkers(false);\n    _clampingMax = 0;\n    refreshInits.forEach(function(result) {\n        return result && result.render && result.render(-1);\n    }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {\n        if (_isFunction(obj)) {\n            obj.smooth && requestAnimationFrame(function() {\n                return obj.target.style.scrollBehavior = \"smooth\";\n            });\n            obj.rec && obj(obj.rec);\n        }\n    });\n    _clearScrollMemory(_scrollRestoration, 1);\n    _resizeDelay.pause();\n    _refreshID++;\n    _refreshingAll = 2;\n    _updateAll(2);\n    _triggers.forEach(function(t) {\n        return _isFunction(t.vars.onRefresh) && t.vars.onRefresh(t);\n    });\n    _refreshingAll = ScrollTrigger.isRefreshing = false;\n    _dispatch(\"refresh\");\n}, _lastScroll = 0, _direction = 1, _primary, _updateAll = function _updateAll(force) {\n    if (force === 2 || !_refreshingAll && !_isReverted) {\n        // _isReverted could be true if, for example, a matchMedia() is in the process of executing. We don't want to update during the time everything is reverted.\n        ScrollTrigger.isUpdating = true;\n        _primary && _primary.update(0); // ScrollSmoother uses refreshPriority -9999 to become the primary that gets updated before all others because it affects the scroll position.\n        var l = _triggers.length, time = _getTime(), recordVelocity = time - _time1 >= 50, scroll = l && _triggers[0].scroll();\n        _direction = _lastScroll > scroll ? -1 : 1;\n        _refreshingAll || (_lastScroll = scroll);\n        if (recordVelocity) {\n            if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {\n                _lastScrollTime = 0;\n                _dispatch(\"scrollEnd\");\n            }\n            _time2 = _time1;\n            _time1 = time;\n        }\n        if (_direction < 0) {\n            _i = l;\n            while(_i-- > 0){\n                _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n            }\n            _direction = 1;\n        } else {\n            for(_i = 0; _i < l; _i++){\n                _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n            }\n        }\n        ScrollTrigger.isUpdating = false;\n    }\n    _rafID = 0;\n}, _propNamesToCopy = [\n    _left,\n    _top,\n    _bottom,\n    _right,\n    _margin + _Bottom,\n    _margin + _Right,\n    _margin + _Top,\n    _margin + _Left,\n    \"display\",\n    \"flexShrink\",\n    \"float\",\n    \"zIndex\",\n    \"gridColumnStart\",\n    \"gridColumnEnd\",\n    \"gridRowStart\",\n    \"gridRowEnd\",\n    \"gridArea\",\n    \"justifySelf\",\n    \"alignSelf\",\n    \"placeSelf\",\n    \"order\"\n], _stateProps = _propNamesToCopy.concat([\n    _width,\n    _height,\n    \"boxSizing\",\n    \"max\" + _Width,\n    \"max\" + _Height,\n    \"position\",\n    _margin,\n    _padding,\n    _padding + _Top,\n    _padding + _Right,\n    _padding + _Bottom,\n    _padding + _Left\n]), _swapPinOut = function _swapPinOut(pin, spacer, state) {\n    _setState(state);\n    var cache = pin._gsap;\n    if (cache.spacerIsNative) {\n        _setState(cache.spacerState);\n    } else if (pin._gsap.swappedIn) {\n        var parent = spacer.parentNode;\n        if (parent) {\n            parent.insertBefore(pin, spacer);\n            parent.removeChild(spacer);\n        }\n    }\n    pin._gsap.swappedIn = false;\n}, _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {\n    if (!pin._gsap.swappedIn) {\n        var i = _propNamesToCopy.length, spacerStyle = spacer.style, pinStyle = pin.style, p;\n        while(i--){\n            p = _propNamesToCopy[i];\n            spacerStyle[p] = cs[p];\n        }\n        spacerStyle.position = cs.position === \"absolute\" ? \"absolute\" : \"relative\";\n        cs.display === \"inline\" && (spacerStyle.display = \"inline-block\");\n        pinStyle[_bottom] = pinStyle[_right] = \"auto\";\n        spacerStyle.flexBasis = cs.flexBasis || \"auto\";\n        spacerStyle.overflow = \"visible\";\n        spacerStyle.boxSizing = \"border-box\";\n        spacerStyle[_width] = _getSize(pin, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal) + _px;\n        spacerStyle[_height] = _getSize(pin, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical) + _px;\n        spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = \"0\";\n        _setState(spacerState);\n        pinStyle[_width] = pinStyle[\"max\" + _Width] = cs[_width];\n        pinStyle[_height] = pinStyle[\"max\" + _Height] = cs[_height];\n        pinStyle[_padding] = cs[_padding];\n        if (pin.parentNode !== spacer) {\n            pin.parentNode.insertBefore(spacer, pin);\n            spacer.appendChild(pin);\n        }\n        pin._gsap.swappedIn = true;\n    }\n}, _capsExp = /([A-Z])/g, _setState = function _setState(state) {\n    if (state) {\n        var style = state.t.style, l = state.length, i = 0, p, value;\n        (state.t._gsap || gsap.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off\n        for(; i < l; i += 2){\n            value = state[i + 1];\n            p = state[i];\n            if (value) {\n                style[p] = value;\n            } else if (style[p]) {\n                style.removeProperty(p.replace(_capsExp, \"-$1\").toLowerCase());\n            }\n        }\n    }\n}, _getState = function _getState(element) {\n    // returns an Array with alternating values like [property, value, property, value] and a \"t\" property pointing to the target (element). Makes it fast and cheap.\n    var l = _stateProps.length, style = element.style, state = [], i = 0;\n    for(; i < l; i++){\n        state.push(_stateProps[i], style[_stateProps[i]]);\n    }\n    state.t = element;\n    return state;\n}, _copyState = function _copyState(state, override, omitOffsets) {\n    var result = [], l = state.length, i = omitOffsets ? 8 : 0, // skip top, left, right, bottom if omitOffsets is true\n    p;\n    for(; i < l; i += 2){\n        p = state[i];\n        result.push(p, p in override ? override[p] : state[i + 1]);\n    }\n    result.t = state.t;\n    return result;\n}, _winOffsets = {\n    left: 0,\n    top: 0\n}, // // potential future feature (?) Allow users to calculate where a trigger hits (scroll position) like getScrollPosition(\"#id\", \"top bottom\")\n// _getScrollPosition = (trigger, position, {scroller, containerAnimation, horizontal}) => {\n// \tscroller = _getTarget(scroller || _win);\n// \tlet direction = horizontal ? _horizontal : _vertical,\n// \t\tisViewport = _isViewport(scroller);\n// \t_getSizeFunc(scroller, isViewport, direction);\n// \treturn _parsePosition(position, _getTarget(trigger), _getSizeFunc(scroller, isViewport, direction)(), direction, _getScrollFunc(scroller, direction)(), 0, 0, 0, _getOffsetsFunc(scroller, isViewport)(), isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0, 0, containerAnimation ? containerAnimation.duration() : _maxScroll(scroller), containerAnimation);\n// },\n_parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation, clampZeroProp) {\n    _isFunction(value) && (value = value(self));\n    if (_isString(value) && value.substr(0, 3) === \"max\") {\n        value = scrollerMax + (value.charAt(4) === \"=\" ? _offsetToPx(\"0\" + value.substr(3), scrollerSize) : 0);\n    }\n    var time = containerAnimation ? containerAnimation.time() : 0, p1, p2, element;\n    containerAnimation && containerAnimation.seek(0);\n    isNaN(value) || (value = +value); // convert a string number like \"45\" to an actual number\n    if (!_isNumber(value)) {\n        _isFunction(trigger) && (trigger = trigger(self));\n        var offsets = (value || \"0\").split(\" \"), bounds, localOffset, globalOffset, display;\n        element = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(trigger, self) || _body;\n        bounds = _getBounds(element) || {};\n        if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === \"none\") {\n            // if display is \"none\", it won't report getBoundingClientRect() properly\n            display = element.style.display;\n            element.style.display = \"block\";\n            bounds = _getBounds(element);\n            display ? element.style.display = display : element.style.removeProperty(\"display\");\n        }\n        localOffset = _offsetToPx(offsets[0], bounds[direction.d]);\n        globalOffset = _offsetToPx(offsets[1] || \"0\", scrollerSize);\n        value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;\n        markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);\n        scrollerSize -= scrollerSize - globalOffset; // adjust for the marker\n    } else {\n        containerAnimation && (value = gsap.utils.mapRange(containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, 0, scrollerMax, value));\n        markerScroller && _positionMarker(markerScroller, scrollerSize, direction, true);\n    }\n    if (clampZeroProp) {\n        self[clampZeroProp] = value || -0.001;\n        value < 0 && (value = 0);\n    }\n    if (marker) {\n        var position = value + scrollerSize, isStart = marker._isStart;\n        p1 = \"scroll\" + direction.d2;\n        _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[p1], _docEl[p1]) : marker.parentNode[p1]) <= position + 1);\n        if (useFixedPosition) {\n            scrollerBounds = _getBounds(markerScroller);\n            useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);\n        }\n    }\n    if (containerAnimation && element) {\n        p1 = _getBounds(element);\n        containerAnimation.seek(scrollerMax);\n        p2 = _getBounds(element);\n        containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];\n        value = value / containerAnimation._caScrollDist * scrollerMax;\n    }\n    containerAnimation && containerAnimation.seek(time);\n    return containerAnimation ? value : Math.round(value);\n}, _prefixExp = /(webkit|moz|length|cssText|inset)/i, _reparent = function _reparent(element, parent, top, left) {\n    if (element.parentNode !== parent) {\n        var style = element.style, p, cs;\n        if (parent === _body) {\n            element._stOrig = style.cssText; // record original inline styles so we can revert them later\n            cs = _getComputedStyle(element);\n            for(p in cs){\n                // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.\n                if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === \"string\" && p !== \"0\") {\n                    style[p] = cs[p];\n                }\n            }\n            style.top = top;\n            style.left = left;\n        } else {\n            style.cssText = element._stOrig;\n        }\n        gsap.core.getCache(element).uncache = 1;\n        parent.appendChild(element);\n    }\n}, _interruptionTracker = function _interruptionTracker(getValueFunc, initialValue, onInterrupt) {\n    var last1 = initialValue, last2 = last1;\n    return function(value) {\n        var current = Math.round(getValueFunc()); // round because in some [very uncommon] Windows environments, scroll can get reported with decimals even though it was set without.\n        if (current !== last1 && current !== last2 && Math.abs(current - last1) > 3 && Math.abs(current - last2) > 3) {\n            // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.\n            value = current;\n            onInterrupt && onInterrupt();\n        }\n        last2 = last1;\n        last1 = value;\n        return value;\n    };\n}, _shiftMarker = function _shiftMarker(marker, direction, value) {\n    var vars = {};\n    vars[direction.p] = \"+=\" + value;\n    gsap.set(marker, vars);\n}, // _mergeAnimations = animations => {\n// \tlet tl = gsap.timeline({smoothChildTiming: true}).startTime(Math.min(...animations.map(a => a.globalTime(0))));\n// \tanimations.forEach(a => {let time = a.totalTime(); tl.add(a); a.totalTime(time); });\n// \ttl.smoothChildTiming = false;\n// \treturn tl;\n// },\n// returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)\n_getTweenCreator = function _getTweenCreator(scroller, direction) {\n    var getScroll = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, direction), prop = \"_scroll\" + direction.p2, // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.\n    getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {\n        var tween = getTween.tween, onComplete = vars.onComplete, modifiers = {};\n        initialValue = initialValue || getScroll();\n        var checkForInterruption = _interruptionTracker(getScroll, initialValue, function() {\n            tween.kill();\n            getTween.tween = 0;\n        });\n        change2 = change1 && change2 || 0; // if change1 is 0, we set that to the difference and ignore change2. Otherwise, there would be a compound effect.\n        change1 = change1 || scrollTo - initialValue;\n        tween && tween.kill();\n        vars[prop] = scrollTo;\n        vars.inherit = false;\n        vars.modifiers = modifiers;\n        modifiers[prop] = function() {\n            return checkForInterruption(initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio);\n        };\n        vars.onUpdate = function() {\n            _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\n            getTween.tween && _updateAll(); // if it was interrupted/killed, like in a context.revert(), don't force an updateAll()\n        };\n        vars.onComplete = function() {\n            getTween.tween = 0;\n            onComplete && onComplete.call(tween);\n        };\n        tween = getTween.tween = gsap.to(scroller, vars);\n        return tween;\n    };\n    scroller[prop] = getScroll;\n    getScroll.wheelHandler = function() {\n        return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);\n    };\n    _addListener(scroller, \"wheel\", getScroll.wheelHandler); // Windows machines handle mousewheel scrolling in chunks (like \"3 lines per scroll\") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.\n    ScrollTrigger.isTouch && _addListener(scroller, \"touchmove\", getScroll.wheelHandler);\n    return getTween;\n};\nvar ScrollTrigger = /*#__PURE__*/ function() {\n    function ScrollTrigger(vars, animation) {\n        _coreInitted || ScrollTrigger.register(gsap) || console.warn(\"Please gsap.registerPlugin(ScrollTrigger)\");\n        _context(this);\n        this.init(vars, animation);\n    }\n    var _proto = ScrollTrigger.prototype;\n    _proto.init = function init(vars, animation) {\n        this.progress = this.start = 0;\n        this.vars && this.kill(true, true); // in case it's being initted again\n        if (!_enabled) {\n            this.update = this.refresh = this.kill = _passThrough;\n            return;\n        }\n        vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {\n            trigger: vars\n        } : vars, _defaults);\n        var _vars = vars, onUpdate = _vars.onUpdate, toggleClass = _vars.toggleClass, id = _vars.id, onToggle = _vars.onToggle, onRefresh = _vars.onRefresh, scrub = _vars.scrub, trigger = _vars.trigger, pin = _vars.pin, pinSpacing = _vars.pinSpacing, invalidateOnRefresh = _vars.invalidateOnRefresh, anticipatePin = _vars.anticipatePin, onScrubComplete = _vars.onScrubComplete, onSnapComplete = _vars.onSnapComplete, once = _vars.once, snap = _vars.snap, pinReparent = _vars.pinReparent, pinSpacer = _vars.pinSpacer, containerAnimation = _vars.containerAnimation, fastScrollEnd = _vars.fastScrollEnd, preventOverlaps = _vars.preventOverlaps, direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical, isToggle = !scrub && scrub !== 0, scroller = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.scroller || _win), scrollerCache = gsap.core.getCache(scroller), isViewport = _isViewport(scroller), useFixedPosition = (\"pinType\" in vars ? vars.pinType : (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"pinType\") || isViewport && \"fixed\") === \"fixed\", callbacks = [\n            vars.onEnter,\n            vars.onLeave,\n            vars.onEnterBack,\n            vars.onLeaveBack\n        ], toggleActions = isToggle && vars.toggleActions.split(\" \"), markers = \"markers\" in vars ? vars.markers : _defaults.markers, borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0, self = this, onRefreshInit = vars.onRefreshInit && function() {\n            return vars.onRefreshInit(self);\n        }, getScrollerSize = _getSizeFunc(scroller, isViewport, direction), getScrollerOffsets = _getOffsetsFunc(scroller, isViewport), lastSnap = 0, lastRefresh = 0, prevProgress = 0, scrollFunc = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, direction), tweenTo, pinCache, snapFunc, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars, executingOnRefresh, change, pinOriginalState, pinActiveState, pinState, spacer, offset, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacerState, markerStartSetter, pinMoves, markerEndSetter, cs, snap1, snap2, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, prevScroll, prevAnimProgress, caMarkerSetter, customRevertReturn; // for the sake of efficiency, _startClamp/_endClamp serve like a truthy value indicating that clamping was enabled on the start/end, and ALSO store the actual pre-clamped numeric value. We tap into that in ScrollSmoother for speed effects. So for example, if start=\"clamp(top bottom)\" results in a start of -100 naturally, it would get clamped to 0 but -100 would be stored in _startClamp.\n        self._startClamp = self._endClamp = false;\n        self._dir = direction;\n        anticipatePin *= 45;\n        self.scroller = scroller;\n        self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;\n        scroll1 = scrollFunc();\n        self.vars = vars;\n        animation = animation || vars.animation;\n        if (\"refreshPriority\" in vars) {\n            _sort = 1;\n            vars.refreshPriority === -9999 && (_primary = self); // used by ScrollSmoother\n        }\n        scrollerCache.tweenScroll = scrollerCache.tweenScroll || {\n            top: _getTweenCreator(scroller, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical),\n            left: _getTweenCreator(scroller, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal)\n        };\n        self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];\n        self.scrubDuration = function(value) {\n            scrubSmooth = _isNumber(value) && value;\n            if (!scrubSmooth) {\n                scrubTween && scrubTween.progress(1).kill();\n                scrubTween = 0;\n            } else {\n                scrubTween ? scrubTween.duration(value) : scrubTween = gsap.to(animation, {\n                    ease: \"expo\",\n                    totalProgress: \"+=0\",\n                    inherit: false,\n                    duration: scrubSmooth,\n                    paused: true,\n                    onComplete: function onComplete() {\n                        return onScrubComplete && onScrubComplete(self);\n                    }\n                });\n            }\n        };\n        if (animation) {\n            animation.vars.lazy = false;\n            animation._initted && !self.isReverted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true); // special case: if this ScrollTrigger gets re-initted, a from() tween with a stagger could get initted initially and then reverted on the re-init which means it'll need to get rendered again here to properly display things. Otherwise, See https://gsap.com/forums/topic/36777-scrollsmoother-splittext-nextjs/ and https://codepen.io/GreenSock/pen/eYPyPpd?editors=0010\n            self.animation = animation.pause();\n            animation.scrollTrigger = self;\n            self.scrubDuration(scrub);\n            snap1 = 0;\n            id || (id = animation.vars.id);\n        }\n        if (snap) {\n            // TODO: potential idea: use legitimate CSS scroll snapping by pushing invisible elements into the DOM that serve as snap positions, and toggle the document.scrollingElement.style.scrollSnapType onToggle. See https://codepen.io/GreenSock/pen/JjLrgWM for a quick proof of concept.\n            if (!_isObject(snap) || snap.push) {\n                snap = {\n                    snapTo: snap\n                };\n            }\n            \"scrollBehavior\" in _body.style && gsap.set(isViewport ? [\n                _body,\n                _docEl\n            ] : scroller, {\n                scrollBehavior: \"auto\"\n            }); // smooth scrolling doesn't work with snap.\n            _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(o) {\n                return _isFunction(o) && o.target === (isViewport ? _doc.scrollingElement || _docEl : scroller) && (o.smooth = false);\n            }); // note: set smooth to false on both the vertical and horizontal scroll getters/setters\n            snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === \"labels\" ? _getClosestLabel(animation) : snap.snapTo === \"labelsDirectional\" ? _getLabelAtDirection(animation) : snap.directional !== false ? function snapFunc(value, st) {\n                return _snapDirectional(snap.snapTo)(value, _getTime() - lastRefresh < 500 ? 0 : st.direction);\n            } : gsap.utils.snap(snap.snapTo);\n            snapDurClamp = snap.duration || {\n                min: 0.1,\n                max: 2\n            };\n            snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);\n            snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function() {\n                var scroll = scrollFunc(), refreshedRecently = _getTime() - lastRefresh < 500, tween = tweenTo.tween;\n                if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {\n                    var progress = (scroll - start) / change, totalProgress = animation && !isToggle ? animation.totalProgress() : progress, velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0, change1 = gsap.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185), naturalEnd = progress + (snap.inertia === false ? 0 : change1), endValue, endScroll, _snap = snap, onStart = _snap.onStart, _onInterrupt = _snap.onInterrupt, _onComplete = _snap.onComplete;\n                    endValue = snapFunc(naturalEnd, self);\n                    _isNumber(endValue) || (endValue = naturalEnd); // in case the function didn't return a number, fall back to using the naturalEnd\n                    endScroll = Math.round(start + endValue * change);\n                    if (scroll <= end && scroll >= start && endScroll !== scroll) {\n                        if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {\n                            // there's an overlapping snap! So we must figure out which one is closer and let that tween live.\n                            return;\n                        }\n                        if (snap.inertia === false) {\n                            change1 = endValue - progress;\n                        }\n                        tweenTo(endScroll, {\n                            duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),\n                            ease: snap.ease || \"power3\",\n                            data: _abs(endScroll - scroll),\n                            // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.\n                            onInterrupt: function onInterrupt() {\n                                return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);\n                            },\n                            onComplete: function onComplete() {\n                                self.update();\n                                lastSnap = scrollFunc();\n                                if (animation) {\n                                    // the resolution of the scrollbar is limited, so we should correct the scrubbed animation's playhead at the end to match EXACTLY where it was supposed to snap\n                                    scrubTween ? scrubTween.resetTo(\"totalProgress\", endValue, animation._tTime / animation._tDur) : animation.progress(endValue);\n                                }\n                                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;\n                                onSnapComplete && onSnapComplete(self);\n                                _onComplete && _onComplete(self);\n                            }\n                        }, scroll, change1 * change, endScroll - scroll - change1 * change);\n                        onStart && onStart(self, tweenTo.tween);\n                    }\n                } else if (self.isActive && lastSnap !== scroll) {\n                    snapDelayedCall.restart(true);\n                }\n            }).pause();\n        }\n        id && (_ids[id] = self);\n        trigger = self.trigger = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(trigger || pin !== true && pin); // if a trigger has some kind of scroll-related effect applied that could contaminate the \"y\" or \"x\" position (like a ScrollSmoother effect), we needed a way to temporarily revert it, so we use the stRevert property of the gsCache. It can return another function that we'll call at the end so it can return to its normal state.\n        customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;\n        customRevertReturn && (customRevertReturn = customRevertReturn(self));\n        pin = pin === true ? trigger : (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(pin);\n        _isString(toggleClass) && (toggleClass = {\n            targets: trigger,\n            className: toggleClass\n        });\n        if (pin) {\n            pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === \"flex\" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default. We should check that pin.parentNode is an element (not shadow dom window)\n            self.pin = pin;\n            pinCache = gsap.core.getCache(pin);\n            if (!pinCache.spacer) {\n                // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the \"original\" pin state after it has already been affected by another ScrollTrigger.\n                if (pinSpacer) {\n                    pinSpacer = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(pinSpacer);\n                    pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement); // for React & Angular\n                    pinCache.spacerIsNative = !!pinSpacer;\n                    pinSpacer && (pinCache.spacerState = _getState(pinSpacer));\n                }\n                pinCache.spacer = spacer = pinSpacer || _doc.createElement(\"div\");\n                spacer.classList.add(\"pin-spacer\");\n                id && spacer.classList.add(\"pin-spacer-\" + id);\n                pinCache.pinState = pinOriginalState = _getState(pin);\n            } else {\n                pinOriginalState = pinCache.pinState;\n            }\n            vars.force3D !== false && gsap.set(pin, {\n                force3D: true\n            });\n            self.spacer = spacer = pinCache.spacer;\n            cs = _getComputedStyle(pin);\n            spacingStart = cs[pinSpacing + direction.os2];\n            pinGetter = gsap.getProperty(pin);\n            pinSetter = gsap.quickSetter(pin, direction.a, _px); // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = \"hidden\"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).\n            _swapPinIn(pin, spacer, cs);\n            pinState = _getState(pin);\n        }\n        if (markers) {\n            markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;\n            markerStartTrigger = _createMarker(\"scroller-start\", id, scroller, direction, markerVars, 0);\n            markerEndTrigger = _createMarker(\"scroller-end\", id, scroller, direction, markerVars, 0, markerStartTrigger);\n            offset = markerStartTrigger[\"offset\" + direction.op.d2];\n            var content = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)((0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"content\") || scroller);\n            markerStart = this.markerStart = _createMarker(\"start\", id, content, direction, markerVars, offset, 0, containerAnimation);\n            markerEnd = this.markerEnd = _createMarker(\"end\", id, content, direction, markerVars, offset, 0, containerAnimation);\n            containerAnimation && (caMarkerSetter = gsap.quickSetter([\n                markerStart,\n                markerEnd\n            ], direction.a, _px));\n            if (!useFixedPosition && !(_Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.length && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"fixedMarkers\") === true)) {\n                _makePositionable(isViewport ? _body : scroller);\n                gsap.set([\n                    markerStartTrigger,\n                    markerEndTrigger\n                ], {\n                    force3D: true\n                });\n                markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);\n                markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);\n            }\n        }\n        if (containerAnimation) {\n            var oldOnUpdate = containerAnimation.vars.onUpdate, oldParams = containerAnimation.vars.onUpdateParams;\n            containerAnimation.eventCallback(\"onUpdate\", function() {\n                self.update(0, 0, 1);\n                oldOnUpdate && oldOnUpdate.apply(containerAnimation, oldParams || []);\n            });\n        }\n        self.previous = function() {\n            return _triggers[_triggers.indexOf(self) - 1];\n        };\n        self.next = function() {\n            return _triggers[_triggers.indexOf(self) + 1];\n        };\n        self.revert = function(revert, temp) {\n            if (!temp) {\n                return self.kill(true);\n            } // for compatibility with gsap.context() and gsap.matchMedia() which call revert()\n            var r = revert !== false || !self.enabled, prevRefreshing = _refreshing;\n            if (r !== self.isReverted) {\n                if (r) {\n                    prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.\n                    prevProgress = self.progress;\n                    prevAnimProgress = animation && animation.progress();\n                }\n                markerStart && [\n                    markerStart,\n                    markerEnd,\n                    markerStartTrigger,\n                    markerEndTrigger\n                ].forEach(function(m) {\n                    return m.style.display = r ? \"none\" : \"block\";\n                });\n                if (r) {\n                    _refreshing = self;\n                    self.update(r); // make sure the pin is back in its original position so that all the measurements are correct. do this BEFORE swapping the pin out\n                }\n                if (pin && (!pinReparent || !self.isActive)) {\n                    if (r) {\n                        _swapPinOut(pin, spacer, pinOriginalState);\n                    } else {\n                        _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState);\n                    }\n                }\n                r || self.update(r); // when we're restoring, the update should run AFTER swapping the pin into its pin-spacer.\n                _refreshing = prevRefreshing; // restore. We set it to true during the update() so that things fire properly in there.\n                self.isReverted = r;\n            }\n        };\n        self.refresh = function(soft, force, position, pinOffset) {\n            // position is typically only defined if it's coming from setPositions() - it's a way to skip the normal parsing. pinOffset is also only from setPositions() and is mostly related to fancy stuff we need to do in ScrollSmoother with effects\n            if ((_refreshing || !self.enabled) && !force) {\n                return;\n            }\n            if (pin && soft && _lastScrollTime) {\n                _addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n                return;\n            }\n            !_refreshingAll && onRefreshInit && onRefreshInit(self);\n            _refreshing = self;\n            if (tweenTo.tween && !position) {\n                // we skip this if a position is passed in because typically that's from .setPositions() and it's best to allow in-progress snapping to continue.\n                tweenTo.tween.kill();\n                tweenTo.tween = 0;\n            }\n            scrubTween && scrubTween.pause();\n            invalidateOnRefresh && animation && animation.revert({\n                kill: false\n            }).invalidate();\n            self.isReverted || self.revert(true, true);\n            self._subPinOffset = false; // we'll set this to true in the sub-pins if we find any\n            var size = getScrollerSize(), scrollerBounds = getScrollerOffsets(), max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction), isFirstRefresh = change <= 0.01, offset = 0, otherPinOffset = pinOffset || 0, parsedEnd = _isObject(position) ? position.end : vars.end, parsedEndTrigger = vars.endTrigger || trigger, parsedStart = _isObject(position) ? position.start : vars.start || (vars.start === 0 || !trigger ? 0 : pin ? \"0 0\" : \"0 100%\"), pinnedContainer = self.pinnedContainer = vars.pinnedContainer && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.pinnedContainer, self), triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0, i = triggerIndex, cs, bounds, scroll, isVertical, override, curTrigger, curPin, oppositeScroll, initted, revertedPins, forcedOverflow, markerStartOffset, markerEndOffset;\n            if (markers && _isObject(position)) {\n                // if we alter the start/end positions with .setPositions(), it generally feeds in absolute NUMBERS which don't convey information about where to line up the markers, so to keep it intuitive, we record how far the trigger positions shift after applying the new numbers and then offset by that much in the opposite direction. We do the same to the associated trigger markers too of course.\n                markerStartOffset = gsap.getProperty(markerStartTrigger, direction.p);\n                markerEndOffset = gsap.getProperty(markerEndTrigger, direction.p);\n            }\n            while(i--){\n                // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things \"rewind\" properly.\n                curTrigger = _triggers[i];\n                curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = self); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.\n                curPin = curTrigger.pin;\n                if (curPin && (curPin === trigger || curPin === pin || curPin === pinnedContainer) && !curTrigger.isReverted) {\n                    revertedPins || (revertedPins = []);\n                    revertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly\n                    curTrigger.revert(true, true);\n                }\n                if (curTrigger !== _triggers[i]) {\n                    // in case it got removed.\n                    triggerIndex--;\n                    i--;\n                }\n            }\n            _isFunction(parsedStart) && (parsedStart = parsedStart(self));\n            parsedStart = _parseClamp(parsedStart, \"start\", self);\n            start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._startClamp && \"_startClamp\") || (pin ? -0.001 : 0);\n            _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));\n            if (_isString(parsedEnd) && !parsedEnd.indexOf(\"+=\")) {\n                if (~parsedEnd.indexOf(\" \")) {\n                    parsedEnd = (_isString(parsedStart) ? parsedStart.split(\" \")[0] : \"\") + parsedEnd;\n                } else {\n                    offset = _offsetToPx(parsedEnd.substr(2), size);\n                    parsedEnd = _isString(parsedStart) ? parsedStart : (containerAnimation ? gsap.utils.mapRange(0, containerAnimation.duration(), containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, start) : start) + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.\n                    parsedEndTrigger = trigger;\n                }\n            }\n            parsedEnd = _parseClamp(parsedEnd, \"end\", self);\n            end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? \"100% 0\" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._endClamp && \"_endClamp\")) || -0.001;\n            offset = 0;\n            i = triggerIndex;\n            while(i--){\n                curTrigger = _triggers[i];\n                curPin = curTrigger.pin;\n                if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {\n                    cs = curTrigger.end - (self._startClamp ? Math.max(0, curTrigger.start) : curTrigger.start);\n                    if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && isNaN(parsedStart)) {\n                        // numeric start values shouldn't be offset at all - treat them as absolute\n                        offset += cs * (1 - curTrigger.progress);\n                    }\n                    curPin === pin && (otherPinOffset += cs);\n                }\n            }\n            start += offset;\n            end += offset;\n            self._startClamp && (self._startClamp += offset);\n            if (self._endClamp && !_refreshingAll) {\n                self._endClamp = end || -0.001;\n                end = Math.min(end, _maxScroll(scroller, direction));\n            }\n            change = end - start || (start -= 0.01) && 0.001;\n            if (isFirstRefresh) {\n                // on the very first refresh(), the prevProgress couldn't have been accurate yet because the start/end were never calculated, so we set it here. Before 3.11.5, it could lead to an inaccurate scroll position restoration with snapping.\n                prevProgress = gsap.utils.clamp(0, 1, gsap.utils.normalize(start, end, prevScroll));\n            }\n            self._pinPush = otherPinOffset;\n            if (markerStart && offset) {\n                // offset the markers if necessary\n                cs = {};\n                cs[direction.a] = \"+=\" + offset;\n                pinnedContainer && (cs[direction.p] = \"-=\" + scrollFunc());\n                gsap.set([\n                    markerStart,\n                    markerEnd\n                ], cs);\n            }\n            if (pin && !(_clampingMax && self.end >= _maxScroll(scroller, direction))) {\n                cs = _getComputedStyle(pin);\n                isVertical = direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical;\n                scroll = scrollFunc(); // recalculate because the triggers can affect the scroll\n                pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;\n                if (!max && end > 1) {\n                    // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://gsap.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/\n                    forcedOverflow = (isViewport ? _doc.scrollingElement || _docEl : scroller).style;\n                    forcedOverflow = {\n                        style: forcedOverflow,\n                        value: forcedOverflow[\"overflow\" + direction.a.toUpperCase()]\n                    };\n                    if (isViewport && _getComputedStyle(_body)[\"overflow\" + direction.a.toUpperCase()] !== \"scroll\") {\n                        // avoid an extra scrollbar if BOTH <html> and <body> have overflow set to \"scroll\"\n                        forcedOverflow.style[\"overflow\" + direction.a.toUpperCase()] = \"scroll\";\n                    }\n                }\n                _swapPinIn(pin, spacer, cs);\n                pinState = _getState(pin); // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.\n                bounds = _getBounds(pin, true);\n                oppositeScroll = useFixedPosition && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, isVertical ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical)();\n                if (pinSpacing) {\n                    spacerState = [\n                        pinSpacing + direction.os2,\n                        change + otherPinOffset + _px\n                    ];\n                    spacerState.t = spacer;\n                    i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;\n                    if (i) {\n                        spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).\n                        spacer.style.flexBasis !== \"auto\" && (spacer.style.flexBasis = i + _px);\n                    }\n                    _setState(spacerState);\n                    if (pinnedContainer) {\n                        // in ScrollTrigger.refresh(), we need to re-evaluate the pinContainer's size because this pinSpacing may stretch it out, but we can't just add the exact distance because depending on layout, it may not push things down or it may only do so partially.\n                        _triggers.forEach(function(t) {\n                            if (t.pin === pinnedContainer && t.vars.pinSpacing !== false) {\n                                t._subPinOffset = true;\n                            }\n                        });\n                    }\n                    useFixedPosition && scrollFunc(prevScroll);\n                } else {\n                    i = _getSize(pin, direction);\n                    i && spacer.style.flexBasis !== \"auto\" && (spacer.style.flexBasis = i + _px);\n                }\n                if (useFixedPosition) {\n                    override = {\n                        top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,\n                        left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,\n                        boxSizing: \"border-box\",\n                        position: \"fixed\"\n                    };\n                    override[_width] = override[\"max\" + _Width] = Math.ceil(bounds.width) + _px;\n                    override[_height] = override[\"max\" + _Height] = Math.ceil(bounds.height) + _px;\n                    override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = \"0\";\n                    override[_padding] = cs[_padding];\n                    override[_padding + _Top] = cs[_padding + _Top];\n                    override[_padding + _Right] = cs[_padding + _Right];\n                    override[_padding + _Bottom] = cs[_padding + _Bottom];\n                    override[_padding + _Left] = cs[_padding + _Left];\n                    pinActiveState = _copyState(pinOriginalState, override, pinReparent);\n                    _refreshingAll && scrollFunc(0);\n                }\n                if (animation) {\n                    // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.\n                    initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.\n                    _suppressOverwrites(1);\n                    animation.render(animation.duration(), true, true);\n                    pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;\n                    pinMoves = Math.abs(change - pinChange) > 1;\n                    useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.\n                    animation.render(0, true, true);\n                    initted || animation.invalidate(true);\n                    animation.parent || animation.totalTime(animation.totalTime()); // if, for example, a toggleAction called play() and then refresh() happens and when we render(1) above, it would cause the animation to complete and get removed from its parent, so this makes sure it gets put back in.\n                    _suppressOverwrites(0);\n                } else {\n                    pinChange = change;\n                }\n                forcedOverflow && (forcedOverflow.value ? forcedOverflow.style[\"overflow\" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty(\"overflow-\" + direction.a));\n            } else if (trigger && scrollFunc() && !containerAnimation) {\n                // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()\n                bounds = trigger.parentNode;\n                while(bounds && bounds !== _body){\n                    if (bounds._pinOffset) {\n                        start -= bounds._pinOffset;\n                        end -= bounds._pinOffset;\n                    }\n                    bounds = bounds.parentNode;\n                }\n            }\n            revertedPins && revertedPins.forEach(function(t) {\n                return t.revert(false, true);\n            });\n            self.start = start;\n            self.end = end;\n            scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc(); // reset velocity\n            if (!containerAnimation && !_refreshingAll) {\n                scroll1 < prevScroll && scrollFunc(prevScroll);\n                self.scroll.rec = 0;\n            }\n            self.revert(false, true);\n            lastRefresh = _getTime();\n            if (snapDelayedCall) {\n                lastSnap = -1; // just so snapping gets re-enabled, clear out any recorded last value\n                // self.isActive && scrollFunc(start + change * prevProgress); // previously this line was here to ensure that when snapping kicks in, it's from the previous progress but in some cases that's not desirable, like an all-page ScrollTrigger when new content gets added to the page, that'd totally change the progress.\n                snapDelayedCall.restart(true);\n            }\n            _refreshing = 0;\n            animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress || 0, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().\n            if (isFirstRefresh || prevProgress !== self.progress || containerAnimation || invalidateOnRefresh) {\n                // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.\n                animation && !isToggle && animation.totalProgress(containerAnimation && start < -0.001 && !prevProgress ? gsap.utils.normalize(start, end, 0) : prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.\n                self.progress = isFirstRefresh || (scroll1 - start) / change === prevProgress ? 0 : prevProgress;\n            }\n            pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));\n            scrubTween && scrubTween.invalidate();\n            if (!isNaN(markerStartOffset)) {\n                // numbers were passed in for the position which are absolute, so instead of just putting the markers at the very bottom of the viewport, we figure out how far they shifted down (it's safe to assume they were originally positioned in closer relation to the trigger element with values like \"top\", \"center\", a percentage or whatever, so we offset that much in the opposite direction to basically revert them to the relative position thy were at previously.\n                markerStartOffset -= gsap.getProperty(markerStartTrigger, direction.p);\n                markerEndOffset -= gsap.getProperty(markerEndTrigger, direction.p);\n                _shiftMarker(markerStartTrigger, direction, markerStartOffset);\n                _shiftMarker(markerStart, direction, markerStartOffset - (pinOffset || 0));\n                _shiftMarker(markerEndTrigger, direction, markerEndOffset);\n                _shiftMarker(markerEnd, direction, markerEndOffset - (pinOffset || 0));\n            }\n            isFirstRefresh && !_refreshingAll && self.update(); // edge case - when you reload a page when it's already scrolled down, some browsers fire a \"scroll\" event before DOMContentLoaded, triggering an updateAll(). If we don't update the self.progress as part of refresh(), then when it happens next, it may record prevProgress as 0 when it really shouldn't, potentially causing a callback in an animation to fire again.\n            if (onRefresh && !_refreshingAll && !executingOnRefresh) {\n                // when refreshing all, we do extra work to correct pinnedContainer sizes and ensure things don't exceed the maxScroll, so we should do all the refreshes at the end after all that work so that the start/end values are corrected.\n                executingOnRefresh = true;\n                onRefresh(self);\n                executingOnRefresh = false;\n            }\n        };\n        self.getVelocity = function() {\n            return (scrollFunc() - scroll2) / (_getTime() - _time2) * 1000 || 0;\n        };\n        self.endAnimation = function() {\n            _endAnimation(self.callbackAnimation);\n            if (animation) {\n                scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);\n            }\n        };\n        self.labelToScroll = function(label) {\n            return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;\n        };\n        self.getTrailing = function(name) {\n            var i = _triggers.indexOf(self), a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);\n            return (_isString(name) ? a.filter(function(t) {\n                return t.vars.preventOverlaps === name;\n            }) : a).filter(function(t) {\n                return self.direction > 0 ? t.end <= start : t.start >= end;\n            });\n        };\n        self.update = function(reset, recordVelocity, forceFake) {\n            if (containerAnimation && !forceFake && !reset) {\n                return;\n            }\n            var scroll = _refreshingAll === true ? prevScroll : self.scroll(), p = reset ? 0 : (scroll - start) / change, clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0, prevProgress = self.progress, isActive, wasActive, toggleState, action, stateChanged, toggled, isAtMax, isTakingAction;\n            if (recordVelocity) {\n                scroll2 = scroll1;\n                scroll1 = containerAnimation ? scrollFunc() : scroll;\n                if (snap) {\n                    snap2 = snap1;\n                    snap1 = animation && !isToggle ? animation.totalProgress() : clipped;\n                }\n            } // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).\n            if (anticipatePin && pin && !_refreshing && !_startup && _lastScrollTime) {\n                if (!clipped && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {\n                    clipped = 0.0001;\n                } else if (clipped === 1 && end > scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {\n                    clipped = 0.9999;\n                }\n            }\n            if (clipped !== prevProgress && self.enabled) {\n                isActive = self.isActive = !!clipped && clipped < 1;\n                wasActive = !!prevProgress && prevProgress < 1;\n                toggled = isActive !== wasActive;\n                stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)\n                self.direction = clipped > prevProgress ? 1 : -1;\n                self.progress = clipped;\n                if (stateChanged && !_refreshing) {\n                    toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.\n                    if (isToggle) {\n                        action = !toggled && toggleActions[toggleState + 1] !== \"none\" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the \"enter\" action, we should switch to the \"leave\" in this case (but only if one is defined)\n                        isTakingAction = animation && (action === \"complete\" || action === \"reset\" || action in animation);\n                    }\n                }\n                preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function(t) {\n                    return t.endAnimation();\n                }));\n                if (!isToggle) {\n                    if (scrubTween && !_refreshing && !_startup) {\n                        scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start); // if there's a scrub on both the container animation and this one (or a ScrollSmoother), the update order would cause this one not to have rendered yet, so it wouldn't make any progress before we .restart() it heading toward the new progress so it'd appear stuck thus we force a render here.\n                        if (scrubTween.resetTo) {\n                            scrubTween.resetTo(\"totalProgress\", clipped, animation._tTime / animation._tDur);\n                        } else {\n                            // legacy support (courtesy), before 3.10.0\n                            scrubTween.vars.totalProgress = clipped;\n                            scrubTween.invalidate().restart();\n                        }\n                    } else if (animation) {\n                        animation.totalProgress(clipped, !!(_refreshing && (lastRefresh || reset)));\n                    }\n                }\n                if (pin) {\n                    reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);\n                    if (!useFixedPosition) {\n                        pinSetter(_round(pinStart + pinChange * clipped));\n                    } else if (stateChanged) {\n                        isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)\n                        if (pinReparent) {\n                            if (!reset && (isActive || isAtMax)) {\n                                var bounds = _getBounds(pin, true), _offset = scroll - start;\n                                _reparent(pin, _body, bounds.top + (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? _offset : 0) + _px, bounds.left + (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? 0 : _offset) + _px);\n                            } else {\n                                _reparent(pin, spacer);\n                            }\n                        }\n                        _setState(isActive || isAtMax ? pinActiveState : pinState);\n                        pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));\n                    }\n                }\n                snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);\n                toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function(el) {\n                    return el.classList[isActive || once ? \"add\" : \"remove\"](toggleClass.className);\n                }); // classes could affect positioning, so do it even if reset or refreshing is true.\n                onUpdate && !isToggle && !reset && onUpdate(self);\n                if (stateChanged && !_refreshing) {\n                    if (isToggle) {\n                        if (isTakingAction) {\n                            if (action === \"complete\") {\n                                animation.pause().totalProgress(1);\n                            } else if (action === \"reset\") {\n                                animation.restart(true).pause();\n                            } else if (action === \"restart\") {\n                                animation.restart(true);\n                            } else {\n                                animation[action]();\n                            }\n                        }\n                        onUpdate && onUpdate(self);\n                    }\n                    if (toggled || !_limitCallbacks) {\n                        // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.\n                        onToggle && toggled && _callback(self, onToggle);\n                        callbacks[toggleState] && _callback(self, callbacks[toggleState]);\n                        once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn't be called again if once is true.\n                        if (!toggled) {\n                            // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order\n                            toggleState = clipped === 1 ? 1 : 3;\n                            callbacks[toggleState] && _callback(self, callbacks[toggleState]);\n                        }\n                    }\n                    if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {\n                        _endAnimation(self.callbackAnimation);\n                        scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === \"reverse\" ? 1 : !clipped, 1);\n                    }\n                } else if (isToggle && onUpdate && !_refreshing) {\n                    onUpdate(self);\n                }\n            } // update absolutely-positioned markers (only if the scroller isn't the viewport)\n            if (markerEndSetter) {\n                var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;\n                markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));\n                markerEndSetter(n);\n            }\n            caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));\n        };\n        self.enable = function(reset, refresh) {\n            if (!self.enabled) {\n                self.enabled = true;\n                _addListener(scroller, \"resize\", _onResize);\n                isViewport || _addListener(scroller, \"scroll\", _onScroll);\n                onRefreshInit && _addListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n                if (reset !== false) {\n                    self.progress = prevProgress = 0;\n                    scroll1 = scroll2 = lastSnap = scrollFunc();\n                }\n                refresh !== false && self.refresh();\n            }\n        };\n        self.getTween = function(snap) {\n            return snap && tweenTo ? tweenTo.tween : scrubTween;\n        };\n        self.setPositions = function(newStart, newEnd, keepClamp, pinOffset) {\n            // doesn't persist after refresh()! Intended to be a way to override values that were set during refresh(), like you could set it in onRefresh()\n            if (containerAnimation) {\n                // convert ratios into scroll positions. Remember, start/end values on ScrollTriggers that have a containerAnimation refer to the time (in seconds), NOT scroll positions.\n                var st = containerAnimation.scrollTrigger, duration = containerAnimation.duration(), _change = st.end - st.start;\n                newStart = st.start + _change * newStart / duration;\n                newEnd = st.start + _change * newEnd / duration;\n            }\n            self.refresh(false, false, {\n                start: _keepClamp(newStart, keepClamp && !!self._startClamp),\n                end: _keepClamp(newEnd, keepClamp && !!self._endClamp)\n            }, pinOffset);\n            self.update();\n        };\n        self.adjustPinSpacing = function(amount) {\n            if (spacerState && amount) {\n                var i = spacerState.indexOf(direction.d) + 1;\n                spacerState[i] = parseFloat(spacerState[i]) + amount + _px;\n                spacerState[1] = parseFloat(spacerState[1]) + amount + _px;\n                _setState(spacerState);\n            }\n        };\n        self.disable = function(reset, allowAnimation) {\n            if (self.enabled) {\n                reset !== false && self.revert(true, true);\n                self.enabled = self.isActive = false;\n                allowAnimation || scrubTween && scrubTween.pause();\n                prevScroll = 0;\n                pinCache && (pinCache.uncache = 1);\n                onRefreshInit && _removeListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n                if (snapDelayedCall) {\n                    snapDelayedCall.pause();\n                    tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);\n                }\n                if (!isViewport) {\n                    var i = _triggers.length;\n                    while(i--){\n                        if (_triggers[i].scroller === scroller && _triggers[i] !== self) {\n                            return; //don't remove the listeners if there are still other triggers referencing it.\n                        }\n                    }\n                    _removeListener(scroller, \"resize\", _onResize);\n                    isViewport || _removeListener(scroller, \"scroll\", _onScroll);\n                }\n            }\n        };\n        self.kill = function(revert, allowAnimation) {\n            self.disable(revert, allowAnimation);\n            scrubTween && !allowAnimation && scrubTween.kill();\n            id && delete _ids[id];\n            var i = _triggers.indexOf(self);\n            i >= 0 && _triggers.splice(i, 1);\n            i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...\n            // if no other ScrollTrigger instances of the same scroller are found, wipe out any recorded scroll position. Otherwise, in a single page application, for example, it could maintain scroll position when it really shouldn't.\n            i = 0;\n            _triggers.forEach(function(t) {\n                return t.scroller === self.scroller && (i = 1);\n            });\n            i || _refreshingAll || (self.scroll.rec = 0);\n            if (animation) {\n                animation.scrollTrigger = null;\n                revert && animation.revert({\n                    kill: false\n                });\n                allowAnimation || animation.kill();\n            }\n            markerStart && [\n                markerStart,\n                markerEnd,\n                markerStartTrigger,\n                markerEndTrigger\n            ].forEach(function(m) {\n                return m.parentNode && m.parentNode.removeChild(m);\n            });\n            _primary === self && (_primary = 0);\n            if (pin) {\n                pinCache && (pinCache.uncache = 1);\n                i = 0;\n                _triggers.forEach(function(t) {\n                    return t.pin === pin && i++;\n                });\n                i || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.\n            }\n            vars.onKill && vars.onKill(self);\n        };\n        _triggers.push(self);\n        self.enable(false, false);\n        customRevertReturn && customRevertReturn(self);\n        if (animation && animation.add && !change) {\n            // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If \"change\" is defined, we know it must be re-enabling, thus we can refresh() right away.\n            var updateFunc = self.update; // some browsers may fire a scroll event BEFORE a tick elapses and/or the DOMContentLoaded fires. So there's a chance update() will be called BEFORE a refresh() has happened on a Timeline-attached ScrollTrigger which means the start/end won't be calculated yet. We don't want to add conditional logic inside the update() method (like check to see if end is defined and if not, force a refresh()) because that's a function that gets hit a LOT (performance). So we swap out the real update() method for this one that'll re-attach it the first time it gets called and of course forces a refresh().\n            self.update = function() {\n                self.update = updateFunc;\n                start || end || self.refresh();\n            };\n            gsap.delayedCall(0.01, self.update);\n            change = 0.01;\n            start = end = 0;\n        } else {\n            self.refresh();\n        }\n        pin && _queueRefreshAll(); // pinning could affect the positions of other things, so make sure we queue a full refresh()\n    };\n    ScrollTrigger.register = function register(core) {\n        if (!_coreInitted) {\n            gsap = core || _getGSAP();\n            _windowExists() && window.document && ScrollTrigger.enable();\n            _coreInitted = _enabled;\n        }\n        return _coreInitted;\n    };\n    ScrollTrigger.defaults = function defaults(config) {\n        if (config) {\n            for(var p in config){\n                _defaults[p] = config[p];\n            }\n        }\n        return _defaults;\n    };\n    ScrollTrigger.disable = function disable(reset, kill) {\n        _enabled = 0;\n        _triggers.forEach(function(trigger) {\n            return trigger[kill ? \"kill\" : \"disable\"](reset);\n        });\n        _removeListener(_win, \"wheel\", _onScroll);\n        _removeListener(_doc, \"scroll\", _onScroll);\n        clearInterval(_syncInterval);\n        _removeListener(_doc, \"touchcancel\", _passThrough);\n        _removeListener(_body, \"touchstart\", _passThrough);\n        _multiListener(_removeListener, _doc, \"pointerdown,touchstart,mousedown\", _pointerDownHandler);\n        _multiListener(_removeListener, _doc, \"pointerup,touchend,mouseup\", _pointerUpHandler);\n        _resizeDelay.kill();\n        _iterateAutoRefresh(_removeListener);\n        for(var i = 0; i < _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.length; i += 3){\n            _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 1]);\n            _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 2]);\n        }\n    };\n    ScrollTrigger.enable = function enable() {\n        _win = window;\n        _doc = document;\n        _docEl = _doc.documentElement;\n        _body = _doc.body;\n        if (gsap) {\n            _toArray = gsap.utils.toArray;\n            _clamp = gsap.utils.clamp;\n            _context = gsap.core.context || _passThrough;\n            _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;\n            _scrollRestoration = _win.history.scrollRestoration || \"auto\";\n            _lastScroll = _win.pageYOffset;\n            gsap.core.globals(\"ScrollTrigger\", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a \"name\" property.\n            if (_body) {\n                _enabled = 1;\n                _div100vh = document.createElement(\"div\"); // to solve mobile browser address bar show/hide resizing, we shouldn't rely on window.innerHeight. Instead, use a <div> with its height set to 100vh and measure that since that's what the scrolling is based on anyway and it's not affected by address bar showing/hiding.\n                _div100vh.style.height = \"100vh\";\n                _div100vh.style.position = \"absolute\";\n                _refresh100vh();\n                _rafBugFix();\n                _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.register(gsap); // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.\n                ScrollTrigger.isTouch = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch;\n                _fixIOSBug = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent); // since 2017, iOS has had a bug that causes event.clientX/Y to be inaccurate when a scroll occurs, thus we must alternate ignoring every other touchmove event to work around it. See https://bugs.webkit.org/show_bug.cgi?id=181954 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503\n                _ignoreMobileResize = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch === 1;\n                _addListener(_win, \"wheel\", _onScroll); // mostly for 3rd party smooth scrolling libraries.\n                _root = [\n                    _win,\n                    _doc,\n                    _docEl,\n                    _body\n                ];\n                if (gsap.matchMedia) {\n                    ScrollTrigger.matchMedia = function(vars) {\n                        var mm = gsap.matchMedia(), p;\n                        for(p in vars){\n                            mm.add(p, vars[p]);\n                        }\n                        return mm;\n                    };\n                    gsap.addEventListener(\"matchMediaInit\", function() {\n                        return _revertAll();\n                    });\n                    gsap.addEventListener(\"matchMediaRevert\", function() {\n                        return _revertRecorded();\n                    });\n                    gsap.addEventListener(\"matchMedia\", function() {\n                        _refreshAll(0, 1);\n                        _dispatch(\"matchMedia\");\n                    });\n                    gsap.matchMedia(\"(orientation: portrait)\", function() {\n                        // when orientation changes, we should take new base measurements for the ignoreMobileResize feature.\n                        _setBaseDimensions();\n                        return _setBaseDimensions;\n                    });\n                } else {\n                    console.warn(\"Requires GSAP 3.11.0 or later\");\n                }\n                _setBaseDimensions();\n                _addListener(_doc, \"scroll\", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!\n                var bodyStyle = _body.style, border = bodyStyle.borderTopStyle, AnimationProto = gsap.core.Animation.prototype, bounds, i;\n                AnimationProto.revert || Object.defineProperty(AnimationProto, \"revert\", {\n                    value: function value() {\n                        return this.time(-0.01, true);\n                    }\n                }); // only for backwards compatibility (Animation.revert() was added after 3.10.4)\n                bodyStyle.borderTopStyle = \"solid\"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.\n                bounds = _getBounds(_body);\n                _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical.m = Math.round(bounds.top + _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding\n                _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal.m = Math.round(bounds.left + _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal.sc()) || 0;\n                border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty(\"border-top-style\"); // TODO: (?) maybe move to leveraging the velocity mechanism in Observer and skip intervals.\n                _syncInterval = setInterval(_sync, 250);\n                gsap.delayedCall(0.5, function() {\n                    return _startup = 0;\n                });\n                _addListener(_doc, \"touchcancel\", _passThrough); // some older Android devices intermittently stop dispatching \"touchmove\" events if we don't listen for \"touchcancel\" on the document.\n                _addListener(_body, \"touchstart\", _passThrough); //works around Safari bug: https://gsap.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n                _multiListener(_addListener, _doc, \"pointerdown,touchstart,mousedown\", _pointerDownHandler);\n                _multiListener(_addListener, _doc, \"pointerup,touchend,mouseup\", _pointerUpHandler);\n                _transformProp = gsap.utils.checkPrefix(\"transform\");\n                _stateProps.push(_transformProp);\n                _coreInitted = _getTime();\n                _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();\n                _autoRefresh = [\n                    _doc,\n                    \"visibilitychange\",\n                    function() {\n                        var w = _win.innerWidth, h = _win.innerHeight;\n                        if (_doc.hidden) {\n                            _prevWidth = w;\n                            _prevHeight = h;\n                        } else if (_prevWidth !== w || _prevHeight !== h) {\n                            _onResize();\n                        }\n                    },\n                    _doc,\n                    \"DOMContentLoaded\",\n                    _refreshAll,\n                    _win,\n                    \"load\",\n                    _refreshAll,\n                    _win,\n                    \"resize\",\n                    _onResize\n                ];\n                _iterateAutoRefresh(_addListener);\n                _triggers.forEach(function(trigger) {\n                    return trigger.enable(0, 1);\n                });\n                for(i = 0; i < _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.length; i += 3){\n                    _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 1]);\n                    _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 2]);\n                }\n            }\n        }\n    };\n    ScrollTrigger.config = function config(vars) {\n        \"limitCallbacks\" in vars && (_limitCallbacks = !!vars.limitCallbacks);\n        var ms = vars.syncInterval;\n        ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);\n        \"ignoreMobileResize\" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);\n        if (\"autoRefreshEvents\" in vars) {\n            _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || \"none\");\n            _ignoreResize = (vars.autoRefreshEvents + \"\").indexOf(\"resize\") === -1;\n        }\n    };\n    ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {\n        var t = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(target), i = _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.indexOf(t), isViewport = _isViewport(t);\n        if (~i) {\n            _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.splice(i, isViewport ? 6 : 2);\n        }\n        if (vars) {\n            isViewport ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.unshift(t, vars);\n        }\n    };\n    ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {\n        _triggers.forEach(function(t) {\n            return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);\n        });\n    };\n    ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {\n        var bounds = (_isString(element) ? (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element) : element).getBoundingClientRect(), offset = bounds[horizontal ? _width : _height] * ratio || 0;\n        return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win.innerHeight;\n    };\n    ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {\n        _isString(element) && (element = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element));\n        var bounds = element.getBoundingClientRect(), size = bounds[horizontal ? _width : _height], offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf(\"%\") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;\n        return horizontal ? (bounds.left + offset) / _win.innerWidth : (bounds.top + offset) / _win.innerHeight;\n    };\n    ScrollTrigger.killAll = function killAll(allowListeners) {\n        _triggers.slice(0).forEach(function(t) {\n            return t.vars.id !== \"ScrollSmoother\" && t.kill();\n        });\n        if (allowListeners !== true) {\n            var listeners = _listeners.killAll || [];\n            _listeners = {};\n            listeners.forEach(function(f) {\n                return f();\n            });\n        }\n    };\n    return ScrollTrigger;\n}();\nScrollTrigger.version = \"3.12.5\";\nScrollTrigger.saveStyles = function(targets) {\n    return targets ? _toArray(targets).forEach(function(target) {\n        // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]\n        if (target && target.style) {\n            var i = _savedStyles.indexOf(target);\n            i >= 0 && _savedStyles.splice(i, 5);\n            _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute(\"transform\"), gsap.core.getCache(target), _context());\n        }\n    }) : _savedStyles;\n};\nScrollTrigger.revert = function(soft, media) {\n    return _revertAll(!soft, media);\n};\nScrollTrigger.create = function(vars, animation) {\n    return new ScrollTrigger(vars, animation);\n};\nScrollTrigger.refresh = function(safe) {\n    return safe ? _onResize() : (_coreInitted || ScrollTrigger.register()) && _refreshAll(true);\n};\nScrollTrigger.update = function(force) {\n    return ++_Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache && _updateAll(force === true ? 2 : 0);\n};\nScrollTrigger.clearScrollMemory = _clearScrollMemory;\nScrollTrigger.maxScroll = function(element, horizontal) {\n    return _maxScroll(element, horizontal ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\n};\nScrollTrigger.getScrollFunc = function(element, horizontal) {\n    return (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)((0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element), horizontal ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\n};\nScrollTrigger.getById = function(id) {\n    return _ids[id];\n};\nScrollTrigger.getAll = function() {\n    return _triggers.filter(function(t) {\n        return t.vars.id !== \"ScrollSmoother\";\n    });\n}; // it's common for people to ScrollTrigger.getAll(t => t.kill()) on page routes, for example, and we don't want it to ruin smooth scrolling by killing the main ScrollSmoother one.\nScrollTrigger.isScrolling = function() {\n    return !!_lastScrollTime;\n};\nScrollTrigger.snapDirectional = _snapDirectional;\nScrollTrigger.addEventListener = function(type, callback) {\n    var a = _listeners[type] || (_listeners[type] = []);\n    ~a.indexOf(callback) || a.push(callback);\n};\nScrollTrigger.removeEventListener = function(type, callback) {\n    var a = _listeners[type], i = a && a.indexOf(callback);\n    i >= 0 && a.splice(i, 1);\n};\nScrollTrigger.batch = function(targets, vars) {\n    var result = [], varsCopy = {}, interval = vars.interval || 0.016, batchMax = vars.batchMax || 1e9, proxyCallback = function proxyCallback(type, callback) {\n        var elements = [], triggers = [], delay = gsap.delayedCall(interval, function() {\n            callback(elements, triggers);\n            elements = [];\n            triggers = [];\n        }).pause();\n        return function(self) {\n            elements.length || delay.restart(true);\n            elements.push(self.trigger);\n            triggers.push(self);\n            batchMax <= elements.length && delay.progress(1);\n        };\n    }, p;\n    for(p in vars){\n        varsCopy[p] = p.substr(0, 2) === \"on\" && _isFunction(vars[p]) && p !== \"onRefreshInit\" ? proxyCallback(p, vars[p]) : vars[p];\n    }\n    if (_isFunction(batchMax)) {\n        batchMax = batchMax();\n        _addListener(ScrollTrigger, \"refresh\", function() {\n            return batchMax = vars.batchMax();\n        });\n    }\n    _toArray(targets).forEach(function(target) {\n        var config = {};\n        for(p in varsCopy){\n            config[p] = varsCopy[p];\n        }\n        config.trigger = target;\n        result.push(ScrollTrigger.create(config));\n    });\n    return result;\n}; // to reduce file size. clamps the scroll and also returns a duration multiplier so that if the scroll gets chopped shorter, the duration gets curtailed as well (otherwise if you're very close to the top of the page, for example, and swipe up really fast, it'll suddenly slow down and take a long time to reach the top).\nvar _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {\n    current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);\n    return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;\n}, _allowNativePanning = function _allowNativePanning(target, direction) {\n    if (direction === true) {\n        target.style.removeProperty(\"touch-action\");\n    } else {\n        target.style.touchAction = direction === true ? \"auto\" : direction ? \"pan-\" + direction + (_Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch ? \" pinch-zoom\" : \"\") : \"none\"; // note: Firefox doesn't support it pinch-zoom properly, at least in addition to a pan-x or pan-y.\n    }\n    target === _docEl && _allowNativePanning(_body, direction);\n}, _overflow = {\n    auto: 1,\n    scroll: 1\n}, _nestedScroll = function _nestedScroll(_ref5) {\n    var event = _ref5.event, target = _ref5.target, axis = _ref5.axis;\n    var node = (event.changedTouches ? event.changedTouches[0] : event).target, cache = node._gsap || gsap.core.getCache(node), time = _getTime(), cs;\n    if (!cache._isScrollT || time - cache._isScrollT > 2000) {\n        // cache for 2 seconds to improve performance.\n        while(node && node !== _body && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))){\n            node = node.parentNode;\n        }\n        cache._isScroll = node && node !== target && !_isViewport(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);\n        cache._isScrollT = time;\n    }\n    if (cache._isScroll || axis === \"x\") {\n        event.stopPropagation();\n        event._gsapAllow = true;\n    }\n}, // capture events on scrollable elements INSIDE the <body> and allow those by calling stopPropagation() when we find a scrollable ancestor\n_inputObserver = function _inputObserver(target, type, inputs, nested) {\n    return _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.create({\n        target: target,\n        capture: true,\n        debounce: false,\n        lockAxis: true,\n        type: type,\n        onWheel: nested = nested && _nestedScroll,\n        onPress: nested,\n        onDrag: nested,\n        onScroll: nested,\n        onEnable: function onEnable() {\n            return inputs && _addListener(_doc, _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.eventTypes[0], _captureInputs, false, true);\n        },\n        onDisable: function onDisable() {\n            return _removeListener(_doc, _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.eventTypes[0], _captureInputs, true);\n        }\n    });\n}, _inputExp = /(input|label|select|textarea)/i, _inputIsFocused, _captureInputs = function _captureInputs(e) {\n    var isInput = _inputExp.test(e.target.tagName);\n    if (isInput || _inputIsFocused) {\n        e._gsapAllow = true;\n        _inputIsFocused = isInput;\n    }\n}, _getScrollNormalizer = function _getScrollNormalizer(vars) {\n    _isObject(vars) || (vars = {});\n    vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;\n    vars.type || (vars.type = \"wheel,touch\");\n    vars.debounce = !!vars.debounce;\n    vars.id = vars.id || \"normalizer\";\n    var _vars2 = vars, normalizeScrollX = _vars2.normalizeScrollX, momentum = _vars2.momentum, allowNestedScroll = _vars2.allowNestedScroll, onRelease = _vars2.onRelease, self, maxY, target = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.target) || _docEl, smoother = gsap.core.globals().ScrollSmoother, smootherInstance = smoother && smoother.get(), content = _fixIOSBug && (vars.content && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()), scrollFuncY = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical), scrollFuncX = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal), scale = 1, initialScale = (_Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch && _win.visualViewport ? _win.visualViewport.scale * _win.visualViewport.width : _win.outerWidth) / _win.innerWidth, wheelRefresh = 0, resolveMomentumDuration = _isFunction(momentum) ? function resolveMomentumDuration() {\n        return momentum(self);\n    } : function() {\n        return momentum || 2.8;\n    }, lastRefreshID, skipTouchMove, inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll), resumeTouchMove = function resumeTouchMove() {\n        return skipTouchMove = false;\n    }, scrollClampX = _passThrough, scrollClampY = _passThrough, updateClamps = function updateClamps() {\n        maxY = _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\n        scrollClampY = _clamp(_fixIOSBug ? 1 : 0, maxY);\n        normalizeScrollX && (scrollClampX = _clamp(0, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal)));\n        lastRefreshID = _refreshID;\n    }, removeContentOffset = function removeContentOffset() {\n        content._gsap.y = _round(parseFloat(content._gsap.y) + scrollFuncY.offset) + \"px\";\n        content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + parseFloat(content._gsap.y) + \", 0, 1)\";\n        scrollFuncY.offset = scrollFuncY.cacheID = 0;\n    }, ignoreDrag = function ignoreDrag() {\n        if (skipTouchMove) {\n            requestAnimationFrame(resumeTouchMove);\n            var offset = _round(self.deltaY / 2), scroll = scrollClampY(scrollFuncY.v - offset);\n            if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {\n                scrollFuncY.offset = scroll - scrollFuncY.v;\n                var y = _round((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);\n                content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + y + \", 0, 1)\";\n                content._gsap.y = y + \"px\";\n                scrollFuncY.cacheID = _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache;\n                _updateAll();\n            }\n            return true;\n        }\n        scrollFuncY.offset && removeContentOffset();\n        skipTouchMove = true;\n    }, tween, startScrollX, startScrollY, onStopDelayedCall, onResize = function onResize() {\n        // if the window resizes, like on an iPhone which Apple FORCES the address bar to show/hide even if we event.preventDefault(), it may be scrolling too far now that the address bar is showing, so we must dynamically adjust the momentum tween.\n        updateClamps();\n        if (tween.isActive() && tween.vars.scrollY > maxY) {\n            scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo(\"scrollY\", maxY);\n        }\n    };\n    content && gsap.set(content, {\n        y: \"+=0\"\n    }); // to ensure there's a cache (element._gsap)\n    vars.ignoreCheck = function(e) {\n        return _fixIOSBug && e.type === \"touchmove\" && ignoreDrag(e) || scale > 1.05 && e.type !== \"touchstart\" || self.isGesturing || e.touches && e.touches.length > 1;\n    };\n    vars.onPress = function() {\n        skipTouchMove = false;\n        var prevScale = scale;\n        scale = _round((_win.visualViewport && _win.visualViewport.scale || 1) / initialScale);\n        tween.pause();\n        prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : \"x\");\n        startScrollX = scrollFuncX();\n        startScrollY = scrollFuncY();\n        updateClamps();\n        lastRefreshID = _refreshID;\n    };\n    vars.onRelease = vars.onGestureStart = function(self, wasDragging) {\n        scrollFuncY.offset && removeContentOffset();\n        if (!wasDragging) {\n            onStopDelayedCall.restart(true);\n        } else {\n            _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++; // make sure we're pulling the non-cached value\n            // alternate algorithm: durX = Math.min(6, Math.abs(self.velocityX / 800)),\tdur = Math.max(durX, Math.min(6, Math.abs(self.velocityY / 800))); dur = dur * (0.4 + (1 - _power4In(dur / 6)) * 0.6)) * (momentumSpeed || 1)\n            var dur = resolveMomentumDuration(), currentScroll, endScroll;\n            if (normalizeScrollX) {\n                currentScroll = scrollFuncX();\n                endScroll = currentScroll + dur * 0.05 * -self.velocityX / 0.227; // the constant .227 is from power4(0.05). velocity is inverted because scrolling goes in the opposite direction.\n                dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal));\n                tween.vars.scrollX = scrollClampX(endScroll);\n            }\n            currentScroll = scrollFuncY();\n            endScroll = currentScroll + dur * 0.05 * -self.velocityY / 0.227; // the constant .227 is from power4(0.05)\n            dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical));\n            tween.vars.scrollY = scrollClampY(endScroll);\n            tween.invalidate().duration(dur).play(0.01);\n            if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {\n                // iOS bug: it'll show the address bar but NOT fire the window \"resize\" event until the animation is done but we must protect against overshoot so we leverage an onUpdate to do so.\n                gsap.to({}, {\n                    onUpdate: onResize,\n                    duration: dur\n                });\n            }\n        }\n        onRelease && onRelease(self);\n    };\n    vars.onWheel = function() {\n        tween._ts && tween.pause();\n        if (_getTime() - wheelRefresh > 1000) {\n            // after 1 second, refresh the clamps otherwise that'll only happen when ScrollTrigger.refresh() is called or for touch-scrolling.\n            lastRefreshID = 0;\n            wheelRefresh = _getTime();\n        }\n    };\n    vars.onChange = function(self, dx, dy, xArray, yArray) {\n        _refreshID !== lastRefreshID && updateClamps();\n        dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1])); // for more precision, we track pointer/touch movement from the start, otherwise it'll drift.\n        if (dy) {\n            scrollFuncY.offset && removeContentOffset();\n            var isTouch = yArray[2] === dy, y = isTouch ? startScrollY + self.startY - self.y : scrollFuncY() + dy - yArray[1], yClamped = scrollClampY(y);\n            isTouch && y !== yClamped && (startScrollY += yClamped - y);\n            scrollFuncY(yClamped);\n        }\n        (dy || dx) && _updateAll();\n    };\n    vars.onEnable = function() {\n        _allowNativePanning(target, normalizeScrollX ? false : \"x\");\n        ScrollTrigger.addEventListener(\"refresh\", onResize);\n        _addListener(_win, \"resize\", onResize);\n        if (scrollFuncY.smooth) {\n            scrollFuncY.target.style.scrollBehavior = \"auto\";\n            scrollFuncY.smooth = scrollFuncX.smooth = false;\n        }\n        inputObserver.enable();\n    };\n    vars.onDisable = function() {\n        _allowNativePanning(target, true);\n        _removeListener(_win, \"resize\", onResize);\n        ScrollTrigger.removeEventListener(\"refresh\", onResize);\n        inputObserver.kill();\n    };\n    vars.lockAxis = vars.lockAxis !== false;\n    self = new _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer(vars);\n    self.iOS = _fixIOSBug; // used in the Observer getCachedScroll() function to work around an iOS bug that wreaks havoc with TouchEvent.clientY if we allow scroll to go all the way back to 0.\n    _fixIOSBug && !scrollFuncY() && scrollFuncY(1); // iOS bug causes event.clientY values to freak out (wildly inaccurate) if the scroll position is exactly 0.\n    _fixIOSBug && gsap.ticker.add(_passThrough); // prevent the ticker from sleeping\n    onStopDelayedCall = self._dc;\n    tween = gsap.to(self, {\n        ease: \"power4\",\n        paused: true,\n        inherit: false,\n        scrollX: normalizeScrollX ? \"+=0.1\" : \"+=0\",\n        scrollY: \"+=0.1\",\n        modifiers: {\n            scrollY: _interruptionTracker(scrollFuncY, scrollFuncY(), function() {\n                return tween.pause();\n            })\n        },\n        onUpdate: _updateAll,\n        onComplete: onStopDelayedCall.vars.onComplete\n    }); // we need the modifier to sense if the scroll position is altered outside of the momentum tween (like with a scrollTo tween) so we can pause() it to prevent conflicts.\n    return self;\n};\nScrollTrigger.sort = function(func) {\n    return _triggers.sort(func || function(a, b) {\n        return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);\n    });\n};\nScrollTrigger.observe = function(vars) {\n    return new _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer(vars);\n};\nScrollTrigger.normalizeScroll = function(vars) {\n    if (typeof vars === \"undefined\") {\n        return _normalizer;\n    }\n    if (vars === true && _normalizer) {\n        return _normalizer.enable();\n    }\n    if (vars === false) {\n        _normalizer && _normalizer.kill();\n        _normalizer = vars;\n        return;\n    }\n    var normalizer = vars instanceof _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer ? vars : _getScrollNormalizer(vars);\n    _normalizer && _normalizer.target === normalizer.target && _normalizer.kill();\n    _isViewport(normalizer.target) && (_normalizer = normalizer);\n    return normalizer;\n};\nScrollTrigger.core = {\n    // smaller file size way to leverage in ScrollSmoother and Observer\n    _getVelocityProp: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getVelocityProp,\n    _inputObserver: _inputObserver,\n    _scrollers: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers,\n    _proxies: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies,\n    bridge: {\n        // when normalizeScroll sets the scroll position (ss = setScroll)\n        ss: function ss() {\n            _lastScrollTime || _dispatch(\"scrollStart\");\n            _lastScrollTime = _getTime();\n        },\n        // a way to get the _refreshing value in Observer\n        ref: function ref() {\n            return _refreshing;\n        }\n    }\n};\n_getGSAP() && gsap.registerPlugin(ScrollTrigger);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9TY3JvbGxUcmlnZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCLEdBQ2tJO0FBRXBKLElBQUlTLE1BQ0FDLGNBQ0FDLE1BQ0FDLE1BQ0FDLFFBQ0FDLE9BQ0FDLE9BQ0FDLGNBQ0FDLFVBQ0FDLFFBQ0FDLFFBQ0FDLGVBQ0FDLGFBQ0FDLGdCQUNBQyxnQkFDQUMsSUFDQUMsWUFDQUMsYUFDQUMsY0FDQUMsT0FDQUMscUJBQ0FDLGVBQ0FDLGFBQ0FDLHFCQUNBQyxtQkFDQUMsa0JBQ0FDLFlBQ0FDLFVBQ0FDLG9CQUNBQyxXQUNBQyxRQUNBQyxhQUNBQyxjQUNBQyxpQkFDQSx1UUFBdVE7QUFDM1FDLFdBQVcsR0FDUEMsV0FBV0MsS0FBS0MsR0FBRyxFQUNuQkMsU0FBU0gsWUFDVEksa0JBQWtCLEdBQ2xCQyxXQUFXLEdBQ1hDLGNBQWMsU0FBU0EsWUFBWUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLElBQUk7SUFDdEQsSUFBSUMsUUFBUUMsVUFBVUosVUFBV0EsQ0FBQUEsTUFBTUssTUFBTSxDQUFDLEdBQUcsT0FBTyxZQUFZTCxNQUFNTSxPQUFPLENBQUMsU0FBUyxDQUFDO0lBQzVGSixJQUFJLENBQUMsTUFBTUQsT0FBTyxRQUFRLEdBQUdFO0lBQzdCLE9BQU9BLFFBQVFILE1BQU1LLE1BQU0sQ0FBQyxHQUFHTCxNQUFNTyxNQUFNLEdBQUcsS0FBS1A7QUFDckQsR0FDSVEsYUFBYSxTQUFTQSxXQUFXUixLQUFLLEVBQUVHLEtBQUs7SUFDL0MsT0FBT0EsU0FBVSxFQUFDQyxVQUFVSixVQUFVQSxNQUFNSyxNQUFNLENBQUMsR0FBRyxPQUFPLFFBQU8sSUFBSyxXQUFXTCxRQUFRLE1BQU1BO0FBQ3BHLEdBQ0lTLGFBQWEsU0FBU0E7SUFDeEIsT0FBT1gsWUFBWVksc0JBQXNCRDtBQUMzQyxHQUNJLHVOQUF1TjtBQUMzTkUsc0JBQXNCLFNBQVNBO0lBQzdCLE9BQU94QyxpQkFBaUI7QUFDMUIsR0FDSXlDLG9CQUFvQixTQUFTQTtJQUMvQixPQUFPekMsaUJBQWlCO0FBQzFCLEdBQ0kwQyxlQUFlLFNBQVNBLGFBQWFDLENBQUM7SUFDeEMsT0FBT0E7QUFDVCxHQUNJQyxTQUFTLFNBQVNBLE9BQU9mLEtBQUs7SUFDaEMsT0FBT2dCLEtBQUtDLEtBQUssQ0FBQ2pCLFFBQVEsVUFBVSxVQUFVO0FBQ2hELEdBQ0lrQixnQkFBZ0IsU0FBU0E7SUFDM0IsT0FBTyxPQUFPQyxXQUFXO0FBQzNCLEdBQ0lDLFdBQVcsU0FBU0E7SUFDdEIsT0FBTzlELFFBQVE0RCxtQkFBb0I1RCxDQUFBQSxPQUFPNkQsT0FBTzdELElBQUksS0FBS0EsS0FBSytELGNBQWMsSUFBSS9EO0FBQ25GLEdBQ0lnRSxjQUFjLFNBQVNBLFlBQVlDLENBQUM7SUFDdEMsT0FBTyxDQUFDLENBQUMsQ0FBQzNELE1BQU0wQyxPQUFPLENBQUNpQjtBQUMxQixHQUNJQyx3QkFBd0IsU0FBU0Esc0JBQXNCQyxpQkFBaUI7SUFDMUUsT0FBTyxDQUFDQSxzQkFBc0IsV0FBV3JDLFNBQVM1QixJQUFJLENBQUMsVUFBVWlFLGtCQUFrQixLQUFLL0QsTUFBTSxDQUFDLFdBQVcrRCxrQkFBa0IsSUFBSTlELEtBQUssQ0FBQyxXQUFXOEQsa0JBQWtCO0FBQ3JLLEdBQ0lDLGlCQUFpQixTQUFTQSxlQUFlQyxPQUFPO0lBQ2xELE9BQU92RSwyREFBYUEsQ0FBQ3VFLFNBQVMsNEJBQTZCTCxDQUFBQSxZQUFZSyxXQUFXO1FBQ2hGQyxZQUFZQyxLQUFLLEdBQUdyRSxLQUFLc0UsVUFBVTtRQUNuQ0YsWUFBWUcsTUFBTSxHQUFHM0M7UUFDckIsT0FBT3dDO0lBQ1QsSUFBSTtRQUNGLE9BQU9JLFdBQVdMO0lBQ3BCO0FBQ0YsR0FDSU0sZUFBZSxTQUFTQSxhQUFhQyxRQUFRLEVBQUVDLFVBQVUsRUFBRUMsSUFBSTtJQUNqRSxJQUFJQyxJQUFJRCxLQUFLQyxDQUFDLEVBQ1ZDLEtBQUtGLEtBQUtFLEVBQUUsRUFDWkMsSUFBSUgsS0FBS0csQ0FBQztJQUNkLE9BQU8sQ0FBQ0EsSUFBSW5GLDJEQUFhQSxDQUFDOEUsVUFBVSx3QkFBdUIsSUFBSztRQUM5RCxPQUFPSyxHQUFHLENBQUNGLEVBQUU7SUFDZixJQUFJO1FBQ0YsT0FBTyxDQUFDRixhQUFhWCxzQkFBc0JjLE1BQU1KLFFBQVEsQ0FBQyxXQUFXSSxHQUFHLEtBQUs7SUFDL0U7QUFDRixHQUNJRSxrQkFBa0IsU0FBU0EsZ0JBQWdCYixPQUFPLEVBQUVRLFVBQVU7SUFDaEUsT0FBTyxDQUFDQSxjQUFjLENBQUNqRixrREFBUUEsQ0FBQ29ELE9BQU8sQ0FBQ3FCLFdBQVdELGVBQWVDLFdBQVc7UUFDM0UsT0FBT0M7SUFDVDtBQUNGLEdBQ0lhLGFBQWEsU0FBU0EsV0FBV2QsT0FBTyxFQUFFZSxLQUFLO0lBQ2pELElBQUlDLElBQUlELE1BQU1DLENBQUMsRUFDWEwsS0FBS0ksTUFBTUosRUFBRSxFQUNiRCxJQUFJSyxNQUFNTCxDQUFDLEVBQ1hFLElBQUlHLE1BQU1ILENBQUM7SUFDZixPQUFPdkIsS0FBSzRCLEdBQUcsQ0FBQyxHQUFHLENBQUNELElBQUksV0FBV0wsRUFBQyxLQUFPQyxDQUFBQSxJQUFJbkYsMkRBQWFBLENBQUN1RSxTQUFTZ0IsRUFBQyxJQUFLSixNQUFNYixlQUFlQyxVQUFVLENBQUNVLEVBQUUsR0FBR2YsWUFBWUssV0FBVyxDQUFDakUsTUFBTSxDQUFDaUYsRUFBRSxJQUFJaEYsS0FBSyxDQUFDZ0YsRUFBRSxJQUFJbkIsc0JBQXNCYyxNQUFNWCxPQUFPLENBQUNnQixFQUFFLEdBQUdoQixPQUFPLENBQUMsV0FBV1csR0FBRztBQUNuTyxHQUNJTyxzQkFBc0IsU0FBU0Esb0JBQW9CQyxJQUFJLEVBQUVDLE1BQU07SUFDakUsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUl4RSxhQUFhK0IsTUFBTSxFQUFFeUMsS0FBSyxFQUFHO1FBQzlDLEVBQUNELFVBQVUsQ0FBQ0EsT0FBT3pDLE9BQU8sQ0FBQzlCLFlBQVksQ0FBQ3dFLElBQUksRUFBRSxNQUFNRixLQUFLdEUsWUFBWSxDQUFDd0UsRUFBRSxFQUFFeEUsWUFBWSxDQUFDd0UsSUFBSSxFQUFFLEVBQUV4RSxZQUFZLENBQUN3RSxJQUFJLEVBQUU7SUFDckg7QUFDRixHQUNJNUMsWUFBWSxTQUFTQSxVQUFVSixLQUFLO0lBQ3RDLE9BQU8sT0FBT0EsVUFBVTtBQUMxQixHQUNJaUQsY0FBYyxTQUFTQSxZQUFZakQsS0FBSztJQUMxQyxPQUFPLE9BQU9BLFVBQVU7QUFDMUIsR0FDSWtELFlBQVksU0FBU0EsVUFBVWxELEtBQUs7SUFDdEMsT0FBTyxPQUFPQSxVQUFVO0FBQzFCLEdBQ0ltRCxZQUFZLFNBQVNBLFVBQVVuRCxLQUFLO0lBQ3RDLE9BQU8sT0FBT0EsVUFBVTtBQUMxQixHQUNJb0QsZ0JBQWdCLFNBQVNBLGNBQWNDLFNBQVMsRUFBRUMsUUFBUSxFQUFFQyxLQUFLO0lBQ25FLE9BQU9GLGFBQWFBLFVBQVVHLFFBQVEsQ0FBQ0YsV0FBVyxJQUFJLE1BQU1DLFNBQVNGLFVBQVVFLEtBQUs7QUFDdEYsR0FDSUUsWUFBWSxTQUFTQSxVQUFVdkQsSUFBSSxFQUFFNEMsSUFBSTtJQUMzQyxJQUFJNUMsS0FBS3dELE9BQU8sRUFBRTtRQUNoQixJQUFJQyxTQUFTekQsS0FBSzBELElBQUksR0FBRzFELEtBQUswRCxJQUFJLENBQUNDLEdBQUcsQ0FBQztZQUNyQyxPQUFPZixLQUFLNUM7UUFDZCxLQUFLNEMsS0FBSzVDO1FBQ1Z5RCxVQUFVQSxPQUFPRyxTQUFTLElBQUs1RCxDQUFBQSxLQUFLNkQsaUJBQWlCLEdBQUdKLE1BQUs7SUFDL0Q7QUFDRixHQUNJSyxPQUFPaEQsS0FBS2lELEdBQUcsRUFDZkMsUUFBUSxRQUNSQyxPQUFPLE9BQ1BDLFNBQVMsU0FDVEMsVUFBVSxVQUNWQyxTQUFTLFNBQ1RDLFVBQVUsVUFDVkMsU0FBUyxTQUNUQyxRQUFRLFFBQ1JDLE9BQU8sT0FDUEMsVUFBVSxVQUNWQyxXQUFXLFdBQ1hDLFVBQVUsVUFDVkMsU0FBUyxTQUNUQyxVQUFVLFVBQ1ZDLE1BQU0sTUFDTkMsb0JBQW9CLFNBQVNBLGtCQUFrQnRELE9BQU87SUFDeEQsT0FBT25FLEtBQUswSCxnQkFBZ0IsQ0FBQ3ZEO0FBQy9CLEdBQ0l3RCxvQkFBb0IsU0FBU0Esa0JBQWtCeEQsT0FBTztJQUN4RCwyR0FBMkc7SUFDM0csSUFBSXlELFdBQVdILGtCQUFrQnRELFNBQVN5RCxRQUFRO0lBRWxEekQsUUFBUTBELEtBQUssQ0FBQ0QsUUFBUSxHQUFHQSxhQUFhLGNBQWNBLGFBQWEsVUFBVUEsV0FBVztBQUN4RixHQUNJRSxlQUFlLFNBQVNBLGFBQWFDLEdBQUcsRUFBRUMsUUFBUTtJQUNwRCxJQUFLLElBQUlDLEtBQUtELFNBQVU7UUFDdEJDLEtBQUtGLE9BQVFBLENBQUFBLEdBQUcsQ0FBQ0UsRUFBRSxHQUFHRCxRQUFRLENBQUNDLEVBQUU7SUFDbkM7SUFFQSxPQUFPRjtBQUNULEdBQ0l2RCxhQUFhLFNBQVNBLFdBQVdMLE9BQU8sRUFBRStELGlCQUFpQjtJQUM3RCxJQUFJQyxRQUFRRCxxQkFBcUJULGtCQUFrQnRELFFBQVEsQ0FBQ3ZELGVBQWUsS0FBSyw4QkFBOEJkLEtBQUtzSSxFQUFFLENBQUNqRSxTQUFTO1FBQzdIa0UsR0FBRztRQUNIQyxHQUFHO1FBQ0hDLFVBQVU7UUFDVkMsVUFBVTtRQUNWQyxVQUFVO1FBQ1ZDLFdBQVc7UUFDWEMsV0FBVztRQUNYQyxPQUFPO1FBQ1BDLE9BQU87UUFDUEMsT0FBTztJQUNULEdBQUc5QyxRQUFRLENBQUMsSUFDUitDLFNBQVM1RSxRQUFRNkUscUJBQXFCO0lBQzFDYixTQUFTQSxNQUFNbkMsUUFBUSxDQUFDLEdBQUdpRCxJQUFJO0lBQy9CLE9BQU9GO0FBQ1QsR0FDSUcsV0FBVyxTQUFTQSxTQUFTL0UsT0FBTyxFQUFFZ0YsS0FBSztJQUM3QyxJQUFJckUsS0FBS3FFLE1BQU1yRSxFQUFFO0lBQ2pCLE9BQU9YLE9BQU8sQ0FBQyxXQUFXVyxHQUFHLElBQUlYLE9BQU8sQ0FBQyxXQUFXVyxHQUFHLElBQUk7QUFDN0QsR0FDSXNFLHNCQUFzQixTQUFTQSxvQkFBb0JDLFFBQVE7SUFDN0QsSUFBSXRFLElBQUksRUFBRSxFQUNOdUUsU0FBU0QsU0FBU0MsTUFBTSxFQUN4QkMsV0FBV0YsU0FBU0UsUUFBUSxJQUM1QnRCO0lBRUosSUFBS0EsS0FBS3FCLE9BQVE7UUFDaEJ2RSxFQUFFeUUsSUFBSSxDQUFDRixNQUFNLENBQUNyQixFQUFFLEdBQUdzQjtJQUNyQjtJQUVBLE9BQU94RTtBQUNULEdBQ0kwRSxtQkFBbUIsU0FBU0EsaUJBQWlCNUQsU0FBUztJQUN4RCxPQUFPLFNBQVVyRCxLQUFLO1FBQ3BCLE9BQU8xQyxLQUFLNEosS0FBSyxDQUFDQyxJQUFJLENBQUNQLG9CQUFvQnZELFlBQVlyRDtJQUN6RDtBQUNGLEdBQ0lvSCxtQkFBbUIsU0FBU0EsaUJBQWlCQyxvQkFBb0I7SUFDbkUsSUFBSUYsT0FBTzdKLEtBQUs0SixLQUFLLENBQUNDLElBQUksQ0FBQ0UsdUJBQ3ZCOUUsSUFBSStFLE1BQU1DLE9BQU8sQ0FBQ0YseUJBQXlCQSxxQkFBcUJHLEtBQUssQ0FBQyxHQUFHQyxJQUFJLENBQUMsU0FBVWxGLENBQUMsRUFBRW1GLENBQUM7UUFDOUYsT0FBT25GLElBQUltRjtJQUNiO0lBQ0EsT0FBT25GLElBQUksU0FBVXZDLEtBQUssRUFBRTJILFNBQVMsRUFBRUMsU0FBUztRQUM5QyxJQUFJQSxjQUFjLEtBQUssR0FBRztZQUN4QkEsWUFBWTtRQUNkO1FBRUEsSUFBSTVFO1FBRUosSUFBSSxDQUFDMkUsV0FBVztZQUNkLE9BQU9SLEtBQUtuSDtRQUNkO1FBRUEsSUFBSTJILFlBQVksR0FBRztZQUNqQjNILFNBQVM0SCxXQUFXLDJHQUEyRztZQUUvSCxJQUFLNUUsSUFBSSxHQUFHQSxJQUFJVCxFQUFFaEMsTUFBTSxFQUFFeUMsSUFBSztnQkFDN0IsSUFBSVQsQ0FBQyxDQUFDUyxFQUFFLElBQUloRCxPQUFPO29CQUNqQixPQUFPdUMsQ0FBQyxDQUFDUyxFQUFFO2dCQUNiO1lBQ0Y7WUFFQSxPQUFPVCxDQUFDLENBQUNTLElBQUksRUFBRTtRQUNqQixPQUFPO1lBQ0xBLElBQUlULEVBQUVoQyxNQUFNO1lBQ1pQLFNBQVM0SDtZQUVULE1BQU81RSxJQUFLO2dCQUNWLElBQUlULENBQUMsQ0FBQ1MsRUFBRSxJQUFJaEQsT0FBTztvQkFDakIsT0FBT3VDLENBQUMsQ0FBQ1MsRUFBRTtnQkFDYjtZQUNGO1FBQ0Y7UUFFQSxPQUFPVCxDQUFDLENBQUMsRUFBRTtJQUNiLElBQUksU0FBVXZDLEtBQUssRUFBRTJILFNBQVMsRUFBRUMsU0FBUztRQUN2QyxJQUFJQSxjQUFjLEtBQUssR0FBRztZQUN4QkEsWUFBWTtRQUNkO1FBRUEsSUFBSUMsVUFBVVYsS0FBS25IO1FBQ25CLE9BQU8sQ0FBQzJILGFBQWEzRyxLQUFLaUQsR0FBRyxDQUFDNEQsVUFBVTdILFNBQVM0SCxhQUFhQyxVQUFVN0gsUUFBUSxNQUFNMkgsWUFBWSxJQUFJRSxVQUFVVixLQUFLUSxZQUFZLElBQUkzSCxRQUFRcUgsdUJBQXVCckgsUUFBUXFIO0lBQzlLO0FBQ0YsR0FDSVMsdUJBQXVCLFNBQVNBLHFCQUFxQmpCLFFBQVE7SUFDL0QsT0FBTyxTQUFVN0csS0FBSyxFQUFFK0gsRUFBRTtRQUN4QixPQUFPWCxpQkFBaUJSLG9CQUFvQkMsV0FBVzdHLE9BQU8rSCxHQUFHSixTQUFTO0lBQzVFO0FBQ0YsR0FDSUssaUJBQWlCLFNBQVNBLGVBQWVsRixJQUFJLEVBQUVuQixPQUFPLEVBQUVzRyxLQUFLLEVBQUVDLFFBQVE7SUFDekUsT0FBT0QsTUFBTUUsS0FBSyxDQUFDLEtBQUtDLE9BQU8sQ0FBQyxTQUFVbkksSUFBSTtRQUM1QyxPQUFPNkMsS0FBS25CLFNBQVMxQixNQUFNaUk7SUFDN0I7QUFDRixHQUNJRyxlQUFlLFNBQVNBLGFBQWExRyxPQUFPLEVBQUUxQixJQUFJLEVBQUU2QyxJQUFJLEVBQUV3RixVQUFVLEVBQUVDLE9BQU87SUFDL0UsT0FBTzVHLFFBQVE2RyxnQkFBZ0IsQ0FBQ3ZJLE1BQU02QyxNQUFNO1FBQzFDMkYsU0FBUyxDQUFDSDtRQUNWQyxTQUFTLENBQUMsQ0FBQ0E7SUFDYjtBQUNGLEdBQ0lHLGtCQUFrQixTQUFTQSxnQkFBZ0IvRyxPQUFPLEVBQUUxQixJQUFJLEVBQUU2QyxJQUFJLEVBQUV5RixPQUFPO0lBQ3pFLE9BQU81RyxRQUFRZ0gsbUJBQW1CLENBQUMxSSxNQUFNNkMsTUFBTSxDQUFDLENBQUN5RjtBQUNuRCxHQUNJSyxpQkFBaUIsU0FBU0EsZUFBZTlGLElBQUksRUFBRStGLEVBQUUsRUFBRUMsVUFBVTtJQUMvREEsYUFBYUEsY0FBY0EsV0FBV0MsWUFBWTtJQUVsRCxJQUFJRCxZQUFZO1FBQ2RoRyxLQUFLK0YsSUFBSSxTQUFTQztRQUNsQmhHLEtBQUsrRixJQUFJLGFBQWFDO0lBQ3hCO0FBQ0YsR0FDSUUsa0JBQWtCO0lBQ3BCQyxZQUFZO0lBQ1pDLFVBQVU7SUFDVkMsUUFBUTtJQUNSQyxVQUFVO0lBQ1ZDLFlBQVk7QUFDZCxHQUNJQyxZQUFZO0lBQ2RDLGVBQWU7SUFDZkMsZUFBZTtBQUNqQixHQUNJQyxZQUFZO0lBQ2RDLEtBQUs7SUFDTEMsTUFBTTtJQUNOQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsT0FBTztBQUNULEdBQ0lDLGNBQWMsU0FBU0EsWUFBWS9KLEtBQUssRUFBRWdLLElBQUk7SUFDaEQsSUFBSTVKLFVBQVVKLFFBQVE7UUFDcEIsSUFBSWlLLFVBQVVqSyxNQUFNTSxPQUFPLENBQUMsTUFDeEI0SixXQUFXLENBQUNELFVBQVUsQ0FBRWpLLENBQUFBLE1BQU1tSyxNQUFNLENBQUNGLFVBQVUsS0FBSyxLQUFLRyxXQUFXcEssTUFBTUssTUFBTSxDQUFDNEosVUFBVSxNQUFNO1FBRXJHLElBQUksQ0FBQ0EsU0FBUztZQUNaakssTUFBTU0sT0FBTyxDQUFDLE9BQU8ySixXQUFZQyxDQUFBQSxZQUFZRixPQUFPLEdBQUU7WUFDdERoSyxRQUFRQSxNQUFNSyxNQUFNLENBQUMsR0FBRzRKLFVBQVU7UUFDcEM7UUFFQWpLLFFBQVFrSyxXQUFZbEssQ0FBQUEsU0FBU3lKLFlBQVlBLFNBQVMsQ0FBQ3pKLE1BQU0sR0FBR2dLLE9BQU8sQ0FBQ2hLLE1BQU1NLE9BQU8sQ0FBQyxPQUFPOEosV0FBV3BLLFNBQVNnSyxPQUFPLE1BQU1JLFdBQVdwSyxVQUFVO0lBQ2pKO0lBRUEsT0FBT0E7QUFDVCxHQUNJcUssZ0JBQWdCLFNBQVNBLGNBQWNwSyxJQUFJLEVBQUVxSyxJQUFJLEVBQUVDLFNBQVMsRUFBRTVDLFNBQVMsRUFBRTZDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxZQUFZLEVBQUVDLGtCQUFrQjtJQUMxSCxJQUFJMUIsYUFBYXVCLE1BQU12QixVQUFVLEVBQzdCQyxXQUFXc0IsTUFBTXRCLFFBQVEsRUFDekJFLFdBQVdvQixNQUFNcEIsUUFBUSxFQUN6QkQsU0FBU3FCLE1BQU1yQixNQUFNLEVBQ3JCRSxhQUFhbUIsTUFBTW5CLFVBQVU7SUFFakMsSUFBSTlILElBQUk5RCxLQUFLbU4sYUFBYSxDQUFDLFFBQ3ZCQyxtQkFBbUJ2SixZQUFZaUosY0FBY25OLDJEQUFhQSxDQUFDbU4sV0FBVyxlQUFlLFNBQ3JGTyxhQUFhN0ssS0FBS0ssT0FBTyxDQUFDLGdCQUFnQixDQUFDLEdBQzNDeUssU0FBU0YsbUJBQW1CbE4sUUFBUTRNLFdBQ3BDUyxVQUFVL0ssS0FBS0ssT0FBTyxDQUFDLGFBQWEsQ0FBQyxHQUNyQzJLLFFBQVFELFVBQVUvQixhQUFhQyxVQUMvQmdDLE1BQU0sa0JBQWtCRCxRQUFRLGdCQUFnQjdCLFdBQVcsWUFBWTZCLFFBQVEsa0JBQWtCNUIsYUFBYTtJQUVsSDZCLE9BQU8sY0FBZSxFQUFDSixjQUFjSCxrQkFBaUIsS0FBTUUsbUJBQW1CLFdBQVcsV0FBVTtJQUNuR0MsQ0FBQUEsY0FBY0gsc0JBQXNCLENBQUNFLGdCQUFlLEtBQU9LLENBQUFBLE9BQU8sQ0FBQ3ZELGNBQWM1SyxtREFBU0EsR0FBR3FILFNBQVNDLE9BQU0sSUFBSyxNQUFPb0csQ0FBQUEsU0FBU0wsV0FBV2pCLE9BQU0sSUFBSyxLQUFJO0lBQzVKdUIsZ0JBQWlCUSxDQUFBQSxPQUFPLGlEQUFpRFIsYUFBYVMsV0FBVyxHQUFHLEtBQUk7SUFDeEc1SixFQUFFNkosUUFBUSxHQUFHSjtJQUNiekosRUFBRThKLFlBQVksQ0FBQyxTQUFTLGlCQUFpQnBMLE9BQVFxSyxDQUFBQSxPQUFPLGFBQWFBLE9BQU8sRUFBQztJQUM3RS9JLEVBQUU4RCxLQUFLLENBQUNpRyxPQUFPLEdBQUdKO0lBQ2xCM0osRUFBRWdLLFNBQVMsR0FBR2pCLFFBQVFBLFNBQVMsSUFBSXJLLE9BQU8sTUFBTXFLLE9BQU9ySztJQUN2RDhLLE9BQU9TLFFBQVEsQ0FBQyxFQUFFLEdBQUdULE9BQU9VLFlBQVksQ0FBQ2xLLEdBQUd3SixPQUFPUyxRQUFRLENBQUMsRUFBRSxJQUFJVCxPQUFPVyxXQUFXLENBQUNuSztJQUNyRkEsRUFBRW9LLE9BQU8sR0FBR3BLLENBQUMsQ0FBQyxXQUFXb0csVUFBVWlFLEVBQUUsQ0FBQ3RKLEVBQUUsQ0FBQztJQUV6Q3VKLGdCQUFnQnRLLEdBQUcsR0FBR29HLFdBQVdxRDtJQUVqQyxPQUFPeko7QUFDVCxHQUNJc0ssa0JBQWtCLFNBQVNBLGdCQUFnQkMsTUFBTSxFQUFFQyxLQUFLLEVBQUVwRSxTQUFTLEVBQUVxRSxPQUFPO0lBQzlFLElBQUlDLE9BQU87UUFDVEMsU0FBUztJQUNYLEdBQ0lDLE9BQU94RSxTQUFTLENBQUNxRSxVQUFVLFFBQVEsS0FBSyxFQUN4Q0ksZUFBZXpFLFNBQVMsQ0FBQ3FFLFVBQVUsT0FBTyxNQUFNO0lBQ3BERixPQUFPTyxVQUFVLEdBQUdMO0lBQ3BCQyxJQUFJLENBQUN0RSxVQUFVcEYsQ0FBQyxHQUFHLFVBQVUsR0FBR3lKLFVBQVUsQ0FBQyxNQUFNO0lBQ2pEQyxJQUFJLENBQUN0RSxVQUFVcEYsQ0FBQyxDQUFDLEdBQUd5SixVQUFVLFFBQVE7SUFDdENDLElBQUksQ0FBQyxXQUFXRSxPQUFPckgsT0FBTyxHQUFHO0lBQ2pDbUgsSUFBSSxDQUFDLFdBQVdHLGVBQWV0SCxPQUFPLEdBQUc7SUFDekNtSCxJQUFJLENBQUN0RSxVQUFVbEMsQ0FBQyxDQUFDLEdBQUdzRyxRQUFRO0lBQzVCek8sS0FBS2dQLEdBQUcsQ0FBQ1IsUUFBUUc7QUFDbkIsR0FDSU0sWUFBWSxFQUFFLEVBQ2RDLE9BQU8sQ0FBQyxHQUNSQyxRQUNBQyxRQUFRLFNBQVNBO0lBQ25CLE9BQU9qTixhQUFhSSxrQkFBa0IsTUFBTzRNLENBQUFBLFVBQVdBLENBQUFBLFNBQVMvTCxzQkFBc0JpTSxXQUFVLENBQUM7QUFDcEcsR0FDSUMsWUFBWSxTQUFTQTtJQUN2Qiw0Y0FBNGM7SUFDNWMsSUFBSSxDQUFDaE8sZUFBZSxDQUFDQSxZQUFZaU8sU0FBUyxJQUFJak8sWUFBWWtPLE1BQU0sR0FBR25QLE1BQU1vUCxXQUFXLEVBQUU7UUFDcEYsbURBQW1EO1FBQ25EOVAsb0RBQVVBLENBQUMrUCxLQUFLO1FBRWhCLElBQUlwTyxhQUFhO1lBQ2Y2TixVQUFXQSxDQUFBQSxTQUFTL0wsc0JBQXNCaU0sV0FBVTtRQUN0RCxPQUFPO1lBQ0xBLGNBQWMsc1JBQXNSO1FBRXRTO1FBRUE5TSxtQkFBbUJvTixVQUFVO1FBQzdCcE4sa0JBQWtCSjtJQUNwQjtBQUNGLEdBQ0l5TixxQkFBcUIsU0FBU0E7SUFDaENuTyxtQkFBbUJ2QixLQUFLc0UsVUFBVTtJQUNsQ2hELG9CQUFvQnRCLEtBQUsyUCxXQUFXO0FBQ3RDLEdBQ0lDLFlBQVksU0FBU0E7SUFDdkJuUSxvREFBVUEsQ0FBQytQLEtBQUs7SUFDaEIsQ0FBQzlPLGVBQWUsQ0FBQ1MsaUJBQWlCLENBQUNsQixLQUFLNFAsaUJBQWlCLElBQUksQ0FBQzVQLEtBQUs2UCx1QkFBdUIsSUFBSyxFQUFDek8sdUJBQXVCRSxxQkFBcUJ2QixLQUFLc0UsVUFBVSxJQUFJZCxLQUFLaUQsR0FBRyxDQUFDekcsS0FBSzJQLFdBQVcsR0FBR3JPLHFCQUFxQnRCLEtBQUsyUCxXQUFXLEdBQUcsSUFBRyxLQUFNdFAsYUFBYTBQLE9BQU8sQ0FBQztBQUNuUSxHQUNJLHdDQUF3QztBQUM1Q0MsYUFBYSxDQUFDLEdBQ1ZDLGNBQWMsRUFBRSxFQUNoQkMsZUFBZSxTQUFTQTtJQUMxQixPQUFPaEYsZ0JBQWdCaUYsZUFBZSxhQUFhRCxpQkFBaUJFLFlBQVk7QUFDbEYsR0FDSVgsWUFBWSxTQUFTQSxVQUFVaE4sSUFBSTtJQUNyQyxPQUFPdU4sVUFBVSxDQUFDdk4sS0FBSyxJQUFJdU4sVUFBVSxDQUFDdk4sS0FBSyxDQUFDNE4sR0FBRyxDQUFDLFNBQVVDLENBQUM7UUFDekQsT0FBT0E7SUFDVCxNQUFNTDtBQUNSLEdBQ0lNLGVBQWUsRUFBRSxFQUNqQiwyTkFBMk47QUFDL05DLGtCQUFrQixTQUFTQSxnQkFBZ0JDLEtBQUs7SUFDOUMsSUFBSyxJQUFJakwsSUFBSSxHQUFHQSxJQUFJK0ssYUFBYXhOLE1BQU0sRUFBRXlDLEtBQUssRUFBRztRQUMvQyxJQUFJLENBQUNpTCxTQUFTRixZQUFZLENBQUMvSyxJQUFJLEVBQUUsSUFBSStLLFlBQVksQ0FBQy9LLElBQUksRUFBRSxDQUFDa0wsS0FBSyxLQUFLRCxPQUFPO1lBQ3hFRixZQUFZLENBQUMvSyxFQUFFLENBQUNxQyxLQUFLLENBQUNpRyxPQUFPLEdBQUd5QyxZQUFZLENBQUMvSyxJQUFJLEVBQUU7WUFDbkQrSyxZQUFZLENBQUMvSyxFQUFFLENBQUNtTCxPQUFPLElBQUlKLFlBQVksQ0FBQy9LLEVBQUUsQ0FBQ3FJLFlBQVksQ0FBQyxhQUFhMEMsWUFBWSxDQUFDL0ssSUFBSSxFQUFFLElBQUk7WUFDNUYrSyxZQUFZLENBQUMvSyxJQUFJLEVBQUUsQ0FBQ29MLE9BQU8sR0FBRztRQUNoQztJQUNGO0FBQ0YsR0FDSUMsYUFBYSxTQUFTQSxXQUFXNUgsSUFBSSxFQUFFd0gsS0FBSztJQUM5QyxJQUFJSztJQUVKLElBQUtqUSxLQUFLLEdBQUdBLEtBQUtrTyxVQUFVaE0sTUFBTSxFQUFFbEMsS0FBTTtRQUN4Q2lRLFVBQVUvQixTQUFTLENBQUNsTyxHQUFHO1FBRXZCLElBQUlpUSxXQUFZLEVBQUNMLFNBQVNLLFFBQVExSyxJQUFJLEtBQUtxSyxLQUFJLEdBQUk7WUFDakQsSUFBSXhILE1BQU07Z0JBQ1I2SCxRQUFRN0gsSUFBSSxDQUFDO1lBQ2YsT0FBTztnQkFDTDZILFFBQVFDLE1BQU0sQ0FBQyxNQUFNO1lBQ3ZCO1FBQ0Y7SUFDRjtJQUVBbFAsY0FBYztJQUNkNE8sU0FBU0QsZ0JBQWdCQztJQUN6QkEsU0FBU2hCLFVBQVU7QUFDckIsR0FDSXVCLHFCQUFxQixTQUFTQSxtQkFBbUJDLGlCQUFpQixFQUFFQyxLQUFLO0lBQzNFLHdVQUF3VTtJQUN4VXpSLG9EQUFVQSxDQUFDK1AsS0FBSztJQUNmMEIsQ0FBQUEsU0FBUyxDQUFDQyxjQUFhLEtBQU0xUixvREFBVUEsQ0FBQ21MLE9BQU8sQ0FBQyxTQUFVN0MsR0FBRztRQUM1RCxPQUFPdEMsWUFBWXNDLFFBQVFBLElBQUlxSixPQUFPLE1BQU9ySixDQUFBQSxJQUFJc0osR0FBRyxHQUFHO0lBQ3pEO0lBQ0F6TyxVQUFVcU8sc0JBQXVCalIsQ0FBQUEsS0FBS3NSLE9BQU8sQ0FBQ0wsaUJBQWlCLEdBQUd2UCxxQkFBcUJ1UCxpQkFBZ0I7QUFDekcsR0FDSUUsZ0JBQ0FJLGFBQWEsR0FDYkMsaUJBQ0FDLG1CQUFtQixTQUFTQTtJQUM5QixvUUFBb1E7SUFDcFEsSUFBSUQsb0JBQW9CRCxZQUFZO1FBQ2xDLElBQUlHLEtBQUtGLGtCQUFrQkQ7UUFDM0JyTyxzQkFBc0I7WUFDcEIsT0FBT3dPLE9BQU9ILGNBQWNuQixZQUFZO1FBQzFDO0lBQ0Y7QUFDRixHQUNJdUIsZ0JBQWdCLFNBQVNBO0lBQzNCeFIsTUFBTStOLFdBQVcsQ0FBQ3ZNO0lBRWxCQyxTQUFTLENBQUNSLGVBQWVPLFVBQVVpUSxZQUFZLElBQUk1UixLQUFLMlAsV0FBVztJQUVuRXhQLE1BQU0wUixXQUFXLENBQUNsUTtBQUNwQixHQUNJbVEsa0JBQWtCLFNBQVNBLGdCQUFnQkMsSUFBSTtJQUNqRCxPQUFPelIsU0FBUyxnR0FBZ0dzSyxPQUFPLENBQUMsU0FBVVMsRUFBRTtRQUNsSSxPQUFPQSxHQUFHeEQsS0FBSyxDQUFDNkcsT0FBTyxHQUFHcUQsT0FBTyxTQUFTO0lBQzVDO0FBQ0YsR0FDSTNCLGNBQWMsU0FBU0EsWUFBWWMsS0FBSyxFQUFFYyxVQUFVO0lBQ3RELElBQUkzUCxtQkFBbUIsQ0FBQzZPLFNBQVMsQ0FBQ3JQLGFBQWE7UUFDN0NnSixhQUFhc0YsZUFBZSxhQUFhRDtRQUV6QztJQUNGO0lBRUF5QjtJQUVBUixpQkFBaUJoQixjQUFjOEIsWUFBWSxHQUFHO0lBRTlDeFMsb0RBQVVBLENBQUNtTCxPQUFPLENBQUMsU0FBVTdDLEdBQUc7UUFDOUIsT0FBT3RDLFlBQVlzQyxRQUFRLEVBQUVBLElBQUlxSixPQUFPLElBQUtySixDQUFBQSxJQUFJc0osR0FBRyxHQUFHdEosS0FBSTtJQUM3RCxJQUFJLGdOQUFnTjtJQUdwTixJQUFJbUssZUFBZXpDLFVBQVU7SUFFN0J4TyxTQUFTa1AsY0FBY2xHLElBQUk7SUFDM0IrSCxjQUFjbkI7SUFFZHBSLG9EQUFVQSxDQUFDbUwsT0FBTyxDQUFDLFNBQVU3QyxHQUFHO1FBQzlCLElBQUl0QyxZQUFZc0MsTUFBTTtZQUNwQkEsSUFBSW9LLE1BQU0sSUFBS3BLLENBQUFBLElBQUlxSyxNQUFNLENBQUN2SyxLQUFLLENBQUN3SyxjQUFjLEdBQUcsTUFBSyxHQUFJLDhCQUE4QjtZQUV4RnRLLElBQUk7UUFDTjtJQUNGO0lBRUFnSCxVQUFVL0UsS0FBSyxDQUFDLEdBQUdZLE9BQU8sQ0FBQyxTQUFVMEgsQ0FBQztRQUNwQyxPQUFPQSxFQUFFQyxPQUFPO0lBQ2xCLElBQUksOElBQThJO0lBR2xKMVEsY0FBYztJQUVka04sVUFBVW5FLE9BQU8sQ0FBQyxTQUFVMEgsQ0FBQztRQUMzQiw0R0FBNEc7UUFDNUcsSUFBSUEsRUFBRUUsYUFBYSxJQUFJRixFQUFFRyxHQUFHLEVBQUU7WUFDNUIsSUFBSUMsT0FBT0osRUFBRTdELElBQUksQ0FBQ2tFLFVBQVUsR0FBRyxnQkFBZ0IsZ0JBQzNDQyxXQUFXTixFQUFFRyxHQUFHLENBQUNDLEtBQUs7WUFDMUJKLEVBQUV2QixNQUFNLENBQUMsTUFBTTtZQUNmdUIsRUFBRU8sZ0JBQWdCLENBQUNQLEVBQUVHLEdBQUcsQ0FBQ0MsS0FBSyxHQUFHRTtZQUNqQ04sRUFBRUMsT0FBTztRQUNYO0lBQ0Y7SUFFQXpRLGVBQWUsR0FBRyw0S0FBNEs7SUFFOUxnUSxnQkFBZ0I7SUFFaEIvQyxVQUFVbkUsT0FBTyxDQUFDLFNBQVUwSCxDQUFDO1FBQzNCLHdOQUF3TjtRQUN4TixJQUFJbE4sTUFBTUgsV0FBV3FOLEVBQUU1TixRQUFRLEVBQUU0TixFQUFFUSxJQUFJLEdBQ25DQyxXQUFXVCxFQUFFN0QsSUFBSSxDQUFDdUUsR0FBRyxLQUFLLFNBQVNWLEVBQUVXLFNBQVMsSUFBSVgsRUFBRVUsR0FBRyxHQUFHNU4sS0FDMUQ4TixhQUFhWixFQUFFYSxXQUFXLElBQUliLEVBQUUvRCxLQUFLLElBQUluSjtRQUU1QzJOLENBQUFBLFlBQVlHLFVBQVMsS0FBTVosRUFBRWMsWUFBWSxDQUFDRixhQUFhOU4sTUFBTSxJQUFJa04sRUFBRS9ELEtBQUssRUFBRXdFLFdBQVd2UCxLQUFLNEIsR0FBRyxDQUFDOE4sYUFBYTlOLE1BQU1rTixFQUFFL0QsS0FBSyxHQUFHLEdBQUduSixPQUFPa04sRUFBRVUsR0FBRyxFQUFFO0lBQy9JO0lBRUFsQixnQkFBZ0I7SUFFaEJoUSxlQUFlO0lBQ2ZvUSxhQUFhdEgsT0FBTyxDQUFDLFNBQVV6RSxNQUFNO1FBQ25DLE9BQU9BLFVBQVVBLE9BQU9rTixNQUFNLElBQUlsTixPQUFPa04sTUFBTSxDQUFDLENBQUM7SUFDbkQsSUFBSSw0TUFBNE07SUFFaE41VCxvREFBVUEsQ0FBQ21MLE9BQU8sQ0FBQyxTQUFVN0MsR0FBRztRQUM5QixJQUFJdEMsWUFBWXNDLE1BQU07WUFDcEJBLElBQUlvSyxNQUFNLElBQUlqUCxzQkFBc0I7Z0JBQ2xDLE9BQU82RSxJQUFJcUssTUFBTSxDQUFDdkssS0FBSyxDQUFDd0ssY0FBYyxHQUFHO1lBQzNDO1lBQ0F0SyxJQUFJc0osR0FBRyxJQUFJdEosSUFBSUEsSUFBSXNKLEdBQUc7UUFDeEI7SUFDRjtJQUVBTCxtQkFBbUJ0UCxvQkFBb0I7SUFFdkNyQixhQUFhMEYsS0FBSztJQUVsQndMO0lBQ0FKLGlCQUFpQjtJQUVqQmhDLFdBQVc7SUFFWEosVUFBVW5FLE9BQU8sQ0FBQyxTQUFVMEgsQ0FBQztRQUMzQixPQUFPN00sWUFBWTZNLEVBQUU3RCxJQUFJLENBQUM2RSxTQUFTLEtBQUtoQixFQUFFN0QsSUFBSSxDQUFDNkUsU0FBUyxDQUFDaEI7SUFDM0Q7SUFFQW5CLGlCQUFpQmhCLGNBQWM4QixZQUFZLEdBQUc7SUFFOUN4QyxVQUFVO0FBQ1osR0FDSThELGNBQWMsR0FDZEMsYUFBYSxHQUNiQyxVQUNBdEUsYUFBYSxTQUFTQSxXQUFXK0IsS0FBSztJQUN4QyxJQUFJQSxVQUFVLEtBQUssQ0FBQ0Msa0JBQWtCLENBQUN0UCxhQUFhO1FBQ2xELDRKQUE0SjtRQUM1SnNPLGNBQWN1RCxVQUFVLEdBQUc7UUFDM0JELFlBQVlBLFNBQVNFLE1BQU0sQ0FBQyxJQUFJLDhJQUE4STtRQUU5SyxJQUFJQyxJQUFJN0UsVUFBVWhNLE1BQU0sRUFDcEI4USxPQUFPNVIsWUFDUDZSLGlCQUFpQkQsT0FBT3pSLFVBQVUsSUFDbEMyUixTQUFTSCxLQUFLN0UsU0FBUyxDQUFDLEVBQUUsQ0FBQ2dGLE1BQU07UUFFckNQLGFBQWFELGNBQWNRLFNBQVMsQ0FBQyxJQUFJO1FBQ3pDNUMsa0JBQW1Cb0MsQ0FBQUEsY0FBY1EsTUFBSztRQUV0QyxJQUFJRCxnQkFBZ0I7WUFDbEIsSUFBSXpSLG1CQUFtQixDQUFDMUIsa0JBQWtCa1QsT0FBT3hSLGtCQUFrQixLQUFLO2dCQUN0RUEsa0JBQWtCO2dCQUVsQm9OLFVBQVU7WUFDWjtZQUVBalAsU0FBUzRCO1lBQ1RBLFNBQVN5UjtRQUNYO1FBRUEsSUFBSUwsYUFBYSxHQUFHO1lBQ2xCM1MsS0FBSytTO1lBRUwsTUFBTy9TLE9BQU8sRUFBRztnQkFDZmtPLFNBQVMsQ0FBQ2xPLEdBQUcsSUFBSWtPLFNBQVMsQ0FBQ2xPLEdBQUcsQ0FBQzhTLE1BQU0sQ0FBQyxHQUFHRztZQUMzQztZQUVBTixhQUFhO1FBQ2YsT0FBTztZQUNMLElBQUszUyxLQUFLLEdBQUdBLEtBQUsrUyxHQUFHL1MsS0FBTTtnQkFDekJrTyxTQUFTLENBQUNsTyxHQUFHLElBQUlrTyxTQUFTLENBQUNsTyxHQUFHLENBQUM4UyxNQUFNLENBQUMsR0FBR0c7WUFDM0M7UUFDRjtRQUVBM0QsY0FBY3VELFVBQVUsR0FBRztJQUM3QjtJQUVBekUsU0FBUztBQUNYLEdBQ0krRSxtQkFBbUI7SUFBQ3ROO0lBQU9DO0lBQU1FO0lBQVNEO0lBQVFTLFVBQVVGO0lBQVNFLFVBQVVMO0lBQVFLLFVBQVVIO0lBQU1HLFVBQVVKO0lBQU87SUFBVztJQUFjO0lBQVM7SUFBVTtJQUFtQjtJQUFpQjtJQUFnQjtJQUFjO0lBQVk7SUFBZTtJQUFhO0lBQWE7Q0FBUSxFQUNuU2dOLGNBQWNELGlCQUFpQkUsTUFBTSxDQUFDO0lBQUNwTjtJQUFRQztJQUFTO0lBQWEsUUFBUU87SUFBUSxRQUFRQztJQUFTO0lBQVlGO0lBQVNEO0lBQVVBLFdBQVdGO0lBQU1FLFdBQVdKO0lBQVFJLFdBQVdEO0lBQVNDLFdBQVdIO0NBQU0sR0FDOU1rTixjQUFjLFNBQVNBLFlBQVkxQixHQUFHLEVBQUUyQixNQUFNLEVBQUVDLEtBQUs7SUFDdkRDLFVBQVVEO0lBRVYsSUFBSTdFLFFBQVFpRCxJQUFJOEIsS0FBSztJQUVyQixJQUFJL0UsTUFBTWdGLGNBQWMsRUFBRTtRQUN4QkYsVUFBVTlFLE1BQU1pRixXQUFXO0lBQzdCLE9BQU8sSUFBSWhDLElBQUk4QixLQUFLLENBQUNHLFNBQVMsRUFBRTtRQUM5QixJQUFJbkgsU0FBUzZHLE9BQU9PLFVBQVU7UUFFOUIsSUFBSXBILFFBQVE7WUFDVkEsT0FBT1UsWUFBWSxDQUFDd0UsS0FBSzJCO1lBQ3pCN0csT0FBT3NFLFdBQVcsQ0FBQ3VDO1FBQ3JCO0lBQ0Y7SUFFQTNCLElBQUk4QixLQUFLLENBQUNHLFNBQVMsR0FBRztBQUN4QixHQUNJRSxhQUFhLFNBQVNBLFdBQVduQyxHQUFHLEVBQUUyQixNQUFNLEVBQUVTLEVBQUUsRUFBRUosV0FBVztJQUMvRCxJQUFJLENBQUNoQyxJQUFJOEIsS0FBSyxDQUFDRyxTQUFTLEVBQUU7UUFDeEIsSUFBSWxQLElBQUl3TyxpQkFBaUJqUixNQUFNLEVBQzNCK1IsY0FBY1YsT0FBT3ZNLEtBQUssRUFDMUJrTixXQUFXdEMsSUFBSTVLLEtBQUssRUFDcEJJO1FBRUosTUFBT3pDLElBQUs7WUFDVnlDLElBQUkrTCxnQkFBZ0IsQ0FBQ3hPLEVBQUU7WUFDdkJzUCxXQUFXLENBQUM3TSxFQUFFLEdBQUc0TSxFQUFFLENBQUM1TSxFQUFFO1FBQ3hCO1FBRUE2TSxZQUFZbE4sUUFBUSxHQUFHaU4sR0FBR2pOLFFBQVEsS0FBSyxhQUFhLGFBQWE7UUFDakVpTixHQUFHbkcsT0FBTyxLQUFLLFlBQWFvRyxDQUFBQSxZQUFZcEcsT0FBTyxHQUFHLGNBQWE7UUFDL0RxRyxRQUFRLENBQUNsTyxRQUFRLEdBQUdrTyxRQUFRLENBQUNuTyxPQUFPLEdBQUc7UUFDdkNrTyxZQUFZRSxTQUFTLEdBQUdILEdBQUdHLFNBQVMsSUFBSTtRQUN4Q0YsWUFBWUcsUUFBUSxHQUFHO1FBQ3ZCSCxZQUFZSSxTQUFTLEdBQUc7UUFDeEJKLFdBQVcsQ0FBQ2hPLE9BQU8sR0FBR29DLFNBQVN1SixLQUFLalQscURBQVdBLElBQUlnSTtRQUNuRHNOLFdBQVcsQ0FBQy9OLFFBQVEsR0FBR21DLFNBQVN1SixLQUFLbFQsbURBQVNBLElBQUlpSTtRQUNsRHNOLFdBQVcsQ0FBQzFOLFNBQVMsR0FBRzJOLFFBQVEsQ0FBQzFOLFFBQVEsR0FBRzBOLFFBQVEsQ0FBQ3BPLEtBQUssR0FBR29PLFFBQVEsQ0FBQ3JPLE1BQU0sR0FBRztRQUUvRTROLFVBQVVHO1FBRVZNLFFBQVEsQ0FBQ2pPLE9BQU8sR0FBR2lPLFFBQVEsQ0FBQyxRQUFRek4sT0FBTyxHQUFHdU4sRUFBRSxDQUFDL04sT0FBTztRQUN4RGlPLFFBQVEsQ0FBQ2hPLFFBQVEsR0FBR2dPLFFBQVEsQ0FBQyxRQUFReE4sUUFBUSxHQUFHc04sRUFBRSxDQUFDOU4sUUFBUTtRQUMzRGdPLFFBQVEsQ0FBQzNOLFNBQVMsR0FBR3lOLEVBQUUsQ0FBQ3pOLFNBQVM7UUFFakMsSUFBSXFMLElBQUlrQyxVQUFVLEtBQUtQLFFBQVE7WUFDN0IzQixJQUFJa0MsVUFBVSxDQUFDMUcsWUFBWSxDQUFDbUcsUUFBUTNCO1lBQ3BDMkIsT0FBT2xHLFdBQVcsQ0FBQ3VFO1FBQ3JCO1FBRUFBLElBQUk4QixLQUFLLENBQUNHLFNBQVMsR0FBRztJQUN4QjtBQUNGLEdBQ0lTLFdBQVcsWUFDWGIsWUFBWSxTQUFTQSxVQUFVRCxLQUFLO0lBQ3RDLElBQUlBLE9BQU87UUFDVCxJQUFJeE0sUUFBUXdNLE1BQU0vQixDQUFDLENBQUN6SyxLQUFLLEVBQ3JCK0wsSUFBSVMsTUFBTXRSLE1BQU0sRUFDaEJ5QyxJQUFJLEdBQ0p5QyxHQUNBekY7UUFDSDZSLENBQUFBLE1BQU0vQixDQUFDLENBQUNpQyxLQUFLLElBQUl6VSxLQUFLc1YsSUFBSSxDQUFDQyxRQUFRLENBQUNoQixNQUFNL0IsQ0FBQyxHQUFHMUIsT0FBTyxHQUFHLEdBQUcsa0NBQWtDO1FBRTlGLE1BQU9wTCxJQUFJb08sR0FBR3BPLEtBQUssRUFBRztZQUNwQmhELFFBQVE2UixLQUFLLENBQUM3TyxJQUFJLEVBQUU7WUFDcEJ5QyxJQUFJb00sS0FBSyxDQUFDN08sRUFBRTtZQUVaLElBQUloRCxPQUFPO2dCQUNUcUYsS0FBSyxDQUFDSSxFQUFFLEdBQUd6RjtZQUNiLE9BQU8sSUFBSXFGLEtBQUssQ0FBQ0ksRUFBRSxFQUFFO2dCQUNuQkosTUFBTXlOLGNBQWMsQ0FBQ3JOLEVBQUVzTixPQUFPLENBQUNKLFVBQVUsT0FBT0ssV0FBVztZQUM3RDtRQUNGO0lBQ0Y7QUFDRixHQUNJQyxZQUFZLFNBQVNBLFVBQVV0UixPQUFPO0lBQ3hDLGlLQUFpSztJQUNqSyxJQUFJeVAsSUFBSUssWUFBWWxSLE1BQU0sRUFDdEI4RSxRQUFRMUQsUUFBUTBELEtBQUssRUFDckJ3TSxRQUFRLEVBQUUsRUFDVjdPLElBQUk7SUFFUixNQUFPQSxJQUFJb08sR0FBR3BPLElBQUs7UUFDakI2TyxNQUFNN0ssSUFBSSxDQUFDeUssV0FBVyxDQUFDek8sRUFBRSxFQUFFcUMsS0FBSyxDQUFDb00sV0FBVyxDQUFDek8sRUFBRSxDQUFDO0lBQ2xEO0lBRUE2TyxNQUFNL0IsQ0FBQyxHQUFHbk87SUFDVixPQUFPa1E7QUFDVCxHQUNJcUIsYUFBYSxTQUFTQSxXQUFXckIsS0FBSyxFQUFFc0IsUUFBUSxFQUFFQyxXQUFXO0lBQy9ELElBQUl6UCxTQUFTLEVBQUUsRUFDWHlOLElBQUlTLE1BQU10UixNQUFNLEVBQ2hCeUMsSUFBSW9RLGNBQWMsSUFBSSxHQUN0Qix1REFBdUQ7SUFDM0QzTjtJQUVBLE1BQU96QyxJQUFJb08sR0FBR3BPLEtBQUssRUFBRztRQUNwQnlDLElBQUlvTSxLQUFLLENBQUM3TyxFQUFFO1FBQ1pXLE9BQU9xRCxJQUFJLENBQUN2QixHQUFHQSxLQUFLME4sV0FBV0EsUUFBUSxDQUFDMU4sRUFBRSxHQUFHb00sS0FBSyxDQUFDN08sSUFBSSxFQUFFO0lBQzNEO0lBRUFXLE9BQU9tTSxDQUFDLEdBQUcrQixNQUFNL0IsQ0FBQztJQUNsQixPQUFPbk07QUFDVCxHQUNJL0IsY0FBYztJQUNoQitILE1BQU07SUFDTkQsS0FBSztBQUNQLEdBQ0ksOElBQThJO0FBQ2xKLDRGQUE0RjtBQUM1Riw0Q0FBNEM7QUFDNUMseURBQXlEO0FBQ3pELHdDQUF3QztBQUN4QyxrREFBa0Q7QUFDbEQsaVpBQWlaO0FBQ2paLEtBQUs7QUFDTDJKLGlCQUFpQixTQUFTQSxlQUFlclQsS0FBSyxFQUFFc08sT0FBTyxFQUFFZ0YsWUFBWSxFQUFFM0wsU0FBUyxFQUFFNEosTUFBTSxFQUFFekYsTUFBTSxFQUFFeUgsY0FBYyxFQUFFclQsSUFBSSxFQUFFc1QsY0FBYyxFQUFFQyxXQUFXLEVBQUU1SSxnQkFBZ0IsRUFBRTZJLFdBQVcsRUFBRS9JLGtCQUFrQixFQUFFZ0osYUFBYTtJQUNuTjFRLFlBQVlqRCxVQUFXQSxDQUFBQSxRQUFRQSxNQUFNRSxLQUFJO0lBRXpDLElBQUlFLFVBQVVKLFVBQVVBLE1BQU1LLE1BQU0sQ0FBQyxHQUFHLE9BQU8sT0FBTztRQUNwREwsUUFBUTBULGNBQWUxVCxDQUFBQSxNQUFNbUssTUFBTSxDQUFDLE9BQU8sTUFBTUosWUFBWSxNQUFNL0osTUFBTUssTUFBTSxDQUFDLElBQUlpVCxnQkFBZ0I7SUFDdEc7SUFFQSxJQUFJakMsT0FBTzFHLHFCQUFxQkEsbUJBQW1CMEcsSUFBSSxLQUFLLEdBQ3hEdUMsSUFDQUMsSUFDQWxTO0lBQ0pnSixzQkFBc0JBLG1CQUFtQm1KLElBQUksQ0FBQztJQUM5Q0MsTUFBTS9ULFVBQVdBLENBQUFBLFFBQVEsQ0FBQ0EsS0FBSSxHQUFJLHdEQUF3RDtJQUUxRixJQUFJLENBQUNrRCxVQUFVbEQsUUFBUTtRQUNyQmlELFlBQVlxTCxZQUFhQSxDQUFBQSxVQUFVQSxRQUFRcE8sS0FBSTtRQUMvQyxJQUFJOFQsVUFBVSxDQUFDaFUsU0FBUyxHQUFFLEVBQUdtSSxLQUFLLENBQUMsTUFDL0I1QixRQUNBME4sYUFDQUMsY0FDQWhJO1FBQ0p2SyxVQUFVN0Usd0RBQVVBLENBQUN3UixTQUFTcE8sU0FBU3ZDO1FBQ3ZDNEksU0FBU3ZFLFdBQVdMLFlBQVksQ0FBQztRQUVqQyxJQUFJLENBQUMsQ0FBQzRFLFVBQVUsQ0FBQ0EsT0FBT29ELElBQUksSUFBSSxDQUFDcEQsT0FBT21ELEdBQUcsS0FBS3pFLGtCQUFrQnRELFNBQVN1SyxPQUFPLEtBQUssUUFBUTtZQUM3Rix5RUFBeUU7WUFDekVBLFVBQVV2SyxRQUFRMEQsS0FBSyxDQUFDNkcsT0FBTztZQUMvQnZLLFFBQVEwRCxLQUFLLENBQUM2RyxPQUFPLEdBQUc7WUFDeEIzRixTQUFTdkUsV0FBV0w7WUFDcEJ1SyxVQUFVdkssUUFBUTBELEtBQUssQ0FBQzZHLE9BQU8sR0FBR0EsVUFBVXZLLFFBQVEwRCxLQUFLLENBQUN5TixjQUFjLENBQUM7UUFDM0U7UUFFQW1CLGNBQWNsSyxZQUFZaUssT0FBTyxDQUFDLEVBQUUsRUFBRXpOLE1BQU0sQ0FBQ29CLFVBQVV0RixDQUFDLENBQUM7UUFDekQ2UixlQUFlbkssWUFBWWlLLE9BQU8sQ0FBQyxFQUFFLElBQUksS0FBS1Y7UUFDOUN0VCxRQUFRdUcsTUFBTSxDQUFDb0IsVUFBVWxDLENBQUMsQ0FBQyxHQUFHK04sY0FBYyxDQUFDN0wsVUFBVWxDLENBQUMsQ0FBQyxHQUFHZ08sY0FBY1EsY0FBYzFDLFNBQVMyQztRQUNqR1gsa0JBQWtCMUgsZ0JBQWdCMEgsZ0JBQWdCVyxjQUFjdk0sV0FBVzJMLGVBQWVZLGVBQWUsTUFBTVgsZUFBZW5JLFFBQVEsSUFBSThJLGVBQWU7UUFDekpaLGdCQUFnQkEsZUFBZVksY0FBYyx3QkFBd0I7SUFDdkUsT0FBTztRQUNMdkosc0JBQXVCM0ssQ0FBQUEsUUFBUTFDLEtBQUs0SixLQUFLLENBQUNpTixRQUFRLENBQUN4SixtQkFBbUJ5SixhQUFhLENBQUNySSxLQUFLLEVBQUVwQixtQkFBbUJ5SixhQUFhLENBQUM1RCxHQUFHLEVBQUUsR0FBR2tELGFBQWExVCxNQUFLO1FBQ3RKdVQsa0JBQWtCMUgsZ0JBQWdCMEgsZ0JBQWdCRCxjQUFjM0wsV0FBVztJQUM3RTtJQUVBLElBQUlnTSxlQUFlO1FBQ2pCelQsSUFBSSxDQUFDeVQsY0FBYyxHQUFHM1QsU0FBUyxDQUFDO1FBQ2hDQSxRQUFRLEtBQU1BLENBQUFBLFFBQVE7SUFDeEI7SUFFQSxJQUFJOEwsUUFBUTtRQUNWLElBQUkxRyxXQUFXcEYsUUFBUXNULGNBQ25CdEksVUFBVWMsT0FBT1YsUUFBUTtRQUM3QndJLEtBQUssV0FBV2pNLFVBQVVyRixFQUFFO1FBRTVCdUosZ0JBQWdCQyxRQUFRMUcsVUFBVXVDLFdBQVdxRCxXQUFXNUYsV0FBVyxNQUFNLENBQUM0RixXQUFXLENBQUNILG1CQUFtQjdKLEtBQUs0QixHQUFHLENBQUNqRixLQUFLLENBQUNpVyxHQUFHLEVBQUVsVyxNQUFNLENBQUNrVyxHQUFHLElBQUk5SCxPQUFPcUcsVUFBVSxDQUFDeUIsR0FBRyxLQUFLeE8sV0FBVztRQUVoTCxJQUFJeUYsa0JBQWtCO1lBQ3BCMkksaUJBQWlCeFIsV0FBV3VSO1lBQzVCMUksb0JBQXFCaUIsQ0FBQUEsT0FBT3pHLEtBQUssQ0FBQ3NDLFVBQVVpRSxFQUFFLENBQUNuRyxDQUFDLENBQUMsR0FBRytOLGNBQWMsQ0FBQzdMLFVBQVVpRSxFQUFFLENBQUNuRyxDQUFDLENBQUMsR0FBR2tDLFVBQVVpRSxFQUFFLENBQUN5SSxDQUFDLEdBQUd2SSxPQUFPSCxPQUFPLEdBQUczRyxHQUFFO1FBQzNIO0lBQ0Y7SUFFQSxJQUFJMkYsc0JBQXNCaEosU0FBUztRQUNqQ2lTLEtBQUs1UixXQUFXTDtRQUNoQmdKLG1CQUFtQm1KLElBQUksQ0FBQ0o7UUFDeEJHLEtBQUs3UixXQUFXTDtRQUNoQmdKLG1CQUFtQjJKLGFBQWEsR0FBR1YsRUFBRSxDQUFDak0sVUFBVWxDLENBQUMsQ0FBQyxHQUFHb08sRUFBRSxDQUFDbE0sVUFBVWxDLENBQUMsQ0FBQztRQUNwRXpGLFFBQVFBLFFBQVEySyxtQkFBbUIySixhQUFhLEdBQUdaO0lBQ3JEO0lBRUEvSSxzQkFBc0JBLG1CQUFtQm1KLElBQUksQ0FBQ3pDO0lBQzlDLE9BQU8xRyxxQkFBcUIzSyxRQUFRZ0IsS0FBS0MsS0FBSyxDQUFDakI7QUFDakQsR0FDSXVVLGFBQWEsc0NBQ2JDLFlBQVksU0FBU0EsVUFBVTdTLE9BQU8sRUFBRW9KLE1BQU0sRUFBRXJCLEdBQUcsRUFBRUMsSUFBSTtJQUMzRCxJQUFJaEksUUFBUXdRLFVBQVUsS0FBS3BILFFBQVE7UUFDakMsSUFBSTFGLFFBQVExRCxRQUFRMEQsS0FBSyxFQUNyQkksR0FDQTRNO1FBRUosSUFBSXRILFdBQVdwTixPQUFPO1lBQ3BCZ0UsUUFBUThTLE9BQU8sR0FBR3BQLE1BQU1pRyxPQUFPLEVBQUUsNERBQTREO1lBRTdGK0csS0FBS3BOLGtCQUFrQnREO1lBRXZCLElBQUs4RCxLQUFLNE0sR0FBSTtnQkFDWix1SUFBdUk7Z0JBQ3ZJLElBQUksQ0FBQyxDQUFDNU0sS0FBSyxDQUFDOE8sV0FBV0csSUFBSSxDQUFDalAsTUFBTTRNLEVBQUUsQ0FBQzVNLEVBQUUsSUFBSSxPQUFPSixLQUFLLENBQUNJLEVBQUUsS0FBSyxZQUFZQSxNQUFNLEtBQUs7b0JBQ3BGSixLQUFLLENBQUNJLEVBQUUsR0FBRzRNLEVBQUUsQ0FBQzVNLEVBQUU7Z0JBQ2xCO1lBQ0Y7WUFFQUosTUFBTXFFLEdBQUcsR0FBR0E7WUFDWnJFLE1BQU1zRSxJQUFJLEdBQUdBO1FBQ2YsT0FBTztZQUNMdEUsTUFBTWlHLE9BQU8sR0FBRzNKLFFBQVE4UyxPQUFPO1FBQ2pDO1FBRUFuWCxLQUFLc1YsSUFBSSxDQUFDQyxRQUFRLENBQUNsUixTQUFTeU0sT0FBTyxHQUFHO1FBQ3RDckQsT0FBT1csV0FBVyxDQUFDL0o7SUFDckI7QUFDRixHQUNJZ1QsdUJBQXVCLFNBQVNBLHFCQUFxQkMsWUFBWSxFQUFFQyxZQUFZLEVBQUVDLFdBQVc7SUFDOUYsSUFBSUMsUUFBUUYsY0FDUkcsUUFBUUQ7SUFDWixPQUFPLFNBQVUvVSxLQUFLO1FBQ3BCLElBQUlpVixVQUFValUsS0FBS0MsS0FBSyxDQUFDMlQsaUJBQWlCLG9JQUFvSTtRQUU5SyxJQUFJSyxZQUFZRixTQUFTRSxZQUFZRCxTQUFTaFUsS0FBS2lELEdBQUcsQ0FBQ2dSLFVBQVVGLFNBQVMsS0FBSy9ULEtBQUtpRCxHQUFHLENBQUNnUixVQUFVRCxTQUFTLEdBQUc7WUFDNUcsMlRBQTJUO1lBQzNUaFYsUUFBUWlWO1lBQ1JILGVBQWVBO1FBQ2pCO1FBRUFFLFFBQVFEO1FBQ1JBLFFBQVEvVTtRQUNSLE9BQU9BO0lBQ1Q7QUFDRixHQUNJa1YsZUFBZSxTQUFTQSxhQUFhcEosTUFBTSxFQUFFbkUsU0FBUyxFQUFFM0gsS0FBSztJQUMvRCxJQUFJaU0sT0FBTyxDQUFDO0lBQ1pBLElBQUksQ0FBQ3RFLFVBQVVsQyxDQUFDLENBQUMsR0FBRyxPQUFPekY7SUFDM0IxQyxLQUFLZ1AsR0FBRyxDQUFDUixRQUFRRztBQUNuQixHQUNJLHFDQUFxQztBQUN6QyxtSEFBbUg7QUFDbkgsd0ZBQXdGO0FBQ3hGLGlDQUFpQztBQUNqQyxjQUFjO0FBQ2QsS0FBSztBQUNMLHNaQUFzWjtBQUN0WmtKLG1CQUFtQixTQUFTQSxpQkFBaUJqVCxRQUFRLEVBQUV5RixTQUFTO0lBQzlELElBQUl5TixZQUFZalksNERBQWNBLENBQUMrRSxVQUFVeUYsWUFDckN1SSxPQUFPLFlBQVl2SSxVQUFVa00sRUFBRSxFQUMvQiwrTEFBK0w7SUFDbk13QixXQUFXLFNBQVNBLFNBQVNDLFFBQVEsRUFBRXJKLElBQUksRUFBRTRJLFlBQVksRUFBRVUsT0FBTyxFQUFFQyxPQUFPO1FBQ3pFLElBQUk3UCxRQUFRMFAsU0FBUzFQLEtBQUssRUFDdEI4UCxhQUFheEosS0FBS3dKLFVBQVUsRUFDNUJDLFlBQVksQ0FBQztRQUNqQmIsZUFBZUEsZ0JBQWdCTztRQUUvQixJQUFJTyx1QkFBdUJoQixxQkFBcUJTLFdBQVdQLGNBQWM7WUFDdkVsUCxNQUFNYyxJQUFJO1lBQ1Y0TyxTQUFTMVAsS0FBSyxHQUFHO1FBQ25CO1FBRUE2UCxVQUFVRCxXQUFXQyxXQUFXLEdBQUcsa0hBQWtIO1FBRXJKRCxVQUFVQSxXQUFXRCxXQUFXVDtRQUNoQ2xQLFNBQVNBLE1BQU1jLElBQUk7UUFDbkJ3RixJQUFJLENBQUNpRSxLQUFLLEdBQUdvRjtRQUNickosS0FBSzJKLE9BQU8sR0FBRztRQUNmM0osS0FBS3lKLFNBQVMsR0FBR0E7UUFFakJBLFNBQVMsQ0FBQ3hGLEtBQUssR0FBRztZQUNoQixPQUFPeUYscUJBQXFCZCxlQUFlVSxVQUFVNVAsTUFBTWtRLEtBQUssR0FBR0wsVUFBVTdQLE1BQU1rUSxLQUFLLEdBQUdsUSxNQUFNa1EsS0FBSztRQUN4RztRQUVBNUosS0FBSzZKLFFBQVEsR0FBRztZQUNkN1ksb0RBQVVBLENBQUMrUCxLQUFLO1lBQ2hCcUksU0FBUzFQLEtBQUssSUFBSWdILGNBQWMsdUZBQXVGO1FBQ3pIO1FBRUFWLEtBQUt3SixVQUFVLEdBQUc7WUFDaEJKLFNBQVMxUCxLQUFLLEdBQUc7WUFDakI4UCxjQUFjQSxXQUFXTSxJQUFJLENBQUNwUTtRQUNoQztRQUVBQSxRQUFRMFAsU0FBUzFQLEtBQUssR0FBR3JJLEtBQUtzSSxFQUFFLENBQUMxRCxVQUFVK0o7UUFDM0MsT0FBT3RHO0lBQ1Q7SUFFQXpELFFBQVEsQ0FBQ2dPLEtBQUssR0FBR2tGO0lBRWpCQSxVQUFVck0sWUFBWSxHQUFHO1FBQ3ZCLE9BQU9zTSxTQUFTMVAsS0FBSyxJQUFJMFAsU0FBUzFQLEtBQUssQ0FBQ2MsSUFBSSxNQUFPNE8sQ0FBQUEsU0FBUzFQLEtBQUssR0FBRztJQUN0RTtJQUVBMEMsYUFBYW5HLFVBQVUsU0FBU2tULFVBQVVyTSxZQUFZLEdBQUcsdVNBQXVTO0lBR2hXNEUsY0FBY3FJLE9BQU8sSUFBSTNOLGFBQWFuRyxVQUFVLGFBQWFrVCxVQUFVck0sWUFBWTtJQUNuRixPQUFPc007QUFDVDtBQUVPLElBQUkxSCxnQkFBZ0IsV0FBVyxHQUFFO0lBQ3RDLFNBQVNBLGNBQWMxQixJQUFJLEVBQUU1SSxTQUFTO1FBQ3BDOUYsZ0JBQWdCb1EsY0FBY3NJLFFBQVEsQ0FBQzNZLFNBQVM0WSxRQUFRQyxJQUFJLENBQUM7UUFFN0RsWCxTQUFTLElBQUk7UUFFYixJQUFJLENBQUNtWCxJQUFJLENBQUNuSyxNQUFNNUk7SUFDbEI7SUFFQSxJQUFJZ1QsU0FBUzFJLGNBQWMySSxTQUFTO0lBRXBDRCxPQUFPRCxJQUFJLEdBQUcsU0FBU0EsS0FBS25LLElBQUksRUFBRTVJLFNBQVM7UUFDekMsSUFBSSxDQUFDRyxRQUFRLEdBQUcsSUFBSSxDQUFDdUksS0FBSyxHQUFHO1FBQzdCLElBQUksQ0FBQ0UsSUFBSSxJQUFJLElBQUksQ0FBQ3hGLElBQUksQ0FBQyxNQUFNLE9BQU8sbUNBQW1DO1FBRXZFLElBQUksQ0FBQzNHLFVBQVU7WUFDYixJQUFJLENBQUNxUixNQUFNLEdBQUcsSUFBSSxDQUFDcEIsT0FBTyxHQUFHLElBQUksQ0FBQ3RKLElBQUksR0FBRzVGO1lBQ3pDO1FBQ0Y7UUFFQW9MLE9BQU8zRyxhQUFhbEYsVUFBVTZMLFNBQVMvSSxVQUFVK0ksU0FBU0EsS0FBS3NLLFFBQVEsR0FBRztZQUN4RWpJLFNBQVNyQztRQUNYLElBQUlBLE1BQU0zQztRQUVWLElBQUlrTixRQUFRdkssTUFDUjZKLFdBQVdVLE1BQU1WLFFBQVEsRUFDekJXLGNBQWNELE1BQU1DLFdBQVcsRUFDL0J2SCxLQUFLc0gsTUFBTXRILEVBQUUsRUFDYndILFdBQVdGLE1BQU1FLFFBQVEsRUFDekI1RixZQUFZMEYsTUFBTTFGLFNBQVMsRUFDM0I2RixRQUFRSCxNQUFNRyxLQUFLLEVBQ25CckksVUFBVWtJLE1BQU1sSSxPQUFPLEVBQ3ZCMkIsTUFBTXVHLE1BQU12RyxHQUFHLEVBQ2YyRyxhQUFhSixNQUFNSSxVQUFVLEVBQzdCQyxzQkFBc0JMLE1BQU1LLG1CQUFtQixFQUMvQ3JOLGdCQUFnQmdOLE1BQU1oTixhQUFhLEVBQ25Dc04sa0JBQWtCTixNQUFNTSxlQUFlLEVBQ3ZDQyxpQkFBaUJQLE1BQU1PLGNBQWMsRUFDckNDLE9BQU9SLE1BQU1RLElBQUksRUFDakI3UCxPQUFPcVAsTUFBTXJQLElBQUksRUFDakI4UCxjQUFjVCxNQUFNUyxXQUFXLEVBQy9CQyxZQUFZVixNQUFNVSxTQUFTLEVBQzNCdk0scUJBQXFCNkwsTUFBTTdMLGtCQUFrQixFQUM3Q3dNLGdCQUFnQlgsTUFBTVcsYUFBYSxFQUNuQ0Msa0JBQWtCWixNQUFNWSxlQUFlLEVBQ3ZDelAsWUFBWXNFLEtBQUtrRSxVQUFVLElBQUlsRSxLQUFLdEIsa0JBQWtCLElBQUlzQixLQUFLa0UsVUFBVSxLQUFLLFFBQVFuVCxxREFBV0EsR0FBR0QsbURBQVNBLEVBQzdHc2EsV0FBVyxDQUFDVixTQUFTQSxVQUFVLEdBQy9CelUsV0FBV3BGLHdEQUFVQSxDQUFDbVAsS0FBSy9KLFFBQVEsSUFBSTFFLE9BQ3ZDOFosZ0JBQWdCaGEsS0FBS3NWLElBQUksQ0FBQ0MsUUFBUSxDQUFDM1EsV0FDbkNDLGFBQWFiLFlBQVlZLFdBQ3pCMkksbUJBQW1CLENBQUMsYUFBYW9CLE9BQU9BLEtBQUtzTCxPQUFPLEdBQUduYSwyREFBYUEsQ0FBQzhFLFVBQVUsY0FBY0MsY0FBYyxPQUFNLE1BQU8sU0FDeEhxVixZQUFZO1lBQUN2TCxLQUFLd0wsT0FBTztZQUFFeEwsS0FBS3lMLE9BQU87WUFBRXpMLEtBQUswTCxXQUFXO1lBQUUxTCxLQUFLMkwsV0FBVztTQUFDLEVBQzVFck8sZ0JBQWdCOE4sWUFBWXBMLEtBQUsxQyxhQUFhLENBQUNwQixLQUFLLENBQUMsTUFDckQwUCxVQUFVLGFBQWE1TCxPQUFPQSxLQUFLNEwsT0FBTyxHQUFHdk8sVUFBVXVPLE9BQU8sRUFDOURwRSxjQUFjdFIsYUFBYSxJQUFJaUksV0FBV25GLGtCQUFrQi9DLFNBQVMsQ0FBQyxXQUFXeUYsVUFBVWtNLEVBQUUsR0FBRy9PLE9BQU8sS0FBSyxHQUM1RzVFLE9BQU8sSUFBSSxFQUNYNFgsZ0JBQWdCN0wsS0FBSzZMLGFBQWEsSUFBSTtZQUN4QyxPQUFPN0wsS0FBSzZMLGFBQWEsQ0FBQzVYO1FBQzVCLEdBQ0k2WCxrQkFBa0I5VixhQUFhQyxVQUFVQyxZQUFZd0YsWUFDckRxUSxxQkFBcUJ4VixnQkFBZ0JOLFVBQVVDLGFBQy9DOFYsV0FBVyxHQUNYQyxjQUFjLEdBQ2RDLGVBQWUsR0FDZnJQLGFBQWEzTCw0REFBY0EsQ0FBQytFLFVBQVV5RixZQUN0Q3lRLFNBQ0FDLFVBQ0FDLFVBQ0FDLFNBQ0FDLFNBQ0F6TSxPQUNBeUUsS0FDQWlJLGFBQ0FDLFdBQ0FDLG9CQUNBQyxrQkFDQUMsWUFDQUMsb0JBQ0FDLFFBQ0FDLGtCQUNBQyxnQkFDQUMsVUFDQXRILFFBQ0FuSCxRQUNBME8sV0FDQUMsV0FDQUMsVUFDQUMsV0FDQUMsY0FDQXRILGFBQ0F1SCxtQkFDQUMsVUFDQUMsaUJBQ0FySCxJQUNBc0gsT0FDQUMsT0FDQUMsWUFDQUMsYUFDQUMsY0FDQUMsaUJBQ0FDLFlBQ0FDLGtCQUNBQyxnQkFDQUMsb0JBQW9CLHNZQUFzWTtRQUc5WmxhLEtBQUt5USxXQUFXLEdBQUd6USxLQUFLdVEsU0FBUyxHQUFHO1FBQ3BDdlEsS0FBS29RLElBQUksR0FBRzNJO1FBQ1o2QixpQkFBaUI7UUFDakJ0SixLQUFLZ0MsUUFBUSxHQUFHQTtRQUNoQmhDLEtBQUtxUixNQUFNLEdBQUc1RyxxQkFBcUJBLG1CQUFtQjBHLElBQUksQ0FBQ2dKLElBQUksQ0FBQzFQLHNCQUFzQjdCO1FBQ3RGeVAsVUFBVXpQO1FBQ1Y1SSxLQUFLK0wsSUFBSSxHQUFHQTtRQUNaNUksWUFBWUEsYUFBYTRJLEtBQUs1SSxTQUFTO1FBRXZDLElBQUkscUJBQXFCNEksTUFBTTtZQUM3QnhOLFFBQVE7WUFDUndOLEtBQUtxTyxlQUFlLEtBQUssQ0FBQyxRQUFTckosQ0FBQUEsV0FBVy9RLElBQUcsR0FBSSx5QkFBeUI7UUFDaEY7UUFFQW9YLGNBQWNpRCxXQUFXLEdBQUdqRCxjQUFjaUQsV0FBVyxJQUFJO1lBQ3ZEN1EsS0FBS3lMLGlCQUFpQmpULFVBQVVuRixtREFBU0E7WUFDekM0TSxNQUFNd0wsaUJBQWlCalQsVUFBVWxGLHFEQUFXQTtRQUM5QztRQUNBa0QsS0FBS2tZLE9BQU8sR0FBR0EsVUFBVWQsY0FBY2lELFdBQVcsQ0FBQzVTLFVBQVVsQyxDQUFDLENBQUM7UUFFL0R2RixLQUFLc2EsYUFBYSxHQUFHLFNBQVV4YSxLQUFLO1lBQ2xDOFosY0FBYzVXLFVBQVVsRCxVQUFVQTtZQUVsQyxJQUFJLENBQUM4WixhQUFhO2dCQUNoQkQsY0FBY0EsV0FBV3JXLFFBQVEsQ0FBQyxHQUFHaUQsSUFBSTtnQkFDekNvVCxhQUFhO1lBQ2YsT0FBTztnQkFDTEEsYUFBYUEsV0FBVzlTLFFBQVEsQ0FBQy9HLFNBQVM2WixhQUFhdmMsS0FBS3NJLEVBQUUsQ0FBQ3ZDLFdBQVc7b0JBQ3hFb1gsTUFBTTtvQkFDTkMsZUFBZTtvQkFDZjlFLFNBQVM7b0JBQ1Q3TyxVQUFVK1M7b0JBQ1ZhLFFBQVE7b0JBQ1JsRixZQUFZLFNBQVNBO3dCQUNuQixPQUFPcUIsbUJBQW1CQSxnQkFBZ0I1VztvQkFDNUM7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsSUFBSW1ELFdBQVc7WUFDYkEsVUFBVTRJLElBQUksQ0FBQzJPLElBQUksR0FBRztZQUN0QnZYLFVBQVV3WCxRQUFRLElBQUksQ0FBQzNhLEtBQUs0YSxVQUFVLElBQUl6WCxVQUFVNEksSUFBSSxDQUFDOE8sZUFBZSxLQUFLLFNBQVM5TyxLQUFLOE8sZUFBZSxLQUFLLFNBQVMxWCxVQUFVMEQsUUFBUSxNQUFNMUQsVUFBVXdOLE1BQU0sQ0FBQyxHQUFHLE1BQU0sT0FBTyw4V0FBOFc7WUFFL2hCM1EsS0FBS21ELFNBQVMsR0FBR0EsVUFBVUUsS0FBSztZQUNoQ0YsVUFBVStRLGFBQWEsR0FBR2xVO1lBQzFCQSxLQUFLc2EsYUFBYSxDQUFDN0Q7WUFDbkJnRCxRQUFRO1lBQ1J6SyxNQUFPQSxDQUFBQSxLQUFLN0wsVUFBVTRJLElBQUksQ0FBQ2lELEVBQUU7UUFDL0I7UUFFQSxJQUFJL0gsTUFBTTtZQUNSLHVSQUF1UjtZQUN2UixJQUFJLENBQUNoRSxVQUFVZ0UsU0FBU0EsS0FBS0gsSUFBSSxFQUFFO2dCQUNqQ0csT0FBTztvQkFDTDZULFFBQVE3VDtnQkFDVjtZQUNGO1lBRUEsb0JBQW9CeEosTUFBTTBILEtBQUssSUFBSS9ILEtBQUtnUCxHQUFHLENBQUNuSyxhQUFhO2dCQUFDeEU7Z0JBQU9EO2FBQU8sR0FBR3dFLFVBQVU7Z0JBQ25GMk4sZ0JBQWdCO1lBQ2xCLElBQUksMkNBQTJDO1lBRS9DNVMsb0RBQVVBLENBQUNtTCxPQUFPLENBQUMsU0FBVTZTLENBQUM7Z0JBQzVCLE9BQU9oWSxZQUFZZ1ksTUFBTUEsRUFBRXJMLE1BQU0sS0FBTXpOLENBQUFBLGFBQWExRSxLQUFLeWQsZ0JBQWdCLElBQUl4ZCxTQUFTd0UsUUFBTyxLQUFPK1ksQ0FBQUEsRUFBRXRMLE1BQU0sR0FBRyxLQUFJO1lBQ3JILElBQUksdUZBQXVGO1lBRzNGMkksV0FBV3JWLFlBQVlrRSxLQUFLNlQsTUFBTSxJQUFJN1QsS0FBSzZULE1BQU0sR0FBRzdULEtBQUs2VCxNQUFNLEtBQUssV0FBVy9ULGlCQUFpQjVELGFBQWE4RCxLQUFLNlQsTUFBTSxLQUFLLHNCQUFzQmxULHFCQUFxQnpFLGFBQWE4RCxLQUFLZ1UsV0FBVyxLQUFLLFFBQVEsa0JBQVVuYixLQUFLLEVBQUUrSCxFQUFFO2dCQUNuTyxPQUFPWCxpQkFBaUJELEtBQUs2VCxNQUFNLEVBQUVoYixPQUFPUCxhQUFheVksY0FBYyxNQUFNLElBQUluUSxHQUFHSixTQUFTO1lBQy9GLElBQUlySyxLQUFLNEosS0FBSyxDQUFDQyxJQUFJLENBQUNBLEtBQUs2VCxNQUFNO1lBQy9CakIsZUFBZTVTLEtBQUtKLFFBQVEsSUFBSTtnQkFDOUJxVSxLQUFLO2dCQUNMeFksS0FBSztZQUNQO1lBQ0FtWCxlQUFlNVcsVUFBVTRXLGdCQUFnQmhjLE9BQU9nYyxhQUFhcUIsR0FBRyxFQUFFckIsYUFBYW5YLEdBQUcsSUFBSTdFLE9BQU9nYyxjQUFjQTtZQUMzR0Msa0JBQWtCMWMsS0FBSytkLFdBQVcsQ0FBQ2xVLEtBQUttVSxLQUFLLElBQUl4QixjQUFjLEtBQUssS0FBSztnQkFDdkUsSUFBSXZJLFNBQVN6SSxjQUNUeVMsb0JBQW9COWIsYUFBYXlZLGNBQWMsS0FDL0N2UyxRQUFReVMsUUFBUXpTLEtBQUs7Z0JBRXpCLElBQUksQ0FBQzRWLHFCQUFxQnZhLEtBQUtpRCxHQUFHLENBQUMvRCxLQUFLc2IsV0FBVyxNQUFNLEVBQUMsS0FBTSxDQUFDN1YsU0FBUyxDQUFDeEgsa0JBQWtCOFosYUFBYTFHLFFBQVE7b0JBQ2hILElBQUkvTixXQUFXLENBQUMrTixTQUFTeEYsS0FBSSxJQUFLZ04sUUFDOUIyQixnQkFBZ0JyWCxhQUFhLENBQUNnVSxXQUFXaFUsVUFBVXFYLGFBQWEsS0FBS2xYLFVBQ3JFaVksV0FBV0Ysb0JBQW9CLElBQUksQ0FBQ2IsZ0JBQWdCZCxLQUFJLElBQU1uYSxDQUFBQSxhQUFhekIsTUFBSyxJQUFLLFFBQVEsR0FDN0Z1WCxVQUFValksS0FBSzRKLEtBQUssQ0FBQy9HLEtBQUssQ0FBQyxDQUFDcUQsVUFBVSxJQUFJQSxVQUFVUSxLQUFLeVgsV0FBVyxLQUFLQSxXQUFXLFFBQ3BGQyxhQUFhbFksV0FBWTJELENBQUFBLEtBQUt3VSxPQUFPLEtBQUssUUFBUSxJQUFJcEcsT0FBTSxHQUM1RHFHLFVBQ0FDLFdBQ0FDLFFBQVEzVSxNQUNSNFUsVUFBVUQsTUFBTUMsT0FBTyxFQUN2QkMsZUFBZUYsTUFBTWhILFdBQVcsRUFDaENtSCxjQUFjSCxNQUFNckcsVUFBVTtvQkFDbENtRyxXQUFXdEQsU0FBU29ELFlBQVl4YjtvQkFDaENnRCxVQUFVMFksYUFBY0EsQ0FBQUEsV0FBV0YsVUFBUyxHQUFJLGlGQUFpRjtvQkFFaklHLFlBQVk3YSxLQUFLQyxLQUFLLENBQUM4SyxRQUFRNlAsV0FBVzdDO29CQUUxQyxJQUFJeEgsVUFBVWYsT0FBT2UsVUFBVXhGLFNBQVM4UCxjQUFjdEssUUFBUTt3QkFDNUQsSUFBSTVMLFNBQVMsQ0FBQ0EsTUFBTWtWLFFBQVEsSUFBSWxWLE1BQU11VyxJQUFJLElBQUlsWSxLQUFLNlgsWUFBWXRLLFNBQVM7NEJBQ3RFLGtHQUFrRzs0QkFDbEc7d0JBQ0Y7d0JBRUEsSUFBSXBLLEtBQUt3VSxPQUFPLEtBQUssT0FBTzs0QkFDMUJwRyxVQUFVcUcsV0FBV3BZO3dCQUN2Qjt3QkFFQTRVLFFBQVF5RCxXQUFXOzRCQUNqQjlVLFVBQVVnVCxhQUFhL1YsS0FBS2hELEtBQUs0QixHQUFHLENBQUNvQixLQUFLMFgsYUFBYWhCLGdCQUFnQjFXLEtBQUs0WCxXQUFXbEIsa0JBQWtCLFFBQVFlLFdBQVcsUUFBUTs0QkFDcEloQixNQUFNdFQsS0FBS3NULElBQUksSUFBSTs0QkFDbkJ5QixNQUFNbFksS0FBSzZYLFlBQVl0Szs0QkFDdkIsMEdBQTBHOzRCQUMxR3VELGFBQWEsU0FBU0E7Z0NBQ3BCLE9BQU9rRixnQkFBZ0J6TSxPQUFPLENBQUMsU0FBU3lPLGdCQUFnQkEsYUFBYTliOzRCQUN2RTs0QkFDQXVWLFlBQVksU0FBU0E7Z0NBQ25CdlYsS0FBS2lSLE1BQU07Z0NBQ1g4RyxXQUFXblA7Z0NBRVgsSUFBSXpGLFdBQVc7b0NBQ2IsK0pBQStKO29DQUMvSndXLGFBQWFBLFdBQVdzQyxPQUFPLENBQUMsaUJBQWlCUCxVQUFVdlksVUFBVStZLE1BQU0sR0FBRy9ZLFVBQVVnWixLQUFLLElBQUloWixVQUFVRyxRQUFRLENBQUNvWTtnQ0FDdEg7Z0NBRUFqQyxRQUFRQyxRQUFRdlcsYUFBYSxDQUFDZ1UsV0FBV2hVLFVBQVVxWCxhQUFhLEtBQUt4YSxLQUFLc0QsUUFBUTtnQ0FDbEZ1VCxrQkFBa0JBLGVBQWU3VztnQ0FDakMrYixlQUFlQSxZQUFZL2I7NEJBQzdCO3dCQUNGLEdBQUdxUixRQUFRZ0UsVUFBVXdELFFBQVE4QyxZQUFZdEssU0FBU2dFLFVBQVV3RDt3QkFDNURnRCxXQUFXQSxRQUFRN2IsTUFBTWtZLFFBQVF6UyxLQUFLO29CQUN4QztnQkFDRixPQUFPLElBQUl6RixLQUFLb2MsUUFBUSxJQUFJckUsYUFBYTFHLFFBQVE7b0JBQy9DeUksZ0JBQWdCek0sT0FBTyxDQUFDO2dCQUMxQjtZQUNGLEdBQUdoSyxLQUFLO1FBQ1Y7UUFFQTJMLE1BQU8xQyxDQUFBQSxJQUFJLENBQUMwQyxHQUFHLEdBQUdoUCxJQUFHO1FBQ3JCb08sVUFBVXBPLEtBQUtvTyxPQUFPLEdBQUd4Uix3REFBVUEsQ0FBQ3dSLFdBQVcyQixRQUFRLFFBQVFBLE1BQU0sdVVBQXVVO1FBRTVZbUsscUJBQXFCOUwsV0FBV0EsUUFBUXlELEtBQUssSUFBSXpELFFBQVF5RCxLQUFLLENBQUN3SyxRQUFRO1FBQ3ZFbkMsc0JBQXVCQSxDQUFBQSxxQkFBcUJBLG1CQUFtQmxhLEtBQUk7UUFDbkUrUCxNQUFNQSxRQUFRLE9BQU8zQixVQUFVeFIsd0RBQVVBLENBQUNtVDtRQUMxQzdQLFVBQVVxVyxnQkFBaUJBLENBQUFBLGNBQWM7WUFDdkMrRixTQUFTbE87WUFDVG1PLFdBQVdoRztRQUNiO1FBRUEsSUFBSXhHLEtBQUs7WUFDUDJHLGVBQWUsU0FBU0EsZUFBZS9SLFdBQVkrUixDQUFBQSxhQUFhLENBQUNBLGNBQWMzRyxJQUFJa0MsVUFBVSxJQUFJbEMsSUFBSWtDLFVBQVUsQ0FBQzlNLEtBQUssSUFBSUosa0JBQWtCZ0wsSUFBSWtDLFVBQVUsRUFBRWpHLE9BQU8sS0FBSyxTQUFTLFFBQVF0SCxRQUFPLEdBQUksK0lBQStJO1lBRWxWMUUsS0FBSytQLEdBQUcsR0FBR0E7WUFDWG9JLFdBQVcvYSxLQUFLc1YsSUFBSSxDQUFDQyxRQUFRLENBQUM1QztZQUU5QixJQUFJLENBQUNvSSxTQUFTekcsTUFBTSxFQUFFO2dCQUNwQiwyUUFBMlE7Z0JBQzNRLElBQUlzRixXQUFXO29CQUNiQSxZQUFZcGEsd0RBQVVBLENBQUNvYTtvQkFDdkJBLGFBQWEsQ0FBQ0EsVUFBVVgsUUFBUSxJQUFLVyxDQUFBQSxZQUFZQSxVQUFVakMsT0FBTyxJQUFJaUMsVUFBVXdGLGFBQWEsR0FBRyxzQkFBc0I7b0JBRXRIckUsU0FBU3JHLGNBQWMsR0FBRyxDQUFDLENBQUNrRjtvQkFDNUJBLGFBQWNtQixDQUFBQSxTQUFTcEcsV0FBVyxHQUFHZ0IsVUFBVWlFLFVBQVM7Z0JBQzFEO2dCQUVBbUIsU0FBU3pHLE1BQU0sR0FBR0EsU0FBU3NGLGFBQWF6WixLQUFLbU4sYUFBYSxDQUFDO2dCQUMzRGdILE9BQU8rSyxTQUFTLENBQUM5WSxHQUFHLENBQUM7Z0JBQ3JCcUwsTUFBTTBDLE9BQU8rSyxTQUFTLENBQUM5WSxHQUFHLENBQUMsZ0JBQWdCcUw7Z0JBQzNDbUosU0FBU2EsUUFBUSxHQUFHRixtQkFBbUIvRixVQUFVaEQ7WUFDbkQsT0FBTztnQkFDTCtJLG1CQUFtQlgsU0FBU2EsUUFBUTtZQUN0QztZQUVBak4sS0FBSzJRLE9BQU8sS0FBSyxTQUFTdGYsS0FBS2dQLEdBQUcsQ0FBQzJELEtBQUs7Z0JBQ3RDMk0sU0FBUztZQUNYO1lBQ0ExYyxLQUFLMFIsTUFBTSxHQUFHQSxTQUFTeUcsU0FBU3pHLE1BQU07WUFDdENTLEtBQUtwTixrQkFBa0JnTDtZQUN2QnNKLGVBQWVsSCxFQUFFLENBQUN1RSxhQUFhalAsVUFBVWtWLEdBQUcsQ0FBQztZQUM3QzFELFlBQVk3YixLQUFLd2YsV0FBVyxDQUFDN007WUFDN0JtSixZQUFZOWIsS0FBS3lmLFdBQVcsQ0FBQzlNLEtBQUt0SSxVQUFVcEYsQ0FBQyxFQUFFeUMsTUFBTSx3YkFBd2I7WUFFN2VvTixXQUFXbkMsS0FBSzJCLFFBQVFTO1lBRXhCNkcsV0FBV2pHLFVBQVVoRDtRQUN2QjtRQUVBLElBQUk0SCxTQUFTO1lBQ1hnQixhQUFhMVYsVUFBVTBVLFdBQVd2UyxhQUFhdVMsU0FBUzdPLG1CQUFtQkE7WUFDM0UyUCxxQkFBcUJ0TyxjQUFjLGtCQUFrQjZFLElBQUloTixVQUFVeUYsV0FBV2tSLFlBQVk7WUFDMUZELG1CQUFtQnZPLGNBQWMsZ0JBQWdCNkUsSUFBSWhOLFVBQVV5RixXQUFXa1IsWUFBWSxHQUFHRjtZQUN6RmxPLFNBQVNrTyxrQkFBa0IsQ0FBQyxXQUFXaFIsVUFBVWlFLEVBQUUsQ0FBQ3RKLEVBQUUsQ0FBQztZQUV2RCxJQUFJMGEsVUFBVWxnQix3REFBVUEsQ0FBQ00sMkRBQWFBLENBQUM4RSxVQUFVLGNBQWNBO1lBRS9EdVcsY0FBYyxJQUFJLENBQUNBLFdBQVcsR0FBR3BPLGNBQWMsU0FBUzZFLElBQUk4TixTQUFTclYsV0FBV2tSLFlBQVlwTyxRQUFRLEdBQUdFO1lBQ3ZHK04sWUFBWSxJQUFJLENBQUNBLFNBQVMsR0FBR3JPLGNBQWMsT0FBTzZFLElBQUk4TixTQUFTclYsV0FBV2tSLFlBQVlwTyxRQUFRLEdBQUdFO1lBQ2pHQSxzQkFBdUJ3UCxDQUFBQSxpQkFBaUI3YyxLQUFLeWYsV0FBVyxDQUFDO2dCQUFDdEU7Z0JBQWFDO2FBQVUsRUFBRS9RLFVBQVVwRixDQUFDLEVBQUV5QyxJQUFHO1lBRW5HLElBQUksQ0FBQzZGLG9CQUFvQixDQUFFM04sQ0FBQUEsa0RBQVFBLENBQUNxRCxNQUFNLElBQUluRCwyREFBYUEsQ0FBQzhFLFVBQVUsb0JBQW9CLElBQUcsR0FBSTtnQkFDL0ZpRCxrQkFBa0JoRCxhQUFheEUsUUFBUXVFO2dCQUV2QzVFLEtBQUtnUCxHQUFHLENBQUM7b0JBQUNxTTtvQkFBb0JDO2lCQUFpQixFQUFFO29CQUMvQ2dFLFNBQVM7Z0JBQ1g7Z0JBQ0FwRCxvQkFBb0JsYyxLQUFLeWYsV0FBVyxDQUFDcEUsb0JBQW9CaFIsVUFBVXBGLENBQUMsRUFBRXlDO2dCQUN0RTBVLGtCQUFrQnBjLEtBQUt5ZixXQUFXLENBQUNuRSxrQkFBa0JqUixVQUFVcEYsQ0FBQyxFQUFFeUM7WUFDcEU7UUFDRjtRQUVBLElBQUkyRixvQkFBb0I7WUFDdEIsSUFBSXNTLGNBQWN0UyxtQkFBbUJzQixJQUFJLENBQUM2SixRQUFRLEVBQzlDb0gsWUFBWXZTLG1CQUFtQnNCLElBQUksQ0FBQ2tSLGNBQWM7WUFDdER4UyxtQkFBbUJ5UyxhQUFhLENBQUMsWUFBWTtnQkFDM0NsZCxLQUFLaVIsTUFBTSxDQUFDLEdBQUcsR0FBRztnQkFDbEI4TCxlQUFlQSxZQUFZSSxLQUFLLENBQUMxUyxvQkFBb0J1UyxhQUFhLEVBQUU7WUFDdEU7UUFDRjtRQUVBaGQsS0FBS29kLFFBQVEsR0FBRztZQUNkLE9BQU8vUSxTQUFTLENBQUNBLFVBQVVqTSxPQUFPLENBQUNKLFFBQVEsRUFBRTtRQUMvQztRQUVBQSxLQUFLcWQsSUFBSSxHQUFHO1lBQ1YsT0FBT2hSLFNBQVMsQ0FBQ0EsVUFBVWpNLE9BQU8sQ0FBQ0osUUFBUSxFQUFFO1FBQy9DO1FBRUFBLEtBQUtxTyxNQUFNLEdBQUcsU0FBVUEsTUFBTSxFQUFFaVAsSUFBSTtZQUNsQyxJQUFJLENBQUNBLE1BQU07Z0JBQ1QsT0FBT3RkLEtBQUt1RyxJQUFJLENBQUM7WUFDbkIsRUFBRSxrRkFBa0Y7WUFHcEYsSUFBSWdYLElBQUlsUCxXQUFXLFNBQVMsQ0FBQ3JPLEtBQUt3RCxPQUFPLEVBQ3JDZ2EsaUJBQWlCeGY7WUFFckIsSUFBSXVmLE1BQU12ZCxLQUFLNGEsVUFBVSxFQUFFO2dCQUN6QixJQUFJMkMsR0FBRztvQkFDTHhELGFBQWFqWixLQUFLNEIsR0FBRyxDQUFDa0csY0FBYzVJLEtBQUtxUixNQUFNLENBQUMxQyxHQUFHLElBQUksSUFBSSwrTEFBK0w7b0JBRTFQc0osZUFBZWpZLEtBQUtzRCxRQUFRO29CQUM1QjBXLG1CQUFtQjdXLGFBQWFBLFVBQVVHLFFBQVE7Z0JBQ3BEO2dCQUVBaVYsZUFBZTtvQkFBQ0E7b0JBQWFDO29CQUFXQztvQkFBb0JDO2lCQUFpQixDQUFDeFEsT0FBTyxDQUFDLFNBQVVpTSxDQUFDO29CQUMvRixPQUFPQSxFQUFFaFAsS0FBSyxDQUFDNkcsT0FBTyxHQUFHdVIsSUFBSSxTQUFTO2dCQUN4QztnQkFFQSxJQUFJQSxHQUFHO29CQUNMdmYsY0FBY2dDO29CQUNkQSxLQUFLaVIsTUFBTSxDQUFDc00sSUFBSSxtSUFBbUk7Z0JBQ3JKO2dCQUVBLElBQUl4TixPQUFRLEVBQUNnSCxlQUFlLENBQUMvVyxLQUFLb2MsUUFBUSxHQUFHO29CQUMzQyxJQUFJbUIsR0FBRzt3QkFDTDlMLFlBQVkxQixLQUFLMkIsUUFBUW9IO29CQUMzQixPQUFPO3dCQUNMNUcsV0FBV25DLEtBQUsyQixRQUFRM00sa0JBQWtCZ0wsTUFBTWdDO29CQUNsRDtnQkFDRjtnQkFFQXdMLEtBQUt2ZCxLQUFLaVIsTUFBTSxDQUFDc00sSUFBSSwwRkFBMEY7Z0JBRS9HdmYsY0FBY3dmLGdCQUFnQix3RkFBd0Y7Z0JBRXRIeGQsS0FBSzRhLFVBQVUsR0FBRzJDO1lBQ3BCO1FBQ0Y7UUFFQXZkLEtBQUs2UCxPQUFPLEdBQUcsU0FBVTROLElBQUksRUFBRWpQLEtBQUssRUFBRXRKLFFBQVEsRUFBRXdZLFNBQVM7WUFDdkQsOE9BQThPO1lBQzlPLElBQUksQ0FBQzFmLGVBQWUsQ0FBQ2dDLEtBQUt3RCxPQUFPLEtBQUssQ0FBQ2dMLE9BQU87Z0JBQzVDO1lBQ0Y7WUFFQSxJQUFJdUIsT0FBTzBOLFFBQVE5ZCxpQkFBaUI7Z0JBQ2xDd0ksYUFBYXNGLGVBQWUsYUFBYUQ7Z0JBRXpDO1lBQ0Y7WUFFQSxDQUFDaUIsa0JBQWtCbUosaUJBQWlCQSxjQUFjNVg7WUFDbERoQyxjQUFjZ0M7WUFFZCxJQUFJa1ksUUFBUXpTLEtBQUssSUFBSSxDQUFDUCxVQUFVO2dCQUM5QixpSkFBaUo7Z0JBQ2pKZ1QsUUFBUXpTLEtBQUssQ0FBQ2MsSUFBSTtnQkFDbEIyUixRQUFRelMsS0FBSyxHQUFHO1lBQ2xCO1lBRUFrVSxjQUFjQSxXQUFXdFcsS0FBSztZQUM5QnNULHVCQUF1QnhULGFBQWFBLFVBQVVrTCxNQUFNLENBQUM7Z0JBQ25EOUgsTUFBTTtZQUNSLEdBQUdvWCxVQUFVO1lBQ2IzZCxLQUFLNGEsVUFBVSxJQUFJNWEsS0FBS3FPLE1BQU0sQ0FBQyxNQUFNO1lBQ3JDck8sS0FBSzhQLGFBQWEsR0FBRyxPQUFPLHdEQUF3RDtZQUVwRixJQUFJaEcsT0FBTytOLG1CQUNQdkUsaUJBQWlCd0Usc0JBQ2pCcFYsTUFBTStILHFCQUFxQkEsbUJBQW1CNUQsUUFBUSxLQUFLdEUsV0FBV1AsVUFBVXlGLFlBQ2hGbVcsaUJBQWlCL0UsVUFBVSxNQUMzQnRPLFNBQVMsR0FDVHNULGlCQUFpQkgsYUFBYSxHQUM5QkksWUFBWTdhLFVBQVVpQyxZQUFZQSxTQUFTb0wsR0FBRyxHQUFHdkUsS0FBS3VFLEdBQUcsRUFDekR5TixtQkFBbUJoUyxLQUFLaVMsVUFBVSxJQUFJNVAsU0FDdEM2UCxjQUFjaGIsVUFBVWlDLFlBQVlBLFNBQVMyRyxLQUFLLEdBQUdFLEtBQUtGLEtBQUssSUFBS0UsQ0FBQUEsS0FBS0YsS0FBSyxLQUFLLEtBQUssQ0FBQ3VDLFVBQVUsSUFBSTJCLE1BQU0sUUFBUSxRQUFPLEdBQzVIbU8sa0JBQWtCbGUsS0FBS2tlLGVBQWUsR0FBR25TLEtBQUttUyxlQUFlLElBQUl0aEIsd0RBQVVBLENBQUNtUCxLQUFLbVMsZUFBZSxFQUFFbGUsT0FDbEdtZSxlQUFlL1AsV0FBV3ROLEtBQUs0QixHQUFHLENBQUMsR0FBRzJKLFVBQVVqTSxPQUFPLENBQUNKLFVBQVUsR0FDbEU4QyxJQUFJcWIsY0FDSmhNLElBQ0E5TCxRQUNBZ0wsUUFDQStNLFlBQ0FuTCxVQUNBb0wsWUFDQUMsUUFDQUMsZ0JBQ0FDLFNBQ0FDLGNBQ0FDLGdCQUNBQyxtQkFDQUM7WUFFSixJQUFJakgsV0FBVzFVLFVBQVVpQyxXQUFXO2dCQUNsQyxvWUFBb1k7Z0JBQ3BZeVosb0JBQW9CdmhCLEtBQUt3ZixXQUFXLENBQUNuRSxvQkFBb0JoUixVQUFVbEMsQ0FBQztnQkFDcEVxWixrQkFBa0J4aEIsS0FBS3dmLFdBQVcsQ0FBQ2xFLGtCQUFrQmpSLFVBQVVsQyxDQUFDO1lBQ2xFO1lBRUEsTUFBT3pDLElBQUs7Z0JBQ1Ysd1JBQXdSO2dCQUN4UnViLGFBQWFoUyxTQUFTLENBQUN2SixFQUFFO2dCQUN6QnViLFdBQVcvTixHQUFHLElBQUkrTixXQUFXeE8sT0FBTyxDQUFDLEdBQUcsTUFBTzdSLENBQUFBLGNBQWNnQyxJQUFHLEdBQUksZ1JBQWdSO2dCQUVwVnNlLFNBQVNELFdBQVd0TyxHQUFHO2dCQUV2QixJQUFJdU8sVUFBV0EsQ0FBQUEsV0FBV2xRLFdBQVdrUSxXQUFXdk8sT0FBT3VPLFdBQVdKLGVBQWMsS0FBTSxDQUFDRyxXQUFXekQsVUFBVSxFQUFFO29CQUM1RzZELGdCQUFpQkEsQ0FBQUEsZUFBZSxFQUFFO29CQUNsQ0EsYUFBYUksT0FBTyxDQUFDUixhQUFhLHFGQUFxRjtvQkFFdkhBLFdBQVdoUSxNQUFNLENBQUMsTUFBTTtnQkFDMUI7Z0JBRUEsSUFBSWdRLGVBQWVoUyxTQUFTLENBQUN2SixFQUFFLEVBQUU7b0JBQy9CLDBCQUEwQjtvQkFDMUJxYjtvQkFDQXJiO2dCQUNGO1lBQ0Y7WUFFQUMsWUFBWWtiLGdCQUFpQkEsQ0FBQUEsY0FBY0EsWUFBWWplLEtBQUk7WUFDM0RpZSxjQUFjcGUsWUFBWW9lLGFBQWEsU0FBU2plO1lBQ2hENkwsUUFBUXNILGVBQWU4SyxhQUFhN1AsU0FBU3RFLE1BQU1yQyxXQUFXbUIsY0FBYzJQLGFBQWFFLG9CQUFvQnpZLE1BQU1zVCxnQkFBZ0JDLGFBQWE1SSxrQkFBa0JqSSxLQUFLK0gsb0JBQW9CekssS0FBS3lRLFdBQVcsSUFBSSxrQkFBbUJWLENBQUFBLE1BQU0sQ0FBQyxRQUFRO1lBQ2pQaE4sWUFBWSthLGNBQWVBLENBQUFBLFlBQVlBLFVBQVU5ZCxLQUFJO1lBRXJELElBQUlFLFVBQVU0ZCxjQUFjLENBQUNBLFVBQVUxZCxPQUFPLENBQUMsT0FBTztnQkFDcEQsSUFBSSxDQUFDMGQsVUFBVTFkLE9BQU8sQ0FBQyxNQUFNO29CQUMzQjBkLFlBQVksQ0FBQzVkLFVBQVUrZCxlQUFlQSxZQUFZaFcsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBQyxJQUFLNlY7Z0JBQzFFLE9BQU87b0JBQ0x2VCxTQUFTVixZQUFZaVUsVUFBVTNkLE1BQU0sQ0FBQyxJQUFJMko7b0JBQzFDZ1UsWUFBWTVkLFVBQVUrZCxlQUFlQSxjQUFjLENBQUN4VCxxQkFBcUJyTixLQUFLNEosS0FBSyxDQUFDaU4sUUFBUSxDQUFDLEdBQUd4SixtQkFBbUI1RCxRQUFRLElBQUk0RCxtQkFBbUJ5SixhQUFhLENBQUNySSxLQUFLLEVBQUVwQixtQkFBbUJ5SixhQUFhLENBQUM1RCxHQUFHLEVBQUV6RSxTQUFTQSxLQUFJLElBQUt0QixRQUFRLHFGQUFxRjtvQkFFNVR3VCxtQkFBbUIzUDtnQkFDckI7WUFDRjtZQUVBMFAsWUFBWWplLFlBQVlpZSxXQUFXLE9BQU85ZDtZQUMxQ3NRLE1BQU14UCxLQUFLNEIsR0FBRyxDQUFDbUosT0FBT3NILGVBQWUySyxhQUFjQyxDQUFBQSxtQkFBbUIsV0FBV3JiLEdBQUUsR0FBSXFiLGtCQUFrQmpVLE1BQU1yQyxXQUFXbUIsZUFBZTJCLFFBQVFpTyxXQUFXRSxrQkFBa0IxWSxNQUFNc1QsZ0JBQWdCQyxhQUFhNUksa0JBQWtCakksS0FBSytILG9CQUFvQnpLLEtBQUt1USxTQUFTLElBQUksaUJBQWlCLENBQUM7WUFDaFNoRyxTQUFTO1lBQ1R6SCxJQUFJcWI7WUFFSixNQUFPcmIsSUFBSztnQkFDVnViLGFBQWFoUyxTQUFTLENBQUN2SixFQUFFO2dCQUN6QndiLFNBQVNELFdBQVd0TyxHQUFHO2dCQUV2QixJQUFJdU8sVUFBVUQsV0FBV3hTLEtBQUssR0FBR3dTLFdBQVdTLFFBQVEsSUFBSWpULFNBQVMsQ0FBQ3BCLHNCQUFzQjRULFdBQVcvTixHQUFHLEdBQUcsR0FBRztvQkFDMUc2QixLQUFLa00sV0FBVy9OLEdBQUcsR0FBSXRRLENBQUFBLEtBQUt5USxXQUFXLEdBQUczUCxLQUFLNEIsR0FBRyxDQUFDLEdBQUcyYixXQUFXeFMsS0FBSyxJQUFJd1MsV0FBV3hTLEtBQUs7b0JBRTFGLElBQUksQ0FBQ3lTLFdBQVdsUSxXQUFXaVEsV0FBV3hTLEtBQUssR0FBR3dTLFdBQVdTLFFBQVEsR0FBR2pULFNBQVN5UyxXQUFXSixlQUFjLEtBQU1ySyxNQUFNb0ssY0FBYzt3QkFDOUgsMkVBQTJFO3dCQUMzRTFULFVBQVU0SCxLQUFNLEtBQUlrTSxXQUFXL2EsUUFBUTtvQkFDekM7b0JBRUFnYixXQUFXdk8sT0FBUThOLENBQUFBLGtCQUFrQjFMLEVBQUM7Z0JBQ3hDO1lBQ0Y7WUFFQXRHLFNBQVN0QjtZQUNUK0YsT0FBTy9GO1lBQ1B2SyxLQUFLeVEsV0FBVyxJQUFLelEsQ0FBQUEsS0FBS3lRLFdBQVcsSUFBSWxHLE1BQUs7WUFFOUMsSUFBSXZLLEtBQUt1USxTQUFTLElBQUksQ0FBQzlCLGdCQUFnQjtnQkFDckN6TyxLQUFLdVEsU0FBUyxHQUFHRCxPQUFPLENBQUM7Z0JBQ3pCQSxNQUFNeFAsS0FBS29hLEdBQUcsQ0FBQzVLLEtBQUsvTixXQUFXUCxVQUFVeUY7WUFDM0M7WUFFQW9SLFNBQVN2SSxNQUFNekUsU0FBUyxDQUFDQSxTQUFTLElBQUcsS0FBTTtZQUUzQyxJQUFJK1IsZ0JBQWdCO2dCQUNsQix5T0FBeU87Z0JBQ3pPM0YsZUFBZTdhLEtBQUs0SixLQUFLLENBQUMvRyxLQUFLLENBQUMsR0FBRyxHQUFHN0MsS0FBSzRKLEtBQUssQ0FBQytYLFNBQVMsQ0FBQ2xULE9BQU95RSxLQUFLeUo7WUFDekU7WUFFQS9aLEtBQUs4ZSxRQUFRLEdBQUdqQjtZQUVoQixJQUFJdEYsZUFBZWhPLFFBQVE7Z0JBQ3pCLGtDQUFrQztnQkFDbEM0SCxLQUFLLENBQUM7Z0JBQ05BLEVBQUUsQ0FBQzFLLFVBQVVwRixDQUFDLENBQUMsR0FBRyxPQUFPa0k7Z0JBQ3pCMlQsbUJBQW9CL0wsQ0FBQUEsRUFBRSxDQUFDMUssVUFBVWxDLENBQUMsQ0FBQyxHQUFHLE9BQU9xRCxZQUFXO2dCQUN4RHhMLEtBQUtnUCxHQUFHLENBQUM7b0JBQUNtTTtvQkFBYUM7aUJBQVUsRUFBRXJHO1lBQ3JDO1lBRUEsSUFBSXBDLE9BQU8sQ0FBRTNRLENBQUFBLGdCQUFnQlksS0FBS3NRLEdBQUcsSUFBSS9OLFdBQVdQLFVBQVV5RixVQUFTLEdBQUk7Z0JBQ3pFMEssS0FBS3BOLGtCQUFrQmdMO2dCQUN2QnFPLGFBQWEzVyxjQUFjNUssbURBQVNBO2dCQUNwQ3dVLFNBQVN6SSxjQUFjLHlEQUF5RDtnQkFFaEZ1USxXQUFXalAsV0FBVytPLFVBQVV4UixVQUFVcEYsQ0FBQyxLQUFLd2I7Z0JBRWhELElBQUksQ0FBQ25iLE9BQU80TixNQUFNLEdBQUc7b0JBQ25CLDBQQUEwUDtvQkFDMVBvTyxpQkFBaUIsQ0FBQ3pjLGFBQWExRSxLQUFLeWQsZ0JBQWdCLElBQUl4ZCxTQUFTd0UsUUFBTyxFQUFHbUQsS0FBSztvQkFDaEZ1WixpQkFBaUI7d0JBQ2Z2WixPQUFPdVo7d0JBQ1A1ZSxPQUFPNGUsY0FBYyxDQUFDLGFBQWFqWCxVQUFVcEYsQ0FBQyxDQUFDMmMsV0FBVyxHQUFHO29CQUMvRDtvQkFFQSxJQUFJL2MsY0FBYzhDLGtCQUFrQnRILE1BQU0sQ0FBQyxhQUFhZ0ssVUFBVXBGLENBQUMsQ0FBQzJjLFdBQVcsR0FBRyxLQUFLLFVBQVU7d0JBQy9GLG1GQUFtRjt3QkFDbkZOLGVBQWV2WixLQUFLLENBQUMsYUFBYXNDLFVBQVVwRixDQUFDLENBQUMyYyxXQUFXLEdBQUcsR0FBRztvQkFDakU7Z0JBQ0Y7Z0JBRUE5TSxXQUFXbkMsS0FBSzJCLFFBQVFTO2dCQUV4QjZHLFdBQVdqRyxVQUFVaEQsTUFBTSxpSkFBaUo7Z0JBRTVLMUosU0FBU3ZFLFdBQVdpTyxLQUFLO2dCQUN6QndPLGlCQUFpQjVULG9CQUFvQjFOLDREQUFjQSxDQUFDK0UsVUFBVW9jLGFBQWF0aEIscURBQVdBLEdBQUdELG1EQUFTQTtnQkFFbEcsSUFBSTZaLFlBQVk7b0JBQ2QzRSxjQUFjO3dCQUFDMkUsYUFBYWpQLFVBQVVrVixHQUFHO3dCQUFFOUQsU0FBU2dGLGlCQUFpQi9ZO3FCQUFJO29CQUN6RWlOLFlBQVluQyxDQUFDLEdBQUc4QjtvQkFDaEI1TyxJQUFJNFQsZUFBZWhTLFdBQVc4QixTQUFTdUosS0FBS3RJLGFBQWFvUixTQUFTZ0YsaUJBQWlCO29CQUVuRixJQUFJL2EsR0FBRzt3QkFDTGlQLFlBQVlqTCxJQUFJLENBQUNXLFVBQVV0RixDQUFDLEVBQUVXLElBQUlnQyxNQUFNLHFEQUFxRDt3QkFFN0Y0TSxPQUFPdk0sS0FBSyxDQUFDbU4sU0FBUyxLQUFLLFVBQVdaLENBQUFBLE9BQU92TSxLQUFLLENBQUNtTixTQUFTLEdBQUd4UCxJQUFJZ0MsR0FBRTtvQkFDdkU7b0JBRUE4TSxVQUFVRztvQkFFVixJQUFJbU0saUJBQWlCO3dCQUNuQiwyUEFBMlA7d0JBQzNQN1IsVUFBVW5FLE9BQU8sQ0FBQyxTQUFVMEgsQ0FBQzs0QkFDM0IsSUFBSUEsRUFBRUcsR0FBRyxLQUFLbU8sbUJBQW1CdE8sRUFBRTdELElBQUksQ0FBQzJLLFVBQVUsS0FBSyxPQUFPO2dDQUM1RDlHLEVBQUVFLGFBQWEsR0FBRzs0QkFDcEI7d0JBQ0Y7b0JBQ0Y7b0JBRUFuRixvQkFBb0IvQixXQUFXbVI7Z0JBQ2pDLE9BQU87b0JBQ0xqWCxJQUFJMEQsU0FBU3VKLEtBQUt0STtvQkFDbEIzRSxLQUFLNE8sT0FBT3ZNLEtBQUssQ0FBQ21OLFNBQVMsS0FBSyxVQUFXWixDQUFBQSxPQUFPdk0sS0FBSyxDQUFDbU4sU0FBUyxHQUFHeFAsSUFBSWdDLEdBQUU7Z0JBQzVFO2dCQUVBLElBQUk2RixrQkFBa0I7b0JBQ3BCc0ksV0FBVzt3QkFDVHpKLEtBQUtuRCxPQUFPbUQsR0FBRyxHQUFJNFUsQ0FBQUEsYUFBYS9NLFNBQVN4RixRQUFRMFMsY0FBYSxJQUFLelo7d0JBQ25FMkUsTUFBTXBELE9BQU9vRCxJQUFJLEdBQUkyVSxDQUFBQSxhQUFhRyxpQkFBaUJsTixTQUFTeEYsS0FBSSxJQUFLL0c7d0JBQ3JFME4sV0FBVzt3QkFDWHROLFVBQVU7b0JBQ1o7b0JBQ0ErTixRQUFRLENBQUM3TyxPQUFPLEdBQUc2TyxRQUFRLENBQUMsUUFBUXJPLE9BQU8sR0FBRzlELEtBQUttZSxJQUFJLENBQUM1WSxPQUFPMUUsS0FBSyxJQUFJbUQ7b0JBQ3hFbU8sUUFBUSxDQUFDNU8sUUFBUSxHQUFHNE8sUUFBUSxDQUFDLFFBQVFwTyxRQUFRLEdBQUcvRCxLQUFLbWUsSUFBSSxDQUFDNVksT0FBT3hFLE1BQU0sSUFBSWlEO29CQUMzRW1PLFFBQVEsQ0FBQ3RPLFFBQVEsR0FBR3NPLFFBQVEsQ0FBQ3RPLFVBQVVILEtBQUssR0FBR3lPLFFBQVEsQ0FBQ3RPLFVBQVVMLE9BQU8sR0FBRzJPLFFBQVEsQ0FBQ3RPLFVBQVVGLFFBQVEsR0FBR3dPLFFBQVEsQ0FBQ3RPLFVBQVVKLE1BQU0sR0FBRztvQkFDdEkwTyxRQUFRLENBQUN2TyxTQUFTLEdBQUd5TixFQUFFLENBQUN6TixTQUFTO29CQUNqQ3VPLFFBQVEsQ0FBQ3ZPLFdBQVdGLEtBQUssR0FBRzJOLEVBQUUsQ0FBQ3pOLFdBQVdGLEtBQUs7b0JBQy9DeU8sUUFBUSxDQUFDdk8sV0FBV0osT0FBTyxHQUFHNk4sRUFBRSxDQUFDek4sV0FBV0osT0FBTztvQkFDbkQyTyxRQUFRLENBQUN2TyxXQUFXRCxRQUFRLEdBQUcwTixFQUFFLENBQUN6TixXQUFXRCxRQUFRO29CQUNyRHdPLFFBQVEsQ0FBQ3ZPLFdBQVdILE1BQU0sR0FBRzROLEVBQUUsQ0FBQ3pOLFdBQVdILE1BQU07b0JBQ2pEd1UsaUJBQWlCL0YsV0FBVzhGLGtCQUFrQjdGLFVBQVU4RDtvQkFDeER0SSxrQkFBa0I3RixXQUFXO2dCQUMvQjtnQkFFQSxJQUFJekYsV0FBVztvQkFDYix5UEFBeVA7b0JBQ3pQcWIsVUFBVXJiLFVBQVV3WCxRQUFRLEVBQUUsd0dBQXdHO29CQUV0SW5jLG9CQUFvQjtvQkFFcEIyRSxVQUFVd04sTUFBTSxDQUFDeE4sVUFBVTBELFFBQVEsSUFBSSxNQUFNO29CQUM3Q3VTLFlBQVlILFVBQVV4UixVQUFVcEYsQ0FBQyxJQUFJOFcsV0FBV04sU0FBU2dGO29CQUN6RHRFLFdBQVd6WSxLQUFLaUQsR0FBRyxDQUFDOFUsU0FBU08sYUFBYTtvQkFDMUN6TyxvQkFBb0I0TyxZQUFZUixlQUFlbUcsTUFBTSxDQUFDbkcsZUFBZTFZLE1BQU0sR0FBRyxHQUFHLElBQUksMkhBQTJIO29CQUVoTjhDLFVBQVV3TixNQUFNLENBQUMsR0FBRyxNQUFNO29CQUMxQjZOLFdBQVdyYixVQUFVd2EsVUFBVSxDQUFDO29CQUNoQ3hhLFVBQVUwSCxNQUFNLElBQUkxSCxVQUFVUyxTQUFTLENBQUNULFVBQVVTLFNBQVMsS0FBSywwTkFBME47b0JBRTFScEYsb0JBQW9CO2dCQUN0QixPQUFPO29CQUNMNGEsWUFBWVA7Z0JBQ2Q7Z0JBRUE2RixrQkFBbUJBLENBQUFBLGVBQWU1ZSxLQUFLLEdBQUc0ZSxlQUFldlosS0FBSyxDQUFDLGFBQWFzQyxVQUFVcEYsQ0FBQyxDQUFDMmMsV0FBVyxHQUFHLEdBQUdOLGVBQWU1ZSxLQUFLLEdBQUc0ZSxlQUFldlosS0FBSyxDQUFDeU4sY0FBYyxDQUFDLGNBQWNuTCxVQUFVcEYsQ0FBQztZQUMvTCxPQUFPLElBQUkrTCxXQUFXeEYsZ0JBQWdCLENBQUM2QixvQkFBb0I7Z0JBQ3pELHNPQUFzTztnQkFDdE9wRSxTQUFTK0gsUUFBUTZELFVBQVU7Z0JBRTNCLE1BQU81TCxVQUFVQSxXQUFXNUksTUFBTztvQkFDakMsSUFBSTRJLE9BQU84WSxVQUFVLEVBQUU7d0JBQ3JCdFQsU0FBU3hGLE9BQU84WSxVQUFVO3dCQUMxQjdPLE9BQU9qSyxPQUFPOFksVUFBVTtvQkFDMUI7b0JBRUE5WSxTQUFTQSxPQUFPNEwsVUFBVTtnQkFDNUI7WUFDRjtZQUVBd00sZ0JBQWdCQSxhQUFhdlcsT0FBTyxDQUFDLFNBQVUwSCxDQUFDO2dCQUM5QyxPQUFPQSxFQUFFdkIsTUFBTSxDQUFDLE9BQU87WUFDekI7WUFDQXJPLEtBQUs2TCxLQUFLLEdBQUdBO1lBQ2I3TCxLQUFLc1EsR0FBRyxHQUFHQTtZQUNYK0gsVUFBVUMsVUFBVTdKLGlCQUFpQnNMLGFBQWFuUixjQUFjLGlCQUFpQjtZQUVqRixJQUFJLENBQUM2QixzQkFBc0IsQ0FBQ2dFLGdCQUFnQjtnQkFDMUM0SixVQUFVMEIsY0FBY25SLFdBQVdtUjtnQkFDbkMvWixLQUFLcVIsTUFBTSxDQUFDMUMsR0FBRyxHQUFHO1lBQ3BCO1lBRUEzTyxLQUFLcU8sTUFBTSxDQUFDLE9BQU87WUFDbkIySixjQUFjelk7WUFFZCxJQUFJdWEsaUJBQWlCO2dCQUNuQi9CLFdBQVcsQ0FBQyxHQUFHLHNFQUFzRTtnQkFDckYsMFRBQTBUO2dCQUUxVCtCLGdCQUFnQnpNLE9BQU8sQ0FBQztZQUMxQjtZQUVBclAsY0FBYztZQUNkbUYsYUFBYWdVLFlBQWFoVSxDQUFBQSxVQUFVd1gsUUFBUSxJQUFJWCxnQkFBZSxLQUFNN1csVUFBVUcsUUFBUSxPQUFPMFcsb0JBQW9CN1csVUFBVUcsUUFBUSxDQUFDMFcsb0JBQW9CLEdBQUcsTUFBTXJKLE1BQU0sQ0FBQ3hOLFVBQVVnTyxJQUFJLElBQUksTUFBTSxPQUFPLHVJQUF1STtZQUUvVSxJQUFJeU0sa0JBQWtCM0YsaUJBQWlCalksS0FBS3NELFFBQVEsSUFBSW1ILHNCQUFzQmtNLHFCQUFxQjtnQkFDakcsa0xBQWtMO2dCQUNsTHhULGFBQWEsQ0FBQ2dVLFlBQVloVSxVQUFVcVgsYUFBYSxDQUFDL1Asc0JBQXNCb0IsUUFBUSxDQUFDLFNBQVMsQ0FBQ29NLGVBQWU3YSxLQUFLNEosS0FBSyxDQUFDK1gsU0FBUyxDQUFDbFQsT0FBT3lFLEtBQUssS0FBSzJILGNBQWMsT0FBTywyRUFBMkU7Z0JBRWhQalksS0FBS3NELFFBQVEsR0FBR3NhLGtCQUFrQixDQUFDdkYsVUFBVXhNLEtBQUksSUFBS2dOLFdBQVdaLGVBQWUsSUFBSUE7WUFDdEY7WUFFQWxJLE9BQU8yRyxjQUFlaEYsQ0FBQUEsT0FBT3lOLFVBQVUsR0FBR3JlLEtBQUtDLEtBQUssQ0FBQ2YsS0FBS3NELFFBQVEsR0FBRzhWLFVBQVM7WUFDOUVPLGNBQWNBLFdBQVdnRSxVQUFVO1lBRW5DLElBQUksQ0FBQzlKLE1BQU04SyxvQkFBb0I7Z0JBQzdCLHVjQUF1YztnQkFDdmNBLHFCQUFxQnZoQixLQUFLd2YsV0FBVyxDQUFDbkUsb0JBQW9CaFIsVUFBVWxDLENBQUM7Z0JBQ3JFcVosbUJBQW1CeGhCLEtBQUt3ZixXQUFXLENBQUNsRSxrQkFBa0JqUixVQUFVbEMsQ0FBQztnQkFFakV5UCxhQUFheUQsb0JBQW9CaFIsV0FBV2tYO2dCQUU1QzNKLGFBQWF1RCxhQUFhOVEsV0FBV2tYLG9CQUFxQmpCLENBQUFBLGFBQWE7Z0JBRXZFMUksYUFBYTBELGtCQUFrQmpSLFdBQVdtWDtnQkFFMUM1SixhQUFhd0QsV0FBVy9RLFdBQVdtWCxrQkFBbUJsQixDQUFBQSxhQUFhO1lBQ3JFO1lBRUFFLGtCQUFrQixDQUFDblAsa0JBQWtCek8sS0FBS2lSLE1BQU0sSUFBSSw0V0FBNFc7WUFFaGEsSUFBSUwsYUFBYSxDQUFDbkMsa0JBQWtCLENBQUNtSyxvQkFBb0I7Z0JBQ3ZELG9PQUFvTztnQkFDcE9BLHFCQUFxQjtnQkFDckJoSSxVQUFVNVE7Z0JBQ1Y0WSxxQkFBcUI7WUFDdkI7UUFDRjtRQUVBNVksS0FBS3NiLFdBQVcsR0FBRztZQUNqQixPQUFPLENBQUMxUyxlQUFlMFAsT0FBTSxJQUFNL1ksQ0FBQUEsYUFBYXpCLE1BQUssSUFBSyxRQUFRO1FBQ3BFO1FBRUFrQyxLQUFLb2YsWUFBWSxHQUFHO1lBQ2xCbGMsY0FBY2xELEtBQUs2RCxpQkFBaUI7WUFFcEMsSUFBSVYsV0FBVztnQkFDYndXLGFBQWFBLFdBQVdyVyxRQUFRLENBQUMsS0FBSyxDQUFDSCxVQUFVc1gsTUFBTSxLQUFLdlgsY0FBY0MsV0FBV0EsVUFBVUMsUUFBUSxNQUFNK1QsWUFBWWpVLGNBQWNDLFdBQVduRCxLQUFLeUgsU0FBUyxHQUFHLEdBQUc7WUFDeEs7UUFDRjtRQUVBekgsS0FBS3FmLGFBQWEsR0FBRyxTQUFVQyxLQUFLO1lBQ2xDLE9BQU9uYyxhQUFhQSxVQUFVeUQsTUFBTSxJQUFJLENBQUNpRixTQUFTN0wsS0FBSzZQLE9BQU8sTUFBTWhFLEtBQUksSUFBSzFJLFVBQVV5RCxNQUFNLENBQUMwWSxNQUFNLEdBQUduYyxVQUFVMEQsUUFBUSxLQUFLZ1MsVUFBVTtRQUMxSTtRQUVBN1ksS0FBS3VmLFdBQVcsR0FBRyxTQUFVblYsSUFBSTtZQUMvQixJQUFJdEgsSUFBSXVKLFVBQVVqTSxPQUFPLENBQUNKLE9BQ3RCcUMsSUFBSXJDLEtBQUt5SCxTQUFTLEdBQUcsSUFBSTRFLFVBQVUvRSxLQUFLLENBQUMsR0FBR3hFLEdBQUcwYyxPQUFPLEtBQUtuVCxVQUFVL0UsS0FBSyxDQUFDeEUsSUFBSTtZQUVuRixPQUFPLENBQUM1QyxVQUFVa0ssUUFBUS9ILEVBQUVvZCxNQUFNLENBQUMsU0FBVTdQLENBQUM7Z0JBQzVDLE9BQU9BLEVBQUU3RCxJQUFJLENBQUNtTCxlQUFlLEtBQUs5TTtZQUNwQyxLQUFLL0gsQ0FBQUEsRUFBR29kLE1BQU0sQ0FBQyxTQUFVN1AsQ0FBQztnQkFDeEIsT0FBTzVQLEtBQUt5SCxTQUFTLEdBQUcsSUFBSW1JLEVBQUVVLEdBQUcsSUFBSXpFLFFBQVErRCxFQUFFL0QsS0FBSyxJQUFJeUU7WUFDMUQ7UUFDRjtRQUVBdFEsS0FBS2lSLE1BQU0sR0FBRyxTQUFVeU8sS0FBSyxFQUFFdE8sY0FBYyxFQUFFdU8sU0FBUztZQUN0RCxJQUFJbFYsc0JBQXNCLENBQUNrVixhQUFhLENBQUNELE9BQU87Z0JBQzlDO1lBQ0Y7WUFFQSxJQUFJck8sU0FBUzVDLG1CQUFtQixPQUFPc0wsYUFBYS9aLEtBQUtxUixNQUFNLElBQzNEOUwsSUFBSW1hLFFBQVEsSUFBSSxDQUFDck8sU0FBU3hGLEtBQUksSUFBS2dOLFFBQ25DK0csVUFBVXJhLElBQUksSUFBSSxJQUFJQSxJQUFJLElBQUksSUFBSUEsS0FBSyxHQUN2QzBTLGVBQWVqWSxLQUFLc0QsUUFBUSxFQUM1QjhZLFVBQ0F5RCxXQUNBQyxhQUNBQyxRQUNBQyxjQUNBQyxTQUNBQyxTQUNBQztZQUVKLElBQUkvTyxnQkFBZ0I7Z0JBQ2xCa0gsVUFBVUQ7Z0JBQ1ZBLFVBQVU1TixxQkFBcUI3QixlQUFleUk7Z0JBRTlDLElBQUlwSyxNQUFNO29CQUNSeVMsUUFBUUQ7b0JBQ1JBLFFBQVF0VyxhQUFhLENBQUNnVSxXQUFXaFUsVUFBVXFYLGFBQWEsS0FBS29GO2dCQUMvRDtZQUNGLEVBQUUsNE1BQTRNO1lBRzlNLElBQUl0VyxpQkFBaUJ5RyxPQUFPLENBQUMvUixlQUFlLENBQUNzQixZQUFZSyxpQkFBaUI7Z0JBQ3hFLElBQUksQ0FBQ2lnQixXQUFXL1QsUUFBUXdGLFNBQVMsQ0FBQ0EsU0FBU2lILE9BQU0sSUFBTS9ZLENBQUFBLGFBQWF6QixNQUFLLElBQUt3TCxlQUFlO29CQUMzRnNXLFVBQVU7Z0JBQ1osT0FBTyxJQUFJQSxZQUFZLEtBQUt0UCxNQUFNZSxTQUFTLENBQUNBLFNBQVNpSCxPQUFNLElBQU0vWSxDQUFBQSxhQUFhekIsTUFBSyxJQUFLd0wsZUFBZTtvQkFDckdzVyxVQUFVO2dCQUNaO1lBQ0Y7WUFFQSxJQUFJQSxZQUFZM0gsZ0JBQWdCalksS0FBS3dELE9BQU8sRUFBRTtnQkFDNUM0WSxXQUFXcGMsS0FBS29jLFFBQVEsR0FBRyxDQUFDLENBQUN3RCxXQUFXQSxVQUFVO2dCQUNsREMsWUFBWSxDQUFDLENBQUM1SCxnQkFBZ0JBLGVBQWU7Z0JBQzdDZ0ksVUFBVTdELGFBQWF5RDtnQkFDdkJHLGVBQWVDLFdBQVcsQ0FBQyxDQUFDTCxZQUFZLENBQUMsQ0FBQzNILGNBQWMsaUlBQWlJO2dCQUV6TGpZLEtBQUt5SCxTQUFTLEdBQUdtWSxVQUFVM0gsZUFBZSxJQUFJLENBQUM7Z0JBQy9DalksS0FBS3NELFFBQVEsR0FBR3NjO2dCQUVoQixJQUFJSSxnQkFBZ0IsQ0FBQ2hpQixhQUFhO29CQUNoQzhoQixjQUFjRixXQUFXLENBQUMzSCxlQUFlLElBQUkySCxZQUFZLElBQUksSUFBSTNILGlCQUFpQixJQUFJLElBQUksR0FBRywyTEFBMkw7b0JBRXhSLElBQUlkLFVBQVU7d0JBQ1o0SSxTQUFTLENBQUNFLFdBQVc1VyxhQUFhLENBQUN5VyxjQUFjLEVBQUUsS0FBSyxVQUFVelcsYUFBYSxDQUFDeVcsY0FBYyxFQUFFLElBQUl6VyxhQUFhLENBQUN5VyxZQUFZLEVBQUUsMktBQTJLO3dCQUUzU0ssaUJBQWlCaGQsYUFBYzRjLENBQUFBLFdBQVcsY0FBY0EsV0FBVyxXQUFXQSxVQUFVNWMsU0FBUTtvQkFDbEc7Z0JBQ0Y7Z0JBRUErVCxtQkFBb0IrSSxDQUFBQSxXQUFXRSxjQUFhLEtBQU9BLENBQUFBLGtCQUFrQjFKLFNBQVMsQ0FBQ3RULFNBQVEsS0FBT0osQ0FBQUEsWUFBWW1VLG1CQUFtQkEsZ0JBQWdCbFgsUUFBUUEsS0FBS3VmLFdBQVcsQ0FBQ3JJLGlCQUFpQmhQLE9BQU8sQ0FBQyxTQUFVMEgsQ0FBQztvQkFDeE0sT0FBT0EsRUFBRXdQLFlBQVk7Z0JBQ3ZCLEVBQUM7Z0JBRUQsSUFBSSxDQUFDakksVUFBVTtvQkFDYixJQUFJd0MsY0FBYyxDQUFDM2IsZUFBZSxDQUFDc0IsVUFBVTt3QkFDM0NxYSxXQUFXeUcsR0FBRyxDQUFDQyxLQUFLLEdBQUcxRyxXQUFXMkcsTUFBTSxLQUFLM0csV0FBVzBHLEtBQUssSUFBSTFHLFdBQVdoSixNQUFNLENBQUNnSixXQUFXeUcsR0FBRyxDQUFDQyxLQUFLLEdBQUcxRyxXQUFXMkcsTUFBTSxHQUFHLG9TQUFvUzt3QkFFbGEsSUFBSTNHLFdBQVdzQyxPQUFPLEVBQUU7NEJBQ3RCdEMsV0FBV3NDLE9BQU8sQ0FBQyxpQkFBaUIyRCxTQUFTemMsVUFBVStZLE1BQU0sR0FBRy9ZLFVBQVVnWixLQUFLO3dCQUNqRixPQUFPOzRCQUNMLDJDQUEyQzs0QkFDM0N4QyxXQUFXNU4sSUFBSSxDQUFDeU8sYUFBYSxHQUFHb0Y7NEJBQ2hDakcsV0FBV2dFLFVBQVUsR0FBR3RRLE9BQU87d0JBQ2pDO29CQUNGLE9BQU8sSUFBSWxLLFdBQVc7d0JBQ3BCQSxVQUFVcVgsYUFBYSxDQUFDb0YsU0FBUyxDQUFDLENBQUU1aEIsQ0FBQUEsZUFBZ0JnYSxDQUFBQSxlQUFlMEgsS0FBSSxDQUFDO29CQUMxRTtnQkFDRjtnQkFFQSxJQUFJM1AsS0FBSztvQkFDUDJQLFNBQVNoSixjQUFlaEYsQ0FBQUEsT0FBT3ZNLEtBQUssQ0FBQ3VSLGFBQWFqUCxVQUFVa1YsR0FBRyxDQUFDLEdBQUd0RCxZQUFXO29CQUU5RSxJQUFJLENBQUMxTyxrQkFBa0I7d0JBQ3JCdU8sVUFBVXJZLE9BQU9zWSxXQUFXQyxZQUFZd0c7b0JBQzFDLE9BQU8sSUFBSUksY0FBYzt3QkFDdkJFLFVBQVUsQ0FBQ1IsU0FBU0UsVUFBVTNILGdCQUFnQjNILE1BQU0sSUFBSWUsVUFBVUEsU0FBUyxLQUFLOU8sV0FBV1AsVUFBVXlGLFlBQVksZ01BQWdNO3dCQUVqVCxJQUFJc1AsYUFBYTs0QkFDZixJQUFJLENBQUMySSxTQUFVdEQsQ0FBQUEsWUFBWThELE9BQU0sR0FBSTtnQ0FDbkMsSUFBSTdaLFNBQVN2RSxXQUFXaU8sS0FBSyxPQUN6QnRFLFVBQVU0RixTQUFTeEY7Z0NBRXZCeUksVUFBVXZFLEtBQUt0UyxPQUFPNEksT0FBT21ELEdBQUcsR0FBSS9CLENBQUFBLGNBQWM1SyxtREFBU0EsR0FBRzRPLFVBQVUsS0FBSzNHLEtBQUt1QixPQUFPb0QsSUFBSSxHQUFJaEMsQ0FBQUEsY0FBYzVLLG1EQUFTQSxHQUFHLElBQUk0TyxPQUFNLElBQUszRzs0QkFDNUksT0FBTztnQ0FDTHdQLFVBQVV2RSxLQUFLMkI7NEJBQ2pCO3dCQUNGO3dCQUVBRSxVQUFVd0ssWUFBWThELFVBQVVuSCxpQkFBaUJDO3dCQUVqRE8sWUFBWXFHLFVBQVUsS0FBS3hELFlBQVlsRCxVQUFVQyxXQUFZeUcsQ0FBQUEsWUFBWSxLQUFLLENBQUNNLFVBQVU5RyxZQUFZO29CQUN2RztnQkFDRjtnQkFFQW5TLFFBQVEsQ0FBQ2lSLFFBQVF6UyxLQUFLLElBQUksQ0FBQ3pILGVBQWUsQ0FBQ3NCLFlBQVl3YSxnQkFBZ0J6TSxPQUFPLENBQUM7Z0JBQy9Fa0osZUFBZ0IwSixDQUFBQSxXQUFXbkosUUFBUThJLFdBQVlBLENBQUFBLFVBQVUsS0FBSyxDQUFDdmdCLGVBQWMsQ0FBQyxLQUFNekIsU0FBUzJZLFlBQVkrRixPQUFPLEVBQUVwVSxPQUFPLENBQUMsU0FBVVMsRUFBRTtvQkFDcEksT0FBT0EsR0FBRzhULFNBQVMsQ0FBQ0wsWUFBWXRGLE9BQU8sUUFBUSxTQUFTLENBQUNQLFlBQVlnRyxTQUFTO2dCQUNoRixJQUFJLGtGQUFrRjtnQkFFdEYzRyxZQUFZLENBQUN1QixZQUFZLENBQUN1SSxTQUFTOUosU0FBUzVWO2dCQUU1QyxJQUFJZ2dCLGdCQUFnQixDQUFDaGlCLGFBQWE7b0JBQ2hDLElBQUltWixVQUFVO3dCQUNaLElBQUlnSixnQkFBZ0I7NEJBQ2xCLElBQUlKLFdBQVcsWUFBWTtnQ0FDekI1YyxVQUFVRSxLQUFLLEdBQUdtWCxhQUFhLENBQUM7NEJBQ2xDLE9BQU8sSUFBSXVGLFdBQVcsU0FBUztnQ0FDN0I1YyxVQUFVa0ssT0FBTyxDQUFDLE1BQU1oSyxLQUFLOzRCQUMvQixPQUFPLElBQUkwYyxXQUFXLFdBQVc7Z0NBQy9CNWMsVUFBVWtLLE9BQU8sQ0FBQzs0QkFDcEIsT0FBTztnQ0FDTGxLLFNBQVMsQ0FBQzRjLE9BQU87NEJBQ25CO3dCQUNGO3dCQUVBbkssWUFBWUEsU0FBUzVWO29CQUN2QjtvQkFFQSxJQUFJaWdCLFdBQVcsQ0FBQzVnQixpQkFBaUI7d0JBQy9CLGlMQUFpTDt3QkFDakxtWCxZQUFZeUosV0FBVzFjLFVBQVV2RCxNQUFNd1c7d0JBQ3ZDYyxTQUFTLENBQUN3SSxZQUFZLElBQUl2YyxVQUFVdkQsTUFBTXNYLFNBQVMsQ0FBQ3dJLFlBQVk7d0JBQ2hFaEosUUFBUzhJLENBQUFBLFlBQVksSUFBSTVmLEtBQUt1RyxJQUFJLENBQUMsT0FBTyxLQUFLK1EsU0FBUyxDQUFDd0ksWUFBWSxHQUFHLElBQUksd0RBQXdEO3dCQUVwSSxJQUFJLENBQUNHLFNBQVM7NEJBQ1osOEpBQThKOzRCQUM5SkgsY0FBY0YsWUFBWSxJQUFJLElBQUk7NEJBQ2xDdEksU0FBUyxDQUFDd0ksWUFBWSxJQUFJdmMsVUFBVXZELE1BQU1zWCxTQUFTLENBQUN3SSxZQUFZO3dCQUNsRTtvQkFDRjtvQkFFQSxJQUFJN0ksaUJBQWlCLENBQUNtRixZQUFZdGIsS0FBS2lELEdBQUcsQ0FBQy9ELEtBQUtzYixXQUFXLE1BQU90WSxDQUFBQSxVQUFVaVUsaUJBQWlCQSxnQkFBZ0IsSUFBRyxHQUFJO3dCQUNsSC9ULGNBQWNsRCxLQUFLNkQsaUJBQWlCO3dCQUVwQzhWLGFBQWFBLFdBQVdyVyxRQUFRLENBQUMsS0FBS0osY0FBY0MsV0FBVzRjLFdBQVcsWUFBWSxJQUFJLENBQUNILFNBQVM7b0JBQ3RHO2dCQUNGLE9BQU8sSUFBSXpJLFlBQVl2QixZQUFZLENBQUM1WCxhQUFhO29CQUMvQzRYLFNBQVM1VjtnQkFDWDtZQUNGLEVBQUUsaUZBQWlGO1lBR25GLElBQUl3WixpQkFBaUI7Z0JBQ25CLElBQUkrRyxJQUFJOVYscUJBQXFCNEcsU0FBUzVHLG1CQUFtQjVELFFBQVEsS0FBTTRELENBQUFBLG1CQUFtQjJKLGFBQWEsSUFBSSxLQUFLL0M7Z0JBQ2hIaUksa0JBQWtCaUgsSUFBSzlILENBQUFBLG1CQUFtQnRNLFVBQVUsR0FBRyxJQUFJO2dCQUMzRHFOLGdCQUFnQitHO1lBQ2xCO1lBRUF0RyxrQkFBa0JBLGVBQWUsQ0FBQzVJLFNBQVM1RyxtQkFBbUI1RCxRQUFRLEtBQU00RCxDQUFBQSxtQkFBbUIySixhQUFhLElBQUk7UUFDbEg7UUFFQXBVLEtBQUt3Z0IsTUFBTSxHQUFHLFNBQVVkLEtBQUssRUFBRTdQLE9BQU87WUFDcEMsSUFBSSxDQUFDN1AsS0FBS3dELE9BQU8sRUFBRTtnQkFDakJ4RCxLQUFLd0QsT0FBTyxHQUFHO2dCQUVmMkUsYUFBYW5HLFVBQVUsVUFBVWtMO2dCQUVqQ2pMLGNBQWNrRyxhQUFhbkcsVUFBVSxVQUFVMEs7Z0JBQy9Da0wsaUJBQWlCelAsYUFBYXNGLGVBQWUsZUFBZW1LO2dCQUU1RCxJQUFJOEgsVUFBVSxPQUFPO29CQUNuQjFmLEtBQUtzRCxRQUFRLEdBQUcyVSxlQUFlO29CQUMvQkksVUFBVUMsVUFBVVAsV0FBV25QO2dCQUNqQztnQkFFQWlILFlBQVksU0FBUzdQLEtBQUs2UCxPQUFPO1lBQ25DO1FBQ0Y7UUFFQTdQLEtBQUttVixRQUFRLEdBQUcsU0FBVWxPLElBQUk7WUFDNUIsT0FBT0EsUUFBUWlSLFVBQVVBLFFBQVF6UyxLQUFLLEdBQUdrVTtRQUMzQztRQUVBM1osS0FBSzBRLFlBQVksR0FBRyxTQUFVK1AsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLFNBQVMsRUFBRWpELFNBQVM7WUFDbEUsZ0pBQWdKO1lBQ2hKLElBQUlqVCxvQkFBb0I7Z0JBQ3RCLDBLQUEwSztnQkFDMUssSUFBSTVDLEtBQUs0QyxtQkFBbUJ5SixhQUFhLEVBQ3JDck4sV0FBVzRELG1CQUFtQjVELFFBQVEsSUFDdEMrWixVQUFVL1ksR0FBR3lJLEdBQUcsR0FBR3pJLEdBQUdnRSxLQUFLO2dCQUUvQjRVLFdBQVc1WSxHQUFHZ0UsS0FBSyxHQUFHK1UsVUFBVUgsV0FBVzVaO2dCQUMzQzZaLFNBQVM3WSxHQUFHZ0UsS0FBSyxHQUFHK1UsVUFBVUYsU0FBUzdaO1lBQ3pDO1lBRUE3RyxLQUFLNlAsT0FBTyxDQUFDLE9BQU8sT0FBTztnQkFDekJoRSxPQUFPdkwsV0FBV21nQixVQUFVRSxhQUFhLENBQUMsQ0FBQzNnQixLQUFLeVEsV0FBVztnQkFDM0RILEtBQUtoUSxXQUFXb2dCLFFBQVFDLGFBQWEsQ0FBQyxDQUFDM2dCLEtBQUt1USxTQUFTO1lBQ3ZELEdBQUdtTjtZQUNIMWQsS0FBS2lSLE1BQU07UUFDYjtRQUVBalIsS0FBS21RLGdCQUFnQixHQUFHLFNBQVUwUSxNQUFNO1lBQ3RDLElBQUk5TyxlQUFlOE8sUUFBUTtnQkFDekIsSUFBSS9kLElBQUlpUCxZQUFZM1IsT0FBTyxDQUFDcUgsVUFBVXRGLENBQUMsSUFBSTtnQkFDM0M0UCxXQUFXLENBQUNqUCxFQUFFLEdBQUdvSCxXQUFXNkgsV0FBVyxDQUFDalAsRUFBRSxJQUFJK2QsU0FBUy9iO2dCQUN2RGlOLFdBQVcsQ0FBQyxFQUFFLEdBQUc3SCxXQUFXNkgsV0FBVyxDQUFDLEVBQUUsSUFBSThPLFNBQVMvYjtnQkFFdkQ4TSxVQUFVRztZQUNaO1FBQ0Y7UUFFQS9SLEtBQUs4Z0IsT0FBTyxHQUFHLFNBQVVwQixLQUFLLEVBQUVxQixjQUFjO1lBQzVDLElBQUkvZ0IsS0FBS3dELE9BQU8sRUFBRTtnQkFDaEJrYyxVQUFVLFNBQVMxZixLQUFLcU8sTUFBTSxDQUFDLE1BQU07Z0JBQ3JDck8sS0FBS3dELE9BQU8sR0FBR3hELEtBQUtvYyxRQUFRLEdBQUc7Z0JBQy9CMkUsa0JBQWtCcEgsY0FBY0EsV0FBV3RXLEtBQUs7Z0JBQ2hEMFcsYUFBYTtnQkFDYjVCLFlBQWFBLENBQUFBLFNBQVNqSyxPQUFPLEdBQUc7Z0JBQ2hDMEosaUJBQWlCcFAsZ0JBQWdCaUYsZUFBZSxlQUFlbUs7Z0JBRS9ELElBQUlrQyxpQkFBaUI7b0JBQ25CQSxnQkFBZ0J6VyxLQUFLO29CQUNyQjZVLFFBQVF6UyxLQUFLLElBQUl5UyxRQUFRelMsS0FBSyxDQUFDYyxJQUFJLE1BQU8yUixDQUFBQSxRQUFRelMsS0FBSyxHQUFHO2dCQUM1RDtnQkFFQSxJQUFJLENBQUN4RCxZQUFZO29CQUNmLElBQUlhLElBQUl1SixVQUFVaE0sTUFBTTtvQkFFeEIsTUFBT3lDLElBQUs7d0JBQ1YsSUFBSXVKLFNBQVMsQ0FBQ3ZKLEVBQUUsQ0FBQ2QsUUFBUSxLQUFLQSxZQUFZcUssU0FBUyxDQUFDdkosRUFBRSxLQUFLOUMsTUFBTTs0QkFDL0QsUUFBUSw4RUFBOEU7d0JBQ3hGO29CQUNGO29CQUVBd0ksZ0JBQWdCeEcsVUFBVSxVQUFVa0w7b0JBRXBDakwsY0FBY3VHLGdCQUFnQnhHLFVBQVUsVUFBVTBLO2dCQUNwRDtZQUNGO1FBQ0Y7UUFFQTFNLEtBQUt1RyxJQUFJLEdBQUcsU0FBVThILE1BQU0sRUFBRTBTLGNBQWM7WUFDMUMvZ0IsS0FBSzhnQixPQUFPLENBQUN6UyxRQUFRMFM7WUFDckJwSCxjQUFjLENBQUNvSCxrQkFBa0JwSCxXQUFXcFQsSUFBSTtZQUNoRHlJLE1BQU0sT0FBTzFDLElBQUksQ0FBQzBDLEdBQUc7WUFFckIsSUFBSWxNLElBQUl1SixVQUFVak0sT0FBTyxDQUFDSjtZQUUxQjhDLEtBQUssS0FBS3VKLFVBQVU2UyxNQUFNLENBQUNwYyxHQUFHO1lBQzlCQSxNQUFNM0UsTUFBTTJTLGFBQWEsS0FBSzNTLE1BQU0sMkdBQTJHO1lBQy9JLCtOQUErTjtZQUUvTjJFLElBQUk7WUFFSnVKLFVBQVVuRSxPQUFPLENBQUMsU0FBVTBILENBQUM7Z0JBQzNCLE9BQU9BLEVBQUU1TixRQUFRLEtBQUtoQyxLQUFLZ0MsUUFBUSxJQUFLYyxDQUFBQSxJQUFJO1lBQzlDO1lBRUFBLEtBQUsyTCxrQkFBbUJ6TyxDQUFBQSxLQUFLcVIsTUFBTSxDQUFDMUMsR0FBRyxHQUFHO1lBRTFDLElBQUl4TCxXQUFXO2dCQUNiQSxVQUFVK1EsYUFBYSxHQUFHO2dCQUMxQjdGLFVBQVVsTCxVQUFVa0wsTUFBTSxDQUFDO29CQUN6QjlILE1BQU07Z0JBQ1I7Z0JBQ0F3YSxrQkFBa0I1ZCxVQUFVb0QsSUFBSTtZQUNsQztZQUVBZ1MsZUFBZTtnQkFBQ0E7Z0JBQWFDO2dCQUFXQztnQkFBb0JDO2FBQWlCLENBQUN4USxPQUFPLENBQUMsU0FBVWlNLENBQUM7Z0JBQy9GLE9BQU9BLEVBQUVsQyxVQUFVLElBQUlrQyxFQUFFbEMsVUFBVSxDQUFDOUMsV0FBVyxDQUFDZ0Y7WUFDbEQ7WUFDQXBELGFBQWEvUSxRQUFTK1EsQ0FBQUEsV0FBVztZQUVqQyxJQUFJaEIsS0FBSztnQkFDUG9JLFlBQWFBLENBQUFBLFNBQVNqSyxPQUFPLEdBQUc7Z0JBQ2hDcEwsSUFBSTtnQkFFSnVKLFVBQVVuRSxPQUFPLENBQUMsU0FBVTBILENBQUM7b0JBQzNCLE9BQU9BLEVBQUVHLEdBQUcsS0FBS0EsT0FBT2pOO2dCQUMxQjtnQkFFQUEsS0FBTXFWLENBQUFBLFNBQVN6RyxNQUFNLEdBQUcsSUFBSSxzTUFBc007WUFDcE87WUFFQTNGLEtBQUtpVixNQUFNLElBQUlqVixLQUFLaVYsTUFBTSxDQUFDaGhCO1FBQzdCO1FBRUFxTSxVQUFVdkYsSUFBSSxDQUFDOUc7UUFFZkEsS0FBS3dnQixNQUFNLENBQUMsT0FBTztRQUNuQnRHLHNCQUFzQkEsbUJBQW1CbGE7UUFFekMsSUFBSW1ELGFBQWFBLFVBQVVRLEdBQUcsSUFBSSxDQUFDa1YsUUFBUTtZQUN6QyxpUkFBaVI7WUFDalIsSUFBSW9JLGFBQWFqaEIsS0FBS2lSLE1BQU0sRUFBRSxrbEJBQWtsQjtZQUVobkJqUixLQUFLaVIsTUFBTSxHQUFHO2dCQUNaalIsS0FBS2lSLE1BQU0sR0FBR2dRO2dCQUNkcFYsU0FBU3lFLE9BQU90USxLQUFLNlAsT0FBTztZQUM5QjtZQUVBelMsS0FBSytkLFdBQVcsQ0FBQyxNQUFNbmIsS0FBS2lSLE1BQU07WUFDbEM0SCxTQUFTO1lBQ1RoTixRQUFReUUsTUFBTTtRQUNoQixPQUFPO1lBQ0x0USxLQUFLNlAsT0FBTztRQUNkO1FBRUFFLE9BQU9oQixvQkFBb0IsNkZBQTZGO0lBQzFIO0lBRUF0QixjQUFjc0ksUUFBUSxHQUFHLFNBQVNBLFNBQVNyRCxJQUFJO1FBQzdDLElBQUksQ0FBQ3JWLGNBQWM7WUFDakJELE9BQU9zVixRQUFReFI7WUFDZkYsbUJBQW1CQyxPQUFPaWdCLFFBQVEsSUFBSXpULGNBQWMrUyxNQUFNO1lBQzFEbmpCLGVBQWV1QztRQUNqQjtRQUVBLE9BQU92QztJQUNUO0lBRUFvUSxjQUFjbkksUUFBUSxHQUFHLFNBQVNBLFNBQVM2YixNQUFNO1FBQy9DLElBQUlBLFFBQVE7WUFDVixJQUFLLElBQUk1YixLQUFLNGIsT0FBUTtnQkFDcEIvWCxTQUFTLENBQUM3RCxFQUFFLEdBQUc0YixNQUFNLENBQUM1YixFQUFFO1lBQzFCO1FBQ0Y7UUFFQSxPQUFPNkQ7SUFDVDtJQUVBcUUsY0FBY3FULE9BQU8sR0FBRyxTQUFTQSxRQUFRcEIsS0FBSyxFQUFFblosSUFBSTtRQUNsRDNHLFdBQVc7UUFFWHlNLFVBQVVuRSxPQUFPLENBQUMsU0FBVWtHLE9BQU87WUFDakMsT0FBT0EsT0FBTyxDQUFDN0gsT0FBTyxTQUFTLFVBQVUsQ0FBQ21aO1FBQzVDO1FBRUFsWCxnQkFBZ0JsTCxNQUFNLFNBQVNvUDtRQUUvQmxFLGdCQUFnQmpMLE1BQU0sVUFBVW1QO1FBRWhDMFUsY0FBY3JqQjtRQUVkeUssZ0JBQWdCakwsTUFBTSxlQUFlb0Q7UUFFckM2SCxnQkFBZ0IvSyxPQUFPLGNBQWNrRDtRQUVyQ21ILGVBQWVVLGlCQUFpQmpMLE1BQU0sb0NBQW9Da0Q7UUFFMUVxSCxlQUFlVSxpQkFBaUJqTCxNQUFNLDhCQUE4Qm1EO1FBRXBFL0MsYUFBYTRJLElBQUk7UUFFakI1RCxvQkFBb0I2RjtRQUVwQixJQUFLLElBQUkxRixJQUFJLEdBQUdBLElBQUkvRixvREFBVUEsQ0FBQ3NELE1BQU0sRUFBRXlDLEtBQUssRUFBRztZQUM3QzRGLGVBQWVGLGlCQUFpQnpMLG9EQUFVLENBQUMrRixFQUFFLEVBQUUvRixvREFBVSxDQUFDK0YsSUFBSSxFQUFFO1lBRWhFNEYsZUFBZUYsaUJBQWlCekwsb0RBQVUsQ0FBQytGLEVBQUUsRUFBRS9GLG9EQUFVLENBQUMrRixJQUFJLEVBQUU7UUFDbEU7SUFDRjtJQUVBMkssY0FBYytTLE1BQU0sR0FBRyxTQUFTQTtRQUM5QmxqQixPQUFPMkQ7UUFDUDFELE9BQU8yakI7UUFDUDFqQixTQUFTRCxLQUFLOGpCLGVBQWU7UUFDN0I1akIsUUFBUUYsS0FBSytqQixJQUFJO1FBRWpCLElBQUlsa0IsTUFBTTtZQUNSUSxXQUFXUixLQUFLNEosS0FBSyxDQUFDdWEsT0FBTztZQUM3QjFqQixTQUFTVCxLQUFLNEosS0FBSyxDQUFDL0csS0FBSztZQUN6QmxCLFdBQVczQixLQUFLc1YsSUFBSSxDQUFDOE8sT0FBTyxJQUFJN2dCO1lBQ2hDbkMsc0JBQXNCcEIsS0FBS3NWLElBQUksQ0FBQytPLGtCQUFrQixJQUFJOWdCO1lBQ3REM0IscUJBQXFCMUIsS0FBS3NSLE9BQU8sQ0FBQ0wsaUJBQWlCLElBQUk7WUFDdkRzQyxjQUFjdlQsS0FBS29rQixXQUFXO1lBQzlCdGtCLEtBQUtzVixJQUFJLENBQUNpUCxPQUFPLENBQUMsaUJBQWlCbFUsZ0JBQWdCLG9IQUFvSDtZQUV2SyxJQUFJaFEsT0FBTztnQkFDVG1DLFdBQVc7Z0JBQ1hYLFlBQVlpaUIsU0FBU3hXLGFBQWEsQ0FBQyxRQUFRLDhRQUE4UTtnQkFFelR6TCxVQUFVa0csS0FBSyxDQUFDdEQsTUFBTSxHQUFHO2dCQUN6QjVDLFVBQVVrRyxLQUFLLENBQUNELFFBQVEsR0FBRztnQkFFM0IrSjtnQkFFQTFPO2dCQUVBNUQsa0RBQVFBLENBQUNvWixRQUFRLENBQUMzWSxPQUFPLHdIQUF3SDtnQkFFakpxUSxjQUFjcUksT0FBTyxHQUFHblosa0RBQVFBLENBQUNtWixPQUFPO2dCQUN4Q2hYLGFBQWFuQyxrREFBUUEsQ0FBQ21aLE9BQU8sSUFBSSwwQkFBMEJ0QixJQUFJLENBQUNvTixVQUFVQyxTQUFTLEdBQUcsbVRBQW1UO2dCQUV6WWxqQixzQkFBc0JoQyxrREFBUUEsQ0FBQ21aLE9BQU8sS0FBSztnQkFFM0MzTixhQUFhN0ssTUFBTSxTQUFTb1AsWUFBWSxtREFBbUQ7Z0JBRzNGaFAsUUFBUTtvQkFBQ0o7b0JBQU1DO29CQUFNQztvQkFBUUM7aUJBQU07Z0JBRW5DLElBQUlMLEtBQUswa0IsVUFBVSxFQUFFO29CQUNuQnJVLGNBQWNxVSxVQUFVLEdBQUcsU0FBVS9WLElBQUk7d0JBQ3ZDLElBQUlnVyxLQUFLM2tCLEtBQUswa0IsVUFBVSxJQUNwQnZjO3dCQUVKLElBQUtBLEtBQUt3RyxLQUFNOzRCQUNkZ1csR0FBR3BlLEdBQUcsQ0FBQzRCLEdBQUd3RyxJQUFJLENBQUN4RyxFQUFFO3dCQUNuQjt3QkFFQSxPQUFPd2M7b0JBQ1Q7b0JBRUEza0IsS0FBS2tMLGdCQUFnQixDQUFDLGtCQUFrQjt3QkFDdEMsT0FBTzZGO29CQUNUO29CQUNBL1EsS0FBS2tMLGdCQUFnQixDQUFDLG9CQUFvQjt3QkFDeEMsT0FBT3dGO29CQUNUO29CQUNBMVEsS0FBS2tMLGdCQUFnQixDQUFDLGNBQWM7d0JBQ2xDb0YsWUFBWSxHQUFHO3dCQUVmWCxVQUFVO29CQUNaO29CQUNBM1AsS0FBSzBrQixVQUFVLENBQUMsMkJBQTJCO3dCQUN6QyxxR0FBcUc7d0JBQ3JHOVU7d0JBRUEsT0FBT0E7b0JBQ1Q7Z0JBQ0YsT0FBTztvQkFDTGdKLFFBQVFDLElBQUksQ0FBQztnQkFDZjtnQkFFQWpKO2dCQUVBN0UsYUFBYTVLLE1BQU0sVUFBVW1QLFlBQVksd0pBQXdKO2dCQUdqTSxJQUFJc1YsWUFBWXZrQixNQUFNMEgsS0FBSyxFQUN2QjhjLFNBQVNELFVBQVVFLGNBQWMsRUFDakNDLGlCQUFpQi9rQixLQUFLc1YsSUFBSSxDQUFDMFAsU0FBUyxDQUFDaE0sU0FBUyxFQUM5Qy9QLFFBQ0F2RDtnQkFDSnFmLGVBQWU5VCxNQUFNLElBQUlnVSxPQUFPQyxjQUFjLENBQUNILGdCQUFnQixVQUFVO29CQUN2RXJpQixPQUFPLFNBQVNBO3dCQUNkLE9BQU8sSUFBSSxDQUFDcVIsSUFBSSxDQUFDLENBQUMsTUFBTTtvQkFDMUI7Z0JBQ0YsSUFBSSwrRUFBK0U7Z0JBRW5GNlEsVUFBVUUsY0FBYyxHQUFHLFNBQVMsb05BQW9OO2dCQUV4UDdiLFNBQVN2RSxXQUFXckU7Z0JBQ3BCWixtREFBU0EsQ0FBQ3NYLENBQUMsR0FBR3JULEtBQUtDLEtBQUssQ0FBQ3NGLE9BQU9tRCxHQUFHLEdBQUczTSxtREFBU0EsQ0FBQzBsQixFQUFFLE9BQU8sR0FBRyx3RUFBd0U7Z0JBRXBJemxCLHFEQUFXQSxDQUFDcVgsQ0FBQyxHQUFHclQsS0FBS0MsS0FBSyxDQUFDc0YsT0FBT29ELElBQUksR0FBRzNNLHFEQUFXQSxDQUFDeWxCLEVBQUUsT0FBTztnQkFDOUROLFNBQVNELFVBQVVFLGNBQWMsR0FBR0QsU0FBU0QsVUFBVXBQLGNBQWMsQ0FBQyxxQkFBcUIsNEZBQTRGO2dCQUV2TDdVLGdCQUFnQnlrQixZQUFZaFcsT0FBTztnQkFDbkNwUCxLQUFLK2QsV0FBVyxDQUFDLEtBQUs7b0JBQ3BCLE9BQU83YixXQUFXO2dCQUNwQjtnQkFFQTZJLGFBQWE1SyxNQUFNLGVBQWVvRCxlQUFlLHNJQUFzSTtnQkFHdkx3SCxhQUFhMUssT0FBTyxjQUFja0QsZUFBZSxzR0FBc0c7Z0JBR3ZKbUgsZUFBZUssY0FBYzVLLE1BQU0sb0NBQW9Da0Q7Z0JBRXZFcUgsZUFBZUssY0FBYzVLLE1BQU0sOEJBQThCbUQ7Z0JBRWpFeEMsaUJBQWlCZCxLQUFLNEosS0FBSyxDQUFDeWIsV0FBVyxDQUFDO2dCQUV4Q2xSLFlBQVl6SyxJQUFJLENBQUM1STtnQkFFakJiLGVBQWVrQztnQkFDZjVCLGVBQWVQLEtBQUsrZCxXQUFXLENBQUMsS0FBS3pOLGFBQWFySyxLQUFLO2dCQUN2RC9FLGVBQWU7b0JBQUNmO29CQUFNO29CQUFvQjt3QkFDeEMsSUFBSW1sQixJQUFJcGxCLEtBQUtzRSxVQUFVLEVBQ25CK2dCLElBQUlybEIsS0FBSzJQLFdBQVc7d0JBRXhCLElBQUkxUCxLQUFLcWxCLE1BQU0sRUFBRTs0QkFDZnhrQixhQUFhc2tCOzRCQUNicmtCLGNBQWNza0I7d0JBQ2hCLE9BQU8sSUFBSXZrQixlQUFlc2tCLEtBQUtya0IsZ0JBQWdCc2tCLEdBQUc7NEJBQ2hEelY7d0JBQ0Y7b0JBQ0Y7b0JBQUczUDtvQkFBTTtvQkFBb0JtUTtvQkFBYXBRO29CQUFNO29CQUFRb1E7b0JBQWFwUTtvQkFBTTtvQkFBVTRQO2lCQUFVO2dCQUUvRnZLLG9CQUFvQndGO2dCQUVwQmtFLFVBQVVuRSxPQUFPLENBQUMsU0FBVWtHLE9BQU87b0JBQ2pDLE9BQU9BLFFBQVFvUyxNQUFNLENBQUMsR0FBRztnQkFDM0I7Z0JBRUEsSUFBSzFkLElBQUksR0FBR0EsSUFBSS9GLG9EQUFVQSxDQUFDc0QsTUFBTSxFQUFFeUMsS0FBSyxFQUFHO29CQUN6QzRGLGVBQWVGLGlCQUFpQnpMLG9EQUFVLENBQUMrRixFQUFFLEVBQUUvRixvREFBVSxDQUFDK0YsSUFBSSxFQUFFO29CQUVoRTRGLGVBQWVGLGlCQUFpQnpMLG9EQUFVLENBQUMrRixFQUFFLEVBQUUvRixvREFBVSxDQUFDK0YsSUFBSSxFQUFFO2dCQUNsRTtZQUNGO1FBQ0Y7SUFDRjtJQUVBMkssY0FBYzBULE1BQU0sR0FBRyxTQUFTQSxPQUFPcFYsSUFBSTtRQUN6QyxvQkFBb0JBLFFBQVMxTSxDQUFBQSxrQkFBa0IsQ0FBQyxDQUFDME0sS0FBSzhXLGNBQWM7UUFDcEUsSUFBSUMsS0FBSy9XLEtBQUtnWCxZQUFZO1FBQzFCRCxNQUFNMUIsY0FBY3JqQixrQkFBa0IsQ0FBQ0EsZ0JBQWdCK2tCLEVBQUMsS0FBTU4sWUFBWWhXLE9BQU9zVztRQUNqRix3QkFBd0IvVyxRQUFTcE4sQ0FBQUEsc0JBQXNCOE8sY0FBY3FJLE9BQU8sS0FBSyxLQUFLL0osS0FBS2lYLGtCQUFrQjtRQUU3RyxJQUFJLHVCQUF1QmpYLE1BQU07WUFDL0JwSixvQkFBb0I2RixvQkFBb0I3RixvQkFBb0J3RixjQUFjNEQsS0FBS2tYLGlCQUFpQixJQUFJO1lBQ3BHeGtCLGdCQUFnQixDQUFDc04sS0FBS2tYLGlCQUFpQixHQUFHLEVBQUMsRUFBRzdpQixPQUFPLENBQUMsY0FBYyxDQUFDO1FBQ3ZFO0lBQ0Y7SUFFQXFOLGNBQWN5VixhQUFhLEdBQUcsU0FBU0EsY0FBY3hULE1BQU0sRUFBRTNELElBQUk7UUFDL0QsSUFBSTZELElBQUloVCx3REFBVUEsQ0FBQzhTLFNBQ2Y1TSxJQUFJL0Ysb0RBQVVBLENBQUNxRCxPQUFPLENBQUN3UCxJQUN2QjNOLGFBQWFiLFlBQVl3TztRQUU3QixJQUFJLENBQUM5TSxHQUFHO1lBQ04vRixvREFBVUEsQ0FBQ21pQixNQUFNLENBQUNwYyxHQUFHYixhQUFhLElBQUk7UUFDeEM7UUFFQSxJQUFJOEosTUFBTTtZQUNSOUosYUFBYWpGLGtEQUFRQSxDQUFDNmhCLE9BQU8sQ0FBQ3ZoQixNQUFNeU8sTUFBTXRPLE9BQU9zTyxNQUFNdk8sUUFBUXVPLFFBQVEvTyxrREFBUUEsQ0FBQzZoQixPQUFPLENBQUNqUCxHQUFHN0Q7UUFDN0Y7SUFDRjtJQUVBMEIsY0FBYzBWLGVBQWUsR0FBRyxTQUFTQSxnQkFBZ0JuVixLQUFLO1FBQzVEM0IsVUFBVW5FLE9BQU8sQ0FBQyxTQUFVMEgsQ0FBQztZQUMzQixPQUFPQSxFQUFFbE0sSUFBSSxJQUFJa00sRUFBRWxNLElBQUksQ0FBQ3NLLEtBQUssS0FBS0EsU0FBUzRCLEVBQUVsTSxJQUFJLENBQUM2QyxJQUFJLENBQUMsTUFBTTtRQUMvRDtJQUNGO0lBRUFrSCxjQUFjMlYsWUFBWSxHQUFHLFNBQVNBLGFBQWEzaEIsT0FBTyxFQUFFa1UsS0FBSyxFQUFFMUYsVUFBVTtRQUMzRSxJQUFJNUosU0FBUyxDQUFDbkcsVUFBVXVCLFdBQVc3RSx3REFBVUEsQ0FBQzZFLFdBQVdBLE9BQU0sRUFBRzZFLHFCQUFxQixJQUNuRmlFLFNBQVNsRSxNQUFNLENBQUM0SixhQUFhN0wsU0FBU0MsUUFBUSxHQUFHc1IsU0FBUztRQUM5RCxPQUFPMUYsYUFBYTVKLE9BQU91RCxLQUFLLEdBQUdXLFNBQVMsS0FBS2xFLE9BQU9vRCxJQUFJLEdBQUdjLFNBQVNqTixLQUFLc0UsVUFBVSxHQUFHeUUsT0FBT3NELE1BQU0sR0FBR1ksU0FBUyxLQUFLbEUsT0FBT21ELEdBQUcsR0FBR2UsU0FBU2pOLEtBQUsyUCxXQUFXO0lBQ2hLO0lBRUFRLGNBQWM0VixrQkFBa0IsR0FBRyxTQUFTQSxtQkFBbUI1aEIsT0FBTyxFQUFFNmhCLGNBQWMsRUFBRXJULFVBQVU7UUFDaEcvUCxVQUFVdUIsWUFBYUEsQ0FBQUEsVUFBVTdFLHdEQUFVQSxDQUFDNkUsUUFBTztRQUNuRCxJQUFJNEUsU0FBUzVFLFFBQVE2RSxxQkFBcUIsSUFDdEN3RCxPQUFPekQsTUFBTSxDQUFDNEosYUFBYTdMLFNBQVNDLFFBQVEsRUFDNUNrRyxTQUFTK1ksa0JBQWtCLE9BQU94WixPQUFPLElBQUl3WixrQkFBa0IvWixZQUFZQSxTQUFTLENBQUMrWixlQUFlLEdBQUd4WixPQUFPLENBQUN3WixlQUFlbGpCLE9BQU8sQ0FBQyxPQUFPOEosV0FBV29aLGtCQUFrQnhaLE9BQU8sTUFBTUksV0FBV29aLG1CQUFtQjtRQUN6TixPQUFPclQsYUFBYSxDQUFDNUosT0FBT29ELElBQUksR0FBR2MsTUFBSyxJQUFLak4sS0FBS3NFLFVBQVUsR0FBRyxDQUFDeUUsT0FBT21ELEdBQUcsR0FBR2UsTUFBSyxJQUFLak4sS0FBSzJQLFdBQVc7SUFDekc7SUFFQVEsY0FBYzhWLE9BQU8sR0FBRyxTQUFTQSxRQUFRQyxjQUFjO1FBQ3JEblgsVUFBVS9FLEtBQUssQ0FBQyxHQUFHWSxPQUFPLENBQUMsU0FBVTBILENBQUM7WUFDcEMsT0FBT0EsRUFBRTdELElBQUksQ0FBQ2lELEVBQUUsS0FBSyxvQkFBb0JZLEVBQUVySixJQUFJO1FBQ2pEO1FBRUEsSUFBSWlkLG1CQUFtQixNQUFNO1lBQzNCLElBQUlDLFlBQVluVyxXQUFXaVcsT0FBTyxJQUFJLEVBQUU7WUFDeENqVyxhQUFhLENBQUM7WUFDZG1XLFVBQVV2YixPQUFPLENBQUMsU0FBVTBGLENBQUM7Z0JBQzNCLE9BQU9BO1lBQ1Q7UUFDRjtJQUNGO0lBRUEsT0FBT0g7QUFDVCxJQUFJO0FBQ0pBLGNBQWNpVyxPQUFPLEdBQUc7QUFFeEJqVyxjQUFja1csVUFBVSxHQUFHLFNBQVVySCxPQUFPO0lBQzFDLE9BQU9BLFVBQVUxZSxTQUFTMGUsU0FBU3BVLE9BQU8sQ0FBQyxTQUFVd0gsTUFBTTtRQUN6RCxxSUFBcUk7UUFDckksSUFBSUEsVUFBVUEsT0FBT3ZLLEtBQUssRUFBRTtZQUMxQixJQUFJckMsSUFBSStLLGFBQWF6TixPQUFPLENBQUNzUDtZQUU3QjVNLEtBQUssS0FBSytLLGFBQWFxUixNQUFNLENBQUNwYyxHQUFHO1lBRWpDK0ssYUFBYS9HLElBQUksQ0FBQzRJLFFBQVFBLE9BQU92SyxLQUFLLENBQUNpRyxPQUFPLEVBQUVzRSxPQUFPekIsT0FBTyxJQUFJeUIsT0FBT2tVLFlBQVksQ0FBQyxjQUFjeG1CLEtBQUtzVixJQUFJLENBQUNDLFFBQVEsQ0FBQ2pELFNBQVMzUTtRQUNsSTtJQUNGLEtBQUs4TztBQUNQO0FBRUFKLGNBQWNZLE1BQU0sR0FBRyxTQUFVb1AsSUFBSSxFQUFFMVAsS0FBSztJQUMxQyxPQUFPSSxXQUFXLENBQUNzUCxNQUFNMVA7QUFDM0I7QUFFQU4sY0FBY29XLE1BQU0sR0FBRyxTQUFVOVgsSUFBSSxFQUFFNUksU0FBUztJQUM5QyxPQUFPLElBQUlzSyxjQUFjMUIsTUFBTTVJO0FBQ2pDO0FBRUFzSyxjQUFjb0MsT0FBTyxHQUFHLFNBQVVpVSxJQUFJO0lBQ3BDLE9BQU9BLE9BQU81VyxjQUFjLENBQUM3UCxnQkFBZ0JvUSxjQUFjc0ksUUFBUSxFQUFDLEtBQU1ySSxZQUFZO0FBQ3hGO0FBRUFELGNBQWN3RCxNQUFNLEdBQUcsU0FBVXpDLEtBQUs7SUFDcEMsT0FBTyxFQUFFelIsb0RBQVVBLENBQUMrUCxLQUFLLElBQUlMLFdBQVcrQixVQUFVLE9BQU8sSUFBSTtBQUMvRDtBQUVBZixjQUFjc1csaUJBQWlCLEdBQUd6VjtBQUVsQ2IsY0FBY3VXLFNBQVMsR0FBRyxTQUFVdmlCLE9BQU8sRUFBRXdPLFVBQVU7SUFDckQsT0FBTzFOLFdBQVdkLFNBQVN3TyxhQUFhblQscURBQVdBLEdBQUdELG1EQUFTQTtBQUNqRTtBQUVBNFEsY0FBY3dXLGFBQWEsR0FBRyxTQUFVeGlCLE9BQU8sRUFBRXdPLFVBQVU7SUFDekQsT0FBT2hULDREQUFjQSxDQUFDTCx3REFBVUEsQ0FBQzZFLFVBQVV3TyxhQUFhblQscURBQVdBLEdBQUdELG1EQUFTQTtBQUNqRjtBQUVBNFEsY0FBY3lXLE9BQU8sR0FBRyxTQUFVbFYsRUFBRTtJQUNsQyxPQUFPMUMsSUFBSSxDQUFDMEMsR0FBRztBQUNqQjtBQUVBdkIsY0FBYzBXLE1BQU0sR0FBRztJQUNyQixPQUFPOVgsVUFBVW9ULE1BQU0sQ0FBQyxTQUFVN1AsQ0FBQztRQUNqQyxPQUFPQSxFQUFFN0QsSUFBSSxDQUFDaUQsRUFBRSxLQUFLO0lBQ3ZCO0FBQ0YsR0FBRyxtTEFBbUw7QUFHdEx2QixjQUFjMlcsV0FBVyxHQUFHO0lBQzFCLE9BQU8sQ0FBQyxDQUFDemtCO0FBQ1g7QUFFQThOLGNBQWM0VyxlQUFlLEdBQUduZDtBQUVoQ3VHLGNBQWNuRixnQkFBZ0IsR0FBRyxTQUFVdkksSUFBSSxFQUFFaUksUUFBUTtJQUN2RCxJQUFJM0YsSUFBSWlMLFVBQVUsQ0FBQ3ZOLEtBQUssSUFBS3VOLENBQUFBLFVBQVUsQ0FBQ3ZOLEtBQUssR0FBRyxFQUFFO0lBQ2xELENBQUNzQyxFQUFFakMsT0FBTyxDQUFDNEgsYUFBYTNGLEVBQUV5RSxJQUFJLENBQUNrQjtBQUNqQztBQUVBeUYsY0FBY2hGLG1CQUFtQixHQUFHLFNBQVUxSSxJQUFJLEVBQUVpSSxRQUFRO0lBQzFELElBQUkzRixJQUFJaUwsVUFBVSxDQUFDdk4sS0FBSyxFQUNwQitDLElBQUlULEtBQUtBLEVBQUVqQyxPQUFPLENBQUM0SDtJQUN2QmxGLEtBQUssS0FBS1QsRUFBRTZjLE1BQU0sQ0FBQ3BjLEdBQUc7QUFDeEI7QUFFQTJLLGNBQWM2VyxLQUFLLEdBQUcsU0FBVWhJLE9BQU8sRUFBRXZRLElBQUk7SUFDM0MsSUFBSXRJLFNBQVMsRUFBRSxFQUNYOGdCLFdBQVcsQ0FBQyxHQUNaQyxXQUFXelksS0FBS3lZLFFBQVEsSUFBSSxPQUM1QkMsV0FBVzFZLEtBQUswWSxRQUFRLElBQUksS0FDNUJDLGdCQUFnQixTQUFTQSxjQUFjM2tCLElBQUksRUFBRWlJLFFBQVE7UUFDdkQsSUFBSTJjLFdBQVcsRUFBRSxFQUNiQyxXQUFXLEVBQUUsRUFDYnhKLFFBQVFoZSxLQUFLK2QsV0FBVyxDQUFDcUosVUFBVTtZQUNyQ3hjLFNBQVMyYyxVQUFVQztZQUNuQkQsV0FBVyxFQUFFO1lBQ2JDLFdBQVcsRUFBRTtRQUNmLEdBQUd2aEIsS0FBSztRQUNSLE9BQU8sU0FBVXJELElBQUk7WUFDbkIya0IsU0FBU3RrQixNQUFNLElBQUkrYSxNQUFNL04sT0FBTyxDQUFDO1lBQ2pDc1gsU0FBUzdkLElBQUksQ0FBQzlHLEtBQUtvTyxPQUFPO1lBQzFCd1csU0FBUzlkLElBQUksQ0FBQzlHO1lBQ2R5a0IsWUFBWUUsU0FBU3RrQixNQUFNLElBQUkrYSxNQUFNOVgsUUFBUSxDQUFDO1FBQ2hEO0lBQ0YsR0FDSWlDO0lBRUosSUFBS0EsS0FBS3dHLEtBQU07UUFDZHdZLFFBQVEsQ0FBQ2hmLEVBQUUsR0FBR0EsRUFBRXBGLE1BQU0sQ0FBQyxHQUFHLE9BQU8sUUFBUTRDLFlBQVlnSixJQUFJLENBQUN4RyxFQUFFLEtBQUtBLE1BQU0sa0JBQWtCbWYsY0FBY25mLEdBQUd3RyxJQUFJLENBQUN4RyxFQUFFLElBQUl3RyxJQUFJLENBQUN4RyxFQUFFO0lBQzlIO0lBRUEsSUFBSXhDLFlBQVkwaEIsV0FBVztRQUN6QkEsV0FBV0E7UUFFWHRjLGFBQWFzRixlQUFlLFdBQVc7WUFDckMsT0FBT2dYLFdBQVcxWSxLQUFLMFksUUFBUTtRQUNqQztJQUNGO0lBRUE3bUIsU0FBUzBlLFNBQVNwVSxPQUFPLENBQUMsU0FBVXdILE1BQU07UUFDeEMsSUFBSXlSLFNBQVMsQ0FBQztRQUVkLElBQUs1YixLQUFLZ2YsU0FBVTtZQUNsQnBELE1BQU0sQ0FBQzViLEVBQUUsR0FBR2dmLFFBQVEsQ0FBQ2hmLEVBQUU7UUFDekI7UUFFQTRiLE9BQU8vUyxPQUFPLEdBQUdzQjtRQUNqQmpNLE9BQU9xRCxJQUFJLENBQUMyRyxjQUFjb1csTUFBTSxDQUFDMUM7SUFDbkM7SUFFQSxPQUFPMWQ7QUFDVCxHQUFHLGdVQUFnVTtBQUduVSxJQUFJb2hCLHVDQUF1QyxTQUFTQSxxQ0FBcUNqYyxVQUFVLEVBQUVtTSxPQUFPLEVBQUV6RSxHQUFHLEVBQUU1TixHQUFHO0lBQ3BIcVMsVUFBVXJTLE1BQU1rRyxXQUFXbEcsT0FBT3FTLFVBQVUsS0FBS25NLFdBQVc7SUFDNUQsT0FBTzBILE1BQU01TixNQUFNLENBQUNBLE1BQU1xUyxPQUFNLElBQU16RSxDQUFBQSxNQUFNeUUsT0FBTSxJQUFLekUsTUFBTSxJQUFJeUUsVUFBV0EsQ0FBQUEsVUFBVXpFLEdBQUUsSUFBSztBQUMvRixHQUNJd1Usc0JBQXNCLFNBQVNBLG9CQUFvQnBWLE1BQU0sRUFBRWpJLFNBQVM7SUFDdEUsSUFBSUEsY0FBYyxNQUFNO1FBQ3RCaUksT0FBT3ZLLEtBQUssQ0FBQ3lOLGNBQWMsQ0FBQztJQUM5QixPQUFPO1FBQ0xsRCxPQUFPdkssS0FBSyxDQUFDNGYsV0FBVyxHQUFHdGQsY0FBYyxPQUFPLFNBQVNBLFlBQVksU0FBU0EsWUFBYTlLLENBQUFBLGtEQUFRQSxDQUFDbVosT0FBTyxHQUFHLGdCQUFnQixFQUFDLElBQUssUUFBUSxrR0FBa0c7SUFDaFA7SUFFQXBHLFdBQVdsUyxVQUFVc25CLG9CQUFvQnJuQixPQUFPZ0s7QUFDbEQsR0FDSXVkLFlBQVk7SUFDZEMsTUFBTTtJQUNONVQsUUFBUTtBQUNWLEdBQ0k2VCxnQkFBZ0IsU0FBU0EsY0FBY0MsS0FBSztJQUM5QyxJQUFJQyxRQUFRRCxNQUFNQyxLQUFLLEVBQ25CMVYsU0FBU3lWLE1BQU16VixNQUFNLEVBQ3JCMlYsT0FBT0YsTUFBTUUsSUFBSTtJQUVyQixJQUFJQyxPQUFPLENBQUNGLE1BQU1HLGNBQWMsR0FBR0gsTUFBTUcsY0FBYyxDQUFDLEVBQUUsR0FBR0gsS0FBSSxFQUFHMVYsTUFBTSxFQUN0RTVDLFFBQVF3WSxLQUFLelQsS0FBSyxJQUFJelUsS0FBS3NWLElBQUksQ0FBQ0MsUUFBUSxDQUFDMlMsT0FDekNuVSxPQUFPNVIsWUFDUDRTO0lBRUosSUFBSSxDQUFDckYsTUFBTTBZLFVBQVUsSUFBSXJVLE9BQU9yRSxNQUFNMFksVUFBVSxHQUFHLE1BQU07UUFDdkQsOENBQThDO1FBQzlDLE1BQU9GLFFBQVFBLFNBQVM3bkIsU0FBVTZuQixDQUFBQSxLQUFLRyxZQUFZLElBQUlILEtBQUtJLFlBQVksSUFBSUosS0FBS0ssV0FBVyxJQUFJTCxLQUFLelksV0FBVyxJQUFJLENBQUVtWSxDQUFBQSxTQUFTLENBQUMsQ0FBQzdTLEtBQUtwTixrQkFBa0J1Z0IsS0FBSSxFQUFHTSxTQUFTLENBQUMsSUFBSVosU0FBUyxDQUFDN1MsR0FBRzBULFNBQVMsQ0FBQyxHQUFJO1lBQ3RNUCxPQUFPQSxLQUFLclQsVUFBVTtRQUN4QjtRQUVBbkYsTUFBTWdaLFNBQVMsR0FBR1IsUUFBUUEsU0FBUzVWLFVBQVUsQ0FBQ3RPLFlBQVlra0IsU0FBVU4sQ0FBQUEsU0FBUyxDQUFDLENBQUM3UyxLQUFLcE4sa0JBQWtCdWdCLEtBQUksRUFBR00sU0FBUyxDQUFDLElBQUlaLFNBQVMsQ0FBQzdTLEdBQUcwVCxTQUFTLENBQUM7UUFDbEovWSxNQUFNMFksVUFBVSxHQUFHclU7SUFDckI7SUFFQSxJQUFJckUsTUFBTWdaLFNBQVMsSUFBSVQsU0FBUyxLQUFLO1FBQ25DRCxNQUFNVyxlQUFlO1FBQ3JCWCxNQUFNWSxVQUFVLEdBQUc7SUFDckI7QUFDRixHQUNJLDBJQUEwSTtBQUM5SUMsaUJBQWlCLFNBQVNBLGVBQWV2VyxNQUFNLEVBQUUzUCxJQUFJLEVBQUVtbUIsTUFBTSxFQUFFQyxNQUFNO0lBQ25FLE9BQU94cEIsa0RBQVFBLENBQUNrbkIsTUFBTSxDQUFDO1FBQ3JCblUsUUFBUUE7UUFDUnJILFNBQVM7UUFDVCtkLFVBQVU7UUFDVkMsVUFBVTtRQUNWdG1CLE1BQU1BO1FBQ051bUIsU0FBU0gsU0FBU0EsVUFBVWpCO1FBQzVCcUIsU0FBU0o7UUFDVEssUUFBUUw7UUFDUk0sVUFBVU47UUFDVk8sVUFBVSxTQUFTQTtZQUNqQixPQUFPUixVQUFVL2QsYUFBYTVLLE1BQU1aLGtEQUFRQSxDQUFDZ3FCLFVBQVUsQ0FBQyxFQUFFLEVBQUVDLGdCQUFnQixPQUFPO1FBQ3JGO1FBQ0FDLFdBQVcsU0FBU0E7WUFDbEIsT0FBT3JlLGdCQUFnQmpMLE1BQU1aLGtEQUFRQSxDQUFDZ3FCLFVBQVUsQ0FBQyxFQUFFLEVBQUVDLGdCQUFnQjtRQUN2RTtJQUNGO0FBQ0YsR0FDSUUsWUFBWSxrQ0FDWkMsaUJBQ0FILGlCQUFpQixTQUFTQSxlQUFldmxCLENBQUM7SUFDNUMsSUFBSTJsQixVQUFVRixVQUFVdFMsSUFBSSxDQUFDblQsRUFBRXFPLE1BQU0sQ0FBQ3VYLE9BQU87SUFFN0MsSUFBSUQsV0FBV0QsaUJBQWlCO1FBQzlCMWxCLEVBQUUya0IsVUFBVSxHQUFHO1FBQ2ZlLGtCQUFrQkM7SUFDcEI7QUFDRixHQUNJRSx1QkFBdUIsU0FBU0EscUJBQXFCbmIsSUFBSTtJQUMzRDlJLFVBQVU4SSxTQUFVQSxDQUFBQSxPQUFPLENBQUM7SUFDNUJBLEtBQUtvYixjQUFjLEdBQUdwYixLQUFLcWIsWUFBWSxHQUFHcmIsS0FBS3NiLFdBQVcsR0FBRztJQUM3RHRiLEtBQUtoTSxJQUFJLElBQUtnTSxDQUFBQSxLQUFLaE0sSUFBSSxHQUFHLGFBQVk7SUFDdENnTSxLQUFLcWEsUUFBUSxHQUFHLENBQUMsQ0FBQ3JhLEtBQUtxYSxRQUFRO0lBQy9CcmEsS0FBS2lELEVBQUUsR0FBR2pELEtBQUtpRCxFQUFFLElBQUk7SUFFckIsSUFBSXNZLFNBQVN2YixNQUNUd2IsbUJBQW1CRCxPQUFPQyxnQkFBZ0IsRUFDMUNDLFdBQVdGLE9BQU9FLFFBQVEsRUFDMUJDLG9CQUFvQkgsT0FBT0csaUJBQWlCLEVBQzVDQyxZQUFZSixPQUFPSSxTQUFTLEVBQzVCMW5CLE1BQ0EybkIsTUFDQWpZLFNBQVM5Uyx3REFBVUEsQ0FBQ21QLEtBQUsyRCxNQUFNLEtBQUtsUyxRQUNwQ29xQixXQUFXeHFCLEtBQUtzVixJQUFJLENBQUNpUCxPQUFPLEdBQUdrRyxjQUFjLEVBQzdDQyxtQkFBbUJGLFlBQVlBLFNBQVNHLEdBQUcsSUFDM0NqTCxVQUFVaGUsY0FBZWlOLENBQUFBLEtBQUsrUSxPQUFPLElBQUlsZ0Isd0RBQVVBLENBQUNtUCxLQUFLK1EsT0FBTyxLQUFLZ0wsb0JBQW9CL2IsS0FBSytRLE9BQU8sS0FBSyxTQUFTLENBQUNnTCxpQkFBaUJyWSxNQUFNLE1BQU1xWSxpQkFBaUJoTCxPQUFPLEVBQUMsR0FDMUtrTCxjQUFjL3FCLDREQUFjQSxDQUFDeVMsUUFBUTdTLG1EQUFTQSxHQUM5Q29yQixjQUFjaHJCLDREQUFjQSxDQUFDeVMsUUFBUTVTLHFEQUFXQSxHQUNoRG9KLFFBQVEsR0FDUmdpQixlQUFlLENBQUN2ckIsa0RBQVFBLENBQUNtWixPQUFPLElBQUl4WSxLQUFLNnFCLGNBQWMsR0FBRzdxQixLQUFLNnFCLGNBQWMsQ0FBQ2ppQixLQUFLLEdBQUc1SSxLQUFLNnFCLGNBQWMsQ0FBQ3htQixLQUFLLEdBQUdyRSxLQUFLOHFCLFVBQVUsSUFBSTlxQixLQUFLc0UsVUFBVSxFQUNwSnltQixlQUFlLEdBQ2ZDLDBCQUEwQnZsQixZQUFZeWtCLFlBQVk7UUFDcEQsT0FBT0EsU0FBU3huQjtJQUNsQixJQUFJO1FBQ0YsT0FBT3duQixZQUFZO0lBQ3JCLEdBQ0llLGVBQ0FDLGVBQ0FDLGdCQUFnQnhDLGVBQWV2VyxRQUFRM0QsS0FBS2hNLElBQUksRUFBRSxNQUFNMG5CLG9CQUN4RGlCLGtCQUFrQixTQUFTQTtRQUM3QixPQUFPRixnQkFBZ0I7SUFDekIsR0FDSUcsZUFBZWhvQixjQUNmaW9CLGVBQWVqb0IsY0FDZmtvQixlQUFlLFNBQVNBO1FBQzFCbEIsT0FBT3BsQixXQUFXbU4sUUFBUTdTLG1EQUFTQTtRQUNuQytyQixlQUFlL3FCLE9BQU9pQixhQUFhLElBQUksR0FBRzZvQjtRQUMxQ0osb0JBQXFCb0IsQ0FBQUEsZUFBZTlxQixPQUFPLEdBQUcwRSxXQUFXbU4sUUFBUTVTLHFEQUFXQSxFQUFDO1FBQzdFeXJCLGdCQUFnQjFaO0lBQ2xCLEdBQ0lpYSxzQkFBc0IsU0FBU0E7UUFDakNoTSxRQUFRakwsS0FBSyxDQUFDak0sQ0FBQyxHQUFHL0UsT0FBT3FKLFdBQVc0UyxRQUFRakwsS0FBSyxDQUFDak0sQ0FBQyxJQUFJb2lCLFlBQVl6ZCxNQUFNLElBQUk7UUFDN0V1UyxRQUFRM1gsS0FBSyxDQUFDNGpCLFNBQVMsR0FBRyxxREFBcUQ3ZSxXQUFXNFMsUUFBUWpMLEtBQUssQ0FBQ2pNLENBQUMsSUFBSTtRQUM3R29pQixZQUFZemQsTUFBTSxHQUFHeWQsWUFBWXRaLE9BQU8sR0FBRztJQUM3QyxHQUNJc2EsYUFBYSxTQUFTQTtRQUN4QixJQUFJUixlQUFlO1lBQ2pCaG9CLHNCQUFzQmtvQjtZQUV0QixJQUFJbmUsU0FBUzFKLE9BQU9iLEtBQUtpcEIsTUFBTSxHQUFHLElBQzlCNVgsU0FBU3VYLGFBQWFaLFlBQVlwbkIsQ0FBQyxHQUFHMko7WUFFMUMsSUFBSXVTLFdBQVd6TCxXQUFXMlcsWUFBWXBuQixDQUFDLEdBQUdvbkIsWUFBWXpkLE1BQU0sRUFBRTtnQkFDNUR5ZCxZQUFZemQsTUFBTSxHQUFHOEcsU0FBUzJXLFlBQVlwbkIsQ0FBQztnQkFFM0MsSUFBSWdGLElBQUkvRSxPQUFPLENBQUNxSixXQUFXNFMsV0FBV0EsUUFBUWpMLEtBQUssQ0FBQ2pNLENBQUMsS0FBSyxLQUFLb2lCLFlBQVl6ZCxNQUFNO2dCQUVqRnVTLFFBQVEzWCxLQUFLLENBQUM0akIsU0FBUyxHQUFHLHFEQUFxRG5qQixJQUFJO2dCQUNuRmtYLFFBQVFqTCxLQUFLLENBQUNqTSxDQUFDLEdBQUdBLElBQUk7Z0JBQ3RCb2lCLFlBQVl0WixPQUFPLEdBQUczUixvREFBVUEsQ0FBQytQLEtBQUs7Z0JBRXRDTDtZQUNGO1lBRUEsT0FBTztRQUNUO1FBRUF1YixZQUFZemQsTUFBTSxJQUFJdWU7UUFDdEJOLGdCQUFnQjtJQUNsQixHQUNJL2lCLE9BQ0F5akIsY0FDQUMsY0FDQUMsbUJBQ0FDLFdBQVcsU0FBU0E7UUFDdEIsaVBBQWlQO1FBQ2pQUjtRQUVBLElBQUlwakIsTUFBTTJXLFFBQVEsTUFBTTNXLE1BQU1zRyxJQUFJLENBQUN1ZCxPQUFPLEdBQUczQixNQUFNO1lBQ2pESyxnQkFBZ0JMLE9BQU9saUIsTUFBTW5DLFFBQVEsQ0FBQyxNQUFNMGtCLFlBQVlMLFFBQVFsaUIsTUFBTXdXLE9BQU8sQ0FBQyxXQUFXMEw7UUFDM0Y7SUFDRjtJQUVBN0ssV0FBVzFmLEtBQUtnUCxHQUFHLENBQUMwUSxTQUFTO1FBQzNCbFgsR0FBRztJQUNMLElBQUksNENBQTRDO0lBRWhEbUcsS0FBS3dkLFdBQVcsR0FBRyxTQUFVbG9CLENBQUM7UUFDNUIsT0FBT3ZDLGNBQWN1QyxFQUFFdEIsSUFBSSxLQUFLLGVBQWVpcEIsV0FBVzNuQixNQUFNNkUsUUFBUSxRQUFRN0UsRUFBRXRCLElBQUksS0FBSyxnQkFBZ0JDLEtBQUt3cEIsV0FBVyxJQUFJbm9CLEVBQUVvb0IsT0FBTyxJQUFJcG9CLEVBQUVvb0IsT0FBTyxDQUFDcHBCLE1BQU0sR0FBRztJQUNqSztJQUVBMEwsS0FBS3dhLE9BQU8sR0FBRztRQUNiaUMsZ0JBQWdCO1FBQ2hCLElBQUlrQixZQUFZeGpCO1FBQ2hCQSxRQUFRckYsT0FBTyxDQUFDdkQsS0FBSzZxQixjQUFjLElBQUk3cUIsS0FBSzZxQixjQUFjLENBQUNqaUIsS0FBSyxJQUFJLEtBQUtnaUI7UUFDekV6aUIsTUFBTXBDLEtBQUs7UUFDWHFtQixjQUFjeGpCLFNBQVM0ZSxvQkFBb0JwVixRQUFReEosUUFBUSxPQUFPLE9BQU9xaEIsbUJBQW1CLFFBQVE7UUFDcEcyQixlQUFlakI7UUFDZmtCLGVBQWVuQjtRQUNmYTtRQUNBTixnQkFBZ0IxWjtJQUNsQjtJQUVBOUMsS0FBSzJiLFNBQVMsR0FBRzNiLEtBQUs0ZCxjQUFjLEdBQUcsU0FBVTNwQixJQUFJLEVBQUU0cEIsV0FBVztRQUNoRTVCLFlBQVl6ZCxNQUFNLElBQUl1ZTtRQUV0QixJQUFJLENBQUNjLGFBQWE7WUFDaEJSLGtCQUFrQi9iLE9BQU8sQ0FBQztRQUM1QixPQUFPO1lBQ0x0USxvREFBVUEsQ0FBQytQLEtBQUssSUFBSSwrQ0FBK0M7WUFDbkUseU5BQXlOO1lBRXpOLElBQUkrYyxNQUFNdkIsMkJBQ053QixlQUNBbk87WUFFSixJQUFJNEwsa0JBQWtCO2dCQUNwQnVDLGdCQUFnQjdCO2dCQUNoQnRNLFlBQVltTyxnQkFBZ0JELE1BQU0sT0FBTyxDQUFDN3BCLEtBQUsrcEIsU0FBUyxHQUFHLE9BQU8saUhBQWlIO2dCQUVuTEYsT0FBT2hGLHFDQUFxQ29ELGFBQWE2QixlQUFlbk8sV0FBV3BaLFdBQVdtTixRQUFRNVMscURBQVdBO2dCQUNqSDJJLE1BQU1zRyxJQUFJLENBQUNpZSxPQUFPLEdBQUdyQixhQUFhaE47WUFDcEM7WUFFQW1PLGdCQUFnQjlCO1lBQ2hCck0sWUFBWW1PLGdCQUFnQkQsTUFBTSxPQUFPLENBQUM3cEIsS0FBS2lxQixTQUFTLEdBQUcsT0FBTyx5Q0FBeUM7WUFFM0dKLE9BQU9oRixxQ0FBcUNtRCxhQUFhOEIsZUFBZW5PLFdBQVdwWixXQUFXbU4sUUFBUTdTLG1EQUFTQTtZQUMvRzRJLE1BQU1zRyxJQUFJLENBQUN1ZCxPQUFPLEdBQUdWLGFBQWFqTjtZQUNsQ2xXLE1BQU1rWSxVQUFVLEdBQUc5VyxRQUFRLENBQUNnakIsS0FBS0ssSUFBSSxDQUFDO1lBRXRDLElBQUlwckIsY0FBYzJHLE1BQU1zRyxJQUFJLENBQUN1ZCxPQUFPLElBQUkzQixRQUFRbUMsaUJBQWlCbkMsT0FBTyxHQUFHO2dCQUN6RSxvTEFBb0w7Z0JBQ3BMdnFCLEtBQUtzSSxFQUFFLENBQUMsQ0FBQyxHQUFHO29CQUNWa1EsVUFBVXlUO29CQUNWeGlCLFVBQVVnakI7Z0JBQ1o7WUFDRjtRQUNGO1FBRUFuQyxhQUFhQSxVQUFVMW5CO0lBQ3pCO0lBRUErTCxLQUFLdWEsT0FBTyxHQUFHO1FBQ2I3Z0IsTUFBTTBrQixHQUFHLElBQUkxa0IsTUFBTXBDLEtBQUs7UUFFeEIsSUFBSTlELGFBQWE4b0IsZUFBZSxNQUFNO1lBQ3BDLGtJQUFrSTtZQUNsSUUsZ0JBQWdCO1lBQ2hCRixlQUFlOW9CO1FBQ2pCO0lBQ0Y7SUFFQXdNLEtBQUtxZSxRQUFRLEdBQUcsU0FBVXBxQixJQUFJLEVBQUVxcUIsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLE1BQU0sRUFBRUMsTUFBTTtRQUNwRDNiLGVBQWUwWixpQkFBaUJNO1FBQ2hDd0IsTUFBTTlDLG9CQUFvQlUsWUFBWVUsYUFBYTRCLE1BQU0sQ0FBQyxFQUFFLEtBQUtGLEtBQUtuQixlQUFnQmxwQixDQUFBQSxLQUFLNE0sTUFBTSxHQUFHNU0sS0FBSzJGLENBQUMsSUFBSXNpQixnQkFBZ0JvQyxLQUFLRSxNQUFNLENBQUMsRUFBRSxJQUFJLDZGQUE2RjtRQUU3TyxJQUFJRCxJQUFJO1lBQ050QyxZQUFZemQsTUFBTSxJQUFJdWU7WUFDdEIsSUFBSWhULFVBQVUwVSxNQUFNLENBQUMsRUFBRSxLQUFLRixJQUN4QjFrQixJQUFJa1EsVUFBVXFULGVBQWVucEIsS0FBS3lxQixNQUFNLEdBQUd6cUIsS0FBSzRGLENBQUMsR0FBR29pQixnQkFBZ0JzQyxLQUFLRSxNQUFNLENBQUMsRUFBRSxFQUNsRkUsV0FBVzlCLGFBQWFoakI7WUFDNUJrUSxXQUFXbFEsTUFBTThrQixZQUFhdkIsQ0FBQUEsZ0JBQWdCdUIsV0FBVzlrQixDQUFBQTtZQUN6RG9pQixZQUFZMEM7UUFDZDtRQUVDSixDQUFBQSxNQUFNRCxFQUFDLEtBQU01ZDtJQUNoQjtJQUVBVixLQUFLMmEsUUFBUSxHQUFHO1FBQ2Q1QixvQkFBb0JwVixRQUFRNlgsbUJBQW1CLFFBQVE7UUFFdkQ5WixjQUFjbkYsZ0JBQWdCLENBQUMsV0FBVytnQjtRQUUxQ2xoQixhQUFhN0ssTUFBTSxVQUFVK3JCO1FBRTdCLElBQUlyQixZQUFZdlksTUFBTSxFQUFFO1lBQ3RCdVksWUFBWXRZLE1BQU0sQ0FBQ3ZLLEtBQUssQ0FBQ3dLLGNBQWMsR0FBRztZQUMxQ3FZLFlBQVl2WSxNQUFNLEdBQUd3WSxZQUFZeFksTUFBTSxHQUFHO1FBQzVDO1FBRUFnWixjQUFjakksTUFBTTtJQUN0QjtJQUVBelUsS0FBSzhhLFNBQVMsR0FBRztRQUNmL0Isb0JBQW9CcFYsUUFBUTtRQUU1QmxILGdCQUFnQmxMLE1BQU0sVUFBVStyQjtRQUVoQzViLGNBQWNoRixtQkFBbUIsQ0FBQyxXQUFXNGdCO1FBQzdDWixjQUFjbGlCLElBQUk7SUFDcEI7SUFFQXdGLEtBQUtzYSxRQUFRLEdBQUd0YSxLQUFLc2EsUUFBUSxLQUFLO0lBQ2xDcm1CLE9BQU8sSUFBSXJELGtEQUFRQSxDQUFDb1A7SUFDcEIvTCxLQUFLMnFCLEdBQUcsR0FBRzdyQixZQUFZLHNLQUFzSztJQUU3TEEsY0FBYyxDQUFDa3BCLGlCQUFpQkEsWUFBWSxJQUFJLDRHQUE0RztJQUU1SmxwQixjQUFjMUIsS0FBS3d0QixNQUFNLENBQUNqbkIsR0FBRyxDQUFDaEQsZUFBZSxtQ0FBbUM7SUFFaEZ5b0Isb0JBQW9CcHBCLEtBQUs2cUIsR0FBRztJQUM1QnBsQixRQUFRckksS0FBS3NJLEVBQUUsQ0FBQzFGLE1BQU07UUFDcEJ1YSxNQUFNO1FBQ05FLFFBQVE7UUFDUi9FLFNBQVM7UUFDVHNVLFNBQVN6QyxtQkFBbUIsVUFBVTtRQUN0QytCLFNBQVM7UUFDVDlULFdBQVc7WUFDVDhULFNBQVM3VSxxQkFBcUJ1VCxhQUFhQSxlQUFlO2dCQUN4RCxPQUFPdmlCLE1BQU1wQyxLQUFLO1lBQ3BCO1FBQ0Y7UUFDQXVTLFVBQVVuSjtRQUNWOEksWUFBWTZULGtCQUFrQnJkLElBQUksQ0FBQ3dKLFVBQVU7SUFDL0MsSUFBSSx3S0FBd0s7SUFFNUssT0FBT3ZWO0FBQ1Q7QUFFQXlOLGNBQWNsRyxJQUFJLEdBQUcsU0FBVTNFLElBQUk7SUFDakMsT0FBT3lKLFVBQVU5RSxJQUFJLENBQUMzRSxRQUFRLFNBQVVQLENBQUMsRUFBRW1GLENBQUM7UUFDMUMsT0FBTyxDQUFDbkYsRUFBRTBKLElBQUksQ0FBQ3FPLGVBQWUsSUFBSSxLQUFLLENBQUMsTUFBTS9YLEVBQUV3SixLQUFLLEdBQUlyRSxDQUFBQSxFQUFFcUUsS0FBSyxHQUFHLENBQUNyRSxFQUFFdUUsSUFBSSxDQUFDcU8sZUFBZSxJQUFJLEtBQUssQ0FBQyxHQUFFO0lBQ3hHO0FBQ0Y7QUFFQTNNLGNBQWNxZCxPQUFPLEdBQUcsU0FBVS9lLElBQUk7SUFDcEMsT0FBTyxJQUFJcFAsa0RBQVFBLENBQUNvUDtBQUN0QjtBQUVBMEIsY0FBY3NkLGVBQWUsR0FBRyxTQUFVaGYsSUFBSTtJQUM1QyxJQUFJLE9BQU9BLFNBQVMsYUFBYTtRQUMvQixPQUFPck47SUFDVDtJQUVBLElBQUlxTixTQUFTLFFBQVFyTixhQUFhO1FBQ2hDLE9BQU9BLFlBQVk4aEIsTUFBTTtJQUMzQjtJQUVBLElBQUl6VSxTQUFTLE9BQU87UUFDbEJyTixlQUFlQSxZQUFZNkgsSUFBSTtRQUMvQjdILGNBQWNxTjtRQUNkO0lBQ0Y7SUFFQSxJQUFJaWYsYUFBYWpmLGdCQUFnQnBQLGtEQUFRQSxHQUFHb1AsT0FBT21iLHFCQUFxQm5iO0lBQ3hFck4sZUFBZUEsWUFBWWdSLE1BQU0sS0FBS3NiLFdBQVd0YixNQUFNLElBQUloUixZQUFZNkgsSUFBSTtJQUMzRW5GLFlBQVk0cEIsV0FBV3RiLE1BQU0sS0FBTWhSLENBQUFBLGNBQWNzc0IsVUFBUztJQUMxRCxPQUFPQTtBQUNUO0FBRUF2ZCxjQUFjaUYsSUFBSSxHQUFHO0lBQ25CLG1FQUFtRTtJQUNuRXZWLGtCQUFrQkEsMERBQWdCQTtJQUNsQzhvQixnQkFBZ0JBO0lBQ2hCbHBCLFlBQVlBLG9EQUFVQTtJQUN0QkMsVUFBVUEsa0RBQVFBO0lBQ2xCaXVCLFFBQVE7UUFDTixpRUFBaUU7UUFDakVDLElBQUksU0FBU0E7WUFDWHZyQixtQkFBbUJvTixVQUFVO1lBQzdCcE4sa0JBQWtCSjtRQUNwQjtRQUNBLGlEQUFpRDtRQUNqRDRyQixLQUFLLFNBQVNBO1lBQ1osT0FBT250QjtRQUNUO0lBQ0Y7QUFDRjtBQUNBa0QsY0FBYzlELEtBQUsrRCxjQUFjLENBQUNzTTtBQUNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9TY3JvbGxUcmlnZ2VyLmpzPzYyYTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBTY3JvbGxUcmlnZ2VyIDMuMTIuNVxuICogaHR0cHM6Ly9nc2FwLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjQsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3NhcC5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR1NBUCBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCB7IE9ic2VydmVyLCBfZ2V0VGFyZ2V0LCBfdmVydGljYWwsIF9ob3Jpem9udGFsLCBfc2Nyb2xsZXJzLCBfcHJveGllcywgX2dldFNjcm9sbEZ1bmMsIF9nZXRQcm94eVByb3AsIF9nZXRWZWxvY2l0eVByb3AgfSBmcm9tIFwiLi9PYnNlcnZlci5qc1wiO1xuXG52YXIgZ3NhcCxcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX3dpbixcbiAgICBfZG9jLFxuICAgIF9kb2NFbCxcbiAgICBfYm9keSxcbiAgICBfcm9vdCxcbiAgICBfcmVzaXplRGVsYXksXG4gICAgX3RvQXJyYXksXG4gICAgX2NsYW1wLFxuICAgIF90aW1lMixcbiAgICBfc3luY0ludGVydmFsLFxuICAgIF9yZWZyZXNoaW5nLFxuICAgIF9wb2ludGVySXNEb3duLFxuICAgIF90cmFuc2Zvcm1Qcm9wLFxuICAgIF9pLFxuICAgIF9wcmV2V2lkdGgsXG4gICAgX3ByZXZIZWlnaHQsXG4gICAgX2F1dG9SZWZyZXNoLFxuICAgIF9zb3J0LFxuICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMsXG4gICAgX2lnbm9yZVJlc2l6ZSxcbiAgICBfbm9ybWFsaXplcixcbiAgICBfaWdub3JlTW9iaWxlUmVzaXplLFxuICAgIF9iYXNlU2NyZWVuSGVpZ2h0LFxuICAgIF9iYXNlU2NyZWVuV2lkdGgsXG4gICAgX2ZpeElPU0J1ZyxcbiAgICBfY29udGV4dCxcbiAgICBfc2Nyb2xsUmVzdG9yYXRpb24sXG4gICAgX2RpdjEwMHZoLFxuICAgIF8xMDB2aCxcbiAgICBfaXNSZXZlcnRlZCxcbiAgICBfY2xhbXBpbmdNYXgsXG4gICAgX2xpbWl0Q2FsbGJhY2tzLFxuICAgIC8vIGlmIHRydWUsIHdlJ2xsIG9ubHkgdHJpZ2dlciBjYWxsYmFja3MgaWYgdGhlIGFjdGl2ZSBzdGF0ZSB0b2dnbGVzLCBzbyBpZiB5b3Ugc2Nyb2xsIGltbWVkaWF0ZWx5IHBhc3QgYm90aCB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgb2YgYSBTY3JvbGxUcmlnZ2VyICh0aHVzIGluYWN0aXZlIHRvIGluYWN0aXZlKSwgbmVpdGhlciBpdHMgb25FbnRlciBub3Igb25MZWF2ZSB3aWxsIGJlIGNhbGxlZC4gVGhpcyBpcyB1c2VmdWwgZHVyaW5nIHN0YXJ0dXAuXG5fc3RhcnR1cCA9IDEsXG4gICAgX2dldFRpbWUgPSBEYXRlLm5vdyxcbiAgICBfdGltZTEgPSBfZ2V0VGltZSgpLFxuICAgIF9sYXN0U2Nyb2xsVGltZSA9IDAsXG4gICAgX2VuYWJsZWQgPSAwLFxuICAgIF9wYXJzZUNsYW1wID0gZnVuY3Rpb24gX3BhcnNlQ2xhbXAodmFsdWUsIHR5cGUsIHNlbGYpIHtcbiAgdmFyIGNsYW1wID0gX2lzU3RyaW5nKHZhbHVlKSAmJiAodmFsdWUuc3Vic3RyKDAsIDYpID09PSBcImNsYW1wKFwiIHx8IHZhbHVlLmluZGV4T2YoXCJtYXhcIikgPiAtMSk7XG4gIHNlbGZbXCJfXCIgKyB0eXBlICsgXCJDbGFtcFwiXSA9IGNsYW1wO1xuICByZXR1cm4gY2xhbXAgPyB2YWx1ZS5zdWJzdHIoNiwgdmFsdWUubGVuZ3RoIC0gNykgOiB2YWx1ZTtcbn0sXG4gICAgX2tlZXBDbGFtcCA9IGZ1bmN0aW9uIF9rZWVwQ2xhbXAodmFsdWUsIGNsYW1wKSB7XG4gIHJldHVybiBjbGFtcCAmJiAoIV9pc1N0cmluZyh2YWx1ZSkgfHwgdmFsdWUuc3Vic3RyKDAsIDYpICE9PSBcImNsYW1wKFwiKSA/IFwiY2xhbXAoXCIgKyB2YWx1ZSArIFwiKVwiIDogdmFsdWU7XG59LFxuICAgIF9yYWZCdWdGaXggPSBmdW5jdGlvbiBfcmFmQnVnRml4KCkge1xuICByZXR1cm4gX2VuYWJsZWQgJiYgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF9yYWZCdWdGaXgpO1xufSxcbiAgICAvLyBpbiBzb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpLCBzY3JlZW4gcmVwYWludHMgd2VyZW4ndCBjb25zaXN0ZW50IHVubGVzcyB3ZSBoYWQgU09NRVRISU5HIHF1ZXVlZCB1cCBpbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSEgU28gdGhpcyBqdXN0IGNyZWF0ZXMgYSBzdXBlciBzaW1wbGUgbG9vcCB0byBrZWVwIGl0IGFsaXZlIGFuZCBzbW9vdGggb3V0IHJlcGFpbnRzLlxuX3BvaW50ZXJEb3duSGFuZGxlciA9IGZ1bmN0aW9uIF9wb2ludGVyRG93bkhhbmRsZXIoKSB7XG4gIHJldHVybiBfcG9pbnRlcklzRG93biA9IDE7XG59LFxuICAgIF9wb2ludGVyVXBIYW5kbGVyID0gZnVuY3Rpb24gX3BvaW50ZXJVcEhhbmRsZXIoKSB7XG4gIHJldHVybiBfcG9pbnRlcklzRG93biA9IDA7XG59LFxuICAgIF9wYXNzVGhyb3VnaCA9IGZ1bmN0aW9uIF9wYXNzVGhyb3VnaCh2KSB7XG4gIHJldHVybiB2O1xufSxcbiAgICBfcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMDApIC8gMTAwMDAwIHx8IDA7XG59LFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgX3dpbmRvd0V4aXN0cygpICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX2lzVmlld3BvcnQgPSBmdW5jdGlvbiBfaXNWaWV3cG9ydChlKSB7XG4gIHJldHVybiAhIX5fcm9vdC5pbmRleE9mKGUpO1xufSxcbiAgICBfZ2V0Vmlld3BvcnREaW1lbnNpb24gPSBmdW5jdGlvbiBfZ2V0Vmlld3BvcnREaW1lbnNpb24oZGltZW5zaW9uUHJvcGVydHkpIHtcbiAgcmV0dXJuIChkaW1lbnNpb25Qcm9wZXJ0eSA9PT0gXCJIZWlnaHRcIiA/IF8xMDB2aCA6IF93aW5bXCJpbm5lclwiICsgZGltZW5zaW9uUHJvcGVydHldKSB8fCBfZG9jRWxbXCJjbGllbnRcIiArIGRpbWVuc2lvblByb3BlcnR5XSB8fCBfYm9keVtcImNsaWVudFwiICsgZGltZW5zaW9uUHJvcGVydHldO1xufSxcbiAgICBfZ2V0Qm91bmRzRnVuYyA9IGZ1bmN0aW9uIF9nZXRCb3VuZHNGdW5jKGVsZW1lbnQpIHtcbiAgcmV0dXJuIF9nZXRQcm94eVByb3AoZWxlbWVudCwgXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcIikgfHwgKF9pc1ZpZXdwb3J0KGVsZW1lbnQpID8gZnVuY3Rpb24gKCkge1xuICAgIF93aW5PZmZzZXRzLndpZHRoID0gX3dpbi5pbm5lcldpZHRoO1xuICAgIF93aW5PZmZzZXRzLmhlaWdodCA9IF8xMDB2aDtcbiAgICByZXR1cm4gX3dpbk9mZnNldHM7XG4gIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9nZXRCb3VuZHMoZWxlbWVudCk7XG4gIH0pO1xufSxcbiAgICBfZ2V0U2l6ZUZ1bmMgPSBmdW5jdGlvbiBfZ2V0U2l6ZUZ1bmMoc2Nyb2xsZXIsIGlzVmlld3BvcnQsIF9yZWYpIHtcbiAgdmFyIGQgPSBfcmVmLmQsXG4gICAgICBkMiA9IF9yZWYuZDIsXG4gICAgICBhID0gX3JlZi5hO1xuICByZXR1cm4gKGEgPSBfZ2V0UHJveHlQcm9wKHNjcm9sbGVyLCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiKSkgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGEoKVtkXTtcbiAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKGlzVmlld3BvcnQgPyBfZ2V0Vmlld3BvcnREaW1lbnNpb24oZDIpIDogc2Nyb2xsZXJbXCJjbGllbnRcIiArIGQyXSkgfHwgMDtcbiAgfTtcbn0sXG4gICAgX2dldE9mZnNldHNGdW5jID0gZnVuY3Rpb24gX2dldE9mZnNldHNGdW5jKGVsZW1lbnQsIGlzVmlld3BvcnQpIHtcbiAgcmV0dXJuICFpc1ZpZXdwb3J0IHx8IH5fcHJveGllcy5pbmRleE9mKGVsZW1lbnQpID8gX2dldEJvdW5kc0Z1bmMoZWxlbWVudCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF93aW5PZmZzZXRzO1xuICB9O1xufSxcbiAgICBfbWF4U2Nyb2xsID0gZnVuY3Rpb24gX21heFNjcm9sbChlbGVtZW50LCBfcmVmMikge1xuICB2YXIgcyA9IF9yZWYyLnMsXG4gICAgICBkMiA9IF9yZWYyLmQyLFxuICAgICAgZCA9IF9yZWYyLmQsXG4gICAgICBhID0gX3JlZjIuYTtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIChzID0gXCJzY3JvbGxcIiArIGQyKSAmJiAoYSA9IF9nZXRQcm94eVByb3AoZWxlbWVudCwgcykpID8gYSgpIC0gX2dldEJvdW5kc0Z1bmMoZWxlbWVudCkoKVtkXSA6IF9pc1ZpZXdwb3J0KGVsZW1lbnQpID8gKF9kb2NFbFtzXSB8fCBfYm9keVtzXSkgLSBfZ2V0Vmlld3BvcnREaW1lbnNpb24oZDIpIDogZWxlbWVudFtzXSAtIGVsZW1lbnRbXCJvZmZzZXRcIiArIGQyXSk7XG59LFxuICAgIF9pdGVyYXRlQXV0b1JlZnJlc2ggPSBmdW5jdGlvbiBfaXRlcmF0ZUF1dG9SZWZyZXNoKGZ1bmMsIGV2ZW50cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IF9hdXRvUmVmcmVzaC5sZW5ndGg7IGkgKz0gMykge1xuICAgICghZXZlbnRzIHx8IH5ldmVudHMuaW5kZXhPZihfYXV0b1JlZnJlc2hbaSArIDFdKSkgJiYgZnVuYyhfYXV0b1JlZnJlc2hbaV0sIF9hdXRvUmVmcmVzaFtpICsgMV0sIF9hdXRvUmVmcmVzaFtpICsgMl0pO1xuICB9XG59LFxuICAgIF9pc1N0cmluZyA9IGZ1bmN0aW9uIF9pc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufSxcbiAgICBfaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIF9pc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn0sXG4gICAgX2lzTnVtYmVyID0gZnVuY3Rpb24gX2lzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG59LFxuICAgIF9pc09iamVjdCA9IGZ1bmN0aW9uIF9pc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufSxcbiAgICBfZW5kQW5pbWF0aW9uID0gZnVuY3Rpb24gX2VuZEFuaW1hdGlvbihhbmltYXRpb24sIHJldmVyc2VkLCBwYXVzZSkge1xuICByZXR1cm4gYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5wcm9ncmVzcyhyZXZlcnNlZCA/IDAgOiAxKSAmJiBwYXVzZSAmJiBhbmltYXRpb24ucGF1c2UoKTtcbn0sXG4gICAgX2NhbGxiYWNrID0gZnVuY3Rpb24gX2NhbGxiYWNrKHNlbGYsIGZ1bmMpIHtcbiAgaWYgKHNlbGYuZW5hYmxlZCkge1xuICAgIHZhciByZXN1bHQgPSBzZWxmLl9jdHggPyBzZWxmLl9jdHguYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jKHNlbGYpO1xuICAgIH0pIDogZnVuYyhzZWxmKTtcbiAgICByZXN1bHQgJiYgcmVzdWx0LnRvdGFsVGltZSAmJiAoc2VsZi5jYWxsYmFja0FuaW1hdGlvbiA9IHJlc3VsdCk7XG4gIH1cbn0sXG4gICAgX2FicyA9IE1hdGguYWJzLFxuICAgIF9sZWZ0ID0gXCJsZWZ0XCIsXG4gICAgX3RvcCA9IFwidG9wXCIsXG4gICAgX3JpZ2h0ID0gXCJyaWdodFwiLFxuICAgIF9ib3R0b20gPSBcImJvdHRvbVwiLFxuICAgIF93aWR0aCA9IFwid2lkdGhcIixcbiAgICBfaGVpZ2h0ID0gXCJoZWlnaHRcIixcbiAgICBfUmlnaHQgPSBcIlJpZ2h0XCIsXG4gICAgX0xlZnQgPSBcIkxlZnRcIixcbiAgICBfVG9wID0gXCJUb3BcIixcbiAgICBfQm90dG9tID0gXCJCb3R0b21cIixcbiAgICBfcGFkZGluZyA9IFwicGFkZGluZ1wiLFxuICAgIF9tYXJnaW4gPSBcIm1hcmdpblwiLFxuICAgIF9XaWR0aCA9IFwiV2lkdGhcIixcbiAgICBfSGVpZ2h0ID0gXCJIZWlnaHRcIixcbiAgICBfcHggPSBcInB4XCIsXG4gICAgX2dldENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbiBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBfd2luLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59LFxuICAgIF9tYWtlUG9zaXRpb25hYmxlID0gZnVuY3Rpb24gX21ha2VQb3NpdGlvbmFibGUoZWxlbWVudCkge1xuICAvLyBpZiB0aGUgZWxlbWVudCBhbHJlYWR5IGhhcyBwb3NpdGlvbjogYWJzb2x1dGUgb3IgZml4ZWQsIGxlYXZlIHRoYXQsIG90aGVyd2lzZSBtYWtlIGl0IHBvc2l0aW9uOiByZWxhdGl2ZVxuICB2YXIgcG9zaXRpb24gPSBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbjtcblxuICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gcG9zaXRpb24gOiBcInJlbGF0aXZlXCI7XG59LFxuICAgIF9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIF9zZXREZWZhdWx0cyhvYmosIGRlZmF1bHRzKSB7XG4gIGZvciAodmFyIHAgaW4gZGVmYXVsdHMpIHtcbiAgICBwIGluIG9iaiB8fCAob2JqW3BdID0gZGVmYXVsdHNbcF0pO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0sXG4gICAgX2dldEJvdW5kcyA9IGZ1bmN0aW9uIF9nZXRCb3VuZHMoZWxlbWVudCwgd2l0aG91dFRyYW5zZm9ybXMpIHtcbiAgdmFyIHR3ZWVuID0gd2l0aG91dFRyYW5zZm9ybXMgJiYgX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudClbX3RyYW5zZm9ybVByb3BdICE9PSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiICYmIGdzYXAudG8oZWxlbWVudCwge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB4UGVyY2VudDogMCxcbiAgICB5UGVyY2VudDogMCxcbiAgICByb3RhdGlvbjogMCxcbiAgICByb3RhdGlvblg6IDAsXG4gICAgcm90YXRpb25ZOiAwLFxuICAgIHNjYWxlOiAxLFxuICAgIHNrZXdYOiAwLFxuICAgIHNrZXdZOiAwXG4gIH0pLnByb2dyZXNzKDEpLFxuICAgICAgYm91bmRzID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdHdlZW4gJiYgdHdlZW4ucHJvZ3Jlc3MoMCkua2lsbCgpO1xuICByZXR1cm4gYm91bmRzO1xufSxcbiAgICBfZ2V0U2l6ZSA9IGZ1bmN0aW9uIF9nZXRTaXplKGVsZW1lbnQsIF9yZWYzKSB7XG4gIHZhciBkMiA9IF9yZWYzLmQyO1xuICByZXR1cm4gZWxlbWVudFtcIm9mZnNldFwiICsgZDJdIHx8IGVsZW1lbnRbXCJjbGllbnRcIiArIGQyXSB8fCAwO1xufSxcbiAgICBfZ2V0TGFiZWxSYXRpb0FycmF5ID0gZnVuY3Rpb24gX2dldExhYmVsUmF0aW9BcnJheSh0aW1lbGluZSkge1xuICB2YXIgYSA9IFtdLFxuICAgICAgbGFiZWxzID0gdGltZWxpbmUubGFiZWxzLFxuICAgICAgZHVyYXRpb24gPSB0aW1lbGluZS5kdXJhdGlvbigpLFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gbGFiZWxzKSB7XG4gICAgYS5wdXNoKGxhYmVsc1twXSAvIGR1cmF0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBhO1xufSxcbiAgICBfZ2V0Q2xvc2VzdExhYmVsID0gZnVuY3Rpb24gX2dldENsb3Nlc3RMYWJlbChhbmltYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBnc2FwLnV0aWxzLnNuYXAoX2dldExhYmVsUmF0aW9BcnJheShhbmltYXRpb24pLCB2YWx1ZSk7XG4gIH07XG59LFxuICAgIF9zbmFwRGlyZWN0aW9uYWwgPSBmdW5jdGlvbiBfc25hcERpcmVjdGlvbmFsKHNuYXBJbmNyZW1lbnRPckFycmF5KSB7XG4gIHZhciBzbmFwID0gZ3NhcC51dGlscy5zbmFwKHNuYXBJbmNyZW1lbnRPckFycmF5KSxcbiAgICAgIGEgPSBBcnJheS5pc0FycmF5KHNuYXBJbmNyZW1lbnRPckFycmF5KSAmJiBzbmFwSW5jcmVtZW50T3JBcnJheS5zbGljZSgwKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xuICB9KTtcbiAgcmV0dXJuIGEgPyBmdW5jdGlvbiAodmFsdWUsIGRpcmVjdGlvbiwgdGhyZXNob2xkKSB7XG4gICAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJlc2hvbGQgPSAxZS0zO1xuICAgIH1cblxuICAgIHZhciBpO1xuXG4gICAgaWYgKCFkaXJlY3Rpb24pIHtcbiAgICAgIHJldHVybiBzbmFwKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xuICAgICAgdmFsdWUgLT0gdGhyZXNob2xkOyAvLyB0byBhdm9pZCByb3VuZGluZyBlcnJvcnMuIElmIHdlJ3JlIHRvbyBzdHJpY3QsIGl0IG1pZ2h0IHNuYXAgZm9yd2FyZCwgdGhlbiBpbW1lZGlhdGVseSBhZ2FpbiwgYW5kIGFnYWluLlxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSA+PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBhW2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhW2kgLSAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaSA9IGEubGVuZ3RoO1xuICAgICAgdmFsdWUgKz0gdGhyZXNob2xkO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmIChhW2ldIDw9IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGFbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYVswXTtcbiAgfSA6IGZ1bmN0aW9uICh2YWx1ZSwgZGlyZWN0aW9uLCB0aHJlc2hvbGQpIHtcbiAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICAgIHRocmVzaG9sZCA9IDFlLTM7XG4gICAgfVxuXG4gICAgdmFyIHNuYXBwZWQgPSBzbmFwKHZhbHVlKTtcbiAgICByZXR1cm4gIWRpcmVjdGlvbiB8fCBNYXRoLmFicyhzbmFwcGVkIC0gdmFsdWUpIDwgdGhyZXNob2xkIHx8IHNuYXBwZWQgLSB2YWx1ZSA8IDAgPT09IGRpcmVjdGlvbiA8IDAgPyBzbmFwcGVkIDogc25hcChkaXJlY3Rpb24gPCAwID8gdmFsdWUgLSBzbmFwSW5jcmVtZW50T3JBcnJheSA6IHZhbHVlICsgc25hcEluY3JlbWVudE9yQXJyYXkpO1xuICB9O1xufSxcbiAgICBfZ2V0TGFiZWxBdERpcmVjdGlvbiA9IGZ1bmN0aW9uIF9nZXRMYWJlbEF0RGlyZWN0aW9uKHRpbWVsaW5lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIHN0KSB7XG4gICAgcmV0dXJuIF9zbmFwRGlyZWN0aW9uYWwoX2dldExhYmVsUmF0aW9BcnJheSh0aW1lbGluZSkpKHZhbHVlLCBzdC5kaXJlY3Rpb24pO1xuICB9O1xufSxcbiAgICBfbXVsdGlMaXN0ZW5lciA9IGZ1bmN0aW9uIF9tdWx0aUxpc3RlbmVyKGZ1bmMsIGVsZW1lbnQsIHR5cGVzLCBjYWxsYmFjaykge1xuICByZXR1cm4gdHlwZXMuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICByZXR1cm4gZnVuYyhlbGVtZW50LCB0eXBlLCBjYWxsYmFjayk7XG4gIH0pO1xufSxcbiAgICBfYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBfYWRkTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgZnVuYywgbm9uUGFzc2l2ZSwgY2FwdHVyZSkge1xuICByZXR1cm4gZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmMsIHtcbiAgICBwYXNzaXZlOiAhbm9uUGFzc2l2ZSxcbiAgICBjYXB0dXJlOiAhIWNhcHR1cmVcbiAgfSk7XG59LFxuICAgIF9yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIF9yZW1vdmVMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBmdW5jLCBjYXB0dXJlKSB7XG4gIHJldHVybiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZnVuYywgISFjYXB0dXJlKTtcbn0sXG4gICAgX3doZWVsTGlzdGVuZXIgPSBmdW5jdGlvbiBfd2hlZWxMaXN0ZW5lcihmdW5jLCBlbCwgc2Nyb2xsRnVuYykge1xuICBzY3JvbGxGdW5jID0gc2Nyb2xsRnVuYyAmJiBzY3JvbGxGdW5jLndoZWVsSGFuZGxlcjtcblxuICBpZiAoc2Nyb2xsRnVuYykge1xuICAgIGZ1bmMoZWwsIFwid2hlZWxcIiwgc2Nyb2xsRnVuYyk7XG4gICAgZnVuYyhlbCwgXCJ0b3VjaG1vdmVcIiwgc2Nyb2xsRnVuYyk7XG4gIH1cbn0sXG4gICAgX21hcmtlckRlZmF1bHRzID0ge1xuICBzdGFydENvbG9yOiBcImdyZWVuXCIsXG4gIGVuZENvbG9yOiBcInJlZFwiLFxuICBpbmRlbnQ6IDAsXG4gIGZvbnRTaXplOiBcIjE2cHhcIixcbiAgZm9udFdlaWdodDogXCJub3JtYWxcIlxufSxcbiAgICBfZGVmYXVsdHMgPSB7XG4gIHRvZ2dsZUFjdGlvbnM6IFwicGxheVwiLFxuICBhbnRpY2lwYXRlUGluOiAwXG59LFxuICAgIF9rZXl3b3JkcyA9IHtcbiAgdG9wOiAwLFxuICBsZWZ0OiAwLFxuICBjZW50ZXI6IDAuNSxcbiAgYm90dG9tOiAxLFxuICByaWdodDogMVxufSxcbiAgICBfb2Zmc2V0VG9QeCA9IGZ1bmN0aW9uIF9vZmZzZXRUb1B4KHZhbHVlLCBzaXplKSB7XG4gIGlmIChfaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIGVxSW5kZXggPSB2YWx1ZS5pbmRleE9mKFwiPVwiKSxcbiAgICAgICAgcmVsYXRpdmUgPSB+ZXFJbmRleCA/ICsodmFsdWUuY2hhckF0KGVxSW5kZXggLSAxKSArIDEpICogcGFyc2VGbG9hdCh2YWx1ZS5zdWJzdHIoZXFJbmRleCArIDEpKSA6IDA7XG5cbiAgICBpZiAofmVxSW5kZXgpIHtcbiAgICAgIHZhbHVlLmluZGV4T2YoXCIlXCIpID4gZXFJbmRleCAmJiAocmVsYXRpdmUgKj0gc2l6ZSAvIDEwMCk7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCBlcUluZGV4IC0gMSk7XG4gICAgfVxuXG4gICAgdmFsdWUgPSByZWxhdGl2ZSArICh2YWx1ZSBpbiBfa2V5d29yZHMgPyBfa2V5d29yZHNbdmFsdWVdICogc2l6ZSA6IH52YWx1ZS5pbmRleE9mKFwiJVwiKSA/IHBhcnNlRmxvYXQodmFsdWUpICogc2l6ZSAvIDEwMCA6IHBhcnNlRmxvYXQodmFsdWUpIHx8IDApO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufSxcbiAgICBfY3JlYXRlTWFya2VyID0gZnVuY3Rpb24gX2NyZWF0ZU1hcmtlcih0eXBlLCBuYW1lLCBjb250YWluZXIsIGRpcmVjdGlvbiwgX3JlZjQsIG9mZnNldCwgbWF0Y2hXaWR0aEVsLCBjb250YWluZXJBbmltYXRpb24pIHtcbiAgdmFyIHN0YXJ0Q29sb3IgPSBfcmVmNC5zdGFydENvbG9yLFxuICAgICAgZW5kQ29sb3IgPSBfcmVmNC5lbmRDb2xvcixcbiAgICAgIGZvbnRTaXplID0gX3JlZjQuZm9udFNpemUsXG4gICAgICBpbmRlbnQgPSBfcmVmNC5pbmRlbnQsXG4gICAgICBmb250V2VpZ2h0ID0gX3JlZjQuZm9udFdlaWdodDtcblxuICB2YXIgZSA9IF9kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgIHVzZUZpeGVkUG9zaXRpb24gPSBfaXNWaWV3cG9ydChjb250YWluZXIpIHx8IF9nZXRQcm94eVByb3AoY29udGFpbmVyLCBcInBpblR5cGVcIikgPT09IFwiZml4ZWRcIixcbiAgICAgIGlzU2Nyb2xsZXIgPSB0eXBlLmluZGV4T2YoXCJzY3JvbGxlclwiKSAhPT0gLTEsXG4gICAgICBwYXJlbnQgPSB1c2VGaXhlZFBvc2l0aW9uID8gX2JvZHkgOiBjb250YWluZXIsXG4gICAgICBpc1N0YXJ0ID0gdHlwZS5pbmRleE9mKFwic3RhcnRcIikgIT09IC0xLFxuICAgICAgY29sb3IgPSBpc1N0YXJ0ID8gc3RhcnRDb2xvciA6IGVuZENvbG9yLFxuICAgICAgY3NzID0gXCJib3JkZXItY29sb3I6XCIgKyBjb2xvciArIFwiO2ZvbnQtc2l6ZTpcIiArIGZvbnRTaXplICsgXCI7Y29sb3I6XCIgKyBjb2xvciArIFwiO2ZvbnQtd2VpZ2h0OlwiICsgZm9udFdlaWdodCArIFwiO3BvaW50ZXItZXZlbnRzOm5vbmU7d2hpdGUtc3BhY2U6bm93cmFwO2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWYsQXJpYWw7ei1pbmRleDoxMDAwO3BhZGRpbmc6NHB4IDhweDtib3JkZXItd2lkdGg6MDtib3JkZXItc3R5bGU6c29saWQ7XCI7XG5cbiAgY3NzICs9IFwicG9zaXRpb246XCIgKyAoKGlzU2Nyb2xsZXIgfHwgY29udGFpbmVyQW5pbWF0aW9uKSAmJiB1c2VGaXhlZFBvc2l0aW9uID8gXCJmaXhlZDtcIiA6IFwiYWJzb2x1dGU7XCIpO1xuICAoaXNTY3JvbGxlciB8fCBjb250YWluZXJBbmltYXRpb24gfHwgIXVzZUZpeGVkUG9zaXRpb24pICYmIChjc3MgKz0gKGRpcmVjdGlvbiA9PT0gX3ZlcnRpY2FsID8gX3JpZ2h0IDogX2JvdHRvbSkgKyBcIjpcIiArIChvZmZzZXQgKyBwYXJzZUZsb2F0KGluZGVudCkpICsgXCJweDtcIik7XG4gIG1hdGNoV2lkdGhFbCAmJiAoY3NzICs9IFwiYm94LXNpemluZzpib3JkZXItYm94O3RleHQtYWxpZ246bGVmdDt3aWR0aDpcIiArIG1hdGNoV2lkdGhFbC5vZmZzZXRXaWR0aCArIFwicHg7XCIpO1xuICBlLl9pc1N0YXJ0ID0gaXNTdGFydDtcbiAgZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImdzYXAtbWFya2VyLVwiICsgdHlwZSArIChuYW1lID8gXCIgbWFya2VyLVwiICsgbmFtZSA6IFwiXCIpKTtcbiAgZS5zdHlsZS5jc3NUZXh0ID0gY3NzO1xuICBlLmlubmVyVGV4dCA9IG5hbWUgfHwgbmFtZSA9PT0gMCA/IHR5cGUgKyBcIi1cIiArIG5hbWUgOiB0eXBlO1xuICBwYXJlbnQuY2hpbGRyZW5bMF0gPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKGUsIHBhcmVudC5jaGlsZHJlblswXSkgOiBwYXJlbnQuYXBwZW5kQ2hpbGQoZSk7XG4gIGUuX29mZnNldCA9IGVbXCJvZmZzZXRcIiArIGRpcmVjdGlvbi5vcC5kMl07XG5cbiAgX3Bvc2l0aW9uTWFya2VyKGUsIDAsIGRpcmVjdGlvbiwgaXNTdGFydCk7XG5cbiAgcmV0dXJuIGU7XG59LFxuICAgIF9wb3NpdGlvbk1hcmtlciA9IGZ1bmN0aW9uIF9wb3NpdGlvbk1hcmtlcihtYXJrZXIsIHN0YXJ0LCBkaXJlY3Rpb24sIGZsaXBwZWQpIHtcbiAgdmFyIHZhcnMgPSB7XG4gICAgZGlzcGxheTogXCJibG9ja1wiXG4gIH0sXG4gICAgICBzaWRlID0gZGlyZWN0aW9uW2ZsaXBwZWQgPyBcIm9zMlwiIDogXCJwMlwiXSxcbiAgICAgIG9wcG9zaXRlU2lkZSA9IGRpcmVjdGlvbltmbGlwcGVkID8gXCJwMlwiIDogXCJvczJcIl07XG4gIG1hcmtlci5faXNGbGlwcGVkID0gZmxpcHBlZDtcbiAgdmFyc1tkaXJlY3Rpb24uYSArIFwiUGVyY2VudFwiXSA9IGZsaXBwZWQgPyAtMTAwIDogMDtcbiAgdmFyc1tkaXJlY3Rpb24uYV0gPSBmbGlwcGVkID8gXCIxcHhcIiA6IDA7XG4gIHZhcnNbXCJib3JkZXJcIiArIHNpZGUgKyBfV2lkdGhdID0gMTtcbiAgdmFyc1tcImJvcmRlclwiICsgb3Bwb3NpdGVTaWRlICsgX1dpZHRoXSA9IDA7XG4gIHZhcnNbZGlyZWN0aW9uLnBdID0gc3RhcnQgKyBcInB4XCI7XG4gIGdzYXAuc2V0KG1hcmtlciwgdmFycyk7XG59LFxuICAgIF90cmlnZ2VycyA9IFtdLFxuICAgIF9pZHMgPSB7fSxcbiAgICBfcmFmSUQsXG4gICAgX3N5bmMgPSBmdW5jdGlvbiBfc3luYygpIHtcbiAgcmV0dXJuIF9nZXRUaW1lKCkgLSBfbGFzdFNjcm9sbFRpbWUgPiAzNCAmJiAoX3JhZklEIHx8IChfcmFmSUQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3VwZGF0ZUFsbCkpKTtcbn0sXG4gICAgX29uU2Nyb2xsID0gZnVuY3Rpb24gX29uU2Nyb2xsKCkge1xuICAvLyBwcmV2aW91c2x5LCB3ZSB0cmllZCB0byBvcHRpbWl6ZSBwZXJmb3JtYW5jZSBieSBiYXRjaGluZy9kZWZlcnJpbmcgdG8gdGhlIG5leHQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCksIGJ1dCBkaXNjb3ZlcmVkIHRoYXQgU2FmYXJpIGhhcyBhIGZldyBidWdzIHRoYXQgbWFrZSB0aGlzIHVud29ya2FibGUgKGVzcGVjaWFsbHkgb24gaU9TKS4gU2VlIGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuLzE2YzQzNWIxMmVmMDljMzgxMjUyMDQ4MThlN2I0NWZjP2VkaXRvcnM9MDAxMCBhbmQgaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vSmpPeFlwUS8zZGQ2NWNjZWM1YTYwZjFkODYyYzM1NWQ4NGQxNDU2Mj9lZGl0b3JzPTAwMTAgYW5kIGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuL0V4YnJQTmEvMDg3Y2VmMTk3ZGMzNTQ0NWEwOTUxZTg5MzVjNDE1MDM/ZWRpdG9ycz0wMDEwXG4gIGlmICghX25vcm1hbGl6ZXIgfHwgIV9ub3JtYWxpemVyLmlzUHJlc3NlZCB8fCBfbm9ybWFsaXplci5zdGFydFggPiBfYm9keS5jbGllbnRXaWR0aCkge1xuICAgIC8vIGlmIHRoZSB1c2VyIGlzIGRyYWdnaW5nIHRoZSBzY3JvbGxiYXIsIGFsbG93IGl0LlxuICAgIF9zY3JvbGxlcnMuY2FjaGUrKztcblxuICAgIGlmIChfbm9ybWFsaXplcikge1xuICAgICAgX3JhZklEIHx8IChfcmFmSUQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3VwZGF0ZUFsbCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdXBkYXRlQWxsKCk7IC8vIFNhZmFyaSBpbiBwYXJ0aWN1bGFyIChvbiBkZXNrdG9wKSBORUVEUyB0aGUgaW1tZWRpYXRlIHVwZGF0ZSByYXRoZXIgdGhhbiB3YWl0aW5nIGZvciBhIHJlcXVlc3RBbmltYXRpb25GcmFtZSgpIHdoZXJlYXMgaU9TIHNlZW1zIHRvIGJlbmVmaXQgZnJvbSB3YWl0aW5nIGZvciB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkgdGljaywgYXQgbGVhc3Qgd2hlbiBub3JtYWxpemluZy4gU2VlIGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuL3FCWW96cU8/ZWRpdG9ycz0wMTEwXG5cbiAgICB9XG5cbiAgICBfbGFzdFNjcm9sbFRpbWUgfHwgX2Rpc3BhdGNoKFwic2Nyb2xsU3RhcnRcIik7XG4gICAgX2xhc3RTY3JvbGxUaW1lID0gX2dldFRpbWUoKTtcbiAgfVxufSxcbiAgICBfc2V0QmFzZURpbWVuc2lvbnMgPSBmdW5jdGlvbiBfc2V0QmFzZURpbWVuc2lvbnMoKSB7XG4gIF9iYXNlU2NyZWVuV2lkdGggPSBfd2luLmlubmVyV2lkdGg7XG4gIF9iYXNlU2NyZWVuSGVpZ2h0ID0gX3dpbi5pbm5lckhlaWdodDtcbn0sXG4gICAgX29uUmVzaXplID0gZnVuY3Rpb24gX29uUmVzaXplKCkge1xuICBfc2Nyb2xsZXJzLmNhY2hlKys7XG4gICFfcmVmcmVzaGluZyAmJiAhX2lnbm9yZVJlc2l6ZSAmJiAhX2RvYy5mdWxsc2NyZWVuRWxlbWVudCAmJiAhX2RvYy53ZWJraXRGdWxsc2NyZWVuRWxlbWVudCAmJiAoIV9pZ25vcmVNb2JpbGVSZXNpemUgfHwgX2Jhc2VTY3JlZW5XaWR0aCAhPT0gX3dpbi5pbm5lcldpZHRoIHx8IE1hdGguYWJzKF93aW4uaW5uZXJIZWlnaHQgLSBfYmFzZVNjcmVlbkhlaWdodCkgPiBfd2luLmlubmVySGVpZ2h0ICogMC4yNSkgJiYgX3Jlc2l6ZURlbGF5LnJlc3RhcnQodHJ1ZSk7XG59LFxuICAgIC8vIGlnbm9yZSByZXNpemVzIHRyaWdnZXJlZCBieSByZWZyZXNoKClcbl9saXN0ZW5lcnMgPSB7fSxcbiAgICBfZW1wdHlBcnJheSA9IFtdLFxuICAgIF9zb2Z0UmVmcmVzaCA9IGZ1bmN0aW9uIF9zb2Z0UmVmcmVzaCgpIHtcbiAgcmV0dXJuIF9yZW1vdmVMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInNjcm9sbEVuZFwiLCBfc29mdFJlZnJlc2gpIHx8IF9yZWZyZXNoQWxsKHRydWUpO1xufSxcbiAgICBfZGlzcGF0Y2ggPSBmdW5jdGlvbiBfZGlzcGF0Y2godHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVyc1t0eXBlXSAmJiBfbGlzdGVuZXJzW3R5cGVdLm1hcChmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmKCk7XG4gIH0pIHx8IF9lbXB0eUFycmF5O1xufSxcbiAgICBfc2F2ZWRTdHlsZXMgPSBbXSxcbiAgICAvLyB3aGVuIFNjcm9sbFRyaWdnZXIuc2F2ZVN0eWxlcygpIGlzIGNhbGxlZCwgdGhlIGlubGluZSBzdHlsZXMgYXJlIHJlY29yZGVkIGluIHRoaXMgQXJyYXkgaW4gYSBzZXF1ZW50aWFsIGZvcm1hdCBsaWtlIFtlbGVtZW50LCBjc3NUZXh0LCBnc0NhY2hlLCBtZWRpYV0uIFRoaXMga2VlcHMgaXQgdmVyeSBtZW1vcnktZWZmaWNpZW50IGFuZCBmYXN0IHRvIGl0ZXJhdGUgdGhyb3VnaC5cbl9yZXZlcnRSZWNvcmRlZCA9IGZ1bmN0aW9uIF9yZXZlcnRSZWNvcmRlZChtZWRpYSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IF9zYXZlZFN0eWxlcy5sZW5ndGg7IGkgKz0gNSkge1xuICAgIGlmICghbWVkaWEgfHwgX3NhdmVkU3R5bGVzW2kgKyA0XSAmJiBfc2F2ZWRTdHlsZXNbaSArIDRdLnF1ZXJ5ID09PSBtZWRpYSkge1xuICAgICAgX3NhdmVkU3R5bGVzW2ldLnN0eWxlLmNzc1RleHQgPSBfc2F2ZWRTdHlsZXNbaSArIDFdO1xuICAgICAgX3NhdmVkU3R5bGVzW2ldLmdldEJCb3ggJiYgX3NhdmVkU3R5bGVzW2ldLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBfc2F2ZWRTdHlsZXNbaSArIDJdIHx8IFwiXCIpO1xuICAgICAgX3NhdmVkU3R5bGVzW2kgKyAzXS51bmNhY2hlID0gMTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX3JldmVydEFsbCA9IGZ1bmN0aW9uIF9yZXZlcnRBbGwoa2lsbCwgbWVkaWEpIHtcbiAgdmFyIHRyaWdnZXI7XG5cbiAgZm9yIChfaSA9IDA7IF9pIDwgX3RyaWdnZXJzLmxlbmd0aDsgX2krKykge1xuICAgIHRyaWdnZXIgPSBfdHJpZ2dlcnNbX2ldO1xuXG4gICAgaWYgKHRyaWdnZXIgJiYgKCFtZWRpYSB8fCB0cmlnZ2VyLl9jdHggPT09IG1lZGlhKSkge1xuICAgICAgaWYgKGtpbGwpIHtcbiAgICAgICAgdHJpZ2dlci5raWxsKDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJpZ2dlci5yZXZlcnQodHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2lzUmV2ZXJ0ZWQgPSB0cnVlO1xuICBtZWRpYSAmJiBfcmV2ZXJ0UmVjb3JkZWQobWVkaWEpO1xuICBtZWRpYSB8fCBfZGlzcGF0Y2goXCJyZXZlcnRcIik7XG59LFxuICAgIF9jbGVhclNjcm9sbE1lbW9yeSA9IGZ1bmN0aW9uIF9jbGVhclNjcm9sbE1lbW9yeShzY3JvbGxSZXN0b3JhdGlvbiwgZm9yY2UpIHtcbiAgLy8gemVyby1vdXQgYWxsIHRoZSByZWNvcmRlZCBzY3JvbGwgcG9zaXRpb25zLiBEb24ndCB1c2UgX3RyaWdnZXJzIGJlY2F1c2UgaWYsIGZvciBleGFtcGxlLCAubWF0Y2hNZWRpYSgpIGlzIHVzZWQgdG8gY3JlYXRlIHNvbWUgU2Nyb2xsVHJpZ2dlcnMgYW5kIHRoZW4gdGhlIHVzZXIgcmVzaXplcyBhbmQgaXQgcmVtb3ZlcyBBTEwgU2Nyb2xsVHJpZ2dlcnMsIGFuZCB0aGVuIGdvIGJhY2sgdG8gYSBzaXplIHdoZXJlIHRoZXJlIGFyZSBTY3JvbGxUcmlnZ2VycywgaXQgd291bGQgaGF2ZSBrZXB0IHRoZSBwb3NpdGlvbihzKSBzYXZlZCBmcm9tIHRoZSBpbml0aWFsIHN0YXRlLlxuICBfc2Nyb2xsZXJzLmNhY2hlKys7XG4gIChmb3JjZSB8fCAhX3JlZnJlc2hpbmdBbGwpICYmIF9zY3JvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIF9pc0Z1bmN0aW9uKG9iaikgJiYgb2JqLmNhY2hlSUQrKyAmJiAob2JqLnJlYyA9IDApO1xuICB9KTtcbiAgX2lzU3RyaW5nKHNjcm9sbFJlc3RvcmF0aW9uKSAmJiAoX3dpbi5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gX3Njcm9sbFJlc3RvcmF0aW9uID0gc2Nyb2xsUmVzdG9yYXRpb24pO1xufSxcbiAgICBfcmVmcmVzaGluZ0FsbCxcbiAgICBfcmVmcmVzaElEID0gMCxcbiAgICBfcXVldWVSZWZyZXNoSUQsXG4gICAgX3F1ZXVlUmVmcmVzaEFsbCA9IGZ1bmN0aW9uIF9xdWV1ZVJlZnJlc2hBbGwoKSB7XG4gIC8vIHdlIGRvbid0IHdhbnQgdG8gY2FsbCBfcmVmcmVzaEFsbCgpIGV2ZXJ5IHRpbWUgd2UgY3JlYXRlIGEgbmV3IFNjcm9sbFRyaWdnZXIgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKSAtIGl0J3MgYmV0dGVyIHRvIGJhdGNoIHRoZW0uIFNvbWUgZnJhbWV3b3JrcyBkeW5hbWljYWxseSBsb2FkIGNvbnRlbnQgYW5kIHdlIGNhbid0IHJlbHkgb24gdGhlIHdpbmRvdydzIFwibG9hZFwiIG9yIFwiRE9NQ29udGVudExvYWRlZFwiIGV2ZW50cyB0byB0cmlnZ2VyIGl0LlxuICBpZiAoX3F1ZXVlUmVmcmVzaElEICE9PSBfcmVmcmVzaElEKSB7XG4gICAgdmFyIGlkID0gX3F1ZXVlUmVmcmVzaElEID0gX3JlZnJlc2hJRDtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGlkID09PSBfcmVmcmVzaElEICYmIF9yZWZyZXNoQWxsKHRydWUpO1xuICAgIH0pO1xuICB9XG59LFxuICAgIF9yZWZyZXNoMTAwdmggPSBmdW5jdGlvbiBfcmVmcmVzaDEwMHZoKCkge1xuICBfYm9keS5hcHBlbmRDaGlsZChfZGl2MTAwdmgpO1xuXG4gIF8xMDB2aCA9ICFfbm9ybWFsaXplciAmJiBfZGl2MTAwdmgub2Zmc2V0SGVpZ2h0IHx8IF93aW4uaW5uZXJIZWlnaHQ7XG5cbiAgX2JvZHkucmVtb3ZlQ2hpbGQoX2RpdjEwMHZoKTtcbn0sXG4gICAgX2hpZGVBbGxNYXJrZXJzID0gZnVuY3Rpb24gX2hpZGVBbGxNYXJrZXJzKGhpZGUpIHtcbiAgcmV0dXJuIF90b0FycmF5KFwiLmdzYXAtbWFya2VyLXN0YXJ0LCAuZ3NhcC1tYXJrZXItZW5kLCAuZ3NhcC1tYXJrZXItc2Nyb2xsZXItc3RhcnQsIC5nc2FwLW1hcmtlci1zY3JvbGxlci1lbmRcIikuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWwuc3R5bGUuZGlzcGxheSA9IGhpZGUgPyBcIm5vbmVcIiA6IFwiYmxvY2tcIjtcbiAgfSk7XG59LFxuICAgIF9yZWZyZXNoQWxsID0gZnVuY3Rpb24gX3JlZnJlc2hBbGwoZm9yY2UsIHNraXBSZXZlcnQpIHtcbiAgaWYgKF9sYXN0U2Nyb2xsVGltZSAmJiAhZm9yY2UgJiYgIV9pc1JldmVydGVkKSB7XG4gICAgX2FkZExpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwic2Nyb2xsRW5kXCIsIF9zb2Z0UmVmcmVzaCk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBfcmVmcmVzaDEwMHZoKCk7XG5cbiAgX3JlZnJlc2hpbmdBbGwgPSBTY3JvbGxUcmlnZ2VyLmlzUmVmcmVzaGluZyA9IHRydWU7XG5cbiAgX3Njcm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gX2lzRnVuY3Rpb24ob2JqKSAmJiArK29iai5jYWNoZUlEICYmIChvYmoucmVjID0gb2JqKCkpO1xuICB9KTsgLy8gZm9yY2UgdGhlIGNsZWFyaW5nIG9mIHRoZSBjYWNoZSBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgdGFrZSBhIGxpdHRsZSB3aGlsZSB0byBkaXNwYXRjaCB0aGUgXCJzY3JvbGxcIiBldmVudCBhbmQgdGhlIHVzZXIgbWF5IGhhdmUgY2hhbmdlZCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGFuZCB0aGVuIGNhbGxlZCBTY3JvbGxUcmlnZ2VyLnJlZnJlc2goKSByaWdodCBhd2F5XG5cblxuICB2YXIgcmVmcmVzaEluaXRzID0gX2Rpc3BhdGNoKFwicmVmcmVzaEluaXRcIik7XG5cbiAgX3NvcnQgJiYgU2Nyb2xsVHJpZ2dlci5zb3J0KCk7XG4gIHNraXBSZXZlcnQgfHwgX3JldmVydEFsbCgpO1xuXG4gIF9zY3JvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKF9pc0Z1bmN0aW9uKG9iaikpIHtcbiAgICAgIG9iai5zbW9vdGggJiYgKG9iai50YXJnZXQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSBcImF1dG9cIik7IC8vIHNtb290aCBzY3JvbGxpbmcgaW50ZXJmZXJlc1xuXG4gICAgICBvYmooMCk7XG4gICAgfVxuICB9KTtcblxuICBfdHJpZ2dlcnMuc2xpY2UoMCkuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0LnJlZnJlc2goKTtcbiAgfSk7IC8vIGRvbid0IGxvb3Agd2l0aCBfaSBiZWNhdXNlIGR1cmluZyBhIHJlZnJlc2goKSBzb21lb25lIGNvdWxkIGNhbGwgU2Nyb2xsVHJpZ2dlci51cGRhdGUoKSB3aGljaCB3b3VsZCBpdGVyYXRlIHRocm91Z2ggX2kgcmVzdWx0aW5nIGluIGEgc2tpcC5cblxuXG4gIF9pc1JldmVydGVkID0gZmFsc2U7XG5cbiAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAvLyBuZXN0ZWQgcGlucyAocGlubmVkQ29udGFpbmVyKSB3aXRoIHBpblNwYWNpbmcgbWF5IGV4cGFuZCB0aGUgY29udGFpbmVyLCBzbyB3ZSBtdXN0IGFjY29tbW9kYXRlIHRoYXQgaGVyZS5cbiAgICBpZiAodC5fc3ViUGluT2Zmc2V0ICYmIHQucGluKSB7XG4gICAgICB2YXIgcHJvcCA9IHQudmFycy5ob3Jpem9udGFsID8gXCJvZmZzZXRXaWR0aFwiIDogXCJvZmZzZXRIZWlnaHRcIixcbiAgICAgICAgICBvcmlnaW5hbCA9IHQucGluW3Byb3BdO1xuICAgICAgdC5yZXZlcnQodHJ1ZSwgMSk7XG4gICAgICB0LmFkanVzdFBpblNwYWNpbmcodC5waW5bcHJvcF0gLSBvcmlnaW5hbCk7XG4gICAgICB0LnJlZnJlc2goKTtcbiAgICB9XG4gIH0pO1xuXG4gIF9jbGFtcGluZ01heCA9IDE7IC8vIHBpblNwYWNpbmcgbWlnaHQgYmUgcHJvcHBpbmcgYSBwYWdlIG9wZW4sIHRodXMgd2hlbiB3ZSAuc2V0UG9zaXRpb25zKCkgdG8gY2xhbXAgYSBTY3JvbGxUcmlnZ2VyJ3MgZW5kIHdlIHNob3VsZCBsZWF2ZSB0aGUgcGluU3BhY2luZyBhbG9uZS4gVGhhdCdzIHdoYXQgdGhpcyBmbGFnIGlzIGZvci5cblxuICBfaGlkZUFsbE1hcmtlcnModHJ1ZSk7XG5cbiAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAvLyB0aGUgc2Nyb2xsZXIncyBtYXggc2Nyb2xsIHBvc2l0aW9uIG1heSBjaGFuZ2UgYWZ0ZXIgYWxsIHRoZSBTY3JvbGxUcmlnZ2VycyByZWZyZXNoZWQgKGxpa2UgcGlubmluZyBjb3VsZCBwdXNoIGl0IGRvd24pLCBzbyB3ZSBuZWVkIHRvIGxvb3AgYmFjayBhbmQgY29ycmVjdCBhbnkgd2l0aCBlbmQ6IFwibWF4XCIuIFNhbWUgZm9yIGFueXRoaW5nIHdpdGggYSBjbGFtcGVkIGVuZFxuICAgIHZhciBtYXggPSBfbWF4U2Nyb2xsKHQuc2Nyb2xsZXIsIHQuX2RpciksXG4gICAgICAgIGVuZENsYW1wID0gdC52YXJzLmVuZCA9PT0gXCJtYXhcIiB8fCB0Ll9lbmRDbGFtcCAmJiB0LmVuZCA+IG1heCxcbiAgICAgICAgc3RhcnRDbGFtcCA9IHQuX3N0YXJ0Q2xhbXAgJiYgdC5zdGFydCA+PSBtYXg7XG5cbiAgICAoZW5kQ2xhbXAgfHwgc3RhcnRDbGFtcCkgJiYgdC5zZXRQb3NpdGlvbnMoc3RhcnRDbGFtcCA/IG1heCAtIDEgOiB0LnN0YXJ0LCBlbmRDbGFtcCA/IE1hdGgubWF4KHN0YXJ0Q2xhbXAgPyBtYXggOiB0LnN0YXJ0ICsgMSwgbWF4KSA6IHQuZW5kLCB0cnVlKTtcbiAgfSk7XG5cbiAgX2hpZGVBbGxNYXJrZXJzKGZhbHNlKTtcblxuICBfY2xhbXBpbmdNYXggPSAwO1xuICByZWZyZXNoSW5pdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdCAmJiByZXN1bHQucmVuZGVyICYmIHJlc3VsdC5yZW5kZXIoLTEpO1xuICB9KTsgLy8gaWYgdGhlIG9uUmVmcmVzaEluaXQoKSByZXR1cm5zIGFuIGFuaW1hdGlvbiAodHlwaWNhbGx5IGEgZ3NhcC5zZXQoKSksIHJldmVydCBpdC4gVGhpcyBtYWtlcyBpdCBlYXN5IHRvIHB1dCB0aGluZ3MgaW4gYSBjZXJ0YWluIHNwb3QgYmVmb3JlIHJlZnJlc2hpbmcgZm9yIG1lYXN1cmVtZW50IHB1cnBvc2VzLCBhbmQgdGhlbiBwdXQgdGhpbmdzIGJhY2suXG5cbiAgX3Njcm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoX2lzRnVuY3Rpb24ob2JqKSkge1xuICAgICAgb2JqLnNtb290aCAmJiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb2JqLnRhcmdldC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IFwic21vb3RoXCI7XG4gICAgICB9KTtcbiAgICAgIG9iai5yZWMgJiYgb2JqKG9iai5yZWMpO1xuICAgIH1cbiAgfSk7XG5cbiAgX2NsZWFyU2Nyb2xsTWVtb3J5KF9zY3JvbGxSZXN0b3JhdGlvbiwgMSk7XG5cbiAgX3Jlc2l6ZURlbGF5LnBhdXNlKCk7XG5cbiAgX3JlZnJlc2hJRCsrO1xuICBfcmVmcmVzaGluZ0FsbCA9IDI7XG5cbiAgX3VwZGF0ZUFsbCgyKTtcblxuICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBfaXNGdW5jdGlvbih0LnZhcnMub25SZWZyZXNoKSAmJiB0LnZhcnMub25SZWZyZXNoKHQpO1xuICB9KTtcblxuICBfcmVmcmVzaGluZ0FsbCA9IFNjcm9sbFRyaWdnZXIuaXNSZWZyZXNoaW5nID0gZmFsc2U7XG5cbiAgX2Rpc3BhdGNoKFwicmVmcmVzaFwiKTtcbn0sXG4gICAgX2xhc3RTY3JvbGwgPSAwLFxuICAgIF9kaXJlY3Rpb24gPSAxLFxuICAgIF9wcmltYXJ5LFxuICAgIF91cGRhdGVBbGwgPSBmdW5jdGlvbiBfdXBkYXRlQWxsKGZvcmNlKSB7XG4gIGlmIChmb3JjZSA9PT0gMiB8fCAhX3JlZnJlc2hpbmdBbGwgJiYgIV9pc1JldmVydGVkKSB7XG4gICAgLy8gX2lzUmV2ZXJ0ZWQgY291bGQgYmUgdHJ1ZSBpZiwgZm9yIGV4YW1wbGUsIGEgbWF0Y2hNZWRpYSgpIGlzIGluIHRoZSBwcm9jZXNzIG9mIGV4ZWN1dGluZy4gV2UgZG9uJ3Qgd2FudCB0byB1cGRhdGUgZHVyaW5nIHRoZSB0aW1lIGV2ZXJ5dGhpbmcgaXMgcmV2ZXJ0ZWQuXG4gICAgU2Nyb2xsVHJpZ2dlci5pc1VwZGF0aW5nID0gdHJ1ZTtcbiAgICBfcHJpbWFyeSAmJiBfcHJpbWFyeS51cGRhdGUoMCk7IC8vIFNjcm9sbFNtb290aGVyIHVzZXMgcmVmcmVzaFByaW9yaXR5IC05OTk5IHRvIGJlY29tZSB0aGUgcHJpbWFyeSB0aGF0IGdldHMgdXBkYXRlZCBiZWZvcmUgYWxsIG90aGVycyBiZWNhdXNlIGl0IGFmZmVjdHMgdGhlIHNjcm9sbCBwb3NpdGlvbi5cblxuICAgIHZhciBsID0gX3RyaWdnZXJzLmxlbmd0aCxcbiAgICAgICAgdGltZSA9IF9nZXRUaW1lKCksXG4gICAgICAgIHJlY29yZFZlbG9jaXR5ID0gdGltZSAtIF90aW1lMSA+PSA1MCxcbiAgICAgICAgc2Nyb2xsID0gbCAmJiBfdHJpZ2dlcnNbMF0uc2Nyb2xsKCk7XG5cbiAgICBfZGlyZWN0aW9uID0gX2xhc3RTY3JvbGwgPiBzY3JvbGwgPyAtMSA6IDE7XG4gICAgX3JlZnJlc2hpbmdBbGwgfHwgKF9sYXN0U2Nyb2xsID0gc2Nyb2xsKTtcblxuICAgIGlmIChyZWNvcmRWZWxvY2l0eSkge1xuICAgICAgaWYgKF9sYXN0U2Nyb2xsVGltZSAmJiAhX3BvaW50ZXJJc0Rvd24gJiYgdGltZSAtIF9sYXN0U2Nyb2xsVGltZSA+IDIwMCkge1xuICAgICAgICBfbGFzdFNjcm9sbFRpbWUgPSAwO1xuXG4gICAgICAgIF9kaXNwYXRjaChcInNjcm9sbEVuZFwiKTtcbiAgICAgIH1cblxuICAgICAgX3RpbWUyID0gX3RpbWUxO1xuICAgICAgX3RpbWUxID0gdGltZTtcbiAgICB9XG5cbiAgICBpZiAoX2RpcmVjdGlvbiA8IDApIHtcbiAgICAgIF9pID0gbDtcblxuICAgICAgd2hpbGUgKF9pLS0gPiAwKSB7XG4gICAgICAgIF90cmlnZ2Vyc1tfaV0gJiYgX3RyaWdnZXJzW19pXS51cGRhdGUoMCwgcmVjb3JkVmVsb2NpdHkpO1xuICAgICAgfVxuXG4gICAgICBfZGlyZWN0aW9uID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChfaSA9IDA7IF9pIDwgbDsgX2krKykge1xuICAgICAgICBfdHJpZ2dlcnNbX2ldICYmIF90cmlnZ2Vyc1tfaV0udXBkYXRlKDAsIHJlY29yZFZlbG9jaXR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBTY3JvbGxUcmlnZ2VyLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIF9yYWZJRCA9IDA7XG59LFxuICAgIF9wcm9wTmFtZXNUb0NvcHkgPSBbX2xlZnQsIF90b3AsIF9ib3R0b20sIF9yaWdodCwgX21hcmdpbiArIF9Cb3R0b20sIF9tYXJnaW4gKyBfUmlnaHQsIF9tYXJnaW4gKyBfVG9wLCBfbWFyZ2luICsgX0xlZnQsIFwiZGlzcGxheVwiLCBcImZsZXhTaHJpbmtcIiwgXCJmbG9hdFwiLCBcInpJbmRleFwiLCBcImdyaWRDb2x1bW5TdGFydFwiLCBcImdyaWRDb2x1bW5FbmRcIiwgXCJncmlkUm93U3RhcnRcIiwgXCJncmlkUm93RW5kXCIsIFwiZ3JpZEFyZWFcIiwgXCJqdXN0aWZ5U2VsZlwiLCBcImFsaWduU2VsZlwiLCBcInBsYWNlU2VsZlwiLCBcIm9yZGVyXCJdLFxuICAgIF9zdGF0ZVByb3BzID0gX3Byb3BOYW1lc1RvQ29weS5jb25jYXQoW193aWR0aCwgX2hlaWdodCwgXCJib3hTaXppbmdcIiwgXCJtYXhcIiArIF9XaWR0aCwgXCJtYXhcIiArIF9IZWlnaHQsIFwicG9zaXRpb25cIiwgX21hcmdpbiwgX3BhZGRpbmcsIF9wYWRkaW5nICsgX1RvcCwgX3BhZGRpbmcgKyBfUmlnaHQsIF9wYWRkaW5nICsgX0JvdHRvbSwgX3BhZGRpbmcgKyBfTGVmdF0pLFxuICAgIF9zd2FwUGluT3V0ID0gZnVuY3Rpb24gX3N3YXBQaW5PdXQocGluLCBzcGFjZXIsIHN0YXRlKSB7XG4gIF9zZXRTdGF0ZShzdGF0ZSk7XG5cbiAgdmFyIGNhY2hlID0gcGluLl9nc2FwO1xuXG4gIGlmIChjYWNoZS5zcGFjZXJJc05hdGl2ZSkge1xuICAgIF9zZXRTdGF0ZShjYWNoZS5zcGFjZXJTdGF0ZSk7XG4gIH0gZWxzZSBpZiAocGluLl9nc2FwLnN3YXBwZWRJbikge1xuICAgIHZhciBwYXJlbnQgPSBzcGFjZXIucGFyZW50Tm9kZTtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUocGluLCBzcGFjZXIpO1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHNwYWNlcik7XG4gICAgfVxuICB9XG5cbiAgcGluLl9nc2FwLnN3YXBwZWRJbiA9IGZhbHNlO1xufSxcbiAgICBfc3dhcFBpbkluID0gZnVuY3Rpb24gX3N3YXBQaW5JbihwaW4sIHNwYWNlciwgY3MsIHNwYWNlclN0YXRlKSB7XG4gIGlmICghcGluLl9nc2FwLnN3YXBwZWRJbikge1xuICAgIHZhciBpID0gX3Byb3BOYW1lc1RvQ29weS5sZW5ndGgsXG4gICAgICAgIHNwYWNlclN0eWxlID0gc3BhY2VyLnN0eWxlLFxuICAgICAgICBwaW5TdHlsZSA9IHBpbi5zdHlsZSxcbiAgICAgICAgcDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHAgPSBfcHJvcE5hbWVzVG9Db3B5W2ldO1xuICAgICAgc3BhY2VyU3R5bGVbcF0gPSBjc1twXTtcbiAgICB9XG5cbiAgICBzcGFjZXJTdHlsZS5wb3NpdGlvbiA9IGNzLnBvc2l0aW9uID09PSBcImFic29sdXRlXCIgPyBcImFic29sdXRlXCIgOiBcInJlbGF0aXZlXCI7XG4gICAgY3MuZGlzcGxheSA9PT0gXCJpbmxpbmVcIiAmJiAoc3BhY2VyU3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCIpO1xuICAgIHBpblN0eWxlW19ib3R0b21dID0gcGluU3R5bGVbX3JpZ2h0XSA9IFwiYXV0b1wiO1xuICAgIHNwYWNlclN0eWxlLmZsZXhCYXNpcyA9IGNzLmZsZXhCYXNpcyB8fCBcImF1dG9cIjtcbiAgICBzcGFjZXJTdHlsZS5vdmVyZmxvdyA9IFwidmlzaWJsZVwiO1xuICAgIHNwYWNlclN0eWxlLmJveFNpemluZyA9IFwiYm9yZGVyLWJveFwiO1xuICAgIHNwYWNlclN0eWxlW193aWR0aF0gPSBfZ2V0U2l6ZShwaW4sIF9ob3Jpem9udGFsKSArIF9weDtcbiAgICBzcGFjZXJTdHlsZVtfaGVpZ2h0XSA9IF9nZXRTaXplKHBpbiwgX3ZlcnRpY2FsKSArIF9weDtcbiAgICBzcGFjZXJTdHlsZVtfcGFkZGluZ10gPSBwaW5TdHlsZVtfbWFyZ2luXSA9IHBpblN0eWxlW190b3BdID0gcGluU3R5bGVbX2xlZnRdID0gXCIwXCI7XG5cbiAgICBfc2V0U3RhdGUoc3BhY2VyU3RhdGUpO1xuXG4gICAgcGluU3R5bGVbX3dpZHRoXSA9IHBpblN0eWxlW1wibWF4XCIgKyBfV2lkdGhdID0gY3NbX3dpZHRoXTtcbiAgICBwaW5TdHlsZVtfaGVpZ2h0XSA9IHBpblN0eWxlW1wibWF4XCIgKyBfSGVpZ2h0XSA9IGNzW19oZWlnaHRdO1xuICAgIHBpblN0eWxlW19wYWRkaW5nXSA9IGNzW19wYWRkaW5nXTtcblxuICAgIGlmIChwaW4ucGFyZW50Tm9kZSAhPT0gc3BhY2VyKSB7XG4gICAgICBwaW4ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3BhY2VyLCBwaW4pO1xuICAgICAgc3BhY2VyLmFwcGVuZENoaWxkKHBpbik7XG4gICAgfVxuXG4gICAgcGluLl9nc2FwLnN3YXBwZWRJbiA9IHRydWU7XG4gIH1cbn0sXG4gICAgX2NhcHNFeHAgPSAvKFtBLVpdKS9nLFxuICAgIF9zZXRTdGF0ZSA9IGZ1bmN0aW9uIF9zZXRTdGF0ZShzdGF0ZSkge1xuICBpZiAoc3RhdGUpIHtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS50LnN0eWxlLFxuICAgICAgICBsID0gc3RhdGUubGVuZ3RoLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgcCxcbiAgICAgICAgdmFsdWU7XG4gICAgKHN0YXRlLnQuX2dzYXAgfHwgZ3NhcC5jb3JlLmdldENhY2hlKHN0YXRlLnQpKS51bmNhY2hlID0gMTsgLy8gb3RoZXJ3aXNlIHRyYW5zZm9ybXMgbWF5IGJlIG9mZlxuXG4gICAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgIHZhbHVlID0gc3RhdGVbaSArIDFdO1xuICAgICAgcCA9IHN0YXRlW2ldO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgc3R5bGVbcF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGVbcF0pIHtcbiAgICAgICAgc3R5bGUucmVtb3ZlUHJvcGVydHkocC5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG4gICAgX2dldFN0YXRlID0gZnVuY3Rpb24gX2dldFN0YXRlKGVsZW1lbnQpIHtcbiAgLy8gcmV0dXJucyBhbiBBcnJheSB3aXRoIGFsdGVybmF0aW5nIHZhbHVlcyBsaWtlIFtwcm9wZXJ0eSwgdmFsdWUsIHByb3BlcnR5LCB2YWx1ZV0gYW5kIGEgXCJ0XCIgcHJvcGVydHkgcG9pbnRpbmcgdG8gdGhlIHRhcmdldCAoZWxlbWVudCkuIE1ha2VzIGl0IGZhc3QgYW5kIGNoZWFwLlxuICB2YXIgbCA9IF9zdGF0ZVByb3BzLmxlbmd0aCxcbiAgICAgIHN0eWxlID0gZWxlbWVudC5zdHlsZSxcbiAgICAgIHN0YXRlID0gW10sXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIHN0YXRlLnB1c2goX3N0YXRlUHJvcHNbaV0sIHN0eWxlW19zdGF0ZVByb3BzW2ldXSk7XG4gIH1cblxuICBzdGF0ZS50ID0gZWxlbWVudDtcbiAgcmV0dXJuIHN0YXRlO1xufSxcbiAgICBfY29weVN0YXRlID0gZnVuY3Rpb24gX2NvcHlTdGF0ZShzdGF0ZSwgb3ZlcnJpZGUsIG9taXRPZmZzZXRzKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIGwgPSBzdGF0ZS5sZW5ndGgsXG4gICAgICBpID0gb21pdE9mZnNldHMgPyA4IDogMCxcbiAgICAgIC8vIHNraXAgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tIGlmIG9taXRPZmZzZXRzIGlzIHRydWVcbiAgcDtcblxuICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHAgPSBzdGF0ZVtpXTtcbiAgICByZXN1bHQucHVzaChwLCBwIGluIG92ZXJyaWRlID8gb3ZlcnJpZGVbcF0gOiBzdGF0ZVtpICsgMV0pO1xuICB9XG5cbiAgcmVzdWx0LnQgPSBzdGF0ZS50O1xuICByZXR1cm4gcmVzdWx0O1xufSxcbiAgICBfd2luT2Zmc2V0cyA9IHtcbiAgbGVmdDogMCxcbiAgdG9wOiAwXG59LFxuICAgIC8vIC8vIHBvdGVudGlhbCBmdXR1cmUgZmVhdHVyZSAoPykgQWxsb3cgdXNlcnMgdG8gY2FsY3VsYXRlIHdoZXJlIGEgdHJpZ2dlciBoaXRzIChzY3JvbGwgcG9zaXRpb24pIGxpa2UgZ2V0U2Nyb2xsUG9zaXRpb24oXCIjaWRcIiwgXCJ0b3AgYm90dG9tXCIpXG4vLyBfZ2V0U2Nyb2xsUG9zaXRpb24gPSAodHJpZ2dlciwgcG9zaXRpb24sIHtzY3JvbGxlciwgY29udGFpbmVyQW5pbWF0aW9uLCBob3Jpem9udGFsfSkgPT4ge1xuLy8gXHRzY3JvbGxlciA9IF9nZXRUYXJnZXQoc2Nyb2xsZXIgfHwgX3dpbik7XG4vLyBcdGxldCBkaXJlY3Rpb24gPSBob3Jpem9udGFsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwsXG4vLyBcdFx0aXNWaWV3cG9ydCA9IF9pc1ZpZXdwb3J0KHNjcm9sbGVyKTtcbi8vIFx0X2dldFNpemVGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0LCBkaXJlY3Rpb24pO1xuLy8gXHRyZXR1cm4gX3BhcnNlUG9zaXRpb24ocG9zaXRpb24sIF9nZXRUYXJnZXQodHJpZ2dlciksIF9nZXRTaXplRnVuYyhzY3JvbGxlciwgaXNWaWV3cG9ydCwgZGlyZWN0aW9uKSgpLCBkaXJlY3Rpb24sIF9nZXRTY3JvbGxGdW5jKHNjcm9sbGVyLCBkaXJlY3Rpb24pKCksIDAsIDAsIDAsIF9nZXRPZmZzZXRzRnVuYyhzY3JvbGxlciwgaXNWaWV3cG9ydCkoKSwgaXNWaWV3cG9ydCA/IDAgOiBwYXJzZUZsb2F0KF9nZXRDb21wdXRlZFN0eWxlKHNjcm9sbGVyKVtcImJvcmRlclwiICsgZGlyZWN0aW9uLnAyICsgX1dpZHRoXSkgfHwgMCwgMCwgY29udGFpbmVyQW5pbWF0aW9uID8gY29udGFpbmVyQW5pbWF0aW9uLmR1cmF0aW9uKCkgOiBfbWF4U2Nyb2xsKHNjcm9sbGVyKSwgY29udGFpbmVyQW5pbWF0aW9uKTtcbi8vIH0sXG5fcGFyc2VQb3NpdGlvbiA9IGZ1bmN0aW9uIF9wYXJzZVBvc2l0aW9uKHZhbHVlLCB0cmlnZ2VyLCBzY3JvbGxlclNpemUsIGRpcmVjdGlvbiwgc2Nyb2xsLCBtYXJrZXIsIG1hcmtlclNjcm9sbGVyLCBzZWxmLCBzY3JvbGxlckJvdW5kcywgYm9yZGVyV2lkdGgsIHVzZUZpeGVkUG9zaXRpb24sIHNjcm9sbGVyTWF4LCBjb250YWluZXJBbmltYXRpb24sIGNsYW1wWmVyb1Byb3ApIHtcbiAgX2lzRnVuY3Rpb24odmFsdWUpICYmICh2YWx1ZSA9IHZhbHVlKHNlbGYpKTtcblxuICBpZiAoX2lzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5zdWJzdHIoMCwgMykgPT09IFwibWF4XCIpIHtcbiAgICB2YWx1ZSA9IHNjcm9sbGVyTWF4ICsgKHZhbHVlLmNoYXJBdCg0KSA9PT0gXCI9XCIgPyBfb2Zmc2V0VG9QeChcIjBcIiArIHZhbHVlLnN1YnN0cigzKSwgc2Nyb2xsZXJTaXplKSA6IDApO1xuICB9XG5cbiAgdmFyIHRpbWUgPSBjb250YWluZXJBbmltYXRpb24gPyBjb250YWluZXJBbmltYXRpb24udGltZSgpIDogMCxcbiAgICAgIHAxLFxuICAgICAgcDIsXG4gICAgICBlbGVtZW50O1xuICBjb250YWluZXJBbmltYXRpb24gJiYgY29udGFpbmVyQW5pbWF0aW9uLnNlZWsoMCk7XG4gIGlzTmFOKHZhbHVlKSB8fCAodmFsdWUgPSArdmFsdWUpOyAvLyBjb252ZXJ0IGEgc3RyaW5nIG51bWJlciBsaWtlIFwiNDVcIiB0byBhbiBhY3R1YWwgbnVtYmVyXG5cbiAgaWYgKCFfaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgX2lzRnVuY3Rpb24odHJpZ2dlcikgJiYgKHRyaWdnZXIgPSB0cmlnZ2VyKHNlbGYpKTtcbiAgICB2YXIgb2Zmc2V0cyA9ICh2YWx1ZSB8fCBcIjBcIikuc3BsaXQoXCIgXCIpLFxuICAgICAgICBib3VuZHMsXG4gICAgICAgIGxvY2FsT2Zmc2V0LFxuICAgICAgICBnbG9iYWxPZmZzZXQsXG4gICAgICAgIGRpc3BsYXk7XG4gICAgZWxlbWVudCA9IF9nZXRUYXJnZXQodHJpZ2dlciwgc2VsZikgfHwgX2JvZHk7XG4gICAgYm91bmRzID0gX2dldEJvdW5kcyhlbGVtZW50KSB8fCB7fTtcblxuICAgIGlmICgoIWJvdW5kcyB8fCAhYm91bmRzLmxlZnQgJiYgIWJvdW5kcy50b3ApICYmIF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgICAvLyBpZiBkaXNwbGF5IGlzIFwibm9uZVwiLCBpdCB3b24ndCByZXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgcHJvcGVybHlcbiAgICAgIGRpc3BsYXkgPSBlbGVtZW50LnN0eWxlLmRpc3BsYXk7XG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKGVsZW1lbnQpO1xuICAgICAgZGlzcGxheSA/IGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXkgOiBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZGlzcGxheVwiKTtcbiAgICB9XG5cbiAgICBsb2NhbE9mZnNldCA9IF9vZmZzZXRUb1B4KG9mZnNldHNbMF0sIGJvdW5kc1tkaXJlY3Rpb24uZF0pO1xuICAgIGdsb2JhbE9mZnNldCA9IF9vZmZzZXRUb1B4KG9mZnNldHNbMV0gfHwgXCIwXCIsIHNjcm9sbGVyU2l6ZSk7XG4gICAgdmFsdWUgPSBib3VuZHNbZGlyZWN0aW9uLnBdIC0gc2Nyb2xsZXJCb3VuZHNbZGlyZWN0aW9uLnBdIC0gYm9yZGVyV2lkdGggKyBsb2NhbE9mZnNldCArIHNjcm9sbCAtIGdsb2JhbE9mZnNldDtcbiAgICBtYXJrZXJTY3JvbGxlciAmJiBfcG9zaXRpb25NYXJrZXIobWFya2VyU2Nyb2xsZXIsIGdsb2JhbE9mZnNldCwgZGlyZWN0aW9uLCBzY3JvbGxlclNpemUgLSBnbG9iYWxPZmZzZXQgPCAyMCB8fCBtYXJrZXJTY3JvbGxlci5faXNTdGFydCAmJiBnbG9iYWxPZmZzZXQgPiAyMCk7XG4gICAgc2Nyb2xsZXJTaXplIC09IHNjcm9sbGVyU2l6ZSAtIGdsb2JhbE9mZnNldDsgLy8gYWRqdXN0IGZvciB0aGUgbWFya2VyXG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyQW5pbWF0aW9uICYmICh2YWx1ZSA9IGdzYXAudXRpbHMubWFwUmFuZ2UoY29udGFpbmVyQW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIuc3RhcnQsIGNvbnRhaW5lckFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyLmVuZCwgMCwgc2Nyb2xsZXJNYXgsIHZhbHVlKSk7XG4gICAgbWFya2VyU2Nyb2xsZXIgJiYgX3Bvc2l0aW9uTWFya2VyKG1hcmtlclNjcm9sbGVyLCBzY3JvbGxlclNpemUsIGRpcmVjdGlvbiwgdHJ1ZSk7XG4gIH1cblxuICBpZiAoY2xhbXBaZXJvUHJvcCkge1xuICAgIHNlbGZbY2xhbXBaZXJvUHJvcF0gPSB2YWx1ZSB8fCAtMC4wMDE7XG4gICAgdmFsdWUgPCAwICYmICh2YWx1ZSA9IDApO1xuICB9XG5cbiAgaWYgKG1hcmtlcikge1xuICAgIHZhciBwb3NpdGlvbiA9IHZhbHVlICsgc2Nyb2xsZXJTaXplLFxuICAgICAgICBpc1N0YXJ0ID0gbWFya2VyLl9pc1N0YXJ0O1xuICAgIHAxID0gXCJzY3JvbGxcIiArIGRpcmVjdGlvbi5kMjtcblxuICAgIF9wb3NpdGlvbk1hcmtlcihtYXJrZXIsIHBvc2l0aW9uLCBkaXJlY3Rpb24sIGlzU3RhcnQgJiYgcG9zaXRpb24gPiAyMCB8fCAhaXNTdGFydCAmJiAodXNlRml4ZWRQb3NpdGlvbiA/IE1hdGgubWF4KF9ib2R5W3AxXSwgX2RvY0VsW3AxXSkgOiBtYXJrZXIucGFyZW50Tm9kZVtwMV0pIDw9IHBvc2l0aW9uICsgMSk7XG5cbiAgICBpZiAodXNlRml4ZWRQb3NpdGlvbikge1xuICAgICAgc2Nyb2xsZXJCb3VuZHMgPSBfZ2V0Qm91bmRzKG1hcmtlclNjcm9sbGVyKTtcbiAgICAgIHVzZUZpeGVkUG9zaXRpb24gJiYgKG1hcmtlci5zdHlsZVtkaXJlY3Rpb24ub3AucF0gPSBzY3JvbGxlckJvdW5kc1tkaXJlY3Rpb24ub3AucF0gLSBkaXJlY3Rpb24ub3AubSAtIG1hcmtlci5fb2Zmc2V0ICsgX3B4KTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29udGFpbmVyQW5pbWF0aW9uICYmIGVsZW1lbnQpIHtcbiAgICBwMSA9IF9nZXRCb3VuZHMoZWxlbWVudCk7XG4gICAgY29udGFpbmVyQW5pbWF0aW9uLnNlZWsoc2Nyb2xsZXJNYXgpO1xuICAgIHAyID0gX2dldEJvdW5kcyhlbGVtZW50KTtcbiAgICBjb250YWluZXJBbmltYXRpb24uX2NhU2Nyb2xsRGlzdCA9IHAxW2RpcmVjdGlvbi5wXSAtIHAyW2RpcmVjdGlvbi5wXTtcbiAgICB2YWx1ZSA9IHZhbHVlIC8gY29udGFpbmVyQW5pbWF0aW9uLl9jYVNjcm9sbERpc3QgKiBzY3JvbGxlck1heDtcbiAgfVxuXG4gIGNvbnRhaW5lckFuaW1hdGlvbiAmJiBjb250YWluZXJBbmltYXRpb24uc2Vlayh0aW1lKTtcbiAgcmV0dXJuIGNvbnRhaW5lckFuaW1hdGlvbiA/IHZhbHVlIDogTWF0aC5yb3VuZCh2YWx1ZSk7XG59LFxuICAgIF9wcmVmaXhFeHAgPSAvKHdlYmtpdHxtb3p8bGVuZ3RofGNzc1RleHR8aW5zZXQpL2ksXG4gICAgX3JlcGFyZW50ID0gZnVuY3Rpb24gX3JlcGFyZW50KGVsZW1lbnQsIHBhcmVudCwgdG9wLCBsZWZ0KSB7XG4gIGlmIChlbGVtZW50LnBhcmVudE5vZGUgIT09IHBhcmVudCkge1xuICAgIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGUsXG4gICAgICAgIHAsXG4gICAgICAgIGNzO1xuXG4gICAgaWYgKHBhcmVudCA9PT0gX2JvZHkpIHtcbiAgICAgIGVsZW1lbnQuX3N0T3JpZyA9IHN0eWxlLmNzc1RleHQ7IC8vIHJlY29yZCBvcmlnaW5hbCBpbmxpbmUgc3R5bGVzIHNvIHdlIGNhbiByZXZlcnQgdGhlbSBsYXRlclxuXG4gICAgICBjcyA9IF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgICBmb3IgKHAgaW4gY3MpIHtcbiAgICAgICAgLy8gbXVzdCBjb3B5IGFsbCByZWxldmFudCBzdHlsZXMgdG8gZW5zdXJlIHRoYXQgbm90aGluZyBjaGFuZ2VzIHZpc3VhbGx5IHdoZW4gd2UgcmVwYXJlbnQgdG8gdGhlIDxib2R5Pi4gU2tpcCB0aGUgdmVuZG9yIHByZWZpeGVkIG9uZXMuXG4gICAgICAgIGlmICghK3AgJiYgIV9wcmVmaXhFeHAudGVzdChwKSAmJiBjc1twXSAmJiB0eXBlb2Ygc3R5bGVbcF0gPT09IFwic3RyaW5nXCIgJiYgcCAhPT0gXCIwXCIpIHtcbiAgICAgICAgICBzdHlsZVtwXSA9IGNzW3BdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0eWxlLnRvcCA9IHRvcDtcbiAgICAgIHN0eWxlLmxlZnQgPSBsZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5jc3NUZXh0ID0gZWxlbWVudC5fc3RPcmlnO1xuICAgIH1cblxuICAgIGdzYXAuY29yZS5nZXRDYWNoZShlbGVtZW50KS51bmNhY2hlID0gMTtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gIH1cbn0sXG4gICAgX2ludGVycnVwdGlvblRyYWNrZXIgPSBmdW5jdGlvbiBfaW50ZXJydXB0aW9uVHJhY2tlcihnZXRWYWx1ZUZ1bmMsIGluaXRpYWxWYWx1ZSwgb25JbnRlcnJ1cHQpIHtcbiAgdmFyIGxhc3QxID0gaW5pdGlhbFZhbHVlLFxuICAgICAgbGFzdDIgPSBsYXN0MTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBjdXJyZW50ID0gTWF0aC5yb3VuZChnZXRWYWx1ZUZ1bmMoKSk7IC8vIHJvdW5kIGJlY2F1c2UgaW4gc29tZSBbdmVyeSB1bmNvbW1vbl0gV2luZG93cyBlbnZpcm9ubWVudHMsIHNjcm9sbCBjYW4gZ2V0IHJlcG9ydGVkIHdpdGggZGVjaW1hbHMgZXZlbiB0aG91Z2ggaXQgd2FzIHNldCB3aXRob3V0LlxuXG4gICAgaWYgKGN1cnJlbnQgIT09IGxhc3QxICYmIGN1cnJlbnQgIT09IGxhc3QyICYmIE1hdGguYWJzKGN1cnJlbnQgLSBsYXN0MSkgPiAzICYmIE1hdGguYWJzKGN1cnJlbnQgLSBsYXN0MikgPiAzKSB7XG4gICAgICAvLyBpZiB0aGUgdXNlciBzY3JvbGxzLCBraWxsIHRoZSB0d2Vlbi4gaU9TIFNhZmFyaSBpbnRlcm1pdHRlbnRseSBtaXNyZXBvcnRzIHRoZSBzY3JvbGwgcG9zaXRpb24sIGl0IG1heSBiZSB0aGUgbW9zdCByZWNlbnRseS1zZXQgb25lIG9yIHRoZSBvbmUgYmVmb3JlIHRoYXQhIFdoZW4gU2FmYXJpIGlzIHpvb21lZCAoQ01ELSspLCBpdCBvZnRlbiBtaXNyZXBvcnRzIGFzIDEgcGl4ZWwgb2ZmIHRvbyEgU28gaWYgd2Ugc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gdG8gMTI1LCBmb3IgZXhhbXBsZSwgaXQnbGwgYWN0dWFsbHkgcmVwb3J0IGl0IGFzIDEyNC5cbiAgICAgIHZhbHVlID0gY3VycmVudDtcbiAgICAgIG9uSW50ZXJydXB0ICYmIG9uSW50ZXJydXB0KCk7XG4gICAgfVxuXG4gICAgbGFzdDIgPSBsYXN0MTtcbiAgICBsYXN0MSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn0sXG4gICAgX3NoaWZ0TWFya2VyID0gZnVuY3Rpb24gX3NoaWZ0TWFya2VyKG1hcmtlciwgZGlyZWN0aW9uLCB2YWx1ZSkge1xuICB2YXIgdmFycyA9IHt9O1xuICB2YXJzW2RpcmVjdGlvbi5wXSA9IFwiKz1cIiArIHZhbHVlO1xuICBnc2FwLnNldChtYXJrZXIsIHZhcnMpO1xufSxcbiAgICAvLyBfbWVyZ2VBbmltYXRpb25zID0gYW5pbWF0aW9ucyA9PiB7XG4vLyBcdGxldCB0bCA9IGdzYXAudGltZWxpbmUoe3Ntb290aENoaWxkVGltaW5nOiB0cnVlfSkuc3RhcnRUaW1lKE1hdGgubWluKC4uLmFuaW1hdGlvbnMubWFwKGEgPT4gYS5nbG9iYWxUaW1lKDApKSkpO1xuLy8gXHRhbmltYXRpb25zLmZvckVhY2goYSA9PiB7bGV0IHRpbWUgPSBhLnRvdGFsVGltZSgpOyB0bC5hZGQoYSk7IGEudG90YWxUaW1lKHRpbWUpOyB9KTtcbi8vIFx0dGwuc21vb3RoQ2hpbGRUaW1pbmcgPSBmYWxzZTtcbi8vIFx0cmV0dXJuIHRsO1xuLy8gfSxcbi8vIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHR3ZWVuIHRoZSBzY3JvbGwgcG9zaXRpb24gaW4gdGhlIGRpcmVjdGlvbiBwcm92aWRlZCwgYW5kIHdoZW4gZG9pbmcgc28gaXQnbGwgYWRkIGEgLnR3ZWVuIHByb3BlcnR5IHRvIHRoZSBGVU5DVElPTiBpdHNlbGYsIGFuZCByZW1vdmUgaXQgd2hlbiB0aGUgdHdlZW4gY29tcGxldGVzIG9yIGdldHMga2lsbGVkLiBUaGlzIGdpdmVzIHVzIGEgd2F5IHRvIGhhdmUgbXVsdGlwbGUgU2Nyb2xsVHJpZ2dlcnMgdXNlIGEgY2VudHJhbCBmdW5jdGlvbiBmb3IgYW55IGdpdmVuIHNjcm9sbGVyIGFuZCBzZWUgaWYgdGhlcmUncyBhIHNjcm9sbCB0d2VlbiBydW5uaW5nICh3aGljaCB3b3VsZCBhZmZlY3QgaWYvaG93IHRoaW5ncyBnZXQgdXBkYXRlZClcbl9nZXRUd2VlbkNyZWF0b3IgPSBmdW5jdGlvbiBfZ2V0VHdlZW5DcmVhdG9yKHNjcm9sbGVyLCBkaXJlY3Rpb24pIHtcbiAgdmFyIGdldFNjcm9sbCA9IF9nZXRTY3JvbGxGdW5jKHNjcm9sbGVyLCBkaXJlY3Rpb24pLFxuICAgICAgcHJvcCA9IFwiX3Njcm9sbFwiICsgZGlyZWN0aW9uLnAyLFxuICAgICAgLy8gYWRkIGEgdHdlZW5hYmxlIHByb3BlcnR5IHRvIHRoZSBzY3JvbGxlciB0aGF0J3MgYSBnZXR0ZXIvc2V0dGVyIGZ1bmN0aW9uLCBsaWtlIF9zY3JvbGxUb3Agb3IgX3Njcm9sbExlZnQuIFRoaXMgd2F5LCBpZiBzb21lb25lIGRvZXMgZ3NhcC5raWxsVHdlZW5zT2Yoc2Nyb2xsZXIpIGl0J2xsIGtpbGwgdGhlIHNjcm9sbCB0d2Vlbi5cbiAgZ2V0VHdlZW4gPSBmdW5jdGlvbiBnZXRUd2VlbihzY3JvbGxUbywgdmFycywgaW5pdGlhbFZhbHVlLCBjaGFuZ2UxLCBjaGFuZ2UyKSB7XG4gICAgdmFyIHR3ZWVuID0gZ2V0VHdlZW4udHdlZW4sXG4gICAgICAgIG9uQ29tcGxldGUgPSB2YXJzLm9uQ29tcGxldGUsXG4gICAgICAgIG1vZGlmaWVycyA9IHt9O1xuICAgIGluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZSB8fCBnZXRTY3JvbGwoKTtcblxuICAgIHZhciBjaGVja0ZvckludGVycnVwdGlvbiA9IF9pbnRlcnJ1cHRpb25UcmFja2VyKGdldFNjcm9sbCwgaW5pdGlhbFZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0d2Vlbi5raWxsKCk7XG4gICAgICBnZXRUd2Vlbi50d2VlbiA9IDA7XG4gICAgfSk7XG5cbiAgICBjaGFuZ2UyID0gY2hhbmdlMSAmJiBjaGFuZ2UyIHx8IDA7IC8vIGlmIGNoYW5nZTEgaXMgMCwgd2Ugc2V0IHRoYXQgdG8gdGhlIGRpZmZlcmVuY2UgYW5kIGlnbm9yZSBjaGFuZ2UyLiBPdGhlcndpc2UsIHRoZXJlIHdvdWxkIGJlIGEgY29tcG91bmQgZWZmZWN0LlxuXG4gICAgY2hhbmdlMSA9IGNoYW5nZTEgfHwgc2Nyb2xsVG8gLSBpbml0aWFsVmFsdWU7XG4gICAgdHdlZW4gJiYgdHdlZW4ua2lsbCgpO1xuICAgIHZhcnNbcHJvcF0gPSBzY3JvbGxUbztcbiAgICB2YXJzLmluaGVyaXQgPSBmYWxzZTtcbiAgICB2YXJzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcblxuICAgIG1vZGlmaWVyc1twcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjaGVja0ZvckludGVycnVwdGlvbihpbml0aWFsVmFsdWUgKyBjaGFuZ2UxICogdHdlZW4ucmF0aW8gKyBjaGFuZ2UyICogdHdlZW4ucmF0aW8gKiB0d2Vlbi5yYXRpbyk7XG4gICAgfTtcblxuICAgIHZhcnMub25VcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfc2Nyb2xsZXJzLmNhY2hlKys7XG4gICAgICBnZXRUd2Vlbi50d2VlbiAmJiBfdXBkYXRlQWxsKCk7IC8vIGlmIGl0IHdhcyBpbnRlcnJ1cHRlZC9raWxsZWQsIGxpa2UgaW4gYSBjb250ZXh0LnJldmVydCgpLCBkb24ndCBmb3JjZSBhbiB1cGRhdGVBbGwoKVxuICAgIH07XG5cbiAgICB2YXJzLm9uQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBnZXRUd2Vlbi50d2VlbiA9IDA7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUuY2FsbCh0d2Vlbik7XG4gICAgfTtcblxuICAgIHR3ZWVuID0gZ2V0VHdlZW4udHdlZW4gPSBnc2FwLnRvKHNjcm9sbGVyLCB2YXJzKTtcbiAgICByZXR1cm4gdHdlZW47XG4gIH07XG5cbiAgc2Nyb2xsZXJbcHJvcF0gPSBnZXRTY3JvbGw7XG5cbiAgZ2V0U2Nyb2xsLndoZWVsSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0VHdlZW4udHdlZW4gJiYgZ2V0VHdlZW4udHdlZW4ua2lsbCgpICYmIChnZXRUd2Vlbi50d2VlbiA9IDApO1xuICB9O1xuXG4gIF9hZGRMaXN0ZW5lcihzY3JvbGxlciwgXCJ3aGVlbFwiLCBnZXRTY3JvbGwud2hlZWxIYW5kbGVyKTsgLy8gV2luZG93cyBtYWNoaW5lcyBoYW5kbGUgbW91c2V3aGVlbCBzY3JvbGxpbmcgaW4gY2h1bmtzIChsaWtlIFwiMyBsaW5lcyBwZXIgc2Nyb2xsXCIpIG1lYW5pbmcgdGhlIHR5cGljYWwgc3RyYXRlZ3kgZm9yIGNhbmNlbGxpbmcgdGhlIHNjcm9sbCBpc24ndCBhcyBzZW5zaXRpdmUuIEl0J3MgbXVjaCBtb3JlIGxpa2VseSB0byBtYXRjaCBvbmUgb2YgdGhlIHByZXZpb3VzIDIgc2Nyb2xsIGV2ZW50IHBvc2l0aW9ucy4gU28gd2Uga2lsbCBhbnkgc25hcHBpbmcgYXMgc29vbiBhcyB0aGVyZSdzIGEgd2hlZWwgZXZlbnQuXG5cblxuICBTY3JvbGxUcmlnZ2VyLmlzVG91Y2ggJiYgX2FkZExpc3RlbmVyKHNjcm9sbGVyLCBcInRvdWNobW92ZVwiLCBnZXRTY3JvbGwud2hlZWxIYW5kbGVyKTtcbiAgcmV0dXJuIGdldFR3ZWVuO1xufTtcblxuZXhwb3J0IHZhciBTY3JvbGxUcmlnZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2Nyb2xsVHJpZ2dlcih2YXJzLCBhbmltYXRpb24pIHtcbiAgICBfY29yZUluaXR0ZWQgfHwgU2Nyb2xsVHJpZ2dlci5yZWdpc3Rlcihnc2FwKSB8fCBjb25zb2xlLndhcm4oXCJQbGVhc2UgZ3NhcC5yZWdpc3RlclBsdWdpbihTY3JvbGxUcmlnZ2VyKVwiKTtcblxuICAgIF9jb250ZXh0KHRoaXMpO1xuXG4gICAgdGhpcy5pbml0KHZhcnMsIGFuaW1hdGlvbik7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2Nyb2xsVHJpZ2dlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KHZhcnMsIGFuaW1hdGlvbikge1xuICAgIHRoaXMucHJvZ3Jlc3MgPSB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLnZhcnMgJiYgdGhpcy5raWxsKHRydWUsIHRydWUpOyAvLyBpbiBjYXNlIGl0J3MgYmVpbmcgaW5pdHRlZCBhZ2FpblxuXG4gICAgaWYgKCFfZW5hYmxlZCkge1xuICAgICAgdGhpcy51cGRhdGUgPSB0aGlzLnJlZnJlc2ggPSB0aGlzLmtpbGwgPSBfcGFzc1Rocm91Z2g7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFycyA9IF9zZXREZWZhdWx0cyhfaXNTdHJpbmcodmFycykgfHwgX2lzTnVtYmVyKHZhcnMpIHx8IHZhcnMubm9kZVR5cGUgPyB7XG4gICAgICB0cmlnZ2VyOiB2YXJzXG4gICAgfSA6IHZhcnMsIF9kZWZhdWx0cyk7XG5cbiAgICB2YXIgX3ZhcnMgPSB2YXJzLFxuICAgICAgICBvblVwZGF0ZSA9IF92YXJzLm9uVXBkYXRlLFxuICAgICAgICB0b2dnbGVDbGFzcyA9IF92YXJzLnRvZ2dsZUNsYXNzLFxuICAgICAgICBpZCA9IF92YXJzLmlkLFxuICAgICAgICBvblRvZ2dsZSA9IF92YXJzLm9uVG9nZ2xlLFxuICAgICAgICBvblJlZnJlc2ggPSBfdmFycy5vblJlZnJlc2gsXG4gICAgICAgIHNjcnViID0gX3ZhcnMuc2NydWIsXG4gICAgICAgIHRyaWdnZXIgPSBfdmFycy50cmlnZ2VyLFxuICAgICAgICBwaW4gPSBfdmFycy5waW4sXG4gICAgICAgIHBpblNwYWNpbmcgPSBfdmFycy5waW5TcGFjaW5nLFxuICAgICAgICBpbnZhbGlkYXRlT25SZWZyZXNoID0gX3ZhcnMuaW52YWxpZGF0ZU9uUmVmcmVzaCxcbiAgICAgICAgYW50aWNpcGF0ZVBpbiA9IF92YXJzLmFudGljaXBhdGVQaW4sXG4gICAgICAgIG9uU2NydWJDb21wbGV0ZSA9IF92YXJzLm9uU2NydWJDb21wbGV0ZSxcbiAgICAgICAgb25TbmFwQ29tcGxldGUgPSBfdmFycy5vblNuYXBDb21wbGV0ZSxcbiAgICAgICAgb25jZSA9IF92YXJzLm9uY2UsXG4gICAgICAgIHNuYXAgPSBfdmFycy5zbmFwLFxuICAgICAgICBwaW5SZXBhcmVudCA9IF92YXJzLnBpblJlcGFyZW50LFxuICAgICAgICBwaW5TcGFjZXIgPSBfdmFycy5waW5TcGFjZXIsXG4gICAgICAgIGNvbnRhaW5lckFuaW1hdGlvbiA9IF92YXJzLmNvbnRhaW5lckFuaW1hdGlvbixcbiAgICAgICAgZmFzdFNjcm9sbEVuZCA9IF92YXJzLmZhc3RTY3JvbGxFbmQsXG4gICAgICAgIHByZXZlbnRPdmVybGFwcyA9IF92YXJzLnByZXZlbnRPdmVybGFwcyxcbiAgICAgICAgZGlyZWN0aW9uID0gdmFycy5ob3Jpem9udGFsIHx8IHZhcnMuY29udGFpbmVyQW5pbWF0aW9uICYmIHZhcnMuaG9yaXpvbnRhbCAhPT0gZmFsc2UgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCxcbiAgICAgICAgaXNUb2dnbGUgPSAhc2NydWIgJiYgc2NydWIgIT09IDAsXG4gICAgICAgIHNjcm9sbGVyID0gX2dldFRhcmdldCh2YXJzLnNjcm9sbGVyIHx8IF93aW4pLFxuICAgICAgICBzY3JvbGxlckNhY2hlID0gZ3NhcC5jb3JlLmdldENhY2hlKHNjcm9sbGVyKSxcbiAgICAgICAgaXNWaWV3cG9ydCA9IF9pc1ZpZXdwb3J0KHNjcm9sbGVyKSxcbiAgICAgICAgdXNlRml4ZWRQb3NpdGlvbiA9IChcInBpblR5cGVcIiBpbiB2YXJzID8gdmFycy5waW5UeXBlIDogX2dldFByb3h5UHJvcChzY3JvbGxlciwgXCJwaW5UeXBlXCIpIHx8IGlzVmlld3BvcnQgJiYgXCJmaXhlZFwiKSA9PT0gXCJmaXhlZFwiLFxuICAgICAgICBjYWxsYmFja3MgPSBbdmFycy5vbkVudGVyLCB2YXJzLm9uTGVhdmUsIHZhcnMub25FbnRlckJhY2ssIHZhcnMub25MZWF2ZUJhY2tdLFxuICAgICAgICB0b2dnbGVBY3Rpb25zID0gaXNUb2dnbGUgJiYgdmFycy50b2dnbGVBY3Rpb25zLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgbWFya2VycyA9IFwibWFya2Vyc1wiIGluIHZhcnMgPyB2YXJzLm1hcmtlcnMgOiBfZGVmYXVsdHMubWFya2VycyxcbiAgICAgICAgYm9yZGVyV2lkdGggPSBpc1ZpZXdwb3J0ID8gMCA6IHBhcnNlRmxvYXQoX2dldENvbXB1dGVkU3R5bGUoc2Nyb2xsZXIpW1wiYm9yZGVyXCIgKyBkaXJlY3Rpb24ucDIgKyBfV2lkdGhdKSB8fCAwLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgb25SZWZyZXNoSW5pdCA9IHZhcnMub25SZWZyZXNoSW5pdCAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdmFycy5vblJlZnJlc2hJbml0KHNlbGYpO1xuICAgIH0sXG4gICAgICAgIGdldFNjcm9sbGVyU2l6ZSA9IF9nZXRTaXplRnVuYyhzY3JvbGxlciwgaXNWaWV3cG9ydCwgZGlyZWN0aW9uKSxcbiAgICAgICAgZ2V0U2Nyb2xsZXJPZmZzZXRzID0gX2dldE9mZnNldHNGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0KSxcbiAgICAgICAgbGFzdFNuYXAgPSAwLFxuICAgICAgICBsYXN0UmVmcmVzaCA9IDAsXG4gICAgICAgIHByZXZQcm9ncmVzcyA9IDAsXG4gICAgICAgIHNjcm9sbEZ1bmMgPSBfZ2V0U2Nyb2xsRnVuYyhzY3JvbGxlciwgZGlyZWN0aW9uKSxcbiAgICAgICAgdHdlZW5UbyxcbiAgICAgICAgcGluQ2FjaGUsXG4gICAgICAgIHNuYXBGdW5jLFxuICAgICAgICBzY3JvbGwxLFxuICAgICAgICBzY3JvbGwyLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kLFxuICAgICAgICBtYXJrZXJTdGFydCxcbiAgICAgICAgbWFya2VyRW5kLFxuICAgICAgICBtYXJrZXJTdGFydFRyaWdnZXIsXG4gICAgICAgIG1hcmtlckVuZFRyaWdnZXIsXG4gICAgICAgIG1hcmtlclZhcnMsXG4gICAgICAgIGV4ZWN1dGluZ09uUmVmcmVzaCxcbiAgICAgICAgY2hhbmdlLFxuICAgICAgICBwaW5PcmlnaW5hbFN0YXRlLFxuICAgICAgICBwaW5BY3RpdmVTdGF0ZSxcbiAgICAgICAgcGluU3RhdGUsXG4gICAgICAgIHNwYWNlcixcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBwaW5HZXR0ZXIsXG4gICAgICAgIHBpblNldHRlcixcbiAgICAgICAgcGluU3RhcnQsXG4gICAgICAgIHBpbkNoYW5nZSxcbiAgICAgICAgc3BhY2luZ1N0YXJ0LFxuICAgICAgICBzcGFjZXJTdGF0ZSxcbiAgICAgICAgbWFya2VyU3RhcnRTZXR0ZXIsXG4gICAgICAgIHBpbk1vdmVzLFxuICAgICAgICBtYXJrZXJFbmRTZXR0ZXIsXG4gICAgICAgIGNzLFxuICAgICAgICBzbmFwMSxcbiAgICAgICAgc25hcDIsXG4gICAgICAgIHNjcnViVHdlZW4sXG4gICAgICAgIHNjcnViU21vb3RoLFxuICAgICAgICBzbmFwRHVyQ2xhbXAsXG4gICAgICAgIHNuYXBEZWxheWVkQ2FsbCxcbiAgICAgICAgcHJldlNjcm9sbCxcbiAgICAgICAgcHJldkFuaW1Qcm9ncmVzcyxcbiAgICAgICAgY2FNYXJrZXJTZXR0ZXIsXG4gICAgICAgIGN1c3RvbVJldmVydFJldHVybjsgLy8gZm9yIHRoZSBzYWtlIG9mIGVmZmljaWVuY3ksIF9zdGFydENsYW1wL19lbmRDbGFtcCBzZXJ2ZSBsaWtlIGEgdHJ1dGh5IHZhbHVlIGluZGljYXRpbmcgdGhhdCBjbGFtcGluZyB3YXMgZW5hYmxlZCBvbiB0aGUgc3RhcnQvZW5kLCBhbmQgQUxTTyBzdG9yZSB0aGUgYWN0dWFsIHByZS1jbGFtcGVkIG51bWVyaWMgdmFsdWUuIFdlIHRhcCBpbnRvIHRoYXQgaW4gU2Nyb2xsU21vb3RoZXIgZm9yIHNwZWVkIGVmZmVjdHMuIFNvIGZvciBleGFtcGxlLCBpZiBzdGFydD1cImNsYW1wKHRvcCBib3R0b20pXCIgcmVzdWx0cyBpbiBhIHN0YXJ0IG9mIC0xMDAgbmF0dXJhbGx5LCBpdCB3b3VsZCBnZXQgY2xhbXBlZCB0byAwIGJ1dCAtMTAwIHdvdWxkIGJlIHN0b3JlZCBpbiBfc3RhcnRDbGFtcC5cblxuXG4gICAgc2VsZi5fc3RhcnRDbGFtcCA9IHNlbGYuX2VuZENsYW1wID0gZmFsc2U7XG4gICAgc2VsZi5fZGlyID0gZGlyZWN0aW9uO1xuICAgIGFudGljaXBhdGVQaW4gKj0gNDU7XG4gICAgc2VsZi5zY3JvbGxlciA9IHNjcm9sbGVyO1xuICAgIHNlbGYuc2Nyb2xsID0gY29udGFpbmVyQW5pbWF0aW9uID8gY29udGFpbmVyQW5pbWF0aW9uLnRpbWUuYmluZChjb250YWluZXJBbmltYXRpb24pIDogc2Nyb2xsRnVuYztcbiAgICBzY3JvbGwxID0gc2Nyb2xsRnVuYygpO1xuICAgIHNlbGYudmFycyA9IHZhcnM7XG4gICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uIHx8IHZhcnMuYW5pbWF0aW9uO1xuXG4gICAgaWYgKFwicmVmcmVzaFByaW9yaXR5XCIgaW4gdmFycykge1xuICAgICAgX3NvcnQgPSAxO1xuICAgICAgdmFycy5yZWZyZXNoUHJpb3JpdHkgPT09IC05OTk5ICYmIChfcHJpbWFyeSA9IHNlbGYpOyAvLyB1c2VkIGJ5IFNjcm9sbFNtb290aGVyXG4gICAgfVxuXG4gICAgc2Nyb2xsZXJDYWNoZS50d2VlblNjcm9sbCA9IHNjcm9sbGVyQ2FjaGUudHdlZW5TY3JvbGwgfHwge1xuICAgICAgdG9wOiBfZ2V0VHdlZW5DcmVhdG9yKHNjcm9sbGVyLCBfdmVydGljYWwpLFxuICAgICAgbGVmdDogX2dldFR3ZWVuQ3JlYXRvcihzY3JvbGxlciwgX2hvcml6b250YWwpXG4gICAgfTtcbiAgICBzZWxmLnR3ZWVuVG8gPSB0d2VlblRvID0gc2Nyb2xsZXJDYWNoZS50d2VlblNjcm9sbFtkaXJlY3Rpb24ucF07XG5cbiAgICBzZWxmLnNjcnViRHVyYXRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHNjcnViU21vb3RoID0gX2lzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZTtcblxuICAgICAgaWYgKCFzY3J1YlNtb290aCkge1xuICAgICAgICBzY3J1YlR3ZWVuICYmIHNjcnViVHdlZW4ucHJvZ3Jlc3MoMSkua2lsbCgpO1xuICAgICAgICBzY3J1YlR3ZWVuID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcnViVHdlZW4gPyBzY3J1YlR3ZWVuLmR1cmF0aW9uKHZhbHVlKSA6IHNjcnViVHdlZW4gPSBnc2FwLnRvKGFuaW1hdGlvbiwge1xuICAgICAgICAgIGVhc2U6IFwiZXhwb1wiLFxuICAgICAgICAgIHRvdGFsUHJvZ3Jlc3M6IFwiKz0wXCIsXG4gICAgICAgICAgaW5oZXJpdDogZmFsc2UsXG4gICAgICAgICAgZHVyYXRpb246IHNjcnViU21vb3RoLFxuICAgICAgICAgIHBhdXNlZDogdHJ1ZSxcbiAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9uU2NydWJDb21wbGV0ZSAmJiBvblNjcnViQ29tcGxldGUoc2VsZik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgYW5pbWF0aW9uLnZhcnMubGF6eSA9IGZhbHNlO1xuICAgICAgYW5pbWF0aW9uLl9pbml0dGVkICYmICFzZWxmLmlzUmV2ZXJ0ZWQgfHwgYW5pbWF0aW9uLnZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZSAmJiB2YXJzLmltbWVkaWF0ZVJlbmRlciAhPT0gZmFsc2UgJiYgYW5pbWF0aW9uLmR1cmF0aW9uKCkgJiYgYW5pbWF0aW9uLnJlbmRlcigwLCB0cnVlLCB0cnVlKTsgLy8gc3BlY2lhbCBjYXNlOiBpZiB0aGlzIFNjcm9sbFRyaWdnZXIgZ2V0cyByZS1pbml0dGVkLCBhIGZyb20oKSB0d2VlbiB3aXRoIGEgc3RhZ2dlciBjb3VsZCBnZXQgaW5pdHRlZCBpbml0aWFsbHkgYW5kIHRoZW4gcmV2ZXJ0ZWQgb24gdGhlIHJlLWluaXQgd2hpY2ggbWVhbnMgaXQnbGwgbmVlZCB0byBnZXQgcmVuZGVyZWQgYWdhaW4gaGVyZSB0byBwcm9wZXJseSBkaXNwbGF5IHRoaW5ncy4gT3RoZXJ3aXNlLCBTZWUgaHR0cHM6Ly9nc2FwLmNvbS9mb3J1bXMvdG9waWMvMzY3Nzctc2Nyb2xsc21vb3RoZXItc3BsaXR0ZXh0LW5leHRqcy8gYW5kIGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuL2VZUHlQcGQ/ZWRpdG9ycz0wMDEwXG5cbiAgICAgIHNlbGYuYW5pbWF0aW9uID0gYW5pbWF0aW9uLnBhdXNlKCk7XG4gICAgICBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlciA9IHNlbGY7XG4gICAgICBzZWxmLnNjcnViRHVyYXRpb24oc2NydWIpO1xuICAgICAgc25hcDEgPSAwO1xuICAgICAgaWQgfHwgKGlkID0gYW5pbWF0aW9uLnZhcnMuaWQpO1xuICAgIH1cblxuICAgIGlmIChzbmFwKSB7XG4gICAgICAvLyBUT0RPOiBwb3RlbnRpYWwgaWRlYTogdXNlIGxlZ2l0aW1hdGUgQ1NTIHNjcm9sbCBzbmFwcGluZyBieSBwdXNoaW5nIGludmlzaWJsZSBlbGVtZW50cyBpbnRvIHRoZSBET00gdGhhdCBzZXJ2ZSBhcyBzbmFwIHBvc2l0aW9ucywgYW5kIHRvZ2dsZSB0aGUgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zdHlsZS5zY3JvbGxTbmFwVHlwZSBvblRvZ2dsZS4gU2VlIGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuL0pqTHJnV00gZm9yIGEgcXVpY2sgcHJvb2Ygb2YgY29uY2VwdC5cbiAgICAgIGlmICghX2lzT2JqZWN0KHNuYXApIHx8IHNuYXAucHVzaCkge1xuICAgICAgICBzbmFwID0ge1xuICAgICAgICAgIHNuYXBUbzogc25hcFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBcInNjcm9sbEJlaGF2aW9yXCIgaW4gX2JvZHkuc3R5bGUgJiYgZ3NhcC5zZXQoaXNWaWV3cG9ydCA/IFtfYm9keSwgX2RvY0VsXSA6IHNjcm9sbGVyLCB7XG4gICAgICAgIHNjcm9sbEJlaGF2aW9yOiBcImF1dG9cIlxuICAgICAgfSk7IC8vIHNtb290aCBzY3JvbGxpbmcgZG9lc24ndCB3b3JrIHdpdGggc25hcC5cblxuICAgICAgX3Njcm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBfaXNGdW5jdGlvbihvKSAmJiBvLnRhcmdldCA9PT0gKGlzVmlld3BvcnQgPyBfZG9jLnNjcm9sbGluZ0VsZW1lbnQgfHwgX2RvY0VsIDogc2Nyb2xsZXIpICYmIChvLnNtb290aCA9IGZhbHNlKTtcbiAgICAgIH0pOyAvLyBub3RlOiBzZXQgc21vb3RoIHRvIGZhbHNlIG9uIGJvdGggdGhlIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIHNjcm9sbCBnZXR0ZXJzL3NldHRlcnNcblxuXG4gICAgICBzbmFwRnVuYyA9IF9pc0Z1bmN0aW9uKHNuYXAuc25hcFRvKSA/IHNuYXAuc25hcFRvIDogc25hcC5zbmFwVG8gPT09IFwibGFiZWxzXCIgPyBfZ2V0Q2xvc2VzdExhYmVsKGFuaW1hdGlvbikgOiBzbmFwLnNuYXBUbyA9PT0gXCJsYWJlbHNEaXJlY3Rpb25hbFwiID8gX2dldExhYmVsQXREaXJlY3Rpb24oYW5pbWF0aW9uKSA6IHNuYXAuZGlyZWN0aW9uYWwgIT09IGZhbHNlID8gZnVuY3Rpb24gKHZhbHVlLCBzdCkge1xuICAgICAgICByZXR1cm4gX3NuYXBEaXJlY3Rpb25hbChzbmFwLnNuYXBUbykodmFsdWUsIF9nZXRUaW1lKCkgLSBsYXN0UmVmcmVzaCA8IDUwMCA/IDAgOiBzdC5kaXJlY3Rpb24pO1xuICAgICAgfSA6IGdzYXAudXRpbHMuc25hcChzbmFwLnNuYXBUbyk7XG4gICAgICBzbmFwRHVyQ2xhbXAgPSBzbmFwLmR1cmF0aW9uIHx8IHtcbiAgICAgICAgbWluOiAwLjEsXG4gICAgICAgIG1heDogMlxuICAgICAgfTtcbiAgICAgIHNuYXBEdXJDbGFtcCA9IF9pc09iamVjdChzbmFwRHVyQ2xhbXApID8gX2NsYW1wKHNuYXBEdXJDbGFtcC5taW4sIHNuYXBEdXJDbGFtcC5tYXgpIDogX2NsYW1wKHNuYXBEdXJDbGFtcCwgc25hcER1ckNsYW1wKTtcbiAgICAgIHNuYXBEZWxheWVkQ2FsbCA9IGdzYXAuZGVsYXllZENhbGwoc25hcC5kZWxheSB8fCBzY3J1YlNtb290aCAvIDIgfHwgMC4xLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY3JvbGwgPSBzY3JvbGxGdW5jKCksXG4gICAgICAgICAgICByZWZyZXNoZWRSZWNlbnRseSA9IF9nZXRUaW1lKCkgLSBsYXN0UmVmcmVzaCA8IDUwMCxcbiAgICAgICAgICAgIHR3ZWVuID0gdHdlZW5Uby50d2VlbjtcblxuICAgICAgICBpZiAoKHJlZnJlc2hlZFJlY2VudGx5IHx8IE1hdGguYWJzKHNlbGYuZ2V0VmVsb2NpdHkoKSkgPCAxMCkgJiYgIXR3ZWVuICYmICFfcG9pbnRlcklzRG93biAmJiBsYXN0U25hcCAhPT0gc2Nyb2xsKSB7XG4gICAgICAgICAgdmFyIHByb2dyZXNzID0gKHNjcm9sbCAtIHN0YXJ0KSAvIGNoYW5nZSxcbiAgICAgICAgICAgICAgdG90YWxQcm9ncmVzcyA9IGFuaW1hdGlvbiAmJiAhaXNUb2dnbGUgPyBhbmltYXRpb24udG90YWxQcm9ncmVzcygpIDogcHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHZlbG9jaXR5ID0gcmVmcmVzaGVkUmVjZW50bHkgPyAwIDogKHRvdGFsUHJvZ3Jlc3MgLSBzbmFwMikgLyAoX2dldFRpbWUoKSAtIF90aW1lMikgKiAxMDAwIHx8IDAsXG4gICAgICAgICAgICAgIGNoYW5nZTEgPSBnc2FwLnV0aWxzLmNsYW1wKC1wcm9ncmVzcywgMSAtIHByb2dyZXNzLCBfYWJzKHZlbG9jaXR5IC8gMikgKiB2ZWxvY2l0eSAvIDAuMTg1KSxcbiAgICAgICAgICAgICAgbmF0dXJhbEVuZCA9IHByb2dyZXNzICsgKHNuYXAuaW5lcnRpYSA9PT0gZmFsc2UgPyAwIDogY2hhbmdlMSksXG4gICAgICAgICAgICAgIGVuZFZhbHVlLFxuICAgICAgICAgICAgICBlbmRTY3JvbGwsXG4gICAgICAgICAgICAgIF9zbmFwID0gc25hcCxcbiAgICAgICAgICAgICAgb25TdGFydCA9IF9zbmFwLm9uU3RhcnQsXG4gICAgICAgICAgICAgIF9vbkludGVycnVwdCA9IF9zbmFwLm9uSW50ZXJydXB0LFxuICAgICAgICAgICAgICBfb25Db21wbGV0ZSA9IF9zbmFwLm9uQ29tcGxldGU7XG4gICAgICAgICAgZW5kVmFsdWUgPSBzbmFwRnVuYyhuYXR1cmFsRW5kLCBzZWxmKTtcbiAgICAgICAgICBfaXNOdW1iZXIoZW5kVmFsdWUpIHx8IChlbmRWYWx1ZSA9IG5hdHVyYWxFbmQpOyAvLyBpbiBjYXNlIHRoZSBmdW5jdGlvbiBkaWRuJ3QgcmV0dXJuIGEgbnVtYmVyLCBmYWxsIGJhY2sgdG8gdXNpbmcgdGhlIG5hdHVyYWxFbmRcblxuICAgICAgICAgIGVuZFNjcm9sbCA9IE1hdGgucm91bmQoc3RhcnQgKyBlbmRWYWx1ZSAqIGNoYW5nZSk7XG5cbiAgICAgICAgICBpZiAoc2Nyb2xsIDw9IGVuZCAmJiBzY3JvbGwgPj0gc3RhcnQgJiYgZW5kU2Nyb2xsICE9PSBzY3JvbGwpIHtcbiAgICAgICAgICAgIGlmICh0d2VlbiAmJiAhdHdlZW4uX2luaXR0ZWQgJiYgdHdlZW4uZGF0YSA8PSBfYWJzKGVuZFNjcm9sbCAtIHNjcm9sbCkpIHtcbiAgICAgICAgICAgICAgLy8gdGhlcmUncyBhbiBvdmVybGFwcGluZyBzbmFwISBTbyB3ZSBtdXN0IGZpZ3VyZSBvdXQgd2hpY2ggb25lIGlzIGNsb3NlciBhbmQgbGV0IHRoYXQgdHdlZW4gbGl2ZS5cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc25hcC5pbmVydGlhID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBjaGFuZ2UxID0gZW5kVmFsdWUgLSBwcm9ncmVzcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHdlZW5UbyhlbmRTY3JvbGwsIHtcbiAgICAgICAgICAgICAgZHVyYXRpb246IHNuYXBEdXJDbGFtcChfYWJzKE1hdGgubWF4KF9hYnMobmF0dXJhbEVuZCAtIHRvdGFsUHJvZ3Jlc3MpLCBfYWJzKGVuZFZhbHVlIC0gdG90YWxQcm9ncmVzcykpICogMC4xODUgLyB2ZWxvY2l0eSAvIDAuMDUgfHwgMCkpLFxuICAgICAgICAgICAgICBlYXNlOiBzbmFwLmVhc2UgfHwgXCJwb3dlcjNcIixcbiAgICAgICAgICAgICAgZGF0YTogX2FicyhlbmRTY3JvbGwgLSBzY3JvbGwpLFxuICAgICAgICAgICAgICAvLyByZWNvcmQgdGhlIGRpc3RhbmNlIHNvIHRoYXQgaWYgYW5vdGhlciBzbmFwIHR3ZWVuIG9jY3VycyAoY29uZmxpY3QpIHdlIGNhbiBwcmlvcml0aXplIHRoZSBjbG9zZXN0IHNuYXAuXG4gICAgICAgICAgICAgIG9uSW50ZXJydXB0OiBmdW5jdGlvbiBvbkludGVycnVwdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc25hcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSkgJiYgX29uSW50ZXJydXB0ICYmIF9vbkludGVycnVwdChzZWxmKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIGxhc3RTbmFwID0gc2Nyb2xsRnVuYygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlc29sdXRpb24gb2YgdGhlIHNjcm9sbGJhciBpcyBsaW1pdGVkLCBzbyB3ZSBzaG91bGQgY29ycmVjdCB0aGUgc2NydWJiZWQgYW5pbWF0aW9uJ3MgcGxheWhlYWQgYXQgdGhlIGVuZCB0byBtYXRjaCBFWEFDVExZIHdoZXJlIGl0IHdhcyBzdXBwb3NlZCB0byBzbmFwXG4gICAgICAgICAgICAgICAgICBzY3J1YlR3ZWVuID8gc2NydWJUd2Vlbi5yZXNldFRvKFwidG90YWxQcm9ncmVzc1wiLCBlbmRWYWx1ZSwgYW5pbWF0aW9uLl90VGltZSAvIGFuaW1hdGlvbi5fdER1cikgOiBhbmltYXRpb24ucHJvZ3Jlc3MoZW5kVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNuYXAxID0gc25hcDIgPSBhbmltYXRpb24gJiYgIWlzVG9nZ2xlID8gYW5pbWF0aW9uLnRvdGFsUHJvZ3Jlc3MoKSA6IHNlbGYucHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgb25TbmFwQ29tcGxldGUgJiYgb25TbmFwQ29tcGxldGUoc2VsZik7XG4gICAgICAgICAgICAgICAgX29uQ29tcGxldGUgJiYgX29uQ29tcGxldGUoc2VsZik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHNjcm9sbCwgY2hhbmdlMSAqIGNoYW5nZSwgZW5kU2Nyb2xsIC0gc2Nyb2xsIC0gY2hhbmdlMSAqIGNoYW5nZSk7XG4gICAgICAgICAgICBvblN0YXJ0ICYmIG9uU3RhcnQoc2VsZiwgdHdlZW5Uby50d2Vlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNlbGYuaXNBY3RpdmUgJiYgbGFzdFNuYXAgIT09IHNjcm9sbCkge1xuICAgICAgICAgIHNuYXBEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KS5wYXVzZSgpO1xuICAgIH1cblxuICAgIGlkICYmIChfaWRzW2lkXSA9IHNlbGYpO1xuICAgIHRyaWdnZXIgPSBzZWxmLnRyaWdnZXIgPSBfZ2V0VGFyZ2V0KHRyaWdnZXIgfHwgcGluICE9PSB0cnVlICYmIHBpbik7IC8vIGlmIGEgdHJpZ2dlciBoYXMgc29tZSBraW5kIG9mIHNjcm9sbC1yZWxhdGVkIGVmZmVjdCBhcHBsaWVkIHRoYXQgY291bGQgY29udGFtaW5hdGUgdGhlIFwieVwiIG9yIFwieFwiIHBvc2l0aW9uIChsaWtlIGEgU2Nyb2xsU21vb3RoZXIgZWZmZWN0KSwgd2UgbmVlZGVkIGEgd2F5IHRvIHRlbXBvcmFyaWx5IHJldmVydCBpdCwgc28gd2UgdXNlIHRoZSBzdFJldmVydCBwcm9wZXJ0eSBvZiB0aGUgZ3NDYWNoZS4gSXQgY2FuIHJldHVybiBhbm90aGVyIGZ1bmN0aW9uIHRoYXQgd2UnbGwgY2FsbCBhdCB0aGUgZW5kIHNvIGl0IGNhbiByZXR1cm4gdG8gaXRzIG5vcm1hbCBzdGF0ZS5cblxuICAgIGN1c3RvbVJldmVydFJldHVybiA9IHRyaWdnZXIgJiYgdHJpZ2dlci5fZ3NhcCAmJiB0cmlnZ2VyLl9nc2FwLnN0UmV2ZXJ0O1xuICAgIGN1c3RvbVJldmVydFJldHVybiAmJiAoY3VzdG9tUmV2ZXJ0UmV0dXJuID0gY3VzdG9tUmV2ZXJ0UmV0dXJuKHNlbGYpKTtcbiAgICBwaW4gPSBwaW4gPT09IHRydWUgPyB0cmlnZ2VyIDogX2dldFRhcmdldChwaW4pO1xuICAgIF9pc1N0cmluZyh0b2dnbGVDbGFzcykgJiYgKHRvZ2dsZUNsYXNzID0ge1xuICAgICAgdGFyZ2V0czogdHJpZ2dlcixcbiAgICAgIGNsYXNzTmFtZTogdG9nZ2xlQ2xhc3NcbiAgICB9KTtcblxuICAgIGlmIChwaW4pIHtcbiAgICAgIHBpblNwYWNpbmcgPT09IGZhbHNlIHx8IHBpblNwYWNpbmcgPT09IF9tYXJnaW4gfHwgKHBpblNwYWNpbmcgPSAhcGluU3BhY2luZyAmJiBwaW4ucGFyZW50Tm9kZSAmJiBwaW4ucGFyZW50Tm9kZS5zdHlsZSAmJiBfZ2V0Q29tcHV0ZWRTdHlsZShwaW4ucGFyZW50Tm9kZSkuZGlzcGxheSA9PT0gXCJmbGV4XCIgPyBmYWxzZSA6IF9wYWRkaW5nKTsgLy8gaWYgdGhlIHBhcmVudCBpcyBkaXNwbGF5OiBmbGV4LCBkb24ndCBhcHBseSBwaW5TcGFjaW5nIGJ5IGRlZmF1bHQuIFdlIHNob3VsZCBjaGVjayB0aGF0IHBpbi5wYXJlbnROb2RlIGlzIGFuIGVsZW1lbnQgKG5vdCBzaGFkb3cgZG9tIHdpbmRvdylcblxuICAgICAgc2VsZi5waW4gPSBwaW47XG4gICAgICBwaW5DYWNoZSA9IGdzYXAuY29yZS5nZXRDYWNoZShwaW4pO1xuXG4gICAgICBpZiAoIXBpbkNhY2hlLnNwYWNlcikge1xuICAgICAgICAvLyByZWNvcmQgdGhlIHNwYWNlciBhbmQgcGluT3JpZ2luYWxTdGF0ZSBvbiB0aGUgY2FjaGUgaW4gY2FzZSBzb21lb25lIHRyaWVzIHBpbm5pbmcgdGhlIHNhbWUgZWxlbWVudCB3aXRoIE1VTFRJUExFIFNjcm9sbFRyaWdnZXJzIC0gd2UgZG9uJ3Qgd2FudCB0byBoYXZlIG11bHRpcGxlIHNwYWNlcnMgb3IgcmVjb3JkIHRoZSBcIm9yaWdpbmFsXCIgcGluIHN0YXRlIGFmdGVyIGl0IGhhcyBhbHJlYWR5IGJlZW4gYWZmZWN0ZWQgYnkgYW5vdGhlciBTY3JvbGxUcmlnZ2VyLlxuICAgICAgICBpZiAocGluU3BhY2VyKSB7XG4gICAgICAgICAgcGluU3BhY2VyID0gX2dldFRhcmdldChwaW5TcGFjZXIpO1xuICAgICAgICAgIHBpblNwYWNlciAmJiAhcGluU3BhY2VyLm5vZGVUeXBlICYmIChwaW5TcGFjZXIgPSBwaW5TcGFjZXIuY3VycmVudCB8fCBwaW5TcGFjZXIubmF0aXZlRWxlbWVudCk7IC8vIGZvciBSZWFjdCAmIEFuZ3VsYXJcblxuICAgICAgICAgIHBpbkNhY2hlLnNwYWNlcklzTmF0aXZlID0gISFwaW5TcGFjZXI7XG4gICAgICAgICAgcGluU3BhY2VyICYmIChwaW5DYWNoZS5zcGFjZXJTdGF0ZSA9IF9nZXRTdGF0ZShwaW5TcGFjZXIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBpbkNhY2hlLnNwYWNlciA9IHNwYWNlciA9IHBpblNwYWNlciB8fCBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHNwYWNlci5jbGFzc0xpc3QuYWRkKFwicGluLXNwYWNlclwiKTtcbiAgICAgICAgaWQgJiYgc3BhY2VyLmNsYXNzTGlzdC5hZGQoXCJwaW4tc3BhY2VyLVwiICsgaWQpO1xuICAgICAgICBwaW5DYWNoZS5waW5TdGF0ZSA9IHBpbk9yaWdpbmFsU3RhdGUgPSBfZ2V0U3RhdGUocGluKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBpbk9yaWdpbmFsU3RhdGUgPSBwaW5DYWNoZS5waW5TdGF0ZTtcbiAgICAgIH1cblxuICAgICAgdmFycy5mb3JjZTNEICE9PSBmYWxzZSAmJiBnc2FwLnNldChwaW4sIHtcbiAgICAgICAgZm9yY2UzRDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBzZWxmLnNwYWNlciA9IHNwYWNlciA9IHBpbkNhY2hlLnNwYWNlcjtcbiAgICAgIGNzID0gX2dldENvbXB1dGVkU3R5bGUocGluKTtcbiAgICAgIHNwYWNpbmdTdGFydCA9IGNzW3BpblNwYWNpbmcgKyBkaXJlY3Rpb24ub3MyXTtcbiAgICAgIHBpbkdldHRlciA9IGdzYXAuZ2V0UHJvcGVydHkocGluKTtcbiAgICAgIHBpblNldHRlciA9IGdzYXAucXVpY2tTZXR0ZXIocGluLCBkaXJlY3Rpb24uYSwgX3B4KTsgLy8gcGluLmZpcnN0Q2hpbGQgJiYgIV9tYXhTY3JvbGwocGluLCBkaXJlY3Rpb24pICYmIChwaW4uc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiKTsgLy8gcHJvdGVjdHMgZnJvbSBjb2xsYXBzaW5nIG1hcmdpbnMsIGJ1dCBjYW4gaGF2ZSB1bmludGVuZGVkIGNvbnNlcXVlbmNlcyBhcyBkZW1vbnN0cmF0ZWQgaGVyZTogaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vMWU0MmM3YTczYmZhNDA5ZDJjZjFlMTg0ZTdhNDI0OGQgc28gaXQgd2FzIHJlbW92ZWQgaW4gZmF2b3Igb2YganVzdCB0ZWxsaW5nIHBlb3BsZSB0byBzZXQgdXAgdGhlaXIgQ1NTIHRvIGF2b2lkIHRoZSBjb2xsYXBzaW5nIG1hcmdpbnMgKG92ZXJmbG93OiBoaWRkZW4gfCBhdXRvIGlzIGp1c3Qgb25lIG9wdGlvbi4gQW5vdGhlciBpcyBib3JkZXItdG9wOiAxcHggc29saWQgdHJhbnNwYXJlbnQpLlxuXG4gICAgICBfc3dhcFBpbkluKHBpbiwgc3BhY2VyLCBjcyk7XG5cbiAgICAgIHBpblN0YXRlID0gX2dldFN0YXRlKHBpbik7XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlcnMpIHtcbiAgICAgIG1hcmtlclZhcnMgPSBfaXNPYmplY3QobWFya2VycykgPyBfc2V0RGVmYXVsdHMobWFya2VycywgX21hcmtlckRlZmF1bHRzKSA6IF9tYXJrZXJEZWZhdWx0cztcbiAgICAgIG1hcmtlclN0YXJ0VHJpZ2dlciA9IF9jcmVhdGVNYXJrZXIoXCJzY3JvbGxlci1zdGFydFwiLCBpZCwgc2Nyb2xsZXIsIGRpcmVjdGlvbiwgbWFya2VyVmFycywgMCk7XG4gICAgICBtYXJrZXJFbmRUcmlnZ2VyID0gX2NyZWF0ZU1hcmtlcihcInNjcm9sbGVyLWVuZFwiLCBpZCwgc2Nyb2xsZXIsIGRpcmVjdGlvbiwgbWFya2VyVmFycywgMCwgbWFya2VyU3RhcnRUcmlnZ2VyKTtcbiAgICAgIG9mZnNldCA9IG1hcmtlclN0YXJ0VHJpZ2dlcltcIm9mZnNldFwiICsgZGlyZWN0aW9uLm9wLmQyXTtcblxuICAgICAgdmFyIGNvbnRlbnQgPSBfZ2V0VGFyZ2V0KF9nZXRQcm94eVByb3Aoc2Nyb2xsZXIsIFwiY29udGVudFwiKSB8fCBzY3JvbGxlcik7XG5cbiAgICAgIG1hcmtlclN0YXJ0ID0gdGhpcy5tYXJrZXJTdGFydCA9IF9jcmVhdGVNYXJrZXIoXCJzdGFydFwiLCBpZCwgY29udGVudCwgZGlyZWN0aW9uLCBtYXJrZXJWYXJzLCBvZmZzZXQsIDAsIGNvbnRhaW5lckFuaW1hdGlvbik7XG4gICAgICBtYXJrZXJFbmQgPSB0aGlzLm1hcmtlckVuZCA9IF9jcmVhdGVNYXJrZXIoXCJlbmRcIiwgaWQsIGNvbnRlbnQsIGRpcmVjdGlvbiwgbWFya2VyVmFycywgb2Zmc2V0LCAwLCBjb250YWluZXJBbmltYXRpb24pO1xuICAgICAgY29udGFpbmVyQW5pbWF0aW9uICYmIChjYU1hcmtlclNldHRlciA9IGdzYXAucXVpY2tTZXR0ZXIoW21hcmtlclN0YXJ0LCBtYXJrZXJFbmRdLCBkaXJlY3Rpb24uYSwgX3B4KSk7XG5cbiAgICAgIGlmICghdXNlRml4ZWRQb3NpdGlvbiAmJiAhKF9wcm94aWVzLmxlbmd0aCAmJiBfZ2V0UHJveHlQcm9wKHNjcm9sbGVyLCBcImZpeGVkTWFya2Vyc1wiKSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgX21ha2VQb3NpdGlvbmFibGUoaXNWaWV3cG9ydCA/IF9ib2R5IDogc2Nyb2xsZXIpO1xuXG4gICAgICAgIGdzYXAuc2V0KFttYXJrZXJTdGFydFRyaWdnZXIsIG1hcmtlckVuZFRyaWdnZXJdLCB7XG4gICAgICAgICAgZm9yY2UzRDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgbWFya2VyU3RhcnRTZXR0ZXIgPSBnc2FwLnF1aWNrU2V0dGVyKG1hcmtlclN0YXJ0VHJpZ2dlciwgZGlyZWN0aW9uLmEsIF9weCk7XG4gICAgICAgIG1hcmtlckVuZFNldHRlciA9IGdzYXAucXVpY2tTZXR0ZXIobWFya2VyRW5kVHJpZ2dlciwgZGlyZWN0aW9uLmEsIF9weCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5lckFuaW1hdGlvbikge1xuICAgICAgdmFyIG9sZE9uVXBkYXRlID0gY29udGFpbmVyQW5pbWF0aW9uLnZhcnMub25VcGRhdGUsXG4gICAgICAgICAgb2xkUGFyYW1zID0gY29udGFpbmVyQW5pbWF0aW9uLnZhcnMub25VcGRhdGVQYXJhbXM7XG4gICAgICBjb250YWluZXJBbmltYXRpb24uZXZlbnRDYWxsYmFjayhcIm9uVXBkYXRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi51cGRhdGUoMCwgMCwgMSk7XG4gICAgICAgIG9sZE9uVXBkYXRlICYmIG9sZE9uVXBkYXRlLmFwcGx5KGNvbnRhaW5lckFuaW1hdGlvbiwgb2xkUGFyYW1zIHx8IFtdKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNlbGYucHJldmlvdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RyaWdnZXJzW190cmlnZ2Vycy5pbmRleE9mKHNlbGYpIC0gMV07XG4gICAgfTtcblxuICAgIHNlbGYubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdHJpZ2dlcnNbX3RyaWdnZXJzLmluZGV4T2Yoc2VsZikgKyAxXTtcbiAgICB9O1xuXG4gICAgc2VsZi5yZXZlcnQgPSBmdW5jdGlvbiAocmV2ZXJ0LCB0ZW1wKSB7XG4gICAgICBpZiAoIXRlbXApIHtcbiAgICAgICAgcmV0dXJuIHNlbGYua2lsbCh0cnVlKTtcbiAgICAgIH0gLy8gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBnc2FwLmNvbnRleHQoKSBhbmQgZ3NhcC5tYXRjaE1lZGlhKCkgd2hpY2ggY2FsbCByZXZlcnQoKVxuXG5cbiAgICAgIHZhciByID0gcmV2ZXJ0ICE9PSBmYWxzZSB8fCAhc2VsZi5lbmFibGVkLFxuICAgICAgICAgIHByZXZSZWZyZXNoaW5nID0gX3JlZnJlc2hpbmc7XG5cbiAgICAgIGlmIChyICE9PSBzZWxmLmlzUmV2ZXJ0ZWQpIHtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICBwcmV2U2Nyb2xsID0gTWF0aC5tYXgoc2Nyb2xsRnVuYygpLCBzZWxmLnNjcm9sbC5yZWMgfHwgMCk7IC8vIHJlY29yZCB0aGUgc2Nyb2xsIHNvIHdlIGNhbiByZXZlcnQgbGF0ZXIgKHJlcG9zaXRpb25pbmcvcGlubmluZyB0aGluZ3MgY2FuIGFmZmVjdCBzY3JvbGwgcG9zaXRpb24pLiBJbiB0aGUgc3RhdGljIHJlZnJlc2goKSBtZXRob2QsIHdlIGZpcnN0IHJlY29yZCBhbGwgdGhlIHNjcm9sbCBwb3NpdGlvbnMgYXMgYSByZWZlcmVuY2UuXG5cbiAgICAgICAgICBwcmV2UHJvZ3Jlc3MgPSBzZWxmLnByb2dyZXNzO1xuICAgICAgICAgIHByZXZBbmltUHJvZ3Jlc3MgPSBhbmltYXRpb24gJiYgYW5pbWF0aW9uLnByb2dyZXNzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXJrZXJTdGFydCAmJiBbbWFya2VyU3RhcnQsIG1hcmtlckVuZCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG0uc3R5bGUuZGlzcGxheSA9IHIgPyBcIm5vbmVcIiA6IFwiYmxvY2tcIjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICBfcmVmcmVzaGluZyA9IHNlbGY7XG4gICAgICAgICAgc2VsZi51cGRhdGUocik7IC8vIG1ha2Ugc3VyZSB0aGUgcGluIGlzIGJhY2sgaW4gaXRzIG9yaWdpbmFsIHBvc2l0aW9uIHNvIHRoYXQgYWxsIHRoZSBtZWFzdXJlbWVudHMgYXJlIGNvcnJlY3QuIGRvIHRoaXMgQkVGT1JFIHN3YXBwaW5nIHRoZSBwaW4gb3V0XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGluICYmICghcGluUmVwYXJlbnQgfHwgIXNlbGYuaXNBY3RpdmUpKSB7XG4gICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIF9zd2FwUGluT3V0KHBpbiwgc3BhY2VyLCBwaW5PcmlnaW5hbFN0YXRlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3N3YXBQaW5JbihwaW4sIHNwYWNlciwgX2dldENvbXB1dGVkU3R5bGUocGluKSwgc3BhY2VyU3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHIgfHwgc2VsZi51cGRhdGUocik7IC8vIHdoZW4gd2UncmUgcmVzdG9yaW5nLCB0aGUgdXBkYXRlIHNob3VsZCBydW4gQUZURVIgc3dhcHBpbmcgdGhlIHBpbiBpbnRvIGl0cyBwaW4tc3BhY2VyLlxuXG4gICAgICAgIF9yZWZyZXNoaW5nID0gcHJldlJlZnJlc2hpbmc7IC8vIHJlc3RvcmUuIFdlIHNldCBpdCB0byB0cnVlIGR1cmluZyB0aGUgdXBkYXRlKCkgc28gdGhhdCB0aGluZ3MgZmlyZSBwcm9wZXJseSBpbiB0aGVyZS5cblxuICAgICAgICBzZWxmLmlzUmV2ZXJ0ZWQgPSByO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLnJlZnJlc2ggPSBmdW5jdGlvbiAoc29mdCwgZm9yY2UsIHBvc2l0aW9uLCBwaW5PZmZzZXQpIHtcbiAgICAgIC8vIHBvc2l0aW9uIGlzIHR5cGljYWxseSBvbmx5IGRlZmluZWQgaWYgaXQncyBjb21pbmcgZnJvbSBzZXRQb3NpdGlvbnMoKSAtIGl0J3MgYSB3YXkgdG8gc2tpcCB0aGUgbm9ybWFsIHBhcnNpbmcuIHBpbk9mZnNldCBpcyBhbHNvIG9ubHkgZnJvbSBzZXRQb3NpdGlvbnMoKSBhbmQgaXMgbW9zdGx5IHJlbGF0ZWQgdG8gZmFuY3kgc3R1ZmYgd2UgbmVlZCB0byBkbyBpbiBTY3JvbGxTbW9vdGhlciB3aXRoIGVmZmVjdHNcbiAgICAgIGlmICgoX3JlZnJlc2hpbmcgfHwgIXNlbGYuZW5hYmxlZCkgJiYgIWZvcmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBpbiAmJiBzb2Z0ICYmIF9sYXN0U2Nyb2xsVGltZSkge1xuICAgICAgICBfYWRkTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJzY3JvbGxFbmRcIiwgX3NvZnRSZWZyZXNoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgICFfcmVmcmVzaGluZ0FsbCAmJiBvblJlZnJlc2hJbml0ICYmIG9uUmVmcmVzaEluaXQoc2VsZik7XG4gICAgICBfcmVmcmVzaGluZyA9IHNlbGY7XG5cbiAgICAgIGlmICh0d2VlblRvLnR3ZWVuICYmICFwb3NpdGlvbikge1xuICAgICAgICAvLyB3ZSBza2lwIHRoaXMgaWYgYSBwb3NpdGlvbiBpcyBwYXNzZWQgaW4gYmVjYXVzZSB0eXBpY2FsbHkgdGhhdCdzIGZyb20gLnNldFBvc2l0aW9ucygpIGFuZCBpdCdzIGJlc3QgdG8gYWxsb3cgaW4tcHJvZ3Jlc3Mgc25hcHBpbmcgdG8gY29udGludWUuXG4gICAgICAgIHR3ZWVuVG8udHdlZW4ua2lsbCgpO1xuICAgICAgICB0d2VlblRvLnR3ZWVuID0gMDtcbiAgICAgIH1cblxuICAgICAgc2NydWJUd2VlbiAmJiBzY3J1YlR3ZWVuLnBhdXNlKCk7XG4gICAgICBpbnZhbGlkYXRlT25SZWZyZXNoICYmIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucmV2ZXJ0KHtcbiAgICAgICAga2lsbDogZmFsc2VcbiAgICAgIH0pLmludmFsaWRhdGUoKTtcbiAgICAgIHNlbGYuaXNSZXZlcnRlZCB8fCBzZWxmLnJldmVydCh0cnVlLCB0cnVlKTtcbiAgICAgIHNlbGYuX3N1YlBpbk9mZnNldCA9IGZhbHNlOyAvLyB3ZSdsbCBzZXQgdGhpcyB0byB0cnVlIGluIHRoZSBzdWItcGlucyBpZiB3ZSBmaW5kIGFueVxuXG4gICAgICB2YXIgc2l6ZSA9IGdldFNjcm9sbGVyU2l6ZSgpLFxuICAgICAgICAgIHNjcm9sbGVyQm91bmRzID0gZ2V0U2Nyb2xsZXJPZmZzZXRzKCksXG4gICAgICAgICAgbWF4ID0gY29udGFpbmVyQW5pbWF0aW9uID8gY29udGFpbmVyQW5pbWF0aW9uLmR1cmF0aW9uKCkgOiBfbWF4U2Nyb2xsKHNjcm9sbGVyLCBkaXJlY3Rpb24pLFxuICAgICAgICAgIGlzRmlyc3RSZWZyZXNoID0gY2hhbmdlIDw9IDAuMDEsXG4gICAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgICBvdGhlclBpbk9mZnNldCA9IHBpbk9mZnNldCB8fCAwLFxuICAgICAgICAgIHBhcnNlZEVuZCA9IF9pc09iamVjdChwb3NpdGlvbikgPyBwb3NpdGlvbi5lbmQgOiB2YXJzLmVuZCxcbiAgICAgICAgICBwYXJzZWRFbmRUcmlnZ2VyID0gdmFycy5lbmRUcmlnZ2VyIHx8IHRyaWdnZXIsXG4gICAgICAgICAgcGFyc2VkU3RhcnQgPSBfaXNPYmplY3QocG9zaXRpb24pID8gcG9zaXRpb24uc3RhcnQgOiB2YXJzLnN0YXJ0IHx8ICh2YXJzLnN0YXJ0ID09PSAwIHx8ICF0cmlnZ2VyID8gMCA6IHBpbiA/IFwiMCAwXCIgOiBcIjAgMTAwJVwiKSxcbiAgICAgICAgICBwaW5uZWRDb250YWluZXIgPSBzZWxmLnBpbm5lZENvbnRhaW5lciA9IHZhcnMucGlubmVkQ29udGFpbmVyICYmIF9nZXRUYXJnZXQodmFycy5waW5uZWRDb250YWluZXIsIHNlbGYpLFxuICAgICAgICAgIHRyaWdnZXJJbmRleCA9IHRyaWdnZXIgJiYgTWF0aC5tYXgoMCwgX3RyaWdnZXJzLmluZGV4T2Yoc2VsZikpIHx8IDAsXG4gICAgICAgICAgaSA9IHRyaWdnZXJJbmRleCxcbiAgICAgICAgICBjcyxcbiAgICAgICAgICBib3VuZHMsXG4gICAgICAgICAgc2Nyb2xsLFxuICAgICAgICAgIGlzVmVydGljYWwsXG4gICAgICAgICAgb3ZlcnJpZGUsXG4gICAgICAgICAgY3VyVHJpZ2dlcixcbiAgICAgICAgICBjdXJQaW4sXG4gICAgICAgICAgb3Bwb3NpdGVTY3JvbGwsXG4gICAgICAgICAgaW5pdHRlZCxcbiAgICAgICAgICByZXZlcnRlZFBpbnMsXG4gICAgICAgICAgZm9yY2VkT3ZlcmZsb3csXG4gICAgICAgICAgbWFya2VyU3RhcnRPZmZzZXQsXG4gICAgICAgICAgbWFya2VyRW5kT2Zmc2V0O1xuXG4gICAgICBpZiAobWFya2VycyAmJiBfaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIC8vIGlmIHdlIGFsdGVyIHRoZSBzdGFydC9lbmQgcG9zaXRpb25zIHdpdGggLnNldFBvc2l0aW9ucygpLCBpdCBnZW5lcmFsbHkgZmVlZHMgaW4gYWJzb2x1dGUgTlVNQkVSUyB3aGljaCBkb24ndCBjb252ZXkgaW5mb3JtYXRpb24gYWJvdXQgd2hlcmUgdG8gbGluZSB1cCB0aGUgbWFya2Vycywgc28gdG8ga2VlcCBpdCBpbnR1aXRpdmUsIHdlIHJlY29yZCBob3cgZmFyIHRoZSB0cmlnZ2VyIHBvc2l0aW9ucyBzaGlmdCBhZnRlciBhcHBseWluZyB0aGUgbmV3IG51bWJlcnMgYW5kIHRoZW4gb2Zmc2V0IGJ5IHRoYXQgbXVjaCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLiBXZSBkbyB0aGUgc2FtZSB0byB0aGUgYXNzb2NpYXRlZCB0cmlnZ2VyIG1hcmtlcnMgdG9vIG9mIGNvdXJzZS5cbiAgICAgICAgbWFya2VyU3RhcnRPZmZzZXQgPSBnc2FwLmdldFByb3BlcnR5KG1hcmtlclN0YXJ0VHJpZ2dlciwgZGlyZWN0aW9uLnApO1xuICAgICAgICBtYXJrZXJFbmRPZmZzZXQgPSBnc2FwLmdldFByb3BlcnR5KG1hcmtlckVuZFRyaWdnZXIsIGRpcmVjdGlvbi5wKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAvLyB1c2VyIG1pZ2h0IHRyeSB0byBwaW4gdGhlIHNhbWUgZWxlbWVudCBtb3JlIHRoYW4gb25jZSwgc28gd2UgbXVzdCBmaW5kIGFueSBwcmlvciB0cmlnZ2VycyB3aXRoIHRoZSBzYW1lIHBpbiwgcmV2ZXJ0IHRoZW0sIGFuZCBkZXRlcm1pbmUgaG93IGxvbmcgdGhleSdyZSBwaW5uaW5nIHNvIHRoYXQgd2UgY2FuIG9mZnNldCB0aGluZ3MgYXBwcm9wcmlhdGVseS4gTWFrZSBzdXJlIHdlIHJldmVydCBmcm9tIGxhc3QgdG8gZmlyc3Qgc28gdGhhdCB0aGluZ3MgXCJyZXdpbmRcIiBwcm9wZXJseS5cbiAgICAgICAgY3VyVHJpZ2dlciA9IF90cmlnZ2Vyc1tpXTtcbiAgICAgICAgY3VyVHJpZ2dlci5lbmQgfHwgY3VyVHJpZ2dlci5yZWZyZXNoKDAsIDEpIHx8IChfcmVmcmVzaGluZyA9IHNlbGYpOyAvLyBpZiBpdCdzIGEgdGltZWxpbmUtYmFzZWQgdHJpZ2dlciB0aGF0IGhhc24ndCBiZWVuIGZ1bGx5IGluaXRpYWxpemVkIHlldCBiZWNhdXNlIGl0J3Mgd2FpdGluZyBmb3IgMSB0aWNrLCBqdXN0IGZvcmNlIHRoZSByZWZyZXNoKCkgaGVyZSwgb3RoZXJ3aXNlIGlmIGl0IGNvbnRhaW5zIGEgcGluIHRoYXQncyBzdXBwb3NlZCB0byBhZmZlY3Qgb3RoZXIgU2Nyb2xsVHJpZ2dlcnMgZnVydGhlciBkb3duIHRoZSBwYWdlLCB0aGV5IHdvbid0IGJlIGFkanVzdGVkIHByb3Blcmx5LlxuXG4gICAgICAgIGN1clBpbiA9IGN1clRyaWdnZXIucGluO1xuXG4gICAgICAgIGlmIChjdXJQaW4gJiYgKGN1clBpbiA9PT0gdHJpZ2dlciB8fCBjdXJQaW4gPT09IHBpbiB8fCBjdXJQaW4gPT09IHBpbm5lZENvbnRhaW5lcikgJiYgIWN1clRyaWdnZXIuaXNSZXZlcnRlZCkge1xuICAgICAgICAgIHJldmVydGVkUGlucyB8fCAocmV2ZXJ0ZWRQaW5zID0gW10pO1xuICAgICAgICAgIHJldmVydGVkUGlucy51bnNoaWZ0KGN1clRyaWdnZXIpOyAvLyB3ZSdsbCByZXZlcnQgZnJvbSBmaXJzdCB0byBsYXN0IHRvIG1ha2Ugc3VyZSB0aGluZ3MgcmVhY2ggdGhlaXIgZW5kIHN0YXRlIHByb3Blcmx5XG5cbiAgICAgICAgICBjdXJUcmlnZ2VyLnJldmVydCh0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJUcmlnZ2VyICE9PSBfdHJpZ2dlcnNbaV0pIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIGl0IGdvdCByZW1vdmVkLlxuICAgICAgICAgIHRyaWdnZXJJbmRleC0tO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfaXNGdW5jdGlvbihwYXJzZWRTdGFydCkgJiYgKHBhcnNlZFN0YXJ0ID0gcGFyc2VkU3RhcnQoc2VsZikpO1xuICAgICAgcGFyc2VkU3RhcnQgPSBfcGFyc2VDbGFtcChwYXJzZWRTdGFydCwgXCJzdGFydFwiLCBzZWxmKTtcbiAgICAgIHN0YXJ0ID0gX3BhcnNlUG9zaXRpb24ocGFyc2VkU3RhcnQsIHRyaWdnZXIsIHNpemUsIGRpcmVjdGlvbiwgc2Nyb2xsRnVuYygpLCBtYXJrZXJTdGFydCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBzZWxmLCBzY3JvbGxlckJvdW5kcywgYm9yZGVyV2lkdGgsIHVzZUZpeGVkUG9zaXRpb24sIG1heCwgY29udGFpbmVyQW5pbWF0aW9uLCBzZWxmLl9zdGFydENsYW1wICYmIFwiX3N0YXJ0Q2xhbXBcIikgfHwgKHBpbiA/IC0wLjAwMSA6IDApO1xuICAgICAgX2lzRnVuY3Rpb24ocGFyc2VkRW5kKSAmJiAocGFyc2VkRW5kID0gcGFyc2VkRW5kKHNlbGYpKTtcblxuICAgICAgaWYgKF9pc1N0cmluZyhwYXJzZWRFbmQpICYmICFwYXJzZWRFbmQuaW5kZXhPZihcIis9XCIpKSB7XG4gICAgICAgIGlmICh+cGFyc2VkRW5kLmluZGV4T2YoXCIgXCIpKSB7XG4gICAgICAgICAgcGFyc2VkRW5kID0gKF9pc1N0cmluZyhwYXJzZWRTdGFydCkgPyBwYXJzZWRTdGFydC5zcGxpdChcIiBcIilbMF0gOiBcIlwiKSArIHBhcnNlZEVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSBfb2Zmc2V0VG9QeChwYXJzZWRFbmQuc3Vic3RyKDIpLCBzaXplKTtcbiAgICAgICAgICBwYXJzZWRFbmQgPSBfaXNTdHJpbmcocGFyc2VkU3RhcnQpID8gcGFyc2VkU3RhcnQgOiAoY29udGFpbmVyQW5pbWF0aW9uID8gZ3NhcC51dGlscy5tYXBSYW5nZSgwLCBjb250YWluZXJBbmltYXRpb24uZHVyYXRpb24oKSwgY29udGFpbmVyQW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIuc3RhcnQsIGNvbnRhaW5lckFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyLmVuZCwgc3RhcnQpIDogc3RhcnQpICsgb2Zmc2V0OyAvLyBfcGFyc2VQb3NpdGlvbiB3b24ndCBmYWN0b3IgaW4gdGhlIG9mZnNldCBpZiB0aGUgc3RhcnQgaXMgYSBudW1iZXIsIHNvIGRvIGl0IGhlcmUuXG5cbiAgICAgICAgICBwYXJzZWRFbmRUcmlnZ2VyID0gdHJpZ2dlcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwYXJzZWRFbmQgPSBfcGFyc2VDbGFtcChwYXJzZWRFbmQsIFwiZW5kXCIsIHNlbGYpO1xuICAgICAgZW5kID0gTWF0aC5tYXgoc3RhcnQsIF9wYXJzZVBvc2l0aW9uKHBhcnNlZEVuZCB8fCAocGFyc2VkRW5kVHJpZ2dlciA/IFwiMTAwJSAwXCIgOiBtYXgpLCBwYXJzZWRFbmRUcmlnZ2VyLCBzaXplLCBkaXJlY3Rpb24sIHNjcm9sbEZ1bmMoKSArIG9mZnNldCwgbWFya2VyRW5kLCBtYXJrZXJFbmRUcmlnZ2VyLCBzZWxmLCBzY3JvbGxlckJvdW5kcywgYm9yZGVyV2lkdGgsIHVzZUZpeGVkUG9zaXRpb24sIG1heCwgY29udGFpbmVyQW5pbWF0aW9uLCBzZWxmLl9lbmRDbGFtcCAmJiBcIl9lbmRDbGFtcFwiKSkgfHwgLTAuMDAxO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIGkgPSB0cmlnZ2VySW5kZXg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY3VyVHJpZ2dlciA9IF90cmlnZ2Vyc1tpXTtcbiAgICAgICAgY3VyUGluID0gY3VyVHJpZ2dlci5waW47XG5cbiAgICAgICAgaWYgKGN1clBpbiAmJiBjdXJUcmlnZ2VyLnN0YXJ0IC0gY3VyVHJpZ2dlci5fcGluUHVzaCA8PSBzdGFydCAmJiAhY29udGFpbmVyQW5pbWF0aW9uICYmIGN1clRyaWdnZXIuZW5kID4gMCkge1xuICAgICAgICAgIGNzID0gY3VyVHJpZ2dlci5lbmQgLSAoc2VsZi5fc3RhcnRDbGFtcCA/IE1hdGgubWF4KDAsIGN1clRyaWdnZXIuc3RhcnQpIDogY3VyVHJpZ2dlci5zdGFydCk7XG5cbiAgICAgICAgICBpZiAoKGN1clBpbiA9PT0gdHJpZ2dlciAmJiBjdXJUcmlnZ2VyLnN0YXJ0IC0gY3VyVHJpZ2dlci5fcGluUHVzaCA8IHN0YXJ0IHx8IGN1clBpbiA9PT0gcGlubmVkQ29udGFpbmVyKSAmJiBpc05hTihwYXJzZWRTdGFydCkpIHtcbiAgICAgICAgICAgIC8vIG51bWVyaWMgc3RhcnQgdmFsdWVzIHNob3VsZG4ndCBiZSBvZmZzZXQgYXQgYWxsIC0gdHJlYXQgdGhlbSBhcyBhYnNvbHV0ZVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGNzICogKDEgLSBjdXJUcmlnZ2VyLnByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJQaW4gPT09IHBpbiAmJiAob3RoZXJQaW5PZmZzZXQgKz0gY3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0ICs9IG9mZnNldDtcbiAgICAgIGVuZCArPSBvZmZzZXQ7XG4gICAgICBzZWxmLl9zdGFydENsYW1wICYmIChzZWxmLl9zdGFydENsYW1wICs9IG9mZnNldCk7XG5cbiAgICAgIGlmIChzZWxmLl9lbmRDbGFtcCAmJiAhX3JlZnJlc2hpbmdBbGwpIHtcbiAgICAgICAgc2VsZi5fZW5kQ2xhbXAgPSBlbmQgfHwgLTAuMDAxO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbihlbmQsIF9tYXhTY3JvbGwoc2Nyb2xsZXIsIGRpcmVjdGlvbikpO1xuICAgICAgfVxuXG4gICAgICBjaGFuZ2UgPSBlbmQgLSBzdGFydCB8fCAoc3RhcnQgLT0gMC4wMSkgJiYgMC4wMDE7XG5cbiAgICAgIGlmIChpc0ZpcnN0UmVmcmVzaCkge1xuICAgICAgICAvLyBvbiB0aGUgdmVyeSBmaXJzdCByZWZyZXNoKCksIHRoZSBwcmV2UHJvZ3Jlc3MgY291bGRuJ3QgaGF2ZSBiZWVuIGFjY3VyYXRlIHlldCBiZWNhdXNlIHRoZSBzdGFydC9lbmQgd2VyZSBuZXZlciBjYWxjdWxhdGVkLCBzbyB3ZSBzZXQgaXQgaGVyZS4gQmVmb3JlIDMuMTEuNSwgaXQgY291bGQgbGVhZCB0byBhbiBpbmFjY3VyYXRlIHNjcm9sbCBwb3NpdGlvbiByZXN0b3JhdGlvbiB3aXRoIHNuYXBwaW5nLlxuICAgICAgICBwcmV2UHJvZ3Jlc3MgPSBnc2FwLnV0aWxzLmNsYW1wKDAsIDEsIGdzYXAudXRpbHMubm9ybWFsaXplKHN0YXJ0LCBlbmQsIHByZXZTY3JvbGwpKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5fcGluUHVzaCA9IG90aGVyUGluT2Zmc2V0O1xuXG4gICAgICBpZiAobWFya2VyU3RhcnQgJiYgb2Zmc2V0KSB7XG4gICAgICAgIC8vIG9mZnNldCB0aGUgbWFya2VycyBpZiBuZWNlc3NhcnlcbiAgICAgICAgY3MgPSB7fTtcbiAgICAgICAgY3NbZGlyZWN0aW9uLmFdID0gXCIrPVwiICsgb2Zmc2V0O1xuICAgICAgICBwaW5uZWRDb250YWluZXIgJiYgKGNzW2RpcmVjdGlvbi5wXSA9IFwiLT1cIiArIHNjcm9sbEZ1bmMoKSk7XG4gICAgICAgIGdzYXAuc2V0KFttYXJrZXJTdGFydCwgbWFya2VyRW5kXSwgY3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGluICYmICEoX2NsYW1waW5nTWF4ICYmIHNlbGYuZW5kID49IF9tYXhTY3JvbGwoc2Nyb2xsZXIsIGRpcmVjdGlvbikpKSB7XG4gICAgICAgIGNzID0gX2dldENvbXB1dGVkU3R5bGUocGluKTtcbiAgICAgICAgaXNWZXJ0aWNhbCA9IGRpcmVjdGlvbiA9PT0gX3ZlcnRpY2FsO1xuICAgICAgICBzY3JvbGwgPSBzY3JvbGxGdW5jKCk7IC8vIHJlY2FsY3VsYXRlIGJlY2F1c2UgdGhlIHRyaWdnZXJzIGNhbiBhZmZlY3QgdGhlIHNjcm9sbFxuXG4gICAgICAgIHBpblN0YXJ0ID0gcGFyc2VGbG9hdChwaW5HZXR0ZXIoZGlyZWN0aW9uLmEpKSArIG90aGVyUGluT2Zmc2V0O1xuXG4gICAgICAgIGlmICghbWF4ICYmIGVuZCA+IDEpIHtcbiAgICAgICAgICAvLyBtYWtlcyBzdXJlIHRoZSBzY3JvbGxlciBoYXMgYSBzY3JvbGxiYXIsIG90aGVyd2lzZSBpZiBzb21ldGhpbmcgaGFzIHdpZHRoOiAxMDAlLCBmb3IgZXhhbXBsZSwgaXQgd291bGQgYmUgdG9vIGJpZyAoZXhjbHVkZSB0aGUgc2Nyb2xsYmFyKS4gU2VlIGh0dHBzOi8vZ3NhcC5jb20vZm9ydW1zL3RvcGljLzI1MTgyLXNjcm9sbHRyaWdnZXItd2lkdGgtb2YtcGFnZS1pbmNyZWFzZS13aGVyZS1tYXJrZXJzLWFyZS1zZXQtdG8tZmFsc2UvXG4gICAgICAgICAgZm9yY2VkT3ZlcmZsb3cgPSAoaXNWaWV3cG9ydCA/IF9kb2Muc2Nyb2xsaW5nRWxlbWVudCB8fCBfZG9jRWwgOiBzY3JvbGxlcikuc3R5bGU7XG4gICAgICAgICAgZm9yY2VkT3ZlcmZsb3cgPSB7XG4gICAgICAgICAgICBzdHlsZTogZm9yY2VkT3ZlcmZsb3csXG4gICAgICAgICAgICB2YWx1ZTogZm9yY2VkT3ZlcmZsb3dbXCJvdmVyZmxvd1wiICsgZGlyZWN0aW9uLmEudG9VcHBlckNhc2UoKV1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGlzVmlld3BvcnQgJiYgX2dldENvbXB1dGVkU3R5bGUoX2JvZHkpW1wib3ZlcmZsb3dcIiArIGRpcmVjdGlvbi5hLnRvVXBwZXJDYXNlKCldICE9PSBcInNjcm9sbFwiKSB7XG4gICAgICAgICAgICAvLyBhdm9pZCBhbiBleHRyYSBzY3JvbGxiYXIgaWYgQk9USCA8aHRtbD4gYW5kIDxib2R5PiBoYXZlIG92ZXJmbG93IHNldCB0byBcInNjcm9sbFwiXG4gICAgICAgICAgICBmb3JjZWRPdmVyZmxvdy5zdHlsZVtcIm92ZXJmbG93XCIgKyBkaXJlY3Rpb24uYS50b1VwcGVyQ2FzZSgpXSA9IFwic2Nyb2xsXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3N3YXBQaW5JbihwaW4sIHNwYWNlciwgY3MpO1xuXG4gICAgICAgIHBpblN0YXRlID0gX2dldFN0YXRlKHBpbik7IC8vIHRyYW5zZm9ybXMgd2lsbCBpbnRlcmZlcmUgd2l0aCB0aGUgdG9wL2xlZnQvcmlnaHQvYm90dG9tIHBsYWNlbWVudCwgc28gcmVtb3ZlIHRoZW0gdGVtcG9yYXJpbHkuIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGZhY3RvcnMgaW4gdHJhbnNmb3Jtcy5cblxuICAgICAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKHBpbiwgdHJ1ZSk7XG4gICAgICAgIG9wcG9zaXRlU2Nyb2xsID0gdXNlRml4ZWRQb3NpdGlvbiAmJiBfZ2V0U2Nyb2xsRnVuYyhzY3JvbGxlciwgaXNWZXJ0aWNhbCA/IF9ob3Jpem9udGFsIDogX3ZlcnRpY2FsKSgpO1xuXG4gICAgICAgIGlmIChwaW5TcGFjaW5nKSB7XG4gICAgICAgICAgc3BhY2VyU3RhdGUgPSBbcGluU3BhY2luZyArIGRpcmVjdGlvbi5vczIsIGNoYW5nZSArIG90aGVyUGluT2Zmc2V0ICsgX3B4XTtcbiAgICAgICAgICBzcGFjZXJTdGF0ZS50ID0gc3BhY2VyO1xuICAgICAgICAgIGkgPSBwaW5TcGFjaW5nID09PSBfcGFkZGluZyA/IF9nZXRTaXplKHBpbiwgZGlyZWN0aW9uKSArIGNoYW5nZSArIG90aGVyUGluT2Zmc2V0IDogMDtcblxuICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICBzcGFjZXJTdGF0ZS5wdXNoKGRpcmVjdGlvbi5kLCBpICsgX3B4KTsgLy8gZm9yIGJveC1zaXppbmc6IGJvcmRlci1ib3ggKG11c3QgaW5jbHVkZSBwYWRkaW5nKS5cblxuICAgICAgICAgICAgc3BhY2VyLnN0eWxlLmZsZXhCYXNpcyAhPT0gXCJhdXRvXCIgJiYgKHNwYWNlci5zdHlsZS5mbGV4QmFzaXMgPSBpICsgX3B4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfc2V0U3RhdGUoc3BhY2VyU3RhdGUpO1xuXG4gICAgICAgICAgaWYgKHBpbm5lZENvbnRhaW5lcikge1xuICAgICAgICAgICAgLy8gaW4gU2Nyb2xsVHJpZ2dlci5yZWZyZXNoKCksIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgdGhlIHBpbkNvbnRhaW5lcidzIHNpemUgYmVjYXVzZSB0aGlzIHBpblNwYWNpbmcgbWF5IHN0cmV0Y2ggaXQgb3V0LCBidXQgd2UgY2FuJ3QganVzdCBhZGQgdGhlIGV4YWN0IGRpc3RhbmNlIGJlY2F1c2UgZGVwZW5kaW5nIG9uIGxheW91dCwgaXQgbWF5IG5vdCBwdXNoIHRoaW5ncyBkb3duIG9yIGl0IG1heSBvbmx5IGRvIHNvIHBhcnRpYWxseS5cbiAgICAgICAgICAgIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIGlmICh0LnBpbiA9PT0gcGlubmVkQ29udGFpbmVyICYmIHQudmFycy5waW5TcGFjaW5nICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHQuX3N1YlBpbk9mZnNldCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVzZUZpeGVkUG9zaXRpb24gJiYgc2Nyb2xsRnVuYyhwcmV2U2Nyb2xsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpID0gX2dldFNpemUocGluLCBkaXJlY3Rpb24pO1xuICAgICAgICAgIGkgJiYgc3BhY2VyLnN0eWxlLmZsZXhCYXNpcyAhPT0gXCJhdXRvXCIgJiYgKHNwYWNlci5zdHlsZS5mbGV4QmFzaXMgPSBpICsgX3B4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1c2VGaXhlZFBvc2l0aW9uKSB7XG4gICAgICAgICAgb3ZlcnJpZGUgPSB7XG4gICAgICAgICAgICB0b3A6IGJvdW5kcy50b3AgKyAoaXNWZXJ0aWNhbCA/IHNjcm9sbCAtIHN0YXJ0IDogb3Bwb3NpdGVTY3JvbGwpICsgX3B4LFxuICAgICAgICAgICAgbGVmdDogYm91bmRzLmxlZnQgKyAoaXNWZXJ0aWNhbCA/IG9wcG9zaXRlU2Nyb2xsIDogc2Nyb2xsIC0gc3RhcnQpICsgX3B4LFxuICAgICAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImZpeGVkXCJcbiAgICAgICAgICB9O1xuICAgICAgICAgIG92ZXJyaWRlW193aWR0aF0gPSBvdmVycmlkZVtcIm1heFwiICsgX1dpZHRoXSA9IE1hdGguY2VpbChib3VuZHMud2lkdGgpICsgX3B4O1xuICAgICAgICAgIG92ZXJyaWRlW19oZWlnaHRdID0gb3ZlcnJpZGVbXCJtYXhcIiArIF9IZWlnaHRdID0gTWF0aC5jZWlsKGJvdW5kcy5oZWlnaHQpICsgX3B4O1xuICAgICAgICAgIG92ZXJyaWRlW19tYXJnaW5dID0gb3ZlcnJpZGVbX21hcmdpbiArIF9Ub3BdID0gb3ZlcnJpZGVbX21hcmdpbiArIF9SaWdodF0gPSBvdmVycmlkZVtfbWFyZ2luICsgX0JvdHRvbV0gPSBvdmVycmlkZVtfbWFyZ2luICsgX0xlZnRdID0gXCIwXCI7XG4gICAgICAgICAgb3ZlcnJpZGVbX3BhZGRpbmddID0gY3NbX3BhZGRpbmddO1xuICAgICAgICAgIG92ZXJyaWRlW19wYWRkaW5nICsgX1RvcF0gPSBjc1tfcGFkZGluZyArIF9Ub3BdO1xuICAgICAgICAgIG92ZXJyaWRlW19wYWRkaW5nICsgX1JpZ2h0XSA9IGNzW19wYWRkaW5nICsgX1JpZ2h0XTtcbiAgICAgICAgICBvdmVycmlkZVtfcGFkZGluZyArIF9Cb3R0b21dID0gY3NbX3BhZGRpbmcgKyBfQm90dG9tXTtcbiAgICAgICAgICBvdmVycmlkZVtfcGFkZGluZyArIF9MZWZ0XSA9IGNzW19wYWRkaW5nICsgX0xlZnRdO1xuICAgICAgICAgIHBpbkFjdGl2ZVN0YXRlID0gX2NvcHlTdGF0ZShwaW5PcmlnaW5hbFN0YXRlLCBvdmVycmlkZSwgcGluUmVwYXJlbnQpO1xuICAgICAgICAgIF9yZWZyZXNoaW5nQWxsICYmIHNjcm9sbEZ1bmMoMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgICAgLy8gdGhlIGFuaW1hdGlvbiBtaWdodCBiZSBhZmZlY3RpbmcgdGhlIHRyYW5zZm9ybSwgc28gd2UgbXVzdCBqdW1wIHRvIHRoZSBlbmQsIGNoZWNrIHRoZSB2YWx1ZSwgYW5kIGNvbXBlbnNhdGUgYWNjb3JkaW5nbHkuIE90aGVyd2lzZSwgd2hlbiBpdCBiZWNvbWVzIHVucGlubmVkLCB0aGUgcGluU2V0dGVyKCkgd2lsbCBnZXQgc2V0IHRvIGEgdmFsdWUgdGhhdCBkb2Vzbid0IGluY2x1ZGUgd2hhdGV2ZXIgdGhlIGFuaW1hdGlvbiBkaWQuXG4gICAgICAgICAgaW5pdHRlZCA9IGFuaW1hdGlvbi5faW5pdHRlZDsgLy8gaWYgbm90LCB3ZSBtdXN0IGludmFsaWRhdGUoKSBhZnRlciB0aGlzIHN0ZXAsIG90aGVyd2lzZSBpdCBjb3VsZCBsb2NrIGluIHN0YXJ0aW5nIHZhbHVlcyBwcmVtYXR1cmVseS5cblxuICAgICAgICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMoMSk7XG5cbiAgICAgICAgICBhbmltYXRpb24ucmVuZGVyKGFuaW1hdGlvbi5kdXJhdGlvbigpLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBwaW5DaGFuZ2UgPSBwaW5HZXR0ZXIoZGlyZWN0aW9uLmEpIC0gcGluU3RhcnQgKyBjaGFuZ2UgKyBvdGhlclBpbk9mZnNldDtcbiAgICAgICAgICBwaW5Nb3ZlcyA9IE1hdGguYWJzKGNoYW5nZSAtIHBpbkNoYW5nZSkgPiAxO1xuICAgICAgICAgIHVzZUZpeGVkUG9zaXRpb24gJiYgcGluTW92ZXMgJiYgcGluQWN0aXZlU3RhdGUuc3BsaWNlKHBpbkFjdGl2ZVN0YXRlLmxlbmd0aCAtIDIsIDIpOyAvLyB0cmFuc2Zvcm0gaXMgdGhlIGxhc3QgcHJvcGVydHkvdmFsdWUgc2V0IGluIHRoZSBzdGF0ZSBBcnJheS4gU2luY2UgdGhlIGFuaW1hdGlvbiBpcyBjb250cm9sbGluZyB0aGF0LCB3ZSBzaG91bGQgb21pdCBpdC5cblxuICAgICAgICAgIGFuaW1hdGlvbi5yZW5kZXIoMCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgaW5pdHRlZCB8fCBhbmltYXRpb24uaW52YWxpZGF0ZSh0cnVlKTtcbiAgICAgICAgICBhbmltYXRpb24ucGFyZW50IHx8IGFuaW1hdGlvbi50b3RhbFRpbWUoYW5pbWF0aW9uLnRvdGFsVGltZSgpKTsgLy8gaWYsIGZvciBleGFtcGxlLCBhIHRvZ2dsZUFjdGlvbiBjYWxsZWQgcGxheSgpIGFuZCB0aGVuIHJlZnJlc2goKSBoYXBwZW5zIGFuZCB3aGVuIHdlIHJlbmRlcigxKSBhYm92ZSwgaXQgd291bGQgY2F1c2UgdGhlIGFuaW1hdGlvbiB0byBjb21wbGV0ZSBhbmQgZ2V0IHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50LCBzbyB0aGlzIG1ha2VzIHN1cmUgaXQgZ2V0cyBwdXQgYmFjayBpbi5cblxuICAgICAgICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGluQ2hhbmdlID0gY2hhbmdlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yY2VkT3ZlcmZsb3cgJiYgKGZvcmNlZE92ZXJmbG93LnZhbHVlID8gZm9yY2VkT3ZlcmZsb3cuc3R5bGVbXCJvdmVyZmxvd1wiICsgZGlyZWN0aW9uLmEudG9VcHBlckNhc2UoKV0gPSBmb3JjZWRPdmVyZmxvdy52YWx1ZSA6IGZvcmNlZE92ZXJmbG93LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwib3ZlcmZsb3ctXCIgKyBkaXJlY3Rpb24uYSkpO1xuICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICYmIHNjcm9sbEZ1bmMoKSAmJiAhY29udGFpbmVyQW5pbWF0aW9uKSB7XG4gICAgICAgIC8vIGl0IG1heSBiZSBJTlNJREUgYSBwaW5uZWQgZWxlbWVudCwgc28gd2FsayB1cCB0aGUgdHJlZSBhbmQgbG9vayBmb3IgYW55IGVsZW1lbnRzIHdpdGggX3Bpbk9mZnNldCB0byBjb21wZW5zYXRlIGJlY2F1c2UgYW55dGhpbmcgd2l0aCBwaW5TcGFjaW5nIHRoYXQncyBhbHJlYWR5IHNjcm9sbGVkIHdvdWxkIHRocm93IG9mZiB0aGUgbWVhc3VyZW1lbnRzIGluIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIGJvdW5kcyA9IHRyaWdnZXIucGFyZW50Tm9kZTtcblxuICAgICAgICB3aGlsZSAoYm91bmRzICYmIGJvdW5kcyAhPT0gX2JvZHkpIHtcbiAgICAgICAgICBpZiAoYm91bmRzLl9waW5PZmZzZXQpIHtcbiAgICAgICAgICAgIHN0YXJ0IC09IGJvdW5kcy5fcGluT2Zmc2V0O1xuICAgICAgICAgICAgZW5kIC09IGJvdW5kcy5fcGluT2Zmc2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJvdW5kcyA9IGJvdW5kcy5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldmVydGVkUGlucyAmJiByZXZlcnRlZFBpbnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5yZXZlcnQoZmFsc2UsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICBzZWxmLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICBzZWxmLmVuZCA9IGVuZDtcbiAgICAgIHNjcm9sbDEgPSBzY3JvbGwyID0gX3JlZnJlc2hpbmdBbGwgPyBwcmV2U2Nyb2xsIDogc2Nyb2xsRnVuYygpOyAvLyByZXNldCB2ZWxvY2l0eVxuXG4gICAgICBpZiAoIWNvbnRhaW5lckFuaW1hdGlvbiAmJiAhX3JlZnJlc2hpbmdBbGwpIHtcbiAgICAgICAgc2Nyb2xsMSA8IHByZXZTY3JvbGwgJiYgc2Nyb2xsRnVuYyhwcmV2U2Nyb2xsKTtcbiAgICAgICAgc2VsZi5zY3JvbGwucmVjID0gMDtcbiAgICAgIH1cblxuICAgICAgc2VsZi5yZXZlcnQoZmFsc2UsIHRydWUpO1xuICAgICAgbGFzdFJlZnJlc2ggPSBfZ2V0VGltZSgpO1xuXG4gICAgICBpZiAoc25hcERlbGF5ZWRDYWxsKSB7XG4gICAgICAgIGxhc3RTbmFwID0gLTE7IC8vIGp1c3Qgc28gc25hcHBpbmcgZ2V0cyByZS1lbmFibGVkLCBjbGVhciBvdXQgYW55IHJlY29yZGVkIGxhc3QgdmFsdWVcbiAgICAgICAgLy8gc2VsZi5pc0FjdGl2ZSAmJiBzY3JvbGxGdW5jKHN0YXJ0ICsgY2hhbmdlICogcHJldlByb2dyZXNzKTsgLy8gcHJldmlvdXNseSB0aGlzIGxpbmUgd2FzIGhlcmUgdG8gZW5zdXJlIHRoYXQgd2hlbiBzbmFwcGluZyBraWNrcyBpbiwgaXQncyBmcm9tIHRoZSBwcmV2aW91cyBwcm9ncmVzcyBidXQgaW4gc29tZSBjYXNlcyB0aGF0J3Mgbm90IGRlc2lyYWJsZSwgbGlrZSBhbiBhbGwtcGFnZSBTY3JvbGxUcmlnZ2VyIHdoZW4gbmV3IGNvbnRlbnQgZ2V0cyBhZGRlZCB0byB0aGUgcGFnZSwgdGhhdCdkIHRvdGFsbHkgY2hhbmdlIHRoZSBwcm9ncmVzcy5cblxuICAgICAgICBzbmFwRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgX3JlZnJlc2hpbmcgPSAwO1xuICAgICAgYW5pbWF0aW9uICYmIGlzVG9nZ2xlICYmIChhbmltYXRpb24uX2luaXR0ZWQgfHwgcHJldkFuaW1Qcm9ncmVzcykgJiYgYW5pbWF0aW9uLnByb2dyZXNzKCkgIT09IHByZXZBbmltUHJvZ3Jlc3MgJiYgYW5pbWF0aW9uLnByb2dyZXNzKHByZXZBbmltUHJvZ3Jlc3MgfHwgMCwgdHJ1ZSkucmVuZGVyKGFuaW1hdGlvbi50aW1lKCksIHRydWUsIHRydWUpOyAvLyBtdXN0IGZvcmNlIGEgcmUtcmVuZGVyIGJlY2F1c2UgaWYgc2F2ZVN0eWxlcygpIHdhcyB1c2VkIG9uIHRoZSB0YXJnZXQocyksIHRoZSBzdHlsZXMgY291bGQgaGF2ZSBiZWVuIHdpcGVkIG91dCBkdXJpbmcgdGhlIHJlZnJlc2goKS5cblxuICAgICAgaWYgKGlzRmlyc3RSZWZyZXNoIHx8IHByZXZQcm9ncmVzcyAhPT0gc2VsZi5wcm9ncmVzcyB8fCBjb250YWluZXJBbmltYXRpb24gfHwgaW52YWxpZGF0ZU9uUmVmcmVzaCkge1xuICAgICAgICAvLyBlbnN1cmVzIHRoYXQgdGhlIGRpcmVjdGlvbiBpcyBzZXQgcHJvcGVybHkgKHdoZW4gcmVmcmVzaGluZywgcHJvZ3Jlc3MgaXMgc2V0IGJhY2sgdG8gMCBpbml0aWFsbHksIHRoZW4gYmFjayBhZ2FpbiB0byB3aGVyZXZlciBpdCBuZWVkcyB0byBiZSkgYW5kIHRoYXQgY2FsbGJhY2tzIGFyZSB0cmlnZ2VyZWQuXG4gICAgICAgIGFuaW1hdGlvbiAmJiAhaXNUb2dnbGUgJiYgYW5pbWF0aW9uLnRvdGFsUHJvZ3Jlc3MoY29udGFpbmVyQW5pbWF0aW9uICYmIHN0YXJ0IDwgLTAuMDAxICYmICFwcmV2UHJvZ3Jlc3MgPyBnc2FwLnV0aWxzLm5vcm1hbGl6ZShzdGFydCwgZW5kLCAwKSA6IHByZXZQcm9ncmVzcywgdHJ1ZSk7IC8vIHRvIGF2b2lkIGlzc3VlcyB3aGVyZSBhbmltYXRpb24gY2FsbGJhY2tzIGxpa2Ugb25TdGFydCBhcmVuJ3QgdHJpZ2dlcmVkLlxuXG4gICAgICAgIHNlbGYucHJvZ3Jlc3MgPSBpc0ZpcnN0UmVmcmVzaCB8fCAoc2Nyb2xsMSAtIHN0YXJ0KSAvIGNoYW5nZSA9PT0gcHJldlByb2dyZXNzID8gMCA6IHByZXZQcm9ncmVzcztcbiAgICAgIH1cblxuICAgICAgcGluICYmIHBpblNwYWNpbmcgJiYgKHNwYWNlci5fcGluT2Zmc2V0ID0gTWF0aC5yb3VuZChzZWxmLnByb2dyZXNzICogcGluQ2hhbmdlKSk7XG4gICAgICBzY3J1YlR3ZWVuICYmIHNjcnViVHdlZW4uaW52YWxpZGF0ZSgpO1xuXG4gICAgICBpZiAoIWlzTmFOKG1hcmtlclN0YXJ0T2Zmc2V0KSkge1xuICAgICAgICAvLyBudW1iZXJzIHdlcmUgcGFzc2VkIGluIGZvciB0aGUgcG9zaXRpb24gd2hpY2ggYXJlIGFic29sdXRlLCBzbyBpbnN0ZWFkIG9mIGp1c3QgcHV0dGluZyB0aGUgbWFya2VycyBhdCB0aGUgdmVyeSBib3R0b20gb2YgdGhlIHZpZXdwb3J0LCB3ZSBmaWd1cmUgb3V0IGhvdyBmYXIgdGhleSBzaGlmdGVkIGRvd24gKGl0J3Mgc2FmZSB0byBhc3N1bWUgdGhleSB3ZXJlIG9yaWdpbmFsbHkgcG9zaXRpb25lZCBpbiBjbG9zZXIgcmVsYXRpb24gdG8gdGhlIHRyaWdnZXIgZWxlbWVudCB3aXRoIHZhbHVlcyBsaWtlIFwidG9wXCIsIFwiY2VudGVyXCIsIGEgcGVyY2VudGFnZSBvciB3aGF0ZXZlciwgc28gd2Ugb2Zmc2V0IHRoYXQgbXVjaCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIHRvIGJhc2ljYWxseSByZXZlcnQgdGhlbSB0byB0aGUgcmVsYXRpdmUgcG9zaXRpb24gdGh5IHdlcmUgYXQgcHJldmlvdXNseS5cbiAgICAgICAgbWFya2VyU3RhcnRPZmZzZXQgLT0gZ3NhcC5nZXRQcm9wZXJ0eShtYXJrZXJTdGFydFRyaWdnZXIsIGRpcmVjdGlvbi5wKTtcbiAgICAgICAgbWFya2VyRW5kT2Zmc2V0IC09IGdzYXAuZ2V0UHJvcGVydHkobWFya2VyRW5kVHJpZ2dlciwgZGlyZWN0aW9uLnApO1xuXG4gICAgICAgIF9zaGlmdE1hcmtlcihtYXJrZXJTdGFydFRyaWdnZXIsIGRpcmVjdGlvbiwgbWFya2VyU3RhcnRPZmZzZXQpO1xuXG4gICAgICAgIF9zaGlmdE1hcmtlcihtYXJrZXJTdGFydCwgZGlyZWN0aW9uLCBtYXJrZXJTdGFydE9mZnNldCAtIChwaW5PZmZzZXQgfHwgMCkpO1xuXG4gICAgICAgIF9zaGlmdE1hcmtlcihtYXJrZXJFbmRUcmlnZ2VyLCBkaXJlY3Rpb24sIG1hcmtlckVuZE9mZnNldCk7XG5cbiAgICAgICAgX3NoaWZ0TWFya2VyKG1hcmtlckVuZCwgZGlyZWN0aW9uLCBtYXJrZXJFbmRPZmZzZXQgLSAocGluT2Zmc2V0IHx8IDApKTtcbiAgICAgIH1cblxuICAgICAgaXNGaXJzdFJlZnJlc2ggJiYgIV9yZWZyZXNoaW5nQWxsICYmIHNlbGYudXBkYXRlKCk7IC8vIGVkZ2UgY2FzZSAtIHdoZW4geW91IHJlbG9hZCBhIHBhZ2Ugd2hlbiBpdCdzIGFscmVhZHkgc2Nyb2xsZWQgZG93biwgc29tZSBicm93c2VycyBmaXJlIGEgXCJzY3JvbGxcIiBldmVudCBiZWZvcmUgRE9NQ29udGVudExvYWRlZCwgdHJpZ2dlcmluZyBhbiB1cGRhdGVBbGwoKS4gSWYgd2UgZG9uJ3QgdXBkYXRlIHRoZSBzZWxmLnByb2dyZXNzIGFzIHBhcnQgb2YgcmVmcmVzaCgpLCB0aGVuIHdoZW4gaXQgaGFwcGVucyBuZXh0LCBpdCBtYXkgcmVjb3JkIHByZXZQcm9ncmVzcyBhcyAwIHdoZW4gaXQgcmVhbGx5IHNob3VsZG4ndCwgcG90ZW50aWFsbHkgY2F1c2luZyBhIGNhbGxiYWNrIGluIGFuIGFuaW1hdGlvbiB0byBmaXJlIGFnYWluLlxuXG4gICAgICBpZiAob25SZWZyZXNoICYmICFfcmVmcmVzaGluZ0FsbCAmJiAhZXhlY3V0aW5nT25SZWZyZXNoKSB7XG4gICAgICAgIC8vIHdoZW4gcmVmcmVzaGluZyBhbGwsIHdlIGRvIGV4dHJhIHdvcmsgdG8gY29ycmVjdCBwaW5uZWRDb250YWluZXIgc2l6ZXMgYW5kIGVuc3VyZSB0aGluZ3MgZG9uJ3QgZXhjZWVkIHRoZSBtYXhTY3JvbGwsIHNvIHdlIHNob3VsZCBkbyBhbGwgdGhlIHJlZnJlc2hlcyBhdCB0aGUgZW5kIGFmdGVyIGFsbCB0aGF0IHdvcmsgc28gdGhhdCB0aGUgc3RhcnQvZW5kIHZhbHVlcyBhcmUgY29ycmVjdGVkLlxuICAgICAgICBleGVjdXRpbmdPblJlZnJlc2ggPSB0cnVlO1xuICAgICAgICBvblJlZnJlc2goc2VsZik7XG4gICAgICAgIGV4ZWN1dGluZ09uUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmdldFZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChzY3JvbGxGdW5jKCkgLSBzY3JvbGwyKSAvIChfZ2V0VGltZSgpIC0gX3RpbWUyKSAqIDEwMDAgfHwgMDtcbiAgICB9O1xuXG4gICAgc2VsZi5lbmRBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfZW5kQW5pbWF0aW9uKHNlbGYuY2FsbGJhY2tBbmltYXRpb24pO1xuXG4gICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIHNjcnViVHdlZW4gPyBzY3J1YlR3ZWVuLnByb2dyZXNzKDEpIDogIWFuaW1hdGlvbi5wYXVzZWQoKSA/IF9lbmRBbmltYXRpb24oYW5pbWF0aW9uLCBhbmltYXRpb24ucmV2ZXJzZWQoKSkgOiBpc1RvZ2dsZSB8fCBfZW5kQW5pbWF0aW9uKGFuaW1hdGlvbiwgc2VsZi5kaXJlY3Rpb24gPCAwLCAxKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5sYWJlbFRvU2Nyb2xsID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICByZXR1cm4gYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5sYWJlbHMgJiYgKHN0YXJ0IHx8IHNlbGYucmVmcmVzaCgpIHx8IHN0YXJ0KSArIGFuaW1hdGlvbi5sYWJlbHNbbGFiZWxdIC8gYW5pbWF0aW9uLmR1cmF0aW9uKCkgKiBjaGFuZ2UgfHwgMDtcbiAgICB9O1xuXG4gICAgc2VsZi5nZXRUcmFpbGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgaSA9IF90cmlnZ2Vycy5pbmRleE9mKHNlbGYpLFxuICAgICAgICAgIGEgPSBzZWxmLmRpcmVjdGlvbiA+IDAgPyBfdHJpZ2dlcnMuc2xpY2UoMCwgaSkucmV2ZXJzZSgpIDogX3RyaWdnZXJzLnNsaWNlKGkgKyAxKTtcblxuICAgICAgcmV0dXJuIChfaXNTdHJpbmcobmFtZSkgPyBhLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC52YXJzLnByZXZlbnRPdmVybGFwcyA9PT0gbmFtZTtcbiAgICAgIH0pIDogYSkuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBzZWxmLmRpcmVjdGlvbiA+IDAgPyB0LmVuZCA8PSBzdGFydCA6IHQuc3RhcnQgPj0gZW5kO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHNlbGYudXBkYXRlID0gZnVuY3Rpb24gKHJlc2V0LCByZWNvcmRWZWxvY2l0eSwgZm9yY2VGYWtlKSB7XG4gICAgICBpZiAoY29udGFpbmVyQW5pbWF0aW9uICYmICFmb3JjZUZha2UgJiYgIXJlc2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNjcm9sbCA9IF9yZWZyZXNoaW5nQWxsID09PSB0cnVlID8gcHJldlNjcm9sbCA6IHNlbGYuc2Nyb2xsKCksXG4gICAgICAgICAgcCA9IHJlc2V0ID8gMCA6IChzY3JvbGwgLSBzdGFydCkgLyBjaGFuZ2UsXG4gICAgICAgICAgY2xpcHBlZCA9IHAgPCAwID8gMCA6IHAgPiAxID8gMSA6IHAgfHwgMCxcbiAgICAgICAgICBwcmV2UHJvZ3Jlc3MgPSBzZWxmLnByb2dyZXNzLFxuICAgICAgICAgIGlzQWN0aXZlLFxuICAgICAgICAgIHdhc0FjdGl2ZSxcbiAgICAgICAgICB0b2dnbGVTdGF0ZSxcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgc3RhdGVDaGFuZ2VkLFxuICAgICAgICAgIHRvZ2dsZWQsXG4gICAgICAgICAgaXNBdE1heCxcbiAgICAgICAgICBpc1Rha2luZ0FjdGlvbjtcblxuICAgICAgaWYgKHJlY29yZFZlbG9jaXR5KSB7XG4gICAgICAgIHNjcm9sbDIgPSBzY3JvbGwxO1xuICAgICAgICBzY3JvbGwxID0gY29udGFpbmVyQW5pbWF0aW9uID8gc2Nyb2xsRnVuYygpIDogc2Nyb2xsO1xuXG4gICAgICAgIGlmIChzbmFwKSB7XG4gICAgICAgICAgc25hcDIgPSBzbmFwMTtcbiAgICAgICAgICBzbmFwMSA9IGFuaW1hdGlvbiAmJiAhaXNUb2dnbGUgPyBhbmltYXRpb24udG90YWxQcm9ncmVzcygpIDogY2xpcHBlZDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBhbnRpY2lwYXRlIHRoZSBwaW5uaW5nIGEgZmV3IHRpY2tzIGFoZWFkIG9mIHRpbWUgYmFzZWQgb24gdmVsb2NpdHkgdG8gYXZvaWQgYSB2aXN1YWwgZ2xpdGNoIGR1ZSB0byB0aGUgZmFjdCB0aGF0IG1vc3QgYnJvd3NlcnMgZG8gc2Nyb2xsaW5nIG9uIGEgc2VwYXJhdGUgdGhyZWFkIChub3Qgc3luY2VkIHdpdGggcmVxdWVzdEFuaW1hdGlvbkZyYW1lKS5cblxuXG4gICAgICBpZiAoYW50aWNpcGF0ZVBpbiAmJiBwaW4gJiYgIV9yZWZyZXNoaW5nICYmICFfc3RhcnR1cCAmJiBfbGFzdFNjcm9sbFRpbWUpIHtcbiAgICAgICAgaWYgKCFjbGlwcGVkICYmIHN0YXJ0IDwgc2Nyb2xsICsgKHNjcm9sbCAtIHNjcm9sbDIpIC8gKF9nZXRUaW1lKCkgLSBfdGltZTIpICogYW50aWNpcGF0ZVBpbikge1xuICAgICAgICAgIGNsaXBwZWQgPSAwLjAwMDE7XG4gICAgICAgIH0gZWxzZSBpZiAoY2xpcHBlZCA9PT0gMSAmJiBlbmQgPiBzY3JvbGwgKyAoc2Nyb2xsIC0gc2Nyb2xsMikgLyAoX2dldFRpbWUoKSAtIF90aW1lMikgKiBhbnRpY2lwYXRlUGluKSB7XG4gICAgICAgICAgY2xpcHBlZCA9IDAuOTk5OTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2xpcHBlZCAhPT0gcHJldlByb2dyZXNzICYmIHNlbGYuZW5hYmxlZCkge1xuICAgICAgICBpc0FjdGl2ZSA9IHNlbGYuaXNBY3RpdmUgPSAhIWNsaXBwZWQgJiYgY2xpcHBlZCA8IDE7XG4gICAgICAgIHdhc0FjdGl2ZSA9ICEhcHJldlByb2dyZXNzICYmIHByZXZQcm9ncmVzcyA8IDE7XG4gICAgICAgIHRvZ2dsZWQgPSBpc0FjdGl2ZSAhPT0gd2FzQWN0aXZlO1xuICAgICAgICBzdGF0ZUNoYW5nZWQgPSB0b2dnbGVkIHx8ICEhY2xpcHBlZCAhPT0gISFwcmV2UHJvZ3Jlc3M7IC8vIGNvdWxkIGdvIGZyb20gc3RhcnQgYWxsIHRoZSB3YXkgdG8gZW5kLCB0aHVzIGl0IGRpZG4ndCB0b2dnbGUgYnV0IGl0IGRpZCBjaGFuZ2Ugc3RhdGUgaW4gYSBzZW5zZSAobWF5IG5lZWQgdG8gZmlyZSBhIGNhbGxiYWNrKVxuXG4gICAgICAgIHNlbGYuZGlyZWN0aW9uID0gY2xpcHBlZCA+IHByZXZQcm9ncmVzcyA/IDEgOiAtMTtcbiAgICAgICAgc2VsZi5wcm9ncmVzcyA9IGNsaXBwZWQ7XG5cbiAgICAgICAgaWYgKHN0YXRlQ2hhbmdlZCAmJiAhX3JlZnJlc2hpbmcpIHtcbiAgICAgICAgICB0b2dnbGVTdGF0ZSA9IGNsaXBwZWQgJiYgIXByZXZQcm9ncmVzcyA/IDAgOiBjbGlwcGVkID09PSAxID8gMSA6IHByZXZQcm9ncmVzcyA9PT0gMSA/IDIgOiAzOyAvLyAwID0gZW50ZXIsIDEgPSBsZWF2ZSwgMiA9IGVudGVyQmFjaywgMyA9IGxlYXZlQmFjayAod2UgcHJpb3JpdGl6ZSB0aGUgRklSU1QgZW5jb3VudGVyLCB0aHVzIGlmIHlvdSBzY3JvbGwgcmVhbGx5IGZhc3QgcGFzdCB0aGUgb25FbnRlciBhbmQgb25MZWF2ZSBpbiBvbmUgdGljaywgaXQnZCBwcmlvcml0aXplIG9uRW50ZXIuXG5cbiAgICAgICAgICBpZiAoaXNUb2dnbGUpIHtcbiAgICAgICAgICAgIGFjdGlvbiA9ICF0b2dnbGVkICYmIHRvZ2dsZUFjdGlvbnNbdG9nZ2xlU3RhdGUgKyAxXSAhPT0gXCJub25lXCIgJiYgdG9nZ2xlQWN0aW9uc1t0b2dnbGVTdGF0ZSArIDFdIHx8IHRvZ2dsZUFjdGlvbnNbdG9nZ2xlU3RhdGVdOyAvLyBpZiBpdCBkaWRuJ3QgdG9nZ2xlLCB0aGF0IG1lYW5zIGl0IHNob3QgcmlnaHQgcGFzdCBhbmQgc2luY2Ugd2UgcHJpb3JpdGl6ZSB0aGUgXCJlbnRlclwiIGFjdGlvbiwgd2Ugc2hvdWxkIHN3aXRjaCB0byB0aGUgXCJsZWF2ZVwiIGluIHRoaXMgY2FzZSAoYnV0IG9ubHkgaWYgb25lIGlzIGRlZmluZWQpXG5cbiAgICAgICAgICAgIGlzVGFraW5nQWN0aW9uID0gYW5pbWF0aW9uICYmIChhY3Rpb24gPT09IFwiY29tcGxldGVcIiB8fCBhY3Rpb24gPT09IFwicmVzZXRcIiB8fCBhY3Rpb24gaW4gYW5pbWF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2ZW50T3ZlcmxhcHMgJiYgKHRvZ2dsZWQgfHwgaXNUYWtpbmdBY3Rpb24pICYmIChpc1Rha2luZ0FjdGlvbiB8fCBzY3J1YiB8fCAhYW5pbWF0aW9uKSAmJiAoX2lzRnVuY3Rpb24ocHJldmVudE92ZXJsYXBzKSA/IHByZXZlbnRPdmVybGFwcyhzZWxmKSA6IHNlbGYuZ2V0VHJhaWxpbmcocHJldmVudE92ZXJsYXBzKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQuZW5kQW5pbWF0aW9uKCk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBpZiAoIWlzVG9nZ2xlKSB7XG4gICAgICAgICAgaWYgKHNjcnViVHdlZW4gJiYgIV9yZWZyZXNoaW5nICYmICFfc3RhcnR1cCkge1xuICAgICAgICAgICAgc2NydWJUd2Vlbi5fZHAuX3RpbWUgLSBzY3J1YlR3ZWVuLl9zdGFydCAhPT0gc2NydWJUd2Vlbi5fdGltZSAmJiBzY3J1YlR3ZWVuLnJlbmRlcihzY3J1YlR3ZWVuLl9kcC5fdGltZSAtIHNjcnViVHdlZW4uX3N0YXJ0KTsgLy8gaWYgdGhlcmUncyBhIHNjcnViIG9uIGJvdGggdGhlIGNvbnRhaW5lciBhbmltYXRpb24gYW5kIHRoaXMgb25lIChvciBhIFNjcm9sbFNtb290aGVyKSwgdGhlIHVwZGF0ZSBvcmRlciB3b3VsZCBjYXVzZSB0aGlzIG9uZSBub3QgdG8gaGF2ZSByZW5kZXJlZCB5ZXQsIHNvIGl0IHdvdWxkbid0IG1ha2UgYW55IHByb2dyZXNzIGJlZm9yZSB3ZSAucmVzdGFydCgpIGl0IGhlYWRpbmcgdG93YXJkIHRoZSBuZXcgcHJvZ3Jlc3Mgc28gaXQnZCBhcHBlYXIgc3R1Y2sgdGh1cyB3ZSBmb3JjZSBhIHJlbmRlciBoZXJlLlxuXG4gICAgICAgICAgICBpZiAoc2NydWJUd2Vlbi5yZXNldFRvKSB7XG4gICAgICAgICAgICAgIHNjcnViVHdlZW4ucmVzZXRUbyhcInRvdGFsUHJvZ3Jlc3NcIiwgY2xpcHBlZCwgYW5pbWF0aW9uLl90VGltZSAvIGFuaW1hdGlvbi5fdER1cik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBsZWdhY3kgc3VwcG9ydCAoY291cnRlc3kpLCBiZWZvcmUgMy4xMC4wXG4gICAgICAgICAgICAgIHNjcnViVHdlZW4udmFycy50b3RhbFByb2dyZXNzID0gY2xpcHBlZDtcbiAgICAgICAgICAgICAgc2NydWJUd2Vlbi5pbnZhbGlkYXRlKCkucmVzdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBhbmltYXRpb24udG90YWxQcm9ncmVzcyhjbGlwcGVkLCAhIShfcmVmcmVzaGluZyAmJiAobGFzdFJlZnJlc2ggfHwgcmVzZXQpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBpbikge1xuICAgICAgICAgIHJlc2V0ICYmIHBpblNwYWNpbmcgJiYgKHNwYWNlci5zdHlsZVtwaW5TcGFjaW5nICsgZGlyZWN0aW9uLm9zMl0gPSBzcGFjaW5nU3RhcnQpO1xuXG4gICAgICAgICAgaWYgKCF1c2VGaXhlZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBwaW5TZXR0ZXIoX3JvdW5kKHBpblN0YXJ0ICsgcGluQ2hhbmdlICogY2xpcHBlZCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpc0F0TWF4ID0gIXJlc2V0ICYmIGNsaXBwZWQgPiBwcmV2UHJvZ3Jlc3MgJiYgZW5kICsgMSA+IHNjcm9sbCAmJiBzY3JvbGwgKyAxID49IF9tYXhTY3JvbGwoc2Nyb2xsZXIsIGRpcmVjdGlvbik7IC8vIGlmIGl0J3MgYXQgdGhlIFZFUlkgZW5kIG9mIHRoZSBwYWdlLCBkb24ndCBzd2l0Y2ggYXdheSBmcm9tIHBvc2l0aW9uOiBmaXhlZCBiZWNhdXNlIGl0J3MgcG9pbnRsZXNzIGFuZCBpdCBjb3VsZCBjYXVzZSBhIGJyaWVmIGZsYXNoIHdoZW4gdGhlIHVzZXIgc2Nyb2xscyBiYWNrIHVwICh3aGVuIGl0IGdldHMgcGlubmVkIGFnYWluKVxuXG4gICAgICAgICAgICBpZiAocGluUmVwYXJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKCFyZXNldCAmJiAoaXNBY3RpdmUgfHwgaXNBdE1heCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRzID0gX2dldEJvdW5kcyhwaW4sIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICBfb2Zmc2V0ID0gc2Nyb2xsIC0gc3RhcnQ7XG5cbiAgICAgICAgICAgICAgICBfcmVwYXJlbnQocGluLCBfYm9keSwgYm91bmRzLnRvcCArIChkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbCA/IF9vZmZzZXQgOiAwKSArIF9weCwgYm91bmRzLmxlZnQgKyAoZGlyZWN0aW9uID09PSBfdmVydGljYWwgPyAwIDogX29mZnNldCkgKyBfcHgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9yZXBhcmVudChwaW4sIHNwYWNlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3NldFN0YXRlKGlzQWN0aXZlIHx8IGlzQXRNYXggPyBwaW5BY3RpdmVTdGF0ZSA6IHBpblN0YXRlKTtcblxuICAgICAgICAgICAgcGluTW92ZXMgJiYgY2xpcHBlZCA8IDEgJiYgaXNBY3RpdmUgfHwgcGluU2V0dGVyKHBpblN0YXJ0ICsgKGNsaXBwZWQgPT09IDEgJiYgIWlzQXRNYXggPyBwaW5DaGFuZ2UgOiAwKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc25hcCAmJiAhdHdlZW5Uby50d2VlbiAmJiAhX3JlZnJlc2hpbmcgJiYgIV9zdGFydHVwICYmIHNuYXBEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpO1xuICAgICAgICB0b2dnbGVDbGFzcyAmJiAodG9nZ2xlZCB8fCBvbmNlICYmIGNsaXBwZWQgJiYgKGNsaXBwZWQgPCAxIHx8ICFfbGltaXRDYWxsYmFja3MpKSAmJiBfdG9BcnJheSh0b2dnbGVDbGFzcy50YXJnZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIHJldHVybiBlbC5jbGFzc0xpc3RbaXNBY3RpdmUgfHwgb25jZSA/IFwiYWRkXCIgOiBcInJlbW92ZVwiXSh0b2dnbGVDbGFzcy5jbGFzc05hbWUpO1xuICAgICAgICB9KTsgLy8gY2xhc3NlcyBjb3VsZCBhZmZlY3QgcG9zaXRpb25pbmcsIHNvIGRvIGl0IGV2ZW4gaWYgcmVzZXQgb3IgcmVmcmVzaGluZyBpcyB0cnVlLlxuXG4gICAgICAgIG9uVXBkYXRlICYmICFpc1RvZ2dsZSAmJiAhcmVzZXQgJiYgb25VcGRhdGUoc2VsZik7XG5cbiAgICAgICAgaWYgKHN0YXRlQ2hhbmdlZCAmJiAhX3JlZnJlc2hpbmcpIHtcbiAgICAgICAgICBpZiAoaXNUb2dnbGUpIHtcbiAgICAgICAgICAgIGlmIChpc1Rha2luZ0FjdGlvbikge1xuICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24ucGF1c2UoKS50b3RhbFByb2dyZXNzKDEpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJyZXNldFwiKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLnJlc3RhcnQodHJ1ZSkucGF1c2UoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT09IFwicmVzdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLnJlc3RhcnQodHJ1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uW2FjdGlvbl0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvblVwZGF0ZSAmJiBvblVwZGF0ZShzZWxmKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodG9nZ2xlZCB8fCAhX2xpbWl0Q2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAvLyBvbiBzdGFydHVwLCB0aGUgcGFnZSBjb3VsZCBiZSBzY3JvbGxlZCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBmaXJlIGNhbGxiYWNrcyB0aGF0IGRpZG4ndCB0b2dnbGUuIEZvciBleGFtcGxlIG9uRW50ZXIgc2hvdWxkbid0IGZpcmUgaWYgdGhlIFNjcm9sbFRyaWdnZXIgaXNuJ3QgYWN0dWFsbHkgZW50ZXJlZC5cbiAgICAgICAgICAgIG9uVG9nZ2xlICYmIHRvZ2dsZWQgJiYgX2NhbGxiYWNrKHNlbGYsIG9uVG9nZ2xlKTtcbiAgICAgICAgICAgIGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0gJiYgX2NhbGxiYWNrKHNlbGYsIGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0pO1xuICAgICAgICAgICAgb25jZSAmJiAoY2xpcHBlZCA9PT0gMSA/IHNlbGYua2lsbChmYWxzZSwgMSkgOiBjYWxsYmFja3NbdG9nZ2xlU3RhdGVdID0gMCk7IC8vIGEgY2FsbGJhY2sgc2hvdWxkbid0IGJlIGNhbGxlZCBhZ2FpbiBpZiBvbmNlIGlzIHRydWUuXG5cbiAgICAgICAgICAgIGlmICghdG9nZ2xlZCkge1xuICAgICAgICAgICAgICAvLyBpdCdzIHBvc3NpYmxlIHRvIGdvIGNvbXBsZXRlbHkgcGFzdCwgbGlrZSBmcm9tIGJlZm9yZSB0aGUgc3RhcnQgdG8gYWZ0ZXIgdGhlIGVuZCAob3IgdmljZS12ZXJzYSkgaW4gd2hpY2ggY2FzZSBCT1RIIGNhbGxiYWNrcyBzaG91bGQgYmUgZmlyZWQgaW4gdGhhdCBvcmRlclxuICAgICAgICAgICAgICB0b2dnbGVTdGF0ZSA9IGNsaXBwZWQgPT09IDEgPyAxIDogMztcbiAgICAgICAgICAgICAgY2FsbGJhY2tzW3RvZ2dsZVN0YXRlXSAmJiBfY2FsbGJhY2soc2VsZiwgY2FsbGJhY2tzW3RvZ2dsZVN0YXRlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZhc3RTY3JvbGxFbmQgJiYgIWlzQWN0aXZlICYmIE1hdGguYWJzKHNlbGYuZ2V0VmVsb2NpdHkoKSkgPiAoX2lzTnVtYmVyKGZhc3RTY3JvbGxFbmQpID8gZmFzdFNjcm9sbEVuZCA6IDI1MDApKSB7XG4gICAgICAgICAgICBfZW5kQW5pbWF0aW9uKHNlbGYuY2FsbGJhY2tBbmltYXRpb24pO1xuXG4gICAgICAgICAgICBzY3J1YlR3ZWVuID8gc2NydWJUd2Vlbi5wcm9ncmVzcygxKSA6IF9lbmRBbmltYXRpb24oYW5pbWF0aW9uLCBhY3Rpb24gPT09IFwicmV2ZXJzZVwiID8gMSA6ICFjbGlwcGVkLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNUb2dnbGUgJiYgb25VcGRhdGUgJiYgIV9yZWZyZXNoaW5nKSB7XG4gICAgICAgICAgb25VcGRhdGUoc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gdXBkYXRlIGFic29sdXRlbHktcG9zaXRpb25lZCBtYXJrZXJzIChvbmx5IGlmIHRoZSBzY3JvbGxlciBpc24ndCB0aGUgdmlld3BvcnQpXG5cblxuICAgICAgaWYgKG1hcmtlckVuZFNldHRlcikge1xuICAgICAgICB2YXIgbiA9IGNvbnRhaW5lckFuaW1hdGlvbiA/IHNjcm9sbCAvIGNvbnRhaW5lckFuaW1hdGlvbi5kdXJhdGlvbigpICogKGNvbnRhaW5lckFuaW1hdGlvbi5fY2FTY3JvbGxEaXN0IHx8IDApIDogc2Nyb2xsO1xuICAgICAgICBtYXJrZXJTdGFydFNldHRlcihuICsgKG1hcmtlclN0YXJ0VHJpZ2dlci5faXNGbGlwcGVkID8gMSA6IDApKTtcbiAgICAgICAgbWFya2VyRW5kU2V0dGVyKG4pO1xuICAgICAgfVxuXG4gICAgICBjYU1hcmtlclNldHRlciAmJiBjYU1hcmtlclNldHRlcigtc2Nyb2xsIC8gY29udGFpbmVyQW5pbWF0aW9uLmR1cmF0aW9uKCkgKiAoY29udGFpbmVyQW5pbWF0aW9uLl9jYVNjcm9sbERpc3QgfHwgMCkpO1xuICAgIH07XG5cbiAgICBzZWxmLmVuYWJsZSA9IGZ1bmN0aW9uIChyZXNldCwgcmVmcmVzaCkge1xuICAgICAgaWYgKCFzZWxmLmVuYWJsZWQpIHtcbiAgICAgICAgc2VsZi5lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICBfYWRkTGlzdGVuZXIoc2Nyb2xsZXIsIFwicmVzaXplXCIsIF9vblJlc2l6ZSk7XG5cbiAgICAgICAgaXNWaWV3cG9ydCB8fCBfYWRkTGlzdGVuZXIoc2Nyb2xsZXIsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG4gICAgICAgIG9uUmVmcmVzaEluaXQgJiYgX2FkZExpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwicmVmcmVzaEluaXRcIiwgb25SZWZyZXNoSW5pdCk7XG5cbiAgICAgICAgaWYgKHJlc2V0ICE9PSBmYWxzZSkge1xuICAgICAgICAgIHNlbGYucHJvZ3Jlc3MgPSBwcmV2UHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgIHNjcm9sbDEgPSBzY3JvbGwyID0gbGFzdFNuYXAgPSBzY3JvbGxGdW5jKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZWZyZXNoICE9PSBmYWxzZSAmJiBzZWxmLnJlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5nZXRUd2VlbiA9IGZ1bmN0aW9uIChzbmFwKSB7XG4gICAgICByZXR1cm4gc25hcCAmJiB0d2VlblRvID8gdHdlZW5Uby50d2VlbiA6IHNjcnViVHdlZW47XG4gICAgfTtcblxuICAgIHNlbGYuc2V0UG9zaXRpb25zID0gZnVuY3Rpb24gKG5ld1N0YXJ0LCBuZXdFbmQsIGtlZXBDbGFtcCwgcGluT2Zmc2V0KSB7XG4gICAgICAvLyBkb2Vzbid0IHBlcnNpc3QgYWZ0ZXIgcmVmcmVzaCgpISBJbnRlbmRlZCB0byBiZSBhIHdheSB0byBvdmVycmlkZSB2YWx1ZXMgdGhhdCB3ZXJlIHNldCBkdXJpbmcgcmVmcmVzaCgpLCBsaWtlIHlvdSBjb3VsZCBzZXQgaXQgaW4gb25SZWZyZXNoKClcbiAgICAgIGlmIChjb250YWluZXJBbmltYXRpb24pIHtcbiAgICAgICAgLy8gY29udmVydCByYXRpb3MgaW50byBzY3JvbGwgcG9zaXRpb25zLiBSZW1lbWJlciwgc3RhcnQvZW5kIHZhbHVlcyBvbiBTY3JvbGxUcmlnZ2VycyB0aGF0IGhhdmUgYSBjb250YWluZXJBbmltYXRpb24gcmVmZXIgdG8gdGhlIHRpbWUgKGluIHNlY29uZHMpLCBOT1Qgc2Nyb2xsIHBvc2l0aW9ucy5cbiAgICAgICAgdmFyIHN0ID0gY29udGFpbmVyQW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIsXG4gICAgICAgICAgICBkdXJhdGlvbiA9IGNvbnRhaW5lckFuaW1hdGlvbi5kdXJhdGlvbigpLFxuICAgICAgICAgICAgX2NoYW5nZSA9IHN0LmVuZCAtIHN0LnN0YXJ0O1xuXG4gICAgICAgIG5ld1N0YXJ0ID0gc3Quc3RhcnQgKyBfY2hhbmdlICogbmV3U3RhcnQgLyBkdXJhdGlvbjtcbiAgICAgICAgbmV3RW5kID0gc3Quc3RhcnQgKyBfY2hhbmdlICogbmV3RW5kIC8gZHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIHNlbGYucmVmcmVzaChmYWxzZSwgZmFsc2UsIHtcbiAgICAgICAgc3RhcnQ6IF9rZWVwQ2xhbXAobmV3U3RhcnQsIGtlZXBDbGFtcCAmJiAhIXNlbGYuX3N0YXJ0Q2xhbXApLFxuICAgICAgICBlbmQ6IF9rZWVwQ2xhbXAobmV3RW5kLCBrZWVwQ2xhbXAgJiYgISFzZWxmLl9lbmRDbGFtcClcbiAgICAgIH0sIHBpbk9mZnNldCk7XG4gICAgICBzZWxmLnVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICBzZWxmLmFkanVzdFBpblNwYWNpbmcgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICBpZiAoc3BhY2VyU3RhdGUgJiYgYW1vdW50KSB7XG4gICAgICAgIHZhciBpID0gc3BhY2VyU3RhdGUuaW5kZXhPZihkaXJlY3Rpb24uZCkgKyAxO1xuICAgICAgICBzcGFjZXJTdGF0ZVtpXSA9IHBhcnNlRmxvYXQoc3BhY2VyU3RhdGVbaV0pICsgYW1vdW50ICsgX3B4O1xuICAgICAgICBzcGFjZXJTdGF0ZVsxXSA9IHBhcnNlRmxvYXQoc3BhY2VyU3RhdGVbMV0pICsgYW1vdW50ICsgX3B4O1xuXG4gICAgICAgIF9zZXRTdGF0ZShzcGFjZXJTdGF0ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbGYuZGlzYWJsZSA9IGZ1bmN0aW9uIChyZXNldCwgYWxsb3dBbmltYXRpb24pIHtcbiAgICAgIGlmIChzZWxmLmVuYWJsZWQpIHtcbiAgICAgICAgcmVzZXQgIT09IGZhbHNlICYmIHNlbGYucmV2ZXJ0KHRydWUsIHRydWUpO1xuICAgICAgICBzZWxmLmVuYWJsZWQgPSBzZWxmLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGFsbG93QW5pbWF0aW9uIHx8IHNjcnViVHdlZW4gJiYgc2NydWJUd2Vlbi5wYXVzZSgpO1xuICAgICAgICBwcmV2U2Nyb2xsID0gMDtcbiAgICAgICAgcGluQ2FjaGUgJiYgKHBpbkNhY2hlLnVuY2FjaGUgPSAxKTtcbiAgICAgICAgb25SZWZyZXNoSW5pdCAmJiBfcmVtb3ZlTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJyZWZyZXNoSW5pdFwiLCBvblJlZnJlc2hJbml0KTtcblxuICAgICAgICBpZiAoc25hcERlbGF5ZWRDYWxsKSB7XG4gICAgICAgICAgc25hcERlbGF5ZWRDYWxsLnBhdXNlKCk7XG4gICAgICAgICAgdHdlZW5Uby50d2VlbiAmJiB0d2VlblRvLnR3ZWVuLmtpbGwoKSAmJiAodHdlZW5Uby50d2VlbiA9IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1ZpZXdwb3J0KSB7XG4gICAgICAgICAgdmFyIGkgPSBfdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgaWYgKF90cmlnZ2Vyc1tpXS5zY3JvbGxlciA9PT0gc2Nyb2xsZXIgJiYgX3RyaWdnZXJzW2ldICE9PSBzZWxmKSB7XG4gICAgICAgICAgICAgIHJldHVybjsgLy9kb24ndCByZW1vdmUgdGhlIGxpc3RlbmVycyBpZiB0aGVyZSBhcmUgc3RpbGwgb3RoZXIgdHJpZ2dlcnMgcmVmZXJlbmNpbmcgaXQuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHNjcm9sbGVyLCBcInJlc2l6ZVwiLCBfb25SZXNpemUpO1xuXG4gICAgICAgICAgaXNWaWV3cG9ydCB8fCBfcmVtb3ZlTGlzdGVuZXIoc2Nyb2xsZXIsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5raWxsID0gZnVuY3Rpb24gKHJldmVydCwgYWxsb3dBbmltYXRpb24pIHtcbiAgICAgIHNlbGYuZGlzYWJsZShyZXZlcnQsIGFsbG93QW5pbWF0aW9uKTtcbiAgICAgIHNjcnViVHdlZW4gJiYgIWFsbG93QW5pbWF0aW9uICYmIHNjcnViVHdlZW4ua2lsbCgpO1xuICAgICAgaWQgJiYgZGVsZXRlIF9pZHNbaWRdO1xuXG4gICAgICB2YXIgaSA9IF90cmlnZ2Vycy5pbmRleE9mKHNlbGYpO1xuXG4gICAgICBpID49IDAgJiYgX3RyaWdnZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIGkgPT09IF9pICYmIF9kaXJlY3Rpb24gPiAwICYmIF9pLS07IC8vIGlmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSByZWZyZXNoKCkgb3IgdXBkYXRlKCksIHNwbGljaW5nIHdvdWxkIGNhdXNlIHNraXBzIGluIHRoZSBpbmRleCwgc28gYWRqdXN0Li4uXG4gICAgICAvLyBpZiBubyBvdGhlciBTY3JvbGxUcmlnZ2VyIGluc3RhbmNlcyBvZiB0aGUgc2FtZSBzY3JvbGxlciBhcmUgZm91bmQsIHdpcGUgb3V0IGFueSByZWNvcmRlZCBzY3JvbGwgcG9zaXRpb24uIE90aGVyd2lzZSwgaW4gYSBzaW5nbGUgcGFnZSBhcHBsaWNhdGlvbiwgZm9yIGV4YW1wbGUsIGl0IGNvdWxkIG1haW50YWluIHNjcm9sbCBwb3NpdGlvbiB3aGVuIGl0IHJlYWxseSBzaG91bGRuJ3QuXG5cbiAgICAgIGkgPSAwO1xuXG4gICAgICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5zY3JvbGxlciA9PT0gc2VsZi5zY3JvbGxlciAmJiAoaSA9IDEpO1xuICAgICAgfSk7XG5cbiAgICAgIGkgfHwgX3JlZnJlc2hpbmdBbGwgfHwgKHNlbGYuc2Nyb2xsLnJlYyA9IDApO1xuXG4gICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIGFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyID0gbnVsbDtcbiAgICAgICAgcmV2ZXJ0ICYmIGFuaW1hdGlvbi5yZXZlcnQoe1xuICAgICAgICAgIGtpbGw6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBhbGxvd0FuaW1hdGlvbiB8fCBhbmltYXRpb24ua2lsbCgpO1xuICAgICAgfVxuXG4gICAgICBtYXJrZXJTdGFydCAmJiBbbWFya2VyU3RhcnQsIG1hcmtlckVuZCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiBtLnBhcmVudE5vZGUgJiYgbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG0pO1xuICAgICAgfSk7XG4gICAgICBfcHJpbWFyeSA9PT0gc2VsZiAmJiAoX3ByaW1hcnkgPSAwKTtcblxuICAgICAgaWYgKHBpbikge1xuICAgICAgICBwaW5DYWNoZSAmJiAocGluQ2FjaGUudW5jYWNoZSA9IDEpO1xuICAgICAgICBpID0gMDtcblxuICAgICAgICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0LnBpbiA9PT0gcGluICYmIGkrKztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaSB8fCAocGluQ2FjaGUuc3BhY2VyID0gMCk7IC8vIGlmIHRoZXJlIGFyZW4ndCBhbnkgbW9yZSBTY3JvbGxUcmlnZ2VycyB3aXRoIHRoZSBzYW1lIHBpbiwgcmVtb3ZlIHRoZSBzcGFjZXIsIG90aGVyd2lzZSBpdCBjb3VsZCBiZSBjb250YW1pbmF0ZWQgd2l0aCBvbGQvc3RhbGUgdmFsdWVzIGlmIHRoZSB1c2VyIHJlLWNyZWF0ZXMgYSBTY3JvbGxUcmlnZ2VyIGZvciB0aGUgc2FtZSBlbGVtZW50LlxuICAgICAgfVxuXG4gICAgICB2YXJzLm9uS2lsbCAmJiB2YXJzLm9uS2lsbChzZWxmKTtcbiAgICB9O1xuXG4gICAgX3RyaWdnZXJzLnB1c2goc2VsZik7XG5cbiAgICBzZWxmLmVuYWJsZShmYWxzZSwgZmFsc2UpO1xuICAgIGN1c3RvbVJldmVydFJldHVybiAmJiBjdXN0b21SZXZlcnRSZXR1cm4oc2VsZik7XG5cbiAgICBpZiAoYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5hZGQgJiYgIWNoYW5nZSkge1xuICAgICAgLy8gaWYgdGhlIGFuaW1hdGlvbiBpcyBhIHRpbWVsaW5lLCBpdCBtYXkgbm90IGhhdmUgYmVlbiBwb3B1bGF0ZWQgeWV0LCBzbyBpdCB3b3VsZG4ndCByZW5kZXIgYXQgdGhlIHByb3BlciBwbGFjZSBvbiB0aGUgZmlyc3QgcmVmcmVzaCgpLCB0aHVzIHdlIHNob3VsZCBzY2hlZHVsZSBvbmUgZm9yIHRoZSBuZXh0IHRpY2suIElmIFwiY2hhbmdlXCIgaXMgZGVmaW5lZCwgd2Uga25vdyBpdCBtdXN0IGJlIHJlLWVuYWJsaW5nLCB0aHVzIHdlIGNhbiByZWZyZXNoKCkgcmlnaHQgYXdheS5cbiAgICAgIHZhciB1cGRhdGVGdW5jID0gc2VsZi51cGRhdGU7IC8vIHNvbWUgYnJvd3NlcnMgbWF5IGZpcmUgYSBzY3JvbGwgZXZlbnQgQkVGT1JFIGEgdGljayBlbGFwc2VzIGFuZC9vciB0aGUgRE9NQ29udGVudExvYWRlZCBmaXJlcy4gU28gdGhlcmUncyBhIGNoYW5jZSB1cGRhdGUoKSB3aWxsIGJlIGNhbGxlZCBCRUZPUkUgYSByZWZyZXNoKCkgaGFzIGhhcHBlbmVkIG9uIGEgVGltZWxpbmUtYXR0YWNoZWQgU2Nyb2xsVHJpZ2dlciB3aGljaCBtZWFucyB0aGUgc3RhcnQvZW5kIHdvbid0IGJlIGNhbGN1bGF0ZWQgeWV0LiBXZSBkb24ndCB3YW50IHRvIGFkZCBjb25kaXRpb25hbCBsb2dpYyBpbnNpZGUgdGhlIHVwZGF0ZSgpIG1ldGhvZCAobGlrZSBjaGVjayB0byBzZWUgaWYgZW5kIGlzIGRlZmluZWQgYW5kIGlmIG5vdCwgZm9yY2UgYSByZWZyZXNoKCkpIGJlY2F1c2UgdGhhdCdzIGEgZnVuY3Rpb24gdGhhdCBnZXRzIGhpdCBhIExPVCAocGVyZm9ybWFuY2UpLiBTbyB3ZSBzd2FwIG91dCB0aGUgcmVhbCB1cGRhdGUoKSBtZXRob2QgZm9yIHRoaXMgb25lIHRoYXQnbGwgcmUtYXR0YWNoIGl0IHRoZSBmaXJzdCB0aW1lIGl0IGdldHMgY2FsbGVkIGFuZCBvZiBjb3Vyc2UgZm9yY2VzIGEgcmVmcmVzaCgpLlxuXG4gICAgICBzZWxmLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi51cGRhdGUgPSB1cGRhdGVGdW5jO1xuICAgICAgICBzdGFydCB8fCBlbmQgfHwgc2VsZi5yZWZyZXNoKCk7XG4gICAgICB9O1xuXG4gICAgICBnc2FwLmRlbGF5ZWRDYWxsKDAuMDEsIHNlbGYudXBkYXRlKTtcbiAgICAgIGNoYW5nZSA9IDAuMDE7XG4gICAgICBzdGFydCA9IGVuZCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYucmVmcmVzaCgpO1xuICAgIH1cblxuICAgIHBpbiAmJiBfcXVldWVSZWZyZXNoQWxsKCk7IC8vIHBpbm5pbmcgY291bGQgYWZmZWN0IHRoZSBwb3NpdGlvbnMgb2Ygb3RoZXIgdGhpbmdzLCBzbyBtYWtlIHN1cmUgd2UgcXVldWUgYSBmdWxsIHJlZnJlc2goKVxuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3Rlcihjb3JlKSB7XG4gICAgaWYgKCFfY29yZUluaXR0ZWQpIHtcbiAgICAgIGdzYXAgPSBjb3JlIHx8IF9nZXRHU0FQKCk7XG4gICAgICBfd2luZG93RXhpc3RzKCkgJiYgd2luZG93LmRvY3VtZW50ICYmIFNjcm9sbFRyaWdnZXIuZW5hYmxlKCk7XG4gICAgICBfY29yZUluaXR0ZWQgPSBfZW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gX2NvcmVJbml0dGVkO1xuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuZGVmYXVsdHMgPSBmdW5jdGlvbiBkZWZhdWx0cyhjb25maWcpIHtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGNvbmZpZykge1xuICAgICAgICBfZGVmYXVsdHNbcF0gPSBjb25maWdbcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9kZWZhdWx0cztcbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKHJlc2V0LCBraWxsKSB7XG4gICAgX2VuYWJsZWQgPSAwO1xuXG4gICAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyaWdnZXIpIHtcbiAgICAgIHJldHVybiB0cmlnZ2VyW2tpbGwgPyBcImtpbGxcIiA6IFwiZGlzYWJsZVwiXShyZXNldCk7XG4gICAgfSk7XG5cbiAgICBfcmVtb3ZlTGlzdGVuZXIoX3dpbiwgXCJ3aGVlbFwiLCBfb25TY3JvbGwpO1xuXG4gICAgX3JlbW92ZUxpc3RlbmVyKF9kb2MsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG5cbiAgICBjbGVhckludGVydmFsKF9zeW5jSW50ZXJ2YWwpO1xuXG4gICAgX3JlbW92ZUxpc3RlbmVyKF9kb2MsIFwidG91Y2hjYW5jZWxcIiwgX3Bhc3NUaHJvdWdoKTtcblxuICAgIF9yZW1vdmVMaXN0ZW5lcihfYm9keSwgXCJ0b3VjaHN0YXJ0XCIsIF9wYXNzVGhyb3VnaCk7XG5cbiAgICBfbXVsdGlMaXN0ZW5lcihfcmVtb3ZlTGlzdGVuZXIsIF9kb2MsIFwicG9pbnRlcmRvd24sdG91Y2hzdGFydCxtb3VzZWRvd25cIiwgX3BvaW50ZXJEb3duSGFuZGxlcik7XG5cbiAgICBfbXVsdGlMaXN0ZW5lcihfcmVtb3ZlTGlzdGVuZXIsIF9kb2MsIFwicG9pbnRlcnVwLHRvdWNoZW5kLG1vdXNldXBcIiwgX3BvaW50ZXJVcEhhbmRsZXIpO1xuXG4gICAgX3Jlc2l6ZURlbGF5LmtpbGwoKTtcblxuICAgIF9pdGVyYXRlQXV0b1JlZnJlc2goX3JlbW92ZUxpc3RlbmVyKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3Njcm9sbGVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgX3doZWVsTGlzdGVuZXIoX3JlbW92ZUxpc3RlbmVyLCBfc2Nyb2xsZXJzW2ldLCBfc2Nyb2xsZXJzW2kgKyAxXSk7XG5cbiAgICAgIF93aGVlbExpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX3Njcm9sbGVyc1tpXSwgX3Njcm9sbGVyc1tpICsgMl0pO1xuICAgIH1cbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICBfd2luID0gd2luZG93O1xuICAgIF9kb2MgPSBkb2N1bWVudDtcbiAgICBfZG9jRWwgPSBfZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICBfYm9keSA9IF9kb2MuYm9keTtcblxuICAgIGlmIChnc2FwKSB7XG4gICAgICBfdG9BcnJheSA9IGdzYXAudXRpbHMudG9BcnJheTtcbiAgICAgIF9jbGFtcCA9IGdzYXAudXRpbHMuY2xhbXA7XG4gICAgICBfY29udGV4dCA9IGdzYXAuY29yZS5jb250ZXh0IHx8IF9wYXNzVGhyb3VnaDtcbiAgICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMgPSBnc2FwLmNvcmUuc3VwcHJlc3NPdmVyd3JpdGVzIHx8IF9wYXNzVGhyb3VnaDtcbiAgICAgIF9zY3JvbGxSZXN0b3JhdGlvbiA9IF93aW4uaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiB8fCBcImF1dG9cIjtcbiAgICAgIF9sYXN0U2Nyb2xsID0gX3dpbi5wYWdlWU9mZnNldDtcbiAgICAgIGdzYXAuY29yZS5nbG9iYWxzKFwiU2Nyb2xsVHJpZ2dlclwiLCBTY3JvbGxUcmlnZ2VyKTsgLy8gbXVzdCByZWdpc3RlciB0aGUgZ2xvYmFsIG1hbnVhbGx5IGJlY2F1c2UgaW4gSW50ZXJuZXQgRXhwbG9yZXIsIGZ1bmN0aW9ucyAoY2xhc3NlcykgZG9uJ3QgaGF2ZSBhIFwibmFtZVwiIHByb3BlcnR5LlxuXG4gICAgICBpZiAoX2JvZHkpIHtcbiAgICAgICAgX2VuYWJsZWQgPSAxO1xuICAgICAgICBfZGl2MTAwdmggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpOyAvLyB0byBzb2x2ZSBtb2JpbGUgYnJvd3NlciBhZGRyZXNzIGJhciBzaG93L2hpZGUgcmVzaXppbmcsIHdlIHNob3VsZG4ndCByZWx5IG9uIHdpbmRvdy5pbm5lckhlaWdodC4gSW5zdGVhZCwgdXNlIGEgPGRpdj4gd2l0aCBpdHMgaGVpZ2h0IHNldCB0byAxMDB2aCBhbmQgbWVhc3VyZSB0aGF0IHNpbmNlIHRoYXQncyB3aGF0IHRoZSBzY3JvbGxpbmcgaXMgYmFzZWQgb24gYW55d2F5IGFuZCBpdCdzIG5vdCBhZmZlY3RlZCBieSBhZGRyZXNzIGJhciBzaG93aW5nL2hpZGluZy5cblxuICAgICAgICBfZGl2MTAwdmguc3R5bGUuaGVpZ2h0ID0gXCIxMDB2aFwiO1xuICAgICAgICBfZGl2MTAwdmguc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cbiAgICAgICAgX3JlZnJlc2gxMDB2aCgpO1xuXG4gICAgICAgIF9yYWZCdWdGaXgoKTtcblxuICAgICAgICBPYnNlcnZlci5yZWdpc3Rlcihnc2FwKTsgLy8gaXNUb3VjaCBpcyAwIGlmIG5vIHRvdWNoLCAxIGlmIE9OTFkgdG91Y2gsIGFuZCAyIGlmIGl0IGNhbiBhY2NvbW1vZGF0ZSB0b3VjaCBidXQgYWxzbyBvdGhlciB0eXBlcyBsaWtlIG1vdXNlL3BvaW50ZXIuXG5cbiAgICAgICAgU2Nyb2xsVHJpZ2dlci5pc1RvdWNoID0gT2JzZXJ2ZXIuaXNUb3VjaDtcbiAgICAgICAgX2ZpeElPU0J1ZyA9IE9ic2VydmVyLmlzVG91Y2ggJiYgLyhpUGFkfGlQaG9uZXxpUG9kfE1hYykvZy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyBzaW5jZSAyMDE3LCBpT1MgaGFzIGhhZCBhIGJ1ZyB0aGF0IGNhdXNlcyBldmVudC5jbGllbnRYL1kgdG8gYmUgaW5hY2N1cmF0ZSB3aGVuIGEgc2Nyb2xsIG9jY3VycywgdGh1cyB3ZSBtdXN0IGFsdGVybmF0ZSBpZ25vcmluZyBldmVyeSBvdGhlciB0b3VjaG1vdmUgZXZlbnQgdG8gd29yayBhcm91bmQgaXQuIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTgxOTU0IGFuZCBodHRwczovL2NvZGVwZW4uaW8vR3JlZW5Tb2NrL3Blbi9FeGJyUE5hLzA4N2NlZjE5N2RjMzU0NDVhMDk1MWU4OTM1YzQxNTAzXG5cbiAgICAgICAgX2lnbm9yZU1vYmlsZVJlc2l6ZSA9IE9ic2VydmVyLmlzVG91Y2ggPT09IDE7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKF93aW4sIFwid2hlZWxcIiwgX29uU2Nyb2xsKTsgLy8gbW9zdGx5IGZvciAzcmQgcGFydHkgc21vb3RoIHNjcm9sbGluZyBsaWJyYXJpZXMuXG5cblxuICAgICAgICBfcm9vdCA9IFtfd2luLCBfZG9jLCBfZG9jRWwsIF9ib2R5XTtcblxuICAgICAgICBpZiAoZ3NhcC5tYXRjaE1lZGlhKSB7XG4gICAgICAgICAgU2Nyb2xsVHJpZ2dlci5tYXRjaE1lZGlhID0gZnVuY3Rpb24gKHZhcnMpIHtcbiAgICAgICAgICAgIHZhciBtbSA9IGdzYXAubWF0Y2hNZWRpYSgpLFxuICAgICAgICAgICAgICAgIHA7XG5cbiAgICAgICAgICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICAgICAgICAgIG1tLmFkZChwLCB2YXJzW3BdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1tO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBnc2FwLmFkZEV2ZW50TGlzdGVuZXIoXCJtYXRjaE1lZGlhSW5pdFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JldmVydEFsbCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGdzYXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1hdGNoTWVkaWFSZXZlcnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZXZlcnRSZWNvcmRlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGdzYXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1hdGNoTWVkaWFcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3JlZnJlc2hBbGwoMCwgMSk7XG5cbiAgICAgICAgICAgIF9kaXNwYXRjaChcIm1hdGNoTWVkaWFcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZ3NhcC5tYXRjaE1lZGlhKFwiKG9yaWVudGF0aW9uOiBwb3J0cmFpdClcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gd2hlbiBvcmllbnRhdGlvbiBjaGFuZ2VzLCB3ZSBzaG91bGQgdGFrZSBuZXcgYmFzZSBtZWFzdXJlbWVudHMgZm9yIHRoZSBpZ25vcmVNb2JpbGVSZXNpemUgZmVhdHVyZS5cbiAgICAgICAgICAgIF9zZXRCYXNlRGltZW5zaW9ucygpO1xuXG4gICAgICAgICAgICByZXR1cm4gX3NldEJhc2VEaW1lbnNpb25zO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlJlcXVpcmVzIEdTQVAgMy4xMS4wIG9yIGxhdGVyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3NldEJhc2VEaW1lbnNpb25zKCk7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKF9kb2MsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7IC8vIHNvbWUgYnJvd3NlcnMgKGxpa2UgQ2hyb21lKSwgdGhlIHdpbmRvdyBzdG9wcyBkaXNwYXRjaGluZyBzY3JvbGwgZXZlbnRzIG9uIHRoZSB3aW5kb3cgaWYgeW91IHNjcm9sbCByZWFsbHkgZmFzdCwgYnV0IGl0J3MgY29uc2lzdGVudCBvbiB0aGUgZG9jdW1lbnQhXG5cblxuICAgICAgICB2YXIgYm9keVN0eWxlID0gX2JvZHkuc3R5bGUsXG4gICAgICAgICAgICBib3JkZXIgPSBib2R5U3R5bGUuYm9yZGVyVG9wU3R5bGUsXG4gICAgICAgICAgICBBbmltYXRpb25Qcm90byA9IGdzYXAuY29yZS5BbmltYXRpb24ucHJvdG90eXBlLFxuICAgICAgICAgICAgYm91bmRzLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgQW5pbWF0aW9uUHJvdG8ucmV2ZXJ0IHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRpb25Qcm90bywgXCJyZXZlcnRcIiwge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbWUoLTAuMDEsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IChBbmltYXRpb24ucmV2ZXJ0KCkgd2FzIGFkZGVkIGFmdGVyIDMuMTAuNClcblxuICAgICAgICBib2R5U3R5bGUuYm9yZGVyVG9wU3R5bGUgPSBcInNvbGlkXCI7IC8vIHdvcmtzIGFyb3VuZCBhbiBpc3N1ZSB3aGVyZSBhIG1hcmdpbiBvZiBhIGNoaWxkIGVsZW1lbnQgY291bGQgdGhyb3cgb2ZmIHRoZSBib3VuZHMgb2YgdGhlIF9ib2R5LCBtYWtpbmcgaXQgc2VlbSBsaWtlIHRoZXJlJ3MgYSBtYXJnaW4gd2hlbiB0aGVyZSBhY3R1YWxseSBpc24ndC4gVGhlIGJvcmRlciBlbnN1cmVzIHRoYXQgdGhlIGJvdW5kcyBhcmUgYWNjdXJhdGUuXG5cbiAgICAgICAgYm91bmRzID0gX2dldEJvdW5kcyhfYm9keSk7XG4gICAgICAgIF92ZXJ0aWNhbC5tID0gTWF0aC5yb3VuZChib3VuZHMudG9wICsgX3ZlcnRpY2FsLnNjKCkpIHx8IDA7IC8vIGFjY29tbW9kYXRlIHRoZSBvZmZzZXQgb2YgdGhlIDxib2R5PiBjYXVzZWQgYnkgbWFyZ2lucyBhbmQvb3IgcGFkZGluZ1xuXG4gICAgICAgIF9ob3Jpem9udGFsLm0gPSBNYXRoLnJvdW5kKGJvdW5kcy5sZWZ0ICsgX2hvcml6b250YWwuc2MoKSkgfHwgMDtcbiAgICAgICAgYm9yZGVyID8gYm9keVN0eWxlLmJvcmRlclRvcFN0eWxlID0gYm9yZGVyIDogYm9keVN0eWxlLnJlbW92ZVByb3BlcnR5KFwiYm9yZGVyLXRvcC1zdHlsZVwiKTsgLy8gVE9ETzogKD8pIG1heWJlIG1vdmUgdG8gbGV2ZXJhZ2luZyB0aGUgdmVsb2NpdHkgbWVjaGFuaXNtIGluIE9ic2VydmVyIGFuZCBza2lwIGludGVydmFscy5cblxuICAgICAgICBfc3luY0ludGVydmFsID0gc2V0SW50ZXJ2YWwoX3N5bmMsIDI1MCk7XG4gICAgICAgIGdzYXAuZGVsYXllZENhbGwoMC41LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF9zdGFydHVwID0gMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKF9kb2MsIFwidG91Y2hjYW5jZWxcIiwgX3Bhc3NUaHJvdWdoKTsgLy8gc29tZSBvbGRlciBBbmRyb2lkIGRldmljZXMgaW50ZXJtaXR0ZW50bHkgc3RvcCBkaXNwYXRjaGluZyBcInRvdWNobW92ZVwiIGV2ZW50cyBpZiB3ZSBkb24ndCBsaXN0ZW4gZm9yIFwidG91Y2hjYW5jZWxcIiBvbiB0aGUgZG9jdW1lbnQuXG5cblxuICAgICAgICBfYWRkTGlzdGVuZXIoX2JvZHksIFwidG91Y2hzdGFydFwiLCBfcGFzc1Rocm91Z2gpOyAvL3dvcmtzIGFyb3VuZCBTYWZhcmkgYnVnOiBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8yMTQ1MC1kcmFnZ2FibGUtaW4taWZyYW1lLW9uLW1vYmlsZS1pcy1idWdneS9cblxuXG4gICAgICAgIF9tdWx0aUxpc3RlbmVyKF9hZGRMaXN0ZW5lciwgX2RvYywgXCJwb2ludGVyZG93bix0b3VjaHN0YXJ0LG1vdXNlZG93blwiLCBfcG9pbnRlckRvd25IYW5kbGVyKTtcblxuICAgICAgICBfbXVsdGlMaXN0ZW5lcihfYWRkTGlzdGVuZXIsIF9kb2MsIFwicG9pbnRlcnVwLHRvdWNoZW5kLG1vdXNldXBcIiwgX3BvaW50ZXJVcEhhbmRsZXIpO1xuXG4gICAgICAgIF90cmFuc2Zvcm1Qcm9wID0gZ3NhcC51dGlscy5jaGVja1ByZWZpeChcInRyYW5zZm9ybVwiKTtcblxuICAgICAgICBfc3RhdGVQcm9wcy5wdXNoKF90cmFuc2Zvcm1Qcm9wKTtcblxuICAgICAgICBfY29yZUluaXR0ZWQgPSBfZ2V0VGltZSgpO1xuICAgICAgICBfcmVzaXplRGVsYXkgPSBnc2FwLmRlbGF5ZWRDYWxsKDAuMiwgX3JlZnJlc2hBbGwpLnBhdXNlKCk7XG4gICAgICAgIF9hdXRvUmVmcmVzaCA9IFtfZG9jLCBcInZpc2liaWxpdHljaGFuZ2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB3ID0gX3dpbi5pbm5lcldpZHRoLFxuICAgICAgICAgICAgICBoID0gX3dpbi5pbm5lckhlaWdodDtcblxuICAgICAgICAgIGlmIChfZG9jLmhpZGRlbikge1xuICAgICAgICAgICAgX3ByZXZXaWR0aCA9IHc7XG4gICAgICAgICAgICBfcHJldkhlaWdodCA9IGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChfcHJldldpZHRoICE9PSB3IHx8IF9wcmV2SGVpZ2h0ICE9PSBoKSB7XG4gICAgICAgICAgICBfb25SZXNpemUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9kb2MsIFwiRE9NQ29udGVudExvYWRlZFwiLCBfcmVmcmVzaEFsbCwgX3dpbiwgXCJsb2FkXCIsIF9yZWZyZXNoQWxsLCBfd2luLCBcInJlc2l6ZVwiLCBfb25SZXNpemVdO1xuXG4gICAgICAgIF9pdGVyYXRlQXV0b1JlZnJlc2goX2FkZExpc3RlbmVyKTtcblxuICAgICAgICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJpZ2dlcikge1xuICAgICAgICAgIHJldHVybiB0cmlnZ2VyLmVuYWJsZSgwLCAxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IF9zY3JvbGxlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICBfd2hlZWxMaXN0ZW5lcihfcmVtb3ZlTGlzdGVuZXIsIF9zY3JvbGxlcnNbaV0sIF9zY3JvbGxlcnNbaSArIDFdKTtcblxuICAgICAgICAgIF93aGVlbExpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX3Njcm9sbGVyc1tpXSwgX3Njcm9sbGVyc1tpICsgMl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuY29uZmlnID0gZnVuY3Rpb24gY29uZmlnKHZhcnMpIHtcbiAgICBcImxpbWl0Q2FsbGJhY2tzXCIgaW4gdmFycyAmJiAoX2xpbWl0Q2FsbGJhY2tzID0gISF2YXJzLmxpbWl0Q2FsbGJhY2tzKTtcbiAgICB2YXIgbXMgPSB2YXJzLnN5bmNJbnRlcnZhbDtcbiAgICBtcyAmJiBjbGVhckludGVydmFsKF9zeW5jSW50ZXJ2YWwpIHx8IChfc3luY0ludGVydmFsID0gbXMpICYmIHNldEludGVydmFsKF9zeW5jLCBtcyk7XG4gICAgXCJpZ25vcmVNb2JpbGVSZXNpemVcIiBpbiB2YXJzICYmIChfaWdub3JlTW9iaWxlUmVzaXplID0gU2Nyb2xsVHJpZ2dlci5pc1RvdWNoID09PSAxICYmIHZhcnMuaWdub3JlTW9iaWxlUmVzaXplKTtcblxuICAgIGlmIChcImF1dG9SZWZyZXNoRXZlbnRzXCIgaW4gdmFycykge1xuICAgICAgX2l0ZXJhdGVBdXRvUmVmcmVzaChfcmVtb3ZlTGlzdGVuZXIpIHx8IF9pdGVyYXRlQXV0b1JlZnJlc2goX2FkZExpc3RlbmVyLCB2YXJzLmF1dG9SZWZyZXNoRXZlbnRzIHx8IFwibm9uZVwiKTtcbiAgICAgIF9pZ25vcmVSZXNpemUgPSAodmFycy5hdXRvUmVmcmVzaEV2ZW50cyArIFwiXCIpLmluZGV4T2YoXCJyZXNpemVcIikgPT09IC0xO1xuICAgIH1cbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLnNjcm9sbGVyUHJveHkgPSBmdW5jdGlvbiBzY3JvbGxlclByb3h5KHRhcmdldCwgdmFycykge1xuICAgIHZhciB0ID0gX2dldFRhcmdldCh0YXJnZXQpLFxuICAgICAgICBpID0gX3Njcm9sbGVycy5pbmRleE9mKHQpLFxuICAgICAgICBpc1ZpZXdwb3J0ID0gX2lzVmlld3BvcnQodCk7XG5cbiAgICBpZiAofmkpIHtcbiAgICAgIF9zY3JvbGxlcnMuc3BsaWNlKGksIGlzVmlld3BvcnQgPyA2IDogMik7XG4gICAgfVxuXG4gICAgaWYgKHZhcnMpIHtcbiAgICAgIGlzVmlld3BvcnQgPyBfcHJveGllcy51bnNoaWZ0KF93aW4sIHZhcnMsIF9ib2R5LCB2YXJzLCBfZG9jRWwsIHZhcnMpIDogX3Byb3hpZXMudW5zaGlmdCh0LCB2YXJzKTtcbiAgICB9XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5jbGVhck1hdGNoTWVkaWEgPSBmdW5jdGlvbiBjbGVhck1hdGNoTWVkaWEocXVlcnkpIHtcbiAgICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQuX2N0eCAmJiB0Ll9jdHgucXVlcnkgPT09IHF1ZXJ5ICYmIHQuX2N0eC5raWxsKHRydWUsIHRydWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuaXNJblZpZXdwb3J0ID0gZnVuY3Rpb24gaXNJblZpZXdwb3J0KGVsZW1lbnQsIHJhdGlvLCBob3Jpem9udGFsKSB7XG4gICAgdmFyIGJvdW5kcyA9IChfaXNTdHJpbmcoZWxlbWVudCkgPyBfZ2V0VGFyZ2V0KGVsZW1lbnQpIDogZWxlbWVudCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIG9mZnNldCA9IGJvdW5kc1tob3Jpem9udGFsID8gX3dpZHRoIDogX2hlaWdodF0gKiByYXRpbyB8fCAwO1xuICAgIHJldHVybiBob3Jpem9udGFsID8gYm91bmRzLnJpZ2h0IC0gb2Zmc2V0ID4gMCAmJiBib3VuZHMubGVmdCArIG9mZnNldCA8IF93aW4uaW5uZXJXaWR0aCA6IGJvdW5kcy5ib3R0b20gLSBvZmZzZXQgPiAwICYmIGJvdW5kcy50b3AgKyBvZmZzZXQgPCBfd2luLmlubmVySGVpZ2h0O1xuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIucG9zaXRpb25JblZpZXdwb3J0ID0gZnVuY3Rpb24gcG9zaXRpb25JblZpZXdwb3J0KGVsZW1lbnQsIHJlZmVyZW5jZVBvaW50LCBob3Jpem9udGFsKSB7XG4gICAgX2lzU3RyaW5nKGVsZW1lbnQpICYmIChlbGVtZW50ID0gX2dldFRhcmdldChlbGVtZW50KSk7XG4gICAgdmFyIGJvdW5kcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIHNpemUgPSBib3VuZHNbaG9yaXpvbnRhbCA/IF93aWR0aCA6IF9oZWlnaHRdLFxuICAgICAgICBvZmZzZXQgPSByZWZlcmVuY2VQb2ludCA9PSBudWxsID8gc2l6ZSAvIDIgOiByZWZlcmVuY2VQb2ludCBpbiBfa2V5d29yZHMgPyBfa2V5d29yZHNbcmVmZXJlbmNlUG9pbnRdICogc2l6ZSA6IH5yZWZlcmVuY2VQb2ludC5pbmRleE9mKFwiJVwiKSA/IHBhcnNlRmxvYXQocmVmZXJlbmNlUG9pbnQpICogc2l6ZSAvIDEwMCA6IHBhcnNlRmxvYXQocmVmZXJlbmNlUG9pbnQpIHx8IDA7XG4gICAgcmV0dXJuIGhvcml6b250YWwgPyAoYm91bmRzLmxlZnQgKyBvZmZzZXQpIC8gX3dpbi5pbm5lcldpZHRoIDogKGJvdW5kcy50b3AgKyBvZmZzZXQpIC8gX3dpbi5pbm5lckhlaWdodDtcbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLmtpbGxBbGwgPSBmdW5jdGlvbiBraWxsQWxsKGFsbG93TGlzdGVuZXJzKSB7XG4gICAgX3RyaWdnZXJzLnNsaWNlKDApLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0LnZhcnMuaWQgIT09IFwiU2Nyb2xsU21vb3RoZXJcIiAmJiB0LmtpbGwoKTtcbiAgICB9KTtcblxuICAgIGlmIChhbGxvd0xpc3RlbmVycyAhPT0gdHJ1ZSkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IF9saXN0ZW5lcnMua2lsbEFsbCB8fCBbXTtcbiAgICAgIF9saXN0ZW5lcnMgPSB7fTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNjcm9sbFRyaWdnZXI7XG59KCk7XG5TY3JvbGxUcmlnZ2VyLnZlcnNpb24gPSBcIjMuMTIuNVwiO1xuXG5TY3JvbGxUcmlnZ2VyLnNhdmVTdHlsZXMgPSBmdW5jdGlvbiAodGFyZ2V0cykge1xuICByZXR1cm4gdGFyZ2V0cyA/IF90b0FycmF5KHRhcmdldHMpLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIC8vIHNhdmVkIHN0eWxlcyBhcmUgcmVjb3JkZWQgaW4gYSBjb25zZWN1dGl2ZSBhbHRlcm5hdGluZyBBcnJheSwgbGlrZSBbZWxlbWVudCwgY3NzVGV4dCwgdHJhbnNmb3JtIGF0dHJpYnV0ZSwgY2FjaGUsIG1hdGNoTWVkaWEsIC4uLl1cbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5zdHlsZSkge1xuICAgICAgdmFyIGkgPSBfc2F2ZWRTdHlsZXMuaW5kZXhPZih0YXJnZXQpO1xuXG4gICAgICBpID49IDAgJiYgX3NhdmVkU3R5bGVzLnNwbGljZShpLCA1KTtcblxuICAgICAgX3NhdmVkU3R5bGVzLnB1c2godGFyZ2V0LCB0YXJnZXQuc3R5bGUuY3NzVGV4dCwgdGFyZ2V0LmdldEJCb3ggJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKSwgZ3NhcC5jb3JlLmdldENhY2hlKHRhcmdldCksIF9jb250ZXh0KCkpO1xuICAgIH1cbiAgfSkgOiBfc2F2ZWRTdHlsZXM7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLnJldmVydCA9IGZ1bmN0aW9uIChzb2Z0LCBtZWRpYSkge1xuICByZXR1cm4gX3JldmVydEFsbCghc29mdCwgbWVkaWEpO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5jcmVhdGUgPSBmdW5jdGlvbiAodmFycywgYW5pbWF0aW9uKSB7XG4gIHJldHVybiBuZXcgU2Nyb2xsVHJpZ2dlcih2YXJzLCBhbmltYXRpb24pO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5yZWZyZXNoID0gZnVuY3Rpb24gKHNhZmUpIHtcbiAgcmV0dXJuIHNhZmUgPyBfb25SZXNpemUoKSA6IChfY29yZUluaXR0ZWQgfHwgU2Nyb2xsVHJpZ2dlci5yZWdpc3RlcigpKSAmJiBfcmVmcmVzaEFsbCh0cnVlKTtcbn07XG5cblNjcm9sbFRyaWdnZXIudXBkYXRlID0gZnVuY3Rpb24gKGZvcmNlKSB7XG4gIHJldHVybiArK19zY3JvbGxlcnMuY2FjaGUgJiYgX3VwZGF0ZUFsbChmb3JjZSA9PT0gdHJ1ZSA/IDIgOiAwKTtcbn07XG5cblNjcm9sbFRyaWdnZXIuY2xlYXJTY3JvbGxNZW1vcnkgPSBfY2xlYXJTY3JvbGxNZW1vcnk7XG5cblNjcm9sbFRyaWdnZXIubWF4U2Nyb2xsID0gZnVuY3Rpb24gKGVsZW1lbnQsIGhvcml6b250YWwpIHtcbiAgcmV0dXJuIF9tYXhTY3JvbGwoZWxlbWVudCwgaG9yaXpvbnRhbCA/IF9ob3Jpem9udGFsIDogX3ZlcnRpY2FsKTtcbn07XG5cblNjcm9sbFRyaWdnZXIuZ2V0U2Nyb2xsRnVuYyA9IGZ1bmN0aW9uIChlbGVtZW50LCBob3Jpem9udGFsKSB7XG4gIHJldHVybiBfZ2V0U2Nyb2xsRnVuYyhfZ2V0VGFyZ2V0KGVsZW1lbnQpLCBob3Jpem9udGFsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwpO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5nZXRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiBfaWRzW2lkXTtcbn07XG5cblNjcm9sbFRyaWdnZXIuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX3RyaWdnZXJzLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0LnZhcnMuaWQgIT09IFwiU2Nyb2xsU21vb3RoZXJcIjtcbiAgfSk7XG59OyAvLyBpdCdzIGNvbW1vbiBmb3IgcGVvcGxlIHRvIFNjcm9sbFRyaWdnZXIuZ2V0QWxsKHQgPT4gdC5raWxsKCkpIG9uIHBhZ2Ugcm91dGVzLCBmb3IgZXhhbXBsZSwgYW5kIHdlIGRvbid0IHdhbnQgaXQgdG8gcnVpbiBzbW9vdGggc2Nyb2xsaW5nIGJ5IGtpbGxpbmcgdGhlIG1haW4gU2Nyb2xsU21vb3RoZXIgb25lLlxuXG5cblNjcm9sbFRyaWdnZXIuaXNTY3JvbGxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIV9sYXN0U2Nyb2xsVGltZTtcbn07XG5cblNjcm9sbFRyaWdnZXIuc25hcERpcmVjdGlvbmFsID0gX3NuYXBEaXJlY3Rpb25hbDtcblxuU2Nyb2xsVHJpZ2dlci5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XG4gIHZhciBhID0gX2xpc3RlbmVyc1t0eXBlXSB8fCAoX2xpc3RlbmVyc1t0eXBlXSA9IFtdKTtcbiAgfmEuaW5kZXhPZihjYWxsYmFjaykgfHwgYS5wdXNoKGNhbGxiYWNrKTtcbn07XG5cblNjcm9sbFRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xuICB2YXIgYSA9IF9saXN0ZW5lcnNbdHlwZV0sXG4gICAgICBpID0gYSAmJiBhLmluZGV4T2YoY2FsbGJhY2spO1xuICBpID49IDAgJiYgYS5zcGxpY2UoaSwgMSk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLmJhdGNoID0gZnVuY3Rpb24gKHRhcmdldHMsIHZhcnMpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgdmFyc0NvcHkgPSB7fSxcbiAgICAgIGludGVydmFsID0gdmFycy5pbnRlcnZhbCB8fCAwLjAxNixcbiAgICAgIGJhdGNoTWF4ID0gdmFycy5iYXRjaE1heCB8fCAxZTksXG4gICAgICBwcm94eUNhbGxiYWNrID0gZnVuY3Rpb24gcHJveHlDYWxsYmFjayh0eXBlLCBjYWxsYmFjaykge1xuICAgIHZhciBlbGVtZW50cyA9IFtdLFxuICAgICAgICB0cmlnZ2VycyA9IFtdLFxuICAgICAgICBkZWxheSA9IGdzYXAuZGVsYXllZENhbGwoaW50ZXJ2YWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKGVsZW1lbnRzLCB0cmlnZ2Vycyk7XG4gICAgICBlbGVtZW50cyA9IFtdO1xuICAgICAgdHJpZ2dlcnMgPSBbXTtcbiAgICB9KS5wYXVzZSgpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc2VsZikge1xuICAgICAgZWxlbWVudHMubGVuZ3RoIHx8IGRlbGF5LnJlc3RhcnQodHJ1ZSk7XG4gICAgICBlbGVtZW50cy5wdXNoKHNlbGYudHJpZ2dlcik7XG4gICAgICB0cmlnZ2Vycy5wdXNoKHNlbGYpO1xuICAgICAgYmF0Y2hNYXggPD0gZWxlbWVudHMubGVuZ3RoICYmIGRlbGF5LnByb2dyZXNzKDEpO1xuICAgIH07XG4gIH0sXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiB2YXJzKSB7XG4gICAgdmFyc0NvcHlbcF0gPSBwLnN1YnN0cigwLCAyKSA9PT0gXCJvblwiICYmIF9pc0Z1bmN0aW9uKHZhcnNbcF0pICYmIHAgIT09IFwib25SZWZyZXNoSW5pdFwiID8gcHJveHlDYWxsYmFjayhwLCB2YXJzW3BdKSA6IHZhcnNbcF07XG4gIH1cblxuICBpZiAoX2lzRnVuY3Rpb24oYmF0Y2hNYXgpKSB7XG4gICAgYmF0Y2hNYXggPSBiYXRjaE1heCgpO1xuXG4gICAgX2FkZExpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwicmVmcmVzaFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYmF0Y2hNYXggPSB2YXJzLmJhdGNoTWF4KCk7XG4gICAgfSk7XG4gIH1cblxuICBfdG9BcnJheSh0YXJnZXRzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB2YXIgY29uZmlnID0ge307XG5cbiAgICBmb3IgKHAgaW4gdmFyc0NvcHkpIHtcbiAgICAgIGNvbmZpZ1twXSA9IHZhcnNDb3B5W3BdO1xuICAgIH1cblxuICAgIGNvbmZpZy50cmlnZ2VyID0gdGFyZ2V0O1xuICAgIHJlc3VsdC5wdXNoKFNjcm9sbFRyaWdnZXIuY3JlYXRlKGNvbmZpZykpO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTsgLy8gdG8gcmVkdWNlIGZpbGUgc2l6ZS4gY2xhbXBzIHRoZSBzY3JvbGwgYW5kIGFsc28gcmV0dXJucyBhIGR1cmF0aW9uIG11bHRpcGxpZXIgc28gdGhhdCBpZiB0aGUgc2Nyb2xsIGdldHMgY2hvcHBlZCBzaG9ydGVyLCB0aGUgZHVyYXRpb24gZ2V0cyBjdXJ0YWlsZWQgYXMgd2VsbCAob3RoZXJ3aXNlIGlmIHlvdSdyZSB2ZXJ5IGNsb3NlIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UsIGZvciBleGFtcGxlLCBhbmQgc3dpcGUgdXAgcmVhbGx5IGZhc3QsIGl0J2xsIHN1ZGRlbmx5IHNsb3cgZG93biBhbmQgdGFrZSBhIGxvbmcgdGltZSB0byByZWFjaCB0aGUgdG9wKS5cblxuXG52YXIgX2NsYW1wU2Nyb2xsQW5kR2V0RHVyYXRpb25NdWx0aXBsaWVyID0gZnVuY3Rpb24gX2NsYW1wU2Nyb2xsQW5kR2V0RHVyYXRpb25NdWx0aXBsaWVyKHNjcm9sbEZ1bmMsIGN1cnJlbnQsIGVuZCwgbWF4KSB7XG4gIGN1cnJlbnQgPiBtYXggPyBzY3JvbGxGdW5jKG1heCkgOiBjdXJyZW50IDwgMCAmJiBzY3JvbGxGdW5jKDApO1xuICByZXR1cm4gZW5kID4gbWF4ID8gKG1heCAtIGN1cnJlbnQpIC8gKGVuZCAtIGN1cnJlbnQpIDogZW5kIDwgMCA/IGN1cnJlbnQgLyAoY3VycmVudCAtIGVuZCkgOiAxO1xufSxcbiAgICBfYWxsb3dOYXRpdmVQYW5uaW5nID0gZnVuY3Rpb24gX2FsbG93TmF0aXZlUGFubmluZyh0YXJnZXQsIGRpcmVjdGlvbikge1xuICBpZiAoZGlyZWN0aW9uID09PSB0cnVlKSB7XG4gICAgdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwidG91Y2gtYWN0aW9uXCIpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC5zdHlsZS50b3VjaEFjdGlvbiA9IGRpcmVjdGlvbiA9PT0gdHJ1ZSA/IFwiYXV0b1wiIDogZGlyZWN0aW9uID8gXCJwYW4tXCIgKyBkaXJlY3Rpb24gKyAoT2JzZXJ2ZXIuaXNUb3VjaCA/IFwiIHBpbmNoLXpvb21cIiA6IFwiXCIpIDogXCJub25lXCI7IC8vIG5vdGU6IEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IGl0IHBpbmNoLXpvb20gcHJvcGVybHksIGF0IGxlYXN0IGluIGFkZGl0aW9uIHRvIGEgcGFuLXggb3IgcGFuLXkuXG4gIH1cblxuICB0YXJnZXQgPT09IF9kb2NFbCAmJiBfYWxsb3dOYXRpdmVQYW5uaW5nKF9ib2R5LCBkaXJlY3Rpb24pO1xufSxcbiAgICBfb3ZlcmZsb3cgPSB7XG4gIGF1dG86IDEsXG4gIHNjcm9sbDogMVxufSxcbiAgICBfbmVzdGVkU2Nyb2xsID0gZnVuY3Rpb24gX25lc3RlZFNjcm9sbChfcmVmNSkge1xuICB2YXIgZXZlbnQgPSBfcmVmNS5ldmVudCxcbiAgICAgIHRhcmdldCA9IF9yZWY1LnRhcmdldCxcbiAgICAgIGF4aXMgPSBfcmVmNS5heGlzO1xuXG4gIHZhciBub2RlID0gKGV2ZW50LmNoYW5nZWRUb3VjaGVzID8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldmVudCkudGFyZ2V0LFxuICAgICAgY2FjaGUgPSBub2RlLl9nc2FwIHx8IGdzYXAuY29yZS5nZXRDYWNoZShub2RlKSxcbiAgICAgIHRpbWUgPSBfZ2V0VGltZSgpLFxuICAgICAgY3M7XG5cbiAgaWYgKCFjYWNoZS5faXNTY3JvbGxUIHx8IHRpbWUgLSBjYWNoZS5faXNTY3JvbGxUID4gMjAwMCkge1xuICAgIC8vIGNhY2hlIGZvciAyIHNlY29uZHMgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSBfYm9keSAmJiAobm9kZS5zY3JvbGxIZWlnaHQgPD0gbm9kZS5jbGllbnRIZWlnaHQgJiYgbm9kZS5zY3JvbGxXaWR0aCA8PSBub2RlLmNsaWVudFdpZHRoIHx8ICEoX292ZXJmbG93WyhjcyA9IF9nZXRDb21wdXRlZFN0eWxlKG5vZGUpKS5vdmVyZmxvd1ldIHx8IF9vdmVyZmxvd1tjcy5vdmVyZmxvd1hdKSkpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgY2FjaGUuX2lzU2Nyb2xsID0gbm9kZSAmJiBub2RlICE9PSB0YXJnZXQgJiYgIV9pc1ZpZXdwb3J0KG5vZGUpICYmIChfb3ZlcmZsb3dbKGNzID0gX2dldENvbXB1dGVkU3R5bGUobm9kZSkpLm92ZXJmbG93WV0gfHwgX292ZXJmbG93W2NzLm92ZXJmbG93WF0pO1xuICAgIGNhY2hlLl9pc1Njcm9sbFQgPSB0aW1lO1xuICB9XG5cbiAgaWYgKGNhY2hlLl9pc1Njcm9sbCB8fCBheGlzID09PSBcInhcIikge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50Ll9nc2FwQWxsb3cgPSB0cnVlO1xuICB9XG59LFxuICAgIC8vIGNhcHR1cmUgZXZlbnRzIG9uIHNjcm9sbGFibGUgZWxlbWVudHMgSU5TSURFIHRoZSA8Ym9keT4gYW5kIGFsbG93IHRob3NlIGJ5IGNhbGxpbmcgc3RvcFByb3BhZ2F0aW9uKCkgd2hlbiB3ZSBmaW5kIGEgc2Nyb2xsYWJsZSBhbmNlc3RvclxuX2lucHV0T2JzZXJ2ZXIgPSBmdW5jdGlvbiBfaW5wdXRPYnNlcnZlcih0YXJnZXQsIHR5cGUsIGlucHV0cywgbmVzdGVkKSB7XG4gIHJldHVybiBPYnNlcnZlci5jcmVhdGUoe1xuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIGNhcHR1cmU6IHRydWUsXG4gICAgZGVib3VuY2U6IGZhbHNlLFxuICAgIGxvY2tBeGlzOiB0cnVlLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgb25XaGVlbDogbmVzdGVkID0gbmVzdGVkICYmIF9uZXN0ZWRTY3JvbGwsXG4gICAgb25QcmVzczogbmVzdGVkLFxuICAgIG9uRHJhZzogbmVzdGVkLFxuICAgIG9uU2Nyb2xsOiBuZXN0ZWQsXG4gICAgb25FbmFibGU6IGZ1bmN0aW9uIG9uRW5hYmxlKCkge1xuICAgICAgcmV0dXJuIGlucHV0cyAmJiBfYWRkTGlzdGVuZXIoX2RvYywgT2JzZXJ2ZXIuZXZlbnRUeXBlc1swXSwgX2NhcHR1cmVJbnB1dHMsIGZhbHNlLCB0cnVlKTtcbiAgICB9LFxuICAgIG9uRGlzYWJsZTogZnVuY3Rpb24gb25EaXNhYmxlKCkge1xuICAgICAgcmV0dXJuIF9yZW1vdmVMaXN0ZW5lcihfZG9jLCBPYnNlcnZlci5ldmVudFR5cGVzWzBdLCBfY2FwdHVyZUlucHV0cywgdHJ1ZSk7XG4gICAgfVxuICB9KTtcbn0sXG4gICAgX2lucHV0RXhwID0gLyhpbnB1dHxsYWJlbHxzZWxlY3R8dGV4dGFyZWEpL2ksXG4gICAgX2lucHV0SXNGb2N1c2VkLFxuICAgIF9jYXB0dXJlSW5wdXRzID0gZnVuY3Rpb24gX2NhcHR1cmVJbnB1dHMoZSkge1xuICB2YXIgaXNJbnB1dCA9IF9pbnB1dEV4cC50ZXN0KGUudGFyZ2V0LnRhZ05hbWUpO1xuXG4gIGlmIChpc0lucHV0IHx8IF9pbnB1dElzRm9jdXNlZCkge1xuICAgIGUuX2dzYXBBbGxvdyA9IHRydWU7XG4gICAgX2lucHV0SXNGb2N1c2VkID0gaXNJbnB1dDtcbiAgfVxufSxcbiAgICBfZ2V0U2Nyb2xsTm9ybWFsaXplciA9IGZ1bmN0aW9uIF9nZXRTY3JvbGxOb3JtYWxpemVyKHZhcnMpIHtcbiAgX2lzT2JqZWN0KHZhcnMpIHx8ICh2YXJzID0ge30pO1xuICB2YXJzLnByZXZlbnREZWZhdWx0ID0gdmFycy5pc05vcm1hbGl6ZXIgPSB2YXJzLmFsbG93Q2xpY2tzID0gdHJ1ZTtcbiAgdmFycy50eXBlIHx8ICh2YXJzLnR5cGUgPSBcIndoZWVsLHRvdWNoXCIpO1xuICB2YXJzLmRlYm91bmNlID0gISF2YXJzLmRlYm91bmNlO1xuICB2YXJzLmlkID0gdmFycy5pZCB8fCBcIm5vcm1hbGl6ZXJcIjtcblxuICB2YXIgX3ZhcnMyID0gdmFycyxcbiAgICAgIG5vcm1hbGl6ZVNjcm9sbFggPSBfdmFyczIubm9ybWFsaXplU2Nyb2xsWCxcbiAgICAgIG1vbWVudHVtID0gX3ZhcnMyLm1vbWVudHVtLFxuICAgICAgYWxsb3dOZXN0ZWRTY3JvbGwgPSBfdmFyczIuYWxsb3dOZXN0ZWRTY3JvbGwsXG4gICAgICBvblJlbGVhc2UgPSBfdmFyczIub25SZWxlYXNlLFxuICAgICAgc2VsZixcbiAgICAgIG1heFksXG4gICAgICB0YXJnZXQgPSBfZ2V0VGFyZ2V0KHZhcnMudGFyZ2V0KSB8fCBfZG9jRWwsXG4gICAgICBzbW9vdGhlciA9IGdzYXAuY29yZS5nbG9iYWxzKCkuU2Nyb2xsU21vb3RoZXIsXG4gICAgICBzbW9vdGhlckluc3RhbmNlID0gc21vb3RoZXIgJiYgc21vb3RoZXIuZ2V0KCksXG4gICAgICBjb250ZW50ID0gX2ZpeElPU0J1ZyAmJiAodmFycy5jb250ZW50ICYmIF9nZXRUYXJnZXQodmFycy5jb250ZW50KSB8fCBzbW9vdGhlckluc3RhbmNlICYmIHZhcnMuY29udGVudCAhPT0gZmFsc2UgJiYgIXNtb290aGVySW5zdGFuY2Uuc21vb3RoKCkgJiYgc21vb3RoZXJJbnN0YW5jZS5jb250ZW50KCkpLFxuICAgICAgc2Nyb2xsRnVuY1kgPSBfZ2V0U2Nyb2xsRnVuYyh0YXJnZXQsIF92ZXJ0aWNhbCksXG4gICAgICBzY3JvbGxGdW5jWCA9IF9nZXRTY3JvbGxGdW5jKHRhcmdldCwgX2hvcml6b250YWwpLFxuICAgICAgc2NhbGUgPSAxLFxuICAgICAgaW5pdGlhbFNjYWxlID0gKE9ic2VydmVyLmlzVG91Y2ggJiYgX3dpbi52aXN1YWxWaWV3cG9ydCA/IF93aW4udmlzdWFsVmlld3BvcnQuc2NhbGUgKiBfd2luLnZpc3VhbFZpZXdwb3J0LndpZHRoIDogX3dpbi5vdXRlcldpZHRoKSAvIF93aW4uaW5uZXJXaWR0aCxcbiAgICAgIHdoZWVsUmVmcmVzaCA9IDAsXG4gICAgICByZXNvbHZlTW9tZW50dW1EdXJhdGlvbiA9IF9pc0Z1bmN0aW9uKG1vbWVudHVtKSA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbW9tZW50dW0oc2VsZik7XG4gIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG1vbWVudHVtIHx8IDIuODtcbiAgfSxcbiAgICAgIGxhc3RSZWZyZXNoSUQsXG4gICAgICBza2lwVG91Y2hNb3ZlLFxuICAgICAgaW5wdXRPYnNlcnZlciA9IF9pbnB1dE9ic2VydmVyKHRhcmdldCwgdmFycy50eXBlLCB0cnVlLCBhbGxvd05lc3RlZFNjcm9sbCksXG4gICAgICByZXN1bWVUb3VjaE1vdmUgPSBmdW5jdGlvbiByZXN1bWVUb3VjaE1vdmUoKSB7XG4gICAgcmV0dXJuIHNraXBUb3VjaE1vdmUgPSBmYWxzZTtcbiAgfSxcbiAgICAgIHNjcm9sbENsYW1wWCA9IF9wYXNzVGhyb3VnaCxcbiAgICAgIHNjcm9sbENsYW1wWSA9IF9wYXNzVGhyb3VnaCxcbiAgICAgIHVwZGF0ZUNsYW1wcyA9IGZ1bmN0aW9uIHVwZGF0ZUNsYW1wcygpIHtcbiAgICBtYXhZID0gX21heFNjcm9sbCh0YXJnZXQsIF92ZXJ0aWNhbCk7XG4gICAgc2Nyb2xsQ2xhbXBZID0gX2NsYW1wKF9maXhJT1NCdWcgPyAxIDogMCwgbWF4WSk7XG4gICAgbm9ybWFsaXplU2Nyb2xsWCAmJiAoc2Nyb2xsQ2xhbXBYID0gX2NsYW1wKDAsIF9tYXhTY3JvbGwodGFyZ2V0LCBfaG9yaXpvbnRhbCkpKTtcbiAgICBsYXN0UmVmcmVzaElEID0gX3JlZnJlc2hJRDtcbiAgfSxcbiAgICAgIHJlbW92ZUNvbnRlbnRPZmZzZXQgPSBmdW5jdGlvbiByZW1vdmVDb250ZW50T2Zmc2V0KCkge1xuICAgIGNvbnRlbnQuX2dzYXAueSA9IF9yb3VuZChwYXJzZUZsb2F0KGNvbnRlbnQuX2dzYXAueSkgKyBzY3JvbGxGdW5jWS5vZmZzZXQpICsgXCJweFwiO1xuICAgIGNvbnRlbnQuc3R5bGUudHJhbnNmb3JtID0gXCJtYXRyaXgzZCgxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCBcIiArIHBhcnNlRmxvYXQoY29udGVudC5fZ3NhcC55KSArIFwiLCAwLCAxKVwiO1xuICAgIHNjcm9sbEZ1bmNZLm9mZnNldCA9IHNjcm9sbEZ1bmNZLmNhY2hlSUQgPSAwO1xuICB9LFxuICAgICAgaWdub3JlRHJhZyA9IGZ1bmN0aW9uIGlnbm9yZURyYWcoKSB7XG4gICAgaWYgKHNraXBUb3VjaE1vdmUpIHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZXN1bWVUb3VjaE1vdmUpO1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gX3JvdW5kKHNlbGYuZGVsdGFZIC8gMiksXG4gICAgICAgICAgc2Nyb2xsID0gc2Nyb2xsQ2xhbXBZKHNjcm9sbEZ1bmNZLnYgLSBvZmZzZXQpO1xuXG4gICAgICBpZiAoY29udGVudCAmJiBzY3JvbGwgIT09IHNjcm9sbEZ1bmNZLnYgKyBzY3JvbGxGdW5jWS5vZmZzZXQpIHtcbiAgICAgICAgc2Nyb2xsRnVuY1kub2Zmc2V0ID0gc2Nyb2xsIC0gc2Nyb2xsRnVuY1kudjtcblxuICAgICAgICB2YXIgeSA9IF9yb3VuZCgocGFyc2VGbG9hdChjb250ZW50ICYmIGNvbnRlbnQuX2dzYXAueSkgfHwgMCkgLSBzY3JvbGxGdW5jWS5vZmZzZXQpO1xuXG4gICAgICAgIGNvbnRlbnQuc3R5bGUudHJhbnNmb3JtID0gXCJtYXRyaXgzZCgxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCBcIiArIHkgKyBcIiwgMCwgMSlcIjtcbiAgICAgICAgY29udGVudC5fZ3NhcC55ID0geSArIFwicHhcIjtcbiAgICAgICAgc2Nyb2xsRnVuY1kuY2FjaGVJRCA9IF9zY3JvbGxlcnMuY2FjaGU7XG5cbiAgICAgICAgX3VwZGF0ZUFsbCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzY3JvbGxGdW5jWS5vZmZzZXQgJiYgcmVtb3ZlQ29udGVudE9mZnNldCgpO1xuICAgIHNraXBUb3VjaE1vdmUgPSB0cnVlO1xuICB9LFxuICAgICAgdHdlZW4sXG4gICAgICBzdGFydFNjcm9sbFgsXG4gICAgICBzdGFydFNjcm9sbFksXG4gICAgICBvblN0b3BEZWxheWVkQ2FsbCxcbiAgICAgIG9uUmVzaXplID0gZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gICAgLy8gaWYgdGhlIHdpbmRvdyByZXNpemVzLCBsaWtlIG9uIGFuIGlQaG9uZSB3aGljaCBBcHBsZSBGT1JDRVMgdGhlIGFkZHJlc3MgYmFyIHRvIHNob3cvaGlkZSBldmVuIGlmIHdlIGV2ZW50LnByZXZlbnREZWZhdWx0KCksIGl0IG1heSBiZSBzY3JvbGxpbmcgdG9vIGZhciBub3cgdGhhdCB0aGUgYWRkcmVzcyBiYXIgaXMgc2hvd2luZywgc28gd2UgbXVzdCBkeW5hbWljYWxseSBhZGp1c3QgdGhlIG1vbWVudHVtIHR3ZWVuLlxuICAgIHVwZGF0ZUNsYW1wcygpO1xuXG4gICAgaWYgKHR3ZWVuLmlzQWN0aXZlKCkgJiYgdHdlZW4udmFycy5zY3JvbGxZID4gbWF4WSkge1xuICAgICAgc2Nyb2xsRnVuY1koKSA+IG1heFkgPyB0d2Vlbi5wcm9ncmVzcygxKSAmJiBzY3JvbGxGdW5jWShtYXhZKSA6IHR3ZWVuLnJlc2V0VG8oXCJzY3JvbGxZXCIsIG1heFkpO1xuICAgIH1cbiAgfTtcblxuICBjb250ZW50ICYmIGdzYXAuc2V0KGNvbnRlbnQsIHtcbiAgICB5OiBcIis9MFwiXG4gIH0pOyAvLyB0byBlbnN1cmUgdGhlcmUncyBhIGNhY2hlIChlbGVtZW50Ll9nc2FwKVxuXG4gIHZhcnMuaWdub3JlQ2hlY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBfZml4SU9TQnVnICYmIGUudHlwZSA9PT0gXCJ0b3VjaG1vdmVcIiAmJiBpZ25vcmVEcmFnKGUpIHx8IHNjYWxlID4gMS4wNSAmJiBlLnR5cGUgIT09IFwidG91Y2hzdGFydFwiIHx8IHNlbGYuaXNHZXN0dXJpbmcgfHwgZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxO1xuICB9O1xuXG4gIHZhcnMub25QcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBza2lwVG91Y2hNb3ZlID0gZmFsc2U7XG4gICAgdmFyIHByZXZTY2FsZSA9IHNjYWxlO1xuICAgIHNjYWxlID0gX3JvdW5kKChfd2luLnZpc3VhbFZpZXdwb3J0ICYmIF93aW4udmlzdWFsVmlld3BvcnQuc2NhbGUgfHwgMSkgLyBpbml0aWFsU2NhbGUpO1xuICAgIHR3ZWVuLnBhdXNlKCk7XG4gICAgcHJldlNjYWxlICE9PSBzY2FsZSAmJiBfYWxsb3dOYXRpdmVQYW5uaW5nKHRhcmdldCwgc2NhbGUgPiAxLjAxID8gdHJ1ZSA6IG5vcm1hbGl6ZVNjcm9sbFggPyBmYWxzZSA6IFwieFwiKTtcbiAgICBzdGFydFNjcm9sbFggPSBzY3JvbGxGdW5jWCgpO1xuICAgIHN0YXJ0U2Nyb2xsWSA9IHNjcm9sbEZ1bmNZKCk7XG4gICAgdXBkYXRlQ2xhbXBzKCk7XG4gICAgbGFzdFJlZnJlc2hJRCA9IF9yZWZyZXNoSUQ7XG4gIH07XG5cbiAgdmFycy5vblJlbGVhc2UgPSB2YXJzLm9uR2VzdHVyZVN0YXJ0ID0gZnVuY3Rpb24gKHNlbGYsIHdhc0RyYWdnaW5nKSB7XG4gICAgc2Nyb2xsRnVuY1kub2Zmc2V0ICYmIHJlbW92ZUNvbnRlbnRPZmZzZXQoKTtcblxuICAgIGlmICghd2FzRHJhZ2dpbmcpIHtcbiAgICAgIG9uU3RvcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9zY3JvbGxlcnMuY2FjaGUrKzsgLy8gbWFrZSBzdXJlIHdlJ3JlIHB1bGxpbmcgdGhlIG5vbi1jYWNoZWQgdmFsdWVcbiAgICAgIC8vIGFsdGVybmF0ZSBhbGdvcml0aG06IGR1clggPSBNYXRoLm1pbig2LCBNYXRoLmFicyhzZWxmLnZlbG9jaXR5WCAvIDgwMCkpLFx0ZHVyID0gTWF0aC5tYXgoZHVyWCwgTWF0aC5taW4oNiwgTWF0aC5hYnMoc2VsZi52ZWxvY2l0eVkgLyA4MDApKSk7IGR1ciA9IGR1ciAqICgwLjQgKyAoMSAtIF9wb3dlcjRJbihkdXIgLyA2KSkgKiAwLjYpKSAqIChtb21lbnR1bVNwZWVkIHx8IDEpXG5cbiAgICAgIHZhciBkdXIgPSByZXNvbHZlTW9tZW50dW1EdXJhdGlvbigpLFxuICAgICAgICAgIGN1cnJlbnRTY3JvbGwsXG4gICAgICAgICAgZW5kU2Nyb2xsO1xuXG4gICAgICBpZiAobm9ybWFsaXplU2Nyb2xsWCkge1xuICAgICAgICBjdXJyZW50U2Nyb2xsID0gc2Nyb2xsRnVuY1goKTtcbiAgICAgICAgZW5kU2Nyb2xsID0gY3VycmVudFNjcm9sbCArIGR1ciAqIDAuMDUgKiAtc2VsZi52ZWxvY2l0eVggLyAwLjIyNzsgLy8gdGhlIGNvbnN0YW50IC4yMjcgaXMgZnJvbSBwb3dlcjQoMC4wNSkuIHZlbG9jaXR5IGlzIGludmVydGVkIGJlY2F1c2Ugc2Nyb2xsaW5nIGdvZXMgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbi5cblxuICAgICAgICBkdXIgKj0gX2NsYW1wU2Nyb2xsQW5kR2V0RHVyYXRpb25NdWx0aXBsaWVyKHNjcm9sbEZ1bmNYLCBjdXJyZW50U2Nyb2xsLCBlbmRTY3JvbGwsIF9tYXhTY3JvbGwodGFyZ2V0LCBfaG9yaXpvbnRhbCkpO1xuICAgICAgICB0d2Vlbi52YXJzLnNjcm9sbFggPSBzY3JvbGxDbGFtcFgoZW5kU2Nyb2xsKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudFNjcm9sbCA9IHNjcm9sbEZ1bmNZKCk7XG4gICAgICBlbmRTY3JvbGwgPSBjdXJyZW50U2Nyb2xsICsgZHVyICogMC4wNSAqIC1zZWxmLnZlbG9jaXR5WSAvIDAuMjI3OyAvLyB0aGUgY29uc3RhbnQgLjIyNyBpcyBmcm9tIHBvd2VyNCgwLjA1KVxuXG4gICAgICBkdXIgKj0gX2NsYW1wU2Nyb2xsQW5kR2V0RHVyYXRpb25NdWx0aXBsaWVyKHNjcm9sbEZ1bmNZLCBjdXJyZW50U2Nyb2xsLCBlbmRTY3JvbGwsIF9tYXhTY3JvbGwodGFyZ2V0LCBfdmVydGljYWwpKTtcbiAgICAgIHR3ZWVuLnZhcnMuc2Nyb2xsWSA9IHNjcm9sbENsYW1wWShlbmRTY3JvbGwpO1xuICAgICAgdHdlZW4uaW52YWxpZGF0ZSgpLmR1cmF0aW9uKGR1cikucGxheSgwLjAxKTtcblxuICAgICAgaWYgKF9maXhJT1NCdWcgJiYgdHdlZW4udmFycy5zY3JvbGxZID49IG1heFkgfHwgY3VycmVudFNjcm9sbCA+PSBtYXhZIC0gMSkge1xuICAgICAgICAvLyBpT1MgYnVnOiBpdCdsbCBzaG93IHRoZSBhZGRyZXNzIGJhciBidXQgTk9UIGZpcmUgdGhlIHdpbmRvdyBcInJlc2l6ZVwiIGV2ZW50IHVudGlsIHRoZSBhbmltYXRpb24gaXMgZG9uZSBidXQgd2UgbXVzdCBwcm90ZWN0IGFnYWluc3Qgb3ZlcnNob290IHNvIHdlIGxldmVyYWdlIGFuIG9uVXBkYXRlIHRvIGRvIHNvLlxuICAgICAgICBnc2FwLnRvKHt9LCB7XG4gICAgICAgICAgb25VcGRhdGU6IG9uUmVzaXplLFxuICAgICAgICAgIGR1cmF0aW9uOiBkdXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb25SZWxlYXNlICYmIG9uUmVsZWFzZShzZWxmKTtcbiAgfTtcblxuICB2YXJzLm9uV2hlZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdHdlZW4uX3RzICYmIHR3ZWVuLnBhdXNlKCk7XG5cbiAgICBpZiAoX2dldFRpbWUoKSAtIHdoZWVsUmVmcmVzaCA+IDEwMDApIHtcbiAgICAgIC8vIGFmdGVyIDEgc2Vjb25kLCByZWZyZXNoIHRoZSBjbGFtcHMgb3RoZXJ3aXNlIHRoYXQnbGwgb25seSBoYXBwZW4gd2hlbiBTY3JvbGxUcmlnZ2VyLnJlZnJlc2goKSBpcyBjYWxsZWQgb3IgZm9yIHRvdWNoLXNjcm9sbGluZy5cbiAgICAgIGxhc3RSZWZyZXNoSUQgPSAwO1xuICAgICAgd2hlZWxSZWZyZXNoID0gX2dldFRpbWUoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFycy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChzZWxmLCBkeCwgZHksIHhBcnJheSwgeUFycmF5KSB7XG4gICAgX3JlZnJlc2hJRCAhPT0gbGFzdFJlZnJlc2hJRCAmJiB1cGRhdGVDbGFtcHMoKTtcbiAgICBkeCAmJiBub3JtYWxpemVTY3JvbGxYICYmIHNjcm9sbEZ1bmNYKHNjcm9sbENsYW1wWCh4QXJyYXlbMl0gPT09IGR4ID8gc3RhcnRTY3JvbGxYICsgKHNlbGYuc3RhcnRYIC0gc2VsZi54KSA6IHNjcm9sbEZ1bmNYKCkgKyBkeCAtIHhBcnJheVsxXSkpOyAvLyBmb3IgbW9yZSBwcmVjaXNpb24sIHdlIHRyYWNrIHBvaW50ZXIvdG91Y2ggbW92ZW1lbnQgZnJvbSB0aGUgc3RhcnQsIG90aGVyd2lzZSBpdCdsbCBkcmlmdC5cblxuICAgIGlmIChkeSkge1xuICAgICAgc2Nyb2xsRnVuY1kub2Zmc2V0ICYmIHJlbW92ZUNvbnRlbnRPZmZzZXQoKTtcbiAgICAgIHZhciBpc1RvdWNoID0geUFycmF5WzJdID09PSBkeSxcbiAgICAgICAgICB5ID0gaXNUb3VjaCA/IHN0YXJ0U2Nyb2xsWSArIHNlbGYuc3RhcnRZIC0gc2VsZi55IDogc2Nyb2xsRnVuY1koKSArIGR5IC0geUFycmF5WzFdLFxuICAgICAgICAgIHlDbGFtcGVkID0gc2Nyb2xsQ2xhbXBZKHkpO1xuICAgICAgaXNUb3VjaCAmJiB5ICE9PSB5Q2xhbXBlZCAmJiAoc3RhcnRTY3JvbGxZICs9IHlDbGFtcGVkIC0geSk7XG4gICAgICBzY3JvbGxGdW5jWSh5Q2xhbXBlZCk7XG4gICAgfVxuXG4gICAgKGR5IHx8IGR4KSAmJiBfdXBkYXRlQWxsKCk7XG4gIH07XG5cbiAgdmFycy5vbkVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfYWxsb3dOYXRpdmVQYW5uaW5nKHRhcmdldCwgbm9ybWFsaXplU2Nyb2xsWCA/IGZhbHNlIDogXCJ4XCIpO1xuXG4gICAgU2Nyb2xsVHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKFwicmVmcmVzaFwiLCBvblJlc2l6ZSk7XG5cbiAgICBfYWRkTGlzdGVuZXIoX3dpbiwgXCJyZXNpemVcIiwgb25SZXNpemUpO1xuXG4gICAgaWYgKHNjcm9sbEZ1bmNZLnNtb290aCkge1xuICAgICAgc2Nyb2xsRnVuY1kudGFyZ2V0LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gXCJhdXRvXCI7XG4gICAgICBzY3JvbGxGdW5jWS5zbW9vdGggPSBzY3JvbGxGdW5jWC5zbW9vdGggPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpbnB1dE9ic2VydmVyLmVuYWJsZSgpO1xuICB9O1xuXG4gIHZhcnMub25EaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIF9hbGxvd05hdGl2ZVBhbm5pbmcodGFyZ2V0LCB0cnVlKTtcblxuICAgIF9yZW1vdmVMaXN0ZW5lcihfd2luLCBcInJlc2l6ZVwiLCBvblJlc2l6ZSk7XG5cbiAgICBTY3JvbGxUcmlnZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZWZyZXNoXCIsIG9uUmVzaXplKTtcbiAgICBpbnB1dE9ic2VydmVyLmtpbGwoKTtcbiAgfTtcblxuICB2YXJzLmxvY2tBeGlzID0gdmFycy5sb2NrQXhpcyAhPT0gZmFsc2U7XG4gIHNlbGYgPSBuZXcgT2JzZXJ2ZXIodmFycyk7XG4gIHNlbGYuaU9TID0gX2ZpeElPU0J1ZzsgLy8gdXNlZCBpbiB0aGUgT2JzZXJ2ZXIgZ2V0Q2FjaGVkU2Nyb2xsKCkgZnVuY3Rpb24gdG8gd29yayBhcm91bmQgYW4gaU9TIGJ1ZyB0aGF0IHdyZWFrcyBoYXZvYyB3aXRoIFRvdWNoRXZlbnQuY2xpZW50WSBpZiB3ZSBhbGxvdyBzY3JvbGwgdG8gZ28gYWxsIHRoZSB3YXkgYmFjayB0byAwLlxuXG4gIF9maXhJT1NCdWcgJiYgIXNjcm9sbEZ1bmNZKCkgJiYgc2Nyb2xsRnVuY1koMSk7IC8vIGlPUyBidWcgY2F1c2VzIGV2ZW50LmNsaWVudFkgdmFsdWVzIHRvIGZyZWFrIG91dCAod2lsZGx5IGluYWNjdXJhdGUpIGlmIHRoZSBzY3JvbGwgcG9zaXRpb24gaXMgZXhhY3RseSAwLlxuXG4gIF9maXhJT1NCdWcgJiYgZ3NhcC50aWNrZXIuYWRkKF9wYXNzVGhyb3VnaCk7IC8vIHByZXZlbnQgdGhlIHRpY2tlciBmcm9tIHNsZWVwaW5nXG5cbiAgb25TdG9wRGVsYXllZENhbGwgPSBzZWxmLl9kYztcbiAgdHdlZW4gPSBnc2FwLnRvKHNlbGYsIHtcbiAgICBlYXNlOiBcInBvd2VyNFwiLFxuICAgIHBhdXNlZDogdHJ1ZSxcbiAgICBpbmhlcml0OiBmYWxzZSxcbiAgICBzY3JvbGxYOiBub3JtYWxpemVTY3JvbGxYID8gXCIrPTAuMVwiIDogXCIrPTBcIixcbiAgICBzY3JvbGxZOiBcIis9MC4xXCIsXG4gICAgbW9kaWZpZXJzOiB7XG4gICAgICBzY3JvbGxZOiBfaW50ZXJydXB0aW9uVHJhY2tlcihzY3JvbGxGdW5jWSwgc2Nyb2xsRnVuY1koKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHdlZW4ucGF1c2UoKTtcbiAgICAgIH0pXG4gICAgfSxcbiAgICBvblVwZGF0ZTogX3VwZGF0ZUFsbCxcbiAgICBvbkNvbXBsZXRlOiBvblN0b3BEZWxheWVkQ2FsbC52YXJzLm9uQ29tcGxldGVcbiAgfSk7IC8vIHdlIG5lZWQgdGhlIG1vZGlmaWVyIHRvIHNlbnNlIGlmIHRoZSBzY3JvbGwgcG9zaXRpb24gaXMgYWx0ZXJlZCBvdXRzaWRlIG9mIHRoZSBtb21lbnR1bSB0d2VlbiAobGlrZSB3aXRoIGEgc2Nyb2xsVG8gdHdlZW4pIHNvIHdlIGNhbiBwYXVzZSgpIGl0IHRvIHByZXZlbnQgY29uZmxpY3RzLlxuXG4gIHJldHVybiBzZWxmO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5zb3J0ID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgcmV0dXJuIF90cmlnZ2Vycy5zb3J0KGZ1bmMgfHwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gKGEudmFycy5yZWZyZXNoUHJpb3JpdHkgfHwgMCkgKiAtMWU2ICsgYS5zdGFydCAtIChiLnN0YXJ0ICsgKGIudmFycy5yZWZyZXNoUHJpb3JpdHkgfHwgMCkgKiAtMWU2KTtcbiAgfSk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLm9ic2VydmUgPSBmdW5jdGlvbiAodmFycykge1xuICByZXR1cm4gbmV3IE9ic2VydmVyKHZhcnMpO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5ub3JtYWxpemVTY3JvbGwgPSBmdW5jdGlvbiAodmFycykge1xuICBpZiAodHlwZW9mIHZhcnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gX25vcm1hbGl6ZXI7XG4gIH1cblxuICBpZiAodmFycyA9PT0gdHJ1ZSAmJiBfbm9ybWFsaXplcikge1xuICAgIHJldHVybiBfbm9ybWFsaXplci5lbmFibGUoKTtcbiAgfVxuXG4gIGlmICh2YXJzID09PSBmYWxzZSkge1xuICAgIF9ub3JtYWxpemVyICYmIF9ub3JtYWxpemVyLmtpbGwoKTtcbiAgICBfbm9ybWFsaXplciA9IHZhcnM7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5vcm1hbGl6ZXIgPSB2YXJzIGluc3RhbmNlb2YgT2JzZXJ2ZXIgPyB2YXJzIDogX2dldFNjcm9sbE5vcm1hbGl6ZXIodmFycyk7XG4gIF9ub3JtYWxpemVyICYmIF9ub3JtYWxpemVyLnRhcmdldCA9PT0gbm9ybWFsaXplci50YXJnZXQgJiYgX25vcm1hbGl6ZXIua2lsbCgpO1xuICBfaXNWaWV3cG9ydChub3JtYWxpemVyLnRhcmdldCkgJiYgKF9ub3JtYWxpemVyID0gbm9ybWFsaXplcik7XG4gIHJldHVybiBub3JtYWxpemVyO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5jb3JlID0ge1xuICAvLyBzbWFsbGVyIGZpbGUgc2l6ZSB3YXkgdG8gbGV2ZXJhZ2UgaW4gU2Nyb2xsU21vb3RoZXIgYW5kIE9ic2VydmVyXG4gIF9nZXRWZWxvY2l0eVByb3A6IF9nZXRWZWxvY2l0eVByb3AsXG4gIF9pbnB1dE9ic2VydmVyOiBfaW5wdXRPYnNlcnZlcixcbiAgX3Njcm9sbGVyczogX3Njcm9sbGVycyxcbiAgX3Byb3hpZXM6IF9wcm94aWVzLFxuICBicmlkZ2U6IHtcbiAgICAvLyB3aGVuIG5vcm1hbGl6ZVNjcm9sbCBzZXRzIHRoZSBzY3JvbGwgcG9zaXRpb24gKHNzID0gc2V0U2Nyb2xsKVxuICAgIHNzOiBmdW5jdGlvbiBzcygpIHtcbiAgICAgIF9sYXN0U2Nyb2xsVGltZSB8fCBfZGlzcGF0Y2goXCJzY3JvbGxTdGFydFwiKTtcbiAgICAgIF9sYXN0U2Nyb2xsVGltZSA9IF9nZXRUaW1lKCk7XG4gICAgfSxcbiAgICAvLyBhIHdheSB0byBnZXQgdGhlIF9yZWZyZXNoaW5nIHZhbHVlIGluIE9ic2VydmVyXG4gICAgcmVmOiBmdW5jdGlvbiByZWYoKSB7XG4gICAgICByZXR1cm4gX3JlZnJlc2hpbmc7XG4gICAgfVxuICB9XG59O1xuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRyaWdnZXIpO1xuZXhwb3J0IHsgU2Nyb2xsVHJpZ2dlciBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbIk9ic2VydmVyIiwiX2dldFRhcmdldCIsIl92ZXJ0aWNhbCIsIl9ob3Jpem9udGFsIiwiX3Njcm9sbGVycyIsIl9wcm94aWVzIiwiX2dldFNjcm9sbEZ1bmMiLCJfZ2V0UHJveHlQcm9wIiwiX2dldFZlbG9jaXR5UHJvcCIsImdzYXAiLCJfY29yZUluaXR0ZWQiLCJfd2luIiwiX2RvYyIsIl9kb2NFbCIsIl9ib2R5IiwiX3Jvb3QiLCJfcmVzaXplRGVsYXkiLCJfdG9BcnJheSIsIl9jbGFtcCIsIl90aW1lMiIsIl9zeW5jSW50ZXJ2YWwiLCJfcmVmcmVzaGluZyIsIl9wb2ludGVySXNEb3duIiwiX3RyYW5zZm9ybVByb3AiLCJfaSIsIl9wcmV2V2lkdGgiLCJfcHJldkhlaWdodCIsIl9hdXRvUmVmcmVzaCIsIl9zb3J0IiwiX3N1cHByZXNzT3ZlcndyaXRlcyIsIl9pZ25vcmVSZXNpemUiLCJfbm9ybWFsaXplciIsIl9pZ25vcmVNb2JpbGVSZXNpemUiLCJfYmFzZVNjcmVlbkhlaWdodCIsIl9iYXNlU2NyZWVuV2lkdGgiLCJfZml4SU9TQnVnIiwiX2NvbnRleHQiLCJfc2Nyb2xsUmVzdG9yYXRpb24iLCJfZGl2MTAwdmgiLCJfMTAwdmgiLCJfaXNSZXZlcnRlZCIsIl9jbGFtcGluZ01heCIsIl9saW1pdENhbGxiYWNrcyIsIl9zdGFydHVwIiwiX2dldFRpbWUiLCJEYXRlIiwibm93IiwiX3RpbWUxIiwiX2xhc3RTY3JvbGxUaW1lIiwiX2VuYWJsZWQiLCJfcGFyc2VDbGFtcCIsInZhbHVlIiwidHlwZSIsInNlbGYiLCJjbGFtcCIsIl9pc1N0cmluZyIsInN1YnN0ciIsImluZGV4T2YiLCJsZW5ndGgiLCJfa2VlcENsYW1wIiwiX3JhZkJ1Z0ZpeCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIl9wb2ludGVyRG93bkhhbmRsZXIiLCJfcG9pbnRlclVwSGFuZGxlciIsIl9wYXNzVGhyb3VnaCIsInYiLCJfcm91bmQiLCJNYXRoIiwicm91bmQiLCJfd2luZG93RXhpc3RzIiwid2luZG93IiwiX2dldEdTQVAiLCJyZWdpc3RlclBsdWdpbiIsIl9pc1ZpZXdwb3J0IiwiZSIsIl9nZXRWaWV3cG9ydERpbWVuc2lvbiIsImRpbWVuc2lvblByb3BlcnR5IiwiX2dldEJvdW5kc0Z1bmMiLCJlbGVtZW50IiwiX3dpbk9mZnNldHMiLCJ3aWR0aCIsImlubmVyV2lkdGgiLCJoZWlnaHQiLCJfZ2V0Qm91bmRzIiwiX2dldFNpemVGdW5jIiwic2Nyb2xsZXIiLCJpc1ZpZXdwb3J0IiwiX3JlZiIsImQiLCJkMiIsImEiLCJfZ2V0T2Zmc2V0c0Z1bmMiLCJfbWF4U2Nyb2xsIiwiX3JlZjIiLCJzIiwibWF4IiwiX2l0ZXJhdGVBdXRvUmVmcmVzaCIsImZ1bmMiLCJldmVudHMiLCJpIiwiX2lzRnVuY3Rpb24iLCJfaXNOdW1iZXIiLCJfaXNPYmplY3QiLCJfZW5kQW5pbWF0aW9uIiwiYW5pbWF0aW9uIiwicmV2ZXJzZWQiLCJwYXVzZSIsInByb2dyZXNzIiwiX2NhbGxiYWNrIiwiZW5hYmxlZCIsInJlc3VsdCIsIl9jdHgiLCJhZGQiLCJ0b3RhbFRpbWUiLCJjYWxsYmFja0FuaW1hdGlvbiIsIl9hYnMiLCJhYnMiLCJfbGVmdCIsIl90b3AiLCJfcmlnaHQiLCJfYm90dG9tIiwiX3dpZHRoIiwiX2hlaWdodCIsIl9SaWdodCIsIl9MZWZ0IiwiX1RvcCIsIl9Cb3R0b20iLCJfcGFkZGluZyIsIl9tYXJnaW4iLCJfV2lkdGgiLCJfSGVpZ2h0IiwiX3B4IiwiX2dldENvbXB1dGVkU3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiX21ha2VQb3NpdGlvbmFibGUiLCJwb3NpdGlvbiIsInN0eWxlIiwiX3NldERlZmF1bHRzIiwib2JqIiwiZGVmYXVsdHMiLCJwIiwid2l0aG91dFRyYW5zZm9ybXMiLCJ0d2VlbiIsInRvIiwieCIsInkiLCJ4UGVyY2VudCIsInlQZXJjZW50Iiwicm90YXRpb24iLCJyb3RhdGlvblgiLCJyb3RhdGlvblkiLCJzY2FsZSIsInNrZXdYIiwic2tld1kiLCJib3VuZHMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJraWxsIiwiX2dldFNpemUiLCJfcmVmMyIsIl9nZXRMYWJlbFJhdGlvQXJyYXkiLCJ0aW1lbGluZSIsImxhYmVscyIsImR1cmF0aW9uIiwicHVzaCIsIl9nZXRDbG9zZXN0TGFiZWwiLCJ1dGlscyIsInNuYXAiLCJfc25hcERpcmVjdGlvbmFsIiwic25hcEluY3JlbWVudE9yQXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJzbGljZSIsInNvcnQiLCJiIiwiZGlyZWN0aW9uIiwidGhyZXNob2xkIiwic25hcHBlZCIsIl9nZXRMYWJlbEF0RGlyZWN0aW9uIiwic3QiLCJfbXVsdGlMaXN0ZW5lciIsInR5cGVzIiwiY2FsbGJhY2siLCJzcGxpdCIsImZvckVhY2giLCJfYWRkTGlzdGVuZXIiLCJub25QYXNzaXZlIiwiY2FwdHVyZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwiX3JlbW92ZUxpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIl93aGVlbExpc3RlbmVyIiwiZWwiLCJzY3JvbGxGdW5jIiwid2hlZWxIYW5kbGVyIiwiX21hcmtlckRlZmF1bHRzIiwic3RhcnRDb2xvciIsImVuZENvbG9yIiwiaW5kZW50IiwiZm9udFNpemUiLCJmb250V2VpZ2h0IiwiX2RlZmF1bHRzIiwidG9nZ2xlQWN0aW9ucyIsImFudGljaXBhdGVQaW4iLCJfa2V5d29yZHMiLCJ0b3AiLCJsZWZ0IiwiY2VudGVyIiwiYm90dG9tIiwicmlnaHQiLCJfb2Zmc2V0VG9QeCIsInNpemUiLCJlcUluZGV4IiwicmVsYXRpdmUiLCJjaGFyQXQiLCJwYXJzZUZsb2F0IiwiX2NyZWF0ZU1hcmtlciIsIm5hbWUiLCJjb250YWluZXIiLCJfcmVmNCIsIm9mZnNldCIsIm1hdGNoV2lkdGhFbCIsImNvbnRhaW5lckFuaW1hdGlvbiIsImNyZWF0ZUVsZW1lbnQiLCJ1c2VGaXhlZFBvc2l0aW9uIiwiaXNTY3JvbGxlciIsInBhcmVudCIsImlzU3RhcnQiLCJjb2xvciIsImNzcyIsIm9mZnNldFdpZHRoIiwiX2lzU3RhcnQiLCJzZXRBdHRyaWJ1dGUiLCJjc3NUZXh0IiwiaW5uZXJUZXh0IiwiY2hpbGRyZW4iLCJpbnNlcnRCZWZvcmUiLCJhcHBlbmRDaGlsZCIsIl9vZmZzZXQiLCJvcCIsIl9wb3NpdGlvbk1hcmtlciIsIm1hcmtlciIsInN0YXJ0IiwiZmxpcHBlZCIsInZhcnMiLCJkaXNwbGF5Iiwic2lkZSIsIm9wcG9zaXRlU2lkZSIsIl9pc0ZsaXBwZWQiLCJzZXQiLCJfdHJpZ2dlcnMiLCJfaWRzIiwiX3JhZklEIiwiX3N5bmMiLCJfdXBkYXRlQWxsIiwiX29uU2Nyb2xsIiwiaXNQcmVzc2VkIiwic3RhcnRYIiwiY2xpZW50V2lkdGgiLCJjYWNoZSIsIl9kaXNwYXRjaCIsIl9zZXRCYXNlRGltZW5zaW9ucyIsImlubmVySGVpZ2h0IiwiX29uUmVzaXplIiwiZnVsbHNjcmVlbkVsZW1lbnQiLCJ3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCIsInJlc3RhcnQiLCJfbGlzdGVuZXJzIiwiX2VtcHR5QXJyYXkiLCJfc29mdFJlZnJlc2giLCJTY3JvbGxUcmlnZ2VyIiwiX3JlZnJlc2hBbGwiLCJtYXAiLCJmIiwiX3NhdmVkU3R5bGVzIiwiX3JldmVydFJlY29yZGVkIiwibWVkaWEiLCJxdWVyeSIsImdldEJCb3giLCJ1bmNhY2hlIiwiX3JldmVydEFsbCIsInRyaWdnZXIiLCJyZXZlcnQiLCJfY2xlYXJTY3JvbGxNZW1vcnkiLCJzY3JvbGxSZXN0b3JhdGlvbiIsImZvcmNlIiwiX3JlZnJlc2hpbmdBbGwiLCJjYWNoZUlEIiwicmVjIiwiaGlzdG9yeSIsIl9yZWZyZXNoSUQiLCJfcXVldWVSZWZyZXNoSUQiLCJfcXVldWVSZWZyZXNoQWxsIiwiaWQiLCJfcmVmcmVzaDEwMHZoIiwib2Zmc2V0SGVpZ2h0IiwicmVtb3ZlQ2hpbGQiLCJfaGlkZUFsbE1hcmtlcnMiLCJoaWRlIiwic2tpcFJldmVydCIsImlzUmVmcmVzaGluZyIsInJlZnJlc2hJbml0cyIsInNtb290aCIsInRhcmdldCIsInNjcm9sbEJlaGF2aW9yIiwidCIsInJlZnJlc2giLCJfc3ViUGluT2Zmc2V0IiwicGluIiwicHJvcCIsImhvcml6b250YWwiLCJvcmlnaW5hbCIsImFkanVzdFBpblNwYWNpbmciLCJfZGlyIiwiZW5kQ2xhbXAiLCJlbmQiLCJfZW5kQ2xhbXAiLCJzdGFydENsYW1wIiwiX3N0YXJ0Q2xhbXAiLCJzZXRQb3NpdGlvbnMiLCJyZW5kZXIiLCJvblJlZnJlc2giLCJfbGFzdFNjcm9sbCIsIl9kaXJlY3Rpb24iLCJfcHJpbWFyeSIsImlzVXBkYXRpbmciLCJ1cGRhdGUiLCJsIiwidGltZSIsInJlY29yZFZlbG9jaXR5Iiwic2Nyb2xsIiwiX3Byb3BOYW1lc1RvQ29weSIsIl9zdGF0ZVByb3BzIiwiY29uY2F0IiwiX3N3YXBQaW5PdXQiLCJzcGFjZXIiLCJzdGF0ZSIsIl9zZXRTdGF0ZSIsIl9nc2FwIiwic3BhY2VySXNOYXRpdmUiLCJzcGFjZXJTdGF0ZSIsInN3YXBwZWRJbiIsInBhcmVudE5vZGUiLCJfc3dhcFBpbkluIiwiY3MiLCJzcGFjZXJTdHlsZSIsInBpblN0eWxlIiwiZmxleEJhc2lzIiwib3ZlcmZsb3ciLCJib3hTaXppbmciLCJfY2Fwc0V4cCIsImNvcmUiLCJnZXRDYWNoZSIsInJlbW92ZVByb3BlcnR5IiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwiX2dldFN0YXRlIiwiX2NvcHlTdGF0ZSIsIm92ZXJyaWRlIiwib21pdE9mZnNldHMiLCJfcGFyc2VQb3NpdGlvbiIsInNjcm9sbGVyU2l6ZSIsIm1hcmtlclNjcm9sbGVyIiwic2Nyb2xsZXJCb3VuZHMiLCJib3JkZXJXaWR0aCIsInNjcm9sbGVyTWF4IiwiY2xhbXBaZXJvUHJvcCIsInAxIiwicDIiLCJzZWVrIiwiaXNOYU4iLCJvZmZzZXRzIiwibG9jYWxPZmZzZXQiLCJnbG9iYWxPZmZzZXQiLCJtYXBSYW5nZSIsInNjcm9sbFRyaWdnZXIiLCJtIiwiX2NhU2Nyb2xsRGlzdCIsIl9wcmVmaXhFeHAiLCJfcmVwYXJlbnQiLCJfc3RPcmlnIiwidGVzdCIsIl9pbnRlcnJ1cHRpb25UcmFja2VyIiwiZ2V0VmFsdWVGdW5jIiwiaW5pdGlhbFZhbHVlIiwib25JbnRlcnJ1cHQiLCJsYXN0MSIsImxhc3QyIiwiY3VycmVudCIsIl9zaGlmdE1hcmtlciIsIl9nZXRUd2VlbkNyZWF0b3IiLCJnZXRTY3JvbGwiLCJnZXRUd2VlbiIsInNjcm9sbFRvIiwiY2hhbmdlMSIsImNoYW5nZTIiLCJvbkNvbXBsZXRlIiwibW9kaWZpZXJzIiwiY2hlY2tGb3JJbnRlcnJ1cHRpb24iLCJpbmhlcml0IiwicmF0aW8iLCJvblVwZGF0ZSIsImNhbGwiLCJpc1RvdWNoIiwicmVnaXN0ZXIiLCJjb25zb2xlIiwid2FybiIsImluaXQiLCJfcHJvdG8iLCJwcm90b3R5cGUiLCJub2RlVHlwZSIsIl92YXJzIiwidG9nZ2xlQ2xhc3MiLCJvblRvZ2dsZSIsInNjcnViIiwicGluU3BhY2luZyIsImludmFsaWRhdGVPblJlZnJlc2giLCJvblNjcnViQ29tcGxldGUiLCJvblNuYXBDb21wbGV0ZSIsIm9uY2UiLCJwaW5SZXBhcmVudCIsInBpblNwYWNlciIsImZhc3RTY3JvbGxFbmQiLCJwcmV2ZW50T3ZlcmxhcHMiLCJpc1RvZ2dsZSIsInNjcm9sbGVyQ2FjaGUiLCJwaW5UeXBlIiwiY2FsbGJhY2tzIiwib25FbnRlciIsIm9uTGVhdmUiLCJvbkVudGVyQmFjayIsIm9uTGVhdmVCYWNrIiwibWFya2VycyIsIm9uUmVmcmVzaEluaXQiLCJnZXRTY3JvbGxlclNpemUiLCJnZXRTY3JvbGxlck9mZnNldHMiLCJsYXN0U25hcCIsImxhc3RSZWZyZXNoIiwicHJldlByb2dyZXNzIiwidHdlZW5UbyIsInBpbkNhY2hlIiwic25hcEZ1bmMiLCJzY3JvbGwxIiwic2Nyb2xsMiIsIm1hcmtlclN0YXJ0IiwibWFya2VyRW5kIiwibWFya2VyU3RhcnRUcmlnZ2VyIiwibWFya2VyRW5kVHJpZ2dlciIsIm1hcmtlclZhcnMiLCJleGVjdXRpbmdPblJlZnJlc2giLCJjaGFuZ2UiLCJwaW5PcmlnaW5hbFN0YXRlIiwicGluQWN0aXZlU3RhdGUiLCJwaW5TdGF0ZSIsInBpbkdldHRlciIsInBpblNldHRlciIsInBpblN0YXJ0IiwicGluQ2hhbmdlIiwic3BhY2luZ1N0YXJ0IiwibWFya2VyU3RhcnRTZXR0ZXIiLCJwaW5Nb3ZlcyIsIm1hcmtlckVuZFNldHRlciIsInNuYXAxIiwic25hcDIiLCJzY3J1YlR3ZWVuIiwic2NydWJTbW9vdGgiLCJzbmFwRHVyQ2xhbXAiLCJzbmFwRGVsYXllZENhbGwiLCJwcmV2U2Nyb2xsIiwicHJldkFuaW1Qcm9ncmVzcyIsImNhTWFya2VyU2V0dGVyIiwiY3VzdG9tUmV2ZXJ0UmV0dXJuIiwiYmluZCIsInJlZnJlc2hQcmlvcml0eSIsInR3ZWVuU2Nyb2xsIiwic2NydWJEdXJhdGlvbiIsImVhc2UiLCJ0b3RhbFByb2dyZXNzIiwicGF1c2VkIiwibGF6eSIsIl9pbml0dGVkIiwiaXNSZXZlcnRlZCIsImltbWVkaWF0ZVJlbmRlciIsInNuYXBUbyIsIm8iLCJzY3JvbGxpbmdFbGVtZW50IiwiZGlyZWN0aW9uYWwiLCJtaW4iLCJkZWxheWVkQ2FsbCIsImRlbGF5IiwicmVmcmVzaGVkUmVjZW50bHkiLCJnZXRWZWxvY2l0eSIsInZlbG9jaXR5IiwibmF0dXJhbEVuZCIsImluZXJ0aWEiLCJlbmRWYWx1ZSIsImVuZFNjcm9sbCIsIl9zbmFwIiwib25TdGFydCIsIl9vbkludGVycnVwdCIsIl9vbkNvbXBsZXRlIiwiZGF0YSIsInJlc2V0VG8iLCJfdFRpbWUiLCJfdER1ciIsImlzQWN0aXZlIiwic3RSZXZlcnQiLCJ0YXJnZXRzIiwiY2xhc3NOYW1lIiwibmF0aXZlRWxlbWVudCIsImNsYXNzTGlzdCIsImZvcmNlM0QiLCJvczIiLCJnZXRQcm9wZXJ0eSIsInF1aWNrU2V0dGVyIiwiY29udGVudCIsIm9sZE9uVXBkYXRlIiwib2xkUGFyYW1zIiwib25VcGRhdGVQYXJhbXMiLCJldmVudENhbGxiYWNrIiwiYXBwbHkiLCJwcmV2aW91cyIsIm5leHQiLCJ0ZW1wIiwiciIsInByZXZSZWZyZXNoaW5nIiwic29mdCIsInBpbk9mZnNldCIsImludmFsaWRhdGUiLCJpc0ZpcnN0UmVmcmVzaCIsIm90aGVyUGluT2Zmc2V0IiwicGFyc2VkRW5kIiwicGFyc2VkRW5kVHJpZ2dlciIsImVuZFRyaWdnZXIiLCJwYXJzZWRTdGFydCIsInBpbm5lZENvbnRhaW5lciIsInRyaWdnZXJJbmRleCIsImlzVmVydGljYWwiLCJjdXJUcmlnZ2VyIiwiY3VyUGluIiwib3Bwb3NpdGVTY3JvbGwiLCJpbml0dGVkIiwicmV2ZXJ0ZWRQaW5zIiwiZm9yY2VkT3ZlcmZsb3ciLCJtYXJrZXJTdGFydE9mZnNldCIsIm1hcmtlckVuZE9mZnNldCIsInVuc2hpZnQiLCJfcGluUHVzaCIsIm5vcm1hbGl6ZSIsInRvVXBwZXJDYXNlIiwiY2VpbCIsInNwbGljZSIsIl9waW5PZmZzZXQiLCJlbmRBbmltYXRpb24iLCJsYWJlbFRvU2Nyb2xsIiwibGFiZWwiLCJnZXRUcmFpbGluZyIsInJldmVyc2UiLCJmaWx0ZXIiLCJyZXNldCIsImZvcmNlRmFrZSIsImNsaXBwZWQiLCJ3YXNBY3RpdmUiLCJ0b2dnbGVTdGF0ZSIsImFjdGlvbiIsInN0YXRlQ2hhbmdlZCIsInRvZ2dsZWQiLCJpc0F0TWF4IiwiaXNUYWtpbmdBY3Rpb24iLCJfZHAiLCJfdGltZSIsIl9zdGFydCIsIm4iLCJlbmFibGUiLCJuZXdTdGFydCIsIm5ld0VuZCIsImtlZXBDbGFtcCIsIl9jaGFuZ2UiLCJhbW91bnQiLCJkaXNhYmxlIiwiYWxsb3dBbmltYXRpb24iLCJvbktpbGwiLCJ1cGRhdGVGdW5jIiwiZG9jdW1lbnQiLCJjb25maWciLCJjbGVhckludGVydmFsIiwiZG9jdW1lbnRFbGVtZW50IiwiYm9keSIsInRvQXJyYXkiLCJjb250ZXh0Iiwic3VwcHJlc3NPdmVyd3JpdGVzIiwicGFnZVlPZmZzZXQiLCJnbG9iYWxzIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwibWF0Y2hNZWRpYSIsIm1tIiwiYm9keVN0eWxlIiwiYm9yZGVyIiwiYm9yZGVyVG9wU3R5bGUiLCJBbmltYXRpb25Qcm90byIsIkFuaW1hdGlvbiIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwic2MiLCJzZXRJbnRlcnZhbCIsImNoZWNrUHJlZml4IiwidyIsImgiLCJoaWRkZW4iLCJsaW1pdENhbGxiYWNrcyIsIm1zIiwic3luY0ludGVydmFsIiwiaWdub3JlTW9iaWxlUmVzaXplIiwiYXV0b1JlZnJlc2hFdmVudHMiLCJzY3JvbGxlclByb3h5IiwiY2xlYXJNYXRjaE1lZGlhIiwiaXNJblZpZXdwb3J0IiwicG9zaXRpb25JblZpZXdwb3J0IiwicmVmZXJlbmNlUG9pbnQiLCJraWxsQWxsIiwiYWxsb3dMaXN0ZW5lcnMiLCJsaXN0ZW5lcnMiLCJ2ZXJzaW9uIiwic2F2ZVN0eWxlcyIsImdldEF0dHJpYnV0ZSIsImNyZWF0ZSIsInNhZmUiLCJjbGVhclNjcm9sbE1lbW9yeSIsIm1heFNjcm9sbCIsImdldFNjcm9sbEZ1bmMiLCJnZXRCeUlkIiwiZ2V0QWxsIiwiaXNTY3JvbGxpbmciLCJzbmFwRGlyZWN0aW9uYWwiLCJiYXRjaCIsInZhcnNDb3B5IiwiaW50ZXJ2YWwiLCJiYXRjaE1heCIsInByb3h5Q2FsbGJhY2siLCJlbGVtZW50cyIsInRyaWdnZXJzIiwiX2NsYW1wU2Nyb2xsQW5kR2V0RHVyYXRpb25NdWx0aXBsaWVyIiwiX2FsbG93TmF0aXZlUGFubmluZyIsInRvdWNoQWN0aW9uIiwiX292ZXJmbG93IiwiYXV0byIsIl9uZXN0ZWRTY3JvbGwiLCJfcmVmNSIsImV2ZW50IiwiYXhpcyIsIm5vZGUiLCJjaGFuZ2VkVG91Y2hlcyIsIl9pc1Njcm9sbFQiLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxXaWR0aCIsIm92ZXJmbG93WSIsIm92ZXJmbG93WCIsIl9pc1Njcm9sbCIsInN0b3BQcm9wYWdhdGlvbiIsIl9nc2FwQWxsb3ciLCJfaW5wdXRPYnNlcnZlciIsImlucHV0cyIsIm5lc3RlZCIsImRlYm91bmNlIiwibG9ja0F4aXMiLCJvbldoZWVsIiwib25QcmVzcyIsIm9uRHJhZyIsIm9uU2Nyb2xsIiwib25FbmFibGUiLCJldmVudFR5cGVzIiwiX2NhcHR1cmVJbnB1dHMiLCJvbkRpc2FibGUiLCJfaW5wdXRFeHAiLCJfaW5wdXRJc0ZvY3VzZWQiLCJpc0lucHV0IiwidGFnTmFtZSIsIl9nZXRTY3JvbGxOb3JtYWxpemVyIiwicHJldmVudERlZmF1bHQiLCJpc05vcm1hbGl6ZXIiLCJhbGxvd0NsaWNrcyIsIl92YXJzMiIsIm5vcm1hbGl6ZVNjcm9sbFgiLCJtb21lbnR1bSIsImFsbG93TmVzdGVkU2Nyb2xsIiwib25SZWxlYXNlIiwibWF4WSIsInNtb290aGVyIiwiU2Nyb2xsU21vb3RoZXIiLCJzbW9vdGhlckluc3RhbmNlIiwiZ2V0Iiwic2Nyb2xsRnVuY1kiLCJzY3JvbGxGdW5jWCIsImluaXRpYWxTY2FsZSIsInZpc3VhbFZpZXdwb3J0Iiwib3V0ZXJXaWR0aCIsIndoZWVsUmVmcmVzaCIsInJlc29sdmVNb21lbnR1bUR1cmF0aW9uIiwibGFzdFJlZnJlc2hJRCIsInNraXBUb3VjaE1vdmUiLCJpbnB1dE9ic2VydmVyIiwicmVzdW1lVG91Y2hNb3ZlIiwic2Nyb2xsQ2xhbXBYIiwic2Nyb2xsQ2xhbXBZIiwidXBkYXRlQ2xhbXBzIiwicmVtb3ZlQ29udGVudE9mZnNldCIsInRyYW5zZm9ybSIsImlnbm9yZURyYWciLCJkZWx0YVkiLCJzdGFydFNjcm9sbFgiLCJzdGFydFNjcm9sbFkiLCJvblN0b3BEZWxheWVkQ2FsbCIsIm9uUmVzaXplIiwic2Nyb2xsWSIsImlnbm9yZUNoZWNrIiwiaXNHZXN0dXJpbmciLCJ0b3VjaGVzIiwicHJldlNjYWxlIiwib25HZXN0dXJlU3RhcnQiLCJ3YXNEcmFnZ2luZyIsImR1ciIsImN1cnJlbnRTY3JvbGwiLCJ2ZWxvY2l0eVgiLCJzY3JvbGxYIiwidmVsb2NpdHlZIiwicGxheSIsIl90cyIsIm9uQ2hhbmdlIiwiZHgiLCJkeSIsInhBcnJheSIsInlBcnJheSIsInN0YXJ0WSIsInlDbGFtcGVkIiwiaU9TIiwidGlja2VyIiwiX2RjIiwib2JzZXJ2ZSIsIm5vcm1hbGl6ZVNjcm9sbCIsIm5vcm1hbGl6ZXIiLCJicmlkZ2UiLCJzcyIsInJlZiIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollTrigger.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/TextPlugin.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/TextPlugin.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextPlugin: function() { return /* binding */ TextPlugin; },\n/* harmony export */   \"default\": function() { return /* binding */ TextPlugin; }\n/* harmony export */ });\n/* harmony import */ var _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/strings.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/strings.js\");\n/*!\n * TextPlugin 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ \nvar gsap, _tempDiv, _getGSAP = function _getGSAP() {\n    return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n};\nvar TextPlugin = {\n    version: \"3.12.5\",\n    name: \"text\",\n    init: function init(target, value, tween) {\n        typeof value !== \"object\" && (value = {\n            value: value\n        });\n        var i = target.nodeName.toUpperCase(), data = this, _value = value, newClass = _value.newClass, oldClass = _value.oldClass, preserveSpaces = _value.preserveSpaces, rtl = _value.rtl, delimiter = data.delimiter = value.delimiter || \"\", fillChar = data.fillChar = value.fillChar || (value.padSpace ? \"&nbsp;\" : \"\"), _short, text, original, j, condensedText, condensedOriginal, aggregate, s;\n        data.svg = target.getBBox && (i === \"TEXT\" || i === \"TSPAN\");\n        if (!(\"innerHTML\" in target) && !data.svg) {\n            return false;\n        }\n        data.target = target;\n        if (!(\"value\" in value)) {\n            data.text = data.original = [\n                \"\"\n            ];\n            return;\n        }\n        original = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitInnerHTML)(target, delimiter, false, preserveSpaces);\n        _tempDiv || (_tempDiv = document.createElement(\"div\"));\n        _tempDiv.innerHTML = value.value;\n        text = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitInnerHTML)(_tempDiv, delimiter, false, preserveSpaces);\n        data.from = tween._from;\n        if ((data.from || rtl) && !(rtl && data.from)) {\n            // right-to-left or \"from()\" tweens should invert things (but if it's BOTH .from() and rtl, inverting twice equals not inverting at all :)\n            i = original;\n            original = text;\n            text = i;\n        }\n        data.hasClass = !!(newClass || oldClass);\n        data.newClass = rtl ? oldClass : newClass;\n        data.oldClass = rtl ? newClass : oldClass;\n        i = original.length - text.length;\n        _short = i < 0 ? original : text;\n        if (i < 0) {\n            i = -i;\n        }\n        while(--i > -1){\n            _short.push(fillChar);\n        }\n        if (value.type === \"diff\") {\n            j = 0;\n            condensedText = [];\n            condensedOriginal = [];\n            aggregate = \"\";\n            for(i = 0; i < text.length; i++){\n                s = text[i];\n                if (s === original[i]) {\n                    aggregate += s;\n                } else {\n                    condensedText[j] = aggregate + s;\n                    condensedOriginal[j++] = aggregate + original[i];\n                    aggregate = \"\";\n                }\n            }\n            text = condensedText;\n            original = condensedOriginal;\n            if (aggregate) {\n                text.push(aggregate);\n                original.push(aggregate);\n            }\n        }\n        value.speed && tween.duration(Math.min(0.05 / value.speed * _short.length, value.maxDuration || 9999));\n        data.rtl = rtl;\n        data.original = original;\n        data.text = text;\n        data._props.push(\"text\");\n    },\n    render: function render(ratio, data) {\n        if (ratio > 1) {\n            ratio = 1;\n        } else if (ratio < 0) {\n            ratio = 0;\n        }\n        if (data.from) {\n            ratio = 1 - ratio;\n        }\n        var text = data.text, hasClass = data.hasClass, newClass = data.newClass, oldClass = data.oldClass, delimiter = data.delimiter, target = data.target, fillChar = data.fillChar, original = data.original, rtl = data.rtl, l = text.length, i = (rtl ? 1 - ratio : ratio) * l + 0.5 | 0, applyNew, applyOld, str;\n        if (hasClass && ratio) {\n            applyNew = newClass && i;\n            applyOld = oldClass && i !== l;\n            str = (applyNew ? \"<span class='\" + newClass + \"'>\" : \"\") + text.slice(0, i).join(delimiter) + (applyNew ? \"</span>\" : \"\") + (applyOld ? \"<span class='\" + oldClass + \"'>\" : \"\") + delimiter + original.slice(i).join(delimiter) + (applyOld ? \"</span>\" : \"\");\n        } else {\n            str = text.slice(0, i).join(delimiter) + delimiter + original.slice(i).join(delimiter);\n        }\n        if (data.svg) {\n            //SVG text elements don't have an \"innerHTML\" in Microsoft browsers.\n            target.textContent = str;\n        } else {\n            target.innerHTML = fillChar === \"&nbsp;\" && ~str.indexOf(\"  \") ? str.split(\"  \").join(\"&nbsp;&nbsp;\") : str;\n        }\n    }\n};\nTextPlugin.splitInnerHTML = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitInnerHTML;\nTextPlugin.emojiSafeSplit = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit;\nTextPlugin.getText = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.getText;\n_getGSAP() && gsap.registerPlugin(TextPlugin);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9UZXh0UGx1Z2luLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCLEdBQzJEO0FBRTdFLElBQUlHLE1BQ0FDLFVBQ0FDLFdBQVcsU0FBU0E7SUFDdEIsT0FBT0YsUUFBUSxPQUFPRyxXQUFXLGVBQWdCSCxDQUFBQSxPQUFPRyxPQUFPSCxJQUFJLEtBQUtBLEtBQUtJLGNBQWMsSUFBSUo7QUFDakc7QUFFTyxJQUFJSyxhQUFhO0lBQ3RCQyxTQUFTO0lBQ1RDLE1BQU07SUFDTkMsTUFBTSxTQUFTQSxLQUFLQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsS0FBSztRQUN0QyxPQUFPRCxVQUFVLFlBQWFBLENBQUFBLFFBQVE7WUFDcENBLE9BQU9BO1FBQ1Q7UUFFQSxJQUFJRSxJQUFJSCxPQUFPSSxRQUFRLENBQUNDLFdBQVcsSUFDL0JDLE9BQU8sSUFBSSxFQUNYQyxTQUFTTixPQUNUTyxXQUFXRCxPQUFPQyxRQUFRLEVBQzFCQyxXQUFXRixPQUFPRSxRQUFRLEVBQzFCQyxpQkFBaUJILE9BQU9HLGNBQWMsRUFDdENDLE1BQU1KLE9BQU9JLEdBQUcsRUFDaEJDLFlBQVlOLEtBQUtNLFNBQVMsR0FBR1gsTUFBTVcsU0FBUyxJQUFJLElBQ2hEQyxXQUFXUCxLQUFLTyxRQUFRLEdBQUdaLE1BQU1ZLFFBQVEsSUFBS1osQ0FBQUEsTUFBTWEsUUFBUSxHQUFHLFdBQVcsRUFBQyxHQUMzRUMsUUFDQUMsTUFDQUMsVUFDQUMsR0FDQUMsZUFDQUMsbUJBQ0FDLFdBQ0FDO1FBRUpoQixLQUFLaUIsR0FBRyxHQUFHdkIsT0FBT3dCLE9BQU8sSUFBS3JCLENBQUFBLE1BQU0sVUFBVUEsTUFBTSxPQUFNO1FBRTFELElBQUksQ0FBRSxnQkFBZUgsTUFBSyxLQUFNLENBQUNNLEtBQUtpQixHQUFHLEVBQUU7WUFDekMsT0FB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Y0YsS0FBS0ksY0FBYyxDQUFDQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9UZXh0UGx1Z2luLmpzPzk3M2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUZXh0UGx1Z2luIDMuMTIuNVxuICogaHR0cHM6Ly9nc2FwLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjQsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3NhcC5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR1NBUCBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCB7IGVtb2ppU2FmZVNwbGl0LCBnZXRUZXh0LCBzcGxpdElubmVySFRNTCB9IGZyb20gXCIuL3V0aWxzL3N0cmluZ3MuanNcIjtcblxudmFyIGdzYXAsXG4gICAgX3RlbXBEaXYsXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59O1xuXG5leHBvcnQgdmFyIFRleHRQbHVnaW4gPSB7XG4gIHZlcnNpb246IFwiMy4xMi41XCIsXG4gIG5hbWU6IFwidGV4dFwiLFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFsdWUsIHR3ZWVuKSB7XG4gICAgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiICYmICh2YWx1ZSA9IHtcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuXG4gICAgdmFyIGkgPSB0YXJnZXQubm9kZU5hbWUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgZGF0YSA9IHRoaXMsXG4gICAgICAgIF92YWx1ZSA9IHZhbHVlLFxuICAgICAgICBuZXdDbGFzcyA9IF92YWx1ZS5uZXdDbGFzcyxcbiAgICAgICAgb2xkQ2xhc3MgPSBfdmFsdWUub2xkQ2xhc3MsXG4gICAgICAgIHByZXNlcnZlU3BhY2VzID0gX3ZhbHVlLnByZXNlcnZlU3BhY2VzLFxuICAgICAgICBydGwgPSBfdmFsdWUucnRsLFxuICAgICAgICBkZWxpbWl0ZXIgPSBkYXRhLmRlbGltaXRlciA9IHZhbHVlLmRlbGltaXRlciB8fCBcIlwiLFxuICAgICAgICBmaWxsQ2hhciA9IGRhdGEuZmlsbENoYXIgPSB2YWx1ZS5maWxsQ2hhciB8fCAodmFsdWUucGFkU3BhY2UgPyBcIiZuYnNwO1wiIDogXCJcIiksXG4gICAgICAgIF9zaG9ydCxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgb3JpZ2luYWwsXG4gICAgICAgIGosXG4gICAgICAgIGNvbmRlbnNlZFRleHQsXG4gICAgICAgIGNvbmRlbnNlZE9yaWdpbmFsLFxuICAgICAgICBhZ2dyZWdhdGUsXG4gICAgICAgIHM7XG5cbiAgICBkYXRhLnN2ZyA9IHRhcmdldC5nZXRCQm94ICYmIChpID09PSBcIlRFWFRcIiB8fCBpID09PSBcIlRTUEFOXCIpO1xuXG4gICAgaWYgKCEoXCJpbm5lckhUTUxcIiBpbiB0YXJnZXQpICYmICFkYXRhLnN2Zykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGRhdGEudGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgaWYgKCEoXCJ2YWx1ZVwiIGluIHZhbHVlKSkge1xuICAgICAgZGF0YS50ZXh0ID0gZGF0YS5vcmlnaW5hbCA9IFtcIlwiXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvcmlnaW5hbCA9IHNwbGl0SW5uZXJIVE1MKHRhcmdldCwgZGVsaW1pdGVyLCBmYWxzZSwgcHJlc2VydmVTcGFjZXMpO1xuICAgIF90ZW1wRGl2IHx8IChfdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgIF90ZW1wRGl2LmlubmVySFRNTCA9IHZhbHVlLnZhbHVlO1xuICAgIHRleHQgPSBzcGxpdElubmVySFRNTChfdGVtcERpdiwgZGVsaW1pdGVyLCBmYWxzZSwgcHJlc2VydmVTcGFjZXMpO1xuICAgIGRhdGEuZnJvbSA9IHR3ZWVuLl9mcm9tO1xuXG4gICAgaWYgKChkYXRhLmZyb20gfHwgcnRsKSAmJiAhKHJ0bCAmJiBkYXRhLmZyb20pKSB7XG4gICAgICAvLyByaWdodC10by1sZWZ0IG9yIFwiZnJvbSgpXCIgdHdlZW5zIHNob3VsZCBpbnZlcnQgdGhpbmdzIChidXQgaWYgaXQncyBCT1RIIC5mcm9tKCkgYW5kIHJ0bCwgaW52ZXJ0aW5nIHR3aWNlIGVxdWFscyBub3QgaW52ZXJ0aW5nIGF0IGFsbCA6KVxuICAgICAgaSA9IG9yaWdpbmFsO1xuICAgICAgb3JpZ2luYWwgPSB0ZXh0O1xuICAgICAgdGV4dCA9IGk7XG4gICAgfVxuXG4gICAgZGF0YS5oYXNDbGFzcyA9ICEhKG5ld0NsYXNzIHx8IG9sZENsYXNzKTtcbiAgICBkYXRhLm5ld0NsYXNzID0gcnRsID8gb2xkQ2xhc3MgOiBuZXdDbGFzcztcbiAgICBkYXRhLm9sZENsYXNzID0gcnRsID8gbmV3Q2xhc3MgOiBvbGRDbGFzcztcbiAgICBpID0gb3JpZ2luYWwubGVuZ3RoIC0gdGV4dC5sZW5ndGg7XG4gICAgX3Nob3J0ID0gaSA8IDAgPyBvcmlnaW5hbCA6IHRleHQ7XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIGkgPSAtaTtcbiAgICB9XG5cbiAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgIF9zaG9ydC5wdXNoKGZpbGxDaGFyKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJkaWZmXCIpIHtcbiAgICAgIGogPSAwO1xuICAgICAgY29uZGVuc2VkVGV4dCA9IFtdO1xuICAgICAgY29uZGVuc2VkT3JpZ2luYWwgPSBbXTtcbiAgICAgIGFnZ3JlZ2F0ZSA9IFwiXCI7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHMgPSB0ZXh0W2ldO1xuXG4gICAgICAgIGlmIChzID09PSBvcmlnaW5hbFtpXSkge1xuICAgICAgICAgIGFnZ3JlZ2F0ZSArPSBzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbmRlbnNlZFRleHRbal0gPSBhZ2dyZWdhdGUgKyBzO1xuICAgICAgICAgIGNvbmRlbnNlZE9yaWdpbmFsW2orK10gPSBhZ2dyZWdhdGUgKyBvcmlnaW5hbFtpXTtcbiAgICAgICAgICBhZ2dyZWdhdGUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRleHQgPSBjb25kZW5zZWRUZXh0O1xuICAgICAgb3JpZ2luYWwgPSBjb25kZW5zZWRPcmlnaW5hbDtcblxuICAgICAgaWYgKGFnZ3JlZ2F0ZSkge1xuICAgICAgICB0ZXh0LnB1c2goYWdncmVnYXRlKTtcbiAgICAgICAgb3JpZ2luYWwucHVzaChhZ2dyZWdhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbHVlLnNwZWVkICYmIHR3ZWVuLmR1cmF0aW9uKE1hdGgubWluKDAuMDUgLyB2YWx1ZS5zcGVlZCAqIF9zaG9ydC5sZW5ndGgsIHZhbHVlLm1heER1cmF0aW9uIHx8IDk5OTkpKTtcbiAgICBkYXRhLnJ0bCA9IHJ0bDtcbiAgICBkYXRhLm9yaWdpbmFsID0gb3JpZ2luYWw7XG4gICAgZGF0YS50ZXh0ID0gdGV4dDtcblxuICAgIGRhdGEuX3Byb3BzLnB1c2goXCJ0ZXh0XCIpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyYXRpbywgZGF0YSkge1xuICAgIGlmIChyYXRpbyA+IDEpIHtcbiAgICAgIHJhdGlvID0gMTtcbiAgICB9IGVsc2UgaWYgKHJhdGlvIDwgMCkge1xuICAgICAgcmF0aW8gPSAwO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmZyb20pIHtcbiAgICAgIHJhdGlvID0gMSAtIHJhdGlvO1xuICAgIH1cblxuICAgIHZhciB0ZXh0ID0gZGF0YS50ZXh0LFxuICAgICAgICBoYXNDbGFzcyA9IGRhdGEuaGFzQ2xhc3MsXG4gICAgICAgIG5ld0NsYXNzID0gZGF0YS5uZXdDbGFzcyxcbiAgICAgICAgb2xkQ2xhc3MgPSBkYXRhLm9sZENsYXNzLFxuICAgICAgICBkZWxpbWl0ZXIgPSBkYXRhLmRlbGltaXRlcixcbiAgICAgICAgdGFyZ2V0ID0gZGF0YS50YXJnZXQsXG4gICAgICAgIGZpbGxDaGFyID0gZGF0YS5maWxsQ2hhcixcbiAgICAgICAgb3JpZ2luYWwgPSBkYXRhLm9yaWdpbmFsLFxuICAgICAgICBydGwgPSBkYXRhLnJ0bCxcbiAgICAgICAgbCA9IHRleHQubGVuZ3RoLFxuICAgICAgICBpID0gKHJ0bCA/IDEgLSByYXRpbyA6IHJhdGlvKSAqIGwgKyAwLjUgfCAwLFxuICAgICAgICBhcHBseU5ldyxcbiAgICAgICAgYXBwbHlPbGQsXG4gICAgICAgIHN0cjtcblxuICAgIGlmIChoYXNDbGFzcyAmJiByYXRpbykge1xuICAgICAgYXBwbHlOZXcgPSBuZXdDbGFzcyAmJiBpO1xuICAgICAgYXBwbHlPbGQgPSBvbGRDbGFzcyAmJiBpICE9PSBsO1xuICAgICAgc3RyID0gKGFwcGx5TmV3ID8gXCI8c3BhbiBjbGFzcz0nXCIgKyBuZXdDbGFzcyArIFwiJz5cIiA6IFwiXCIpICsgdGV4dC5zbGljZSgwLCBpKS5qb2luKGRlbGltaXRlcikgKyAoYXBwbHlOZXcgPyBcIjwvc3Bhbj5cIiA6IFwiXCIpICsgKGFwcGx5T2xkID8gXCI8c3BhbiBjbGFzcz0nXCIgKyBvbGRDbGFzcyArIFwiJz5cIiA6IFwiXCIpICsgZGVsaW1pdGVyICsgb3JpZ2luYWwuc2xpY2UoaSkuam9pbihkZWxpbWl0ZXIpICsgKGFwcGx5T2xkID8gXCI8L3NwYW4+XCIgOiBcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gdGV4dC5zbGljZSgwLCBpKS5qb2luKGRlbGltaXRlcikgKyBkZWxpbWl0ZXIgKyBvcmlnaW5hbC5zbGljZShpKS5qb2luKGRlbGltaXRlcik7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuc3ZnKSB7XG4gICAgICAvL1NWRyB0ZXh0IGVsZW1lbnRzIGRvbid0IGhhdmUgYW4gXCJpbm5lckhUTUxcIiBpbiBNaWNyb3NvZnQgYnJvd3NlcnMuXG4gICAgICB0YXJnZXQudGV4dENvbnRlbnQgPSBzdHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5pbm5lckhUTUwgPSBmaWxsQ2hhciA9PT0gXCImbmJzcDtcIiAmJiB+c3RyLmluZGV4T2YoXCIgIFwiKSA/IHN0ci5zcGxpdChcIiAgXCIpLmpvaW4oXCImbmJzcDsmbmJzcDtcIikgOiBzdHI7XG4gICAgfVxuICB9XG59O1xuVGV4dFBsdWdpbi5zcGxpdElubmVySFRNTCA9IHNwbGl0SW5uZXJIVE1MO1xuVGV4dFBsdWdpbi5lbW9qaVNhZmVTcGxpdCA9IGVtb2ppU2FmZVNwbGl0O1xuVGV4dFBsdWdpbi5nZXRUZXh0ID0gZ2V0VGV4dDtcbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihUZXh0UGx1Z2luKTtcbmV4cG9ydCB7IFRleHRQbHVnaW4gYXMgZGVmYXVsdCB9OyJdLCJuYW1lcyI6WyJlbW9qaVNhZmVTcGxpdCIsImdldFRleHQiLCJzcGxpdElubmVySFRNTCIsImdzYXAiLCJfdGVtcERpdiIsIl9nZXRHU0FQIiwid2luZG93IiwicmVnaXN0ZXJQbHVnaW4iLCJUZXh0UGx1Z2luIiwidmVyc2lvbiIsIm5hbWUiLCJpbml0IiwidGFyZ2V0IiwidmFsdWUiLCJ0d2VlbiIsImkiLCJub2RlTmFtZSIsInRvVXBwZXJDYXNlIiwiZGF0YSIsIl92YWx1ZSIsIm5ld0NsYXNzIiwib2xkQ2xhc3MiLCJwcmVzZXJ2ZVNwYWNlcyIsInJ0bCIsImRlbGltaXRlciIsImZpbGxDaGFyIiwicGFkU3BhY2UiLCJfc2hvcnQiLCJ0ZXh0Iiwib3JpZ2luYWwiLCJqIiwiY29uZGVuc2VkVGV4dCIsImNvbmRlbnNlZE9yaWdpbmFsIiwiYWdncmVnYXRlIiwicyIsInN2ZyIsImdldEJCb3giLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbm5lckhUTUwiLCJmcm9tIiwiX2Zyb20iLCJoYXNDbGFzcyIsImxlbmd0aCIsInB1c2giLCJ0eXBlIiwic3BlZWQiLCJkdXJhdGlvbiIsIk1hdGgiLCJtaW4iLCJtYXhEdXJhdGlvbiIsIl9wcm9wcyIsInJlbmRlciIsInJhdGlvIiwibCIsImFwcGx5TmV3IiwiYXBwbHlPbGQiLCJzdHIiLCJzbGljZSIsImpvaW4iLCJ0ZXh0Q29udGVudCIsImluZGV4T2YiLCJzcGxpdCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/TextPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/all.js":
/*!*****************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/all.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Back: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Back; },\n/* harmony export */   Bounce: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Bounce; },\n/* harmony export */   CSSPlugin: function() { return /* reexport safe */ _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   CSSRulePlugin: function() { return /* reexport safe */ _CSSRulePlugin_js__WEBPACK_IMPORTED_MODULE_4__.CSSRulePlugin; },\n/* harmony export */   Circ: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Circ; },\n/* harmony export */   Cubic: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Cubic; },\n/* harmony export */   CustomEase: function() { return /* reexport safe */ _CustomEase_js__WEBPACK_IMPORTED_MODULE_2__.CustomEase; },\n/* harmony export */   Draggable: function() { return /* reexport safe */ _Draggable_js__WEBPACK_IMPORTED_MODULE_3__.Draggable; },\n/* harmony export */   EasePack: function() { return /* reexport safe */ _EasePack_js__WEBPACK_IMPORTED_MODULE_6__.EasePack; },\n/* harmony export */   EaselPlugin: function() { return /* reexport safe */ _EaselPlugin_js__WEBPACK_IMPORTED_MODULE_5__.EaselPlugin; },\n/* harmony export */   Elastic: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Elastic; },\n/* harmony export */   Expo: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Expo; },\n/* harmony export */   ExpoScaleEase: function() { return /* reexport safe */ _EasePack_js__WEBPACK_IMPORTED_MODULE_6__.ExpoScaleEase; },\n/* harmony export */   Flip: function() { return /* reexport safe */ _Flip_js__WEBPACK_IMPORTED_MODULE_7__.Flip; },\n/* harmony export */   Linear: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Linear; },\n/* harmony export */   MotionPathPlugin: function() { return /* reexport safe */ _MotionPathPlugin_js__WEBPACK_IMPORTED_MODULE_8__.MotionPathPlugin; },\n/* harmony export */   Observer: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__.Observer; },\n/* harmony export */   PixiPlugin: function() { return /* reexport safe */ _PixiPlugin_js__WEBPACK_IMPORTED_MODULE_10__.PixiPlugin; },\n/* harmony export */   Power0: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power0; },\n/* harmony export */   Power1: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power1; },\n/* harmony export */   Power2: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power2; },\n/* harmony export */   Power3: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power3; },\n/* harmony export */   Power4: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power4; },\n/* harmony export */   Quad: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quad; },\n/* harmony export */   Quart: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quart; },\n/* harmony export */   Quint: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quint; },\n/* harmony export */   RoughEase: function() { return /* reexport safe */ _EasePack_js__WEBPACK_IMPORTED_MODULE_6__.RoughEase; },\n/* harmony export */   ScrollToPlugin: function() { return /* reexport safe */ _ScrollToPlugin_js__WEBPACK_IMPORTED_MODULE_11__.ScrollToPlugin; },\n/* harmony export */   ScrollTrigger: function() { return /* reexport safe */ _ScrollTrigger_js__WEBPACK_IMPORTED_MODULE_12__.ScrollTrigger; },\n/* harmony export */   Sine: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Sine; },\n/* harmony export */   SlowMo: function() { return /* reexport safe */ _EasePack_js__WEBPACK_IMPORTED_MODULE_6__.SlowMo; },\n/* harmony export */   SteppedEase: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.SteppedEase; },\n/* harmony export */   Strong: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Strong; },\n/* harmony export */   TextPlugin: function() { return /* reexport safe */ _TextPlugin_js__WEBPACK_IMPORTED_MODULE_13__.TextPlugin; },\n/* harmony export */   TimelineLite: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineLite; },\n/* harmony export */   TimelineMax: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineMax; },\n/* harmony export */   TweenLite: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TweenLite; },\n/* harmony export */   TweenMax: function() { return /* binding */ TweenMaxWithCSS; },\n/* harmony export */   _getProxyProp: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__._getProxyProp; },\n/* harmony export */   _getScrollFunc: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__._getScrollFunc; },\n/* harmony export */   _getTarget: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__._getTarget; },\n/* harmony export */   _getVelocityProp: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__._getVelocityProp; },\n/* harmony export */   _horizontal: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__._horizontal; },\n/* harmony export */   _isViewport: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__._isViewport; },\n/* harmony export */   _proxies: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__._proxies; },\n/* harmony export */   _scrollers: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__._scrollers; },\n/* harmony export */   _vertical: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__._vertical; },\n/* harmony export */   clamp: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.clamp; },\n/* harmony export */   \"default\": function() { return /* binding */ gsapWithCSS; },\n/* harmony export */   distribute: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.distribute; },\n/* harmony export */   getUnit: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit; },\n/* harmony export */   gsap: function() { return /* binding */ gsapWithCSS; },\n/* harmony export */   interpolate: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.interpolate; },\n/* harmony export */   mapRange: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.mapRange; },\n/* harmony export */   normalize: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.normalize; },\n/* harmony export */   pipe: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.pipe; },\n/* harmony export */   random: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.random; },\n/* harmony export */   selector: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.selector; },\n/* harmony export */   shuffle: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.shuffle; },\n/* harmony export */   snap: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.snap; },\n/* harmony export */   splitColor: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.splitColor; },\n/* harmony export */   toArray: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.toArray; },\n/* harmony export */   unitize: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.unitize; },\n/* harmony export */   wrap: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.wrap; },\n/* harmony export */   wrapYoyo: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.wrapYoyo; }\n/* harmony export */ });\n/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/gsap-core.js\");\n/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSPlugin.js\");\n/* harmony import */ var _CustomEase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CustomEase.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CustomEase.js\");\n/* harmony import */ var _Draggable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Draggable.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Draggable.js\");\n/* harmony import */ var _CSSRulePlugin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CSSRulePlugin.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSRulePlugin.js\");\n/* harmony import */ var _EaselPlugin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EaselPlugin.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/EaselPlugin.js\");\n/* harmony import */ var _EasePack_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./EasePack.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/EasePack.js\");\n/* harmony import */ var _Flip_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Flip.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Flip.js\");\n/* harmony import */ var _MotionPathPlugin_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./MotionPathPlugin.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/MotionPathPlugin.js\");\n/* harmony import */ var _Observer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Observer.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Observer.js\");\n/* harmony import */ var _PixiPlugin_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./PixiPlugin.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/PixiPlugin.js\");\n/* harmony import */ var _ScrollToPlugin_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ScrollToPlugin.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollToPlugin.js\");\n/* harmony import */ var _ScrollTrigger_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ScrollTrigger.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollTrigger.js\");\n/* harmony import */ var _TextPlugin_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./TextPlugin.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/TextPlugin.js\");\n\n\nvar gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"], // to protect from tree shaking\nTweenMaxWithCSS = gsapWithCSS.core.Tween;\n\n\n\n\n\n\n\n\n\n\n\n\n\n //BONUS EXPORTS\n // export * from \"./DrawSVGPlugin.js\";\n // export * from \"./Physics2DPlugin.js\";\n // export * from \"./PhysicsPropsPlugin.js\";\n // export * from \"./ScrambleTextPlugin.js\";\n // export * from \"./CustomBounce.js\";\n // export * from \"./CustomWiggle.js\";\n // export * from \"./GSDevTools.js\";\n // export * from \"./InertiaPlugin.js\";\n // export * from \"./MorphSVGPlugin.js\";\n // export * from \"./MotionPathHelper.js\";\n // export * from \"./ScrollSmoother.js\";\n // export * from \"./SplitText.js\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9hbGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrQztBQUNLO0FBQ3ZDLElBQUlFLGNBQWNGLHFEQUFJQSxDQUFDRyxjQUFjLENBQUNGLHFEQUFTQSxLQUFLRCxxREFBSUEsRUFDcEQsK0JBQStCO0FBQ25DSSxrQkFBa0JGLFlBQVlHLElBQUksQ0FBQ0MsS0FBSztBQUN1RDtBQUNtUTtBQUNsVTtBQUNEO0FBQ0k7QUFDRjtBQUNIO0FBQ0o7QUFDWTtBQUNSO0FBQ0U7QUFDSTtBQUNEO0FBQ0gsQ0FBQyxlQUFlO0NBQ2hELHNDQUFzQztDQUN0Qyx3Q0FBd0M7Q0FDeEMsMkNBQTJDO0NBQzNDLDJDQUEyQztDQUMzQyxxQ0FBcUM7Q0FDckMscUNBQXFDO0NBQ3JDLG1DQUFtQztDQUNuQyxzQ0FBc0M7Q0FDdEMsdUNBQXVDO0NBQ3ZDLHlDQUF5QztDQUN6Qyx1Q0FBdUM7Q0FDdkMsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9hbGwuanM/MDFhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ3NhcCBmcm9tIFwiLi9nc2FwLWNvcmUuanNcIjtcbmltcG9ydCBDU1NQbHVnaW4gZnJvbSBcIi4vQ1NTUGx1Z2luLmpzXCI7XG52YXIgZ3NhcFdpdGhDU1MgPSBnc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1BsdWdpbikgfHwgZ3NhcCxcbiAgICAvLyB0byBwcm90ZWN0IGZyb20gdHJlZSBzaGFraW5nXG5Ud2Vlbk1heFdpdGhDU1MgPSBnc2FwV2l0aENTUy5jb3JlLlR3ZWVuO1xuZXhwb3J0IHsgZ3NhcFdpdGhDU1MgYXMgZ3NhcCwgZ3NhcFdpdGhDU1MgYXMgZGVmYXVsdCwgVHdlZW5NYXhXaXRoQ1NTIGFzIFR3ZWVuTWF4LCBDU1NQbHVnaW4gfTtcbmV4cG9ydCB7IFR3ZWVuTGl0ZSwgVGltZWxpbmVNYXgsIFRpbWVsaW5lTGl0ZSwgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjLCB3cmFwLCB3cmFwWW95bywgZGlzdHJpYnV0ZSwgcmFuZG9tLCBzbmFwLCBub3JtYWxpemUsIGdldFVuaXQsIGNsYW1wLCBzcGxpdENvbG9yLCB0b0FycmF5LCBtYXBSYW5nZSwgcGlwZSwgdW5pdGl6ZSwgaW50ZXJwb2xhdGUsIHNodWZmbGUsIHNlbGVjdG9yIH0gZnJvbSBcIi4vZ3NhcC1jb3JlLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9DdXN0b21FYXNlLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9EcmFnZ2FibGUuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0NTU1J1bGVQbHVnaW4uanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0Vhc2VsUGx1Z2luLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9FYXNlUGFjay5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vRmxpcC5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vTW90aW9uUGF0aFBsdWdpbi5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vT2JzZXJ2ZXIuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1BpeGlQbHVnaW4uanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1Njcm9sbFRvUGx1Z2luLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9TY3JvbGxUcmlnZ2VyLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9UZXh0UGx1Z2luLmpzXCI7IC8vQk9OVVMgRVhQT1JUU1xuLy8gZXhwb3J0ICogZnJvbSBcIi4vRHJhd1NWR1BsdWdpbi5qc1wiO1xuLy8gZXhwb3J0ICogZnJvbSBcIi4vUGh5c2ljczJEUGx1Z2luLmpzXCI7XG4vLyBleHBvcnQgKiBmcm9tIFwiLi9QaHlzaWNzUHJvcHNQbHVnaW4uanNcIjtcbi8vIGV4cG9ydCAqIGZyb20gXCIuL1NjcmFtYmxlVGV4dFBsdWdpbi5qc1wiO1xuLy8gZXhwb3J0ICogZnJvbSBcIi4vQ3VzdG9tQm91bmNlLmpzXCI7XG4vLyBleHBvcnQgKiBmcm9tIFwiLi9DdXN0b21XaWdnbGUuanNcIjtcbi8vIGV4cG9ydCAqIGZyb20gXCIuL0dTRGV2VG9vbHMuanNcIjtcbi8vIGV4cG9ydCAqIGZyb20gXCIuL0luZXJ0aWFQbHVnaW4uanNcIjtcbi8vIGV4cG9ydCAqIGZyb20gXCIuL01vcnBoU1ZHUGx1Z2luLmpzXCI7XG4vLyBleHBvcnQgKiBmcm9tIFwiLi9Nb3Rpb25QYXRoSGVscGVyLmpzXCI7XG4vLyBleHBvcnQgKiBmcm9tIFwiLi9TY3JvbGxTbW9vdGhlci5qc1wiO1xuLy8gZXhwb3J0ICogZnJvbSBcIi4vU3BsaXRUZXh0LmpzXCI7Il0sIm5hbWVzIjpbImdzYXAiLCJDU1NQbHVnaW4iLCJnc2FwV2l0aENTUyIsInJlZ2lzdGVyUGx1Z2luIiwiVHdlZW5NYXhXaXRoQ1NTIiwiY29yZSIsIlR3ZWVuIiwiZGVmYXVsdCIsIlR3ZWVuTWF4IiwiVHdlZW5MaXRlIiwiVGltZWxpbmVNYXgiLCJUaW1lbGluZUxpdGUiLCJQb3dlcjAiLCJQb3dlcjEiLCJQb3dlcjIiLCJQb3dlcjMiLCJQb3dlcjQiLCJMaW5lYXIiLCJRdWFkIiwiQ3ViaWMiLCJRdWFydCIsIlF1aW50IiwiU3Ryb25nIiwiRWxhc3RpYyIsIkJhY2siLCJTdGVwcGVkRWFzZSIsIkJvdW5jZSIsIlNpbmUiLCJFeHBvIiwiQ2lyYyIsIndyYXAiLCJ3cmFwWW95byIsImRpc3RyaWJ1dGUiLCJyYW5kb20iLCJzbmFwIiwibm9ybWFsaXplIiwiZ2V0VW5pdCIsImNsYW1wIiwic3BsaXRDb2xvciIsInRvQXJyYXkiLCJtYXBSYW5nZSIsInBpcGUiLCJ1bml0aXplIiwiaW50ZXJwb2xhdGUiLCJzaHVmZmxlIiwic2VsZWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/all.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/gsap-core.js":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/gsap-core.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animation: function() { return /* binding */ Animation; },\n/* harmony export */   Back: function() { return /* binding */ Back; },\n/* harmony export */   Bounce: function() { return /* binding */ Bounce; },\n/* harmony export */   Circ: function() { return /* binding */ Circ; },\n/* harmony export */   Cubic: function() { return /* binding */ Cubic; },\n/* harmony export */   Elastic: function() { return /* binding */ Elastic; },\n/* harmony export */   Expo: function() { return /* binding */ Expo; },\n/* harmony export */   GSCache: function() { return /* binding */ GSCache; },\n/* harmony export */   Linear: function() { return /* binding */ Linear; },\n/* harmony export */   Power0: function() { return /* binding */ Power0; },\n/* harmony export */   Power1: function() { return /* binding */ Power1; },\n/* harmony export */   Power2: function() { return /* binding */ Power2; },\n/* harmony export */   Power3: function() { return /* binding */ Power3; },\n/* harmony export */   Power4: function() { return /* binding */ Power4; },\n/* harmony export */   PropTween: function() { return /* binding */ PropTween; },\n/* harmony export */   Quad: function() { return /* binding */ Quad; },\n/* harmony export */   Quart: function() { return /* binding */ Quart; },\n/* harmony export */   Quint: function() { return /* binding */ Quint; },\n/* harmony export */   Sine: function() { return /* binding */ Sine; },\n/* harmony export */   SteppedEase: function() { return /* binding */ SteppedEase; },\n/* harmony export */   Strong: function() { return /* binding */ Strong; },\n/* harmony export */   Timeline: function() { return /* binding */ Timeline; },\n/* harmony export */   TimelineLite: function() { return /* binding */ Timeline; },\n/* harmony export */   TimelineMax: function() { return /* binding */ Timeline; },\n/* harmony export */   Tween: function() { return /* binding */ Tween; },\n/* harmony export */   TweenLite: function() { return /* binding */ Tween; },\n/* harmony export */   TweenMax: function() { return /* binding */ Tween; },\n/* harmony export */   _checkPlugin: function() { return /* binding */ _checkPlugin; },\n/* harmony export */   _colorExp: function() { return /* binding */ _colorExp; },\n/* harmony export */   _colorStringFilter: function() { return /* binding */ _colorStringFilter; },\n/* harmony export */   _config: function() { return /* binding */ _config; },\n/* harmony export */   _forEachName: function() { return /* binding */ _forEachName; },\n/* harmony export */   _getCache: function() { return /* binding */ _getCache; },\n/* harmony export */   _getProperty: function() { return /* binding */ _getProperty; },\n/* harmony export */   _getSetter: function() { return /* binding */ _getSetter; },\n/* harmony export */   _isString: function() { return /* binding */ _isString; },\n/* harmony export */   _isUndefined: function() { return /* binding */ _isUndefined; },\n/* harmony export */   _missingPlugin: function() { return /* binding */ _missingPlugin; },\n/* harmony export */   _numExp: function() { return /* binding */ _numExp; },\n/* harmony export */   _numWithUnitExp: function() { return /* binding */ _numWithUnitExp; },\n/* harmony export */   _parseRelative: function() { return /* binding */ _parseRelative; },\n/* harmony export */   _plugins: function() { return /* binding */ _plugins; },\n/* harmony export */   _relExp: function() { return /* binding */ _relExp; },\n/* harmony export */   _removeLinkedListItem: function() { return /* binding */ _removeLinkedListItem; },\n/* harmony export */   _renderComplexString: function() { return /* binding */ _renderComplexString; },\n/* harmony export */   _replaceRandom: function() { return /* binding */ _replaceRandom; },\n/* harmony export */   _round: function() { return /* binding */ _round; },\n/* harmony export */   _roundModifier: function() { return /* binding */ _roundModifier; },\n/* harmony export */   _setDefaults: function() { return /* binding */ _setDefaults; },\n/* harmony export */   _sortPropTweensByPriority: function() { return /* binding */ _sortPropTweensByPriority; },\n/* harmony export */   _ticker: function() { return /* binding */ _ticker; },\n/* harmony export */   clamp: function() { return /* binding */ clamp; },\n/* harmony export */   \"default\": function() { return /* binding */ gsap; },\n/* harmony export */   distribute: function() { return /* binding */ distribute; },\n/* harmony export */   getUnit: function() { return /* binding */ getUnit; },\n/* harmony export */   gsap: function() { return /* binding */ gsap; },\n/* harmony export */   interpolate: function() { return /* binding */ interpolate; },\n/* harmony export */   mapRange: function() { return /* binding */ mapRange; },\n/* harmony export */   normalize: function() { return /* binding */ normalize; },\n/* harmony export */   pipe: function() { return /* binding */ pipe; },\n/* harmony export */   random: function() { return /* binding */ random; },\n/* harmony export */   selector: function() { return /* binding */ selector; },\n/* harmony export */   shuffle: function() { return /* binding */ shuffle; },\n/* harmony export */   snap: function() { return /* binding */ snap; },\n/* harmony export */   splitColor: function() { return /* binding */ splitColor; },\n/* harmony export */   toArray: function() { return /* binding */ toArray; },\n/* harmony export */   unitize: function() { return /* binding */ unitize; },\n/* harmony export */   wrap: function() { return /* binding */ wrap; },\n/* harmony export */   wrapYoyo: function() { return /* binding */ wrapYoyo; }\n/* harmony export */ });\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n}\n/*!\n * GSAP 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var _config = {\n    autoSleep: 120,\n    force3D: \"auto\",\n    nullTargetWarn: 1,\n    units: {\n        lineHeight: \"\"\n    }\n}, _defaults = {\n    duration: .5,\n    overwrite: false,\n    delay: 0\n}, _suppressOverwrites, _reverting, _context, _bigNum = 1e8, _tinyNum = 1 / _bigNum, _2PI = Math.PI * 2, _HALF_PI = _2PI / 4, _gsID = 0, _sqrt = Math.sqrt, _cos = Math.cos, _sin = Math.sin, _isString = function _isString(value) {\n    return typeof value === \"string\";\n}, _isFunction = function _isFunction(value) {\n    return typeof value === \"function\";\n}, _isNumber = function _isNumber(value) {\n    return typeof value === \"number\";\n}, _isUndefined = function _isUndefined(value) {\n    return typeof value === \"undefined\";\n}, _isObject = function _isObject(value) {\n    return typeof value === \"object\";\n}, _isNotFalse = function _isNotFalse(value) {\n    return value !== false;\n}, _windowExists = function _windowExists() {\n    return typeof window !== \"undefined\";\n}, _isFuncOrString = function _isFuncOrString(value) {\n    return _isFunction(value) || _isString(value);\n}, _isTypedArray = typeof ArrayBuffer === \"function\" && ArrayBuffer.isView || function() {}, // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().\n_isArray = Array.isArray, _strictNumExp = /(?:-?\\.?\\d|\\.)+/gi, //only numbers (including negatives and decimals) but NOT relative values.\n_numExp = /[-+=.]*\\d+[.e\\-+]*\\d*[e\\-+]*\\d*/g, //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\n_numWithUnitExp = /[-+=.]*\\d+[.e-]*\\d*[a-z%]*/g, _complexStringNumExp = /[-+=.]*\\d+\\.?\\d*(?:e-|e\\+)?\\d*/gi, //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.\n_relExp = /[+-]=-?[.\\d]+/, _delimitedValueExp = /[^,'\"\\[\\]\\s]+/gi, // previously /[#\\-+.]*\\b[a-z\\d\\-=+%.]+/gi but didn't catch special characters.\n_unitExp = /^[+\\-=e\\s\\d]*\\d+[.\\d]*([a-z]*|%)\\s*$/i, _globalTimeline, _win, _coreInitted, _doc, _globals = {}, _installScope = {}, _coreReady, _install = function _install(scope) {\n    return (_installScope = _merge(scope, _globals)) && gsap;\n}, _missingPlugin = function _missingPlugin(property, value) {\n    return console.warn(\"Invalid property\", property, \"set to\", value, \"Missing plugin? gsap.registerPlugin()\");\n}, _warn = function _warn(message, suppress) {\n    return !suppress && console.warn(message);\n}, _addGlobal = function _addGlobal(name, obj) {\n    return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;\n}, _emptyFunc = function _emptyFunc() {\n    return 0;\n}, _startAtRevertConfig = {\n    suppressEvents: true,\n    isStart: true,\n    kill: false\n}, _revertConfigNoKill = {\n    suppressEvents: true,\n    kill: false\n}, _revertConfig = {\n    suppressEvents: true\n}, _reservedProps = {}, _lazyTweens = [], _lazyLookup = {}, _lastRenderedFrame, _plugins = {}, _effects = {}, _nextGCFrame = 30, _harnessPlugins = [], _callbackNames = \"\", _harness = function _harness(targets) {\n    var target = targets[0], harnessPlugin, i;\n    _isObject(target) || _isFunction(target) || (targets = [\n        targets\n    ]);\n    if (!(harnessPlugin = (target._gsap || {}).harness)) {\n        // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)\n        i = _harnessPlugins.length;\n        while(i-- && !_harnessPlugins[i].targetTest(target)){}\n        harnessPlugin = _harnessPlugins[i];\n    }\n    i = targets.length;\n    while(i--){\n        targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);\n    }\n    return targets;\n}, _getCache = function _getCache(target) {\n    return target._gsap || _harness(toArray(target))[0]._gsap;\n}, _getProperty = function _getProperty(target, property, v) {\n    return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;\n}, _forEachName = function _forEachName(names, func) {\n    return (names = names.split(\",\")).forEach(func) || names;\n}, //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).\n_round = function _round(value) {\n    return Math.round(value * 100000) / 100000 || 0;\n}, _roundPrecise = function _roundPrecise(value) {\n    return Math.round(value * 10000000) / 10000000 || 0;\n}, // increased precision mostly for timing values.\n_parseRelative = function _parseRelative(start, value) {\n    var operator = value.charAt(0), end = parseFloat(value.substr(2));\n    start = parseFloat(start);\n    return operator === \"+\" ? start + end : operator === \"-\" ? start - end : operator === \"*\" ? start * end : start / end;\n}, _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {\n    //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.\n    var l = toFind.length, i = 0;\n    for(; toSearch.indexOf(toFind[i]) < 0 && ++i < l;){}\n    return i < l;\n}, _lazyRender = function _lazyRender() {\n    var l = _lazyTweens.length, a = _lazyTweens.slice(0), i, tween;\n    _lazyLookup = {};\n    _lazyTweens.length = 0;\n    for(i = 0; i < l; i++){\n        tween = a[i];\n        tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);\n    }\n}, _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {\n    _lazyTweens.length && !_reverting && _lazyRender();\n    animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));\n    _lazyTweens.length && !_reverting && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.\n}, _numericIfPossible = function _numericIfPossible(value) {\n    var n = parseFloat(value);\n    return (n || n === 0) && (value + \"\").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;\n}, _passThrough = function _passThrough(p) {\n    return p;\n}, _setDefaults = function _setDefaults(obj, defaults) {\n    for(var p in defaults){\n        p in obj || (obj[p] = defaults[p]);\n    }\n    return obj;\n}, _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {\n    return function(obj, defaults) {\n        for(var p in defaults){\n            p in obj || p === \"duration\" && excludeDuration || p === \"ease\" || (obj[p] = defaults[p]);\n        }\n    };\n}, _merge = function _merge(base, toMerge) {\n    for(var p in toMerge){\n        base[p] = toMerge[p];\n    }\n    return base;\n}, _mergeDeep = function _mergeDeep(base, toMerge) {\n    for(var p in toMerge){\n        p !== \"__proto__\" && p !== \"constructor\" && p !== \"prototype\" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);\n    }\n    return base;\n}, _copyExcluding = function _copyExcluding(obj, excluding) {\n    var copy = {}, p;\n    for(p in obj){\n        p in excluding || (copy[p] = obj[p]);\n    }\n    return copy;\n}, _inheritDefaults = function _inheritDefaults(vars) {\n    var parent = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;\n    if (_isNotFalse(vars.inherit)) {\n        while(parent){\n            func(vars, parent.vars.defaults);\n            parent = parent.parent || parent._dp;\n        }\n    }\n    return vars;\n}, _arraysMatch = function _arraysMatch(a1, a2) {\n    var i = a1.length, match = i === a2.length;\n    while(match && i-- && a1[i] === a2[i]){}\n    return i < 0;\n}, _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {\n    if (firstProp === void 0) {\n        firstProp = \"_first\";\n    }\n    if (lastProp === void 0) {\n        lastProp = \"_last\";\n    }\n    var prev = parent[lastProp], t;\n    if (sortBy) {\n        t = child[sortBy];\n        while(prev && prev[sortBy] > t){\n            prev = prev._prev;\n        }\n    }\n    if (prev) {\n        child._next = prev._next;\n        prev._next = child;\n    } else {\n        child._next = parent[firstProp];\n        parent[firstProp] = child;\n    }\n    if (child._next) {\n        child._next._prev = child;\n    } else {\n        parent[lastProp] = child;\n    }\n    child._prev = prev;\n    child.parent = child._dp = parent;\n    return child;\n}, _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {\n    if (firstProp === void 0) {\n        firstProp = \"_first\";\n    }\n    if (lastProp === void 0) {\n        lastProp = \"_last\";\n    }\n    var prev = child._prev, next = child._next;\n    if (prev) {\n        prev._next = next;\n    } else if (parent[firstProp] === child) {\n        parent[firstProp] = next;\n    }\n    if (next) {\n        next._prev = prev;\n    } else if (parent[lastProp] === child) {\n        parent[lastProp] = prev;\n    }\n    child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.\n}, _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {\n    child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);\n    child._act = 0;\n}, _uncache = function _uncache(animation, child) {\n    if (animation && (!child || child._end > animation._dur || child._start < 0)) {\n        // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)\n        var a = animation;\n        while(a){\n            a._dirty = 1;\n            a = a.parent;\n        }\n    }\n    return animation;\n}, _recacheAncestors = function _recacheAncestors(animation) {\n    var parent = animation.parent;\n    while(parent && parent.parent){\n        //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.\n        parent._dirty = 1;\n        parent.totalDuration();\n        parent = parent.parent;\n    }\n    return animation;\n}, _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {\n    return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));\n}, _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {\n    return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);\n}, _elapsedCycleDuration = function _elapsedCycleDuration(animation) {\n    return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;\n}, // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.\n_animationCycle = function _animationCycle(tTime, cycleDuration) {\n    var whole = Math.floor(tTime /= cycleDuration);\n    return tTime && whole === tTime ? whole - 1 : whole;\n}, _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {\n    return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);\n}, _setEnd = function _setEnd(animation) {\n    return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));\n}, _alignPlayhead = function _alignPlayhead(animation, totalTime) {\n    // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.\n    var parent = animation._dp;\n    if (parent && parent.smoothChildTiming && animation._ts) {\n        animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));\n        _setEnd(animation);\n        parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.\n    }\n    return animation;\n}, /*\n_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {\n\tlet cycleDuration = duration + repeatDelay,\n\t\ttime = _round(clampedTotalTime % cycleDuration);\n\tif (time > duration) {\n\t\ttime = duration;\n\t}\n\treturn (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;\n},\n*/ _postAddChecks = function _postAddChecks(timeline, child) {\n    var t;\n    if (child._time || !child._dur && child._initted || child._start < timeline._time && (child._dur || !child.add)) {\n        // in case, for example, the _start is moved on a tween that has already rendered, or if it's being inserted into a timeline BEFORE where the playhead is currently. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning. Special case: if it's a timeline (has .add() method) and no duration, we can skip rendering because the user may be populating it AFTER adding it to a parent timeline (unconventional, but possible, and we wouldn't want it to get removed if the parent's autoRemoveChildren is true).\n        t = _parentToChildTotalTime(timeline.rawTime(), child);\n        if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {\n            child.render(t, true);\n        }\n    } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.\n    if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {\n        //in case any of the ancestors had completed but should now be enabled...\n        if (timeline._dur < timeline.duration()) {\n            t = timeline;\n            while(t._dp){\n                t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.\n                t = t._dp;\n            }\n        }\n        timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.\n    }\n}, _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {\n    child.parent && _removeFromParent(child);\n    child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);\n    child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));\n    _addLinkedListItem(timeline, child, \"_first\", \"_last\", timeline._sort ? \"_start\" : 0);\n    _isFromOrFromStart(child) || (timeline._recent = child);\n    skipChecks || _postAddChecks(timeline, child);\n    timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime); // if the timeline is reversed and the new child makes it longer, we may need to adjust the parent's _start (push it back)\n    return timeline;\n}, _scrollTrigger = function _scrollTrigger(animation, trigger) {\n    return (_globals.ScrollTrigger || _missingPlugin(\"scrollTrigger\", trigger)) && _globals.ScrollTrigger.create(trigger, animation);\n}, _attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {\n    _initTween(tween, time, tTime);\n    if (!tween._initted) {\n        return 1;\n    }\n    if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {\n        _lazyTweens.push(tween);\n        tween._lazy = [\n            tTime,\n            suppressEvents\n        ];\n        return 1;\n    }\n}, _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {\n    var parent = _ref.parent;\n    return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));\n}, // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0\n_isFromOrFromStart = function _isFromOrFromStart(_ref2) {\n    var data = _ref2.data;\n    return data === \"isFromStart\" || data === \"isStart\";\n}, _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {\n    var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the \"startAt\" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any \"from\" and \"fromTo\" startAt tweens are rendered the first time at a ratio of 1.\n    repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;\n    if (repeatDelay && tween._repeat) {\n        // in case there's a zero-duration tween that has a repeat with a repeatDelay\n        tTime = _clamp(0, tween._tDur, totalTime);\n        iteration = _animationCycle(tTime, repeatDelay);\n        tween._yoyo && iteration & 1 && (ratio = 1 - ratio);\n        if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {\n            // if iteration changed\n            prevRatio = 1 - ratio;\n            tween.vars.repeatRefresh && tween._initted && tween.invalidate();\n        }\n    }\n    if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {\n        if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {\n            // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.\n            return;\n        }\n        prevIteration = tween._zTime;\n        tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\n        suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.\n        tween.ratio = ratio;\n        tween._from && (ratio = 1 - ratio);\n        tween._time = 0;\n        tween._tTime = tTime;\n        pt = tween._pt;\n        while(pt){\n            pt.r(ratio, pt.d);\n            pt = pt._next;\n        }\n        totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);\n        tween._onUpdate && !suppressEvents && _callback(tween, \"onUpdate\");\n        tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, \"onRepeat\");\n        if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {\n            ratio && _removeFromParent(tween, 1);\n            if (!suppressEvents && !_reverting) {\n                _callback(tween, ratio ? \"onComplete\" : \"onReverseComplete\", true);\n                tween._prom && tween._prom();\n            }\n        }\n    } else if (!tween._zTime) {\n        tween._zTime = totalTime;\n    }\n}, _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {\n    var child;\n    if (time > prevTime) {\n        child = animation._first;\n        while(child && child._start <= time){\n            if (child.data === \"isPause\" && child._start > prevTime) {\n                return child;\n            }\n            child = child._next;\n        }\n    } else {\n        child = animation._last;\n        while(child && child._start >= time){\n            if (child.data === \"isPause\" && child._start < prevTime) {\n                return child;\n            }\n            child = child._prev;\n        }\n    }\n}, _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {\n    var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;\n    totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);\n    animation._dur = dur;\n    animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);\n    totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);\n    animation.parent && _setEnd(animation);\n    skipUncache || _uncache(animation.parent, animation);\n    return animation;\n}, _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {\n    return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);\n}, _zeroPosition = {\n    _start: 0,\n    endTime: _emptyFunc,\n    totalDuration: _emptyFunc\n}, _parsePosition = function _parsePosition(animation, position, percentAnimation) {\n    var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.\n    i, offset, isPercent;\n    if (_isString(position) && (isNaN(position) || position in labels)) {\n        //if the string is a number like \"1\", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).\n        offset = position.charAt(0);\n        isPercent = position.substr(-1) === \"%\";\n        i = position.indexOf(\"=\");\n        if (offset === \"<\" || offset === \">\") {\n            i >= 0 && (position = position.replace(/=/, \"\"));\n            return (offset === \"<\" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);\n        }\n        if (i < 0) {\n            position in labels || (labels[position] = clippedDuration);\n            return labels[position];\n        }\n        offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));\n        if (isPercent && percentAnimation) {\n            offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();\n        }\n        return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;\n    }\n    return position == null ? clippedDuration : +position;\n}, _createTweenType = function _createTweenType(type, params, timeline) {\n    var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent;\n    isLegacy && (vars.duration = params[1]);\n    vars.parent = timeline;\n    if (type) {\n        irVars = vars;\n        parent = timeline;\n        while(parent && !(\"immediateRender\" in irVars)){\n            // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.\n            irVars = parent.vars.defaults || {};\n            parent = _isNotFalse(parent.vars.inherit) && parent.parent;\n        }\n        vars.immediateRender = _isNotFalse(irVars.immediateRender);\n        type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // \"from\" vars\n    }\n    return new Tween(params[0], vars, params[varsIndex + 1]);\n}, _conditionalReturn = function _conditionalReturn(value, func) {\n    return value || value === 0 ? func(value) : func;\n}, _clamp = function _clamp(min, max, value) {\n    return value < min ? min : value > max ? max : value;\n}, getUnit = function getUnit(value, v) {\n    return !_isString(value) || !(v = _unitExp.exec(value)) ? \"\" : v[1];\n}, // note: protect against padded numbers as strings, like \"100.100\". That shouldn't return \"00\" as the unit. If it's numeric, return no unit.\nclamp = function clamp(min, max, value) {\n    return _conditionalReturn(value, function(v) {\n        return _clamp(min, max, v);\n    });\n}, _slice = [].slice, _isArrayLike = function _isArrayLike(value, nonEmpty) {\n    return value && _isObject(value) && \"length\" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;\n}, _flatten = function _flatten(ar, leaveStrings, accumulator) {\n    if (accumulator === void 0) {\n        accumulator = [];\n    }\n    return ar.forEach(function(value) {\n        var _accumulator;\n        return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);\n    }) || accumulator;\n}, //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.\ntoArray = function toArray(value, scope, leaveStrings) {\n    return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [\n        value\n    ] : [];\n}, selector = function selector(value) {\n    value = toArray(value)[0] || _warn(\"Invalid scope\") || {};\n    return function(v) {\n        var el = value.current || value.nativeElement || value;\n        return toArray(v, el.querySelectorAll ? el : el === value ? _warn(\"Invalid scope\") || _doc.createElement(\"div\") : value);\n    };\n}, shuffle = function shuffle(a) {\n    return a.sort(function() {\n        return .5 - Math.random();\n    });\n}, // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;\n//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following\ndistribute = function distribute(v) {\n    if (_isFunction(v)) {\n        return v;\n    }\n    var vars = _isObject(v) ? v : {\n        each: v\n    }, //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total \"amount\" that's chunked out among them all.\n    ease = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;\n    if (_isString(from)) {\n        ratioX = ratioY = ({\n            center: .5,\n            edges: .5,\n            end: 1\n        })[from] || 0;\n    } else if (!isDecimal && ratios) {\n        ratioX = from[0];\n        ratioY = from[1];\n    }\n    return function(i, target, a) {\n        var l = (a || vars).length, distances = cache[l], originX, originY, x, y, d, j, max, min, wrapAt;\n        if (!distances) {\n            wrapAt = vars.grid === \"auto\" ? 0 : (vars.grid || [\n                1,\n                _bigNum\n            ])[1];\n            if (!wrapAt) {\n                max = -_bigNum;\n                while(max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l){}\n                wrapAt < l && wrapAt--;\n            }\n            distances = cache[l] = [];\n            originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;\n            originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;\n            max = 0;\n            min = _bigNum;\n            for(j = 0; j < l; j++){\n                x = j % wrapAt - originX;\n                y = originY - (j / wrapAt | 0);\n                distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === \"y\" ? y : x);\n                d > max && (max = d);\n                d < min && (min = d);\n            }\n            from === \"random\" && shuffle(distances);\n            distances.max = max - min;\n            distances.min = min;\n            distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === \"y\" ? l / wrapAt : wrapAt) || 0) * (from === \"edges\" ? -1 : 1);\n            distances.b = l < 0 ? base - l : base;\n            distances.u = getUnit(vars.amount || vars.each) || 0; //unit\n            ease = ease && l < 0 ? _invertEase(ease) : ease;\n        }\n        l = (distances[i] - distances.min) / distances.max || 0;\n        return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors\n    };\n}, _roundModifier = function _roundModifier(v) {\n    //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.\n    var p = Math.pow(10, ((v + \"\").split(\".\")[1] || \"\").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())\n    return function(raw) {\n        var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);\n        return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!\n    };\n}, snap = function snap(snapTo, value) {\n    var isArray = _isArray(snapTo), radius, is2D;\n    if (!isArray && _isObject(snapTo)) {\n        radius = isArray = snapTo.radius || _bigNum;\n        if (snapTo.values) {\n            snapTo = toArray(snapTo.values);\n            if (is2D = !_isNumber(snapTo[0])) {\n                radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.\n            }\n        } else {\n            snapTo = _roundModifier(snapTo.increment);\n        }\n    }\n    return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {\n        is2D = snapTo(raw);\n        return Math.abs(is2D - raw) <= radius ? is2D : raw;\n    } : function(raw) {\n        var x = parseFloat(is2D ? raw.x : raw), y = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest = 0, i = snapTo.length, dx, dy;\n        while(i--){\n            if (is2D) {\n                dx = snapTo[i].x - x;\n                dy = snapTo[i].y - y;\n                dx = dx * dx + dy * dy;\n            } else {\n                dx = Math.abs(snapTo[i] - x);\n            }\n            if (dx < min) {\n                min = dx;\n                closest = i;\n            }\n        }\n        closest = !radius || min <= radius ? snapTo[closest] : raw;\n        return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);\n    });\n}, random = function random(min, max, roundingIncrement, returnFunction) {\n    return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {\n        return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + \"\").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;\n    });\n}, pipe = function pipe() {\n    for(var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++){\n        functions[_key] = arguments[_key];\n    }\n    return function(value) {\n        return functions.reduce(function(v, f) {\n            return f(v);\n        }, value);\n    };\n}, unitize = function unitize(func, unit) {\n    return function(value) {\n        return func(parseFloat(value)) + (unit || getUnit(value));\n    };\n}, normalize = function normalize(min, max, value) {\n    return mapRange(min, max, 0, 1, value);\n}, _wrapArray = function _wrapArray(a, wrapper, value) {\n    return _conditionalReturn(value, function(index) {\n        return a[~~wrapper(index)];\n    });\n}, wrap = function wrap(min, max, value) {\n    // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).\n    var range = max - min;\n    return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function(value) {\n        return (range + (value - min) % range) % range + min;\n    });\n}, wrapYoyo = function wrapYoyo(min, max, value) {\n    var range = max - min, total = range * 2;\n    return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function(value) {\n        value = (total + (value - min) % total) % total || 0;\n        return min + (value > range ? total - value : value);\n    });\n}, _replaceRandom = function _replaceRandom(value) {\n    //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])\n    var prev = 0, s = \"\", i, nums, end, isArray;\n    while(~(i = value.indexOf(\"random(\", prev))){\n        end = value.indexOf(\")\", i);\n        isArray = value.charAt(i + 7) === \"[\";\n        nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);\n        s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);\n        prev = end + 1;\n    }\n    return s + value.substr(prev, value.length - prev);\n}, mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {\n    var inRange = inMax - inMin, outRange = outMax - outMin;\n    return _conditionalReturn(value, function(value) {\n        return outMin + ((value - inMin) / inRange * outRange || 0);\n    });\n}, interpolate = function interpolate(start, end, progress, mutate) {\n    var func = isNaN(start + end) ? 0 : function func(p) {\n        return (1 - p) * start + p * end;\n    };\n    if (!func) {\n        var isString = _isString(start), master = {}, p, i, interpolators, l, il;\n        progress === true && (mutate = 1) && (progress = null);\n        if (isString) {\n            start = {\n                p: start\n            };\n            end = {\n                p: end\n            };\n        } else if (_isArray(start) && !_isArray(end)) {\n            interpolators = [];\n            l = start.length;\n            il = l - 2;\n            for(i = 1; i < l; i++){\n                interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.\n            }\n            l--;\n            func = function func(p) {\n                p *= l;\n                var i = Math.min(il, ~~p);\n                return interpolators[i](p - i);\n            };\n            progress = end;\n        } else if (!mutate) {\n            start = _merge(_isArray(start) ? [] : {}, start);\n        }\n        if (!interpolators) {\n            for(p in end){\n                _addPropTween.call(master, start, p, \"get\", end[p]);\n            }\n            func = function func(p) {\n                return _renderPropTweens(p, master) || (isString ? start.p : start);\n            };\n        }\n    }\n    return _conditionalReturn(progress, func);\n}, _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {\n    //used for nextLabel() and previousLabel()\n    var labels = timeline.labels, min = _bigNum, p, distance, label;\n    for(p in labels){\n        distance = labels[p] - fromTime;\n        if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {\n            label = p;\n            min = distance;\n        }\n    }\n    return label;\n}, _callback = function _callback(animation, type, executeLazyFirst) {\n    var v = animation.vars, callback = v[type], prevContext = _context, context = animation._ctx, params, scope, result;\n    if (!callback) {\n        return;\n    }\n    params = v[type + \"Params\"];\n    scope = v.callbackScope || animation;\n    executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.\n    context && (_context = context);\n    result = params ? callback.apply(scope, params) : callback.call(scope);\n    _context = prevContext;\n    return result;\n}, _interrupt = function _interrupt(animation) {\n    _removeFromParent(animation);\n    animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);\n    animation.progress() < 1 && _callback(animation, \"onInterrupt\");\n    return animation;\n}, _quickTween, _registerPluginQueue = [], _createPlugin = function _createPlugin(config) {\n    if (!config) return;\n    config = !config.name && config[\"default\"] || config; // UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.\n    if (_windowExists() || config.headless) {\n        // edge case: some build tools may pass in a null/undefined value\n        var name = config.name, isFunc = _isFunction(config), Plugin = name && !isFunc && config.init ? function Plugin() {\n            this._props = [];\n        } : config, //in case someone passes in an object that's not a plugin, like CustomEase\n        instanceDefaults = {\n            init: _emptyFunc,\n            render: _renderPropTweens,\n            add: _addPropTween,\n            kill: _killPropTweensOf,\n            modifier: _addPluginModifier,\n            rawVars: 0\n        }, statics = {\n            targetTest: 0,\n            get: 0,\n            getSetter: _getSetter,\n            aliases: {},\n            register: 0\n        };\n        _wake();\n        if (config !== Plugin) {\n            if (_plugins[name]) {\n                return;\n            }\n            _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods\n            _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods\n            _plugins[Plugin.prop = name] = Plugin;\n            if (config.targetTest) {\n                _harnessPlugins.push(Plugin);\n                _reservedProps[name] = 1;\n            }\n            name = (name === \"css\" ? \"CSS\" : name.charAt(0).toUpperCase() + name.substr(1)) + \"Plugin\"; //for the global name. \"motionPath\" should become MotionPathPlugin\n        }\n        _addGlobal(name, Plugin);\n        config.register && config.register(gsap, Plugin, PropTween);\n    } else {\n        _registerPluginQueue.push(config);\n    }\n}, /*\n * --------------------------------------------------------------------------------------\n * COLORS\n * --------------------------------------------------------------------------------------\n */ _255 = 255, _colorLookup = {\n    aqua: [\n        0,\n        _255,\n        _255\n    ],\n    lime: [\n        0,\n        _255,\n        0\n    ],\n    silver: [\n        192,\n        192,\n        192\n    ],\n    black: [\n        0,\n        0,\n        0\n    ],\n    maroon: [\n        128,\n        0,\n        0\n    ],\n    teal: [\n        0,\n        128,\n        128\n    ],\n    blue: [\n        0,\n        0,\n        _255\n    ],\n    navy: [\n        0,\n        0,\n        128\n    ],\n    white: [\n        _255,\n        _255,\n        _255\n    ],\n    olive: [\n        128,\n        128,\n        0\n    ],\n    yellow: [\n        _255,\n        _255,\n        0\n    ],\n    orange: [\n        _255,\n        165,\n        0\n    ],\n    gray: [\n        128,\n        128,\n        128\n    ],\n    purple: [\n        128,\n        0,\n        128\n    ],\n    green: [\n        0,\n        128,\n        0\n    ],\n    red: [\n        _255,\n        0,\n        0\n    ],\n    pink: [\n        _255,\n        192,\n        203\n    ],\n    cyan: [\n        0,\n        _255,\n        _255\n    ],\n    transparent: [\n        _255,\n        _255,\n        _255,\n        0\n    ]\n}, // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:\n// let ctx = _doc.createElement(\"canvas\").getContext(\"2d\");\n// _forEachName(\"aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan\", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});\n_hue = function _hue(h, m1, m2) {\n    h += h < 0 ? 1 : h > 1 ? -1 : 0;\n    return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;\n}, splitColor = function splitColor(v, toHSL, forceAlpha) {\n    var a = !v ? _colorLookup.black : _isNumber(v) ? [\n        v >> 16,\n        v >> 8 & _255,\n        v & _255\n    ] : 0, r, g, b, h, s, l, max, min, d, wasHSL;\n    if (!a) {\n        if (v.substr(-1) === \",\") {\n            //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:\"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)\" - in this example \"blue,\" has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.\n            v = v.substr(0, v.length - 1);\n        }\n        if (_colorLookup[v]) {\n            a = _colorLookup[v];\n        } else if (v.charAt(0) === \"#\") {\n            if (v.length < 6) {\n                //for shorthand like #9F0 or #9F0F (could have alpha)\n                r = v.charAt(1);\n                g = v.charAt(2);\n                b = v.charAt(3);\n                v = \"#\" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : \"\");\n            }\n            if (v.length === 9) {\n                // hex with alpha, like #fd5e53ff\n                a = parseInt(v.substr(1, 6), 16);\n                return [\n                    a >> 16,\n                    a >> 8 & _255,\n                    a & _255,\n                    parseInt(v.substr(7), 16) / 255\n                ];\n            }\n            v = parseInt(v.substr(1), 16);\n            a = [\n                v >> 16,\n                v >> 8 & _255,\n                v & _255\n            ];\n        } else if (v.substr(0, 3) === \"hsl\") {\n            a = wasHSL = v.match(_strictNumExp);\n            if (!toHSL) {\n                h = +a[0] % 360 / 360;\n                s = +a[1] / 100;\n                l = +a[2] / 100;\n                g = l <= .5 ? l * (s + 1) : l + s - l * s;\n                r = l * 2 - g;\n                a.length > 3 && (a[3] *= 1); //cast as number\n                a[0] = _hue(h + 1 / 3, r, g);\n                a[1] = _hue(h, r, g);\n                a[2] = _hue(h - 1 / 3, r, g);\n            } else if (~v.indexOf(\"=\")) {\n                //if relative values are found, just return the raw strings with the relative prefixes in place.\n                a = v.match(_numExp);\n                forceAlpha && a.length < 4 && (a[3] = 1);\n                return a;\n            }\n        } else {\n            a = v.match(_strictNumExp) || _colorLookup.transparent;\n        }\n        a = a.map(Number);\n    }\n    if (toHSL && !wasHSL) {\n        r = a[0] / _255;\n        g = a[1] / _255;\n        b = a[2] / _255;\n        max = Math.max(r, g, b);\n        min = Math.min(r, g, b);\n        l = (max + min) / 2;\n        if (max === min) {\n            h = s = 0;\n        } else {\n            d = max - min;\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n            h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;\n            h *= 60;\n        }\n        a[0] = ~~(h + .5);\n        a[1] = ~~(s * 100 + .5);\n        a[2] = ~~(l * 100 + .5);\n    }\n    forceAlpha && a.length < 4 && (a[3] = 1);\n    return a;\n}, _colorOrderData = function _colorOrderData(v) {\n    // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a \"c\" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()\n    var values = [], c = [], i = -1;\n    v.split(_colorExp).forEach(function(v) {\n        var a = v.match(_numWithUnitExp) || [];\n        values.push.apply(values, a);\n        c.push(i += a.length + 1);\n    });\n    values.c = c;\n    return values;\n}, _formatColors = function _formatColors(s, toHSL, orderMatchData) {\n    var result = \"\", colors = (s + result).match(_colorExp), type = toHSL ? \"hsla(\" : \"rgba(\", i = 0, c, shell, d, l;\n    if (!colors) {\n        return s;\n    }\n    colors = colors.map(function(color) {\n        return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + \",\" + color[1] + \"%,\" + color[2] + \"%,\" + color[3] : color.join(\",\")) + \")\";\n    });\n    if (orderMatchData) {\n        d = _colorOrderData(s);\n        c = orderMatchData.c;\n        if (c.join(result) !== d.c.join(result)) {\n            shell = s.replace(_colorExp, \"1\").split(_numWithUnitExp);\n            l = shell.length - 1;\n            for(; i < l; i++){\n                result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + \"0,0,0,0)\" : (d.length ? d : colors.length ? colors : orderMatchData).shift());\n            }\n        }\n    }\n    if (!shell) {\n        shell = s.split(_colorExp);\n        l = shell.length - 1;\n        for(; i < l; i++){\n            result += shell[i] + colors[i];\n        }\n    }\n    return result + shell[l];\n}, _colorExp = function() {\n    var s = \"(?:\\\\b(?:(?:rgb|rgba|hsl|hsla)\\\\(.+?\\\\))|\\\\B#(?:[0-9a-f]{3,4}){1,2}\\\\b\", //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,\n    p;\n    for(p in _colorLookup){\n        s += \"|\" + p + \"\\\\b\";\n    }\n    return new RegExp(s + \")\", \"gi\");\n}(), _hslExp = /hsl[a]?\\(/, _colorStringFilter = function _colorStringFilter(a) {\n    var combined = a.join(\" \"), toHSL;\n    _colorExp.lastIndex = 0;\n    if (_colorExp.test(combined)) {\n        toHSL = _hslExp.test(combined);\n        a[1] = _formatColors(a[1], toHSL);\n        a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.\n        return true;\n    }\n}, /*\n * --------------------------------------------------------------------------------------\n * TICKER\n * --------------------------------------------------------------------------------------\n */ _tickerActive, _ticker = function() {\n    var _getTime = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime(), _lastUpdate = _startTime, _gap = 1000 / 240, _nextTime = _gap, _listeners = [], _id, _req, _raf, _self, _delta, _i, _tick = function _tick(v) {\n        var elapsed = _getTime() - _lastUpdate, manual = v === true, overlap, dispatch, time, frame;\n        (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);\n        _lastUpdate += elapsed;\n        time = _lastUpdate - _startTime;\n        overlap = time - _nextTime;\n        if (overlap > 0 || manual) {\n            frame = ++_self.frame;\n            _delta = time - _self.time * 1000;\n            _self.time = time = time / 1000;\n            _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);\n            dispatch = 1;\n        }\n        manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the \"tick\" event so that timing is maintained. Otherwise, if processing the \"tick\" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.\n        if (dispatch) {\n            for(_i = 0; _i < _listeners.length; _i++){\n                // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.\n                _listeners[_i](time, _delta, frame, v);\n            }\n        }\n    };\n    _self = {\n        time: 0,\n        frame: 0,\n        tick: function tick() {\n            _tick(true);\n        },\n        deltaRatio: function deltaRatio(fps) {\n            return _delta / (1000 / (fps || 60));\n        },\n        wake: function wake() {\n            if (_coreReady) {\n                if (!_coreInitted && _windowExists()) {\n                    _win = _coreInitted = window;\n                    _doc = _win.document || {};\n                    _globals.gsap = gsap;\n                    (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);\n                    _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});\n                    _registerPluginQueue.forEach(_createPlugin);\n                }\n                _raf = typeof requestAnimationFrame !== \"undefined\" && requestAnimationFrame;\n                _id && _self.sleep();\n                _req = _raf || function(f) {\n                    return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);\n                };\n                _tickerActive = 1;\n                _tick(2);\n            }\n        },\n        sleep: function sleep() {\n            (_raf ? cancelAnimationFrame : clearTimeout)(_id);\n            _tickerActive = 0;\n            _req = _emptyFunc;\n        },\n        lagSmoothing: function lagSmoothing(threshold, adjustedLag) {\n            _lagThreshold = threshold || Infinity; // zero should be interpreted as basically unlimited\n            _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);\n        },\n        fps: function fps(_fps) {\n            _gap = 1000 / (_fps || 240);\n            _nextTime = _self.time * 1000 + _gap;\n        },\n        add: function add(callback, once, prioritize) {\n            var func = once ? function func1(t, d, f, v) {\n                callback(t, d, f, v);\n                _self.remove(func);\n            } : callback;\n            _self.remove(callback);\n            _listeners[prioritize ? \"unshift\" : \"push\"](func);\n            _wake();\n            return func;\n        },\n        remove: function remove(callback, i) {\n            ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;\n        },\n        _listeners: _listeners\n    };\n    return _self;\n}(), _wake = function _wake() {\n    return !_tickerActive && _ticker.wake();\n}, //also ensures the core classes are initialized.\n/*\n* -------------------------------------------------\n* EASING\n* -------------------------------------------------\n*/ _easeMap = {}, _customEaseExp = /^[\\d.\\-M][\\d.\\-,\\s]/, _quotesExp = /[\"']/g, _parseObjectInString = function _parseObjectInString(value) {\n    //takes a string like \"{wiggles:10, type:anticipate})\" and turns it into a real object. Notice it ends in \")\" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.\n    var obj = {}, split = value.substr(1, value.length - 3).split(\":\"), key = split[0], i = 1, l = split.length, index, val, parsedVal;\n    for(; i < l; i++){\n        val = split[i];\n        index = i !== l - 1 ? val.lastIndexOf(\",\") : val.length;\n        parsedVal = val.substr(0, index);\n        obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, \"\").trim() : +parsedVal;\n        key = val.substr(index + 1).trim();\n    }\n    return obj;\n}, _valueInParentheses = function _valueInParentheses(value) {\n    var open = value.indexOf(\"(\") + 1, close = value.indexOf(\")\"), nested = value.indexOf(\"(\", open);\n    return value.substring(open, ~nested && nested < close ? value.indexOf(\")\", close + 1) : close);\n}, _configEaseFromString = function _configEaseFromString(name) {\n    //name can be a string like \"elastic.out(1,0.5)\", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).\n    var split = (name + \"\").split(\"(\"), ease = _easeMap[split[0]];\n    return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf(\"{\") ? [\n        _parseObjectInString(split[1])\n    ] : _valueInParentheses(name).split(\",\").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE(\"\", name) : ease;\n}, _invertEase = function _invertEase(ease) {\n    return function(p) {\n        return 1 - ease(1 - p);\n    };\n}, // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.\n_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {\n    var child = timeline._first, ease;\n    while(child){\n        if (child instanceof Timeline) {\n            _propagateYoyoEase(child, isYoyo);\n        } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {\n            if (child.timeline) {\n                _propagateYoyoEase(child.timeline, isYoyo);\n            } else {\n                ease = child._ease;\n                child._ease = child._yEase;\n                child._yEase = ease;\n                child._yoyo = isYoyo;\n            }\n        }\n        child = child._next;\n    }\n}, _parseEase = function _parseEase(ease, defaultEase) {\n    return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;\n}, _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {\n    if (easeOut === void 0) {\n        easeOut = function easeOut(p) {\n            return 1 - easeIn(1 - p);\n        };\n    }\n    if (easeInOut === void 0) {\n        easeInOut = function easeInOut(p) {\n            return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;\n        };\n    }\n    var ease = {\n        easeIn: easeIn,\n        easeOut: easeOut,\n        easeInOut: easeInOut\n    }, lowercaseName;\n    _forEachName(names, function(name) {\n        _easeMap[name] = _globals[name] = ease;\n        _easeMap[lowercaseName = name.toLowerCase()] = easeOut;\n        for(var p in ease){\n            _easeMap[lowercaseName + (p === \"easeIn\" ? \".in\" : p === \"easeOut\" ? \".out\" : \".inOut\")] = _easeMap[name + \".\" + p] = ease[p];\n        }\n    });\n    return ease;\n}, _easeInOutFromOut = function _easeInOutFromOut(easeOut) {\n    return function(p) {\n        return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;\n    };\n}, _configElastic = function _configElastic(type, amplitude, period) {\n    var p1 = amplitude >= 1 ? amplitude : 1, //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.\n    p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut(p) {\n        return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;\n    }, ease = type === \"out\" ? easeOut : type === \"in\" ? function ease(p) {\n        return 1 - easeOut(1 - p);\n    } : _easeInOutFromOut(easeOut);\n    p2 = _2PI / p2; //precalculate to optimize\n    ease.config = function(amplitude, period) {\n        return _configElastic(type, amplitude, period);\n    };\n    return ease;\n}, _configBack = function _configBack(type, overshoot) {\n    if (overshoot === void 0) {\n        overshoot = 1.70158;\n    }\n    var easeOut = function easeOut(p) {\n        return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;\n    }, ease = type === \"out\" ? easeOut : type === \"in\" ? function ease(p) {\n        return 1 - easeOut(1 - p);\n    } : _easeInOutFromOut(easeOut);\n    ease.config = function(overshoot) {\n        return _configBack(type, overshoot);\n    };\n    return ease;\n}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\n// _weightedEase = ratio => {\n// \tlet y = 0.5 + ratio / 2;\n// \treturn p => (2 * (1 - p) * p * y + p * p);\n// },\n// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\n// _weightedEaseStrong = ratio => {\n// \tratio = .5 + ratio / 2;\n// \tlet o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),\n// \t\tb = ratio - o,\n// \t\tc = ratio + o;\n// \treturn p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;\n// };\n_forEachName(\"Linear,Quad,Cubic,Quart,Quint,Strong\", function(name, i) {\n    var power = i < 5 ? i + 1 : i;\n    _insertEase(name + \",Power\" + (power - 1), i ? function(p) {\n        return Math.pow(p, power);\n    } : function(p) {\n        return p;\n    }, function(p) {\n        return 1 - Math.pow(1 - p, power);\n    }, function(p) {\n        return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;\n    });\n});\n_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;\n_insertEase(\"Elastic\", _configElastic(\"in\"), _configElastic(\"out\"), _configElastic());\n(function(n, c) {\n    var n1 = 1 / c, n2 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut(p) {\n        return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;\n    };\n    _insertEase(\"Bounce\", function(p) {\n        return 1 - easeOut(1 - p);\n    }, easeOut);\n})(7.5625, 2.75);\n_insertEase(\"Expo\", function(p) {\n    return p ? Math.pow(2, 10 * (p - 1)) : 0;\n});\n_insertEase(\"Circ\", function(p) {\n    return -(_sqrt(1 - p * p) - 1);\n});\n_insertEase(\"Sine\", function(p) {\n    return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;\n});\n_insertEase(\"Back\", _configBack(\"in\"), _configBack(\"out\"), _configBack());\n_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {\n    config: function config(steps, immediateStart) {\n        if (steps === void 0) {\n            steps = 1;\n        }\n        var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;\n        return function(p) {\n            return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;\n        };\n    }\n};\n_defaults.ease = _easeMap[\"quad.out\"];\n_forEachName(\"onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt\", function(name) {\n    return _callbackNames += name + \",\" + name + \"Params,\";\n});\n/*\n * --------------------------------------------------------------------------------------\n * CACHE\n * --------------------------------------------------------------------------------------\n */ var GSCache = function GSCache(target, harness) {\n    this.id = _gsID++;\n    target._gsap = this;\n    this.target = target;\n    this.harness = harness;\n    this.get = harness ? harness.get : _getProperty;\n    this.set = harness ? harness.getSetter : _getSetter;\n};\n_c = GSCache;\n/*\n * --------------------------------------------------------------------------------------\n * ANIMATION\n * --------------------------------------------------------------------------------------\n */ var Animation = /*#__PURE__*/ function() {\n    function Animation(vars) {\n        this.vars = vars;\n        this._delay = +vars.delay || 0;\n        if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {\n            // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.\n            this._rDelay = vars.repeatDelay || 0;\n            this._yoyo = !!vars.yoyo || !!vars.yoyoEase;\n        }\n        this._ts = 1;\n        _setDuration(this, +vars.duration, 1, 1);\n        this.data = vars.data;\n        if (_context) {\n            this._ctx = _context;\n            _context.data.push(this);\n        }\n        _tickerActive || _ticker.wake();\n    }\n    var _proto = Animation.prototype;\n    _proto.delay = function delay(value) {\n        if (value || value === 0) {\n            this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);\n            this._delay = value;\n            return this;\n        }\n        return this._delay;\n    };\n    _proto.duration = function duration(value) {\n        return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;\n    };\n    _proto.totalDuration = function totalDuration(value) {\n        if (!arguments.length) {\n            return this._tDur;\n        }\n        this._dirty = 0;\n        return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));\n    };\n    _proto.totalTime = function totalTime(_totalTime, suppressEvents) {\n        _wake();\n        if (!arguments.length) {\n            return this._tTime;\n        }\n        var parent = this._dp;\n        if (parent && parent.smoothChildTiming && this._ts) {\n            _alignPlayhead(this, _totalTime);\n            !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.\n            //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.\n            while(parent && parent.parent){\n                if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {\n                    parent.totalTime(parent._tTime, true);\n                }\n                parent = parent.parent;\n            }\n            if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {\n                //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.\n                _addToTimeline(this._dp, this, this._start - this._delay);\n            }\n        }\n        if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {\n            // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)\n            this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause\n            //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)\n            //   this._lock = 1;\n            _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;\n        //}\n        }\n        return this;\n    };\n    _proto.time = function time(value, suppressEvents) {\n        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!\n    };\n    _proto.totalProgress = function totalProgress(value, suppressEvents) {\n        return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;\n    };\n    _proto.progress = function progress(value, suppressEvents) {\n        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;\n    };\n    _proto.iteration = function iteration(value, suppressEvents) {\n        var cycleDuration = this.duration() + this._rDelay;\n        return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;\n    } // potential future addition:\n    ;\n    _proto.timeScale = function timeScale(value, suppressEvents) {\n        if (!arguments.length) {\n            return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.\n        }\n        if (this._rts === value) {\n            return this;\n        }\n        var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.\n        // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.\n        //(+value < 0 && this._rts >= 0) && _callback(this, \"onReverse\", true);\n        // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.\n        this._rts = +value || 0;\n        this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.\n        this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), suppressEvents !== false);\n        _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.\n        return _recacheAncestors(this);\n    };\n    _proto.paused = function paused(value) {\n        if (!arguments.length) {\n            return this._ps;\n        }\n        if (this._ps !== value) {\n            this._ps = value;\n            if (value) {\n                this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.\n                this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the \"real\" timeScale as _rts (recorded time scale)\n            } else {\n                _wake();\n                this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.\n                this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.\n            }\n        }\n        return this;\n    };\n    _proto.startTime = function startTime(value) {\n        if (arguments.length) {\n            this._start = value;\n            var parent = this.parent || this._dp;\n            parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);\n            return this;\n        }\n        return this._start;\n    };\n    _proto.endTime = function endTime(includeRepeats) {\n        return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);\n    };\n    _proto.rawTime = function rawTime(wrapRepeats) {\n        var parent = this.parent || this._dp; // _dp = detached parent\n        return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);\n    };\n    _proto.revert = function revert(config) {\n        if (config === void 0) {\n            config = _revertConfig;\n        }\n        var prevIsReverting = _reverting;\n        _reverting = config;\n        if (this._initted || this._startAt) {\n            this.timeline && this.timeline.revert(config);\n            this.totalTime(-0.01, config.suppressEvents);\n        }\n        this.data !== \"nested\" && config.kill !== false && this.kill();\n        _reverting = prevIsReverting;\n        return this;\n    };\n    _proto.globalTime = function globalTime(rawTime) {\n        var animation = this, time = arguments.length ? rawTime : animation.rawTime();\n        while(animation){\n            time = animation._start + time / (Math.abs(animation._ts) || 1);\n            animation = animation._dp;\n        }\n        return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time; // the _startAt tweens for .fromTo() and .from() that have immediateRender should always be FIRST in the timeline (important for context.revert()). \"_sat\" stands for _startAtTween, referring to the parent tween that created the _startAt. We must discern if that tween had immediateRender so that we can know whether or not to prioritize it in revert().\n    };\n    _proto.repeat = function repeat(value) {\n        if (arguments.length) {\n            this._repeat = value === Infinity ? -2 : value;\n            return _onUpdateTotalDuration(this);\n        }\n        return this._repeat === -2 ? Infinity : this._repeat;\n    };\n    _proto.repeatDelay = function repeatDelay(value) {\n        if (arguments.length) {\n            var time = this._time;\n            this._rDelay = value;\n            _onUpdateTotalDuration(this);\n            return time ? this.time(time) : this;\n        }\n        return this._rDelay;\n    };\n    _proto.yoyo = function yoyo(value) {\n        if (arguments.length) {\n            this._yoyo = value;\n            return this;\n        }\n        return this._yoyo;\n    };\n    _proto.seek = function seek(position, suppressEvents) {\n        return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));\n    };\n    _proto.restart = function restart(includeDelay, suppressEvents) {\n        return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));\n    };\n    _proto.play = function play(from, suppressEvents) {\n        from != null && this.seek(from, suppressEvents);\n        return this.reversed(false).paused(false);\n    };\n    _proto.reverse = function reverse(from, suppressEvents) {\n        from != null && this.seek(from || this.totalDuration(), suppressEvents);\n        return this.reversed(true).paused(false);\n    };\n    _proto.pause = function pause(atTime, suppressEvents) {\n        atTime != null && this.seek(atTime, suppressEvents);\n        return this.paused(true);\n    };\n    _proto.resume = function resume() {\n        return this.paused(false);\n    };\n    _proto.reversed = function reversed(value) {\n        if (arguments.length) {\n            !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.\n            return this;\n        }\n        return this._rts < 0;\n    };\n    _proto.invalidate = function invalidate() {\n        this._initted = this._act = 0;\n        this._zTime = -_tinyNum;\n        return this;\n    };\n    _proto.isActive = function isActive() {\n        var parent = this.parent || this._dp, start = this._start, rawTime;\n        return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);\n    };\n    _proto.eventCallback = function eventCallback(type, callback, params) {\n        var vars = this.vars;\n        if (arguments.length > 1) {\n            if (!callback) {\n                delete vars[type];\n            } else {\n                vars[type] = callback;\n                params && (vars[type + \"Params\"] = params);\n                type === \"onUpdate\" && (this._onUpdate = callback);\n            }\n            return this;\n        }\n        return vars[type];\n    };\n    _proto.then = function then(onFulfilled) {\n        var self = this;\n        return new Promise(function(resolve) {\n            var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve() {\n                var _then = self.then;\n                self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)\n                _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);\n                resolve(f);\n                self.then = _then;\n            };\n            if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {\n                _resolve();\n            } else {\n                self._prom = _resolve;\n            }\n        });\n    };\n    _proto.kill = function kill() {\n        _interrupt(this);\n    };\n    return Animation;\n}();\n_setDefaults(Animation.prototype, {\n    _time: 0,\n    _start: 0,\n    _end: 0,\n    _tTime: 0,\n    _tDur: 0,\n    _dirty: 0,\n    _repeat: 0,\n    _yoyo: false,\n    parent: null,\n    _initted: false,\n    _rDelay: 0,\n    _ts: 1,\n    _dp: 0,\n    ratio: 0,\n    _zTime: -_tinyNum,\n    _prom: 0,\n    _ps: false,\n    _rts: 1\n});\n/*\n * -------------------------------------------------\n * TIMELINE\n * -------------------------------------------------\n */ var Timeline = /*#__PURE__*/ function(_Animation) {\n    _inheritsLoose(Timeline, _Animation);\n    function Timeline(vars, position) {\n        var _this;\n        if (vars === void 0) {\n            vars = {};\n        }\n        _this = _Animation.call(this, vars) || this;\n        _this.labels = {};\n        _this.smoothChildTiming = !!vars.smoothChildTiming;\n        _this.autoRemoveChildren = !!vars.autoRemoveChildren;\n        _this._sort = _isNotFalse(vars.sortChildren);\n        _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);\n        vars.reversed && _this.reverse();\n        vars.paused && _this.paused(true);\n        vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);\n        return _this;\n    }\n    var _proto2 = Timeline.prototype;\n    _proto2.to = function to(targets, vars, position) {\n        _createTweenType(0, arguments, this);\n        return this;\n    };\n    _proto2.from = function from(targets, vars, position) {\n        _createTweenType(1, arguments, this);\n        return this;\n    };\n    _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {\n        _createTweenType(2, arguments, this);\n        return this;\n    };\n    _proto2.set = function set(targets, vars, position) {\n        vars.duration = 0;\n        vars.parent = this;\n        _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);\n        vars.immediateRender = !!vars.immediateRender;\n        new Tween(targets, vars, _parsePosition(this, position), 1);\n        return this;\n    };\n    _proto2.call = function call(callback, params, position) {\n        return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);\n    } //ONLY for backward compatibility! Maybe delete?\n    ;\n    _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n        vars.duration = duration;\n        vars.stagger = vars.stagger || stagger;\n        vars.onComplete = onCompleteAll;\n        vars.onCompleteParams = onCompleteAllParams;\n        vars.parent = this;\n        new Tween(targets, vars, _parsePosition(this, position));\n        return this;\n    };\n    _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n        vars.runBackwards = 1;\n        _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);\n        return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);\n    };\n    _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {\n        toVars.startAt = fromVars;\n        _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);\n        return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);\n    };\n    _proto2.render = function render(totalTime, suppressEvents, force) {\n        var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.\n        crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;\n        this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);\n        if (tTime !== this._tTime || force || crossingStart) {\n            if (prevTime !== this._time && dur) {\n                //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).\n                tTime += this._time - prevTime;\n                totalTime += this._time - prevTime;\n            }\n            time = tTime;\n            prevStart = this._start;\n            timeScale = this._ts;\n            prevPaused = !timeScale;\n            if (crossingStart) {\n                dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\n                (totalTime || !suppressEvents) && (this._zTime = totalTime);\n            }\n            if (this._repeat) {\n                //adjust the time for repeats and yoyos\n                yoyo = this._yoyo;\n                cycleDuration = dur + this._rDelay;\n                if (this._repeat < -1 && totalTime < 0) {\n                    return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n                }\n                time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\n                if (tTime === tDur) {\n                    // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)\n                    iteration = this._repeat;\n                    time = dur;\n                } else {\n                    iteration = ~~(tTime / cycleDuration);\n                    if (iteration && iteration === tTime / cycleDuration) {\n                        time = dur;\n                        iteration--;\n                    }\n                    time > dur && (time = dur);\n                }\n                prevIteration = _animationCycle(this._tTime, cycleDuration);\n                !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://gsap.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005 also, this._tTime - prevIteration * cycleDuration - this._dur <= 0 just checks to make sure it wasn't previously in the \"repeatDelay\" portion\n                if (yoyo && iteration & 1) {\n                    time = dur - time;\n                    isYoyo = 1;\n                }\n                /*\n        make sure children at the end/beginning of the timeline are rendered properly. If, for example,\n        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which\n        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there\n        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So\n        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must\n        ensure that zero-duration tweens at the very beginning or end of the Timeline work.\n        */ if (iteration !== prevIteration && !this._lock) {\n                    var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);\n                    iteration < prevIteration && (rewinding = !rewinding);\n                    prevTime = rewinding ? 0 : tTime % dur ? dur : tTime; // if the playhead is landing exactly at the end of an iteration, use that totalTime rather than only the duration, otherwise it'll skip the 2nd render since it's effectively at the same time.\n                    this._lock = 1;\n                    this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;\n                    this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.\n                    !suppressEvents && this.parent && _callback(this, \"onRepeat\");\n                    this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);\n                    if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {\n                        // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.\n                        return this;\n                    }\n                    dur = this._dur; // in case the duration changed in the onRepeat\n                    tDur = this._tDur;\n                    if (doesWrap) {\n                        this._lock = 2;\n                        prevTime = rewinding ? dur : -0.0001;\n                        this.render(prevTime, true);\n                        this.vars.repeatRefresh && !isYoyo && this.invalidate();\n                    }\n                    this._lock = 0;\n                    if (!this._ts && !prevPaused) {\n                        return this;\n                    } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.\n                    _propagateYoyoEase(this, isYoyo);\n                }\n            }\n            if (this._hasPause && !this._forcing && this._lock < 2) {\n                pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));\n                if (pauseTween) {\n                    tTime -= time - (time = pauseTween._start);\n                }\n            }\n            this._tTime = tTime;\n            this._time = time;\n            this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.\n            if (!this._initted) {\n                this._onUpdate = this.vars.onUpdate;\n                this._initted = 1;\n                this._zTime = totalTime;\n                prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).\n            }\n            if (!prevTime && time && !suppressEvents && !iteration) {\n                _callback(this, \"onStart\");\n                if (this._tTime !== tTime) {\n                    // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.\n                    return this;\n                }\n            }\n            if (time >= prevTime && totalTime >= 0) {\n                child = this._first;\n                while(child){\n                    next = child._next;\n                    if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {\n                        if (child.parent !== this) {\n                            // an extreme edge case - the child's render could do something like kill() the \"next\" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\n                            return this.render(totalTime, suppressEvents, force);\n                        }\n                        child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);\n                        if (time !== this._time || !this._ts && !prevPaused) {\n                            //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\n                            pauseTween = 0;\n                            next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)\n                            break;\n                        }\n                    }\n                    child = next;\n                }\n            } else {\n                child = this._last;\n                var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.\n                while(child){\n                    next = child._prev;\n                    if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {\n                        if (child.parent !== this) {\n                            // an extreme edge case - the child's render could do something like kill() the \"next\" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\n                            return this.render(totalTime, suppressEvents, force);\n                        }\n                        child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt)); // if reverting, we should always force renders of initted tweens (but remember that .fromTo() or .from() may have a _startAt but not _initted yet). If, for example, a .fromTo() tween with a stagger (which creates an internal timeline) gets reverted BEFORE some of its child tweens render for the first time, it may not properly trigger them to revert.\n                        if (time !== this._time || !this._ts && !prevPaused) {\n                            //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\n                            pauseTween = 0;\n                            next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)\n                            break;\n                        }\n                    }\n                    child = next;\n                }\n            }\n            if (pauseTween && !suppressEvents) {\n                this.pause();\n                pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;\n                if (this._ts) {\n                    //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).\n                    this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.\n                    _setEnd(this);\n                    return this.render(totalTime, suppressEvents, force);\n                }\n            }\n            this._onUpdate && !suppressEvents && _callback(this, \"onUpdate\", true);\n            if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {\n                if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {\n                    if (!this._lock) {\n                        // remember, a child's callback may alter this timeline's playhead or timeScale which is why we need to add some of these checks.\n                        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\n                        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {\n                            _callback(this, tTime === tDur && totalTime >= 0 ? \"onComplete\" : \"onReverseComplete\", true);\n                            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n                        }\n                    }\n                }\n            }\n        }\n        return this;\n    };\n    _proto2.add = function add(child, position) {\n        var _this2 = this;\n        _isNumber(position) || (position = _parsePosition(this, position, child));\n        if (!(child instanceof Animation)) {\n            if (_isArray(child)) {\n                child.forEach(function(obj) {\n                    return _this2.add(obj, position);\n                });\n                return this;\n            }\n            if (_isString(child)) {\n                return this.addLabel(child, position);\n            }\n            if (_isFunction(child)) {\n                child = Tween.delayedCall(0, child);\n            } else {\n                return this;\n            }\n        }\n        return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!\n    };\n    _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {\n        if (nested === void 0) {\n            nested = true;\n        }\n        if (tweens === void 0) {\n            tweens = true;\n        }\n        if (timelines === void 0) {\n            timelines = true;\n        }\n        if (ignoreBeforeTime === void 0) {\n            ignoreBeforeTime = -_bigNum;\n        }\n        var a = [], child = this._first;\n        while(child){\n            if (child._start >= ignoreBeforeTime) {\n                if (child instanceof Tween) {\n                    tweens && a.push(child);\n                } else {\n                    timelines && a.push(child);\n                    nested && a.push.apply(a, child.getChildren(true, tweens, timelines));\n                }\n            }\n            child = child._next;\n        }\n        return a;\n    };\n    _proto2.getById = function getById(id) {\n        var animations = this.getChildren(1, 1, 1), i = animations.length;\n        while(i--){\n            if (animations[i].vars.id === id) {\n                return animations[i];\n            }\n        }\n    };\n    _proto2.remove = function remove(child) {\n        if (_isString(child)) {\n            return this.removeLabel(child);\n        }\n        if (_isFunction(child)) {\n            return this.killTweensOf(child);\n        }\n        _removeLinkedListItem(this, child);\n        if (child === this._recent) {\n            this._recent = this._last;\n        }\n        return _uncache(this);\n    };\n    _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {\n        if (!arguments.length) {\n            return this._tTime;\n        }\n        this._forcing = 1;\n        if (!this._dp && this._ts) {\n            //special case for the global timeline (or any other that has no parent or detached parent).\n            this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));\n        }\n        _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);\n        this._forcing = 0;\n        return this;\n    };\n    _proto2.addLabel = function addLabel(label, position) {\n        this.labels[label] = _parsePosition(this, position);\n        return this;\n    };\n    _proto2.removeLabel = function removeLabel(label) {\n        delete this.labels[label];\n        return this;\n    };\n    _proto2.addPause = function addPause(position, callback, params) {\n        var t = Tween.delayedCall(0, callback || _emptyFunc, params);\n        t.data = \"isPause\";\n        this._hasPause = 1;\n        return _addToTimeline(this, t, _parsePosition(this, position));\n    };\n    _proto2.removePause = function removePause(position) {\n        var child = this._first;\n        position = _parsePosition(this, position);\n        while(child){\n            if (child._start === position && child.data === \"isPause\") {\n                _removeFromParent(child);\n            }\n            child = child._next;\n        }\n    };\n    _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n        var tweens = this.getTweensOf(targets, onlyActive), i = tweens.length;\n        while(i--){\n            _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);\n        }\n        return this;\n    };\n    _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {\n        var a = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), // a number is interpreted as a global time. If the animation spans\n        children;\n        while(child){\n            if (child instanceof Tween) {\n                if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {\n                    // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.\n                    a.push(child);\n                }\n            } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {\n                a.push.apply(a, children);\n            }\n            child = child._next;\n        }\n        return a;\n    } // potential future feature - targets() on timelines\n    ;\n    _proto2.tweenTo = function tweenTo(position, vars) {\n        vars = vars || {};\n        var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({\n            ease: vars.ease || \"none\",\n            lazy: false,\n            immediateRender: false,\n            time: endTime,\n            overwrite: \"auto\",\n            duration: vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,\n            onStart: function onStart() {\n                tl.pause();\n                if (!initted) {\n                    var duration = vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale());\n                    tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);\n                    initted = 1;\n                }\n                _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.\n            }\n        }, vars));\n        return immediateRender ? tween.render(0) : tween;\n    };\n    _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {\n        return this.tweenTo(toPosition, _setDefaults({\n            startAt: {\n                time: _parsePosition(this, fromPosition)\n            }\n        }, vars));\n    };\n    _proto2.recent = function recent() {\n        return this._recent;\n    };\n    _proto2.nextLabel = function nextLabel(afterTime) {\n        if (afterTime === void 0) {\n            afterTime = this._time;\n        }\n        return _getLabelInDirection(this, _parsePosition(this, afterTime));\n    };\n    _proto2.previousLabel = function previousLabel(beforeTime) {\n        if (beforeTime === void 0) {\n            beforeTime = this._time;\n        }\n        return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);\n    };\n    _proto2.currentLabel = function currentLabel(value) {\n        return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);\n    };\n    _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {\n        if (ignoreBeforeTime === void 0) {\n            ignoreBeforeTime = 0;\n        }\n        var child = this._first, labels = this.labels, p;\n        while(child){\n            if (child._start >= ignoreBeforeTime) {\n                child._start += amount;\n                child._end += amount;\n            }\n            child = child._next;\n        }\n        if (adjustLabels) {\n            for(p in labels){\n                if (labels[p] >= ignoreBeforeTime) {\n                    labels[p] += amount;\n                }\n            }\n        }\n        return _uncache(this);\n    };\n    _proto2.invalidate = function invalidate(soft) {\n        var child = this._first;\n        this._lock = 0;\n        while(child){\n            child.invalidate(soft);\n            child = child._next;\n        }\n        return _Animation.prototype.invalidate.call(this, soft);\n    };\n    _proto2.clear = function clear(includeLabels) {\n        if (includeLabels === void 0) {\n            includeLabels = true;\n        }\n        var child = this._first, next;\n        while(child){\n            next = child._next;\n            this.remove(child);\n            child = next;\n        }\n        this._dp && (this._time = this._tTime = this._pTime = 0);\n        includeLabels && (this.labels = {});\n        return _uncache(this);\n    };\n    _proto2.totalDuration = function totalDuration(value) {\n        var max = 0, self = this, child = self._last, prevStart = _bigNum, prev, start, parent;\n        if (arguments.length) {\n            return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));\n        }\n        if (self._dirty) {\n            parent = self.parent;\n            while(child){\n                prev = child._prev; //record it here in case the tween changes position in the sequence...\n                child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.\n                start = child._start;\n                if (start > prevStart && self._sort && child._ts && !self._lock) {\n                    //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence\n                    self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().\n                    _addToTimeline(self, child, start - child._delay, 1)._lock = 0;\n                } else {\n                    prevStart = start;\n                }\n                if (start < 0 && child._ts) {\n                    //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.\n                    max -= start;\n                    if (!parent && !self._dp || parent && parent.smoothChildTiming) {\n                        self._start += start / self._ts;\n                        self._time -= start;\n                        self._tTime -= start;\n                    }\n                    self.shiftChildren(-start, false, -Infinity);\n                    prevStart = 0;\n                }\n                child._end > max && child._ts && (max = child._end);\n                child = prev;\n            }\n            _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);\n            self._dirty = 0;\n        }\n        return self._tDur;\n    };\n    Timeline.updateRoot = function updateRoot(time) {\n        if (_globalTimeline._ts) {\n            _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));\n            _lastRenderedFrame = _ticker.frame;\n        }\n        if (_ticker.frame >= _nextGCFrame) {\n            _nextGCFrame += _config.autoSleep || 120;\n            var child = _globalTimeline._first;\n            if (!child || !child._ts) {\n                if (_config.autoSleep && _ticker._listeners.length < 2) {\n                    while(child && !child._ts){\n                        child = child._next;\n                    }\n                    child || _ticker.sleep();\n                }\n            }\n        }\n    };\n    return Timeline;\n}(Animation);\n_setDefaults(Timeline.prototype, {\n    _lock: 0,\n    _hasPause: 0,\n    _forcing: 0\n});\nvar _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {\n    //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\n    var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a;\n    pt.b = start;\n    pt.e = end;\n    start += \"\"; //ensure values are strings\n    end += \"\";\n    if (hasRandom = ~end.indexOf(\"random(\")) {\n        end = _replaceRandom(end);\n    }\n    if (stringFilter) {\n        a = [\n            start,\n            end\n        ];\n        stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.\n        start = a[0];\n        end = a[1];\n    }\n    startNums = start.match(_complexStringNumExp) || [];\n    while(result = _complexStringNumExp.exec(end)){\n        endNum = result[0];\n        chunk = end.substring(index, result.index);\n        if (color) {\n            color = (color + 1) % 5;\n        } else if (chunk.substr(-5) === \"rgba(\") {\n            color = 1;\n        }\n        if (endNum !== startNums[matchIndex++]) {\n            startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.\n            pt._pt = {\n                _next: pt._pt,\n                p: chunk || matchIndex === 1 ? chunk : \",\",\n                //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n                s: startNum,\n                c: endNum.charAt(1) === \"=\" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,\n                m: color && color < 4 ? Math.round : 0\n            };\n            index = _complexStringNumExp.lastIndex;\n        }\n    }\n    pt.c = index < end.length ? end.substring(index, end.length) : \"\"; //we use the \"c\" of the PropTween to store the final part of the string (after the last number)\n    pt.fp = funcParam;\n    if (_relExp.test(end) || hasRandom) {\n        pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).\n    }\n    this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\n    return pt;\n}, _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {\n    _isFunction(end) && (end = end(index || 0, target, targets));\n    var currentValue = target[prop], parsedStart = start !== \"get\" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf(\"set\") || !_isFunction(target[\"get\" + prop.substr(3)]) ? prop : \"get\" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;\n    if (_isString(end)) {\n        if (~end.indexOf(\"random(\")) {\n            end = _replaceRandom(end);\n        }\n        if (end.charAt(1) === \"=\") {\n            pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);\n            if (pt || pt === 0) {\n                // to avoid isNaN, like if someone passes in a value like \"!= whatever\"\n                end = pt;\n            }\n        }\n    }\n    if (!optional || parsedStart !== end || _forceAllPropTweens) {\n        if (!isNaN(parsedStart * end) && end !== \"\") {\n            // fun fact: any number multiplied by \"\" is evaluated as the number 0!\n            pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === \"boolean\" ? _renderBoolean : _renderPlain, 0, setter);\n            funcParam && (pt.fp = funcParam);\n            modifier && pt.modifier(modifier, this, target);\n            return this._pt = pt;\n        }\n        !currentValue && !(prop in target) && _missingPlugin(prop, end);\n        return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);\n    }\n}, //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with \"random()\" in them. It does NOT process relative values.\n_processVars = function _processVars(vars, index, target, targets, tween) {\n    _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));\n    if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {\n        return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;\n    }\n    var copy = {}, p;\n    for(p in vars){\n        copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);\n    }\n    return copy;\n}, _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {\n    var plugin, pt, ptLookup, i;\n    if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {\n        tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);\n        if (tween !== _quickTween) {\n            ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.\n            i = plugin._props.length;\n            while(i--){\n                ptLookup[plugin._props[i]] = pt;\n            }\n        }\n    }\n    return plugin;\n}, _overwritingTween, //store a reference temporarily so we can avoid overwriting itself.\n_forceAllPropTweens, _initTween = function _initTween(tween, time, tTime) {\n    var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent = tween.parent, fullTargets = parent && parent.data === \"nested\" ? parent.vars.targets : targets, autoOverwrite = tween._overwrite === \"auto\" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;\n    tl && (!keyframes || !ease) && (ease = \"none\");\n    tween._ease = _parseEase(ease, _defaults.ease);\n    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;\n    if (yoyoEase && tween._yoyo && !tween._repeat) {\n        //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.\n        yoyoEase = tween._yEase;\n        tween._yEase = tween._ease;\n        tween._ease = yoyoEase;\n    }\n    tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.\n    if (!tl || keyframes && !vars.stagger) {\n        //if there's an internal timeline, skip all the parsing because we passed that task down the chain.\n        harness = targets[0] ? _getCache(targets[0]).harness : 0;\n        harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an \"x\" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.\n        cleanVars = _copyExcluding(vars, _reservedProps);\n        if (prevStartAt) {\n            prevStartAt._zTime < 0 && prevStartAt.progress(1); // in case it's a lazy startAt that hasn't rendered yet.\n            time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig); // if it's a \"startAt\" (not \"from()\" or runBackwards: true), we only need to do a shallow revert (keep transforms cached in CSSPlugin)\n            // don't just _removeFromParent(prevStartAt.render(-1, true)) because that'll leave inline styles. We're creating a new _startAt for \"startAt\" tweens that re-capture things to ensure that if the pre-tween values changed since the tween was created, they're recorded.\n            prevStartAt._lazy = 0;\n        }\n        if (startAt) {\n            _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({\n                data: \"isStart\",\n                overwrite: false,\n                parent: parent,\n                immediateRender: true,\n                lazy: !prevStartAt && _isNotFalse(lazy),\n                startAt: null,\n                delay: 0,\n                onUpdate: onUpdate && function() {\n                    return _callback(tween, \"onUpdate\");\n                },\n                stagger: 0\n            }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);\n            tween._startAt._dp = 0; // don't allow it to get put back into root timeline! Like when revert() is called and totalTime() gets set.\n            tween._startAt._sat = tween; // used in globalTime(). _sat stands for _startAtTween\n            time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.\n            if (immediateRender) {\n                if (dur && time <= 0 && tTime <= 0) {\n                    // check tTime here because in the case of a yoyo tween whose playhead gets pushed to the end like tween.progress(1), we should allow it through so that the onComplete gets fired properly.\n                    time && (tween._zTime = time);\n                    return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.\n                }\n            }\n        } else if (runBackwards && dur) {\n            //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)\n            if (!prevStartAt) {\n                time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0\n                p = _setDefaults({\n                    overwrite: false,\n                    data: \"isFromStart\",\n                    //we tag the tween with as \"isFromStart\" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a \"from()\" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:\"height\", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.\n                    lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),\n                    immediateRender: immediateRender,\n                    //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)\n                    stagger: 0,\n                    parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(\".class\", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})\n                }, cleanVars);\n                harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})\n                _removeFromParent(tween._startAt = Tween.set(targets, p));\n                tween._startAt._dp = 0; // don't allow it to get put back into root timeline!\n                tween._startAt._sat = tween; // used in globalTime()\n                time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));\n                tween._zTime = time;\n                if (!immediateRender) {\n                    _initTween(tween._startAt, _tinyNum, _tinyNum); //ensures that the initial values are recorded\n                } else if (!time) {\n                    return;\n                }\n            }\n        }\n        tween._pt = tween._ptCache = 0;\n        lazy = dur && _isNotFalse(lazy) || lazy && !dur;\n        for(i = 0; i < targets.length; i++){\n            target = targets[i];\n            gsData = target._gsap || _harness(targets)[i]._gsap;\n            tween._ptLookup[i] = ptLookup = {};\n            _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)\n            index = fullTargets === targets ? i : fullTargets.indexOf(target);\n            if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {\n                tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);\n                plugin._props.forEach(function(name) {\n                    ptLookup[name] = pt;\n                });\n                plugin.priority && (hasPriority = 1);\n            }\n            if (!harness || harnessVars) {\n                for(p in cleanVars){\n                    if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {\n                        plugin.priority && (hasPriority = 1);\n                    } else {\n                        ptLookup[p] = pt = _addPropTween.call(tween, target, p, \"get\", cleanVars[p], index, fullTargets, 0, vars.stringFilter);\n                    }\n                }\n            }\n            tween._op && tween._op[i] && tween.kill(target, tween._op[i]);\n            if (autoOverwrite && tween._pt) {\n                _overwritingTween = tween;\n                _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!\n                overwritten = !tween.parent;\n                _overwritingTween = 0;\n            }\n            tween._pt && lazy && (_lazyLookup[gsData.id] = 1);\n        }\n        hasPriority && _sortPropTweensByPriority(tween);\n        tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.\n    }\n    tween._onUpdate = onUpdate;\n    tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.\n    keyframes && time <= 0 && tl.render(_bigNum, true, true); // if there's a 0% keyframe, it'll render in the \"before\" state for any staggered/delayed animations thus when the following tween initializes, it'll use the \"before\" state instead of the \"after\" state as the initial values.\n}, _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {\n    var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property], pt, rootPT, lookup, i;\n    if (!ptCache) {\n        ptCache = tween._ptCache[property] = [];\n        lookup = tween._ptLookup;\n        i = tween._targets.length;\n        while(i--){\n            pt = lookup[i][property];\n            if (pt && pt.d && pt.d._pt) {\n                // it's a plugin, so find the nested PropTween\n                pt = pt.d._pt;\n                while(pt && pt.p !== property && pt.fp !== property){\n                    // \"fp\" is functionParam for things like setting CSS variables which require .setProperty(\"--var-name\", value)\n                    pt = pt._next;\n                }\n            }\n            if (!pt) {\n                // there is no PropTween associated with that property, so we must FORCE one to be created and ditch out of this\n                // if the tween has other properties that already rendered at new positions, we'd normally have to rewind to put them back like tween.render(0, true) before forcing an _initTween(), but that can create another edge case like tweening a timeline's progress would trigger onUpdates to fire which could move other things around. It's better to just inform users that .resetTo() should ONLY be used for tweens that already have that property. For example, you can't gsap.to(...{ y: 0 }) and then tween.restTo(\"x\", 200) for example.\n                _forceAllPropTweens = 1; // otherwise, when we _addPropTween() and it finds no change between the start and end values, it skips creating a PropTween (for efficiency...why tween when there's no difference?) but in this case we NEED that PropTween created so we can edit it.\n                tween.vars[property] = \"+=0\";\n                _initTween(tween, time);\n                _forceAllPropTweens = 0;\n                return skipRecursion ? _warn(property + \" not eligible for reset\") : 1; // if someone tries to do a quickTo() on a special property like borderRadius which must get split into 4 different properties, that's not eligible for .resetTo().\n            }\n            ptCache.push(pt);\n        }\n    }\n    i = ptCache.length;\n    while(i--){\n        rootPT = ptCache[i];\n        pt = rootPT._pt || rootPT; // complex values may have nested PropTweens. We only accommodate the FIRST value.\n        pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;\n        pt.c = value - pt.s;\n        rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e)); // mainly for CSSPlugin (end value)\n        rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b)); // (beginning value)\n    }\n}, _addAliasesToVars = function _addAliasesToVars(targets, vars) {\n    var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p, i, aliases;\n    if (!propertyAliases) {\n        return vars;\n    }\n    copy = _merge({}, vars);\n    for(p in propertyAliases){\n        if (p in copy) {\n            aliases = propertyAliases[p].split(\",\");\n            i = aliases.length;\n            while(i--){\n                copy[aliases[i]] = copy[p];\n            }\n        }\n    }\n    return copy;\n}, // parses multiple formats, like {\"0%\": {x: 100}, {\"50%\": {x: -20}} and { x: {\"0%\": 100, \"50%\": -20} }, and an \"ease\" can be set on any object. We populate an \"allProps\" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a \"t\" (time), \"v\", (value), and \"e\" (ease) property. This allows us to piece together a timeline later.\n_parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {\n    var ease = obj.ease || easeEach || \"power1.inOut\", p, a;\n    if (_isArray(obj)) {\n        a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease\n        obj.forEach(function(value, i) {\n            return a.push({\n                t: i / (obj.length - 1) * 100,\n                v: value,\n                e: ease\n            });\n        });\n    } else {\n        for(p in obj){\n            a = allProps[p] || (allProps[p] = []);\n            p === \"ease\" || a.push({\n                t: parseFloat(prop),\n                v: obj[p],\n                e: ease\n            });\n        }\n    }\n}, _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {\n    return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf(\"random(\") ? _replaceRandom(value) : value;\n}, _staggerTweenProps = _callbackNames + \"repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert\", _staggerPropsToSkip = {};\n_forEachName(_staggerTweenProps + \",id,stagger,delay,duration,paused,scrollTrigger\", function(name) {\n    return _staggerPropsToSkip[name] = 1;\n});\n/*\n * --------------------------------------------------------------------------------------\n * TWEEN\n * --------------------------------------------------------------------------------------\n */ var Tween = /*#__PURE__*/ function(_Animation2) {\n    _inheritsLoose(Tween, _Animation2);\n    function Tween(targets, vars, position, skipInherit) {\n        var _this3;\n        if (typeof vars === \"number\") {\n            position.duration = vars;\n            vars = position;\n            position = null;\n        }\n        _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;\n        var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : \"length\" in vars) ? [\n            targets\n        ] : toArray(targets), tl, i, copy, l, p, curTarget, staggerFunc, staggerVarsToMerge;\n        _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn(\"GSAP target \" + targets + \" not found. https://gsap.com\", !_config.nullTargetWarn) || [];\n        _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property\n        _this3._overwrite = overwrite;\n        if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n            vars = _this3.vars;\n            tl = _this3.timeline = new Timeline({\n                data: \"nested\",\n                defaults: defaults || {},\n                targets: parent && parent.data === \"nested\" ? parent.vars.targets : parsedTargets\n            }); // we need to store the targets because for staggers and keyframes, we end up creating an individual tween for each but function-based values need to know the index and the whole Array of targets.\n            tl.kill();\n            tl.parent = tl._dp = _assertThisInitialized(_this3);\n            tl._start = 0;\n            if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n                l = parsedTargets.length;\n                staggerFunc = stagger && distribute(stagger);\n                if (_isObject(stagger)) {\n                    //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.\n                    for(p in stagger){\n                        if (~_staggerTweenProps.indexOf(p)) {\n                            staggerVarsToMerge || (staggerVarsToMerge = {});\n                            staggerVarsToMerge[p] = stagger[p];\n                        }\n                    }\n                }\n                for(i = 0; i < l; i++){\n                    copy = _copyExcluding(vars, _staggerPropsToSkip);\n                    copy.stagger = 0;\n                    yoyoEase && (copy.yoyoEase = yoyoEase);\n                    staggerVarsToMerge && _merge(copy, staggerVarsToMerge);\n                    curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.\n                    copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);\n                    copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;\n                    if (!stagger && l === 1 && copy.delay) {\n                        // if someone does delay:\"random(1, 5)\", repeat:-1, for example, the delay shouldn't be inside the repeat.\n                        _this3._delay = delay = copy.delay;\n                        _this3._start += delay;\n                        copy.delay = 0;\n                    }\n                    tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);\n                    tl._ease = _easeMap.none;\n                }\n                tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!\n            } else if (keyframes) {\n                _inheritDefaults(_setDefaults(tl.vars.defaults, {\n                    ease: \"none\"\n                }));\n                tl._ease = _parseEase(keyframes.ease || vars.ease || \"none\");\n                var time = 0, a, kf, v;\n                if (_isArray(keyframes)) {\n                    keyframes.forEach(function(frame) {\n                        return tl.to(parsedTargets, frame, \">\");\n                    });\n                    tl.duration(); // to ensure tl._dur is cached because we tap into it for performance purposes in the render() method.\n                } else {\n                    copy = {};\n                    for(p in keyframes){\n                        p === \"ease\" || p === \"easeEach\" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);\n                    }\n                    for(p in copy){\n                        a = copy[p].sort(function(a, b) {\n                            return a.t - b.t;\n                        });\n                        time = 0;\n                        for(i = 0; i < a.length; i++){\n                            kf = a[i];\n                            v = {\n                                ease: kf.e,\n                                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration\n                            };\n                            v[p] = kf.v;\n                            tl.to(parsedTargets, v, time);\n                            time += v.duration;\n                        }\n                    }\n                    tl.duration() < duration && tl.to({}, {\n                        duration: duration - tl.duration()\n                    }); // in case keyframes didn't go to 100%\n                }\n            }\n            duration || _this3.duration(duration = tl.duration());\n        } else {\n            _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)\n        }\n        if (overwrite === true && !_suppressOverwrites) {\n            _overwritingTween = _assertThisInitialized(_this3);\n            _globalTimeline.killTweensOf(parsedTargets);\n            _overwritingTween = 0;\n        }\n        _addToTimeline(parent, _assertThisInitialized(_this3), position);\n        vars.reversed && _this3.reverse();\n        vars.paused && _this3.paused(true);\n        if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== \"nested\") {\n            _this3._tTime = -_tinyNum; //forces a render without having to set the render() \"force\" parameter to true because we want to allow lazying by default (using the \"force\" parameter always forces an immediate full render)\n            _this3.render(Math.max(0, -delay) || 0); //in case delay is negative\n        }\n        scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);\n        return _this3;\n    }\n    var _proto3 = Tween.prototype;\n    _proto3.render = function render(totalTime, suppressEvents, force) {\n        var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline, yoyoEase;\n        if (!dur) {\n            _renderZeroDurationTween(this, totalTime, suppressEvents, force);\n        } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {\n            //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)\n            time = tTime;\n            timeline = this.timeline;\n            if (this._repeat) {\n                //adjust the time for repeats and yoyos\n                cycleDuration = dur + this._rDelay;\n                if (this._repeat < -1 && isNegative) {\n                    return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n                }\n                time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\n                if (tTime === tDur) {\n                    // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)\n                    iteration = this._repeat;\n                    time = dur;\n                } else {\n                    iteration = ~~(tTime / cycleDuration);\n                    if (iteration && iteration === _roundPrecise(tTime / cycleDuration)) {\n                        time = dur;\n                        iteration--;\n                    }\n                    time > dur && (time = dur);\n                }\n                isYoyo = this._yoyo && iteration & 1;\n                if (isYoyo) {\n                    yoyoEase = this._yEase;\n                    time = dur - time;\n                }\n                prevIteration = _animationCycle(this._tTime, cycleDuration);\n                if (time === prevTime && !force && this._initted && iteration === prevIteration) {\n                    //could be during the repeatDelay part. No need to render and fire callbacks.\n                    this._tTime = tTime;\n                    return this;\n                }\n                if (iteration !== prevIteration) {\n                    timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality\n                    if (this.vars.repeatRefresh && !isYoyo && !this._lock && this._time !== cycleDuration && this._initted) {\n                        // this._time will === cycleDuration when we render at EXACTLY the end of an iteration. Without this condition, it'd often do the repeatRefresh render TWICE (again on the very next tick).\n                        this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.\n                        this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;\n                    }\n                }\n            }\n            if (!this._initted) {\n                if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {\n                    this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.\n                    return this;\n                }\n                if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {\n                    // rare edge case - during initialization, an onUpdate in the _startAt (.fromTo()) might force this tween to render at a different spot in which case we should ditch this render() call so that it doesn't revert the values. But we also don't want to dump if we're doing a repeatRefresh render!\n                    return this;\n                }\n                if (dur !== this._dur) {\n                    // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.\n                    return this.render(totalTime, suppressEvents, force);\n                }\n            }\n            this._tTime = tTime;\n            this._time = time;\n            if (!this._act && this._ts) {\n                this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.\n                this._lazy = 0;\n            }\n            this.ratio = ratio = (yoyoEase || this._ease)(time / dur);\n            if (this._from) {\n                this.ratio = ratio = 1 - ratio;\n            }\n            if (time && !prevTime && !suppressEvents && !iteration) {\n                _callback(this, \"onStart\");\n                if (this._tTime !== tTime) {\n                    // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.\n                    return this;\n                }\n            }\n            pt = this._pt;\n            while(pt){\n                pt.r(ratio, pt.d);\n                pt = pt._next;\n            }\n            timeline && timeline.render(totalTime < 0 ? totalTime : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);\n            if (this._onUpdate && !suppressEvents) {\n                isNegative && _rewindStartAt(this, totalTime, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.\n                _callback(this, \"onUpdate\");\n            }\n            this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, \"onRepeat\");\n            if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {\n                isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);\n                (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\n                if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {\n                    // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();\n                    _callback(this, tTime === tDur ? \"onComplete\" : \"onReverseComplete\", true);\n                    this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n                }\n            }\n        }\n        return this;\n    };\n    _proto3.targets = function targets() {\n        return this._targets;\n    };\n    _proto3.invalidate = function invalidate(soft) {\n        // \"soft\" gives us a way to clear out everything EXCEPT the recorded pre-\"from\" portion of from() tweens. Otherwise, for example, if you tween.progress(1).render(0, true true).invalidate(), the \"from\" values would persist and then on the next render, the from() tweens would initialize and the current value would match the \"from\" values, thus animate from the same value to the same value (no animation). We tap into this in ScrollTrigger's refresh() where we must push a tween to completion and then back again but honor its init state in case the tween is dependent on another tween further up on the page.\n        (!soft || !this.vars.runBackwards) && (this._startAt = 0);\n        this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;\n        this._ptLookup = [];\n        this.timeline && this.timeline.invalidate(soft);\n        return _Animation2.prototype.invalidate.call(this, soft);\n    };\n    _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {\n        _tickerActive || _ticker.wake();\n        this._ts || this.play();\n        var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;\n        this._initted || _initTween(this, time);\n        ratio = this._ease(time / this._dur); // don't just get tween.ratio because it may not have rendered yet.\n        // possible future addition to allow an object with multiple values to update, like tween.resetTo({x: 100, y: 200}); At this point, it doesn't seem worth the added kb given the fact that most users will likely opt for the convenient gsap.quickTo() way of interacting with this method.\n        // if (_isObject(property)) { // performance optimization\n        // \tfor (p in property) {\n        // \t\tif (_updatePropTweens(this, p, property[p], value ? value[p] : null, start, ratio, time)) {\n        // \t\t\treturn this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.\n        // \t\t}\n        // \t}\n        // } else {\n        if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {\n            return this.resetTo(property, value, start, startIsRelative, 1); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.\n        } //}\n        _alignPlayhead(this, 0);\n        this.parent || _addLinkedListItem(this._dp, this, \"_first\", \"_last\", this._dp._sort ? \"_start\" : 0);\n        return this.render(0);\n    };\n    _proto3.kill = function kill(targets, vars) {\n        if (vars === void 0) {\n            vars = \"all\";\n        }\n        if (!targets && (!vars || vars === \"all\")) {\n            this._lazy = this._pt = 0;\n            return this.parent ? _interrupt(this) : this;\n        }\n        if (this.timeline) {\n            var tDur = this.timeline.totalDuration();\n            this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.\n            this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.\n            return this;\n        }\n        var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i;\n        if ((!vars || vars === \"all\") && _arraysMatch(parsedTargets, killingTargets)) {\n            vars === \"all\" && (this._pt = 0);\n            return _interrupt(this);\n        }\n        overwrittenProps = this._op = this._op || [];\n        if (vars !== \"all\") {\n            //so people can pass in a comma-delimited list of property names\n            if (_isString(vars)) {\n                p = {};\n                _forEachName(vars, function(name) {\n                    return p[name] = 1;\n                });\n                vars = p;\n            }\n            vars = _addAliasesToVars(parsedTargets, vars);\n        }\n        i = parsedTargets.length;\n        while(i--){\n            if (~killingTargets.indexOf(parsedTargets[i])) {\n                curLookup = propTweenLookup[i];\n                if (vars === \"all\") {\n                    overwrittenProps[i] = vars;\n                    props = curLookup;\n                    curOverwriteProps = {};\n                } else {\n                    curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};\n                    props = vars;\n                }\n                for(p in props){\n                    pt = curLookup && curLookup[p];\n                    if (pt) {\n                        if (!(\"kill\" in pt.d) || pt.d.kill(p) === true) {\n                            _removeLinkedListItem(this, pt, \"_pt\");\n                        }\n                        delete curLookup[p];\n                    }\n                    if (curOverwriteProps !== \"all\") {\n                        curOverwriteProps[p] = 1;\n                    }\n                }\n            }\n        }\n        this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.\n        return this;\n    };\n    Tween.to = function to(targets, vars) {\n        return new Tween(targets, vars, arguments[2]);\n    };\n    Tween.from = function from(targets, vars) {\n        return _createTweenType(1, arguments);\n    };\n    Tween.delayedCall = function delayedCall(delay, callback, params, scope) {\n        return new Tween(callback, 0, {\n            immediateRender: false,\n            lazy: false,\n            overwrite: false,\n            delay: delay,\n            onComplete: callback,\n            onReverseComplete: callback,\n            onCompleteParams: params,\n            onReverseCompleteParams: params,\n            callbackScope: scope\n        }); // we must use onReverseComplete too for things like timeline.add(() => {...}) which should be triggered in BOTH directions (forward and reverse)\n    };\n    Tween.fromTo = function fromTo(targets, fromVars, toVars) {\n        return _createTweenType(2, arguments);\n    };\n    Tween.set = function set(targets, vars) {\n        vars.duration = 0;\n        vars.repeatDelay || (vars.repeat = 0);\n        return new Tween(targets, vars);\n    };\n    Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n        return _globalTimeline.killTweensOf(targets, props, onlyActive);\n    };\n    return Tween;\n}(Animation);\n_setDefaults(Tween.prototype, {\n    _targets: [],\n    _lazy: 0,\n    _startAt: 0,\n    _op: 0,\n    _onInit: 0\n}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)\n// _forEachName(\"to,from,fromTo,set,call,add,addLabel,addPause\", name => {\n// \tTween.prototype[name] = function() {\n// \t\tlet tl = new Timeline();\n// \t\treturn _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));\n// \t}\n// });\n//for backward compatibility. Leverage the timeline calls.\n_forEachName(\"staggerTo,staggerFrom,staggerFromTo\", function(name) {\n    Tween[name] = function() {\n        var tl = new Timeline(), params = _slice.call(arguments, 0);\n        params.splice(name === \"staggerFromTo\" ? 5 : 4, 0, 0);\n        return tl[name].apply(tl, params);\n    };\n});\n/*\n * --------------------------------------------------------------------------------------\n * PROPTWEEN\n * --------------------------------------------------------------------------------------\n */ var _setterPlain = function _setterPlain(target, property, value) {\n    return target[property] = value;\n}, _setterFunc = function _setterFunc(target, property, value) {\n    return target[property](value);\n}, _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {\n    return target[property](data.fp, value);\n}, _setterAttribute = function _setterAttribute(target, property, value) {\n    return target.setAttribute(property, value);\n}, _getSetter = function _getSetter(target, property) {\n    return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;\n}, _renderPlain = function _renderPlain(ratio, data) {\n    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);\n}, _renderBoolean = function _renderBoolean(ratio, data) {\n    return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);\n}, _renderComplexString = function _renderComplexString(ratio, data) {\n    var pt = data._pt, s = \"\";\n    if (!ratio && data.b) {\n        //b = beginning string\n        s = data.b;\n    } else if (ratio === 1 && data.e) {\n        //e = ending string\n        s = data.e;\n    } else {\n        while(pt){\n            s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the \"p\" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.\n            pt = pt._next;\n        }\n        s += data.c; //we use the \"c\" of the PropTween to store the final chunk of non-numeric text.\n    }\n    data.set(data.t, data.p, s, data);\n}, _renderPropTweens = function _renderPropTweens(ratio, data) {\n    var pt = data._pt;\n    while(pt){\n        pt.r(ratio, pt.d);\n        pt = pt._next;\n    }\n}, _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {\n    var pt = this._pt, next;\n    while(pt){\n        next = pt._next;\n        pt.p === property && pt.modifier(modifier, tween, target);\n        pt = next;\n    }\n}, _killPropTweensOf = function _killPropTweensOf(property) {\n    var pt = this._pt, hasNonDependentRemaining, next;\n    while(pt){\n        next = pt._next;\n        if (pt.p === property && !pt.op || pt.op === property) {\n            _removeLinkedListItem(this, pt, \"_pt\");\n        } else if (!pt.dep) {\n            hasNonDependentRemaining = 1;\n        }\n        pt = next;\n    }\n    return !hasNonDependentRemaining;\n}, _setterWithModifier = function _setterWithModifier(target, property, value, data) {\n    data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);\n}, _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {\n    var pt = parent._pt, next, pt2, first, last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)\n    while(pt){\n        next = pt._next;\n        pt2 = first;\n        while(pt2 && pt2.pr > pt.pr){\n            pt2 = pt2._next;\n        }\n        if (pt._prev = pt2 ? pt2._prev : last) {\n            pt._prev._next = pt;\n        } else {\n            first = pt;\n        }\n        if (pt._next = pt2) {\n            pt2._prev = pt;\n        } else {\n            last = pt;\n        }\n        pt = next;\n    }\n    parent._pt = first;\n}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)\nvar PropTween = /*#__PURE__*/ function() {\n    function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {\n        this.t = target;\n        this.s = start;\n        this.c = change;\n        this.p = prop;\n        this.r = renderer || _renderPlain;\n        this.d = data || this;\n        this.set = setter || _setterPlain;\n        this.pr = priority || 0;\n        this._next = next;\n        if (next) {\n            next._prev = this;\n        }\n    }\n    var _proto4 = PropTween.prototype;\n    _proto4.modifier = function modifier(func, tween, target) {\n        this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)\n        this.set = _setterWithModifier;\n        this.m = func;\n        this.mt = target; //modifier target\n        this.tween = tween;\n    };\n    return PropTween;\n}(); //Initialization tasks\n_forEachName(_callbackNames + \"parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger\", function(name) {\n    return _reservedProps[name] = 1;\n});\n_globals.TweenMax = _globals.TweenLite = Tween;\n_globals.TimelineLite = _globals.TimelineMax = Timeline;\n_globalTimeline = new Timeline({\n    sortChildren: false,\n    defaults: _defaults,\n    autoRemoveChildren: true,\n    id: \"root\",\n    smoothChildTiming: true\n});\n_config.stringFilter = _colorStringFilter;\nvar _media = [], _listeners = {}, _emptyArray = [], _lastMediaTime = 0, _contextID = 0, _dispatch = function _dispatch(type) {\n    return (_listeners[type] || _emptyArray).map(function(f) {\n        return f();\n    });\n}, _onMediaChange = function _onMediaChange() {\n    var time = Date.now(), matches = [];\n    if (time - _lastMediaTime > 2) {\n        _dispatch(\"matchMediaInit\");\n        _media.forEach(function(c) {\n            var queries = c.queries, conditions = c.conditions, match, p, anyMatch, toggled;\n            for(p in queries){\n                match = _win.matchMedia(queries[p]).matches; // Firefox doesn't update the \"matches\" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.\n                match && (anyMatch = 1);\n                if (match !== conditions[p]) {\n                    conditions[p] = match;\n                    toggled = 1;\n                }\n            }\n            if (toggled) {\n                c.revert();\n                anyMatch && matches.push(c);\n            }\n        });\n        _dispatch(\"matchMediaRevert\");\n        matches.forEach(function(c) {\n            return c.onMatch(c, function(func) {\n                return c.add(null, func);\n            });\n        });\n        _lastMediaTime = time;\n        _dispatch(\"matchMedia\");\n    }\n};\nvar Context = /*#__PURE__*/ function() {\n    function Context(func, scope) {\n        this.selector = scope && selector(scope);\n        this.data = [];\n        this._r = []; // returned/cleanup functions\n        this.isReverted = false;\n        this.id = _contextID++; // to work around issues that frameworks like Vue cause by making things into Proxies which make it impossible to do something like _media.indexOf(this) because \"this\" would no longer refer to the Context instance itself - it'd refer to a Proxy! We needed a way to identify the context uniquely\n        func && this.add(func);\n    }\n    var _proto5 = Context.prototype;\n    _proto5.add = function add(name, func, scope) {\n        // possible future addition if we need the ability to add() an animation to a context and for whatever reason cannot create that animation inside of a context.add(() => {...}) function.\n        // if (name && _isFunction(name.revert)) {\n        // \tthis.data.push(name);\n        // \treturn (name._ctx = this);\n        // }\n        if (_isFunction(name)) {\n            scope = func;\n            func = name;\n            name = _isFunction;\n        }\n        var self = this, f = function f() {\n            var prev = _context, prevSelector = self.selector, result;\n            prev && prev !== self && prev.data.push(self);\n            scope && (self.selector = selector(scope));\n            _context = self;\n            result = func.apply(self, arguments);\n            _isFunction(result) && self._r.push(result);\n            _context = prev;\n            self.selector = prevSelector;\n            self.isReverted = false;\n            return result;\n        };\n        self.last = f;\n        return name === _isFunction ? f(self, function(func) {\n            return self.add(null, func);\n        }) : name ? self[name] = f : f;\n    };\n    _proto5.ignore = function ignore(func) {\n        var prev = _context;\n        _context = null;\n        func(this);\n        _context = prev;\n    };\n    _proto5.getTweens = function getTweens() {\n        var a = [];\n        this.data.forEach(function(e) {\n            return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === \"nested\") && a.push(e);\n        });\n        return a;\n    };\n    _proto5.clear = function clear() {\n        this._r.length = this.data.length = 0;\n    };\n    _proto5.kill = function kill(revert, matchMedia) {\n        var _this4 = this;\n        if (revert) {\n            (function() {\n                var tweens = _this4.getTweens(), i = _this4.data.length, t;\n                while(i--){\n                    // Flip plugin tweens are very different in that they should actually be pushed to their end. The plugin replaces the timeline's .revert() method to do exactly that. But we also need to remove any of those nested tweens inside the flip timeline so that they don't get individually reverted.\n                    t = _this4.data[i];\n                    if (t.data === \"isFlip\") {\n                        t.revert();\n                        t.getChildren(true, true, false).forEach(function(tween) {\n                            return tweens.splice(tweens.indexOf(tween), 1);\n                        });\n                    }\n                } // save as an object so that we can cache the globalTime for each tween to optimize performance during the sort\n                tweens.map(function(t) {\n                    return {\n                        g: t._dur || t._delay || t._sat && !t._sat.vars.immediateRender ? t.globalTime(0) : -Infinity,\n                        t: t\n                    };\n                }).sort(function(a, b) {\n                    return b.g - a.g || -Infinity;\n                }).forEach(function(o) {\n                    return o.t.revert(revert);\n                }); // note: all of the _startAt tweens should be reverted in reverse order that they were created, and they'll all have the same globalTime (-1) so the \" || -1\" in the sort keeps the order properly.\n                i = _this4.data.length;\n                while(i--){\n                    // make sure we loop backwards so that, for example, SplitTexts that were created later on the same element get reverted first\n                    t = _this4.data[i];\n                    if (t instanceof Timeline) {\n                        if (t.data !== \"nested\") {\n                            t.scrollTrigger && t.scrollTrigger.revert();\n                            t.kill(); // don't revert() the timeline because that's duplicating efforts since we already reverted all the tweens\n                        }\n                    } else {\n                        !(t instanceof Tween) && t.revert && t.revert(revert);\n                    }\n                }\n                _this4._r.forEach(function(f) {\n                    return f(revert, _this4);\n                });\n                _this4.isReverted = true;\n            })();\n        } else {\n            this.data.forEach(function(e) {\n                return e.kill && e.kill();\n            });\n        }\n        this.clear();\n        if (matchMedia) {\n            var i = _media.length;\n            while(i--){\n                // previously, we checked _media.indexOf(this), but some frameworks like Vue enforce Proxy objects that make it impossible to get the proper result that way, so we must use a unique ID number instead.\n                _media[i].id === this.id && _media.splice(i, 1);\n            }\n        }\n    };\n    _proto5.revert = function revert(config) {\n        this.kill(config || {});\n    };\n    return Context;\n}();\nvar MatchMedia = /*#__PURE__*/ function() {\n    function MatchMedia(scope) {\n        this.contexts = [];\n        this.scope = scope;\n        _context && _context.data.push(this);\n    }\n    var _proto6 = MatchMedia.prototype;\n    _proto6.add = function add(conditions, func, scope) {\n        _isObject(conditions) || (conditions = {\n            matches: conditions\n        });\n        var context = new Context(0, scope || this.scope), cond = context.conditions = {}, mq, p, active;\n        _context && !context.selector && (context.selector = _context.selector); // in case a context is created inside a context. Like a gsap.matchMedia() that's inside a scoped gsap.context()\n        this.contexts.push(context);\n        func = context.add(\"onMatch\", func);\n        context.queries = conditions;\n        for(p in conditions){\n            if (p === \"all\") {\n                active = 1;\n            } else {\n                mq = _win.matchMedia(conditions[p]);\n                if (mq) {\n                    _media.indexOf(context) < 0 && _media.push(context);\n                    (cond[p] = mq.matches) && (active = 1);\n                    mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener(\"change\", _onMediaChange);\n                }\n            }\n        }\n        active && func(context, function(f) {\n            return context.add(null, f);\n        });\n        return this;\n    } // refresh() {\n    ;\n    _proto6.revert = function revert(config) {\n        this.kill(config || {});\n    };\n    _proto6.kill = function kill(revert) {\n        this.contexts.forEach(function(c) {\n            return c.kill(revert, true);\n        });\n    };\n    return MatchMedia;\n}();\n/*\n * --------------------------------------------------------------------------------------\n * GSAP\n * --------------------------------------------------------------------------------------\n */ var _gsap = {\n    registerPlugin: function registerPlugin() {\n        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            args[_key2] = arguments[_key2];\n        }\n        args.forEach(function(config) {\n            return _createPlugin(config);\n        });\n    },\n    timeline: function timeline(vars) {\n        return new Timeline(vars);\n    },\n    getTweensOf: function getTweensOf(targets, onlyActive) {\n        return _globalTimeline.getTweensOf(targets, onlyActive);\n    },\n    getProperty: function getProperty(target, property, unit, uncache) {\n        _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in\n        var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;\n        unit === \"native\" && (unit = \"\");\n        return !target ? target : !property ? function(property, unit, uncache) {\n            return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n        } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n    },\n    quickSetter: function quickSetter(target, property, unit) {\n        target = toArray(target);\n        if (target.length > 1) {\n            var setters = target.map(function(t) {\n                return gsap.quickSetter(t, property, unit);\n            }), l = setters.length;\n            return function(value) {\n                var i = l;\n                while(i--){\n                    setters[i](value);\n                }\n            };\n        }\n        target = target[0] || {};\n        var Plugin = _plugins[property], cache = _getCache(target), p = cache.harness && (cache.harness.aliases || {})[property] || property, // in case it's an alias, like \"rotate\" for \"rotation\".\n        setter = Plugin ? function setter(value) {\n            var p = new Plugin();\n            _quickTween._pt = 0;\n            p.init(target, unit ? value + unit : value, _quickTween, 0, [\n                target\n            ]);\n            p.render(1, p);\n            _quickTween._pt && _renderPropTweens(1, _quickTween);\n        } : cache.set(target, p);\n        return Plugin ? setter : function(value) {\n            return setter(target, p, unit ? value + unit : value, cache, 1);\n        };\n    },\n    quickTo: function quickTo(target, property, vars) {\n        var _merge2;\n        var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = \"+=0.1\", _merge2.paused = true, _merge2), vars || {})), func = function func(value, start, startIsRelative) {\n            return tween.resetTo(property, value, start, startIsRelative);\n        };\n        func.tween = tween;\n        return func;\n    },\n    isTweening: function isTweening(targets) {\n        return _globalTimeline.getTweensOf(targets, true).length > 0;\n    },\n    defaults: function defaults(value) {\n        value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));\n        return _mergeDeep(_defaults, value || {});\n    },\n    config: function config(value) {\n        return _mergeDeep(_config, value || {});\n    },\n    registerEffect: function registerEffect(_ref3) {\n        var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults = _ref3.defaults, extendTimeline = _ref3.extendTimeline;\n        (plugins || \"\").split(\",\").forEach(function(pluginName) {\n            return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + \" effect requires \" + pluginName + \" plugin.\");\n        });\n        _effects[name] = function(targets, vars, tl) {\n            return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);\n        };\n        if (extendTimeline) {\n            Timeline.prototype[name] = function(targets, vars, position) {\n                return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);\n            };\n        }\n    },\n    registerEase: function registerEase(name, ease) {\n        _easeMap[name] = _parseEase(ease);\n    },\n    parseEase: function parseEase(ease, defaultEase) {\n        return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;\n    },\n    getById: function getById(id) {\n        return _globalTimeline.getById(id);\n    },\n    exportRoot: function exportRoot(vars, includeDelayedCalls) {\n        if (vars === void 0) {\n            vars = {};\n        }\n        var tl = new Timeline(vars), child, next;\n        tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);\n        _globalTimeline.remove(tl);\n        tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).\n        tl._time = tl._tTime = _globalTimeline._time;\n        child = _globalTimeline._first;\n        while(child){\n            next = child._next;\n            if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {\n                _addToTimeline(tl, child, child._start - child._delay);\n            }\n            child = next;\n        }\n        _addToTimeline(_globalTimeline, tl, 0);\n        return tl;\n    },\n    context: function context(func, scope) {\n        return func ? new Context(func, scope) : _context;\n    },\n    matchMedia: function matchMedia(scope) {\n        return new MatchMedia(scope);\n    },\n    matchMediaRefresh: function matchMediaRefresh() {\n        return _media.forEach(function(c) {\n            var cond = c.conditions, found, p;\n            for(p in cond){\n                if (cond[p]) {\n                    cond[p] = false;\n                    found = 1;\n                }\n            }\n            found && c.revert();\n        }) || _onMediaChange();\n    },\n    addEventListener: function addEventListener(type, callback) {\n        var a = _listeners[type] || (_listeners[type] = []);\n        ~a.indexOf(callback) || a.push(callback);\n    },\n    removeEventListener: function removeEventListener(type, callback) {\n        var a = _listeners[type], i = a && a.indexOf(callback);\n        i >= 0 && a.splice(i, 1);\n    },\n    utils: {\n        wrap: wrap,\n        wrapYoyo: wrapYoyo,\n        distribute: distribute,\n        random: random,\n        snap: snap,\n        normalize: normalize,\n        getUnit: getUnit,\n        clamp: clamp,\n        splitColor: splitColor,\n        toArray: toArray,\n        selector: selector,\n        mapRange: mapRange,\n        pipe: pipe,\n        unitize: unitize,\n        interpolate: interpolate,\n        shuffle: shuffle\n    },\n    install: _install,\n    effects: _effects,\n    ticker: _ticker,\n    updateRoot: Timeline.updateRoot,\n    plugins: _plugins,\n    globalTimeline: _globalTimeline,\n    core: {\n        PropTween: PropTween,\n        globals: _addGlobal,\n        Tween: Tween,\n        Timeline: Timeline,\n        Animation: Animation,\n        getCache: _getCache,\n        _removeLinkedListItem: _removeLinkedListItem,\n        reverting: function reverting() {\n            return _reverting;\n        },\n        context: function context(toAdd) {\n            if (toAdd && _context) {\n                _context.data.push(toAdd);\n                toAdd._ctx = _context;\n            }\n            return _context;\n        },\n        suppressOverwrites: function suppressOverwrites(value) {\n            return _suppressOverwrites = value;\n        }\n    }\n};\n_forEachName(\"to,from,fromTo,delayedCall,set,killTweensOf\", function(name) {\n    return _gsap[name] = Tween[name];\n});\n_ticker.add(Timeline.updateRoot);\n_quickTween = _gsap.to({}, {\n    duration: 0\n}); // ---- EXTRA PLUGINS --------------------------------------------------------\nvar _getPluginPropTween = function _getPluginPropTween(plugin, prop) {\n    var pt = plugin._pt;\n    while(pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop){\n        pt = pt._next;\n    }\n    return pt;\n}, _addModifiers = function _addModifiers(tween, modifiers) {\n    var targets = tween._targets, p, i, pt;\n    for(p in modifiers){\n        i = targets.length;\n        while(i--){\n            pt = tween._ptLookup[i][p];\n            if (pt && (pt = pt.d)) {\n                if (pt._pt) {\n                    // is a plugin\n                    pt = _getPluginPropTween(pt, p);\n                }\n                pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);\n            }\n        }\n    }\n}, _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {\n    return {\n        name: name,\n        rawVars: 1,\n        //don't pre-process function-based values or \"random()\" strings.\n        init: function init(target, vars, tween) {\n            tween._onInit = function(tween) {\n                var temp, p;\n                if (_isString(vars)) {\n                    temp = {};\n                    _forEachName(vars, function(name) {\n                        return temp[name] = 1;\n                    }); //if the user passes in a comma-delimited list of property names to roundProps, like \"x,y\", we round to whole numbers.\n                    vars = temp;\n                }\n                if (modifier) {\n                    temp = {};\n                    for(p in vars){\n                        temp[p] = modifier(vars[p]);\n                    }\n                    vars = temp;\n                }\n                _addModifiers(tween, vars);\n            };\n        }\n    };\n}; //register core plugins\nvar gsap = _gsap.registerPlugin({\n    name: \"attr\",\n    init: function init(target, vars, tween, index, targets) {\n        var p, pt, v;\n        this.tween = tween;\n        for(p in vars){\n            v = target.getAttribute(p) || \"\";\n            pt = this.add(target, \"setAttribute\", (v || 0) + \"\", vars[p], index, targets, 0, 0, p);\n            pt.op = p;\n            pt.b = v; // record the beginning value so we can revert()\n            this._props.push(p);\n        }\n    },\n    render: function render(ratio, data) {\n        var pt = data._pt;\n        while(pt){\n            _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d); // if reverting, go back to the original (pt.b)\n            pt = pt._next;\n        }\n    }\n}, {\n    name: \"endArray\",\n    init: function init(target, value) {\n        var i = value.length;\n        while(i--){\n            this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);\n        }\n    }\n}, _buildModifierPlugin(\"roundProps\", _roundModifier), _buildModifierPlugin(\"modifiers\"), _buildModifierPlugin(\"snap\", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.\nTween.version = Timeline.version = gsap.version = \"3.12.5\";\n_coreReady = 1;\n_windowExists() && _wake();\nvar Power0 = _easeMap.Power0, Power1 = _easeMap.Power1, Power2 = _easeMap.Power2, Power3 = _easeMap.Power3, Power4 = _easeMap.Power4, Linear = _easeMap.Linear, Quad = _easeMap.Quad, Cubic = _easeMap.Cubic, Quart = _easeMap.Quart, Quint = _easeMap.Quint, Strong = _easeMap.Strong, Elastic = _easeMap.Elastic, Back = _easeMap.Back, SteppedEase = _easeMap.SteppedEase, Bounce = _easeMap.Bounce, Sine = _easeMap.Sine, Expo = _easeMap.Expo, Circ = _easeMap.Circ;\n\n //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.\n\nvar _c;\n$RefreshReg$(_c, \"GSCache\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9nc2FwLWNvcmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsU0FBU0EsdUJBQXVCQyxJQUFJO0lBQUksSUFBSUEsU0FBUyxLQUFLLEdBQUc7UUFBRSxNQUFNLElBQUlDLGVBQWU7SUFBOEQ7SUFBRSxPQUFPRDtBQUFNO0FBRXJLLFNBQVNFLGVBQWVDLFFBQVEsRUFBRUMsVUFBVTtJQUFJRCxTQUFTRSxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0gsV0FBV0MsU0FBUztJQUFHRixTQUFTRSxTQUFTLENBQUNHLFdBQVcsR0FBR0w7SUFBVUEsU0FBU00sU0FBUyxHQUFHTDtBQUFZO0FBRXRMOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCLEdBQ2xCLElBQUlNLFVBQVU7SUFDWkMsV0FBVztJQUNYQyxTQUFTO0lBQ1RDLGdCQUFnQjtJQUNoQkMsT0FBTztRQUNMQyxZQUFZO0lBQ2Q7QUFDRixHQUNJQyxZQUFZO0lBQ2RDLFVBQVU7SUFDVkMsV0FBVztJQUNYQyxPQUFPO0FBQ1QsR0FDSUMscUJBQ0FDLFlBQ0FDLFVBQ0FDLFVBQVUsS0FDVkMsV0FBVyxJQUFJRCxTQUNmRSxPQUFPQyxLQUFLQyxFQUFFLEdBQUcsR0FDakJDLFdBQVdILE9BQU8sR0FDbEJJLFFBQVEsR0FDUkMsUUFBUUosS0FBS0ssSUFBSSxFQUNqQkMsT0FBT04sS0FBS08sR0FBRyxFQUNmQyxPQUFPUixLQUFLUyxHQUFHLEVBQ2ZDLFlBQVksU0FBU0EsVUFBVUMsS0FBSztJQUN0QyxPQUFPLE9BQU9BLFVBQVU7QUFDMUIsR0FDSUMsY0FBYyxTQUFTQSxZQUFZRCxLQUFLO0lBQzFDLE9BQU8sT0FBT0EsVUFBVTtBQUMxQixHQUNJRSxZQUFZLFNBQVNBLFVB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QUcvRCxLQUFLLENBQUMrRCxFQUFFLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO1FBQy9EO0lBQ0Y7QUFDRixHQUFHcXVCLHFCQUFxQixjQUFjN2UsaUJBQWlCNmUscUJBQXFCLGNBQWNBLHFCQUFxQixRQUFRMWUsVUFBVTFQLE1BQU0sQ0FBQywySUFBMkk7QUFFblJnTSxNQUFNMk4sT0FBTyxHQUFHOU8sU0FBUzhPLE9BQU8sR0FBRzNiLEtBQUsyYixPQUFPLEdBQUc7QUFDbEQvYixhQUFhO0FBQ2J0QixtQkFBbUI0UTtBQUNuQixJQUFJb2hCLFNBQVM3VCxTQUFTNlQsTUFBTSxFQUN4QkMsU0FBUzlULFNBQVM4VCxNQUFNLEVBQ3hCQyxTQUFTL1QsU0FBUytULE1BQU0sRUFDeEJDLFNBQVNoVSxTQUFTZ1UsTUFBTSxFQUN4QkMsU0FBU2pVLFNBQVNpVSxNQUFNLEVBQ3hCM1IsU0FBU3RDLFNBQVNzQyxNQUFNLEVBQ3hCNFIsT0FBT2xVLFNBQVNrVSxJQUFJLEVBQ3BCQyxRQUFRblUsU0FBU21VLEtBQUssRUFDdEJDLFFBQVFwVSxTQUFTb1UsS0FBSyxFQUN0QkMsUUFBUXJVLFNBQVNxVSxLQUFLLEVBQ3RCQyxTQUFTdFUsU0FBU3NVLE1BQU0sRUFDeEJDLFVBQVV2VSxTQUFTdVUsT0FBTyxFQUMxQkMsT0FBT3hVLFNBQVN3VSxJQUFJLEVBQ3BCNVIsY0FBYzVDLFNBQVM0QyxXQUFXLEVBQ2xDNlIsU0FBU3pVLFNBQVN5VSxNQUFNLEVBQ3hCQyxPQUFPMVUsU0FBUzBVLElBQUksRUFDcEJDLE9BQU8zVSxTQUFTMlUsSUFBSSxFQUNwQkMsT0FBTzVVLFNBQVM0VSxJQUFJO0FBQzJIO0FBQ3FILENBQUMsMElBQTBJO0FBRW5EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9nc2FwLWNvcmUuanM/NWQyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qIVxuICogR1NBUCAzLjEyLjVcbiAqIGh0dHBzOi8vZ3NhcC5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDI0LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dzYXAuY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdTQVAgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgX2NvbmZpZyA9IHtcbiAgYXV0b1NsZWVwOiAxMjAsXG4gIGZvcmNlM0Q6IFwiYXV0b1wiLFxuICBudWxsVGFyZ2V0V2FybjogMSxcbiAgdW5pdHM6IHtcbiAgICBsaW5lSGVpZ2h0OiBcIlwiXG4gIH1cbn0sXG4gICAgX2RlZmF1bHRzID0ge1xuICBkdXJhdGlvbjogLjUsXG4gIG92ZXJ3cml0ZTogZmFsc2UsXG4gIGRlbGF5OiAwXG59LFxuICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMsXG4gICAgX3JldmVydGluZyxcbiAgICBfY29udGV4dCxcbiAgICBfYmlnTnVtID0gMWU4LFxuICAgIF90aW55TnVtID0gMSAvIF9iaWdOdW0sXG4gICAgXzJQSSA9IE1hdGguUEkgKiAyLFxuICAgIF9IQUxGX1BJID0gXzJQSSAvIDQsXG4gICAgX2dzSUQgPSAwLFxuICAgIF9zcXJ0ID0gTWF0aC5zcXJ0LFxuICAgIF9jb3MgPSBNYXRoLmNvcyxcbiAgICBfc2luID0gTWF0aC5zaW4sXG4gICAgX2lzU3RyaW5nID0gZnVuY3Rpb24gX2lzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59LFxuICAgIF9pc0Z1bmN0aW9uID0gZnVuY3Rpb24gX2lzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufSxcbiAgICBfaXNOdW1iZXIgPSBmdW5jdGlvbiBfaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn0sXG4gICAgX2lzVW5kZWZpbmVkID0gZnVuY3Rpb24gX2lzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9pc09iamVjdCA9IGZ1bmN0aW9uIF9pc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufSxcbiAgICBfaXNOb3RGYWxzZSA9IGZ1bmN0aW9uIF9pc05vdEZhbHNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gZmFsc2U7XG59LFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2lzRnVuY09yU3RyaW5nID0gZnVuY3Rpb24gX2lzRnVuY09yU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBfaXNGdW5jdGlvbih2YWx1ZSkgfHwgX2lzU3RyaW5nKHZhbHVlKTtcbn0sXG4gICAgX2lzVHlwZWRBcnJheSA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiICYmIEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbiAoKSB7fSxcbiAgICAvLyBub3RlOiBJRTEwIGhhcyBBcnJheUJ1ZmZlciwgYnV0IE5PVCBBcnJheUJ1ZmZlci5pc1ZpZXcoKS5cbl9pc0FycmF5ID0gQXJyYXkuaXNBcnJheSxcbiAgICBfc3RyaWN0TnVtRXhwID0gLyg/Oi0/XFwuP1xcZHxcXC4pKy9naSxcbiAgICAvL29ubHkgbnVtYmVycyAoaW5jbHVkaW5nIG5lZ2F0aXZlcyBhbmQgZGVjaW1hbHMpIGJ1dCBOT1QgcmVsYXRpdmUgdmFsdWVzLlxuX251bUV4cCA9IC9bLSs9Ll0qXFxkK1suZVxcLStdKlxcZCpbZVxcLStdKlxcZCovZyxcbiAgICAvL2ZpbmRzIGFueSBudW1iZXJzLCBpbmNsdWRpbmcgb25lcyB0aGF0IHN0YXJ0IHdpdGggKz0gb3IgLT0sIG5lZ2F0aXZlIG51bWJlcnMsIGFuZCBvbmVzIGluIHNjaWVudGlmaWMgbm90YXRpb24gbGlrZSAxZS04LlxuX251bVdpdGhVbml0RXhwID0gL1stKz0uXSpcXGQrWy5lLV0qXFxkKlthLXolXSovZyxcbiAgICBfY29tcGxleFN0cmluZ051bUV4cCA9IC9bLSs9Ll0qXFxkK1xcLj9cXGQqKD86ZS18ZVxcKyk/XFxkKi9naSxcbiAgICAvL2R1cGxpY2F0ZSBzbyB0aGF0IHdoaWxlIHdlJ3JlIGxvb3BpbmcgdGhyb3VnaCBtYXRjaGVzIGZyb20gZXhlYygpLCBpdCBkb2Vzbid0IGNvbnRhbWluYXRlIHRoZSBsYXN0SW5kZXggb2YgX251bUV4cCB3aGljaCB3ZSB1c2UgdG8gc2VhcmNoIGZvciBjb2xvcnMgdG9vLlxuX3JlbEV4cCA9IC9bKy1dPS0/Wy5cXGRdKy8sXG4gICAgX2RlbGltaXRlZFZhbHVlRXhwID0gL1teLCdcIlxcW1xcXVxcc10rL2dpLFxuICAgIC8vIHByZXZpb3VzbHkgL1sjXFwtKy5dKlxcYlthLXpcXGRcXC09KyUuXSsvZ2kgYnV0IGRpZG4ndCBjYXRjaCBzcGVjaWFsIGNoYXJhY3RlcnMuXG5fdW5pdEV4cCA9IC9eWytcXC09ZVxcc1xcZF0qXFxkK1suXFxkXSooW2Etel0qfCUpXFxzKiQvaSxcbiAgICBfZ2xvYmFsVGltZWxpbmUsXG4gICAgX3dpbixcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX2RvYyxcbiAgICBfZ2xvYmFscyA9IHt9LFxuICAgIF9pbnN0YWxsU2NvcGUgPSB7fSxcbiAgICBfY29yZVJlYWR5LFxuICAgIF9pbnN0YWxsID0gZnVuY3Rpb24gX2luc3RhbGwoc2NvcGUpIHtcbiAgcmV0dXJuIChfaW5zdGFsbFNjb3BlID0gX21lcmdlKHNjb3BlLCBfZ2xvYmFscykpICYmIGdzYXA7XG59LFxuICAgIF9taXNzaW5nUGx1Z2luID0gZnVuY3Rpb24gX21pc3NpbmdQbHVnaW4ocHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHByb3BlcnR5XCIsIHByb3BlcnR5LCBcInNldCB0b1wiLCB2YWx1ZSwgXCJNaXNzaW5nIHBsdWdpbj8gZ3NhcC5yZWdpc3RlclBsdWdpbigpXCIpO1xufSxcbiAgICBfd2FybiA9IGZ1bmN0aW9uIF93YXJuKG1lc3NhZ2UsIHN1cHByZXNzKSB7XG4gIHJldHVybiAhc3VwcHJlc3MgJiYgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xufSxcbiAgICBfYWRkR2xvYmFsID0gZnVuY3Rpb24gX2FkZEdsb2JhbChuYW1lLCBvYmopIHtcbiAgcmV0dXJuIG5hbWUgJiYgKF9nbG9iYWxzW25hbWVdID0gb2JqKSAmJiBfaW5zdGFsbFNjb3BlICYmIChfaW5zdGFsbFNjb3BlW25hbWVdID0gb2JqKSB8fCBfZ2xvYmFscztcbn0sXG4gICAgX2VtcHR5RnVuYyA9IGZ1bmN0aW9uIF9lbXB0eUZ1bmMoKSB7XG4gIHJldHVybiAwO1xufSxcbiAgICBfc3RhcnRBdFJldmVydENvbmZpZyA9IHtcbiAgc3VwcHJlc3NFdmVudHM6IHRydWUsXG4gIGlzU3RhcnQ6IHRydWUsXG4gIGtpbGw6IGZhbHNlXG59LFxuICAgIF9yZXZlcnRDb25maWdOb0tpbGwgPSB7XG4gIHN1cHByZXNzRXZlbnRzOiB0cnVlLFxuICBraWxsOiBmYWxzZVxufSxcbiAgICBfcmV2ZXJ0Q29uZmlnID0ge1xuICBzdXBwcmVzc0V2ZW50czogdHJ1ZVxufSxcbiAgICBfcmVzZXJ2ZWRQcm9wcyA9IHt9LFxuICAgIF9sYXp5VHdlZW5zID0gW10sXG4gICAgX2xhenlMb29rdXAgPSB7fSxcbiAgICBfbGFzdFJlbmRlcmVkRnJhbWUsXG4gICAgX3BsdWdpbnMgPSB7fSxcbiAgICBfZWZmZWN0cyA9IHt9LFxuICAgIF9uZXh0R0NGcmFtZSA9IDMwLFxuICAgIF9oYXJuZXNzUGx1Z2lucyA9IFtdLFxuICAgIF9jYWxsYmFja05hbWVzID0gXCJcIixcbiAgICBfaGFybmVzcyA9IGZ1bmN0aW9uIF9oYXJuZXNzKHRhcmdldHMpIHtcbiAgdmFyIHRhcmdldCA9IHRhcmdldHNbMF0sXG4gICAgICBoYXJuZXNzUGx1Z2luLFxuICAgICAgaTtcbiAgX2lzT2JqZWN0KHRhcmdldCkgfHwgX2lzRnVuY3Rpb24odGFyZ2V0KSB8fCAodGFyZ2V0cyA9IFt0YXJnZXRzXSk7XG5cbiAgaWYgKCEoaGFybmVzc1BsdWdpbiA9ICh0YXJnZXQuX2dzYXAgfHwge30pLmhhcm5lc3MpKSB7XG4gICAgLy8gZmluZCB0aGUgZmlyc3QgdGFyZ2V0IHdpdGggYSBoYXJuZXNzLiBXZSBhc3N1bWUgdGFyZ2V0cyBwYXNzZWQgaW50byBhbiBhbmltYXRpb24gd2lsbCBiZSBvZiBzaW1pbGFyIHR5cGUsIG1lYW5pbmcgdGhlIHNhbWUga2luZCBvZiBoYXJuZXNzIGNhbiBiZSB1c2VkIGZvciB0aGVtIGFsbCAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uKVxuICAgIGkgPSBfaGFybmVzc1BsdWdpbnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSAmJiAhX2hhcm5lc3NQbHVnaW5zW2ldLnRhcmdldFRlc3QodGFyZ2V0KSkge31cblxuICAgIGhhcm5lc3NQbHVnaW4gPSBfaGFybmVzc1BsdWdpbnNbaV07XG4gIH1cblxuICBpID0gdGFyZ2V0cy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHRhcmdldHNbaV0gJiYgKHRhcmdldHNbaV0uX2dzYXAgfHwgKHRhcmdldHNbaV0uX2dzYXAgPSBuZXcgR1NDYWNoZSh0YXJnZXRzW2ldLCBoYXJuZXNzUGx1Z2luKSkpIHx8IHRhcmdldHMuc3BsaWNlKGksIDEpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldHM7XG59LFxuICAgIF9nZXRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRDYWNoZSh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldC5fZ3NhcCB8fCBfaGFybmVzcyh0b0FycmF5KHRhcmdldCkpWzBdLl9nc2FwO1xufSxcbiAgICBfZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiBfZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgdikge1xuICByZXR1cm4gKHYgPSB0YXJnZXRbcHJvcGVydHldKSAmJiBfaXNGdW5jdGlvbih2KSA/IHRhcmdldFtwcm9wZXJ0eV0oKSA6IF9pc1VuZGVmaW5lZCh2KSAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUocHJvcGVydHkpIHx8IHY7XG59LFxuICAgIF9mb3JFYWNoTmFtZSA9IGZ1bmN0aW9uIF9mb3JFYWNoTmFtZShuYW1lcywgZnVuYykge1xuICByZXR1cm4gKG5hbWVzID0gbmFtZXMuc3BsaXQoXCIsXCIpKS5mb3JFYWNoKGZ1bmMpIHx8IG5hbWVzO1xufSxcbiAgICAvL3NwbGl0IGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgbmFtZXMgaW50byBhbiBhcnJheSwgdGhlbiBydW4gYSBmb3JFYWNoKCkgZnVuY3Rpb24gYW5kIHJldHVybiB0aGUgc3BsaXQgYXJyYXkgKHRoaXMgaXMganVzdCBhIHdheSB0byBjb25zb2xpZGF0ZS9zaG9ydGVuIHNvbWUgY29kZSkuXG5fcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMDApIC8gMTAwMDAwIHx8IDA7XG59LFxuICAgIF9yb3VuZFByZWNpc2UgPSBmdW5jdGlvbiBfcm91bmRQcmVjaXNlKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwMDApIC8gMTAwMDAwMDAgfHwgMDtcbn0sXG4gICAgLy8gaW5jcmVhc2VkIHByZWNpc2lvbiBtb3N0bHkgZm9yIHRpbWluZyB2YWx1ZXMuXG5fcGFyc2VSZWxhdGl2ZSA9IGZ1bmN0aW9uIF9wYXJzZVJlbGF0aXZlKHN0YXJ0LCB2YWx1ZSkge1xuICB2YXIgb3BlcmF0b3IgPSB2YWx1ZS5jaGFyQXQoMCksXG4gICAgICBlbmQgPSBwYXJzZUZsb2F0KHZhbHVlLnN1YnN0cigyKSk7XG4gIHN0YXJ0ID0gcGFyc2VGbG9hdChzdGFydCk7XG4gIHJldHVybiBvcGVyYXRvciA9PT0gXCIrXCIgPyBzdGFydCArIGVuZCA6IG9wZXJhdG9yID09PSBcIi1cIiA/IHN0YXJ0IC0gZW5kIDogb3BlcmF0b3IgPT09IFwiKlwiID8gc3RhcnQgKiBlbmQgOiBzdGFydCAvIGVuZDtcbn0sXG4gICAgX2FycmF5Q29udGFpbnNBbnkgPSBmdW5jdGlvbiBfYXJyYXlDb250YWluc0FueSh0b1NlYXJjaCwgdG9GaW5kKSB7XG4gIC8vc2VhcmNoZXMgb25lIGFycmF5IHRvIGZpbmQgbWF0Y2hlcyBmb3IgYW55IG9mIHRoZSBpdGVtcyBpbiB0aGUgdG9GaW5kIGFycmF5LiBBcyBzb29uIGFzIG9uZSBpcyBmb3VuZCwgaXQgcmV0dXJucyB0cnVlLiBJdCBkb2VzIE5PVCByZXR1cm4gYWxsIHRoZSBtYXRjaGVzOyBpdCdzIHNpbXBseSBhIGJvb2xlYW4gc2VhcmNoLlxuICB2YXIgbCA9IHRvRmluZC5sZW5ndGgsXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgdG9TZWFyY2guaW5kZXhPZih0b0ZpbmRbaV0pIDwgMCAmJiArK2kgPCBsOykge31cblxuICByZXR1cm4gaSA8IGw7XG59LFxuICAgIF9sYXp5UmVuZGVyID0gZnVuY3Rpb24gX2xhenlSZW5kZXIoKSB7XG4gIHZhciBsID0gX2xhenlUd2VlbnMubGVuZ3RoLFxuICAgICAgYSA9IF9sYXp5VHdlZW5zLnNsaWNlKDApLFxuICAgICAgaSxcbiAgICAgIHR3ZWVuO1xuXG4gIF9sYXp5TG9va3VwID0ge307XG4gIF9sYXp5VHdlZW5zLmxlbmd0aCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHR3ZWVuID0gYVtpXTtcbiAgICB0d2VlbiAmJiB0d2Vlbi5fbGF6eSAmJiAodHdlZW4ucmVuZGVyKHR3ZWVuLl9sYXp5WzBdLCB0d2Vlbi5fbGF6eVsxXSwgdHJ1ZSkuX2xhenkgPSAwKTtcbiAgfVxufSxcbiAgICBfbGF6eVNhZmVSZW5kZXIgPSBmdW5jdGlvbiBfbGF6eVNhZmVSZW5kZXIoYW5pbWF0aW9uLCB0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgX2xhenlUd2VlbnMubGVuZ3RoICYmICFfcmV2ZXJ0aW5nICYmIF9sYXp5UmVuZGVyKCk7XG4gIGFuaW1hdGlvbi5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlIHx8IF9yZXZlcnRpbmcgJiYgdGltZSA8IDAgJiYgKGFuaW1hdGlvbi5faW5pdHRlZCB8fCBhbmltYXRpb24uX3N0YXJ0QXQpKTtcbiAgX2xhenlUd2VlbnMubGVuZ3RoICYmICFfcmV2ZXJ0aW5nICYmIF9sYXp5UmVuZGVyKCk7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBzb21lb25lIGNhbGxzIHNlZWsoKSBvciB0aW1lKCkgb3IgcHJvZ3Jlc3MoKSwgdGhleSBleHBlY3QgYW4gaW1tZWRpYXRlIHJlbmRlci5cbn0sXG4gICAgX251bWVyaWNJZlBvc3NpYmxlID0gZnVuY3Rpb24gX251bWVyaWNJZlBvc3NpYmxlKHZhbHVlKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIHJldHVybiAobiB8fCBuID09PSAwKSAmJiAodmFsdWUgKyBcIlwiKS5tYXRjaChfZGVsaW1pdGVkVmFsdWVFeHApLmxlbmd0aCA8IDIgPyBuIDogX2lzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xufSxcbiAgICBfcGFzc1Rocm91Z2ggPSBmdW5jdGlvbiBfcGFzc1Rocm91Z2gocCkge1xuICByZXR1cm4gcDtcbn0sXG4gICAgX3NldERlZmF1bHRzID0gZnVuY3Rpb24gX3NldERlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIHAgaW4gb2JqIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfc2V0S2V5ZnJhbWVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9zZXRLZXlmcmFtZURlZmF1bHRzKGV4Y2x1ZGVEdXJhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgZGVmYXVsdHMpIHtcbiAgICBmb3IgKHZhciBwIGluIGRlZmF1bHRzKSB7XG4gICAgICBwIGluIG9iaiB8fCBwID09PSBcImR1cmF0aW9uXCIgJiYgZXhjbHVkZUR1cmF0aW9uIHx8IHAgPT09IFwiZWFzZVwiIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gICAgfVxuICB9O1xufSxcbiAgICBfbWVyZ2UgPSBmdW5jdGlvbiBfbWVyZ2UoYmFzZSwgdG9NZXJnZSkge1xuICBmb3IgKHZhciBwIGluIHRvTWVyZ2UpIHtcbiAgICBiYXNlW3BdID0gdG9NZXJnZVtwXTtcbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufSxcbiAgICBfbWVyZ2VEZWVwID0gZnVuY3Rpb24gX21lcmdlRGVlcChiYXNlLCB0b01lcmdlKSB7XG4gIGZvciAodmFyIHAgaW4gdG9NZXJnZSkge1xuICAgIHAgIT09IFwiX19wcm90b19fXCIgJiYgcCAhPT0gXCJjb25zdHJ1Y3RvclwiICYmIHAgIT09IFwicHJvdG90eXBlXCIgJiYgKGJhc2VbcF0gPSBfaXNPYmplY3QodG9NZXJnZVtwXSkgPyBfbWVyZ2VEZWVwKGJhc2VbcF0gfHwgKGJhc2VbcF0gPSB7fSksIHRvTWVyZ2VbcF0pIDogdG9NZXJnZVtwXSk7XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn0sXG4gICAgX2NvcHlFeGNsdWRpbmcgPSBmdW5jdGlvbiBfY29weUV4Y2x1ZGluZyhvYmosIGV4Y2x1ZGluZykge1xuICB2YXIgY29weSA9IHt9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gb2JqKSB7XG4gICAgcCBpbiBleGNsdWRpbmcgfHwgKGNvcHlbcF0gPSBvYmpbcF0pO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIF9pbmhlcml0RGVmYXVsdHMgPSBmdW5jdGlvbiBfaW5oZXJpdERlZmF1bHRzKHZhcnMpIHtcbiAgdmFyIHBhcmVudCA9IHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZSxcbiAgICAgIGZ1bmMgPSB2YXJzLmtleWZyYW1lcyA/IF9zZXRLZXlmcmFtZURlZmF1bHRzKF9pc0FycmF5KHZhcnMua2V5ZnJhbWVzKSkgOiBfc2V0RGVmYXVsdHM7XG5cbiAgaWYgKF9pc05vdEZhbHNlKHZhcnMuaW5oZXJpdCkpIHtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBmdW5jKHZhcnMsIHBhcmVudC52YXJzLmRlZmF1bHRzKTtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQgfHwgcGFyZW50Ll9kcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFycztcbn0sXG4gICAgX2FycmF5c01hdGNoID0gZnVuY3Rpb24gX2FycmF5c01hdGNoKGExLCBhMikge1xuICB2YXIgaSA9IGExLmxlbmd0aCxcbiAgICAgIG1hdGNoID0gaSA9PT0gYTIubGVuZ3RoO1xuXG4gIHdoaWxlIChtYXRjaCAmJiBpLS0gJiYgYTFbaV0gPT09IGEyW2ldKSB7fVxuXG4gIHJldHVybiBpIDwgMDtcbn0sXG4gICAgX2FkZExpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX2FkZExpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3AsIHNvcnRCeSkge1xuICBpZiAoZmlyc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBmaXJzdFByb3AgPSBcIl9maXJzdFwiO1xuICB9XG5cbiAgaWYgKGxhc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBsYXN0UHJvcCA9IFwiX2xhc3RcIjtcbiAgfVxuXG4gIHZhciBwcmV2ID0gcGFyZW50W2xhc3RQcm9wXSxcbiAgICAgIHQ7XG5cbiAgaWYgKHNvcnRCeSkge1xuICAgIHQgPSBjaGlsZFtzb3J0QnldO1xuXG4gICAgd2hpbGUgKHByZXYgJiYgcHJldltzb3J0QnldID4gdCkge1xuICAgICAgcHJldiA9IHByZXYuX3ByZXY7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXYpIHtcbiAgICBjaGlsZC5fbmV4dCA9IHByZXYuX25leHQ7XG4gICAgcHJldi5fbmV4dCA9IGNoaWxkO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkLl9uZXh0ID0gcGFyZW50W2ZpcnN0UHJvcF07XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBjaGlsZDtcbiAgfVxuXG4gIGlmIChjaGlsZC5fbmV4dCkge1xuICAgIGNoaWxkLl9uZXh0Ll9wcmV2ID0gY2hpbGQ7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50W2xhc3RQcm9wXSA9IGNoaWxkO1xuICB9XG5cbiAgY2hpbGQuX3ByZXYgPSBwcmV2O1xuICBjaGlsZC5wYXJlbnQgPSBjaGlsZC5fZHAgPSBwYXJlbnQ7XG4gIHJldHVybiBjaGlsZDtcbn0sXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX3JlbW92ZUxpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3ApIHtcbiAgaWYgKGZpcnN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgZmlyc3RQcm9wID0gXCJfZmlyc3RcIjtcbiAgfVxuXG4gIGlmIChsYXN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgbGFzdFByb3AgPSBcIl9sYXN0XCI7XG4gIH1cblxuICB2YXIgcHJldiA9IGNoaWxkLl9wcmV2LFxuICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5fbmV4dCA9IG5leHQ7XG4gIH0gZWxzZSBpZiAocGFyZW50W2ZpcnN0UHJvcF0gPT09IGNoaWxkKSB7XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0Ll9wcmV2ID0gcHJldjtcbiAgfSBlbHNlIGlmIChwYXJlbnRbbGFzdFByb3BdID09PSBjaGlsZCkge1xuICAgIHBhcmVudFtsYXN0UHJvcF0gPSBwcmV2O1xuICB9XG5cbiAgY2hpbGQuX25leHQgPSBjaGlsZC5fcHJldiA9IGNoaWxkLnBhcmVudCA9IG51bGw7IC8vIGRvbid0IGRlbGV0ZSB0aGUgX2RwIGp1c3Qgc28gd2UgY2FuIHJldmVydCBpZiBuZWNlc3NhcnkuIEJ1dCBwYXJlbnQgc2hvdWxkIGJlIG51bGwgdG8gaW5kaWNhdGUgdGhlIGl0ZW0gaXNuJ3QgaW4gYSBsaW5rZWQgbGlzdC5cbn0sXG4gICAgX3JlbW92ZUZyb21QYXJlbnQgPSBmdW5jdGlvbiBfcmVtb3ZlRnJvbVBhcmVudChjaGlsZCwgb25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSkge1xuICBjaGlsZC5wYXJlbnQgJiYgKCFvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlIHx8IGNoaWxkLnBhcmVudC5hdXRvUmVtb3ZlQ2hpbGRyZW4pICYmIGNoaWxkLnBhcmVudC5yZW1vdmUgJiYgY2hpbGQucGFyZW50LnJlbW92ZShjaGlsZCk7XG4gIGNoaWxkLl9hY3QgPSAwO1xufSxcbiAgICBfdW5jYWNoZSA9IGZ1bmN0aW9uIF91bmNhY2hlKGFuaW1hdGlvbiwgY2hpbGQpIHtcbiAgaWYgKGFuaW1hdGlvbiAmJiAoIWNoaWxkIHx8IGNoaWxkLl9lbmQgPiBhbmltYXRpb24uX2R1ciB8fCBjaGlsZC5fc3RhcnQgPCAwKSkge1xuICAgIC8vIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogaWYgYSBjaGlsZCBhbmltYXRpb24gaXMgcGFzc2VkIGluIHdlIHNob3VsZCBvbmx5IHVuY2FjaGUgaWYgdGhhdCBjaGlsZCBFWFRFTkRTIHRoZSBhbmltYXRpb24gKGl0cyBlbmQgdGltZSBpcyBiZXlvbmQgdGhlIGVuZClcbiAgICB2YXIgYSA9IGFuaW1hdGlvbjtcblxuICAgIHdoaWxlIChhKSB7XG4gICAgICBhLl9kaXJ0eSA9IDE7XG4gICAgICBhID0gYS5wYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG4gICAgX3JlY2FjaGVBbmNlc3RvcnMgPSBmdW5jdGlvbiBfcmVjYWNoZUFuY2VzdG9ycyhhbmltYXRpb24pIHtcbiAgdmFyIHBhcmVudCA9IGFuaW1hdGlvbi5wYXJlbnQ7XG5cbiAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQucGFyZW50KSB7XG4gICAgLy9zb21ldGltZXMgd2UgbXVzdCBmb3JjZSBhIHJlLXNvcnQgb2YgYWxsIGNoaWxkcmVuIGFuZCB1cGRhdGUgdGhlIGR1cmF0aW9uL3RvdGFsRHVyYXRpb24gb2YgYWxsIGFuY2VzdG9yIHRpbWVsaW5lcyBpbW1lZGlhdGVseSBpbiBjYXNlLCBmb3IgZXhhbXBsZSwgaW4gdGhlIG1pZGRsZSBvZiBhIHJlbmRlciBsb29wLCBvbmUgdHdlZW4gYWx0ZXJzIGFub3RoZXIgdHdlZW4ncyB0aW1lU2NhbGUgd2hpY2ggc2hvdmVzIGl0cyBzdGFydFRpbWUgYmVmb3JlIDAsIGZvcmNpbmcgdGhlIHBhcmVudCB0aW1lbGluZSB0byBzaGlmdCBhcm91bmQgYW5kIHNoaWZ0Q2hpbGRyZW4oKSB3aGljaCBjb3VsZCBhZmZlY3QgdGhhdCBuZXh0IHR3ZWVuJ3MgcmVuZGVyIChzdGFydFRpbWUpLiBEb2Vzbid0IG1hdHRlciBmb3IgdGhlIHJvb3QgdGltZWxpbmUgdGhvdWdoLlxuICAgIHBhcmVudC5fZGlydHkgPSAxO1xuICAgIHBhcmVudC50b3RhbER1cmF0aW9uKCk7XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuXG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9yZXdpbmRTdGFydEF0ID0gZnVuY3Rpb24gX3Jld2luZFN0YXJ0QXQodHdlZW4sIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG4gIHJldHVybiB0d2Vlbi5fc3RhcnRBdCAmJiAoX3JldmVydGluZyA/IHR3ZWVuLl9zdGFydEF0LnJldmVydChfcmV2ZXJ0Q29uZmlnTm9LaWxsKSA6IHR3ZWVuLnZhcnMuaW1tZWRpYXRlUmVuZGVyICYmICF0d2Vlbi52YXJzLmF1dG9SZXZlcnQgfHwgdHdlZW4uX3N0YXJ0QXQucmVuZGVyKHRvdGFsVGltZSwgdHJ1ZSwgZm9yY2UpKTtcbn0sXG4gICAgX2hhc05vUGF1c2VkQW5jZXN0b3JzID0gZnVuY3Rpb24gX2hhc05vUGF1c2VkQW5jZXN0b3JzKGFuaW1hdGlvbikge1xuICByZXR1cm4gIWFuaW1hdGlvbiB8fCBhbmltYXRpb24uX3RzICYmIF9oYXNOb1BhdXNlZEFuY2VzdG9ycyhhbmltYXRpb24ucGFyZW50KTtcbn0sXG4gICAgX2VsYXBzZWRDeWNsZUR1cmF0aW9uID0gZnVuY3Rpb24gX2VsYXBzZWRDeWNsZUR1cmF0aW9uKGFuaW1hdGlvbikge1xuICByZXR1cm4gYW5pbWF0aW9uLl9yZXBlYXQgPyBfYW5pbWF0aW9uQ3ljbGUoYW5pbWF0aW9uLl90VGltZSwgYW5pbWF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uKCkgKyBhbmltYXRpb24uX3JEZWxheSkgKiBhbmltYXRpb24gOiAwO1xufSxcbiAgICAvLyBmZWVkIGluIHRoZSB0b3RhbFRpbWUgYW5kIGN5Y2xlRHVyYXRpb24gYW5kIGl0J2xsIHJldHVybiB0aGUgY3ljbGUgKGl0ZXJhdGlvbiBtaW51cyAxKSBhbmQgaWYgdGhlIHBsYXloZWFkIGlzIGV4YWN0bHkgYXQgdGhlIHZlcnkgRU5ELCBpdCB3aWxsIE5PVCBidW1wIHVwIHRvIHRoZSBuZXh0IGN5Y2xlLlxuX2FuaW1hdGlvbkN5Y2xlID0gZnVuY3Rpb24gX2FuaW1hdGlvbkN5Y2xlKHRUaW1lLCBjeWNsZUR1cmF0aW9uKSB7XG4gIHZhciB3aG9sZSA9IE1hdGguZmxvb3IodFRpbWUgLz0gY3ljbGVEdXJhdGlvbik7XG4gIHJldHVybiB0VGltZSAmJiB3aG9sZSA9PT0gdFRpbWUgPyB3aG9sZSAtIDEgOiB3aG9sZTtcbn0sXG4gICAgX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUgPSBmdW5jdGlvbiBfcGFyZW50VG9DaGlsZFRvdGFsVGltZShwYXJlbnRUaW1lLCBjaGlsZCkge1xuICByZXR1cm4gKHBhcmVudFRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzICsgKGNoaWxkLl90cyA+PSAwID8gMCA6IGNoaWxkLl9kaXJ0eSA/IGNoaWxkLnRvdGFsRHVyYXRpb24oKSA6IGNoaWxkLl90RHVyKTtcbn0sXG4gICAgX3NldEVuZCA9IGZ1bmN0aW9uIF9zZXRFbmQoYW5pbWF0aW9uKSB7XG4gIHJldHVybiBhbmltYXRpb24uX2VuZCA9IF9yb3VuZFByZWNpc2UoYW5pbWF0aW9uLl9zdGFydCArIChhbmltYXRpb24uX3REdXIgLyBNYXRoLmFicyhhbmltYXRpb24uX3RzIHx8IGFuaW1hdGlvbi5fcnRzIHx8IF90aW55TnVtKSB8fCAwKSk7XG59LFxuICAgIF9hbGlnblBsYXloZWFkID0gZnVuY3Rpb24gX2FsaWduUGxheWhlYWQoYW5pbWF0aW9uLCB0b3RhbFRpbWUpIHtcbiAgLy8gYWRqdXN0cyB0aGUgYW5pbWF0aW9uJ3MgX3N0YXJ0IGFuZCBfZW5kIGFjY29yZGluZyB0byB0aGUgcHJvdmlkZWQgdG90YWxUaW1lIChvbmx5IGlmIHRoZSBwYXJlbnQncyBzbW9vdGhDaGlsZFRpbWluZyBpcyB0cnVlIGFuZCB0aGUgYW5pbWF0aW9uIGlzbid0IHBhdXNlZCkuIEl0IGRvZXNuJ3QgZG8gYW55IHJlbmRlcmluZyBvciBmb3JjaW5nIHRoaW5ncyBiYWNrIGludG8gcGFyZW50IHRpbWVsaW5lcywgZXRjLiAtIHRoYXQncyB3aGF0IHRvdGFsVGltZSgpIGlzIGZvci5cbiAgdmFyIHBhcmVudCA9IGFuaW1hdGlvbi5fZHA7XG5cbiAgaWYgKHBhcmVudCAmJiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgJiYgYW5pbWF0aW9uLl90cykge1xuICAgIGFuaW1hdGlvbi5fc3RhcnQgPSBfcm91bmRQcmVjaXNlKHBhcmVudC5fdGltZSAtIChhbmltYXRpb24uX3RzID4gMCA/IHRvdGFsVGltZSAvIGFuaW1hdGlvbi5fdHMgOiAoKGFuaW1hdGlvbi5fZGlydHkgPyBhbmltYXRpb24udG90YWxEdXJhdGlvbigpIDogYW5pbWF0aW9uLl90RHVyKSAtIHRvdGFsVGltZSkgLyAtYW5pbWF0aW9uLl90cykpO1xuXG4gICAgX3NldEVuZChhbmltYXRpb24pO1xuXG4gICAgcGFyZW50Ll9kaXJ0eSB8fCBfdW5jYWNoZShwYXJlbnQsIGFuaW1hdGlvbik7IC8vZm9yIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50LiBJZiB0aGUgcGFyZW50J3MgY2FjaGUgaXMgYWxyZWFkeSBkaXJ0eSwgaXQgYWxyZWFkeSB0b29rIGNhcmUgb2YgbWFya2luZyB0aGUgYW5jZXN0b3JzIGFzIGRpcnR5IHRvbywgc28gc2tpcCB0aGUgZnVuY3Rpb24gY2FsbCBoZXJlLlxuICB9XG5cbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG5cbi8qXG5fdG90YWxUaW1lVG9UaW1lID0gKGNsYW1wZWRUb3RhbFRpbWUsIGR1cmF0aW9uLCByZXBlYXQsIHJlcGVhdERlbGF5LCB5b3lvKSA9PiB7XG5cdGxldCBjeWNsZUR1cmF0aW9uID0gZHVyYXRpb24gKyByZXBlYXREZWxheSxcblx0XHR0aW1lID0gX3JvdW5kKGNsYW1wZWRUb3RhbFRpbWUgJSBjeWNsZUR1cmF0aW9uKTtcblx0aWYgKHRpbWUgPiBkdXJhdGlvbikge1xuXHRcdHRpbWUgPSBkdXJhdGlvbjtcblx0fVxuXHRyZXR1cm4gKHlveW8gJiYgKH5+KGNsYW1wZWRUb3RhbFRpbWUgLyBjeWNsZUR1cmF0aW9uKSAmIDEpKSA/IGR1cmF0aW9uIC0gdGltZSA6IHRpbWU7XG59LFxuKi9cbl9wb3N0QWRkQ2hlY2tzID0gZnVuY3Rpb24gX3Bvc3RBZGRDaGVja3ModGltZWxpbmUsIGNoaWxkKSB7XG4gIHZhciB0O1xuXG4gIGlmIChjaGlsZC5fdGltZSB8fCAhY2hpbGQuX2R1ciAmJiBjaGlsZC5faW5pdHRlZCB8fCBjaGlsZC5fc3RhcnQgPCB0aW1lbGluZS5fdGltZSAmJiAoY2hpbGQuX2R1ciB8fCAhY2hpbGQuYWRkKSkge1xuICAgIC8vIGluIGNhc2UsIGZvciBleGFtcGxlLCB0aGUgX3N0YXJ0IGlzIG1vdmVkIG9uIGEgdHdlZW4gdGhhdCBoYXMgYWxyZWFkeSByZW5kZXJlZCwgb3IgaWYgaXQncyBiZWluZyBpbnNlcnRlZCBpbnRvIGEgdGltZWxpbmUgQkVGT1JFIHdoZXJlIHRoZSBwbGF5aGVhZCBpcyBjdXJyZW50bHkuIEltYWdpbmUgaXQncyBhdCBpdHMgZW5kIHN0YXRlLCB0aGVuIHRoZSBzdGFydFRpbWUgaXMgbW92ZWQgV0FZIGxhdGVyIChhZnRlciB0aGUgZW5kIG9mIHRoaXMgdGltZWxpbmUpLCBpdCBzaG91bGQgcmVuZGVyIGF0IGl0cyBiZWdpbm5pbmcuIFNwZWNpYWwgY2FzZTogaWYgaXQncyBhIHRpbWVsaW5lIChoYXMgLmFkZCgpIG1ldGhvZCkgYW5kIG5vIGR1cmF0aW9uLCB3ZSBjYW4gc2tpcCByZW5kZXJpbmcgYmVjYXVzZSB0aGUgdXNlciBtYXkgYmUgcG9wdWxhdGluZyBpdCBBRlRFUiBhZGRpbmcgaXQgdG8gYSBwYXJlbnQgdGltZWxpbmUgKHVuY29udmVudGlvbmFsLCBidXQgcG9zc2libGUsIGFuZCB3ZSB3b3VsZG4ndCB3YW50IGl0IHRvIGdldCByZW1vdmVkIGlmIHRoZSBwYXJlbnQncyBhdXRvUmVtb3ZlQ2hpbGRyZW4gaXMgdHJ1ZSkuXG4gICAgdCA9IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRpbWVsaW5lLnJhd1RpbWUoKSwgY2hpbGQpO1xuXG4gICAgaWYgKCFjaGlsZC5fZHVyIHx8IF9jbGFtcCgwLCBjaGlsZC50b3RhbER1cmF0aW9uKCksIHQpIC0gY2hpbGQuX3RUaW1lID4gX3RpbnlOdW0pIHtcbiAgICAgIGNoaWxkLnJlbmRlcih0LCB0cnVlKTtcbiAgICB9XG4gIH0gLy9pZiB0aGUgdGltZWxpbmUgaGFzIGFscmVhZHkgZW5kZWQgYnV0IHRoZSBpbnNlcnRlZCB0d2Vlbi90aW1lbGluZSBleHRlbmRzIHRoZSBkdXJhdGlvbiwgd2Ugc2hvdWxkIGVuYWJsZSB0aGlzIHRpbWVsaW5lIGFnYWluIHNvIHRoYXQgaXQgcmVuZGVycyBwcm9wZXJseS4gV2Ugc2hvdWxkIGFsc28gYWxpZ24gdGhlIHBsYXloZWFkIHdpdGggdGhlIHBhcmVudCB0aW1lbGluZSdzIHdoZW4gYXBwcm9wcmlhdGUuXG5cblxuICBpZiAoX3VuY2FjaGUodGltZWxpbmUsIGNoaWxkKS5fZHAgJiYgdGltZWxpbmUuX2luaXR0ZWQgJiYgdGltZWxpbmUuX3RpbWUgPj0gdGltZWxpbmUuX2R1ciAmJiB0aW1lbGluZS5fdHMpIHtcbiAgICAvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvcnMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLi4uXG4gICAgaWYgKHRpbWVsaW5lLl9kdXIgPCB0aW1lbGluZS5kdXJhdGlvbigpKSB7XG4gICAgICB0ID0gdGltZWxpbmU7XG5cbiAgICAgIHdoaWxlICh0Ll9kcCkge1xuICAgICAgICB0LnJhd1RpbWUoKSA+PSAwICYmIHQudG90YWxUaW1lKHQuX3RUaW1lKTsgLy9tb3ZlcyB0aGUgdGltZWxpbmUgKHNoaWZ0cyBpdHMgc3RhcnRUaW1lKSBpZiBuZWNlc3NhcnksIGFuZCBhbHNvIGVuYWJsZXMgaXQuIElmIGl0J3MgY3VycmVudGx5IHplcm8sIHRob3VnaCwgaXQgbWF5IG5vdCBiZSBzY2hlZHVsZWQgdG8gcmVuZGVyIHVudGlsIGxhdGVyIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSBpdCB0byBhbGlnbiB3aXRoIHRoZSBjdXJyZW50IHBsYXloZWFkIHBvc2l0aW9uLiBPbmx5IG1vdmUgdG8gY2F0Y2ggdXAgd2l0aCB0aGUgcGxheWhlYWQuXG5cbiAgICAgICAgdCA9IHQuX2RwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRpbWVsaW5lLl96VGltZSA9IC1fdGlueU51bTsgLy8gaGVscHMgZW5zdXJlIHRoYXQgdGhlIG5leHQgcmVuZGVyKCkgd2lsbCBiZSBmb3JjZWQgKGNyb3NzaW5nU3RhcnQgPSB0cnVlIGluIHJlbmRlcigpKSwgZXZlbiBpZiB0aGUgZHVyYXRpb24gaGFzbid0IGNoYW5nZWQgKHdlJ3JlIGFkZGluZyBhIGNoaWxkIHdoaWNoIHdvdWxkIG5lZWQgdG8gZ2V0IHJlbmRlcmVkKS4gRGVmaW5pdGVseSBhbiBlZGdlIGNhc2UuIE5vdGU6IHdlIE1VU1QgZG8gdGhpcyBBRlRFUiB0aGUgbG9vcCBhYm92ZSB3aGVyZSB0aGUgdG90YWxUaW1lKCkgbWlnaHQgdHJpZ2dlciBhIHJlbmRlcigpIGJlY2F1c2UgdGhpcyBfYWRkVG9UaW1lbGluZSgpIG1ldGhvZCBnZXRzIGNhbGxlZCBmcm9tIHRoZSBBbmltYXRpb24gY29uc3RydWN0b3IsIEJFRk9SRSB0d2VlbnMgZXZlbiByZWNvcmQgdGhlaXIgdGFyZ2V0cywgZXRjLiBzbyB3ZSB3b3VsZG4ndCB3YW50IHRoaW5ncyB0byBnZXQgdHJpZ2dlcmVkIGluIHRoZSB3cm9uZyBvcmRlci5cbiAgfVxufSxcbiAgICBfYWRkVG9UaW1lbGluZSA9IGZ1bmN0aW9uIF9hZGRUb1RpbWVsaW5lKHRpbWVsaW5lLCBjaGlsZCwgcG9zaXRpb24sIHNraXBDaGVja3MpIHtcbiAgY2hpbGQucGFyZW50ICYmIF9yZW1vdmVGcm9tUGFyZW50KGNoaWxkKTtcbiAgY2hpbGQuX3N0YXJ0ID0gX3JvdW5kUHJlY2lzZSgoX2lzTnVtYmVyKHBvc2l0aW9uKSA/IHBvc2l0aW9uIDogcG9zaXRpb24gfHwgdGltZWxpbmUgIT09IF9nbG9iYWxUaW1lbGluZSA/IF9wYXJzZVBvc2l0aW9uKHRpbWVsaW5lLCBwb3NpdGlvbiwgY2hpbGQpIDogdGltZWxpbmUuX3RpbWUpICsgY2hpbGQuX2RlbGF5KTtcbiAgY2hpbGQuX2VuZCA9IF9yb3VuZFByZWNpc2UoY2hpbGQuX3N0YXJ0ICsgKGNoaWxkLnRvdGFsRHVyYXRpb24oKSAvIE1hdGguYWJzKGNoaWxkLnRpbWVTY2FsZSgpKSB8fCAwKSk7XG5cbiAgX2FkZExpbmtlZExpc3RJdGVtKHRpbWVsaW5lLCBjaGlsZCwgXCJfZmlyc3RcIiwgXCJfbGFzdFwiLCB0aW1lbGluZS5fc29ydCA/IFwiX3N0YXJ0XCIgOiAwKTtcblxuICBfaXNGcm9tT3JGcm9tU3RhcnQoY2hpbGQpIHx8ICh0aW1lbGluZS5fcmVjZW50ID0gY2hpbGQpO1xuICBza2lwQ2hlY2tzIHx8IF9wb3N0QWRkQ2hlY2tzKHRpbWVsaW5lLCBjaGlsZCk7XG4gIHRpbWVsaW5lLl90cyA8IDAgJiYgX2FsaWduUGxheWhlYWQodGltZWxpbmUsIHRpbWVsaW5lLl90VGltZSk7IC8vIGlmIHRoZSB0aW1lbGluZSBpcyByZXZlcnNlZCBhbmQgdGhlIG5ldyBjaGlsZCBtYWtlcyBpdCBsb25nZXIsIHdlIG1heSBuZWVkIHRvIGFkanVzdCB0aGUgcGFyZW50J3MgX3N0YXJ0IChwdXNoIGl0IGJhY2spXG5cbiAgcmV0dXJuIHRpbWVsaW5lO1xufSxcbiAgICBfc2Nyb2xsVHJpZ2dlciA9IGZ1bmN0aW9uIF9zY3JvbGxUcmlnZ2VyKGFuaW1hdGlvbiwgdHJpZ2dlcikge1xuICByZXR1cm4gKF9nbG9iYWxzLlNjcm9sbFRyaWdnZXIgfHwgX21pc3NpbmdQbHVnaW4oXCJzY3JvbGxUcmlnZ2VyXCIsIHRyaWdnZXIpKSAmJiBfZ2xvYmFscy5TY3JvbGxUcmlnZ2VyLmNyZWF0ZSh0cmlnZ2VyLCBhbmltYXRpb24pO1xufSxcbiAgICBfYXR0ZW1wdEluaXRUd2VlbiA9IGZ1bmN0aW9uIF9hdHRlbXB0SW5pdFR3ZWVuKHR3ZWVuLCB0aW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMsIHRUaW1lKSB7XG4gIF9pbml0VHdlZW4odHdlZW4sIHRpbWUsIHRUaW1lKTtcblxuICBpZiAoIXR3ZWVuLl9pbml0dGVkKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBpZiAoIWZvcmNlICYmIHR3ZWVuLl9wdCAmJiAhX3JldmVydGluZyAmJiAodHdlZW4uX2R1ciAmJiB0d2Vlbi52YXJzLmxhenkgIT09IGZhbHNlIHx8ICF0d2Vlbi5fZHVyICYmIHR3ZWVuLnZhcnMubGF6eSkgJiYgX2xhc3RSZW5kZXJlZEZyYW1lICE9PSBfdGlja2VyLmZyYW1lKSB7XG4gICAgX2xhenlUd2VlbnMucHVzaCh0d2Vlbik7XG5cbiAgICB0d2Vlbi5fbGF6eSA9IFt0VGltZSwgc3VwcHJlc3NFdmVudHNdO1xuICAgIHJldHVybiAxO1xuICB9XG59LFxuICAgIF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQgPSBmdW5jdGlvbiBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KF9yZWYpIHtcbiAgdmFyIHBhcmVudCA9IF9yZWYucGFyZW50O1xuICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC5fdHMgJiYgcGFyZW50Ll9pbml0dGVkICYmICFwYXJlbnQuX2xvY2sgJiYgKHBhcmVudC5yYXdUaW1lKCkgPCAwIHx8IF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQocGFyZW50KSk7XG59LFxuICAgIC8vIGNoZWNrIHBhcmVudCdzIF9sb2NrIGJlY2F1c2Ugd2hlbiBhIHRpbWVsaW5lIHJlcGVhdHMveW95b3MgYW5kIGRvZXMgaXRzIGFydGlmaWNpYWwgd3JhcHBpbmcsIHdlIHNob3VsZG4ndCBmb3JjZSB0aGUgcmF0aW8gYmFjayB0byAwXG5faXNGcm9tT3JGcm9tU3RhcnQgPSBmdW5jdGlvbiBfaXNGcm9tT3JGcm9tU3RhcnQoX3JlZjIpIHtcbiAgdmFyIGRhdGEgPSBfcmVmMi5kYXRhO1xuICByZXR1cm4gZGF0YSA9PT0gXCJpc0Zyb21TdGFydFwiIHx8IGRhdGEgPT09IFwiaXNTdGFydFwiO1xufSxcbiAgICBfcmVuZGVyWmVyb0R1cmF0aW9uVHdlZW4gPSBmdW5jdGlvbiBfcmVuZGVyWmVyb0R1cmF0aW9uVHdlZW4odHdlZW4sIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG4gIHZhciBwcmV2UmF0aW8gPSB0d2Vlbi5yYXRpbyxcbiAgICAgIHJhdGlvID0gdG90YWxUaW1lIDwgMCB8fCAhdG90YWxUaW1lICYmICghdHdlZW4uX3N0YXJ0ICYmIF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQodHdlZW4pICYmICEoIXR3ZWVuLl9pbml0dGVkICYmIF9pc0Zyb21PckZyb21TdGFydCh0d2VlbikpIHx8ICh0d2Vlbi5fdHMgPCAwIHx8IHR3ZWVuLl9kcC5fdHMgPCAwKSAmJiAhX2lzRnJvbU9yRnJvbVN0YXJ0KHR3ZWVuKSkgPyAwIDogMSxcbiAgICAgIC8vIGlmIHRoZSB0d2VlbiBvciBpdHMgcGFyZW50IGlzIHJldmVyc2VkIGFuZCB0aGUgdG90YWxUaW1lIGlzIDAsIHdlIHNob3VsZCBnbyB0byBhIHJhdGlvIG9mIDAuIEVkZ2UgY2FzZTogaWYgYSBmcm9tKCkgb3IgZnJvbVRvKCkgc3RhZ2dlciB0d2VlbiBpcyBwbGFjZWQgbGF0ZXIgaW4gYSB0aW1lbGluZSwgdGhlIFwic3RhcnRBdFwiIHplcm8tZHVyYXRpb24gdHdlZW4gY291bGQgaW5pdGlhbGx5IHJlbmRlciBhdCBhIHRpbWUgd2hlbiB0aGUgcGFyZW50IHRpbWVsaW5lJ3MgcGxheWhlYWQgaXMgdGVjaG5pY2FsbHkgQkVGT1JFIHdoZXJlIHRoaXMgdHdlZW4gaXMsIHNvIG1ha2Ugc3VyZSB0aGF0IGFueSBcImZyb21cIiBhbmQgXCJmcm9tVG9cIiBzdGFydEF0IHR3ZWVucyBhcmUgcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUgYXQgYSByYXRpbyBvZiAxLlxuICByZXBlYXREZWxheSA9IHR3ZWVuLl9yRGVsYXksXG4gICAgICB0VGltZSA9IDAsXG4gICAgICBwdCxcbiAgICAgIGl0ZXJhdGlvbixcbiAgICAgIHByZXZJdGVyYXRpb247XG5cbiAgaWYgKHJlcGVhdERlbGF5ICYmIHR3ZWVuLl9yZXBlYXQpIHtcbiAgICAvLyBpbiBjYXNlIHRoZXJlJ3MgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIHRoYXQgaGFzIGEgcmVwZWF0IHdpdGggYSByZXBlYXREZWxheVxuICAgIHRUaW1lID0gX2NsYW1wKDAsIHR3ZWVuLl90RHVyLCB0b3RhbFRpbWUpO1xuICAgIGl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0VGltZSwgcmVwZWF0RGVsYXkpO1xuICAgIHR3ZWVuLl95b3lvICYmIGl0ZXJhdGlvbiAmIDEgJiYgKHJhdGlvID0gMSAtIHJhdGlvKTtcblxuICAgIGlmIChpdGVyYXRpb24gIT09IF9hbmltYXRpb25DeWNsZSh0d2Vlbi5fdFRpbWUsIHJlcGVhdERlbGF5KSkge1xuICAgICAgLy8gaWYgaXRlcmF0aW9uIGNoYW5nZWRcbiAgICAgIHByZXZSYXRpbyA9IDEgLSByYXRpbztcbiAgICAgIHR3ZWVuLnZhcnMucmVwZWF0UmVmcmVzaCAmJiB0d2Vlbi5faW5pdHRlZCAmJiB0d2Vlbi5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJhdGlvICE9PSBwcmV2UmF0aW8gfHwgX3JldmVydGluZyB8fCBmb3JjZSB8fCB0d2Vlbi5felRpbWUgPT09IF90aW55TnVtIHx8ICF0b3RhbFRpbWUgJiYgdHdlZW4uX3pUaW1lKSB7XG4gICAgaWYgKCF0d2Vlbi5faW5pdHRlZCAmJiBfYXR0ZW1wdEluaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMsIHRUaW1lKSkge1xuICAgICAgLy8gaWYgd2UgcmVuZGVyIHRoZSB2ZXJ5IGJlZ2lubmluZyAodGltZSA9PSAwKSBvZiBhIGZyb21UbygpLCB3ZSBtdXN0IGZvcmNlIHRoZSByZW5kZXIgKG5vcm1hbCB0d2VlbnMgd291bGRuJ3QgbmVlZCB0byByZW5kZXIgYXQgYSB0aW1lIG9mIDAgd2hlbiB0aGUgcHJldlRpbWUgd2FzIGFsc28gMCkuIFRoaXMgaXMgYWxzbyBtYW5kYXRvcnkgdG8gbWFrZSBzdXJlIG92ZXJ3cml0aW5nIGtpY2tzIGluIGltbWVkaWF0ZWx5LlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByZXZJdGVyYXRpb24gPSB0d2Vlbi5felRpbWU7XG4gICAgdHdlZW4uX3pUaW1lID0gdG90YWxUaW1lIHx8IChzdXBwcmVzc0V2ZW50cyA/IF90aW55TnVtIDogMCk7IC8vIHdoZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LlxuXG4gICAgc3VwcHJlc3NFdmVudHMgfHwgKHN1cHByZXNzRXZlbnRzID0gdG90YWxUaW1lICYmICFwcmV2SXRlcmF0aW9uKTsgLy8gaWYgaXQgd2FzIHJlbmRlcmVkIHByZXZpb3VzbHkgYXQgZXhhY3RseSAwIChfelRpbWUpIGFuZCBub3cgdGhlIHBsYXloZWFkIGlzIG1vdmluZyBhd2F5LCBET04nVCBmaXJlIGNhbGxiYWNrcyBvdGhlcndpc2UgdGhleSdsbCBzZWVtIGxpa2UgZHVwbGljYXRlcy5cblxuICAgIHR3ZWVuLnJhdGlvID0gcmF0aW87XG4gICAgdHdlZW4uX2Zyb20gJiYgKHJhdGlvID0gMSAtIHJhdGlvKTtcbiAgICB0d2Vlbi5fdGltZSA9IDA7XG4gICAgdHdlZW4uX3RUaW1lID0gdFRpbWU7XG4gICAgcHQgPSB0d2Vlbi5fcHQ7XG5cbiAgICB3aGlsZSAocHQpIHtcbiAgICAgIHB0LnIocmF0aW8sIHB0LmQpO1xuICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICB9XG5cbiAgICB0b3RhbFRpbWUgPCAwICYmIF9yZXdpbmRTdGFydEF0KHR3ZWVuLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCB0cnVlKTtcbiAgICB0d2Vlbi5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzICYmIF9jYWxsYmFjayh0d2VlbiwgXCJvblVwZGF0ZVwiKTtcbiAgICB0VGltZSAmJiB0d2Vlbi5fcmVwZWF0ICYmICFzdXBwcmVzc0V2ZW50cyAmJiB0d2Vlbi5wYXJlbnQgJiYgX2NhbGxiYWNrKHR3ZWVuLCBcIm9uUmVwZWF0XCIpO1xuXG4gICAgaWYgKCh0b3RhbFRpbWUgPj0gdHdlZW4uX3REdXIgfHwgdG90YWxUaW1lIDwgMCkgJiYgdHdlZW4ucmF0aW8gPT09IHJhdGlvKSB7XG4gICAgICByYXRpbyAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0d2VlbiwgMSk7XG5cbiAgICAgIGlmICghc3VwcHJlc3NFdmVudHMgJiYgIV9yZXZlcnRpbmcpIHtcbiAgICAgICAgX2NhbGxiYWNrKHR3ZWVuLCByYXRpbyA/IFwib25Db21wbGV0ZVwiIDogXCJvblJldmVyc2VDb21wbGV0ZVwiLCB0cnVlKTtcblxuICAgICAgICB0d2Vlbi5fcHJvbSAmJiB0d2Vlbi5fcHJvbSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICghdHdlZW4uX3pUaW1lKSB7XG4gICAgdHdlZW4uX3pUaW1lID0gdG90YWxUaW1lO1xuICB9XG59LFxuICAgIF9maW5kTmV4dFBhdXNlVHdlZW4gPSBmdW5jdGlvbiBfZmluZE5leHRQYXVzZVR3ZWVuKGFuaW1hdGlvbiwgcHJldlRpbWUsIHRpbWUpIHtcbiAgdmFyIGNoaWxkO1xuXG4gIGlmICh0aW1lID4gcHJldlRpbWUpIHtcbiAgICBjaGlsZCA9IGFuaW1hdGlvbi5fZmlyc3Q7XG5cbiAgICB3aGlsZSAoY2hpbGQgJiYgY2hpbGQuX3N0YXJ0IDw9IHRpbWUpIHtcbiAgICAgIGlmIChjaGlsZC5kYXRhID09PSBcImlzUGF1c2VcIiAmJiBjaGlsZC5fc3RhcnQgPiBwcmV2VGltZSkge1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNoaWxkID0gYW5pbWF0aW9uLl9sYXN0O1xuXG4gICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLl9zdGFydCA+PSB0aW1lKSB7XG4gICAgICBpZiAoY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgY2hpbGQuX3N0YXJ0IDwgcHJldlRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9wcmV2O1xuICAgIH1cbiAgfVxufSxcbiAgICBfc2V0RHVyYXRpb24gPSBmdW5jdGlvbiBfc2V0RHVyYXRpb24oYW5pbWF0aW9uLCBkdXJhdGlvbiwgc2tpcFVuY2FjaGUsIGxlYXZlUGxheWhlYWQpIHtcbiAgdmFyIHJlcGVhdCA9IGFuaW1hdGlvbi5fcmVwZWF0LFxuICAgICAgZHVyID0gX3JvdW5kUHJlY2lzZShkdXJhdGlvbikgfHwgMCxcbiAgICAgIHRvdGFsUHJvZ3Jlc3MgPSBhbmltYXRpb24uX3RUaW1lIC8gYW5pbWF0aW9uLl90RHVyO1xuICB0b3RhbFByb2dyZXNzICYmICFsZWF2ZVBsYXloZWFkICYmIChhbmltYXRpb24uX3RpbWUgKj0gZHVyIC8gYW5pbWF0aW9uLl9kdXIpO1xuICBhbmltYXRpb24uX2R1ciA9IGR1cjtcbiAgYW5pbWF0aW9uLl90RHVyID0gIXJlcGVhdCA/IGR1ciA6IHJlcGVhdCA8IDAgPyAxZTEwIDogX3JvdW5kUHJlY2lzZShkdXIgKiAocmVwZWF0ICsgMSkgKyBhbmltYXRpb24uX3JEZWxheSAqIHJlcGVhdCk7XG4gIHRvdGFsUHJvZ3Jlc3MgPiAwICYmICFsZWF2ZVBsYXloZWFkICYmIF9hbGlnblBsYXloZWFkKGFuaW1hdGlvbiwgYW5pbWF0aW9uLl90VGltZSA9IGFuaW1hdGlvbi5fdER1ciAqIHRvdGFsUHJvZ3Jlc3MpO1xuICBhbmltYXRpb24ucGFyZW50ICYmIF9zZXRFbmQoYW5pbWF0aW9uKTtcbiAgc2tpcFVuY2FjaGUgfHwgX3VuY2FjaGUoYW5pbWF0aW9uLnBhcmVudCwgYW5pbWF0aW9uKTtcbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG4gICAgX29uVXBkYXRlVG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24oYW5pbWF0aW9uKSB7XG4gIHJldHVybiBhbmltYXRpb24gaW5zdGFuY2VvZiBUaW1lbGluZSA/IF91bmNhY2hlKGFuaW1hdGlvbikgOiBfc2V0RHVyYXRpb24oYW5pbWF0aW9uLCBhbmltYXRpb24uX2R1cik7XG59LFxuICAgIF96ZXJvUG9zaXRpb24gPSB7XG4gIF9zdGFydDogMCxcbiAgZW5kVGltZTogX2VtcHR5RnVuYyxcbiAgdG90YWxEdXJhdGlvbjogX2VtcHR5RnVuY1xufSxcbiAgICBfcGFyc2VQb3NpdGlvbiA9IGZ1bmN0aW9uIF9wYXJzZVBvc2l0aW9uKGFuaW1hdGlvbiwgcG9zaXRpb24sIHBlcmNlbnRBbmltYXRpb24pIHtcbiAgdmFyIGxhYmVscyA9IGFuaW1hdGlvbi5sYWJlbHMsXG4gICAgICByZWNlbnQgPSBhbmltYXRpb24uX3JlY2VudCB8fCBfemVyb1Bvc2l0aW9uLFxuICAgICAgY2xpcHBlZER1cmF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uKCkgPj0gX2JpZ051bSA/IHJlY2VudC5lbmRUaW1lKGZhbHNlKSA6IGFuaW1hdGlvbi5fZHVyLFxuICAgICAgLy9pbiBjYXNlIHRoZXJlJ3MgYSBjaGlsZCB0aGF0IGluZmluaXRlbHkgcmVwZWF0cywgdXNlcnMgYWxtb3N0IG5ldmVyIGludGVuZCBmb3IgdGhlIGluc2VydGlvbiBwb2ludCBvZiBhIG5ldyBjaGlsZCB0byBiZSBiYXNlZCBvbiBhIFNVUEVSIGxvbmcgdmFsdWUgbGlrZSB0aGF0IHNvIHdlIGNsaXAgaXQgYW5kIGFzc3VtZSB0aGUgbW9zdCByZWNlbnRseS1hZGRlZCBjaGlsZCdzIGVuZFRpbWUgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgaSxcbiAgICAgIG9mZnNldCxcbiAgICAgIGlzUGVyY2VudDtcblxuICBpZiAoX2lzU3RyaW5nKHBvc2l0aW9uKSAmJiAoaXNOYU4ocG9zaXRpb24pIHx8IHBvc2l0aW9uIGluIGxhYmVscykpIHtcbiAgICAvL2lmIHRoZSBzdHJpbmcgaXMgYSBudW1iZXIgbGlrZSBcIjFcIiwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlJ3MgYSBsYWJlbCB3aXRoIHRoYXQgbmFtZSwgb3RoZXJ3aXNlIGludGVycHJldCBpdCBhcyBhIG51bWJlciAoYWJzb2x1dGUgdmFsdWUpLlxuICAgIG9mZnNldCA9IHBvc2l0aW9uLmNoYXJBdCgwKTtcbiAgICBpc1BlcmNlbnQgPSBwb3NpdGlvbi5zdWJzdHIoLTEpID09PSBcIiVcIjtcbiAgICBpID0gcG9zaXRpb24uaW5kZXhPZihcIj1cIik7XG5cbiAgICBpZiAob2Zmc2V0ID09PSBcIjxcIiB8fCBvZmZzZXQgPT09IFwiPlwiKSB7XG4gICAgICBpID49IDAgJiYgKHBvc2l0aW9uID0gcG9zaXRpb24ucmVwbGFjZSgvPS8sIFwiXCIpKTtcbiAgICAgIHJldHVybiAob2Zmc2V0ID09PSBcIjxcIiA/IHJlY2VudC5fc3RhcnQgOiByZWNlbnQuZW5kVGltZShyZWNlbnQuX3JlcGVhdCA+PSAwKSkgKyAocGFyc2VGbG9hdChwb3NpdGlvbi5zdWJzdHIoMSkpIHx8IDApICogKGlzUGVyY2VudCA/IChpIDwgMCA/IHJlY2VudCA6IHBlcmNlbnRBbmltYXRpb24pLnRvdGFsRHVyYXRpb24oKSAvIDEwMCA6IDEpO1xuICAgIH1cblxuICAgIGlmIChpIDwgMCkge1xuICAgICAgcG9zaXRpb24gaW4gbGFiZWxzIHx8IChsYWJlbHNbcG9zaXRpb25dID0gY2xpcHBlZER1cmF0aW9uKTtcbiAgICAgIHJldHVybiBsYWJlbHNbcG9zaXRpb25dO1xuICAgIH1cblxuICAgIG9mZnNldCA9IHBhcnNlRmxvYXQocG9zaXRpb24uY2hhckF0KGkgLSAxKSArIHBvc2l0aW9uLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGlzUGVyY2VudCAmJiBwZXJjZW50QW5pbWF0aW9uKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgLyAxMDAgKiAoX2lzQXJyYXkocGVyY2VudEFuaW1hdGlvbikgPyBwZXJjZW50QW5pbWF0aW9uWzBdIDogcGVyY2VudEFuaW1hdGlvbikudG90YWxEdXJhdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiBpID4gMSA/IF9wYXJzZVBvc2l0aW9uKGFuaW1hdGlvbiwgcG9zaXRpb24uc3Vic3RyKDAsIGkgLSAxKSwgcGVyY2VudEFuaW1hdGlvbikgKyBvZmZzZXQgOiBjbGlwcGVkRHVyYXRpb24gKyBvZmZzZXQ7XG4gIH1cblxuICByZXR1cm4gcG9zaXRpb24gPT0gbnVsbCA/IGNsaXBwZWREdXJhdGlvbiA6ICtwb3NpdGlvbjtcbn0sXG4gICAgX2NyZWF0ZVR3ZWVuVHlwZSA9IGZ1bmN0aW9uIF9jcmVhdGVUd2VlblR5cGUodHlwZSwgcGFyYW1zLCB0aW1lbGluZSkge1xuICB2YXIgaXNMZWdhY3kgPSBfaXNOdW1iZXIocGFyYW1zWzFdKSxcbiAgICAgIHZhcnNJbmRleCA9IChpc0xlZ2FjeSA/IDIgOiAxKSArICh0eXBlIDwgMiA/IDAgOiAxKSxcbiAgICAgIHZhcnMgPSBwYXJhbXNbdmFyc0luZGV4XSxcbiAgICAgIGlyVmFycyxcbiAgICAgIHBhcmVudDtcblxuICBpc0xlZ2FjeSAmJiAodmFycy5kdXJhdGlvbiA9IHBhcmFtc1sxXSk7XG4gIHZhcnMucGFyZW50ID0gdGltZWxpbmU7XG5cbiAgaWYgKHR5cGUpIHtcbiAgICBpclZhcnMgPSB2YXJzO1xuICAgIHBhcmVudCA9IHRpbWVsaW5lO1xuXG4gICAgd2hpbGUgKHBhcmVudCAmJiAhKFwiaW1tZWRpYXRlUmVuZGVyXCIgaW4gaXJWYXJzKSkge1xuICAgICAgLy8gaW5oZXJpdGFuY2UgaGFzbid0IGhhcHBlbmVkIHlldCwgYnV0IHNvbWVvbmUgbWF5IGhhdmUgc2V0IGEgZGVmYXVsdCBpbiBhbiBhbmNlc3RvciB0aW1lbGluZS4gV2UgY291bGQgZG8gdmFycy5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZShfaW5oZXJpdERlZmF1bHRzKHZhcnMpLmltbWVkaWF0ZVJlbmRlcikgYnV0IHRoYXQnZCBleGFjdCBhIHNsaWdodCBwZXJmb3JtYW5jZSBwZW5hbHR5IGJlY2F1c2UgX2luaGVyaXREZWZhdWx0cygpIGFsc28gcnVucyBpbiB0aGUgVHdlZW4gY29uc3RydWN0b3IuIFdlJ3JlIHBheWluZyBhIHNtYWxsIGtiIHByaWNlIGhlcmUgdG8gZ2FpbiBzcGVlZC5cbiAgICAgIGlyVmFycyA9IHBhcmVudC52YXJzLmRlZmF1bHRzIHx8IHt9O1xuICAgICAgcGFyZW50ID0gX2lzTm90RmFsc2UocGFyZW50LnZhcnMuaW5oZXJpdCkgJiYgcGFyZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICB2YXJzLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKGlyVmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuICAgIHR5cGUgPCAyID8gdmFycy5ydW5CYWNrd2FyZHMgPSAxIDogdmFycy5zdGFydEF0ID0gcGFyYW1zW3ZhcnNJbmRleCAtIDFdOyAvLyBcImZyb21cIiB2YXJzXG4gIH1cblxuICByZXR1cm4gbmV3IFR3ZWVuKHBhcmFtc1swXSwgdmFycywgcGFyYW1zW3ZhcnNJbmRleCArIDFdKTtcbn0sXG4gICAgX2NvbmRpdGlvbmFsUmV0dXJuID0gZnVuY3Rpb24gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jKSB7XG4gIHJldHVybiB2YWx1ZSB8fCB2YWx1ZSA9PT0gMCA/IGZ1bmModmFsdWUpIDogZnVuYztcbn0sXG4gICAgX2NsYW1wID0gZnVuY3Rpb24gX2NsYW1wKG1pbiwgbWF4LCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPCBtaW4gPyBtaW4gOiB2YWx1ZSA+IG1heCA/IG1heCA6IHZhbHVlO1xufSxcbiAgICBnZXRVbml0ID0gZnVuY3Rpb24gZ2V0VW5pdCh2YWx1ZSwgdikge1xuICByZXR1cm4gIV9pc1N0cmluZyh2YWx1ZSkgfHwgISh2ID0gX3VuaXRFeHAuZXhlYyh2YWx1ZSkpID8gXCJcIiA6IHZbMV07XG59LFxuICAgIC8vIG5vdGU6IHByb3RlY3QgYWdhaW5zdCBwYWRkZWQgbnVtYmVycyBhcyBzdHJpbmdzLCBsaWtlIFwiMTAwLjEwMFwiLiBUaGF0IHNob3VsZG4ndCByZXR1cm4gXCIwMFwiIGFzIHRoZSB1bml0LiBJZiBpdCdzIG51bWVyaWMsIHJldHVybiBubyB1bml0LlxuY2xhbXAgPSBmdW5jdGlvbiBjbGFtcChtaW4sIG1heCwgdmFsdWUpIHtcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gX2NsYW1wKG1pbiwgbWF4LCB2KTtcbiAgfSk7XG59LFxuICAgIF9zbGljZSA9IFtdLnNsaWNlLFxuICAgIF9pc0FycmF5TGlrZSA9IGZ1bmN0aW9uIF9pc0FycmF5TGlrZSh2YWx1ZSwgbm9uRW1wdHkpIHtcbiAgcmV0dXJuIHZhbHVlICYmIF9pc09iamVjdCh2YWx1ZSkgJiYgXCJsZW5ndGhcIiBpbiB2YWx1ZSAmJiAoIW5vbkVtcHR5ICYmICF2YWx1ZS5sZW5ndGggfHwgdmFsdWUubGVuZ3RoIC0gMSBpbiB2YWx1ZSAmJiBfaXNPYmplY3QodmFsdWVbMF0pKSAmJiAhdmFsdWUubm9kZVR5cGUgJiYgdmFsdWUgIT09IF93aW47XG59LFxuICAgIF9mbGF0dGVuID0gZnVuY3Rpb24gX2ZsYXR0ZW4oYXIsIGxlYXZlU3RyaW5ncywgYWNjdW11bGF0b3IpIHtcbiAgaWYgKGFjY3VtdWxhdG9yID09PSB2b2lkIDApIHtcbiAgICBhY2N1bXVsYXRvciA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGFyLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIF9hY2N1bXVsYXRvcjtcblxuICAgIHJldHVybiBfaXNTdHJpbmcodmFsdWUpICYmICFsZWF2ZVN0cmluZ3MgfHwgX2lzQXJyYXlMaWtlKHZhbHVlLCAxKSA/IChfYWNjdW11bGF0b3IgPSBhY2N1bXVsYXRvcikucHVzaC5hcHBseShfYWNjdW11bGF0b3IsIHRvQXJyYXkodmFsdWUpKSA6IGFjY3VtdWxhdG9yLnB1c2godmFsdWUpO1xuICB9KSB8fCBhY2N1bXVsYXRvcjtcbn0sXG4gICAgLy90YWtlcyBhbnkgdmFsdWUgYW5kIHJldHVybnMgYW4gYXJyYXkuIElmIGl0J3MgYSBzdHJpbmcgKGFuZCBsZWF2ZVN0cmluZ3MgaXNuJ3QgdHJ1ZSksIGl0J2xsIHVzZSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCkgYW5kIGNvbnZlcnQgdGhhdCB0byBhbiBhcnJheS4gSXQnbGwgYWxzbyBhY2NlcHQgaXRlcmFibGVzIGxpa2UgalF1ZXJ5IG9iamVjdHMuXG50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSwgc2NvcGUsIGxlYXZlU3RyaW5ncykge1xuICByZXR1cm4gX2NvbnRleHQgJiYgIXNjb3BlICYmIF9jb250ZXh0LnNlbGVjdG9yID8gX2NvbnRleHQuc2VsZWN0b3IodmFsdWUpIDogX2lzU3RyaW5nKHZhbHVlKSAmJiAhbGVhdmVTdHJpbmdzICYmIChfY29yZUluaXR0ZWQgfHwgIV93YWtlKCkpID8gX3NsaWNlLmNhbGwoKHNjb3BlIHx8IF9kb2MpLnF1ZXJ5U2VsZWN0b3JBbGwodmFsdWUpLCAwKSA6IF9pc0FycmF5KHZhbHVlKSA/IF9mbGF0dGVuKHZhbHVlLCBsZWF2ZVN0cmluZ3MpIDogX2lzQXJyYXlMaWtlKHZhbHVlKSA/IF9zbGljZS5jYWxsKHZhbHVlLCAwKSA6IHZhbHVlID8gW3ZhbHVlXSA6IFtdO1xufSxcbiAgICBzZWxlY3RvciA9IGZ1bmN0aW9uIHNlbGVjdG9yKHZhbHVlKSB7XG4gIHZhbHVlID0gdG9BcnJheSh2YWx1ZSlbMF0gfHwgX3dhcm4oXCJJbnZhbGlkIHNjb3BlXCIpIHx8IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgZWwgPSB2YWx1ZS5jdXJyZW50IHx8IHZhbHVlLm5hdGl2ZUVsZW1lbnQgfHwgdmFsdWU7XG4gICAgcmV0dXJuIHRvQXJyYXkodiwgZWwucXVlcnlTZWxlY3RvckFsbCA/IGVsIDogZWwgPT09IHZhbHVlID8gX3dhcm4oXCJJbnZhbGlkIHNjb3BlXCIpIHx8IF9kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSA6IHZhbHVlKTtcbiAgfTtcbn0sXG4gICAgc2h1ZmZsZSA9IGZ1bmN0aW9uIHNodWZmbGUoYSkge1xuICByZXR1cm4gYS5zb3J0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gLjUgLSBNYXRoLnJhbmRvbSgpO1xuICB9KTtcbn0sXG4gICAgLy8gYWx0ZXJuYXRpdmUgdGhhdCdzIGEgYml0IGZhc3RlciBhbmQgbW9yZSByZWxpYWJseSBkaXZlcnNlIGJ1dCBiaWdnZXI6ICAgZm9yIChsZXQgaiwgdiwgaSA9IGEubGVuZ3RoOyBpOyBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogaSksIHYgPSBhWy0taV0sIGFbaV0gPSBhW2pdLCBhW2pdID0gdik7IHJldHVybiBhO1xuLy9mb3IgZGlzdHJpYnV0aW5nIHZhbHVlcyBhY3Jvc3MgYW4gYXJyYXkuIENhbiBhY2NlcHQgYSBudW1iZXIsIGEgZnVuY3Rpb24gb3IgKG1vc3QgY29tbW9ubHkpIGEgZnVuY3Rpb24gd2hpY2ggY2FuIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOiB7YmFzZSwgYW1vdW50LCBmcm9tLCBlYXNlLCBncmlkLCBheGlzLCBsZW5ndGgsIGVhY2h9LiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBleHBlY3RzIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczogaW5kZXgsIHRhcmdldCwgYXJyYXkuIFJlY29nbml6ZXMgdGhlIGZvbGxvd2luZ1xuZGlzdHJpYnV0ZSA9IGZ1bmN0aW9uIGRpc3RyaWJ1dGUodikge1xuICBpZiAoX2lzRnVuY3Rpb24odikpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuXG4gIHZhciB2YXJzID0gX2lzT2JqZWN0KHYpID8gdiA6IHtcbiAgICBlYWNoOiB2XG4gIH0sXG4gICAgICAvL246MSBpcyBqdXN0IHRvIGluZGljYXRlIHYgd2FzIGEgbnVtYmVyOyB3ZSBsZXZlcmFnZSB0aGF0IGxhdGVyIHRvIHNldCB2IGFjY29yZGluZyB0byB0aGUgbGVuZ3RoIHdlIGdldC4gSWYgYSBudW1iZXIgaXMgcGFzc2VkIGluLCB3ZSB0cmVhdCBpdCBsaWtlIHRoZSBvbGQgc3RhZ2dlciB2YWx1ZSB3aGVyZSAwLjEsIGZvciBleGFtcGxlLCB3b3VsZCBtZWFuIHRoYXQgdGhpbmdzIHdvdWxkIGJlIGRpc3RyaWJ1dGVkIHdpdGggMC4xIGJldHdlZW4gZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSByYXRoZXIgdGhhbiBhIHRvdGFsIFwiYW1vdW50XCIgdGhhdCdzIGNodW5rZWQgb3V0IGFtb25nIHRoZW0gYWxsLlxuICBlYXNlID0gX3BhcnNlRWFzZSh2YXJzLmVhc2UpLFxuICAgICAgZnJvbSA9IHZhcnMuZnJvbSB8fCAwLFxuICAgICAgYmFzZSA9IHBhcnNlRmxvYXQodmFycy5iYXNlKSB8fCAwLFxuICAgICAgY2FjaGUgPSB7fSxcbiAgICAgIGlzRGVjaW1hbCA9IGZyb20gPiAwICYmIGZyb20gPCAxLFxuICAgICAgcmF0aW9zID0gaXNOYU4oZnJvbSkgfHwgaXNEZWNpbWFsLFxuICAgICAgYXhpcyA9IHZhcnMuYXhpcyxcbiAgICAgIHJhdGlvWCA9IGZyb20sXG4gICAgICByYXRpb1kgPSBmcm9tO1xuXG4gIGlmIChfaXNTdHJpbmcoZnJvbSkpIHtcbiAgICByYXRpb1ggPSByYXRpb1kgPSB7XG4gICAgICBjZW50ZXI6IC41LFxuICAgICAgZWRnZXM6IC41LFxuICAgICAgZW5kOiAxXG4gICAgfVtmcm9tXSB8fCAwO1xuICB9IGVsc2UgaWYgKCFpc0RlY2ltYWwgJiYgcmF0aW9zKSB7XG4gICAgcmF0aW9YID0gZnJvbVswXTtcbiAgICByYXRpb1kgPSBmcm9tWzFdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpLCB0YXJnZXQsIGEpIHtcbiAgICB2YXIgbCA9IChhIHx8IHZhcnMpLmxlbmd0aCxcbiAgICAgICAgZGlzdGFuY2VzID0gY2FjaGVbbF0sXG4gICAgICAgIG9yaWdpblgsXG4gICAgICAgIG9yaWdpblksXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGQsXG4gICAgICAgIGosXG4gICAgICAgIG1heCxcbiAgICAgICAgbWluLFxuICAgICAgICB3cmFwQXQ7XG5cbiAgICBpZiAoIWRpc3RhbmNlcykge1xuICAgICAgd3JhcEF0ID0gdmFycy5ncmlkID09PSBcImF1dG9cIiA/IDAgOiAodmFycy5ncmlkIHx8IFsxLCBfYmlnTnVtXSlbMV07XG5cbiAgICAgIGlmICghd3JhcEF0KSB7XG4gICAgICAgIG1heCA9IC1fYmlnTnVtO1xuXG4gICAgICAgIHdoaWxlIChtYXggPCAobWF4ID0gYVt3cmFwQXQrK10uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCkgJiYgd3JhcEF0IDwgbCkge31cblxuICAgICAgICB3cmFwQXQgPCBsICYmIHdyYXBBdC0tO1xuICAgICAgfVxuXG4gICAgICBkaXN0YW5jZXMgPSBjYWNoZVtsXSA9IFtdO1xuICAgICAgb3JpZ2luWCA9IHJhdGlvcyA/IE1hdGgubWluKHdyYXBBdCwgbCkgKiByYXRpb1ggLSAuNSA6IGZyb20gJSB3cmFwQXQ7XG4gICAgICBvcmlnaW5ZID0gd3JhcEF0ID09PSBfYmlnTnVtID8gMCA6IHJhdGlvcyA/IGwgKiByYXRpb1kgLyB3cmFwQXQgLSAuNSA6IGZyb20gLyB3cmFwQXQgfCAwO1xuICAgICAgbWF4ID0gMDtcbiAgICAgIG1pbiA9IF9iaWdOdW07XG5cbiAgICAgIGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICAgICAgeCA9IGogJSB3cmFwQXQgLSBvcmlnaW5YO1xuICAgICAgICB5ID0gb3JpZ2luWSAtIChqIC8gd3JhcEF0IHwgMCk7XG4gICAgICAgIGRpc3RhbmNlc1tqXSA9IGQgPSAhYXhpcyA/IF9zcXJ0KHggKiB4ICsgeSAqIHkpIDogTWF0aC5hYnMoYXhpcyA9PT0gXCJ5XCIgPyB5IDogeCk7XG4gICAgICAgIGQgPiBtYXggJiYgKG1heCA9IGQpO1xuICAgICAgICBkIDwgbWluICYmIChtaW4gPSBkKTtcbiAgICAgIH1cblxuICAgICAgZnJvbSA9PT0gXCJyYW5kb21cIiAmJiBzaHVmZmxlKGRpc3RhbmNlcyk7XG4gICAgICBkaXN0YW5jZXMubWF4ID0gbWF4IC0gbWluO1xuICAgICAgZGlzdGFuY2VzLm1pbiA9IG1pbjtcbiAgICAgIGRpc3RhbmNlcy52ID0gbCA9IChwYXJzZUZsb2F0KHZhcnMuYW1vdW50KSB8fCBwYXJzZUZsb2F0KHZhcnMuZWFjaCkgKiAod3JhcEF0ID4gbCA/IGwgLSAxIDogIWF4aXMgPyBNYXRoLm1heCh3cmFwQXQsIGwgLyB3cmFwQXQpIDogYXhpcyA9PT0gXCJ5XCIgPyBsIC8gd3JhcEF0IDogd3JhcEF0KSB8fCAwKSAqIChmcm9tID09PSBcImVkZ2VzXCIgPyAtMSA6IDEpO1xuICAgICAgZGlzdGFuY2VzLmIgPSBsIDwgMCA/IGJhc2UgLSBsIDogYmFzZTtcbiAgICAgIGRpc3RhbmNlcy51ID0gZ2V0VW5pdCh2YXJzLmFtb3VudCB8fCB2YXJzLmVhY2gpIHx8IDA7IC8vdW5pdFxuXG4gICAgICBlYXNlID0gZWFzZSAmJiBsIDwgMCA/IF9pbnZlcnRFYXNlKGVhc2UpIDogZWFzZTtcbiAgICB9XG5cbiAgICBsID0gKGRpc3RhbmNlc1tpXSAtIGRpc3RhbmNlcy5taW4pIC8gZGlzdGFuY2VzLm1heCB8fCAwO1xuICAgIHJldHVybiBfcm91bmRQcmVjaXNlKGRpc3RhbmNlcy5iICsgKGVhc2UgPyBlYXNlKGwpIDogbCkgKiBkaXN0YW5jZXMudikgKyBkaXN0YW5jZXMudTsgLy9yb3VuZCBpbiBvcmRlciB0byB3b3JrIGFyb3VuZCBmbG9hdGluZyBwb2ludCBlcnJvcnNcbiAgfTtcbn0sXG4gICAgX3JvdW5kTW9kaWZpZXIgPSBmdW5jdGlvbiBfcm91bmRNb2RpZmllcih2KSB7XG4gIC8vcGFzcyBpbiAwLjEgZ2V0IGEgZnVuY3Rpb24gdGhhdCdsbCByb3VuZCB0byB0aGUgbmVhcmVzdCB0ZW50aCwgb3IgNSB0byByb3VuZCB0byB0aGUgY2xvc2VzdCA1LCBvciAwLjAwMSB0byB0aGUgY2xvc2VzdCAxMDAwdGgsIGV0Yy5cbiAgdmFyIHAgPSBNYXRoLnBvdygxMCwgKCh2ICsgXCJcIikuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aCk7IC8vdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGxpa2UgMjQgKiAwLjEgPT0gMi40MDAwMDAwMDAwMDAwMDA0KSwgd2UgY2hvcCBvZmYgYXQgYSBzcGVjaWZpYyBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgKG11Y2ggZmFzdGVyIHRoYW4gdG9GaXhlZCgpKVxuXG4gIHJldHVybiBmdW5jdGlvbiAocmF3KSB7XG4gICAgdmFyIG4gPSBfcm91bmRQcmVjaXNlKE1hdGgucm91bmQocGFyc2VGbG9hdChyYXcpIC8gdikgKiB2ICogcCk7XG5cbiAgICByZXR1cm4gKG4gLSBuICUgMSkgLyBwICsgKF9pc051bWJlcihyYXcpID8gMCA6IGdldFVuaXQocmF3KSk7IC8vIG4gLSBuICUgMSByZXBsYWNlcyBNYXRoLmZsb29yKCkgaW4gb3JkZXIgdG8gaGFuZGxlIG5lZ2F0aXZlIHZhbHVlcyBwcm9wZXJseS4gRm9yIGV4YW1wbGUsIE1hdGguZmxvb3IoLTE1MC4wMDAwMDAwMDAwMDAwMykgaXMgMTUxIVxuICB9O1xufSxcbiAgICBzbmFwID0gZnVuY3Rpb24gc25hcChzbmFwVG8sIHZhbHVlKSB7XG4gIHZhciBpc0FycmF5ID0gX2lzQXJyYXkoc25hcFRvKSxcbiAgICAgIHJhZGl1cyxcbiAgICAgIGlzMkQ7XG5cbiAgaWYgKCFpc0FycmF5ICYmIF9pc09iamVjdChzbmFwVG8pKSB7XG4gICAgcmFkaXVzID0gaXNBcnJheSA9IHNuYXBUby5yYWRpdXMgfHwgX2JpZ051bTtcblxuICAgIGlmIChzbmFwVG8udmFsdWVzKSB7XG4gICAgICBzbmFwVG8gPSB0b0FycmF5KHNuYXBUby52YWx1ZXMpO1xuXG4gICAgICBpZiAoaXMyRCA9ICFfaXNOdW1iZXIoc25hcFRvWzBdKSkge1xuICAgICAgICByYWRpdXMgKj0gcmFkaXVzOyAvL3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBzbyB3ZSBkb24ndCBoYXZlIHRvIE1hdGguc3FydCgpIGluIHRoZSBsb29wLlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzbmFwVG8gPSBfcm91bmRNb2RpZmllcihzbmFwVG8uaW5jcmVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCAhaXNBcnJheSA/IF9yb3VuZE1vZGlmaWVyKHNuYXBUbykgOiBfaXNGdW5jdGlvbihzbmFwVG8pID8gZnVuY3Rpb24gKHJhdykge1xuICAgIGlzMkQgPSBzbmFwVG8ocmF3KTtcbiAgICByZXR1cm4gTWF0aC5hYnMoaXMyRCAtIHJhdykgPD0gcmFkaXVzID8gaXMyRCA6IHJhdztcbiAgfSA6IGZ1bmN0aW9uIChyYXcpIHtcbiAgICB2YXIgeCA9IHBhcnNlRmxvYXQoaXMyRCA/IHJhdy54IDogcmF3KSxcbiAgICAgICAgeSA9IHBhcnNlRmxvYXQoaXMyRCA/IHJhdy55IDogMCksXG4gICAgICAgIG1pbiA9IF9iaWdOdW0sXG4gICAgICAgIGNsb3Nlc3QgPSAwLFxuICAgICAgICBpID0gc25hcFRvLmxlbmd0aCxcbiAgICAgICAgZHgsXG4gICAgICAgIGR5O1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGlzMkQpIHtcbiAgICAgICAgZHggPSBzbmFwVG9baV0ueCAtIHg7XG4gICAgICAgIGR5ID0gc25hcFRvW2ldLnkgLSB5O1xuICAgICAgICBkeCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHggPSBNYXRoLmFicyhzbmFwVG9baV0gLSB4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGR4IDwgbWluKSB7XG4gICAgICAgIG1pbiA9IGR4O1xuICAgICAgICBjbG9zZXN0ID0gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbG9zZXN0ID0gIXJhZGl1cyB8fCBtaW4gPD0gcmFkaXVzID8gc25hcFRvW2Nsb3Nlc3RdIDogcmF3O1xuICAgIHJldHVybiBpczJEIHx8IGNsb3Nlc3QgPT09IHJhdyB8fCBfaXNOdW1iZXIocmF3KSA/IGNsb3Nlc3QgOiBjbG9zZXN0ICsgZ2V0VW5pdChyYXcpO1xuICB9KTtcbn0sXG4gICAgcmFuZG9tID0gZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4LCByb3VuZGluZ0luY3JlbWVudCwgcmV0dXJuRnVuY3Rpb24pIHtcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybihfaXNBcnJheShtaW4pID8gIW1heCA6IHJvdW5kaW5nSW5jcmVtZW50ID09PSB0cnVlID8gISEocm91bmRpbmdJbmNyZW1lbnQgPSAwKSA6ICFyZXR1cm5GdW5jdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNBcnJheShtaW4pID8gbWluW35+KE1hdGgucmFuZG9tKCkgKiBtaW4ubGVuZ3RoKV0gOiAocm91bmRpbmdJbmNyZW1lbnQgPSByb3VuZGluZ0luY3JlbWVudCB8fCAxZS01KSAmJiAocmV0dXJuRnVuY3Rpb24gPSByb3VuZGluZ0luY3JlbWVudCA8IDEgPyBNYXRoLnBvdygxMCwgKHJvdW5kaW5nSW5jcmVtZW50ICsgXCJcIikubGVuZ3RoIC0gMikgOiAxKSAmJiBNYXRoLmZsb29yKE1hdGgucm91bmQoKG1pbiAtIHJvdW5kaW5nSW5jcmVtZW50IC8gMiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgcm91bmRpbmdJbmNyZW1lbnQgKiAuOTkpKSAvIHJvdW5kaW5nSW5jcmVtZW50KSAqIHJvdW5kaW5nSW5jcmVtZW50ICogcmV0dXJuRnVuY3Rpb24pIC8gcmV0dXJuRnVuY3Rpb247XG4gIH0pO1xufSxcbiAgICBwaXBlID0gZnVuY3Rpb24gcGlwZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmN0aW9ucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jdGlvbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHYsIGYpIHtcbiAgICAgIHJldHVybiBmKHYpO1xuICAgIH0sIHZhbHVlKTtcbiAgfTtcbn0sXG4gICAgdW5pdGl6ZSA9IGZ1bmN0aW9uIHVuaXRpemUoZnVuYywgdW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmMocGFyc2VGbG9hdCh2YWx1ZSkpICsgKHVuaXQgfHwgZ2V0VW5pdCh2YWx1ZSkpO1xuICB9O1xufSxcbiAgICBub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUobWluLCBtYXgsIHZhbHVlKSB7XG4gIHJldHVybiBtYXBSYW5nZShtaW4sIG1heCwgMCwgMSwgdmFsdWUpO1xufSxcbiAgICBfd3JhcEFycmF5ID0gZnVuY3Rpb24gX3dyYXBBcnJheShhLCB3cmFwcGVyLCB2YWx1ZSkge1xuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gYVt+fndyYXBwZXIoaW5kZXgpXTtcbiAgfSk7XG59LFxuICAgIHdyYXAgPSBmdW5jdGlvbiB3cmFwKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAvLyBOT1RFOiB3cmFwKCkgQ0FOTk9UIGJlIGFuIGFycm93IGZ1bmN0aW9uISBBIHZlcnkgb2RkIGNvbXBpbGluZyBidWcgY2F1c2VzIHByb2JsZW1zICh1bnJlbGF0ZWQgdG8gR1NBUCkuXG4gIHZhciByYW5nZSA9IG1heCAtIG1pbjtcbiAgcmV0dXJuIF9pc0FycmF5KG1pbikgPyBfd3JhcEFycmF5KG1pbiwgd3JhcCgwLCBtaW4ubGVuZ3RoKSwgbWF4KSA6IF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIChyYW5nZSArICh2YWx1ZSAtIG1pbikgJSByYW5nZSkgJSByYW5nZSArIG1pbjtcbiAgfSk7XG59LFxuICAgIHdyYXBZb3lvID0gZnVuY3Rpb24gd3JhcFlveW8obWluLCBtYXgsIHZhbHVlKSB7XG4gIHZhciByYW5nZSA9IG1heCAtIG1pbixcbiAgICAgIHRvdGFsID0gcmFuZ2UgKiAyO1xuICByZXR1cm4gX2lzQXJyYXkobWluKSA/IF93cmFwQXJyYXkobWluLCB3cmFwWW95bygwLCBtaW4ubGVuZ3RoIC0gMSksIG1heCkgOiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhbHVlID0gKHRvdGFsICsgKHZhbHVlIC0gbWluKSAlIHRvdGFsKSAlIHRvdGFsIHx8IDA7XG4gICAgcmV0dXJuIG1pbiArICh2YWx1ZSA+IHJhbmdlID8gdG90YWwgLSB2YWx1ZSA6IHZhbHVlKTtcbiAgfSk7XG59LFxuICAgIF9yZXBsYWNlUmFuZG9tID0gZnVuY3Rpb24gX3JlcGxhY2VSYW5kb20odmFsdWUpIHtcbiAgLy9yZXBsYWNlcyBhbGwgb2NjdXJyZW5jZXMgb2YgcmFuZG9tKC4uLikgaW4gYSBzdHJpbmcgd2l0aCB0aGUgY2FsY3VsYXRlZCByYW5kb20gdmFsdWUuIGNhbiBiZSBhIHJhbmdlIGxpa2UgcmFuZG9tKC0xMDAsIDEwMCwgNSkgb3IgYW4gYXJyYXkgbGlrZSByYW5kb20oWzAsIDEwMCwgNTAwXSlcbiAgdmFyIHByZXYgPSAwLFxuICAgICAgcyA9IFwiXCIsXG4gICAgICBpLFxuICAgICAgbnVtcyxcbiAgICAgIGVuZCxcbiAgICAgIGlzQXJyYXk7XG5cbiAgd2hpbGUgKH4oaSA9IHZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIsIHByZXYpKSkge1xuICAgIGVuZCA9IHZhbHVlLmluZGV4T2YoXCIpXCIsIGkpO1xuICAgIGlzQXJyYXkgPSB2YWx1ZS5jaGFyQXQoaSArIDcpID09PSBcIltcIjtcbiAgICBudW1zID0gdmFsdWUuc3Vic3RyKGkgKyA3LCBlbmQgLSBpIC0gNykubWF0Y2goaXNBcnJheSA/IF9kZWxpbWl0ZWRWYWx1ZUV4cCA6IF9zdHJpY3ROdW1FeHApO1xuICAgIHMgKz0gdmFsdWUuc3Vic3RyKHByZXYsIGkgLSBwcmV2KSArIHJhbmRvbShpc0FycmF5ID8gbnVtcyA6ICtudW1zWzBdLCBpc0FycmF5ID8gMCA6ICtudW1zWzFdLCArbnVtc1syXSB8fCAxZS01KTtcbiAgICBwcmV2ID0gZW5kICsgMTtcbiAgfVxuXG4gIHJldHVybiBzICsgdmFsdWUuc3Vic3RyKHByZXYsIHZhbHVlLmxlbmd0aCAtIHByZXYpO1xufSxcbiAgICBtYXBSYW5nZSA9IGZ1bmN0aW9uIG1hcFJhbmdlKGluTWluLCBpbk1heCwgb3V0TWluLCBvdXRNYXgsIHZhbHVlKSB7XG4gIHZhciBpblJhbmdlID0gaW5NYXggLSBpbk1pbixcbiAgICAgIG91dFJhbmdlID0gb3V0TWF4IC0gb3V0TWluO1xuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gb3V0TWluICsgKCh2YWx1ZSAtIGluTWluKSAvIGluUmFuZ2UgKiBvdXRSYW5nZSB8fCAwKTtcbiAgfSk7XG59LFxuICAgIGludGVycG9sYXRlID0gZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3RhcnQsIGVuZCwgcHJvZ3Jlc3MsIG11dGF0ZSkge1xuICB2YXIgZnVuYyA9IGlzTmFOKHN0YXJ0ICsgZW5kKSA/IDAgOiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAoMSAtIHApICogc3RhcnQgKyBwICogZW5kO1xuICB9O1xuXG4gIGlmICghZnVuYykge1xuICAgIHZhciBpc1N0cmluZyA9IF9pc1N0cmluZyhzdGFydCksXG4gICAgICAgIG1hc3RlciA9IHt9LFxuICAgICAgICBwLFxuICAgICAgICBpLFxuICAgICAgICBpbnRlcnBvbGF0b3JzLFxuICAgICAgICBsLFxuICAgICAgICBpbDtcblxuICAgIHByb2dyZXNzID09PSB0cnVlICYmIChtdXRhdGUgPSAxKSAmJiAocHJvZ3Jlc3MgPSBudWxsKTtcblxuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgc3RhcnQgPSB7XG4gICAgICAgIHA6IHN0YXJ0XG4gICAgICB9O1xuICAgICAgZW5kID0ge1xuICAgICAgICBwOiBlbmRcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChfaXNBcnJheShzdGFydCkgJiYgIV9pc0FycmF5KGVuZCkpIHtcbiAgICAgIGludGVycG9sYXRvcnMgPSBbXTtcbiAgICAgIGwgPSBzdGFydC5sZW5ndGg7XG4gICAgICBpbCA9IGwgLSAyO1xuXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGludGVycG9sYXRvcnMucHVzaChpbnRlcnBvbGF0ZShzdGFydFtpIC0gMV0sIHN0YXJ0W2ldKSk7IC8vYnVpbGQgdGhlIGludGVycG9sYXRvcnMgdXAgZnJvbnQgYXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gc28gdGhhdCB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgbWFueSB0aW1lcywgaXQgY2FuIGp1c3QgcmV1c2UgdGhlbS5cbiAgICAgIH1cblxuICAgICAgbC0tO1xuXG4gICAgICBmdW5jID0gZnVuY3Rpb24gZnVuYyhwKSB7XG4gICAgICAgIHAgKj0gbDtcbiAgICAgICAgdmFyIGkgPSBNYXRoLm1pbihpbCwgfn5wKTtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRvcnNbaV0ocCAtIGkpO1xuICAgICAgfTtcblxuICAgICAgcHJvZ3Jlc3MgPSBlbmQ7XG4gICAgfSBlbHNlIGlmICghbXV0YXRlKSB7XG4gICAgICBzdGFydCA9IF9tZXJnZShfaXNBcnJheShzdGFydCkgPyBbXSA6IHt9LCBzdGFydCk7XG4gICAgfVxuXG4gICAgaWYgKCFpbnRlcnBvbGF0b3JzKSB7XG4gICAgICBmb3IgKHAgaW4gZW5kKSB7XG4gICAgICAgIF9hZGRQcm9wVHdlZW4uY2FsbChtYXN0ZXIsIHN0YXJ0LCBwLCBcImdldFwiLCBlbmRbcF0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jID0gZnVuY3Rpb24gZnVuYyhwKSB7XG4gICAgICAgIHJldHVybiBfcmVuZGVyUHJvcFR3ZWVucyhwLCBtYXN0ZXIpIHx8IChpc1N0cmluZyA/IHN0YXJ0LnAgOiBzdGFydCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4ocHJvZ3Jlc3MsIGZ1bmMpO1xufSxcbiAgICBfZ2V0TGFiZWxJbkRpcmVjdGlvbiA9IGZ1bmN0aW9uIF9nZXRMYWJlbEluRGlyZWN0aW9uKHRpbWVsaW5lLCBmcm9tVGltZSwgYmFja3dhcmQpIHtcbiAgLy91c2VkIGZvciBuZXh0TGFiZWwoKSBhbmQgcHJldmlvdXNMYWJlbCgpXG4gIHZhciBsYWJlbHMgPSB0aW1lbGluZS5sYWJlbHMsXG4gICAgICBtaW4gPSBfYmlnTnVtLFxuICAgICAgcCxcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgbGFiZWw7XG5cbiAgZm9yIChwIGluIGxhYmVscykge1xuICAgIGRpc3RhbmNlID0gbGFiZWxzW3BdIC0gZnJvbVRpbWU7XG5cbiAgICBpZiAoZGlzdGFuY2UgPCAwID09PSAhIWJhY2t3YXJkICYmIGRpc3RhbmNlICYmIG1pbiA+IChkaXN0YW5jZSA9IE1hdGguYWJzKGRpc3RhbmNlKSkpIHtcbiAgICAgIGxhYmVsID0gcDtcbiAgICAgIG1pbiA9IGRpc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsYWJlbDtcbn0sXG4gICAgX2NhbGxiYWNrID0gZnVuY3Rpb24gX2NhbGxiYWNrKGFuaW1hdGlvbiwgdHlwZSwgZXhlY3V0ZUxhenlGaXJzdCkge1xuICB2YXIgdiA9IGFuaW1hdGlvbi52YXJzLFxuICAgICAgY2FsbGJhY2sgPSB2W3R5cGVdLFxuICAgICAgcHJldkNvbnRleHQgPSBfY29udGV4dCxcbiAgICAgIGNvbnRleHQgPSBhbmltYXRpb24uX2N0eCxcbiAgICAgIHBhcmFtcyxcbiAgICAgIHNjb3BlLFxuICAgICAgcmVzdWx0O1xuXG4gIGlmICghY2FsbGJhY2spIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwYXJhbXMgPSB2W3R5cGUgKyBcIlBhcmFtc1wiXTtcbiAgc2NvcGUgPSB2LmNhbGxiYWNrU2NvcGUgfHwgYW5pbWF0aW9uO1xuICBleGVjdXRlTGF6eUZpcnN0ICYmIF9sYXp5VHdlZW5zLmxlbmd0aCAmJiBfbGF6eVJlbmRlcigpOyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gYSB0aW1lbGluZSBmaW5pc2hlcywgdXNlcnMgZXhwZWN0IHRoaW5ncyB0byBoYXZlIHJlbmRlcmVkIGZ1bGx5LiBJbWFnaW5lIGFuIG9uVXBkYXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblxuICBjb250ZXh0ICYmIChfY29udGV4dCA9IGNvbnRleHQpO1xuICByZXN1bHQgPSBwYXJhbXMgPyBjYWxsYmFjay5hcHBseShzY29wZSwgcGFyYW1zKSA6IGNhbGxiYWNrLmNhbGwoc2NvcGUpO1xuICBfY29udGV4dCA9IHByZXZDb250ZXh0O1xuICByZXR1cm4gcmVzdWx0O1xufSxcbiAgICBfaW50ZXJydXB0ID0gZnVuY3Rpb24gX2ludGVycnVwdChhbmltYXRpb24pIHtcbiAgX3JlbW92ZUZyb21QYXJlbnQoYW5pbWF0aW9uKTtcblxuICBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlciAmJiBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlci5raWxsKCEhX3JldmVydGluZyk7XG4gIGFuaW1hdGlvbi5wcm9ncmVzcygpIDwgMSAmJiBfY2FsbGJhY2soYW5pbWF0aW9uLCBcIm9uSW50ZXJydXB0XCIpO1xuICByZXR1cm4gYW5pbWF0aW9uO1xufSxcbiAgICBfcXVpY2tUd2VlbixcbiAgICBfcmVnaXN0ZXJQbHVnaW5RdWV1ZSA9IFtdLFxuICAgIF9jcmVhdGVQbHVnaW4gPSBmdW5jdGlvbiBfY3JlYXRlUGx1Z2luKGNvbmZpZykge1xuICBpZiAoIWNvbmZpZykgcmV0dXJuO1xuICBjb25maWcgPSAhY29uZmlnLm5hbWUgJiYgY29uZmlnW1wiZGVmYXVsdFwiXSB8fCBjb25maWc7IC8vIFVNRCBwYWNrYWdpbmcgd3JhcHMgdGhpbmdzIG9kZGx5LCBzbyBmb3IgZXhhbXBsZSBNb3Rpb25QYXRoSGVscGVyIGJlY29tZXMge01vdGlvblBhdGhIZWxwZXI6TW90aW9uUGF0aEhlbHBlciwgZGVmYXVsdDpNb3Rpb25QYXRoSGVscGVyfS5cblxuICBpZiAoX3dpbmRvd0V4aXN0cygpIHx8IGNvbmZpZy5oZWFkbGVzcykge1xuICAgIC8vIGVkZ2UgY2FzZTogc29tZSBidWlsZCB0b29scyBtYXkgcGFzcyBpbiBhIG51bGwvdW5kZWZpbmVkIHZhbHVlXG4gICAgdmFyIG5hbWUgPSBjb25maWcubmFtZSxcbiAgICAgICAgaXNGdW5jID0gX2lzRnVuY3Rpb24oY29uZmlnKSxcbiAgICAgICAgUGx1Z2luID0gbmFtZSAmJiAhaXNGdW5jICYmIGNvbmZpZy5pbml0ID8gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcHJvcHMgPSBbXTtcbiAgICB9IDogY29uZmlnLFxuICAgICAgICAvL2luIGNhc2Ugc29tZW9uZSBwYXNzZXMgaW4gYW4gb2JqZWN0IHRoYXQncyBub3QgYSBwbHVnaW4sIGxpa2UgQ3VzdG9tRWFzZVxuICAgIGluc3RhbmNlRGVmYXVsdHMgPSB7XG4gICAgICBpbml0OiBfZW1wdHlGdW5jLFxuICAgICAgcmVuZGVyOiBfcmVuZGVyUHJvcFR3ZWVucyxcbiAgICAgIGFkZDogX2FkZFByb3BUd2VlbixcbiAgICAgIGtpbGw6IF9raWxsUHJvcFR3ZWVuc09mLFxuICAgICAgbW9kaWZpZXI6IF9hZGRQbHVnaW5Nb2RpZmllcixcbiAgICAgIHJhd1ZhcnM6IDBcbiAgICB9LFxuICAgICAgICBzdGF0aWNzID0ge1xuICAgICAgdGFyZ2V0VGVzdDogMCxcbiAgICAgIGdldDogMCxcbiAgICAgIGdldFNldHRlcjogX2dldFNldHRlcixcbiAgICAgIGFsaWFzZXM6IHt9LFxuICAgICAgcmVnaXN0ZXI6IDBcbiAgICB9O1xuXG4gICAgX3dha2UoKTtcblxuICAgIGlmIChjb25maWcgIT09IFBsdWdpbikge1xuICAgICAgaWYgKF9wbHVnaW5zW25hbWVdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3NldERlZmF1bHRzKFBsdWdpbiwgX3NldERlZmF1bHRzKF9jb3B5RXhjbHVkaW5nKGNvbmZpZywgaW5zdGFuY2VEZWZhdWx0cyksIHN0YXRpY3MpKTsgLy9zdGF0aWMgbWV0aG9kc1xuXG5cbiAgICAgIF9tZXJnZShQbHVnaW4ucHJvdG90eXBlLCBfbWVyZ2UoaW5zdGFuY2VEZWZhdWx0cywgX2NvcHlFeGNsdWRpbmcoY29uZmlnLCBzdGF0aWNzKSkpOyAvL2luc3RhbmNlIG1ldGhvZHNcblxuXG4gICAgICBfcGx1Z2luc1tQbHVnaW4ucHJvcCA9IG5hbWVdID0gUGx1Z2luO1xuXG4gICAgICBpZiAoY29uZmlnLnRhcmdldFRlc3QpIHtcbiAgICAgICAgX2hhcm5lc3NQbHVnaW5zLnB1c2goUGx1Z2luKTtcblxuICAgICAgICBfcmVzZXJ2ZWRQcm9wc1tuYW1lXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIG5hbWUgPSAobmFtZSA9PT0gXCJjc3NcIiA/IFwiQ1NTXCIgOiBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSkpICsgXCJQbHVnaW5cIjsgLy9mb3IgdGhlIGdsb2JhbCBuYW1lLiBcIm1vdGlvblBhdGhcIiBzaG91bGQgYmVjb21lIE1vdGlvblBhdGhQbHVnaW5cbiAgICB9XG5cbiAgICBfYWRkR2xvYmFsKG5hbWUsIFBsdWdpbik7XG5cbiAgICBjb25maWcucmVnaXN0ZXIgJiYgY29uZmlnLnJlZ2lzdGVyKGdzYXAsIFBsdWdpbiwgUHJvcFR3ZWVuKTtcbiAgfSBlbHNlIHtcbiAgICBfcmVnaXN0ZXJQbHVnaW5RdWV1ZS5wdXNoKGNvbmZpZyk7XG4gIH1cbn0sXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ09MT1JTXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5fMjU1ID0gMjU1LFxuICAgIF9jb2xvckxvb2t1cCA9IHtcbiAgYXF1YTogWzAsIF8yNTUsIF8yNTVdLFxuICBsaW1lOiBbMCwgXzI1NSwgMF0sXG4gIHNpbHZlcjogWzE5MiwgMTkyLCAxOTJdLFxuICBibGFjazogWzAsIDAsIDBdLFxuICBtYXJvb246IFsxMjgsIDAsIDBdLFxuICB0ZWFsOiBbMCwgMTI4LCAxMjhdLFxuICBibHVlOiBbMCwgMCwgXzI1NV0sXG4gIG5hdnk6IFswLCAwLCAxMjhdLFxuICB3aGl0ZTogW18yNTUsIF8yNTUsIF8yNTVdLFxuICBvbGl2ZTogWzEyOCwgMTI4LCAwXSxcbiAgeWVsbG93OiBbXzI1NSwgXzI1NSwgMF0sXG4gIG9yYW5nZTogW18yNTUsIDE2NSwgMF0sXG4gIGdyYXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgcHVycGxlOiBbMTI4LCAwLCAxMjhdLFxuICBncmVlbjogWzAsIDEyOCwgMF0sXG4gIHJlZDogW18yNTUsIDAsIDBdLFxuICBwaW5rOiBbXzI1NSwgMTkyLCAyMDNdLFxuICBjeWFuOiBbMCwgXzI1NSwgXzI1NV0sXG4gIHRyYW5zcGFyZW50OiBbXzI1NSwgXzI1NSwgXzI1NSwgMF1cbn0sXG4gICAgLy8gcG9zc2libGUgZnV0dXJlIGlkZWEgdG8gcmVwbGFjZSB0aGUgaGFyZC1jb2RlZCBjb2xvciBuYW1lIHZhbHVlcyAtIHB1dCB0aGlzIGluIHRoZSB0aWNrZXIud2FrZSgpIHdoZXJlIHdlIHNldCB0aGUgX2RvYzpcbi8vIGxldCBjdHggPSBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpO1xuLy8gX2ZvckVhY2hOYW1lKFwiYXF1YSxsaW1lLHNpbHZlcixibGFjayxtYXJvb24sdGVhbCxibHVlLG5hdnksd2hpdGUsb2xpdmUseWVsbG93LG9yYW5nZSxncmF5LHB1cnBsZSxncmVlbixyZWQscGluayxjeWFuXCIsIGNvbG9yID0+IHtjdHguZmlsbFN0eWxlID0gY29sb3I7IF9jb2xvckxvb2t1cFtjb2xvcl0gPSBzcGxpdENvbG9yKGN0eC5maWxsU3R5bGUpfSk7XG5faHVlID0gZnVuY3Rpb24gX2h1ZShoLCBtMSwgbTIpIHtcbiAgaCArPSBoIDwgMCA/IDEgOiBoID4gMSA/IC0xIDogMDtcbiAgcmV0dXJuIChoICogNiA8IDEgPyBtMSArIChtMiAtIG0xKSAqIGggKiA2IDogaCA8IC41ID8gbTIgOiBoICogMyA8IDIgPyBtMSArIChtMiAtIG0xKSAqICgyIC8gMyAtIGgpICogNiA6IG0xKSAqIF8yNTUgKyAuNSB8IDA7XG59LFxuICAgIHNwbGl0Q29sb3IgPSBmdW5jdGlvbiBzcGxpdENvbG9yKHYsIHRvSFNMLCBmb3JjZUFscGhhKSB7XG4gIHZhciBhID0gIXYgPyBfY29sb3JMb29rdXAuYmxhY2sgOiBfaXNOdW1iZXIodikgPyBbdiA+PiAxNiwgdiA+PiA4ICYgXzI1NSwgdiAmIF8yNTVdIDogMCxcbiAgICAgIHIsXG4gICAgICBnLFxuICAgICAgYixcbiAgICAgIGgsXG4gICAgICBzLFxuICAgICAgbCxcbiAgICAgIG1heCxcbiAgICAgIG1pbixcbiAgICAgIGQsXG4gICAgICB3YXNIU0w7XG5cbiAgaWYgKCFhKSB7XG4gICAgaWYgKHYuc3Vic3RyKC0xKSA9PT0gXCIsXCIpIHtcbiAgICAgIC8vc29tZXRpbWVzIGEgdHJhaWxpbmcgY29tbWEgaXMgaW5jbHVkZWQgYW5kIHdlIHNob3VsZCBjaG9wIGl0IG9mZiAodHlwaWNhbGx5IGZyb20gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiB2YWx1ZXMgbGlrZSBhIHRleHRTaGFkb3c6XCIycHggMnB4IDJweCBibHVlLCA1cHggNXB4IDVweCByZ2IoMjU1LDAsMClcIiAtIGluIHRoaXMgZXhhbXBsZSBcImJsdWUsXCIgaGFzIGEgdHJhaWxpbmcgY29tbWEuIFdlIGNvdWxkIHN0cmlwIGl0IG91dCBpbnNpZGUgcGFyc2VDb21wbGV4KCkgYnV0IHdlJ2QgbmVlZCB0byBkbyBpdCB0byB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIHBsdXMgaXQgd291bGRuJ3QgcHJvdmlkZSBwcm90ZWN0aW9uIGZyb20gb3RoZXIgcG90ZW50aWFsIHNjZW5hcmlvcyBsaWtlIGlmIHRoZSB1c2VyIHBhc3NlcyBpbiBhIHNpbWlsYXIgdmFsdWUuXG4gICAgICB2ID0gdi5zdWJzdHIoMCwgdi5sZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICBpZiAoX2NvbG9yTG9va3VwW3ZdKSB7XG4gICAgICBhID0gX2NvbG9yTG9va3VwW3ZdO1xuICAgIH0gZWxzZSBpZiAodi5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICBpZiAodi5sZW5ndGggPCA2KSB7XG4gICAgICAgIC8vZm9yIHNob3J0aGFuZCBsaWtlICM5RjAgb3IgIzlGMEYgKGNvdWxkIGhhdmUgYWxwaGEpXG4gICAgICAgIHIgPSB2LmNoYXJBdCgxKTtcbiAgICAgICAgZyA9IHYuY2hhckF0KDIpO1xuICAgICAgICBiID0gdi5jaGFyQXQoMyk7XG4gICAgICAgIHYgPSBcIiNcIiArIHIgKyByICsgZyArIGcgKyBiICsgYiArICh2Lmxlbmd0aCA9PT0gNSA/IHYuY2hhckF0KDQpICsgdi5jaGFyQXQoNCkgOiBcIlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHYubGVuZ3RoID09PSA5KSB7XG4gICAgICAgIC8vIGhleCB3aXRoIGFscGhhLCBsaWtlICNmZDVlNTNmZlxuICAgICAgICBhID0gcGFyc2VJbnQodi5zdWJzdHIoMSwgNiksIDE2KTtcbiAgICAgICAgcmV0dXJuIFthID4+IDE2LCBhID4+IDggJiBfMjU1LCBhICYgXzI1NSwgcGFyc2VJbnQodi5zdWJzdHIoNyksIDE2KSAvIDI1NV07XG4gICAgICB9XG5cbiAgICAgIHYgPSBwYXJzZUludCh2LnN1YnN0cigxKSwgMTYpO1xuICAgICAgYSA9IFt2ID4+IDE2LCB2ID4+IDggJiBfMjU1LCB2ICYgXzI1NV07XG4gICAgfSBlbHNlIGlmICh2LnN1YnN0cigwLCAzKSA9PT0gXCJoc2xcIikge1xuICAgICAgYSA9IHdhc0hTTCA9IHYubWF0Y2goX3N0cmljdE51bUV4cCk7XG5cbiAgICAgIGlmICghdG9IU0wpIHtcbiAgICAgICAgaCA9ICthWzBdICUgMzYwIC8gMzYwO1xuICAgICAgICBzID0gK2FbMV0gLyAxMDA7XG4gICAgICAgIGwgPSArYVsyXSAvIDEwMDtcbiAgICAgICAgZyA9IGwgPD0gLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHIgPSBsICogMiAtIGc7XG4gICAgICAgIGEubGVuZ3RoID4gMyAmJiAoYVszXSAqPSAxKTsgLy9jYXN0IGFzIG51bWJlclxuXG4gICAgICAgIGFbMF0gPSBfaHVlKGggKyAxIC8gMywgciwgZyk7XG4gICAgICAgIGFbMV0gPSBfaHVlKGgsIHIsIGcpO1xuICAgICAgICBhWzJdID0gX2h1ZShoIC0gMSAvIDMsIHIsIGcpO1xuICAgICAgfSBlbHNlIGlmICh+di5pbmRleE9mKFwiPVwiKSkge1xuICAgICAgICAvL2lmIHJlbGF0aXZlIHZhbHVlcyBhcmUgZm91bmQsIGp1c3QgcmV0dXJuIHRoZSByYXcgc3RyaW5ncyB3aXRoIHRoZSByZWxhdGl2ZSBwcmVmaXhlcyBpbiBwbGFjZS5cbiAgICAgICAgYSA9IHYubWF0Y2goX251bUV4cCk7XG4gICAgICAgIGZvcmNlQWxwaGEgJiYgYS5sZW5ndGggPCA0ICYmIChhWzNdID0gMSk7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhID0gdi5tYXRjaChfc3RyaWN0TnVtRXhwKSB8fCBfY29sb3JMb29rdXAudHJhbnNwYXJlbnQ7XG4gICAgfVxuXG4gICAgYSA9IGEubWFwKE51bWJlcik7XG4gIH1cblxuICBpZiAodG9IU0wgJiYgIXdhc0hTTCkge1xuICAgIHIgPSBhWzBdIC8gXzI1NTtcbiAgICBnID0gYVsxXSAvIF8yNTU7XG4gICAgYiA9IGFbMl0gLyBfMjU1O1xuICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIGwgPSAobWF4ICsgbWluKSAvIDI7XG5cbiAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgIGggPSBzID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZCA9IG1heCAtIG1pbjtcbiAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICAgIGggPSBtYXggPT09IHIgPyAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKSA6IG1heCA9PT0gZyA/IChiIC0gcikgLyBkICsgMiA6IChyIC0gZykgLyBkICsgNDtcbiAgICAgIGggKj0gNjA7XG4gICAgfVxuXG4gICAgYVswXSA9IH5+KGggKyAuNSk7XG4gICAgYVsxXSA9IH5+KHMgKiAxMDAgKyAuNSk7XG4gICAgYVsyXSA9IH5+KGwgKiAxMDAgKyAuNSk7XG4gIH1cblxuICBmb3JjZUFscGhhICYmIGEubGVuZ3RoIDwgNCAmJiAoYVszXSA9IDEpO1xuICByZXR1cm4gYTtcbn0sXG4gICAgX2NvbG9yT3JkZXJEYXRhID0gZnVuY3Rpb24gX2NvbG9yT3JkZXJEYXRhKHYpIHtcbiAgLy8gc3RyaXBzIG91dCB0aGUgY29sb3JzIGZyb20gdGhlIHN0cmluZywgZmluZHMgYWxsIHRoZSBudW1lcmljIHNsb3RzICh3aXRoIHVuaXRzKSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aG9zZS4gVGhlIEFycmF5IGFsc28gaGFzIGEgXCJjXCIgcHJvcGVydHkgd2hpY2ggaXMgYW4gQXJyYXkgb2YgdGhlIGluZGV4IHZhbHVlcyB3aGVyZSB0aGUgY29sb3JzIGJlbG9uZy4gVGhpcyBpcyB0byBoZWxwIHdvcmsgYXJvdW5kIGlzc3VlcyB3aGVyZSB0aGVyZSdzIGEgbWlzLW1hdGNoZWQgb3JkZXIgb2YgY29sb3IvbnVtZXJpYyBkYXRhIGxpa2UgZHJvcC1zaGFkb3coI2YwMCAwcHggMXB4IDJweCkgYW5kIGRyb3Atc2hhZG93KDB4IDFweCAycHggI2YwMCkuIFRoaXMgaXMgYmFzaWNhbGx5IGEgaGVscGVyIGZ1bmN0aW9uIHVzZWQgaW4gX2Zvcm1hdENvbG9ycygpXG4gIHZhciB2YWx1ZXMgPSBbXSxcbiAgICAgIGMgPSBbXSxcbiAgICAgIGkgPSAtMTtcbiAgdi5zcGxpdChfY29sb3JFeHApLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgYSA9IHYubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcbiAgICB2YWx1ZXMucHVzaC5hcHBseSh2YWx1ZXMsIGEpO1xuICAgIGMucHVzaChpICs9IGEubGVuZ3RoICsgMSk7XG4gIH0pO1xuICB2YWx1ZXMuYyA9IGM7XG4gIHJldHVybiB2YWx1ZXM7XG59LFxuICAgIF9mb3JtYXRDb2xvcnMgPSBmdW5jdGlvbiBfZm9ybWF0Q29sb3JzKHMsIHRvSFNMLCBvcmRlck1hdGNoRGF0YSkge1xuICB2YXIgcmVzdWx0ID0gXCJcIixcbiAgICAgIGNvbG9ycyA9IChzICsgcmVzdWx0KS5tYXRjaChfY29sb3JFeHApLFxuICAgICAgdHlwZSA9IHRvSFNMID8gXCJoc2xhKFwiIDogXCJyZ2JhKFwiLFxuICAgICAgaSA9IDAsXG4gICAgICBjLFxuICAgICAgc2hlbGwsXG4gICAgICBkLFxuICAgICAgbDtcblxuICBpZiAoIWNvbG9ycykge1xuICAgIHJldHVybiBzO1xuICB9XG5cbiAgY29sb3JzID0gY29sb3JzLm1hcChmdW5jdGlvbiAoY29sb3IpIHtcbiAgICByZXR1cm4gKGNvbG9yID0gc3BsaXRDb2xvcihjb2xvciwgdG9IU0wsIDEpKSAmJiB0eXBlICsgKHRvSFNMID8gY29sb3JbMF0gKyBcIixcIiArIGNvbG9yWzFdICsgXCIlLFwiICsgY29sb3JbMl0gKyBcIiUsXCIgKyBjb2xvclszXSA6IGNvbG9yLmpvaW4oXCIsXCIpKSArIFwiKVwiO1xuICB9KTtcblxuICBpZiAob3JkZXJNYXRjaERhdGEpIHtcbiAgICBkID0gX2NvbG9yT3JkZXJEYXRhKHMpO1xuICAgIGMgPSBvcmRlck1hdGNoRGF0YS5jO1xuXG4gICAgaWYgKGMuam9pbihyZXN1bHQpICE9PSBkLmMuam9pbihyZXN1bHQpKSB7XG4gICAgICBzaGVsbCA9IHMucmVwbGFjZShfY29sb3JFeHAsIFwiMVwiKS5zcGxpdChfbnVtV2l0aFVuaXRFeHApO1xuICAgICAgbCA9IHNoZWxsLmxlbmd0aCAtIDE7XG5cbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCArPSBzaGVsbFtpXSArICh+Yy5pbmRleE9mKGkpID8gY29sb3JzLnNoaWZ0KCkgfHwgdHlwZSArIFwiMCwwLDAsMClcIiA6IChkLmxlbmd0aCA/IGQgOiBjb2xvcnMubGVuZ3RoID8gY29sb3JzIDogb3JkZXJNYXRjaERhdGEpLnNoaWZ0KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghc2hlbGwpIHtcbiAgICBzaGVsbCA9IHMuc3BsaXQoX2NvbG9yRXhwKTtcbiAgICBsID0gc2hlbGwubGVuZ3RoIC0gMTtcblxuICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXN1bHQgKz0gc2hlbGxbaV0gKyBjb2xvcnNbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdCArIHNoZWxsW2xdO1xufSxcbiAgICBfY29sb3JFeHAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzID0gXCIoPzpcXFxcYig/Oig/OnJnYnxyZ2JhfGhzbHxoc2xhKVxcXFwoLis/XFxcXCkpfFxcXFxCIyg/OlswLTlhLWZdezMsNH0pezEsMn1cXFxcYlwiLFxuICAgICAgLy93ZSdsbCBkeW5hbWljYWxseSBidWlsZCB0aGlzIFJlZ3VsYXIgRXhwcmVzc2lvbiB0byBjb25zZXJ2ZSBmaWxlIHNpemUuIEFmdGVyIGJ1aWxkaW5nIGl0LCBpdCB3aWxsIGJlIGFibGUgdG8gZmluZCByZ2IoKSwgcmdiYSgpLCAjIChoZXhhZGVjaW1hbCksIGFuZCBuYW1lZCBjb2xvciB2YWx1ZXMgbGlrZSByZWQsIGJsdWUsIHB1cnBsZSwgZXRjLixcbiAgcDtcblxuICBmb3IgKHAgaW4gX2NvbG9yTG9va3VwKSB7XG4gICAgcyArPSBcInxcIiArIHAgKyBcIlxcXFxiXCI7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlZ0V4cChzICsgXCIpXCIsIFwiZ2lcIik7XG59KCksXG4gICAgX2hzbEV4cCA9IC9oc2xbYV0/XFwoLyxcbiAgICBfY29sb3JTdHJpbmdGaWx0ZXIgPSBmdW5jdGlvbiBfY29sb3JTdHJpbmdGaWx0ZXIoYSkge1xuICB2YXIgY29tYmluZWQgPSBhLmpvaW4oXCIgXCIpLFxuICAgICAgdG9IU0w7XG4gIF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xuXG4gIGlmIChfY29sb3JFeHAudGVzdChjb21iaW5lZCkpIHtcbiAgICB0b0hTTCA9IF9oc2xFeHAudGVzdChjb21iaW5lZCk7XG4gICAgYVsxXSA9IF9mb3JtYXRDb2xvcnMoYVsxXSwgdG9IU0wpO1xuICAgIGFbMF0gPSBfZm9ybWF0Q29sb3JzKGFbMF0sIHRvSFNMLCBfY29sb3JPcmRlckRhdGEoYVsxXSkpOyAvLyBtYWtlIHN1cmUgdGhlIG9yZGVyIG9mIG51bWJlcnMvY29sb3JzIG1hdGNoIHdpdGggdGhlIEVORCB2YWx1ZS5cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59LFxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRJQ0tFUlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuX3RpY2tlckFjdGl2ZSxcbiAgICBfdGlja2VyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX2dldFRpbWUgPSBEYXRlLm5vdyxcbiAgICAgIF9sYWdUaHJlc2hvbGQgPSA1MDAsXG4gICAgICBfYWRqdXN0ZWRMYWcgPSAzMyxcbiAgICAgIF9zdGFydFRpbWUgPSBfZ2V0VGltZSgpLFxuICAgICAgX2xhc3RVcGRhdGUgPSBfc3RhcnRUaW1lLFxuICAgICAgX2dhcCA9IDEwMDAgLyAyNDAsXG4gICAgICBfbmV4dFRpbWUgPSBfZ2FwLFxuICAgICAgX2xpc3RlbmVycyA9IFtdLFxuICAgICAgX2lkLFxuICAgICAgX3JlcSxcbiAgICAgIF9yYWYsXG4gICAgICBfc2VsZixcbiAgICAgIF9kZWx0YSxcbiAgICAgIF9pLFxuICAgICAgX3RpY2sgPSBmdW5jdGlvbiBfdGljayh2KSB7XG4gICAgdmFyIGVsYXBzZWQgPSBfZ2V0VGltZSgpIC0gX2xhc3RVcGRhdGUsXG4gICAgICAgIG1hbnVhbCA9IHYgPT09IHRydWUsXG4gICAgICAgIG92ZXJsYXAsXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICB0aW1lLFxuICAgICAgICBmcmFtZTtcblxuICAgIChlbGFwc2VkID4gX2xhZ1RocmVzaG9sZCB8fCBlbGFwc2VkIDwgMCkgJiYgKF9zdGFydFRpbWUgKz0gZWxhcHNlZCAtIF9hZGp1c3RlZExhZyk7XG4gICAgX2xhc3RVcGRhdGUgKz0gZWxhcHNlZDtcbiAgICB0aW1lID0gX2xhc3RVcGRhdGUgLSBfc3RhcnRUaW1lO1xuICAgIG92ZXJsYXAgPSB0aW1lIC0gX25leHRUaW1lO1xuXG4gICAgaWYgKG92ZXJsYXAgPiAwIHx8IG1hbnVhbCkge1xuICAgICAgZnJhbWUgPSArK19zZWxmLmZyYW1lO1xuICAgICAgX2RlbHRhID0gdGltZSAtIF9zZWxmLnRpbWUgKiAxMDAwO1xuICAgICAgX3NlbGYudGltZSA9IHRpbWUgPSB0aW1lIC8gMTAwMDtcbiAgICAgIF9uZXh0VGltZSArPSBvdmVybGFwICsgKG92ZXJsYXAgPj0gX2dhcCA/IDQgOiBfZ2FwIC0gb3ZlcmxhcCk7XG4gICAgICBkaXNwYXRjaCA9IDE7XG4gICAgfVxuXG4gICAgbWFudWFsIHx8IChfaWQgPSBfcmVxKF90aWNrKSk7IC8vbWFrZSBzdXJlIHRoZSByZXF1ZXN0IGlzIG1hZGUgYmVmb3JlIHdlIGRpc3BhdGNoIHRoZSBcInRpY2tcIiBldmVudCBzbyB0aGF0IHRpbWluZyBpcyBtYWludGFpbmVkLiBPdGhlcndpc2UsIGlmIHByb2Nlc3NpbmcgdGhlIFwidGlja1wiIHJlcXVpcmVzIGEgYnVuY2ggb2YgdGltZSAobGlrZSAxNW1zKSBhbmQgd2UncmUgdXNpbmcgYSBzZXRUaW1lb3V0KCkgdGhhdCdzIGJhc2VkIG9uIDE2LjdtcywgaXQnZCB0ZWNobmljYWxseSB0YWtlIDMxLjdtcyBiZXR3ZWVuIGZyYW1lcyBvdGhlcndpc2UuXG5cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGZvciAoX2kgPSAwOyBfaSA8IF9saXN0ZW5lcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIC8vIHVzZSBfaSBhbmQgY2hlY2sgX2xpc3RlbmVycy5sZW5ndGggaW5zdGVhZCBvZiBhIHZhcmlhYmxlIGJlY2F1c2UgYSBsaXN0ZW5lciBjb3VsZCBnZXQgcmVtb3ZlZCBkdXJpbmcgdGhlIGxvb3AsIGFuZCBpZiB0aGF0IGhhcHBlbnMgdG8gYW4gZWxlbWVudCBsZXNzIHRoYW4gdGhlIGN1cnJlbnQgaW5kZXgsIGl0J2QgdGhyb3cgdGhpbmdzIG9mZiBpbiB0aGUgbG9vcC5cbiAgICAgICAgX2xpc3RlbmVyc1tfaV0odGltZSwgX2RlbHRhLCBmcmFtZSwgdik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9zZWxmID0ge1xuICAgIHRpbWU6IDAsXG4gICAgZnJhbWU6IDAsXG4gICAgdGljazogZnVuY3Rpb24gdGljaygpIHtcbiAgICAgIF90aWNrKHRydWUpO1xuICAgIH0sXG4gICAgZGVsdGFSYXRpbzogZnVuY3Rpb24gZGVsdGFSYXRpbyhmcHMpIHtcbiAgICAgIHJldHVybiBfZGVsdGEgLyAoMTAwMCAvIChmcHMgfHwgNjApKTtcbiAgICB9LFxuICAgIHdha2U6IGZ1bmN0aW9uIHdha2UoKSB7XG4gICAgICBpZiAoX2NvcmVSZWFkeSkge1xuICAgICAgICBpZiAoIV9jb3JlSW5pdHRlZCAmJiBfd2luZG93RXhpc3RzKCkpIHtcbiAgICAgICAgICBfd2luID0gX2NvcmVJbml0dGVkID0gd2luZG93O1xuICAgICAgICAgIF9kb2MgPSBfd2luLmRvY3VtZW50IHx8IHt9O1xuICAgICAgICAgIF9nbG9iYWxzLmdzYXAgPSBnc2FwO1xuICAgICAgICAgIChfd2luLmdzYXBWZXJzaW9ucyB8fCAoX3dpbi5nc2FwVmVyc2lvbnMgPSBbXSkpLnB1c2goZ3NhcC52ZXJzaW9uKTtcblxuICAgICAgICAgIF9pbnN0YWxsKF9pbnN0YWxsU2NvcGUgfHwgX3dpbi5HcmVlblNvY2tHbG9iYWxzIHx8ICFfd2luLmdzYXAgJiYgX3dpbiB8fCB7fSk7XG5cbiAgICAgICAgICBfcmVnaXN0ZXJQbHVnaW5RdWV1ZS5mb3JFYWNoKF9jcmVhdGVQbHVnaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgX3JhZiA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgICAgICBfaWQgJiYgX3NlbGYuc2xlZXAoKTtcblxuICAgICAgICBfcmVxID0gX3JhZiB8fCBmdW5jdGlvbiAoZikge1xuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGYsIF9uZXh0VGltZSAtIF9zZWxmLnRpbWUgKiAxMDAwICsgMSB8IDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aWNrZXJBY3RpdmUgPSAxO1xuXG4gICAgICAgIF90aWNrKDIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2xlZXA6IGZ1bmN0aW9uIHNsZWVwKCkge1xuICAgICAgKF9yYWYgPyBjYW5jZWxBbmltYXRpb25GcmFtZSA6IGNsZWFyVGltZW91dCkoX2lkKTtcbiAgICAgIF90aWNrZXJBY3RpdmUgPSAwO1xuICAgICAgX3JlcSA9IF9lbXB0eUZ1bmM7XG4gICAgfSxcbiAgICBsYWdTbW9vdGhpbmc6IGZ1bmN0aW9uIGxhZ1Ntb290aGluZyh0aHJlc2hvbGQsIGFkanVzdGVkTGFnKSB7XG4gICAgICBfbGFnVGhyZXNob2xkID0gdGhyZXNob2xkIHx8IEluZmluaXR5OyAvLyB6ZXJvIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBiYXNpY2FsbHkgdW5saW1pdGVkXG5cbiAgICAgIF9hZGp1c3RlZExhZyA9IE1hdGgubWluKGFkanVzdGVkTGFnIHx8IDMzLCBfbGFnVGhyZXNob2xkKTtcbiAgICB9LFxuICAgIGZwczogZnVuY3Rpb24gZnBzKF9mcHMpIHtcbiAgICAgIF9nYXAgPSAxMDAwIC8gKF9mcHMgfHwgMjQwKTtcbiAgICAgIF9uZXh0VGltZSA9IF9zZWxmLnRpbWUgKiAxMDAwICsgX2dhcDtcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24gYWRkKGNhbGxiYWNrLCBvbmNlLCBwcmlvcml0aXplKSB7XG4gICAgICB2YXIgZnVuYyA9IG9uY2UgPyBmdW5jdGlvbiAodCwgZCwgZiwgdikge1xuICAgICAgICBjYWxsYmFjayh0LCBkLCBmLCB2KTtcblxuICAgICAgICBfc2VsZi5yZW1vdmUoZnVuYyk7XG4gICAgICB9IDogY2FsbGJhY2s7XG5cbiAgICAgIF9zZWxmLnJlbW92ZShjYWxsYmFjayk7XG5cbiAgICAgIF9saXN0ZW5lcnNbcHJpb3JpdGl6ZSA/IFwidW5zaGlmdFwiIDogXCJwdXNoXCJdKGZ1bmMpO1xuXG4gICAgICBfd2FrZSgpO1xuXG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGNhbGxiYWNrLCBpKSB7XG4gICAgICB+KGkgPSBfbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spKSAmJiBfbGlzdGVuZXJzLnNwbGljZShpLCAxKSAmJiBfaSA+PSBpICYmIF9pLS07XG4gICAgfSxcbiAgICBfbGlzdGVuZXJzOiBfbGlzdGVuZXJzXG4gIH07XG4gIHJldHVybiBfc2VsZjtcbn0oKSxcbiAgICBfd2FrZSA9IGZ1bmN0aW9uIF93YWtlKCkge1xuICByZXR1cm4gIV90aWNrZXJBY3RpdmUgJiYgX3RpY2tlci53YWtlKCk7XG59LFxuICAgIC8vYWxzbyBlbnN1cmVzIHRoZSBjb3JlIGNsYXNzZXMgYXJlIGluaXRpYWxpemVkLlxuXG4vKlxuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIEVBU0lOR1xuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qL1xuX2Vhc2VNYXAgPSB7fSxcbiAgICBfY3VzdG9tRWFzZUV4cCA9IC9eW1xcZC5cXC1NXVtcXGQuXFwtLFxcc10vLFxuICAgIF9xdW90ZXNFeHAgPSAvW1wiJ10vZyxcbiAgICBfcGFyc2VPYmplY3RJblN0cmluZyA9IGZ1bmN0aW9uIF9wYXJzZU9iamVjdEluU3RyaW5nKHZhbHVlKSB7XG4gIC8vdGFrZXMgYSBzdHJpbmcgbGlrZSBcInt3aWdnbGVzOjEwLCB0eXBlOmFudGljaXBhdGV9KVwiIGFuZCB0dXJucyBpdCBpbnRvIGEgcmVhbCBvYmplY3QuIE5vdGljZSBpdCBlbmRzIGluIFwiKVwiIGFuZCBpbmNsdWRlcyB0aGUge30gd3JhcHBlcnMuIFRoaXMgaXMgYmVjYXVzZSB3ZSBvbmx5IHVzZSB0aGlzIGZ1bmN0aW9uIGZvciBwYXJzaW5nIGVhc2UgY29uZmlncyBhbmQgcHJpb3JpdGl6ZWQgb3B0aW1pemF0aW9uIHJhdGhlciB0aGFuIHJldXNhYmlsaXR5LlxuICB2YXIgb2JqID0ge30sXG4gICAgICBzcGxpdCA9IHZhbHVlLnN1YnN0cigxLCB2YWx1ZS5sZW5ndGggLSAzKS5zcGxpdChcIjpcIiksXG4gICAgICBrZXkgPSBzcGxpdFswXSxcbiAgICAgIGkgPSAxLFxuICAgICAgbCA9IHNwbGl0Lmxlbmd0aCxcbiAgICAgIGluZGV4LFxuICAgICAgdmFsLFxuICAgICAgcGFyc2VkVmFsO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFsID0gc3BsaXRbaV07XG4gICAgaW5kZXggPSBpICE9PSBsIC0gMSA/IHZhbC5sYXN0SW5kZXhPZihcIixcIikgOiB2YWwubGVuZ3RoO1xuICAgIHBhcnNlZFZhbCA9IHZhbC5zdWJzdHIoMCwgaW5kZXgpO1xuICAgIG9ialtrZXldID0gaXNOYU4ocGFyc2VkVmFsKSA/IHBhcnNlZFZhbC5yZXBsYWNlKF9xdW90ZXNFeHAsIFwiXCIpLnRyaW0oKSA6ICtwYXJzZWRWYWw7XG4gICAga2V5ID0gdmFsLnN1YnN0cihpbmRleCArIDEpLnRyaW0oKTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59LFxuICAgIF92YWx1ZUluUGFyZW50aGVzZXMgPSBmdW5jdGlvbiBfdmFsdWVJblBhcmVudGhlc2VzKHZhbHVlKSB7XG4gIHZhciBvcGVuID0gdmFsdWUuaW5kZXhPZihcIihcIikgKyAxLFxuICAgICAgY2xvc2UgPSB2YWx1ZS5pbmRleE9mKFwiKVwiKSxcbiAgICAgIG5lc3RlZCA9IHZhbHVlLmluZGV4T2YoXCIoXCIsIG9wZW4pO1xuICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKG9wZW4sIH5uZXN0ZWQgJiYgbmVzdGVkIDwgY2xvc2UgPyB2YWx1ZS5pbmRleE9mKFwiKVwiLCBjbG9zZSArIDEpIDogY2xvc2UpO1xufSxcbiAgICBfY29uZmlnRWFzZUZyb21TdHJpbmcgPSBmdW5jdGlvbiBfY29uZmlnRWFzZUZyb21TdHJpbmcobmFtZSkge1xuICAvL25hbWUgY2FuIGJlIGEgc3RyaW5nIGxpa2UgXCJlbGFzdGljLm91dCgxLDAuNSlcIiwgYW5kIHBhc3MgaW4gX2Vhc2VNYXAgYXMgb2JqIGFuZCBpdCdsbCBwYXJzZSBpdCBvdXQgYW5kIGNhbGwgdGhlIGFjdHVhbCBmdW5jdGlvbiBsaWtlIF9lYXNlTWFwLkVsYXN0aWMuZWFzZU91dC5jb25maWcoMSwwLjUpLiBJdCB3aWxsIGFsc28gcGFyc2UgY3VzdG9tIGVhc2Ugc3RyaW5ncyBhcyBsb25nIGFzIEN1c3RvbUVhc2UgaXMgbG9hZGVkIGFuZCByZWdpc3RlcmVkIChpbnRlcm5hbGx5IGFzIF9lYXNlTWFwLl9DRSkuXG4gIHZhciBzcGxpdCA9IChuYW1lICsgXCJcIikuc3BsaXQoXCIoXCIpLFxuICAgICAgZWFzZSA9IF9lYXNlTWFwW3NwbGl0WzBdXTtcbiAgcmV0dXJuIGVhc2UgJiYgc3BsaXQubGVuZ3RoID4gMSAmJiBlYXNlLmNvbmZpZyA/IGVhc2UuY29uZmlnLmFwcGx5KG51bGwsIH5uYW1lLmluZGV4T2YoXCJ7XCIpID8gW19wYXJzZU9iamVjdEluU3RyaW5nKHNwbGl0WzFdKV0gOiBfdmFsdWVJblBhcmVudGhlc2VzKG5hbWUpLnNwbGl0KFwiLFwiKS5tYXAoX251bWVyaWNJZlBvc3NpYmxlKSkgOiBfZWFzZU1hcC5fQ0UgJiYgX2N1c3RvbUVhc2VFeHAudGVzdChuYW1lKSA/IF9lYXNlTWFwLl9DRShcIlwiLCBuYW1lKSA6IGVhc2U7XG59LFxuICAgIF9pbnZlcnRFYXNlID0gZnVuY3Rpb24gX2ludmVydEVhc2UoZWFzZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2UoMSAtIHApO1xuICB9O1xufSxcbiAgICAvLyBhbGxvdyB5b3lvRWFzZSB0byBiZSBzZXQgaW4gY2hpbGRyZW4gYW5kIGhhdmUgdGhvc2UgYWZmZWN0ZWQgd2hlbiB0aGUgcGFyZW50L2FuY2VzdG9yIHRpbWVsaW5lIHlveW9zLlxuX3Byb3BhZ2F0ZVlveW9FYXNlID0gZnVuY3Rpb24gX3Byb3BhZ2F0ZVlveW9FYXNlKHRpbWVsaW5lLCBpc1lveW8pIHtcbiAgdmFyIGNoaWxkID0gdGltZWxpbmUuX2ZpcnN0LFxuICAgICAgZWFzZTtcblxuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUaW1lbGluZSkge1xuICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLCBpc1lveW8pO1xuICAgIH0gZWxzZSBpZiAoY2hpbGQudmFycy55b3lvRWFzZSAmJiAoIWNoaWxkLl95b3lvIHx8ICFjaGlsZC5fcmVwZWF0KSAmJiBjaGlsZC5feW95byAhPT0gaXNZb3lvKSB7XG4gICAgICBpZiAoY2hpbGQudGltZWxpbmUpIHtcbiAgICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLnRpbWVsaW5lLCBpc1lveW8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWFzZSA9IGNoaWxkLl9lYXNlO1xuICAgICAgICBjaGlsZC5fZWFzZSA9IGNoaWxkLl95RWFzZTtcbiAgICAgICAgY2hpbGQuX3lFYXNlID0gZWFzZTtcbiAgICAgICAgY2hpbGQuX3lveW8gPSBpc1lveW87XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgfVxufSxcbiAgICBfcGFyc2VFYXNlID0gZnVuY3Rpb24gX3BhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkge1xuICByZXR1cm4gIWVhc2UgPyBkZWZhdWx0RWFzZSA6IChfaXNGdW5jdGlvbihlYXNlKSA/IGVhc2UgOiBfZWFzZU1hcFtlYXNlXSB8fCBfY29uZmlnRWFzZUZyb21TdHJpbmcoZWFzZSkpIHx8IGRlZmF1bHRFYXNlO1xufSxcbiAgICBfaW5zZXJ0RWFzZSA9IGZ1bmN0aW9uIF9pbnNlcnRFYXNlKG5hbWVzLCBlYXNlSW4sIGVhc2VPdXQsIGVhc2VJbk91dCkge1xuICBpZiAoZWFzZU91dCA9PT0gdm9pZCAwKSB7XG4gICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgICAgcmV0dXJuIDEgLSBlYXNlSW4oMSAtIHApO1xuICAgIH07XG4gIH1cblxuICBpZiAoZWFzZUluT3V0ID09PSB2b2lkIDApIHtcbiAgICBlYXNlSW5PdXQgPSBmdW5jdGlvbiBlYXNlSW5PdXQocCkge1xuICAgICAgcmV0dXJuIHAgPCAuNSA/IGVhc2VJbihwICogMikgLyAyIDogMSAtIGVhc2VJbigoMSAtIHApICogMikgLyAyO1xuICAgIH07XG4gIH1cblxuICB2YXIgZWFzZSA9IHtcbiAgICBlYXNlSW46IGVhc2VJbixcbiAgICBlYXNlT3V0OiBlYXNlT3V0LFxuICAgIGVhc2VJbk91dDogZWFzZUluT3V0XG4gIH0sXG4gICAgICBsb3dlcmNhc2VOYW1lO1xuXG4gIF9mb3JFYWNoTmFtZShuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBfZWFzZU1hcFtuYW1lXSA9IF9nbG9iYWxzW25hbWVdID0gZWFzZTtcbiAgICBfZWFzZU1hcFtsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXSA9IGVhc2VPdXQ7XG5cbiAgICBmb3IgKHZhciBwIGluIGVhc2UpIHtcbiAgICAgIF9lYXNlTWFwW2xvd2VyY2FzZU5hbWUgKyAocCA9PT0gXCJlYXNlSW5cIiA/IFwiLmluXCIgOiBwID09PSBcImVhc2VPdXRcIiA/IFwiLm91dFwiIDogXCIuaW5PdXRcIildID0gX2Vhc2VNYXBbbmFtZSArIFwiLlwiICsgcF0gPSBlYXNlW3BdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVhc2U7XG59LFxuICAgIF9lYXNlSW5PdXRGcm9tT3V0ID0gZnVuY3Rpb24gX2Vhc2VJbk91dEZyb21PdXQoZWFzZU91dCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcCA8IC41ID8gKDEgLSBlYXNlT3V0KDEgLSBwICogMikpIC8gMiA6IC41ICsgZWFzZU91dCgocCAtIC41KSAqIDIpIC8gMjtcbiAgfTtcbn0sXG4gICAgX2NvbmZpZ0VsYXN0aWMgPSBmdW5jdGlvbiBfY29uZmlnRWxhc3RpYyh0eXBlLCBhbXBsaXR1ZGUsIHBlcmlvZCkge1xuICB2YXIgcDEgPSBhbXBsaXR1ZGUgPj0gMSA/IGFtcGxpdHVkZSA6IDEsXG4gICAgICAvL25vdGU6IGlmIGFtcGxpdHVkZSBpcyA8IDEsIHdlIHNpbXBseSBhZGp1c3QgdGhlIHBlcmlvZCBmb3IgYSBtb3JlIG5hdHVyYWwgZmVlbC4gT3RoZXJ3aXNlIHRoZSBtYXRoIGRvZXNuJ3Qgd29yayByaWdodCBhbmQgdGhlIGN1cnZlIHN0YXJ0cyBhdCAxLlxuICBwMiA9IChwZXJpb2QgfHwgKHR5cGUgPyAuMyA6IC40NSkpIC8gKGFtcGxpdHVkZSA8IDEgPyBhbXBsaXR1ZGUgOiAxKSxcbiAgICAgIHAzID0gcDIgLyBfMlBJICogKE1hdGguYXNpbigxIC8gcDEpIHx8IDApLFxuICAgICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgIHJldHVybiBwID09PSAxID8gMSA6IHAxICogTWF0aC5wb3coMiwgLTEwICogcCkgKiBfc2luKChwIC0gcDMpICogcDIpICsgMTtcbiAgfSxcbiAgICAgIGVhc2UgPSB0eXBlID09PSBcIm91dFwiID8gZWFzZU91dCA6IHR5cGUgPT09IFwiaW5cIiA/IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIDEgLSBlYXNlT3V0KDEgLSBwKTtcbiAgfSA6IF9lYXNlSW5PdXRGcm9tT3V0KGVhc2VPdXQpO1xuXG4gIHAyID0gXzJQSSAvIHAyOyAvL3ByZWNhbGN1bGF0ZSB0byBvcHRpbWl6ZVxuXG4gIGVhc2UuY29uZmlnID0gZnVuY3Rpb24gKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gICAgcmV0dXJuIF9jb25maWdFbGFzdGljKHR5cGUsIGFtcGxpdHVkZSwgcGVyaW9kKTtcbiAgfTtcblxuICByZXR1cm4gZWFzZTtcbn0sXG4gICAgX2NvbmZpZ0JhY2sgPSBmdW5jdGlvbiBfY29uZmlnQmFjayh0eXBlLCBvdmVyc2hvb3QpIHtcbiAgaWYgKG92ZXJzaG9vdCA9PT0gdm9pZCAwKSB7XG4gICAgb3ZlcnNob290ID0gMS43MDE1ODtcbiAgfVxuXG4gIHZhciBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgcmV0dXJuIHAgPyAtLXAgKiBwICogKChvdmVyc2hvb3QgKyAxKSAqIHAgKyBvdmVyc2hvb3QpICsgMSA6IDA7XG4gIH0sXG4gICAgICBlYXNlID0gdHlwZSA9PT0gXCJvdXRcIiA/IGVhc2VPdXQgOiB0eXBlID09PSBcImluXCIgPyBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gZWFzZU91dCgxIC0gcCk7XG4gIH0gOiBfZWFzZUluT3V0RnJvbU91dChlYXNlT3V0KTtcblxuICBlYXNlLmNvbmZpZyA9IGZ1bmN0aW9uIChvdmVyc2hvb3QpIHtcbiAgICByZXR1cm4gX2NvbmZpZ0JhY2sodHlwZSwgb3ZlcnNob290KTtcbiAgfTtcblxuICByZXR1cm4gZWFzZTtcbn07IC8vIGEgY2hlYXBlciAoa2IgYW5kIGNwdSkgYnV0IG1vcmUgbWlsZCB3YXkgdG8gZ2V0IGEgcGFyYW1ldGVyaXplZCB3ZWlnaHRlZCBlYXNlIGJ5IGZlZWRpbmcgaW4gYSB2YWx1ZSBiZXR3ZWVuIC0xIChlYXNlSW4pIGFuZCAxIChlYXNlT3V0KSB3aGVyZSAwIGlzIGxpbmVhci5cbi8vIF93ZWlnaHRlZEVhc2UgPSByYXRpbyA9PiB7XG4vLyBcdGxldCB5ID0gMC41ICsgcmF0aW8gLyAyO1xuLy8gXHRyZXR1cm4gcCA9PiAoMiAqICgxIC0gcCkgKiBwICogeSArIHAgKiBwKTtcbi8vIH0sXG4vLyBhIHN0cm9uZ2VyIChidXQgbW9yZSBleHBlbnNpdmUga2IvY3B1KSBwYXJhbWV0ZXJpemVkIHdlaWdodGVkIGVhc2UgdGhhdCBsZXRzIHlvdSBmZWVkIGluIGEgdmFsdWUgYmV0d2VlbiAtMSAoZWFzZUluKSBhbmQgMSAoZWFzZU91dCkgd2hlcmUgMCBpcyBsaW5lYXIuXG4vLyBfd2VpZ2h0ZWRFYXNlU3Ryb25nID0gcmF0aW8gPT4ge1xuLy8gXHRyYXRpbyA9IC41ICsgcmF0aW8gLyAyO1xuLy8gXHRsZXQgbyA9IDEgLyAzICogKHJhdGlvIDwgLjUgPyByYXRpbyA6IDEgLSByYXRpbyksXG4vLyBcdFx0YiA9IHJhdGlvIC0gbyxcbi8vIFx0XHRjID0gcmF0aW8gKyBvO1xuLy8gXHRyZXR1cm4gcCA9PiBwID09PSAxID8gcCA6IDMgKiBiICogKDEgLSBwKSAqICgxIC0gcCkgKiBwICsgMyAqIGMgKiAoMSAtIHApICogcCAqIHAgKyBwICogcCAqIHA7XG4vLyB9O1xuXG5cbl9mb3JFYWNoTmFtZShcIkxpbmVhcixRdWFkLEN1YmljLFF1YXJ0LFF1aW50LFN0cm9uZ1wiLCBmdW5jdGlvbiAobmFtZSwgaSkge1xuICB2YXIgcG93ZXIgPSBpIDwgNSA/IGkgKyAxIDogaTtcblxuICBfaW5zZXJ0RWFzZShuYW1lICsgXCIsUG93ZXJcIiArIChwb3dlciAtIDEpLCBpID8gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gTWF0aC5wb3cocCwgcG93ZXIpO1xuICB9IDogZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcDtcbiAgfSwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIE1hdGgucG93KDEgLSBwLCBwb3dlcik7XG4gIH0sIGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAgPCAuNSA/IE1hdGgucG93KHAgKiAyLCBwb3dlcikgLyAyIDogMSAtIE1hdGgucG93KCgxIC0gcCkgKiAyLCBwb3dlcikgLyAyO1xuICB9KTtcbn0pO1xuXG5fZWFzZU1hcC5MaW5lYXIuZWFzZU5vbmUgPSBfZWFzZU1hcC5ub25lID0gX2Vhc2VNYXAuTGluZWFyLmVhc2VJbjtcblxuX2luc2VydEVhc2UoXCJFbGFzdGljXCIsIF9jb25maWdFbGFzdGljKFwiaW5cIiksIF9jb25maWdFbGFzdGljKFwib3V0XCIpLCBfY29uZmlnRWxhc3RpYygpKTtcblxuKGZ1bmN0aW9uIChuLCBjKSB7XG4gIHZhciBuMSA9IDEgLyBjLFxuICAgICAgbjIgPSAyICogbjEsXG4gICAgICBuMyA9IDIuNSAqIG4xLFxuICAgICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgIHJldHVybiBwIDwgbjEgPyBuICogcCAqIHAgOiBwIDwgbjIgPyBuICogTWF0aC5wb3cocCAtIDEuNSAvIGMsIDIpICsgLjc1IDogcCA8IG4zID8gbiAqIChwIC09IDIuMjUgLyBjKSAqIHAgKyAuOTM3NSA6IG4gKiBNYXRoLnBvdyhwIC0gMi42MjUgLyBjLCAyKSArIC45ODQzNzU7XG4gIH07XG5cbiAgX2luc2VydEVhc2UoXCJCb3VuY2VcIiwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2VPdXQoMSAtIHApO1xuICB9LCBlYXNlT3V0KTtcbn0pKDcuNTYyNSwgMi43NSk7XG5cbl9pbnNlcnRFYXNlKFwiRXhwb1wiLCBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gcCA/IE1hdGgucG93KDIsIDEwICogKHAgLSAxKSkgOiAwO1xufSk7XG5cbl9pbnNlcnRFYXNlKFwiQ2lyY1wiLCBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gLShfc3FydCgxIC0gcCAqIHApIC0gMSk7XG59KTtcblxuX2luc2VydEVhc2UoXCJTaW5lXCIsIGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBwID09PSAxID8gMSA6IC1fY29zKHAgKiBfSEFMRl9QSSkgKyAxO1xufSk7XG5cbl9pbnNlcnRFYXNlKFwiQmFja1wiLCBfY29uZmlnQmFjayhcImluXCIpLCBfY29uZmlnQmFjayhcIm91dFwiKSwgX2NvbmZpZ0JhY2soKSk7XG5cbl9lYXNlTWFwLlN0ZXBwZWRFYXNlID0gX2Vhc2VNYXAuc3RlcHMgPSBfZ2xvYmFscy5TdGVwcGVkRWFzZSA9IHtcbiAgY29uZmlnOiBmdW5jdGlvbiBjb25maWcoc3RlcHMsIGltbWVkaWF0ZVN0YXJ0KSB7XG4gICAgaWYgKHN0ZXBzID09PSB2b2lkIDApIHtcbiAgICAgIHN0ZXBzID0gMTtcbiAgICB9XG5cbiAgICB2YXIgcDEgPSAxIC8gc3RlcHMsXG4gICAgICAgIHAyID0gc3RlcHMgKyAoaW1tZWRpYXRlU3RhcnQgPyAwIDogMSksXG4gICAgICAgIHAzID0gaW1tZWRpYXRlU3RhcnQgPyAxIDogMCxcbiAgICAgICAgbWF4ID0gMSAtIF90aW55TnVtO1xuICAgIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuICgocDIgKiBfY2xhbXAoMCwgbWF4LCBwKSB8IDApICsgcDMpICogcDE7XG4gICAgfTtcbiAgfVxufTtcbl9kZWZhdWx0cy5lYXNlID0gX2Vhc2VNYXBbXCJxdWFkLm91dFwiXTtcblxuX2ZvckVhY2hOYW1lKFwib25Db21wbGV0ZSxvblVwZGF0ZSxvblN0YXJ0LG9uUmVwZWF0LG9uUmV2ZXJzZUNvbXBsZXRlLG9uSW50ZXJydXB0XCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfY2FsbGJhY2tOYW1lcyArPSBuYW1lICsgXCIsXCIgKyBuYW1lICsgXCJQYXJhbXMsXCI7XG59KTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ0FDSEVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5leHBvcnQgdmFyIEdTQ2FjaGUgPSBmdW5jdGlvbiBHU0NhY2hlKHRhcmdldCwgaGFybmVzcykge1xuICB0aGlzLmlkID0gX2dzSUQrKztcbiAgdGFyZ2V0Ll9nc2FwID0gdGhpcztcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIHRoaXMuaGFybmVzcyA9IGhhcm5lc3M7XG4gIHRoaXMuZ2V0ID0gaGFybmVzcyA/IGhhcm5lc3MuZ2V0IDogX2dldFByb3BlcnR5O1xuICB0aGlzLnNldCA9IGhhcm5lc3MgPyBoYXJuZXNzLmdldFNldHRlciA6IF9nZXRTZXR0ZXI7XG59O1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBBTklNQVRJT05cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuZXhwb3J0IHZhciBBbmltYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBbmltYXRpb24odmFycykge1xuICAgIHRoaXMudmFycyA9IHZhcnM7XG4gICAgdGhpcy5fZGVsYXkgPSArdmFycy5kZWxheSB8fCAwO1xuXG4gICAgaWYgKHRoaXMuX3JlcGVhdCA9IHZhcnMucmVwZWF0ID09PSBJbmZpbml0eSA/IC0yIDogdmFycy5yZXBlYXQgfHwgMCkge1xuICAgICAgLy8gVE9ETzogcmVwZWF0OiBJbmZpbml0eSBvbiBhIHRpbWVsaW5lJ3MgY2hpbGRyZW4gbXVzdCBmbGFnIHRoYXQgdGltZWxpbmUgaW50ZXJuYWxseSBhbmQgYWZmZWN0IGl0cyB0b3RhbER1cmF0aW9uLCBvdGhlcndpc2UgaXQnbGwgc3RvcCBpbiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uIHdoZW4gcmVhY2hpbmcgdGhlIHN0YXJ0LlxuICAgICAgdGhpcy5fckRlbGF5ID0gdmFycy5yZXBlYXREZWxheSB8fCAwO1xuICAgICAgdGhpcy5feW95byA9ICEhdmFycy55b3lvIHx8ICEhdmFycy55b3lvRWFzZTtcbiAgICB9XG5cbiAgICB0aGlzLl90cyA9IDE7XG5cbiAgICBfc2V0RHVyYXRpb24odGhpcywgK3ZhcnMuZHVyYXRpb24sIDEsIDEpO1xuXG4gICAgdGhpcy5kYXRhID0gdmFycy5kYXRhO1xuXG4gICAgaWYgKF9jb250ZXh0KSB7XG4gICAgICB0aGlzLl9jdHggPSBfY29udGV4dDtcblxuICAgICAgX2NvbnRleHQuZGF0YS5wdXNoKHRoaXMpO1xuICAgIH1cblxuICAgIF90aWNrZXJBY3RpdmUgfHwgX3RpY2tlci53YWtlKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVsYXkgPSBmdW5jdGlvbiBkZWxheSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgJiYgdGhpcy5zdGFydFRpbWUodGhpcy5fc3RhcnQgKyB2YWx1ZSAtIHRoaXMuX2RlbGF5KTtcbiAgICAgIHRoaXMuX2RlbGF5ID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZGVsYXk7XG4gIH07XG5cbiAgX3Byb3RvLmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxEdXJhdGlvbih0aGlzLl9yZXBlYXQgPiAwID8gdmFsdWUgKyAodmFsdWUgKyB0aGlzLl9yRGVsYXkpICogdGhpcy5fcmVwZWF0IDogdmFsdWUpIDogdGhpcy50b3RhbER1cmF0aW9uKCkgJiYgdGhpcy5fZHVyO1xuICB9O1xuXG4gIF9wcm90by50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24gdG90YWxEdXJhdGlvbih2YWx1ZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3REdXI7XG4gICAgfVxuXG4gICAgdGhpcy5fZGlydHkgPSAwO1xuICAgIHJldHVybiBfc2V0RHVyYXRpb24odGhpcywgdGhpcy5fcmVwZWF0IDwgMCA/IHZhbHVlIDogKHZhbHVlIC0gdGhpcy5fcmVwZWF0ICogdGhpcy5fckRlbGF5KSAvICh0aGlzLl9yZXBlYXQgKyAxKSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvdGFsVGltZSA9IGZ1bmN0aW9uIHRvdGFsVGltZShfdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIF93YWtlKCk7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90VGltZTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy5fZHA7XG5cbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyAmJiB0aGlzLl90cykge1xuICAgICAgX2FsaWduUGxheWhlYWQodGhpcywgX3RvdGFsVGltZSk7XG5cbiAgICAgICFwYXJlbnQuX2RwIHx8IHBhcmVudC5wYXJlbnQgfHwgX3Bvc3RBZGRDaGVja3MocGFyZW50LCB0aGlzKTsgLy8gZWRnZSBjYXNlOiBpZiB0aGlzIGlzIGEgY2hpbGQgb2YgYSB0aW1lbGluZSB0aGF0IGFscmVhZHkgY29tcGxldGVkLCBmb3IgZXhhbXBsZSwgd2UgbXVzdCByZS1hY3RpdmF0ZSB0aGUgcGFyZW50LlxuICAgICAgLy9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3IgdGltZWxpbmVzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZCwgd2Ugc2hvdWxkIHJlc2V0IHRoZWlyIHRvdGFsVGltZSgpIHdoaWNoIHdpbGwgYWxzbyBlbnN1cmUgdGhhdCB0aGV5J3JlIGxpbmVkIHVwIHByb3Blcmx5IGFuZCBlbmFibGVkLiBTa2lwIGZvciBhbmltYXRpb25zIHRoYXQgYXJlIG9uIHRoZSByb290ICh3YXN0ZWZ1bCkuIEV4YW1wbGU6IGEgVGltZWxpbmVMaXRlLmV4cG9ydFJvb3QoKSBpcyBwZXJmb3JtZWQgd2hlbiB0aGVyZSdzIGEgcGF1c2VkIHR3ZWVuIG9uIHRoZSByb290LCB0aGUgZXhwb3J0IHdpbGwgbm90IGNvbXBsZXRlIHVudGlsIHRoYXQgdHdlZW4gaXMgdW5wYXVzZWQsIGJ1dCBpbWFnaW5lIGEgY2hpbGQgZ2V0cyByZXN0YXJ0ZWQgbGF0ZXIsIGFmdGVyIGFsbCBbdW5wYXVzZWRdIHR3ZWVucyBoYXZlIGNvbXBsZXRlZC4gVGhlIHN0YXJ0IG9mIHRoYXQgY2hpbGQgd291bGQgZ2V0IHB1c2hlZCBvdXQsIGJ1dCBvbmUgb2YgdGhlIGFuY2VzdG9ycyBtYXkgaGF2ZSBjb21wbGV0ZWQuXG5cbiAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LnBhcmVudC5fdGltZSAhPT0gcGFyZW50Ll9zdGFydCArIChwYXJlbnQuX3RzID49IDAgPyBwYXJlbnQuX3RUaW1lIC8gcGFyZW50Ll90cyA6IChwYXJlbnQudG90YWxEdXJhdGlvbigpIC0gcGFyZW50Ll90VGltZSkgLyAtcGFyZW50Ll90cykpIHtcbiAgICAgICAgICBwYXJlbnQudG90YWxUaW1lKHBhcmVudC5fdFRpbWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnBhcmVudCAmJiB0aGlzLl9kcC5hdXRvUmVtb3ZlQ2hpbGRyZW4gJiYgKHRoaXMuX3RzID4gMCAmJiBfdG90YWxUaW1lIDwgdGhpcy5fdER1ciB8fCB0aGlzLl90cyA8IDAgJiYgX3RvdGFsVGltZSA+IDAgfHwgIXRoaXMuX3REdXIgJiYgIV90b3RhbFRpbWUpKSB7XG4gICAgICAgIC8vaWYgdGhlIGFuaW1hdGlvbiBkb2Vzbid0IGhhdmUgYSBwYXJlbnQsIHB1dCBpdCBiYWNrIGludG8gaXRzIGxhc3QgcGFyZW50IChyZWNvcmRlZCBhcyBfZHAgZm9yIGV4YWN0bHkgY2FzZXMgbGlrZSB0aGlzKS4gTGltaXQgdG8gcGFyZW50cyB3aXRoIGF1dG9SZW1vdmVDaGlsZHJlbiAobGlrZSBnbG9iYWxUaW1lbGluZSkgc28gdGhhdCBpZiB0aGUgdXNlciBtYW51YWxseSByZW1vdmVzIGFuIGFuaW1hdGlvbiBmcm9tIGEgdGltZWxpbmUgYW5kIHRoZW4gYWx0ZXJzIGl0cyBwbGF5aGVhZCwgaXQgZG9lc24ndCBnZXQgYWRkZWQgYmFjayBpbi5cbiAgICAgICAgX2FkZFRvVGltZWxpbmUodGhpcy5fZHAsIHRoaXMsIHRoaXMuX3N0YXJ0IC0gdGhpcy5fZGVsYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl90VGltZSAhPT0gX3RvdGFsVGltZSB8fCAhdGhpcy5fZHVyICYmICFzdXBwcmVzc0V2ZW50cyB8fCB0aGlzLl9pbml0dGVkICYmIE1hdGguYWJzKHRoaXMuX3pUaW1lKSA9PT0gX3RpbnlOdW0gfHwgIV90b3RhbFRpbWUgJiYgIXRoaXMuX2luaXR0ZWQgJiYgKHRoaXMuYWRkIHx8IHRoaXMuX3B0TG9va3VwKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIF9wdExvb2t1cCBvbiBhIFR3ZWVuIGluc3RhbmNlIHRvIGVuc3VyZSBpdCBoYXMgYWN0dWFsbHkgZmluaXNoZWQgYmVpbmcgaW5zdGFudGlhdGVkLCBvdGhlcndpc2UgaWYgdGhpcy5yZXZlcnNlKCkgZ2V0cyBjYWxsZWQgaW4gdGhlIEFuaW1hdGlvbiBjb25zdHJ1Y3RvciwgaXQgY291bGQgdHJpZ2dlciBhIHJlbmRlcigpIGhlcmUgZXZlbiB0aG91Z2ggdGhlIF90YXJnZXRzIHdlcmVuJ3QgcG9wdWxhdGVkLCB0aHVzIHdoZW4gX2luaXQoKSBpcyBjYWxsZWQgdGhlcmUgd29uJ3QgYmUgYW55IFByb3BUd2VlbnMgKGl0J2xsIGFjdCBsaWtlIHRoZSB0d2VlbiBpcyBub24tZnVuY3Rpb25hbClcbiAgICAgIHRoaXMuX3RzIHx8ICh0aGlzLl9wVGltZSA9IF90b3RhbFRpbWUpOyAvLyBvdGhlcndpc2UsIGlmIGFuIGFuaW1hdGlvbiBpcyBwYXVzZWQsIHRoZW4gdGhlIHBsYXloZWFkIGlzIG1vdmVkIGJhY2sgdG8gemVybywgdGhlbiByZXN1bWVkLCBpdCdkIHJldmVydCBiYWNrIHRvIHRoZSBvcmlnaW5hbCB0aW1lIGF0IHRoZSBwYXVzZVxuICAgICAgLy9pZiAoIXRoaXMuX2xvY2spIHsgLy8gYXZvaWQgZW5kbGVzcyByZWN1cnNpb24gKG5vdCBzdXJlIHdlIG5lZWQgdGhpcyB5ZXQgb3IgaWYgaXQncyB3b3J0aCB0aGUgcGVyZm9ybWFuY2UgaGl0KVxuICAgICAgLy8gICB0aGlzLl9sb2NrID0gMTtcblxuICAgICAgX2xhenlTYWZlUmVuZGVyKHRoaXMsIF90b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzKTsgLy8gICB0aGlzLl9sb2NrID0gMDtcbiAgICAgIC8vfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnRpbWUgPSBmdW5jdGlvbiB0aW1lKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUoTWF0aC5taW4odGhpcy50b3RhbER1cmF0aW9uKCksIHZhbHVlICsgX2VsYXBzZWRDeWNsZUR1cmF0aW9uKHRoaXMpKSAlICh0aGlzLl9kdXIgKyB0aGlzLl9yRGVsYXkpIHx8ICh2YWx1ZSA/IHRoaXMuX2R1ciA6IDApLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLl90aW1lOyAvLyBub3RlOiBpZiB0aGUgbW9kdWx1cyByZXN1bHRzIGluIDAsIHRoZSBwbGF5aGVhZCBjb3VsZCBiZSBleGFjdGx5IGF0IHRoZSBlbmQgb3IgdGhlIGJlZ2lubmluZywgYW5kIHdlIGFsd2F5cyBkZWZlciB0byB0aGUgRU5EIHdpdGggYSBub24temVybyB2YWx1ZSwgb3RoZXJ3aXNlIGlmIHlvdSBzZXQgdGhlIHRpbWUoKSB0byB0aGUgdmVyeSBlbmQgKGR1cmF0aW9uKCkpLCBpdCB3b3VsZCByZW5kZXIgYXQgdGhlIFNUQVJUIVxuICB9O1xuXG4gIF9wcm90by50b3RhbFByb2dyZXNzID0gZnVuY3Rpb24gdG90YWxQcm9ncmVzcyh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKHRoaXMudG90YWxEdXJhdGlvbigpICogdmFsdWUsIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMudG90YWxEdXJhdGlvbigpID8gTWF0aC5taW4oMSwgdGhpcy5fdFRpbWUgLyB0aGlzLl90RHVyKSA6IHRoaXMucmF3VGltZSgpID4gMCA/IDEgOiAwO1xuICB9O1xuXG4gIF9wcm90by5wcm9ncmVzcyA9IGZ1bmN0aW9uIHByb2dyZXNzKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUodGhpcy5kdXJhdGlvbigpICogKHRoaXMuX3lveW8gJiYgISh0aGlzLml0ZXJhdGlvbigpICYgMSkgPyAxIC0gdmFsdWUgOiB2YWx1ZSkgKyBfZWxhcHNlZEN5Y2xlRHVyYXRpb24odGhpcyksIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMuZHVyYXRpb24oKSA/IE1hdGgubWluKDEsIHRoaXMuX3RpbWUgLyB0aGlzLl9kdXIpIDogdGhpcy5yYXdUaW1lKCkgPiAwID8gMSA6IDA7XG4gIH07XG5cbiAgX3Byb3RvLml0ZXJhdGlvbiA9IGZ1bmN0aW9uIGl0ZXJhdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICB2YXIgY3ljbGVEdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKSArIHRoaXMuX3JEZWxheTtcblxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUodGhpcy5fdGltZSArICh2YWx1ZSAtIDEpICogY3ljbGVEdXJhdGlvbiwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy5fcmVwZWF0ID8gX2FuaW1hdGlvbkN5Y2xlKHRoaXMuX3RUaW1lLCBjeWNsZUR1cmF0aW9uKSArIDEgOiAxO1xuICB9IC8vIHBvdGVudGlhbCBmdXR1cmUgYWRkaXRpb246XG4gIC8vIGlzUGxheWluZ0JhY2t3YXJkcygpIHtcbiAgLy8gXHRsZXQgYW5pbWF0aW9uID0gdGhpcyxcbiAgLy8gXHRcdG9yaWVudGF0aW9uID0gMTsgLy8gMSA9IGZvcndhcmQsIC0xID0gYmFja3dhcmRcbiAgLy8gXHR3aGlsZSAoYW5pbWF0aW9uKSB7XG4gIC8vIFx0XHRvcmllbnRhdGlvbiAqPSBhbmltYXRpb24ucmV2ZXJzZWQoKSB8fCAoYW5pbWF0aW9uLnJlcGVhdCgpICYmICEoYW5pbWF0aW9uLml0ZXJhdGlvbigpICYgMSkpID8gLTEgOiAxO1xuICAvLyBcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uLnBhcmVudDtcbiAgLy8gXHR9XG4gIC8vIFx0cmV0dXJuIG9yaWVudGF0aW9uIDwgMDtcbiAgLy8gfVxuICA7XG5cbiAgX3Byb3RvLnRpbWVTY2FsZSA9IGZ1bmN0aW9uIHRpbWVTY2FsZSh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydHMgPT09IC1fdGlueU51bSA/IDAgOiB0aGlzLl9ydHM7IC8vIHJlY29yZGVkIHRpbWVTY2FsZS4gU3BlY2lhbCBjYXNlOiBpZiBzb21lb25lIGNhbGxzIHJldmVyc2UoKSBvbiBhbiBhbmltYXRpb24gd2l0aCB0aW1lU2NhbGUgb2YgMCwgd2UgYXNzaWduIGl0IC1fdGlueU51bSB0byByZW1lbWJlciBpdCdzIHJldmVyc2VkLlxuICAgIH1cblxuICAgIGlmICh0aGlzLl9ydHMgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgdFRpbWUgPSB0aGlzLnBhcmVudCAmJiB0aGlzLl90cyA/IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRoaXMucGFyZW50Ll90aW1lLCB0aGlzKSA6IHRoaXMuX3RUaW1lOyAvLyBtYWtlIHN1cmUgdG8gZG8gdGhlIHBhcmVudFRvQ2hpbGRUb3RhbFRpbWUoKSBCRUZPUkUgc2V0dGluZyB0aGUgbmV3IF90cyBiZWNhdXNlIHRoZSBvbGQgb25lIG11c3QgYmUgdXNlZCBpbiB0aGF0IGNhbGN1bGF0aW9uLlxuICAgIC8vIGZ1dHVyZSBhZGRpdGlvbj8gVXAgc2lkZTogZmFzdCBhbmQgbWluaW1hbCBmaWxlIHNpemUuIERvd24gc2lkZTogb25seSB3b3JrcyBvbiB0aGlzIGFuaW1hdGlvbjsgaWYgYSB0aW1lbGluZSBpcyByZXZlcnNlZCwgZm9yIGV4YW1wbGUsIGl0cyBjaGlsZHJlbnMnIG9uUmV2ZXJzZSB3b3VsZG4ndCBnZXQgY2FsbGVkLlxuICAgIC8vKCt2YWx1ZSA8IDAgJiYgdGhpcy5fcnRzID49IDApICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uUmV2ZXJzZVwiLCB0cnVlKTtcbiAgICAvLyBwcmlvcml0aXplIHJlbmRlcmluZyB3aGVyZSB0aGUgcGFyZW50J3MgcGxheWhlYWQgbGluZXMgdXAgaW5zdGVhZCBvZiB0aGlzLl90VGltZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIGEgdHdlZW4gdGhhdCdzIGFuaW1hdGluZyBhbm90aGVyIHR3ZWVuJ3MgdGltZVNjYWxlIGluIHRoZSBzYW1lIHJlbmRlcmluZyBsb29wIChzYW1lIHBhcmVudCksIHRodXMgaWYgdGhlIHRpbWVTY2FsZSB0d2VlbiByZW5kZXJzIGZpcnN0LCBpdCB3b3VsZCBhbHRlciBfc3RhcnQgQkVGT1JFIF90VGltZSB3YXMgc2V0IG9uIHRoYXQgdGljayAoaW4gdGhlIHJlbmRlcmluZyBsb29wKSwgZWZmZWN0aXZlbHkgZnJlZXppbmcgaXQgdW50aWwgdGhlIHRpbWVTY2FsZSB0d2VlbiBmaW5pc2hlcy5cblxuICAgIHRoaXMuX3J0cyA9ICt2YWx1ZSB8fCAwO1xuICAgIHRoaXMuX3RzID0gdGhpcy5fcHMgfHwgdmFsdWUgPT09IC1fdGlueU51bSA/IDAgOiB0aGlzLl9ydHM7IC8vIF90cyBpcyB0aGUgZnVuY3Rpb25hbCB0aW1lU2NhbGUgd2hpY2ggd291bGQgYmUgMCBpZiB0aGUgYW5pbWF0aW9uIGlzIHBhdXNlZC5cblxuICAgIHRoaXMudG90YWxUaW1lKF9jbGFtcCgtTWF0aC5hYnModGhpcy5fZGVsYXkpLCB0aGlzLl90RHVyLCB0VGltZSksIHN1cHByZXNzRXZlbnRzICE9PSBmYWxzZSk7XG5cbiAgICBfc2V0RW5kKHRoaXMpOyAvLyBpZiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgd2FzIGZhbHNlLCB0aGUgZW5kIHRpbWUgZGlkbid0IGdldCB1cGRhdGVkIGluIHRoZSBfYWxpZ25QbGF5aGVhZCgpIG1ldGhvZCwgc28gZG8gaXQgaGVyZS5cblxuXG4gICAgcmV0dXJuIF9yZWNhY2hlQW5jZXN0b3JzKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5wYXVzZWQgPSBmdW5jdGlvbiBwYXVzZWQodmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcHMgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9wcyA9IHZhbHVlO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcFRpbWUgPSB0aGlzLl90VGltZSB8fCBNYXRoLm1heCgtdGhpcy5fZGVsYXksIHRoaXMucmF3VGltZSgpKTsgLy8gaWYgdGhlIHBhdXNlIG9jY3VycyBkdXJpbmcgdGhlIGRlbGF5IHBoYXNlLCBtYWtlIHN1cmUgdGhhdCdzIGZhY3RvcmVkIGluIHdoZW4gcmVzdW1pbmcuXG5cbiAgICAgICAgdGhpcy5fdHMgPSB0aGlzLl9hY3QgPSAwOyAvLyBfdHMgaXMgdGhlIGZ1bmN0aW9uYWwgdGltZVNjYWxlLCBzbyBhIHBhdXNlZCB0d2VlbiB3b3VsZCBlZmZlY3RpdmVseSBoYXZlIGEgdGltZVNjYWxlIG9mIDAuIFdlIHJlY29yZCB0aGUgXCJyZWFsXCIgdGltZVNjYWxlIGFzIF9ydHMgKHJlY29yZGVkIHRpbWUgc2NhbGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfd2FrZSgpO1xuXG4gICAgICAgIHRoaXMuX3RzID0gdGhpcy5fcnRzOyAvL29ubHkgZGVmZXIgdG8gX3BUaW1lIChwYXVzZVRpbWUpIGlmIHRUaW1lIGlzIHplcm8uIFJlbWVtYmVyLCBzb21lb25lIGNvdWxkIHBhdXNlKCkgYW4gYW5pbWF0aW9uLCB0aGVuIHNjcnViIHRoZSBwbGF5aGVhZCBhbmQgcmVzdW1lKCkuIElmIHRoZSBwYXJlbnQgZG9lc24ndCBoYXZlIHNtb290aENoaWxkVGltaW5nLCB3ZSByZW5kZXIgYXQgdGhlIHJhd1RpbWUoKSBiZWNhdXNlIHRoZSBzdGFydFRpbWUgd29uJ3QgZ2V0IHVwZGF0ZWQuXG5cbiAgICAgICAgdGhpcy50b3RhbFRpbWUodGhpcy5wYXJlbnQgJiYgIXRoaXMucGFyZW50LnNtb290aENoaWxkVGltaW5nID8gdGhpcy5yYXdUaW1lKCkgOiB0aGlzLl90VGltZSB8fCB0aGlzLl9wVGltZSwgdGhpcy5wcm9ncmVzcygpID09PSAxICYmIE1hdGguYWJzKHRoaXMuX3pUaW1lKSAhPT0gX3RpbnlOdW0gJiYgKHRoaXMuX3RUaW1lIC09IF90aW55TnVtKSk7IC8vIGVkZ2UgY2FzZTogYW5pbWF0aW9uLnByb2dyZXNzKDEpLnBhdXNlKCkucGxheSgpIHdvdWxkbid0IHJlbmRlciBhZ2FpbiBiZWNhdXNlIHRoZSBwbGF5aGVhZCBpcyBhbHJlYWR5IGF0IHRoZSBlbmQsIGJ1dCB0aGUgY2FsbCB0byB0b3RhbFRpbWUoKSBiZWxvdyB3aWxsIGFkZCBpdCBiYWNrIHRvIGl0cyBwYXJlbnQuLi5hbmQgbm90IHJlbW92ZSBpdCBhZ2FpbiAoc2luY2UgcmVtb3Zpbmcgb25seSBoYXBwZW5zIHVwb24gcmVuZGVyaW5nIGF0IGEgbmV3IHRpbWUpLiBPZmZzZXR0aW5nIHRoZSBfdFRpbWUgc2xpZ2h0bHkgaXMgZG9uZSBzaW1wbHkgdG8gY2F1c2UgdGhlIGZpbmFsIHJlbmRlciBpbiB0b3RhbFRpbWUoKSB0aGF0J2xsIHBvcCBpdCBvZmYgaXRzIHRpbWVsaW5lIChpZiBhdXRvUmVtb3ZlQ2hpbGRyZW4gaXMgdHJ1ZSwgb2YgY291cnNlKS4gQ2hlY2sgdG8gbWFrZSBzdXJlIF96VGltZSBpc24ndCAtX3RpbnlOdW0gdG8gYXZvaWQgYW4gZWRnZSBjYXNlIHdoZXJlIHRoZSBwbGF5aGVhZCBpcyBwdXNoZWQgdG8gdGhlIGVuZCBidXQgSU5TSURFIGEgdHdlZW4vY2FsbGJhY2ssIHRoZSB0aW1lbGluZSBpdHNlbGYgaXMgcGF1c2VkIHRodXMgaGFsdGluZyByZW5kZXJpbmcgYW5kIGxlYXZpbmcgYSBmZXcgdW5yZW5kZXJlZC4gV2hlbiByZXN1bWluZywgaXQgd291bGRuJ3QgcmVuZGVyIHRob3NlIG90aGVyd2lzZS5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRUaW1lID0gZnVuY3Rpb24gc3RhcnRUaW1lKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3N0YXJ0ID0gdmFsdWU7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHA7XG4gICAgICBwYXJlbnQgJiYgKHBhcmVudC5fc29ydCB8fCAhdGhpcy5wYXJlbnQpICYmIF9hZGRUb1RpbWVsaW5lKHBhcmVudCwgdGhpcywgdmFsdWUgLSB0aGlzLl9kZWxheSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RhcnQ7XG4gIH07XG5cbiAgX3Byb3RvLmVuZFRpbWUgPSBmdW5jdGlvbiBlbmRUaW1lKGluY2x1ZGVSZXBlYXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0ICsgKF9pc05vdEZhbHNlKGluY2x1ZGVSZXBlYXRzKSA/IHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy5kdXJhdGlvbigpKSAvIE1hdGguYWJzKHRoaXMuX3RzIHx8IDEpO1xuICB9O1xuXG4gIF9wcm90by5yYXdUaW1lID0gZnVuY3Rpb24gcmF3VGltZSh3cmFwUmVwZWF0cykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLl9kcDsgLy8gX2RwID0gZGV0YWNoZWQgcGFyZW50XG5cbiAgICByZXR1cm4gIXBhcmVudCA/IHRoaXMuX3RUaW1lIDogd3JhcFJlcGVhdHMgJiYgKCF0aGlzLl90cyB8fCB0aGlzLl9yZXBlYXQgJiYgdGhpcy5fdGltZSAmJiB0aGlzLnRvdGFsUHJvZ3Jlc3MoKSA8IDEpID8gdGhpcy5fdFRpbWUgJSAodGhpcy5fZHVyICsgdGhpcy5fckRlbGF5KSA6ICF0aGlzLl90cyA/IHRoaXMuX3RUaW1lIDogX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUocGFyZW50LnJhd1RpbWUod3JhcFJlcGVhdHMpLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucmV2ZXJ0ID0gZnVuY3Rpb24gcmV2ZXJ0KGNvbmZpZykge1xuICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkge1xuICAgICAgY29uZmlnID0gX3JldmVydENvbmZpZztcbiAgICB9XG5cbiAgICB2YXIgcHJldklzUmV2ZXJ0aW5nID0gX3JldmVydGluZztcbiAgICBfcmV2ZXJ0aW5nID0gY29uZmlnO1xuXG4gICAgaWYgKHRoaXMuX2luaXR0ZWQgfHwgdGhpcy5fc3RhcnRBdCkge1xuICAgICAgdGhpcy50aW1lbGluZSAmJiB0aGlzLnRpbWVsaW5lLnJldmVydChjb25maWcpO1xuICAgICAgdGhpcy50b3RhbFRpbWUoLTAuMDEsIGNvbmZpZy5zdXBwcmVzc0V2ZW50cyk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhICE9PSBcIm5lc3RlZFwiICYmIGNvbmZpZy5raWxsICE9PSBmYWxzZSAmJiB0aGlzLmtpbGwoKTtcbiAgICBfcmV2ZXJ0aW5nID0gcHJldklzUmV2ZXJ0aW5nO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5nbG9iYWxUaW1lID0gZnVuY3Rpb24gZ2xvYmFsVGltZShyYXdUaW1lKSB7XG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMsXG4gICAgICAgIHRpbWUgPSBhcmd1bWVudHMubGVuZ3RoID8gcmF3VGltZSA6IGFuaW1hdGlvbi5yYXdUaW1lKCk7XG5cbiAgICB3aGlsZSAoYW5pbWF0aW9uKSB7XG4gICAgICB0aW1lID0gYW5pbWF0aW9uLl9zdGFydCArIHRpbWUgLyAoTWF0aC5hYnMoYW5pbWF0aW9uLl90cykgfHwgMSk7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24uX2RwO1xuICAgIH1cblxuICAgIHJldHVybiAhdGhpcy5wYXJlbnQgJiYgdGhpcy5fc2F0ID8gdGhpcy5fc2F0Lmdsb2JhbFRpbWUocmF3VGltZSkgOiB0aW1lOyAvLyB0aGUgX3N0YXJ0QXQgdHdlZW5zIGZvciAuZnJvbVRvKCkgYW5kIC5mcm9tKCkgdGhhdCBoYXZlIGltbWVkaWF0ZVJlbmRlciBzaG91bGQgYWx3YXlzIGJlIEZJUlNUIGluIHRoZSB0aW1lbGluZSAoaW1wb3J0YW50IGZvciBjb250ZXh0LnJldmVydCgpKS4gXCJfc2F0XCIgc3RhbmRzIGZvciBfc3RhcnRBdFR3ZWVuLCByZWZlcnJpbmcgdG8gdGhlIHBhcmVudCB0d2VlbiB0aGF0IGNyZWF0ZWQgdGhlIF9zdGFydEF0LiBXZSBtdXN0IGRpc2Nlcm4gaWYgdGhhdCB0d2VlbiBoYWQgaW1tZWRpYXRlUmVuZGVyIHNvIHRoYXQgd2UgY2FuIGtub3cgd2hldGhlciBvciBub3QgdG8gcHJpb3JpdGl6ZSBpdCBpbiByZXZlcnQoKS5cbiAgfTtcblxuICBfcHJvdG8ucmVwZWF0ID0gZnVuY3Rpb24gcmVwZWF0KHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3JlcGVhdCA9IHZhbHVlID09PSBJbmZpbml0eSA/IC0yIDogdmFsdWU7XG4gICAgICByZXR1cm4gX29uVXBkYXRlVG90YWxEdXJhdGlvbih0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVwZWF0ID09PSAtMiA/IEluZmluaXR5IDogdGhpcy5fcmVwZWF0O1xuICB9O1xuXG4gIF9wcm90by5yZXBlYXREZWxheSA9IGZ1bmN0aW9uIHJlcGVhdERlbGF5KHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciB0aW1lID0gdGhpcy5fdGltZTtcbiAgICAgIHRoaXMuX3JEZWxheSA9IHZhbHVlO1xuXG4gICAgICBfb25VcGRhdGVUb3RhbER1cmF0aW9uKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGltZSA/IHRoaXMudGltZSh0aW1lKSA6IHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JEZWxheTtcbiAgfTtcblxuICBfcHJvdG8ueW95byA9IGZ1bmN0aW9uIHlveW8odmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5feW95byA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3lveW87XG4gIH07XG5cbiAgX3Byb3RvLnNlZWsgPSBmdW5jdGlvbiBzZWVrKHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiB0aGlzLnRvdGFsVGltZShfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbiksIF9pc05vdEZhbHNlKHN1cHByZXNzRXZlbnRzKSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlc3RhcnQgPSBmdW5jdGlvbiByZXN0YXJ0KGluY2x1ZGVEZWxheSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5KCkudG90YWxUaW1lKGluY2x1ZGVEZWxheSA/IC10aGlzLl9kZWxheSA6IDAsIF9pc05vdEZhbHNlKHN1cHByZXNzRXZlbnRzKSk7XG4gIH07XG5cbiAgX3Byb3RvLnBsYXkgPSBmdW5jdGlvbiBwbGF5KGZyb20sIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgZnJvbSAhPSBudWxsICYmIHRoaXMuc2Vlayhmcm9tLCBzdXBwcmVzc0V2ZW50cyk7XG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZWQoZmFsc2UpLnBhdXNlZChmYWxzZSk7XG4gIH07XG5cbiAgX3Byb3RvLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKGZyb20sIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgZnJvbSAhPSBudWxsICYmIHRoaXMuc2Vlayhmcm9tIHx8IHRoaXMudG90YWxEdXJhdGlvbigpLCBzdXBwcmVzc0V2ZW50cyk7XG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZWQodHJ1ZSkucGF1c2VkKGZhbHNlKTtcbiAgfTtcblxuICBfcHJvdG8ucGF1c2UgPSBmdW5jdGlvbiBwYXVzZShhdFRpbWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgYXRUaW1lICE9IG51bGwgJiYgdGhpcy5zZWVrKGF0VGltZSwgc3VwcHJlc3NFdmVudHMpO1xuICAgIHJldHVybiB0aGlzLnBhdXNlZCh0cnVlKTtcbiAgfTtcblxuICBfcHJvdG8ucmVzdW1lID0gZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgIHJldHVybiB0aGlzLnBhdXNlZChmYWxzZSk7XG4gIH07XG5cbiAgX3Byb3RvLnJldmVyc2VkID0gZnVuY3Rpb24gcmV2ZXJzZWQodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgISF2YWx1ZSAhPT0gdGhpcy5yZXZlcnNlZCgpICYmIHRoaXMudGltZVNjYWxlKC10aGlzLl9ydHMgfHwgKHZhbHVlID8gLV90aW55TnVtIDogMCkpOyAvLyBpbiBjYXNlIHRpbWVTY2FsZSBpcyB6ZXJvLCByZXZlcnNpbmcgd291bGQgaGF2ZSBubyBlZmZlY3Qgc28gd2UgdXNlIF90aW55TnVtLlxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcnRzIDwgMDtcbiAgfTtcblxuICBfcHJvdG8uaW52YWxpZGF0ZSA9IGZ1bmN0aW9uIGludmFsaWRhdGUoKSB7XG4gICAgdGhpcy5faW5pdHRlZCA9IHRoaXMuX2FjdCA9IDA7XG4gICAgdGhpcy5felRpbWUgPSAtX3RpbnlOdW07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmlzQWN0aXZlID0gZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXMuX2RwLFxuICAgICAgICBzdGFydCA9IHRoaXMuX3N0YXJ0LFxuICAgICAgICByYXdUaW1lO1xuICAgIHJldHVybiAhISghcGFyZW50IHx8IHRoaXMuX3RzICYmIHRoaXMuX2luaXR0ZWQgJiYgcGFyZW50LmlzQWN0aXZlKCkgJiYgKHJhd1RpbWUgPSBwYXJlbnQucmF3VGltZSh0cnVlKSkgPj0gc3RhcnQgJiYgcmF3VGltZSA8IHRoaXMuZW5kVGltZSh0cnVlKSAtIF90aW55TnVtKTtcbiAgfTtcblxuICBfcHJvdG8uZXZlbnRDYWxsYmFjayA9IGZ1bmN0aW9uIGV2ZW50Q2FsbGJhY2sodHlwZSwgY2FsbGJhY2ssIHBhcmFtcykge1xuICAgIHZhciB2YXJzID0gdGhpcy52YXJzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIGRlbGV0ZSB2YXJzW3R5cGVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyc1t0eXBlXSA9IGNhbGxiYWNrO1xuICAgICAgICBwYXJhbXMgJiYgKHZhcnNbdHlwZSArIFwiUGFyYW1zXCJdID0gcGFyYW1zKTtcbiAgICAgICAgdHlwZSA9PT0gXCJvblVwZGF0ZVwiICYmICh0aGlzLl9vblVwZGF0ZSA9IGNhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhcnNbdHlwZV07XG4gIH07XG5cbiAgX3Byb3RvLnRoZW4gPSBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgdmFyIGYgPSBfaXNGdW5jdGlvbihvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IF9wYXNzVGhyb3VnaCxcbiAgICAgICAgICBfcmVzb2x2ZSA9IGZ1bmN0aW9uIF9yZXNvbHZlKCkge1xuICAgICAgICB2YXIgX3RoZW4gPSBzZWxmLnRoZW47XG4gICAgICAgIHNlbGYudGhlbiA9IG51bGw7IC8vIHRlbXBvcmFyaWx5IG51bGwgdGhlIHRoZW4oKSBtZXRob2QgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVlbnNvY2svR1NBUC9pc3N1ZXMvMzIyKVxuXG4gICAgICAgIF9pc0Z1bmN0aW9uKGYpICYmIChmID0gZihzZWxmKSkgJiYgKGYudGhlbiB8fCBmID09PSBzZWxmKSAmJiAoc2VsZi50aGVuID0gX3RoZW4pO1xuICAgICAgICByZXNvbHZlKGYpO1xuICAgICAgICBzZWxmLnRoZW4gPSBfdGhlbjtcbiAgICAgIH07XG5cbiAgICAgIGlmIChzZWxmLl9pbml0dGVkICYmIHNlbGYudG90YWxQcm9ncmVzcygpID09PSAxICYmIHNlbGYuX3RzID49IDAgfHwgIXNlbGYuX3RUaW1lICYmIHNlbGYuX3RzIDwgMCkge1xuICAgICAgICBfcmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5fcHJvbSA9IF9yZXNvbHZlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5raWxsID0gZnVuY3Rpb24ga2lsbCgpIHtcbiAgICBfaW50ZXJydXB0KHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBBbmltYXRpb247XG59KCk7XG5cbl9zZXREZWZhdWx0cyhBbmltYXRpb24ucHJvdG90eXBlLCB7XG4gIF90aW1lOiAwLFxuICBfc3RhcnQ6IDAsXG4gIF9lbmQ6IDAsXG4gIF90VGltZTogMCxcbiAgX3REdXI6IDAsXG4gIF9kaXJ0eTogMCxcbiAgX3JlcGVhdDogMCxcbiAgX3lveW86IGZhbHNlLFxuICBwYXJlbnQ6IG51bGwsXG4gIF9pbml0dGVkOiBmYWxzZSxcbiAgX3JEZWxheTogMCxcbiAgX3RzOiAxLFxuICBfZHA6IDAsXG4gIHJhdGlvOiAwLFxuICBfelRpbWU6IC1fdGlueU51bSxcbiAgX3Byb206IDAsXG4gIF9wczogZmFsc2UsXG4gIF9ydHM6IDFcbn0pO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRJTUVMSU5FXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5leHBvcnQgdmFyIFRpbWVsaW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5pbWF0aW9uKSB7XG4gIF9pbmhlcml0c0xvb3NlKFRpbWVsaW5lLCBfQW5pbWF0aW9uKTtcblxuICBmdW5jdGlvbiBUaW1lbGluZSh2YXJzLCBwb3NpdGlvbikge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgIHZhcnMgPSB7fTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9BbmltYXRpb24uY2FsbCh0aGlzLCB2YXJzKSB8fCB0aGlzO1xuICAgIF90aGlzLmxhYmVscyA9IHt9O1xuICAgIF90aGlzLnNtb290aENoaWxkVGltaW5nID0gISF2YXJzLnNtb290aENoaWxkVGltaW5nO1xuICAgIF90aGlzLmF1dG9SZW1vdmVDaGlsZHJlbiA9ICEhdmFycy5hdXRvUmVtb3ZlQ2hpbGRyZW47XG4gICAgX3RoaXMuX3NvcnQgPSBfaXNOb3RGYWxzZSh2YXJzLnNvcnRDaGlsZHJlbik7XG4gICAgX2dsb2JhbFRpbWVsaW5lICYmIF9hZGRUb1RpbWVsaW5lKHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZSwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHBvc2l0aW9uKTtcbiAgICB2YXJzLnJldmVyc2VkICYmIF90aGlzLnJldmVyc2UoKTtcbiAgICB2YXJzLnBhdXNlZCAmJiBfdGhpcy5wYXVzZWQodHJ1ZSk7XG4gICAgdmFycy5zY3JvbGxUcmlnZ2VyICYmIF9zY3JvbGxUcmlnZ2VyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCB2YXJzLnNjcm9sbFRyaWdnZXIpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gVGltZWxpbmUucHJvdG90eXBlO1xuXG4gIF9wcm90bzIudG8gPSBmdW5jdGlvbiB0byh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgIF9jcmVhdGVUd2VlblR5cGUoMCwgYXJndW1lbnRzLCB0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuZnJvbSA9IGZ1bmN0aW9uIGZyb20odGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICBfY3JlYXRlVHdlZW5UeXBlKDEsIGFyZ3VtZW50cywgdGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmZyb21UbyA9IGZ1bmN0aW9uIGZyb21Ubyh0YXJnZXRzLCBmcm9tVmFycywgdG9WYXJzLCBwb3NpdGlvbikge1xuICAgIF9jcmVhdGVUd2VlblR5cGUoMiwgYXJndW1lbnRzLCB0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgdmFycy5kdXJhdGlvbiA9IDA7XG4gICAgdmFycy5wYXJlbnQgPSB0aGlzO1xuICAgIF9pbmhlcml0RGVmYXVsdHModmFycykucmVwZWF0RGVsYXkgfHwgKHZhcnMucmVwZWF0ID0gMCk7XG4gICAgdmFycy5pbW1lZGlhdGVSZW5kZXIgPSAhIXZhcnMuaW1tZWRpYXRlUmVuZGVyO1xuICAgIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbiksIDEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuY2FsbCA9IGZ1bmN0aW9uIGNhbGwoY2FsbGJhY2ssIHBhcmFtcywgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gX2FkZFRvVGltZWxpbmUodGhpcywgVHdlZW4uZGVsYXllZENhbGwoMCwgY2FsbGJhY2ssIHBhcmFtcyksIHBvc2l0aW9uKTtcbiAgfSAvL09OTFkgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkhIE1heWJlIGRlbGV0ZT9cbiAgO1xuXG4gIF9wcm90bzIuc3RhZ2dlclRvID0gZnVuY3Rpb24gc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuICAgIHZhcnMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB2YXJzLnN0YWdnZXIgPSB2YXJzLnN0YWdnZXIgfHwgc3RhZ2dlcjtcbiAgICB2YXJzLm9uQ29tcGxldGUgPSBvbkNvbXBsZXRlQWxsO1xuICAgIHZhcnMub25Db21wbGV0ZVBhcmFtcyA9IG9uQ29tcGxldGVBbGxQYXJhbXM7XG4gICAgdmFycy5wYXJlbnQgPSB0aGlzO1xuICAgIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbikpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuc3RhZ2dlckZyb20gPSBmdW5jdGlvbiBzdGFnZ2VyRnJvbSh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpIHtcbiAgICB2YXJzLnJ1bkJhY2t3YXJkcyA9IDE7XG4gICAgX2luaGVyaXREZWZhdWx0cyh2YXJzKS5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZSh2YXJzLmltbWVkaWF0ZVJlbmRlcik7XG4gICAgcmV0dXJuIHRoaXMuc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcyk7XG4gIH07XG5cbiAgX3Byb3RvMi5zdGFnZ2VyRnJvbVRvID0gZnVuY3Rpb24gc3RhZ2dlckZyb21Ubyh0YXJnZXRzLCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpIHtcbiAgICB0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuICAgIF9pbmhlcml0RGVmYXVsdHModG9WYXJzKS5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZSh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyKTtcbiAgICByZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpO1xuICB9O1xuXG4gIF9wcm90bzIucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG4gICAgdmFyIHByZXZUaW1lID0gdGhpcy5fdGltZSxcbiAgICAgICAgdER1ciA9IHRoaXMuX2RpcnR5ID8gdGhpcy50b3RhbER1cmF0aW9uKCkgOiB0aGlzLl90RHVyLFxuICAgICAgICBkdXIgPSB0aGlzLl9kdXIsXG4gICAgICAgIHRUaW1lID0gdG90YWxUaW1lIDw9IDAgPyAwIDogX3JvdW5kUHJlY2lzZSh0b3RhbFRpbWUpLFxuICAgICAgICAvLyBpZiBhIHBhdXNlZCB0aW1lbGluZSBpcyByZXN1bWVkIChvciBpdHMgX3N0YXJ0IGlzIHVwZGF0ZWQgZm9yIGFub3RoZXIgcmVhc29uLi4ud2hpY2ggcm91bmRzIGl0KSwgdGhhdCBjb3VsZCByZXN1bHQgaW4gdGhlIHBsYXloZWFkIHNoaWZ0aW5nIGEgKip0aW55KiogYW1vdW50IGFuZCBhIHplcm8tZHVyYXRpb24gY2hpbGQgYXQgdGhhdCBzcG90IG1heSBnZXQgcmVuZGVyZWQgYXQgYSBkaWZmZXJlbnQgcmF0aW8sIGxpa2UgaXRzIHRvdGFsVGltZSBpbiByZW5kZXIoKSBtYXkgYmUgMWUtMTcgaW5zdGVhZCBvZiAwLCBmb3IgZXhhbXBsZS5cbiAgICBjcm9zc2luZ1N0YXJ0ID0gdGhpcy5felRpbWUgPCAwICE9PSB0b3RhbFRpbWUgPCAwICYmICh0aGlzLl9pbml0dGVkIHx8ICFkdXIpLFxuICAgICAgICB0aW1lLFxuICAgICAgICBjaGlsZCxcbiAgICAgICAgbmV4dCxcbiAgICAgICAgaXRlcmF0aW9uLFxuICAgICAgICBjeWNsZUR1cmF0aW9uLFxuICAgICAgICBwcmV2UGF1c2VkLFxuICAgICAgICBwYXVzZVR3ZWVuLFxuICAgICAgICB0aW1lU2NhbGUsXG4gICAgICAgIHByZXZTdGFydCxcbiAgICAgICAgcHJldkl0ZXJhdGlvbixcbiAgICAgICAgeW95byxcbiAgICAgICAgaXNZb3lvO1xuICAgIHRoaXMgIT09IF9nbG9iYWxUaW1lbGluZSAmJiB0VGltZSA+IHREdXIgJiYgdG90YWxUaW1lID49IDAgJiYgKHRUaW1lID0gdER1cik7XG5cbiAgICBpZiAodFRpbWUgIT09IHRoaXMuX3RUaW1lIHx8IGZvcmNlIHx8IGNyb3NzaW5nU3RhcnQpIHtcbiAgICAgIGlmIChwcmV2VGltZSAhPT0gdGhpcy5fdGltZSAmJiBkdXIpIHtcbiAgICAgICAgLy9pZiB0b3RhbER1cmF0aW9uKCkgZmluZHMgYSBjaGlsZCB3aXRoIGEgbmVnYXRpdmUgc3RhcnRUaW1lIGFuZCBzbW9vdGhDaGlsZFRpbWluZyBpcyB0cnVlLCB0aGluZ3MgZ2V0IHNoaWZ0ZWQgYXJvdW5kIGludGVybmFsbHkgc28gd2UgbmVlZCB0byBhZGp1c3QgdGhlIHRpbWUgYWNjb3JkaW5nbHkuIEZvciBleGFtcGxlLCBpZiBhIHR3ZWVuIHN0YXJ0cyBhdCAtMzAgd2UgbXVzdCBzaGlmdCBFVkVSWVRISU5HIGZvcndhcmQgMzAgc2Vjb25kcyBhbmQgbW92ZSB0aGlzIHRpbWVsaW5lJ3Mgc3RhcnRUaW1lIGJhY2t3YXJkIGJ5IDMwIHNlY29uZHMgc28gdGhhdCB0aGluZ3MgYWxpZ24gd2l0aCB0aGUgcGxheWhlYWQgKG5vIGp1bXApLlxuICAgICAgICB0VGltZSArPSB0aGlzLl90aW1lIC0gcHJldlRpbWU7XG4gICAgICAgIHRvdGFsVGltZSArPSB0aGlzLl90aW1lIC0gcHJldlRpbWU7XG4gICAgICB9XG5cbiAgICAgIHRpbWUgPSB0VGltZTtcbiAgICAgIHByZXZTdGFydCA9IHRoaXMuX3N0YXJ0O1xuICAgICAgdGltZVNjYWxlID0gdGhpcy5fdHM7XG4gICAgICBwcmV2UGF1c2VkID0gIXRpbWVTY2FsZTtcblxuICAgICAgaWYgKGNyb3NzaW5nU3RhcnQpIHtcbiAgICAgICAgZHVyIHx8IChwcmV2VGltZSA9IHRoaXMuX3pUaW1lKTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC5cblxuICAgICAgICAodG90YWxUaW1lIHx8ICFzdXBwcmVzc0V2ZW50cykgJiYgKHRoaXMuX3pUaW1lID0gdG90YWxUaW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3JlcGVhdCkge1xuICAgICAgICAvL2FkanVzdCB0aGUgdGltZSBmb3IgcmVwZWF0cyBhbmQgeW95b3NcbiAgICAgICAgeW95byA9IHRoaXMuX3lveW87XG4gICAgICAgIGN5Y2xlRHVyYXRpb24gPSBkdXIgKyB0aGlzLl9yRGVsYXk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3JlcGVhdCA8IC0xICYmIHRvdGFsVGltZSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b3RhbFRpbWUoY3ljbGVEdXJhdGlvbiAqIDEwMCArIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbWUgPSBfcm91bmRQcmVjaXNlKHRUaW1lICUgY3ljbGVEdXJhdGlvbik7IC8vcm91bmQgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzLiAoNCAlIDAuOCBzaG91bGQgYmUgMCBidXQgc29tZSBicm93c2VycyByZXBvcnQgaXQgYXMgMC43OTk5OTk5OSEpXG5cbiAgICAgICAgaWYgKHRUaW1lID09PSB0RHVyKSB7XG4gICAgICAgICAgLy8gdGhlIHREdXIgPT09IHRUaW1lIGlzIGZvciBlZGdlIGNhc2VzIHdoZXJlIHRoZXJlJ3MgYSBsZW5ndGh5IGRlY2ltYWwgb24gdGhlIGR1cmF0aW9uIGFuZCBpdCBtYXkgcmVhY2ggdGhlIHZlcnkgZW5kIGJ1dCB0aGUgdGltZSBpcyByZW5kZXJlZCBhcyBub3QtcXVpdGUtdGhlcmUgKHJlbWVtYmVyLCB0RHVyIGlzIHJvdW5kZWQgdG8gNCBkZWNpbWFscyB3aGVyZWFzIGR1ciBpc24ndClcbiAgICAgICAgICBpdGVyYXRpb24gPSB0aGlzLl9yZXBlYXQ7XG4gICAgICAgICAgdGltZSA9IGR1cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVyYXRpb24gPSB+fih0VGltZSAvIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgICAgaWYgKGl0ZXJhdGlvbiAmJiBpdGVyYXRpb24gPT09IHRUaW1lIC8gY3ljbGVEdXJhdGlvbikge1xuICAgICAgICAgICAgdGltZSA9IGR1cjtcbiAgICAgICAgICAgIGl0ZXJhdGlvbi0tO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpbWUgPiBkdXIgJiYgKHRpbWUgPSBkdXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldkl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbik7XG4gICAgICAgICFwcmV2VGltZSAmJiB0aGlzLl90VGltZSAmJiBwcmV2SXRlcmF0aW9uICE9PSBpdGVyYXRpb24gJiYgdGhpcy5fdFRpbWUgLSBwcmV2SXRlcmF0aW9uICogY3ljbGVEdXJhdGlvbiAtIHRoaXMuX2R1ciA8PSAwICYmIChwcmV2SXRlcmF0aW9uID0gaXRlcmF0aW9uKTsgLy8gZWRnZSBjYXNlIC0gaWYgc29tZW9uZSBkb2VzIGFkZFBhdXNlKCkgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIGEgcmVwZWF0aW5nIHRpbWVsaW5lLCB0aGF0IHBhdXNlIGlzIHRlY2huaWNhbGx5IGF0IHRoZSBzYW1lIHNwb3QgYXMgdGhlIGVuZCB3aGljaCBjYXVzZXMgdGhpcy5fdGltZSB0byBnZXQgc2V0IHRvIDAgd2hlbiB0aGUgdG90YWxUaW1lIHdvdWxkIG5vcm1hbGx5IHBsYWNlIHRoZSBwbGF5aGVhZCBhdCB0aGUgZW5kLiBTZWUgaHR0cHM6Ly9nc2FwLmNvbS9mb3J1bXMvdG9waWMvMjM4MjMtY2xvc2luZy1uYXYtYW5pbWF0aW9uLW5vdC13b3JraW5nLW9uLWllLWFuZC1pcGhvbmUtNi1tYXliZS1vdGhlci1vbGRlci1icm93c2VyLz90YWI9Y29tbWVudHMjY29tbWVudC0xMTMwMDUgYWxzbywgdGhpcy5fdFRpbWUgLSBwcmV2SXRlcmF0aW9uICogY3ljbGVEdXJhdGlvbiAtIHRoaXMuX2R1ciA8PSAwIGp1c3QgY2hlY2tzIHRvIG1ha2Ugc3VyZSBpdCB3YXNuJ3QgcHJldmlvdXNseSBpbiB0aGUgXCJyZXBlYXREZWxheVwiIHBvcnRpb25cblxuICAgICAgICBpZiAoeW95byAmJiBpdGVyYXRpb24gJiAxKSB7XG4gICAgICAgICAgdGltZSA9IGR1ciAtIHRpbWU7XG4gICAgICAgICAgaXNZb3lvID0gMTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICBtYWtlIHN1cmUgY2hpbGRyZW4gYXQgdGhlIGVuZC9iZWdpbm5pbmcgb2YgdGhlIHRpbWVsaW5lIGFyZSByZW5kZXJlZCBwcm9wZXJseS4gSWYsIGZvciBleGFtcGxlLFxuICAgICAgICBhIDMtc2Vjb25kIGxvbmcgdGltZWxpbmUgcmVuZGVyZWQgYXQgMi45IHNlY29uZHMgcHJldmlvdXNseSwgYW5kIG5vdyByZW5kZXJzIGF0IDMuMiBzZWNvbmRzICh3aGljaFxuICAgICAgICB3b3VsZCBnZXQgdHJhbnNsYXRlZCB0byAyLjggc2Vjb25kcyBpZiB0aGUgdGltZWxpbmUgeW95b3Mgb3IgMC4yIHNlY29uZHMgaWYgaXQganVzdCByZXBlYXRzKSwgdGhlcmVcbiAgICAgICAgY291bGQgYmUgYSBjYWxsYmFjayBvciBhIHNob3J0IHR3ZWVuIHRoYXQncyBhdCAyLjk1IG9yIDMgc2Vjb25kcyBpbiB3aGljaCB3b3VsZG4ndCByZW5kZXIuIFNvXG4gICAgICAgIHdlIG5lZWQgdG8gcHVzaCB0aGUgdGltZWxpbmUgdG8gdGhlIGVuZCAoYW5kL29yIGJlZ2lubmluZyBkZXBlbmRpbmcgb24gaXRzIHlveW8gdmFsdWUpLiBBbHNvIHdlIG11c3RcbiAgICAgICAgZW5zdXJlIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9yIGVuZCBvZiB0aGUgVGltZWxpbmUgd29yay5cbiAgICAgICAgKi9cblxuXG4gICAgICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24gJiYgIXRoaXMuX2xvY2spIHtcbiAgICAgICAgICB2YXIgcmV3aW5kaW5nID0geW95byAmJiBwcmV2SXRlcmF0aW9uICYgMSxcbiAgICAgICAgICAgICAgZG9lc1dyYXAgPSByZXdpbmRpbmcgPT09ICh5b3lvICYmIGl0ZXJhdGlvbiAmIDEpO1xuICAgICAgICAgIGl0ZXJhdGlvbiA8IHByZXZJdGVyYXRpb24gJiYgKHJld2luZGluZyA9ICFyZXdpbmRpbmcpO1xuICAgICAgICAgIHByZXZUaW1lID0gcmV3aW5kaW5nID8gMCA6IHRUaW1lICUgZHVyID8gZHVyIDogdFRpbWU7IC8vIGlmIHRoZSBwbGF5aGVhZCBpcyBsYW5kaW5nIGV4YWN0bHkgYXQgdGhlIGVuZCBvZiBhbiBpdGVyYXRpb24sIHVzZSB0aGF0IHRvdGFsVGltZSByYXRoZXIgdGhhbiBvbmx5IHRoZSBkdXJhdGlvbiwgb3RoZXJ3aXNlIGl0J2xsIHNraXAgdGhlIDJuZCByZW5kZXIgc2luY2UgaXQncyBlZmZlY3RpdmVseSBhdCB0aGUgc2FtZSB0aW1lLlxuXG4gICAgICAgICAgdGhpcy5fbG9jayA9IDE7XG4gICAgICAgICAgdGhpcy5yZW5kZXIocHJldlRpbWUgfHwgKGlzWW95byA/IDAgOiBfcm91bmRQcmVjaXNlKGl0ZXJhdGlvbiAqIGN5Y2xlRHVyYXRpb24pKSwgc3VwcHJlc3NFdmVudHMsICFkdXIpLl9sb2NrID0gMDtcbiAgICAgICAgICB0aGlzLl90VGltZSA9IHRUaW1lOyAvLyBpZiBhIHVzZXIgZ2V0cyB0aGUgaXRlcmF0aW9uKCkgaW5zaWRlIHRoZSBvblJlcGVhdCwgZm9yIGV4YW1wbGUsIGl0IHNob3VsZCBiZSBhY2N1cmF0ZS5cblxuICAgICAgICAgICFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnBhcmVudCAmJiBfY2FsbGJhY2sodGhpcywgXCJvblJlcGVhdFwiKTtcbiAgICAgICAgICB0aGlzLnZhcnMucmVwZWF0UmVmcmVzaCAmJiAhaXNZb3lvICYmICh0aGlzLmludmFsaWRhdGUoKS5fbG9jayA9IDEpO1xuXG4gICAgICAgICAgaWYgKHByZXZUaW1lICYmIHByZXZUaW1lICE9PSB0aGlzLl90aW1lIHx8IHByZXZQYXVzZWQgIT09ICF0aGlzLl90cyB8fCB0aGlzLnZhcnMub25SZXBlYXQgJiYgIXRoaXMucGFyZW50ICYmICF0aGlzLl9hY3QpIHtcbiAgICAgICAgICAgIC8vIGlmIHByZXZUaW1lIGlzIDAgYW5kIHdlIHJlbmRlciBhdCB0aGUgdmVyeSBlbmQsIF90aW1lIHdpbGwgYmUgdGhlIGVuZCwgdGh1cyB3b24ndCBtYXRjaC4gU28gaW4gdGhpcyBlZGdlIGNhc2UsIHByZXZUaW1lIHdvbid0IG1hdGNoIF90aW1lIGJ1dCB0aGF0J3Mgb2theS4gSWYgaXQgZ2V0cyBraWxsZWQgaW4gdGhlIG9uUmVwZWF0LCBlamVjdCBhcyB3ZWxsLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZHVyID0gdGhpcy5fZHVyOyAvLyBpbiBjYXNlIHRoZSBkdXJhdGlvbiBjaGFuZ2VkIGluIHRoZSBvblJlcGVhdFxuXG4gICAgICAgICAgdER1ciA9IHRoaXMuX3REdXI7XG5cbiAgICAgICAgICBpZiAoZG9lc1dyYXApIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2sgPSAyO1xuICAgICAgICAgICAgcHJldlRpbWUgPSByZXdpbmRpbmcgPyBkdXIgOiAtMC4wMDAxO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIocHJldlRpbWUsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgIWlzWW95byAmJiB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9sb2NrID0gMDtcblxuICAgICAgICAgIGlmICghdGhpcy5fdHMgJiYgIXByZXZQYXVzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0gLy9pbiBvcmRlciBmb3IgeW95b0Vhc2UgdG8gd29yayBwcm9wZXJseSB3aGVuIHRoZXJlJ3MgYSBzdGFnZ2VyLCB3ZSBtdXN0IHN3YXAgb3V0IHRoZSBlYXNlIGluIGVhY2ggc3ViLXR3ZWVuLlxuXG5cbiAgICAgICAgICBfcHJvcGFnYXRlWW95b0Vhc2UodGhpcywgaXNZb3lvKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faGFzUGF1c2UgJiYgIXRoaXMuX2ZvcmNpbmcgJiYgdGhpcy5fbG9jayA8IDIpIHtcbiAgICAgICAgcGF1c2VUd2VlbiA9IF9maW5kTmV4dFBhdXNlVHdlZW4odGhpcywgX3JvdW5kUHJlY2lzZShwcmV2VGltZSksIF9yb3VuZFByZWNpc2UodGltZSkpO1xuXG4gICAgICAgIGlmIChwYXVzZVR3ZWVuKSB7XG4gICAgICAgICAgdFRpbWUgLT0gdGltZSAtICh0aW1lID0gcGF1c2VUd2Vlbi5fc3RhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7XG4gICAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICAgIHRoaXMuX2FjdCA9ICF0aW1lU2NhbGU7IC8vYXMgbG9uZyBhcyBpdCdzIG5vdCBwYXVzZWQsIGZvcmNlIGl0IHRvIGJlIGFjdGl2ZSBzbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgaW5kZXBlbmRlbnQgb2YgdGhlIHBhcmVudCB0aW1lbGluZSwgaXQnbGwgYmUgZm9yY2VkIHRvIHJlLXJlbmRlciBvbiB0aGUgbmV4dCB0aWNrLlxuXG4gICAgICBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5fb25VcGRhdGUgPSB0aGlzLnZhcnMub25VcGRhdGU7XG4gICAgICAgIHRoaXMuX2luaXR0ZWQgPSAxO1xuICAgICAgICB0aGlzLl96VGltZSA9IHRvdGFsVGltZTtcbiAgICAgICAgcHJldlRpbWUgPSAwOyAvLyB1cG9uIGluaXQsIHRoZSBwbGF5aGVhZCBzaG91bGQgYWx3YXlzIGdvIGZvcndhcmQ7IHNvbWVvbmUgY291bGQgaW52YWxpZGF0ZSgpIGEgY29tcGxldGVkIHRpbWVsaW5lIGFuZCB0aGVuIGlmIHRoZXkgcmVzdGFydCgpLCB0aGF0IHdvdWxkIG1ha2UgY2hpbGQgdHdlZW5zIHJlbmRlciBpbiByZXZlcnNlIG9yZGVyIHdoaWNoIGNvdWxkIGxvY2sgaW4gdGhlIHdyb25nIHN0YXJ0aW5nIHZhbHVlcyBpZiB0aGV5IGJ1aWxkIG9uIGVhY2ggb3RoZXIsIGxpa2UgdGwudG8ob2JqLCB7eDogMTAwfSkudG8ob2JqLCB7eDogMH0pLlxuICAgICAgfVxuXG4gICAgICBpZiAoIXByZXZUaW1lICYmIHRpbWUgJiYgIXN1cHByZXNzRXZlbnRzICYmICFpdGVyYXRpb24pIHtcbiAgICAgICAgX2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcblxuICAgICAgICBpZiAodGhpcy5fdFRpbWUgIT09IHRUaW1lKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSB0aGUgb25TdGFydCB0cmlnZ2VyZWQgYSByZW5kZXIgYXQgYSBkaWZmZXJlbnQgc3BvdCwgZWplY3QuIExpa2UgaWYgc29tZW9uZSBkaWQgYW5pbWF0aW9uLnBhdXNlKDAuNSkgb3Igc29tZXRoaW5nIGluc2lkZSB0aGUgb25TdGFydC5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGltZSA+PSBwcmV2VGltZSAmJiB0b3RhbFRpbWUgPj0gMCkge1xuICAgICAgICBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuXG4gICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgIG5leHQgPSBjaGlsZC5fbmV4dDtcblxuICAgICAgICAgIGlmICgoY2hpbGQuX2FjdCB8fCB0aW1lID49IGNoaWxkLl9zdGFydCkgJiYgY2hpbGQuX3RzICYmIHBhdXNlVHdlZW4gIT09IGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgIC8vIGFuIGV4dHJlbWUgZWRnZSBjYXNlIC0gdGhlIGNoaWxkJ3MgcmVuZGVyIGNvdWxkIGRvIHNvbWV0aGluZyBsaWtlIGtpbGwoKSB0aGUgXCJuZXh0XCIgb25lIGluIHRoZSBsaW5rZWQgbGlzdCwgb3IgcmVwYXJlbnQgaXQuIEluIHRoYXQgY2FzZSB3ZSBtdXN0IHJlLWluaXRpYXRlIHRoZSB3aG9sZSByZW5kZXIgdG8gYmUgc2FmZS5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucmVuZGVyKGNoaWxkLl90cyA+IDAgPyAodGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgOiAoY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpICsgKHRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXG4gICAgICAgICAgICBpZiAodGltZSAhPT0gdGhpcy5fdGltZSB8fCAhdGhpcy5fdHMgJiYgIXByZXZQYXVzZWQpIHtcbiAgICAgICAgICAgICAgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuICAgICAgICAgICAgICBwYXVzZVR3ZWVuID0gMDtcbiAgICAgICAgICAgICAgbmV4dCAmJiAodFRpbWUgKz0gdGhpcy5felRpbWUgPSAtX3RpbnlOdW0pOyAvLyBpdCBkaWRuJ3QgZmluaXNoIHJlbmRlcmluZywgc28gZmxhZyB6VGltZSBhcyBuZWdhdGl2ZSBzbyB0aGF0IHNvIHRoYXQgdGhlIG5leHQgdGltZSByZW5kZXIoKSBpcyBjYWxsZWQgaXQnbGwgYmUgZm9yY2VkICh0byByZW5kZXIgYW55IHJlbWFpbmluZyBjaGlsZHJlbilcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkID0gdGhpcy5fbGFzdDtcbiAgICAgICAgdmFyIGFkanVzdGVkVGltZSA9IHRvdGFsVGltZSA8IDAgPyB0b3RhbFRpbWUgOiB0aW1lOyAvL3doZW4gdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgYmV5b25kIHRoZSBzdGFydCBvZiB0aGlzIHRpbWVsaW5lLCB3ZSBtdXN0IHBhc3MgdGhhdCBpbmZvcm1hdGlvbiBkb3duIHRvIHRoZSBjaGlsZCBhbmltYXRpb25zIHNvIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMga25vdyB3aGV0aGVyIHRvIHJlbmRlciB0aGVpciBzdGFydGluZyBvciBlbmRpbmcgdmFsdWVzLlxuXG4gICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgIG5leHQgPSBjaGlsZC5fcHJldjtcblxuICAgICAgICAgIGlmICgoY2hpbGQuX2FjdCB8fCBhZGp1c3RlZFRpbWUgPD0gY2hpbGQuX2VuZCkgJiYgY2hpbGQuX3RzICYmIHBhdXNlVHdlZW4gIT09IGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgIC8vIGFuIGV4dHJlbWUgZWRnZSBjYXNlIC0gdGhlIGNoaWxkJ3MgcmVuZGVyIGNvdWxkIGRvIHNvbWV0aGluZyBsaWtlIGtpbGwoKSB0aGUgXCJuZXh0XCIgb25lIGluIHRoZSBsaW5rZWQgbGlzdCwgb3IgcmVwYXJlbnQgaXQuIEluIHRoYXQgY2FzZSB3ZSBtdXN0IHJlLWluaXRpYXRlIHRoZSB3aG9sZSByZW5kZXIgdG8gYmUgc2FmZS5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucmVuZGVyKGNoaWxkLl90cyA+IDAgPyAoYWRqdXN0ZWRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cyA6IChjaGlsZC5fZGlydHkgPyBjaGlsZC50b3RhbER1cmF0aW9uKCkgOiBjaGlsZC5fdER1cikgKyAoYWRqdXN0ZWRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cywgc3VwcHJlc3NFdmVudHMsIGZvcmNlIHx8IF9yZXZlcnRpbmcgJiYgKGNoaWxkLl9pbml0dGVkIHx8IGNoaWxkLl9zdGFydEF0KSk7IC8vIGlmIHJldmVydGluZywgd2Ugc2hvdWxkIGFsd2F5cyBmb3JjZSByZW5kZXJzIG9mIGluaXR0ZWQgdHdlZW5zIChidXQgcmVtZW1iZXIgdGhhdCAuZnJvbVRvKCkgb3IgLmZyb20oKSBtYXkgaGF2ZSBhIF9zdGFydEF0IGJ1dCBub3QgX2luaXR0ZWQgeWV0KS4gSWYsIGZvciBleGFtcGxlLCBhIC5mcm9tVG8oKSB0d2VlbiB3aXRoIGEgc3RhZ2dlciAod2hpY2ggY3JlYXRlcyBhbiBpbnRlcm5hbCB0aW1lbGluZSkgZ2V0cyByZXZlcnRlZCBCRUZPUkUgc29tZSBvZiBpdHMgY2hpbGQgdHdlZW5zIHJlbmRlciBmb3IgdGhlIGZpcnN0IHRpbWUsIGl0IG1heSBub3QgcHJvcGVybHkgdHJpZ2dlciB0aGVtIHRvIHJldmVydC5cblxuICAgICAgICAgICAgaWYgKHRpbWUgIT09IHRoaXMuX3RpbWUgfHwgIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSB7XG4gICAgICAgICAgICAgIC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcbiAgICAgICAgICAgICAgcGF1c2VUd2VlbiA9IDA7XG4gICAgICAgICAgICAgIG5leHQgJiYgKHRUaW1lICs9IHRoaXMuX3pUaW1lID0gYWRqdXN0ZWRUaW1lID8gLV90aW55TnVtIDogX3RpbnlOdW0pOyAvLyBpdCBkaWRuJ3QgZmluaXNoIHJlbmRlcmluZywgc28gYWRqdXN0IHpUaW1lIHNvIHRoYXQgc28gdGhhdCB0aGUgbmV4dCB0aW1lIHJlbmRlcigpIGlzIGNhbGxlZCBpdCdsbCBiZSBmb3JjZWQgKHRvIHJlbmRlciBhbnkgcmVtYWluaW5nIGNoaWxkcmVuKVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoaWxkID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGF1c2VUd2VlbiAmJiAhc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICBwYXVzZVR3ZWVuLnJlbmRlcih0aW1lID49IHByZXZUaW1lID8gMCA6IC1fdGlueU51bSkuX3pUaW1lID0gdGltZSA+PSBwcmV2VGltZSA/IDEgOiAtMTtcblxuICAgICAgICBpZiAodGhpcy5fdHMpIHtcbiAgICAgICAgICAvL3RoZSBjYWxsYmFjayByZXN1bWVkIHBsYXliYWNrISBTbyBzaW5jZSB3ZSBtYXkgaGF2ZSBoZWxkIGJhY2sgdGhlIHBsYXloZWFkIGR1ZSB0byB3aGVyZSB0aGUgcGF1c2UgaXMgcG9zaXRpb25lZCwgZ28gYWhlYWQgYW5kIGp1bXAgdG8gd2hlcmUgaXQncyBTVVBQT1NFRCB0byBiZSAoaWYgbm8gcGF1c2UgaGFwcGVuZWQpLlxuICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gcHJldlN0YXJ0OyAvL2lmIHRoZSBwYXVzZSB3YXMgYXQgYW4gZWFybGllciB0aW1lIGFuZCB0aGUgdXNlciByZXN1bWVkIGluIHRoZSBjYWxsYmFjaywgaXQgY291bGQgcmVwb3NpdGlvbiB0aGUgdGltZWxpbmUgKGNoYW5naW5nIGl0cyBzdGFydFRpbWUpLCB0aHJvd2luZyB0aGluZ3Mgb2ZmIHNsaWdodGx5LCBzbyB3ZSBtYWtlIHN1cmUgdGhlIF9zdGFydCBkb2Vzbid0IHNoaWZ0LlxuXG4gICAgICAgICAgX3NldEVuZCh0aGlzKTtcblxuICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uVXBkYXRlXCIsIHRydWUpO1xuICAgICAgaWYgKHRUaW1lID09PSB0RHVyICYmIHRoaXMuX3RUaW1lID49IHRoaXMudG90YWxEdXJhdGlvbigpIHx8ICF0VGltZSAmJiBwcmV2VGltZSkgaWYgKHByZXZTdGFydCA9PT0gdGhpcy5fc3RhcnQgfHwgTWF0aC5hYnModGltZVNjYWxlKSAhPT0gTWF0aC5hYnModGhpcy5fdHMpKSBpZiAoIXRoaXMuX2xvY2spIHtcbiAgICAgICAgLy8gcmVtZW1iZXIsIGEgY2hpbGQncyBjYWxsYmFjayBtYXkgYWx0ZXIgdGhpcyB0aW1lbGluZSdzIHBsYXloZWFkIG9yIHRpbWVTY2FsZSB3aGljaCBpcyB3aHkgd2UgbmVlZCB0byBhZGQgc29tZSBvZiB0aGVzZSBjaGVja3MuXG4gICAgICAgICh0b3RhbFRpbWUgfHwgIWR1cikgJiYgKHRUaW1lID09PSB0RHVyICYmIHRoaXMuX3RzID4gMCB8fCAhdFRpbWUgJiYgdGhpcy5fdHMgPCAwKSAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0aGlzLCAxKTsgLy8gZG9uJ3QgcmVtb3ZlIGlmIHRoZSB0aW1lbGluZSBpcyByZXZlcnNlZCBhbmQgdGhlIHBsYXloZWFkIGlzbid0IGF0IDAsIG90aGVyd2lzZSB0bC5wcm9ncmVzcygxKS5yZXZlcnNlKCkgd29uJ3Qgd29yay4gT25seSByZW1vdmUgaWYgdGhlIHBsYXloZWFkIGlzIGF0IHRoZSBlbmQgYW5kIHRpbWVTY2FsZSBpcyBwb3NpdGl2ZSwgb3IgaWYgdGhlIHBsYXloZWFkIGlzIGF0IDAgYW5kIHRoZSB0aW1lU2NhbGUgaXMgbmVnYXRpdmUuXG5cbiAgICAgICAgaWYgKCFzdXBwcmVzc0V2ZW50cyAmJiAhKHRvdGFsVGltZSA8IDAgJiYgIXByZXZUaW1lKSAmJiAodFRpbWUgfHwgcHJldlRpbWUgfHwgIXREdXIpKSB7XG4gICAgICAgICAgX2NhbGxiYWNrKHRoaXMsIHRUaW1lID09PSB0RHVyICYmIHRvdGFsVGltZSA+PSAwID8gXCJvbkNvbXBsZXRlXCIgOiBcIm9uUmV2ZXJzZUNvbXBsZXRlXCIsIHRydWUpO1xuXG4gICAgICAgICAgdGhpcy5fcHJvbSAmJiAhKHRUaW1lIDwgdER1ciAmJiB0aGlzLnRpbWVTY2FsZSgpID4gMCkgJiYgdGhpcy5fcHJvbSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGQgPSBmdW5jdGlvbiBhZGQoY2hpbGQsIHBvc2l0aW9uKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBfaXNOdW1iZXIocG9zaXRpb24pIHx8IChwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uLCBjaGlsZCkpO1xuXG4gICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBBbmltYXRpb24pKSB7XG4gICAgICBpZiAoX2lzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuYWRkKG9iaiwgcG9zaXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNTdHJpbmcoY2hpbGQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZExhYmVsKGNoaWxkLCBwb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNGdW5jdGlvbihjaGlsZCkpIHtcbiAgICAgICAgY2hpbGQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcyAhPT0gY2hpbGQgPyBfYWRkVG9UaW1lbGluZSh0aGlzLCBjaGlsZCwgcG9zaXRpb24pIDogdGhpczsgLy9kb24ndCBhbGxvdyBhIHRpbWVsaW5lIHRvIGJlIGFkZGVkIHRvIGl0c2VsZiBhcyBhIGNoaWxkIVxuICB9O1xuXG4gIF9wcm90bzIuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRDaGlsZHJlbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgaWYgKG5lc3RlZCA9PT0gdm9pZCAwKSB7XG4gICAgICBuZXN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0d2VlbnMgPT09IHZvaWQgMCkge1xuICAgICAgdHdlZW5zID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGltZWxpbmVzID09PSB2b2lkIDApIHtcbiAgICAgIHRpbWVsaW5lcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlnbm9yZUJlZm9yZVRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgaWdub3JlQmVmb3JlVGltZSA9IC1fYmlnTnVtO1xuICAgIH1cblxuICAgIHZhciBhID0gW10sXG4gICAgICAgIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5fc3RhcnQgPj0gaWdub3JlQmVmb3JlVGltZSkge1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUd2Vlbikge1xuICAgICAgICAgIHR3ZWVucyAmJiBhLnB1c2goY2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVsaW5lcyAmJiBhLnB1c2goY2hpbGQpO1xuICAgICAgICAgIG5lc3RlZCAmJiBhLnB1c2guYXBwbHkoYSwgY2hpbGQuZ2V0Q2hpbGRyZW4odHJ1ZSwgdHdlZW5zLCB0aW1lbGluZXMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0QnlJZCA9IGZ1bmN0aW9uIGdldEJ5SWQoaWQpIHtcbiAgICB2YXIgYW5pbWF0aW9ucyA9IHRoaXMuZ2V0Q2hpbGRyZW4oMSwgMSwgMSksXG4gICAgICAgIGkgPSBhbmltYXRpb25zLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChhbmltYXRpb25zW2ldLnZhcnMuaWQgPT09IGlkKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRpb25zW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8yLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShjaGlsZCkge1xuICAgIGlmIChfaXNTdHJpbmcoY2hpbGQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmVMYWJlbChjaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKF9pc0Z1bmN0aW9uKGNoaWxkKSkge1xuICAgICAgcmV0dXJuIHRoaXMua2lsbFR3ZWVuc09mKGNoaWxkKTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0odGhpcywgY2hpbGQpO1xuXG4gICAgaWYgKGNoaWxkID09PSB0aGlzLl9yZWNlbnQpIHtcbiAgICAgIHRoaXMuX3JlY2VudCA9IHRoaXMuX2xhc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIudG90YWxUaW1lID0gZnVuY3Rpb24gdG90YWxUaW1lKF90b3RhbFRpbWUyLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RUaW1lO1xuICAgIH1cblxuICAgIHRoaXMuX2ZvcmNpbmcgPSAxO1xuXG4gICAgaWYgKCF0aGlzLl9kcCAmJiB0aGlzLl90cykge1xuICAgICAgLy9zcGVjaWFsIGNhc2UgZm9yIHRoZSBnbG9iYWwgdGltZWxpbmUgKG9yIGFueSBvdGhlciB0aGF0IGhhcyBubyBwYXJlbnQgb3IgZGV0YWNoZWQgcGFyZW50KS5cbiAgICAgIHRoaXMuX3N0YXJ0ID0gX3JvdW5kUHJlY2lzZShfdGlja2VyLnRpbWUgLSAodGhpcy5fdHMgPiAwID8gX3RvdGFsVGltZTIgLyB0aGlzLl90cyA6ICh0aGlzLnRvdGFsRHVyYXRpb24oKSAtIF90b3RhbFRpbWUyKSAvIC10aGlzLl90cykpO1xuICAgIH1cblxuICAgIF9BbmltYXRpb24ucHJvdG90eXBlLnRvdGFsVGltZS5jYWxsKHRoaXMsIF90b3RhbFRpbWUyLCBzdXBwcmVzc0V2ZW50cyk7XG5cbiAgICB0aGlzLl9mb3JjaW5nID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmFkZExhYmVsID0gZnVuY3Rpb24gYWRkTGFiZWwobGFiZWwsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5sYWJlbHNbbGFiZWxdID0gX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIucmVtb3ZlTGFiZWwgPSBmdW5jdGlvbiByZW1vdmVMYWJlbChsYWJlbCkge1xuICAgIGRlbGV0ZSB0aGlzLmxhYmVsc1tsYWJlbF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGRQYXVzZSA9IGZ1bmN0aW9uIGFkZFBhdXNlKHBvc2l0aW9uLCBjYWxsYmFjaywgcGFyYW1zKSB7XG4gICAgdmFyIHQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjayB8fCBfZW1wdHlGdW5jLCBwYXJhbXMpO1xuICAgIHQuZGF0YSA9IFwiaXNQYXVzZVwiO1xuICAgIHRoaXMuX2hhc1BhdXNlID0gMTtcbiAgICByZXR1cm4gX2FkZFRvVGltZWxpbmUodGhpcywgdCwgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pKTtcbiAgfTtcblxuICBfcHJvdG8yLnJlbW92ZVBhdXNlID0gZnVuY3Rpb24gcmVtb3ZlUGF1c2UocG9zaXRpb24pIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdDtcbiAgICBwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLl9zdGFydCA9PT0gcG9zaXRpb24gJiYgY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIpIHtcbiAgICAgICAgX3JlbW92ZUZyb21QYXJlbnQoY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8yLmtpbGxUd2VlbnNPZiA9IGZ1bmN0aW9uIGtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSkge1xuICAgIHZhciB0d2VlbnMgPSB0aGlzLmdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpLFxuICAgICAgICBpID0gdHdlZW5zLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuICE9PSB0d2VlbnNbaV0gJiYgdHdlZW5zW2ldLmtpbGwodGFyZ2V0cywgcHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0VHdlZW5zT2YgPSBmdW5jdGlvbiBnZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSB7XG4gICAgdmFyIGEgPSBbXSxcbiAgICAgICAgcGFyc2VkVGFyZ2V0cyA9IHRvQXJyYXkodGFyZ2V0cyksXG4gICAgICAgIGNoaWxkID0gdGhpcy5fZmlyc3QsXG4gICAgICAgIGlzR2xvYmFsVGltZSA9IF9pc051bWJlcihvbmx5QWN0aXZlKSxcbiAgICAgICAgLy8gYSBudW1iZXIgaXMgaW50ZXJwcmV0ZWQgYXMgYSBnbG9iYWwgdGltZS4gSWYgdGhlIGFuaW1hdGlvbiBzcGFuc1xuICAgIGNoaWxkcmVuO1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUd2Vlbikge1xuICAgICAgICBpZiAoX2FycmF5Q29udGFpbnNBbnkoY2hpbGQuX3RhcmdldHMsIHBhcnNlZFRhcmdldHMpICYmIChpc0dsb2JhbFRpbWUgPyAoIV9vdmVyd3JpdGluZ1R3ZWVuIHx8IGNoaWxkLl9pbml0dGVkICYmIGNoaWxkLl90cykgJiYgY2hpbGQuZ2xvYmFsVGltZSgwKSA8PSBvbmx5QWN0aXZlICYmIGNoaWxkLmdsb2JhbFRpbWUoY2hpbGQudG90YWxEdXJhdGlvbigpKSA+IG9ubHlBY3RpdmUgOiAhb25seUFjdGl2ZSB8fCBjaGlsZC5pc0FjdGl2ZSgpKSkge1xuICAgICAgICAgIC8vIG5vdGU6IGlmIHRoaXMgaXMgZm9yIG92ZXJ3cml0aW5nLCBpdCBzaG91bGQgb25seSBiZSBmb3IgdHdlZW5zIHRoYXQgYXJlbid0IHBhdXNlZCBhbmQgYXJlIGluaXR0ZWQuXG4gICAgICAgICAgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoY2hpbGRyZW4gPSBjaGlsZC5nZXRUd2VlbnNPZihwYXJzZWRUYXJnZXRzLCBvbmx5QWN0aXZlKSkubGVuZ3RoKSB7XG4gICAgICAgIGEucHVzaC5hcHBseShhLCBjaGlsZHJlbik7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH0gLy8gcG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlIC0gdGFyZ2V0cygpIG9uIHRpbWVsaW5lc1xuICAvLyB0YXJnZXRzKCkge1xuICAvLyBcdGxldCByZXN1bHQgPSBbXTtcbiAgLy8gXHR0aGlzLmdldENoaWxkcmVuKHRydWUsIHRydWUsIGZhbHNlKS5mb3JFYWNoKHQgPT4gcmVzdWx0LnB1c2goLi4udC50YXJnZXRzKCkpKTtcbiAgLy8gXHRyZXR1cm4gcmVzdWx0LmZpbHRlcigodiwgaSkgPT4gcmVzdWx0LmluZGV4T2YodikgPT09IGkpO1xuICAvLyB9XG4gIDtcblxuICBfcHJvdG8yLnR3ZWVuVG8gPSBmdW5jdGlvbiB0d2VlblRvKHBvc2l0aW9uLCB2YXJzKSB7XG4gICAgdmFycyA9IHZhcnMgfHwge307XG5cbiAgICB2YXIgdGwgPSB0aGlzLFxuICAgICAgICBlbmRUaW1lID0gX3BhcnNlUG9zaXRpb24odGwsIHBvc2l0aW9uKSxcbiAgICAgICAgX3ZhcnMgPSB2YXJzLFxuICAgICAgICBzdGFydEF0ID0gX3ZhcnMuc3RhcnRBdCxcbiAgICAgICAgX29uU3RhcnQgPSBfdmFycy5vblN0YXJ0LFxuICAgICAgICBvblN0YXJ0UGFyYW1zID0gX3ZhcnMub25TdGFydFBhcmFtcyxcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyID0gX3ZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICBpbml0dGVkLFxuICAgICAgICB0d2VlbiA9IFR3ZWVuLnRvKHRsLCBfc2V0RGVmYXVsdHMoe1xuICAgICAgZWFzZTogdmFycy5lYXNlIHx8IFwibm9uZVwiLFxuICAgICAgbGF6eTogZmFsc2UsXG4gICAgICBpbW1lZGlhdGVSZW5kZXI6IGZhbHNlLFxuICAgICAgdGltZTogZW5kVGltZSxcbiAgICAgIG92ZXJ3cml0ZTogXCJhdXRvXCIsXG4gICAgICBkdXJhdGlvbjogdmFycy5kdXJhdGlvbiB8fCBNYXRoLmFicygoZW5kVGltZSAtIChzdGFydEF0ICYmIFwidGltZVwiIGluIHN0YXJ0QXQgPyBzdGFydEF0LnRpbWUgOiB0bC5fdGltZSkpIC8gdGwudGltZVNjYWxlKCkpIHx8IF90aW55TnVtLFxuICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHtcbiAgICAgICAgdGwucGF1c2UoKTtcblxuICAgICAgICBpZiAoIWluaXR0ZWQpIHtcbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSB2YXJzLmR1cmF0aW9uIHx8IE1hdGguYWJzKChlbmRUaW1lIC0gKHN0YXJ0QXQgJiYgXCJ0aW1lXCIgaW4gc3RhcnRBdCA/IHN0YXJ0QXQudGltZSA6IHRsLl90aW1lKSkgLyB0bC50aW1lU2NhbGUoKSk7XG4gICAgICAgICAgdHdlZW4uX2R1ciAhPT0gZHVyYXRpb24gJiYgX3NldER1cmF0aW9uKHR3ZWVuLCBkdXJhdGlvbiwgMCwgMSkucmVuZGVyKHR3ZWVuLl90aW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBpbml0dGVkID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9vblN0YXJ0ICYmIF9vblN0YXJ0LmFwcGx5KHR3ZWVuLCBvblN0YXJ0UGFyYW1zIHx8IFtdKTsgLy9pbiBjYXNlIHRoZSB1c2VyIGhhZCBhbiBvblN0YXJ0IGluIHRoZSB2YXJzIC0gd2UgZG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgaXQuXG4gICAgICB9XG4gICAgfSwgdmFycykpO1xuXG4gICAgcmV0dXJuIGltbWVkaWF0ZVJlbmRlciA/IHR3ZWVuLnJlbmRlcigwKSA6IHR3ZWVuO1xuICB9O1xuXG4gIF9wcm90bzIudHdlZW5Gcm9tVG8gPSBmdW5jdGlvbiB0d2VlbkZyb21Ubyhmcm9tUG9zaXRpb24sIHRvUG9zaXRpb24sIHZhcnMpIHtcbiAgICByZXR1cm4gdGhpcy50d2VlblRvKHRvUG9zaXRpb24sIF9zZXREZWZhdWx0cyh7XG4gICAgICBzdGFydEF0OiB7XG4gICAgICAgIHRpbWU6IF9wYXJzZVBvc2l0aW9uKHRoaXMsIGZyb21Qb3NpdGlvbilcbiAgICAgIH1cbiAgICB9LCB2YXJzKSk7XG4gIH07XG5cbiAgX3Byb3RvMi5yZWNlbnQgPSBmdW5jdGlvbiByZWNlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlY2VudDtcbiAgfTtcblxuICBfcHJvdG8yLm5leHRMYWJlbCA9IGZ1bmN0aW9uIG5leHRMYWJlbChhZnRlclRpbWUpIHtcbiAgICBpZiAoYWZ0ZXJUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGFmdGVyVGltZSA9IHRoaXMuX3RpbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXRMYWJlbEluRGlyZWN0aW9uKHRoaXMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIGFmdGVyVGltZSkpO1xuICB9O1xuXG4gIF9wcm90bzIucHJldmlvdXNMYWJlbCA9IGZ1bmN0aW9uIHByZXZpb3VzTGFiZWwoYmVmb3JlVGltZSkge1xuICAgIGlmIChiZWZvcmVUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGJlZm9yZVRpbWUgPSB0aGlzLl90aW1lO1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0TGFiZWxJbkRpcmVjdGlvbih0aGlzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBiZWZvcmVUaW1lKSwgMSk7XG4gIH07XG5cbiAgX3Byb3RvMi5jdXJyZW50TGFiZWwgPSBmdW5jdGlvbiBjdXJyZW50TGFiZWwodmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuc2Vlayh2YWx1ZSwgdHJ1ZSkgOiB0aGlzLnByZXZpb3VzTGFiZWwodGhpcy5fdGltZSArIF90aW55TnVtKTtcbiAgfTtcblxuICBfcHJvdG8yLnNoaWZ0Q2hpbGRyZW4gPSBmdW5jdGlvbiBzaGlmdENoaWxkcmVuKGFtb3VudCwgYWRqdXN0TGFiZWxzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgaWYgKGlnbm9yZUJlZm9yZVRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgaWdub3JlQmVmb3JlVGltZSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3QsXG4gICAgICAgIGxhYmVscyA9IHRoaXMubGFiZWxzLFxuICAgICAgICBwO1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuX3N0YXJ0ID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgICAgY2hpbGQuX3N0YXJ0ICs9IGFtb3VudDtcbiAgICAgICAgY2hpbGQuX2VuZCArPSBhbW91bnQ7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgaWYgKGFkanVzdExhYmVscykge1xuICAgICAgZm9yIChwIGluIGxhYmVscykge1xuICAgICAgICBpZiAobGFiZWxzW3BdID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgICAgICBsYWJlbHNbcF0gKz0gYW1vdW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uIGludmFsaWRhdGUoc29mdCkge1xuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuICAgIHRoaXMuX2xvY2sgPSAwO1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBjaGlsZC5pbnZhbGlkYXRlKHNvZnQpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gX0FuaW1hdGlvbi5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMsIHNvZnQpO1xuICB9O1xuXG4gIF9wcm90bzIuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcihpbmNsdWRlTGFiZWxzKSB7XG4gICAgaWYgKGluY2x1ZGVMYWJlbHMgPT09IHZvaWQgMCkge1xuICAgICAgaW5jbHVkZUxhYmVscyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3QsXG4gICAgICAgIG5leHQ7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIG5leHQgPSBjaGlsZC5fbmV4dDtcbiAgICAgIHRoaXMucmVtb3ZlKGNoaWxkKTtcbiAgICAgIGNoaWxkID0gbmV4dDtcbiAgICB9XG5cbiAgICB0aGlzLl9kcCAmJiAodGhpcy5fdGltZSA9IHRoaXMuX3RUaW1lID0gdGhpcy5fcFRpbWUgPSAwKTtcbiAgICBpbmNsdWRlTGFiZWxzICYmICh0aGlzLmxhYmVscyA9IHt9KTtcbiAgICByZXR1cm4gX3VuY2FjaGUodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvMi50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24gdG90YWxEdXJhdGlvbih2YWx1ZSkge1xuICAgIHZhciBtYXggPSAwLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgY2hpbGQgPSBzZWxmLl9sYXN0LFxuICAgICAgICBwcmV2U3RhcnQgPSBfYmlnTnVtLFxuICAgICAgICBwcmV2LFxuICAgICAgICBzdGFydCxcbiAgICAgICAgcGFyZW50O1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBzZWxmLnRpbWVTY2FsZSgoc2VsZi5fcmVwZWF0IDwgMCA/IHNlbGYuZHVyYXRpb24oKSA6IHNlbGYudG90YWxEdXJhdGlvbigpKSAvIChzZWxmLnJldmVyc2VkKCkgPyAtdmFsdWUgOiB2YWx1ZSkpO1xuICAgIH1cblxuICAgIGlmIChzZWxmLl9kaXJ0eSkge1xuICAgICAgcGFyZW50ID0gc2VsZi5wYXJlbnQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBwcmV2ID0gY2hpbGQuX3ByZXY7IC8vcmVjb3JkIGl0IGhlcmUgaW4gY2FzZSB0aGUgdHdlZW4gY2hhbmdlcyBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2UuLi5cblxuICAgICAgICBjaGlsZC5fZGlydHkgJiYgY2hpbGQudG90YWxEdXJhdGlvbigpOyAvL2NvdWxkIGNoYW5nZSB0aGUgdHdlZW4uX3N0YXJ0VGltZSwgc28gbWFrZSBzdXJlIHRoZSBhbmltYXRpb24ncyBjYWNoZSBpcyBjbGVhbiBiZWZvcmUgYW5hbHl6aW5nIGl0LlxuXG4gICAgICAgIHN0YXJ0ID0gY2hpbGQuX3N0YXJ0O1xuXG4gICAgICAgIGlmIChzdGFydCA+IHByZXZTdGFydCAmJiBzZWxmLl9zb3J0ICYmIGNoaWxkLl90cyAmJiAhc2VsZi5fbG9jaykge1xuICAgICAgICAgIC8vaW4gY2FzZSBvbmUgb2YgdGhlIHR3ZWVucyBzaGlmdGVkIG91dCBvZiBvcmRlciwgaXQgbmVlZHMgdG8gYmUgcmUtaW5zZXJ0ZWQgaW50byB0aGUgY29ycmVjdCBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2VcbiAgICAgICAgICBzZWxmLl9sb2NrID0gMTsgLy9wcmV2ZW50IGVuZGxlc3MgcmVjdXJzaXZlIGNhbGxzIC0gdGhlcmUgYXJlIG1ldGhvZHMgdGhhdCBnZXQgdHJpZ2dlcmVkIHRoYXQgY2hlY2sgZHVyYXRpb24vdG90YWxEdXJhdGlvbiB3aGVuIHdlIGFkZCgpLlxuXG4gICAgICAgICAgX2FkZFRvVGltZWxpbmUoc2VsZiwgY2hpbGQsIHN0YXJ0IC0gY2hpbGQuX2RlbGF5LCAxKS5fbG9jayA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldlN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnQgPCAwICYmIGNoaWxkLl90cykge1xuICAgICAgICAgIC8vY2hpbGRyZW4gYXJlbid0IGFsbG93ZWQgdG8gaGF2ZSBuZWdhdGl2ZSBzdGFydFRpbWVzIHVubGVzcyBzbW9vdGhDaGlsZFRpbWluZyBpcyB0cnVlLCBzbyBhZGp1c3QgaGVyZSBpZiBvbmUgaXMgZm91bmQuXG4gICAgICAgICAgbWF4IC09IHN0YXJ0O1xuXG4gICAgICAgICAgaWYgKCFwYXJlbnQgJiYgIXNlbGYuX2RwIHx8IHBhcmVudCAmJiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcpIHtcbiAgICAgICAgICAgIHNlbGYuX3N0YXJ0ICs9IHN0YXJ0IC8gc2VsZi5fdHM7XG4gICAgICAgICAgICBzZWxmLl90aW1lIC09IHN0YXJ0O1xuICAgICAgICAgICAgc2VsZi5fdFRpbWUgLT0gc3RhcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5zaGlmdENoaWxkcmVuKC1zdGFydCwgZmFsc2UsIC0xZTk5OSk7XG4gICAgICAgICAgcHJldlN0YXJ0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkLl9lbmQgPiBtYXggJiYgY2hpbGQuX3RzICYmIChtYXggPSBjaGlsZC5fZW5kKTtcbiAgICAgICAgY2hpbGQgPSBwcmV2O1xuICAgICAgfVxuXG4gICAgICBfc2V0RHVyYXRpb24oc2VsZiwgc2VsZiA9PT0gX2dsb2JhbFRpbWVsaW5lICYmIHNlbGYuX3RpbWUgPiBtYXggPyBzZWxmLl90aW1lIDogbWF4LCAxLCAxKTtcblxuICAgICAgc2VsZi5fZGlydHkgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmLl90RHVyO1xuICB9O1xuXG4gIFRpbWVsaW5lLnVwZGF0ZVJvb3QgPSBmdW5jdGlvbiB1cGRhdGVSb290KHRpbWUpIHtcbiAgICBpZiAoX2dsb2JhbFRpbWVsaW5lLl90cykge1xuICAgICAgX2xhenlTYWZlUmVuZGVyKF9nbG9iYWxUaW1lbGluZSwgX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUodGltZSwgX2dsb2JhbFRpbWVsaW5lKSk7XG5cbiAgICAgIF9sYXN0UmVuZGVyZWRGcmFtZSA9IF90aWNrZXIuZnJhbWU7XG4gICAgfVxuXG4gICAgaWYgKF90aWNrZXIuZnJhbWUgPj0gX25leHRHQ0ZyYW1lKSB7XG4gICAgICBfbmV4dEdDRnJhbWUgKz0gX2NvbmZpZy5hdXRvU2xlZXAgfHwgMTIwO1xuICAgICAgdmFyIGNoaWxkID0gX2dsb2JhbFRpbWVsaW5lLl9maXJzdDtcbiAgICAgIGlmICghY2hpbGQgfHwgIWNoaWxkLl90cykgaWYgKF9jb25maWcuYXV0b1NsZWVwICYmIF90aWNrZXIuX2xpc3RlbmVycy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHdoaWxlIChjaGlsZCAmJiAhY2hpbGQuX3RzKSB7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkIHx8IF90aWNrZXIuc2xlZXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRpbWVsaW5lO1xufShBbmltYXRpb24pO1xuXG5fc2V0RGVmYXVsdHMoVGltZWxpbmUucHJvdG90eXBlLCB7XG4gIF9sb2NrOiAwLFxuICBfaGFzUGF1c2U6IDAsXG4gIF9mb3JjaW5nOiAwXG59KTtcblxudmFyIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBzZXR0ZXIsIHN0cmluZ0ZpbHRlciwgZnVuY1BhcmFtKSB7XG4gIC8vbm90ZTogd2UgY2FsbCBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHR3ZWVuSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cbiAgdmFyIHB0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LCBwcm9wLCAwLCAxLCBfcmVuZGVyQ29tcGxleFN0cmluZywgbnVsbCwgc2V0dGVyKSxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIG1hdGNoSW5kZXggPSAwLFxuICAgICAgcmVzdWx0LFxuICAgICAgc3RhcnROdW1zLFxuICAgICAgY29sb3IsXG4gICAgICBlbmROdW0sXG4gICAgICBjaHVuayxcbiAgICAgIHN0YXJ0TnVtLFxuICAgICAgaGFzUmFuZG9tLFxuICAgICAgYTtcbiAgcHQuYiA9IHN0YXJ0O1xuICBwdC5lID0gZW5kO1xuICBzdGFydCArPSBcIlwiOyAvL2Vuc3VyZSB2YWx1ZXMgYXJlIHN0cmluZ3NcblxuICBlbmQgKz0gXCJcIjtcblxuICBpZiAoaGFzUmFuZG9tID0gfmVuZC5pbmRleE9mKFwicmFuZG9tKFwiKSkge1xuICAgIGVuZCA9IF9yZXBsYWNlUmFuZG9tKGVuZCk7XG4gIH1cblxuICBpZiAoc3RyaW5nRmlsdGVyKSB7XG4gICAgYSA9IFtzdGFydCwgZW5kXTtcbiAgICBzdHJpbmdGaWx0ZXIoYSwgdGFyZ2V0LCBwcm9wKTsgLy9wYXNzIGFuIGFycmF5IHdpdGggdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgdmFsdWVzIGFuZCBsZXQgdGhlIGZpbHRlciBkbyB3aGF0ZXZlciBpdCBuZWVkcyB0byB0aGUgdmFsdWVzLlxuXG4gICAgc3RhcnQgPSBhWzBdO1xuICAgIGVuZCA9IGFbMV07XG4gIH1cblxuICBzdGFydE51bXMgPSBzdGFydC5tYXRjaChfY29tcGxleFN0cmluZ051bUV4cCkgfHwgW107XG5cbiAgd2hpbGUgKHJlc3VsdCA9IF9jb21wbGV4U3RyaW5nTnVtRXhwLmV4ZWMoZW5kKSkge1xuICAgIGVuZE51bSA9IHJlc3VsdFswXTtcbiAgICBjaHVuayA9IGVuZC5zdWJzdHJpbmcoaW5kZXgsIHJlc3VsdC5pbmRleCk7XG5cbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGNvbG9yID0gKGNvbG9yICsgMSkgJSA1O1xuICAgIH0gZWxzZSBpZiAoY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJyZ2JhKFwiKSB7XG4gICAgICBjb2xvciA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGVuZE51bSAhPT0gc3RhcnROdW1zW21hdGNoSW5kZXgrK10pIHtcbiAgICAgIHN0YXJ0TnVtID0gcGFyc2VGbG9hdChzdGFydE51bXNbbWF0Y2hJbmRleCAtIDFdKSB8fCAwOyAvL3RoZXNlIG5lc3RlZCBQcm9wVHdlZW5zIGFyZSBoYW5kbGVkIGluIGEgc3BlY2lhbCB3YXkgLSB3ZSdsbCBuZXZlciBhY3R1YWxseSBjYWxsIGEgcmVuZGVyIG9yIHNldHRlciBtZXRob2Qgb24gdGhlbS4gV2UnbGwganVzdCBsb29wIHRocm91Z2ggdGhlbSBpbiB0aGUgcGFyZW50IGNvbXBsZXggc3RyaW5nIFByb3BUd2VlbidzIHJlbmRlciBtZXRob2QuXG5cbiAgICAgIHB0Ll9wdCA9IHtcbiAgICAgICAgX25leHQ6IHB0Ll9wdCxcbiAgICAgICAgcDogY2h1bmsgfHwgbWF0Y2hJbmRleCA9PT0gMSA/IGNodW5rIDogXCIsXCIsXG4gICAgICAgIC8vbm90ZTogU1ZHIHNwZWMgYWxsb3dzIG9taXNzaW9uIG9mIGNvbW1hL3NwYWNlIHdoZW4gYSBuZWdhdGl2ZSBzaWduIGlzIHdlZGdlZCBiZXR3ZWVuIHR3byBudW1iZXJzLCBsaWtlIDIuNS01LjMgaW5zdGVhZCBvZiAyLjUsLTUuMyBidXQgd2hlbiB0d2VlbmluZywgdGhlIG5lZ2F0aXZlIHZhbHVlIG1heSBzd2l0Y2ggdG8gcG9zaXRpdmUsIHNvIHdlIGluc2VydCB0aGUgY29tbWEganVzdCBpbiBjYXNlLlxuICAgICAgICBzOiBzdGFydE51bSxcbiAgICAgICAgYzogZW5kTnVtLmNoYXJBdCgxKSA9PT0gXCI9XCIgPyBfcGFyc2VSZWxhdGl2ZShzdGFydE51bSwgZW5kTnVtKSAtIHN0YXJ0TnVtIDogcGFyc2VGbG9hdChlbmROdW0pIC0gc3RhcnROdW0sXG4gICAgICAgIG06IGNvbG9yICYmIGNvbG9yIDwgNCA/IE1hdGgucm91bmQgOiAwXG4gICAgICB9O1xuICAgICAgaW5kZXggPSBfY29tcGxleFN0cmluZ051bUV4cC5sYXN0SW5kZXg7XG4gICAgfVxuICB9XG5cbiAgcHQuYyA9IGluZGV4IDwgZW5kLmxlbmd0aCA/IGVuZC5zdWJzdHJpbmcoaW5kZXgsIGVuZC5sZW5ndGgpIDogXCJcIjsgLy93ZSB1c2UgdGhlIFwiY1wiIG9mIHRoZSBQcm9wVHdlZW4gdG8gc3RvcmUgdGhlIGZpbmFsIHBhcnQgb2YgdGhlIHN0cmluZyAoYWZ0ZXIgdGhlIGxhc3QgbnVtYmVyKVxuXG4gIHB0LmZwID0gZnVuY1BhcmFtO1xuXG4gIGlmIChfcmVsRXhwLnRlc3QoZW5kKSB8fCBoYXNSYW5kb20pIHtcbiAgICBwdC5lID0gMDsgLy9pZiB0aGUgZW5kIHN0cmluZyBjb250YWlucyByZWxhdGl2ZSB2YWx1ZXMgb3IgZHluYW1pYyByYW5kb20oLi4uKSB2YWx1ZXMsIGRlbGV0ZSB0aGUgZW5kIGl0IHNvIHRoYXQgb24gdGhlIGZpbmFsIHJlbmRlciB3ZSBkb24ndCBhY3R1YWxseSBzZXQgaXQgdG8gdGhlIHN0cmluZyB3aXRoICs9IG9yIC09IGNoYXJhY3RlcnMgKGZvcmNlcyBpdCB0byB1c2UgdGhlIGNhbGN1bGF0ZWQgdmFsdWUpLlxuICB9XG5cbiAgdGhpcy5fcHQgPSBwdDsgLy9zdGFydCB0aGUgbGlua2VkIGxpc3Qgd2l0aCB0aGlzIG5ldyBQcm9wVHdlZW4uIFJlbWVtYmVyLCB3ZSBjYWxsIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuLmNhbGwodHdlZW5JbnN0YW5jZS4uLikgdG8gZW5zdXJlIHRoYXQgaXQncyBzY29wZWQgcHJvcGVybHkuIFdlIG1heSBjYWxsIGl0IGZyb20gd2l0aGluIGEgcGx1Z2luIHRvbywgdGh1cyBcInRoaXNcIiB3b3VsZCByZWZlciB0byB0aGUgcGx1Z2luLlxuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX2FkZFByb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGRQcm9wVHdlZW4odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBpbmRleCwgdGFyZ2V0cywgbW9kaWZpZXIsIHN0cmluZ0ZpbHRlciwgZnVuY1BhcmFtLCBvcHRpb25hbCkge1xuICBfaXNGdW5jdGlvbihlbmQpICYmIChlbmQgPSBlbmQoaW5kZXggfHwgMCwgdGFyZ2V0LCB0YXJnZXRzKSk7XG4gIHZhciBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcHJvcF0sXG4gICAgICBwYXJzZWRTdGFydCA9IHN0YXJ0ICE9PSBcImdldFwiID8gc3RhcnQgOiAhX2lzRnVuY3Rpb24oY3VycmVudFZhbHVlKSA/IGN1cnJlbnRWYWx1ZSA6IGZ1bmNQYXJhbSA/IHRhcmdldFtwcm9wLmluZGV4T2YoXCJzZXRcIikgfHwgIV9pc0Z1bmN0aW9uKHRhcmdldFtcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKSA/IHByb3AgOiBcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKGZ1bmNQYXJhbSkgOiB0YXJnZXRbcHJvcF0oKSxcbiAgICAgIHNldHRlciA9ICFfaXNGdW5jdGlvbihjdXJyZW50VmFsdWUpID8gX3NldHRlclBsYWluIDogZnVuY1BhcmFtID8gX3NldHRlckZ1bmNXaXRoUGFyYW0gOiBfc2V0dGVyRnVuYyxcbiAgICAgIHB0O1xuXG4gIGlmIChfaXNTdHJpbmcoZW5kKSkge1xuICAgIGlmICh+ZW5kLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG4gICAgICBlbmQgPSBfcmVwbGFjZVJhbmRvbShlbmQpO1xuICAgIH1cblxuICAgIGlmIChlbmQuY2hhckF0KDEpID09PSBcIj1cIikge1xuICAgICAgcHQgPSBfcGFyc2VSZWxhdGl2ZShwYXJzZWRTdGFydCwgZW5kKSArIChnZXRVbml0KHBhcnNlZFN0YXJ0KSB8fCAwKTtcblxuICAgICAgaWYgKHB0IHx8IHB0ID09PSAwKSB7XG4gICAgICAgIC8vIHRvIGF2b2lkIGlzTmFOLCBsaWtlIGlmIHNvbWVvbmUgcGFzc2VzIGluIGEgdmFsdWUgbGlrZSBcIiE9IHdoYXRldmVyXCJcbiAgICAgICAgZW5kID0gcHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFvcHRpb25hbCB8fCBwYXJzZWRTdGFydCAhPT0gZW5kIHx8IF9mb3JjZUFsbFByb3BUd2VlbnMpIHtcbiAgICBpZiAoIWlzTmFOKHBhcnNlZFN0YXJ0ICogZW5kKSAmJiBlbmQgIT09IFwiXCIpIHtcbiAgICAgIC8vIGZ1biBmYWN0OiBhbnkgbnVtYmVyIG11bHRpcGxpZWQgYnkgXCJcIiBpcyBldmFsdWF0ZWQgYXMgdGhlIG51bWJlciAwIVxuICAgICAgcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCB0YXJnZXQsIHByb3AsICtwYXJzZWRTdGFydCB8fCAwLCBlbmQgLSAocGFyc2VkU3RhcnQgfHwgMCksIHR5cGVvZiBjdXJyZW50VmFsdWUgPT09IFwiYm9vbGVhblwiID8gX3JlbmRlckJvb2xlYW4gOiBfcmVuZGVyUGxhaW4sIDAsIHNldHRlcik7XG4gICAgICBmdW5jUGFyYW0gJiYgKHB0LmZwID0gZnVuY1BhcmFtKTtcbiAgICAgIG1vZGlmaWVyICYmIHB0Lm1vZGlmaWVyKG1vZGlmaWVyLCB0aGlzLCB0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRoaXMuX3B0ID0gcHQ7XG4gICAgfVxuXG4gICAgIWN1cnJlbnRWYWx1ZSAmJiAhKHByb3AgaW4gdGFyZ2V0KSAmJiBfbWlzc2luZ1BsdWdpbihwcm9wLCBlbmQpO1xuICAgIHJldHVybiBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHRoaXMsIHRhcmdldCwgcHJvcCwgcGFyc2VkU3RhcnQsIGVuZCwgc2V0dGVyLCBzdHJpbmdGaWx0ZXIgfHwgX2NvbmZpZy5zdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSk7XG4gIH1cbn0sXG4gICAgLy9jcmVhdGVzIGEgY29weSBvZiB0aGUgdmFycyBvYmplY3QgYW5kIHByb2Nlc3NlcyBhbnkgZnVuY3Rpb24tYmFzZWQgdmFsdWVzIChwdXR0aW5nIHRoZSByZXN1bHRpbmcgdmFsdWVzIGRpcmVjdGx5IGludG8gdGhlIGNvcHkpIGFzIHdlbGwgYXMgc3RyaW5ncyB3aXRoIFwicmFuZG9tKClcIiBpbiB0aGVtLiBJdCBkb2VzIE5PVCBwcm9jZXNzIHJlbGF0aXZlIHZhbHVlcy5cbl9wcm9jZXNzVmFycyA9IGZ1bmN0aW9uIF9wcm9jZXNzVmFycyh2YXJzLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzLCB0d2Vlbikge1xuICBfaXNGdW5jdGlvbih2YXJzKSAmJiAodmFycyA9IF9wYXJzZUZ1bmNPclN0cmluZyh2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykpO1xuXG4gIGlmICghX2lzT2JqZWN0KHZhcnMpIHx8IHZhcnMuc3R5bGUgJiYgdmFycy5ub2RlVHlwZSB8fCBfaXNBcnJheSh2YXJzKSB8fCBfaXNUeXBlZEFycmF5KHZhcnMpKSB7XG4gICAgcmV0dXJuIF9pc1N0cmluZyh2YXJzKSA/IF9wYXJzZUZ1bmNPclN0cmluZyh2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykgOiB2YXJzO1xuICB9XG5cbiAgdmFyIGNvcHkgPSB7fSxcbiAgICAgIHA7XG5cbiAgZm9yIChwIGluIHZhcnMpIHtcbiAgICBjb3B5W3BdID0gX3BhcnNlRnVuY09yU3RyaW5nKHZhcnNbcF0sIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKTtcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICBfY2hlY2tQbHVnaW4gPSBmdW5jdGlvbiBfY2hlY2tQbHVnaW4ocHJvcGVydHksIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSB7XG4gIHZhciBwbHVnaW4sIHB0LCBwdExvb2t1cCwgaTtcblxuICBpZiAoX3BsdWdpbnNbcHJvcGVydHldICYmIChwbHVnaW4gPSBuZXcgX3BsdWdpbnNbcHJvcGVydHldKCkpLmluaXQodGFyZ2V0LCBwbHVnaW4ucmF3VmFycyA/IHZhcnNbcHJvcGVydHldIDogX3Byb2Nlc3NWYXJzKHZhcnNbcHJvcGVydHldLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzLCB0d2VlbiksIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykgIT09IGZhbHNlKSB7XG4gICAgdHdlZW4uX3B0ID0gcHQgPSBuZXcgUHJvcFR3ZWVuKHR3ZWVuLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgMCwgMSwgcGx1Z2luLnJlbmRlciwgcGx1Z2luLCAwLCBwbHVnaW4ucHJpb3JpdHkpO1xuXG4gICAgaWYgKHR3ZWVuICE9PSBfcXVpY2tUd2Vlbikge1xuICAgICAgcHRMb29rdXAgPSB0d2Vlbi5fcHRMb29rdXBbdHdlZW4uX3RhcmdldHMuaW5kZXhPZih0YXJnZXQpXTsgLy9ub3RlOiB3ZSBjYW4ndCB1c2UgdHdlZW4uX3B0TG9va3VwW2luZGV4XSBiZWNhdXNlIGZvciBzdGFnZ2VyZWQgdHdlZW5zLCB0aGUgaW5kZXggZnJvbSB0aGUgZnVsbFRhcmdldHMgYXJyYXkgd29uJ3QgbWF0Y2ggd2hhdCBpdCBpcyBpbiBlYWNoIGluZGl2aWR1YWwgdHdlZW4gdGhhdCBzcGF3bnMgZnJvbSB0aGUgc3RhZ2dlci5cblxuICAgICAgaSA9IHBsdWdpbi5fcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHB0TG9va3VwW3BsdWdpbi5fcHJvcHNbaV1dID0gcHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBsdWdpbjtcbn0sXG4gICAgX292ZXJ3cml0aW5nVHdlZW4sXG4gICAgLy9zdG9yZSBhIHJlZmVyZW5jZSB0ZW1wb3JhcmlseSBzbyB3ZSBjYW4gYXZvaWQgb3ZlcndyaXRpbmcgaXRzZWxmLlxuX2ZvcmNlQWxsUHJvcFR3ZWVucyxcbiAgICBfaW5pdFR3ZWVuID0gZnVuY3Rpb24gX2luaXRUd2Vlbih0d2VlbiwgdGltZSwgdFRpbWUpIHtcbiAgdmFyIHZhcnMgPSB0d2Vlbi52YXJzLFxuICAgICAgZWFzZSA9IHZhcnMuZWFzZSxcbiAgICAgIHN0YXJ0QXQgPSB2YXJzLnN0YXJ0QXQsXG4gICAgICBpbW1lZGlhdGVSZW5kZXIgPSB2YXJzLmltbWVkaWF0ZVJlbmRlcixcbiAgICAgIGxhenkgPSB2YXJzLmxhenksXG4gICAgICBvblVwZGF0ZSA9IHZhcnMub25VcGRhdGUsXG4gICAgICBydW5CYWNrd2FyZHMgPSB2YXJzLnJ1bkJhY2t3YXJkcyxcbiAgICAgIHlveW9FYXNlID0gdmFycy55b3lvRWFzZSxcbiAgICAgIGtleWZyYW1lcyA9IHZhcnMua2V5ZnJhbWVzLFxuICAgICAgYXV0b1JldmVydCA9IHZhcnMuYXV0b1JldmVydCxcbiAgICAgIGR1ciA9IHR3ZWVuLl9kdXIsXG4gICAgICBwcmV2U3RhcnRBdCA9IHR3ZWVuLl9zdGFydEF0LFxuICAgICAgdGFyZ2V0cyA9IHR3ZWVuLl90YXJnZXRzLFxuICAgICAgcGFyZW50ID0gdHdlZW4ucGFyZW50LFxuICAgICAgZnVsbFRhcmdldHMgPSBwYXJlbnQgJiYgcGFyZW50LmRhdGEgPT09IFwibmVzdGVkXCIgPyBwYXJlbnQudmFycy50YXJnZXRzIDogdGFyZ2V0cyxcbiAgICAgIGF1dG9PdmVyd3JpdGUgPSB0d2Vlbi5fb3ZlcndyaXRlID09PSBcImF1dG9cIiAmJiAhX3N1cHByZXNzT3ZlcndyaXRlcyxcbiAgICAgIHRsID0gdHdlZW4udGltZWxpbmUsXG4gICAgICBjbGVhblZhcnMsXG4gICAgICBpLFxuICAgICAgcCxcbiAgICAgIHB0LFxuICAgICAgdGFyZ2V0LFxuICAgICAgaGFzUHJpb3JpdHksXG4gICAgICBnc0RhdGEsXG4gICAgICBoYXJuZXNzLFxuICAgICAgcGx1Z2luLFxuICAgICAgcHRMb29rdXAsXG4gICAgICBpbmRleCxcbiAgICAgIGhhcm5lc3NWYXJzLFxuICAgICAgb3ZlcndyaXR0ZW47XG4gIHRsICYmICgha2V5ZnJhbWVzIHx8ICFlYXNlKSAmJiAoZWFzZSA9IFwibm9uZVwiKTtcbiAgdHdlZW4uX2Vhc2UgPSBfcGFyc2VFYXNlKGVhc2UsIF9kZWZhdWx0cy5lYXNlKTtcbiAgdHdlZW4uX3lFYXNlID0geW95b0Vhc2UgPyBfaW52ZXJ0RWFzZShfcGFyc2VFYXNlKHlveW9FYXNlID09PSB0cnVlID8gZWFzZSA6IHlveW9FYXNlLCBfZGVmYXVsdHMuZWFzZSkpIDogMDtcblxuICBpZiAoeW95b0Vhc2UgJiYgdHdlZW4uX3lveW8gJiYgIXR3ZWVuLl9yZXBlYXQpIHtcbiAgICAvL3RoZXJlIG11c3QgaGF2ZSBiZWVuIGEgcGFyZW50IHRpbWVsaW5lIHdpdGggeW95bzp0cnVlIHRoYXQgaXMgY3VycmVudGx5IGluIGl0cyB5b3lvIHBoYXNlLCBzbyBmbGlwIHRoZSBlYXNlcy5cbiAgICB5b3lvRWFzZSA9IHR3ZWVuLl95RWFzZTtcbiAgICB0d2Vlbi5feUVhc2UgPSB0d2Vlbi5fZWFzZTtcbiAgICB0d2Vlbi5fZWFzZSA9IHlveW9FYXNlO1xuICB9XG5cbiAgdHdlZW4uX2Zyb20gPSAhdGwgJiYgISF2YXJzLnJ1bkJhY2t3YXJkczsgLy9uZXN0ZWQgdGltZWxpbmVzIHNob3VsZCBuZXZlciBydW4gYmFja3dhcmRzIC0gdGhlIGJhY2t3YXJkcy1uZXNzIGlzIGluIHRoZSBjaGlsZCB0d2VlbnMuXG5cbiAgaWYgKCF0bCB8fCBrZXlmcmFtZXMgJiYgIXZhcnMuc3RhZ2dlcikge1xuICAgIC8vaWYgdGhlcmUncyBhbiBpbnRlcm5hbCB0aW1lbGluZSwgc2tpcCBhbGwgdGhlIHBhcnNpbmcgYmVjYXVzZSB3ZSBwYXNzZWQgdGhhdCB0YXNrIGRvd24gdGhlIGNoYWluLlxuICAgIGhhcm5lc3MgPSB0YXJnZXRzWzBdID8gX2dldENhY2hlKHRhcmdldHNbMF0pLmhhcm5lc3MgOiAwO1xuICAgIGhhcm5lc3NWYXJzID0gaGFybmVzcyAmJiB2YXJzW2hhcm5lc3MucHJvcF07IC8vc29tZW9uZSBtYXkgbmVlZCB0byBzcGVjaWZ5IENTUy1zcGVjaWZpYyB2YWx1ZXMgQU5EIG5vbi1DU1MgdmFsdWVzLCBsaWtlIGlmIHRoZSBlbGVtZW50IGhhcyBhbiBcInhcIiBwcm9wZXJ0eSBwbHVzIGl0J3MgYSBzdGFuZGFyZCBET00gZWxlbWVudC4gV2UgYWxsb3cgcGVvcGxlIHRvIGRpc3Rpbmd1aXNoIGJ5IHdyYXBwaW5nIHBsdWdpbi1zcGVjaWZpYyBzdHVmZiBpbiBhIGNzczp7fSBvYmplY3QgZm9yIGV4YW1wbGUuXG5cbiAgICBjbGVhblZhcnMgPSBfY29weUV4Y2x1ZGluZyh2YXJzLCBfcmVzZXJ2ZWRQcm9wcyk7XG5cbiAgICBpZiAocHJldlN0YXJ0QXQpIHtcbiAgICAgIHByZXZTdGFydEF0Ll96VGltZSA8IDAgJiYgcHJldlN0YXJ0QXQucHJvZ3Jlc3MoMSk7IC8vIGluIGNhc2UgaXQncyBhIGxhenkgc3RhcnRBdCB0aGF0IGhhc24ndCByZW5kZXJlZCB5ZXQuXG5cbiAgICAgIHRpbWUgPCAwICYmIHJ1bkJhY2t3YXJkcyAmJiBpbW1lZGlhdGVSZW5kZXIgJiYgIWF1dG9SZXZlcnQgPyBwcmV2U3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpIDogcHJldlN0YXJ0QXQucmV2ZXJ0KHJ1bkJhY2t3YXJkcyAmJiBkdXIgPyBfcmV2ZXJ0Q29uZmlnTm9LaWxsIDogX3N0YXJ0QXRSZXZlcnRDb25maWcpOyAvLyBpZiBpdCdzIGEgXCJzdGFydEF0XCIgKG5vdCBcImZyb20oKVwiIG9yIHJ1bkJhY2t3YXJkczogdHJ1ZSksIHdlIG9ubHkgbmVlZCB0byBkbyBhIHNoYWxsb3cgcmV2ZXJ0IChrZWVwIHRyYW5zZm9ybXMgY2FjaGVkIGluIENTU1BsdWdpbilcbiAgICAgIC8vIGRvbid0IGp1c3QgX3JlbW92ZUZyb21QYXJlbnQocHJldlN0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKSkgYmVjYXVzZSB0aGF0J2xsIGxlYXZlIGlubGluZSBzdHlsZXMuIFdlJ3JlIGNyZWF0aW5nIGEgbmV3IF9zdGFydEF0IGZvciBcInN0YXJ0QXRcIiB0d2VlbnMgdGhhdCByZS1jYXB0dXJlIHRoaW5ncyB0byBlbnN1cmUgdGhhdCBpZiB0aGUgcHJlLXR3ZWVuIHZhbHVlcyBjaGFuZ2VkIHNpbmNlIHRoZSB0d2VlbiB3YXMgY3JlYXRlZCwgdGhleSdyZSByZWNvcmRlZC5cblxuICAgICAgcHJldlN0YXJ0QXQuX2xhenkgPSAwO1xuICAgIH1cblxuICAgIGlmIChzdGFydEF0KSB7XG4gICAgICBfcmVtb3ZlRnJvbVBhcmVudCh0d2Vlbi5fc3RhcnRBdCA9IFR3ZWVuLnNldCh0YXJnZXRzLCBfc2V0RGVmYXVsdHMoe1xuICAgICAgICBkYXRhOiBcImlzU3RhcnRcIixcbiAgICAgICAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIGltbWVkaWF0ZVJlbmRlcjogdHJ1ZSxcbiAgICAgICAgbGF6eTogIXByZXZTdGFydEF0ICYmIF9pc05vdEZhbHNlKGxhenkpLFxuICAgICAgICBzdGFydEF0OiBudWxsLFxuICAgICAgICBkZWxheTogMCxcbiAgICAgICAgb25VcGRhdGU6IG9uVXBkYXRlICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX2NhbGxiYWNrKHR3ZWVuLCBcIm9uVXBkYXRlXCIpO1xuICAgICAgICB9LFxuICAgICAgICBzdGFnZ2VyOiAwXG4gICAgICB9LCBzdGFydEF0KSkpOyAvL2NvcHkgdGhlIHByb3BlcnRpZXMvdmFsdWVzIGludG8gYSBuZXcgb2JqZWN0IHRvIGF2b2lkIGNvbGxpc2lvbnMsIGxpa2UgdmFyIHRvID0ge3g6MH0sIGZyb20gPSB7eDo1MDB9OyB0aW1lbGluZS5mcm9tVG8oZSwgZnJvbSwgdG8pLmZyb21UbyhlLCB0bywgZnJvbSk7XG5cblxuICAgICAgdHdlZW4uX3N0YXJ0QXQuX2RwID0gMDsgLy8gZG9uJ3QgYWxsb3cgaXQgdG8gZ2V0IHB1dCBiYWNrIGludG8gcm9vdCB0aW1lbGluZSEgTGlrZSB3aGVuIHJldmVydCgpIGlzIGNhbGxlZCBhbmQgdG90YWxUaW1lKCkgZ2V0cyBzZXQuXG5cbiAgICAgIHR3ZWVuLl9zdGFydEF0Ll9zYXQgPSB0d2VlbjsgLy8gdXNlZCBpbiBnbG9iYWxUaW1lKCkuIF9zYXQgc3RhbmRzIGZvciBfc3RhcnRBdFR3ZWVuXG5cbiAgICAgIHRpbWUgPCAwICYmIChfcmV2ZXJ0aW5nIHx8ICFpbW1lZGlhdGVSZW5kZXIgJiYgIWF1dG9SZXZlcnQpICYmIHR3ZWVuLl9zdGFydEF0LnJldmVydChfcmV2ZXJ0Q29uZmlnTm9LaWxsKTsgLy8gcmFyZSBlZGdlIGNhc2UsIGxpa2UgaWYgYSByZW5kZXIgaXMgZm9yY2VkIGluIHRoZSBuZWdhdGl2ZSBkaXJlY3Rpb24gb2YgYSBub24taW5pdHRlZCB0d2Vlbi5cblxuICAgICAgaWYgKGltbWVkaWF0ZVJlbmRlcikge1xuICAgICAgICBpZiAoZHVyICYmIHRpbWUgPD0gMCAmJiB0VGltZSA8PSAwKSB7XG4gICAgICAgICAgLy8gY2hlY2sgdFRpbWUgaGVyZSBiZWNhdXNlIGluIHRoZSBjYXNlIG9mIGEgeW95byB0d2VlbiB3aG9zZSBwbGF5aGVhZCBnZXRzIHB1c2hlZCB0byB0aGUgZW5kIGxpa2UgdHdlZW4ucHJvZ3Jlc3MoMSksIHdlIHNob3VsZCBhbGxvdyBpdCB0aHJvdWdoIHNvIHRoYXQgdGhlIG9uQ29tcGxldGUgZ2V0cyBmaXJlZCBwcm9wZXJseS5cbiAgICAgICAgICB0aW1lICYmICh0d2Vlbi5felRpbWUgPSB0aW1lKTtcbiAgICAgICAgICByZXR1cm47IC8vd2Ugc2tpcCBpbml0aWFsaXphdGlvbiBoZXJlIHNvIHRoYXQgb3ZlcndyaXRpbmcgZG9lc24ndCBvY2N1ciB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zLiBPdGhlcndpc2UsIGlmIHlvdSBjcmVhdGUgc2V2ZXJhbCBpbW1lZGlhdGVSZW5kZXI6dHJ1ZSB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0L3Byb3BlcnRpZXMgdG8gZHJvcCBpbnRvIGEgVGltZWxpbmUsIHRoZSBsYXN0IG9uZSBjcmVhdGVkIHdvdWxkIG92ZXJ3cml0ZSB0aGUgZmlyc3Qgb25lcyBiZWNhdXNlIHRoZXkgZGlkbid0IGdldCBwbGFjZWQgaW50byB0aGUgdGltZWxpbmUgeWV0IGJlZm9yZSB0aGUgZmlyc3QgcmVuZGVyIG9jY3VycyBhbmQga2lja3MgaW4gb3ZlcndyaXRpbmcuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJ1bkJhY2t3YXJkcyAmJiBkdXIpIHtcbiAgICAgIC8vZnJvbSgpIHR3ZWVucyBtdXN0IGJlIGhhbmRsZWQgdW5pcXVlbHk6IHRoZWlyIGJlZ2lubmluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZCBidXQgd2UgZG9uJ3Qgd2FudCBvdmVyd3JpdGluZyB0byBvY2N1ciB5ZXQgKHdoZW4gdGltZSBpcyBzdGlsbCAwKS4gV2FpdCB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zIGJlZm9yZSBkb2luZyBhbGwgdGhlIHJvdXRpbmVzIGxpa2Ugb3ZlcndyaXRpbmcuIEF0IHRoYXQgdGltZSwgd2Ugc2hvdWxkIHJlbmRlciBhdCB0aGUgRU5EIG9mIHRoZSB0d2VlbiB0byBlbnN1cmUgdGhhdCB0aGluZ3MgaW5pdGlhbGl6ZSBjb3JyZWN0bHkgKHJlbWVtYmVyLCBmcm9tKCkgdHdlZW5zIGdvIGJhY2t3YXJkcylcbiAgICAgIGlmICghcHJldlN0YXJ0QXQpIHtcbiAgICAgICAgdGltZSAmJiAoaW1tZWRpYXRlUmVuZGVyID0gZmFsc2UpOyAvL2luIHJhcmUgY2FzZXMgKGxpa2UgaWYgYSBmcm9tKCkgdHdlZW4gcnVucyBhbmQgdGhlbiBpcyBpbnZhbGlkYXRlKCktZWQpLCBpbW1lZGlhdGVSZW5kZXIgY291bGQgYmUgdHJ1ZSBidXQgdGhlIGluaXRpYWwgZm9yY2VkLXJlbmRlciBnZXRzIHNraXBwZWQsIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSB0aGUgcmVuZGVyIGluIHRoaXMgY29udGV4dCB3aGVuIHRoZSBfdGltZSBpcyBncmVhdGVyIHRoYW4gMFxuXG4gICAgICAgIHAgPSBfc2V0RGVmYXVsdHMoe1xuICAgICAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICAgICAgZGF0YTogXCJpc0Zyb21TdGFydFwiLFxuICAgICAgICAgIC8vd2UgdGFnIHRoZSB0d2VlbiB3aXRoIGFzIFwiaXNGcm9tU3RhcnRcIiBzbyB0aGF0IGlmIFtpbnNpZGUgYSBwbHVnaW5dIHdlIG5lZWQgdG8gb25seSBkbyBzb21ldGhpbmcgYXQgdGhlIHZlcnkgRU5EIG9mIGEgdHdlZW4sIHdlIGhhdmUgYSB3YXkgb2YgaWRlbnRpZnlpbmcgdGhpcyB0d2VlbiBhcyBtZXJlbHkgdGhlIG9uZSB0aGF0J3Mgc2V0dGluZyB0aGUgYmVnaW5uaW5nIHZhbHVlcyBmb3IgYSBcImZyb20oKVwiIHR3ZWVuLiBGb3IgZXhhbXBsZSwgY2xlYXJQcm9wcyBpbiBDU1NQbHVnaW4gc2hvdWxkIG9ubHkgZ2V0IGFwcGxpZWQgYXQgdGhlIHZlcnkgRU5EIG9mIGEgdHdlZW4gYW5kIHdpdGhvdXQgdGhpcyB0YWcsIGZyb20oLi4ue2hlaWdodDoxMDAsIGNsZWFyUHJvcHM6XCJoZWlnaHRcIiwgZGVsYXk6MX0pIHdvdWxkIHdpcGUgdGhlIGhlaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0d2VlbiBhbmQgYWZ0ZXIgMSBzZWNvbmQsIGl0J2Qga2ljayBiYWNrIGluLlxuICAgICAgICAgIGxhenk6IGltbWVkaWF0ZVJlbmRlciAmJiAhcHJldlN0YXJ0QXQgJiYgX2lzTm90RmFsc2UobGF6eSksXG4gICAgICAgICAgaW1tZWRpYXRlUmVuZGVyOiBpbW1lZGlhdGVSZW5kZXIsXG4gICAgICAgICAgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyByZW5kZXIgaW1tZWRpYXRlbHkgYnkgZGVmYXVsdCwgYnV0IGlmIHdlJ3JlIG5vdCBzcGVjaWZpY2FsbHkgaW5zdHJ1Y3RlZCB0byByZW5kZXIgdGhpcyB0d2VlbiBpbW1lZGlhdGVseSwgd2Ugc2hvdWxkIHNraXAgdGhpcyBhbmQgbWVyZWx5IF9pbml0KCkgdG8gcmVjb3JkIHRoZSBzdGFydGluZyB2YWx1ZXMgKHJlbmRlcmluZyB0aGVtIGltbWVkaWF0ZWx5IHdvdWxkIHB1c2ggdGhlbSB0byBjb21wbGV0aW9uIHdoaWNoIGlzIHdhc3RlZnVsIGluIHRoYXQgY2FzZSAtIHdlJ2QgaGF2ZSB0byByZW5kZXIoLTEpIGltbWVkaWF0ZWx5IGFmdGVyKVxuICAgICAgICAgIHN0YWdnZXI6IDAsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnQgLy9lbnN1cmVzIHRoYXQgbmVzdGVkIHR3ZWVucyB0aGF0IGhhZCBhIHN0YWdnZXIgYXJlIGhhbmRsZWQgcHJvcGVybHksIGxpa2UgZ3NhcC5mcm9tKFwiLmNsYXNzXCIsIHt5OiBnc2FwLnV0aWxzLndyYXAoWy0xMDAsMTAwXSksIHN0YWdnZXI6IDAuNX0pXG5cbiAgICAgICAgfSwgY2xlYW5WYXJzKTtcbiAgICAgICAgaGFybmVzc1ZhcnMgJiYgKHBbaGFybmVzcy5wcm9wXSA9IGhhcm5lc3NWYXJzKTsgLy8gaW4gY2FzZSBzb21lb25lIGRvZXMgc29tZXRoaW5nIGxpa2UgLmZyb20oLi4uLCB7Y3NzOnt9fSlcblxuICAgICAgICBfcmVtb3ZlRnJvbVBhcmVudCh0d2Vlbi5fc3RhcnRBdCA9IFR3ZWVuLnNldCh0YXJnZXRzLCBwKSk7XG5cbiAgICAgICAgdHdlZW4uX3N0YXJ0QXQuX2RwID0gMDsgLy8gZG9uJ3QgYWxsb3cgaXQgdG8gZ2V0IHB1dCBiYWNrIGludG8gcm9vdCB0aW1lbGluZSFcblxuICAgICAgICB0d2Vlbi5fc3RhcnRBdC5fc2F0ID0gdHdlZW47IC8vIHVzZWQgaW4gZ2xvYmFsVGltZSgpXG5cbiAgICAgICAgdGltZSA8IDAgJiYgKF9yZXZlcnRpbmcgPyB0d2Vlbi5fc3RhcnRBdC5yZXZlcnQoX3JldmVydENvbmZpZ05vS2lsbCkgOiB0d2Vlbi5fc3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpKTtcbiAgICAgICAgdHdlZW4uX3pUaW1lID0gdGltZTtcblxuICAgICAgICBpZiAoIWltbWVkaWF0ZVJlbmRlcikge1xuICAgICAgICAgIF9pbml0VHdlZW4odHdlZW4uX3N0YXJ0QXQsIF90aW55TnVtLCBfdGlueU51bSk7IC8vZW5zdXJlcyB0aGF0IHRoZSBpbml0aWFsIHZhbHVlcyBhcmUgcmVjb3JkZWRcblxuICAgICAgICB9IGVsc2UgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHdlZW4uX3B0ID0gdHdlZW4uX3B0Q2FjaGUgPSAwO1xuICAgIGxhenkgPSBkdXIgJiYgX2lzTm90RmFsc2UobGF6eSkgfHwgbGF6eSAmJiAhZHVyO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICBnc0RhdGEgPSB0YXJnZXQuX2dzYXAgfHwgX2hhcm5lc3ModGFyZ2V0cylbaV0uX2dzYXA7XG4gICAgICB0d2Vlbi5fcHRMb29rdXBbaV0gPSBwdExvb2t1cCA9IHt9O1xuICAgICAgX2xhenlMb29rdXBbZ3NEYXRhLmlkXSAmJiBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTsgLy9pZiBvdGhlciB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0IGhhdmUgcmVjZW50bHkgaW5pdHRlZCBidXQgaGF2ZW4ndCByZW5kZXJlZCB5ZXQsIHdlJ3ZlIGdvdCB0byBmb3JjZSB0aGUgcmVuZGVyIHNvIHRoYXQgdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcmUgY29ycmVjdCAoaW1hZ2luZSBwb3B1bGF0aW5nIGEgdGltZWxpbmUgd2l0aCBhIGJ1bmNoIG9mIHNlcXVlbnRpYWwgdHdlZW5zIGFuZCB0aGVuIGp1bXBpbmcgdG8gdGhlIGVuZClcblxuICAgICAgaW5kZXggPSBmdWxsVGFyZ2V0cyA9PT0gdGFyZ2V0cyA/IGkgOiBmdWxsVGFyZ2V0cy5pbmRleE9mKHRhcmdldCk7XG5cbiAgICAgIGlmIChoYXJuZXNzICYmIChwbHVnaW4gPSBuZXcgaGFybmVzcygpKS5pbml0KHRhcmdldCwgaGFybmVzc1ZhcnMgfHwgY2xlYW5WYXJzLCB0d2VlbiwgaW5kZXgsIGZ1bGxUYXJnZXRzKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgdHdlZW4uX3B0ID0gcHQgPSBuZXcgUHJvcFR3ZWVuKHR3ZWVuLl9wdCwgdGFyZ2V0LCBwbHVnaW4ubmFtZSwgMCwgMSwgcGx1Z2luLnJlbmRlciwgcGx1Z2luLCAwLCBwbHVnaW4ucHJpb3JpdHkpO1xuXG4gICAgICAgIHBsdWdpbi5fcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHB0TG9va3VwW25hbWVdID0gcHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBsdWdpbi5wcmlvcml0eSAmJiAoaGFzUHJpb3JpdHkgPSAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXJuZXNzIHx8IGhhcm5lc3NWYXJzKSB7XG4gICAgICAgIGZvciAocCBpbiBjbGVhblZhcnMpIHtcbiAgICAgICAgICBpZiAoX3BsdWdpbnNbcF0gJiYgKHBsdWdpbiA9IF9jaGVja1BsdWdpbihwLCBjbGVhblZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCBmdWxsVGFyZ2V0cykpKSB7XG4gICAgICAgICAgICBwbHVnaW4ucHJpb3JpdHkgJiYgKGhhc1ByaW9yaXR5ID0gMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHB0TG9va3VwW3BdID0gcHQgPSBfYWRkUHJvcFR3ZWVuLmNhbGwodHdlZW4sIHRhcmdldCwgcCwgXCJnZXRcIiwgY2xlYW5WYXJzW3BdLCBpbmRleCwgZnVsbFRhcmdldHMsIDAsIHZhcnMuc3RyaW5nRmlsdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHdlZW4uX29wICYmIHR3ZWVuLl9vcFtpXSAmJiB0d2Vlbi5raWxsKHRhcmdldCwgdHdlZW4uX29wW2ldKTtcblxuICAgICAgaWYgKGF1dG9PdmVyd3JpdGUgJiYgdHdlZW4uX3B0KSB7XG4gICAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gdHdlZW47XG5cbiAgICAgICAgX2dsb2JhbFRpbWVsaW5lLmtpbGxUd2VlbnNPZih0YXJnZXQsIHB0TG9va3VwLCB0d2Vlbi5nbG9iYWxUaW1lKHRpbWUpKTsgLy8gbWFrZSBzdXJlIHRoZSBvdmVyd3JpdGluZyBkb2Vzbid0IG92ZXJ3cml0ZSBUSElTIHR3ZWVuISEhXG5cblxuICAgICAgICBvdmVyd3JpdHRlbiA9ICF0d2Vlbi5wYXJlbnQ7XG4gICAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gMDtcbiAgICAgIH1cblxuICAgICAgdHdlZW4uX3B0ICYmIGxhenkgJiYgKF9sYXp5TG9va3VwW2dzRGF0YS5pZF0gPSAxKTtcbiAgICB9XG5cbiAgICBoYXNQcmlvcml0eSAmJiBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5KHR3ZWVuKTtcbiAgICB0d2Vlbi5fb25Jbml0ICYmIHR3ZWVuLl9vbkluaXQodHdlZW4pOyAvL3BsdWdpbnMgbGlrZSBSb3VuZFByb3BzIG11c3Qgd2FpdCB1bnRpbCBBTEwgb2YgdGhlIFByb3BUd2VlbnMgYXJlIGluc3RhbnRpYXRlZC4gSW4gdGhlIHBsdWdpbidzIGluaXQoKSBmdW5jdGlvbiwgaXQgc2V0cyB0aGUgX29uSW5pdCBvbiB0aGUgdHdlZW4gaW5zdGFuY2UuIE1heSBub3QgYmUgcHJldHR5L2ludHVpdGl2ZSwgYnV0IGl0J3MgZmFzdCBhbmQga2VlcHMgZmlsZSBzaXplIGRvd24uXG4gIH1cblxuICB0d2Vlbi5fb25VcGRhdGUgPSBvblVwZGF0ZTtcbiAgdHdlZW4uX2luaXR0ZWQgPSAoIXR3ZWVuLl9vcCB8fCB0d2Vlbi5fcHQpICYmICFvdmVyd3JpdHRlbjsgLy8gaWYgb3ZlcndyaXR0ZW5Qcm9wcyByZXN1bHRlZCBpbiB0aGUgZW50aXJlIHR3ZWVuIGJlaW5nIGtpbGxlZCwgZG8gTk9UIGZsYWcgaXQgYXMgaW5pdHRlZCBvciBlbHNlIGl0IG1heSByZW5kZXIgZm9yIG9uZSB0aWNrLlxuXG4gIGtleWZyYW1lcyAmJiB0aW1lIDw9IDAgJiYgdGwucmVuZGVyKF9iaWdOdW0sIHRydWUsIHRydWUpOyAvLyBpZiB0aGVyZSdzIGEgMCUga2V5ZnJhbWUsIGl0J2xsIHJlbmRlciBpbiB0aGUgXCJiZWZvcmVcIiBzdGF0ZSBmb3IgYW55IHN0YWdnZXJlZC9kZWxheWVkIGFuaW1hdGlvbnMgdGh1cyB3aGVuIHRoZSBmb2xsb3dpbmcgdHdlZW4gaW5pdGlhbGl6ZXMsIGl0J2xsIHVzZSB0aGUgXCJiZWZvcmVcIiBzdGF0ZSBpbnN0ZWFkIG9mIHRoZSBcImFmdGVyXCIgc3RhdGUgYXMgdGhlIGluaXRpYWwgdmFsdWVzLlxufSxcbiAgICBfdXBkYXRlUHJvcFR3ZWVucyA9IGZ1bmN0aW9uIF91cGRhdGVQcm9wVHdlZW5zKHR3ZWVuLCBwcm9wZXJ0eSwgdmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUsIHJhdGlvLCB0aW1lLCBza2lwUmVjdXJzaW9uKSB7XG4gIHZhciBwdENhY2hlID0gKHR3ZWVuLl9wdCAmJiB0d2Vlbi5fcHRDYWNoZSB8fCAodHdlZW4uX3B0Q2FjaGUgPSB7fSkpW3Byb3BlcnR5XSxcbiAgICAgIHB0LFxuICAgICAgcm9vdFBULFxuICAgICAgbG9va3VwLFxuICAgICAgaTtcblxuICBpZiAoIXB0Q2FjaGUpIHtcbiAgICBwdENhY2hlID0gdHdlZW4uX3B0Q2FjaGVbcHJvcGVydHldID0gW107XG4gICAgbG9va3VwID0gdHdlZW4uX3B0TG9va3VwO1xuICAgIGkgPSB0d2Vlbi5fdGFyZ2V0cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBwdCA9IGxvb2t1cFtpXVtwcm9wZXJ0eV07XG5cbiAgICAgIGlmIChwdCAmJiBwdC5kICYmIHB0LmQuX3B0KSB7XG4gICAgICAgIC8vIGl0J3MgYSBwbHVnaW4sIHNvIGZpbmQgdGhlIG5lc3RlZCBQcm9wVHdlZW5cbiAgICAgICAgcHQgPSBwdC5kLl9wdDtcblxuICAgICAgICB3aGlsZSAocHQgJiYgcHQucCAhPT0gcHJvcGVydHkgJiYgcHQuZnAgIT09IHByb3BlcnR5KSB7XG4gICAgICAgICAgLy8gXCJmcFwiIGlzIGZ1bmN0aW9uUGFyYW0gZm9yIHRoaW5ncyBsaWtlIHNldHRpbmcgQ1NTIHZhcmlhYmxlcyB3aGljaCByZXF1aXJlIC5zZXRQcm9wZXJ0eShcIi0tdmFyLW5hbWVcIiwgdmFsdWUpXG4gICAgICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXB0KSB7XG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIFByb3BUd2VlbiBhc3NvY2lhdGVkIHdpdGggdGhhdCBwcm9wZXJ0eSwgc28gd2UgbXVzdCBGT1JDRSBvbmUgdG8gYmUgY3JlYXRlZCBhbmQgZGl0Y2ggb3V0IG9mIHRoaXNcbiAgICAgICAgLy8gaWYgdGhlIHR3ZWVuIGhhcyBvdGhlciBwcm9wZXJ0aWVzIHRoYXQgYWxyZWFkeSByZW5kZXJlZCBhdCBuZXcgcG9zaXRpb25zLCB3ZSdkIG5vcm1hbGx5IGhhdmUgdG8gcmV3aW5kIHRvIHB1dCB0aGVtIGJhY2sgbGlrZSB0d2Vlbi5yZW5kZXIoMCwgdHJ1ZSkgYmVmb3JlIGZvcmNpbmcgYW4gX2luaXRUd2VlbigpLCBidXQgdGhhdCBjYW4gY3JlYXRlIGFub3RoZXIgZWRnZSBjYXNlIGxpa2UgdHdlZW5pbmcgYSB0aW1lbGluZSdzIHByb2dyZXNzIHdvdWxkIHRyaWdnZXIgb25VcGRhdGVzIHRvIGZpcmUgd2hpY2ggY291bGQgbW92ZSBvdGhlciB0aGluZ3MgYXJvdW5kLiBJdCdzIGJldHRlciB0byBqdXN0IGluZm9ybSB1c2VycyB0aGF0IC5yZXNldFRvKCkgc2hvdWxkIE9OTFkgYmUgdXNlZCBmb3IgdHdlZW5zIHRoYXQgYWxyZWFkeSBoYXZlIHRoYXQgcHJvcGVydHkuIEZvciBleGFtcGxlLCB5b3UgY2FuJ3QgZ3NhcC50byguLi57IHk6IDAgfSkgYW5kIHRoZW4gdHdlZW4ucmVzdFRvKFwieFwiLCAyMDApIGZvciBleGFtcGxlLlxuICAgICAgICBfZm9yY2VBbGxQcm9wVHdlZW5zID0gMTsgLy8gb3RoZXJ3aXNlLCB3aGVuIHdlIF9hZGRQcm9wVHdlZW4oKSBhbmQgaXQgZmluZHMgbm8gY2hhbmdlIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgdmFsdWVzLCBpdCBza2lwcyBjcmVhdGluZyBhIFByb3BUd2VlbiAoZm9yIGVmZmljaWVuY3kuLi53aHkgdHdlZW4gd2hlbiB0aGVyZSdzIG5vIGRpZmZlcmVuY2U/KSBidXQgaW4gdGhpcyBjYXNlIHdlIE5FRUQgdGhhdCBQcm9wVHdlZW4gY3JlYXRlZCBzbyB3ZSBjYW4gZWRpdCBpdC5cblxuICAgICAgICB0d2Vlbi52YXJzW3Byb3BlcnR5XSA9IFwiKz0wXCI7XG5cbiAgICAgICAgX2luaXRUd2Vlbih0d2VlbiwgdGltZSk7XG5cbiAgICAgICAgX2ZvcmNlQWxsUHJvcFR3ZWVucyA9IDA7XG4gICAgICAgIHJldHVybiBza2lwUmVjdXJzaW9uID8gX3dhcm4ocHJvcGVydHkgKyBcIiBub3QgZWxpZ2libGUgZm9yIHJlc2V0XCIpIDogMTsgLy8gaWYgc29tZW9uZSB0cmllcyB0byBkbyBhIHF1aWNrVG8oKSBvbiBhIHNwZWNpYWwgcHJvcGVydHkgbGlrZSBib3JkZXJSYWRpdXMgd2hpY2ggbXVzdCBnZXQgc3BsaXQgaW50byA0IGRpZmZlcmVudCBwcm9wZXJ0aWVzLCB0aGF0J3Mgbm90IGVsaWdpYmxlIGZvciAucmVzZXRUbygpLlxuICAgICAgfVxuXG4gICAgICBwdENhY2hlLnB1c2gocHQpO1xuICAgIH1cbiAgfVxuXG4gIGkgPSBwdENhY2hlLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgcm9vdFBUID0gcHRDYWNoZVtpXTtcbiAgICBwdCA9IHJvb3RQVC5fcHQgfHwgcm9vdFBUOyAvLyBjb21wbGV4IHZhbHVlcyBtYXkgaGF2ZSBuZXN0ZWQgUHJvcFR3ZWVucy4gV2Ugb25seSBhY2NvbW1vZGF0ZSB0aGUgRklSU1QgdmFsdWUuXG5cbiAgICBwdC5zID0gKHN0YXJ0IHx8IHN0YXJ0ID09PSAwKSAmJiAhc3RhcnRJc1JlbGF0aXZlID8gc3RhcnQgOiBwdC5zICsgKHN0YXJ0IHx8IDApICsgcmF0aW8gKiBwdC5jO1xuICAgIHB0LmMgPSB2YWx1ZSAtIHB0LnM7XG4gICAgcm9vdFBULmUgJiYgKHJvb3RQVC5lID0gX3JvdW5kKHZhbHVlKSArIGdldFVuaXQocm9vdFBULmUpKTsgLy8gbWFpbmx5IGZvciBDU1NQbHVnaW4gKGVuZCB2YWx1ZSlcblxuICAgIHJvb3RQVC5iICYmIChyb290UFQuYiA9IHB0LnMgKyBnZXRVbml0KHJvb3RQVC5iKSk7IC8vIChiZWdpbm5pbmcgdmFsdWUpXG4gIH1cbn0sXG4gICAgX2FkZEFsaWFzZXNUb1ZhcnMgPSBmdW5jdGlvbiBfYWRkQWxpYXNlc1RvVmFycyh0YXJnZXRzLCB2YXJzKSB7XG4gIHZhciBoYXJuZXNzID0gdGFyZ2V0c1swXSA/IF9nZXRDYWNoZSh0YXJnZXRzWzBdKS5oYXJuZXNzIDogMCxcbiAgICAgIHByb3BlcnR5QWxpYXNlcyA9IGhhcm5lc3MgJiYgaGFybmVzcy5hbGlhc2VzLFxuICAgICAgY29weSxcbiAgICAgIHAsXG4gICAgICBpLFxuICAgICAgYWxpYXNlcztcblxuICBpZiAoIXByb3BlcnR5QWxpYXNlcykge1xuICAgIHJldHVybiB2YXJzO1xuICB9XG5cbiAgY29weSA9IF9tZXJnZSh7fSwgdmFycyk7XG5cbiAgZm9yIChwIGluIHByb3BlcnR5QWxpYXNlcykge1xuICAgIGlmIChwIGluIGNvcHkpIHtcbiAgICAgIGFsaWFzZXMgPSBwcm9wZXJ0eUFsaWFzZXNbcF0uc3BsaXQoXCIsXCIpO1xuICAgICAgaSA9IGFsaWFzZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvcHlbYWxpYXNlc1tpXV0gPSBjb3B5W3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICAvLyBwYXJzZXMgbXVsdGlwbGUgZm9ybWF0cywgbGlrZSB7XCIwJVwiOiB7eDogMTAwfSwge1wiNTAlXCI6IHt4OiAtMjB9fSBhbmQgeyB4OiB7XCIwJVwiOiAxMDAsIFwiNTAlXCI6IC0yMH0gfSwgYW5kIGFuIFwiZWFzZVwiIGNhbiBiZSBzZXQgb24gYW55IG9iamVjdC4gV2UgcG9wdWxhdGUgYW4gXCJhbGxQcm9wc1wiIG9iamVjdCB3aXRoIGFuIEFycmF5IGZvciBlYWNoIHByb3BlcnR5LCBsaWtlIHt4OiBbe30sIHt9XSwgeTpbe30sIHt9XX0gd2l0aCBkYXRhIGZvciBlYWNoIHByb3BlcnR5IHR3ZWVuLiBUaGUgb2JqZWN0cyBoYXZlIGEgXCJ0XCIgKHRpbWUpLCBcInZcIiwgKHZhbHVlKSwgYW5kIFwiZVwiIChlYXNlKSBwcm9wZXJ0eS4gVGhpcyBhbGxvd3MgdXMgdG8gcGllY2UgdG9nZXRoZXIgYSB0aW1lbGluZSBsYXRlci5cbl9wYXJzZUtleWZyYW1lID0gZnVuY3Rpb24gX3BhcnNlS2V5ZnJhbWUocHJvcCwgb2JqLCBhbGxQcm9wcywgZWFzZUVhY2gpIHtcbiAgdmFyIGVhc2UgPSBvYmouZWFzZSB8fCBlYXNlRWFjaCB8fCBcInBvd2VyMS5pbk91dFwiLFxuICAgICAgcCxcbiAgICAgIGE7XG5cbiAgaWYgKF9pc0FycmF5KG9iaikpIHtcbiAgICBhID0gYWxsUHJvcHNbcHJvcF0gfHwgKGFsbFByb3BzW3Byb3BdID0gW10pOyAvLyB0ID0gdGltZSAob3V0IG9mIDEwMCksIHYgPSB2YWx1ZSwgZSA9IGVhc2VcblxuICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgcmV0dXJuIGEucHVzaCh7XG4gICAgICAgIHQ6IGkgLyAob2JqLmxlbmd0aCAtIDEpICogMTAwLFxuICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgZTogZWFzZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChwIGluIG9iaikge1xuICAgICAgYSA9IGFsbFByb3BzW3BdIHx8IChhbGxQcm9wc1twXSA9IFtdKTtcbiAgICAgIHAgPT09IFwiZWFzZVwiIHx8IGEucHVzaCh7XG4gICAgICAgIHQ6IHBhcnNlRmxvYXQocHJvcCksXG4gICAgICAgIHY6IG9ialtwXSxcbiAgICAgICAgZTogZWFzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59LFxuICAgIF9wYXJzZUZ1bmNPclN0cmluZyA9IGZ1bmN0aW9uIF9wYXJzZUZ1bmNPclN0cmluZyh2YWx1ZSwgdHdlZW4sIGksIHRhcmdldCwgdGFyZ2V0cykge1xuICByZXR1cm4gX2lzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbCh0d2VlbiwgaSwgdGFyZ2V0LCB0YXJnZXRzKSA6IF9pc1N0cmluZyh2YWx1ZSkgJiYgfnZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpID8gX3JlcGxhY2VSYW5kb20odmFsdWUpIDogdmFsdWU7XG59LFxuICAgIF9zdGFnZ2VyVHdlZW5Qcm9wcyA9IF9jYWxsYmFja05hbWVzICsgXCJyZXBlYXQscmVwZWF0RGVsYXkseW95byxyZXBlYXRSZWZyZXNoLHlveW9FYXNlLGF1dG9SZXZlcnRcIixcbiAgICBfc3RhZ2dlclByb3BzVG9Ta2lwID0ge307XG5cbl9mb3JFYWNoTmFtZShfc3RhZ2dlclR3ZWVuUHJvcHMgKyBcIixpZCxzdGFnZ2VyLGRlbGF5LGR1cmF0aW9uLHBhdXNlZCxzY3JvbGxUcmlnZ2VyXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfc3RhZ2dlclByb3BzVG9Ta2lwW25hbWVdID0gMTtcbn0pO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUV0VFTlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbmV4cG9ydCB2YXIgVHdlZW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BbmltYXRpb24yKSB7XG4gIF9pbmhlcml0c0xvb3NlKFR3ZWVuLCBfQW5pbWF0aW9uMik7XG5cbiAgZnVuY3Rpb24gVHdlZW4odGFyZ2V0cywgdmFycywgcG9zaXRpb24sIHNraXBJbmhlcml0KSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgIGlmICh0eXBlb2YgdmFycyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcG9zaXRpb24uZHVyYXRpb24gPSB2YXJzO1xuICAgICAgdmFycyA9IHBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIF90aGlzMyA9IF9BbmltYXRpb24yLmNhbGwodGhpcywgc2tpcEluaGVyaXQgPyB2YXJzIDogX2luaGVyaXREZWZhdWx0cyh2YXJzKSkgfHwgdGhpcztcbiAgICB2YXIgX3RoaXMzJHZhcnMgPSBfdGhpczMudmFycyxcbiAgICAgICAgZHVyYXRpb24gPSBfdGhpczMkdmFycy5kdXJhdGlvbixcbiAgICAgICAgZGVsYXkgPSBfdGhpczMkdmFycy5kZWxheSxcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyID0gX3RoaXMzJHZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICBzdGFnZ2VyID0gX3RoaXMzJHZhcnMuc3RhZ2dlcixcbiAgICAgICAgb3ZlcndyaXRlID0gX3RoaXMzJHZhcnMub3ZlcndyaXRlLFxuICAgICAgICBrZXlmcmFtZXMgPSBfdGhpczMkdmFycy5rZXlmcmFtZXMsXG4gICAgICAgIGRlZmF1bHRzID0gX3RoaXMzJHZhcnMuZGVmYXVsdHMsXG4gICAgICAgIHNjcm9sbFRyaWdnZXIgPSBfdGhpczMkdmFycy5zY3JvbGxUcmlnZ2VyLFxuICAgICAgICB5b3lvRWFzZSA9IF90aGlzMyR2YXJzLnlveW9FYXNlLFxuICAgICAgICBwYXJlbnQgPSB2YXJzLnBhcmVudCB8fCBfZ2xvYmFsVGltZWxpbmUsXG4gICAgICAgIHBhcnNlZFRhcmdldHMgPSAoX2lzQXJyYXkodGFyZ2V0cykgfHwgX2lzVHlwZWRBcnJheSh0YXJnZXRzKSA/IF9pc051bWJlcih0YXJnZXRzWzBdKSA6IFwibGVuZ3RoXCIgaW4gdmFycykgPyBbdGFyZ2V0c10gOiB0b0FycmF5KHRhcmdldHMpLFxuICAgICAgICB0bCxcbiAgICAgICAgaSxcbiAgICAgICAgY29weSxcbiAgICAgICAgbCxcbiAgICAgICAgcCxcbiAgICAgICAgY3VyVGFyZ2V0LFxuICAgICAgICBzdGFnZ2VyRnVuYyxcbiAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlO1xuICAgIF90aGlzMy5fdGFyZ2V0cyA9IHBhcnNlZFRhcmdldHMubGVuZ3RoID8gX2hhcm5lc3MocGFyc2VkVGFyZ2V0cykgOiBfd2FybihcIkdTQVAgdGFyZ2V0IFwiICsgdGFyZ2V0cyArIFwiIG5vdCBmb3VuZC4gaHR0cHM6Ly9nc2FwLmNvbVwiLCAhX2NvbmZpZy5udWxsVGFyZ2V0V2FybikgfHwgW107XG4gICAgX3RoaXMzLl9wdExvb2t1cCA9IFtdOyAvL1Byb3BUd2VlbiBsb29rdXAuIEFuIGFycmF5IGNvbnRhaW5pbmcgYW4gb2JqZWN0IGZvciBlYWNoIHRhcmdldCwgaGF2aW5nIGtleXMgZm9yIGVhY2ggdHdlZW5pbmcgcHJvcGVydHlcblxuICAgIF90aGlzMy5fb3ZlcndyaXRlID0gb3ZlcndyaXRlO1xuXG4gICAgaWYgKGtleWZyYW1lcyB8fCBzdGFnZ2VyIHx8IF9pc0Z1bmNPclN0cmluZyhkdXJhdGlvbikgfHwgX2lzRnVuY09yU3RyaW5nKGRlbGF5KSkge1xuICAgICAgdmFycyA9IF90aGlzMy52YXJzO1xuICAgICAgdGwgPSBfdGhpczMudGltZWxpbmUgPSBuZXcgVGltZWxpbmUoe1xuICAgICAgICBkYXRhOiBcIm5lc3RlZFwiLFxuICAgICAgICBkZWZhdWx0czogZGVmYXVsdHMgfHwge30sXG4gICAgICAgIHRhcmdldHM6IHBhcmVudCAmJiBwYXJlbnQuZGF0YSA9PT0gXCJuZXN0ZWRcIiA/IHBhcmVudC52YXJzLnRhcmdldHMgOiBwYXJzZWRUYXJnZXRzXG4gICAgICB9KTsgLy8gd2UgbmVlZCB0byBzdG9yZSB0aGUgdGFyZ2V0cyBiZWNhdXNlIGZvciBzdGFnZ2VycyBhbmQga2V5ZnJhbWVzLCB3ZSBlbmQgdXAgY3JlYXRpbmcgYW4gaW5kaXZpZHVhbCB0d2VlbiBmb3IgZWFjaCBidXQgZnVuY3Rpb24tYmFzZWQgdmFsdWVzIG5lZWQgdG8ga25vdyB0aGUgaW5kZXggYW5kIHRoZSB3aG9sZSBBcnJheSBvZiB0YXJnZXRzLlxuXG4gICAgICB0bC5raWxsKCk7XG4gICAgICB0bC5wYXJlbnQgPSB0bC5fZHAgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyk7XG4gICAgICB0bC5fc3RhcnQgPSAwO1xuXG4gICAgICBpZiAoc3RhZ2dlciB8fCBfaXNGdW5jT3JTdHJpbmcoZHVyYXRpb24pIHx8IF9pc0Z1bmNPclN0cmluZyhkZWxheSkpIHtcbiAgICAgICAgbCA9IHBhcnNlZFRhcmdldHMubGVuZ3RoO1xuICAgICAgICBzdGFnZ2VyRnVuYyA9IHN0YWdnZXIgJiYgZGlzdHJpYnV0ZShzdGFnZ2VyKTtcblxuICAgICAgICBpZiAoX2lzT2JqZWN0KHN0YWdnZXIpKSB7XG4gICAgICAgICAgLy91c2VycyBjYW4gcGFzcyBpbiBjYWxsYmFja3MgbGlrZSBvblN0YXJ0L29uQ29tcGxldGUgaW4gdGhlIHN0YWdnZXIgb2JqZWN0LiBUaGVzZSBzaG91bGQgZmlyZSB3aXRoIGVhY2ggaW5kaXZpZHVhbCB0d2Vlbi5cbiAgICAgICAgICBmb3IgKHAgaW4gc3RhZ2dlcikge1xuICAgICAgICAgICAgaWYgKH5fc3RhZ2dlclR3ZWVuUHJvcHMuaW5kZXhPZihwKSkge1xuICAgICAgICAgICAgICBzdGFnZ2VyVmFyc1RvTWVyZ2UgfHwgKHN0YWdnZXJWYXJzVG9NZXJnZSA9IHt9KTtcbiAgICAgICAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlW3BdID0gc3RhZ2dlcltwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY29weSA9IF9jb3B5RXhjbHVkaW5nKHZhcnMsIF9zdGFnZ2VyUHJvcHNUb1NraXApO1xuICAgICAgICAgIGNvcHkuc3RhZ2dlciA9IDA7XG4gICAgICAgICAgeW95b0Vhc2UgJiYgKGNvcHkueW95b0Vhc2UgPSB5b3lvRWFzZSk7XG4gICAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlICYmIF9tZXJnZShjb3B5LCBzdGFnZ2VyVmFyc1RvTWVyZ2UpO1xuICAgICAgICAgIGN1clRhcmdldCA9IHBhcnNlZFRhcmdldHNbaV07IC8vZG9uJ3QganVzdCBjb3B5IGR1cmF0aW9uIG9yIGRlbGF5IGJlY2F1c2UgaWYgdGhleSdyZSBhIHN0cmluZyBvciBmdW5jdGlvbiwgd2UnZCBlbmQgdXAgaW4gYW4gaW5maW5pdGUgbG9vcCBiZWNhdXNlIF9pc0Z1bmNPclN0cmluZygpIHdvdWxkIGV2YWx1YXRlIGFzIHRydWUgaW4gdGhlIGNoaWxkIHR3ZWVucywgZW50ZXJpbmcgdGhpcyBsb29wLCBldGMuIFNvIHdlIHBhcnNlIHRoZSB2YWx1ZSBzdHJhaWdodCBmcm9tIHZhcnMgYW5kIGRlZmF1bHQgdG8gMC5cblxuICAgICAgICAgIGNvcHkuZHVyYXRpb24gPSArX3BhcnNlRnVuY09yU3RyaW5nKGR1cmF0aW9uLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIGksIGN1clRhcmdldCwgcGFyc2VkVGFyZ2V0cyk7XG4gICAgICAgICAgY29weS5kZWxheSA9ICgrX3BhcnNlRnVuY09yU3RyaW5nKGRlbGF5LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIGksIGN1clRhcmdldCwgcGFyc2VkVGFyZ2V0cykgfHwgMCkgLSBfdGhpczMuX2RlbGF5O1xuXG4gICAgICAgICAgaWYgKCFzdGFnZ2VyICYmIGwgPT09IDEgJiYgY29weS5kZWxheSkge1xuICAgICAgICAgICAgLy8gaWYgc29tZW9uZSBkb2VzIGRlbGF5OlwicmFuZG9tKDEsIDUpXCIsIHJlcGVhdDotMSwgZm9yIGV4YW1wbGUsIHRoZSBkZWxheSBzaG91bGRuJ3QgYmUgaW5zaWRlIHRoZSByZXBlYXQuXG4gICAgICAgICAgICBfdGhpczMuX2RlbGF5ID0gZGVsYXkgPSBjb3B5LmRlbGF5O1xuICAgICAgICAgICAgX3RoaXMzLl9zdGFydCArPSBkZWxheTtcbiAgICAgICAgICAgIGNvcHkuZGVsYXkgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRsLnRvKGN1clRhcmdldCwgY29weSwgc3RhZ2dlckZ1bmMgPyBzdGFnZ2VyRnVuYyhpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpIDogMCk7XG4gICAgICAgICAgdGwuX2Vhc2UgPSBfZWFzZU1hcC5ub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgdGwuZHVyYXRpb24oKSA/IGR1cmF0aW9uID0gZGVsYXkgPSAwIDogX3RoaXMzLnRpbWVsaW5lID0gMDsgLy8gaWYgdGhlIHRpbWVsaW5lJ3MgZHVyYXRpb24gaXMgMCwgd2UgZG9uJ3QgbmVlZCBhIHRpbWVsaW5lIGludGVybmFsbHkhXG4gICAgICB9IGVsc2UgaWYgKGtleWZyYW1lcykge1xuICAgICAgICBfaW5oZXJpdERlZmF1bHRzKF9zZXREZWZhdWx0cyh0bC52YXJzLmRlZmF1bHRzLCB7XG4gICAgICAgICAgZWFzZTogXCJub25lXCJcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHRsLl9lYXNlID0gX3BhcnNlRWFzZShrZXlmcmFtZXMuZWFzZSB8fCB2YXJzLmVhc2UgfHwgXCJub25lXCIpO1xuICAgICAgICB2YXIgdGltZSA9IDAsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAga2YsXG4gICAgICAgICAgICB2O1xuXG4gICAgICAgIGlmIChfaXNBcnJheShrZXlmcmFtZXMpKSB7XG4gICAgICAgICAga2V5ZnJhbWVzLmZvckVhY2goZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGwudG8ocGFyc2VkVGFyZ2V0cywgZnJhbWUsIFwiPlwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0bC5kdXJhdGlvbigpOyAvLyB0byBlbnN1cmUgdGwuX2R1ciBpcyBjYWNoZWQgYmVjYXVzZSB3ZSB0YXAgaW50byBpdCBmb3IgcGVyZm9ybWFuY2UgcHVycG9zZXMgaW4gdGhlIHJlbmRlcigpIG1ldGhvZC5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3B5ID0ge307XG5cbiAgICAgICAgICBmb3IgKHAgaW4ga2V5ZnJhbWVzKSB7XG4gICAgICAgICAgICBwID09PSBcImVhc2VcIiB8fCBwID09PSBcImVhc2VFYWNoXCIgfHwgX3BhcnNlS2V5ZnJhbWUocCwga2V5ZnJhbWVzW3BdLCBjb3B5LCBrZXlmcmFtZXMuZWFzZUVhY2gpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAocCBpbiBjb3B5KSB7XG4gICAgICAgICAgICBhID0gY29weVtwXS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhLnQgLSBiLnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRpbWUgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBrZiA9IGFbaV07XG4gICAgICAgICAgICAgIHYgPSB7XG4gICAgICAgICAgICAgICAgZWFzZToga2YuZSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogKGtmLnQgLSAoaSA/IGFbaSAtIDFdLnQgOiAwKSkgLyAxMDAgKiBkdXJhdGlvblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB2W3BdID0ga2YudjtcbiAgICAgICAgICAgICAgdGwudG8ocGFyc2VkVGFyZ2V0cywgdiwgdGltZSk7XG4gICAgICAgICAgICAgIHRpbWUgKz0gdi5kdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0bC5kdXJhdGlvbigpIDwgZHVyYXRpb24gJiYgdGwudG8oe30sIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiAtIHRsLmR1cmF0aW9uKClcbiAgICAgICAgICB9KTsgLy8gaW4gY2FzZSBrZXlmcmFtZXMgZGlkbid0IGdvIHRvIDEwMCVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkdXJhdGlvbiB8fCBfdGhpczMuZHVyYXRpb24oZHVyYXRpb24gPSB0bC5kdXJhdGlvbigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMzLnRpbWVsaW5lID0gMDsgLy9zcGVlZCBvcHRpbWl6YXRpb24sIGZhc3RlciBsb29rdXBzIChubyBnb2luZyB1cCB0aGUgcHJvdG90eXBlIGNoYWluKVxuICAgIH1cblxuICAgIGlmIChvdmVyd3JpdGUgPT09IHRydWUgJiYgIV9zdXBwcmVzc092ZXJ3cml0ZXMpIHtcbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpO1xuXG4gICAgICBfZ2xvYmFsVGltZWxpbmUua2lsbFR3ZWVuc09mKHBhcnNlZFRhcmdldHMpO1xuXG4gICAgICBfb3ZlcndyaXRpbmdUd2VlbiA9IDA7XG4gICAgfVxuXG4gICAgX2FkZFRvVGltZWxpbmUocGFyZW50LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIHBvc2l0aW9uKTtcblxuICAgIHZhcnMucmV2ZXJzZWQgJiYgX3RoaXMzLnJldmVyc2UoKTtcbiAgICB2YXJzLnBhdXNlZCAmJiBfdGhpczMucGF1c2VkKHRydWUpO1xuXG4gICAgaWYgKGltbWVkaWF0ZVJlbmRlciB8fCAhZHVyYXRpb24gJiYgIWtleWZyYW1lcyAmJiBfdGhpczMuX3N0YXJ0ID09PSBfcm91bmRQcmVjaXNlKHBhcmVudC5fdGltZSkgJiYgX2lzTm90RmFsc2UoaW1tZWRpYXRlUmVuZGVyKSAmJiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpKSAmJiBwYXJlbnQuZGF0YSAhPT0gXCJuZXN0ZWRcIikge1xuICAgICAgX3RoaXMzLl90VGltZSA9IC1fdGlueU51bTsgLy9mb3JjZXMgYSByZW5kZXIgd2l0aG91dCBoYXZpbmcgdG8gc2V0IHRoZSByZW5kZXIoKSBcImZvcmNlXCIgcGFyYW1ldGVyIHRvIHRydWUgYmVjYXVzZSB3ZSB3YW50IHRvIGFsbG93IGxhenlpbmcgYnkgZGVmYXVsdCAodXNpbmcgdGhlIFwiZm9yY2VcIiBwYXJhbWV0ZXIgYWx3YXlzIGZvcmNlcyBhbiBpbW1lZGlhdGUgZnVsbCByZW5kZXIpXG5cbiAgICAgIF90aGlzMy5yZW5kZXIoTWF0aC5tYXgoMCwgLWRlbGF5KSB8fCAwKTsgLy9pbiBjYXNlIGRlbGF5IGlzIG5lZ2F0aXZlXG5cbiAgICB9XG5cbiAgICBzY3JvbGxUcmlnZ2VyICYmIF9zY3JvbGxUcmlnZ2VyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgc2Nyb2xsVHJpZ2dlcik7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIHZhciBfcHJvdG8zID0gVHdlZW4ucHJvdG90eXBlO1xuXG4gIF9wcm90bzMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG4gICAgdmFyIHByZXZUaW1lID0gdGhpcy5fdGltZSxcbiAgICAgICAgdER1ciA9IHRoaXMuX3REdXIsXG4gICAgICAgIGR1ciA9IHRoaXMuX2R1cixcbiAgICAgICAgaXNOZWdhdGl2ZSA9IHRvdGFsVGltZSA8IDAsXG4gICAgICAgIHRUaW1lID0gdG90YWxUaW1lID4gdER1ciAtIF90aW55TnVtICYmICFpc05lZ2F0aXZlID8gdER1ciA6IHRvdGFsVGltZSA8IF90aW55TnVtID8gMCA6IHRvdGFsVGltZSxcbiAgICAgICAgdGltZSxcbiAgICAgICAgcHQsXG4gICAgICAgIGl0ZXJhdGlvbixcbiAgICAgICAgY3ljbGVEdXJhdGlvbixcbiAgICAgICAgcHJldkl0ZXJhdGlvbixcbiAgICAgICAgaXNZb3lvLFxuICAgICAgICByYXRpbyxcbiAgICAgICAgdGltZWxpbmUsXG4gICAgICAgIHlveW9FYXNlO1xuXG4gICAgaWYgKCFkdXIpIHtcbiAgICAgIF9yZW5kZXJaZXJvRHVyYXRpb25Ud2Vlbih0aGlzLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgfSBlbHNlIGlmICh0VGltZSAhPT0gdGhpcy5fdFRpbWUgfHwgIXRvdGFsVGltZSB8fCBmb3JjZSB8fCAhdGhpcy5faW5pdHRlZCAmJiB0aGlzLl90VGltZSB8fCB0aGlzLl9zdGFydEF0ICYmIHRoaXMuX3pUaW1lIDwgMCAhPT0gaXNOZWdhdGl2ZSkge1xuICAgICAgLy90aGlzIHNlbnNlcyBpZiB3ZSdyZSBjcm9zc2luZyBvdmVyIHRoZSBzdGFydCB0aW1lLCBpbiB3aGljaCBjYXNlIHdlIG11c3QgcmVjb3JkIF96VGltZSBhbmQgZm9yY2UgdGhlIHJlbmRlciwgYnV0IHdlIGRvIGl0IGluIHRoaXMgbGVuZ3RoeSBjb25kaXRpb25hbCB3YXkgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgKHVzdWFsbHkgd2UgY2FuIHNraXAgdGhlIGNhbGN1bGF0aW9ucyk6IHRoaXMuX2luaXR0ZWQgJiYgKHRoaXMuX3pUaW1lIDwgMCkgIT09ICh0b3RhbFRpbWUgPCAwKVxuICAgICAgdGltZSA9IHRUaW1lO1xuICAgICAgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lO1xuXG4gICAgICBpZiAodGhpcy5fcmVwZWF0KSB7XG4gICAgICAgIC8vYWRqdXN0IHRoZSB0aW1lIGZvciByZXBlYXRzIGFuZCB5b3lvc1xuICAgICAgICBjeWNsZUR1cmF0aW9uID0gZHVyICsgdGhpcy5fckRlbGF5O1xuXG4gICAgICAgIGlmICh0aGlzLl9yZXBlYXQgPCAtMSAmJiBpc05lZ2F0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG90YWxUaW1lKGN5Y2xlRHVyYXRpb24gKiAxMDAgKyB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lID0gX3JvdW5kUHJlY2lzZSh0VGltZSAlIGN5Y2xlRHVyYXRpb24pOyAvL3JvdW5kIHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IGVycm9ycy4gKDQgJSAwLjggc2hvdWxkIGJlIDAgYnV0IHNvbWUgYnJvd3NlcnMgcmVwb3J0IGl0IGFzIDAuNzk5OTk5OTkhKVxuXG4gICAgICAgIGlmICh0VGltZSA9PT0gdER1cikge1xuICAgICAgICAgIC8vIHRoZSB0RHVyID09PSB0VGltZSBpcyBmb3IgZWRnZSBjYXNlcyB3aGVyZSB0aGVyZSdzIGEgbGVuZ3RoeSBkZWNpbWFsIG9uIHRoZSBkdXJhdGlvbiBhbmQgaXQgbWF5IHJlYWNoIHRoZSB2ZXJ5IGVuZCBidXQgdGhlIHRpbWUgaXMgcmVuZGVyZWQgYXMgbm90LXF1aXRlLXRoZXJlIChyZW1lbWJlciwgdER1ciBpcyByb3VuZGVkIHRvIDQgZGVjaW1hbHMgd2hlcmVhcyBkdXIgaXNuJ3QpXG4gICAgICAgICAgaXRlcmF0aW9uID0gdGhpcy5fcmVwZWF0O1xuICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlcmF0aW9uID0gfn4odFRpbWUgLyBjeWNsZUR1cmF0aW9uKTtcblxuICAgICAgICAgIGlmIChpdGVyYXRpb24gJiYgaXRlcmF0aW9uID09PSBfcm91bmRQcmVjaXNlKHRUaW1lIC8gY3ljbGVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgICAgICBpdGVyYXRpb24tLTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aW1lID4gZHVyICYmICh0aW1lID0gZHVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzWW95byA9IHRoaXMuX3lveW8gJiYgaXRlcmF0aW9uICYgMTtcblxuICAgICAgICBpZiAoaXNZb3lvKSB7XG4gICAgICAgICAgeW95b0Vhc2UgPSB0aGlzLl95RWFzZTtcbiAgICAgICAgICB0aW1lID0gZHVyIC0gdGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZJdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodGhpcy5fdFRpbWUsIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgIGlmICh0aW1lID09PSBwcmV2VGltZSAmJiAhZm9yY2UgJiYgdGhpcy5faW5pdHRlZCAmJiBpdGVyYXRpb24gPT09IHByZXZJdGVyYXRpb24pIHtcbiAgICAgICAgICAvL2NvdWxkIGJlIGR1cmluZyB0aGUgcmVwZWF0RGVsYXkgcGFydC4gTm8gbmVlZCB0byByZW5kZXIgYW5kIGZpcmUgY2FsbGJhY2tzLlxuICAgICAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uKSB7XG4gICAgICAgICAgdGltZWxpbmUgJiYgdGhpcy5feUVhc2UgJiYgX3Byb3BhZ2F0ZVlveW9FYXNlKHRpbWVsaW5lLCBpc1lveW8pOyAvL3JlcGVhdFJlZnJlc2ggZnVuY3Rpb25hbGl0eVxuXG4gICAgICAgICAgaWYgKHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgIXRoaXMuX2xvY2sgJiYgdGhpcy5fdGltZSAhPT0gY3ljbGVEdXJhdGlvbiAmJiB0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgICAgICAvLyB0aGlzLl90aW1lIHdpbGwgPT09IGN5Y2xlRHVyYXRpb24gd2hlbiB3ZSByZW5kZXIgYXQgRVhBQ1RMWSB0aGUgZW5kIG9mIGFuIGl0ZXJhdGlvbi4gV2l0aG91dCB0aGlzIGNvbmRpdGlvbiwgaXQnZCBvZnRlbiBkbyB0aGUgcmVwZWF0UmVmcmVzaCByZW5kZXIgVFdJQ0UgKGFnYWluIG9uIHRoZSB2ZXJ5IG5leHQgdGljaykuXG4gICAgICAgICAgICB0aGlzLl9sb2NrID0gZm9yY2UgPSAxOyAvL2ZvcmNlLCBvdGhlcndpc2UgaWYgbGF6eSBpcyB0cnVlLCB0aGUgX2F0dGVtcHRJbml0VHdlZW4oKSB3aWxsIHJldHVybiBhbmQgd2UnbGwganVtcCBvdXQgYW5kIGdldCBjYXVnaHQgYm91bmNpbmcgb24gZWFjaCB0aWNrLlxuXG4gICAgICAgICAgICB0aGlzLnJlbmRlcihfcm91bmRQcmVjaXNlKGN5Y2xlRHVyYXRpb24gKiBpdGVyYXRpb24pLCB0cnVlKS5pbnZhbGlkYXRlKCkuX2xvY2sgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcbiAgICAgICAgaWYgKF9hdHRlbXB0SW5pdFR3ZWVuKHRoaXMsIGlzTmVnYXRpdmUgPyB0b3RhbFRpbWUgOiB0aW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMsIHRUaW1lKSkge1xuICAgICAgICAgIHRoaXMuX3RUaW1lID0gMDsgLy8gaW4gY29uc3RydWN0b3IgaWYgaW1tZWRpYXRlUmVuZGVyIGlzIHRydWUsIHdlIHNldCBfdFRpbWUgdG8gLV90aW55TnVtIHRvIGhhdmUgdGhlIHBsYXloZWFkIGNyb3NzIHRoZSBzdGFydGluZyBwb2ludCBidXQgd2UgY2FuJ3QgbGVhdmUgX3RUaW1lIGFzIGEgbmVnYXRpdmUgbnVtYmVyLlxuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldlRpbWUgIT09IHRoaXMuX3RpbWUgJiYgIShmb3JjZSAmJiB0aGlzLnZhcnMucmVwZWF0UmVmcmVzaCAmJiBpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24pKSB7XG4gICAgICAgICAgLy8gcmFyZSBlZGdlIGNhc2UgLSBkdXJpbmcgaW5pdGlhbGl6YXRpb24sIGFuIG9uVXBkYXRlIGluIHRoZSBfc3RhcnRBdCAoLmZyb21UbygpKSBtaWdodCBmb3JjZSB0aGlzIHR3ZWVuIHRvIHJlbmRlciBhdCBhIGRpZmZlcmVudCBzcG90IGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIGRpdGNoIHRoaXMgcmVuZGVyKCkgY2FsbCBzbyB0aGF0IGl0IGRvZXNuJ3QgcmV2ZXJ0IHRoZSB2YWx1ZXMuIEJ1dCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gZHVtcCBpZiB3ZSdyZSBkb2luZyBhIHJlcGVhdFJlZnJlc2ggcmVuZGVyIVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGR1ciAhPT0gdGhpcy5fZHVyKSB7XG4gICAgICAgICAgLy8gd2hpbGUgaW5pdHRpbmcsIGEgcGx1Z2luIGxpa2UgSW5lcnRpYVBsdWdpbiBtaWdodCBhbHRlciB0aGUgZHVyYXRpb24sIHNvIHJlcnVuIGZyb20gdGhlIHN0YXJ0IHRvIGVuc3VyZSBldmVyeXRoaW5nIHJlbmRlcnMgYXMgaXQgc2hvdWxkLlxuICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fdFRpbWUgPSB0VGltZTtcbiAgICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuXG4gICAgICBpZiAoIXRoaXMuX2FjdCAmJiB0aGlzLl90cykge1xuICAgICAgICB0aGlzLl9hY3QgPSAxOyAvL2FzIGxvbmcgYXMgaXQncyBub3QgcGF1c2VkLCBmb3JjZSBpdCB0byBiZSBhY3RpdmUgc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIGluZGVwZW5kZW50IG9mIHRoZSBwYXJlbnQgdGltZWxpbmUsIGl0J2xsIGJlIGZvcmNlZCB0byByZS1yZW5kZXIgb24gdGhlIG5leHQgdGljay5cblxuICAgICAgICB0aGlzLl9sYXp5ID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yYXRpbyA9IHJhdGlvID0gKHlveW9FYXNlIHx8IHRoaXMuX2Vhc2UpKHRpbWUgLyBkdXIpO1xuXG4gICAgICBpZiAodGhpcy5fZnJvbSkge1xuICAgICAgICB0aGlzLnJhdGlvID0gcmF0aW8gPSAxIC0gcmF0aW87XG4gICAgICB9XG5cbiAgICAgIGlmICh0aW1lICYmICFwcmV2VGltZSAmJiAhc3VwcHJlc3NFdmVudHMgJiYgIWl0ZXJhdGlvbikge1xuICAgICAgICBfY2FsbGJhY2sodGhpcywgXCJvblN0YXJ0XCIpO1xuXG4gICAgICAgIGlmICh0aGlzLl90VGltZSAhPT0gdFRpbWUpIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBvblN0YXJ0IHRyaWdnZXJlZCBhIHJlbmRlciBhdCBhIGRpZmZlcmVudCBzcG90LCBlamVjdC4gTGlrZSBpZiBzb21lb25lIGRpZCBhbmltYXRpb24ucGF1c2UoMC41KSBvciBzb21ldGhpbmcgaW5zaWRlIHRoZSBvblN0YXJ0LlxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHB0ID0gdGhpcy5fcHQ7XG5cbiAgICAgIHdoaWxlIChwdCkge1xuICAgICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICAgIH1cblxuICAgICAgdGltZWxpbmUgJiYgdGltZWxpbmUucmVuZGVyKHRvdGFsVGltZSA8IDAgPyB0b3RhbFRpbWUgOiB0aW1lbGluZS5fZHVyICogdGltZWxpbmUuX2Vhc2UodGltZSAvIHRoaXMuX2R1ciksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkgfHwgdGhpcy5fc3RhcnRBdCAmJiAodGhpcy5felRpbWUgPSB0b3RhbFRpbWUpO1xuXG4gICAgICBpZiAodGhpcy5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgIGlzTmVnYXRpdmUgJiYgX3Jld2luZFN0YXJ0QXQodGhpcywgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpOyAvL25vdGU6IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSB0dWNrIHRoaXMgY29uZGl0aW9uYWwgbG9naWMgaW5zaWRlIGxlc3MgdHJhdmVsZWQgYXJlYXMgKG1vc3QgdHdlZW5zIGRvbid0IGhhdmUgYW4gb25VcGRhdGUpLiBXZSdkIGp1c3QgaGF2ZSBpdCBhdCB0aGUgZW5kIGJlZm9yZSB0aGUgb25Db21wbGV0ZSwgYnV0IHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQgYmVmb3JlIGFueSBvblVwZGF0ZSBpcyBjYWxsZWQsIHNvIHdlIEFMU08gcHV0IGl0IGhlcmUgYW5kIHRoZW4gaWYgaXQncyBub3QgY2FsbGVkLCB3ZSBkbyBzbyBsYXRlciBuZWFyIHRoZSBvbkNvbXBsZXRlLlxuXG4gICAgICAgIF9jYWxsYmFjayh0aGlzLCBcIm9uVXBkYXRlXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXBlYXQgJiYgaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uICYmIHRoaXMudmFycy5vblJlcGVhdCAmJiAhc3VwcHJlc3NFdmVudHMgJiYgdGhpcy5wYXJlbnQgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25SZXBlYXRcIik7XG5cbiAgICAgIGlmICgodFRpbWUgPT09IHRoaXMuX3REdXIgfHwgIXRUaW1lKSAmJiB0aGlzLl90VGltZSA9PT0gdFRpbWUpIHtcbiAgICAgICAgaXNOZWdhdGl2ZSAmJiAhdGhpcy5fb25VcGRhdGUgJiYgX3Jld2luZFN0YXJ0QXQodGhpcywgdG90YWxUaW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgKHRvdGFsVGltZSB8fCAhZHVyKSAmJiAodFRpbWUgPT09IHRoaXMuX3REdXIgJiYgdGhpcy5fdHMgPiAwIHx8ICF0VGltZSAmJiB0aGlzLl90cyA8IDApICYmIF9yZW1vdmVGcm9tUGFyZW50KHRoaXMsIDEpOyAvLyBkb24ndCByZW1vdmUgaWYgd2UncmUgcmVuZGVyaW5nIGF0IGV4YWN0bHkgYSB0aW1lIG9mIDAsIGFzIHRoZXJlIGNvdWxkIGJlIGF1dG9SZXZlcnQgdmFsdWVzIHRoYXQgc2hvdWxkIGdldCBzZXQgb24gdGhlIG5leHQgdGljayAoaWYgdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgYmV5b25kIHRoZSBzdGFydFRpbWUsIG5lZ2F0aXZlIHRvdGFsVGltZSkuIERvbid0IHJlbW92ZSBpZiB0aGUgdGltZWxpbmUgaXMgcmV2ZXJzZWQgYW5kIHRoZSBwbGF5aGVhZCBpc24ndCBhdCAwLCBvdGhlcndpc2UgdGwucHJvZ3Jlc3MoMSkucmV2ZXJzZSgpIHdvbid0IHdvcmsuIE9ubHkgcmVtb3ZlIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCB0aGUgZW5kIGFuZCB0aW1lU2NhbGUgaXMgcG9zaXRpdmUsIG9yIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCAwIGFuZCB0aGUgdGltZVNjYWxlIGlzIG5lZ2F0aXZlLlxuXG4gICAgICAgIGlmICghc3VwcHJlc3NFdmVudHMgJiYgIShpc05lZ2F0aXZlICYmICFwcmV2VGltZSkgJiYgKHRUaW1lIHx8IHByZXZUaW1lIHx8IGlzWW95bykpIHtcbiAgICAgICAgICAvLyBpZiBwcmV2VGltZSBhbmQgdFRpbWUgYXJlIHplcm8sIHdlIHNob3VsZG4ndCBmaXJlIHRoZSBvblJldmVyc2VDb21wbGV0ZS4gVGhpcyBjb3VsZCBoYXBwZW4gaWYgeW91IGdzYXAudG8oLi4uIHtwYXVzZWQ6dHJ1ZX0pLnBsYXkoKTtcbiAgICAgICAgICBfY2FsbGJhY2sodGhpcywgdFRpbWUgPT09IHREdXIgPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiwgdHJ1ZSk7XG5cbiAgICAgICAgICB0aGlzLl9wcm9tICYmICEodFRpbWUgPCB0RHVyICYmIHRoaXMudGltZVNjYWxlKCkgPiAwKSAmJiB0aGlzLl9wcm9tKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8zLnRhcmdldHMgPSBmdW5jdGlvbiB0YXJnZXRzKCkge1xuICAgIHJldHVybiB0aGlzLl90YXJnZXRzO1xuICB9O1xuXG4gIF9wcm90bzMuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uIGludmFsaWRhdGUoc29mdCkge1xuICAgIC8vIFwic29mdFwiIGdpdmVzIHVzIGEgd2F5IHRvIGNsZWFyIG91dCBldmVyeXRoaW5nIEVYQ0VQVCB0aGUgcmVjb3JkZWQgcHJlLVwiZnJvbVwiIHBvcnRpb24gb2YgZnJvbSgpIHR3ZWVucy4gT3RoZXJ3aXNlLCBmb3IgZXhhbXBsZSwgaWYgeW91IHR3ZWVuLnByb2dyZXNzKDEpLnJlbmRlcigwLCB0cnVlIHRydWUpLmludmFsaWRhdGUoKSwgdGhlIFwiZnJvbVwiIHZhbHVlcyB3b3VsZCBwZXJzaXN0IGFuZCB0aGVuIG9uIHRoZSBuZXh0IHJlbmRlciwgdGhlIGZyb20oKSB0d2VlbnMgd291bGQgaW5pdGlhbGl6ZSBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgd291bGQgbWF0Y2ggdGhlIFwiZnJvbVwiIHZhbHVlcywgdGh1cyBhbmltYXRlIGZyb20gdGhlIHNhbWUgdmFsdWUgdG8gdGhlIHNhbWUgdmFsdWUgKG5vIGFuaW1hdGlvbikuIFdlIHRhcCBpbnRvIHRoaXMgaW4gU2Nyb2xsVHJpZ2dlcidzIHJlZnJlc2goKSB3aGVyZSB3ZSBtdXN0IHB1c2ggYSB0d2VlbiB0byBjb21wbGV0aW9uIGFuZCB0aGVuIGJhY2sgYWdhaW4gYnV0IGhvbm9yIGl0cyBpbml0IHN0YXRlIGluIGNhc2UgdGhlIHR3ZWVuIGlzIGRlcGVuZGVudCBvbiBhbm90aGVyIHR3ZWVuIGZ1cnRoZXIgdXAgb24gdGhlIHBhZ2UuXG4gICAgKCFzb2Z0IHx8ICF0aGlzLnZhcnMucnVuQmFja3dhcmRzKSAmJiAodGhpcy5fc3RhcnRBdCA9IDApO1xuICAgIHRoaXMuX3B0ID0gdGhpcy5fb3AgPSB0aGlzLl9vblVwZGF0ZSA9IHRoaXMuX2xhenkgPSB0aGlzLnJhdGlvID0gMDtcbiAgICB0aGlzLl9wdExvb2t1cCA9IFtdO1xuICAgIHRoaXMudGltZWxpbmUgJiYgdGhpcy50aW1lbGluZS5pbnZhbGlkYXRlKHNvZnQpO1xuICAgIHJldHVybiBfQW5pbWF0aW9uMi5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMsIHNvZnQpO1xuICB9O1xuXG4gIF9wcm90bzMucmVzZXRUbyA9IGZ1bmN0aW9uIHJlc2V0VG8ocHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlLCBza2lwUmVjdXJzaW9uKSB7XG4gICAgX3RpY2tlckFjdGl2ZSB8fCBfdGlja2VyLndha2UoKTtcbiAgICB0aGlzLl90cyB8fCB0aGlzLnBsYXkoKTtcbiAgICB2YXIgdGltZSA9IE1hdGgubWluKHRoaXMuX2R1ciwgKHRoaXMuX2RwLl90aW1lIC0gdGhpcy5fc3RhcnQpICogdGhpcy5fdHMpLFxuICAgICAgICByYXRpbztcbiAgICB0aGlzLl9pbml0dGVkIHx8IF9pbml0VHdlZW4odGhpcywgdGltZSk7XG4gICAgcmF0aW8gPSB0aGlzLl9lYXNlKHRpbWUgLyB0aGlzLl9kdXIpOyAvLyBkb24ndCBqdXN0IGdldCB0d2Vlbi5yYXRpbyBiZWNhdXNlIGl0IG1heSBub3QgaGF2ZSByZW5kZXJlZCB5ZXQuXG4gICAgLy8gcG9zc2libGUgZnV0dXJlIGFkZGl0aW9uIHRvIGFsbG93IGFuIG9iamVjdCB3aXRoIG11bHRpcGxlIHZhbHVlcyB0byB1cGRhdGUsIGxpa2UgdHdlZW4ucmVzZXRUbyh7eDogMTAwLCB5OiAyMDB9KTsgQXQgdGhpcyBwb2ludCwgaXQgZG9lc24ndCBzZWVtIHdvcnRoIHRoZSBhZGRlZCBrYiBnaXZlbiB0aGUgZmFjdCB0aGF0IG1vc3QgdXNlcnMgd2lsbCBsaWtlbHkgb3B0IGZvciB0aGUgY29udmVuaWVudCBnc2FwLnF1aWNrVG8oKSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCB0aGlzIG1ldGhvZC5cbiAgICAvLyBpZiAoX2lzT2JqZWN0KHByb3BlcnR5KSkgeyAvLyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25cbiAgICAvLyBcdGZvciAocCBpbiBwcm9wZXJ0eSkge1xuICAgIC8vIFx0XHRpZiAoX3VwZGF0ZVByb3BUd2VlbnModGhpcywgcCwgcHJvcGVydHlbcF0sIHZhbHVlID8gdmFsdWVbcF0gOiBudWxsLCBzdGFydCwgcmF0aW8sIHRpbWUpKSB7XG4gICAgLy8gXHRcdFx0cmV0dXJuIHRoaXMucmVzZXRUbyhwcm9wZXJ0eSwgdmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUpOyAvLyBpZiBhIFByb3BUd2VlbiB3YXNuJ3QgZm91bmQgZm9yIHRoZSBwcm9wZXJ0eSwgaXQnbGwgZ2V0IGZvcmNlZCB3aXRoIGEgcmUtaW5pdGlhbGl6YXRpb24gc28gd2UgbmVlZCB0byBqdW1wIG91dCBhbmQgc3RhcnQgb3ZlciBhZ2Fpbi5cbiAgICAvLyBcdFx0fVxuICAgIC8vIFx0fVxuICAgIC8vIH0gZWxzZSB7XG5cbiAgICBpZiAoX3VwZGF0ZVByb3BUd2VlbnModGhpcywgcHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlLCByYXRpbywgdGltZSwgc2tpcFJlY3Vyc2lvbikpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc2V0VG8ocHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlLCAxKTsgLy8gaWYgYSBQcm9wVHdlZW4gd2Fzbid0IGZvdW5kIGZvciB0aGUgcHJvcGVydHksIGl0J2xsIGdldCBmb3JjZWQgd2l0aCBhIHJlLWluaXRpYWxpemF0aW9uIHNvIHdlIG5lZWQgdG8ganVtcCBvdXQgYW5kIHN0YXJ0IG92ZXIgYWdhaW4uXG4gICAgfSAvL31cblxuXG4gICAgX2FsaWduUGxheWhlYWQodGhpcywgMCk7XG5cbiAgICB0aGlzLnBhcmVudCB8fCBfYWRkTGlua2VkTGlzdEl0ZW0odGhpcy5fZHAsIHRoaXMsIFwiX2ZpcnN0XCIsIFwiX2xhc3RcIiwgdGhpcy5fZHAuX3NvcnQgPyBcIl9zdGFydFwiIDogMCk7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyKDApO1xuICB9O1xuXG4gIF9wcm90bzMua2lsbCA9IGZ1bmN0aW9uIGtpbGwodGFyZ2V0cywgdmFycykge1xuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgIHZhcnMgPSBcImFsbFwiO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0cyAmJiAoIXZhcnMgfHwgdmFycyA9PT0gXCJhbGxcIikpIHtcbiAgICAgIHRoaXMuX2xhenkgPSB0aGlzLl9wdCA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyBfaW50ZXJydXB0KHRoaXMpIDogdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy50aW1lbGluZSkge1xuICAgICAgdmFyIHREdXIgPSB0aGlzLnRpbWVsaW5lLnRvdGFsRHVyYXRpb24oKTtcbiAgICAgIHRoaXMudGltZWxpbmUua2lsbFR3ZWVuc09mKHRhcmdldHMsIHZhcnMsIF9vdmVyd3JpdGluZ1R3ZWVuICYmIF9vdmVyd3JpdGluZ1R3ZWVuLnZhcnMub3ZlcndyaXRlICE9PSB0cnVlKS5fZmlyc3QgfHwgX2ludGVycnVwdCh0aGlzKTsgLy8gaWYgbm90aGluZyBpcyBsZWZ0IHR3ZWVuaW5nLCBpbnRlcnJ1cHQuXG5cbiAgICAgIHRoaXMucGFyZW50ICYmIHREdXIgIT09IHRoaXMudGltZWxpbmUudG90YWxEdXJhdGlvbigpICYmIF9zZXREdXJhdGlvbih0aGlzLCB0aGlzLl9kdXIgKiB0aGlzLnRpbWVsaW5lLl90RHVyIC8gdER1ciwgMCwgMSk7IC8vIGlmIGEgbmVzdGVkIHR3ZWVuIGlzIGtpbGxlZCB0aGF0IGNoYW5nZXMgdGhlIGR1cmF0aW9uLCBpdCBzaG91bGQgYWZmZWN0IHRoaXMgdHdlZW4ncyBkdXJhdGlvbi4gV2UgbXVzdCB1c2UgdGhlIHJhdGlvLCB0aG91Z2gsIGJlY2F1c2Ugc29tZXRpbWVzIHRoZSBpbnRlcm5hbCB0aW1lbGluZSBpcyBzdHJldGNoZWQgbGlrZSBmb3Iga2V5ZnJhbWVzIHdoZXJlIHRoZXkgZG9uJ3QgYWxsIGFkZCB1cCB0byB3aGF0ZXZlciB0aGUgcGFyZW50IHR3ZWVuJ3MgZHVyYXRpb24gd2FzIHNldCB0by5cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZFRhcmdldHMgPSB0aGlzLl90YXJnZXRzLFxuICAgICAgICBraWxsaW5nVGFyZ2V0cyA9IHRhcmdldHMgPyB0b0FycmF5KHRhcmdldHMpIDogcGFyc2VkVGFyZ2V0cyxcbiAgICAgICAgcHJvcFR3ZWVuTG9va3VwID0gdGhpcy5fcHRMb29rdXAsXG4gICAgICAgIGZpcnN0UFQgPSB0aGlzLl9wdCxcbiAgICAgICAgb3ZlcndyaXR0ZW5Qcm9wcyxcbiAgICAgICAgY3VyTG9va3VwLFxuICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHAsXG4gICAgICAgIHB0LFxuICAgICAgICBpO1xuXG4gICAgaWYgKCghdmFycyB8fCB2YXJzID09PSBcImFsbFwiKSAmJiBfYXJyYXlzTWF0Y2gocGFyc2VkVGFyZ2V0cywga2lsbGluZ1RhcmdldHMpKSB7XG4gICAgICB2YXJzID09PSBcImFsbFwiICYmICh0aGlzLl9wdCA9IDApO1xuICAgICAgcmV0dXJuIF9pbnRlcnJ1cHQodGhpcyk7XG4gICAgfVxuXG4gICAgb3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX29wID0gdGhpcy5fb3AgfHwgW107XG5cbiAgICBpZiAodmFycyAhPT0gXCJhbGxcIikge1xuICAgICAgLy9zbyBwZW9wbGUgY2FuIHBhc3MgaW4gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lc1xuICAgICAgaWYgKF9pc1N0cmluZyh2YXJzKSkge1xuICAgICAgICBwID0ge307XG5cbiAgICAgICAgX2ZvckVhY2hOYW1lKHZhcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHBbbmFtZV0gPSAxO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXJzID0gcDtcbiAgICAgIH1cblxuICAgICAgdmFycyA9IF9hZGRBbGlhc2VzVG9WYXJzKHBhcnNlZFRhcmdldHMsIHZhcnMpO1xuICAgIH1cblxuICAgIGkgPSBwYXJzZWRUYXJnZXRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmICh+a2lsbGluZ1RhcmdldHMuaW5kZXhPZihwYXJzZWRUYXJnZXRzW2ldKSkge1xuICAgICAgICBjdXJMb29rdXAgPSBwcm9wVHdlZW5Mb29rdXBbaV07XG5cbiAgICAgICAgaWYgKHZhcnMgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgICBvdmVyd3JpdHRlblByb3BzW2ldID0gdmFycztcbiAgICAgICAgICBwcm9wcyA9IGN1ckxvb2t1cDtcbiAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyA9IHt9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1ck92ZXJ3cml0ZVByb3BzID0gb3ZlcndyaXR0ZW5Qcm9wc1tpXSA9IG92ZXJ3cml0dGVuUHJvcHNbaV0gfHwge307XG4gICAgICAgICAgcHJvcHMgPSB2YXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChwIGluIHByb3BzKSB7XG4gICAgICAgICAgcHQgPSBjdXJMb29rdXAgJiYgY3VyTG9va3VwW3BdO1xuXG4gICAgICAgICAgaWYgKHB0KSB7XG4gICAgICAgICAgICBpZiAoIShcImtpbGxcIiBpbiBwdC5kKSB8fCBwdC5kLmtpbGwocCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtKHRoaXMsIHB0LCBcIl9wdFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGN1ckxvb2t1cFtwXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3VyT3ZlcndyaXRlUHJvcHMgIT09IFwiYWxsXCIpIHtcbiAgICAgICAgICAgIGN1ck92ZXJ3cml0ZVByb3BzW3BdID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9pbml0dGVkICYmICF0aGlzLl9wdCAmJiBmaXJzdFBUICYmIF9pbnRlcnJ1cHQodGhpcyk7IC8vaWYgYWxsIHR3ZWVuaW5nIHByb3BlcnRpZXMgYXJlIGtpbGxlZCwga2lsbCB0aGUgdHdlZW4uIFdpdGhvdXQgdGhpcyBsaW5lLCBpZiB0aGVyZSdzIGEgdHdlZW4gd2l0aCBtdWx0aXBsZSB0YXJnZXRzIGFuZCB0aGVuIHlvdSBraWxsVHdlZW5zT2YoKSBlYWNoIHRhcmdldCBpbmRpdmlkdWFsbHksIHRoZSB0d2VlbiB3b3VsZCB0ZWNobmljYWxseSBzdGlsbCByZW1haW4gYWN0aXZlIGFuZCBmaXJlIGl0cyBvbkNvbXBsZXRlIGV2ZW4gdGhvdWdoIHRoZXJlIGFyZW4ndCBhbnkgbW9yZSBwcm9wZXJ0aWVzIHR3ZWVuaW5nLlxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgVHdlZW4udG8gPSBmdW5jdGlvbiB0byh0YXJnZXRzLCB2YXJzKSB7XG4gICAgcmV0dXJuIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzLCBhcmd1bWVudHNbMl0pO1xuICB9O1xuXG4gIFR3ZWVuLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRhcmdldHMsIHZhcnMpIHtcbiAgICByZXR1cm4gX2NyZWF0ZVR3ZWVuVHlwZSgxLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIFR3ZWVuLmRlbGF5ZWRDYWxsID0gZnVuY3Rpb24gZGVsYXllZENhbGwoZGVsYXksIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG4gICAgcmV0dXJuIG5ldyBUd2VlbihjYWxsYmFjaywgMCwge1xuICAgICAgaW1tZWRpYXRlUmVuZGVyOiBmYWxzZSxcbiAgICAgIGxhenk6IGZhbHNlLFxuICAgICAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgIG9uQ29tcGxldGU6IGNhbGxiYWNrLFxuICAgICAgb25SZXZlcnNlQ29tcGxldGU6IGNhbGxiYWNrLFxuICAgICAgb25Db21wbGV0ZVBhcmFtczogcGFyYW1zLFxuICAgICAgb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6IHBhcmFtcyxcbiAgICAgIGNhbGxiYWNrU2NvcGU6IHNjb3BlXG4gICAgfSk7IC8vIHdlIG11c3QgdXNlIG9uUmV2ZXJzZUNvbXBsZXRlIHRvbyBmb3IgdGhpbmdzIGxpa2UgdGltZWxpbmUuYWRkKCgpID0+IHsuLi59KSB3aGljaCBzaG91bGQgYmUgdHJpZ2dlcmVkIGluIEJPVEggZGlyZWN0aW9ucyAoZm9yd2FyZCBhbmQgcmV2ZXJzZSlcbiAgfTtcblxuICBUd2Vlbi5mcm9tVG8gPSBmdW5jdGlvbiBmcm9tVG8odGFyZ2V0cywgZnJvbVZhcnMsIHRvVmFycykge1xuICAgIHJldHVybiBfY3JlYXRlVHdlZW5UeXBlKDIsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgVHdlZW4uc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldHMsIHZhcnMpIHtcbiAgICB2YXJzLmR1cmF0aW9uID0gMDtcbiAgICB2YXJzLnJlcGVhdERlbGF5IHx8ICh2YXJzLnJlcGVhdCA9IDApO1xuICAgIHJldHVybiBuZXcgVHdlZW4odGFyZ2V0cywgdmFycyk7XG4gIH07XG5cbiAgVHdlZW4ua2lsbFR3ZWVuc09mID0gZnVuY3Rpb24ga2lsbFR3ZWVuc09mKHRhcmdldHMsIHByb3BzLCBvbmx5QWN0aXZlKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5raWxsVHdlZW5zT2YodGFyZ2V0cywgcHJvcHMsIG9ubHlBY3RpdmUpO1xuICB9O1xuXG4gIHJldHVybiBUd2Vlbjtcbn0oQW5pbWF0aW9uKTtcblxuX3NldERlZmF1bHRzKFR3ZWVuLnByb3RvdHlwZSwge1xuICBfdGFyZ2V0czogW10sXG4gIF9sYXp5OiAwLFxuICBfc3RhcnRBdDogMCxcbiAgX29wOiAwLFxuICBfb25Jbml0OiAwXG59KTsgLy9hZGQgdGhlIHBlcnRpbmVudCB0aW1lbGluZSBtZXRob2RzIHRvIFR3ZWVuIGluc3RhbmNlcyBzbyB0aGF0IHVzZXJzIGNhbiBjaGFpbiBjb252ZW5pZW50bHkgYW5kIGNyZWF0ZSBhIHRpbWVsaW5lIGF1dG9tYXRpY2FsbHkuIChyZW1vdmVkIGR1ZSB0byBjb25jZXJucyB0aGF0IGl0J2QgdWx0aW1hdGVseSBhZGQgdG8gbW9yZSBjb25mdXNpb24gZXNwZWNpYWxseSBmb3IgYmVnaW5uZXJzKVxuLy8gX2ZvckVhY2hOYW1lKFwidG8sZnJvbSxmcm9tVG8sc2V0LGNhbGwsYWRkLGFkZExhYmVsLGFkZFBhdXNlXCIsIG5hbWUgPT4ge1xuLy8gXHRUd2Vlbi5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbi8vIFx0XHRsZXQgdGwgPSBuZXcgVGltZWxpbmUoKTtcbi8vIFx0XHRyZXR1cm4gX2FkZFRvVGltZWxpbmUodGwsIHRoaXMpW25hbWVdLmFwcGx5KHRsLCB0b0FycmF5KGFyZ3VtZW50cykpO1xuLy8gXHR9XG4vLyB9KTtcbi8vZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIExldmVyYWdlIHRoZSB0aW1lbGluZSBjYWxscy5cblxuXG5fZm9yRWFjaE5hbWUoXCJzdGFnZ2VyVG8sc3RhZ2dlckZyb20sc3RhZ2dlckZyb21Ub1wiLCBmdW5jdGlvbiAobmFtZSkge1xuICBUd2VlbltuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGwgPSBuZXcgVGltZWxpbmUoKSxcbiAgICAgICAgcGFyYW1zID0gX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIHBhcmFtcy5zcGxpY2UobmFtZSA9PT0gXCJzdGFnZ2VyRnJvbVRvXCIgPyA1IDogNCwgMCwgMCk7XG4gICAgcmV0dXJuIHRsW25hbWVdLmFwcGx5KHRsLCBwYXJhbXMpO1xuICB9O1xufSk7XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFBST1BUV0VFTlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbnZhciBfc2V0dGVyUGxhaW4gPSBmdW5jdGlvbiBfc2V0dGVyUGxhaW4odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbn0sXG4gICAgX3NldHRlckZ1bmMgPSBmdW5jdGlvbiBfc2V0dGVyRnVuYyh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XSh2YWx1ZSk7XG59LFxuICAgIF9zZXR0ZXJGdW5jV2l0aFBhcmFtID0gZnVuY3Rpb24gX3NldHRlckZ1bmNXaXRoUGFyYW0odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEpIHtcbiAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eV0oZGF0YS5mcCwgdmFsdWUpO1xufSxcbiAgICBfc2V0dGVyQXR0cmlidXRlID0gZnVuY3Rpb24gX3NldHRlckF0dHJpYnV0ZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0LnNldEF0dHJpYnV0ZShwcm9wZXJ0eSwgdmFsdWUpO1xufSxcbiAgICBfZ2V0U2V0dGVyID0gZnVuY3Rpb24gX2dldFNldHRlcih0YXJnZXQsIHByb3BlcnR5KSB7XG4gIHJldHVybiBfaXNGdW5jdGlvbih0YXJnZXRbcHJvcGVydHldKSA/IF9zZXR0ZXJGdW5jIDogX2lzVW5kZWZpbmVkKHRhcmdldFtwcm9wZXJ0eV0pICYmIHRhcmdldC5zZXRBdHRyaWJ1dGUgPyBfc2V0dGVyQXR0cmlidXRlIDogX3NldHRlclBsYWluO1xufSxcbiAgICBfcmVuZGVyUGxhaW4gPSBmdW5jdGlvbiBfcmVuZGVyUGxhaW4ocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMDAwKSAvIDEwMDAwMDAsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyQm9vbGVhbiA9IGZ1bmN0aW9uIF9yZW5kZXJCb29sZWFuKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgISEoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pLCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlckNvbXBsZXhTdHJpbmcgPSBmdW5jdGlvbiBfcmVuZGVyQ29tcGxleFN0cmluZyhyYXRpbywgZGF0YSkge1xuICB2YXIgcHQgPSBkYXRhLl9wdCxcbiAgICAgIHMgPSBcIlwiO1xuXG4gIGlmICghcmF0aW8gJiYgZGF0YS5iKSB7XG4gICAgLy9iID0gYmVnaW5uaW5nIHN0cmluZ1xuICAgIHMgPSBkYXRhLmI7XG4gIH0gZWxzZSBpZiAocmF0aW8gPT09IDEgJiYgZGF0YS5lKSB7XG4gICAgLy9lID0gZW5kaW5nIHN0cmluZ1xuICAgIHMgPSBkYXRhLmU7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBzID0gcHQucCArIChwdC5tID8gcHQubShwdC5zICsgcHQuYyAqIHJhdGlvKSA6IE1hdGgucm91bmQoKHB0LnMgKyBwdC5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDApICsgczsgLy93ZSB1c2UgdGhlIFwicFwiIHByb3BlcnR5IGZvciB0aGUgdGV4dCBpbmJldHdlZW4gKGxpa2UgYSBzdWZmaXgpLiBBbmQgaW4gdGhlIGNvbnRleHQgb2YgYSBjb21wbGV4IHN0cmluZywgdGhlIG1vZGlmaWVyIChtKSBpcyB0eXBpY2FsbHkganVzdCBNYXRoLnJvdW5kKCksIGxpa2UgZm9yIFJHQiBjb2xvcnMuXG5cbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuXG4gICAgcyArPSBkYXRhLmM7IC8vd2UgdXNlIHRoZSBcImNcIiBvZiB0aGUgUHJvcFR3ZWVuIHRvIHN0b3JlIHRoZSBmaW5hbCBjaHVuayBvZiBub24tbnVtZXJpYyB0ZXh0LlxuICB9XG5cbiAgZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHMsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyUHJvcFR3ZWVucyA9IGZ1bmN0aW9uIF9yZW5kZXJQcm9wVHdlZW5zKHJhdGlvLCBkYXRhKSB7XG4gIHZhciBwdCA9IGRhdGEuX3B0O1xuXG4gIHdoaWxlIChwdCkge1xuICAgIHB0LnIocmF0aW8sIHB0LmQpO1xuICAgIHB0ID0gcHQuX25leHQ7XG4gIH1cbn0sXG4gICAgX2FkZFBsdWdpbk1vZGlmaWVyID0gZnVuY3Rpb24gX2FkZFBsdWdpbk1vZGlmaWVyKG1vZGlmaWVyLCB0d2VlbiwgdGFyZ2V0LCBwcm9wZXJ0eSkge1xuICB2YXIgcHQgPSB0aGlzLl9wdCxcbiAgICAgIG5leHQ7XG5cbiAgd2hpbGUgKHB0KSB7XG4gICAgbmV4dCA9IHB0Ll9uZXh0O1xuICAgIHB0LnAgPT09IHByb3BlcnR5ICYmIHB0Lm1vZGlmaWVyKG1vZGlmaWVyLCB0d2VlbiwgdGFyZ2V0KTtcbiAgICBwdCA9IG5leHQ7XG4gIH1cbn0sXG4gICAgX2tpbGxQcm9wVHdlZW5zT2YgPSBmdW5jdGlvbiBfa2lsbFByb3BUd2VlbnNPZihwcm9wZXJ0eSkge1xuICB2YXIgcHQgPSB0aGlzLl9wdCxcbiAgICAgIGhhc05vbkRlcGVuZGVudFJlbWFpbmluZyxcbiAgICAgIG5leHQ7XG5cbiAgd2hpbGUgKHB0KSB7XG4gICAgbmV4dCA9IHB0Ll9uZXh0O1xuXG4gICAgaWYgKHB0LnAgPT09IHByb3BlcnR5ICYmICFwdC5vcCB8fCBwdC5vcCA9PT0gcHJvcGVydHkpIHtcbiAgICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSh0aGlzLCBwdCwgXCJfcHRcIik7XG4gICAgfSBlbHNlIGlmICghcHQuZGVwKSB7XG4gICAgICBoYXNOb25EZXBlbmRlbnRSZW1haW5pbmcgPSAxO1xuICAgIH1cblxuICAgIHB0ID0gbmV4dDtcbiAgfVxuXG4gIHJldHVybiAhaGFzTm9uRGVwZW5kZW50UmVtYWluaW5nO1xufSxcbiAgICBfc2V0dGVyV2l0aE1vZGlmaWVyID0gZnVuY3Rpb24gX3NldHRlcldpdGhNb2RpZmllcih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSkge1xuICBkYXRhLm1TZXQodGFyZ2V0LCBwcm9wZXJ0eSwgZGF0YS5tLmNhbGwoZGF0YS50d2VlbiwgdmFsdWUsIGRhdGEubXQpLCBkYXRhKTtcbn0sXG4gICAgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSA9IGZ1bmN0aW9uIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkocGFyZW50KSB7XG4gIHZhciBwdCA9IHBhcmVudC5fcHQsXG4gICAgICBuZXh0LFxuICAgICAgcHQyLFxuICAgICAgZmlyc3QsXG4gICAgICBsYXN0OyAvL3NvcnRzIHRoZSBQcm9wVHdlZW4gbGlua2VkIGxpc3QgaW4gb3JkZXIgb2YgcHJpb3JpdHkgYmVjYXVzZSBzb21lIHBsdWdpbnMgbmVlZCB0byBkbyB0aGVpciB3b3JrIGFmdGVyIEFMTCBvZiB0aGUgUHJvcFR3ZWVucyB3ZXJlIGNyZWF0ZWQgKGxpa2UgUm91bmRQcm9wc1BsdWdpbiBhbmQgTW9kaWZpZXJzUGx1Z2luKVxuXG4gIHdoaWxlIChwdCkge1xuICAgIG5leHQgPSBwdC5fbmV4dDtcbiAgICBwdDIgPSBmaXJzdDtcblxuICAgIHdoaWxlIChwdDIgJiYgcHQyLnByID4gcHQucHIpIHtcbiAgICAgIHB0MiA9IHB0Mi5fbmV4dDtcbiAgICB9XG5cbiAgICBpZiAocHQuX3ByZXYgPSBwdDIgPyBwdDIuX3ByZXYgOiBsYXN0KSB7XG4gICAgICBwdC5fcHJldi5fbmV4dCA9IHB0O1xuICAgIH0gZWxzZSB7XG4gICAgICBmaXJzdCA9IHB0O1xuICAgIH1cblxuICAgIGlmIChwdC5fbmV4dCA9IHB0Mikge1xuICAgICAgcHQyLl9wcmV2ID0gcHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSBwdDtcbiAgICB9XG5cbiAgICBwdCA9IG5leHQ7XG4gIH1cblxuICBwYXJlbnQuX3B0ID0gZmlyc3Q7XG59OyAvL1Byb3BUd2VlbiBrZXk6IHQgPSB0YXJnZXQsIHAgPSBwcm9wLCByID0gcmVuZGVyZXIsIGQgPSBkYXRhLCBzID0gc3RhcnQsIGMgPSBjaGFuZ2UsIG9wID0gb3ZlcndyaXRlUHJvcGVydHkgKE9OTFkgcG9wdWxhdGVkIHdoZW4gaXQncyBkaWZmZXJlbnQgdGhhbiBwKSwgcHIgPSBwcmlvcml0eSwgX25leHQvX3ByZXYgZm9yIHRoZSBsaW5rZWQgbGlzdCBzaWJsaW5ncywgc2V0ID0gc2V0dGVyLCBtID0gbW9kaWZpZXIsIG1TZXQgPSBtb2RpZmllclNldHRlciAodGhlIG9yaWdpbmFsIHNldHRlciwgYmVmb3JlIGEgbW9kaWZpZXIgd2FzIGFkZGVkKVxuXG5cbmV4cG9ydCB2YXIgUHJvcFR3ZWVuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUHJvcFR3ZWVuKG5leHQsIHRhcmdldCwgcHJvcCwgc3RhcnQsIGNoYW5nZSwgcmVuZGVyZXIsIGRhdGEsIHNldHRlciwgcHJpb3JpdHkpIHtcbiAgICB0aGlzLnQgPSB0YXJnZXQ7XG4gICAgdGhpcy5zID0gc3RhcnQ7XG4gICAgdGhpcy5jID0gY2hhbmdlO1xuICAgIHRoaXMucCA9IHByb3A7XG4gICAgdGhpcy5yID0gcmVuZGVyZXIgfHwgX3JlbmRlclBsYWluO1xuICAgIHRoaXMuZCA9IGRhdGEgfHwgdGhpcztcbiAgICB0aGlzLnNldCA9IHNldHRlciB8fCBfc2V0dGVyUGxhaW47XG4gICAgdGhpcy5wciA9IHByaW9yaXR5IHx8IDA7XG4gICAgdGhpcy5fbmV4dCA9IG5leHQ7XG5cbiAgICBpZiAobmV4dCkge1xuICAgICAgbmV4dC5fcHJldiA9IHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90bzQgPSBQcm9wVHdlZW4ucHJvdG90eXBlO1xuXG4gIF9wcm90bzQubW9kaWZpZXIgPSBmdW5jdGlvbiBtb2RpZmllcihmdW5jLCB0d2VlbiwgdGFyZ2V0KSB7XG4gICAgdGhpcy5tU2V0ID0gdGhpcy5tU2V0IHx8IHRoaXMuc2V0OyAvL2luIGNhc2UgaXQgd2FzIGFscmVhZHkgc2V0IChhIFByb3BUd2VlbiBjYW4gb25seSBoYXZlIG9uZSBtb2RpZmllcilcblxuICAgIHRoaXMuc2V0ID0gX3NldHRlcldpdGhNb2RpZmllcjtcbiAgICB0aGlzLm0gPSBmdW5jO1xuICAgIHRoaXMubXQgPSB0YXJnZXQ7IC8vbW9kaWZpZXIgdGFyZ2V0XG5cbiAgICB0aGlzLnR3ZWVuID0gdHdlZW47XG4gIH07XG5cbiAgcmV0dXJuIFByb3BUd2Vlbjtcbn0oKTsgLy9Jbml0aWFsaXphdGlvbiB0YXNrc1xuXG5fZm9yRWFjaE5hbWUoX2NhbGxiYWNrTmFtZXMgKyBcInBhcmVudCxkdXJhdGlvbixlYXNlLGRlbGF5LG92ZXJ3cml0ZSxydW5CYWNrd2FyZHMsc3RhcnRBdCx5b3lvLGltbWVkaWF0ZVJlbmRlcixyZXBlYXQscmVwZWF0RGVsYXksZGF0YSxwYXVzZWQscmV2ZXJzZWQsbGF6eSxjYWxsYmFja1Njb3BlLHN0cmluZ0ZpbHRlcixpZCx5b3lvRWFzZSxzdGFnZ2VyLGluaGVyaXQscmVwZWF0UmVmcmVzaCxrZXlmcmFtZXMsYXV0b1JldmVydCxzY3JvbGxUcmlnZ2VyXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfcmVzZXJ2ZWRQcm9wc1tuYW1lXSA9IDE7XG59KTtcblxuX2dsb2JhbHMuVHdlZW5NYXggPSBfZ2xvYmFscy5Ud2VlbkxpdGUgPSBUd2Vlbjtcbl9nbG9iYWxzLlRpbWVsaW5lTGl0ZSA9IF9nbG9iYWxzLlRpbWVsaW5lTWF4ID0gVGltZWxpbmU7XG5fZ2xvYmFsVGltZWxpbmUgPSBuZXcgVGltZWxpbmUoe1xuICBzb3J0Q2hpbGRyZW46IGZhbHNlLFxuICBkZWZhdWx0czogX2RlZmF1bHRzLFxuICBhdXRvUmVtb3ZlQ2hpbGRyZW46IHRydWUsXG4gIGlkOiBcInJvb3RcIixcbiAgc21vb3RoQ2hpbGRUaW1pbmc6IHRydWVcbn0pO1xuX2NvbmZpZy5zdHJpbmdGaWx0ZXIgPSBfY29sb3JTdHJpbmdGaWx0ZXI7XG5cbnZhciBfbWVkaWEgPSBbXSxcbiAgICBfbGlzdGVuZXJzID0ge30sXG4gICAgX2VtcHR5QXJyYXkgPSBbXSxcbiAgICBfbGFzdE1lZGlhVGltZSA9IDAsXG4gICAgX2NvbnRleHRJRCA9IDAsXG4gICAgX2Rpc3BhdGNoID0gZnVuY3Rpb24gX2Rpc3BhdGNoKHR5cGUpIHtcbiAgcmV0dXJuIChfbGlzdGVuZXJzW3R5cGVdIHx8IF9lbXB0eUFycmF5KS5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gZigpO1xuICB9KTtcbn0sXG4gICAgX29uTWVkaWFDaGFuZ2UgPSBmdW5jdGlvbiBfb25NZWRpYUNoYW5nZSgpIHtcbiAgdmFyIHRpbWUgPSBEYXRlLm5vdygpLFxuICAgICAgbWF0Y2hlcyA9IFtdO1xuXG4gIGlmICh0aW1lIC0gX2xhc3RNZWRpYVRpbWUgPiAyKSB7XG4gICAgX2Rpc3BhdGNoKFwibWF0Y2hNZWRpYUluaXRcIik7XG5cbiAgICBfbWVkaWEuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgdmFyIHF1ZXJpZXMgPSBjLnF1ZXJpZXMsXG4gICAgICAgICAgY29uZGl0aW9ucyA9IGMuY29uZGl0aW9ucyxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBwLFxuICAgICAgICAgIGFueU1hdGNoLFxuICAgICAgICAgIHRvZ2dsZWQ7XG5cbiAgICAgIGZvciAocCBpbiBxdWVyaWVzKSB7XG4gICAgICAgIG1hdGNoID0gX3dpbi5tYXRjaE1lZGlhKHF1ZXJpZXNbcF0pLm1hdGNoZXM7IC8vIEZpcmVmb3ggZG9lc24ndCB1cGRhdGUgdGhlIFwibWF0Y2hlc1wiIHByb3BlcnR5IG9mIHRoZSBNZWRpYVF1ZXJ5TGlzdCBvYmplY3QgY29ycmVjdGx5IC0gaXQgb25seSBkb2VzIHNvIGFzIGl0IGNhbGxzIGl0cyBjaGFuZ2UgaGFuZGxlciAtIHNvIHdlIG11c3QgcmUtY3JlYXRlIGEgbWVkaWEgcXVlcnkgaGVyZSB0byBlbnN1cmUgaXQncyBhY2N1cmF0ZS5cblxuICAgICAgICBtYXRjaCAmJiAoYW55TWF0Y2ggPSAxKTtcblxuICAgICAgICBpZiAobWF0Y2ggIT09IGNvbmRpdGlvbnNbcF0pIHtcbiAgICAgICAgICBjb25kaXRpb25zW3BdID0gbWF0Y2g7XG4gICAgICAgICAgdG9nZ2xlZCA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRvZ2dsZWQpIHtcbiAgICAgICAgYy5yZXZlcnQoKTtcbiAgICAgICAgYW55TWF0Y2ggJiYgbWF0Y2hlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2Rpc3BhdGNoKFwibWF0Y2hNZWRpYVJldmVydFwiKTtcblxuICAgIG1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMub25NYXRjaChjLCBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICByZXR1cm4gYy5hZGQobnVsbCwgZnVuYyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBfbGFzdE1lZGlhVGltZSA9IHRpbWU7XG5cbiAgICBfZGlzcGF0Y2goXCJtYXRjaE1lZGlhXCIpO1xuICB9XG59O1xuXG52YXIgQ29udGV4dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbnRleHQoZnVuYywgc2NvcGUpIHtcbiAgICB0aGlzLnNlbGVjdG9yID0gc2NvcGUgJiYgc2VsZWN0b3Ioc2NvcGUpO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMuX3IgPSBbXTsgLy8gcmV0dXJuZWQvY2xlYW51cCBmdW5jdGlvbnNcblxuICAgIHRoaXMuaXNSZXZlcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuaWQgPSBfY29udGV4dElEKys7IC8vIHRvIHdvcmsgYXJvdW5kIGlzc3VlcyB0aGF0IGZyYW1ld29ya3MgbGlrZSBWdWUgY2F1c2UgYnkgbWFraW5nIHRoaW5ncyBpbnRvIFByb3hpZXMgd2hpY2ggbWFrZSBpdCBpbXBvc3NpYmxlIHRvIGRvIHNvbWV0aGluZyBsaWtlIF9tZWRpYS5pbmRleE9mKHRoaXMpIGJlY2F1c2UgXCJ0aGlzXCIgd291bGQgbm8gbG9uZ2VyIHJlZmVyIHRvIHRoZSBDb250ZXh0IGluc3RhbmNlIGl0c2VsZiAtIGl0J2QgcmVmZXIgdG8gYSBQcm94eSEgV2UgbmVlZGVkIGEgd2F5IHRvIGlkZW50aWZ5IHRoZSBjb250ZXh0IHVuaXF1ZWx5XG5cbiAgICBmdW5jICYmIHRoaXMuYWRkKGZ1bmMpO1xuICB9XG5cbiAgdmFyIF9wcm90bzUgPSBDb250ZXh0LnByb3RvdHlwZTtcblxuICBfcHJvdG81LmFkZCA9IGZ1bmN0aW9uIGFkZChuYW1lLCBmdW5jLCBzY29wZSkge1xuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBhZGRpdGlvbiBpZiB3ZSBuZWVkIHRoZSBhYmlsaXR5IHRvIGFkZCgpIGFuIGFuaW1hdGlvbiB0byBhIGNvbnRleHQgYW5kIGZvciB3aGF0ZXZlciByZWFzb24gY2Fubm90IGNyZWF0ZSB0aGF0IGFuaW1hdGlvbiBpbnNpZGUgb2YgYSBjb250ZXh0LmFkZCgoKSA9PiB7Li4ufSkgZnVuY3Rpb24uXG4gICAgLy8gaWYgKG5hbWUgJiYgX2lzRnVuY3Rpb24obmFtZS5yZXZlcnQpKSB7XG4gICAgLy8gXHR0aGlzLmRhdGEucHVzaChuYW1lKTtcbiAgICAvLyBcdHJldHVybiAobmFtZS5fY3R4ID0gdGhpcyk7XG4gICAgLy8gfVxuICAgIGlmIChfaXNGdW5jdGlvbihuYW1lKSkge1xuICAgICAgc2NvcGUgPSBmdW5jO1xuICAgICAgZnVuYyA9IG5hbWU7XG4gICAgICBuYW1lID0gX2lzRnVuY3Rpb247XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBmID0gZnVuY3Rpb24gZigpIHtcbiAgICAgIHZhciBwcmV2ID0gX2NvbnRleHQsXG4gICAgICAgICAgcHJldlNlbGVjdG9yID0gc2VsZi5zZWxlY3RvcixcbiAgICAgICAgICByZXN1bHQ7XG4gICAgICBwcmV2ICYmIHByZXYgIT09IHNlbGYgJiYgcHJldi5kYXRhLnB1c2goc2VsZik7XG4gICAgICBzY29wZSAmJiAoc2VsZi5zZWxlY3RvciA9IHNlbGVjdG9yKHNjb3BlKSk7XG4gICAgICBfY29udGV4dCA9IHNlbGY7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICBfaXNGdW5jdGlvbihyZXN1bHQpICYmIHNlbGYuX3IucHVzaChyZXN1bHQpO1xuICAgICAgX2NvbnRleHQgPSBwcmV2O1xuICAgICAgc2VsZi5zZWxlY3RvciA9IHByZXZTZWxlY3RvcjtcbiAgICAgIHNlbGYuaXNSZXZlcnRlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgc2VsZi5sYXN0ID0gZjtcbiAgICByZXR1cm4gbmFtZSA9PT0gX2lzRnVuY3Rpb24gPyBmKHNlbGYsIGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICByZXR1cm4gc2VsZi5hZGQobnVsbCwgZnVuYyk7XG4gICAgfSkgOiBuYW1lID8gc2VsZltuYW1lXSA9IGYgOiBmO1xuICB9O1xuXG4gIF9wcm90bzUuaWdub3JlID0gZnVuY3Rpb24gaWdub3JlKGZ1bmMpIHtcbiAgICB2YXIgcHJldiA9IF9jb250ZXh0O1xuICAgIF9jb250ZXh0ID0gbnVsbDtcbiAgICBmdW5jKHRoaXMpO1xuICAgIF9jb250ZXh0ID0gcHJldjtcbiAgfTtcblxuICBfcHJvdG81LmdldFR3ZWVucyA9IGZ1bmN0aW9uIGdldFR3ZWVucygpIHtcbiAgICB2YXIgYSA9IFtdO1xuICAgIHRoaXMuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIENvbnRleHQgPyBhLnB1c2guYXBwbHkoYSwgZS5nZXRUd2VlbnMoKSkgOiBlIGluc3RhbmNlb2YgVHdlZW4gJiYgIShlLnBhcmVudCAmJiBlLnBhcmVudC5kYXRhID09PSBcIm5lc3RlZFwiKSAmJiBhLnB1c2goZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgX3Byb3RvNS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuX3IubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgX3Byb3RvNS5raWxsID0gZnVuY3Rpb24ga2lsbChyZXZlcnQsIG1hdGNoTWVkaWEpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIGlmIChyZXZlcnQpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0d2VlbnMgPSBfdGhpczQuZ2V0VHdlZW5zKCksXG4gICAgICAgICAgICBpID0gX3RoaXM0LmRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgdDtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgLy8gRmxpcCBwbHVnaW4gdHdlZW5zIGFyZSB2ZXJ5IGRpZmZlcmVudCBpbiB0aGF0IHRoZXkgc2hvdWxkIGFjdHVhbGx5IGJlIHB1c2hlZCB0byB0aGVpciBlbmQuIFRoZSBwbHVnaW4gcmVwbGFjZXMgdGhlIHRpbWVsaW5lJ3MgLnJldmVydCgpIG1ldGhvZCB0byBkbyBleGFjdGx5IHRoYXQuIEJ1dCB3ZSBhbHNvIG5lZWQgdG8gcmVtb3ZlIGFueSBvZiB0aG9zZSBuZXN0ZWQgdHdlZW5zIGluc2lkZSB0aGUgZmxpcCB0aW1lbGluZSBzbyB0aGF0IHRoZXkgZG9uJ3QgZ2V0IGluZGl2aWR1YWxseSByZXZlcnRlZC5cbiAgICAgICAgICB0ID0gX3RoaXM0LmRhdGFbaV07XG5cbiAgICAgICAgICBpZiAodC5kYXRhID09PSBcImlzRmxpcFwiKSB7XG4gICAgICAgICAgICB0LnJldmVydCgpO1xuICAgICAgICAgICAgdC5nZXRDaGlsZHJlbih0cnVlLCB0cnVlLCBmYWxzZSkuZm9yRWFjaChmdW5jdGlvbiAodHdlZW4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHR3ZWVucy5zcGxpY2UodHdlZW5zLmluZGV4T2YodHdlZW4pLCAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBzYXZlIGFzIGFuIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBjYWNoZSB0aGUgZ2xvYmFsVGltZSBmb3IgZWFjaCB0d2VlbiB0byBvcHRpbWl6ZSBwZXJmb3JtYW5jZSBkdXJpbmcgdGhlIHNvcnRcblxuXG4gICAgICAgIHR3ZWVucy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZzogdC5fZHVyIHx8IHQuX2RlbGF5IHx8IHQuX3NhdCAmJiAhdC5fc2F0LnZhcnMuaW1tZWRpYXRlUmVuZGVyID8gdC5nbG9iYWxUaW1lKDApIDogLUluZmluaXR5LFxuICAgICAgICAgICAgdDogdFxuICAgICAgICAgIH07XG4gICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYi5nIC0gYS5nIHx8IC1JbmZpbml0eTtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAobykge1xuICAgICAgICAgIHJldHVybiBvLnQucmV2ZXJ0KHJldmVydCk7XG4gICAgICAgIH0pOyAvLyBub3RlOiBhbGwgb2YgdGhlIF9zdGFydEF0IHR3ZWVucyBzaG91bGQgYmUgcmV2ZXJ0ZWQgaW4gcmV2ZXJzZSBvcmRlciB0aGF0IHRoZXkgd2VyZSBjcmVhdGVkLCBhbmQgdGhleSdsbCBhbGwgaGF2ZSB0aGUgc2FtZSBnbG9iYWxUaW1lICgtMSkgc28gdGhlIFwiIHx8IC0xXCIgaW4gdGhlIHNvcnQga2VlcHMgdGhlIG9yZGVyIHByb3Blcmx5LlxuXG4gICAgICAgIGkgPSBfdGhpczQuZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBsb29wIGJhY2t3YXJkcyBzbyB0aGF0LCBmb3IgZXhhbXBsZSwgU3BsaXRUZXh0cyB0aGF0IHdlcmUgY3JlYXRlZCBsYXRlciBvbiB0aGUgc2FtZSBlbGVtZW50IGdldCByZXZlcnRlZCBmaXJzdFxuICAgICAgICAgIHQgPSBfdGhpczQuZGF0YVtpXTtcblxuICAgICAgICAgIGlmICh0IGluc3RhbmNlb2YgVGltZWxpbmUpIHtcbiAgICAgICAgICAgIGlmICh0LmRhdGEgIT09IFwibmVzdGVkXCIpIHtcbiAgICAgICAgICAgICAgdC5zY3JvbGxUcmlnZ2VyICYmIHQuc2Nyb2xsVHJpZ2dlci5yZXZlcnQoKTtcbiAgICAgICAgICAgICAgdC5raWxsKCk7IC8vIGRvbid0IHJldmVydCgpIHRoZSB0aW1lbGluZSBiZWNhdXNlIHRoYXQncyBkdXBsaWNhdGluZyBlZmZvcnRzIHNpbmNlIHdlIGFscmVhZHkgcmV2ZXJ0ZWQgYWxsIHRoZSB0d2VlbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgISh0IGluc3RhbmNlb2YgVHdlZW4pICYmIHQucmV2ZXJ0ICYmIHQucmV2ZXJ0KHJldmVydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM0Ll9yLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICByZXR1cm4gZihyZXZlcnQsIF90aGlzNCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF90aGlzNC5pc1JldmVydGVkID0gdHJ1ZTtcbiAgICAgIH0pKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLmtpbGwgJiYgZS5raWxsKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICBpZiAobWF0Y2hNZWRpYSkge1xuICAgICAgdmFyIGkgPSBfbWVkaWEubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIC8vIHByZXZpb3VzbHksIHdlIGNoZWNrZWQgX21lZGlhLmluZGV4T2YodGhpcyksIGJ1dCBzb21lIGZyYW1ld29ya3MgbGlrZSBWdWUgZW5mb3JjZSBQcm94eSBvYmplY3RzIHRoYXQgbWFrZSBpdCBpbXBvc3NpYmxlIHRvIGdldCB0aGUgcHJvcGVyIHJlc3VsdCB0aGF0IHdheSwgc28gd2UgbXVzdCB1c2UgYSB1bmlxdWUgSUQgbnVtYmVyIGluc3RlYWQuXG4gICAgICAgIF9tZWRpYVtpXS5pZCA9PT0gdGhpcy5pZCAmJiBfbWVkaWEuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG81LnJldmVydCA9IGZ1bmN0aW9uIHJldmVydChjb25maWcpIHtcbiAgICB0aGlzLmtpbGwoY29uZmlnIHx8IHt9KTtcbiAgfTtcblxuICByZXR1cm4gQ29udGV4dDtcbn0oKTtcblxudmFyIE1hdGNoTWVkaWEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXRjaE1lZGlhKHNjb3BlKSB7XG4gICAgdGhpcy5jb250ZXh0cyA9IFtdO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICBfY29udGV4dCAmJiBfY29udGV4dC5kYXRhLnB1c2godGhpcyk7XG4gIH1cblxuICB2YXIgX3Byb3RvNiA9IE1hdGNoTWVkaWEucHJvdG90eXBlO1xuXG4gIF9wcm90bzYuYWRkID0gZnVuY3Rpb24gYWRkKGNvbmRpdGlvbnMsIGZ1bmMsIHNjb3BlKSB7XG4gICAgX2lzT2JqZWN0KGNvbmRpdGlvbnMpIHx8IChjb25kaXRpb25zID0ge1xuICAgICAgbWF0Y2hlczogY29uZGl0aW9uc1xuICAgIH0pO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQoMCwgc2NvcGUgfHwgdGhpcy5zY29wZSksXG4gICAgICAgIGNvbmQgPSBjb250ZXh0LmNvbmRpdGlvbnMgPSB7fSxcbiAgICAgICAgbXEsXG4gICAgICAgIHAsXG4gICAgICAgIGFjdGl2ZTtcbiAgICBfY29udGV4dCAmJiAhY29udGV4dC5zZWxlY3RvciAmJiAoY29udGV4dC5zZWxlY3RvciA9IF9jb250ZXh0LnNlbGVjdG9yKTsgLy8gaW4gY2FzZSBhIGNvbnRleHQgaXMgY3JlYXRlZCBpbnNpZGUgYSBjb250ZXh0LiBMaWtlIGEgZ3NhcC5tYXRjaE1lZGlhKCkgdGhhdCdzIGluc2lkZSBhIHNjb3BlZCBnc2FwLmNvbnRleHQoKVxuXG4gICAgdGhpcy5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICAgIGZ1bmMgPSBjb250ZXh0LmFkZChcIm9uTWF0Y2hcIiwgZnVuYyk7XG4gICAgY29udGV4dC5xdWVyaWVzID0gY29uZGl0aW9ucztcblxuICAgIGZvciAocCBpbiBjb25kaXRpb25zKSB7XG4gICAgICBpZiAocCA9PT0gXCJhbGxcIikge1xuICAgICAgICBhY3RpdmUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXEgPSBfd2luLm1hdGNoTWVkaWEoY29uZGl0aW9uc1twXSk7XG5cbiAgICAgICAgaWYgKG1xKSB7XG4gICAgICAgICAgX21lZGlhLmluZGV4T2YoY29udGV4dCkgPCAwICYmIF9tZWRpYS5wdXNoKGNvbnRleHQpO1xuICAgICAgICAgIChjb25kW3BdID0gbXEubWF0Y2hlcykgJiYgKGFjdGl2ZSA9IDEpO1xuICAgICAgICAgIG1xLmFkZExpc3RlbmVyID8gbXEuYWRkTGlzdGVuZXIoX29uTWVkaWFDaGFuZ2UpIDogbXEuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBfb25NZWRpYUNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhY3RpdmUgJiYgZnVuYyhjb250ZXh0LCBmdW5jdGlvbiAoZikge1xuICAgICAgcmV0dXJuIGNvbnRleHQuYWRkKG51bGwsIGYpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHJlZnJlc2goKSB7XG4gIC8vIFx0bGV0IHRpbWUgPSBfbGFzdE1lZGlhVGltZSxcbiAgLy8gXHRcdG1lZGlhID0gX21lZGlhO1xuICAvLyBcdF9sYXN0TWVkaWFUaW1lID0gLTE7XG4gIC8vIFx0X21lZGlhID0gdGhpcy5jb250ZXh0cztcbiAgLy8gXHRfb25NZWRpYUNoYW5nZSgpO1xuICAvLyBcdF9sYXN0TWVkaWFUaW1lID0gdGltZTtcbiAgLy8gXHRfbWVkaWEgPSBtZWRpYTtcbiAgLy8gfVxuICA7XG5cbiAgX3Byb3RvNi5yZXZlcnQgPSBmdW5jdGlvbiByZXZlcnQoY29uZmlnKSB7XG4gICAgdGhpcy5raWxsKGNvbmZpZyB8fCB7fSk7XG4gIH07XG5cbiAgX3Byb3RvNi5raWxsID0gZnVuY3Rpb24ga2lsbChyZXZlcnQpIHtcbiAgICB0aGlzLmNvbnRleHRzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjLmtpbGwocmV2ZXJ0LCB0cnVlKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gTWF0Y2hNZWRpYTtcbn0oKTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogR1NBUFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbnZhciBfZ3NhcCA9IHtcbiAgcmVnaXN0ZXJQbHVnaW46IGZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICByZXR1cm4gX2NyZWF0ZVBsdWdpbihjb25maWcpO1xuICAgIH0pO1xuICB9LFxuICB0aW1lbGluZTogZnVuY3Rpb24gdGltZWxpbmUodmFycykge1xuICAgIHJldHVybiBuZXcgVGltZWxpbmUodmFycyk7XG4gIH0sXG4gIGdldFR3ZWVuc09mOiBmdW5jdGlvbiBnZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKTtcbiAgfSxcbiAgZ2V0UHJvcGVydHk6IGZ1bmN0aW9uIGdldFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpIHtcbiAgICBfaXNTdHJpbmcodGFyZ2V0KSAmJiAodGFyZ2V0ID0gdG9BcnJheSh0YXJnZXQpWzBdKTsgLy9pbiBjYXNlIHNlbGVjdG9yIHRleHQgb3IgYW4gYXJyYXkgaXMgcGFzc2VkIGluXG5cbiAgICB2YXIgZ2V0dGVyID0gX2dldENhY2hlKHRhcmdldCB8fCB7fSkuZ2V0LFxuICAgICAgICBmb3JtYXQgPSB1bml0ID8gX3Bhc3NUaHJvdWdoIDogX251bWVyaWNJZlBvc3NpYmxlO1xuXG4gICAgdW5pdCA9PT0gXCJuYXRpdmVcIiAmJiAodW5pdCA9IFwiXCIpO1xuICAgIHJldHVybiAhdGFyZ2V0ID8gdGFyZ2V0IDogIXByb3BlcnR5ID8gZnVuY3Rpb24gKHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSB7XG4gICAgICByZXR1cm4gZm9ybWF0KChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgX3BsdWdpbnNbcHJvcGVydHldLmdldCB8fCBnZXR0ZXIpKHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpKTtcbiAgICB9IDogZm9ybWF0KChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgX3BsdWdpbnNbcHJvcGVydHldLmdldCB8fCBnZXR0ZXIpKHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpKTtcbiAgfSxcbiAgcXVpY2tTZXR0ZXI6IGZ1bmN0aW9uIHF1aWNrU2V0dGVyKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHtcbiAgICB0YXJnZXQgPSB0b0FycmF5KHRhcmdldCk7XG5cbiAgICBpZiAodGFyZ2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBzZXR0ZXJzID0gdGFyZ2V0Lm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gZ3NhcC5xdWlja1NldHRlcih0LCBwcm9wZXJ0eSwgdW5pdCk7XG4gICAgICB9KSxcbiAgICAgICAgICBsID0gc2V0dGVycy5sZW5ndGg7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpID0gbDtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgc2V0dGVyc1tpXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gdGFyZ2V0WzBdIHx8IHt9O1xuXG4gICAgdmFyIFBsdWdpbiA9IF9wbHVnaW5zW3Byb3BlcnR5XSxcbiAgICAgICAgY2FjaGUgPSBfZ2V0Q2FjaGUodGFyZ2V0KSxcbiAgICAgICAgcCA9IGNhY2hlLmhhcm5lc3MgJiYgKGNhY2hlLmhhcm5lc3MuYWxpYXNlcyB8fCB7fSlbcHJvcGVydHldIHx8IHByb3BlcnR5LFxuICAgICAgICAvLyBpbiBjYXNlIGl0J3MgYW4gYWxpYXMsIGxpa2UgXCJyb3RhdGVcIiBmb3IgXCJyb3RhdGlvblwiLlxuICAgIHNldHRlciA9IFBsdWdpbiA/IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIHAgPSBuZXcgUGx1Z2luKCk7XG4gICAgICBfcXVpY2tUd2Vlbi5fcHQgPSAwO1xuICAgICAgcC5pbml0KHRhcmdldCwgdW5pdCA/IHZhbHVlICsgdW5pdCA6IHZhbHVlLCBfcXVpY2tUd2VlbiwgMCwgW3RhcmdldF0pO1xuICAgICAgcC5yZW5kZXIoMSwgcCk7XG4gICAgICBfcXVpY2tUd2Vlbi5fcHQgJiYgX3JlbmRlclByb3BUd2VlbnMoMSwgX3F1aWNrVHdlZW4pO1xuICAgIH0gOiBjYWNoZS5zZXQodGFyZ2V0LCBwKTtcblxuICAgIHJldHVybiBQbHVnaW4gPyBzZXR0ZXIgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBzZXR0ZXIodGFyZ2V0LCBwLCB1bml0ID8gdmFsdWUgKyB1bml0IDogdmFsdWUsIGNhY2hlLCAxKTtcbiAgICB9O1xuICB9LFxuICBxdWlja1RvOiBmdW5jdGlvbiBxdWlja1RvKHRhcmdldCwgcHJvcGVydHksIHZhcnMpIHtcbiAgICB2YXIgX21lcmdlMjtcblxuICAgIHZhciB0d2VlbiA9IGdzYXAudG8odGFyZ2V0LCBfbWVyZ2UoKF9tZXJnZTIgPSB7fSwgX21lcmdlMltwcm9wZXJ0eV0gPSBcIis9MC4xXCIsIF9tZXJnZTIucGF1c2VkID0gdHJ1ZSwgX21lcmdlMiksIHZhcnMgfHwge30pKSxcbiAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIGZ1bmModmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUpIHtcbiAgICAgIHJldHVybiB0d2Vlbi5yZXNldFRvKHByb3BlcnR5LCB2YWx1ZSwgc3RhcnQsIHN0YXJ0SXNSZWxhdGl2ZSk7XG4gICAgfTtcblxuICAgIGZ1bmMudHdlZW4gPSB0d2VlbjtcbiAgICByZXR1cm4gZnVuYztcbiAgfSxcbiAgaXNUd2VlbmluZzogZnVuY3Rpb24gaXNUd2VlbmluZyh0YXJnZXRzKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRUd2VlbnNPZih0YXJnZXRzLCB0cnVlKS5sZW5ndGggPiAwO1xuICB9LFxuICBkZWZhdWx0czogZnVuY3Rpb24gZGVmYXVsdHModmFsdWUpIHtcbiAgICB2YWx1ZSAmJiB2YWx1ZS5lYXNlICYmICh2YWx1ZS5lYXNlID0gX3BhcnNlRWFzZSh2YWx1ZS5lYXNlLCBfZGVmYXVsdHMuZWFzZSkpO1xuICAgIHJldHVybiBfbWVyZ2VEZWVwKF9kZWZhdWx0cywgdmFsdWUgfHwge30pO1xuICB9LFxuICBjb25maWc6IGZ1bmN0aW9uIGNvbmZpZyh2YWx1ZSkge1xuICAgIHJldHVybiBfbWVyZ2VEZWVwKF9jb25maWcsIHZhbHVlIHx8IHt9KTtcbiAgfSxcbiAgcmVnaXN0ZXJFZmZlY3Q6IGZ1bmN0aW9uIHJlZ2lzdGVyRWZmZWN0KF9yZWYzKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lLFxuICAgICAgICBlZmZlY3QgPSBfcmVmMy5lZmZlY3QsXG4gICAgICAgIHBsdWdpbnMgPSBfcmVmMy5wbHVnaW5zLFxuICAgICAgICBkZWZhdWx0cyA9IF9yZWYzLmRlZmF1bHRzLFxuICAgICAgICBleHRlbmRUaW1lbGluZSA9IF9yZWYzLmV4dGVuZFRpbWVsaW5lO1xuICAgIChwbHVnaW5zIHx8IFwiXCIpLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW5OYW1lKSB7XG4gICAgICByZXR1cm4gcGx1Z2luTmFtZSAmJiAhX3BsdWdpbnNbcGx1Z2luTmFtZV0gJiYgIV9nbG9iYWxzW3BsdWdpbk5hbWVdICYmIF93YXJuKG5hbWUgKyBcIiBlZmZlY3QgcmVxdWlyZXMgXCIgKyBwbHVnaW5OYW1lICsgXCIgcGx1Z2luLlwiKTtcbiAgICB9KTtcblxuICAgIF9lZmZlY3RzW25hbWVdID0gZnVuY3Rpb24gKHRhcmdldHMsIHZhcnMsIHRsKSB7XG4gICAgICByZXR1cm4gZWZmZWN0KHRvQXJyYXkodGFyZ2V0cyksIF9zZXREZWZhdWx0cyh2YXJzIHx8IHt9LCBkZWZhdWx0cyksIHRsKTtcbiAgICB9O1xuXG4gICAgaWYgKGV4dGVuZFRpbWVsaW5lKSB7XG4gICAgICBUaW1lbGluZS5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAodGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKF9lZmZlY3RzW25hbWVdKHRhcmdldHMsIF9pc09iamVjdCh2YXJzKSA/IHZhcnMgOiAocG9zaXRpb24gPSB2YXJzKSAmJiB7fSwgdGhpcyksIHBvc2l0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICByZWdpc3RlckVhc2U6IGZ1bmN0aW9uIHJlZ2lzdGVyRWFzZShuYW1lLCBlYXNlKSB7XG4gICAgX2Vhc2VNYXBbbmFtZV0gPSBfcGFyc2VFYXNlKGVhc2UpO1xuICB9LFxuICBwYXJzZUVhc2U6IGZ1bmN0aW9uIHBhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gX3BhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkgOiBfZWFzZU1hcDtcbiAgfSxcbiAgZ2V0QnlJZDogZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0QnlJZChpZCk7XG4gIH0sXG4gIGV4cG9ydFJvb3Q6IGZ1bmN0aW9uIGV4cG9ydFJvb3QodmFycywgaW5jbHVkZURlbGF5ZWRDYWxscykge1xuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgIHZhcnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgdGwgPSBuZXcgVGltZWxpbmUodmFycyksXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBuZXh0O1xuICAgIHRsLnNtb290aENoaWxkVGltaW5nID0gX2lzTm90RmFsc2UodmFycy5zbW9vdGhDaGlsZFRpbWluZyk7XG5cbiAgICBfZ2xvYmFsVGltZWxpbmUucmVtb3ZlKHRsKTtcblxuICAgIHRsLl9kcCA9IDA7IC8vb3RoZXJ3aXNlIGl0J2xsIGdldCByZS1hY3RpdmF0ZWQgd2hlbiBhZGRpbmcgY2hpbGRyZW4gYW5kIGJlIHJlLWludHJvZHVjZWQgaW50byBfZ2xvYmFsVGltZWxpbmUncyBsaW5rZWQgbGlzdCAodGhlbiBhZGRlZCB0byBpdHNlbGYpLlxuXG4gICAgdGwuX3RpbWUgPSB0bC5fdFRpbWUgPSBfZ2xvYmFsVGltZWxpbmUuX3RpbWU7XG4gICAgY2hpbGQgPSBfZ2xvYmFsVGltZWxpbmUuX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG5cbiAgICAgIGlmIChpbmNsdWRlRGVsYXllZENhbGxzIHx8ICEoIWNoaWxkLl9kdXIgJiYgY2hpbGQgaW5zdGFuY2VvZiBUd2VlbiAmJiBjaGlsZC52YXJzLm9uQ29tcGxldGUgPT09IGNoaWxkLl90YXJnZXRzWzBdKSkge1xuICAgICAgICBfYWRkVG9UaW1lbGluZSh0bCwgY2hpbGQsIGNoaWxkLl9zdGFydCAtIGNoaWxkLl9kZWxheSk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gbmV4dDtcbiAgICB9XG5cbiAgICBfYWRkVG9UaW1lbGluZShfZ2xvYmFsVGltZWxpbmUsIHRsLCAwKTtcblxuICAgIHJldHVybiB0bDtcbiAgfSxcbiAgY29udGV4dDogZnVuY3Rpb24gY29udGV4dChmdW5jLCBzY29wZSkge1xuICAgIHJldHVybiBmdW5jID8gbmV3IENvbnRleHQoZnVuYywgc2NvcGUpIDogX2NvbnRleHQ7XG4gIH0sXG4gIG1hdGNoTWVkaWE6IGZ1bmN0aW9uIG1hdGNoTWVkaWEoc2NvcGUpIHtcbiAgICByZXR1cm4gbmV3IE1hdGNoTWVkaWEoc2NvcGUpO1xuICB9LFxuICBtYXRjaE1lZGlhUmVmcmVzaDogZnVuY3Rpb24gbWF0Y2hNZWRpYVJlZnJlc2goKSB7XG4gICAgcmV0dXJuIF9tZWRpYS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICB2YXIgY29uZCA9IGMuY29uZGl0aW9ucyxcbiAgICAgICAgICBmb3VuZCxcbiAgICAgICAgICBwO1xuXG4gICAgICBmb3IgKHAgaW4gY29uZCkge1xuICAgICAgICBpZiAoY29uZFtwXSkge1xuICAgICAgICAgIGNvbmRbcF0gPSBmYWxzZTtcbiAgICAgICAgICBmb3VuZCA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm91bmQgJiYgYy5yZXZlcnQoKTtcbiAgICB9KSB8fCBfb25NZWRpYUNoYW5nZSgpO1xuICB9LFxuICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGEgPSBfbGlzdGVuZXJzW3R5cGVdIHx8IChfbGlzdGVuZXJzW3R5cGVdID0gW10pO1xuICAgIH5hLmluZGV4T2YoY2FsbGJhY2spIHx8IGEucHVzaChjYWxsYmFjayk7XG4gIH0sXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgYSA9IF9saXN0ZW5lcnNbdHlwZV0sXG4gICAgICAgIGkgPSBhICYmIGEuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgaSA+PSAwICYmIGEuc3BsaWNlKGksIDEpO1xuICB9LFxuICB1dGlsczoge1xuICAgIHdyYXA6IHdyYXAsXG4gICAgd3JhcFlveW86IHdyYXBZb3lvLFxuICAgIGRpc3RyaWJ1dGU6IGRpc3RyaWJ1dGUsXG4gICAgcmFuZG9tOiByYW5kb20sXG4gICAgc25hcDogc25hcCxcbiAgICBub3JtYWxpemU6IG5vcm1hbGl6ZSxcbiAgICBnZXRVbml0OiBnZXRVbml0LFxuICAgIGNsYW1wOiBjbGFtcCxcbiAgICBzcGxpdENvbG9yOiBzcGxpdENvbG9yLFxuICAgIHRvQXJyYXk6IHRvQXJyYXksXG4gICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgIG1hcFJhbmdlOiBtYXBSYW5nZSxcbiAgICBwaXBlOiBwaXBlLFxuICAgIHVuaXRpemU6IHVuaXRpemUsXG4gICAgaW50ZXJwb2xhdGU6IGludGVycG9sYXRlLFxuICAgIHNodWZmbGU6IHNodWZmbGVcbiAgfSxcbiAgaW5zdGFsbDogX2luc3RhbGwsXG4gIGVmZmVjdHM6IF9lZmZlY3RzLFxuICB0aWNrZXI6IF90aWNrZXIsXG4gIHVwZGF0ZVJvb3Q6IFRpbWVsaW5lLnVwZGF0ZVJvb3QsXG4gIHBsdWdpbnM6IF9wbHVnaW5zLFxuICBnbG9iYWxUaW1lbGluZTogX2dsb2JhbFRpbWVsaW5lLFxuICBjb3JlOiB7XG4gICAgUHJvcFR3ZWVuOiBQcm9wVHdlZW4sXG4gICAgZ2xvYmFsczogX2FkZEdsb2JhbCxcbiAgICBUd2VlbjogVHdlZW4sXG4gICAgVGltZWxpbmU6IFRpbWVsaW5lLFxuICAgIEFuaW1hdGlvbjogQW5pbWF0aW9uLFxuICAgIGdldENhY2hlOiBfZ2V0Q2FjaGUsXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtOiBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0sXG4gICAgcmV2ZXJ0aW5nOiBmdW5jdGlvbiByZXZlcnRpbmcoKSB7XG4gICAgICByZXR1cm4gX3JldmVydGluZztcbiAgICB9LFxuICAgIGNvbnRleHQ6IGZ1bmN0aW9uIGNvbnRleHQodG9BZGQpIHtcbiAgICAgIGlmICh0b0FkZCAmJiBfY29udGV4dCkge1xuICAgICAgICBfY29udGV4dC5kYXRhLnB1c2godG9BZGQpO1xuXG4gICAgICAgIHRvQWRkLl9jdHggPSBfY29udGV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9jb250ZXh0O1xuICAgIH0sXG4gICAgc3VwcHJlc3NPdmVyd3JpdGVzOiBmdW5jdGlvbiBzdXBwcmVzc092ZXJ3cml0ZXModmFsdWUpIHtcbiAgICAgIHJldHVybiBfc3VwcHJlc3NPdmVyd3JpdGVzID0gdmFsdWU7XG4gICAgfVxuICB9XG59O1xuXG5fZm9yRWFjaE5hbWUoXCJ0byxmcm9tLGZyb21UbyxkZWxheWVkQ2FsbCxzZXQsa2lsbFR3ZWVuc09mXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfZ3NhcFtuYW1lXSA9IFR3ZWVuW25hbWVdO1xufSk7XG5cbl90aWNrZXIuYWRkKFRpbWVsaW5lLnVwZGF0ZVJvb3QpO1xuXG5fcXVpY2tUd2VlbiA9IF9nc2FwLnRvKHt9LCB7XG4gIGR1cmF0aW9uOiAwXG59KTsgLy8gLS0tLSBFWFRSQSBQTFVHSU5TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBfZ2V0UGx1Z2luUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2dldFBsdWdpblByb3BUd2VlbihwbHVnaW4sIHByb3ApIHtcbiAgdmFyIHB0ID0gcGx1Z2luLl9wdDtcblxuICB3aGlsZSAocHQgJiYgcHQucCAhPT0gcHJvcCAmJiBwdC5vcCAhPT0gcHJvcCAmJiBwdC5mcCAhPT0gcHJvcCkge1xuICAgIHB0ID0gcHQuX25leHQ7XG4gIH1cblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9hZGRNb2RpZmllcnMgPSBmdW5jdGlvbiBfYWRkTW9kaWZpZXJzKHR3ZWVuLCBtb2RpZmllcnMpIHtcbiAgdmFyIHRhcmdldHMgPSB0d2Vlbi5fdGFyZ2V0cyxcbiAgICAgIHAsXG4gICAgICBpLFxuICAgICAgcHQ7XG5cbiAgZm9yIChwIGluIG1vZGlmaWVycykge1xuICAgIGkgPSB0YXJnZXRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHB0ID0gdHdlZW4uX3B0TG9va3VwW2ldW3BdO1xuXG4gICAgICBpZiAocHQgJiYgKHB0ID0gcHQuZCkpIHtcbiAgICAgICAgaWYgKHB0Ll9wdCkge1xuICAgICAgICAgIC8vIGlzIGEgcGx1Z2luXG4gICAgICAgICAgcHQgPSBfZ2V0UGx1Z2luUHJvcFR3ZWVuKHB0LCBwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB0ICYmIHB0Lm1vZGlmaWVyICYmIHB0Lm1vZGlmaWVyKG1vZGlmaWVyc1twXSwgdHdlZW4sIHRhcmdldHNbaV0sIHApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSxcbiAgICBfYnVpbGRNb2RpZmllclBsdWdpbiA9IGZ1bmN0aW9uIF9idWlsZE1vZGlmaWVyUGx1Z2luKG5hbWUsIG1vZGlmaWVyKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICByYXdWYXJzOiAxLFxuICAgIC8vZG9uJ3QgcHJlLXByb2Nlc3MgZnVuY3Rpb24tYmFzZWQgdmFsdWVzIG9yIFwicmFuZG9tKClcIiBzdHJpbmdzLlxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YXJzLCB0d2Vlbikge1xuICAgICAgdHdlZW4uX29uSW5pdCA9IGZ1bmN0aW9uICh0d2Vlbikge1xuICAgICAgICB2YXIgdGVtcCwgcDtcblxuICAgICAgICBpZiAoX2lzU3RyaW5nKHZhcnMpKSB7XG4gICAgICAgICAgdGVtcCA9IHt9O1xuXG4gICAgICAgICAgX2ZvckVhY2hOYW1lKHZhcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVtcFtuYW1lXSA9IDE7XG4gICAgICAgICAgfSk7IC8vaWYgdGhlIHVzZXIgcGFzc2VzIGluIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMgdG8gcm91bmRQcm9wcywgbGlrZSBcIngseVwiLCB3ZSByb3VuZCB0byB3aG9sZSBudW1iZXJzLlxuXG5cbiAgICAgICAgICB2YXJzID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RpZmllcikge1xuICAgICAgICAgIHRlbXAgPSB7fTtcblxuICAgICAgICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICAgICAgICB0ZW1wW3BdID0gbW9kaWZpZXIodmFyc1twXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFycyA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICBfYWRkTW9kaWZpZXJzKHR3ZWVuLCB2YXJzKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xufTsgLy9yZWdpc3RlciBjb3JlIHBsdWdpbnNcblxuXG5leHBvcnQgdmFyIGdzYXAgPSBfZ3NhcC5yZWdpc3RlclBsdWdpbih7XG4gIG5hbWU6IFwiYXR0clwiLFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgdmFyIHAsIHB0LCB2O1xuICAgIHRoaXMudHdlZW4gPSB0d2VlbjtcblxuICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICB2ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShwKSB8fCBcIlwiO1xuICAgICAgcHQgPSB0aGlzLmFkZCh0YXJnZXQsIFwic2V0QXR0cmlidXRlXCIsICh2IHx8IDApICsgXCJcIiwgdmFyc1twXSwgaW5kZXgsIHRhcmdldHMsIDAsIDAsIHApO1xuICAgICAgcHQub3AgPSBwO1xuICAgICAgcHQuYiA9IHY7IC8vIHJlY29yZCB0aGUgYmVnaW5uaW5nIHZhbHVlIHNvIHdlIGNhbiByZXZlcnQoKVxuXG4gICAgICB0aGlzLl9wcm9wcy5wdXNoKHApO1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocmF0aW8sIGRhdGEpIHtcbiAgICB2YXIgcHQgPSBkYXRhLl9wdDtcblxuICAgIHdoaWxlIChwdCkge1xuICAgICAgX3JldmVydGluZyA/IHB0LnNldChwdC50LCBwdC5wLCBwdC5iLCBwdCkgOiBwdC5yKHJhdGlvLCBwdC5kKTsgLy8gaWYgcmV2ZXJ0aW5nLCBnbyBiYWNrIHRvIHRoZSBvcmlnaW5hbCAocHQuYilcblxuICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICB9XG4gIH1cbn0sIHtcbiAgbmFtZTogXCJlbmRBcnJheVwiLFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFsdWUpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuYWRkKHRhcmdldCwgaSwgdGFyZ2V0W2ldIHx8IDAsIHZhbHVlW2ldLCAwLCAwLCAwLCAwLCAwLCAxKTtcbiAgICB9XG4gIH1cbn0sIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwicm91bmRQcm9wc1wiLCBfcm91bmRNb2RpZmllciksIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwibW9kaWZpZXJzXCIpLCBfYnVpbGRNb2RpZmllclBsdWdpbihcInNuYXBcIiwgc25hcCkpIHx8IF9nc2FwOyAvL3RvIHByZXZlbnQgdGhlIGNvcmUgcGx1Z2lucyBmcm9tIGJlaW5nIGRyb3BwZWQgdmlhIGFnZ3Jlc3NpdmUgdHJlZSBzaGFraW5nLCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGUgdmFyaWFibGUgZGVjbGFyYXRpb24gaW4gdGhpcyB3YXkuXG5cblR3ZWVuLnZlcnNpb24gPSBUaW1lbGluZS52ZXJzaW9uID0gZ3NhcC52ZXJzaW9uID0gXCIzLjEyLjVcIjtcbl9jb3JlUmVhZHkgPSAxO1xuX3dpbmRvd0V4aXN0cygpICYmIF93YWtlKCk7XG52YXIgUG93ZXIwID0gX2Vhc2VNYXAuUG93ZXIwLFxuICAgIFBvd2VyMSA9IF9lYXNlTWFwLlBvd2VyMSxcbiAgICBQb3dlcjIgPSBfZWFzZU1hcC5Qb3dlcjIsXG4gICAgUG93ZXIzID0gX2Vhc2VNYXAuUG93ZXIzLFxuICAgIFBvd2VyNCA9IF9lYXNlTWFwLlBvd2VyNCxcbiAgICBMaW5lYXIgPSBfZWFzZU1hcC5MaW5lYXIsXG4gICAgUXVhZCA9IF9lYXNlTWFwLlF1YWQsXG4gICAgQ3ViaWMgPSBfZWFzZU1hcC5DdWJpYyxcbiAgICBRdWFydCA9IF9lYXNlTWFwLlF1YXJ0LFxuICAgIFF1aW50ID0gX2Vhc2VNYXAuUXVpbnQsXG4gICAgU3Ryb25nID0gX2Vhc2VNYXAuU3Ryb25nLFxuICAgIEVsYXN0aWMgPSBfZWFzZU1hcC5FbGFzdGljLFxuICAgIEJhY2sgPSBfZWFzZU1hcC5CYWNrLFxuICAgIFN0ZXBwZWRFYXNlID0gX2Vhc2VNYXAuU3RlcHBlZEVhc2UsXG4gICAgQm91bmNlID0gX2Vhc2VNYXAuQm91bmNlLFxuICAgIFNpbmUgPSBfZWFzZU1hcC5TaW5lLFxuICAgIEV4cG8gPSBfZWFzZU1hcC5FeHBvLFxuICAgIENpcmMgPSBfZWFzZU1hcC5DaXJjO1xuZXhwb3J0IHsgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjIH07XG5leHBvcnQgeyBUd2VlbiBhcyBUd2Vlbk1heCwgVHdlZW4gYXMgVHdlZW5MaXRlLCBUaW1lbGluZSBhcyBUaW1lbGluZU1heCwgVGltZWxpbmUgYXMgVGltZWxpbmVMaXRlLCBnc2FwIGFzIGRlZmF1bHQsIHdyYXAsIHdyYXBZb3lvLCBkaXN0cmlidXRlLCByYW5kb20sIHNuYXAsIG5vcm1hbGl6ZSwgZ2V0VW5pdCwgY2xhbXAsIHNwbGl0Q29sb3IsIHRvQXJyYXksIHNlbGVjdG9yLCBtYXBSYW5nZSwgcGlwZSwgdW5pdGl6ZSwgaW50ZXJwb2xhdGUsIHNodWZmbGUgfTsgLy9leHBvcnQgc29tZSBpbnRlcm5hbCBtZXRob2RzL29yb2plY3RzIGZvciB1c2UgaW4gQ1NTUGx1Z2luIHNvIHRoYXQgd2UgY2FuIGV4dGVybmFsaXplIHRoYXQgZmlsZSBhbmQgYWxsb3cgY3VzdG9tIGJ1aWxkcyB0aGF0IGV4Y2x1ZGUgaXQuXG5cbmV4cG9ydCB7IF9nZXRQcm9wZXJ0eSwgX251bUV4cCwgX251bVdpdGhVbml0RXhwLCBfaXNTdHJpbmcsIF9pc1VuZGVmaW5lZCwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIF9yZWxFeHAsIF9zZXREZWZhdWx0cywgX3JlbW92ZUxpbmtlZExpc3RJdGVtLCBfZm9yRWFjaE5hbWUsIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHksIF9jb2xvclN0cmluZ0ZpbHRlciwgX3JlcGxhY2VSYW5kb20sIF9jaGVja1BsdWdpbiwgX3BsdWdpbnMsIF90aWNrZXIsIF9jb25maWcsIF9yb3VuZE1vZGlmaWVyLCBfcm91bmQsIF9taXNzaW5nUGx1Z2luLCBfZ2V0U2V0dGVyLCBfZ2V0Q2FjaGUsIF9jb2xvckV4cCwgX3BhcnNlUmVsYXRpdmUgfTsiXSwibmFtZXMiOlsiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIl9pbmhlcml0c0xvb3NlIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJfX3Byb3RvX18iLCJfY29uZmlnIiwiYXV0b1NsZWVwIiwiZm9yY2UzRCIsIm51bGxUYXJnZXRXYXJuIiwidW5pdHMiLCJsaW5lSGVpZ2h0IiwiX2RlZmF1bHRzIiwiZHVyYXRpb24iLCJvdmVyd3JpdGUiLCJkZWxheSIsIl9zdXBwcmVzc092ZXJ3cml0ZXMiLCJfcmV2ZXJ0aW5nIiwiX2NvbnRleHQiLCJfYmlnTnVtIiwiX3RpbnlOdW0iLCJfMlBJIiwiTWF0aCIsIlBJIiwiX0hBTEZfUEkiLCJfZ3NJRCIsIl9zcXJ0Iiwic3FydCIsIl9jb3MiLCJjb3MiLCJfc2luIiwic2luIiwiX2lzU3RyaW5nIiwidmFsdWUiLCJfaXNGdW5jdGlvbiIsIl9pc051bWJlciIsIl9pc1VuZGVmaW5lZCIsIl9pc09iamVjdCIsIl9pc05vdEZhbHNlIiwiX3dpbmRvd0V4aXN0cyIsIndpbmRvdyIsIl9pc0Z1bmNPclN0cmluZyIsIl9pc1R5cGVkQXJyYXkiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsIl9pc0FycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiX3N0cmljdE51bUV4cCIsIl9udW1FeHAiLCJfbnVtV2l0aFVuaXRFeHAiLCJfY29tcGxleFN0cmluZ051bUV4cCIsIl9yZWxFeHAiLCJfZGVsaW1pdGVkVmFsdWVFeHAiLCJfdW5pdEV4cCIsIl9nbG9iYWxUaW1lbGluZSIsIl93aW4iLCJfY29yZUluaXR0ZWQiLCJfZG9jIiwiX2dsb2JhbHMiLCJfaW5zdGFsbFNjb3BlIiwiX2NvcmVSZWFkeSIsIl9pbnN0YWxsIiwic2NvcGUiLCJfbWVyZ2UiLCJnc2FwIiwiX21pc3NpbmdQbHVnaW4iLCJwcm9wZXJ0eSIsImNvbnNvbGUiLCJ3YXJuIiwiX3dhcm4iLCJtZXNzYWdlIiwic3VwcHJlc3MiLCJfYWRkR2xvYmFsIiwibmFtZSIsIm9iaiIsIl9lbXB0eUZ1bmMiLCJfc3RhcnRBdFJldmVydENvbmZpZyIsInN1cHByZXNzRXZlbnRzIiwiaXNTdGFydCIsImtpbGwiLCJfcmV2ZXJ0Q29uZmlnTm9LaWxsIiwiX3JldmVydENvbmZpZyIsIl9yZXNlcnZlZFByb3BzIiwiX2xhenlUd2VlbnMiLCJfbGF6eUxvb2t1cCIsIl9sYXN0UmVuZGVyZWRGcmFtZSIsIl9wbHVnaW5zIiwiX2VmZmVjdHMiLCJfbmV4dEdDRnJhbWUiLCJfaGFybmVzc1BsdWdpbnMiLCJfY2FsbGJhY2tOYW1lcyIsIl9oYXJuZXNzIiwidGFyZ2V0cyIsInRhcmdldCIsImhhcm5lc3NQbHVnaW4iLCJpIiwiX2dzYXAiLCJoYXJuZXNzIiwibGVuZ3RoIiwidGFyZ2V0VGVzdCIsIkdTQ2FjaGUiLCJzcGxpY2UiLCJfZ2V0Q2FjaGUiLCJ0b0FycmF5IiwiX2dldFByb3BlcnR5IiwidiIsImdldEF0dHJpYnV0ZSIsIl9mb3JFYWNoTmFtZSIsIm5hbWVzIiwiZnVuYyIsInNwbGl0IiwiZm9yRWFjaCIsIl9yb3VuZCIsInJvdW5kIiwiX3JvdW5kUHJlY2lzZSIsIl9wYXJzZVJlbGF0aXZlIiwic3RhcnQiLCJvcGVyYXRvciIsImNoYXJBdCIsImVuZCIsInBhcnNlRmxvYXQiLCJzdWJzdHIiLCJfYXJyYXlDb250YWluc0FueSIsInRvU2VhcmNoIiwidG9GaW5kIiwibCIsImluZGV4T2YiLCJfbGF6eVJlbmRlciIsImEiLCJzbGljZSIsInR3ZWVuIiwiX2xhenkiLCJyZW5kZXIiLCJfbGF6eVNhZmVSZW5kZXIiLCJhbmltYXRpb24iLCJ0aW1lIiwiZm9yY2UiLCJfaW5pdHRlZCIsIl9zdGFydEF0IiwiX251bWVyaWNJZlBvc3NpYmxlIiwibiIsIm1hdGNoIiwidHJpbSIsIl9wYXNzVGhyb3VnaCIsInAiLCJfc2V0RGVmYXVsdHMiLCJkZWZhdWx0cyIsIl9zZXRLZXlmcmFtZURlZmF1bHRzIiwiZXhjbHVkZUR1cmF0aW9uIiwiYmFzZSIsInRvTWVyZ2UiLCJfbWVyZ2VEZWVwIiwiX2NvcHlFeGNsdWRpbmciLCJleGNsdWRpbmciLCJjb3B5IiwiX2luaGVyaXREZWZhdWx0cyIsInZhcnMiLCJwYXJlbnQiLCJrZXlmcmFtZXMiLCJpbmhlcml0IiwiX2RwIiwiX2FycmF5c01hdGNoIiwiYTEiLCJhMiIsIl9hZGRMaW5rZWRMaXN0SXRlbSIsImNoaWxkIiwiZmlyc3RQcm9wIiwibGFzdFByb3AiLCJzb3J0QnkiLCJwcmV2IiwidCIsIl9wcmV2IiwiX25leHQiLCJfcmVtb3ZlTGlua2VkTGlzdEl0ZW0iLCJuZXh0IiwiX3JlbW92ZUZyb21QYXJlbnQiLCJvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlIiwiYXV0b1JlbW92ZUNoaWxkcmVuIiwicmVtb3ZlIiwiX2FjdCIsIl91bmNhY2hlIiwiX2VuZCIsIl9kdXIiLCJfc3RhcnQiLCJfZGlydHkiLCJfcmVjYWNoZUFuY2VzdG9ycyIsInRvdGFsRHVyYXRpb24iLCJfcmV3aW5kU3RhcnRBdCIsInRvdGFsVGltZSIsInJldmVydCIsImltbWVkaWF0ZVJlbmRlciIsImF1dG9SZXZlcnQiLCJfaGFzTm9QYXVzZWRBbmNlc3RvcnMiLCJfdHMiLCJfZWxhcHNlZEN5Y2xlRHVyYXRpb24iLCJfcmVwZWF0IiwiX2FuaW1hdGlvbkN5Y2xlIiwiX3RUaW1lIiwiX3JEZWxheSIsInRUaW1lIiwiY3ljbGVEdXJhdGlvbiIsIndob2xlIiwiZmxvb3IiLCJfcGFyZW50VG9DaGlsZFRvdGFsVGltZSIsInBhcmVudFRpbWUiLCJfdER1ciIsIl9zZXRFbmQiLCJhYnMiLCJfcnRzIiwiX2FsaWduUGxheWhlYWQiLCJzbW9vdGhDaGlsZFRpbWluZyIsIl90aW1lIiwiX3Bvc3RBZGRDaGVja3MiLCJ0aW1lbGluZSIsImFkZCIsInJhd1RpbWUiLCJfY2xhbXAiLCJfelRpbWUiLCJfYWRkVG9UaW1lbGluZSIsInBvc2l0aW9uIiwic2tpcENoZWNrcyIsIl9wYXJzZVBvc2l0aW9uIiwiX2RlbGF5IiwidGltZVNjYWxlIiwiX3NvcnQiLCJfaXNGcm9tT3JGcm9tU3RhcnQiLCJfcmVjZW50IiwiX3Njcm9sbFRyaWdnZXIiLCJ0cmlnZ2VyIiwiU2Nyb2xsVHJpZ2dlciIsIl9hdHRlbXB0SW5pdFR3ZWVuIiwiX2luaXRUd2VlbiIsIl9wdCIsImxhenkiLCJfdGlja2VyIiwiZnJhbWUiLCJwdXNoIiwiX3BhcmVudFBsYXloZWFkSXNCZWZvcmVTdGFydCIsIl9yZWYiLCJfbG9jayIsIl9yZWYyIiwiZGF0YSIsIl9yZW5kZXJaZXJvRHVyYXRpb25Ud2VlbiIsInByZXZSYXRpbyIsInJhdGlvIiwicmVwZWF0RGVsYXkiLCJwdCIsIml0ZXJhdGlvbiIsInByZXZJdGVyYXRpb24iLCJfeW95byIsInJlcGVhdFJlZnJlc2giLCJpbnZhbGlkYXRlIiwiX2Zyb20iLCJyIiwiZCIsIl9vblVwZGF0ZSIsIl9jYWxsYmFjayIsIl9wcm9tIiwiX2ZpbmROZXh0UGF1c2VUd2VlbiIsInByZXZUaW1lIiwiX2ZpcnN0IiwiX2xhc3QiLCJfc2V0RHVyYXRpb24iLCJza2lwVW5jYWNoZSIsImxlYXZlUGxheWhlYWQiLCJyZXBlYXQiLCJkdXIiLCJ0b3RhbFByb2dyZXNzIiwiX29uVXBkYXRlVG90YWxEdXJhdGlvbiIsIlRpbWVsaW5lIiwiX3plcm9Qb3NpdGlvbiIsImVuZFRpbWUiLCJwZXJjZW50QW5pbWF0aW9uIiwibGFiZWxzIiwicmVjZW50IiwiY2xpcHBlZER1cmF0aW9uIiwib2Zmc2V0IiwiaXNQZXJjZW50IiwiaXNOYU4iLCJyZXBsYWNlIiwiX2NyZWF0ZVR3ZWVuVHlwZSIsInR5cGUiLCJwYXJhbXMiLCJpc0xlZ2FjeSIsInZhcnNJbmRleCIsImlyVmFycyIsInJ1bkJhY2t3YXJkcyIsInN0YXJ0QXQiLCJUd2VlbiIsIl9jb25kaXRpb25hbFJldHVybiIsIm1pbiIsIm1heCIsImdldFVuaXQiLCJleGVjIiwiY2xhbXAiLCJfc2xpY2UiLCJfaXNBcnJheUxpa2UiLCJub25FbXB0eSIsIm5vZGVUeXBlIiwiX2ZsYXR0ZW4iLCJhciIsImxlYXZlU3RyaW5ncyIsImFjY3VtdWxhdG9yIiwiX2FjY3VtdWxhdG9yIiwiYXBwbHkiLCJzZWxlY3RvciIsIl93YWtlIiwiY2FsbCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJlbCIsImN1cnJlbnQiLCJuYXRpdmVFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsInNodWZmbGUiLCJzb3J0IiwicmFuZG9tIiwiZGlzdHJpYnV0ZSIsImVhY2giLCJlYXNlIiwiX3BhcnNlRWFzZSIsImZyb20iLCJjYWNoZSIsImlzRGVjaW1hbCIsInJhdGlvcyIsImF4aXMiLCJyYXRpb1giLCJyYXRpb1kiLCJjZW50ZXIiLCJlZGdlcyIsImRpc3RhbmNlcyIsIm9yaWdpblgiLCJvcmlnaW5ZIiwieCIsInkiLCJqIiwid3JhcEF0IiwiZ3JpZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImxlZnQiLCJhbW91bnQiLCJiIiwidSIsIl9pbnZlcnRFYXNlIiwiX3JvdW5kTW9kaWZpZXIiLCJwb3ciLCJyYXciLCJzbmFwIiwic25hcFRvIiwicmFkaXVzIiwiaXMyRCIsInZhbHVlcyIsImluY3JlbWVudCIsImNsb3Nlc3QiLCJkeCIsImR5Iiwicm91bmRpbmdJbmNyZW1lbnQiLCJyZXR1cm5GdW5jdGlvbiIsInBpcGUiLCJfbGVuIiwiYXJndW1lbnRzIiwiZnVuY3Rpb25zIiwiX2tleSIsInJlZHVjZSIsImYiLCJ1bml0aXplIiwidW5pdCIsIm5vcm1hbGl6ZSIsIm1hcFJhbmdlIiwiX3dyYXBBcnJheSIsIndyYXBwZXIiLCJpbmRleCIsIndyYXAiLCJyYW5nZSIsIndyYXBZb3lvIiwidG90YWwiLCJfcmVwbGFjZVJhbmRvbSIsInMiLCJudW1zIiwiaW5NaW4iLCJpbk1heCIsIm91dE1pbiIsIm91dE1heCIsImluUmFuZ2UiLCJvdXRSYW5nZSIsImludGVycG9sYXRlIiwicHJvZ3Jlc3MiLCJtdXRhdGUiLCJpc1N0cmluZyIsIm1hc3RlciIsImludGVycG9sYXRvcnMiLCJpbCIsIl9hZGRQcm9wVHdlZW4iLCJfcmVuZGVyUHJvcFR3ZWVucyIsIl9nZXRMYWJlbEluRGlyZWN0aW9uIiwiZnJvbVRpbWUiLCJiYWNrd2FyZCIsImRpc3RhbmNlIiwibGFiZWwiLCJleGVjdXRlTGF6eUZpcnN0IiwiY2FsbGJhY2siLCJwcmV2Q29udGV4dCIsImNvbnRleHQiLCJfY3R4IiwicmVzdWx0IiwiY2FsbGJhY2tTY29wZSIsIl9pbnRlcnJ1cHQiLCJzY3JvbGxUcmlnZ2VyIiwiX3F1aWNrVHdlZW4iLCJfcmVnaXN0ZXJQbHVnaW5RdWV1ZSIsIl9jcmVhdGVQbHVnaW4iLCJjb25maWciLCJoZWFkbGVzcyIsImlzRnVuYyIsIlBsdWdpbiIsImluaXQiLCJfcHJvcHMiLCJpbnN0YW5jZURlZmF1bHRzIiwiX2tpbGxQcm9wVHdlZW5zT2YiLCJtb2RpZmllciIsIl9hZGRQbHVnaW5Nb2RpZmllciIsInJhd1ZhcnMiLCJzdGF0aWNzIiwiZ2V0IiwiZ2V0U2V0dGVyIiwiX2dldFNldHRlciIsImFsaWFzZXMiLCJyZWdpc3RlciIsInByb3AiLCJ0b1VwcGVyQ2FzZSIsIlByb3BUd2VlbiIsIl8yNTUiLCJfY29sb3JMb29rdXAiLCJhcXVhIiwibGltZSIsInNpbHZlciIsImJsYWNrIiwibWFyb29uIiwidGVhbCIsImJsdWUiLCJuYXZ5Iiwid2hpdGUiLCJvbGl2ZSIsInllbGxvdyIsIm9yYW5nZSIsImdyYXkiLCJwdXJwbGUiLCJncmVlbiIsInJlZCIsInBpbmsiLCJjeWFuIiwidHJhbnNwYXJlbnQiLCJfaHVlIiwiaCIsIm0xIiwibTIiLCJzcGxpdENvbG9yIiwidG9IU0wiLCJmb3JjZUFscGhhIiwiZyIsIndhc0hTTCIsInBhcnNlSW50IiwibWFwIiwiTnVtYmVyIiwiX2NvbG9yT3JkZXJEYXRhIiwiYyIsIl9jb2xvckV4cCIsIl9mb3JtYXRDb2xvcnMiLCJvcmRlck1hdGNoRGF0YSIsImNvbG9ycyIsInNoZWxsIiwiY29sb3IiLCJqb2luIiwic2hpZnQiLCJSZWdFeHAiLCJfaHNsRXhwIiwiX2NvbG9yU3RyaW5nRmlsdGVyIiwiY29tYmluZWQiLCJsYXN0SW5kZXgiLCJ0ZXN0IiwiX3RpY2tlckFjdGl2ZSIsIl9nZXRUaW1lIiwiRGF0ZSIsIm5vdyIsIl9sYWdUaHJlc2hvbGQiLCJfYWRqdXN0ZWRMYWciLCJfc3RhcnRUaW1lIiwiX2xhc3RVcGRhdGUiLCJfZ2FwIiwiX25leHRUaW1lIiwiX2xpc3RlbmVycyIsIl9pZCIsIl9yZXEiLCJfcmFmIiwiX3NlbGYiLCJfZGVsdGEiLCJfaSIsIl90aWNrIiwiZWxhcHNlZCIsIm1hbnVhbCIsIm92ZXJsYXAiLCJkaXNwYXRjaCIsInRpY2siLCJkZWx0YVJhdGlvIiwiZnBzIiwid2FrZSIsImRvY3VtZW50IiwiZ3NhcFZlcnNpb25zIiwidmVyc2lvbiIsIkdyZWVuU29ja0dsb2JhbHMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzbGVlcCIsInNldFRpbWVvdXQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNsZWFyVGltZW91dCIsImxhZ1Ntb290aGluZyIsInRocmVzaG9sZCIsImFkanVzdGVkTGFnIiwiSW5maW5pdHkiLCJfZnBzIiwib25jZSIsInByaW9yaXRpemUiLCJfZWFzZU1hcCIsIl9jdXN0b21FYXNlRXhwIiwiX3F1b3Rlc0V4cCIsIl9wYXJzZU9iamVjdEluU3RyaW5nIiwia2V5IiwidmFsIiwicGFyc2VkVmFsIiwibGFzdEluZGV4T2YiLCJfdmFsdWVJblBhcmVudGhlc2VzIiwib3BlbiIsImNsb3NlIiwibmVzdGVkIiwic3Vic3RyaW5nIiwiX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nIiwiX0NFIiwiX3Byb3BhZ2F0ZVlveW9FYXNlIiwiaXNZb3lvIiwieW95b0Vhc2UiLCJfZWFzZSIsIl95RWFzZSIsImRlZmF1bHRFYXNlIiwiX2luc2VydEVhc2UiLCJlYXNlSW4iLCJlYXNlT3V0IiwiZWFzZUluT3V0IiwibG93ZXJjYXNlTmFtZSIsInRvTG93ZXJDYXNlIiwiX2Vhc2VJbk91dEZyb21PdXQiLCJfY29uZmlnRWxhc3RpYyIsImFtcGxpdHVkZSIsInBlcmlvZCIsInAxIiwicDIiLCJwMyIsImFzaW4iLCJfY29uZmlnQmFjayIsIm92ZXJzaG9vdCIsInBvd2VyIiwiTGluZWFyIiwiZWFzZU5vbmUiLCJub25lIiwibjEiLCJuMiIsIm4zIiwiU3RlcHBlZEVhc2UiLCJzdGVwcyIsImltbWVkaWF0ZVN0YXJ0IiwiaWQiLCJzZXQiLCJBbmltYXRpb24iLCJ5b3lvIiwiX3Byb3RvIiwic3RhcnRUaW1lIiwiX3RvdGFsVGltZSIsIl9wdExvb2t1cCIsIl9wVGltZSIsIl9wcyIsInBhdXNlZCIsImluY2x1ZGVSZXBlYXRzIiwid3JhcFJlcGVhdHMiLCJwcmV2SXNSZXZlcnRpbmciLCJnbG9iYWxUaW1lIiwiX3NhdCIsInNlZWsiLCJyZXN0YXJ0IiwiaW5jbHVkZURlbGF5IiwicGxheSIsInJldmVyc2VkIiwicmV2ZXJzZSIsInBhdXNlIiwiYXRUaW1lIiwicmVzdW1lIiwiaXNBY3RpdmUiLCJldmVudENhbGxiYWNrIiwidGhlbiIsIm9uRnVsZmlsbGVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJfcmVzb2x2ZSIsIl90aGVuIiwiX0FuaW1hdGlvbiIsIl90aGlzIiwic29ydENoaWxkcmVuIiwiX3Byb3RvMiIsInRvIiwiZnJvbVRvIiwiZnJvbVZhcnMiLCJ0b1ZhcnMiLCJkZWxheWVkQ2FsbCIsInN0YWdnZXJUbyIsInN0YWdnZXIiLCJvbkNvbXBsZXRlQWxsIiwib25Db21wbGV0ZUFsbFBhcmFtcyIsIm9uQ29tcGxldGUiLCJvbkNvbXBsZXRlUGFyYW1zIiwic3RhZ2dlckZyb20iLCJzdGFnZ2VyRnJvbVRvIiwidER1ciIsImNyb3NzaW5nU3RhcnQiLCJwcmV2UGF1c2VkIiwicGF1c2VUd2VlbiIsInByZXZTdGFydCIsInJld2luZGluZyIsImRvZXNXcmFwIiwib25SZXBlYXQiLCJfaGFzUGF1c2UiLCJfZm9yY2luZyIsIm9uVXBkYXRlIiwiYWRqdXN0ZWRUaW1lIiwiX3RoaXMyIiwiYWRkTGFiZWwiLCJnZXRDaGlsZHJlbiIsInR3ZWVucyIsInRpbWVsaW5lcyIsImlnbm9yZUJlZm9yZVRpbWUiLCJnZXRCeUlkIiwiYW5pbWF0aW9ucyIsInJlbW92ZUxhYmVsIiwia2lsbFR3ZWVuc09mIiwiX3RvdGFsVGltZTIiLCJhZGRQYXVzZSIsInJlbW92ZVBhdXNlIiwicHJvcHMiLCJvbmx5QWN0aXZlIiwiZ2V0VHdlZW5zT2YiLCJfb3ZlcndyaXRpbmdUd2VlbiIsInBhcnNlZFRhcmdldHMiLCJpc0dsb2JhbFRpbWUiLCJjaGlsZHJlbiIsIl90YXJnZXRzIiwidHdlZW5UbyIsInRsIiwiX3ZhcnMiLCJfb25TdGFydCIsIm9uU3RhcnQiLCJvblN0YXJ0UGFyYW1zIiwiaW5pdHRlZCIsInR3ZWVuRnJvbVRvIiwiZnJvbVBvc2l0aW9uIiwidG9Qb3NpdGlvbiIsIm5leHRMYWJlbCIsImFmdGVyVGltZSIsInByZXZpb3VzTGFiZWwiLCJiZWZvcmVUaW1lIiwiY3VycmVudExhYmVsIiwic2hpZnRDaGlsZHJlbiIsImFkanVzdExhYmVscyIsInNvZnQiLCJjbGVhciIsImluY2x1ZGVMYWJlbHMiLCJ1cGRhdGVSb290IiwiX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4iLCJzZXR0ZXIiLCJzdHJpbmdGaWx0ZXIiLCJmdW5jUGFyYW0iLCJfcmVuZGVyQ29tcGxleFN0cmluZyIsIm1hdGNoSW5kZXgiLCJzdGFydE51bXMiLCJlbmROdW0iLCJjaHVuayIsInN0YXJ0TnVtIiwiaGFzUmFuZG9tIiwiZSIsIm0iLCJmcCIsIm9wdGlvbmFsIiwiY3VycmVudFZhbHVlIiwicGFyc2VkU3RhcnQiLCJfc2V0dGVyUGxhaW4iLCJfc2V0dGVyRnVuY1dpdGhQYXJhbSIsIl9zZXR0ZXJGdW5jIiwiX2ZvcmNlQWxsUHJvcFR3ZWVucyIsIl9yZW5kZXJCb29sZWFuIiwiX3JlbmRlclBsYWluIiwiX3Byb2Nlc3NWYXJzIiwiX3BhcnNlRnVuY09yU3RyaW5nIiwic3R5bGUiLCJfY2hlY2tQbHVnaW4iLCJwbHVnaW4iLCJwdExvb2t1cCIsInByaW9yaXR5IiwicHJldlN0YXJ0QXQiLCJmdWxsVGFyZ2V0cyIsImF1dG9PdmVyd3JpdGUiLCJfb3ZlcndyaXRlIiwiY2xlYW5WYXJzIiwiaGFzUHJpb3JpdHkiLCJnc0RhdGEiLCJoYXJuZXNzVmFycyIsIm92ZXJ3cml0dGVuIiwiX3B0Q2FjaGUiLCJfb3AiLCJfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5IiwiX29uSW5pdCIsIl91cGRhdGVQcm9wVHdlZW5zIiwic3RhcnRJc1JlbGF0aXZlIiwic2tpcFJlY3Vyc2lvbiIsInB0Q2FjaGUiLCJyb290UFQiLCJsb29rdXAiLCJfYWRkQWxpYXNlc1RvVmFycyIsInByb3BlcnR5QWxpYXNlcyIsIl9wYXJzZUtleWZyYW1lIiwiYWxsUHJvcHMiLCJlYXNlRWFjaCIsIl9zdGFnZ2VyVHdlZW5Qcm9wcyIsIl9zdGFnZ2VyUHJvcHNUb1NraXAiLCJfQW5pbWF0aW9uMiIsInNraXBJbmhlcml0IiwiX3RoaXMzIiwiX3RoaXMzJHZhcnMiLCJjdXJUYXJnZXQiLCJzdGFnZ2VyRnVuYyIsInN0YWdnZXJWYXJzVG9NZXJnZSIsImtmIiwiX3Byb3RvMyIsImlzTmVnYXRpdmUiLCJyZXNldFRvIiwia2lsbGluZ1RhcmdldHMiLCJwcm9wVHdlZW5Mb29rdXAiLCJmaXJzdFBUIiwib3ZlcndyaXR0ZW5Qcm9wcyIsImN1ckxvb2t1cCIsImN1ck92ZXJ3cml0ZVByb3BzIiwib25SZXZlcnNlQ29tcGxldGUiLCJvblJldmVyc2VDb21wbGV0ZVBhcmFtcyIsIl9zZXR0ZXJBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJoYXNOb25EZXBlbmRlbnRSZW1haW5pbmciLCJvcCIsImRlcCIsIl9zZXR0ZXJXaXRoTW9kaWZpZXIiLCJtU2V0IiwibXQiLCJwdDIiLCJmaXJzdCIsImxhc3QiLCJwciIsImNoYW5nZSIsInJlbmRlcmVyIiwiX3Byb3RvNCIsIlR3ZWVuTWF4IiwiVHdlZW5MaXRlIiwiVGltZWxpbmVMaXRlIiwiVGltZWxpbmVNYXgiLCJfbWVkaWEiLCJfZW1wdHlBcnJheSIsIl9sYXN0TWVkaWFUaW1lIiwiX2NvbnRleHRJRCIsIl9kaXNwYXRjaCIsIl9vbk1lZGlhQ2hhbmdlIiwibWF0Y2hlcyIsInF1ZXJpZXMiLCJjb25kaXRpb25zIiwiYW55TWF0Y2giLCJ0b2dnbGVkIiwibWF0Y2hNZWRpYSIsIm9uTWF0Y2giLCJDb250ZXh0IiwiX3IiLCJpc1JldmVydGVkIiwiX3Byb3RvNSIsInByZXZTZWxlY3RvciIsImlnbm9yZSIsImdldFR3ZWVucyIsIl90aGlzNCIsIm8iLCJNYXRjaE1lZGlhIiwiY29udGV4dHMiLCJfcHJvdG82IiwiY29uZCIsIm1xIiwiYWN0aXZlIiwiYWRkTGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVnaXN0ZXJQbHVnaW4iLCJfbGVuMiIsImFyZ3MiLCJfa2V5MiIsImdldFByb3BlcnR5IiwidW5jYWNoZSIsImdldHRlciIsImZvcm1hdCIsInF1aWNrU2V0dGVyIiwic2V0dGVycyIsInF1aWNrVG8iLCJfbWVyZ2UyIiwiaXNUd2VlbmluZyIsInJlZ2lzdGVyRWZmZWN0IiwiX3JlZjMiLCJlZmZlY3QiLCJwbHVnaW5zIiwiZXh0ZW5kVGltZWxpbmUiLCJwbHVnaW5OYW1lIiwicmVnaXN0ZXJFYXNlIiwicGFyc2VFYXNlIiwiZXhwb3J0Um9vdCIsImluY2x1ZGVEZWxheWVkQ2FsbHMiLCJtYXRjaE1lZGlhUmVmcmVzaCIsImZvdW5kIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInV0aWxzIiwiaW5zdGFsbCIsImVmZmVjdHMiLCJ0aWNrZXIiLCJnbG9iYWxUaW1lbGluZSIsImNvcmUiLCJnbG9iYWxzIiwiZ2V0Q2FjaGUiLCJyZXZlcnRpbmciLCJ0b0FkZCIsInN1cHByZXNzT3ZlcndyaXRlcyIsIl9nZXRQbHVnaW5Qcm9wVHdlZW4iLCJfYWRkTW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiX2J1aWxkTW9kaWZpZXJQbHVnaW4iLCJ0ZW1wIiwiUG93ZXIwIiwiUG93ZXIxIiwiUG93ZXIyIiwiUG93ZXIzIiwiUG93ZXI0IiwiUXVhZCIsIkN1YmljIiwiUXVhcnQiLCJRdWludCIsIlN0cm9uZyIsIkVsYXN0aWMiLCJCYWNrIiwiQm91bmNlIiwiU2luZSIsIkV4cG8iLCJDaXJjIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/gsap-core.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Back: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Back; },\n/* harmony export */   Bounce: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Bounce; },\n/* harmony export */   CSSPlugin: function() { return /* reexport safe */ _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin; },\n/* harmony export */   Circ: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Circ; },\n/* harmony export */   Cubic: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Cubic; },\n/* harmony export */   Elastic: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Elastic; },\n/* harmony export */   Expo: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Expo; },\n/* harmony export */   Linear: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Linear; },\n/* harmony export */   Power0: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power0; },\n/* harmony export */   Power1: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power1; },\n/* harmony export */   Power2: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power2; },\n/* harmony export */   Power3: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power3; },\n/* harmony export */   Power4: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power4; },\n/* harmony export */   Quad: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quad; },\n/* harmony export */   Quart: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quart; },\n/* harmony export */   Quint: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quint; },\n/* harmony export */   Sine: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Sine; },\n/* harmony export */   SteppedEase: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.SteppedEase; },\n/* harmony export */   Strong: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Strong; },\n/* harmony export */   TimelineLite: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineLite; },\n/* harmony export */   TimelineMax: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineMax; },\n/* harmony export */   TweenLite: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TweenLite; },\n/* harmony export */   TweenMax: function() { return /* binding */ TweenMaxWithCSS; },\n/* harmony export */   \"default\": function() { return /* binding */ gsapWithCSS; },\n/* harmony export */   gsap: function() { return /* binding */ gsapWithCSS; }\n/* harmony export */ });\n/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/gsap-core.js\");\n/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSPlugin.js\");\n\n\nvar gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap, // to protect from tree shaking\nTweenMaxWithCSS = gsapWithCSS.core.Tween;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcU47QUFDMUs7QUFDM0MsSUFBSXVCLGNBQWN2QiwrQ0FBSUEsQ0FBQ3dCLGNBQWMsQ0FBQ0Ysb0RBQVNBLEtBQUt0QiwrQ0FBSUEsRUFDcEQsK0JBQStCO0FBQ25DeUIsa0JBQWtCRixZQUFZRyxJQUFJLENBQUNDLEtBQUs7QUFDc08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dzYXBAMy4xMi41L25vZGVfbW9kdWxlcy9nc2FwL2luZGV4LmpzPzQzOTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ3NhcCwgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjLCBUd2VlbkxpdGUsIFRpbWVsaW5lTGl0ZSwgVGltZWxpbmVNYXggfSBmcm9tIFwiLi9nc2FwLWNvcmUuanNcIjtcbmltcG9ydCB7IENTU1BsdWdpbiB9IGZyb20gXCIuL0NTU1BsdWdpbi5qc1wiO1xudmFyIGdzYXBXaXRoQ1NTID0gZ3NhcC5yZWdpc3RlclBsdWdpbihDU1NQbHVnaW4pIHx8IGdzYXAsXG4gICAgLy8gdG8gcHJvdGVjdCBmcm9tIHRyZWUgc2hha2luZ1xuVHdlZW5NYXhXaXRoQ1NTID0gZ3NhcFdpdGhDU1MuY29yZS5Ud2VlbjtcbmV4cG9ydCB7IGdzYXBXaXRoQ1NTIGFzIGdzYXAsIGdzYXBXaXRoQ1NTIGFzIGRlZmF1bHQsIENTU1BsdWdpbiwgVHdlZW5NYXhXaXRoQ1NTIGFzIFR3ZWVuTWF4LCBUd2VlbkxpdGUsIFRpbWVsaW5lTWF4LCBUaW1lbGluZUxpdGUsIFBvd2VyMCwgUG93ZXIxLCBQb3dlcjIsIFBvd2VyMywgUG93ZXI0LCBMaW5lYXIsIFF1YWQsIEN1YmljLCBRdWFydCwgUXVpbnQsIFN0cm9uZywgRWxhc3RpYywgQmFjaywgU3RlcHBlZEVhc2UsIEJvdW5jZSwgU2luZSwgRXhwbywgQ2lyYyB9OyJdLCJuYW1lcyI6WyJnc2FwIiwiUG93ZXIwIiwiUG93ZXIxIiwiUG93ZXIyIiwiUG93ZXIzIiwiUG93ZXI0IiwiTGluZWFyIiwiUXVhZCIsIkN1YmljIiwiUXVhcnQiLCJRdWludCIsIlN0cm9uZyIsIkVsYXN0aWMiLCJCYWNrIiwiU3RlcHBlZEVhc2UiLCJCb3VuY2UiLCJTaW5lIiwiRXhwbyIsIkNpcmMiLCJUd2VlbkxpdGUiLCJUaW1lbGluZUxpdGUiLCJUaW1lbGluZU1heCIsIkNTU1BsdWdpbiIsImdzYXBXaXRoQ1NTIiwicmVnaXN0ZXJQbHVnaW4iLCJUd2Vlbk1heFdpdGhDU1MiLCJjb3JlIiwiVHdlZW4iLCJkZWZhdWx0IiwiVHdlZW5NYXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/matrix.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/matrix.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Matrix2D: function() { return /* binding */ Matrix2D; },\n/* harmony export */   _getCTM: function() { return /* binding */ _getCTM; },\n/* harmony export */   _getDocScrollLeft: function() { return /* binding */ _getDocScrollLeft; },\n/* harmony export */   _getDocScrollTop: function() { return /* binding */ _getDocScrollTop; },\n/* harmony export */   _isFixed: function() { return /* binding */ _isFixed; },\n/* harmony export */   _setDoc: function() { return /* binding */ _setDoc; },\n/* harmony export */   getGlobalMatrix: function() { return /* binding */ getGlobalMatrix; }\n/* harmony export */ });\n/*!\n * matrix 3.12.5\n * https://gsap.com\n *\n * Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var _doc, _win, _docElement, _body, _divContainer, _svgContainer, _identityMatrix, _gEl, _transformProp = \"transform\", _transformOriginProp = _transformProp + \"Origin\", _hasOffsetBug, _setDoc = function _setDoc(element) {\n    var doc = element.ownerDocument || element;\n    if (!(_transformProp in element.style) && \"msTransform\" in element.style) {\n        //to improve compatibility with old Microsoft browsers\n        _transformProp = \"msTransform\";\n        _transformOriginProp = _transformProp + \"Origin\";\n    }\n    while(doc.parentNode && (doc = doc.parentNode)){}\n    _win = window;\n    _identityMatrix = new Matrix2D();\n    if (doc) {\n        _doc = doc;\n        _docElement = doc.documentElement;\n        _body = doc.body;\n        _gEl = _doc.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"); // prevent any existing CSS from transforming it\n        _gEl.style.transform = \"none\"; // now test for the offset reporting bug. Use feature detection instead of browser sniffing to make things more bulletproof and future-proof. Hopefully Safari will fix their bug soon.\n        var d1 = doc.createElement(\"div\"), d2 = doc.createElement(\"div\"), root = doc && (doc.body || doc.firstElementChild);\n        if (root && root.appendChild) {\n            root.appendChild(d1);\n            d1.appendChild(d2);\n            d1.setAttribute(\"style\", \"position:static;transform:translate3d(0,0,1px)\");\n            _hasOffsetBug = d2.offsetParent !== d1;\n            root.removeChild(d1);\n        }\n    }\n    return doc;\n}, _forceNonZeroScale = function _forceNonZeroScale(e) {\n    // walks up the element's ancestors and finds any that had their scale set to 0 via GSAP, and changes them to 0.0001 to ensure that measurements work. Firefox has a bug that causes it to incorrectly report getBoundingClientRect() when scale is 0.\n    var a, cache;\n    while(e && e !== _body){\n        cache = e._gsap;\n        cache && cache.uncache && cache.get(e, \"x\"); // force re-parsing of transforms if necessary\n        if (cache && !cache.scaleX && !cache.scaleY && cache.renderTransform) {\n            cache.scaleX = cache.scaleY = 1e-4;\n            cache.renderTransform(1, cache);\n            a ? a.push(cache) : a = [\n                cache\n            ];\n        }\n        e = e.parentNode;\n    }\n    return a;\n}, // possible future addition: pass an element to _forceDisplay() and it'll walk up all its ancestors and make sure anything with display: none is set to display: block, and if there's no parentNode, it'll add it to the body. It returns an Array that you can then feed to _revertDisplay() to have it revert all the changes it made.\n// _forceDisplay = e => {\n// \tlet a = [],\n// \t\tparent;\n// \twhile (e && e !== _body) {\n// \t\tparent = e.parentNode;\n// \t\t(_win.getComputedStyle(e).display === \"none\" || !parent) && a.push(e, e.style.display, parent) && (e.style.display = \"block\");\n// \t\tparent || _body.appendChild(e);\n// \t\te = parent;\n// \t}\n// \treturn a;\n// },\n// _revertDisplay = a => {\n// \tfor (let i = 0; i < a.length; i+=3) {\n// \t\ta[i+1] ? (a[i].style.display = a[i+1]) : a[i].style.removeProperty(\"display\");\n// \t\ta[i+2] || a[i].parentNode.removeChild(a[i]);\n// \t}\n// },\n_svgTemps = [], //we create 3 elements for SVG, and 3 for other DOM elements and cache them for performance reasons. They get nested in _divContainer and _svgContainer so that just one element is added to the DOM on each successive attempt. Again, performance is key.\n_divTemps = [], _getDocScrollTop = function _getDocScrollTop() {\n    return _win.pageYOffset || _doc.scrollTop || _docElement.scrollTop || _body.scrollTop || 0;\n}, _getDocScrollLeft = function _getDocScrollLeft() {\n    return _win.pageXOffset || _doc.scrollLeft || _docElement.scrollLeft || _body.scrollLeft || 0;\n}, _svgOwner = function _svgOwner(element) {\n    return element.ownerSVGElement || ((element.tagName + \"\").toLowerCase() === \"svg\" ? element : null);\n}, _isFixed = function _isFixed(element) {\n    if (_win.getComputedStyle(element).position === \"fixed\") {\n        return true;\n    }\n    element = element.parentNode;\n    if (element && element.nodeType === 1) {\n        // avoid document fragments which will throw an error.\n        return _isFixed(element);\n    }\n}, _createSibling = function _createSibling(element, i) {\n    if (element.parentNode && (_doc || _setDoc(element))) {\n        var svg = _svgOwner(element), ns = svg ? svg.getAttribute(\"xmlns\") || \"http://www.w3.org/2000/svg\" : \"http://www.w3.org/1999/xhtml\", type = svg ? i ? \"rect\" : \"g\" : \"div\", x = i !== 2 ? 0 : 100, y = i === 3 ? 100 : 0, css = \"position:absolute;display:block;pointer-events:none;margin:0;padding:0;\", e = _doc.createElementNS ? _doc.createElementNS(ns.replace(/^https/, \"http\"), type) : _doc.createElement(type);\n        if (i) {\n            if (!svg) {\n                if (!_divContainer) {\n                    _divContainer = _createSibling(element);\n                    _divContainer.style.cssText = css;\n                }\n                e.style.cssText = css + \"width:0.1px;height:0.1px;top:\" + y + \"px;left:\" + x + \"px\";\n                _divContainer.appendChild(e);\n            } else {\n                _svgContainer || (_svgContainer = _createSibling(element));\n                e.setAttribute(\"width\", 0.01);\n                e.setAttribute(\"height\", 0.01);\n                e.setAttribute(\"transform\", \"translate(\" + x + \",\" + y + \")\");\n                _svgContainer.appendChild(e);\n            }\n        }\n        return e;\n    }\n    throw \"Need document and parent.\";\n}, _consolidate = function _consolidate(m) {\n    // replaces SVGTransformList.consolidate() because a bug in Firefox causes it to break pointer events. See https://gsap.com/forums/topic/23248-touch-is-not-working-on-draggable-in-firefox-windows-v324/?tab=comments#comment-109800\n    var c = new Matrix2D(), i = 0;\n    for(; i < m.numberOfItems; i++){\n        c.multiply(m.getItem(i).matrix);\n    }\n    return c;\n}, _getCTM = function _getCTM(svg) {\n    var m = svg.getCTM(), transform;\n    if (!m) {\n        // Firefox returns null for getCTM() on root <svg> elements, so this is a workaround using a <g> that we temporarily append.\n        transform = svg.style[_transformProp];\n        svg.style[_transformProp] = \"none\"; // a bug in Firefox causes css transforms to contaminate the getCTM()\n        svg.appendChild(_gEl);\n        m = _gEl.getCTM();\n        svg.removeChild(_gEl);\n        transform ? svg.style[_transformProp] = transform : svg.style.removeProperty(_transformProp.replace(/([A-Z])/g, \"-$1\").toLowerCase());\n    }\n    return m || _identityMatrix.clone(); // Firefox will still return null if the <svg> has a width/height of 0 in the browser.\n}, _placeSiblings = function _placeSiblings(element, adjustGOffset) {\n    var svg = _svgOwner(element), isRootSVG = element === svg, siblings = svg ? _svgTemps : _divTemps, parent = element.parentNode, container, m, b, x, y, cs;\n    if (element === _win) {\n        return element;\n    }\n    siblings.length || siblings.push(_createSibling(element, 1), _createSibling(element, 2), _createSibling(element, 3));\n    container = svg ? _svgContainer : _divContainer;\n    if (svg) {\n        if (isRootSVG) {\n            b = _getCTM(element);\n            x = -b.e / b.a;\n            y = -b.f / b.d;\n            m = _identityMatrix;\n        } else if (element.getBBox) {\n            b = element.getBBox();\n            m = element.transform ? element.transform.baseVal : {}; // IE11 doesn't follow the spec.\n            m = !m.numberOfItems ? _identityMatrix : m.numberOfItems > 1 ? _consolidate(m) : m.getItem(0).matrix; // don't call m.consolidate().matrix because a bug in Firefox makes pointer events not work when consolidate() is called on the same tick as getBoundingClientRect()! See https://gsap.com/forums/topic/23248-touch-is-not-working-on-draggable-in-firefox-windows-v324/?tab=comments#comment-109800\n            x = m.a * b.x + m.c * b.y;\n            y = m.b * b.x + m.d * b.y;\n        } else {\n            // may be a <mask> which has no getBBox() so just use defaults instead of throwing errors.\n            m = new Matrix2D();\n            x = y = 0;\n        }\n        if (adjustGOffset && element.tagName.toLowerCase() === \"g\") {\n            x = y = 0;\n        }\n        (isRootSVG ? svg : parent).appendChild(container);\n        container.setAttribute(\"transform\", \"matrix(\" + m.a + \",\" + m.b + \",\" + m.c + \",\" + m.d + \",\" + (m.e + x) + \",\" + (m.f + y) + \")\");\n    } else {\n        x = y = 0;\n        if (_hasOffsetBug) {\n            // some browsers (like Safari) have a bug that causes them to misreport offset values. When an ancestor element has a transform applied, it's supposed to treat it as if it's position: relative (new context). Safari botches this, so we need to find the closest ancestor (between the element and its offsetParent) that has a transform applied and if one is found, grab its offsetTop/Left and subtract them to compensate.\n            m = element.offsetParent;\n            b = element;\n            while(b && (b = b.parentNode) && b !== m && b.parentNode){\n                if ((_win.getComputedStyle(b)[_transformProp] + \"\").length > 4) {\n                    x = b.offsetLeft;\n                    y = b.offsetTop;\n                    b = 0;\n                }\n            }\n        }\n        cs = _win.getComputedStyle(element);\n        if (cs.position !== \"absolute\" && cs.position !== \"fixed\") {\n            m = element.offsetParent;\n            while(parent && parent !== m){\n                // if there's an ancestor element between the element and its offsetParent that's scrolled, we must factor that in.\n                x += parent.scrollLeft || 0;\n                y += parent.scrollTop || 0;\n                parent = parent.parentNode;\n            }\n        }\n        b = container.style;\n        b.top = element.offsetTop - y + \"px\";\n        b.left = element.offsetLeft - x + \"px\";\n        b[_transformProp] = cs[_transformProp];\n        b[_transformOriginProp] = cs[_transformOriginProp]; // b.border = m.border;\n        // b.borderLeftStyle = m.borderLeftStyle;\n        // b.borderTopStyle = m.borderTopStyle;\n        // b.borderLeftWidth = m.borderLeftWidth;\n        // b.borderTopWidth = m.borderTopWidth;\n        b.position = cs.position === \"fixed\" ? \"fixed\" : \"absolute\";\n        element.parentNode.appendChild(container);\n    }\n    return container;\n}, _setMatrix = function _setMatrix(m, a, b, c, d, e, f) {\n    m.a = a;\n    m.b = b;\n    m.c = c;\n    m.d = d;\n    m.e = e;\n    m.f = f;\n    return m;\n};\nvar Matrix2D = /*#__PURE__*/ function() {\n    function Matrix2D(a, b, c, d, e, f) {\n        if (a === void 0) {\n            a = 1;\n        }\n        if (b === void 0) {\n            b = 0;\n        }\n        if (c === void 0) {\n            c = 0;\n        }\n        if (d === void 0) {\n            d = 1;\n        }\n        if (e === void 0) {\n            e = 0;\n        }\n        if (f === void 0) {\n            f = 0;\n        }\n        _setMatrix(this, a, b, c, d, e, f);\n    }\n    var _proto = Matrix2D.prototype;\n    _proto.inverse = function inverse() {\n        var a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f, determinant = a * d - b * c || 1e-10;\n        return _setMatrix(this, d / determinant, -b / determinant, -c / determinant, a / determinant, (c * f - d * e) / determinant, -(a * f - b * e) / determinant);\n    };\n    _proto.multiply = function multiply(matrix) {\n        var a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f, a2 = matrix.a, b2 = matrix.c, c2 = matrix.b, d2 = matrix.d, e2 = matrix.e, f2 = matrix.f;\n        return _setMatrix(this, a2 * a + c2 * c, a2 * b + c2 * d, b2 * a + d2 * c, b2 * b + d2 * d, e + e2 * a + f2 * c, f + e2 * b + f2 * d);\n    };\n    _proto.clone = function clone() {\n        return new Matrix2D(this.a, this.b, this.c, this.d, this.e, this.f);\n    };\n    _proto.equals = function equals(matrix) {\n        var a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f;\n        return a === matrix.a && b === matrix.b && c === matrix.c && d === matrix.d && e === matrix.e && f === matrix.f;\n    };\n    _proto.apply = function apply(point, decoratee) {\n        if (decoratee === void 0) {\n            decoratee = {};\n        }\n        var x = point.x, y = point.y, a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f;\n        decoratee.x = x * a + y * c + e || 0;\n        decoratee.y = x * b + y * d + f || 0;\n        return decoratee;\n    };\n    return Matrix2D;\n}(); // Feed in an element and it'll return a 2D matrix (optionally inverted) so that you can translate between coordinate spaces.\n// Inverting lets you translate a global point into a local coordinate space. No inverting lets you go the other way.\n// We needed this to work around various browser bugs, like Firefox doesn't accurately report getScreenCTM() when there\n// are transforms applied to ancestor elements.\n// The matrix math to convert any x/y coordinate is as follows, which is wrapped in a convenient apply() method of Matrix2D above:\n//     tx = m.a * x + m.c * y + m.e\n//     ty = m.b * x + m.d * y + m.f\nfunction getGlobalMatrix(element, inverse, adjustGOffset, includeScrollInFixed) {\n    // adjustGOffset is typically used only when grabbing an element's PARENT's global matrix, and it ignores the x/y offset of any SVG <g> elements because they behave in a special way.\n    if (!element || !element.parentNode || (_doc || _setDoc(element)).documentElement === element) {\n        return new Matrix2D();\n    }\n    var zeroScales = _forceNonZeroScale(element), svg = _svgOwner(element), temps = svg ? _svgTemps : _divTemps, container = _placeSiblings(element, adjustGOffset), b1 = temps[0].getBoundingClientRect(), b2 = temps[1].getBoundingClientRect(), b3 = temps[2].getBoundingClientRect(), parent = container.parentNode, isFixed = !includeScrollInFixed && _isFixed(element), m = new Matrix2D((b2.left - b1.left) / 100, (b2.top - b1.top) / 100, (b3.left - b1.left) / 100, (b3.top - b1.top) / 100, b1.left + (isFixed ? 0 : _getDocScrollLeft()), b1.top + (isFixed ? 0 : _getDocScrollTop()));\n    parent.removeChild(container);\n    if (zeroScales) {\n        b1 = zeroScales.length;\n        while(b1--){\n            b2 = zeroScales[b1];\n            b2.scaleX = b2.scaleY = 0;\n            b2.renderTransform(1, b2);\n        }\n    }\n    return inverse ? m.inverse() : m;\n}\n // export function getMatrix(element) {\n // \t_doc || _setDoc(element);\n // \tlet m = (_win.getComputedStyle(element)[_transformProp] + \"\").substr(7).match(/[-.]*\\d+[.e\\-+]*\\d*[e\\-\\+]*\\d*/g),\n // \t\tis2D = m && m.length === 6;\n // \treturn !m || m.length < 6 ? new Matrix2D() : new Matrix2D(+m[0], +m[1], +m[is2D ? 2 : 4], +m[is2D ? 3 : 5], +m[is2D ? 4 : 12], +m[is2D ? 5 : 13]);\n // }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC91dGlscy9tYXRyaXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCLEdBQ2xCLElBQUlBLE1BQ0FDLE1BQ0FDLGFBQ0FDLE9BQ0FDLGVBQ0FDLGVBQ0FDLGlCQUNBQyxNQUNBQyxpQkFBaUIsYUFDakJDLHVCQUF1QkQsaUJBQWlCLFVBQ3hDRSxlQUNBQyxVQUFVLFNBQVNBLFFBQVFDLE9BQU87SUFDcEMsSUFBSUMsTUFBTUQsUUFBUUUsYUFBYSxJQUFJRjtJQUVuQyxJQUFJLENBQUVKLENBQUFBLGtCQUFrQkksUUFBUUcsS0FBSyxLQUFLLGlCQUFpQkgsUUFBUUcsS0FBSyxFQUFFO1FBQ3hFLHNEQUFzRDtRQUN0RFAsaUJBQWlCO1FBQ2pCQyx1QkFBdUJELGlCQUFpQjtJQUMxQztJQUVBLE1BQU9LLElBQUlHLFVBQVUsSUFBS0gsQ0FBQUEsTUFBTUEsSUFBSUcsVUFBVSxFQUFHLENBQUM7SUFFbERmLE9BQU9nQjtJQUNQWCxrQkFBa0IsSUFBSVk7SUFFdEIsSUFBSUwsS0FBSztRQUNQYixPQUFPYTtRQUNQWCxjQUFjVyxJQUFJTSxlQUFlO1FBQ2pDaEIsUUFBUVUsSUFBSU8sSUFBSTtRQUNoQmIsT0FBT1AsS0FBS3FCLGVBQWUsQ0FBQyw4QkFBOEIsTUFBTSxnREFBZ0Q7UUFFaEhkLEtBQUtRLEtBQUssQ0FBQ08sU0FBUyxHQUFHLFFBQVEsdUxBQXVMO1FBRXROLElBQUlDLEtBQUtWLElBQUlXLGFBQWEsQ0FBQyxRQUN2QkMsS0FBS1osSUFBSVcsYUFBYSxDQUFDLFFBQ3ZCRSxPQUFPYixPQUFRQSxDQUFBQSxJQUFJTyxJQUFJLElBQUlQLElBQUljLGlCQUFpQjtRQUVwRCxJQUFJRCxRQUFRQSxLQUFLRSxXQUFXLEVBQUU7WUFDNUJGLEtBQUtFLFdBQVcsQ0FBQ0w7WUFDakJBLEdBQUdL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RSxHQUFHL0QsZUFBZSxDQUFDLEdBQUcrRDtRQUN4QjtJQUNGO0lBRUEsT0FBT0gsVUFBVTlCLEVBQUU4QixPQUFPLEtBQUs5QjtBQUNqQztBQUMyRSxDQUFDLHVDQUF1QztDQUNuSCw2QkFBNkI7Q0FDN0IscUhBQXFIO0NBQ3JILGdDQUFnQztDQUNoQyxzSkFBc0o7Q0FDdEosSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vZ3NhcEAzLjEyLjUvbm9kZV9tb2R1bGVzL2dzYXAvdXRpbHMvbWF0cml4LmpzPzU0ODMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBtYXRyaXggMy4xMi41XG4gKiBodHRwczovL2dzYXAuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyNCwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9nc2FwLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHU0FQIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIF9kb2MsXG4gICAgX3dpbixcbiAgICBfZG9jRWxlbWVudCxcbiAgICBfYm9keSxcbiAgICBfZGl2Q29udGFpbmVyLFxuICAgIF9zdmdDb250YWluZXIsXG4gICAgX2lkZW50aXR5TWF0cml4LFxuICAgIF9nRWwsXG4gICAgX3RyYW5zZm9ybVByb3AgPSBcInRyYW5zZm9ybVwiLFxuICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiLFxuICAgIF9oYXNPZmZzZXRCdWcsXG4gICAgX3NldERvYyA9IGZ1bmN0aW9uIF9zZXREb2MoZWxlbWVudCkge1xuICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGVsZW1lbnQ7XG5cbiAgaWYgKCEoX3RyYW5zZm9ybVByb3AgaW4gZWxlbWVudC5zdHlsZSkgJiYgXCJtc1RyYW5zZm9ybVwiIGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAvL3RvIGltcHJvdmUgY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBNaWNyb3NvZnQgYnJvd3NlcnNcbiAgICBfdHJhbnNmb3JtUHJvcCA9IFwibXNUcmFuc2Zvcm1cIjtcbiAgICBfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF90cmFuc2Zvcm1Qcm9wICsgXCJPcmlnaW5cIjtcbiAgfVxuXG4gIHdoaWxlIChkb2MucGFyZW50Tm9kZSAmJiAoZG9jID0gZG9jLnBhcmVudE5vZGUpKSB7fVxuXG4gIF93aW4gPSB3aW5kb3c7XG4gIF9pZGVudGl0eU1hdHJpeCA9IG5ldyBNYXRyaXgyRCgpO1xuXG4gIGlmIChkb2MpIHtcbiAgICBfZG9jID0gZG9jO1xuICAgIF9kb2NFbGVtZW50ID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICBfYm9keSA9IGRvYy5ib2R5O1xuICAgIF9nRWwgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTsgLy8gcHJldmVudCBhbnkgZXhpc3RpbmcgQ1NTIGZyb20gdHJhbnNmb3JtaW5nIGl0XG5cbiAgICBfZ0VsLnN0eWxlLnRyYW5zZm9ybSA9IFwibm9uZVwiOyAvLyBub3cgdGVzdCBmb3IgdGhlIG9mZnNldCByZXBvcnRpbmcgYnVnLiBVc2UgZmVhdHVyZSBkZXRlY3Rpb24gaW5zdGVhZCBvZiBicm93c2VyIHNuaWZmaW5nIHRvIG1ha2UgdGhpbmdzIG1vcmUgYnVsbGV0cHJvb2YgYW5kIGZ1dHVyZS1wcm9vZi4gSG9wZWZ1bGx5IFNhZmFyaSB3aWxsIGZpeCB0aGVpciBidWcgc29vbi5cblxuICAgIHZhciBkMSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICBkMiA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICByb290ID0gZG9jICYmIChkb2MuYm9keSB8fCBkb2MuZmlyc3RFbGVtZW50Q2hpbGQpO1xuXG4gICAgaWYgKHJvb3QgJiYgcm9vdC5hcHBlbmRDaGlsZCkge1xuICAgICAgcm9vdC5hcHBlbmRDaGlsZChkMSk7XG4gICAgICBkMS5hcHBlbmRDaGlsZChkMik7XG4gICAgICBkMS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcInBvc2l0aW9uOnN0YXRpYzt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDFweClcIik7XG4gICAgICBfaGFzT2Zmc2V0QnVnID0gZDIub2Zmc2V0UGFyZW50ICE9PSBkMTtcbiAgICAgIHJvb3QucmVtb3ZlQ2hpbGQoZDEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkb2M7XG59LFxuICAgIF9mb3JjZU5vblplcm9TY2FsZSA9IGZ1bmN0aW9uIF9mb3JjZU5vblplcm9TY2FsZShlKSB7XG4gIC8vIHdhbGtzIHVwIHRoZSBlbGVtZW50J3MgYW5jZXN0b3JzIGFuZCBmaW5kcyBhbnkgdGhhdCBoYWQgdGhlaXIgc2NhbGUgc2V0IHRvIDAgdmlhIEdTQVAsIGFuZCBjaGFuZ2VzIHRoZW0gdG8gMC4wMDAxIHRvIGVuc3VyZSB0aGF0IG1lYXN1cmVtZW50cyB3b3JrLiBGaXJlZm94IGhhcyBhIGJ1ZyB0aGF0IGNhdXNlcyBpdCB0byBpbmNvcnJlY3RseSByZXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgd2hlbiBzY2FsZSBpcyAwLlxuICB2YXIgYSwgY2FjaGU7XG5cbiAgd2hpbGUgKGUgJiYgZSAhPT0gX2JvZHkpIHtcbiAgICBjYWNoZSA9IGUuX2dzYXA7XG4gICAgY2FjaGUgJiYgY2FjaGUudW5jYWNoZSAmJiBjYWNoZS5nZXQoZSwgXCJ4XCIpOyAvLyBmb3JjZSByZS1wYXJzaW5nIG9mIHRyYW5zZm9ybXMgaWYgbmVjZXNzYXJ5XG5cbiAgICBpZiAoY2FjaGUgJiYgIWNhY2hlLnNjYWxlWCAmJiAhY2FjaGUuc2NhbGVZICYmIGNhY2hlLnJlbmRlclRyYW5zZm9ybSkge1xuICAgICAgY2FjaGUuc2NhbGVYID0gY2FjaGUuc2NhbGVZID0gMWUtNDtcbiAgICAgIGNhY2hlLnJlbmRlclRyYW5zZm9ybSgxLCBjYWNoZSk7XG4gICAgICBhID8gYS5wdXNoKGNhY2hlKSA6IGEgPSBbY2FjaGVdO1xuICAgIH1cblxuICAgIGUgPSBlLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gYTtcbn0sXG4gICAgLy8gcG9zc2libGUgZnV0dXJlIGFkZGl0aW9uOiBwYXNzIGFuIGVsZW1lbnQgdG8gX2ZvcmNlRGlzcGxheSgpIGFuZCBpdCdsbCB3YWxrIHVwIGFsbCBpdHMgYW5jZXN0b3JzIGFuZCBtYWtlIHN1cmUgYW55dGhpbmcgd2l0aCBkaXNwbGF5OiBub25lIGlzIHNldCB0byBkaXNwbGF5OiBibG9jaywgYW5kIGlmIHRoZXJlJ3Mgbm8gcGFyZW50Tm9kZSwgaXQnbGwgYWRkIGl0IHRvIHRoZSBib2R5LiBJdCByZXR1cm5zIGFuIEFycmF5IHRoYXQgeW91IGNhbiB0aGVuIGZlZWQgdG8gX3JldmVydERpc3BsYXkoKSB0byBoYXZlIGl0IHJldmVydCBhbGwgdGhlIGNoYW5nZXMgaXQgbWFkZS5cbi8vIF9mb3JjZURpc3BsYXkgPSBlID0+IHtcbi8vIFx0bGV0IGEgPSBbXSxcbi8vIFx0XHRwYXJlbnQ7XG4vLyBcdHdoaWxlIChlICYmIGUgIT09IF9ib2R5KSB7XG4vLyBcdFx0cGFyZW50ID0gZS5wYXJlbnROb2RlO1xuLy8gXHRcdChfd2luLmdldENvbXB1dGVkU3R5bGUoZSkuZGlzcGxheSA9PT0gXCJub25lXCIgfHwgIXBhcmVudCkgJiYgYS5wdXNoKGUsIGUuc3R5bGUuZGlzcGxheSwgcGFyZW50KSAmJiAoZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiKTtcbi8vIFx0XHRwYXJlbnQgfHwgX2JvZHkuYXBwZW5kQ2hpbGQoZSk7XG4vLyBcdFx0ZSA9IHBhcmVudDtcbi8vIFx0fVxuLy8gXHRyZXR1cm4gYTtcbi8vIH0sXG4vLyBfcmV2ZXJ0RGlzcGxheSA9IGEgPT4ge1xuLy8gXHRmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKz0zKSB7XG4vLyBcdFx0YVtpKzFdID8gKGFbaV0uc3R5bGUuZGlzcGxheSA9IGFbaSsxXSkgOiBhW2ldLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZGlzcGxheVwiKTtcbi8vIFx0XHRhW2krMl0gfHwgYVtpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGFbaV0pO1xuLy8gXHR9XG4vLyB9LFxuX3N2Z1RlbXBzID0gW10sXG4gICAgLy93ZSBjcmVhdGUgMyBlbGVtZW50cyBmb3IgU1ZHLCBhbmQgMyBmb3Igb3RoZXIgRE9NIGVsZW1lbnRzIGFuZCBjYWNoZSB0aGVtIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBUaGV5IGdldCBuZXN0ZWQgaW4gX2RpdkNvbnRhaW5lciBhbmQgX3N2Z0NvbnRhaW5lciBzbyB0aGF0IGp1c3Qgb25lIGVsZW1lbnQgaXMgYWRkZWQgdG8gdGhlIERPTSBvbiBlYWNoIHN1Y2Nlc3NpdmUgYXR0ZW1wdC4gQWdhaW4sIHBlcmZvcm1hbmNlIGlzIGtleS5cbl9kaXZUZW1wcyA9IFtdLFxuICAgIF9nZXREb2NTY3JvbGxUb3AgPSBmdW5jdGlvbiBfZ2V0RG9jU2Nyb2xsVG9wKCkge1xuICByZXR1cm4gX3dpbi5wYWdlWU9mZnNldCB8fCBfZG9jLnNjcm9sbFRvcCB8fCBfZG9jRWxlbWVudC5zY3JvbGxUb3AgfHwgX2JvZHkuc2Nyb2xsVG9wIHx8IDA7XG59LFxuICAgIF9nZXREb2NTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gX2dldERvY1Njcm9sbExlZnQoKSB7XG4gIHJldHVybiBfd2luLnBhZ2VYT2Zmc2V0IHx8IF9kb2Muc2Nyb2xsTGVmdCB8fCBfZG9jRWxlbWVudC5zY3JvbGxMZWZ0IHx8IF9ib2R5LnNjcm9sbExlZnQgfHwgMDtcbn0sXG4gICAgX3N2Z093bmVyID0gZnVuY3Rpb24gX3N2Z093bmVyKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQub3duZXJTVkdFbGVtZW50IHx8ICgoZWxlbWVudC50YWdOYW1lICsgXCJcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJzdmdcIiA/IGVsZW1lbnQgOiBudWxsKTtcbn0sXG4gICAgX2lzRml4ZWQgPSBmdW5jdGlvbiBfaXNGaXhlZChlbGVtZW50KSB7XG4gIGlmIChfd2luLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09IFwiZml4ZWRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgLy8gYXZvaWQgZG9jdW1lbnQgZnJhZ21lbnRzIHdoaWNoIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgcmV0dXJuIF9pc0ZpeGVkKGVsZW1lbnQpO1xuICB9XG59LFxuICAgIF9jcmVhdGVTaWJsaW5nID0gZnVuY3Rpb24gX2NyZWF0ZVNpYmxpbmcoZWxlbWVudCwgaSkge1xuICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICYmIChfZG9jIHx8IF9zZXREb2MoZWxlbWVudCkpKSB7XG4gICAgdmFyIHN2ZyA9IF9zdmdPd25lcihlbGVtZW50KSxcbiAgICAgICAgbnMgPSBzdmcgPyBzdmcuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIDogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsXG4gICAgICAgIHR5cGUgPSBzdmcgPyBpID8gXCJyZWN0XCIgOiBcImdcIiA6IFwiZGl2XCIsXG4gICAgICAgIHggPSBpICE9PSAyID8gMCA6IDEwMCxcbiAgICAgICAgeSA9IGkgPT09IDMgPyAxMDAgOiAwLFxuICAgICAgICBjc3MgPSBcInBvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7cG9pbnRlci1ldmVudHM6bm9uZTttYXJnaW46MDtwYWRkaW5nOjA7XCIsXG4gICAgICAgIGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyA/IF9kb2MuY3JlYXRlRWxlbWVudE5TKG5zLnJlcGxhY2UoL15odHRwcy8sIFwiaHR0cFwiKSwgdHlwZSkgOiBfZG9jLmNyZWF0ZUVsZW1lbnQodHlwZSk7XG5cbiAgICBpZiAoaSkge1xuICAgICAgaWYgKCFzdmcpIHtcbiAgICAgICAgaWYgKCFfZGl2Q29udGFpbmVyKSB7XG4gICAgICAgICAgX2RpdkNvbnRhaW5lciA9IF9jcmVhdGVTaWJsaW5nKGVsZW1lbnQpO1xuICAgICAgICAgIF9kaXZDb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGNzcztcbiAgICAgICAgfVxuXG4gICAgICAgIGUuc3R5bGUuY3NzVGV4dCA9IGNzcyArIFwid2lkdGg6MC4xcHg7aGVpZ2h0OjAuMXB4O3RvcDpcIiArIHkgKyBcInB4O2xlZnQ6XCIgKyB4ICsgXCJweFwiO1xuXG4gICAgICAgIF9kaXZDb250YWluZXIuYXBwZW5kQ2hpbGQoZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfc3ZnQ29udGFpbmVyIHx8IChfc3ZnQ29udGFpbmVyID0gX2NyZWF0ZVNpYmxpbmcoZWxlbWVudCkpO1xuICAgICAgICBlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIDAuMDEpO1xuICAgICAgICBlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCAwLjAxKTtcbiAgICAgICAgZS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpXCIpO1xuXG4gICAgICAgIF9zdmdDb250YWluZXIuYXBwZW5kQ2hpbGQoZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICB0aHJvdyBcIk5lZWQgZG9jdW1lbnQgYW5kIHBhcmVudC5cIjtcbn0sXG4gICAgX2NvbnNvbGlkYXRlID0gZnVuY3Rpb24gX2NvbnNvbGlkYXRlKG0pIHtcbiAgLy8gcmVwbGFjZXMgU1ZHVHJhbnNmb3JtTGlzdC5jb25zb2xpZGF0ZSgpIGJlY2F1c2UgYSBidWcgaW4gRmlyZWZveCBjYXVzZXMgaXQgdG8gYnJlYWsgcG9pbnRlciBldmVudHMuIFNlZSBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8yMzI0OC10b3VjaC1pcy1ub3Qtd29ya2luZy1vbi1kcmFnZ2FibGUtaW4tZmlyZWZveC13aW5kb3dzLXYzMjQvP3RhYj1jb21tZW50cyNjb21tZW50LTEwOTgwMFxuICB2YXIgYyA9IG5ldyBNYXRyaXgyRCgpLFxuICAgICAgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBtLm51bWJlck9mSXRlbXM7IGkrKykge1xuICAgIGMubXVsdGlwbHkobS5nZXRJdGVtKGkpLm1hdHJpeCk7XG4gIH1cblxuICByZXR1cm4gYztcbn0sXG4gICAgX2dldENUTSA9IGZ1bmN0aW9uIF9nZXRDVE0oc3ZnKSB7XG4gIHZhciBtID0gc3ZnLmdldENUTSgpLFxuICAgICAgdHJhbnNmb3JtO1xuXG4gIGlmICghbSkge1xuICAgIC8vIEZpcmVmb3ggcmV0dXJucyBudWxsIGZvciBnZXRDVE0oKSBvbiByb290IDxzdmc+IGVsZW1lbnRzLCBzbyB0aGlzIGlzIGEgd29ya2Fyb3VuZCB1c2luZyBhIDxnPiB0aGF0IHdlIHRlbXBvcmFyaWx5IGFwcGVuZC5cbiAgICB0cmFuc2Zvcm0gPSBzdmcuc3R5bGVbX3RyYW5zZm9ybVByb3BdO1xuICAgIHN2Zy5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSBcIm5vbmVcIjsgLy8gYSBidWcgaW4gRmlyZWZveCBjYXVzZXMgY3NzIHRyYW5zZm9ybXMgdG8gY29udGFtaW5hdGUgdGhlIGdldENUTSgpXG5cbiAgICBzdmcuYXBwZW5kQ2hpbGQoX2dFbCk7XG4gICAgbSA9IF9nRWwuZ2V0Q1RNKCk7XG4gICAgc3ZnLnJlbW92ZUNoaWxkKF9nRWwpO1xuICAgIHRyYW5zZm9ybSA/IHN2Zy5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm0gOiBzdmcuc3R5bGUucmVtb3ZlUHJvcGVydHkoX3RyYW5zZm9ybVByb3AucmVwbGFjZSgvKFtBLVpdKS9nLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIHJldHVybiBtIHx8IF9pZGVudGl0eU1hdHJpeC5jbG9uZSgpOyAvLyBGaXJlZm94IHdpbGwgc3RpbGwgcmV0dXJuIG51bGwgaWYgdGhlIDxzdmc+IGhhcyBhIHdpZHRoL2hlaWdodCBvZiAwIGluIHRoZSBicm93c2VyLlxufSxcbiAgICBfcGxhY2VTaWJsaW5ncyA9IGZ1bmN0aW9uIF9wbGFjZVNpYmxpbmdzKGVsZW1lbnQsIGFkanVzdEdPZmZzZXQpIHtcbiAgdmFyIHN2ZyA9IF9zdmdPd25lcihlbGVtZW50KSxcbiAgICAgIGlzUm9vdFNWRyA9IGVsZW1lbnQgPT09IHN2ZyxcbiAgICAgIHNpYmxpbmdzID0gc3ZnID8gX3N2Z1RlbXBzIDogX2RpdlRlbXBzLFxuICAgICAgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgbSxcbiAgICAgIGIsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGNzO1xuXG4gIGlmIChlbGVtZW50ID09PSBfd2luKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBzaWJsaW5ncy5sZW5ndGggfHwgc2libGluZ3MucHVzaChfY3JlYXRlU2libGluZyhlbGVtZW50LCAxKSwgX2NyZWF0ZVNpYmxpbmcoZWxlbWVudCwgMiksIF9jcmVhdGVTaWJsaW5nKGVsZW1lbnQsIDMpKTtcbiAgY29udGFpbmVyID0gc3ZnID8gX3N2Z0NvbnRhaW5lciA6IF9kaXZDb250YWluZXI7XG5cbiAgaWYgKHN2Zykge1xuICAgIGlmIChpc1Jvb3RTVkcpIHtcbiAgICAgIGIgPSBfZ2V0Q1RNKGVsZW1lbnQpO1xuICAgICAgeCA9IC1iLmUgLyBiLmE7XG4gICAgICB5ID0gLWIuZiAvIGIuZDtcbiAgICAgIG0gPSBfaWRlbnRpdHlNYXRyaXg7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LmdldEJCb3gpIHtcbiAgICAgIGIgPSBlbGVtZW50LmdldEJCb3goKTtcbiAgICAgIG0gPSBlbGVtZW50LnRyYW5zZm9ybSA/IGVsZW1lbnQudHJhbnNmb3JtLmJhc2VWYWwgOiB7fTsgLy8gSUUxMSBkb2Vzbid0IGZvbGxvdyB0aGUgc3BlYy5cblxuICAgICAgbSA9ICFtLm51bWJlck9mSXRlbXMgPyBfaWRlbnRpdHlNYXRyaXggOiBtLm51bWJlck9mSXRlbXMgPiAxID8gX2NvbnNvbGlkYXRlKG0pIDogbS5nZXRJdGVtKDApLm1hdHJpeDsgLy8gZG9uJ3QgY2FsbCBtLmNvbnNvbGlkYXRlKCkubWF0cml4IGJlY2F1c2UgYSBidWcgaW4gRmlyZWZveCBtYWtlcyBwb2ludGVyIGV2ZW50cyBub3Qgd29yayB3aGVuIGNvbnNvbGlkYXRlKCkgaXMgY2FsbGVkIG9uIHRoZSBzYW1lIHRpY2sgYXMgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkhIFNlZSBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8yMzI0OC10b3VjaC1pcy1ub3Qtd29ya2luZy1vbi1kcmFnZ2FibGUtaW4tZmlyZWZveC13aW5kb3dzLXYzMjQvP3RhYj1jb21tZW50cyNjb21tZW50LTEwOTgwMFxuXG4gICAgICB4ID0gbS5hICogYi54ICsgbS5jICogYi55O1xuICAgICAgeSA9IG0uYiAqIGIueCArIG0uZCAqIGIueTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbWF5IGJlIGEgPG1hc2s+IHdoaWNoIGhhcyBubyBnZXRCQm94KCkgc28ganVzdCB1c2UgZGVmYXVsdHMgaW5zdGVhZCBvZiB0aHJvd2luZyBlcnJvcnMuXG4gICAgICBtID0gbmV3IE1hdHJpeDJEKCk7XG4gICAgICB4ID0geSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGFkanVzdEdPZmZzZXQgJiYgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZ1wiKSB7XG4gICAgICB4ID0geSA9IDA7XG4gICAgfVxuXG4gICAgKGlzUm9vdFNWRyA/IHN2ZyA6IHBhcmVudCkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwibWF0cml4KFwiICsgbS5hICsgXCIsXCIgKyBtLmIgKyBcIixcIiArIG0uYyArIFwiLFwiICsgbS5kICsgXCIsXCIgKyAobS5lICsgeCkgKyBcIixcIiArIChtLmYgKyB5KSArIFwiKVwiKTtcbiAgfSBlbHNlIHtcbiAgICB4ID0geSA9IDA7XG5cbiAgICBpZiAoX2hhc09mZnNldEJ1Zykge1xuICAgICAgLy8gc29tZSBicm93c2VycyAobGlrZSBTYWZhcmkpIGhhdmUgYSBidWcgdGhhdCBjYXVzZXMgdGhlbSB0byBtaXNyZXBvcnQgb2Zmc2V0IHZhbHVlcy4gV2hlbiBhbiBhbmNlc3RvciBlbGVtZW50IGhhcyBhIHRyYW5zZm9ybSBhcHBsaWVkLCBpdCdzIHN1cHBvc2VkIHRvIHRyZWF0IGl0IGFzIGlmIGl0J3MgcG9zaXRpb246IHJlbGF0aXZlIChuZXcgY29udGV4dCkuIFNhZmFyaSBib3RjaGVzIHRoaXMsIHNvIHdlIG5lZWQgdG8gZmluZCB0aGUgY2xvc2VzdCBhbmNlc3RvciAoYmV0d2VlbiB0aGUgZWxlbWVudCBhbmQgaXRzIG9mZnNldFBhcmVudCkgdGhhdCBoYXMgYSB0cmFuc2Zvcm0gYXBwbGllZCBhbmQgaWYgb25lIGlzIGZvdW5kLCBncmFiIGl0cyBvZmZzZXRUb3AvTGVmdCBhbmQgc3VidHJhY3QgdGhlbSB0byBjb21wZW5zYXRlLlxuICAgICAgbSA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAgICAgYiA9IGVsZW1lbnQ7XG5cbiAgICAgIHdoaWxlIChiICYmIChiID0gYi5wYXJlbnROb2RlKSAmJiBiICE9PSBtICYmIGIucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoKF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShiKVtfdHJhbnNmb3JtUHJvcF0gKyBcIlwiKS5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgeCA9IGIub2Zmc2V0TGVmdDtcbiAgICAgICAgICB5ID0gYi5vZmZzZXRUb3A7XG4gICAgICAgICAgYiA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjcyA9IF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChjcy5wb3NpdGlvbiAhPT0gXCJhYnNvbHV0ZVwiICYmIGNzLnBvc2l0aW9uICE9PSBcImZpeGVkXCIpIHtcbiAgICAgIG0gPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcblxuICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQgIT09IG0pIHtcbiAgICAgICAgLy8gaWYgdGhlcmUncyBhbiBhbmNlc3RvciBlbGVtZW50IGJldHdlZW4gdGhlIGVsZW1lbnQgYW5kIGl0cyBvZmZzZXRQYXJlbnQgdGhhdCdzIHNjcm9sbGVkLCB3ZSBtdXN0IGZhY3RvciB0aGF0IGluLlxuICAgICAgICB4ICs9IHBhcmVudC5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgIHkgKz0gcGFyZW50LnNjcm9sbFRvcCB8fCAwO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiID0gY29udGFpbmVyLnN0eWxlO1xuICAgIGIudG9wID0gZWxlbWVudC5vZmZzZXRUb3AgLSB5ICsgXCJweFwiO1xuICAgIGIubGVmdCA9IGVsZW1lbnQub2Zmc2V0TGVmdCAtIHggKyBcInB4XCI7XG4gICAgYltfdHJhbnNmb3JtUHJvcF0gPSBjc1tfdHJhbnNmb3JtUHJvcF07XG4gICAgYltfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBjc1tfdHJhbnNmb3JtT3JpZ2luUHJvcF07IC8vIGIuYm9yZGVyID0gbS5ib3JkZXI7XG4gICAgLy8gYi5ib3JkZXJMZWZ0U3R5bGUgPSBtLmJvcmRlckxlZnRTdHlsZTtcbiAgICAvLyBiLmJvcmRlclRvcFN0eWxlID0gbS5ib3JkZXJUb3BTdHlsZTtcbiAgICAvLyBiLmJvcmRlckxlZnRXaWR0aCA9IG0uYm9yZGVyTGVmdFdpZHRoO1xuICAgIC8vIGIuYm9yZGVyVG9wV2lkdGggPSBtLmJvcmRlclRvcFdpZHRoO1xuXG4gICAgYi5wb3NpdGlvbiA9IGNzLnBvc2l0aW9uID09PSBcImZpeGVkXCIgPyBcImZpeGVkXCIgOiBcImFic29sdXRlXCI7XG4gICAgZWxlbWVudC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gIH1cblxuICByZXR1cm4gY29udGFpbmVyO1xufSxcbiAgICBfc2V0TWF0cml4ID0gZnVuY3Rpb24gX3NldE1hdHJpeChtLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIG0uYSA9IGE7XG4gIG0uYiA9IGI7XG4gIG0uYyA9IGM7XG4gIG0uZCA9IGQ7XG4gIG0uZSA9IGU7XG4gIG0uZiA9IGY7XG4gIHJldHVybiBtO1xufTtcblxuZXhwb3J0IHZhciBNYXRyaXgyRCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hdHJpeDJEKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBpZiAoYSA9PT0gdm9pZCAwKSB7XG4gICAgICBhID0gMTtcbiAgICB9XG5cbiAgICBpZiAoYiA9PT0gdm9pZCAwKSB7XG4gICAgICBiID0gMDtcbiAgICB9XG5cbiAgICBpZiAoYyA9PT0gdm9pZCAwKSB7XG4gICAgICBjID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZCA9PT0gdm9pZCAwKSB7XG4gICAgICBkID0gMTtcbiAgICB9XG5cbiAgICBpZiAoZSA9PT0gdm9pZCAwKSB7XG4gICAgICBlID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZiA9PT0gdm9pZCAwKSB7XG4gICAgICBmID0gMDtcbiAgICB9XG5cbiAgICBfc2V0TWF0cml4KHRoaXMsIGEsIGIsIGMsIGQsIGUsIGYpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE1hdHJpeDJELnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW52ZXJzZSA9IGZ1bmN0aW9uIGludmVyc2UoKSB7XG4gICAgdmFyIGEgPSB0aGlzLmEsXG4gICAgICAgIGIgPSB0aGlzLmIsXG4gICAgICAgIGMgPSB0aGlzLmMsXG4gICAgICAgIGQgPSB0aGlzLmQsXG4gICAgICAgIGUgPSB0aGlzLmUsXG4gICAgICAgIGYgPSB0aGlzLmYsXG4gICAgICAgIGRldGVybWluYW50ID0gYSAqIGQgLSBiICogYyB8fCAxZS0xMDtcbiAgICByZXR1cm4gX3NldE1hdHJpeCh0aGlzLCBkIC8gZGV0ZXJtaW5hbnQsIC1iIC8gZGV0ZXJtaW5hbnQsIC1jIC8gZGV0ZXJtaW5hbnQsIGEgLyBkZXRlcm1pbmFudCwgKGMgKiBmIC0gZCAqIGUpIC8gZGV0ZXJtaW5hbnQsIC0oYSAqIGYgLSBiICogZSkgLyBkZXRlcm1pbmFudCk7XG4gIH07XG5cbiAgX3Byb3RvLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobWF0cml4KSB7XG4gICAgdmFyIGEgPSB0aGlzLmEsXG4gICAgICAgIGIgPSB0aGlzLmIsXG4gICAgICAgIGMgPSB0aGlzLmMsXG4gICAgICAgIGQgPSB0aGlzLmQsXG4gICAgICAgIGUgPSB0aGlzLmUsXG4gICAgICAgIGYgPSB0aGlzLmYsXG4gICAgICAgIGEyID0gbWF0cml4LmEsXG4gICAgICAgIGIyID0gbWF0cml4LmMsXG4gICAgICAgIGMyID0gbWF0cml4LmIsXG4gICAgICAgIGQyID0gbWF0cml4LmQsXG4gICAgICAgIGUyID0gbWF0cml4LmUsXG4gICAgICAgIGYyID0gbWF0cml4LmY7XG4gICAgcmV0dXJuIF9zZXRNYXRyaXgodGhpcywgYTIgKiBhICsgYzIgKiBjLCBhMiAqIGIgKyBjMiAqIGQsIGIyICogYSArIGQyICogYywgYjIgKiBiICsgZDIgKiBkLCBlICsgZTIgKiBhICsgZjIgKiBjLCBmICsgZTIgKiBiICsgZjIgKiBkKTtcbiAgfTtcblxuICBfcHJvdG8uY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDJEKHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRoaXMuZCwgdGhpcy5lLCB0aGlzLmYpO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMobWF0cml4KSB7XG4gICAgdmFyIGEgPSB0aGlzLmEsXG4gICAgICAgIGIgPSB0aGlzLmIsXG4gICAgICAgIGMgPSB0aGlzLmMsXG4gICAgICAgIGQgPSB0aGlzLmQsXG4gICAgICAgIGUgPSB0aGlzLmUsXG4gICAgICAgIGYgPSB0aGlzLmY7XG4gICAgcmV0dXJuIGEgPT09IG1hdHJpeC5hICYmIGIgPT09IG1hdHJpeC5iICYmIGMgPT09IG1hdHJpeC5jICYmIGQgPT09IG1hdHJpeC5kICYmIGUgPT09IG1hdHJpeC5lICYmIGYgPT09IG1hdHJpeC5mO1xuICB9O1xuXG4gIF9wcm90by5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5KHBvaW50LCBkZWNvcmF0ZWUpIHtcbiAgICBpZiAoZGVjb3JhdGVlID09PSB2b2lkIDApIHtcbiAgICAgIGRlY29yYXRlZSA9IHt9O1xuICAgIH1cblxuICAgIHZhciB4ID0gcG9pbnQueCxcbiAgICAgICAgeSA9IHBvaW50LnksXG4gICAgICAgIGEgPSB0aGlzLmEsXG4gICAgICAgIGIgPSB0aGlzLmIsXG4gICAgICAgIGMgPSB0aGlzLmMsXG4gICAgICAgIGQgPSB0aGlzLmQsXG4gICAgICAgIGUgPSB0aGlzLmUsXG4gICAgICAgIGYgPSB0aGlzLmY7XG4gICAgZGVjb3JhdGVlLnggPSB4ICogYSArIHkgKiBjICsgZSB8fCAwO1xuICAgIGRlY29yYXRlZS55ID0geCAqIGIgKyB5ICogZCArIGYgfHwgMDtcbiAgICByZXR1cm4gZGVjb3JhdGVlO1xuICB9O1xuXG4gIHJldHVybiBNYXRyaXgyRDtcbn0oKTsgLy8gRmVlZCBpbiBhbiBlbGVtZW50IGFuZCBpdCdsbCByZXR1cm4gYSAyRCBtYXRyaXggKG9wdGlvbmFsbHkgaW52ZXJ0ZWQpIHNvIHRoYXQgeW91IGNhbiB0cmFuc2xhdGUgYmV0d2VlbiBjb29yZGluYXRlIHNwYWNlcy5cbi8vIEludmVydGluZyBsZXRzIHlvdSB0cmFuc2xhdGUgYSBnbG9iYWwgcG9pbnQgaW50byBhIGxvY2FsIGNvb3JkaW5hdGUgc3BhY2UuIE5vIGludmVydGluZyBsZXRzIHlvdSBnbyB0aGUgb3RoZXIgd2F5LlxuLy8gV2UgbmVlZGVkIHRoaXMgdG8gd29yayBhcm91bmQgdmFyaW91cyBicm93c2VyIGJ1Z3MsIGxpa2UgRmlyZWZveCBkb2Vzbid0IGFjY3VyYXRlbHkgcmVwb3J0IGdldFNjcmVlbkNUTSgpIHdoZW4gdGhlcmVcbi8vIGFyZSB0cmFuc2Zvcm1zIGFwcGxpZWQgdG8gYW5jZXN0b3IgZWxlbWVudHMuXG4vLyBUaGUgbWF0cml4IG1hdGggdG8gY29udmVydCBhbnkgeC95IGNvb3JkaW5hdGUgaXMgYXMgZm9sbG93cywgd2hpY2ggaXMgd3JhcHBlZCBpbiBhIGNvbnZlbmllbnQgYXBwbHkoKSBtZXRob2Qgb2YgTWF0cml4MkQgYWJvdmU6XG4vLyAgICAgdHggPSBtLmEgKiB4ICsgbS5jICogeSArIG0uZVxuLy8gICAgIHR5ID0gbS5iICogeCArIG0uZCAqIHkgKyBtLmZcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEdsb2JhbE1hdHJpeChlbGVtZW50LCBpbnZlcnNlLCBhZGp1c3RHT2Zmc2V0LCBpbmNsdWRlU2Nyb2xsSW5GaXhlZCkge1xuICAvLyBhZGp1c3RHT2Zmc2V0IGlzIHR5cGljYWxseSB1c2VkIG9ubHkgd2hlbiBncmFiYmluZyBhbiBlbGVtZW50J3MgUEFSRU5UJ3MgZ2xvYmFsIG1hdHJpeCwgYW5kIGl0IGlnbm9yZXMgdGhlIHgveSBvZmZzZXQgb2YgYW55IFNWRyA8Zz4gZWxlbWVudHMgYmVjYXVzZSB0aGV5IGJlaGF2ZSBpbiBhIHNwZWNpYWwgd2F5LlxuICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQucGFyZW50Tm9kZSB8fCAoX2RvYyB8fCBfc2V0RG9jKGVsZW1lbnQpKS5kb2N1bWVudEVsZW1lbnQgPT09IGVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDJEKCk7XG4gIH1cblxuICB2YXIgemVyb1NjYWxlcyA9IF9mb3JjZU5vblplcm9TY2FsZShlbGVtZW50KSxcbiAgICAgIHN2ZyA9IF9zdmdPd25lcihlbGVtZW50KSxcbiAgICAgIHRlbXBzID0gc3ZnID8gX3N2Z1RlbXBzIDogX2RpdlRlbXBzLFxuICAgICAgY29udGFpbmVyID0gX3BsYWNlU2libGluZ3MoZWxlbWVudCwgYWRqdXN0R09mZnNldCksXG4gICAgICBiMSA9IHRlbXBzWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgYjIgPSB0ZW1wc1sxXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGIzID0gdGVtcHNbMl0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBwYXJlbnQgPSBjb250YWluZXIucGFyZW50Tm9kZSxcbiAgICAgIGlzRml4ZWQgPSAhaW5jbHVkZVNjcm9sbEluRml4ZWQgJiYgX2lzRml4ZWQoZWxlbWVudCksXG4gICAgICBtID0gbmV3IE1hdHJpeDJEKChiMi5sZWZ0IC0gYjEubGVmdCkgLyAxMDAsIChiMi50b3AgLSBiMS50b3ApIC8gMTAwLCAoYjMubGVmdCAtIGIxLmxlZnQpIC8gMTAwLCAoYjMudG9wIC0gYjEudG9wKSAvIDEwMCwgYjEubGVmdCArIChpc0ZpeGVkID8gMCA6IF9nZXREb2NTY3JvbGxMZWZ0KCkpLCBiMS50b3AgKyAoaXNGaXhlZCA/IDAgOiBfZ2V0RG9jU2Nyb2xsVG9wKCkpKTtcblxuICBwYXJlbnQucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcblxuICBpZiAoemVyb1NjYWxlcykge1xuICAgIGIxID0gemVyb1NjYWxlcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoYjEtLSkge1xuICAgICAgYjIgPSB6ZXJvU2NhbGVzW2IxXTtcbiAgICAgIGIyLnNjYWxlWCA9IGIyLnNjYWxlWSA9IDA7XG4gICAgICBiMi5yZW5kZXJUcmFuc2Zvcm0oMSwgYjIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnZlcnNlID8gbS5pbnZlcnNlKCkgOiBtO1xufVxuZXhwb3J0IHsgX2dldERvY1Njcm9sbFRvcCwgX2dldERvY1Njcm9sbExlZnQsIF9zZXREb2MsIF9pc0ZpeGVkLCBfZ2V0Q1RNIH07IC8vIGV4cG9ydCBmdW5jdGlvbiBnZXRNYXRyaXgoZWxlbWVudCkge1xuLy8gXHRfZG9jIHx8IF9zZXREb2MoZWxlbWVudCk7XG4vLyBcdGxldCBtID0gKF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVtfdHJhbnNmb3JtUHJvcF0gKyBcIlwiKS5zdWJzdHIoNykubWF0Y2goL1stLl0qXFxkK1suZVxcLStdKlxcZCpbZVxcLVxcK10qXFxkKi9nKSxcbi8vIFx0XHRpczJEID0gbSAmJiBtLmxlbmd0aCA9PT0gNjtcbi8vIFx0cmV0dXJuICFtIHx8IG0ubGVuZ3RoIDwgNiA/IG5ldyBNYXRyaXgyRCgpIDogbmV3IE1hdHJpeDJEKCttWzBdLCArbVsxXSwgK21baXMyRCA/IDIgOiA0XSwgK21baXMyRCA/IDMgOiA1XSwgK21baXMyRCA/IDQgOiAxMl0sICttW2lzMkQgPyA1IDogMTNdKTtcbi8vIH0iXSwibmFtZXMiOlsiX2RvYyIsIl93aW4iLCJfZG9jRWxlbWVudCIsIl9ib2R5IiwiX2RpdkNvbnRhaW5lciIsIl9zdmdDb250YWluZXIiLCJfaWRlbnRpdHlNYXRyaXgiLCJfZ0VsIiwiX3RyYW5zZm9ybVByb3AiLCJfdHJhbnNmb3JtT3JpZ2luUHJvcCIsIl9oYXNPZmZzZXRCdWciLCJfc2V0RG9jIiwiZWxlbWVudCIsImRvYyIsIm93bmVyRG9jdW1lbnQiLCJzdHlsZSIsInBhcmVudE5vZGUiLCJ3aW5kb3ciLCJNYXRyaXgyRCIsImRvY3VtZW50RWxlbWVudCIsImJvZHkiLCJjcmVhdGVFbGVtZW50TlMiLCJ0cmFuc2Zvcm0iLCJkMSIsImNyZWF0ZUVsZW1lbnQiLCJkMiIsInJvb3QiLCJmaXJzdEVsZW1lbnRDaGlsZCIsImFwcGVuZENoaWxkIiwic2V0QXR0cmlidXRlIiwib2Zmc2V0UGFyZW50IiwicmVtb3ZlQ2hpbGQiLCJfZm9yY2VOb25aZXJvU2NhbGUiLCJlIiwiYSIsImNhY2hlIiwiX2dzYXAiLCJ1bmNhY2hlIiwiZ2V0Iiwic2NhbGVYIiwic2NhbGVZIiwicmVuZGVyVHJhbnNmb3JtIiwicHVzaCIsIl9zdmdUZW1wcyIsIl9kaXZUZW1wcyIsIl9nZXREb2NTY3JvbGxUb3AiLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsIl9nZXREb2NTY3JvbGxMZWZ0IiwicGFnZVhPZmZzZXQiLCJzY3JvbGxMZWZ0IiwiX3N2Z093bmVyIiwib3duZXJTVkdFbGVtZW50IiwidGFnTmFtZSIsInRvTG93ZXJDYXNlIiwiX2lzRml4ZWQiLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJub2RlVHlwZSIsIl9jcmVhdGVTaWJsaW5nIiwiaSIsInN2ZyIsIm5zIiwiZ2V0QXR0cmlidXRlIiwidHlwZSIsIngiLCJ5IiwiY3NzIiwicmVwbGFjZSIsImNzc1RleHQiLCJfY29uc29saWRhdGUiLCJtIiwiYyIsIm51bWJlck9mSXRlbXMiLCJtdWx0aXBseSIsImdldEl0ZW0iLCJtYXRyaXgiLCJfZ2V0Q1RNIiwiZ2V0Q1RNIiwicmVtb3ZlUHJvcGVydHkiLCJjbG9uZSIsIl9wbGFjZVNpYmxpbmdzIiwiYWRqdXN0R09mZnNldCIsImlzUm9vdFNWRyIsInNpYmxpbmdzIiwicGFyZW50IiwiY29udGFpbmVyIiwiYiIsImNzIiwibGVuZ3RoIiwiZiIsImQiLCJnZXRCQm94IiwiYmFzZVZhbCIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJ0b3AiLCJsZWZ0IiwiX3NldE1hdHJpeCIsIl9wcm90byIsInByb3RvdHlwZSIsImludmVyc2UiLCJkZXRlcm1pbmFudCIsImEyIiwiYjIiLCJjMiIsImUyIiwiZjIiLCJlcXVhbHMiLCJhcHBseSIsInBvaW50IiwiZGVjb3JhdGVlIiwiZ2V0R2xvYmFsTWF0cml4IiwiaW5jbHVkZVNjcm9sbEluRml4ZWQiLCJ6ZXJvU2NhbGVzIiwidGVtcHMiLCJiMSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImIzIiwiaXNGaXhlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/matrix.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/paths.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/paths.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bezierToPoints: function() { return /* binding */ bezierToPoints; },\n/* harmony export */   cacheRawPathMeasurements: function() { return /* binding */ cacheRawPathMeasurements; },\n/* harmony export */   convertToPath: function() { return /* binding */ convertToPath; },\n/* harmony export */   copyRawPath: function() { return /* binding */ copyRawPath; },\n/* harmony export */   flatPointsToSegment: function() { return /* binding */ flatPointsToSegment; },\n/* harmony export */   getClosestData: function() { return /* binding */ getClosestData; },\n/* harmony export */   getPositionOnPath: function() { return /* binding */ getPositionOnPath; },\n/* harmony export */   getRawPath: function() { return /* binding */ getRawPath; },\n/* harmony export */   getRotationAtProgress: function() { return /* binding */ getRotationAtProgress; },\n/* harmony export */   pointsToSegment: function() { return /* binding */ pointsToSegment; },\n/* harmony export */   rawPathToString: function() { return /* binding */ rawPathToString; },\n/* harmony export */   reverseSegment: function() { return /* binding */ reverseSegment; },\n/* harmony export */   simplifyPoints: function() { return /* binding */ simplifyPoints; },\n/* harmony export */   sliceRawPath: function() { return /* binding */ sliceRawPath; },\n/* harmony export */   stringToRawPath: function() { return /* binding */ stringToRawPath; },\n/* harmony export */   subdivideSegment: function() { return /* binding */ subdivideSegment; },\n/* harmony export */   subdivideSegmentNear: function() { return /* binding */ subdivideSegmentNear; },\n/* harmony export */   transformRawPath: function() { return /* binding */ transformRawPath; }\n/* harmony export */ });\n/*!\n * paths 3.12.5\n * https://gsap.com\n *\n * Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var _svgPathExp = /[achlmqstvz]|(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig, _numbersExp = /(?:(-)?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig, _scientific = /[\\+\\-]?\\d*\\.?\\d+e[\\+\\-]?\\d+/ig, _selectorExp = /(^[#\\.][a-z]|[a-y][a-z])/i, _DEG2RAD = Math.PI / 180, _RAD2DEG = 180 / Math.PI, _sin = Math.sin, _cos = Math.cos, _abs = Math.abs, _sqrt = Math.sqrt, _atan2 = Math.atan2, _largeNum = 1e8, _isString = function _isString(value) {\n    return typeof value === \"string\";\n}, _isNumber = function _isNumber(value) {\n    return typeof value === \"number\";\n}, _isUndefined = function _isUndefined(value) {\n    return typeof value === \"undefined\";\n}, _temp = {}, _temp2 = {}, _roundingNum = 1e5, _wrapProgress = function _wrapProgress(progress) {\n    return Math.round((progress + _largeNum) % 1 * _roundingNum) / _roundingNum || (progress < 0 ? 0 : 1);\n}, //if progress lands on 1, the % will make it 0 which is why we || 1, but not if it's negative because it makes more sense for motion to end at 0 in that case.\n_round = function _round(value) {\n    return Math.round(value * _roundingNum) / _roundingNum || 0;\n}, _roundPrecise = function _roundPrecise(value) {\n    return Math.round(value * 1e10) / 1e10 || 0;\n}, _splitSegment = function _splitSegment(rawPath, segIndex, i, t) {\n    var segment = rawPath[segIndex], shift = t === 1 ? 6 : subdivideSegment(segment, i, t);\n    if ((shift || !t) && shift + i + 2 < segment.length) {\n        rawPath.splice(segIndex, 0, segment.slice(0, i + shift + 2));\n        segment.splice(0, i + shift);\n        return 1;\n    }\n}, _getSampleIndex = function _getSampleIndex(samples, length, progress) {\n    // slightly slower way than doing this (when there's no lookup): segment.lookup[progress < 1 ? ~~(length / segment.minLength) : segment.lookup.length - 1] || 0;\n    var l = samples.length, i = ~~(progress * l);\n    if (samples[i] > length) {\n        while(--i && samples[i] > length){}\n        i < 0 && (i = 0);\n    } else {\n        while(samples[++i] < length && i < l){}\n    }\n    return i < l ? i : l - 1;\n}, _reverseRawPath = function _reverseRawPath(rawPath, skipOuter) {\n    var i = rawPath.length;\n    skipOuter || rawPath.reverse();\n    while(i--){\n        rawPath[i].reversed || reverseSegment(rawPath[i]);\n    }\n}, _copyMetaData = function _copyMetaData(source, copy) {\n    copy.totalLength = source.totalLength;\n    if (source.samples) {\n        //segment\n        copy.samples = source.samples.slice(0);\n        copy.lookup = source.lookup.slice(0);\n        copy.minLength = source.minLength;\n        copy.resolution = source.resolution;\n    } else if (source.totalPoints) {\n        //rawPath\n        copy.totalPoints = source.totalPoints;\n    }\n    return copy;\n}, //pushes a new segment into a rawPath, but if its starting values match the ending values of the last segment, it'll merge it into that same segment (to reduce the number of segments)\n_appendOrMerge = function _appendOrMerge(rawPath, segment) {\n    var index = rawPath.length, prevSeg = rawPath[index - 1] || [], l = prevSeg.length;\n    if (index && segment[0] === prevSeg[l - 2] && segment[1] === prevSeg[l - 1]) {\n        segment = prevSeg.concat(segment.slice(2));\n        index--;\n    }\n    rawPath[index] = segment;\n}, _bestDistance;\n/* TERMINOLOGY\n - RawPath - an array of arrays, one for each Segment. A single RawPath could have multiple \"M\" commands, defining Segments (paths aren't always connected).\n - Segment - an array containing a sequence of Cubic Bezier coordinates in alternating x, y, x, y format. Starting anchor, then control point 1, control point 2, and ending anchor, then the next control point 1, control point 2, anchor, etc. Uses less memory than an array with a bunch of {x, y} points.\n - Bezier - a single cubic Bezier with a starting anchor, two control points, and an ending anchor.\n - the variable \"t\" is typically the position along an individual Bezier path (time) and it's NOT linear, meaning it could accelerate/decelerate based on the control points whereas the \"p\" or \"progress\" value is linearly mapped to the whole path, so it shouldn't really accelerate/decelerate based on control points. So a progress of 0.2 would be almost exactly 20% along the path. \"t\" is ONLY in an individual Bezier piece.\n */ //accepts basic selector text, a path instance, a RawPath instance, or a Segment and returns a RawPath (makes it easy to homogenize things). If an element or selector text is passed in, it'll also cache the value so that if it's queried again, it'll just take the path data from there instead of parsing it all over again (as long as the path data itself hasn't changed - it'll check).\nfunction getRawPath(value) {\n    value = _isString(value) && _selectorExp.test(value) ? document.querySelector(value) || value : value;\n    var e = value.getAttribute ? value : 0, rawPath;\n    if (e && (value = value.getAttribute(\"d\"))) {\n        //implements caching\n        if (!e._gsPath) {\n            e._gsPath = {};\n        }\n        rawPath = e._gsPath[value];\n        return rawPath && !rawPath._dirty ? rawPath : e._gsPath[value] = stringToRawPath(value);\n    }\n    return !value ? console.warn(\"Expecting a <path> element or an SVG path data string\") : _isString(value) ? stringToRawPath(value) : _isNumber(value[0]) ? [\n        value\n    ] : value;\n} //copies a RawPath WITHOUT the length meta data (for speed)\nfunction copyRawPath(rawPath) {\n    var a = [], i = 0;\n    for(; i < rawPath.length; i++){\n        a[i] = _copyMetaData(rawPath[i], rawPath[i].slice(0));\n    }\n    return _copyMetaData(rawPath, a);\n}\nfunction reverseSegment(segment) {\n    var i = 0, y;\n    segment.reverse(); //this will invert the order y, x, y, x so we must flip it back.\n    for(; i < segment.length; i += 2){\n        y = segment[i];\n        segment[i] = segment[i + 1];\n        segment[i + 1] = y;\n    }\n    segment.reversed = !segment.reversed;\n}\nvar _createPath = function _createPath(e, ignore) {\n    var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\"), attr = [].slice.call(e.attributes), i = attr.length, name;\n    ignore = \",\" + ignore + \",\";\n    while(--i > -1){\n        name = attr[i].nodeName.toLowerCase(); //in Microsoft Edge, if you don't set the attribute with a lowercase name, it doesn't render correctly! Super weird.\n        if (ignore.indexOf(\",\" + name + \",\") < 0) {\n            path.setAttributeNS(null, name, attr[i].nodeValue);\n        }\n    }\n    return path;\n}, _typeAttrs = {\n    rect: \"rx,ry,x,y,width,height\",\n    circle: \"r,cx,cy\",\n    ellipse: \"rx,ry,cx,cy\",\n    line: \"x1,x2,y1,y2\"\n}, _attrToObj = function _attrToObj(e, attrs) {\n    var props = attrs ? attrs.split(\",\") : [], obj = {}, i = props.length;\n    while(--i > -1){\n        obj[props[i]] = +e.getAttribute(props[i]) || 0;\n    }\n    return obj;\n}; //converts an SVG shape like <circle>, <rect>, <polygon>, <polyline>, <ellipse>, etc. to a <path>, swapping it in and copying the attributes to match.\nfunction convertToPath(element, swap) {\n    var type = element.tagName.toLowerCase(), circ = 0.552284749831, data, x, y, r, ry, path, rcirc, rycirc, points, w, h, x2, x3, x4, x5, x6, y2, y3, y4, y5, y6, attr;\n    if (type === \"path\" || !element.getBBox) {\n        return element;\n    }\n    path = _createPath(element, \"x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points\");\n    attr = _attrToObj(element, _typeAttrs[type]);\n    if (type === \"rect\") {\n        r = attr.rx;\n        ry = attr.ry || r;\n        x = attr.x;\n        y = attr.y;\n        w = attr.width - r * 2;\n        h = attr.height - ry * 2;\n        if (r || ry) {\n            //if there are rounded corners, render cubic beziers\n            x2 = x + r * (1 - circ);\n            x3 = x + r;\n            x4 = x3 + w;\n            x5 = x4 + r * circ;\n            x6 = x4 + r;\n            y2 = y + ry * (1 - circ);\n            y3 = y + ry;\n            y4 = y3 + h;\n            y5 = y4 + ry * circ;\n            y6 = y4 + ry;\n            data = \"M\" + x6 + \",\" + y3 + \" V\" + y4 + \" C\" + [\n                x6,\n                y5,\n                x5,\n                y6,\n                x4,\n                y6,\n                x4 - (x4 - x3) / 3,\n                y6,\n                x3 + (x4 - x3) / 3,\n                y6,\n                x3,\n                y6,\n                x2,\n                y6,\n                x,\n                y5,\n                x,\n                y4,\n                x,\n                y4 - (y4 - y3) / 3,\n                x,\n                y3 + (y4 - y3) / 3,\n                x,\n                y3,\n                x,\n                y2,\n                x2,\n                y,\n                x3,\n                y,\n                x3 + (x4 - x3) / 3,\n                y,\n                x4 - (x4 - x3) / 3,\n                y,\n                x4,\n                y,\n                x5,\n                y,\n                x6,\n                y2,\n                x6,\n                y3\n            ].join(\",\") + \"z\";\n        } else {\n            data = \"M\" + (x + w) + \",\" + y + \" v\" + h + \" h\" + -w + \" v\" + -h + \" h\" + w + \"z\";\n        }\n    } else if (type === \"circle\" || type === \"ellipse\") {\n        if (type === \"circle\") {\n            r = ry = attr.r;\n            rycirc = r * circ;\n        } else {\n            r = attr.rx;\n            ry = attr.ry;\n            rycirc = ry * circ;\n        }\n        x = attr.cx;\n        y = attr.cy;\n        rcirc = r * circ;\n        data = \"M\" + (x + r) + \",\" + y + \" C\" + [\n            x + r,\n            y + rycirc,\n            x + rcirc,\n            y + ry,\n            x,\n            y + ry,\n            x - rcirc,\n            y + ry,\n            x - r,\n            y + rycirc,\n            x - r,\n            y,\n            x - r,\n            y - rycirc,\n            x - rcirc,\n            y - ry,\n            x,\n            y - ry,\n            x + rcirc,\n            y - ry,\n            x + r,\n            y - rycirc,\n            x + r,\n            y\n        ].join(\",\") + \"z\";\n    } else if (type === \"line\") {\n        data = \"M\" + attr.x1 + \",\" + attr.y1 + \" L\" + attr.x2 + \",\" + attr.y2; //previously, we just converted to \"Mx,y Lx,y\" but Safari has bugs that cause that not to render properly when using a stroke-dasharray that's not fully visible! Using a cubic bezier fixes that issue.\n    } else if (type === \"polyline\" || type === \"polygon\") {\n        points = (element.getAttribute(\"points\") + \"\").match(_numbersExp) || [];\n        x = points.shift();\n        y = points.shift();\n        data = \"M\" + x + \",\" + y + \" L\" + points.join(\",\");\n        if (type === \"polygon\") {\n            data += \",\" + x + \",\" + y + \"z\";\n        }\n    }\n    path.setAttribute(\"d\", rawPathToString(path._gsRawPath = stringToRawPath(data)));\n    if (swap && element.parentNode) {\n        element.parentNode.insertBefore(path, element);\n        element.parentNode.removeChild(element);\n    }\n    return path;\n} //returns the rotation (in degrees) at a particular progress on a rawPath (the slope of the tangent)\nfunction getRotationAtProgress(rawPath, progress) {\n    var d = getProgressData(rawPath, progress >= 1 ? 1 - 1e-9 : progress ? progress : 1e-9);\n    return getRotationAtBezierT(d.segment, d.i, d.t);\n}\nfunction getRotationAtBezierT(segment, i, t) {\n    var a = segment[i], b = segment[i + 2], c = segment[i + 4], x;\n    a += (b - a) * t;\n    b += (c - b) * t;\n    a += (b - a) * t;\n    x = b + (c + (segment[i + 6] - c) * t - b) * t - a;\n    a = segment[i + 1];\n    b = segment[i + 3];\n    c = segment[i + 5];\n    a += (b - a) * t;\n    b += (c - b) * t;\n    a += (b - a) * t;\n    return _round(_atan2(b + (c + (segment[i + 7] - c) * t - b) * t - a, x) * _RAD2DEG);\n}\nfunction sliceRawPath(rawPath, start, end) {\n    end = _isUndefined(end) ? 1 : _roundPrecise(end) || 0; // we must round to avoid issues like 4.15 / 8 = 0.8300000000000001 instead of 0.83 or 2.8 / 5 = 0.5599999999999999 instead of 0.56 and if someone is doing a loop like start: 2.8 / 0.5, end: 2.8 / 0.5 + 1.\n    start = _roundPrecise(start) || 0;\n    var loops = Math.max(0, ~~(_abs(end - start) - 1e-8)), path = copyRawPath(rawPath);\n    if (start > end) {\n        start = 1 - start;\n        end = 1 - end;\n        _reverseRawPath(path);\n        path.totalLength = 0;\n    }\n    if (start < 0 || end < 0) {\n        var offset = Math.abs(~~Math.min(start, end)) + 1;\n        start += offset;\n        end += offset;\n    }\n    path.totalLength || cacheRawPathMeasurements(path);\n    var wrap = end > 1, s = getProgressData(path, start, _temp, true), e = getProgressData(path, end, _temp2), eSeg = e.segment, sSeg = s.segment, eSegIndex = e.segIndex, sSegIndex = s.segIndex, ei = e.i, si = s.i, sameSegment = sSegIndex === eSegIndex, sameBezier = ei === si && sameSegment, wrapsBehind, sShift, eShift, i, copy, totalSegments, l, j;\n    if (wrap || loops) {\n        wrapsBehind = eSegIndex < sSegIndex || sameSegment && ei < si || sameBezier && e.t < s.t;\n        if (_splitSegment(path, sSegIndex, si, s.t)) {\n            sSegIndex++;\n            if (!wrapsBehind) {\n                eSegIndex++;\n                if (sameBezier) {\n                    e.t = (e.t - s.t) / (1 - s.t);\n                    ei = 0;\n                } else if (sameSegment) {\n                    ei -= si;\n                }\n            }\n        }\n        if (Math.abs(1 - (end - start)) < 1e-5) {\n            eSegIndex = sSegIndex - 1;\n        } else if (!e.t && eSegIndex) {\n            eSegIndex--;\n        } else if (_splitSegment(path, eSegIndex, ei, e.t) && wrapsBehind) {\n            sSegIndex++;\n        }\n        if (s.t === 1) {\n            sSegIndex = (sSegIndex + 1) % path.length;\n        }\n        copy = [];\n        totalSegments = path.length;\n        l = 1 + totalSegments * loops;\n        j = sSegIndex;\n        l += (totalSegments - sSegIndex + eSegIndex) % totalSegments;\n        for(i = 0; i < l; i++){\n            _appendOrMerge(copy, path[j++ % totalSegments]);\n        }\n        path = copy;\n    } else {\n        eShift = e.t === 1 ? 6 : subdivideSegment(eSeg, ei, e.t);\n        if (start !== end) {\n            sShift = subdivideSegment(sSeg, si, sameBezier ? s.t / e.t : s.t);\n            sameSegment && (eShift += sShift);\n            eSeg.splice(ei + eShift + 2);\n            (sShift || si) && sSeg.splice(0, si + sShift);\n            i = path.length;\n            while(i--){\n                //chop off any extra segments\n                (i < sSegIndex || i > eSegIndex) && path.splice(i, 1);\n            }\n        } else {\n            eSeg.angle = getRotationAtBezierT(eSeg, ei + eShift, 0); //record the value before we chop because it'll be impossible to determine the angle after its length is 0!\n            ei += eShift;\n            s = eSeg[ei];\n            e = eSeg[ei + 1];\n            eSeg.length = eSeg.totalLength = 0;\n            eSeg.totalPoints = path.totalPoints = 8;\n            eSeg.push(s, e, s, e, s, e, s, e);\n        }\n    }\n    path.totalLength = 0;\n    return path;\n} //measures a Segment according to its resolution (so if segment.resolution is 6, for example, it'll take 6 samples equally across each Bezier) and create/populate a \"samples\" Array that has the length up to each of those sample points (always increasing from the start) as well as a \"lookup\" array that's broken up according to the smallest distance between 2 samples. This gives us a very fast way of looking up a progress position rather than looping through all the points/Beziers. You can optionally have it only measure a subset, starting at startIndex and going for a specific number of beziers (remember, there are 3 x/y pairs each, for a total of 6 elements for each Bezier). It will also populate a \"totalLength\" property, but that's not generally super accurate because by default it'll only take 6 samples per Bezier. But for performance reasons, it's perfectly adequate for measuring progress values along the path. If you need a more accurate totalLength, either increase the resolution or use the more advanced bezierToPoints() method which keeps adding points until they don't deviate by more than a certain precision value.\nfunction measureSegment(segment, startIndex, bezierQty) {\n    startIndex = startIndex || 0;\n    if (!segment.samples) {\n        segment.samples = [];\n        segment.lookup = [];\n    }\n    var resolution = ~~segment.resolution || 12, inc = 1 / resolution, endIndex = bezierQty ? startIndex + bezierQty * 6 + 1 : segment.length, x1 = segment[startIndex], y1 = segment[startIndex + 1], samplesIndex = startIndex ? startIndex / 6 * resolution : 0, samples = segment.samples, lookup = segment.lookup, min = (startIndex ? segment.minLength : _largeNum) || _largeNum, prevLength = samples[samplesIndex + bezierQty * resolution - 1], length = startIndex ? samples[samplesIndex - 1] : 0, i, j, x4, x3, x2, xd, xd1, y4, y3, y2, yd, yd1, inv, t, lengthIndex, l, segLength;\n    samples.length = lookup.length = 0;\n    for(j = startIndex + 2; j < endIndex; j += 6){\n        x4 = segment[j + 4] - x1;\n        x3 = segment[j + 2] - x1;\n        x2 = segment[j] - x1;\n        y4 = segment[j + 5] - y1;\n        y3 = segment[j + 3] - y1;\n        y2 = segment[j + 1] - y1;\n        xd = xd1 = yd = yd1 = 0;\n        if (_abs(x4) < .01 && _abs(y4) < .01 && _abs(x2) + _abs(y2) < .01) {\n            //dump points that are sufficiently close (basically right on top of each other, making a bezier super tiny or 0 length)\n            if (segment.length > 8) {\n                segment.splice(j, 6);\n                j -= 6;\n                endIndex -= 6;\n            }\n        } else {\n            for(i = 1; i <= resolution; i++){\n                t = inc * i;\n                inv = 1 - t;\n                xd = xd1 - (xd1 = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t);\n                yd = yd1 - (yd1 = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t);\n                l = _sqrt(yd * yd + xd * xd);\n                if (l < min) {\n                    min = l;\n                }\n                length += l;\n                samples[samplesIndex++] = length;\n            }\n        }\n        x1 += x4;\n        y1 += y4;\n    }\n    if (prevLength) {\n        prevLength -= length;\n        for(; samplesIndex < samples.length; samplesIndex++){\n            samples[samplesIndex] += prevLength;\n        }\n    }\n    if (samples.length && min) {\n        segment.totalLength = segLength = samples[samples.length - 1] || 0;\n        segment.minLength = min;\n        if (segLength / min < 9999) {\n            // if the lookup would require too many values (memory problem), we skip this and instead we use a loop to lookup values directly in the samples Array\n            l = lengthIndex = 0;\n            for(i = 0; i < segLength; i += min){\n                lookup[l++] = samples[lengthIndex] < i ? ++lengthIndex : lengthIndex;\n            }\n        }\n    } else {\n        segment.totalLength = samples[0] = 0;\n    }\n    return startIndex ? length - samples[startIndex / 2 - 1] : length;\n}\nfunction cacheRawPathMeasurements(rawPath, resolution) {\n    var pathLength, points, i;\n    for(i = pathLength = points = 0; i < rawPath.length; i++){\n        rawPath[i].resolution = ~~resolution || 12; //steps per Bezier curve (anchor, 2 control points, to anchor)\n        points += rawPath[i].length;\n        pathLength += measureSegment(rawPath[i]);\n    }\n    rawPath.totalPoints = points;\n    rawPath.totalLength = pathLength;\n    return rawPath;\n} //divide segment[i] at position t (value between 0 and 1, progress along that particular cubic bezier segment that starts at segment[i]). Returns how many elements were spliced into the segment array (either 0 or 6)\nfunction subdivideSegment(segment, i, t) {\n    if (t <= 0 || t >= 1) {\n        return 0;\n    }\n    var ax = segment[i], ay = segment[i + 1], cp1x = segment[i + 2], cp1y = segment[i + 3], cp2x = segment[i + 4], cp2y = segment[i + 5], bx = segment[i + 6], by = segment[i + 7], x1a = ax + (cp1x - ax) * t, x2 = cp1x + (cp2x - cp1x) * t, y1a = ay + (cp1y - ay) * t, y2 = cp1y + (cp2y - cp1y) * t, x1 = x1a + (x2 - x1a) * t, y1 = y1a + (y2 - y1a) * t, x2a = cp2x + (bx - cp2x) * t, y2a = cp2y + (by - cp2y) * t;\n    x2 += (x2a - x2) * t;\n    y2 += (y2a - y2) * t;\n    segment.splice(i + 2, 4, _round(x1a), _round(y1a), _round(x1), _round(y1), _round(x1 + (x2 - x1) * t), _round(y1 + (y2 - y1) * t), _round(x2), _round(y2), _round(x2a), _round(y2a));\n    segment.samples && segment.samples.splice(i / 6 * segment.resolution | 0, 0, 0, 0, 0, 0, 0, 0);\n    return 6;\n} // returns an object {path, segment, segIndex, i, t}\nfunction getProgressData(rawPath, progress, decoratee, pushToNextIfAtEnd) {\n    decoratee = decoratee || {};\n    rawPath.totalLength || cacheRawPathMeasurements(rawPath);\n    if (progress < 0 || progress > 1) {\n        progress = _wrapProgress(progress);\n    }\n    var segIndex = 0, segment = rawPath[0], samples, resolution, length, min, max, i, t;\n    if (!progress) {\n        t = i = segIndex = 0;\n        segment = rawPath[0];\n    } else if (progress === 1) {\n        t = 1;\n        segIndex = rawPath.length - 1;\n        segment = rawPath[segIndex];\n        i = segment.length - 8;\n    } else {\n        if (rawPath.length > 1) {\n            //speed optimization: most of the time, there's only one segment so skip the recursion.\n            length = rawPath.totalLength * progress;\n            max = i = 0;\n            while((max += rawPath[i++].totalLength) < length){\n                segIndex = i;\n            }\n            segment = rawPath[segIndex];\n            min = max - segment.totalLength;\n            progress = (length - min) / (max - min) || 0;\n        }\n        samples = segment.samples;\n        resolution = segment.resolution; //how many samples per cubic bezier chunk\n        length = segment.totalLength * progress;\n        i = segment.lookup.length ? segment.lookup[~~(length / segment.minLength)] || 0 : _getSampleIndex(samples, length, progress);\n        min = i ? samples[i - 1] : 0;\n        max = samples[i];\n        if (max < length) {\n            min = max;\n            max = samples[++i];\n        }\n        t = 1 / resolution * ((length - min) / (max - min) + i % resolution);\n        i = ~~(i / resolution) * 6;\n        if (pushToNextIfAtEnd && t === 1) {\n            if (i + 6 < segment.length) {\n                i += 6;\n                t = 0;\n            } else if (segIndex + 1 < rawPath.length) {\n                i = t = 0;\n                segment = rawPath[++segIndex];\n            }\n        }\n    }\n    decoratee.t = t;\n    decoratee.i = i;\n    decoratee.path = rawPath;\n    decoratee.segment = segment;\n    decoratee.segIndex = segIndex;\n    return decoratee;\n}\nfunction getPositionOnPath(rawPath, progress, includeAngle, point) {\n    var segment = rawPath[0], result = point || {}, samples, resolution, length, min, max, i, t, a, inv;\n    if (progress < 0 || progress > 1) {\n        progress = _wrapProgress(progress);\n    }\n    segment.lookup || cacheRawPathMeasurements(rawPath);\n    if (rawPath.length > 1) {\n        //speed optimization: most of the time, there's only one segment so skip the recursion.\n        length = rawPath.totalLength * progress;\n        max = i = 0;\n        while((max += rawPath[i++].totalLength) < length){\n            segment = rawPath[i];\n        }\n        min = max - segment.totalLength;\n        progress = (length - min) / (max - min) || 0;\n    }\n    samples = segment.samples;\n    resolution = segment.resolution;\n    length = segment.totalLength * progress;\n    i = segment.lookup.length ? segment.lookup[progress < 1 ? ~~(length / segment.minLength) : segment.lookup.length - 1] || 0 : _getSampleIndex(samples, length, progress);\n    min = i ? samples[i - 1] : 0;\n    max = samples[i];\n    if (max < length) {\n        min = max;\n        max = samples[++i];\n    }\n    t = 1 / resolution * ((length - min) / (max - min) + i % resolution) || 0;\n    inv = 1 - t;\n    i = ~~(i / resolution) * 6;\n    a = segment[i];\n    result.x = _round((t * t * (segment[i + 6] - a) + 3 * inv * (t * (segment[i + 4] - a) + inv * (segment[i + 2] - a))) * t + a);\n    result.y = _round((t * t * (segment[i + 7] - (a = segment[i + 1])) + 3 * inv * (t * (segment[i + 5] - a) + inv * (segment[i + 3] - a))) * t + a);\n    if (includeAngle) {\n        result.angle = segment.totalLength ? getRotationAtBezierT(segment, i, t >= 1 ? 1 - 1e-9 : t ? t : 1e-9) : segment.angle || 0;\n    }\n    return result;\n} //applies a matrix transform to RawPath (or a segment in a RawPath) and returns whatever was passed in (it transforms the values in the array(s), not a copy).\nfunction transformRawPath(rawPath, a, b, c, d, tx, ty) {\n    var j = rawPath.length, segment, l, i, x, y;\n    while(--j > -1){\n        segment = rawPath[j];\n        l = segment.length;\n        for(i = 0; i < l; i += 2){\n            x = segment[i];\n            y = segment[i + 1];\n            segment[i] = x * a + y * c + tx;\n            segment[i + 1] = x * b + y * d + ty;\n        }\n    }\n    rawPath._dirty = 1;\n    return rawPath;\n} // translates SVG arc data into a segment (cubic beziers). Angle is in degrees.\nfunction arcToSegment(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {\n    if (lastX === x && lastY === y) {\n        return;\n    }\n    rx = _abs(rx);\n    ry = _abs(ry);\n    var angleRad = angle % 360 * _DEG2RAD, cosAngle = _cos(angleRad), sinAngle = _sin(angleRad), PI = Math.PI, TWOPI = PI * 2, dx2 = (lastX - x) / 2, dy2 = (lastY - y) / 2, x1 = cosAngle * dx2 + sinAngle * dy2, y1 = -sinAngle * dx2 + cosAngle * dy2, x1_sq = x1 * x1, y1_sq = y1 * y1, radiiCheck = x1_sq / (rx * rx) + y1_sq / (ry * ry);\n    if (radiiCheck > 1) {\n        rx = _sqrt(radiiCheck) * rx;\n        ry = _sqrt(radiiCheck) * ry;\n    }\n    var rx_sq = rx * rx, ry_sq = ry * ry, sq = (rx_sq * ry_sq - rx_sq * y1_sq - ry_sq * x1_sq) / (rx_sq * y1_sq + ry_sq * x1_sq);\n    if (sq < 0) {\n        sq = 0;\n    }\n    var coef = (largeArcFlag === sweepFlag ? -1 : 1) * _sqrt(sq), cx1 = coef * (rx * y1 / ry), cy1 = coef * -(ry * x1 / rx), sx2 = (lastX + x) / 2, sy2 = (lastY + y) / 2, cx = sx2 + (cosAngle * cx1 - sinAngle * cy1), cy = sy2 + (sinAngle * cx1 + cosAngle * cy1), ux = (x1 - cx1) / rx, uy = (y1 - cy1) / ry, vx = (-x1 - cx1) / rx, vy = (-y1 - cy1) / ry, temp = ux * ux + uy * uy, angleStart = (uy < 0 ? -1 : 1) * Math.acos(ux / _sqrt(temp)), angleExtent = (ux * vy - uy * vx < 0 ? -1 : 1) * Math.acos((ux * vx + uy * vy) / _sqrt(temp * (vx * vx + vy * vy)));\n    isNaN(angleExtent) && (angleExtent = PI); //rare edge case. Math.cos(-1) is NaN.\n    if (!sweepFlag && angleExtent > 0) {\n        angleExtent -= TWOPI;\n    } else if (sweepFlag && angleExtent < 0) {\n        angleExtent += TWOPI;\n    }\n    angleStart %= TWOPI;\n    angleExtent %= TWOPI;\n    var segments = Math.ceil(_abs(angleExtent) / (TWOPI / 4)), rawPath = [], angleIncrement = angleExtent / segments, controlLength = 4 / 3 * _sin(angleIncrement / 2) / (1 + _cos(angleIncrement / 2)), ma = cosAngle * rx, mb = sinAngle * rx, mc = sinAngle * -ry, md = cosAngle * ry, i;\n    for(i = 0; i < segments; i++){\n        angle = angleStart + i * angleIncrement;\n        x1 = _cos(angle);\n        y1 = _sin(angle);\n        ux = _cos(angle += angleIncrement);\n        uy = _sin(angle);\n        rawPath.push(x1 - controlLength * y1, y1 + controlLength * x1, ux + controlLength * uy, uy - controlLength * ux, ux, uy);\n    } //now transform according to the actual size of the ellipse/arc (the beziers were noramlized, between 0 and 1 on a circle).\n    for(i = 0; i < rawPath.length; i += 2){\n        x1 = rawPath[i];\n        y1 = rawPath[i + 1];\n        rawPath[i] = x1 * ma + y1 * mc + cx;\n        rawPath[i + 1] = x1 * mb + y1 * md + cy;\n    }\n    rawPath[i - 2] = x; //always set the end to exactly where it's supposed to be\n    rawPath[i - 1] = y;\n    return rawPath;\n} //Spits back a RawPath with absolute coordinates. Each segment starts with a \"moveTo\" command (x coordinate, then y) and then 2 control points (x, y, x, y), then anchor. The goal is to minimize memory and maximize speed.\nfunction stringToRawPath(d) {\n    var a = (d + \"\").replace(_scientific, function(m) {\n        var n = +m;\n        return n < 0.0001 && n > -0.0001 ? 0 : n;\n    }).match(_svgPathExp) || [], //some authoring programs spit out very small numbers in scientific notation like \"1e-5\", so make sure we round that down to 0 first.\n    path = [], relativeX = 0, relativeY = 0, twoThirds = 2 / 3, elements = a.length, points = 0, errorMessage = \"ERROR: malformed path: \" + d, i, j, x, y, command, isRelative, segment, startX, startY, difX, difY, beziers, prevCommand, flag1, flag2, line = function line(sx, sy, ex, ey) {\n        difX = (ex - sx) / 3;\n        difY = (ey - sy) / 3;\n        segment.push(sx + difX, sy + difY, ex - difX, ey - difY, ex, ey);\n    };\n    if (!d || !isNaN(a[0]) || isNaN(a[1])) {\n        console.log(errorMessage);\n        return path;\n    }\n    for(i = 0; i < elements; i++){\n        prevCommand = command;\n        if (isNaN(a[i])) {\n            command = a[i].toUpperCase();\n            isRelative = command !== a[i]; //lower case means relative\n        } else {\n            //commands like \"C\" can be strung together without any new command characters between.\n            i--;\n        }\n        x = +a[i + 1];\n        y = +a[i + 2];\n        if (isRelative) {\n            x += relativeX;\n            y += relativeY;\n        }\n        if (!i) {\n            startX = x;\n            startY = y;\n        } // \"M\" (move)\n        if (command === \"M\") {\n            if (segment) {\n                if (segment.length < 8) {\n                    //if the path data was funky and just had a M with no actual drawing anywhere, skip it.\n                    path.length -= 1;\n                } else {\n                    points += segment.length;\n                }\n            }\n            relativeX = startX = x;\n            relativeY = startY = y;\n            segment = [\n                x,\n                y\n            ];\n            path.push(segment);\n            i += 2;\n            command = \"L\"; //an \"M\" with more than 2 values gets interpreted as \"lineTo\" commands (\"L\").\n        // \"C\" (cubic bezier)\n        } else if (command === \"C\") {\n            if (!segment) {\n                segment = [\n                    0,\n                    0\n                ];\n            }\n            if (!isRelative) {\n                relativeX = relativeY = 0;\n            } //note: \"*1\" is just a fast/short way to cast the value as a Number. WAAAY faster in Chrome, slightly slower in Firefox.\n            segment.push(x, y, relativeX + a[i + 3] * 1, relativeY + a[i + 4] * 1, relativeX += a[i + 5] * 1, relativeY += a[i + 6] * 1);\n            i += 6; // \"S\" (continuation of cubic bezier)\n        } else if (command === \"S\") {\n            difX = relativeX;\n            difY = relativeY;\n            if (prevCommand === \"C\" || prevCommand === \"S\") {\n                difX += relativeX - segment[segment.length - 4];\n                difY += relativeY - segment[segment.length - 3];\n            }\n            if (!isRelative) {\n                relativeX = relativeY = 0;\n            }\n            segment.push(difX, difY, x, y, relativeX += a[i + 3] * 1, relativeY += a[i + 4] * 1);\n            i += 4; // \"Q\" (quadratic bezier)\n        } else if (command === \"Q\") {\n            difX = relativeX + (x - relativeX) * twoThirds;\n            difY = relativeY + (y - relativeY) * twoThirds;\n            if (!isRelative) {\n                relativeX = relativeY = 0;\n            }\n            relativeX += a[i + 3] * 1;\n            relativeY += a[i + 4] * 1;\n            segment.push(difX, difY, relativeX + (x - relativeX) * twoThirds, relativeY + (y - relativeY) * twoThirds, relativeX, relativeY);\n            i += 4; // \"T\" (continuation of quadratic bezier)\n        } else if (command === \"T\") {\n            difX = relativeX - segment[segment.length - 4];\n            difY = relativeY - segment[segment.length - 3];\n            segment.push(relativeX + difX, relativeY + difY, x + (relativeX + difX * 1.5 - x) * twoThirds, y + (relativeY + difY * 1.5 - y) * twoThirds, relativeX = x, relativeY = y);\n            i += 2; // \"H\" (horizontal line)\n        } else if (command === \"H\") {\n            line(relativeX, relativeY, relativeX = x, relativeY);\n            i += 1; // \"V\" (vertical line)\n        } else if (command === \"V\") {\n            //adjust values because the first (and only one) isn't x in this case, it's y.\n            line(relativeX, relativeY, relativeX, relativeY = x + (isRelative ? relativeY - relativeX : 0));\n            i += 1; // \"L\" (line) or \"Z\" (close)\n        } else if (command === \"L\" || command === \"Z\") {\n            if (command === \"Z\") {\n                x = startX;\n                y = startY;\n                segment.closed = true;\n            }\n            if (command === \"L\" || _abs(relativeX - x) > 0.5 || _abs(relativeY - y) > 0.5) {\n                line(relativeX, relativeY, x, y);\n                if (command === \"L\") {\n                    i += 2;\n                }\n            }\n            relativeX = x;\n            relativeY = y; // \"A\" (arc)\n        } else if (command === \"A\") {\n            flag1 = a[i + 4];\n            flag2 = a[i + 5];\n            difX = a[i + 6];\n            difY = a[i + 7];\n            j = 7;\n            if (flag1.length > 1) {\n                // for cases when the flags are merged, like \"a8 8 0 018 8\" (the 0 and 1 flags are WITH the x value of 8, but it could also be \"a8 8 0 01-8 8\" so it may include x or not)\n                if (flag1.length < 3) {\n                    difY = difX;\n                    difX = flag2;\n                    j--;\n                } else {\n                    difY = flag2;\n                    difX = flag1.substr(2);\n                    j -= 2;\n                }\n                flag2 = flag1.charAt(1);\n                flag1 = flag1.charAt(0);\n            }\n            beziers = arcToSegment(relativeX, relativeY, +a[i + 1], +a[i + 2], +a[i + 3], +flag1, +flag2, (isRelative ? relativeX : 0) + difX * 1, (isRelative ? relativeY : 0) + difY * 1);\n            i += j;\n            if (beziers) {\n                for(j = 0; j < beziers.length; j++){\n                    segment.push(beziers[j]);\n                }\n            }\n            relativeX = segment[segment.length - 2];\n            relativeY = segment[segment.length - 1];\n        } else {\n            console.log(errorMessage);\n        }\n    }\n    i = segment.length;\n    if (i < 6) {\n        //in case there's odd SVG like a M0,0 command at the very end.\n        path.pop();\n        i = 0;\n    } else if (segment[0] === segment[i - 2] && segment[1] === segment[i - 1]) {\n        segment.closed = true;\n    }\n    path.totalPoints = points + i;\n    return path;\n} //populates the points array in alternating x/y values (like [x, y, x, y...] instead of individual point objects [{x, y}, {x, y}...] to conserve memory and stay in line with how we're handling segment arrays\nfunction bezierToPoints(x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {\n    var x12 = (x1 + x2) / 2, y12 = (y1 + y2) / 2, x23 = (x2 + x3) / 2, y23 = (y2 + y3) / 2, x34 = (x3 + x4) / 2, y34 = (y3 + y4) / 2, x123 = (x12 + x23) / 2, y123 = (y12 + y23) / 2, x234 = (x23 + x34) / 2, y234 = (y23 + y34) / 2, x1234 = (x123 + x234) / 2, y1234 = (y123 + y234) / 2, dx = x4 - x1, dy = y4 - y1, d2 = _abs((x2 - x4) * dy - (y2 - y4) * dx), d3 = _abs((x3 - x4) * dy - (y3 - y4) * dx), length;\n    if (!points) {\n        points = [\n            x1,\n            y1,\n            x4,\n            y4\n        ];\n        index = 2;\n    }\n    points.splice(index || points.length - 2, 0, x1234, y1234);\n    if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {\n        length = points.length;\n        bezierToPoints(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);\n        bezierToPoints(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 2 + (points.length - length));\n    }\n    return points;\n}\n/*\nfunction getAngleBetweenPoints(x0, y0, x1, y1, x2, y2) { //angle between 3 points in radians\n\tvar dx1 = x1 - x0,\n\t\tdy1 = y1 - y0,\n\t\tdx2 = x2 - x1,\n\t\tdy2 = y2 - y1,\n\t\tdx3 = x2 - x0,\n\t\tdy3 = y2 - y0,\n\t\ta = dx1 * dx1 + dy1 * dy1,\n\t\tb = dx2 * dx2 + dy2 * dy2,\n\t\tc = dx3 * dx3 + dy3 * dy3;\n\treturn Math.acos( (a + b - c) / _sqrt(4 * a * b) );\n},\n*/ //pointsToSegment() doesn't handle flat coordinates (where y is always 0) the way we need (the resulting control points are always right on top of the anchors), so this function basically makes the control points go directly up and down, varying in length based on the curviness (more curvy, further control points)\nfunction flatPointsToSegment(points, curviness) {\n    if (curviness === void 0) {\n        curviness = 1;\n    }\n    var x = points[0], y = 0, segment = [\n        x,\n        y\n    ], i = 2;\n    for(; i < points.length; i += 2){\n        segment.push(x, y, points[i], y = (points[i] - x) * curviness / 2, x = points[i], -y);\n    }\n    return segment;\n} //points is an array of x/y points, like [x, y, x, y, x, y]\nfunction pointsToSegment(points, curviness) {\n    //points = simplifyPoints(points, tolerance);\n    _abs(points[0] - points[2]) < 1e-4 && _abs(points[1] - points[3]) < 1e-4 && (points = points.slice(2)); // if the first two points are super close, dump the first one.\n    var l = points.length - 2, x = +points[0], y = +points[1], nextX = +points[2], nextY = +points[3], segment = [\n        x,\n        y,\n        x,\n        y\n    ], dx2 = nextX - x, dy2 = nextY - y, closed = Math.abs(points[l] - x) < 0.001 && Math.abs(points[l + 1] - y) < 0.001, prevX, prevY, i, dx1, dy1, r1, r2, r3, tl, mx1, mx2, mxm, my1, my2, mym;\n    if (closed) {\n        // if the start and end points are basically on top of each other, close the segment by adding the 2nd point to the end, and the 2nd-to-last point to the beginning (we'll remove them at the end, but this allows the curvature to look perfect)\n        points.push(nextX, nextY);\n        nextX = x;\n        nextY = y;\n        x = points[l - 2];\n        y = points[l - 1];\n        points.unshift(x, y);\n        l += 4;\n    }\n    curviness = curviness || curviness === 0 ? +curviness : 1;\n    for(i = 2; i < l; i += 2){\n        prevX = x;\n        prevY = y;\n        x = nextX;\n        y = nextY;\n        nextX = +points[i + 2];\n        nextY = +points[i + 3];\n        if (x === nextX && y === nextY) {\n            continue;\n        }\n        dx1 = dx2;\n        dy1 = dy2;\n        dx2 = nextX - x;\n        dy2 = nextY - y;\n        r1 = _sqrt(dx1 * dx1 + dy1 * dy1); // r1, r2, and r3 correlate x and y (and z in the future). Basically 2D or 3D hypotenuse\n        r2 = _sqrt(dx2 * dx2 + dy2 * dy2);\n        r3 = _sqrt(Math.pow(dx2 / r2 + dx1 / r1, 2) + Math.pow(dy2 / r2 + dy1 / r1, 2));\n        tl = (r1 + r2) * curviness * 0.25 / r3;\n        mx1 = x - (x - prevX) * (r1 ? tl / r1 : 0);\n        mx2 = x + (nextX - x) * (r2 ? tl / r2 : 0);\n        mxm = x - (mx1 + ((mx2 - mx1) * (r1 * 3 / (r1 + r2) + 0.5) / 4 || 0));\n        my1 = y - (y - prevY) * (r1 ? tl / r1 : 0);\n        my2 = y + (nextY - y) * (r2 ? tl / r2 : 0);\n        mym = y - (my1 + ((my2 - my1) * (r1 * 3 / (r1 + r2) + 0.5) / 4 || 0));\n        if (x !== prevX || y !== prevY) {\n            segment.push(_round(mx1 + mxm), _round(my1 + mym), _round(x), _round(y), _round(mx2 + mxm), _round(my2 + mym));\n        }\n    }\n    x !== nextX || y !== nextY || segment.length < 4 ? segment.push(_round(nextX), _round(nextY), _round(nextX), _round(nextY)) : segment.length -= 2;\n    if (segment.length === 2) {\n        // only one point!\n        segment.push(x, y, x, y, x, y);\n    } else if (closed) {\n        segment.splice(0, 6);\n        segment.length = segment.length - 6;\n    }\n    return segment;\n} //returns the squared distance between an x/y coordinate and a segment between x1/y1 and x2/y2\nfunction pointToSegDist(x, y, x1, y1, x2, y2) {\n    var dx = x2 - x1, dy = y2 - y1, t;\n    if (dx || dy) {\n        t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n        if (t > 1) {\n            x1 = x2;\n            y1 = y2;\n        } else if (t > 0) {\n            x1 += dx * t;\n            y1 += dy * t;\n        }\n    }\n    return Math.pow(x - x1, 2) + Math.pow(y - y1, 2);\n}\nfunction simplifyStep(points, first, last, tolerance, simplified) {\n    var maxSqDist = tolerance, firstX = points[first], firstY = points[first + 1], lastX = points[last], lastY = points[last + 1], index, i, d;\n    for(i = first + 2; i < last; i += 2){\n        d = pointToSegDist(points[i], points[i + 1], firstX, firstY, lastX, lastY);\n        if (d > maxSqDist) {\n            index = i;\n            maxSqDist = d;\n        }\n    }\n    if (maxSqDist > tolerance) {\n        index - first > 2 && simplifyStep(points, first, index, tolerance, simplified);\n        simplified.push(points[index], points[index + 1]);\n        last - index > 2 && simplifyStep(points, index, last, tolerance, simplified);\n    }\n} //points is an array of x/y values like [x, y, x, y, x, y]\nfunction simplifyPoints(points, tolerance) {\n    var prevX = parseFloat(points[0]), prevY = parseFloat(points[1]), temp = [\n        prevX,\n        prevY\n    ], l = points.length - 2, i, x, y, dx, dy, result, last;\n    tolerance = Math.pow(tolerance || 1, 2);\n    for(i = 2; i < l; i += 2){\n        x = parseFloat(points[i]);\n        y = parseFloat(points[i + 1]);\n        dx = prevX - x;\n        dy = prevY - y;\n        if (dx * dx + dy * dy > tolerance) {\n            temp.push(x, y);\n            prevX = x;\n            prevY = y;\n        }\n    }\n    temp.push(parseFloat(points[l]), parseFloat(points[l + 1]));\n    last = temp.length - 2;\n    result = [\n        temp[0],\n        temp[1]\n    ];\n    simplifyStep(temp, 0, last, tolerance, result);\n    result.push(temp[last], temp[last + 1]);\n    return result;\n}\nfunction getClosestProgressOnBezier(iterations, px, py, start, end, slices, x0, y0, x1, y1, x2, y2, x3, y3) {\n    var inc = (end - start) / slices, best = 0, t = start, x, y, d, dx, dy, inv;\n    _bestDistance = _largeNum;\n    while(t <= end){\n        inv = 1 - t;\n        x = inv * inv * inv * x0 + 3 * inv * inv * t * x1 + 3 * inv * t * t * x2 + t * t * t * x3;\n        y = inv * inv * inv * y0 + 3 * inv * inv * t * y1 + 3 * inv * t * t * y2 + t * t * t * y3;\n        dx = x - px;\n        dy = y - py;\n        d = dx * dx + dy * dy;\n        if (d < _bestDistance) {\n            _bestDistance = d;\n            best = t;\n        }\n        t += inc;\n    }\n    return iterations > 1 ? getClosestProgressOnBezier(iterations - 1, px, py, Math.max(best - inc, 0), Math.min(best + inc, 1), slices, x0, y0, x1, y1, x2, y2, x3, y3) : best;\n}\nfunction getClosestData(rawPath, x, y, slices) {\n    //returns an object with the closest j, i, and t (j is the segment index, i is the index of the point in that segment, and t is the time/progress along that bezier)\n    var closest = {\n        j: 0,\n        i: 0,\n        t: 0\n    }, bestDistance = _largeNum, i, j, t, segment;\n    for(j = 0; j < rawPath.length; j++){\n        segment = rawPath[j];\n        for(i = 0; i < segment.length; i += 6){\n            t = getClosestProgressOnBezier(1, x, y, 0, 1, slices || 20, segment[i], segment[i + 1], segment[i + 2], segment[i + 3], segment[i + 4], segment[i + 5], segment[i + 6], segment[i + 7]);\n            if (bestDistance > _bestDistance) {\n                bestDistance = _bestDistance;\n                closest.j = j;\n                closest.i = i;\n                closest.t = t;\n            }\n        }\n    }\n    return closest;\n} //subdivide a Segment closest to a specific x,y coordinate\nfunction subdivideSegmentNear(x, y, segment, slices, iterations) {\n    var l = segment.length, bestDistance = _largeNum, bestT = 0, bestSegmentIndex = 0, t, i;\n    slices = slices || 20;\n    iterations = iterations || 3;\n    for(i = 0; i < l; i += 6){\n        t = getClosestProgressOnBezier(1, x, y, 0, 1, slices, segment[i], segment[i + 1], segment[i + 2], segment[i + 3], segment[i + 4], segment[i + 5], segment[i + 6], segment[i + 7]);\n        if (bestDistance > _bestDistance) {\n            bestDistance = _bestDistance;\n            bestT = t;\n            bestSegmentIndex = i;\n        }\n    }\n    t = getClosestProgressOnBezier(iterations, x, y, bestT - 0.05, bestT + 0.05, slices, segment[bestSegmentIndex], segment[bestSegmentIndex + 1], segment[bestSegmentIndex + 2], segment[bestSegmentIndex + 3], segment[bestSegmentIndex + 4], segment[bestSegmentIndex + 5], segment[bestSegmentIndex + 6], segment[bestSegmentIndex + 7]);\n    subdivideSegment(segment, bestSegmentIndex, t);\n    return bestSegmentIndex + 6;\n}\n/*\nTakes any of the following and converts it to an all Cubic Bezier SVG data string:\n- A <path> data string like \"M0,0 L2,4 v20,15 H100\"\n- A RawPath, like [[x, y, x, y, x, y, x, y][[x, y, x, y, x, y, x, y]]\n- A Segment, like [x, y, x, y, x, y, x, y]\n\nNote: all numbers are rounded down to the closest 0.001 to minimize memory, maximize speed, and avoid odd numbers like 1e-13\n*/ function rawPathToString(rawPath) {\n    if (_isNumber(rawPath[0])) {\n        //in case a segment is passed in instead\n        rawPath = [\n            rawPath\n        ];\n    }\n    var result = \"\", l = rawPath.length, sl, s, i, segment;\n    for(s = 0; s < l; s++){\n        segment = rawPath[s];\n        result += \"M\" + _round(segment[0]) + \",\" + _round(segment[1]) + \" C\";\n        sl = segment.length;\n        for(i = 2; i < sl; i++){\n            result += _round(segment[i++]) + \",\" + _round(segment[i++]) + \" \" + _round(segment[i++]) + \",\" + _round(segment[i++]) + \" \" + _round(segment[i++]) + \",\" + _round(segment[i]) + \" \";\n        }\n        if (segment.closed) {\n            result += \"z\";\n        }\n    }\n    return result;\n} /*\n// takes a segment with coordinates [x, y, x, y, ...] and converts the control points into angles and lengths [x, y, angle, length, angle, length, x, y, angle, length, ...] so that it animates more cleanly and avoids odd breaks/kinks. For example, if you animate from 1 o'clock to 6 o'clock, it'd just go directly/linearly rather than around. So the length would be very short in the middle of the tween.\nexport function cpCoordsToAngles(segment, copy) {\n\tvar result = copy ? segment.slice(0) : segment,\n\t\tx, y, i;\n\tfor (i = 0; i < segment.length; i+=6) {\n\t\tx = segment[i+2] - segment[i];\n\t\ty = segment[i+3] - segment[i+1];\n\t\tresult[i+2] = Math.atan2(y, x);\n\t\tresult[i+3] = Math.sqrt(x * x + y * y);\n\t\tx = segment[i+6] - segment[i+4];\n\t\ty = segment[i+7] - segment[i+5];\n\t\tresult[i+4] = Math.atan2(y, x);\n\t\tresult[i+5] = Math.sqrt(x * x + y * y);\n\t}\n\treturn result;\n}\n\n// takes a segment that was converted with cpCoordsToAngles() to have angles and lengths instead of coordinates for the control points, and converts it BACK into coordinates.\nexport function cpAnglesToCoords(segment, copy) {\n\tvar result = copy ? segment.slice(0) : segment,\n\t\tlength = segment.length,\n\t\trnd = 1000,\n\t\tangle, l, i, j;\n\tfor (i = 0; i < length; i+=6) {\n\t\tangle = segment[i+2];\n\t\tl = segment[i+3]; //length\n\t\tresult[i+2] = (((segment[i] + Math.cos(angle) * l) * rnd) | 0) / rnd;\n\t\tresult[i+3] = (((segment[i+1] + Math.sin(angle) * l) * rnd) | 0) / rnd;\n\t\tangle = segment[i+4];\n\t\tl = segment[i+5]; //length\n\t\tresult[i+4] = (((segment[i+6] - Math.cos(angle) * l) * rnd) | 0) / rnd;\n\t\tresult[i+5] = (((segment[i+7] - Math.sin(angle) * l) * rnd) | 0) / rnd;\n\t}\n\treturn result;\n}\n\n//adds an \"isSmooth\" array to each segment and populates it with a boolean value indicating whether or not it's smooth (the control points have basically the same slope). For any smooth control points, it converts the coordinates into angle (x, in radians) and length (y) and puts them into the same index value in a smoothData array.\nexport function populateSmoothData(rawPath) {\n\tlet j = rawPath.length,\n\t\tsmooth, segment, x, y, x2, y2, i, l, a, a2, isSmooth, smoothData;\n\twhile (--j > -1) {\n\t\tsegment = rawPath[j];\n\t\tisSmooth = segment.isSmooth = segment.isSmooth || [0, 0, 0, 0];\n\t\tsmoothData = segment.smoothData = segment.smoothData || [0, 0, 0, 0];\n\t\tisSmooth.length = 4;\n\t\tl = segment.length - 2;\n\t\tfor (i = 6; i < l; i += 6) {\n\t\t\tx = segment[i] - segment[i - 2];\n\t\t\ty = segment[i + 1] - segment[i - 1];\n\t\t\tx2 = segment[i + 2] - segment[i];\n\t\t\ty2 = segment[i + 3] - segment[i + 1];\n\t\t\ta = _atan2(y, x);\n\t\t\ta2 = _atan2(y2, x2);\n\t\t\tsmooth = (Math.abs(a - a2) < 0.09);\n\t\t\tif (smooth) {\n\t\t\t\tsmoothData[i - 2] = a;\n\t\t\t\tsmoothData[i + 2] = a2;\n\t\t\t\tsmoothData[i - 1] = _sqrt(x * x + y * y);\n\t\t\t\tsmoothData[i + 3] = _sqrt(x2 * x2 + y2 * y2);\n\t\t\t}\n\t\t\tisSmooth.push(smooth, smooth, 0, 0, smooth, smooth);\n\t\t}\n\t\t//if the first and last points are identical, check to see if there's a smooth transition. We must handle this a bit differently due to their positions in the array.\n\t\tif (segment[l] === segment[0] && segment[l+1] === segment[1]) {\n\t\t\tx = segment[0] - segment[l-2];\n\t\t\ty = segment[1] - segment[l-1];\n\t\t\tx2 = segment[2] - segment[0];\n\t\t\ty2 = segment[3] - segment[1];\n\t\t\ta = _atan2(y, x);\n\t\t\ta2 = _atan2(y2, x2);\n\t\t\tif (Math.abs(a - a2) < 0.09) {\n\t\t\t\tsmoothData[l-2] = a;\n\t\t\t\tsmoothData[2] = a2;\n\t\t\t\tsmoothData[l-1] = _sqrt(x * x + y * y);\n\t\t\t\tsmoothData[3] = _sqrt(x2 * x2 + y2 * y2);\n\t\t\t\tisSmooth[l-2] = isSmooth[l-1] = true; //don't change indexes 2 and 3 because we'll trigger everything from the END, and this will optimize file size a bit.\n\t\t\t}\n\t\t}\n\t}\n\treturn rawPath;\n}\nexport function pointToScreen(svgElement, point) {\n\tif (arguments.length < 2) { //by default, take the first set of coordinates in the path as the point\n\t\tlet rawPath = getRawPath(svgElement);\n\t\tpoint = svgElement.ownerSVGElement.createSVGPoint();\n\t\tpoint.x = rawPath[0][0];\n\t\tpoint.y = rawPath[0][1];\n\t}\n\treturn point.matrixTransform(svgElement.getScreenCTM());\n}\n\n*/ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC91dGlscy9wYXRocy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFRQSxHQUVBLGtCQUFrQixHQUNsQixJQUFJQSxjQUFjLG9EQUNkQyxjQUFjLDJDQUNkQyxjQUFjLGlDQUNkQyxlQUFlLDZCQUNmQyxXQUFXQyxLQUFLQyxFQUFFLEdBQUcsS0FDckJDLFdBQVcsTUFBTUYsS0FBS0MsRUFBRSxFQUN4QkUsT0FBT0gsS0FBS0ksR0FBRyxFQUNmQyxPQUFPTCxLQUFLTSxHQUFHLEVBQ2ZDLE9BQU9QLEtBQUtRLEdBQUcsRUFDZkMsUUFBUVQsS0FBS1UsSUFBSSxFQUNqQkMsU0FBU1gsS0FBS1ksS0FBSyxFQUNuQkMsWUFBWSxLQUNaQyxZQUFZLFNBQVNBLFVBQVVDLEtBQUs7SUFDdEMsT0FBTyxPQUFPQSxVQUFVO0FBQzFCLEdBQ0lDLFlBQVksU0FBU0EsVUFBVUQsS0FBSztJQUN0QyxPQUFPLE9BQU9BLFVBQVU7QUFDMUIsR0FDSUUsZUFBZSxTQUFTQSxhQUFhRixLQUFLO0lBQzVDLE9BQU8sT0FBT0EsVUFBVTtBQUMxQixHQUNJRyxRQUFRLENBQUMsR0FDVEMsU0FBUyxDQUFDLEdBQ1ZDLGVBQWUsS0FDZkMsZ0JBQWdCLFNBQVNBLGNBQWNDLFFBQVE7SUFDakQsT0FBT3RCLEtBQUt1QixLQUFLLENBQUMsQ0FBQ0QsV0FBV1QsU0FBUSxJQUFLLElBQUlPLGdCQUFnQkEsZ0JBQWlCRSxDQUFBQSxXQUFXLElBQUksSUFBSTtBQUNyRyxHQUNJLDhKQUE4SjtBQUNsS0UsU0FBUyxTQUFTQSxPQUFPVCxLQUFLO0lBQzVCLE9BQU9mLEtBQUt1QixLQUFLLENBQUNSLFFBQVFLLGdCQUFnQkEsZ0JBQWdCO0FBQzVELEdBQ0lLLGdCQUFnQixTQUFTQSxjQUFjVixLQUFLO0lBQzlDLE9BQU9mLEtBQUt1QixLQUFLLENBQUNSLFFBQVEsUUFBUSxRQUFRO0FBQzVDLEdBQ0lXLGdCQUFnQixTQUFTQSxjQUFjQyxPQUFPLEVBQUVDLFFBQVEsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hFLElBQUlDLFVBQVVKLE9BQU8sQ0FBQ0MsU0FBUyxFQUMzQkksUUFBUUYsTUFBTSxJQUFJLElBQUlHLGlCQUFpQkYsU0FBU0YsR0FBR0M7SUFFdkQsSUFBSSxDQUFDRSxTQUFTLENBQUNGLENBQUFBLEtBQU1FLFFBQVFILElBQUksSUFBSUUsUUFBUUcsTUFBTSxFQUFFO1FBQ25EUCxRQUFRUSxNQUFNLENBQUNQLFVBQVUsR0FBR0csUUFBUUssS0FBSyxDQUFDLEdBQUdQLElBQUlHLFFBQVE7UUFDekRELFFBQVFJLE1BQU0sQ0FBQyxHQUFHTixJQUFJRztRQUN0QixPQUFPO0lBQ1Q7QUFDRixHQUNJSyxrQkFBa0IsU0FBU0EsZ0JBQWdCQyxPQUFPLEVBQUVKLE1BQU0sRUFBRVosUUFBUTtJQUN0RSxnS0FBZ0s7SUFDaEssSUFBSWlCLElBQUlELFFBQVFKLE1BQU0sRUFDbEJMLElBQUksQ0FBQyxDQUFFUCxDQUFBQSxXQUFXaUIsQ0FBQUE7SUFFdEIsSUFBSUQsT0FBTyxDQUFDVCxFQUFFLEdBQUdLLFFBQVE7UUFDdkIsTUFBTyxFQUFFTCxLQUFLUyxPQUFPLENBQUNULEVBQUUsR0FBR0ssT0FBUSxDQUFDO1FBRXBDTCxJQUFJLEtBQU1BLENBQUFBLElBQUk7SUFDaEIsT0FBTztRQUNMLE1BQU9TLE9BQU8sQ0FBQyxFQUFFVCxFQUFFLEdBQUdLLFVBQVVMLElBQUlVLEVBQUcsQ0FBQztJQUMxQztJQUVBLE9BQU9WLElBQUlVLElBQUlWLElBQUlVLElBQUk7QUFDekIsR0FDSUMsa0JBQWtCLFNBQVNBLGdCQUFnQmIsT0FBTyxFQUFFYyxTQUFTO0lBQy9ELElBQUlaLElBQUlGLFFBQVFPLE1BQU07SUFDdEJPLGFBQWFkLFFBQVFlLE9BQU87SUFFNUIsTUFBT2IsSUFBSztRQUNWRixPQUFPLENBQUNFLEVBQUUsQ0FBQ2MsUUFBUSxJQUFJQyxlQUFlakIsT0FBTyxDQUFDRSxFQUFFO0lBQ2xEO0FBQ0YsR0FDSWdCLGdCQUFnQixTQUFTQSxjQUFjQyxNQUFNLEVBQUVDLElBQUk7SUFDckRBLEtBQUtDLFdBQVcsR0FBR0YsT0FBT0UsV0FBVztJQUVyQyxJQUFJRixPQUFPUixPQUFPLEVBQUU7UUFDbEIsU0FBUztRQUNUUyxLQUFLVCxPQUFPLEdBQUdRLE9BQU9SLE9BQU8sQ0FBQ0YsS0FBSyxDQUFDO1FBQ3BDVyxLQUFLRSxNQUFNLEdBQUdILE9BQU9HLE1BQU0sQ0FBQ2IsS0FBSyxDQUFDO1FBQ2xDVyxLQUFLRyxTQUFTLEdBQUdKLE9BQU9JLFNBQVM7UUFDakNILEtBQUtJLFVBQVUsR0FBR0wsT0FBT0ssVUFBVTtJQUNyQyxPQUFPLElBQUlMLE9BQU9NLFdBQVcsRUFBRTtRQUM3QixTQUFTO1FBQ1RMLEtBQUtLLFdBQVcsR0FBR04sT0FBT00sV0FBVztJQUN2QztJQUVBLE9BQU9MO0FBQ1QsR0FDSSx1TEFBdUw7QUFDM0xNLGlCQUFpQixTQUFTQSxlQUFlMUIsT0FBTyxFQUFFSSxPQUFPO0lBQ3ZELElBQUl1QixRQUFRM0IsUUFBUU8sTUFBTSxFQUN0QnFCLFVBQVU1QixPQUFPLENBQUMyQixRQUFRLEVBQUUsSUFBSSxFQUFFLEVBQ2xDZixJQUFJZ0IsUUFBUXJCLE1BQU07SUFFdEIsSUFBSW9CLFNBQVN2QixPQUFPLENBQUMsRUFBRSxLQUFLd0IsT0FBTyxDQUFDaEIsSUFBSSxFQUFFLElBQUlSLE9BQU8sQ0FBQyxFQUFFLEtBQUt3QixPQUFPLENBQUNoQixJQUFJLEVBQUUsRUFBRTtRQUMzRVIsVUFBVXdCLFFBQVFDLE1BQU0sQ0FBQ3pCLFFBQVFLLEtBQUssQ0FBQztRQUN2Q2tCO0lBQ0Y7SUFFQTNCLE9BQU8sQ0FBQzJCLE1BQU0sR0FBR3ZCO0FBQ25CLEdBQ0kwQjtBQUNKOzs7OztDQUtDLEdBQ0QsaVlBQWlZO0FBRzFYLFNBQVNDLFdBQVczQyxLQUFLO0lBQzlCQSxRQUFRRCxVQUFVQyxVQUFVakIsYUFBYTZELElBQUksQ0FBQzVDLFNBQVM2QyxTQUFTQyxhQUFhLENBQUM5QyxVQUFVQSxRQUFRQTtJQUNoRyxJQUFJK0MsSUFBSS9DLE1BQU1nRCxZQUFZLEdBQUdoRCxRQUFRLEdBQ2pDWTtJQUVKLElBQUltQyxLQUFNL0MsQ0FBQUEsUUFBUUEsTUFBTWdELFlBQVksQ0FBQyxJQUFHLEdBQUk7UUFDMUMsb0JBQW9CO1FBQ3BCLElBQUksQ0FBQ0QsRUFBRUUsT0FBTyxFQUFFO1lBQ2RGLEVBQUVFLE9BQU8sR0FBRyxDQUFDO1FBQ2Y7UUFFQXJDLFVBQVVtQyxFQUFFRSxPQUFPLENBQUNqRCxNQUFNO1FBQzFCLE9BQU9ZLFdBQVcsQ0FBQ0EsUUFBUXNDLE1BQU0sR0FBR3RDLFVBQVVtQyxFQUFFRSxPQUFPLENBQUNqRCxNQUFNLEdBQUdtRCxnQkFBZ0JuRDtJQUNuRjtJQUVBLE9BQU8sQ0FBQ0EsUUFBUW9ELFFBQVFDLElBQUksQ0FBQywyREFBMkR0RCxVQUFVQyxTQUFTbUQsZ0JBQWdCbkQsU0FBU0MsVUFBVUQsS0FBSyxDQUFDLEVBQUUsSUFBSTtRQUFDQTtLQUFNLEdBQUdBO0FBQ3RLLEVBQUUsMkRBQTJEO0FBRXRELFNBQVNzRCxZQUFZMUMsT0FBTztJQUNqQyxJQUFJMkMsSUFBSSxFQUFFLEVBQ056QyxJQUFJO0lBRVIsTUFBT0EsSUFBSUYsUUFBUU8sTUFBTSxFQUFFTCxJQUFLO1FBQzlCeUMsQ0FBQyxDQUFDekMsRUFBRSxHQUFHZ0IsY0FBY2xCLE9BQU8sQ0FBQ0UsRUFBRSxFQUFFRixPQUFPLENBQUNFLEVBQUUsQ0FBQ08sS0FBSyxDQUFDO0lBQ3BEO0lBRUEsT0FBT1MsY0FBY2xCLFNBQVMyQztBQUNoQztBQUNPLFNBQVMxQixlQUFlYixPQUFPO0lBQ3BDLElBQUlGLElBQUksR0FDSjBDO0lBQ0p4QyxRQUFRVyxPQUFPLElBQUksZ0VBQWdFO0lBRW5GLE1BQU9iLElBQUlFLFFBQVFHLE1BQU0sRUFBRUwsS0FBSyxFQUFHO1FBQ2pDMEMsSUFBSXhDLE9BQU8sQ0FBQ0YsRUFBRTtRQUNkRSxPQUFPLENBQUNGLEVBQUUsR0FBR0UsT0FBTyxDQUFDRixJQUFJLEVBQUU7UUFDM0JFLE9BQU8sQ0FBQ0YsSUFBSSxFQUFFLEdBQUcwQztJQUNuQjtJQUVBeEMsUUFBUVksUUFBUSxHQUFHLENBQUNaLFFBQVFZLFFBQVE7QUFDdEM7QUFFQSxJQUFJNkIsY0FBYyxTQUFTQSxZQUFZVixDQUFDLEVBQUVXLE1BQU07SUFDOUMsSUFBSUMsT0FBT2QsU0FBU2UsZUFBZSxDQUFDLDhCQUE4QixTQUM5REMsT0FBTyxFQUFFLENBQUN4QyxLQUFLLENBQUN5QyxJQUFJLENBQUNmLEVBQUVnQixVQUFVLEdBQ2pDakQsSUFBSStDLEtBQUsxQyxNQUFNLEVBQ2Y2QztJQUNKTixTQUFTLE1BQU1BLFNBQVM7SUFFeEIsTUFBTyxFQUFFNUMsSUFBSSxDQUFDLEVBQUc7UUFDZmtELE9BQU9ILElBQUksQ0FBQy9DLEVBQUUsQ0FBQ21ELFFBQVEsQ0FBQ0MsV0FBVyxJQUFJLG9IQUFvSDtRQUUzSixJQUFJUixPQUFPUyxPQUFPLENBQUMsTUFBTUgsT0FBTyxPQUFPLEdBQUc7WUFDeENMLEtBQUtTLGNBQWMsQ0FBQyxNQUFNSixNQUFNSCxJQUFJLENBQUMvQyxFQUFFLENBQUN1RCxTQUFTO1FBQ25EO0lBQ0Y7SUFFQSxPQUFPVjtBQUNULEdBQ0lXLGFBQWE7SUFDZkMsTUFBTTtJQUNOQyxRQUFRO0lBQ1JDLFNBQVM7SUFDVEMsTUFBTTtBQUNSLEdBQ0lDLGFBQWEsU0FBU0EsV0FBVzVCLENBQUMsRUFBRTZCLEtBQUs7SUFDM0MsSUFBSUMsUUFBUUQsUUFBUUEsTUFBTUUsS0FBSyxDQUFDLE9BQU8sRUFBRSxFQUNyQ0MsTUFBTSxDQUFDLEdBQ1BqRSxJQUFJK0QsTUFBTTFELE1BQU07SUFFcEIsTUFBTyxFQUFFTCxJQUFJLENBQUMsRUFBRztRQUNmaUUsR0FBRyxDQUFDRixLQUFLLENBQUMvRCxFQUFFLENBQUMsR0FBRyxDQUFDaUMsRUFBRUMsWUFBWSxDQUFDNkIsS0FBSyxDQUFDL0QsRUFBRSxLQUFLO0lBQy9DO0lBRUEsT0FBT2lFO0FBQ1QsR0FBRyxzSkFBc0o7QUFHbEosU0FBU0MsY0FBY0MsT0FBTyxFQUFFQyxJQUFJO0lBQ3pDLElBQUlDLE9BQU9GLFFBQVFHLE9BQU8sQ0FBQ2xCLFdBQVcsSUFDbENtQixPQUFPLGdCQUNQQyxNQUNBQyxHQUNBL0IsR0FDQWdDLEdBQ0FDLElBQ0E5QixNQUNBK0IsT0FDQUMsUUFDQUMsUUFDQUMsR0FDQUMsR0FDQUMsSUFDQUMsSUFDQUMsSUFDQUMsSUFDQUMsSUFDQUMsSUFDQUMsSUFDQUMsSUFDQUMsSUFDQUMsSUFDQTNDO0lBRUosSUFBSXNCLFNBQVMsVUFBVSxDQUFDRixRQUFRd0IsT0FBTyxFQUFFO1FBQ3ZDLE9BQU94QjtJQUNUO0lBRUF0QixPQUFPRixZQUFZd0IsU0FBUztJQUM1QnBCLE9BQU9jLFdBQVdNLFNBQVNYLFVBQVUsQ0FBQ2EsS0FBSztJQUUzQyxJQUFJQSxTQUFTLFFBQVE7UUFDbkJLLElBQUkzQixLQUFLNkMsRUFBRTtRQUNYakIsS0FBSzVCLEtBQUs0QixFQUFFLElBQUlEO1FBQ2hCRCxJQUFJMUIsS0FBSzBCLENBQUM7UUFDVi9CLElBQUlLLEtBQUtMLENBQUM7UUFDVnFDLElBQUloQyxLQUFLOEMsS0FBSyxHQUFHbkIsSUFBSTtRQUNyQk0sSUFBSWpDLEtBQUsrQyxNQUFNLEdBQUduQixLQUFLO1FBRXZCLElBQUlELEtBQUtDLElBQUk7WUFDWCxvREFBb0Q7WUFDcERNLEtBQUtSLElBQUlDLElBQUssS0FBSUgsSUFBRztZQUNyQlcsS0FBS1QsSUFBSUM7WUFDVFMsS0FBS0QsS0FBS0g7WUFDVkssS0FBS0QsS0FBS1QsSUFBSUg7WUFDZGMsS0FBS0YsS0FBS1Q7WUFDVlksS0FBSzVDLElBQUlpQyxLQUFNLEtBQUlKLElBQUc7WUFDdEJnQixLQUFLN0MsSUFBSWlDO1lBQ1RhLEtBQUtELEtBQUtQO1lBQ1ZTLEtBQUtELEtBQUtiLEtBQUtKO1lBQ2ZtQixLQUFLRixLQUFLYjtZQUNWSCxPQUFPLE1BQU1hLEtBQUssTUFBTUUsS0FBSyxPQUFPQyxLQUFLLE9BQU87Z0JBQUNIO2dCQUFJSTtnQkFBSUw7Z0JBQUlNO2dCQUFJUDtnQkFBSU87Z0JBQUlQLEtBQUssQ0FBQ0EsS0FBS0QsRUFBQyxJQUFLO2dCQUFHUTtnQkFBSVIsS0FBSyxDQUFDQyxLQUFLRCxFQUFDLElBQUs7Z0JBQUdRO2dCQUFJUjtnQkFBSVE7Z0JBQUlUO2dCQUFJUztnQkFBSWpCO2dCQUFHZ0I7Z0JBQUloQjtnQkFBR2U7Z0JBQUlmO2dCQUFHZSxLQUFLLENBQUNBLEtBQUtELEVBQUMsSUFBSztnQkFBR2Q7Z0JBQUdjLEtBQUssQ0FBQ0MsS0FBS0QsRUFBQyxJQUFLO2dCQUFHZDtnQkFBR2M7Z0JBQUlkO2dCQUFHYTtnQkFBSUw7Z0JBQUl2QztnQkFBR3dDO2dCQUFJeEM7Z0JBQUd3QyxLQUFLLENBQUNDLEtBQUtELEVBQUMsSUFBSztnQkFBR3hDO2dCQUFHeUMsS0FBSyxDQUFDQSxLQUFLRCxFQUFDLElBQUs7Z0JBQUd4QztnQkFBR3lDO2dCQUFJekM7Z0JBQUcwQztnQkFBSTFDO2dCQUFHMkM7Z0JBQUlDO2dCQUFJRDtnQkFBSUU7YUFBRyxDQUFDUSxJQUFJLENBQUMsT0FBTztRQUMzVCxPQUFPO1lBQ0x2QixPQUFPLE1BQU9DLENBQUFBLElBQUlNLENBQUFBLElBQUssTUFBTXJDLElBQUksT0FBT3NDLElBQUksT0FBTyxDQUFDRCxJQUFJLE9BQU8sQ0FBQ0MsSUFBSSxPQUFPRCxJQUFJO1FBQ2pGO0lBQ0YsT0FBTyxJQUFJVixTQUFTLFlBQVlBLFNBQVMsV0FBVztRQUNsRCxJQUFJQSxTQUFTLFVBQVU7WUFDckJLLElBQUlDLEtBQUs1QixLQUFLMkIsQ0FBQztZQUNmRyxTQUFTSCxJQUFJSDtRQUNmLE9BQU87WUFDTEcsSUFBSTNCLEtBQUs2QyxFQUFFO1lBQ1hqQixLQUFLNUIsS0FBSzRCLEVBQUU7WUFDWkUsU0FBU0YsS0FBS0o7UUFDaEI7UUFFQUUsSUFBSTFCLEtBQUtpRCxFQUFFO1FBQ1h0RCxJQUFJSyxLQUFLa0QsRUFBRTtRQUNYckIsUUFBUUYsSUFBSUg7UUFDWkMsT0FBTyxNQUFPQyxDQUFBQSxJQUFJQyxDQUFBQSxJQUFLLE1BQU1oQyxJQUFJLE9BQU87WUFBQytCLElBQUlDO1lBQUdoQyxJQUFJbUM7WUFBUUosSUFBSUc7WUFBT2xDLElBQUlpQztZQUFJRjtZQUFHL0IsSUFBSWlDO1lBQUlGLElBQUlHO1lBQU9sQyxJQUFJaUM7WUFBSUYsSUFBSUM7WUFBR2hDLElBQUltQztZQUFRSixJQUFJQztZQUFHaEM7WUFBRytCLElBQUlDO1lBQUdoQyxJQUFJbUM7WUFBUUosSUFBSUc7WUFBT2xDLElBQUlpQztZQUFJRjtZQUFHL0IsSUFBSWlDO1lBQUlGLElBQUlHO1lBQU9sQyxJQUFJaUM7WUFBSUYsSUFBSUM7WUFBR2hDLElBQUltQztZQUFRSixJQUFJQztZQUFHaEM7U0FBRSxDQUFDcUQsSUFBSSxDQUFDLE9BQU87SUFDelAsT0FBTyxJQUFJMUIsU0FBUyxRQUFRO1FBQzFCRyxPQUFPLE1BQU16QixLQUFLbUQsRUFBRSxHQUFHLE1BQU1uRCxLQUFLb0QsRUFBRSxHQUFHLE9BQU9wRCxLQUFLa0MsRUFBRSxHQUFHLE1BQU1sQyxLQUFLdUMsRUFBRSxFQUFFLHdNQUF3TTtJQUNqUixPQUFPLElBQUlqQixTQUFTLGNBQWNBLFNBQVMsV0FBVztRQUNwRFMsU0FBUyxDQUFDWCxRQUFRakMsWUFBWSxDQUFDLFlBQVksRUFBQyxFQUFHa0UsS0FBSyxDQUFDckksZ0JBQWdCLEVBQUU7UUFDdkUwRyxJQUFJSyxPQUFPM0UsS0FBSztRQUNoQnVDLElBQUlvQyxPQUFPM0UsS0FBSztRQUNoQnFFLE9BQU8sTUFBTUMsSUFBSSxNQUFNL0IsSUFBSSxPQUFPb0MsT0FBT2lCLElBQUksQ0FBQztRQUU5QyxJQUFJMUIsU0FBUyxXQUFXO1lBQ3RCRyxRQUFRLE1BQU1DLElBQUksTUFBTS9CLElBQUk7UUFDOUI7SUFDRjtJQUVBRyxLQUFLd0QsWUFBWSxDQUFDLEtBQUtDLGdCQUFnQnpELEtBQUswRCxVQUFVLEdBQUdsRSxnQkFBZ0JtQztJQUV6RSxJQUFJSixRQUFRRCxRQUFRcUMsVUFBVSxFQUFFO1FBQzlCckMsUUFBUXFDLFVBQVUsQ0FBQ0MsWUFBWSxDQUFDNUQsTUFBTXNCO1FBQ3RDQSxRQUFRcUMsVUFBVSxDQUFDRSxXQUFXLENBQUN2QztJQUNqQztJQUVBLE9BQU90QjtBQUNULEVBQUUsb0dBQW9HO0FBRS9GLFNBQVM4RCxzQkFBc0I3RyxPQUFPLEVBQUVMLFFBQVE7SUFDckQsSUFBSW1ILElBQUlDLGdCQUFnQi9HLFNBQVNMLFlBQVksSUFBSSxJQUFJLE9BQU9BLFdBQVdBLFdBQVc7SUFDbEYsT0FBT3FILHFCQUFxQkYsRUFBRTFHLE9BQU8sRUFBRTBHLEVBQUU1RyxDQUFDLEVBQUU0RyxFQUFFM0csQ0FBQztBQUNqRDtBQUVBLFNBQVM2RyxxQkFBcUI1RyxPQUFPLEVBQUVGLENBQUMsRUFBRUMsQ0FBQztJQUN6QyxJQUFJd0MsSUFBSXZDLE9BQU8sQ0FBQ0YsRUFBRSxFQUNkK0csSUFBSTdHLE9BQU8sQ0FBQ0YsSUFBSSxFQUFFLEVBQ2xCZ0gsSUFBSTlHLE9BQU8sQ0FBQ0YsSUFBSSxFQUFFLEVBQ2xCeUU7SUFDSmhDLEtBQUssQ0FBQ3NFLElBQUl0RSxDQUFBQSxJQUFLeEM7SUFDZjhHLEtBQUssQ0FBQ0MsSUFBSUQsQ0FBQUEsSUFBSzlHO0lBQ2Z3QyxLQUFLLENBQUNzRSxJQUFJdEUsQ0FBQUEsSUFBS3hDO0lBQ2Z3RSxJQUFJc0MsSUFBSSxDQUFDQyxJQUFJLENBQUM5RyxPQUFPLENBQUNGLElBQUksRUFBRSxHQUFHZ0gsQ0FBQUEsSUFBSy9HLElBQUk4RyxDQUFBQSxJQUFLOUcsSUFBSXdDO0lBQ2pEQSxJQUFJdkMsT0FBTyxDQUFDRixJQUFJLEVBQUU7SUFDbEIrRyxJQUFJN0csT0FBTyxDQUFDRixJQUFJLEVBQUU7SUFDbEJnSCxJQUFJOUcsT0FBTyxDQUFDRixJQUFJLEVBQUU7SUFDbEJ5QyxLQUFLLENBQUNzRSxJQUFJdEUsQ0FBQUEsSUFBS3hDO0lBQ2Y4RyxLQUFLLENBQUNDLElBQUlELENBQUFBLElBQUs5RztJQUNmd0MsS0FBSyxDQUFDc0UsSUFBSXRFLENBQUFBLElBQUt4QztJQUNmLE9BQU9OLE9BQU9iLE9BQU9pSSxJQUFJLENBQUNDLElBQUksQ0FBQzlHLE9BQU8sQ0FBQ0YsSUFBSSxFQUFFLEdBQUdnSCxDQUFBQSxJQUFLL0csSUFBSThHLENBQUFBLElBQUs5RyxJQUFJd0MsR0FBR2dDLEtBQUtwRztBQUM1RTtBQUVPLFNBQVM0SSxhQUFhbkgsT0FBTyxFQUFFb0gsS0FBSyxFQUFFQyxHQUFHO0lBQzlDQSxNQUFNL0gsYUFBYStILE9BQU8sSUFBSXZILGNBQWN1SCxRQUFRLEdBQUcsNk1BQTZNO0lBRXBRRCxRQUFRdEgsY0FBY3NILFVBQVU7SUFDaEMsSUFBSUUsUUFBUWpKLEtBQUtrSixHQUFHLENBQUMsR0FBRyxDQUFDLENBQUUzSSxDQUFBQSxLQUFLeUksTUFBTUQsU0FBUyxJQUFHLElBQzlDckUsT0FBT0wsWUFBWTFDO0lBRXZCLElBQUlvSCxRQUFRQyxLQUFLO1FBQ2ZELFFBQVEsSUFBSUE7UUFDWkMsTUFBTSxJQUFJQTtRQUVWeEcsZ0JBQWdCa0M7UUFFaEJBLEtBQUsxQixXQUFXLEdBQUc7SUFDckI7SUFFQSxJQUFJK0YsUUFBUSxLQUFLQyxNQUFNLEdBQUc7UUFDeEIsSUFBSUcsU0FBU25KLEtBQUtRLEdBQUcsQ0FBQyxDQUFDLENBQUNSLEtBQUtvSixHQUFHLENBQUNMLE9BQU9DLFFBQVE7UUFDaERELFNBQVNJO1FBQ1RILE9BQU9HO0lBQ1Q7SUFFQXpFLEtBQUsxQixXQUFXLElBQUlxRyx5QkFBeUIzRTtJQUM3QyxJQUFJNEUsT0FBT04sTUFBTSxHQUNiTyxJQUFJYixnQkFBZ0JoRSxNQUFNcUUsT0FBTzdILE9BQU8sT0FDeEM0QyxJQUFJNEUsZ0JBQWdCaEUsTUFBTXNFLEtBQUs3SCxTQUMvQnFJLE9BQU8xRixFQUFFL0IsT0FBTyxFQUNoQjBILE9BQU9GLEVBQUV4SCxPQUFPLEVBQ2hCMkgsWUFBWTVGLEVBQUVsQyxRQUFRLEVBQ3RCK0gsWUFBWUosRUFBRTNILFFBQVEsRUFDdEJnSSxLQUFLOUYsRUFBRWpDLENBQUMsRUFDUmdJLEtBQUtOLEVBQUUxSCxDQUFDLEVBQ1JpSSxjQUFjSCxjQUFjRCxXQUM1QkssYUFBYUgsT0FBT0MsTUFBTUMsYUFDMUJFLGFBQ0FDLFFBQ0FDLFFBQ0FySSxHQUNBa0IsTUFDQW9ILGVBQ0E1SCxHQUNBNkg7SUFFSixJQUFJZCxRQUFRTCxPQUFPO1FBQ2pCZSxjQUFjTixZQUFZQyxhQUFhRyxlQUFlRixLQUFLQyxNQUFNRSxjQUFjakcsRUFBRWhDLENBQUMsR0FBR3lILEVBQUV6SCxDQUFDO1FBRXhGLElBQUlKLGNBQWNnRCxNQUFNaUYsV0FBV0UsSUFBSU4sRUFBRXpILENBQUMsR0FBRztZQUMzQzZIO1lBRUEsSUFBSSxDQUFDSyxhQUFhO2dCQUNoQk47Z0JBRUEsSUFBSUssWUFBWTtvQkFDZGpHLEVBQUVoQyxDQUFDLEdBQUcsQ0FBQ2dDLEVBQUVoQyxDQUFDLEdBQUd5SCxFQUFFekgsQ0FBQyxJQUFLLEtBQUl5SCxFQUFFekgsQ0FBQztvQkFDNUI4SCxLQUFLO2dCQUNQLE9BQU8sSUFBSUUsYUFBYTtvQkFDdEJGLE1BQU1DO2dCQUNSO1lBQ0Y7UUFDRjtRQUVBLElBQUk3SixLQUFLUSxHQUFHLENBQUMsSUFBS3dJLENBQUFBLE1BQU1ELEtBQUksS0FBTSxNQUFNO1lBQ3RDVyxZQUFZQyxZQUFZO1FBQzFCLE9BQU8sSUFBSSxDQUFDN0YsRUFBRWhDLENBQUMsSUFBSTRILFdBQVc7WUFDNUJBO1FBQ0YsT0FBTyxJQUFJaEksY0FBY2dELE1BQU1nRixXQUFXRSxJQUFJOUYsRUFBRWhDLENBQUMsS0FBS2tJLGFBQWE7WUFDakVMO1FBQ0Y7UUFFQSxJQUFJSixFQUFFekgsQ0FBQyxLQUFLLEdBQUc7WUFDYjZILFlBQVksQ0FBQ0EsWUFBWSxLQUFLakYsS0FBS3hDLE1BQU07UUFDM0M7UUFFQWEsT0FBTyxFQUFFO1FBQ1RvSCxnQkFBZ0J6RixLQUFLeEMsTUFBTTtRQUMzQkssSUFBSSxJQUFJNEgsZ0JBQWdCbEI7UUFDeEJtQixJQUFJVDtRQUNKcEgsS0FBSyxDQUFDNEgsZ0JBQWdCUixZQUFZRCxTQUFRLElBQUtTO1FBRS9DLElBQUt0SSxJQUFJLEdBQUdBLElBQUlVLEdBQUdWLElBQUs7WUFDdEJ3QixlQUFlTixNQUFNMkIsSUFBSSxDQUFDMEYsTUFBTUQsY0FBYztRQUNoRDtRQUVBekYsT0FBTzNCO0lBQ1QsT0FBTztRQUNMbUgsU0FBU3BHLEVBQUVoQyxDQUFDLEtBQUssSUFBSSxJQUFJRyxpQkFBaUJ1SCxNQUFNSSxJQUFJOUYsRUFBRWhDLENBQUM7UUFFdkQsSUFBSWlILFVBQVVDLEtBQUs7WUFDakJpQixTQUFTaEksaUJBQWlCd0gsTUFBTUksSUFBSUUsYUFBYVIsRUFBRXpILENBQUMsR0FBR2dDLEVBQUVoQyxDQUFDLEdBQUd5SCxFQUFFekgsQ0FBQztZQUNoRWdJLGVBQWdCSSxDQUFBQSxVQUFVRCxNQUFLO1lBQy9CVCxLQUFLckgsTUFBTSxDQUFDeUgsS0FBS00sU0FBUztZQUN6QkQsQ0FBQUEsVUFBVUosRUFBQyxLQUFNSixLQUFLdEgsTUFBTSxDQUFDLEdBQUcwSCxLQUFLSTtZQUN0Q3BJLElBQUk2QyxLQUFLeEMsTUFBTTtZQUVmLE1BQU9MLElBQUs7Z0JBQ1YsNkJBQTZCO2dCQUM1QkEsQ0FBQUEsSUFBSThILGFBQWE5SCxJQUFJNkgsU0FBUSxLQUFNaEYsS0FBS3ZDLE1BQU0sQ0FBQ04sR0FBRztZQUNyRDtRQUNGLE9BQU87WUFDTDJILEtBQUthLEtBQUssR0FBRzFCLHFCQUFxQmEsTUFBTUksS0FBS00sUUFBUSxJQUFJLDJHQUEyRztZQUVwS04sTUFBTU07WUFDTlgsSUFBSUMsSUFBSSxDQUFDSSxHQUFHO1lBQ1o5RixJQUFJMEYsSUFBSSxDQUFDSSxLQUFLLEVBQUU7WUFDaEJKLEtBQUt0SCxNQUFNLEdBQUdzSCxLQUFLeEcsV0FBVyxHQUFHO1lBQ2pDd0csS0FBS3BHLFdBQVcsR0FBR3NCLEtBQUt0QixXQUFXLEdBQUc7WUFDdENvRyxLQUFLYyxJQUFJLENBQUNmLEdBQUd6RixHQUFHeUYsR0FBR3pGLEdBQUd5RixHQUFHekYsR0FBR3lGLEdBQUd6RjtRQUNqQztJQUNGO0lBRUFZLEtBQUsxQixXQUFXLEdBQUc7SUFDbkIsT0FBTzBCO0FBQ1QsRUFBRSxtbkNBQW1uQztBQUVybkMsU0FBUzZGLGVBQWV4SSxPQUFPLEVBQUV5SSxVQUFVLEVBQUVDLFNBQVM7SUFDcERELGFBQWFBLGNBQWM7SUFFM0IsSUFBSSxDQUFDekksUUFBUU8sT0FBTyxFQUFFO1FBQ3BCUCxRQUFRTyxPQUFPLEdBQUcsRUFBRTtRQUNwQlAsUUFBUWtCLE1BQU0sR0FBRyxFQUFFO0lBQ3JCO0lBRUEsSUFBSUUsYUFBYSxDQUFDLENBQUNwQixRQUFRb0IsVUFBVSxJQUFJLElBQ3JDdUgsTUFBTSxJQUFJdkgsWUFDVndILFdBQVdGLFlBQVlELGFBQWFDLFlBQVksSUFBSSxJQUFJMUksUUFBUUcsTUFBTSxFQUN0RTZGLEtBQUtoRyxPQUFPLENBQUN5SSxXQUFXLEVBQ3hCeEMsS0FBS2pHLE9BQU8sQ0FBQ3lJLGFBQWEsRUFBRSxFQUM1QkksZUFBZUosYUFBYUEsYUFBYSxJQUFJckgsYUFBYSxHQUMxRGIsVUFBVVAsUUFBUU8sT0FBTyxFQUN6QlcsU0FBU2xCLFFBQVFrQixNQUFNLEVBQ3ZCbUcsTUFBTSxDQUFDb0IsYUFBYXpJLFFBQVFtQixTQUFTLEdBQUdyQyxTQUFRLEtBQU1BLFdBQ3REZ0ssYUFBYXZJLE9BQU8sQ0FBQ3NJLGVBQWVILFlBQVl0SCxhQUFhLEVBQUUsRUFDL0RqQixTQUFTc0ksYUFBYWxJLE9BQU8sQ0FBQ3NJLGVBQWUsRUFBRSxHQUFHLEdBQ2xEL0ksR0FDQXVJLEdBQ0FwRCxJQUNBRCxJQUNBRCxJQUNBZ0UsSUFDQUMsS0FDQTFELElBQ0FELElBQ0FELElBQ0E2RCxJQUNBQyxLQUNBQyxLQUNBcEosR0FDQXFKLGFBQ0E1SSxHQUNBNkk7SUFDSjlJLFFBQVFKLE1BQU0sR0FBR2UsT0FBT2YsTUFBTSxHQUFHO0lBRWpDLElBQUtrSSxJQUFJSSxhQUFhLEdBQUdKLElBQUlPLFVBQVVQLEtBQUssRUFBRztRQUM3Q3BELEtBQUtqRixPQUFPLENBQUNxSSxJQUFJLEVBQUUsR0FBR3JDO1FBQ3RCaEIsS0FBS2hGLE9BQU8sQ0FBQ3FJLElBQUksRUFBRSxHQUFHckM7UUFDdEJqQixLQUFLL0UsT0FBTyxDQUFDcUksRUFBRSxHQUFHckM7UUFDbEJWLEtBQUt0RixPQUFPLENBQUNxSSxJQUFJLEVBQUUsR0FBR3BDO1FBQ3RCWixLQUFLckYsT0FBTyxDQUFDcUksSUFBSSxFQUFFLEdBQUdwQztRQUN0QmIsS0FBS3BGLE9BQU8sQ0FBQ3FJLElBQUksRUFBRSxHQUFHcEM7UUFDdEI4QyxLQUFLQyxNQUFNQyxLQUFLQyxNQUFNO1FBRXRCLElBQUkxSyxLQUFLeUcsTUFBTSxPQUFPekcsS0FBSzhHLE1BQU0sT0FBTzlHLEtBQUt1RyxNQUFNdkcsS0FBSzRHLE1BQU0sS0FBSztZQUNqRSx3SEFBd0g7WUFDeEgsSUFBSXBGLFFBQVFHLE1BQU0sR0FBRyxHQUFHO2dCQUN0QkgsUUFBUUksTUFBTSxDQUFDaUksR0FBRztnQkFDbEJBLEtBQUs7Z0JBQ0xPLFlBQVk7WUFDZDtRQUNGLE9BQU87WUFDTCxJQUFLOUksSUFBSSxHQUFHQSxLQUFLc0IsWUFBWXRCLElBQUs7Z0JBQ2hDQyxJQUFJNEksTUFBTTdJO2dCQUNWcUosTUFBTSxJQUFJcEo7Z0JBQ1ZnSixLQUFLQyxNQUFPQSxDQUFBQSxNQUFNLENBQUNqSixJQUFJQSxJQUFJa0YsS0FBSyxJQUFJa0UsTUFBT3BKLENBQUFBLElBQUlpRixLQUFLbUUsTUFBTXBFLEVBQUMsQ0FBQyxJQUFLaEYsQ0FBQUE7Z0JBQ2pFa0osS0FBS0MsTUFBT0EsQ0FBQUEsTUFBTSxDQUFDbkosSUFBSUEsSUFBSXVGLEtBQUssSUFBSTZELE1BQU9wSixDQUFBQSxJQUFJc0YsS0FBSzhELE1BQU0vRCxFQUFDLENBQUMsSUFBS3JGLENBQUFBO2dCQUNqRVMsSUFBSTlCLE1BQU11SyxLQUFLQSxLQUFLRixLQUFLQTtnQkFFekIsSUFBSXZJLElBQUk2RyxLQUFLO29CQUNYQSxNQUFNN0c7Z0JBQ1I7Z0JBRUFMLFVBQVVLO2dCQUNWRCxPQUFPLENBQUNzSSxlQUFlLEdBQUcxSTtZQUM1QjtRQUNGO1FBRUE2RixNQUFNZjtRQUNOZ0IsTUFBTVg7SUFDUjtJQUVBLElBQUl3RCxZQUFZO1FBQ2RBLGNBQWMzSTtRQUVkLE1BQU8wSSxlQUFldEksUUFBUUosTUFBTSxFQUFFMEksZUFBZ0I7WUFDcER0SSxPQUFPLENBQUNzSSxhQUFhLElBQUlDO1FBQzNCO0lBQ0Y7SUFFQSxJQUFJdkksUUFBUUosTUFBTSxJQUFJa0gsS0FBSztRQUN6QnJILFFBQVFpQixXQUFXLEdBQUdvSSxZQUFZOUksT0FBTyxDQUFDQSxRQUFRSixNQUFNLEdBQUcsRUFBRSxJQUFJO1FBQ2pFSCxRQUFRbUIsU0FBUyxHQUFHa0c7UUFFcEIsSUFBSWdDLFlBQVloQyxNQUFNLE1BQU07WUFDMUIsc0pBQXNKO1lBQ3RKN0csSUFBSTRJLGNBQWM7WUFFbEIsSUFBS3RKLElBQUksR0FBR0EsSUFBSXVKLFdBQVd2SixLQUFLdUgsSUFBSztnQkFDbkNuRyxNQUFNLENBQUNWLElBQUksR0FBR0QsT0FBTyxDQUFDNkksWUFBWSxHQUFHdEosSUFBSSxFQUFFc0osY0FBY0E7WUFDM0Q7UUFDRjtJQUNGLE9BQU87UUFDTHBKLFFBQVFpQixXQUFXLEdBQUdWLE9BQU8sQ0FBQyxFQUFFLEdBQUc7SUFDckM7SUFFQSxPQUFPa0ksYUFBYXRJLFNBQVNJLE9BQU8sQ0FBQ2tJLGFBQWEsSUFBSSxFQUFFLEdBQUd0STtBQUM3RDtBQUVPLFNBQVNtSCx5QkFBeUIxSCxPQUFPLEVBQUV3QixVQUFVO0lBQzFELElBQUlrSSxZQUFZMUUsUUFBUTlFO0lBRXhCLElBQUtBLElBQUl3SixhQUFhMUUsU0FBUyxHQUFHOUUsSUFBSUYsUUFBUU8sTUFBTSxFQUFFTCxJQUFLO1FBQ3pERixPQUFPLENBQUNFLEVBQUUsQ0FBQ3NCLFVBQVUsR0FBRyxDQUFDLENBQUNBLGNBQWMsSUFBSSw4REFBOEQ7UUFFMUd3RCxVQUFVaEYsT0FBTyxDQUFDRSxFQUFFLENBQUNLLE1BQU07UUFDM0JtSixjQUFjZCxlQUFlNUksT0FBTyxDQUFDRSxFQUFFO0lBQ3pDO0lBRUFGLFFBQVF5QixXQUFXLEdBQUd1RDtJQUN0QmhGLFFBQVFxQixXQUFXLEdBQUdxSTtJQUN0QixPQUFPMUo7QUFDVCxFQUFFLHVOQUF1TjtBQUVsTixTQUFTTSxpQkFBaUJGLE9BQU8sRUFBRUYsQ0FBQyxFQUFFQyxDQUFDO0lBQzVDLElBQUlBLEtBQUssS0FBS0EsS0FBSyxHQUFHO1FBQ3BCLE9BQU87SUFDVDtJQUVBLElBQUl3SixLQUFLdkosT0FBTyxDQUFDRixFQUFFLEVBQ2YwSixLQUFLeEosT0FBTyxDQUFDRixJQUFJLEVBQUUsRUFDbkIySixPQUFPekosT0FBTyxDQUFDRixJQUFJLEVBQUUsRUFDckI0SixPQUFPMUosT0FBTyxDQUFDRixJQUFJLEVBQUUsRUFDckI2SixPQUFPM0osT0FBTyxDQUFDRixJQUFJLEVBQUUsRUFDckI4SixPQUFPNUosT0FBTyxDQUFDRixJQUFJLEVBQUUsRUFDckIrSixLQUFLN0osT0FBTyxDQUFDRixJQUFJLEVBQUUsRUFDbkJnSyxLQUFLOUosT0FBTyxDQUFDRixJQUFJLEVBQUUsRUFDbkJpSyxNQUFNUixLQUFLLENBQUNFLE9BQU9GLEVBQUMsSUFBS3hKLEdBQ3pCZ0YsS0FBSzBFLE9BQU8sQ0FBQ0UsT0FBT0YsSUFBRyxJQUFLMUosR0FDNUJpSyxNQUFNUixLQUFLLENBQUNFLE9BQU9GLEVBQUMsSUFBS3pKLEdBQ3pCcUYsS0FBS3NFLE9BQU8sQ0FBQ0UsT0FBT0YsSUFBRyxJQUFLM0osR0FDNUJpRyxLQUFLK0QsTUFBTSxDQUFDaEYsS0FBS2dGLEdBQUUsSUFBS2hLLEdBQ3hCa0csS0FBSytELE1BQU0sQ0FBQzVFLEtBQUs0RSxHQUFFLElBQUtqSyxHQUN4QmtLLE1BQU1OLE9BQU8sQ0FBQ0UsS0FBS0YsSUFBRyxJQUFLNUosR0FDM0JtSyxNQUFNTixPQUFPLENBQUNFLEtBQUtGLElBQUcsSUFBSzdKO0lBQy9CZ0YsTUFBTSxDQUFDa0YsTUFBTWxGLEVBQUMsSUFBS2hGO0lBQ25CcUYsTUFBTSxDQUFDOEUsTUFBTTlFLEVBQUMsSUFBS3JGO0lBQ25CQyxRQUFRSSxNQUFNLENBQUNOLElBQUksR0FBRyxHQUFHTCxPQUFPc0ssTUFDaEN0SyxPQUFPdUssTUFBTXZLLE9BQU91RyxLQUNwQnZHLE9BQU93RyxLQUFLeEcsT0FBT3VHLEtBQUssQ0FBQ2pCLEtBQUtpQixFQUFDLElBQUtqRyxJQUNwQ04sT0FBT3dHLEtBQUssQ0FBQ2IsS0FBS2EsRUFBQyxJQUFLbEcsSUFBSU4sT0FBT3NGLEtBQ25DdEYsT0FBTzJGLEtBQUszRixPQUFPd0ssTUFDbkJ4SyxPQUFPeUs7SUFDUGxLLFFBQVFPLE9BQU8sSUFBSVAsUUFBUU8sT0FBTyxDQUFDSCxNQUFNLENBQUNOLElBQUksSUFBSUUsUUFBUW9CLFVBQVUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQzVGLE9BQU87QUFDVCxFQUFFLG9EQUFvRDtBQUV0RCxTQUFTdUYsZ0JBQWdCL0csT0FBTyxFQUFFTCxRQUFRLEVBQUU0SyxTQUFTLEVBQUVDLGlCQUFpQjtJQUN0RUQsWUFBWUEsYUFBYSxDQUFDO0lBQzFCdkssUUFBUXFCLFdBQVcsSUFBSXFHLHlCQUF5QjFIO0lBRWhELElBQUlMLFdBQVcsS0FBS0EsV0FBVyxHQUFHO1FBQ2hDQSxXQUFXRCxjQUFjQztJQUMzQjtJQUVBLElBQUlNLFdBQVcsR0FDWEcsVUFBVUosT0FBTyxDQUFDLEVBQUUsRUFDcEJXLFNBQ0FhLFlBQ0FqQixRQUNBa0gsS0FDQUYsS0FDQXJILEdBQ0FDO0lBRUosSUFBSSxDQUFDUixVQUFVO1FBQ2JRLElBQUlELElBQUlELFdBQVc7UUFDbkJHLFVBQVVKLE9BQU8sQ0FBQyxFQUFFO0lBQ3RCLE9BQU8sSUFBSUwsYUFBYSxHQUFHO1FBQ3pCUSxJQUFJO1FBQ0pGLFdBQVdELFFBQVFPLE1BQU0sR0FBRztRQUM1QkgsVUFBVUosT0FBTyxDQUFDQyxTQUFTO1FBQzNCQyxJQUFJRSxRQUFRRyxNQUFNLEdBQUc7SUFDdkIsT0FBTztRQUNMLElBQUlQLFFBQVFPLE1BQU0sR0FBRyxHQUFHO1lBQ3RCLHVGQUF1RjtZQUN2RkEsU0FBU1AsUUFBUXFCLFdBQVcsR0FBRzFCO1lBQy9CNEgsTUFBTXJILElBQUk7WUFFVixNQUFPLENBQUNxSCxPQUFPdkgsT0FBTyxDQUFDRSxJQUFJLENBQUNtQixXQUFXLElBQUlkLE9BQVE7Z0JBQ2pETixXQUFXQztZQUNiO1lBRUFFLFVBQVVKLE9BQU8sQ0FBQ0MsU0FBUztZQUMzQndILE1BQU1GLE1BQU1uSCxRQUFRaUIsV0FBVztZQUMvQjFCLFdBQVcsQ0FBQ1ksU0FBU2tILEdBQUUsSUFBTUYsQ0FBQUEsTUFBTUUsR0FBRSxLQUFNO1FBQzdDO1FBRUE5RyxVQUFVUCxRQUFRTyxPQUFPO1FBQ3pCYSxhQUFhcEIsUUFBUW9CLFVBQVUsRUFBRSx5Q0FBeUM7UUFFMUVqQixTQUFTSCxRQUFRaUIsV0FBVyxHQUFHMUI7UUFDL0JPLElBQUlFLFFBQVFrQixNQUFNLENBQUNmLE1BQU0sR0FBR0gsUUFBUWtCLE1BQU0sQ0FBQyxDQUFDLENBQUVmLENBQUFBLFNBQVNILFFBQVFtQixTQUFTLEVBQUUsSUFBSSxJQUFJYixnQkFBZ0JDLFNBQVNKLFFBQVFaO1FBQ25IOEgsTUFBTXZILElBQUlTLE9BQU8sQ0FBQ1QsSUFBSSxFQUFFLEdBQUc7UUFDM0JxSCxNQUFNNUcsT0FBTyxDQUFDVCxFQUFFO1FBRWhCLElBQUlxSCxNQUFNaEgsUUFBUTtZQUNoQmtILE1BQU1GO1lBQ05BLE1BQU01RyxPQUFPLENBQUMsRUFBRVQsRUFBRTtRQUNwQjtRQUVBQyxJQUFJLElBQUlxQixhQUFjLEVBQUNqQixTQUFTa0gsR0FBRSxJQUFNRixDQUFBQSxNQUFNRSxHQUFFLElBQUt2SCxJQUFJc0IsVUFBUztRQUNsRXRCLElBQUksQ0FBQyxDQUFFQSxDQUFBQSxJQUFJc0IsVUFBUyxJQUFLO1FBRXpCLElBQUlnSixxQkFBcUJySyxNQUFNLEdBQUc7WUFDaEMsSUFBSUQsSUFBSSxJQUFJRSxRQUFRRyxNQUFNLEVBQUU7Z0JBQzFCTCxLQUFLO2dCQUNMQyxJQUFJO1lBQ04sT0FBTyxJQUFJRixXQUFXLElBQUlELFFBQVFPLE1BQU0sRUFBRTtnQkFDeENMLElBQUlDLElBQUk7Z0JBQ1JDLFVBQVVKLE9BQU8sQ0FBQyxFQUFFQyxTQUFTO1lBQy9CO1FBQ0Y7SUFDRjtJQUVBc0ssVUFBVXBLLENBQUMsR0FBR0E7SUFDZG9LLFVBQVVySyxDQUFDLEdBQUdBO0lBQ2RxSyxVQUFVeEgsSUFBSSxHQUFHL0M7SUFDakJ1SyxVQUFVbkssT0FBTyxHQUFHQTtJQUNwQm1LLFVBQVV0SyxRQUFRLEdBQUdBO0lBQ3JCLE9BQU9zSztBQUNUO0FBRU8sU0FBU0Usa0JBQWtCekssT0FBTyxFQUFFTCxRQUFRLEVBQUUrSyxZQUFZLEVBQUVDLEtBQUs7SUFDdEUsSUFBSXZLLFVBQVVKLE9BQU8sQ0FBQyxFQUFFLEVBQ3BCNEssU0FBU0QsU0FBUyxDQUFDLEdBQ25CaEssU0FDQWEsWUFDQWpCLFFBQ0FrSCxLQUNBRixLQUNBckgsR0FDQUMsR0FDQXdDLEdBQ0E0RztJQUVKLElBQUk1SixXQUFXLEtBQUtBLFdBQVcsR0FBRztRQUNoQ0EsV0FBV0QsY0FBY0M7SUFDM0I7SUFFQVMsUUFBUWtCLE1BQU0sSUFBSW9HLHlCQUF5QjFIO0lBRTNDLElBQUlBLFFBQVFPLE1BQU0sR0FBRyxHQUFHO1FBQ3RCLHVGQUF1RjtRQUN2RkEsU0FBU1AsUUFBUXFCLFdBQVcsR0FBRzFCO1FBQy9CNEgsTUFBTXJILElBQUk7UUFFVixNQUFPLENBQUNxSCxPQUFPdkgsT0FBTyxDQUFDRSxJQUFJLENBQUNtQixXQUFXLElBQUlkLE9BQVE7WUFDakRILFVBQVVKLE9BQU8sQ0FBQ0UsRUFBRTtRQUN0QjtRQUVBdUgsTUFBTUYsTUFBTW5ILFFBQVFpQixXQUFXO1FBQy9CMUIsV0FBVyxDQUFDWSxTQUFTa0gsR0FBRSxJQUFNRixDQUFBQSxNQUFNRSxHQUFFLEtBQU07SUFDN0M7SUFFQTlHLFVBQVVQLFFBQVFPLE9BQU87SUFDekJhLGFBQWFwQixRQUFRb0IsVUFBVTtJQUMvQmpCLFNBQVNILFFBQVFpQixXQUFXLEdBQUcxQjtJQUMvQk8sSUFBSUUsUUFBUWtCLE1BQU0sQ0FBQ2YsTUFBTSxHQUFHSCxRQUFRa0IsTUFBTSxDQUFDM0IsV0FBVyxJQUFJLENBQUMsQ0FBRVksQ0FBQUEsU0FBU0gsUUFBUW1CLFNBQVMsSUFBSW5CLFFBQVFrQixNQUFNLENBQUNmLE1BQU0sR0FBRyxFQUFFLElBQUksSUFBSUcsZ0JBQWdCQyxTQUFTSixRQUFRWjtJQUM5SjhILE1BQU12SCxJQUFJUyxPQUFPLENBQUNULElBQUksRUFBRSxHQUFHO0lBQzNCcUgsTUFBTTVHLE9BQU8sQ0FBQ1QsRUFBRTtJQUVoQixJQUFJcUgsTUFBTWhILFFBQVE7UUFDaEJrSCxNQUFNRjtRQUNOQSxNQUFNNUcsT0FBTyxDQUFDLEVBQUVULEVBQUU7SUFDcEI7SUFFQUMsSUFBSSxJQUFJcUIsYUFBYyxFQUFDakIsU0FBU2tILEdBQUUsSUFBTUYsQ0FBQUEsTUFBTUUsR0FBRSxJQUFLdkgsSUFBSXNCLFVBQVMsS0FBTTtJQUN4RStILE1BQU0sSUFBSXBKO0lBQ1ZELElBQUksQ0FBQyxDQUFFQSxDQUFBQSxJQUFJc0IsVUFBUyxJQUFLO0lBQ3pCbUIsSUFBSXZDLE9BQU8sQ0FBQ0YsRUFBRTtJQUNkMEssT0FBT2pHLENBQUMsR0FBRzlFLE9BQU8sQ0FBQ00sSUFBSUEsSUFBS0MsQ0FBQUEsT0FBTyxDQUFDRixJQUFJLEVBQUUsR0FBR3lDLENBQUFBLElBQUssSUFBSTRHLE1BQU9wSixDQUFBQSxJQUFLQyxDQUFBQSxPQUFPLENBQUNGLElBQUksRUFBRSxHQUFHeUMsQ0FBQUEsSUFBSzRHLE1BQU9uSixDQUFBQSxPQUFPLENBQUNGLElBQUksRUFBRSxHQUFHeUMsQ0FBQUEsQ0FBQyxDQUFDLElBQUt4QyxJQUFJd0M7SUFDM0hpSSxPQUFPaEksQ0FBQyxHQUFHL0MsT0FBTyxDQUFDTSxJQUFJQSxJQUFLQyxDQUFBQSxPQUFPLENBQUNGLElBQUksRUFBRSxHQUFJeUMsQ0FBQUEsSUFBSXZDLE9BQU8sQ0FBQ0YsSUFBSSxFQUFFLEtBQUssSUFBSXFKLE1BQU9wSixDQUFBQSxJQUFLQyxDQUFBQSxPQUFPLENBQUNGLElBQUksRUFBRSxHQUFHeUMsQ0FBQUEsSUFBSzRHLE1BQU9uSixDQUFBQSxPQUFPLENBQUNGLElBQUksRUFBRSxHQUFHeUMsQ0FBQUEsQ0FBQyxDQUFDLElBQUt4QyxJQUFJd0M7SUFFOUksSUFBSStILGNBQWM7UUFDaEJFLE9BQU9sQyxLQUFLLEdBQUd0SSxRQUFRaUIsV0FBVyxHQUFHMkYscUJBQXFCNUcsU0FBU0YsR0FBR0MsS0FBSyxJQUFJLElBQUksT0FBT0EsSUFBSUEsSUFBSSxRQUFRQyxRQUFRc0ksS0FBSyxJQUFJO0lBQzdIO0lBRUEsT0FBT2tDO0FBQ1QsRUFBRSw4SkFBOEo7QUFFekosU0FBU0MsaUJBQWlCN0ssT0FBTyxFQUFFMkMsQ0FBQyxFQUFFc0UsQ0FBQyxFQUFFQyxDQUFDLEVBQUVKLENBQUMsRUFBRWdFLEVBQUUsRUFBRUMsRUFBRTtJQUMxRCxJQUFJdEMsSUFBSXpJLFFBQVFPLE1BQU0sRUFDbEJILFNBQ0FRLEdBQ0FWLEdBQ0F5RSxHQUNBL0I7SUFFSixNQUFPLEVBQUU2RixJQUFJLENBQUMsRUFBRztRQUNmckksVUFBVUosT0FBTyxDQUFDeUksRUFBRTtRQUNwQjdILElBQUlSLFFBQVFHLE1BQU07UUFFbEIsSUFBS0wsSUFBSSxHQUFHQSxJQUFJVSxHQUFHVixLQUFLLEVBQUc7WUFDekJ5RSxJQUFJdkUsT0FBTyxDQUFDRixFQUFFO1lBQ2QwQyxJQUFJeEMsT0FBTyxDQUFDRixJQUFJLEVBQUU7WUFDbEJFLE9BQU8sQ0FBQ0YsRUFBRSxHQUFHeUUsSUFBSWhDLElBQUlDLElBQUlzRSxJQUFJNEQ7WUFDN0IxSyxPQUFPLENBQUNGLElBQUksRUFBRSxHQUFHeUUsSUFBSXNDLElBQUlyRSxJQUFJa0UsSUFBSWlFO1FBQ25DO0lBQ0Y7SUFFQS9LLFFBQVFzQyxNQUFNLEdBQUc7SUFDakIsT0FBT3RDO0FBQ1QsRUFBRSwrRUFBK0U7QUFFakYsU0FBU2dMLGFBQWFDLEtBQUssRUFBRUMsS0FBSyxFQUFFcEYsRUFBRSxFQUFFakIsRUFBRSxFQUFFNkQsS0FBSyxFQUFFeUMsWUFBWSxFQUFFQyxTQUFTLEVBQUV6RyxDQUFDLEVBQUUvQixDQUFDO0lBQzlFLElBQUlxSSxVQUFVdEcsS0FBS3VHLFVBQVV0SSxHQUFHO1FBQzlCO0lBQ0Y7SUFFQWtELEtBQUtsSCxLQUFLa0g7SUFDVmpCLEtBQUtqRyxLQUFLaUc7SUFFVixJQUFJd0csV0FBVzNDLFFBQVEsTUFBTXRLLFVBQ3pCa04sV0FBVzVNLEtBQUsyTSxXQUNoQkUsV0FBVy9NLEtBQUs2TSxXQUNoQi9NLEtBQUtELEtBQUtDLEVBQUUsRUFDWmtOLFFBQVFsTixLQUFLLEdBQ2JtTixNQUFNLENBQUNSLFFBQVF0RyxDQUFBQSxJQUFLLEdBQ3BCK0csTUFBTSxDQUFDUixRQUFRdEksQ0FBQUEsSUFBSyxHQUNwQndELEtBQUtrRixXQUFXRyxNQUFNRixXQUFXRyxLQUNqQ3JGLEtBQUssQ0FBQ2tGLFdBQVdFLE1BQU1ILFdBQVdJLEtBQ2xDQyxRQUFRdkYsS0FBS0EsSUFDYndGLFFBQVF2RixLQUFLQSxJQUNid0YsYUFBYUYsUUFBUzdGLENBQUFBLEtBQUtBLEVBQUMsSUFBSzhGLFFBQVMvRyxDQUFBQSxLQUFLQSxFQUFDO0lBRXBELElBQUlnSCxhQUFhLEdBQUc7UUFDbEIvRixLQUFLaEgsTUFBTStNLGNBQWMvRjtRQUN6QmpCLEtBQUsvRixNQUFNK00sY0FBY2hIO0lBQzNCO0lBRUEsSUFBSWlILFFBQVFoRyxLQUFLQSxJQUNiaUcsUUFBUWxILEtBQUtBLElBQ2JtSCxLQUFLLENBQUNGLFFBQVFDLFFBQVFELFFBQVFGLFFBQVFHLFFBQVFKLEtBQUksSUFBTUcsQ0FBQUEsUUFBUUYsUUFBUUcsUUFBUUosS0FBSTtJQUV4RixJQUFJSyxLQUFLLEdBQUc7UUFDVkEsS0FBSztJQUNQO0lBRUEsSUFBSUMsT0FBTyxDQUFDZCxpQkFBaUJDLFlBQVksQ0FBQyxJQUFJLEtBQUt0TSxNQUFNa04sS0FDckRFLE1BQU1ELE9BQVFuRyxDQUFBQSxLQUFLTyxLQUFLeEIsRUFBQyxHQUN6QnNILE1BQU1GLE9BQU8sQ0FBRXBILENBQUFBLEtBQUt1QixLQUFLTixFQUFDLEdBQzFCc0csTUFBTSxDQUFDbkIsUUFBUXRHLENBQUFBLElBQUssR0FDcEIwSCxNQUFNLENBQUNuQixRQUFRdEksQ0FBQUEsSUFBSyxHQUNwQnNELEtBQUtrRyxNQUFPZCxDQUFBQSxXQUFXWSxNQUFNWCxXQUFXWSxHQUFFLEdBQzFDaEcsS0FBS2tHLE1BQU9kLENBQUFBLFdBQVdXLE1BQU1aLFdBQVdhLEdBQUUsR0FDMUNHLEtBQUssQ0FBQ2xHLEtBQUs4RixHQUFFLElBQUtwRyxJQUNsQnlHLEtBQUssQ0FBQ2xHLEtBQUs4RixHQUFFLElBQUt0SCxJQUNsQjJILEtBQUssQ0FBQyxDQUFDcEcsS0FBSzhGLEdBQUUsSUFBS3BHLElBQ25CMkcsS0FBSyxDQUFDLENBQUNwRyxLQUFLOEYsR0FBRSxJQUFLdEgsSUFDbkI2SCxPQUFPSixLQUFLQSxLQUFLQyxLQUFLQSxJQUN0QkksYUFBYSxDQUFDSixLQUFLLElBQUksQ0FBQyxJQUFJLEtBQUtsTyxLQUFLdU8sSUFBSSxDQUFDTixLQUFLeE4sTUFBTTROLFFBQ3RERyxjQUFjLENBQUNQLEtBQUtHLEtBQUtGLEtBQUtDLEtBQUssSUFBSSxDQUFDLElBQUksS0FBS25PLEtBQUt1TyxJQUFJLENBQUMsQ0FBQ04sS0FBS0UsS0FBS0QsS0FBS0UsRUFBQyxJQUFLM04sTUFBTTROLE9BQVFGLENBQUFBLEtBQUtBLEtBQUtDLEtBQUtBLEVBQUM7SUFFbkhLLE1BQU1ELGdCQUFpQkEsQ0FBQUEsY0FBY3ZPLEVBQUMsR0FBSSxzQ0FBc0M7SUFFaEYsSUFBSSxDQUFDOE0sYUFBYXlCLGNBQWMsR0FBRztRQUNqQ0EsZUFBZXJCO0lBQ2pCLE9BQU8sSUFBSUosYUFBYXlCLGNBQWMsR0FBRztRQUN2Q0EsZUFBZXJCO0lBQ2pCO0lBRUFtQixjQUFjbkI7SUFDZHFCLGVBQWVyQjtJQUVmLElBQUl1QixXQUFXMU8sS0FBSzJPLElBQUksQ0FBQ3BPLEtBQUtpTyxlQUFnQnJCLENBQUFBLFFBQVEsS0FDbER4TCxVQUFVLEVBQUUsRUFDWmlOLGlCQUFpQkosY0FBY0UsVUFDL0JHLGdCQUFnQixJQUFJLElBQUkxTyxLQUFLeU8saUJBQWlCLEtBQU0sS0FBSXZPLEtBQUt1TyxpQkFBaUIsRUFBQyxHQUMvRUUsS0FBSzdCLFdBQVd4RixJQUNoQnNILEtBQUs3QixXQUFXekYsSUFDaEJ1SCxLQUFLOUIsV0FBVyxDQUFDMUcsSUFDakJ5SSxLQUFLaEMsV0FBV3pHLElBQ2hCM0U7SUFFSixJQUFLQSxJQUFJLEdBQUdBLElBQUk2TSxVQUFVN00sSUFBSztRQUM3QndJLFFBQVFpRSxhQUFhek0sSUFBSStNO1FBQ3pCN0csS0FBSzFILEtBQUtnSztRQUNWckMsS0FBSzdILEtBQUtrSztRQUNWNEQsS0FBSzVOLEtBQUtnSyxTQUFTdUU7UUFDbkJWLEtBQUsvTixLQUFLa0s7UUFDVjFJLFFBQVEySSxJQUFJLENBQUN2QyxLQUFLOEcsZ0JBQWdCN0csSUFBSUEsS0FBSzZHLGdCQUFnQjlHLElBQUlrRyxLQUFLWSxnQkFBZ0JYLElBQUlBLEtBQUtXLGdCQUFnQlosSUFBSUEsSUFBSUM7SUFDdkgsRUFBRSwySEFBMkg7SUFHN0gsSUFBS3JNLElBQUksR0FBR0EsSUFBSUYsUUFBUU8sTUFBTSxFQUFFTCxLQUFLLEVBQUc7UUFDdENrRyxLQUFLcEcsT0FBTyxDQUFDRSxFQUFFO1FBQ2ZtRyxLQUFLckcsT0FBTyxDQUFDRSxJQUFJLEVBQUU7UUFDbkJGLE9BQU8sQ0FBQ0UsRUFBRSxHQUFHa0csS0FBSytHLEtBQUs5RyxLQUFLZ0gsS0FBS25IO1FBQ2pDbEcsT0FBTyxDQUFDRSxJQUFJLEVBQUUsR0FBR2tHLEtBQUtnSCxLQUFLL0csS0FBS2lILEtBQUtuSDtJQUN2QztJQUVBbkcsT0FBTyxDQUFDRSxJQUFJLEVBQUUsR0FBR3lFLEdBQUcseURBQXlEO0lBRTdFM0UsT0FBTyxDQUFDRSxJQUFJLEVBQUUsR0FBRzBDO0lBQ2pCLE9BQU81QztBQUNULEVBQUUsNE5BQTROO0FBR3ZOLFNBQVN1QyxnQkFBZ0J1RSxDQUFDO0lBQy9CLElBQUluRSxJQUFJLENBQUNtRSxJQUFJLEVBQUMsRUFBR3lHLE9BQU8sQ0FBQ3JQLGFBQWEsU0FBVXNQLENBQUM7UUFDL0MsSUFBSUMsSUFBSSxDQUFDRDtRQUNULE9BQU9DLElBQUksVUFBVUEsSUFBSSxDQUFDLFNBQVMsSUFBSUE7SUFDekMsR0FBR25ILEtBQUssQ0FBQ3RJLGdCQUFnQixFQUFFLEVBQ3ZCLHFJQUFxSTtJQUN6SStFLE9BQU8sRUFBRSxFQUNMMkssWUFBWSxHQUNaQyxZQUFZLEdBQ1pDLFlBQVksSUFBSSxHQUNoQkMsV0FBV2xMLEVBQUVwQyxNQUFNLEVBQ25CeUUsU0FBUyxHQUNUOEksZUFBZSw0QkFBNEJoSCxHQUMzQzVHLEdBQ0F1SSxHQUNBOUQsR0FDQS9CLEdBQ0FtTCxTQUNBQyxZQUNBNU4sU0FDQTZOLFFBQ0FDLFFBQ0FDLE1BQ0FDLE1BQ0FDLFNBQ0FDLGFBQ0FDLE9BQ0FDLE9BQ0ExSyxPQUFPLFNBQVNBLEtBQUsySyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFO1FBQ3JDVCxPQUFPLENBQUNRLEtBQUtGLEVBQUMsSUFBSztRQUNuQkwsT0FBTyxDQUFDUSxLQUFLRixFQUFDLElBQUs7UUFDbkJ0TyxRQUFRdUksSUFBSSxDQUFDOEYsS0FBS04sTUFBTU8sS0FBS04sTUFBTU8sS0FBS1IsTUFBTVMsS0FBS1IsTUFBTU8sSUFBSUM7SUFDL0Q7SUFFQSxJQUFJLENBQUM5SCxLQUFLLENBQUNnRyxNQUFNbkssQ0FBQyxDQUFDLEVBQUUsS0FBS21LLE1BQU1uSyxDQUFDLENBQUMsRUFBRSxHQUFHO1FBQ3JDSCxRQUFRcU0sR0FBRyxDQUFDZjtRQUNaLE9BQU8vSztJQUNUO0lBRUEsSUFBSzdDLElBQUksR0FBR0EsSUFBSTJOLFVBQVUzTixJQUFLO1FBQzdCb08sY0FBY1A7UUFFZCxJQUFJakIsTUFBTW5LLENBQUMsQ0FBQ3pDLEVBQUUsR0FBRztZQUNmNk4sVUFBVXBMLENBQUMsQ0FBQ3pDLEVBQUUsQ0FBQzRPLFdBQVc7WUFDMUJkLGFBQWFELFlBQVlwTCxDQUFDLENBQUN6QyxFQUFFLEVBQUUsMkJBQTJCO1FBQzVELE9BQU87WUFDTCxzRkFBc0Y7WUFDdEZBO1FBQ0Y7UUFFQXlFLElBQUksQ0FBQ2hDLENBQUMsQ0FBQ3pDLElBQUksRUFBRTtRQUNiMEMsSUFBSSxDQUFDRCxDQUFDLENBQUN6QyxJQUFJLEVBQUU7UUFFYixJQUFJOE4sWUFBWTtZQUNkckosS0FBSytJO1lBQ0w5SyxLQUFLK0s7UUFDUDtRQUVBLElBQUksQ0FBQ3pOLEdBQUc7WUFDTitOLFNBQVN0SjtZQUNUdUosU0FBU3RMO1FBQ1gsRUFBRSxhQUFhO1FBR2YsSUFBSW1MLFlBQVksS0FBSztZQUNuQixJQUFJM04sU0FBUztnQkFDWCxJQUFJQSxRQUFRRyxNQUFNLEdBQUcsR0FBRztvQkFDdEIsdUZBQXVGO29CQUN2RndDLEtBQUt4QyxNQUFNLElBQUk7Z0JBQ2pCLE9BQU87b0JBQ0x5RSxVQUFVNUUsUUFBUUcsTUFBTTtnQkFDMUI7WUFDRjtZQUVBbU4sWUFBWU8sU0FBU3RKO1lBQ3JCZ0osWUFBWU8sU0FBU3RMO1lBQ3JCeEMsVUFBVTtnQkFBQ3VFO2dCQUFHL0I7YUFBRTtZQUNoQkcsS0FBSzRGLElBQUksQ0FBQ3ZJO1lBQ1ZGLEtBQUs7WUFDTDZOLFVBQVUsS0FBSyw2RUFBNkU7UUFDNUYscUJBQXFCO1FBQ3ZCLE9BQU8sSUFBSUEsWUFBWSxLQUFLO1lBQzFCLElBQUksQ0FBQzNOLFNBQVM7Z0JBQ1pBLFVBQVU7b0JBQUM7b0JBQUc7aUJBQUU7WUFDbEI7WUFFQSxJQUFJLENBQUM0TixZQUFZO2dCQUNmTixZQUFZQyxZQUFZO1lBQzFCLEVBQUUsd0hBQXdIO1lBRzFIdk4sUUFBUXVJLElBQUksQ0FBQ2hFLEdBQUcvQixHQUFHOEssWUFBWS9LLENBQUMsQ0FBQ3pDLElBQUksRUFBRSxHQUFHLEdBQUd5TixZQUFZaEwsQ0FBQyxDQUFDekMsSUFBSSxFQUFFLEdBQUcsR0FBR3dOLGFBQWEvSyxDQUFDLENBQUN6QyxJQUFJLEVBQUUsR0FBRyxHQUFHeU4sYUFBYWhMLENBQUMsQ0FBQ3pDLElBQUksRUFBRSxHQUFHO1lBQzFIQSxLQUFLLEdBQUcscUNBQXFDO1FBQy9DLE9BQU8sSUFBSTZOLFlBQVksS0FBSztZQUMxQkksT0FBT1Q7WUFDUFUsT0FBT1Q7WUFFUCxJQUFJVyxnQkFBZ0IsT0FBT0EsZ0JBQWdCLEtBQUs7Z0JBQzlDSCxRQUFRVCxZQUFZdE4sT0FBTyxDQUFDQSxRQUFRRyxNQUFNLEdBQUcsRUFBRTtnQkFDL0M2TixRQUFRVCxZQUFZdk4sT0FBTyxDQUFDQSxRQUFRRyxNQUFNLEdBQUcsRUFBRTtZQUNqRDtZQUVBLElBQUksQ0FBQ3lOLFlBQVk7Z0JBQ2ZOLFlBQVlDLFlBQVk7WUFDMUI7WUFFQXZOLFFBQVF1SSxJQUFJLENBQUN3RixNQUFNQyxNQUFNekosR0FBRy9CLEdBQUc4SyxhQUFhL0ssQ0FBQyxDQUFDekMsSUFBSSxFQUFFLEdBQUcsR0FBR3lOLGFBQWFoTCxDQUFDLENBQUN6QyxJQUFJLEVBQUUsR0FBRztZQUNsRkEsS0FBSyxHQUFHLHlCQUF5QjtRQUNuQyxPQUFPLElBQUk2TixZQUFZLEtBQUs7WUFDMUJJLE9BQU9ULFlBQVksQ0FBQy9JLElBQUkrSSxTQUFRLElBQUtFO1lBQ3JDUSxPQUFPVCxZQUFZLENBQUMvSyxJQUFJK0ssU0FBUSxJQUFLQztZQUVyQyxJQUFJLENBQUNJLFlBQVk7Z0JBQ2ZOLFlBQVlDLFlBQVk7WUFDMUI7WUFFQUQsYUFBYS9LLENBQUMsQ0FBQ3pDLElBQUksRUFBRSxHQUFHO1lBQ3hCeU4sYUFBYWhMLENBQUMsQ0FBQ3pDLElBQUksRUFBRSxHQUFHO1lBQ3hCRSxRQUFRdUksSUFBSSxDQUFDd0YsTUFBTUMsTUFBTVYsWUFBWSxDQUFDL0ksSUFBSStJLFNBQVEsSUFBS0UsV0FBV0QsWUFBWSxDQUFDL0ssSUFBSStLLFNBQVEsSUFBS0MsV0FBV0YsV0FBV0M7WUFDdEh6TixLQUFLLEdBQUcseUNBQXlDO1FBQ25ELE9BQU8sSUFBSTZOLFlBQVksS0FBSztZQUMxQkksT0FBT1QsWUFBWXROLE9BQU8sQ0FBQ0EsUUFBUUcsTUFBTSxHQUFHLEVBQUU7WUFDOUM2TixPQUFPVCxZQUFZdk4sT0FBTyxDQUFDQSxRQUFRRyxNQUFNLEdBQUcsRUFBRTtZQUM5Q0gsUUFBUXVJLElBQUksQ0FBQytFLFlBQVlTLE1BQU1SLFlBQVlTLE1BQU16SixJQUFJLENBQUMrSSxZQUFZUyxPQUFPLE1BQU14SixDQUFBQSxJQUFLaUosV0FBV2hMLElBQUksQ0FBQytLLFlBQVlTLE9BQU8sTUFBTXhMLENBQUFBLElBQUtnTCxXQUFXRixZQUFZL0ksR0FBR2dKLFlBQVkvSztZQUN4SzFDLEtBQUssR0FBRyx3QkFBd0I7UUFDbEMsT0FBTyxJQUFJNk4sWUFBWSxLQUFLO1lBQzFCakssS0FBSzRKLFdBQVdDLFdBQVdELFlBQVkvSSxHQUFHZ0o7WUFDMUN6TixLQUFLLEdBQUcsc0JBQXNCO1FBQ2hDLE9BQU8sSUFBSTZOLFlBQVksS0FBSztZQUMxQiw4RUFBOEU7WUFDOUVqSyxLQUFLNEosV0FBV0MsV0FBV0QsV0FBV0MsWUFBWWhKLElBQUtxSixDQUFBQSxhQUFhTCxZQUFZRCxZQUFZO1lBQzVGeE4sS0FBSyxHQUFHLDRCQUE0QjtRQUN0QyxPQUFPLElBQUk2TixZQUFZLE9BQU9BLFlBQVksS0FBSztZQUM3QyxJQUFJQSxZQUFZLEtBQUs7Z0JBQ25CcEosSUFBSXNKO2dCQUNKckwsSUFBSXNMO2dCQUNKOU4sUUFBUTJPLE1BQU0sR0FBRztZQUNuQjtZQUVBLElBQUloQixZQUFZLE9BQU9uUCxLQUFLOE8sWUFBWS9JLEtBQUssT0FBTy9GLEtBQUsrTyxZQUFZL0ssS0FBSyxLQUFLO2dCQUM3RWtCLEtBQUs0SixXQUFXQyxXQUFXaEosR0FBRy9CO2dCQUU5QixJQUFJbUwsWUFBWSxLQUFLO29CQUNuQjdOLEtBQUs7Z0JBQ1A7WUFDRjtZQUVBd04sWUFBWS9JO1lBQ1pnSixZQUFZL0ssR0FBRyxZQUFZO1FBQzdCLE9BQU8sSUFBSW1MLFlBQVksS0FBSztZQUMxQlEsUUFBUTVMLENBQUMsQ0FBQ3pDLElBQUksRUFBRTtZQUNoQnNPLFFBQVE3TCxDQUFDLENBQUN6QyxJQUFJLEVBQUU7WUFDaEJpTyxPQUFPeEwsQ0FBQyxDQUFDekMsSUFBSSxFQUFFO1lBQ2ZrTyxPQUFPekwsQ0FBQyxDQUFDekMsSUFBSSxFQUFFO1lBQ2Z1SSxJQUFJO1lBRUosSUFBSThGLE1BQU1oTyxNQUFNLEdBQUcsR0FBRztnQkFDcEIsMEtBQTBLO2dCQUMxSyxJQUFJZ08sTUFBTWhPLE1BQU0sR0FBRyxHQUFHO29CQUNwQjZOLE9BQU9EO29CQUNQQSxPQUFPSztvQkFDUC9GO2dCQUNGLE9BQU87b0JBQ0wyRixPQUFPSTtvQkFDUEwsT0FBT0ksTUFBTVMsTUFBTSxDQUFDO29CQUNwQnZHLEtBQUs7Z0JBQ1A7Z0JBRUErRixRQUFRRCxNQUFNVSxNQUFNLENBQUM7Z0JBQ3JCVixRQUFRQSxNQUFNVSxNQUFNLENBQUM7WUFDdkI7WUFFQVosVUFBVXJELGFBQWEwQyxXQUFXQyxXQUFXLENBQUNoTCxDQUFDLENBQUN6QyxJQUFJLEVBQUUsRUFBRSxDQUFDeUMsQ0FBQyxDQUFDekMsSUFBSSxFQUFFLEVBQUUsQ0FBQ3lDLENBQUMsQ0FBQ3pDLElBQUksRUFBRSxFQUFFLENBQUNxTyxPQUFPLENBQUNDLE9BQU8sQ0FBQ1IsYUFBYU4sWUFBWSxLQUFLUyxPQUFPLEdBQUcsQ0FBQ0gsYUFBYUwsWUFBWSxLQUFLUyxPQUFPO1lBQzdLbE8sS0FBS3VJO1lBRUwsSUFBSTRGLFNBQVM7Z0JBQ1gsSUFBSzVGLElBQUksR0FBR0EsSUFBSTRGLFFBQVE5TixNQUFNLEVBQUVrSSxJQUFLO29CQUNuQ3JJLFFBQVF1SSxJQUFJLENBQUMwRixPQUFPLENBQUM1RixFQUFFO2dCQUN6QjtZQUNGO1lBRUFpRixZQUFZdE4sT0FBTyxDQUFDQSxRQUFRRyxNQUFNLEdBQUcsRUFBRTtZQUN2Q29OLFlBQVl2TixPQUFPLENBQUNBLFFBQVFHLE1BQU0sR0FBRyxFQUFFO1FBQ3pDLE9BQU87WUFDTGlDLFFBQVFxTSxHQUFHLENBQUNmO1FBQ2Q7SUFDRjtJQUVBNU4sSUFBSUUsUUFBUUcsTUFBTTtJQUVsQixJQUFJTCxJQUFJLEdBQUc7UUFDVCw4REFBOEQ7UUFDOUQ2QyxLQUFLbU0sR0FBRztRQUNSaFAsSUFBSTtJQUNOLE9BQU8sSUFBSUUsT0FBTyxDQUFDLEVBQUUsS0FBS0EsT0FBTyxDQUFDRixJQUFJLEVBQUUsSUFBSUUsT0FBTyxDQUFDLEVBQUUsS0FBS0EsT0FBTyxDQUFDRixJQUFJLEVBQUUsRUFBRTtRQUN6RUUsUUFBUTJPLE1BQU0sR0FBRztJQUNuQjtJQUVBaE0sS0FBS3RCLFdBQVcsR0FBR3VELFNBQVM5RTtJQUM1QixPQUFPNkM7QUFDVCxFQUFFLCtNQUErTTtBQUUxTSxTQUFTb00sZUFBZS9JLEVBQUUsRUFBRUMsRUFBRSxFQUFFbEIsRUFBRSxFQUFFSyxFQUFFLEVBQUVKLEVBQUUsRUFBRUssRUFBRSxFQUFFSixFQUFFLEVBQUVLLEVBQUUsRUFBRTBKLFNBQVMsRUFBRXBLLE1BQU0sRUFBRXJELEtBQUs7SUFDckYsSUFBSTBOLE1BQU0sQ0FBQ2pKLEtBQUtqQixFQUFDLElBQUssR0FDbEJtSyxNQUFNLENBQUNqSixLQUFLYixFQUFDLElBQUssR0FDbEIrSixNQUFNLENBQUNwSyxLQUFLQyxFQUFDLElBQUssR0FDbEJvSyxNQUFNLENBQUNoSyxLQUFLQyxFQUFDLElBQUssR0FDbEJnSyxNQUFNLENBQUNySyxLQUFLQyxFQUFDLElBQUssR0FDbEJxSyxNQUFNLENBQUNqSyxLQUFLQyxFQUFDLElBQUssR0FDbEJpSyxPQUFPLENBQUNOLE1BQU1FLEdBQUUsSUFBSyxHQUNyQkssT0FBTyxDQUFDTixNQUFNRSxHQUFFLElBQUssR0FDckJLLE9BQU8sQ0FBQ04sTUFBTUUsR0FBRSxJQUFLLEdBQ3JCSyxPQUFPLENBQUNOLE1BQU1FLEdBQUUsSUFBSyxHQUNyQkssUUFBUSxDQUFDSixPQUFPRSxJQUFHLElBQUssR0FDeEJHLFFBQVEsQ0FBQ0osT0FBT0UsSUFBRyxJQUFLLEdBQ3hCRyxLQUFLNUssS0FBS2UsSUFDVjhKLEtBQUt4SyxLQUFLVyxJQUNWOEosS0FBS3ZSLEtBQUssQ0FBQ3VHLEtBQUtFLEVBQUMsSUFBSzZLLEtBQUssQ0FBQzFLLEtBQUtFLEVBQUMsSUFBS3VLLEtBQ3ZDRyxLQUFLeFIsS0FBSyxDQUFDd0csS0FBS0MsRUFBQyxJQUFLNkssS0FBSyxDQUFDekssS0FBS0MsRUFBQyxJQUFLdUssS0FDdkMxUDtJQUVKLElBQUksQ0FBQ3lFLFFBQVE7UUFDWEEsU0FBUztZQUFDb0I7WUFBSUM7WUFBSWhCO1lBQUlLO1NBQUc7UUFDekIvRCxRQUFRO0lBQ1Y7SUFFQXFELE9BQU94RSxNQUFNLENBQUNtQixTQUFTcUQsT0FBT3pFLE1BQU0sR0FBRyxHQUFHLEdBQUd3UCxPQUFPQztJQUVwRCxJQUFJLENBQUNHLEtBQUtDLEVBQUMsSUFBTUQsQ0FBQUEsS0FBS0MsRUFBQyxJQUFLaEIsWUFBYWEsQ0FBQUEsS0FBS0EsS0FBS0MsS0FBS0EsRUFBQyxHQUFJO1FBQzNEM1AsU0FBU3lFLE9BQU96RSxNQUFNO1FBQ3RCNE8sZUFBZS9JLElBQUlDLElBQUlnSixLQUFLQyxLQUFLSyxNQUFNQyxNQUFNRyxPQUFPQyxPQUFPWixXQUFXcEssUUFBUXJEO1FBQzlFd04sZUFBZVksT0FBT0MsT0FBT0gsTUFBTUMsTUFBTUwsS0FBS0MsS0FBS3JLLElBQUlLLElBQUkwSixXQUFXcEssUUFBUXJELFFBQVEsSUFBS3FELENBQUFBLE9BQU96RSxNQUFNLEdBQUdBLE1BQUs7SUFDbEg7SUFFQSxPQUFPeUU7QUFDVDtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUEsR0FDQSwyVEFBMlQ7QUFFcFQsU0FBU3FMLG9CQUFvQnJMLE1BQU0sRUFBRXNMLFNBQVM7SUFDbkQsSUFBSUEsY0FBYyxLQUFLLEdBQUc7UUFDeEJBLFlBQVk7SUFDZDtJQUVBLElBQUkzTCxJQUFJSyxNQUFNLENBQUMsRUFBRSxFQUNicEMsSUFBSSxHQUNKeEMsVUFBVTtRQUFDdUU7UUFBRy9CO0tBQUUsRUFDaEIxQyxJQUFJO0lBRVIsTUFBT0EsSUFBSThFLE9BQU96RSxNQUFNLEVBQUVMLEtBQUssRUFBRztRQUNoQ0UsUUFBUXVJLElBQUksQ0FBQ2hFLEdBQUcvQixHQUFHb0MsTUFBTSxDQUFDOUUsRUFBRSxFQUFFMEMsSUFBSSxDQUFDb0MsTUFBTSxDQUFDOUUsRUFBRSxHQUFHeUUsQ0FBQUEsSUFBSzJMLFlBQVksR0FBRzNMLElBQUlLLE1BQU0sQ0FBQzlFLEVBQUUsRUFBRSxDQUFDMEM7SUFDckY7SUFFQSxPQUFPeEM7QUFDVCxFQUFFLDJEQUEyRDtBQUV0RCxTQUFTbVEsZ0JBQWdCdkwsTUFBTSxFQUFFc0wsU0FBUztJQUMvQyw2Q0FBNkM7SUFDN0MxUixLQUFLb0csTUFBTSxDQUFDLEVBQUUsR0FBR0EsTUFBTSxDQUFDLEVBQUUsSUFBSSxRQUFRcEcsS0FBS29HLE1BQU0sQ0FBQyxFQUFFLEdBQUdBLE1BQU0sQ0FBQyxFQUFFLElBQUksUUFBU0EsQ0FBQUEsU0FBU0EsT0FBT3ZFLEtBQUssQ0FBQyxFQUFDLEdBQUksK0RBQStEO0lBRXZLLElBQUlHLElBQUlvRSxPQUFPekUsTUFBTSxHQUFHLEdBQ3BCb0UsSUFBSSxDQUFDSyxNQUFNLENBQUMsRUFBRSxFQUNkcEMsSUFBSSxDQUFDb0MsTUFBTSxDQUFDLEVBQUUsRUFDZHdMLFFBQVEsQ0FBQ3hMLE1BQU0sQ0FBQyxFQUFFLEVBQ2xCeUwsUUFBUSxDQUFDekwsTUFBTSxDQUFDLEVBQUUsRUFDbEI1RSxVQUFVO1FBQUN1RTtRQUFHL0I7UUFBRytCO1FBQUcvQjtLQUFFLEVBQ3RCNkksTUFBTStFLFFBQVE3TCxHQUNkK0csTUFBTStFLFFBQVE3TixHQUNkbU0sU0FBUzFRLEtBQUtRLEdBQUcsQ0FBQ21HLE1BQU0sQ0FBQ3BFLEVBQUUsR0FBRytELEtBQUssU0FBU3RHLEtBQUtRLEdBQUcsQ0FBQ21HLE1BQU0sQ0FBQ3BFLElBQUksRUFBRSxHQUFHZ0MsS0FBSyxPQUMxRThOLE9BQ0FDLE9BQ0F6USxHQUNBMFEsS0FDQUMsS0FDQUMsSUFDQUMsSUFDQUMsSUFDQUMsSUFDQUMsS0FDQUMsS0FDQUMsS0FDQUMsS0FDQUMsS0FDQUM7SUFFSixJQUFJeEMsUUFBUTtRQUNWLGlQQUFpUDtRQUNqUC9KLE9BQU8yRCxJQUFJLENBQUM2SCxPQUFPQztRQUNuQkQsUUFBUTdMO1FBQ1I4TCxRQUFRN047UUFDUitCLElBQUlLLE1BQU0sQ0FBQ3BFLElBQUksRUFBRTtRQUNqQmdDLElBQUlvQyxNQUFNLENBQUNwRSxJQUFJLEVBQUU7UUFDakJvRSxPQUFPd00sT0FBTyxDQUFDN00sR0FBRy9CO1FBQ2xCaEMsS0FBSztJQUNQO0lBRUEwUCxZQUFZQSxhQUFhQSxjQUFjLElBQUksQ0FBQ0EsWUFBWTtJQUV4RCxJQUFLcFEsSUFBSSxHQUFHQSxJQUFJVSxHQUFHVixLQUFLLEVBQUc7UUFDekJ3USxRQUFRL0w7UUFDUmdNLFFBQVEvTjtRQUNSK0IsSUFBSTZMO1FBQ0o1TixJQUFJNk47UUFDSkQsUUFBUSxDQUFDeEwsTUFBTSxDQUFDOUUsSUFBSSxFQUFFO1FBQ3RCdVEsUUFBUSxDQUFDekwsTUFBTSxDQUFDOUUsSUFBSSxFQUFFO1FBRXRCLElBQUl5RSxNQUFNNkwsU0FBUzVOLE1BQU02TixPQUFPO1lBQzlCO1FBQ0Y7UUFFQUcsTUFBTW5GO1FBQ05vRixNQUFNbkY7UUFDTkQsTUFBTStFLFFBQVE3TDtRQUNkK0csTUFBTStFLFFBQVE3TjtRQUNka08sS0FBS2hTLE1BQU04UixNQUFNQSxNQUFNQyxNQUFNQSxNQUFNLHdGQUF3RjtRQUUzSEUsS0FBS2pTLE1BQU0yTSxNQUFNQSxNQUFNQyxNQUFNQTtRQUM3QnNGLEtBQUtsUyxNQUFNVCxLQUFLb1QsR0FBRyxDQUFDaEcsTUFBTXNGLEtBQUtILE1BQU1FLElBQUksS0FBS3pTLEtBQUtvVCxHQUFHLENBQUMvRixNQUFNcUYsS0FBS0YsTUFBTUMsSUFBSTtRQUM1RUcsS0FBSyxDQUFDSCxLQUFLQyxFQUFDLElBQUtULFlBQVksT0FBT1U7UUFDcENFLE1BQU12TSxJQUFJLENBQUNBLElBQUkrTCxLQUFJLElBQU1JLENBQUFBLEtBQUtHLEtBQUtILEtBQUs7UUFDeENLLE1BQU14TSxJQUFJLENBQUM2TCxRQUFRN0wsQ0FBQUEsSUFBTW9NLENBQUFBLEtBQUtFLEtBQUtGLEtBQUs7UUFDeENLLE1BQU16TSxJQUFLdU0sQ0FBQUEsTUFBTyxFQUFDQyxNQUFNRCxHQUFFLElBQU1KLENBQUFBLEtBQUssSUFBS0EsQ0FBQUEsS0FBS0MsRUFBQyxJQUFLLEdBQUUsSUFBSyxLQUFLLEVBQUM7UUFDbkVNLE1BQU16TyxJQUFJLENBQUNBLElBQUkrTixLQUFJLElBQU1HLENBQUFBLEtBQUtHLEtBQUtILEtBQUs7UUFDeENRLE1BQU0xTyxJQUFJLENBQUM2TixRQUFRN04sQ0FBQUEsSUFBTW1PLENBQUFBLEtBQUtFLEtBQUtGLEtBQUs7UUFDeENRLE1BQU0zTyxJQUFLeU8sQ0FBQUEsTUFBTyxFQUFDQyxNQUFNRCxHQUFFLElBQU1QLENBQUFBLEtBQUssSUFBS0EsQ0FBQUEsS0FBS0MsRUFBQyxJQUFLLEdBQUUsSUFBSyxLQUFLLEVBQUM7UUFFbkUsSUFBSXBNLE1BQU0rTCxTQUFTOU4sTUFBTStOLE9BQU87WUFDOUJ2USxRQUFRdUksSUFBSSxDQUFDOUksT0FBT3FSLE1BQU1FLE1BQzFCdlIsT0FBT3dSLE1BQU1FLE1BQU0xUixPQUFPOEUsSUFDMUI5RSxPQUFPK0MsSUFBSS9DLE9BQU9zUixNQUFNQyxNQUN4QnZSLE9BQU95UixNQUFNQztRQUNmO0lBQ0Y7SUFFQTVNLE1BQU02TCxTQUFTNU4sTUFBTTZOLFNBQVNyUSxRQUFRRyxNQUFNLEdBQUcsSUFBSUgsUUFBUXVJLElBQUksQ0FBQzlJLE9BQU8yUSxRQUFRM1EsT0FBTzRRLFFBQVE1USxPQUFPMlEsUUFBUTNRLE9BQU80USxVQUFVclEsUUFBUUcsTUFBTSxJQUFJO0lBRWhKLElBQUlILFFBQVFHLE1BQU0sS0FBSyxHQUFHO1FBQ3hCLGtCQUFrQjtRQUNsQkgsUUFBUXVJLElBQUksQ0FBQ2hFLEdBQUcvQixHQUFHK0IsR0FBRy9CLEdBQUcrQixHQUFHL0I7SUFDOUIsT0FBTyxJQUFJbU0sUUFBUTtRQUNqQjNPLFFBQVFJLE1BQU0sQ0FBQyxHQUFHO1FBQ2xCSixRQUFRRyxNQUFNLEdBQUdILFFBQVFHLE1BQU0sR0FBRztJQUNwQztJQUVBLE9BQU9IO0FBQ1QsRUFBRSw4RkFBOEY7QUFFaEcsU0FBU3NSLGVBQWUvTSxDQUFDLEVBQUUvQixDQUFDLEVBQUV3RCxFQUFFLEVBQUVDLEVBQUUsRUFBRWxCLEVBQUUsRUFBRUssRUFBRTtJQUMxQyxJQUFJeUssS0FBSzlLLEtBQUtpQixJQUNWOEosS0FBSzFLLEtBQUthLElBQ1ZsRztJQUVKLElBQUk4UCxNQUFNQyxJQUFJO1FBQ1ovUCxJQUFJLENBQUMsQ0FBQ3dFLElBQUl5QixFQUFDLElBQUs2SixLQUFLLENBQUNyTixJQUFJeUQsRUFBQyxJQUFLNkosRUFBQyxJQUFNRCxDQUFBQSxLQUFLQSxLQUFLQyxLQUFLQSxFQUFDO1FBRXZELElBQUkvUCxJQUFJLEdBQUc7WUFDVGlHLEtBQUtqQjtZQUNMa0IsS0FBS2I7UUFDUCxPQUFPLElBQUlyRixJQUFJLEdBQUc7WUFDaEJpRyxNQUFNNkosS0FBSzlQO1lBQ1hrRyxNQUFNNkosS0FBSy9QO1FBQ2I7SUFDRjtJQUVBLE9BQU85QixLQUFLb1QsR0FBRyxDQUFDOU0sSUFBSXlCLElBQUksS0FBSy9ILEtBQUtvVCxHQUFHLENBQUM3TyxJQUFJeUQsSUFBSTtBQUNoRDtBQUVBLFNBQVNzTCxhQUFhM00sTUFBTSxFQUFFNE0sS0FBSyxFQUFFQyxJQUFJLEVBQUVDLFNBQVMsRUFBRUMsVUFBVTtJQUM5RCxJQUFJQyxZQUFZRixXQUNaRyxTQUFTak4sTUFBTSxDQUFDNE0sTUFBTSxFQUN0Qk0sU0FBU2xOLE1BQU0sQ0FBQzRNLFFBQVEsRUFBRSxFQUMxQjNHLFFBQVFqRyxNQUFNLENBQUM2TSxLQUFLLEVBQ3BCM0csUUFBUWxHLE1BQU0sQ0FBQzZNLE9BQU8sRUFBRSxFQUN4QmxRLE9BQ0F6QixHQUNBNEc7SUFFSixJQUFLNUcsSUFBSTBSLFFBQVEsR0FBRzFSLElBQUkyUixNQUFNM1IsS0FBSyxFQUFHO1FBQ3BDNEcsSUFBSTRLLGVBQWUxTSxNQUFNLENBQUM5RSxFQUFFLEVBQUU4RSxNQUFNLENBQUM5RSxJQUFJLEVBQUUsRUFBRStSLFFBQVFDLFFBQVFqSCxPQUFPQztRQUVwRSxJQUFJcEUsSUFBSWtMLFdBQVc7WUFDakJyUSxRQUFRekI7WUFDUjhSLFlBQVlsTDtRQUNkO0lBQ0Y7SUFFQSxJQUFJa0wsWUFBWUYsV0FBVztRQUN6Qm5RLFFBQVFpUSxRQUFRLEtBQUtELGFBQWEzTSxRQUFRNE0sT0FBT2pRLE9BQU9tUSxXQUFXQztRQUNuRUEsV0FBV3BKLElBQUksQ0FBQzNELE1BQU0sQ0FBQ3JELE1BQU0sRUFBRXFELE1BQU0sQ0FBQ3JELFFBQVEsRUFBRTtRQUNoRGtRLE9BQU9sUSxRQUFRLEtBQUtnUSxhQUFhM00sUUFBUXJELE9BQU9rUSxNQUFNQyxXQUFXQztJQUNuRTtBQUNGLEVBQUUsMERBQTBEO0FBR3JELFNBQVNJLGVBQWVuTixNQUFNLEVBQUU4TSxTQUFTO0lBQzlDLElBQUlwQixRQUFRMEIsV0FBV3BOLE1BQU0sQ0FBQyxFQUFFLEdBQzVCMkwsUUFBUXlCLFdBQVdwTixNQUFNLENBQUMsRUFBRSxHQUM1QjBILE9BQU87UUFBQ2dFO1FBQU9DO0tBQU0sRUFDckIvUCxJQUFJb0UsT0FBT3pFLE1BQU0sR0FBRyxHQUNwQkwsR0FDQXlFLEdBQ0EvQixHQUNBcU4sSUFDQUMsSUFDQXRGLFFBQ0FpSDtJQUNKQyxZQUFZelQsS0FBS29ULEdBQUcsQ0FBQ0ssYUFBYSxHQUFHO0lBRXJDLElBQUs1UixJQUFJLEdBQUdBLElBQUlVLEdBQUdWLEtBQUssRUFBRztRQUN6QnlFLElBQUl5TixXQUFXcE4sTUFBTSxDQUFDOUUsRUFBRTtRQUN4QjBDLElBQUl3UCxXQUFXcE4sTUFBTSxDQUFDOUUsSUFBSSxFQUFFO1FBQzVCK1AsS0FBS1MsUUFBUS9MO1FBQ2J1TCxLQUFLUyxRQUFRL047UUFFYixJQUFJcU4sS0FBS0EsS0FBS0MsS0FBS0EsS0FBSzRCLFdBQVc7WUFDakNwRixLQUFLL0QsSUFBSSxDQUFDaEUsR0FBRy9CO1lBQ2I4TixRQUFRL0w7WUFDUmdNLFFBQVEvTjtRQUNWO0lBQ0Y7SUFFQThKLEtBQUsvRCxJQUFJLENBQUN5SixXQUFXcE4sTUFBTSxDQUFDcEUsRUFBRSxHQUFHd1IsV0FBV3BOLE1BQU0sQ0FBQ3BFLElBQUksRUFBRTtJQUN6RGlSLE9BQU9uRixLQUFLbk0sTUFBTSxHQUFHO0lBQ3JCcUssU0FBUztRQUFDOEIsSUFBSSxDQUFDLEVBQUU7UUFBRUEsSUFBSSxDQUFDLEVBQUU7S0FBQztJQUMzQmlGLGFBQWFqRixNQUFNLEdBQUdtRixNQUFNQyxXQUFXbEg7SUFDdkNBLE9BQU9qQyxJQUFJLENBQUMrRCxJQUFJLENBQUNtRixLQUFLLEVBQUVuRixJQUFJLENBQUNtRixPQUFPLEVBQUU7SUFDdEMsT0FBT2pIO0FBQ1Q7QUFFQSxTQUFTeUgsMkJBQTJCQyxVQUFVLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFcEwsS0FBSyxFQUFFQyxHQUFHLEVBQUVvTCxNQUFNLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFdk0sRUFBRSxFQUFFQyxFQUFFLEVBQUVsQixFQUFFLEVBQUVLLEVBQUUsRUFBRUosRUFBRSxFQUFFSyxFQUFFO0lBQ3hHLElBQUlzRCxNQUFNLENBQUMxQixNQUFNRCxLQUFJLElBQUtxTCxRQUN0QkcsT0FBTyxHQUNQelMsSUFBSWlILE9BQ0p6QyxHQUNBL0IsR0FDQWtFLEdBQ0FtSixJQUNBQyxJQUNBM0c7SUFDSnpILGdCQUFnQjVDO0lBRWhCLE1BQU9pQixLQUFLa0gsSUFBSztRQUNma0MsTUFBTSxJQUFJcEo7UUFDVndFLElBQUk0RSxNQUFNQSxNQUFNQSxNQUFNbUosS0FBSyxJQUFJbkosTUFBTUEsTUFBTXBKLElBQUlpRyxLQUFLLElBQUltRCxNQUFNcEosSUFBSUEsSUFBSWdGLEtBQUtoRixJQUFJQSxJQUFJQSxJQUFJaUY7UUFDdkZ4QyxJQUFJMkcsTUFBTUEsTUFBTUEsTUFBTW9KLEtBQUssSUFBSXBKLE1BQU1BLE1BQU1wSixJQUFJa0csS0FBSyxJQUFJa0QsTUFBTXBKLElBQUlBLElBQUlxRixLQUFLckYsSUFBSUEsSUFBSUEsSUFBSXNGO1FBQ3ZGd0ssS0FBS3RMLElBQUk0TjtRQUNUckMsS0FBS3ROLElBQUk0UDtRQUNUMUwsSUFBSW1KLEtBQUtBLEtBQUtDLEtBQUtBO1FBRW5CLElBQUlwSixJQUFJaEYsZUFBZTtZQUNyQkEsZ0JBQWdCZ0Y7WUFDaEI4TCxPQUFPelM7UUFDVDtRQUVBQSxLQUFLNEk7SUFDUDtJQUVBLE9BQU91SixhQUFhLElBQUlELDJCQUEyQkMsYUFBYSxHQUFHQyxJQUFJQyxJQUFJblUsS0FBS2tKLEdBQUcsQ0FBQ3FMLE9BQU83SixLQUFLLElBQUkxSyxLQUFLb0osR0FBRyxDQUFDbUwsT0FBTzdKLEtBQUssSUFBSTBKLFFBQVFDLElBQUlDLElBQUl2TSxJQUFJQyxJQUFJbEIsSUFBSUssSUFBSUosSUFBSUssTUFBTW1OO0FBQ3pLO0FBRU8sU0FBU0MsZUFBZTdTLE9BQU8sRUFBRTJFLENBQUMsRUFBRS9CLENBQUMsRUFBRTZQLE1BQU07SUFDbEQsb0tBQW9LO0lBQ3BLLElBQUlLLFVBQVU7UUFDWnJLLEdBQUc7UUFDSHZJLEdBQUc7UUFDSEMsR0FBRztJQUNMLEdBQ0k0UyxlQUFlN1QsV0FDZmdCLEdBQ0F1SSxHQUNBdEksR0FDQUM7SUFFSixJQUFLcUksSUFBSSxHQUFHQSxJQUFJekksUUFBUU8sTUFBTSxFQUFFa0ksSUFBSztRQUNuQ3JJLFVBQVVKLE9BQU8sQ0FBQ3lJLEVBQUU7UUFFcEIsSUFBS3ZJLElBQUksR0FBR0EsSUFBSUUsUUFBUUcsTUFBTSxFQUFFTCxLQUFLLEVBQUc7WUFDdENDLElBQUlrUywyQkFBMkIsR0FBRzFOLEdBQUcvQixHQUFHLEdBQUcsR0FBRzZQLFVBQVUsSUFBSXJTLE9BQU8sQ0FBQ0YsRUFBRSxFQUFFRSxPQUFPLENBQUNGLElBQUksRUFBRSxFQUFFRSxPQUFPLENBQUNGLElBQUksRUFBRSxFQUFFRSxPQUFPLENBQUNGLElBQUksRUFBRSxFQUFFRSxPQUFPLENBQUNGLElBQUksRUFBRSxFQUFFRSxPQUFPLENBQUNGLElBQUksRUFBRSxFQUFFRSxPQUFPLENBQUNGLElBQUksRUFBRSxFQUFFRSxPQUFPLENBQUNGLElBQUksRUFBRTtZQUV0TCxJQUFJNlMsZUFBZWpSLGVBQWU7Z0JBQ2hDaVIsZUFBZWpSO2dCQUNmZ1IsUUFBUXJLLENBQUMsR0FBR0E7Z0JBQ1pxSyxRQUFRNVMsQ0FBQyxHQUFHQTtnQkFDWjRTLFFBQVEzUyxDQUFDLEdBQUdBO1lBQ2Q7UUFDRjtJQUNGO0lBRUEsT0FBTzJTO0FBQ1QsRUFBRSwwREFBMEQ7QUFFckQsU0FBU0UscUJBQXFCck8sQ0FBQyxFQUFFL0IsQ0FBQyxFQUFFeEMsT0FBTyxFQUFFcVMsTUFBTSxFQUFFSCxVQUFVO0lBQ3BFLElBQUkxUixJQUFJUixRQUFRRyxNQUFNLEVBQ2xCd1MsZUFBZTdULFdBQ2YrVCxRQUFRLEdBQ1JDLG1CQUFtQixHQUNuQi9TLEdBQ0FEO0lBQ0p1UyxTQUFTQSxVQUFVO0lBQ25CSCxhQUFhQSxjQUFjO0lBRTNCLElBQUtwUyxJQUFJLEdBQUdBLElBQUlVLEdBQUdWLEtBQUssRUFBRztRQUN6QkMsSUFBSWtTLDJCQUEyQixHQUFHMU4sR0FBRy9CLEdBQUcsR0FBRyxHQUFHNlAsUUFBUXJTLE9BQU8sQ0FBQ0YsRUFBRSxFQUFFRSxPQUFPLENBQUNGLElBQUksRUFBRSxFQUFFRSxPQUFPLENBQUNGLElBQUksRUFBRSxFQUFFRSxPQUFPLENBQUNGLElBQUksRUFBRSxFQUFFRSxPQUFPLENBQUNGLElBQUksRUFBRSxFQUFFRSxPQUFPLENBQUNGLElBQUksRUFBRSxFQUFFRSxPQUFPLENBQUNGLElBQUksRUFBRSxFQUFFRSxPQUFPLENBQUNGLElBQUksRUFBRTtRQUVoTCxJQUFJNlMsZUFBZWpSLGVBQWU7WUFDaENpUixlQUFlalI7WUFDZm1SLFFBQVE5UztZQUNSK1MsbUJBQW1CaFQ7UUFDckI7SUFDRjtJQUVBQyxJQUFJa1MsMkJBQTJCQyxZQUFZM04sR0FBRy9CLEdBQUdxUSxRQUFRLE1BQU1BLFFBQVEsTUFBTVIsUUFBUXJTLE9BQU8sQ0FBQzhTLGlCQUFpQixFQUFFOVMsT0FBTyxDQUFDOFMsbUJBQW1CLEVBQUUsRUFBRTlTLE9BQU8sQ0FBQzhTLG1CQUFtQixFQUFFLEVBQUU5UyxPQUFPLENBQUM4UyxtQkFBbUIsRUFBRSxFQUFFOVMsT0FBTyxDQUFDOFMsbUJBQW1CLEVBQUUsRUFBRTlTLE9BQU8sQ0FBQzhTLG1CQUFtQixFQUFFLEVBQUU5UyxPQUFPLENBQUM4UyxtQkFBbUIsRUFBRSxFQUFFOVMsT0FBTyxDQUFDOFMsbUJBQW1CLEVBQUU7SUFDdlU1UyxpQkFBaUJGLFNBQVM4UyxrQkFBa0IvUztJQUM1QyxPQUFPK1MsbUJBQW1CO0FBQzVCO0FBQ0E7Ozs7Ozs7QUFPQSxHQUVPLFNBQVMxTSxnQkFBZ0J4RyxPQUFPO0lBQ3JDLElBQUlYLFVBQVVXLE9BQU8sQ0FBQyxFQUFFLEdBQUc7UUFDekIsd0NBQXdDO1FBQ3hDQSxVQUFVO1lBQUNBO1NBQVE7SUFDckI7SUFFQSxJQUFJNEssU0FBUyxJQUNUaEssSUFBSVosUUFBUU8sTUFBTSxFQUNsQjRTLElBQ0F2TCxHQUNBMUgsR0FDQUU7SUFFSixJQUFLd0gsSUFBSSxHQUFHQSxJQUFJaEgsR0FBR2dILElBQUs7UUFDdEJ4SCxVQUFVSixPQUFPLENBQUM0SCxFQUFFO1FBQ3BCZ0QsVUFBVSxNQUFNL0ssT0FBT08sT0FBTyxDQUFDLEVBQUUsSUFBSSxNQUFNUCxPQUFPTyxPQUFPLENBQUMsRUFBRSxJQUFJO1FBQ2hFK1MsS0FBSy9TLFFBQVFHLE1BQU07UUFFbkIsSUFBS0wsSUFBSSxHQUFHQSxJQUFJaVQsSUFBSWpULElBQUs7WUFDdkIwSyxVQUFVL0ssT0FBT08sT0FBTyxDQUFDRixJQUFJLElBQUksTUFBTUwsT0FBT08sT0FBTyxDQUFDRixJQUFJLElBQUksTUFBTUwsT0FBT08sT0FBTyxDQUFDRixJQUFJLElBQUksTUFBTUwsT0FBT08sT0FBTyxDQUFDRixJQUFJLElBQUksTUFBTUwsT0FBT08sT0FBTyxDQUFDRixJQUFJLElBQUksTUFBTUwsT0FBT08sT0FBTyxDQUFDRixFQUFFLElBQUk7UUFDbEw7UUFFQSxJQUFJRSxRQUFRMk8sTUFBTSxFQUFFO1lBQ2xCbkUsVUFBVTtRQUNaO0lBQ0Y7SUFFQSxPQUFPQTtBQUNULEVBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEZBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC91dGlscy9wYXRocy5qcz83MDllIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogcGF0aHMgMy4xMi41XG4gKiBodHRwczovL2dzYXAuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyNCwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9nc2FwLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHU0FQIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIF9zdmdQYXRoRXhwID0gL1thY2hsbXFzdHZ6XXwoLT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspPylbMC05XS9pZyxcbiAgICBfbnVtYmVyc0V4cCA9IC8oPzooLSk/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT8pWzAtOV0vaWcsXG4gICAgX3NjaWVudGlmaWMgPSAvW1xcK1xcLV0/XFxkKlxcLj9cXGQrZVtcXCtcXC1dP1xcZCsvaWcsXG4gICAgX3NlbGVjdG9yRXhwID0gLyheWyNcXC5dW2Etel18W2EteV1bYS16XSkvaSxcbiAgICBfREVHMlJBRCA9IE1hdGguUEkgLyAxODAsXG4gICAgX1JBRDJERUcgPSAxODAgLyBNYXRoLlBJLFxuICAgIF9zaW4gPSBNYXRoLnNpbixcbiAgICBfY29zID0gTWF0aC5jb3MsXG4gICAgX2FicyA9IE1hdGguYWJzLFxuICAgIF9zcXJ0ID0gTWF0aC5zcXJ0LFxuICAgIF9hdGFuMiA9IE1hdGguYXRhbjIsXG4gICAgX2xhcmdlTnVtID0gMWU4LFxuICAgIF9pc1N0cmluZyA9IGZ1bmN0aW9uIF9pc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufSxcbiAgICBfaXNOdW1iZXIgPSBmdW5jdGlvbiBfaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn0sXG4gICAgX2lzVW5kZWZpbmVkID0gZnVuY3Rpb24gX2lzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF90ZW1wID0ge30sXG4gICAgX3RlbXAyID0ge30sXG4gICAgX3JvdW5kaW5nTnVtID0gMWU1LFxuICAgIF93cmFwUHJvZ3Jlc3MgPSBmdW5jdGlvbiBfd3JhcFByb2dyZXNzKHByb2dyZXNzKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKChwcm9ncmVzcyArIF9sYXJnZU51bSkgJSAxICogX3JvdW5kaW5nTnVtKSAvIF9yb3VuZGluZ051bSB8fCAocHJvZ3Jlc3MgPCAwID8gMCA6IDEpO1xufSxcbiAgICAvL2lmIHByb2dyZXNzIGxhbmRzIG9uIDEsIHRoZSAlIHdpbGwgbWFrZSBpdCAwIHdoaWNoIGlzIHdoeSB3ZSB8fCAxLCBidXQgbm90IGlmIGl0J3MgbmVnYXRpdmUgYmVjYXVzZSBpdCBtYWtlcyBtb3JlIHNlbnNlIGZvciBtb3Rpb24gdG8gZW5kIGF0IDAgaW4gdGhhdCBjYXNlLlxuX3JvdW5kID0gZnVuY3Rpb24gX3JvdW5kKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogX3JvdW5kaW5nTnVtKSAvIF9yb3VuZGluZ051bSB8fCAwO1xufSxcbiAgICBfcm91bmRQcmVjaXNlID0gZnVuY3Rpb24gX3JvdW5kUHJlY2lzZSh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDFlMTApIC8gMWUxMCB8fCAwO1xufSxcbiAgICBfc3BsaXRTZWdtZW50ID0gZnVuY3Rpb24gX3NwbGl0U2VnbWVudChyYXdQYXRoLCBzZWdJbmRleCwgaSwgdCkge1xuICB2YXIgc2VnbWVudCA9IHJhd1BhdGhbc2VnSW5kZXhdLFxuICAgICAgc2hpZnQgPSB0ID09PSAxID8gNiA6IHN1YmRpdmlkZVNlZ21lbnQoc2VnbWVudCwgaSwgdCk7XG5cbiAgaWYgKChzaGlmdCB8fCAhdCkgJiYgc2hpZnQgKyBpICsgMiA8IHNlZ21lbnQubGVuZ3RoKSB7XG4gICAgcmF3UGF0aC5zcGxpY2Uoc2VnSW5kZXgsIDAsIHNlZ21lbnQuc2xpY2UoMCwgaSArIHNoaWZ0ICsgMikpO1xuICAgIHNlZ21lbnQuc3BsaWNlKDAsIGkgKyBzaGlmdCk7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn0sXG4gICAgX2dldFNhbXBsZUluZGV4ID0gZnVuY3Rpb24gX2dldFNhbXBsZUluZGV4KHNhbXBsZXMsIGxlbmd0aCwgcHJvZ3Jlc3MpIHtcbiAgLy8gc2xpZ2h0bHkgc2xvd2VyIHdheSB0aGFuIGRvaW5nIHRoaXMgKHdoZW4gdGhlcmUncyBubyBsb29rdXApOiBzZWdtZW50Lmxvb2t1cFtwcm9ncmVzcyA8IDEgPyB+fihsZW5ndGggLyBzZWdtZW50Lm1pbkxlbmd0aCkgOiBzZWdtZW50Lmxvb2t1cC5sZW5ndGggLSAxXSB8fCAwO1xuICB2YXIgbCA9IHNhbXBsZXMubGVuZ3RoLFxuICAgICAgaSA9IH5+KHByb2dyZXNzICogbCk7XG5cbiAgaWYgKHNhbXBsZXNbaV0gPiBsZW5ndGgpIHtcbiAgICB3aGlsZSAoLS1pICYmIHNhbXBsZXNbaV0gPiBsZW5ndGgpIHt9XG5cbiAgICBpIDwgMCAmJiAoaSA9IDApO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzYW1wbGVzWysraV0gPCBsZW5ndGggJiYgaSA8IGwpIHt9XG4gIH1cblxuICByZXR1cm4gaSA8IGwgPyBpIDogbCAtIDE7XG59LFxuICAgIF9yZXZlcnNlUmF3UGF0aCA9IGZ1bmN0aW9uIF9yZXZlcnNlUmF3UGF0aChyYXdQYXRoLCBza2lwT3V0ZXIpIHtcbiAgdmFyIGkgPSByYXdQYXRoLmxlbmd0aDtcbiAgc2tpcE91dGVyIHx8IHJhd1BhdGgucmV2ZXJzZSgpO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICByYXdQYXRoW2ldLnJldmVyc2VkIHx8IHJldmVyc2VTZWdtZW50KHJhd1BhdGhbaV0pO1xuICB9XG59LFxuICAgIF9jb3B5TWV0YURhdGEgPSBmdW5jdGlvbiBfY29weU1ldGFEYXRhKHNvdXJjZSwgY29weSkge1xuICBjb3B5LnRvdGFsTGVuZ3RoID0gc291cmNlLnRvdGFsTGVuZ3RoO1xuXG4gIGlmIChzb3VyY2Uuc2FtcGxlcykge1xuICAgIC8vc2VnbWVudFxuICAgIGNvcHkuc2FtcGxlcyA9IHNvdXJjZS5zYW1wbGVzLnNsaWNlKDApO1xuICAgIGNvcHkubG9va3VwID0gc291cmNlLmxvb2t1cC5zbGljZSgwKTtcbiAgICBjb3B5Lm1pbkxlbmd0aCA9IHNvdXJjZS5taW5MZW5ndGg7XG4gICAgY29weS5yZXNvbHV0aW9uID0gc291cmNlLnJlc29sdXRpb247XG4gIH0gZWxzZSBpZiAoc291cmNlLnRvdGFsUG9pbnRzKSB7XG4gICAgLy9yYXdQYXRoXG4gICAgY29weS50b3RhbFBvaW50cyA9IHNvdXJjZS50b3RhbFBvaW50cztcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICAvL3B1c2hlcyBhIG5ldyBzZWdtZW50IGludG8gYSByYXdQYXRoLCBidXQgaWYgaXRzIHN0YXJ0aW5nIHZhbHVlcyBtYXRjaCB0aGUgZW5kaW5nIHZhbHVlcyBvZiB0aGUgbGFzdCBzZWdtZW50LCBpdCdsbCBtZXJnZSBpdCBpbnRvIHRoYXQgc2FtZSBzZWdtZW50ICh0byByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWdtZW50cylcbl9hcHBlbmRPck1lcmdlID0gZnVuY3Rpb24gX2FwcGVuZE9yTWVyZ2UocmF3UGF0aCwgc2VnbWVudCkge1xuICB2YXIgaW5kZXggPSByYXdQYXRoLmxlbmd0aCxcbiAgICAgIHByZXZTZWcgPSByYXdQYXRoW2luZGV4IC0gMV0gfHwgW10sXG4gICAgICBsID0gcHJldlNlZy5sZW5ndGg7XG5cbiAgaWYgKGluZGV4ICYmIHNlZ21lbnRbMF0gPT09IHByZXZTZWdbbCAtIDJdICYmIHNlZ21lbnRbMV0gPT09IHByZXZTZWdbbCAtIDFdKSB7XG4gICAgc2VnbWVudCA9IHByZXZTZWcuY29uY2F0KHNlZ21lbnQuc2xpY2UoMikpO1xuICAgIGluZGV4LS07XG4gIH1cblxuICByYXdQYXRoW2luZGV4XSA9IHNlZ21lbnQ7XG59LFxuICAgIF9iZXN0RGlzdGFuY2U7XG4vKiBURVJNSU5PTE9HWVxuIC0gUmF3UGF0aCAtIGFuIGFycmF5IG9mIGFycmF5cywgb25lIGZvciBlYWNoIFNlZ21lbnQuIEEgc2luZ2xlIFJhd1BhdGggY291bGQgaGF2ZSBtdWx0aXBsZSBcIk1cIiBjb21tYW5kcywgZGVmaW5pbmcgU2VnbWVudHMgKHBhdGhzIGFyZW4ndCBhbHdheXMgY29ubmVjdGVkKS5cbiAtIFNlZ21lbnQgLSBhbiBhcnJheSBjb250YWluaW5nIGEgc2VxdWVuY2Ugb2YgQ3ViaWMgQmV6aWVyIGNvb3JkaW5hdGVzIGluIGFsdGVybmF0aW5nIHgsIHksIHgsIHkgZm9ybWF0LiBTdGFydGluZyBhbmNob3IsIHRoZW4gY29udHJvbCBwb2ludCAxLCBjb250cm9sIHBvaW50IDIsIGFuZCBlbmRpbmcgYW5jaG9yLCB0aGVuIHRoZSBuZXh0IGNvbnRyb2wgcG9pbnQgMSwgY29udHJvbCBwb2ludCAyLCBhbmNob3IsIGV0Yy4gVXNlcyBsZXNzIG1lbW9yeSB0aGFuIGFuIGFycmF5IHdpdGggYSBidW5jaCBvZiB7eCwgeX0gcG9pbnRzLlxuIC0gQmV6aWVyIC0gYSBzaW5nbGUgY3ViaWMgQmV6aWVyIHdpdGggYSBzdGFydGluZyBhbmNob3IsIHR3byBjb250cm9sIHBvaW50cywgYW5kIGFuIGVuZGluZyBhbmNob3IuXG4gLSB0aGUgdmFyaWFibGUgXCJ0XCIgaXMgdHlwaWNhbGx5IHRoZSBwb3NpdGlvbiBhbG9uZyBhbiBpbmRpdmlkdWFsIEJlemllciBwYXRoICh0aW1lKSBhbmQgaXQncyBOT1QgbGluZWFyLCBtZWFuaW5nIGl0IGNvdWxkIGFjY2VsZXJhdGUvZGVjZWxlcmF0ZSBiYXNlZCBvbiB0aGUgY29udHJvbCBwb2ludHMgd2hlcmVhcyB0aGUgXCJwXCIgb3IgXCJwcm9ncmVzc1wiIHZhbHVlIGlzIGxpbmVhcmx5IG1hcHBlZCB0byB0aGUgd2hvbGUgcGF0aCwgc28gaXQgc2hvdWxkbid0IHJlYWxseSBhY2NlbGVyYXRlL2RlY2VsZXJhdGUgYmFzZWQgb24gY29udHJvbCBwb2ludHMuIFNvIGEgcHJvZ3Jlc3Mgb2YgMC4yIHdvdWxkIGJlIGFsbW9zdCBleGFjdGx5IDIwJSBhbG9uZyB0aGUgcGF0aC4gXCJ0XCIgaXMgT05MWSBpbiBhbiBpbmRpdmlkdWFsIEJlemllciBwaWVjZS5cbiAqL1xuLy9hY2NlcHRzIGJhc2ljIHNlbGVjdG9yIHRleHQsIGEgcGF0aCBpbnN0YW5jZSwgYSBSYXdQYXRoIGluc3RhbmNlLCBvciBhIFNlZ21lbnQgYW5kIHJldHVybnMgYSBSYXdQYXRoIChtYWtlcyBpdCBlYXN5IHRvIGhvbW9nZW5pemUgdGhpbmdzKS4gSWYgYW4gZWxlbWVudCBvciBzZWxlY3RvciB0ZXh0IGlzIHBhc3NlZCBpbiwgaXQnbGwgYWxzbyBjYWNoZSB0aGUgdmFsdWUgc28gdGhhdCBpZiBpdCdzIHF1ZXJpZWQgYWdhaW4sIGl0J2xsIGp1c3QgdGFrZSB0aGUgcGF0aCBkYXRhIGZyb20gdGhlcmUgaW5zdGVhZCBvZiBwYXJzaW5nIGl0IGFsbCBvdmVyIGFnYWluIChhcyBsb25nIGFzIHRoZSBwYXRoIGRhdGEgaXRzZWxmIGhhc24ndCBjaGFuZ2VkIC0gaXQnbGwgY2hlY2spLlxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYXdQYXRoKHZhbHVlKSB7XG4gIHZhbHVlID0gX2lzU3RyaW5nKHZhbHVlKSAmJiBfc2VsZWN0b3JFeHAudGVzdCh2YWx1ZSkgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHZhbHVlKSB8fCB2YWx1ZSA6IHZhbHVlO1xuICB2YXIgZSA9IHZhbHVlLmdldEF0dHJpYnV0ZSA/IHZhbHVlIDogMCxcbiAgICAgIHJhd1BhdGg7XG5cbiAgaWYgKGUgJiYgKHZhbHVlID0gdmFsdWUuZ2V0QXR0cmlidXRlKFwiZFwiKSkpIHtcbiAgICAvL2ltcGxlbWVudHMgY2FjaGluZ1xuICAgIGlmICghZS5fZ3NQYXRoKSB7XG4gICAgICBlLl9nc1BhdGggPSB7fTtcbiAgICB9XG5cbiAgICByYXdQYXRoID0gZS5fZ3NQYXRoW3ZhbHVlXTtcbiAgICByZXR1cm4gcmF3UGF0aCAmJiAhcmF3UGF0aC5fZGlydHkgPyByYXdQYXRoIDogZS5fZ3NQYXRoW3ZhbHVlXSA9IHN0cmluZ1RvUmF3UGF0aCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gIXZhbHVlID8gY29uc29sZS53YXJuKFwiRXhwZWN0aW5nIGEgPHBhdGg+IGVsZW1lbnQgb3IgYW4gU1ZHIHBhdGggZGF0YSBzdHJpbmdcIikgOiBfaXNTdHJpbmcodmFsdWUpID8gc3RyaW5nVG9SYXdQYXRoKHZhbHVlKSA6IF9pc051bWJlcih2YWx1ZVswXSkgPyBbdmFsdWVdIDogdmFsdWU7XG59IC8vY29waWVzIGEgUmF3UGF0aCBXSVRIT1VUIHRoZSBsZW5ndGggbWV0YSBkYXRhIChmb3Igc3BlZWQpXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5UmF3UGF0aChyYXdQYXRoKSB7XG4gIHZhciBhID0gW10sXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgaSA8IHJhd1BhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBhW2ldID0gX2NvcHlNZXRhRGF0YShyYXdQYXRoW2ldLCByYXdQYXRoW2ldLnNsaWNlKDApKTtcbiAgfVxuXG4gIHJldHVybiBfY29weU1ldGFEYXRhKHJhd1BhdGgsIGEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2VTZWdtZW50KHNlZ21lbnQpIHtcbiAgdmFyIGkgPSAwLFxuICAgICAgeTtcbiAgc2VnbWVudC5yZXZlcnNlKCk7IC8vdGhpcyB3aWxsIGludmVydCB0aGUgb3JkZXIgeSwgeCwgeSwgeCBzbyB3ZSBtdXN0IGZsaXAgaXQgYmFjay5cblxuICBmb3IgKDsgaSA8IHNlZ21lbnQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB5ID0gc2VnbWVudFtpXTtcbiAgICBzZWdtZW50W2ldID0gc2VnbWVudFtpICsgMV07XG4gICAgc2VnbWVudFtpICsgMV0gPSB5O1xuICB9XG5cbiAgc2VnbWVudC5yZXZlcnNlZCA9ICFzZWdtZW50LnJldmVyc2VkO1xufVxuXG52YXIgX2NyZWF0ZVBhdGggPSBmdW5jdGlvbiBfY3JlYXRlUGF0aChlLCBpZ25vcmUpIHtcbiAgdmFyIHBhdGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInBhdGhcIiksXG4gICAgICBhdHRyID0gW10uc2xpY2UuY2FsbChlLmF0dHJpYnV0ZXMpLFxuICAgICAgaSA9IGF0dHIubGVuZ3RoLFxuICAgICAgbmFtZTtcbiAgaWdub3JlID0gXCIsXCIgKyBpZ25vcmUgKyBcIixcIjtcblxuICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICBuYW1lID0gYXR0cltpXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOyAvL2luIE1pY3Jvc29mdCBFZGdlLCBpZiB5b3UgZG9uJ3Qgc2V0IHRoZSBhdHRyaWJ1dGUgd2l0aCBhIGxvd2VyY2FzZSBuYW1lLCBpdCBkb2Vzbid0IHJlbmRlciBjb3JyZWN0bHkhIFN1cGVyIHdlaXJkLlxuXG4gICAgaWYgKGlnbm9yZS5pbmRleE9mKFwiLFwiICsgbmFtZSArIFwiLFwiKSA8IDApIHtcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgbmFtZSwgYXR0cltpXS5ub2RlVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufSxcbiAgICBfdHlwZUF0dHJzID0ge1xuICByZWN0OiBcInJ4LHJ5LHgseSx3aWR0aCxoZWlnaHRcIixcbiAgY2lyY2xlOiBcInIsY3gsY3lcIixcbiAgZWxsaXBzZTogXCJyeCxyeSxjeCxjeVwiLFxuICBsaW5lOiBcIngxLHgyLHkxLHkyXCJcbn0sXG4gICAgX2F0dHJUb09iaiA9IGZ1bmN0aW9uIF9hdHRyVG9PYmooZSwgYXR0cnMpIHtcbiAgdmFyIHByb3BzID0gYXR0cnMgPyBhdHRycy5zcGxpdChcIixcIikgOiBbXSxcbiAgICAgIG9iaiA9IHt9LFxuICAgICAgaSA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICBvYmpbcHJvcHNbaV1dID0gK2UuZ2V0QXR0cmlidXRlKHByb3BzW2ldKSB8fCAwO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07IC8vY29udmVydHMgYW4gU1ZHIHNoYXBlIGxpa2UgPGNpcmNsZT4sIDxyZWN0PiwgPHBvbHlnb24+LCA8cG9seWxpbmU+LCA8ZWxsaXBzZT4sIGV0Yy4gdG8gYSA8cGF0aD4sIHN3YXBwaW5nIGl0IGluIGFuZCBjb3B5aW5nIHRoZSBhdHRyaWJ1dGVzIHRvIG1hdGNoLlxuXG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9QYXRoKGVsZW1lbnQsIHN3YXApIHtcbiAgdmFyIHR5cGUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgIGNpcmMgPSAwLjU1MjI4NDc0OTgzMSxcbiAgICAgIGRhdGEsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHIsXG4gICAgICByeSxcbiAgICAgIHBhdGgsXG4gICAgICByY2lyYyxcbiAgICAgIHJ5Y2lyYyxcbiAgICAgIHBvaW50cyxcbiAgICAgIHcsXG4gICAgICBoLFxuICAgICAgeDIsXG4gICAgICB4MyxcbiAgICAgIHg0LFxuICAgICAgeDUsXG4gICAgICB4NixcbiAgICAgIHkyLFxuICAgICAgeTMsXG4gICAgICB5NCxcbiAgICAgIHk1LFxuICAgICAgeTYsXG4gICAgICBhdHRyO1xuXG4gIGlmICh0eXBlID09PSBcInBhdGhcIiB8fCAhZWxlbWVudC5nZXRCQm94KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBwYXRoID0gX2NyZWF0ZVBhdGgoZWxlbWVudCwgXCJ4LHksd2lkdGgsaGVpZ2h0LGN4LGN5LHJ4LHJ5LHIseDEseDIseTEseTIscG9pbnRzXCIpO1xuICBhdHRyID0gX2F0dHJUb09iaihlbGVtZW50LCBfdHlwZUF0dHJzW3R5cGVdKTtcblxuICBpZiAodHlwZSA9PT0gXCJyZWN0XCIpIHtcbiAgICByID0gYXR0ci5yeDtcbiAgICByeSA9IGF0dHIucnkgfHwgcjtcbiAgICB4ID0gYXR0ci54O1xuICAgIHkgPSBhdHRyLnk7XG4gICAgdyA9IGF0dHIud2lkdGggLSByICogMjtcbiAgICBoID0gYXR0ci5oZWlnaHQgLSByeSAqIDI7XG5cbiAgICBpZiAociB8fCByeSkge1xuICAgICAgLy9pZiB0aGVyZSBhcmUgcm91bmRlZCBjb3JuZXJzLCByZW5kZXIgY3ViaWMgYmV6aWVyc1xuICAgICAgeDIgPSB4ICsgciAqICgxIC0gY2lyYyk7XG4gICAgICB4MyA9IHggKyByO1xuICAgICAgeDQgPSB4MyArIHc7XG4gICAgICB4NSA9IHg0ICsgciAqIGNpcmM7XG4gICAgICB4NiA9IHg0ICsgcjtcbiAgICAgIHkyID0geSArIHJ5ICogKDEgLSBjaXJjKTtcbiAgICAgIHkzID0geSArIHJ5O1xuICAgICAgeTQgPSB5MyArIGg7XG4gICAgICB5NSA9IHk0ICsgcnkgKiBjaXJjO1xuICAgICAgeTYgPSB5NCArIHJ5O1xuICAgICAgZGF0YSA9IFwiTVwiICsgeDYgKyBcIixcIiArIHkzICsgXCIgVlwiICsgeTQgKyBcIiBDXCIgKyBbeDYsIHk1LCB4NSwgeTYsIHg0LCB5NiwgeDQgLSAoeDQgLSB4MykgLyAzLCB5NiwgeDMgKyAoeDQgLSB4MykgLyAzLCB5NiwgeDMsIHk2LCB4MiwgeTYsIHgsIHk1LCB4LCB5NCwgeCwgeTQgLSAoeTQgLSB5MykgLyAzLCB4LCB5MyArICh5NCAtIHkzKSAvIDMsIHgsIHkzLCB4LCB5MiwgeDIsIHksIHgzLCB5LCB4MyArICh4NCAtIHgzKSAvIDMsIHksIHg0IC0gKHg0IC0geDMpIC8gMywgeSwgeDQsIHksIHg1LCB5LCB4NiwgeTIsIHg2LCB5M10uam9pbihcIixcIikgKyBcInpcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IFwiTVwiICsgKHggKyB3KSArIFwiLFwiICsgeSArIFwiIHZcIiArIGggKyBcIiBoXCIgKyAtdyArIFwiIHZcIiArIC1oICsgXCIgaFwiICsgdyArIFwielwiO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSBcImNpcmNsZVwiIHx8IHR5cGUgPT09IFwiZWxsaXBzZVwiKSB7XG4gICAgaWYgKHR5cGUgPT09IFwiY2lyY2xlXCIpIHtcbiAgICAgIHIgPSByeSA9IGF0dHIucjtcbiAgICAgIHJ5Y2lyYyA9IHIgKiBjaXJjO1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gYXR0ci5yeDtcbiAgICAgIHJ5ID0gYXR0ci5yeTtcbiAgICAgIHJ5Y2lyYyA9IHJ5ICogY2lyYztcbiAgICB9XG5cbiAgICB4ID0gYXR0ci5jeDtcbiAgICB5ID0gYXR0ci5jeTtcbiAgICByY2lyYyA9IHIgKiBjaXJjO1xuICAgIGRhdGEgPSBcIk1cIiArICh4ICsgcikgKyBcIixcIiArIHkgKyBcIiBDXCIgKyBbeCArIHIsIHkgKyByeWNpcmMsIHggKyByY2lyYywgeSArIHJ5LCB4LCB5ICsgcnksIHggLSByY2lyYywgeSArIHJ5LCB4IC0gciwgeSArIHJ5Y2lyYywgeCAtIHIsIHksIHggLSByLCB5IC0gcnljaXJjLCB4IC0gcmNpcmMsIHkgLSByeSwgeCwgeSAtIHJ5LCB4ICsgcmNpcmMsIHkgLSByeSwgeCArIHIsIHkgLSByeWNpcmMsIHggKyByLCB5XS5qb2luKFwiLFwiKSArIFwielwiO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibGluZVwiKSB7XG4gICAgZGF0YSA9IFwiTVwiICsgYXR0ci54MSArIFwiLFwiICsgYXR0ci55MSArIFwiIExcIiArIGF0dHIueDIgKyBcIixcIiArIGF0dHIueTI7IC8vcHJldmlvdXNseSwgd2UganVzdCBjb252ZXJ0ZWQgdG8gXCJNeCx5IEx4LHlcIiBidXQgU2FmYXJpIGhhcyBidWdzIHRoYXQgY2F1c2UgdGhhdCBub3QgdG8gcmVuZGVyIHByb3Blcmx5IHdoZW4gdXNpbmcgYSBzdHJva2UtZGFzaGFycmF5IHRoYXQncyBub3QgZnVsbHkgdmlzaWJsZSEgVXNpbmcgYSBjdWJpYyBiZXppZXIgZml4ZXMgdGhhdCBpc3N1ZS5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBcInBvbHlsaW5lXCIgfHwgdHlwZSA9PT0gXCJwb2x5Z29uXCIpIHtcbiAgICBwb2ludHMgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJwb2ludHNcIikgKyBcIlwiKS5tYXRjaChfbnVtYmVyc0V4cCkgfHwgW107XG4gICAgeCA9IHBvaW50cy5zaGlmdCgpO1xuICAgIHkgPSBwb2ludHMuc2hpZnQoKTtcbiAgICBkYXRhID0gXCJNXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIgTFwiICsgcG9pbnRzLmpvaW4oXCIsXCIpO1xuXG4gICAgaWYgKHR5cGUgPT09IFwicG9seWdvblwiKSB7XG4gICAgICBkYXRhICs9IFwiLFwiICsgeCArIFwiLFwiICsgeSArIFwielwiO1xuICAgIH1cbiAgfVxuXG4gIHBhdGguc2V0QXR0cmlidXRlKFwiZFwiLCByYXdQYXRoVG9TdHJpbmcocGF0aC5fZ3NSYXdQYXRoID0gc3RyaW5nVG9SYXdQYXRoKGRhdGEpKSk7XG5cbiAgaWYgKHN3YXAgJiYgZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShwYXRoLCBlbGVtZW50KTtcbiAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gcGF0aDtcbn0gLy9yZXR1cm5zIHRoZSByb3RhdGlvbiAoaW4gZGVncmVlcykgYXQgYSBwYXJ0aWN1bGFyIHByb2dyZXNzIG9uIGEgcmF3UGF0aCAodGhlIHNsb3BlIG9mIHRoZSB0YW5nZW50KVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um90YXRpb25BdFByb2dyZXNzKHJhd1BhdGgsIHByb2dyZXNzKSB7XG4gIHZhciBkID0gZ2V0UHJvZ3Jlc3NEYXRhKHJhd1BhdGgsIHByb2dyZXNzID49IDEgPyAxIC0gMWUtOSA6IHByb2dyZXNzID8gcHJvZ3Jlc3MgOiAxZS05KTtcbiAgcmV0dXJuIGdldFJvdGF0aW9uQXRCZXppZXJUKGQuc2VnbWVudCwgZC5pLCBkLnQpO1xufVxuXG5mdW5jdGlvbiBnZXRSb3RhdGlvbkF0QmV6aWVyVChzZWdtZW50LCBpLCB0KSB7XG4gIHZhciBhID0gc2VnbWVudFtpXSxcbiAgICAgIGIgPSBzZWdtZW50W2kgKyAyXSxcbiAgICAgIGMgPSBzZWdtZW50W2kgKyA0XSxcbiAgICAgIHg7XG4gIGEgKz0gKGIgLSBhKSAqIHQ7XG4gIGIgKz0gKGMgLSBiKSAqIHQ7XG4gIGEgKz0gKGIgLSBhKSAqIHQ7XG4gIHggPSBiICsgKGMgKyAoc2VnbWVudFtpICsgNl0gLSBjKSAqIHQgLSBiKSAqIHQgLSBhO1xuICBhID0gc2VnbWVudFtpICsgMV07XG4gIGIgPSBzZWdtZW50W2kgKyAzXTtcbiAgYyA9IHNlZ21lbnRbaSArIDVdO1xuICBhICs9IChiIC0gYSkgKiB0O1xuICBiICs9IChjIC0gYikgKiB0O1xuICBhICs9IChiIC0gYSkgKiB0O1xuICByZXR1cm4gX3JvdW5kKF9hdGFuMihiICsgKGMgKyAoc2VnbWVudFtpICsgN10gLSBjKSAqIHQgLSBiKSAqIHQgLSBhLCB4KSAqIF9SQUQyREVHKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlUmF3UGF0aChyYXdQYXRoLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IF9pc1VuZGVmaW5lZChlbmQpID8gMSA6IF9yb3VuZFByZWNpc2UoZW5kKSB8fCAwOyAvLyB3ZSBtdXN0IHJvdW5kIHRvIGF2b2lkIGlzc3VlcyBsaWtlIDQuMTUgLyA4ID0gMC44MzAwMDAwMDAwMDAwMDAxIGluc3RlYWQgb2YgMC44MyBvciAyLjggLyA1ID0gMC41NTk5OTk5OTk5OTk5OTk5IGluc3RlYWQgb2YgMC41NiBhbmQgaWYgc29tZW9uZSBpcyBkb2luZyBhIGxvb3AgbGlrZSBzdGFydDogMi44IC8gMC41LCBlbmQ6IDIuOCAvIDAuNSArIDEuXG5cbiAgc3RhcnQgPSBfcm91bmRQcmVjaXNlKHN0YXJ0KSB8fCAwO1xuICB2YXIgbG9vcHMgPSBNYXRoLm1heCgwLCB+fihfYWJzKGVuZCAtIHN0YXJ0KSAtIDFlLTgpKSxcbiAgICAgIHBhdGggPSBjb3B5UmF3UGF0aChyYXdQYXRoKTtcblxuICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICBzdGFydCA9IDEgLSBzdGFydDtcbiAgICBlbmQgPSAxIC0gZW5kO1xuXG4gICAgX3JldmVyc2VSYXdQYXRoKHBhdGgpO1xuXG4gICAgcGF0aC50b3RhbExlbmd0aCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA8IDApIHtcbiAgICB2YXIgb2Zmc2V0ID0gTWF0aC5hYnMofn5NYXRoLm1pbihzdGFydCwgZW5kKSkgKyAxO1xuICAgIHN0YXJ0ICs9IG9mZnNldDtcbiAgICBlbmQgKz0gb2Zmc2V0O1xuICB9XG5cbiAgcGF0aC50b3RhbExlbmd0aCB8fCBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMocGF0aCk7XG4gIHZhciB3cmFwID0gZW5kID4gMSxcbiAgICAgIHMgPSBnZXRQcm9ncmVzc0RhdGEocGF0aCwgc3RhcnQsIF90ZW1wLCB0cnVlKSxcbiAgICAgIGUgPSBnZXRQcm9ncmVzc0RhdGEocGF0aCwgZW5kLCBfdGVtcDIpLFxuICAgICAgZVNlZyA9IGUuc2VnbWVudCxcbiAgICAgIHNTZWcgPSBzLnNlZ21lbnQsXG4gICAgICBlU2VnSW5kZXggPSBlLnNlZ0luZGV4LFxuICAgICAgc1NlZ0luZGV4ID0gcy5zZWdJbmRleCxcbiAgICAgIGVpID0gZS5pLFxuICAgICAgc2kgPSBzLmksXG4gICAgICBzYW1lU2VnbWVudCA9IHNTZWdJbmRleCA9PT0gZVNlZ0luZGV4LFxuICAgICAgc2FtZUJlemllciA9IGVpID09PSBzaSAmJiBzYW1lU2VnbWVudCxcbiAgICAgIHdyYXBzQmVoaW5kLFxuICAgICAgc1NoaWZ0LFxuICAgICAgZVNoaWZ0LFxuICAgICAgaSxcbiAgICAgIGNvcHksXG4gICAgICB0b3RhbFNlZ21lbnRzLFxuICAgICAgbCxcbiAgICAgIGo7XG5cbiAgaWYgKHdyYXAgfHwgbG9vcHMpIHtcbiAgICB3cmFwc0JlaGluZCA9IGVTZWdJbmRleCA8IHNTZWdJbmRleCB8fCBzYW1lU2VnbWVudCAmJiBlaSA8IHNpIHx8IHNhbWVCZXppZXIgJiYgZS50IDwgcy50O1xuXG4gICAgaWYgKF9zcGxpdFNlZ21lbnQocGF0aCwgc1NlZ0luZGV4LCBzaSwgcy50KSkge1xuICAgICAgc1NlZ0luZGV4Kys7XG5cbiAgICAgIGlmICghd3JhcHNCZWhpbmQpIHtcbiAgICAgICAgZVNlZ0luZGV4Kys7XG5cbiAgICAgICAgaWYgKHNhbWVCZXppZXIpIHtcbiAgICAgICAgICBlLnQgPSAoZS50IC0gcy50KSAvICgxIC0gcy50KTtcbiAgICAgICAgICBlaSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc2FtZVNlZ21lbnQpIHtcbiAgICAgICAgICBlaSAtPSBzaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChNYXRoLmFicygxIC0gKGVuZCAtIHN0YXJ0KSkgPCAxZS01KSB7XG4gICAgICBlU2VnSW5kZXggPSBzU2VnSW5kZXggLSAxO1xuICAgIH0gZWxzZSBpZiAoIWUudCAmJiBlU2VnSW5kZXgpIHtcbiAgICAgIGVTZWdJbmRleC0tO1xuICAgIH0gZWxzZSBpZiAoX3NwbGl0U2VnbWVudChwYXRoLCBlU2VnSW5kZXgsIGVpLCBlLnQpICYmIHdyYXBzQmVoaW5kKSB7XG4gICAgICBzU2VnSW5kZXgrKztcbiAgICB9XG5cbiAgICBpZiAocy50ID09PSAxKSB7XG4gICAgICBzU2VnSW5kZXggPSAoc1NlZ0luZGV4ICsgMSkgJSBwYXRoLmxlbmd0aDtcbiAgICB9XG5cbiAgICBjb3B5ID0gW107XG4gICAgdG90YWxTZWdtZW50cyA9IHBhdGgubGVuZ3RoO1xuICAgIGwgPSAxICsgdG90YWxTZWdtZW50cyAqIGxvb3BzO1xuICAgIGogPSBzU2VnSW5kZXg7XG4gICAgbCArPSAodG90YWxTZWdtZW50cyAtIHNTZWdJbmRleCArIGVTZWdJbmRleCkgJSB0b3RhbFNlZ21lbnRzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgX2FwcGVuZE9yTWVyZ2UoY29weSwgcGF0aFtqKysgJSB0b3RhbFNlZ21lbnRzXSk7XG4gICAgfVxuXG4gICAgcGF0aCA9IGNvcHk7XG4gIH0gZWxzZSB7XG4gICAgZVNoaWZ0ID0gZS50ID09PSAxID8gNiA6IHN1YmRpdmlkZVNlZ21lbnQoZVNlZywgZWksIGUudCk7XG5cbiAgICBpZiAoc3RhcnQgIT09IGVuZCkge1xuICAgICAgc1NoaWZ0ID0gc3ViZGl2aWRlU2VnbWVudChzU2VnLCBzaSwgc2FtZUJlemllciA/IHMudCAvIGUudCA6IHMudCk7XG4gICAgICBzYW1lU2VnbWVudCAmJiAoZVNoaWZ0ICs9IHNTaGlmdCk7XG4gICAgICBlU2VnLnNwbGljZShlaSArIGVTaGlmdCArIDIpO1xuICAgICAgKHNTaGlmdCB8fCBzaSkgJiYgc1NlZy5zcGxpY2UoMCwgc2kgKyBzU2hpZnQpO1xuICAgICAgaSA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIC8vY2hvcCBvZmYgYW55IGV4dHJhIHNlZ21lbnRzXG4gICAgICAgIChpIDwgc1NlZ0luZGV4IHx8IGkgPiBlU2VnSW5kZXgpICYmIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlU2VnLmFuZ2xlID0gZ2V0Um90YXRpb25BdEJlemllclQoZVNlZywgZWkgKyBlU2hpZnQsIDApOyAvL3JlY29yZCB0aGUgdmFsdWUgYmVmb3JlIHdlIGNob3AgYmVjYXVzZSBpdCdsbCBiZSBpbXBvc3NpYmxlIHRvIGRldGVybWluZSB0aGUgYW5nbGUgYWZ0ZXIgaXRzIGxlbmd0aCBpcyAwIVxuXG4gICAgICBlaSArPSBlU2hpZnQ7XG4gICAgICBzID0gZVNlZ1tlaV07XG4gICAgICBlID0gZVNlZ1tlaSArIDFdO1xuICAgICAgZVNlZy5sZW5ndGggPSBlU2VnLnRvdGFsTGVuZ3RoID0gMDtcbiAgICAgIGVTZWcudG90YWxQb2ludHMgPSBwYXRoLnRvdGFsUG9pbnRzID0gODtcbiAgICAgIGVTZWcucHVzaChzLCBlLCBzLCBlLCBzLCBlLCBzLCBlKTtcbiAgICB9XG4gIH1cblxuICBwYXRoLnRvdGFsTGVuZ3RoID0gMDtcbiAgcmV0dXJuIHBhdGg7XG59IC8vbWVhc3VyZXMgYSBTZWdtZW50IGFjY29yZGluZyB0byBpdHMgcmVzb2x1dGlvbiAoc28gaWYgc2VnbWVudC5yZXNvbHV0aW9uIGlzIDYsIGZvciBleGFtcGxlLCBpdCdsbCB0YWtlIDYgc2FtcGxlcyBlcXVhbGx5IGFjcm9zcyBlYWNoIEJlemllcikgYW5kIGNyZWF0ZS9wb3B1bGF0ZSBhIFwic2FtcGxlc1wiIEFycmF5IHRoYXQgaGFzIHRoZSBsZW5ndGggdXAgdG8gZWFjaCBvZiB0aG9zZSBzYW1wbGUgcG9pbnRzIChhbHdheXMgaW5jcmVhc2luZyBmcm9tIHRoZSBzdGFydCkgYXMgd2VsbCBhcyBhIFwibG9va3VwXCIgYXJyYXkgdGhhdCdzIGJyb2tlbiB1cCBhY2NvcmRpbmcgdG8gdGhlIHNtYWxsZXN0IGRpc3RhbmNlIGJldHdlZW4gMiBzYW1wbGVzLiBUaGlzIGdpdmVzIHVzIGEgdmVyeSBmYXN0IHdheSBvZiBsb29raW5nIHVwIGEgcHJvZ3Jlc3MgcG9zaXRpb24gcmF0aGVyIHRoYW4gbG9vcGluZyB0aHJvdWdoIGFsbCB0aGUgcG9pbnRzL0JlemllcnMuIFlvdSBjYW4gb3B0aW9uYWxseSBoYXZlIGl0IG9ubHkgbWVhc3VyZSBhIHN1YnNldCwgc3RhcnRpbmcgYXQgc3RhcnRJbmRleCBhbmQgZ29pbmcgZm9yIGEgc3BlY2lmaWMgbnVtYmVyIG9mIGJlemllcnMgKHJlbWVtYmVyLCB0aGVyZSBhcmUgMyB4L3kgcGFpcnMgZWFjaCwgZm9yIGEgdG90YWwgb2YgNiBlbGVtZW50cyBmb3IgZWFjaCBCZXppZXIpLiBJdCB3aWxsIGFsc28gcG9wdWxhdGUgYSBcInRvdGFsTGVuZ3RoXCIgcHJvcGVydHksIGJ1dCB0aGF0J3Mgbm90IGdlbmVyYWxseSBzdXBlciBhY2N1cmF0ZSBiZWNhdXNlIGJ5IGRlZmF1bHQgaXQnbGwgb25seSB0YWtlIDYgc2FtcGxlcyBwZXIgQmV6aWVyLiBCdXQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGl0J3MgcGVyZmVjdGx5IGFkZXF1YXRlIGZvciBtZWFzdXJpbmcgcHJvZ3Jlc3MgdmFsdWVzIGFsb25nIHRoZSBwYXRoLiBJZiB5b3UgbmVlZCBhIG1vcmUgYWNjdXJhdGUgdG90YWxMZW5ndGgsIGVpdGhlciBpbmNyZWFzZSB0aGUgcmVzb2x1dGlvbiBvciB1c2UgdGhlIG1vcmUgYWR2YW5jZWQgYmV6aWVyVG9Qb2ludHMoKSBtZXRob2Qgd2hpY2gga2VlcHMgYWRkaW5nIHBvaW50cyB1bnRpbCB0aGV5IGRvbid0IGRldmlhdGUgYnkgbW9yZSB0aGFuIGEgY2VydGFpbiBwcmVjaXNpb24gdmFsdWUuXG5cbmZ1bmN0aW9uIG1lYXN1cmVTZWdtZW50KHNlZ21lbnQsIHN0YXJ0SW5kZXgsIGJlemllclF0eSkge1xuICBzdGFydEluZGV4ID0gc3RhcnRJbmRleCB8fCAwO1xuXG4gIGlmICghc2VnbWVudC5zYW1wbGVzKSB7XG4gICAgc2VnbWVudC5zYW1wbGVzID0gW107XG4gICAgc2VnbWVudC5sb29rdXAgPSBbXTtcbiAgfVxuXG4gIHZhciByZXNvbHV0aW9uID0gfn5zZWdtZW50LnJlc29sdXRpb24gfHwgMTIsXG4gICAgICBpbmMgPSAxIC8gcmVzb2x1dGlvbixcbiAgICAgIGVuZEluZGV4ID0gYmV6aWVyUXR5ID8gc3RhcnRJbmRleCArIGJlemllclF0eSAqIDYgKyAxIDogc2VnbWVudC5sZW5ndGgsXG4gICAgICB4MSA9IHNlZ21lbnRbc3RhcnRJbmRleF0sXG4gICAgICB5MSA9IHNlZ21lbnRbc3RhcnRJbmRleCArIDFdLFxuICAgICAgc2FtcGxlc0luZGV4ID0gc3RhcnRJbmRleCA/IHN0YXJ0SW5kZXggLyA2ICogcmVzb2x1dGlvbiA6IDAsXG4gICAgICBzYW1wbGVzID0gc2VnbWVudC5zYW1wbGVzLFxuICAgICAgbG9va3VwID0gc2VnbWVudC5sb29rdXAsXG4gICAgICBtaW4gPSAoc3RhcnRJbmRleCA/IHNlZ21lbnQubWluTGVuZ3RoIDogX2xhcmdlTnVtKSB8fCBfbGFyZ2VOdW0sXG4gICAgICBwcmV2TGVuZ3RoID0gc2FtcGxlc1tzYW1wbGVzSW5kZXggKyBiZXppZXJRdHkgKiByZXNvbHV0aW9uIC0gMV0sXG4gICAgICBsZW5ndGggPSBzdGFydEluZGV4ID8gc2FtcGxlc1tzYW1wbGVzSW5kZXggLSAxXSA6IDAsXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIHg0LFxuICAgICAgeDMsXG4gICAgICB4MixcbiAgICAgIHhkLFxuICAgICAgeGQxLFxuICAgICAgeTQsXG4gICAgICB5MyxcbiAgICAgIHkyLFxuICAgICAgeWQsXG4gICAgICB5ZDEsXG4gICAgICBpbnYsXG4gICAgICB0LFxuICAgICAgbGVuZ3RoSW5kZXgsXG4gICAgICBsLFxuICAgICAgc2VnTGVuZ3RoO1xuICBzYW1wbGVzLmxlbmd0aCA9IGxvb2t1cC5sZW5ndGggPSAwO1xuXG4gIGZvciAoaiA9IHN0YXJ0SW5kZXggKyAyOyBqIDwgZW5kSW5kZXg7IGogKz0gNikge1xuICAgIHg0ID0gc2VnbWVudFtqICsgNF0gLSB4MTtcbiAgICB4MyA9IHNlZ21lbnRbaiArIDJdIC0geDE7XG4gICAgeDIgPSBzZWdtZW50W2pdIC0geDE7XG4gICAgeTQgPSBzZWdtZW50W2ogKyA1XSAtIHkxO1xuICAgIHkzID0gc2VnbWVudFtqICsgM10gLSB5MTtcbiAgICB5MiA9IHNlZ21lbnRbaiArIDFdIC0geTE7XG4gICAgeGQgPSB4ZDEgPSB5ZCA9IHlkMSA9IDA7XG5cbiAgICBpZiAoX2Ficyh4NCkgPCAuMDEgJiYgX2Ficyh5NCkgPCAuMDEgJiYgX2Ficyh4MikgKyBfYWJzKHkyKSA8IC4wMSkge1xuICAgICAgLy9kdW1wIHBvaW50cyB0aGF0IGFyZSBzdWZmaWNpZW50bHkgY2xvc2UgKGJhc2ljYWxseSByaWdodCBvbiB0b3Agb2YgZWFjaCBvdGhlciwgbWFraW5nIGEgYmV6aWVyIHN1cGVyIHRpbnkgb3IgMCBsZW5ndGgpXG4gICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiA4KSB7XG4gICAgICAgIHNlZ21lbnQuc3BsaWNlKGosIDYpO1xuICAgICAgICBqIC09IDY7XG4gICAgICAgIGVuZEluZGV4IC09IDY7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDE7IGkgPD0gcmVzb2x1dGlvbjsgaSsrKSB7XG4gICAgICAgIHQgPSBpbmMgKiBpO1xuICAgICAgICBpbnYgPSAxIC0gdDtcbiAgICAgICAgeGQgPSB4ZDEgLSAoeGQxID0gKHQgKiB0ICogeDQgKyAzICogaW52ICogKHQgKiB4MyArIGludiAqIHgyKSkgKiB0KTtcbiAgICAgICAgeWQgPSB5ZDEgLSAoeWQxID0gKHQgKiB0ICogeTQgKyAzICogaW52ICogKHQgKiB5MyArIGludiAqIHkyKSkgKiB0KTtcbiAgICAgICAgbCA9IF9zcXJ0KHlkICogeWQgKyB4ZCAqIHhkKTtcblxuICAgICAgICBpZiAobCA8IG1pbikge1xuICAgICAgICAgIG1pbiA9IGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGggKz0gbDtcbiAgICAgICAgc2FtcGxlc1tzYW1wbGVzSW5kZXgrK10gPSBsZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgeDEgKz0geDQ7XG4gICAgeTEgKz0geTQ7XG4gIH1cblxuICBpZiAocHJldkxlbmd0aCkge1xuICAgIHByZXZMZW5ndGggLT0gbGVuZ3RoO1xuXG4gICAgZm9yICg7IHNhbXBsZXNJbmRleCA8IHNhbXBsZXMubGVuZ3RoOyBzYW1wbGVzSW5kZXgrKykge1xuICAgICAgc2FtcGxlc1tzYW1wbGVzSW5kZXhdICs9IHByZXZMZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNhbXBsZXMubGVuZ3RoICYmIG1pbikge1xuICAgIHNlZ21lbnQudG90YWxMZW5ndGggPSBzZWdMZW5ndGggPSBzYW1wbGVzW3NhbXBsZXMubGVuZ3RoIC0gMV0gfHwgMDtcbiAgICBzZWdtZW50Lm1pbkxlbmd0aCA9IG1pbjtcblxuICAgIGlmIChzZWdMZW5ndGggLyBtaW4gPCA5OTk5KSB7XG4gICAgICAvLyBpZiB0aGUgbG9va3VwIHdvdWxkIHJlcXVpcmUgdG9vIG1hbnkgdmFsdWVzIChtZW1vcnkgcHJvYmxlbSksIHdlIHNraXAgdGhpcyBhbmQgaW5zdGVhZCB3ZSB1c2UgYSBsb29wIHRvIGxvb2t1cCB2YWx1ZXMgZGlyZWN0bHkgaW4gdGhlIHNhbXBsZXMgQXJyYXlcbiAgICAgIGwgPSBsZW5ndGhJbmRleCA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdMZW5ndGg7IGkgKz0gbWluKSB7XG4gICAgICAgIGxvb2t1cFtsKytdID0gc2FtcGxlc1tsZW5ndGhJbmRleF0gPCBpID8gKytsZW5ndGhJbmRleCA6IGxlbmd0aEluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZWdtZW50LnRvdGFsTGVuZ3RoID0gc2FtcGxlc1swXSA9IDA7XG4gIH1cblxuICByZXR1cm4gc3RhcnRJbmRleCA/IGxlbmd0aCAtIHNhbXBsZXNbc3RhcnRJbmRleCAvIDIgLSAxXSA6IGxlbmd0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyhyYXdQYXRoLCByZXNvbHV0aW9uKSB7XG4gIHZhciBwYXRoTGVuZ3RoLCBwb2ludHMsIGk7XG5cbiAgZm9yIChpID0gcGF0aExlbmd0aCA9IHBvaW50cyA9IDA7IGkgPCByYXdQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcmF3UGF0aFtpXS5yZXNvbHV0aW9uID0gfn5yZXNvbHV0aW9uIHx8IDEyOyAvL3N0ZXBzIHBlciBCZXppZXIgY3VydmUgKGFuY2hvciwgMiBjb250cm9sIHBvaW50cywgdG8gYW5jaG9yKVxuXG4gICAgcG9pbnRzICs9IHJhd1BhdGhbaV0ubGVuZ3RoO1xuICAgIHBhdGhMZW5ndGggKz0gbWVhc3VyZVNlZ21lbnQocmF3UGF0aFtpXSk7XG4gIH1cblxuICByYXdQYXRoLnRvdGFsUG9pbnRzID0gcG9pbnRzO1xuICByYXdQYXRoLnRvdGFsTGVuZ3RoID0gcGF0aExlbmd0aDtcbiAgcmV0dXJuIHJhd1BhdGg7XG59IC8vZGl2aWRlIHNlZ21lbnRbaV0gYXQgcG9zaXRpb24gdCAodmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBwcm9ncmVzcyBhbG9uZyB0aGF0IHBhcnRpY3VsYXIgY3ViaWMgYmV6aWVyIHNlZ21lbnQgdGhhdCBzdGFydHMgYXQgc2VnbWVudFtpXSkuIFJldHVybnMgaG93IG1hbnkgZWxlbWVudHMgd2VyZSBzcGxpY2VkIGludG8gdGhlIHNlZ21lbnQgYXJyYXkgKGVpdGhlciAwIG9yIDYpXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJkaXZpZGVTZWdtZW50KHNlZ21lbnQsIGksIHQpIHtcbiAgaWYgKHQgPD0gMCB8fCB0ID49IDEpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBheCA9IHNlZ21lbnRbaV0sXG4gICAgICBheSA9IHNlZ21lbnRbaSArIDFdLFxuICAgICAgY3AxeCA9IHNlZ21lbnRbaSArIDJdLFxuICAgICAgY3AxeSA9IHNlZ21lbnRbaSArIDNdLFxuICAgICAgY3AyeCA9IHNlZ21lbnRbaSArIDRdLFxuICAgICAgY3AyeSA9IHNlZ21lbnRbaSArIDVdLFxuICAgICAgYnggPSBzZWdtZW50W2kgKyA2XSxcbiAgICAgIGJ5ID0gc2VnbWVudFtpICsgN10sXG4gICAgICB4MWEgPSBheCArIChjcDF4IC0gYXgpICogdCxcbiAgICAgIHgyID0gY3AxeCArIChjcDJ4IC0gY3AxeCkgKiB0LFxuICAgICAgeTFhID0gYXkgKyAoY3AxeSAtIGF5KSAqIHQsXG4gICAgICB5MiA9IGNwMXkgKyAoY3AyeSAtIGNwMXkpICogdCxcbiAgICAgIHgxID0geDFhICsgKHgyIC0geDFhKSAqIHQsXG4gICAgICB5MSA9IHkxYSArICh5MiAtIHkxYSkgKiB0LFxuICAgICAgeDJhID0gY3AyeCArIChieCAtIGNwMngpICogdCxcbiAgICAgIHkyYSA9IGNwMnkgKyAoYnkgLSBjcDJ5KSAqIHQ7XG4gIHgyICs9ICh4MmEgLSB4MikgKiB0O1xuICB5MiArPSAoeTJhIC0geTIpICogdDtcbiAgc2VnbWVudC5zcGxpY2UoaSArIDIsIDQsIF9yb3VuZCh4MWEpLCAvL2ZpcnN0IGNvbnRyb2wgcG9pbnRcbiAgX3JvdW5kKHkxYSksIF9yb3VuZCh4MSksIC8vc2Vjb25kIGNvbnRyb2wgcG9pbnRcbiAgX3JvdW5kKHkxKSwgX3JvdW5kKHgxICsgKHgyIC0geDEpICogdCksIC8vbmV3IGZhYnJpY2F0ZWQgYW5jaG9yIG9uIGxpbmVcbiAgX3JvdW5kKHkxICsgKHkyIC0geTEpICogdCksIF9yb3VuZCh4MiksIC8vdGhpcmQgY29udHJvbCBwb2ludFxuICBfcm91bmQoeTIpLCBfcm91bmQoeDJhKSwgLy9mb3VydGggY29udHJvbCBwb2ludFxuICBfcm91bmQoeTJhKSk7XG4gIHNlZ21lbnQuc2FtcGxlcyAmJiBzZWdtZW50LnNhbXBsZXMuc3BsaWNlKGkgLyA2ICogc2VnbWVudC5yZXNvbHV0aW9uIHwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gIHJldHVybiA2O1xufSAvLyByZXR1cm5zIGFuIG9iamVjdCB7cGF0aCwgc2VnbWVudCwgc2VnSW5kZXgsIGksIHR9XG5cbmZ1bmN0aW9uIGdldFByb2dyZXNzRGF0YShyYXdQYXRoLCBwcm9ncmVzcywgZGVjb3JhdGVlLCBwdXNoVG9OZXh0SWZBdEVuZCkge1xuICBkZWNvcmF0ZWUgPSBkZWNvcmF0ZWUgfHwge307XG4gIHJhd1BhdGgudG90YWxMZW5ndGggfHwgY2FjaGVSYXdQYXRoTWVhc3VyZW1lbnRzKHJhd1BhdGgpO1xuXG4gIGlmIChwcm9ncmVzcyA8IDAgfHwgcHJvZ3Jlc3MgPiAxKSB7XG4gICAgcHJvZ3Jlc3MgPSBfd3JhcFByb2dyZXNzKHByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciBzZWdJbmRleCA9IDAsXG4gICAgICBzZWdtZW50ID0gcmF3UGF0aFswXSxcbiAgICAgIHNhbXBsZXMsXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgbGVuZ3RoLFxuICAgICAgbWluLFxuICAgICAgbWF4LFxuICAgICAgaSxcbiAgICAgIHQ7XG5cbiAgaWYgKCFwcm9ncmVzcykge1xuICAgIHQgPSBpID0gc2VnSW5kZXggPSAwO1xuICAgIHNlZ21lbnQgPSByYXdQYXRoWzBdO1xuICB9IGVsc2UgaWYgKHByb2dyZXNzID09PSAxKSB7XG4gICAgdCA9IDE7XG4gICAgc2VnSW5kZXggPSByYXdQYXRoLmxlbmd0aCAtIDE7XG4gICAgc2VnbWVudCA9IHJhd1BhdGhbc2VnSW5kZXhdO1xuICAgIGkgPSBzZWdtZW50Lmxlbmd0aCAtIDg7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHJhd1BhdGgubGVuZ3RoID4gMSkge1xuICAgICAgLy9zcGVlZCBvcHRpbWl6YXRpb246IG1vc3Qgb2YgdGhlIHRpbWUsIHRoZXJlJ3Mgb25seSBvbmUgc2VnbWVudCBzbyBza2lwIHRoZSByZWN1cnNpb24uXG4gICAgICBsZW5ndGggPSByYXdQYXRoLnRvdGFsTGVuZ3RoICogcHJvZ3Jlc3M7XG4gICAgICBtYXggPSBpID0gMDtcblxuICAgICAgd2hpbGUgKChtYXggKz0gcmF3UGF0aFtpKytdLnRvdGFsTGVuZ3RoKSA8IGxlbmd0aCkge1xuICAgICAgICBzZWdJbmRleCA9IGk7XG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQgPSByYXdQYXRoW3NlZ0luZGV4XTtcbiAgICAgIG1pbiA9IG1heCAtIHNlZ21lbnQudG90YWxMZW5ndGg7XG4gICAgICBwcm9ncmVzcyA9IChsZW5ndGggLSBtaW4pIC8gKG1heCAtIG1pbikgfHwgMDtcbiAgICB9XG5cbiAgICBzYW1wbGVzID0gc2VnbWVudC5zYW1wbGVzO1xuICAgIHJlc29sdXRpb24gPSBzZWdtZW50LnJlc29sdXRpb247IC8vaG93IG1hbnkgc2FtcGxlcyBwZXIgY3ViaWMgYmV6aWVyIGNodW5rXG5cbiAgICBsZW5ndGggPSBzZWdtZW50LnRvdGFsTGVuZ3RoICogcHJvZ3Jlc3M7XG4gICAgaSA9IHNlZ21lbnQubG9va3VwLmxlbmd0aCA/IHNlZ21lbnQubG9va3VwW35+KGxlbmd0aCAvIHNlZ21lbnQubWluTGVuZ3RoKV0gfHwgMCA6IF9nZXRTYW1wbGVJbmRleChzYW1wbGVzLCBsZW5ndGgsIHByb2dyZXNzKTtcbiAgICBtaW4gPSBpID8gc2FtcGxlc1tpIC0gMV0gOiAwO1xuICAgIG1heCA9IHNhbXBsZXNbaV07XG5cbiAgICBpZiAobWF4IDwgbGVuZ3RoKSB7XG4gICAgICBtaW4gPSBtYXg7XG4gICAgICBtYXggPSBzYW1wbGVzWysraV07XG4gICAgfVxuXG4gICAgdCA9IDEgLyByZXNvbHV0aW9uICogKChsZW5ndGggLSBtaW4pIC8gKG1heCAtIG1pbikgKyBpICUgcmVzb2x1dGlvbik7XG4gICAgaSA9IH5+KGkgLyByZXNvbHV0aW9uKSAqIDY7XG5cbiAgICBpZiAocHVzaFRvTmV4dElmQXRFbmQgJiYgdCA9PT0gMSkge1xuICAgICAgaWYgKGkgKyA2IDwgc2VnbWVudC5sZW5ndGgpIHtcbiAgICAgICAgaSArPSA2O1xuICAgICAgICB0ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoc2VnSW5kZXggKyAxIDwgcmF3UGF0aC5sZW5ndGgpIHtcbiAgICAgICAgaSA9IHQgPSAwO1xuICAgICAgICBzZWdtZW50ID0gcmF3UGF0aFsrK3NlZ0luZGV4XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWNvcmF0ZWUudCA9IHQ7XG4gIGRlY29yYXRlZS5pID0gaTtcbiAgZGVjb3JhdGVlLnBhdGggPSByYXdQYXRoO1xuICBkZWNvcmF0ZWUuc2VnbWVudCA9IHNlZ21lbnQ7XG4gIGRlY29yYXRlZS5zZWdJbmRleCA9IHNlZ0luZGV4O1xuICByZXR1cm4gZGVjb3JhdGVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9zaXRpb25PblBhdGgocmF3UGF0aCwgcHJvZ3Jlc3MsIGluY2x1ZGVBbmdsZSwgcG9pbnQpIHtcbiAgdmFyIHNlZ21lbnQgPSByYXdQYXRoWzBdLFxuICAgICAgcmVzdWx0ID0gcG9pbnQgfHwge30sXG4gICAgICBzYW1wbGVzLFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIGxlbmd0aCxcbiAgICAgIG1pbixcbiAgICAgIG1heCxcbiAgICAgIGksXG4gICAgICB0LFxuICAgICAgYSxcbiAgICAgIGludjtcblxuICBpZiAocHJvZ3Jlc3MgPCAwIHx8IHByb2dyZXNzID4gMSkge1xuICAgIHByb2dyZXNzID0gX3dyYXBQcm9ncmVzcyhwcm9ncmVzcyk7XG4gIH1cblxuICBzZWdtZW50Lmxvb2t1cCB8fCBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMocmF3UGF0aCk7XG5cbiAgaWYgKHJhd1BhdGgubGVuZ3RoID4gMSkge1xuICAgIC8vc3BlZWQgb3B0aW1pemF0aW9uOiBtb3N0IG9mIHRoZSB0aW1lLCB0aGVyZSdzIG9ubHkgb25lIHNlZ21lbnQgc28gc2tpcCB0aGUgcmVjdXJzaW9uLlxuICAgIGxlbmd0aCA9IHJhd1BhdGgudG90YWxMZW5ndGggKiBwcm9ncmVzcztcbiAgICBtYXggPSBpID0gMDtcblxuICAgIHdoaWxlICgobWF4ICs9IHJhd1BhdGhbaSsrXS50b3RhbExlbmd0aCkgPCBsZW5ndGgpIHtcbiAgICAgIHNlZ21lbnQgPSByYXdQYXRoW2ldO1xuICAgIH1cblxuICAgIG1pbiA9IG1heCAtIHNlZ21lbnQudG90YWxMZW5ndGg7XG4gICAgcHJvZ3Jlc3MgPSAobGVuZ3RoIC0gbWluKSAvIChtYXggLSBtaW4pIHx8IDA7XG4gIH1cblxuICBzYW1wbGVzID0gc2VnbWVudC5zYW1wbGVzO1xuICByZXNvbHV0aW9uID0gc2VnbWVudC5yZXNvbHV0aW9uO1xuICBsZW5ndGggPSBzZWdtZW50LnRvdGFsTGVuZ3RoICogcHJvZ3Jlc3M7XG4gIGkgPSBzZWdtZW50Lmxvb2t1cC5sZW5ndGggPyBzZWdtZW50Lmxvb2t1cFtwcm9ncmVzcyA8IDEgPyB+fihsZW5ndGggLyBzZWdtZW50Lm1pbkxlbmd0aCkgOiBzZWdtZW50Lmxvb2t1cC5sZW5ndGggLSAxXSB8fCAwIDogX2dldFNhbXBsZUluZGV4KHNhbXBsZXMsIGxlbmd0aCwgcHJvZ3Jlc3MpO1xuICBtaW4gPSBpID8gc2FtcGxlc1tpIC0gMV0gOiAwO1xuICBtYXggPSBzYW1wbGVzW2ldO1xuXG4gIGlmIChtYXggPCBsZW5ndGgpIHtcbiAgICBtaW4gPSBtYXg7XG4gICAgbWF4ID0gc2FtcGxlc1srK2ldO1xuICB9XG5cbiAgdCA9IDEgLyByZXNvbHV0aW9uICogKChsZW5ndGggLSBtaW4pIC8gKG1heCAtIG1pbikgKyBpICUgcmVzb2x1dGlvbikgfHwgMDtcbiAgaW52ID0gMSAtIHQ7XG4gIGkgPSB+fihpIC8gcmVzb2x1dGlvbikgKiA2O1xuICBhID0gc2VnbWVudFtpXTtcbiAgcmVzdWx0LnggPSBfcm91bmQoKHQgKiB0ICogKHNlZ21lbnRbaSArIDZdIC0gYSkgKyAzICogaW52ICogKHQgKiAoc2VnbWVudFtpICsgNF0gLSBhKSArIGludiAqIChzZWdtZW50W2kgKyAyXSAtIGEpKSkgKiB0ICsgYSk7XG4gIHJlc3VsdC55ID0gX3JvdW5kKCh0ICogdCAqIChzZWdtZW50W2kgKyA3XSAtIChhID0gc2VnbWVudFtpICsgMV0pKSArIDMgKiBpbnYgKiAodCAqIChzZWdtZW50W2kgKyA1XSAtIGEpICsgaW52ICogKHNlZ21lbnRbaSArIDNdIC0gYSkpKSAqIHQgKyBhKTtcblxuICBpZiAoaW5jbHVkZUFuZ2xlKSB7XG4gICAgcmVzdWx0LmFuZ2xlID0gc2VnbWVudC50b3RhbExlbmd0aCA/IGdldFJvdGF0aW9uQXRCZXppZXJUKHNlZ21lbnQsIGksIHQgPj0gMSA/IDEgLSAxZS05IDogdCA/IHQgOiAxZS05KSA6IHNlZ21lbnQuYW5nbGUgfHwgMDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59IC8vYXBwbGllcyBhIG1hdHJpeCB0cmFuc2Zvcm0gdG8gUmF3UGF0aCAob3IgYSBzZWdtZW50IGluIGEgUmF3UGF0aCkgYW5kIHJldHVybnMgd2hhdGV2ZXIgd2FzIHBhc3NlZCBpbiAoaXQgdHJhbnNmb3JtcyB0aGUgdmFsdWVzIGluIHRoZSBhcnJheShzKSwgbm90IGEgY29weSkuXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1SYXdQYXRoKHJhd1BhdGgsIGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICB2YXIgaiA9IHJhd1BhdGgubGVuZ3RoLFxuICAgICAgc2VnbWVudCxcbiAgICAgIGwsXG4gICAgICBpLFxuICAgICAgeCxcbiAgICAgIHk7XG5cbiAgd2hpbGUgKC0taiA+IC0xKSB7XG4gICAgc2VnbWVudCA9IHJhd1BhdGhbal07XG4gICAgbCA9IHNlZ21lbnQubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgeCA9IHNlZ21lbnRbaV07XG4gICAgICB5ID0gc2VnbWVudFtpICsgMV07XG4gICAgICBzZWdtZW50W2ldID0geCAqIGEgKyB5ICogYyArIHR4O1xuICAgICAgc2VnbWVudFtpICsgMV0gPSB4ICogYiArIHkgKiBkICsgdHk7XG4gICAgfVxuICB9XG5cbiAgcmF3UGF0aC5fZGlydHkgPSAxO1xuICByZXR1cm4gcmF3UGF0aDtcbn0gLy8gdHJhbnNsYXRlcyBTVkcgYXJjIGRhdGEgaW50byBhIHNlZ21lbnQgKGN1YmljIGJlemllcnMpLiBBbmdsZSBpcyBpbiBkZWdyZWVzLlxuXG5mdW5jdGlvbiBhcmNUb1NlZ21lbnQobGFzdFgsIGxhc3RZLCByeCwgcnksIGFuZ2xlLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgeCwgeSkge1xuICBpZiAobGFzdFggPT09IHggJiYgbGFzdFkgPT09IHkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByeCA9IF9hYnMocngpO1xuICByeSA9IF9hYnMocnkpO1xuXG4gIHZhciBhbmdsZVJhZCA9IGFuZ2xlICUgMzYwICogX0RFRzJSQUQsXG4gICAgICBjb3NBbmdsZSA9IF9jb3MoYW5nbGVSYWQpLFxuICAgICAgc2luQW5nbGUgPSBfc2luKGFuZ2xlUmFkKSxcbiAgICAgIFBJID0gTWF0aC5QSSxcbiAgICAgIFRXT1BJID0gUEkgKiAyLFxuICAgICAgZHgyID0gKGxhc3RYIC0geCkgLyAyLFxuICAgICAgZHkyID0gKGxhc3RZIC0geSkgLyAyLFxuICAgICAgeDEgPSBjb3NBbmdsZSAqIGR4MiArIHNpbkFuZ2xlICogZHkyLFxuICAgICAgeTEgPSAtc2luQW5nbGUgKiBkeDIgKyBjb3NBbmdsZSAqIGR5MixcbiAgICAgIHgxX3NxID0geDEgKiB4MSxcbiAgICAgIHkxX3NxID0geTEgKiB5MSxcbiAgICAgIHJhZGlpQ2hlY2sgPSB4MV9zcSAvIChyeCAqIHJ4KSArIHkxX3NxIC8gKHJ5ICogcnkpO1xuXG4gIGlmIChyYWRpaUNoZWNrID4gMSkge1xuICAgIHJ4ID0gX3NxcnQocmFkaWlDaGVjaykgKiByeDtcbiAgICByeSA9IF9zcXJ0KHJhZGlpQ2hlY2spICogcnk7XG4gIH1cblxuICB2YXIgcnhfc3EgPSByeCAqIHJ4LFxuICAgICAgcnlfc3EgPSByeSAqIHJ5LFxuICAgICAgc3EgPSAocnhfc3EgKiByeV9zcSAtIHJ4X3NxICogeTFfc3EgLSByeV9zcSAqIHgxX3NxKSAvIChyeF9zcSAqIHkxX3NxICsgcnlfc3EgKiB4MV9zcSk7XG5cbiAgaWYgKHNxIDwgMCkge1xuICAgIHNxID0gMDtcbiAgfVxuXG4gIHZhciBjb2VmID0gKGxhcmdlQXJjRmxhZyA9PT0gc3dlZXBGbGFnID8gLTEgOiAxKSAqIF9zcXJ0KHNxKSxcbiAgICAgIGN4MSA9IGNvZWYgKiAocnggKiB5MSAvIHJ5KSxcbiAgICAgIGN5MSA9IGNvZWYgKiAtKHJ5ICogeDEgLyByeCksXG4gICAgICBzeDIgPSAobGFzdFggKyB4KSAvIDIsXG4gICAgICBzeTIgPSAobGFzdFkgKyB5KSAvIDIsXG4gICAgICBjeCA9IHN4MiArIChjb3NBbmdsZSAqIGN4MSAtIHNpbkFuZ2xlICogY3kxKSxcbiAgICAgIGN5ID0gc3kyICsgKHNpbkFuZ2xlICogY3gxICsgY29zQW5nbGUgKiBjeTEpLFxuICAgICAgdXggPSAoeDEgLSBjeDEpIC8gcngsXG4gICAgICB1eSA9ICh5MSAtIGN5MSkgLyByeSxcbiAgICAgIHZ4ID0gKC14MSAtIGN4MSkgLyByeCxcbiAgICAgIHZ5ID0gKC15MSAtIGN5MSkgLyByeSxcbiAgICAgIHRlbXAgPSB1eCAqIHV4ICsgdXkgKiB1eSxcbiAgICAgIGFuZ2xlU3RhcnQgPSAodXkgPCAwID8gLTEgOiAxKSAqIE1hdGguYWNvcyh1eCAvIF9zcXJ0KHRlbXApKSxcbiAgICAgIGFuZ2xlRXh0ZW50ID0gKHV4ICogdnkgLSB1eSAqIHZ4IDwgMCA/IC0xIDogMSkgKiBNYXRoLmFjb3MoKHV4ICogdnggKyB1eSAqIHZ5KSAvIF9zcXJ0KHRlbXAgKiAodnggKiB2eCArIHZ5ICogdnkpKSk7XG5cbiAgaXNOYU4oYW5nbGVFeHRlbnQpICYmIChhbmdsZUV4dGVudCA9IFBJKTsgLy9yYXJlIGVkZ2UgY2FzZS4gTWF0aC5jb3MoLTEpIGlzIE5hTi5cblxuICBpZiAoIXN3ZWVwRmxhZyAmJiBhbmdsZUV4dGVudCA+IDApIHtcbiAgICBhbmdsZUV4dGVudCAtPSBUV09QSTtcbiAgfSBlbHNlIGlmIChzd2VlcEZsYWcgJiYgYW5nbGVFeHRlbnQgPCAwKSB7XG4gICAgYW5nbGVFeHRlbnQgKz0gVFdPUEk7XG4gIH1cblxuICBhbmdsZVN0YXJ0ICU9IFRXT1BJO1xuICBhbmdsZUV4dGVudCAlPSBUV09QSTtcblxuICB2YXIgc2VnbWVudHMgPSBNYXRoLmNlaWwoX2FicyhhbmdsZUV4dGVudCkgLyAoVFdPUEkgLyA0KSksXG4gICAgICByYXdQYXRoID0gW10sXG4gICAgICBhbmdsZUluY3JlbWVudCA9IGFuZ2xlRXh0ZW50IC8gc2VnbWVudHMsXG4gICAgICBjb250cm9sTGVuZ3RoID0gNCAvIDMgKiBfc2luKGFuZ2xlSW5jcmVtZW50IC8gMikgLyAoMSArIF9jb3MoYW5nbGVJbmNyZW1lbnQgLyAyKSksXG4gICAgICBtYSA9IGNvc0FuZ2xlICogcngsXG4gICAgICBtYiA9IHNpbkFuZ2xlICogcngsXG4gICAgICBtYyA9IHNpbkFuZ2xlICogLXJ5LFxuICAgICAgbWQgPSBjb3NBbmdsZSAqIHJ5LFxuICAgICAgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc2VnbWVudHM7IGkrKykge1xuICAgIGFuZ2xlID0gYW5nbGVTdGFydCArIGkgKiBhbmdsZUluY3JlbWVudDtcbiAgICB4MSA9IF9jb3MoYW5nbGUpO1xuICAgIHkxID0gX3NpbihhbmdsZSk7XG4gICAgdXggPSBfY29zKGFuZ2xlICs9IGFuZ2xlSW5jcmVtZW50KTtcbiAgICB1eSA9IF9zaW4oYW5nbGUpO1xuICAgIHJhd1BhdGgucHVzaCh4MSAtIGNvbnRyb2xMZW5ndGggKiB5MSwgeTEgKyBjb250cm9sTGVuZ3RoICogeDEsIHV4ICsgY29udHJvbExlbmd0aCAqIHV5LCB1eSAtIGNvbnRyb2xMZW5ndGggKiB1eCwgdXgsIHV5KTtcbiAgfSAvL25vdyB0cmFuc2Zvcm0gYWNjb3JkaW5nIHRvIHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGUgZWxsaXBzZS9hcmMgKHRoZSBiZXppZXJzIHdlcmUgbm9yYW1saXplZCwgYmV0d2VlbiAwIGFuZCAxIG9uIGEgY2lyY2xlKS5cblxuXG4gIGZvciAoaSA9IDA7IGkgPCByYXdQYXRoLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgeDEgPSByYXdQYXRoW2ldO1xuICAgIHkxID0gcmF3UGF0aFtpICsgMV07XG4gICAgcmF3UGF0aFtpXSA9IHgxICogbWEgKyB5MSAqIG1jICsgY3g7XG4gICAgcmF3UGF0aFtpICsgMV0gPSB4MSAqIG1iICsgeTEgKiBtZCArIGN5O1xuICB9XG5cbiAgcmF3UGF0aFtpIC0gMl0gPSB4OyAvL2Fsd2F5cyBzZXQgdGhlIGVuZCB0byBleGFjdGx5IHdoZXJlIGl0J3Mgc3VwcG9zZWQgdG8gYmVcblxuICByYXdQYXRoW2kgLSAxXSA9IHk7XG4gIHJldHVybiByYXdQYXRoO1xufSAvL1NwaXRzIGJhY2sgYSBSYXdQYXRoIHdpdGggYWJzb2x1dGUgY29vcmRpbmF0ZXMuIEVhY2ggc2VnbWVudCBzdGFydHMgd2l0aCBhIFwibW92ZVRvXCIgY29tbWFuZCAoeCBjb29yZGluYXRlLCB0aGVuIHkpIGFuZCB0aGVuIDIgY29udHJvbCBwb2ludHMgKHgsIHksIHgsIHkpLCB0aGVuIGFuY2hvci4gVGhlIGdvYWwgaXMgdG8gbWluaW1pemUgbWVtb3J5IGFuZCBtYXhpbWl6ZSBzcGVlZC5cblxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9SYXdQYXRoKGQpIHtcbiAgdmFyIGEgPSAoZCArIFwiXCIpLnJlcGxhY2UoX3NjaWVudGlmaWMsIGZ1bmN0aW9uIChtKSB7XG4gICAgdmFyIG4gPSArbTtcbiAgICByZXR1cm4gbiA8IDAuMDAwMSAmJiBuID4gLTAuMDAwMSA/IDAgOiBuO1xuICB9KS5tYXRjaChfc3ZnUGF0aEV4cCkgfHwgW10sXG4gICAgICAvL3NvbWUgYXV0aG9yaW5nIHByb2dyYW1zIHNwaXQgb3V0IHZlcnkgc21hbGwgbnVtYmVycyBpbiBzY2llbnRpZmljIG5vdGF0aW9uIGxpa2UgXCIxZS01XCIsIHNvIG1ha2Ugc3VyZSB3ZSByb3VuZCB0aGF0IGRvd24gdG8gMCBmaXJzdC5cbiAgcGF0aCA9IFtdLFxuICAgICAgcmVsYXRpdmVYID0gMCxcbiAgICAgIHJlbGF0aXZlWSA9IDAsXG4gICAgICB0d29UaGlyZHMgPSAyIC8gMyxcbiAgICAgIGVsZW1lbnRzID0gYS5sZW5ndGgsXG4gICAgICBwb2ludHMgPSAwLFxuICAgICAgZXJyb3JNZXNzYWdlID0gXCJFUlJPUjogbWFsZm9ybWVkIHBhdGg6IFwiICsgZCxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBjb21tYW5kLFxuICAgICAgaXNSZWxhdGl2ZSxcbiAgICAgIHNlZ21lbnQsXG4gICAgICBzdGFydFgsXG4gICAgICBzdGFydFksXG4gICAgICBkaWZYLFxuICAgICAgZGlmWSxcbiAgICAgIGJlemllcnMsXG4gICAgICBwcmV2Q29tbWFuZCxcbiAgICAgIGZsYWcxLFxuICAgICAgZmxhZzIsXG4gICAgICBsaW5lID0gZnVuY3Rpb24gbGluZShzeCwgc3ksIGV4LCBleSkge1xuICAgIGRpZlggPSAoZXggLSBzeCkgLyAzO1xuICAgIGRpZlkgPSAoZXkgLSBzeSkgLyAzO1xuICAgIHNlZ21lbnQucHVzaChzeCArIGRpZlgsIHN5ICsgZGlmWSwgZXggLSBkaWZYLCBleSAtIGRpZlksIGV4LCBleSk7XG4gIH07XG5cbiAgaWYgKCFkIHx8ICFpc05hTihhWzBdKSB8fCBpc05hTihhWzFdKSkge1xuICAgIGNvbnNvbGUubG9nKGVycm9yTWVzc2FnZSk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHM7IGkrKykge1xuICAgIHByZXZDb21tYW5kID0gY29tbWFuZDtcblxuICAgIGlmIChpc05hTihhW2ldKSkge1xuICAgICAgY29tbWFuZCA9IGFbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgIGlzUmVsYXRpdmUgPSBjb21tYW5kICE9PSBhW2ldOyAvL2xvd2VyIGNhc2UgbWVhbnMgcmVsYXRpdmVcbiAgICB9IGVsc2Uge1xuICAgICAgLy9jb21tYW5kcyBsaWtlIFwiQ1wiIGNhbiBiZSBzdHJ1bmcgdG9nZXRoZXIgd2l0aG91dCBhbnkgbmV3IGNvbW1hbmQgY2hhcmFjdGVycyBiZXR3ZWVuLlxuICAgICAgaS0tO1xuICAgIH1cblxuICAgIHggPSArYVtpICsgMV07XG4gICAgeSA9ICthW2kgKyAyXTtcblxuICAgIGlmIChpc1JlbGF0aXZlKSB7XG4gICAgICB4ICs9IHJlbGF0aXZlWDtcbiAgICAgIHkgKz0gcmVsYXRpdmVZO1xuICAgIH1cblxuICAgIGlmICghaSkge1xuICAgICAgc3RhcnRYID0geDtcbiAgICAgIHN0YXJ0WSA9IHk7XG4gICAgfSAvLyBcIk1cIiAobW92ZSlcblxuXG4gICAgaWYgKGNvbW1hbmQgPT09IFwiTVwiKSB7XG4gICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPCA4KSB7XG4gICAgICAgICAgLy9pZiB0aGUgcGF0aCBkYXRhIHdhcyBmdW5reSBhbmQganVzdCBoYWQgYSBNIHdpdGggbm8gYWN0dWFsIGRyYXdpbmcgYW55d2hlcmUsIHNraXAgaXQuXG4gICAgICAgICAgcGF0aC5sZW5ndGggLT0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ludHMgKz0gc2VnbWVudC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVsYXRpdmVYID0gc3RhcnRYID0geDtcbiAgICAgIHJlbGF0aXZlWSA9IHN0YXJ0WSA9IHk7XG4gICAgICBzZWdtZW50ID0gW3gsIHldO1xuICAgICAgcGF0aC5wdXNoKHNlZ21lbnQpO1xuICAgICAgaSArPSAyO1xuICAgICAgY29tbWFuZCA9IFwiTFwiOyAvL2FuIFwiTVwiIHdpdGggbW9yZSB0aGFuIDIgdmFsdWVzIGdldHMgaW50ZXJwcmV0ZWQgYXMgXCJsaW5lVG9cIiBjb21tYW5kcyAoXCJMXCIpLlxuICAgICAgLy8gXCJDXCIgKGN1YmljIGJlemllcilcbiAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiQ1wiKSB7XG4gICAgICBpZiAoIXNlZ21lbnQpIHtcbiAgICAgICAgc2VnbWVudCA9IFswLCAwXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1JlbGF0aXZlKSB7XG4gICAgICAgIHJlbGF0aXZlWCA9IHJlbGF0aXZlWSA9IDA7XG4gICAgICB9IC8vbm90ZTogXCIqMVwiIGlzIGp1c3QgYSBmYXN0L3Nob3J0IHdheSB0byBjYXN0IHRoZSB2YWx1ZSBhcyBhIE51bWJlci4gV0FBQVkgZmFzdGVyIGluIENocm9tZSwgc2xpZ2h0bHkgc2xvd2VyIGluIEZpcmVmb3guXG5cblxuICAgICAgc2VnbWVudC5wdXNoKHgsIHksIHJlbGF0aXZlWCArIGFbaSArIDNdICogMSwgcmVsYXRpdmVZICsgYVtpICsgNF0gKiAxLCByZWxhdGl2ZVggKz0gYVtpICsgNV0gKiAxLCByZWxhdGl2ZVkgKz0gYVtpICsgNl0gKiAxKTtcbiAgICAgIGkgKz0gNjsgLy8gXCJTXCIgKGNvbnRpbnVhdGlvbiBvZiBjdWJpYyBiZXppZXIpXG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSBcIlNcIikge1xuICAgICAgZGlmWCA9IHJlbGF0aXZlWDtcbiAgICAgIGRpZlkgPSByZWxhdGl2ZVk7XG5cbiAgICAgIGlmIChwcmV2Q29tbWFuZCA9PT0gXCJDXCIgfHwgcHJldkNvbW1hbmQgPT09IFwiU1wiKSB7XG4gICAgICAgIGRpZlggKz0gcmVsYXRpdmVYIC0gc2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDRdO1xuICAgICAgICBkaWZZICs9IHJlbGF0aXZlWSAtIHNlZ21lbnRbc2VnbWVudC5sZW5ndGggLSAzXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1JlbGF0aXZlKSB7XG4gICAgICAgIHJlbGF0aXZlWCA9IHJlbGF0aXZlWSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQucHVzaChkaWZYLCBkaWZZLCB4LCB5LCByZWxhdGl2ZVggKz0gYVtpICsgM10gKiAxLCByZWxhdGl2ZVkgKz0gYVtpICsgNF0gKiAxKTtcbiAgICAgIGkgKz0gNDsgLy8gXCJRXCIgKHF1YWRyYXRpYyBiZXppZXIpXG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSBcIlFcIikge1xuICAgICAgZGlmWCA9IHJlbGF0aXZlWCArICh4IC0gcmVsYXRpdmVYKSAqIHR3b1RoaXJkcztcbiAgICAgIGRpZlkgPSByZWxhdGl2ZVkgKyAoeSAtIHJlbGF0aXZlWSkgKiB0d29UaGlyZHM7XG5cbiAgICAgIGlmICghaXNSZWxhdGl2ZSkge1xuICAgICAgICByZWxhdGl2ZVggPSByZWxhdGl2ZVkgPSAwO1xuICAgICAgfVxuXG4gICAgICByZWxhdGl2ZVggKz0gYVtpICsgM10gKiAxO1xuICAgICAgcmVsYXRpdmVZICs9IGFbaSArIDRdICogMTtcbiAgICAgIHNlZ21lbnQucHVzaChkaWZYLCBkaWZZLCByZWxhdGl2ZVggKyAoeCAtIHJlbGF0aXZlWCkgKiB0d29UaGlyZHMsIHJlbGF0aXZlWSArICh5IC0gcmVsYXRpdmVZKSAqIHR3b1RoaXJkcywgcmVsYXRpdmVYLCByZWxhdGl2ZVkpO1xuICAgICAgaSArPSA0OyAvLyBcIlRcIiAoY29udGludWF0aW9uIG9mIHF1YWRyYXRpYyBiZXppZXIpXG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSBcIlRcIikge1xuICAgICAgZGlmWCA9IHJlbGF0aXZlWCAtIHNlZ21lbnRbc2VnbWVudC5sZW5ndGggLSA0XTtcbiAgICAgIGRpZlkgPSByZWxhdGl2ZVkgLSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gM107XG4gICAgICBzZWdtZW50LnB1c2gocmVsYXRpdmVYICsgZGlmWCwgcmVsYXRpdmVZICsgZGlmWSwgeCArIChyZWxhdGl2ZVggKyBkaWZYICogMS41IC0geCkgKiB0d29UaGlyZHMsIHkgKyAocmVsYXRpdmVZICsgZGlmWSAqIDEuNSAtIHkpICogdHdvVGhpcmRzLCByZWxhdGl2ZVggPSB4LCByZWxhdGl2ZVkgPSB5KTtcbiAgICAgIGkgKz0gMjsgLy8gXCJIXCIgKGhvcml6b250YWwgbGluZSlcbiAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiSFwiKSB7XG4gICAgICBsaW5lKHJlbGF0aXZlWCwgcmVsYXRpdmVZLCByZWxhdGl2ZVggPSB4LCByZWxhdGl2ZVkpO1xuICAgICAgaSArPSAxOyAvLyBcIlZcIiAodmVydGljYWwgbGluZSlcbiAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiVlwiKSB7XG4gICAgICAvL2FkanVzdCB2YWx1ZXMgYmVjYXVzZSB0aGUgZmlyc3QgKGFuZCBvbmx5IG9uZSkgaXNuJ3QgeCBpbiB0aGlzIGNhc2UsIGl0J3MgeS5cbiAgICAgIGxpbmUocmVsYXRpdmVYLCByZWxhdGl2ZVksIHJlbGF0aXZlWCwgcmVsYXRpdmVZID0geCArIChpc1JlbGF0aXZlID8gcmVsYXRpdmVZIC0gcmVsYXRpdmVYIDogMCkpO1xuICAgICAgaSArPSAxOyAvLyBcIkxcIiAobGluZSkgb3IgXCJaXCIgKGNsb3NlKVxuICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJMXCIgfHwgY29tbWFuZCA9PT0gXCJaXCIpIHtcbiAgICAgIGlmIChjb21tYW5kID09PSBcIlpcIikge1xuICAgICAgICB4ID0gc3RhcnRYO1xuICAgICAgICB5ID0gc3RhcnRZO1xuICAgICAgICBzZWdtZW50LmNsb3NlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21tYW5kID09PSBcIkxcIiB8fCBfYWJzKHJlbGF0aXZlWCAtIHgpID4gMC41IHx8IF9hYnMocmVsYXRpdmVZIC0geSkgPiAwLjUpIHtcbiAgICAgICAgbGluZShyZWxhdGl2ZVgsIHJlbGF0aXZlWSwgeCwgeSk7XG5cbiAgICAgICAgaWYgKGNvbW1hbmQgPT09IFwiTFwiKSB7XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlbGF0aXZlWCA9IHg7XG4gICAgICByZWxhdGl2ZVkgPSB5OyAvLyBcIkFcIiAoYXJjKVxuICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJBXCIpIHtcbiAgICAgIGZsYWcxID0gYVtpICsgNF07XG4gICAgICBmbGFnMiA9IGFbaSArIDVdO1xuICAgICAgZGlmWCA9IGFbaSArIDZdO1xuICAgICAgZGlmWSA9IGFbaSArIDddO1xuICAgICAgaiA9IDc7XG5cbiAgICAgIGlmIChmbGFnMS5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIGZvciBjYXNlcyB3aGVuIHRoZSBmbGFncyBhcmUgbWVyZ2VkLCBsaWtlIFwiYTggOCAwIDAxOCA4XCIgKHRoZSAwIGFuZCAxIGZsYWdzIGFyZSBXSVRIIHRoZSB4IHZhbHVlIG9mIDgsIGJ1dCBpdCBjb3VsZCBhbHNvIGJlIFwiYTggOCAwIDAxLTggOFwiIHNvIGl0IG1heSBpbmNsdWRlIHggb3Igbm90KVxuICAgICAgICBpZiAoZmxhZzEubGVuZ3RoIDwgMykge1xuICAgICAgICAgIGRpZlkgPSBkaWZYO1xuICAgICAgICAgIGRpZlggPSBmbGFnMjtcbiAgICAgICAgICBqLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlmWSA9IGZsYWcyO1xuICAgICAgICAgIGRpZlggPSBmbGFnMS5zdWJzdHIoMik7XG4gICAgICAgICAgaiAtPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgZmxhZzIgPSBmbGFnMS5jaGFyQXQoMSk7XG4gICAgICAgIGZsYWcxID0gZmxhZzEuY2hhckF0KDApO1xuICAgICAgfVxuXG4gICAgICBiZXppZXJzID0gYXJjVG9TZWdtZW50KHJlbGF0aXZlWCwgcmVsYXRpdmVZLCArYVtpICsgMV0sICthW2kgKyAyXSwgK2FbaSArIDNdLCArZmxhZzEsICtmbGFnMiwgKGlzUmVsYXRpdmUgPyByZWxhdGl2ZVggOiAwKSArIGRpZlggKiAxLCAoaXNSZWxhdGl2ZSA/IHJlbGF0aXZlWSA6IDApICsgZGlmWSAqIDEpO1xuICAgICAgaSArPSBqO1xuXG4gICAgICBpZiAoYmV6aWVycykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgYmV6aWVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNlZ21lbnQucHVzaChiZXppZXJzW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZWxhdGl2ZVggPSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gMl07XG4gICAgICByZWxhdGl2ZVkgPSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgaSA9IHNlZ21lbnQubGVuZ3RoO1xuXG4gIGlmIChpIDwgNikge1xuICAgIC8vaW4gY2FzZSB0aGVyZSdzIG9kZCBTVkcgbGlrZSBhIE0wLDAgY29tbWFuZCBhdCB0aGUgdmVyeSBlbmQuXG4gICAgcGF0aC5wb3AoKTtcbiAgICBpID0gMDtcbiAgfSBlbHNlIGlmIChzZWdtZW50WzBdID09PSBzZWdtZW50W2kgLSAyXSAmJiBzZWdtZW50WzFdID09PSBzZWdtZW50W2kgLSAxXSkge1xuICAgIHNlZ21lbnQuY2xvc2VkID0gdHJ1ZTtcbiAgfVxuXG4gIHBhdGgudG90YWxQb2ludHMgPSBwb2ludHMgKyBpO1xuICByZXR1cm4gcGF0aDtcbn0gLy9wb3B1bGF0ZXMgdGhlIHBvaW50cyBhcnJheSBpbiBhbHRlcm5hdGluZyB4L3kgdmFsdWVzIChsaWtlIFt4LCB5LCB4LCB5Li4uXSBpbnN0ZWFkIG9mIGluZGl2aWR1YWwgcG9pbnQgb2JqZWN0cyBbe3gsIHl9LCB7eCwgeX0uLi5dIHRvIGNvbnNlcnZlIG1lbW9yeSBhbmQgc3RheSBpbiBsaW5lIHdpdGggaG93IHdlJ3JlIGhhbmRsaW5nIHNlZ21lbnQgYXJyYXlzXG5cbmV4cG9ydCBmdW5jdGlvbiBiZXppZXJUb1BvaW50cyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIHRocmVzaG9sZCwgcG9pbnRzLCBpbmRleCkge1xuICB2YXIgeDEyID0gKHgxICsgeDIpIC8gMixcbiAgICAgIHkxMiA9ICh5MSArIHkyKSAvIDIsXG4gICAgICB4MjMgPSAoeDIgKyB4MykgLyAyLFxuICAgICAgeTIzID0gKHkyICsgeTMpIC8gMixcbiAgICAgIHgzNCA9ICh4MyArIHg0KSAvIDIsXG4gICAgICB5MzQgPSAoeTMgKyB5NCkgLyAyLFxuICAgICAgeDEyMyA9ICh4MTIgKyB4MjMpIC8gMixcbiAgICAgIHkxMjMgPSAoeTEyICsgeTIzKSAvIDIsXG4gICAgICB4MjM0ID0gKHgyMyArIHgzNCkgLyAyLFxuICAgICAgeTIzNCA9ICh5MjMgKyB5MzQpIC8gMixcbiAgICAgIHgxMjM0ID0gKHgxMjMgKyB4MjM0KSAvIDIsXG4gICAgICB5MTIzNCA9ICh5MTIzICsgeTIzNCkgLyAyLFxuICAgICAgZHggPSB4NCAtIHgxLFxuICAgICAgZHkgPSB5NCAtIHkxLFxuICAgICAgZDIgPSBfYWJzKCh4MiAtIHg0KSAqIGR5IC0gKHkyIC0geTQpICogZHgpLFxuICAgICAgZDMgPSBfYWJzKCh4MyAtIHg0KSAqIGR5IC0gKHkzIC0geTQpICogZHgpLFxuICAgICAgbGVuZ3RoO1xuXG4gIGlmICghcG9pbnRzKSB7XG4gICAgcG9pbnRzID0gW3gxLCB5MSwgeDQsIHk0XTtcbiAgICBpbmRleCA9IDI7XG4gIH1cblxuICBwb2ludHMuc3BsaWNlKGluZGV4IHx8IHBvaW50cy5sZW5ndGggLSAyLCAwLCB4MTIzNCwgeTEyMzQpO1xuXG4gIGlmICgoZDIgKyBkMykgKiAoZDIgKyBkMykgPiB0aHJlc2hvbGQgKiAoZHggKiBkeCArIGR5ICogZHkpKSB7XG4gICAgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcbiAgICBiZXppZXJUb1BvaW50cyh4MSwgeTEsIHgxMiwgeTEyLCB4MTIzLCB5MTIzLCB4MTIzNCwgeTEyMzQsIHRocmVzaG9sZCwgcG9pbnRzLCBpbmRleCk7XG4gICAgYmV6aWVyVG9Qb2ludHMoeDEyMzQsIHkxMjM0LCB4MjM0LCB5MjM0LCB4MzQsIHkzNCwgeDQsIHk0LCB0aHJlc2hvbGQsIHBvaW50cywgaW5kZXggKyAyICsgKHBvaW50cy5sZW5ndGggLSBsZW5ndGgpKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59XG4vKlxuZnVuY3Rpb24gZ2V0QW5nbGVCZXR3ZWVuUG9pbnRzKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIpIHsgLy9hbmdsZSBiZXR3ZWVuIDMgcG9pbnRzIGluIHJhZGlhbnNcblx0dmFyIGR4MSA9IHgxIC0geDAsXG5cdFx0ZHkxID0geTEgLSB5MCxcblx0XHRkeDIgPSB4MiAtIHgxLFxuXHRcdGR5MiA9IHkyIC0geTEsXG5cdFx0ZHgzID0geDIgLSB4MCxcblx0XHRkeTMgPSB5MiAtIHkwLFxuXHRcdGEgPSBkeDEgKiBkeDEgKyBkeTEgKiBkeTEsXG5cdFx0YiA9IGR4MiAqIGR4MiArIGR5MiAqIGR5Mixcblx0XHRjID0gZHgzICogZHgzICsgZHkzICogZHkzO1xuXHRyZXR1cm4gTWF0aC5hY29zKCAoYSArIGIgLSBjKSAvIF9zcXJ0KDQgKiBhICogYikgKTtcbn0sXG4qL1xuLy9wb2ludHNUb1NlZ21lbnQoKSBkb2Vzbid0IGhhbmRsZSBmbGF0IGNvb3JkaW5hdGVzICh3aGVyZSB5IGlzIGFsd2F5cyAwKSB0aGUgd2F5IHdlIG5lZWQgKHRoZSByZXN1bHRpbmcgY29udHJvbCBwb2ludHMgYXJlIGFsd2F5cyByaWdodCBvbiB0b3Agb2YgdGhlIGFuY2hvcnMpLCBzbyB0aGlzIGZ1bmN0aW9uIGJhc2ljYWxseSBtYWtlcyB0aGUgY29udHJvbCBwb2ludHMgZ28gZGlyZWN0bHkgdXAgYW5kIGRvd24sIHZhcnlpbmcgaW4gbGVuZ3RoIGJhc2VkIG9uIHRoZSBjdXJ2aW5lc3MgKG1vcmUgY3VydnksIGZ1cnRoZXIgY29udHJvbCBwb2ludHMpXG5cbmV4cG9ydCBmdW5jdGlvbiBmbGF0UG9pbnRzVG9TZWdtZW50KHBvaW50cywgY3VydmluZXNzKSB7XG4gIGlmIChjdXJ2aW5lc3MgPT09IHZvaWQgMCkge1xuICAgIGN1cnZpbmVzcyA9IDE7XG4gIH1cblxuICB2YXIgeCA9IHBvaW50c1swXSxcbiAgICAgIHkgPSAwLFxuICAgICAgc2VnbWVudCA9IFt4LCB5XSxcbiAgICAgIGkgPSAyO1xuXG4gIGZvciAoOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgc2VnbWVudC5wdXNoKHgsIHksIHBvaW50c1tpXSwgeSA9IChwb2ludHNbaV0gLSB4KSAqIGN1cnZpbmVzcyAvIDIsIHggPSBwb2ludHNbaV0sIC15KTtcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50O1xufSAvL3BvaW50cyBpcyBhbiBhcnJheSBvZiB4L3kgcG9pbnRzLCBsaWtlIFt4LCB5LCB4LCB5LCB4LCB5XVxuXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRzVG9TZWdtZW50KHBvaW50cywgY3VydmluZXNzKSB7XG4gIC8vcG9pbnRzID0gc2ltcGxpZnlQb2ludHMocG9pbnRzLCB0b2xlcmFuY2UpO1xuICBfYWJzKHBvaW50c1swXSAtIHBvaW50c1syXSkgPCAxZS00ICYmIF9hYnMocG9pbnRzWzFdIC0gcG9pbnRzWzNdKSA8IDFlLTQgJiYgKHBvaW50cyA9IHBvaW50cy5zbGljZSgyKSk7IC8vIGlmIHRoZSBmaXJzdCB0d28gcG9pbnRzIGFyZSBzdXBlciBjbG9zZSwgZHVtcCB0aGUgZmlyc3Qgb25lLlxuXG4gIHZhciBsID0gcG9pbnRzLmxlbmd0aCAtIDIsXG4gICAgICB4ID0gK3BvaW50c1swXSxcbiAgICAgIHkgPSArcG9pbnRzWzFdLFxuICAgICAgbmV4dFggPSArcG9pbnRzWzJdLFxuICAgICAgbmV4dFkgPSArcG9pbnRzWzNdLFxuICAgICAgc2VnbWVudCA9IFt4LCB5LCB4LCB5XSxcbiAgICAgIGR4MiA9IG5leHRYIC0geCxcbiAgICAgIGR5MiA9IG5leHRZIC0geSxcbiAgICAgIGNsb3NlZCA9IE1hdGguYWJzKHBvaW50c1tsXSAtIHgpIDwgMC4wMDEgJiYgTWF0aC5hYnMocG9pbnRzW2wgKyAxXSAtIHkpIDwgMC4wMDEsXG4gICAgICBwcmV2WCxcbiAgICAgIHByZXZZLFxuICAgICAgaSxcbiAgICAgIGR4MSxcbiAgICAgIGR5MSxcbiAgICAgIHIxLFxuICAgICAgcjIsXG4gICAgICByMyxcbiAgICAgIHRsLFxuICAgICAgbXgxLFxuICAgICAgbXgyLFxuICAgICAgbXhtLFxuICAgICAgbXkxLFxuICAgICAgbXkyLFxuICAgICAgbXltO1xuXG4gIGlmIChjbG9zZWQpIHtcbiAgICAvLyBpZiB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgYXJlIGJhc2ljYWxseSBvbiB0b3Agb2YgZWFjaCBvdGhlciwgY2xvc2UgdGhlIHNlZ21lbnQgYnkgYWRkaW5nIHRoZSAybmQgcG9pbnQgdG8gdGhlIGVuZCwgYW5kIHRoZSAybmQtdG8tbGFzdCBwb2ludCB0byB0aGUgYmVnaW5uaW5nICh3ZSdsbCByZW1vdmUgdGhlbSBhdCB0aGUgZW5kLCBidXQgdGhpcyBhbGxvd3MgdGhlIGN1cnZhdHVyZSB0byBsb29rIHBlcmZlY3QpXG4gICAgcG9pbnRzLnB1c2gobmV4dFgsIG5leHRZKTtcbiAgICBuZXh0WCA9IHg7XG4gICAgbmV4dFkgPSB5O1xuICAgIHggPSBwb2ludHNbbCAtIDJdO1xuICAgIHkgPSBwb2ludHNbbCAtIDFdO1xuICAgIHBvaW50cy51bnNoaWZ0KHgsIHkpO1xuICAgIGwgKz0gNDtcbiAgfVxuXG4gIGN1cnZpbmVzcyA9IGN1cnZpbmVzcyB8fCBjdXJ2aW5lc3MgPT09IDAgPyArY3VydmluZXNzIDogMTtcblxuICBmb3IgKGkgPSAyOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgcHJldlggPSB4O1xuICAgIHByZXZZID0geTtcbiAgICB4ID0gbmV4dFg7XG4gICAgeSA9IG5leHRZO1xuICAgIG5leHRYID0gK3BvaW50c1tpICsgMl07XG4gICAgbmV4dFkgPSArcG9pbnRzW2kgKyAzXTtcblxuICAgIGlmICh4ID09PSBuZXh0WCAmJiB5ID09PSBuZXh0WSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZHgxID0gZHgyO1xuICAgIGR5MSA9IGR5MjtcbiAgICBkeDIgPSBuZXh0WCAtIHg7XG4gICAgZHkyID0gbmV4dFkgLSB5O1xuICAgIHIxID0gX3NxcnQoZHgxICogZHgxICsgZHkxICogZHkxKTsgLy8gcjEsIHIyLCBhbmQgcjMgY29ycmVsYXRlIHggYW5kIHkgKGFuZCB6IGluIHRoZSBmdXR1cmUpLiBCYXNpY2FsbHkgMkQgb3IgM0QgaHlwb3RlbnVzZVxuXG4gICAgcjIgPSBfc3FydChkeDIgKiBkeDIgKyBkeTIgKiBkeTIpO1xuICAgIHIzID0gX3NxcnQoTWF0aC5wb3coZHgyIC8gcjIgKyBkeDEgLyByMSwgMikgKyBNYXRoLnBvdyhkeTIgLyByMiArIGR5MSAvIHIxLCAyKSk7XG4gICAgdGwgPSAocjEgKyByMikgKiBjdXJ2aW5lc3MgKiAwLjI1IC8gcjM7XG4gICAgbXgxID0geCAtICh4IC0gcHJldlgpICogKHIxID8gdGwgLyByMSA6IDApO1xuICAgIG14MiA9IHggKyAobmV4dFggLSB4KSAqIChyMiA/IHRsIC8gcjIgOiAwKTtcbiAgICBteG0gPSB4IC0gKG14MSArICgobXgyIC0gbXgxKSAqIChyMSAqIDMgLyAocjEgKyByMikgKyAwLjUpIC8gNCB8fCAwKSk7XG4gICAgbXkxID0geSAtICh5IC0gcHJldlkpICogKHIxID8gdGwgLyByMSA6IDApO1xuICAgIG15MiA9IHkgKyAobmV4dFkgLSB5KSAqIChyMiA/IHRsIC8gcjIgOiAwKTtcbiAgICBteW0gPSB5IC0gKG15MSArICgobXkyIC0gbXkxKSAqIChyMSAqIDMgLyAocjEgKyByMikgKyAwLjUpIC8gNCB8fCAwKSk7XG5cbiAgICBpZiAoeCAhPT0gcHJldlggfHwgeSAhPT0gcHJldlkpIHtcbiAgICAgIHNlZ21lbnQucHVzaChfcm91bmQobXgxICsgbXhtKSwgLy8gZmlyc3QgY29udHJvbCBwb2ludFxuICAgICAgX3JvdW5kKG15MSArIG15bSksIF9yb3VuZCh4KSwgLy8gYW5jaG9yXG4gICAgICBfcm91bmQoeSksIF9yb3VuZChteDIgKyBteG0pLCAvLyBzZWNvbmQgY29udHJvbCBwb2ludFxuICAgICAgX3JvdW5kKG15MiArIG15bSkpO1xuICAgIH1cbiAgfVxuXG4gIHggIT09IG5leHRYIHx8IHkgIT09IG5leHRZIHx8IHNlZ21lbnQubGVuZ3RoIDwgNCA/IHNlZ21lbnQucHVzaChfcm91bmQobmV4dFgpLCBfcm91bmQobmV4dFkpLCBfcm91bmQobmV4dFgpLCBfcm91bmQobmV4dFkpKSA6IHNlZ21lbnQubGVuZ3RoIC09IDI7XG5cbiAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAyKSB7XG4gICAgLy8gb25seSBvbmUgcG9pbnQhXG4gICAgc2VnbWVudC5wdXNoKHgsIHksIHgsIHksIHgsIHkpO1xuICB9IGVsc2UgaWYgKGNsb3NlZCkge1xuICAgIHNlZ21lbnQuc3BsaWNlKDAsIDYpO1xuICAgIHNlZ21lbnQubGVuZ3RoID0gc2VnbWVudC5sZW5ndGggLSA2O1xuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnQ7XG59IC8vcmV0dXJucyB0aGUgc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGFuIHgveSBjb29yZGluYXRlIGFuZCBhIHNlZ21lbnQgYmV0d2VlbiB4MS95MSBhbmQgeDIveTJcblxuZnVuY3Rpb24gcG9pbnRUb1NlZ0Rpc3QoeCwgeSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgdmFyIGR4ID0geDIgLSB4MSxcbiAgICAgIGR5ID0geTIgLSB5MSxcbiAgICAgIHQ7XG5cbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgdCA9ICgoeCAtIHgxKSAqIGR4ICsgKHkgLSB5MSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgaWYgKHQgPiAxKSB7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeTEgPSB5MjtcbiAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICB4MSArPSBkeCAqIHQ7XG4gICAgICB5MSArPSBkeSAqIHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE1hdGgucG93KHggLSB4MSwgMikgKyBNYXRoLnBvdyh5IC0geTEsIDIpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGlmeVN0ZXAocG9pbnRzLCBmaXJzdCwgbGFzdCwgdG9sZXJhbmNlLCBzaW1wbGlmaWVkKSB7XG4gIHZhciBtYXhTcURpc3QgPSB0b2xlcmFuY2UsXG4gICAgICBmaXJzdFggPSBwb2ludHNbZmlyc3RdLFxuICAgICAgZmlyc3RZID0gcG9pbnRzW2ZpcnN0ICsgMV0sXG4gICAgICBsYXN0WCA9IHBvaW50c1tsYXN0XSxcbiAgICAgIGxhc3RZID0gcG9pbnRzW2xhc3QgKyAxXSxcbiAgICAgIGluZGV4LFxuICAgICAgaSxcbiAgICAgIGQ7XG5cbiAgZm9yIChpID0gZmlyc3QgKyAyOyBpIDwgbGFzdDsgaSArPSAyKSB7XG4gICAgZCA9IHBvaW50VG9TZWdEaXN0KHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSwgZmlyc3RYLCBmaXJzdFksIGxhc3RYLCBsYXN0WSk7XG5cbiAgICBpZiAoZCA+IG1heFNxRGlzdCkge1xuICAgICAgaW5kZXggPSBpO1xuICAgICAgbWF4U3FEaXN0ID0gZDtcbiAgICB9XG4gIH1cblxuICBpZiAobWF4U3FEaXN0ID4gdG9sZXJhbmNlKSB7XG4gICAgaW5kZXggLSBmaXJzdCA+IDIgJiYgc2ltcGxpZnlTdGVwKHBvaW50cywgZmlyc3QsIGluZGV4LCB0b2xlcmFuY2UsIHNpbXBsaWZpZWQpO1xuICAgIHNpbXBsaWZpZWQucHVzaChwb2ludHNbaW5kZXhdLCBwb2ludHNbaW5kZXggKyAxXSk7XG4gICAgbGFzdCAtIGluZGV4ID4gMiAmJiBzaW1wbGlmeVN0ZXAocG9pbnRzLCBpbmRleCwgbGFzdCwgdG9sZXJhbmNlLCBzaW1wbGlmaWVkKTtcbiAgfVxufSAvL3BvaW50cyBpcyBhbiBhcnJheSBvZiB4L3kgdmFsdWVzIGxpa2UgW3gsIHksIHgsIHksIHgsIHldXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsaWZ5UG9pbnRzKHBvaW50cywgdG9sZXJhbmNlKSB7XG4gIHZhciBwcmV2WCA9IHBhcnNlRmxvYXQocG9pbnRzWzBdKSxcbiAgICAgIHByZXZZID0gcGFyc2VGbG9hdChwb2ludHNbMV0pLFxuICAgICAgdGVtcCA9IFtwcmV2WCwgcHJldlldLFxuICAgICAgbCA9IHBvaW50cy5sZW5ndGggLSAyLFxuICAgICAgaSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgZHgsXG4gICAgICBkeSxcbiAgICAgIHJlc3VsdCxcbiAgICAgIGxhc3Q7XG4gIHRvbGVyYW5jZSA9IE1hdGgucG93KHRvbGVyYW5jZSB8fCAxLCAyKTtcblxuICBmb3IgKGkgPSAyOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgeCA9IHBhcnNlRmxvYXQocG9pbnRzW2ldKTtcbiAgICB5ID0gcGFyc2VGbG9hdChwb2ludHNbaSArIDFdKTtcbiAgICBkeCA9IHByZXZYIC0geDtcbiAgICBkeSA9IHByZXZZIC0geTtcblxuICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA+IHRvbGVyYW5jZSkge1xuICAgICAgdGVtcC5wdXNoKHgsIHkpO1xuICAgICAgcHJldlggPSB4O1xuICAgICAgcHJldlkgPSB5O1xuICAgIH1cbiAgfVxuXG4gIHRlbXAucHVzaChwYXJzZUZsb2F0KHBvaW50c1tsXSksIHBhcnNlRmxvYXQocG9pbnRzW2wgKyAxXSkpO1xuICBsYXN0ID0gdGVtcC5sZW5ndGggLSAyO1xuICByZXN1bHQgPSBbdGVtcFswXSwgdGVtcFsxXV07XG4gIHNpbXBsaWZ5U3RlcCh0ZW1wLCAwLCBsYXN0LCB0b2xlcmFuY2UsIHJlc3VsdCk7XG4gIHJlc3VsdC5wdXNoKHRlbXBbbGFzdF0sIHRlbXBbbGFzdCArIDFdKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xvc2VzdFByb2dyZXNzT25CZXppZXIoaXRlcmF0aW9ucywgcHgsIHB5LCBzdGFydCwgZW5kLCBzbGljZXMsIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICB2YXIgaW5jID0gKGVuZCAtIHN0YXJ0KSAvIHNsaWNlcyxcbiAgICAgIGJlc3QgPSAwLFxuICAgICAgdCA9IHN0YXJ0LFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBkLFxuICAgICAgZHgsXG4gICAgICBkeSxcbiAgICAgIGludjtcbiAgX2Jlc3REaXN0YW5jZSA9IF9sYXJnZU51bTtcblxuICB3aGlsZSAodCA8PSBlbmQpIHtcbiAgICBpbnYgPSAxIC0gdDtcbiAgICB4ID0gaW52ICogaW52ICogaW52ICogeDAgKyAzICogaW52ICogaW52ICogdCAqIHgxICsgMyAqIGludiAqIHQgKiB0ICogeDIgKyB0ICogdCAqIHQgKiB4MztcbiAgICB5ID0gaW52ICogaW52ICogaW52ICogeTAgKyAzICogaW52ICogaW52ICogdCAqIHkxICsgMyAqIGludiAqIHQgKiB0ICogeTIgKyB0ICogdCAqIHQgKiB5MztcbiAgICBkeCA9IHggLSBweDtcbiAgICBkeSA9IHkgLSBweTtcbiAgICBkID0gZHggKiBkeCArIGR5ICogZHk7XG5cbiAgICBpZiAoZCA8IF9iZXN0RGlzdGFuY2UpIHtcbiAgICAgIF9iZXN0RGlzdGFuY2UgPSBkO1xuICAgICAgYmVzdCA9IHQ7XG4gICAgfVxuXG4gICAgdCArPSBpbmM7XG4gIH1cblxuICByZXR1cm4gaXRlcmF0aW9ucyA+IDEgPyBnZXRDbG9zZXN0UHJvZ3Jlc3NPbkJlemllcihpdGVyYXRpb25zIC0gMSwgcHgsIHB5LCBNYXRoLm1heChiZXN0IC0gaW5jLCAwKSwgTWF0aC5taW4oYmVzdCArIGluYywgMSksIHNsaWNlcywgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSA6IGJlc3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbG9zZXN0RGF0YShyYXdQYXRoLCB4LCB5LCBzbGljZXMpIHtcbiAgLy9yZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBjbG9zZXN0IGosIGksIGFuZCB0IChqIGlzIHRoZSBzZWdtZW50IGluZGV4LCBpIGlzIHRoZSBpbmRleCBvZiB0aGUgcG9pbnQgaW4gdGhhdCBzZWdtZW50LCBhbmQgdCBpcyB0aGUgdGltZS9wcm9ncmVzcyBhbG9uZyB0aGF0IGJlemllcilcbiAgdmFyIGNsb3Nlc3QgPSB7XG4gICAgajogMCxcbiAgICBpOiAwLFxuICAgIHQ6IDBcbiAgfSxcbiAgICAgIGJlc3REaXN0YW5jZSA9IF9sYXJnZU51bSxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgdCxcbiAgICAgIHNlZ21lbnQ7XG5cbiAgZm9yIChqID0gMDsgaiA8IHJhd1BhdGgubGVuZ3RoOyBqKyspIHtcbiAgICBzZWdtZW50ID0gcmF3UGF0aFtqXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzZWdtZW50Lmxlbmd0aDsgaSArPSA2KSB7XG4gICAgICB0ID0gZ2V0Q2xvc2VzdFByb2dyZXNzT25CZXppZXIoMSwgeCwgeSwgMCwgMSwgc2xpY2VzIHx8IDIwLCBzZWdtZW50W2ldLCBzZWdtZW50W2kgKyAxXSwgc2VnbWVudFtpICsgMl0sIHNlZ21lbnRbaSArIDNdLCBzZWdtZW50W2kgKyA0XSwgc2VnbWVudFtpICsgNV0sIHNlZ21lbnRbaSArIDZdLCBzZWdtZW50W2kgKyA3XSk7XG5cbiAgICAgIGlmIChiZXN0RGlzdGFuY2UgPiBfYmVzdERpc3RhbmNlKSB7XG4gICAgICAgIGJlc3REaXN0YW5jZSA9IF9iZXN0RGlzdGFuY2U7XG4gICAgICAgIGNsb3Nlc3QuaiA9IGo7XG4gICAgICAgIGNsb3Nlc3QuaSA9IGk7XG4gICAgICAgIGNsb3Nlc3QudCA9IHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsb3Nlc3Q7XG59IC8vc3ViZGl2aWRlIGEgU2VnbWVudCBjbG9zZXN0IHRvIGEgc3BlY2lmaWMgeCx5IGNvb3JkaW5hdGVcblxuZXhwb3J0IGZ1bmN0aW9uIHN1YmRpdmlkZVNlZ21lbnROZWFyKHgsIHksIHNlZ21lbnQsIHNsaWNlcywgaXRlcmF0aW9ucykge1xuICB2YXIgbCA9IHNlZ21lbnQubGVuZ3RoLFxuICAgICAgYmVzdERpc3RhbmNlID0gX2xhcmdlTnVtLFxuICAgICAgYmVzdFQgPSAwLFxuICAgICAgYmVzdFNlZ21lbnRJbmRleCA9IDAsXG4gICAgICB0LFxuICAgICAgaTtcbiAgc2xpY2VzID0gc2xpY2VzIHx8IDIwO1xuICBpdGVyYXRpb25zID0gaXRlcmF0aW9ucyB8fCAzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpICs9IDYpIHtcbiAgICB0ID0gZ2V0Q2xvc2VzdFByb2dyZXNzT25CZXppZXIoMSwgeCwgeSwgMCwgMSwgc2xpY2VzLCBzZWdtZW50W2ldLCBzZWdtZW50W2kgKyAxXSwgc2VnbWVudFtpICsgMl0sIHNlZ21lbnRbaSArIDNdLCBzZWdtZW50W2kgKyA0XSwgc2VnbWVudFtpICsgNV0sIHNlZ21lbnRbaSArIDZdLCBzZWdtZW50W2kgKyA3XSk7XG5cbiAgICBpZiAoYmVzdERpc3RhbmNlID4gX2Jlc3REaXN0YW5jZSkge1xuICAgICAgYmVzdERpc3RhbmNlID0gX2Jlc3REaXN0YW5jZTtcbiAgICAgIGJlc3RUID0gdDtcbiAgICAgIGJlc3RTZWdtZW50SW5kZXggPSBpO1xuICAgIH1cbiAgfVxuXG4gIHQgPSBnZXRDbG9zZXN0UHJvZ3Jlc3NPbkJlemllcihpdGVyYXRpb25zLCB4LCB5LCBiZXN0VCAtIDAuMDUsIGJlc3RUICsgMC4wNSwgc2xpY2VzLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXhdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXggKyAxXSwgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4ICsgMl0sIHNlZ21lbnRbYmVzdFNlZ21lbnRJbmRleCArIDNdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXggKyA0XSwgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4ICsgNV0sIHNlZ21lbnRbYmVzdFNlZ21lbnRJbmRleCArIDZdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXggKyA3XSk7XG4gIHN1YmRpdmlkZVNlZ21lbnQoc2VnbWVudCwgYmVzdFNlZ21lbnRJbmRleCwgdCk7XG4gIHJldHVybiBiZXN0U2VnbWVudEluZGV4ICsgNjtcbn1cbi8qXG5UYWtlcyBhbnkgb2YgdGhlIGZvbGxvd2luZyBhbmQgY29udmVydHMgaXQgdG8gYW4gYWxsIEN1YmljIEJlemllciBTVkcgZGF0YSBzdHJpbmc6XG4tIEEgPHBhdGg+IGRhdGEgc3RyaW5nIGxpa2UgXCJNMCwwIEwyLDQgdjIwLDE1IEgxMDBcIlxuLSBBIFJhd1BhdGgsIGxpa2UgW1t4LCB5LCB4LCB5LCB4LCB5LCB4LCB5XVtbeCwgeSwgeCwgeSwgeCwgeSwgeCwgeV1dXG4tIEEgU2VnbWVudCwgbGlrZSBbeCwgeSwgeCwgeSwgeCwgeSwgeCwgeV1cblxuTm90ZTogYWxsIG51bWJlcnMgYXJlIHJvdW5kZWQgZG93biB0byB0aGUgY2xvc2VzdCAwLjAwMSB0byBtaW5pbWl6ZSBtZW1vcnksIG1heGltaXplIHNwZWVkLCBhbmQgYXZvaWQgb2RkIG51bWJlcnMgbGlrZSAxZS0xM1xuKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhd1BhdGhUb1N0cmluZyhyYXdQYXRoKSB7XG4gIGlmIChfaXNOdW1iZXIocmF3UGF0aFswXSkpIHtcbiAgICAvL2luIGNhc2UgYSBzZWdtZW50IGlzIHBhc3NlZCBpbiBpbnN0ZWFkXG4gICAgcmF3UGF0aCA9IFtyYXdQYXRoXTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBcIlwiLFxuICAgICAgbCA9IHJhd1BhdGgubGVuZ3RoLFxuICAgICAgc2wsXG4gICAgICBzLFxuICAgICAgaSxcbiAgICAgIHNlZ21lbnQ7XG5cbiAgZm9yIChzID0gMDsgcyA8IGw7IHMrKykge1xuICAgIHNlZ21lbnQgPSByYXdQYXRoW3NdO1xuICAgIHJlc3VsdCArPSBcIk1cIiArIF9yb3VuZChzZWdtZW50WzBdKSArIFwiLFwiICsgX3JvdW5kKHNlZ21lbnRbMV0pICsgXCIgQ1wiO1xuICAgIHNsID0gc2VnbWVudC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAyOyBpIDwgc2w7IGkrKykge1xuICAgICAgcmVzdWx0ICs9IF9yb3VuZChzZWdtZW50W2krK10pICsgXCIsXCIgKyBfcm91bmQoc2VnbWVudFtpKytdKSArIFwiIFwiICsgX3JvdW5kKHNlZ21lbnRbaSsrXSkgKyBcIixcIiArIF9yb3VuZChzZWdtZW50W2krK10pICsgXCIgXCIgKyBfcm91bmQoc2VnbWVudFtpKytdKSArIFwiLFwiICsgX3JvdW5kKHNlZ21lbnRbaV0pICsgXCIgXCI7XG4gICAgfVxuXG4gICAgaWYgKHNlZ21lbnQuY2xvc2VkKSB7XG4gICAgICByZXN1bHQgKz0gXCJ6XCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qXG4vLyB0YWtlcyBhIHNlZ21lbnQgd2l0aCBjb29yZGluYXRlcyBbeCwgeSwgeCwgeSwgLi4uXSBhbmQgY29udmVydHMgdGhlIGNvbnRyb2wgcG9pbnRzIGludG8gYW5nbGVzIGFuZCBsZW5ndGhzIFt4LCB5LCBhbmdsZSwgbGVuZ3RoLCBhbmdsZSwgbGVuZ3RoLCB4LCB5LCBhbmdsZSwgbGVuZ3RoLCAuLi5dIHNvIHRoYXQgaXQgYW5pbWF0ZXMgbW9yZSBjbGVhbmx5IGFuZCBhdm9pZHMgb2RkIGJyZWFrcy9raW5rcy4gRm9yIGV4YW1wbGUsIGlmIHlvdSBhbmltYXRlIGZyb20gMSBvJ2Nsb2NrIHRvIDYgbydjbG9jaywgaXQnZCBqdXN0IGdvIGRpcmVjdGx5L2xpbmVhcmx5IHJhdGhlciB0aGFuIGFyb3VuZC4gU28gdGhlIGxlbmd0aCB3b3VsZCBiZSB2ZXJ5IHNob3J0IGluIHRoZSBtaWRkbGUgb2YgdGhlIHR3ZWVuLlxuZXhwb3J0IGZ1bmN0aW9uIGNwQ29vcmRzVG9BbmdsZXMoc2VnbWVudCwgY29weSkge1xuXHR2YXIgcmVzdWx0ID0gY29weSA/IHNlZ21lbnQuc2xpY2UoMCkgOiBzZWdtZW50LFxuXHRcdHgsIHksIGk7XG5cdGZvciAoaSA9IDA7IGkgPCBzZWdtZW50Lmxlbmd0aDsgaSs9Nikge1xuXHRcdHggPSBzZWdtZW50W2krMl0gLSBzZWdtZW50W2ldO1xuXHRcdHkgPSBzZWdtZW50W2krM10gLSBzZWdtZW50W2krMV07XG5cdFx0cmVzdWx0W2krMl0gPSBNYXRoLmF0YW4yKHksIHgpO1xuXHRcdHJlc3VsdFtpKzNdID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdHggPSBzZWdtZW50W2krNl0gLSBzZWdtZW50W2krNF07XG5cdFx0eSA9IHNlZ21lbnRbaSs3XSAtIHNlZ21lbnRbaSs1XTtcblx0XHRyZXN1bHRbaSs0XSA9IE1hdGguYXRhbjIoeSwgeCk7XG5cdFx0cmVzdWx0W2krNV0gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gdGFrZXMgYSBzZWdtZW50IHRoYXQgd2FzIGNvbnZlcnRlZCB3aXRoIGNwQ29vcmRzVG9BbmdsZXMoKSB0byBoYXZlIGFuZ2xlcyBhbmQgbGVuZ3RocyBpbnN0ZWFkIG9mIGNvb3JkaW5hdGVzIGZvciB0aGUgY29udHJvbCBwb2ludHMsIGFuZCBjb252ZXJ0cyBpdCBCQUNLIGludG8gY29vcmRpbmF0ZXMuXG5leHBvcnQgZnVuY3Rpb24gY3BBbmdsZXNUb0Nvb3JkcyhzZWdtZW50LCBjb3B5KSB7XG5cdHZhciByZXN1bHQgPSBjb3B5ID8gc2VnbWVudC5zbGljZSgwKSA6IHNlZ21lbnQsXG5cdFx0bGVuZ3RoID0gc2VnbWVudC5sZW5ndGgsXG5cdFx0cm5kID0gMTAwMCxcblx0XHRhbmdsZSwgbCwgaSwgajtcblx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSs9Nikge1xuXHRcdGFuZ2xlID0gc2VnbWVudFtpKzJdO1xuXHRcdGwgPSBzZWdtZW50W2krM107IC8vbGVuZ3RoXG5cdFx0cmVzdWx0W2krMl0gPSAoKChzZWdtZW50W2ldICsgTWF0aC5jb3MoYW5nbGUpICogbCkgKiBybmQpIHwgMCkgLyBybmQ7XG5cdFx0cmVzdWx0W2krM10gPSAoKChzZWdtZW50W2krMV0gKyBNYXRoLnNpbihhbmdsZSkgKiBsKSAqIHJuZCkgfCAwKSAvIHJuZDtcblx0XHRhbmdsZSA9IHNlZ21lbnRbaSs0XTtcblx0XHRsID0gc2VnbWVudFtpKzVdOyAvL2xlbmd0aFxuXHRcdHJlc3VsdFtpKzRdID0gKCgoc2VnbWVudFtpKzZdIC0gTWF0aC5jb3MoYW5nbGUpICogbCkgKiBybmQpIHwgMCkgLyBybmQ7XG5cdFx0cmVzdWx0W2krNV0gPSAoKChzZWdtZW50W2krN10gLSBNYXRoLnNpbihhbmdsZSkgKiBsKSAqIHJuZCkgfCAwKSAvIHJuZDtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vL2FkZHMgYW4gXCJpc1Ntb290aFwiIGFycmF5IHRvIGVhY2ggc2VnbWVudCBhbmQgcG9wdWxhdGVzIGl0IHdpdGggYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgaXQncyBzbW9vdGggKHRoZSBjb250cm9sIHBvaW50cyBoYXZlIGJhc2ljYWxseSB0aGUgc2FtZSBzbG9wZSkuIEZvciBhbnkgc21vb3RoIGNvbnRyb2wgcG9pbnRzLCBpdCBjb252ZXJ0cyB0aGUgY29vcmRpbmF0ZXMgaW50byBhbmdsZSAoeCwgaW4gcmFkaWFucykgYW5kIGxlbmd0aCAoeSkgYW5kIHB1dHMgdGhlbSBpbnRvIHRoZSBzYW1lIGluZGV4IHZhbHVlIGluIGEgc21vb3RoRGF0YSBhcnJheS5cbmV4cG9ydCBmdW5jdGlvbiBwb3B1bGF0ZVNtb290aERhdGEocmF3UGF0aCkge1xuXHRsZXQgaiA9IHJhd1BhdGgubGVuZ3RoLFxuXHRcdHNtb290aCwgc2VnbWVudCwgeCwgeSwgeDIsIHkyLCBpLCBsLCBhLCBhMiwgaXNTbW9vdGgsIHNtb290aERhdGE7XG5cdHdoaWxlICgtLWogPiAtMSkge1xuXHRcdHNlZ21lbnQgPSByYXdQYXRoW2pdO1xuXHRcdGlzU21vb3RoID0gc2VnbWVudC5pc1Ntb290aCA9IHNlZ21lbnQuaXNTbW9vdGggfHwgWzAsIDAsIDAsIDBdO1xuXHRcdHNtb290aERhdGEgPSBzZWdtZW50LnNtb290aERhdGEgPSBzZWdtZW50LnNtb290aERhdGEgfHwgWzAsIDAsIDAsIDBdO1xuXHRcdGlzU21vb3RoLmxlbmd0aCA9IDQ7XG5cdFx0bCA9IHNlZ21lbnQubGVuZ3RoIC0gMjtcblx0XHRmb3IgKGkgPSA2OyBpIDwgbDsgaSArPSA2KSB7XG5cdFx0XHR4ID0gc2VnbWVudFtpXSAtIHNlZ21lbnRbaSAtIDJdO1xuXHRcdFx0eSA9IHNlZ21lbnRbaSArIDFdIC0gc2VnbWVudFtpIC0gMV07XG5cdFx0XHR4MiA9IHNlZ21lbnRbaSArIDJdIC0gc2VnbWVudFtpXTtcblx0XHRcdHkyID0gc2VnbWVudFtpICsgM10gLSBzZWdtZW50W2kgKyAxXTtcblx0XHRcdGEgPSBfYXRhbjIoeSwgeCk7XG5cdFx0XHRhMiA9IF9hdGFuMih5MiwgeDIpO1xuXHRcdFx0c21vb3RoID0gKE1hdGguYWJzKGEgLSBhMikgPCAwLjA5KTtcblx0XHRcdGlmIChzbW9vdGgpIHtcblx0XHRcdFx0c21vb3RoRGF0YVtpIC0gMl0gPSBhO1xuXHRcdFx0XHRzbW9vdGhEYXRhW2kgKyAyXSA9IGEyO1xuXHRcdFx0XHRzbW9vdGhEYXRhW2kgLSAxXSA9IF9zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdFx0XHRzbW9vdGhEYXRhW2kgKyAzXSA9IF9zcXJ0KHgyICogeDIgKyB5MiAqIHkyKTtcblx0XHRcdH1cblx0XHRcdGlzU21vb3RoLnB1c2goc21vb3RoLCBzbW9vdGgsIDAsIDAsIHNtb290aCwgc21vb3RoKTtcblx0XHR9XG5cdFx0Ly9pZiB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnRzIGFyZSBpZGVudGljYWwsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgc21vb3RoIHRyYW5zaXRpb24uIFdlIG11c3QgaGFuZGxlIHRoaXMgYSBiaXQgZGlmZmVyZW50bHkgZHVlIHRvIHRoZWlyIHBvc2l0aW9ucyBpbiB0aGUgYXJyYXkuXG5cdFx0aWYgKHNlZ21lbnRbbF0gPT09IHNlZ21lbnRbMF0gJiYgc2VnbWVudFtsKzFdID09PSBzZWdtZW50WzFdKSB7XG5cdFx0XHR4ID0gc2VnbWVudFswXSAtIHNlZ21lbnRbbC0yXTtcblx0XHRcdHkgPSBzZWdtZW50WzFdIC0gc2VnbWVudFtsLTFdO1xuXHRcdFx0eDIgPSBzZWdtZW50WzJdIC0gc2VnbWVudFswXTtcblx0XHRcdHkyID0gc2VnbWVudFszXSAtIHNlZ21lbnRbMV07XG5cdFx0XHRhID0gX2F0YW4yKHksIHgpO1xuXHRcdFx0YTIgPSBfYXRhbjIoeTIsIHgyKTtcblx0XHRcdGlmIChNYXRoLmFicyhhIC0gYTIpIDwgMC4wOSkge1xuXHRcdFx0XHRzbW9vdGhEYXRhW2wtMl0gPSBhO1xuXHRcdFx0XHRzbW9vdGhEYXRhWzJdID0gYTI7XG5cdFx0XHRcdHNtb290aERhdGFbbC0xXSA9IF9zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdFx0XHRzbW9vdGhEYXRhWzNdID0gX3NxcnQoeDIgKiB4MiArIHkyICogeTIpO1xuXHRcdFx0XHRpc1Ntb290aFtsLTJdID0gaXNTbW9vdGhbbC0xXSA9IHRydWU7IC8vZG9uJ3QgY2hhbmdlIGluZGV4ZXMgMiBhbmQgMyBiZWNhdXNlIHdlJ2xsIHRyaWdnZXIgZXZlcnl0aGluZyBmcm9tIHRoZSBFTkQsIGFuZCB0aGlzIHdpbGwgb3B0aW1pemUgZmlsZSBzaXplIGEgYml0LlxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmF3UGF0aDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb2ludFRvU2NyZWVuKHN2Z0VsZW1lbnQsIHBvaW50KSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgeyAvL2J5IGRlZmF1bHQsIHRha2UgdGhlIGZpcnN0IHNldCBvZiBjb29yZGluYXRlcyBpbiB0aGUgcGF0aCBhcyB0aGUgcG9pbnRcblx0XHRsZXQgcmF3UGF0aCA9IGdldFJhd1BhdGgoc3ZnRWxlbWVudCk7XG5cdFx0cG9pbnQgPSBzdmdFbGVtZW50Lm93bmVyU1ZHRWxlbWVudC5jcmVhdGVTVkdQb2ludCgpO1xuXHRcdHBvaW50LnggPSByYXdQYXRoWzBdWzBdO1xuXHRcdHBvaW50LnkgPSByYXdQYXRoWzBdWzFdO1xuXHR9XG5cdHJldHVybiBwb2ludC5tYXRyaXhUcmFuc2Zvcm0oc3ZnRWxlbWVudC5nZXRTY3JlZW5DVE0oKSk7XG59XG5cbiovIl0sIm5hbWVzIjpbIl9zdmdQYXRoRXhwIiwiX251bWJlcnNFeHAiLCJfc2NpZW50aWZpYyIsIl9zZWxlY3RvckV4cCIsIl9ERUcyUkFEIiwiTWF0aCIsIlBJIiwiX1JBRDJERUciLCJfc2luIiwic2luIiwiX2NvcyIsImNvcyIsIl9hYnMiLCJhYnMiLCJfc3FydCIsInNxcnQiLCJfYXRhbjIiLCJhdGFuMiIsIl9sYXJnZU51bSIsIl9pc1N0cmluZyIsInZhbHVlIiwiX2lzTnVtYmVyIiwiX2lzVW5kZWZpbmVkIiwiX3RlbXAiLCJfdGVtcDIiLCJfcm91bmRpbmdOdW0iLCJfd3JhcFByb2dyZXNzIiwicHJvZ3Jlc3MiLCJyb3VuZCIsIl9yb3VuZCIsIl9yb3VuZFByZWNpc2UiLCJfc3BsaXRTZWdtZW50IiwicmF3UGF0aCIsInNlZ0luZGV4IiwiaSIsInQiLCJzZWdtZW50Iiwic2hpZnQiLCJzdWJkaXZpZGVTZWdtZW50IiwibGVuZ3RoIiwic3BsaWNlIiwic2xpY2UiLCJfZ2V0U2FtcGxlSW5kZXgiLCJzYW1wbGVzIiwibCIsIl9yZXZlcnNlUmF3UGF0aCIsInNraXBPdXRlciIsInJldmVyc2UiLCJyZXZlcnNlZCIsInJldmVyc2VTZWdtZW50IiwiX2NvcHlNZXRhRGF0YSIsInNvdXJjZSIsImNvcHkiLCJ0b3RhbExlbmd0aCIsImxvb2t1cCIsIm1pbkxlbmd0aCIsInJlc29sdXRpb24iLCJ0b3RhbFBvaW50cyIsIl9hcHBlbmRPck1lcmdlIiwiaW5kZXgiLCJwcmV2U2VnIiwiY29uY2F0IiwiX2Jlc3REaXN0YW5jZSIsImdldFJhd1BhdGgiLCJ0ZXN0IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiZSIsImdldEF0dHJpYnV0ZSIsIl9nc1BhdGgiLCJfZGlydHkiLCJzdHJpbmdUb1Jhd1BhdGgiLCJjb25zb2xlIiwid2FybiIsImNvcHlSYXdQYXRoIiwiYSIsInkiLCJfY3JlYXRlUGF0aCIsImlnbm9yZSIsInBhdGgiLCJjcmVhdGVFbGVtZW50TlMiLCJhdHRyIiwiY2FsbCIsImF0dHJpYnV0ZXMiLCJuYW1lIiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImluZGV4T2YiLCJzZXRBdHRyaWJ1dGVOUyIsIm5vZGVWYWx1ZSIsIl90eXBlQXR0cnMiLCJyZWN0IiwiY2lyY2xlIiwiZWxsaXBzZSIsImxpbmUiLCJfYXR0clRvT2JqIiwiYXR0cnMiLCJwcm9wcyIsInNwbGl0Iiwib2JqIiwiY29udmVydFRvUGF0aCIsImVsZW1lbnQiLCJzd2FwIiwidHlwZSIsInRhZ05hbWUiLCJjaXJjIiwiZGF0YSIsIngiLCJyIiwicnkiLCJyY2lyYyIsInJ5Y2lyYyIsInBvaW50cyIsInciLCJoIiwieDIiLCJ4MyIsIng0IiwieDUiLCJ4NiIsInkyIiwieTMiLCJ5NCIsInk1IiwieTYiLCJnZXRCQm94IiwicngiLCJ3aWR0aCIsImhlaWdodCIsImpvaW4iLCJjeCIsImN5IiwieDEiLCJ5MSIsIm1hdGNoIiwic2V0QXR0cmlidXRlIiwicmF3UGF0aFRvU3RyaW5nIiwiX2dzUmF3UGF0aCIsInBhcmVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJyZW1vdmVDaGlsZCIsImdldFJvdGF0aW9uQXRQcm9ncmVzcyIsImQiLCJnZXRQcm9ncmVzc0RhdGEiLCJnZXRSb3RhdGlvbkF0QmV6aWVyVCIsImIiLCJjIiwic2xpY2VSYXdQYXRoIiwic3RhcnQiLCJlbmQiLCJsb29wcyIsIm1heCIsIm9mZnNldCIsIm1pbiIsImNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyIsIndyYXAiLCJzIiwiZVNlZyIsInNTZWciLCJlU2VnSW5kZXgiLCJzU2VnSW5kZXgiLCJlaSIsInNpIiwic2FtZVNlZ21lbnQiLCJzYW1lQmV6aWVyIiwid3JhcHNCZWhpbmQiLCJzU2hpZnQiLCJlU2hpZnQiLCJ0b3RhbFNlZ21lbnRzIiwiaiIsImFuZ2xlIiwicHVzaCIsIm1lYXN1cmVTZWdtZW50Iiwic3RhcnRJbmRleCIsImJlemllclF0eSIsImluYyIsImVuZEluZGV4Iiwic2FtcGxlc0luZGV4IiwicHJldkxlbmd0aCIsInhkIiwieGQxIiwieWQiLCJ5ZDEiLCJpbnYiLCJsZW5ndGhJbmRleCIsInNlZ0xlbmd0aCIsInBhdGhMZW5ndGgiLCJheCIsImF5IiwiY3AxeCIsImNwMXkiLCJjcDJ4IiwiY3AyeSIsImJ4IiwiYnkiLCJ4MWEiLCJ5MWEiLCJ4MmEiLCJ5MmEiLCJkZWNvcmF0ZWUiLCJwdXNoVG9OZXh0SWZBdEVuZCIsImdldFBvc2l0aW9uT25QYXRoIiwiaW5jbHVkZUFuZ2xlIiwicG9pbnQiLCJyZXN1bHQiLCJ0cmFuc2Zvcm1SYXdQYXRoIiwidHgiLCJ0eSIsImFyY1RvU2VnbWVudCIsImxhc3RYIiwibGFzdFkiLCJsYXJnZUFyY0ZsYWciLCJzd2VlcEZsYWciLCJhbmdsZVJhZCIsImNvc0FuZ2xlIiwic2luQW5nbGUiLCJUV09QSSIsImR4MiIsImR5MiIsIngxX3NxIiwieTFfc3EiLCJyYWRpaUNoZWNrIiwicnhfc3EiLCJyeV9zcSIsInNxIiwiY29lZiIsImN4MSIsImN5MSIsInN4MiIsInN5MiIsInV4IiwidXkiLCJ2eCIsInZ5IiwidGVtcCIsImFuZ2xlU3RhcnQiLCJhY29zIiwiYW5nbGVFeHRlbnQiLCJpc05hTiIsInNlZ21lbnRzIiwiY2VpbCIsImFuZ2xlSW5jcmVtZW50IiwiY29udHJvbExlbmd0aCIsIm1hIiwibWIiLCJtYyIsIm1kIiwicmVwbGFjZSIsIm0iLCJuIiwicmVsYXRpdmVYIiwicmVsYXRpdmVZIiwidHdvVGhpcmRzIiwiZWxlbWVudHMiLCJlcnJvck1lc3NhZ2UiLCJjb21tYW5kIiwiaXNSZWxhdGl2ZSIsInN0YXJ0WCIsInN0YXJ0WSIsImRpZlgiLCJkaWZZIiwiYmV6aWVycyIsInByZXZDb21tYW5kIiwiZmxhZzEiLCJmbGFnMiIsInN4Iiwic3kiLCJleCIsImV5IiwibG9nIiwidG9VcHBlckNhc2UiLCJjbG9zZWQiLCJzdWJzdHIiLCJjaGFyQXQiLCJwb3AiLCJiZXppZXJUb1BvaW50cyIsInRocmVzaG9sZCIsIngxMiIsInkxMiIsIngyMyIsInkyMyIsIngzNCIsInkzNCIsIngxMjMiLCJ5MTIzIiwieDIzNCIsInkyMzQiLCJ4MTIzNCIsInkxMjM0IiwiZHgiLCJkeSIsImQyIiwiZDMiLCJmbGF0UG9pbnRzVG9TZWdtZW50IiwiY3VydmluZXNzIiwicG9pbnRzVG9TZWdtZW50IiwibmV4dFgiLCJuZXh0WSIsInByZXZYIiwicHJldlkiLCJkeDEiLCJkeTEiLCJyMSIsInIyIiwicjMiLCJ0bCIsIm14MSIsIm14MiIsIm14bSIsIm15MSIsIm15MiIsIm15bSIsInVuc2hpZnQiLCJwb3ciLCJwb2ludFRvU2VnRGlzdCIsInNpbXBsaWZ5U3RlcCIsImZpcnN0IiwibGFzdCIsInRvbGVyYW5jZSIsInNpbXBsaWZpZWQiLCJtYXhTcURpc3QiLCJmaXJzdFgiLCJmaXJzdFkiLCJzaW1wbGlmeVBvaW50cyIsInBhcnNlRmxvYXQiLCJnZXRDbG9zZXN0UHJvZ3Jlc3NPbkJlemllciIsIml0ZXJhdGlvbnMiLCJweCIsInB5Iiwic2xpY2VzIiwieDAiLCJ5MCIsImJlc3QiLCJnZXRDbG9zZXN0RGF0YSIsImNsb3Nlc3QiLCJiZXN0RGlzdGFuY2UiLCJzdWJkaXZpZGVTZWdtZW50TmVhciIsImJlc3RUIiwiYmVzdFNlZ21lbnRJbmRleCIsInNsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/paths.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/strings.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/strings.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   emojiExp: function() { return /* binding */ emojiExp; },\n/* harmony export */   emojiSafeSplit: function() { return /* binding */ emojiSafeSplit; },\n/* harmony export */   getText: function() { return /* binding */ getText; },\n/* harmony export */   splitInnerHTML: function() { return /* binding */ splitInnerHTML; }\n/* harmony export */ });\n/*!\n * strings: 3.12.5\n * https://gsap.com\n *\n * Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var _trimExp = /(?:^\\s+|\\s+$)/g;\nvar emojiExp = /([\\uD800-\\uDBFF][\\uDC00-\\uDFFF](?:[\\u200D\\uFE0F][\\uD800-\\uDBFF][\\uDC00-\\uDFFF]){2,}|\\uD83D\\uDC69(?:\\u200D(?:(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC67|(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC66)|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]\\uFE0F|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC6F\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3C-\\uDD3E\\uDDD6-\\uDDDF])\\u200D[\\u2640\\u2642]\\uFE0F|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642])\\uFE0F|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\uD83D\\uDC69\\u200D[\\u2695\\u2696\\u2708]|\\uD83D\\uDC68(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708]))\\uFE0F|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83D\\uDC69\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69]))|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67)\\uDB40\\uDC7F|\\uD83D\\uDC68(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92])|(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]))|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDD1-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\u200D(?:(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC67|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC66)|\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC69\\uDC6E\\uDC70-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3D\\uDD3E\\uDDD1-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])?|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDEEB\\uDEEC\\uDEF4-\\uDEF8]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD4C\\uDD50-\\uDD6B\\uDD80-\\uDD97\\uDDC0\\uDDD0-\\uDDE6])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEF8]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD4C\\uDD50-\\uDD6B\\uDD80-\\uDD97\\uDDC0\\uDDD0-\\uDDE6])\\uFE0F)/;\nfunction getText(e) {\n    var type = e.nodeType, result = \"\";\n    if (type === 1 || type === 9 || type === 11) {\n        if (typeof e.textContent === \"string\") {\n            return e.textContent;\n        } else {\n            for(e = e.firstChild; e; e = e.nextSibling){\n                result += getText(e);\n            }\n        }\n    } else if (type === 3 || type === 4) {\n        return e.nodeValue;\n    }\n    return result;\n}\nfunction splitInnerHTML(element, delimiter, trim, preserveSpaces) {\n    var node = element.firstChild, result = [], s;\n    while(node){\n        if (node.nodeType === 3) {\n            s = (node.nodeValue + \"\").replace(/^\\n+/g, \"\");\n            if (!preserveSpaces) {\n                s = s.replace(/\\s+/g, \" \");\n            }\n            result.push.apply(result, emojiSafeSplit(s, delimiter, trim, preserveSpaces));\n        } else if ((node.nodeName + \"\").toLowerCase() === \"br\") {\n            result[result.length - 1] += \"<br>\";\n        } else {\n            result.push(node.outerHTML);\n        }\n        node = node.nextSibling;\n    }\n    s = result.length;\n    while(s--){\n        result[s] === \"&\" && result.splice(s, 1, \"&amp;\");\n    }\n    return result;\n}\n/*\n//smaller kb version that only handles the simpler emoji's, which is often perfectly adequate.\n\nlet _emoji = \"[\\uE000-\\uF8FF]|\\uD83C[\\uDC00-\\uDFFF]|\\uD83D[\\uDC00-\\uDFFF]|[\\u2694-\\u2697]|\\uD83E[\\uDD10-\\uDD5D]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]\",\n\t_emojiExp = new RegExp(_emoji),\n\t_emojiAndCharsExp = new RegExp(_emoji + \"|.\", \"g\"),\n\t_emojiSafeSplit = (text, delimiter, trim) => {\n\t\tif (trim) {\n\t\t\ttext = text.replace(_trimExp, \"\");\n\t\t}\n\t\treturn ((delimiter === \"\" || !delimiter) && _emojiExp.test(text)) ? text.match(_emojiAndCharsExp) : text.split(delimiter || \"\");\n\t};\n */ function emojiSafeSplit(text, delimiter, trim, preserveSpaces) {\n    text += \"\"; // make sure it's cast as a string. Someone may pass in a number.\n    trim && (text = text.trim ? text.trim() : text.replace(_trimExp, \"\")); // IE9 and earlier compatibility\n    if (delimiter && delimiter !== \"\") {\n        return text.replace(/>/g, \"&gt;\").replace(/</g, \"&lt;\").split(delimiter);\n    }\n    var result = [], l = text.length, i = 0, j, character;\n    for(; i < l; i++){\n        character = text.charAt(i);\n        if (character.charCodeAt(0) >= 0xD800 && character.charCodeAt(0) <= 0xDBFF || text.charCodeAt(i + 1) >= 0xFE00 && text.charCodeAt(i + 1) <= 0xFE0F) {\n            //special emoji characters use 2 or 4 unicode characters that we must keep together.\n            j = ((text.substr(i, 12).split(emojiExp) || [])[1] || \"\").length || 2;\n            character = text.substr(i, j);\n            result.emoji = 1;\n            i += j - 1;\n        }\n        result.push(character === \">\" ? \"&gt;\" : character === \"<\" ? \"&lt;\" : preserveSpaces && character === \" \" && (text.charAt(i - 1) === \" \" || text.charAt(i + 1) === \" \") ? \"&nbsp;\" : character);\n    }\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC91dGlscy9zdHJpbmdzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFRQSxHQUVBLGtCQUFrQixHQUNsQixJQUFJQSxXQUFXO0FBQ1IsSUFBSUMsV0FBVyw0Z09BQTRnTztBQUMzaE8sU0FBU0MsUUFBUUMsQ0FBQztJQUN2QixJQUFJQyxPQUFPRCxFQUFFRSxRQUFRLEVBQ2pCQyxTQUFTO0lBRWIsSUFBSUYsU0FBUyxLQUFLQSxTQUFTLEtBQUtBLFNBQVMsSUFBSTtRQUMzQyxJQUFJLE9BQU9ELEVBQUVJLFdBQVcsS0FBSyxVQUFVO1lBQ3JDLE9BQU9KLEVBQUVJLFdBQVc7UUFDdEIsT0FBTztZQUNMLElBQUtKLElBQUlBLEVBQUVLLFVBQVUsRUFBRUwsR0FBR0EsSUFBSUEsRUFBRU0sV0FBVyxDQUFFO2dCQUMzQ0gsVUFBVUosUUFBUUM7WUFDcEI7UUFDRjtJQUNGLE9BQU8sSUFBSUMsU0FBUyxLQUFLQSxTQUFTLEdBQUc7UUFDbkMsT0FBT0QsRUFBRU8sU0FBUztJQUNwQjtJQUVBLE9BQU9KO0FBQ1Q7QUFDTyxTQUFTSyxlQUFlQyxPQUFPLEVBQUVDLFNBQVMsRUFBRUMsSUFBSSxFQUFFQyxjQUFjO0lBQ3JFLElBQUlDLE9BQU9KLFFBQVFKLFVBQVUsRUFDekJGLFNBQVMsRUFBRSxFQUNYVztJQUVKLE1BQU9ELEtBQU07UUFDWCxJQUFJQSxLQUFLWCxRQUFRLEtBQUssR0FBRztZQUN2QlksSUFBSSxDQUFDRCxLQUFLTixTQUFTLEdBQUcsRUFBQyxFQUFHUSxPQUFPLENBQUMsU0FBUztZQUUzQyxJQUFJLENBQUNILGdCQUFnQjtnQkFDbkJFLElBQUlBLEVBQUVDLE9BQU8sQ0FBQyxRQUFRO1lBQ3hCO1lBRUFaLE9BQU9hLElBQUksQ0FBQ0MsS0FBSyxDQUFDZCxRQUFRZSxlQUFlSixHQUFHSixXQUFXQyxNQUFNQztRQUMvRCxPQUFPLElBQUksQ0FBQ0MsS0FBS00sUUFBUSxHQUFHLEVBQUMsRUFBR0MsV0FBVyxPQUFPLE1BQU07WUFDdERqQixNQUFNLENBQUNBLE9BQU9rQixNQUFNLEdBQUcsRUFBRSxJQUFJO1FBQy9CLE9BQU87WUFDTGxCLE9BQU9hLElBQUksQ0FBQ0gsS0FBS1MsU0FBUztRQUM1QjtRQUVBVCxPQUFPQSxLQUFLUCxXQUFXO0lBQ3pCO0lBRUFRLElBQUlYLE9BQU9rQixNQUFNO0lBRWpCLE1BQU9QLElBQUs7UUFDVlgsTUFBTSxDQUFDVyxFQUFFLEtBQUssT0FBT1gsT0FBT29CLE1BQU0sQ0FBQ1QsR0FBRyxHQUFHO0lBQzNDO0lBRUEsT0FBT1g7QUFDVDtBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUVNLFNBQVNlLGVBQWVNLElBQUksRUFBRWQsU0FBUyxFQUFFQyxJQUFJLEVBQUVDLGNBQWM7SUFDbEVZLFFBQVEsSUFBSSxpRUFBaUU7SUFFN0ViLFFBQVNhLENBQUFBLE9BQU9BLEtBQUtiLElBQUksR0FBR2EsS0FBS2IsSUFBSSxLQUFLYSxLQUFLVCxPQUFPLENBQUNsQixVQUFVLEdBQUUsR0FBSSxnQ0FBZ0M7SUFFdkcsSUFBSWEsYUFBYUEsY0FBYyxJQUFJO1FBQ2pDLE9BQU9jLEtBQUtULE9BQU8sQ0FBQyxNQUFNLFFBQVFBLE9BQU8sQ0FBQyxNQUFNLFFBQVFVLEtBQUssQ0FBQ2Y7SUFDaEU7SUFFQSxJQUFJUCxTQUFTLEVBQUUsRUFDWHVCLElBQUlGLEtBQUtILE1BQU0sRUFDZk0sSUFBSSxHQUNKQyxHQUNBQztJQUVKLE1BQU9GLElBQUlELEdBQUdDLElBQUs7UUFDakJFLFlBQVlMLEtBQUtNLE1BQU0sQ0FBQ0g7UUFFeEIsSUFBSUUsVUFBVUUsVUFBVSxDQUFDLE1BQU0sVUFBVUYsVUFBVUUsVUFBVSxDQUFDLE1BQU0sVUFBVVAsS0FBS08sVUFBVSxDQUFDSixJQUFJLE1BQU0sVUFBVUgsS0FBS08sVUFBVSxDQUFDSixJQUFJLE1BQU0sUUFBUTtZQUNsSixvRkFBb0Y7WUFDcEZDLElBQUksQ0FBQyxDQUFDSixLQUFLUSxNQUFNLENBQUNMLEdBQUcsSUFBSUYsS0FBSyxDQUFDM0IsYUFBYSxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBQyxFQUFHdUIsTUFBTSxJQUFJO1lBQ3BFUSxZQUFZTCxLQUFLUSxNQUFNLENBQUNMLEdBQUdDO1lBQzNCekIsT0FBTzhCLEtBQUssR0FBRztZQUNmTixLQUFLQyxJQUFJO1FBQ1g7UUFFQXpCLE9BQU9hLElBQUksQ0FBQ2EsY0FBYyxNQUFNLFNBQVNBLGNBQWMsTUFBTSxTQUFTakIsa0JBQWtCaUIsY0FBYyxPQUFRTCxDQUFBQSxLQUFLTSxNQUFNLENBQUNILElBQUksT0FBTyxPQUFPSCxLQUFLTSxNQUFNLENBQUNILElBQUksT0FBTyxHQUFFLElBQUssV0FBV0U7SUFDdkw7SUFFQSxPQUFPMUI7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vZ3NhcEAzLjEyLjUvbm9kZV9tb2R1bGVzL2dzYXAvdXRpbHMvc3RyaW5ncy5qcz8wNzIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogc3RyaW5nczogMy4xMi41XG4gKiBodHRwczovL2dzYXAuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyNCwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9nc2FwLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHU0FQIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIF90cmltRXhwID0gLyg/Ol5cXHMrfFxccyskKS9nO1xuZXhwb3J0IHZhciBlbW9qaUV4cCA9IC8oW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXSg/OltcXHUyMDBEXFx1RkUwRl1bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdKXsyLH18XFx1RDgzRFxcdURDNjkoPzpcXHUyMDBEKD86KD86XFx1RDgzRFxcdURDNjlcXHUyMDBEKT9cXHVEODNEXFx1REM2N3woPzpcXHVEODNEXFx1REM2OVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY2KXxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFxcdUQ4M0RcXHVEQzY5XFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzY5XFx1MjAwRCk/XFx1RDgzRFxcdURDNjZcXHUyMDBEXFx1RDgzRFxcdURDNjZ8XFx1RDgzRFxcdURDNjlcXHUyMDBEKD86XFx1RDgzRFxcdURDNjlcXHUyMDBEKT9cXHVEODNEXFx1REM2N1xcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8XFx1RDgzQ1xcdURGRjNcXHVGRTBGXFx1MjAwRFxcdUQ4M0NcXHVERjA4fCg/OlxcdUQ4M0NbXFx1REZDM1xcdURGQzRcXHVERkNBXXxcXHVEODNEW1xcdURDNkVcXHVEQzcxXFx1REM3M1xcdURDNzdcXHVEQzgxXFx1REM4MlxcdURDODZcXHVEQzg3XFx1REU0NS1cXHVERTQ3XFx1REU0QlxcdURFNERcXHVERTRFXFx1REVBM1xcdURFQjQtXFx1REVCNl18XFx1RDgzRVtcXHVERDI2XFx1REQzNy1cXHVERDM5XFx1REQzRFxcdUREM0VcXHVEREQ2LVxcdURERERdKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSlcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEZ8XFx1RDgzRFxcdURDNjkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdKXwoPzpcXHVEODNDW1xcdURGQzNcXHVERkM0XFx1REZDQV18XFx1RDgzRFtcXHVEQzZFXFx1REM2RlxcdURDNzFcXHVEQzczXFx1REM3N1xcdURDODFcXHVEQzgyXFx1REM4NlxcdURDODdcXHVERTQ1LVxcdURFNDdcXHVERTRCXFx1REU0RFxcdURFNEVcXHVERUEzXFx1REVCNC1cXHVERUI2XXxcXHVEODNFW1xcdUREMjZcXHVERDM3LVxcdUREMzlcXHVERDNDLVxcdUREM0VcXHVEREQ2LVxcdUREREZdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRnxcXHVEODNDXFx1RERGRFxcdUQ4M0NcXHVEREYwfFxcdUQ4M0NcXHVEREY2XFx1RDgzQ1xcdURERTZ8XFx1RDgzQ1xcdURERjRcXHVEODNDXFx1RERGMnxcXHVEODNDXFx1RERFOSg/OlxcdUQ4M0NbXFx1RERFQVxcdURERUNcXHVEREVGXFx1RERGMFxcdURERjJcXHVEREY0XFx1RERGRl0pfFxcdUQ4M0NcXHVEREY3KD86XFx1RDgzQ1tcXHVEREVBXFx1RERGNFxcdURERjhcXHVEREZBXFx1RERGQ10pfFxcdUQ4M0NcXHVEREU4KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERTlcXHVEREVCLVxcdURERUVcXHVEREYwLVxcdURERjVcXHVEREY3XFx1RERGQS1cXHVEREZGXSl8KD86XFx1MjZGOXxcXHVEODNDW1xcdURGQ0JcXHVERkNDXXxcXHVEODNEXFx1REQ3NSkoPzpcXHVGRTBGXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml18KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdKVxcdUZFMEZ8KD86XFx1RDgzRFxcdURDNDFcXHVGRTBGXFx1MjAwRFxcdUQ4M0RcXHVEREU4fFxcdUQ4M0RcXHVEQzY5KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNEXFx1REM2OVxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNEXFx1REM2OCg/Oig/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSlcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdKSlcXHVGRTBGfFxcdUQ4M0NcXHVEREYyKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOC1cXHVEREVEXFx1RERGMC1cXHVEREZGXSl8XFx1RDgzRFxcdURDNjlcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pfFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKSl8XFx1RDgzQ1xcdURERjEoPzpcXHVEODNDW1xcdURERTYtXFx1RERFOFxcdURERUVcXHVEREYwXFx1RERGNy1cXHVEREZCXFx1RERGRV0pfFxcdUQ4M0NcXHVEREVGKD86XFx1RDgzQ1tcXHVEREVBXFx1RERGMlxcdURERjRcXHVEREY1XSl8XFx1RDgzQ1xcdURERUQoPzpcXHVEODNDW1xcdURERjBcXHVEREYyXFx1RERGM1xcdURERjdcXHVEREY5XFx1RERGQV0pfFxcdUQ4M0NcXHVEREVCKD86XFx1RDgzQ1tcXHVEREVFLVxcdURERjBcXHVEREYyXFx1RERGNFxcdURERjddKXxbI1xcKjAtOV1cXHVGRTBGXFx1MjBFM3xcXHVEODNDXFx1RERFNyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERTdcXHVEREU5LVxcdURERUZcXHVEREYxLVxcdURERjRcXHVEREY2LVxcdURERjlcXHVEREZCXFx1RERGQ1xcdURERkVcXHVEREZGXSl8XFx1RDgzQ1xcdURERTYoPzpcXHVEODNDW1xcdURERTgtXFx1RERFQ1xcdURERUVcXHVEREYxXFx1RERGMlxcdURERjRcXHVEREY2LVxcdURERkFcXHVEREZDXFx1RERGRFxcdURERkZdKXxcXHVEODNDXFx1RERGRig/OlxcdUQ4M0NbXFx1RERFNlxcdURERjJcXHVEREZDXSl8XFx1RDgzQ1xcdURERjUoPzpcXHVEODNDW1xcdURERTZcXHVEREVBLVxcdURERURcXHVEREYwLVxcdURERjNcXHVEREY3LVxcdURERjlcXHVEREZDXFx1RERGRV0pfFxcdUQ4M0NcXHVEREZCKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUFcXHVEREVDXFx1RERFRVxcdURERjNcXHVEREZBXSl8XFx1RDgzQ1xcdURERjMoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQS1cXHVEREVDXFx1RERFRVxcdURERjFcXHVEREY0XFx1RERGNVxcdURERjdcXHVEREZBXFx1RERGRl0pfFxcdUQ4M0NcXHVERkY0XFx1REI0MFxcdURDNjdcXHVEQjQwXFx1REM2Mig/OlxcdURCNDBcXHVEQzc3XFx1REI0MFxcdURDNkNcXHVEQjQwXFx1REM3M3xcXHVEQjQwXFx1REM3M1xcdURCNDBcXHVEQzYzXFx1REI0MFxcdURDNzR8XFx1REI0MFxcdURDNjVcXHVEQjQwXFx1REM2RVxcdURCNDBcXHVEQzY3KVxcdURCNDBcXHVEQzdGfFxcdUQ4M0RcXHVEQzY4KD86XFx1MjAwRCg/OlxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRFxcdURDNjh8KD86KD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1MjAwRCk/XFx1RDgzRFxcdURDNjZcXHUyMDBEXFx1RDgzRFxcdURDNjZ8KD86KD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1MjAwRCk/XFx1RDgzRFxcdURDNjdcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdKXwoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdKSl8XFx1RDgzQ1xcdURERjgoPzpcXHVEODNDW1xcdURERTYtXFx1RERFQVxcdURERUMtXFx1RERGNFxcdURERjctXFx1RERGOVxcdURERkJcXHVEREZELVxcdURERkZdKXxcXHVEODNDXFx1RERGMCg/OlxcdUQ4M0NbXFx1RERFQVxcdURERUMtXFx1RERFRVxcdURERjJcXHVEREYzXFx1RERGNVxcdURERjdcXHVEREZDXFx1RERGRVxcdURERkZdKXxcXHVEODNDXFx1RERGRSg/OlxcdUQ4M0NbXFx1RERFQVxcdURERjldKXxcXHVEODNDXFx1RERFRSg/OlxcdUQ4M0NbXFx1RERFOC1cXHVEREVBXFx1RERGMS1cXHVEREY0XFx1RERGNi1cXHVEREY5XSl8XFx1RDgzQ1xcdURERjkoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFOVxcdURERUItXFx1RERFRFxcdURERUYtXFx1RERGNFxcdURERjdcXHVEREY5XFx1RERGQlxcdURERkNcXHVEREZGXSl8XFx1RDgzQ1xcdURERUMoPzpcXHVEODNDW1xcdURERTZcXHVEREU3XFx1RERFOS1cXHVEREVFXFx1RERGMS1cXHVEREYzXFx1RERGNS1cXHVEREZBXFx1RERGQ1xcdURERkVdKXxcXHVEODNDXFx1RERGQSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERUNcXHVEREYyXFx1RERGM1xcdURERjhcXHVEREZFXFx1RERGRl0pfFxcdUQ4M0NcXHVEREVBKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUFcXHVEREVDXFx1RERFRFxcdURERjctXFx1RERGQV0pfFxcdUQ4M0NcXHVEREZDKD86XFx1RDgzQ1tcXHVEREVCXFx1RERGOF0pfCg/OlxcdTI2Rjl8XFx1RDgzQ1tcXHVERkNCXFx1REZDQ118XFx1RDgzRFxcdURENzUpKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXwoPzpcXHVEODNDW1xcdURGQzNcXHVERkM0XFx1REZDQV18XFx1RDgzRFtcXHVEQzZFXFx1REM3MVxcdURDNzNcXHVEQzc3XFx1REM4MVxcdURDODJcXHVEQzg2XFx1REM4N1xcdURFNDUtXFx1REU0N1xcdURFNEJcXHVERTREXFx1REU0RVxcdURFQTNcXHVERUI0LVxcdURFQjZdfFxcdUQ4M0VbXFx1REQyNlxcdUREMzctXFx1REQzOVxcdUREM0RcXHVERDNFXFx1RERENi1cXHVEREREXSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OltcXHUyNjFEXFx1MjcwQS1cXHUyNzBEXXxcXHVEODNDW1xcdURGODVcXHVERkMyXFx1REZDN118XFx1RDgzRFtcXHVEQzQyXFx1REM0M1xcdURDNDYtXFx1REM1MFxcdURDNjZcXHVEQzY3XFx1REM3MFxcdURDNzJcXHVEQzc0LVxcdURDNzZcXHVEQzc4XFx1REM3Q1xcdURDODNcXHVEQzg1XFx1RENBQVxcdURENzRcXHVERDdBXFx1REQ5MFxcdUREOTVcXHVERDk2XFx1REU0Q1xcdURFNEZcXHVERUMwXFx1REVDQ118XFx1RDgzRVtcXHVERDE4LVxcdUREMUNcXHVERDFFXFx1REQxRlxcdUREMzAtXFx1REQzNlxcdURERDEtXFx1RERENV0pKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXxcXHVEODNEXFx1REM2OCg/OlxcdTIwMEQoPzooPzooPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHUyMDBEKT9cXHVEODNEXFx1REM2N3woPzooPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHUyMDBEKT9cXHVEODNEXFx1REM2Nil8XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXwoPzpbXFx1MjYxRFxcdTI2RjlcXHUyNzBBLVxcdTI3MERdfFxcdUQ4M0NbXFx1REY4NVxcdURGQzItXFx1REZDNFxcdURGQzdcXHVERkNBLVxcdURGQ0NdfFxcdUQ4M0RbXFx1REM0MlxcdURDNDNcXHVEQzQ2LVxcdURDNTBcXHVEQzY2LVxcdURDNjlcXHVEQzZFXFx1REM3MC1cXHVEQzc4XFx1REM3Q1xcdURDODEtXFx1REM4M1xcdURDODUtXFx1REM4N1xcdURDQUFcXHVERDc0XFx1REQ3NVxcdUREN0FcXHVERDkwXFx1REQ5NVxcdUREOTZcXHVERTQ1LVxcdURFNDdcXHVERTRCLVxcdURFNEZcXHVERUEzXFx1REVCNC1cXHVERUI2XFx1REVDMFxcdURFQ0NdfFxcdUQ4M0VbXFx1REQxOC1cXHVERDFDXFx1REQxRVxcdUREMUZcXHVERDI2XFx1REQzMC1cXHVERDM5XFx1REQzRFxcdUREM0VcXHVEREQxLVxcdURERERdKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/fCg/OltcXHUyMzFBXFx1MjMxQlxcdTIzRTktXFx1MjNFQ1xcdTIzRjBcXHUyM0YzXFx1MjVGRFxcdTI1RkVcXHUyNjE0XFx1MjYxNVxcdTI2NDgtXFx1MjY1M1xcdTI2N0ZcXHUyNjkzXFx1MjZBMVxcdTI2QUFcXHUyNkFCXFx1MjZCRFxcdTI2QkVcXHUyNkM0XFx1MjZDNVxcdTI2Q0VcXHUyNkQ0XFx1MjZFQVxcdTI2RjJcXHUyNkYzXFx1MjZGNVxcdTI2RkFcXHUyNkZEXFx1MjcwNVxcdTI3MEFcXHUyNzBCXFx1MjcyOFxcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3OTUtXFx1Mjc5N1xcdTI3QjBcXHUyN0JGXFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NV18XFx1RDgzQ1tcXHVEQzA0XFx1RENDRlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREU2LVxcdURERkZcXHVERTAxXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFMzZcXHVERTM4LVxcdURFM0FcXHVERTUwXFx1REU1MVxcdURGMDAtXFx1REYyMFxcdURGMkQtXFx1REYzNVxcdURGMzctXFx1REY3Q1xcdURGN0UtXFx1REY5M1xcdURGQTAtXFx1REZDQVxcdURGQ0YtXFx1REZEM1xcdURGRTAtXFx1REZGMFxcdURGRjRcXHVERkY4LVxcdURGRkZdfFxcdUQ4M0RbXFx1REMwMC1cXHVEQzNFXFx1REM0MFxcdURDNDItXFx1RENGQ1xcdURDRkYtXFx1REQzRFxcdURENEItXFx1REQ0RVxcdURENTAtXFx1REQ2N1xcdUREN0FcXHVERDk1XFx1REQ5NlxcdUREQTRcXHVEREZCLVxcdURFNEZcXHVERTgwLVxcdURFQzVcXHVERUNDXFx1REVEMC1cXHVERUQyXFx1REVFQlxcdURFRUNcXHVERUY0LVxcdURFRjhdfFxcdUQ4M0VbXFx1REQxMC1cXHVERDNBXFx1REQzQy1cXHVERDNFXFx1REQ0MC1cXHVERDQ1XFx1REQ0Ny1cXHVERDRDXFx1REQ1MC1cXHVERDZCXFx1REQ4MC1cXHVERDk3XFx1RERDMFxcdURERDAtXFx1RERFNl0pfCg/OlsjXFwqMC05XFx4QTlcXHhBRVxcdTIwM0NcXHUyMDQ5XFx1MjEyMlxcdTIxMzlcXHUyMTk0LVxcdTIxOTlcXHUyMUE5XFx1MjFBQVxcdTIzMUFcXHUyMzFCXFx1MjMyOFxcdTIzQ0ZcXHUyM0U5LVxcdTIzRjNcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkItXFx1MjVGRVxcdTI2MDAtXFx1MjYwNFxcdTI2MEVcXHUyNjExXFx1MjYxNFxcdTI2MTVcXHUyNjE4XFx1MjYxRFxcdTI2MjBcXHUyNjIyXFx1MjYyM1xcdTI2MjZcXHUyNjJBXFx1MjYyRVxcdTI2MkZcXHUyNjM4LVxcdTI2M0FcXHUyNjQwXFx1MjY0MlxcdTI2NDgtXFx1MjY1M1xcdTI2NjBcXHUyNjYzXFx1MjY2NVxcdTI2NjZcXHUyNjY4XFx1MjY3QlxcdTI2N0ZcXHUyNjkyLVxcdTI2OTdcXHUyNjk5XFx1MjY5QlxcdTI2OUNcXHUyNkEwXFx1MjZBMVxcdTI2QUFcXHUyNkFCXFx1MjZCMFxcdTI2QjFcXHUyNkJEXFx1MjZCRVxcdTI2QzRcXHUyNkM1XFx1MjZDOFxcdTI2Q0VcXHUyNkNGXFx1MjZEMVxcdTI2RDNcXHUyNkQ0XFx1MjZFOVxcdTI2RUFcXHUyNkYwLVxcdTI2RjVcXHUyNkY3LVxcdTI2RkFcXHUyNkZEXFx1MjcwMlxcdTI3MDVcXHUyNzA4LVxcdTI3MERcXHUyNzBGXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzI4XFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3NjNcXHUyNzY0XFx1Mjc5NS1cXHUyNzk3XFx1MjdBMVxcdTI3QjBcXHUyN0JGXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV18XFx1RDgzQ1tcXHVEQzA0XFx1RENDRlxcdURENzBcXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERFNi1cXHVEREZGXFx1REUwMVxcdURFMDJcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzQVxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERjIxXFx1REYyNC1cXHVERjkzXFx1REY5NlxcdURGOTdcXHVERjk5LVxcdURGOUJcXHVERjlFLVxcdURGRjBcXHVERkYzLVxcdURGRjVcXHVERkY3LVxcdURGRkZdfFxcdUQ4M0RbXFx1REMwMC1cXHVEQ0ZEXFx1RENGRi1cXHVERDNEXFx1REQ0OS1cXHVERDRFXFx1REQ1MC1cXHVERDY3XFx1REQ2RlxcdURENzBcXHVERDczLVxcdUREN0FcXHVERDg3XFx1REQ4QS1cXHVERDhEXFx1REQ5MFxcdUREOTVcXHVERDk2XFx1RERBNFxcdUREQTVcXHVEREE4XFx1RERCMVxcdUREQjJcXHVEREJDXFx1RERDMi1cXHVEREM0XFx1REREMS1cXHVEREQzXFx1REREQy1cXHVERERFXFx1RERFMVxcdURERTNcXHVEREU4XFx1RERFRlxcdURERjNcXHVEREZBLVxcdURFNEZcXHVERTgwLVxcdURFQzVcXHVERUNCLVxcdURFRDJcXHVERUUwLVxcdURFRTVcXHVERUU5XFx1REVFQlxcdURFRUNcXHVERUYwXFx1REVGMy1cXHVERUY4XXxcXHVEODNFW1xcdUREMTAtXFx1REQzQVxcdUREM0MtXFx1REQzRVxcdURENDAtXFx1REQ0NVxcdURENDctXFx1REQ0Q1xcdURENTAtXFx1REQ2QlxcdUREODAtXFx1REQ5N1xcdUREQzBcXHVEREQwLVxcdURERTZdKVxcdUZFMEYpLztcbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXh0KGUpIHtcbiAgdmFyIHR5cGUgPSBlLm5vZGVUeXBlLFxuICAgICAgcmVzdWx0ID0gXCJcIjtcblxuICBpZiAodHlwZSA9PT0gMSB8fCB0eXBlID09PSA5IHx8IHR5cGUgPT09IDExKSB7XG4gICAgaWYgKHR5cGVvZiBlLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZS50ZXh0Q29udGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChlID0gZS5maXJzdENoaWxkOyBlOyBlID0gZS5uZXh0U2libGluZykge1xuICAgICAgICByZXN1bHQgKz0gZ2V0VGV4dChlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gMyB8fCB0eXBlID09PSA0KSB7XG4gICAgcmV0dXJuIGUubm9kZVZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdElubmVySFRNTChlbGVtZW50LCBkZWxpbWl0ZXIsIHRyaW0sIHByZXNlcnZlU3BhY2VzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudC5maXJzdENoaWxkLFxuICAgICAgcmVzdWx0ID0gW10sXG4gICAgICBzO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIHMgPSAobm9kZS5ub2RlVmFsdWUgKyBcIlwiKS5yZXBsYWNlKC9eXFxuKy9nLCBcIlwiKTtcblxuICAgICAgaWYgKCFwcmVzZXJ2ZVNwYWNlcykge1xuICAgICAgICBzID0gcy5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBlbW9qaVNhZmVTcGxpdChzLCBkZWxpbWl0ZXIsIHRyaW0sIHByZXNlcnZlU3BhY2VzKSk7XG4gICAgfSBlbHNlIGlmICgobm9kZS5ub2RlTmFtZSArIFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwiYnJcIikge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSArPSBcIjxicj5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2gobm9kZS5vdXRlckhUTUwpO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICB9XG5cbiAgcyA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKHMtLSkge1xuICAgIHJlc3VsdFtzXSA9PT0gXCImXCIgJiYgcmVzdWx0LnNwbGljZShzLCAxLCBcIiZhbXA7XCIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qXG4vL3NtYWxsZXIga2IgdmVyc2lvbiB0aGF0IG9ubHkgaGFuZGxlcyB0aGUgc2ltcGxlciBlbW9qaSdzLCB3aGljaCBpcyBvZnRlbiBwZXJmZWN0bHkgYWRlcXVhdGUuXG5cbmxldCBfZW1vamkgPSBcIltcXHVFMDAwLVxcdUY4RkZdfFxcdUQ4M0NbXFx1REMwMC1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1REZGRl18W1xcdTI2OTQtXFx1MjY5N118XFx1RDgzRVtcXHVERDEwLVxcdURENURdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl1cIixcblx0X2Vtb2ppRXhwID0gbmV3IFJlZ0V4cChfZW1vamkpLFxuXHRfZW1vamlBbmRDaGFyc0V4cCA9IG5ldyBSZWdFeHAoX2Vtb2ppICsgXCJ8LlwiLCBcImdcIiksXG5cdF9lbW9qaVNhZmVTcGxpdCA9ICh0ZXh0LCBkZWxpbWl0ZXIsIHRyaW0pID0+IHtcblx0XHRpZiAodHJpbSkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZShfdHJpbUV4cCwgXCJcIik7XG5cdFx0fVxuXHRcdHJldHVybiAoKGRlbGltaXRlciA9PT0gXCJcIiB8fCAhZGVsaW1pdGVyKSAmJiBfZW1vamlFeHAudGVzdCh0ZXh0KSkgPyB0ZXh0Lm1hdGNoKF9lbW9qaUFuZENoYXJzRXhwKSA6IHRleHQuc3BsaXQoZGVsaW1pdGVyIHx8IFwiXCIpO1xuXHR9O1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlbW9qaVNhZmVTcGxpdCh0ZXh0LCBkZWxpbWl0ZXIsIHRyaW0sIHByZXNlcnZlU3BhY2VzKSB7XG4gIHRleHQgKz0gXCJcIjsgLy8gbWFrZSBzdXJlIGl0J3MgY2FzdCBhcyBhIHN0cmluZy4gU29tZW9uZSBtYXkgcGFzcyBpbiBhIG51bWJlci5cblxuICB0cmltICYmICh0ZXh0ID0gdGV4dC50cmltID8gdGV4dC50cmltKCkgOiB0ZXh0LnJlcGxhY2UoX3RyaW1FeHAsIFwiXCIpKTsgLy8gSUU5IGFuZCBlYXJsaWVyIGNvbXBhdGliaWxpdHlcblxuICBpZiAoZGVsaW1pdGVyICYmIGRlbGltaXRlciAhPT0gXCJcIikge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpLnNwbGl0KGRlbGltaXRlcik7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICBsID0gdGV4dC5sZW5ndGgsXG4gICAgICBpID0gMCxcbiAgICAgIGosXG4gICAgICBjaGFyYWN0ZXI7XG5cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBjaGFyYWN0ZXIgPSB0ZXh0LmNoYXJBdChpKTtcblxuICAgIGlmIChjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKSA+PSAweEQ4MDAgJiYgY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkgPD0gMHhEQkZGIHx8IHRleHQuY2hhckNvZGVBdChpICsgMSkgPj0gMHhGRTAwICYmIHRleHQuY2hhckNvZGVBdChpICsgMSkgPD0gMHhGRTBGKSB7XG4gICAgICAvL3NwZWNpYWwgZW1vamkgY2hhcmFjdGVycyB1c2UgMiBvciA0IHVuaWNvZGUgY2hhcmFjdGVycyB0aGF0IHdlIG11c3Qga2VlcCB0b2dldGhlci5cbiAgICAgIGogPSAoKHRleHQuc3Vic3RyKGksIDEyKS5zcGxpdChlbW9qaUV4cCkgfHwgW10pWzFdIHx8IFwiXCIpLmxlbmd0aCB8fCAyO1xuICAgICAgY2hhcmFjdGVyID0gdGV4dC5zdWJzdHIoaSwgaik7XG4gICAgICByZXN1bHQuZW1vamkgPSAxO1xuICAgICAgaSArPSBqIC0gMTtcbiAgICB9XG5cbiAgICByZXN1bHQucHVzaChjaGFyYWN0ZXIgPT09IFwiPlwiID8gXCImZ3Q7XCIgOiBjaGFyYWN0ZXIgPT09IFwiPFwiID8gXCImbHQ7XCIgOiBwcmVzZXJ2ZVNwYWNlcyAmJiBjaGFyYWN0ZXIgPT09IFwiIFwiICYmICh0ZXh0LmNoYXJBdChpIC0gMSkgPT09IFwiIFwiIHx8IHRleHQuY2hhckF0KGkgKyAxKSA9PT0gXCIgXCIpID8gXCImbmJzcDtcIiA6IGNoYXJhY3Rlcik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSJdLCJuYW1lcyI6WyJfdHJpbUV4cCIsImVtb2ppRXhwIiwiZ2V0VGV4dCIsImUiLCJ0eXBlIiwibm9kZVR5cGUiLCJyZXN1bHQiLCJ0ZXh0Q29udGVudCIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsIm5vZGVWYWx1ZSIsInNwbGl0SW5uZXJIVE1MIiwiZWxlbWVudCIsImRlbGltaXRlciIsInRyaW0iLCJwcmVzZXJ2ZVNwYWNlcyIsIm5vZGUiLCJzIiwicmVwbGFjZSIsInB1c2giLCJhcHBseSIsImVtb2ppU2FmZVNwbGl0Iiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImxlbmd0aCIsIm91dGVySFRNTCIsInNwbGljZSIsInRleHQiLCJzcGxpdCIsImwiLCJpIiwiaiIsImNoYXJhY3RlciIsImNoYXJBdCIsImNoYXJDb2RlQXQiLCJzdWJzdHIiLCJlbW9qaSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/strings.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/app-dynamic.js":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/app-dynamic.js ***!
  \******************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _shared_lib_app_dynamic__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _shared_lib_app_dynamic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/lib/app-dynamic */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/app-dynamic.js\");\n/* harmony import */ var _shared_lib_app_dynamic__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shared_lib_app_dynamic__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _shared_lib_app_dynamic__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _shared_lib_app_dynamic__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=app-dynamic.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2FwcC1keW5hbWljLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEwQztBQUNVOztBQUVwRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuNzcuMi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9hcHAtZHluYW1pYy5qcz8yMDJmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuLi9zaGFyZWQvbGliL2FwcC1keW5hbWljXCI7XG5leHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi4uL3NoYXJlZC9saWIvYXBwLWR5bmFtaWNcIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLWR5bmFtaWMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/app-dynamic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/link.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/link.js ***!
  \***********************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _client_link__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/link */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/link.js\");\n/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_link__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_link__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_link__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=link.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2xpbmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXlDO0FBQ1Y7O0FBRS9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2xpbmsuanM/ZGI0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi4uL2NsaWVudC9saW5rXCI7XG5leHBvcnQgKiBmcm9tIFwiLi4vY2xpZW50L2xpbmtcIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluay5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/navigation.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/navigation.js ***!
  \*****************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEOztBQUVoRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuNzcuMi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9uYXZpZ2F0aW9uLmpzPzU5MzIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4uL2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb25cIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/build/polyfills/process.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/build/polyfills/process.js ***!
  \**************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQyxtTUFBNEI7O0FBRXpQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/YTk1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={592:(e,r,t)=>{var n=t(722);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},722:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(592);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQyw4QkFBOEIsdUJBQXVCLFFBQVEsa0JBQWtCLFdBQVcsZ0JBQWdCLDhCQUE4QixxQkFBcUIsZ0JBQWdCLG1CQUFtQixpQkFBaUIsZ0NBQWdDLFdBQVcsT0FBTywyQkFBMkIsNkJBQTZCLEtBQUssOENBQThDLG9CQUFvQixNQUFNLFNBQVMsT0FBTyxtQkFBbUIsT0FBTyxZQUFZLGdDQUFnQyxjQUFjLE9BQU8sZ0NBQWdDLE9BQU8sZ0NBQWdDLHFDQUFxQyw0Q0FBNEMsMkNBQTJDLFNBQVMsZ0JBQWdCLElBQUksd0JBQXdCLE9BQU8sWUFBWSxPQUFPLHVCQUF1QixxQkFBcUIsT0FBTyx1QkFBdUIsT0FBTyxnQ0FBZ0MsT0FBTyxlQUFlLG9CQUFvQixpQkFBaUIsc0NBQXNDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsdUNBQXVDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsMkNBQTJDLGtCQUFrQiwyQ0FBMkMsS0FBSyw2QkFBNkIsMkJBQTJCLE1BQU0sT0FBTyxlQUFlLEVBQUUsb0JBQW9CLG9CQUFvQixLQUFLLEdBQUcsU0FBUyx3QkFBd0IsT0FBTyxhQUFhLHdDQUF3QyxZQUFZLHNCQUFzQixZQUFZLE9BQU8sNkJBQTZCLHFCQUFxQixPQUFPLHFCQUFxQixPQUFPLE1BQU0sZUFBZSxRQUFRLEdBQUcsU0FBUyxxQkFBcUIsd0NBQXdDLHNCQUFzQixxQkFBcUIsT0FBTyxhQUFhLEdBQUcseUJBQXlCLHlDQUF5QyxhQUFhLFlBQVksd0JBQXdCLE1BQU0sMERBQTBELFlBQVksNkJBQTZCLGtCQUFrQixvQkFBb0IscUJBQXFCLGFBQWEsZ0VBQWdFLFlBQVksT0FBTyxNQUFNLCtDQUErQyxLQUFLLG9DQUFvQyxhQUFhLDRCQUE0QixTQUFTLHlCQUF5QiwrQkFBK0IsVUFBVSxpQkFBaUIsTUFBTSxjQUFjLGtCQUFrQixTQUFTLGdCQUFnQixzQkFBc0IsV0FBVyxzQkFBc0IsU0FBUyxvREFBb0QsaURBQWlELDJDQUEyQyxRQUFRLHNCQUFzQixnQkFBZ0IsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuNzcuMi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qcz9lOWRmIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs1OTI6KGUscix0KT0+e3ZhciBuPXQoNzIyKTt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhPXR5cGVvZiBkb2N1bWVudD09PVwidW5kZWZpbmVkXCI7dmFyIG89QXJyYXkucHJvdG90eXBlLmZvckVhY2g7ZnVuY3Rpb24gZGVib3VuY2UoZSxyKXt2YXIgdD0wO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXM7dmFyIGk9YXJndW1lbnRzO3ZhciBhPWZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbCgpe3JldHVybiBlLmFwcGx5KG4saSl9O2NsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQoYSxyKX19ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0VXJsKGUpe3ZhciByPWlbZV07aWYoIXIpe2lmKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3I9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9ZWxzZXt2YXIgdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTt2YXIgYT10W3QubGVuZ3RoLTFdO2lmKGEpe3I9YS5zcmN9fWlbZV09cn1yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXIpe3JldHVybiBudWxsfXZhciB0PXIuc3BsaXQoLyhbXlxcXFwvXSspXFwuanMkLyk7dmFyIGk9dCYmdFsxXTtpZighaSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19aWYoIWUpe3JldHVybltyLnJlcGxhY2UoXCIuanNcIixcIi5jc3NcIildfXJldHVybiBlLnNwbGl0KFwiLFwiKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBSZWdFeHAoXCJcIi5jb25jYXQoaSxcIlxcXFwuanMkXCIpLFwiZ1wiKTtyZXR1cm4gbihyLnJlcGxhY2UodCxcIlwiLmNvbmNhdChlLnJlcGxhY2UoL3tmaWxlTmFtZX0vZyxpKSxcIi5jc3NcIikpKX0pKX19ZnVuY3Rpb24gdXBkYXRlQ3NzKGUscil7aWYoIXIpe2lmKCFlLmhyZWYpe3JldHVybn1yPWUuaHJlZi5zcGxpdChcIj9cIilbMF19aWYoIWlzVXJsUmVxdWVzdChyKSl7cmV0dXJufWlmKGUuaXNMb2FkZWQ9PT1mYWxzZSl7cmV0dXJufWlmKCFyfHwhKHIuaW5kZXhPZihcIi5jc3NcIik+LTEpKXtyZXR1cm59ZS52aXNpdGVkPXRydWU7dmFyIHQ9ZS5jbG9uZU5vZGUoKTt0LmlzTG9hZGVkPWZhbHNlO3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtpZih0LmlzTG9hZGVkKXtyZXR1cm59dC5pc0xvYWRlZD10cnVlO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuaHJlZj1cIlwiLmNvbmNhdChyLFwiP1wiKS5jb25jYXQoRGF0ZS5ub3coKSk7aWYoZS5uZXh0U2libGluZyl7ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpfWVsc2V7ZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpfX1mdW5jdGlvbiBnZXRSZWxvYWRVcmwoZSxyKXt2YXIgdDtlPW4oZSx7c3RyaXBXV1c6ZmFsc2V9KTtyLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihyKT4tMSl7dD1ufX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRTdHlsZShlKXtpZighZSl7cmV0dXJuIGZhbHNlfXZhciByPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO3ZhciB0PWZhbHNlO28uY2FsbChyLChmdW5jdGlvbihyKXtpZighci5ocmVmKXtyZXR1cm59dmFyIG49Z2V0UmVsb2FkVXJsKHIuaHJlZixlKTtpZighaXNVcmxSZXF1ZXN0KG4pKXtyZXR1cm59aWYoci52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufWlmKG4pe3VwZGF0ZUNzcyhyLG4pO3Q9dHJ1ZX19KSk7cmV0dXJuIHR9ZnVuY3Rpb24gcmVsb2FkQWxsKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7by5jYWxsKGUsKGZ1bmN0aW9uKGUpe2lmKGUudmlzaXRlZD09PXRydWUpe3JldHVybn11cGRhdGVDc3MoZSl9KSl9ZnVuY3Rpb24gaXNVcmxSZXF1ZXN0KGUpe2lmKCEvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly50ZXN0KGUpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYoYSl7Y29uc29sZS5sb2coXCJubyB3aW5kb3cuZG9jdW1lbnQgZm91bmQsIHdpbGwgbm90IEhNUiBDU1NcIik7cmV0dXJuIG5vb3B9dmFyIHQ9Z2V0Q3VycmVudFNjcmlwdFVybChlKTtmdW5jdGlvbiB1cGRhdGUoKXt2YXIgZT10KHIuZmlsZW5hbWUpO3ZhciBuPXJlbG9hZFN0eWxlKGUpO2lmKHIubG9jYWxzKXtjb25zb2xlLmxvZyhcIltITVJdIERldGVjdGVkIGxvY2FsIGNzcyBtb2R1bGVzLiBSZWxvYWQgYWxsIGNzc1wiKTtyZWxvYWRBbGwoKTtyZXR1cm59aWYobil7Y29uc29sZS5sb2coXCJbSE1SXSBjc3MgcmVsb2FkICVzXCIsZS5qb2luKFwiIFwiKSl9ZWxzZXtjb25zb2xlLmxvZyhcIltITVJdIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpfX1yZXR1cm4gZGVib3VuY2UodXBkYXRlLDUwKX19LDcyMjplPT57ZnVuY3Rpb24gbm9ybWFsaXplVXJsKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtzd2l0Y2gocil7Y2FzZVwiLi5cIjplLnBvcCgpO2JyZWFrO2Nhc2VcIi5cIjpicmVhaztkZWZhdWx0OmUucHVzaChyKX1yZXR1cm4gZX0pLFtdKS5qb2luKFwiL1wiKX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtpZigvXmRhdGE6L2kudGVzdChlKSl7cmV0dXJuIGV9dmFyIHI9ZS5pbmRleE9mKFwiLy9cIikhPT0tMT9lLnNwbGl0KFwiLy9cIilbMF0rXCIvL1wiOlwiXCI7dmFyIHQ9ZS5yZXBsYWNlKG5ldyBSZWdFeHAocixcImlcIiksXCJcIikuc3BsaXQoXCIvXCIpO3ZhciBuPXRbMF0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4kLyxcIlwiKTt0WzBdPVwiXCI7dmFyIGk9bm9ybWFsaXplVXJsKHQpO3JldHVybiByK24raX19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPXJbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNTkyKTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/picomatch/index.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/picomatch/index.js ***!
  \***************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/build/polyfills/process.js\");\n(()=>{\"use strict\";var t={170:(t,e,u)=>{const n=u(510);const isWindows=()=>{if(typeof navigator!==\"undefined\"&&navigator.platform){const t=navigator.platform.toLowerCase();return t===\"win32\"||t===\"windows\"}if(typeof process!==\"undefined\"&&process.platform){return process.platform===\"win32\"}return false};function picomatch(t,e,u=false){if(e&&(e.windows===null||e.windows===undefined)){e={...e,windows:isWindows()}}return n(t,e,u)}Object.assign(picomatch,n);t.exports=picomatch},154:t=>{const e=\"\\\\\\\\/\";const u=`[^${e}]`;const n=\"\\\\.\";const o=\"\\\\+\";const s=\"\\\\?\";const r=\"\\\\/\";const a=\"(?=.)\";const i=\"[^/]\";const c=`(?:${r}|$)`;const p=`(?:^|${r})`;const l=`${n}{1,2}${c}`;const f=`(?!${n})`;const A=`(?!${p}${l})`;const _=`(?!${n}{0,1}${c})`;const R=`(?!${l})`;const E=`[^.${r}]`;const h=`${i}*?`;const g=\"/\";const b={DOT_LITERAL:n,PLUS_LITERAL:o,QMARK_LITERAL:s,SLASH_LITERAL:r,ONE_CHAR:a,QMARK:i,END_ANCHOR:c,DOTS_SLASH:l,NO_DOT:f,NO_DOTS:A,NO_DOT_SLASH:_,NO_DOTS_SLASH:R,QMARK_NO_DOT:E,STAR:h,START_ANCHOR:p,SEP:g};const C={...b,SLASH_LITERAL:`[${e}]`,QMARK:u,STAR:`${u}*?`,DOTS_SLASH:`${n}{1,2}(?:[${e}]|$)`,NO_DOT:`(?!${n})`,NO_DOTS:`(?!(?:^|[${e}])${n}{1,2}(?:[${e}]|$))`,NO_DOT_SLASH:`(?!${n}{0,1}(?:[${e}]|$))`,NO_DOTS_SLASH:`(?!${n}{1,2}(?:[${e}]|$))`,QMARK_NO_DOT:`[^.${e}]`,START_ANCHOR:`(?:^|[${e}])`,END_ANCHOR:`(?:[${e}]|$)`,SEP:\"\\\\\"};const y={alnum:\"a-zA-Z0-9\",alpha:\"a-zA-Z\",ascii:\"\\\\x00-\\\\x7F\",blank:\" \\\\t\",cntrl:\"\\\\x00-\\\\x1F\\\\x7F\",digit:\"0-9\",graph:\"\\\\x21-\\\\x7E\",lower:\"a-z\",print:\"\\\\x20-\\\\x7E \",punct:\"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",space:\" \\\\t\\\\r\\\\n\\\\v\\\\f\",upper:\"A-Z\",word:\"A-Za-z0-9_\",xdigit:\"A-Fa-f0-9\"};t.exports={MAX_LENGTH:1024*64,POSIX_REGEX_SOURCE:y,REGEX_BACKSLASH:/\\\\(?![*+?^${}(|)[\\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\\].,$*+?^{}()|\\\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\\\?)((\\W)(\\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,REPLACEMENTS:{\"***\":\"*\",\"**/**\":\"**\",\"**/**/**\":\"**\"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,extglobChars(t){return{\"!\":{type:\"negate\",open:\"(?:(?!(?:\",close:`))${t.STAR})`},\"?\":{type:\"qmark\",open:\"(?:\",close:\")?\"},\"+\":{type:\"plus\",open:\"(?:\",close:\")+\"},\"*\":{type:\"star\",open:\"(?:\",close:\")*\"},\"@\":{type:\"at\",open:\"(?:\",close:\")\"}}},globChars(t){return t===true?C:b}}},697:(t,e,u)=>{const n=u(154);const o=u(96);const{MAX_LENGTH:s,POSIX_REGEX_SOURCE:r,REGEX_NON_SPECIAL_CHARS:a,REGEX_SPECIAL_CHARS_BACKREF:i,REPLACEMENTS:c}=n;const expandRange=(t,e)=>{if(typeof e.expandRange===\"function\"){return e.expandRange(...t,e)}t.sort();const u=`[${t.join(\"-\")}]`;try{new RegExp(u)}catch(e){return t.map((t=>o.escapeRegex(t))).join(\"..\")}return u};const syntaxError=(t,e)=>`Missing ${t}: \"${e}\" - use \"\\\\\\\\${e}\" to match literal characters`;const parse=(t,e)=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected a string\")}t=c[t]||t;const u={...e};const p=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;let l=t.length;if(l>p){throw new SyntaxError(`Input length: ${l}, exceeds maximum allowed length: ${p}`)}const f={type:\"bos\",value:\"\",output:u.prepend||\"\"};const A=[f];const _=u.capture?\"\":\"?:\";const R=n.globChars(u.windows);const E=n.extglobChars(R);const{DOT_LITERAL:h,PLUS_LITERAL:g,SLASH_LITERAL:b,ONE_CHAR:C,DOTS_SLASH:y,NO_DOT:$,NO_DOT_SLASH:x,NO_DOTS_SLASH:S,QMARK:H,QMARK_NO_DOT:v,STAR:d,START_ANCHOR:L}=R;const globstar=t=>`(${_}(?:(?!${L}${t.dot?y:h}).)*?)`;const T=u.dot?\"\":$;const O=u.dot?H:v;let k=u.bash===true?globstar(u):d;if(u.capture){k=`(${k})`}if(typeof u.noext===\"boolean\"){u.noextglob=u.noext}const m={input:t,index:-1,start:0,dot:u.dot===true,consumed:\"\",output:\"\",prefix:\"\",backtrack:false,negated:false,brackets:0,braces:0,parens:0,quotes:0,globstar:false,tokens:A};t=o.removePrefix(t,m);l=t.length;const w=[];const N=[];const I=[];let B=f;let G;const eos=()=>m.index===l-1;const D=m.peek=(e=1)=>t[m.index+e];const M=m.advance=()=>t[++m.index]||\"\";const remaining=()=>t.slice(m.index+1);const consume=(t=\"\",e=0)=>{m.consumed+=t;m.index+=e};const append=t=>{m.output+=t.output!=null?t.output:t.value;consume(t.value)};const negate=()=>{let t=1;while(D()===\"!\"&&(D(2)!==\"(\"||D(3)===\"?\")){M();m.start++;t++}if(t%2===0){return false}m.negated=true;m.start++;return true};const increment=t=>{m[t]++;I.push(t)};const decrement=t=>{m[t]--;I.pop()};const push=t=>{if(B.type===\"globstar\"){const e=m.braces>0&&(t.type===\"comma\"||t.type===\"brace\");const u=t.extglob===true||w.length&&(t.type===\"pipe\"||t.type===\"paren\");if(t.type!==\"slash\"&&t.type!==\"paren\"&&!e&&!u){m.output=m.output.slice(0,-B.output.length);B.type=\"star\";B.value=\"*\";B.output=k;m.output+=B.output}}if(w.length&&t.type!==\"paren\"){w[w.length-1].inner+=t.value}if(t.value||t.output)append(t);if(B&&B.type===\"text\"&&t.type===\"text\"){B.output=(B.output||B.value)+t.value;B.value+=t.value;return}t.prev=B;A.push(t);B=t};const extglobOpen=(t,e)=>{const n={...E[e],conditions:1,inner:\"\"};n.prev=B;n.parens=m.parens;n.output=m.output;const o=(u.capture?\"(\":\"\")+n.open;increment(\"parens\");push({type:t,value:e,output:m.output?\"\":C});push({type:\"paren\",extglob:true,value:M(),output:o});w.push(n)};const extglobClose=t=>{let n=t.close+(u.capture?\")\":\"\");let o;if(t.type===\"negate\"){let s=k;if(t.inner&&t.inner.length>1&&t.inner.includes(\"/\")){s=globstar(u)}if(s!==k||eos()||/^\\)+$/.test(remaining())){n=t.close=`)$))${s}`}if(t.inner.includes(\"*\")&&(o=remaining())&&/^\\.[^\\\\/.]+$/.test(o)){const u=parse(o,{...e,fastpaths:false}).output;n=t.close=`)${u})${s})`}if(t.prev.type===\"bos\"){m.negatedExtglob=true}}push({type:\"paren\",extglob:true,value:G,output:n});decrement(\"parens\")};if(u.fastpaths!==false&&!/(^[*!]|[/()[\\]{}\"])/.test(t)){let n=false;let s=t.replace(i,((t,e,u,o,s,r)=>{if(o===\"\\\\\"){n=true;return t}if(o===\"?\"){if(e){return e+o+(s?H.repeat(s.length):\"\")}if(r===0){return O+(s?H.repeat(s.length):\"\")}return H.repeat(u.length)}if(o===\".\"){return h.repeat(u.length)}if(o===\"*\"){if(e){return e+o+(s?k:\"\")}return k}return e?t:`\\\\${t}`}));if(n===true){if(u.unescape===true){s=s.replace(/\\\\/g,\"\")}else{s=s.replace(/\\\\+/g,(t=>t.length%2===0?\"\\\\\\\\\":t?\"\\\\\":\"\"))}}if(s===t&&u.contains===true){m.output=t;return m}m.output=o.wrapOutput(s,m,e);return m}while(!eos()){G=M();if(G===\"\\0\"){continue}if(G===\"\\\\\"){const t=D();if(t===\"/\"&&u.bash!==true){continue}if(t===\".\"||t===\";\"){continue}if(!t){G+=\"\\\\\";push({type:\"text\",value:G});continue}const e=/^\\\\+/.exec(remaining());let n=0;if(e&&e[0].length>2){n=e[0].length;m.index+=n;if(n%2!==0){G+=\"\\\\\"}}if(u.unescape===true){G=M()}else{G+=M()}if(m.brackets===0){push({type:\"text\",value:G});continue}}if(m.brackets>0&&(G!==\"]\"||B.value===\"[\"||B.value===\"[^\")){if(u.posix!==false&&G===\":\"){const t=B.value.slice(1);if(t.includes(\"[\")){B.posix=true;if(t.includes(\":\")){const t=B.value.lastIndexOf(\"[\");const e=B.value.slice(0,t);const u=B.value.slice(t+2);const n=r[u];if(n){B.value=e+n;m.backtrack=true;M();if(!f.output&&A.indexOf(B)===1){f.output=C}continue}}}}if(G===\"[\"&&D()!==\":\"||G===\"-\"&&D()===\"]\"){G=`\\\\${G}`}if(G===\"]\"&&(B.value===\"[\"||B.value===\"[^\")){G=`\\\\${G}`}if(u.posix===true&&G===\"!\"&&B.value===\"[\"){G=\"^\"}B.value+=G;append({value:G});continue}if(m.quotes===1&&G!=='\"'){G=o.escapeRegex(G);B.value+=G;append({value:G});continue}if(G==='\"'){m.quotes=m.quotes===1?0:1;if(u.keepQuotes===true){push({type:\"text\",value:G})}continue}if(G===\"(\"){increment(\"parens\");push({type:\"paren\",value:G});continue}if(G===\")\"){if(m.parens===0&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"(\"))}const t=w[w.length-1];if(t&&m.parens===t.parens+1){extglobClose(w.pop());continue}push({type:\"paren\",value:G,output:m.parens?\")\":\"\\\\)\"});decrement(\"parens\");continue}if(G===\"[\"){if(u.nobracket===true||!remaining().includes(\"]\")){if(u.nobracket!==true&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"closing\",\"]\"))}G=`\\\\${G}`}else{increment(\"brackets\")}push({type:\"bracket\",value:G});continue}if(G===\"]\"){if(u.nobracket===true||B&&B.type===\"bracket\"&&B.value.length===1){push({type:\"text\",value:G,output:`\\\\${G}`});continue}if(m.brackets===0){if(u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"[\"))}push({type:\"text\",value:G,output:`\\\\${G}`});continue}decrement(\"brackets\");const t=B.value.slice(1);if(B.posix!==true&&t[0]===\"^\"&&!t.includes(\"/\")){G=`/${G}`}B.value+=G;append({value:G});if(u.literalBrackets===false||o.hasRegexChars(t)){continue}const e=o.escapeRegex(B.value);m.output=m.output.slice(0,-B.value.length);if(u.literalBrackets===true){m.output+=e;B.value=e;continue}B.value=`(${_}${e}|${B.value})`;m.output+=B.value;continue}if(G===\"{\"&&u.nobrace!==true){increment(\"braces\");const t={type:\"brace\",value:G,output:\"(\",outputIndex:m.output.length,tokensIndex:m.tokens.length};N.push(t);push(t);continue}if(G===\"}\"){const t=N[N.length-1];if(u.nobrace===true||!t){push({type:\"text\",value:G,output:G});continue}let e=\")\";if(t.dots===true){const t=A.slice();const n=[];for(let e=t.length-1;e>=0;e--){A.pop();if(t[e].type===\"brace\"){break}if(t[e].type!==\"dots\"){n.unshift(t[e].value)}}e=expandRange(n,u);m.backtrack=true}if(t.comma!==true&&t.dots!==true){const u=m.output.slice(0,t.outputIndex);const n=m.tokens.slice(t.tokensIndex);t.value=t.output=\"\\\\{\";G=e=\"\\\\}\";m.output=u;for(const t of n){m.output+=t.output||t.value}}push({type:\"brace\",value:G,output:e});decrement(\"braces\");N.pop();continue}if(G===\"|\"){if(w.length>0){w[w.length-1].conditions++}push({type:\"text\",value:G});continue}if(G===\",\"){let t=G;const e=N[N.length-1];if(e&&I[I.length-1]===\"braces\"){e.comma=true;t=\"|\"}push({type:\"comma\",value:G,output:t});continue}if(G===\"/\"){if(B.type===\"dot\"&&m.index===m.start+1){m.start=m.index+1;m.consumed=\"\";m.output=\"\";A.pop();B=f;continue}push({type:\"slash\",value:G,output:b});continue}if(G===\".\"){if(m.braces>0&&B.type===\"dot\"){if(B.value===\".\")B.output=h;const t=N[N.length-1];B.type=\"dots\";B.output+=G;B.value+=G;t.dots=true;continue}if(m.braces+m.parens===0&&B.type!==\"bos\"&&B.type!==\"slash\"){push({type:\"text\",value:G,output:h});continue}push({type:\"dot\",value:G,output:h});continue}if(G===\"?\"){const t=B&&B.value===\"(\";if(!t&&u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"qmark\",G);continue}if(B&&B.type===\"paren\"){const t=D();let e=G;if(B.value===\"(\"&&!/[!=<:]/.test(t)||t===\"<\"&&!/<([!=]|\\w+>)/.test(remaining())){e=`\\\\${G}`}push({type:\"text\",value:G,output:e});continue}if(u.dot!==true&&(B.type===\"slash\"||B.type===\"bos\")){push({type:\"qmark\",value:G,output:v});continue}push({type:\"qmark\",value:G,output:H});continue}if(G===\"!\"){if(u.noextglob!==true&&D()===\"(\"){if(D(2)!==\"?\"||!/[!=<:]/.test(D(3))){extglobOpen(\"negate\",G);continue}}if(u.nonegate!==true&&m.index===0){negate();continue}}if(G===\"+\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"plus\",G);continue}if(B&&B.value===\"(\"||u.regex===false){push({type:\"plus\",value:G,output:g});continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\"||B.type===\"brace\")||m.parens>0){push({type:\"plus\",value:G});continue}push({type:\"plus\",value:g});continue}if(G===\"@\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){push({type:\"at\",extglob:true,value:G,output:\"\"});continue}push({type:\"text\",value:G});continue}if(G!==\"*\"){if(G===\"$\"||G===\"^\"){G=`\\\\${G}`}const t=a.exec(remaining());if(t){G+=t[0];m.index+=t[0].length}push({type:\"text\",value:G});continue}if(B&&(B.type===\"globstar\"||B.star===true)){B.type=\"star\";B.star=true;B.value+=G;B.output=k;m.backtrack=true;m.globstar=true;consume(G);continue}let e=remaining();if(u.noextglob!==true&&/^\\([^?]/.test(e)){extglobOpen(\"star\",G);continue}if(B.type===\"star\"){if(u.noglobstar===true){consume(G);continue}const n=B.prev;const o=n.prev;const s=n.type===\"slash\"||n.type===\"bos\";const r=o&&(o.type===\"star\"||o.type===\"globstar\");if(u.bash===true&&(!s||e[0]&&e[0]!==\"/\")){push({type:\"star\",value:G,output:\"\"});continue}const a=m.braces>0&&(n.type===\"comma\"||n.type===\"brace\");const i=w.length&&(n.type===\"pipe\"||n.type===\"paren\");if(!s&&n.type!==\"paren\"&&!a&&!i){push({type:\"star\",value:G,output:\"\"});continue}while(e.slice(0,3)===\"/**\"){const u=t[m.index+4];if(u&&u!==\"/\"){break}e=e.slice(3);consume(\"/**\",3)}if(n.type===\"bos\"&&eos()){B.type=\"globstar\";B.value+=G;B.output=globstar(u);m.output=B.output;m.globstar=true;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&!r&&eos()){m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=globstar(u)+(u.strictSlashes?\")\":\"|$)\");B.value+=G;m.globstar=true;m.output+=n.output+B.output;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&e[0]===\"/\"){const t=e[1]!==void 0?\"|$\":\"\";m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=`${globstar(u)}${b}|${b}${t})`;B.value+=G;m.output+=n.output+B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}if(n.type===\"bos\"&&e[0]===\"/\"){B.type=\"globstar\";B.value+=G;B.output=`(?:^|${b}|${globstar(u)}${b})`;m.output=B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}m.output=m.output.slice(0,-B.output.length);B.type=\"globstar\";B.output=globstar(u);B.value+=G;m.output+=B.output;m.globstar=true;consume(G);continue}const n={type:\"star\",value:G,output:k};if(u.bash===true){n.output=\".*?\";if(B.type===\"bos\"||B.type===\"slash\"){n.output=T+n.output}push(n);continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\")&&u.regex===true){n.output=G;push(n);continue}if(m.index===m.start||B.type===\"slash\"||B.type===\"dot\"){if(B.type===\"dot\"){m.output+=x;B.output+=x}else if(u.dot===true){m.output+=S;B.output+=S}else{m.output+=T;B.output+=T}if(D()!==\"*\"){m.output+=C;B.output+=C}}push(n)}while(m.brackets>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"]\"));m.output=o.escapeLast(m.output,\"[\");decrement(\"brackets\")}while(m.parens>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\")\"));m.output=o.escapeLast(m.output,\"(\");decrement(\"parens\")}while(m.braces>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"}\"));m.output=o.escapeLast(m.output,\"{\");decrement(\"braces\")}if(u.strictSlashes!==true&&(B.type===\"star\"||B.type===\"bracket\")){push({type:\"maybe_slash\",value:\"\",output:`${b}?`})}if(m.backtrack===true){m.output=\"\";for(const t of m.tokens){m.output+=t.output!=null?t.output:t.value;if(t.suffix){m.output+=t.suffix}}}return m};parse.fastpaths=(t,e)=>{const u={...e};const r=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;const a=t.length;if(a>r){throw new SyntaxError(`Input length: ${a}, exceeds maximum allowed length: ${r}`)}t=c[t]||t;const{DOT_LITERAL:i,SLASH_LITERAL:p,ONE_CHAR:l,DOTS_SLASH:f,NO_DOT:A,NO_DOTS:_,NO_DOTS_SLASH:R,STAR:E,START_ANCHOR:h}=n.globChars(u.windows);const g=u.dot?_:A;const b=u.dot?R:A;const C=u.capture?\"\":\"?:\";const y={negated:false,prefix:\"\"};let $=u.bash===true?\".*?\":E;if(u.capture){$=`(${$})`}const globstar=t=>{if(t.noglobstar===true)return $;return`(${C}(?:(?!${h}${t.dot?f:i}).)*?)`};const create=t=>{switch(t){case\"*\":return`${g}${l}${$}`;case\".*\":return`${i}${l}${$}`;case\"*.*\":return`${g}${$}${i}${l}${$}`;case\"*/*\":return`${g}${$}${p}${l}${b}${$}`;case\"**\":return g+globstar(u);case\"**/*\":return`(?:${g}${globstar(u)}${p})?${b}${l}${$}`;case\"**/*.*\":return`(?:${g}${globstar(u)}${p})?${b}${$}${i}${l}${$}`;case\"**/.*\":return`(?:${g}${globstar(u)}${p})?${i}${l}${$}`;default:{const e=/^(.*?)\\.(\\w+)$/.exec(t);if(!e)return;const u=create(e[1]);if(!u)return;return u+i+e[2]}}};const x=o.removePrefix(t,y);let S=create(x);if(S&&u.strictSlashes!==true){S+=`${p}?`}return S};t.exports=parse},510:(t,e,u)=>{const n=u(716);const o=u(697);const s=u(96);const r=u(154);const isObject=t=>t&&typeof t===\"object\"&&!Array.isArray(t);const picomatch=(t,e,u=false)=>{if(Array.isArray(t)){const n=t.map((t=>picomatch(t,e,u)));const arrayMatcher=t=>{for(const e of n){const u=e(t);if(u)return u}return false};return arrayMatcher}const n=isObject(t)&&t.tokens&&t.input;if(t===\"\"||typeof t!==\"string\"&&!n){throw new TypeError(\"Expected pattern to be a non-empty string\")}const o=e||{};const s=o.windows;const r=n?picomatch.compileRe(t,e):picomatch.makeRe(t,e,false,true);const a=r.state;delete r.state;let isIgnored=()=>false;if(o.ignore){const t={...e,ignore:null,onMatch:null,onResult:null};isIgnored=picomatch(o.ignore,t,u)}const matcher=(u,n=false)=>{const{isMatch:i,match:c,output:p}=picomatch.test(u,r,e,{glob:t,posix:s});const l={glob:t,state:a,regex:r,posix:s,input:u,output:p,match:c,isMatch:i};if(typeof o.onResult===\"function\"){o.onResult(l)}if(i===false){l.isMatch=false;return n?l:false}if(isIgnored(u)){if(typeof o.onIgnore===\"function\"){o.onIgnore(l)}l.isMatch=false;return n?l:false}if(typeof o.onMatch===\"function\"){o.onMatch(l)}return n?l:true};if(u){matcher.state=a}return matcher};picomatch.test=(t,e,u,{glob:n,posix:o}={})=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected input to be a string\")}if(t===\"\"){return{isMatch:false,output:\"\"}}const r=u||{};const a=r.format||(o?s.toPosixSlashes:null);let i=t===n;let c=i&&a?a(t):t;if(i===false){c=a?a(t):t;i=c===n}if(i===false||r.capture===true){if(r.matchBase===true||r.basename===true){i=picomatch.matchBase(t,e,u,o)}else{i=e.exec(c)}}return{isMatch:Boolean(i),match:i,output:c}};picomatch.matchBase=(t,e,u)=>{const n=e instanceof RegExp?e:picomatch.makeRe(e,u);return n.test(s.basename(t))};picomatch.isMatch=(t,e,u)=>picomatch(e,u)(t);picomatch.parse=(t,e)=>{if(Array.isArray(t))return t.map((t=>picomatch.parse(t,e)));return o(t,{...e,fastpaths:false})};picomatch.scan=(t,e)=>n(t,e);picomatch.compileRe=(t,e,u=false,n=false)=>{if(u===true){return t.output}const o=e||{};const s=o.contains?\"\":\"^\";const r=o.contains?\"\":\"$\";let a=`${s}(?:${t.output})${r}`;if(t&&t.negated===true){a=`^(?!${a}).*$`}const i=picomatch.toRegex(a,e);if(n===true){i.state=t}return i};picomatch.makeRe=(t,e={},u=false,n=false)=>{if(!t||typeof t!==\"string\"){throw new TypeError(\"Expected a non-empty string\")}let s={negated:false,fastpaths:true};if(e.fastpaths!==false&&(t[0]===\".\"||t[0]===\"*\")){s.output=o.fastpaths(t,e)}if(!s.output){s=o(t,e)}return picomatch.compileRe(s,e,u,n)};picomatch.toRegex=(t,e)=>{try{const u=e||{};return new RegExp(t,u.flags||(u.nocase?\"i\":\"\"))}catch(t){if(e&&e.debug===true)throw t;return/$^/}};picomatch.constants=r;t.exports=picomatch},716:(t,e,u)=>{const n=u(96);const{CHAR_ASTERISK:o,CHAR_AT:s,CHAR_BACKWARD_SLASH:r,CHAR_COMMA:a,CHAR_DOT:i,CHAR_EXCLAMATION_MARK:c,CHAR_FORWARD_SLASH:p,CHAR_LEFT_CURLY_BRACE:l,CHAR_LEFT_PARENTHESES:f,CHAR_LEFT_SQUARE_BRACKET:A,CHAR_PLUS:_,CHAR_QUESTION_MARK:R,CHAR_RIGHT_CURLY_BRACE:E,CHAR_RIGHT_PARENTHESES:h,CHAR_RIGHT_SQUARE_BRACKET:g}=u(154);const isPathSeparator=t=>t===p||t===r;const depth=t=>{if(t.isPrefix!==true){t.depth=t.isGlobstar?Infinity:1}};const scan=(t,e)=>{const u=e||{};const b=t.length-1;const C=u.parts===true||u.scanToEnd===true;const y=[];const $=[];const x=[];let S=t;let H=-1;let v=0;let d=0;let L=false;let T=false;let O=false;let k=false;let m=false;let w=false;let N=false;let I=false;let B=false;let G=false;let D=0;let M;let P;let K={value:\"\",depth:0,isGlob:false};const eos=()=>H>=b;const peek=()=>S.charCodeAt(H+1);const advance=()=>{M=P;return S.charCodeAt(++H)};while(H<b){P=advance();let t;if(P===r){N=K.backslashes=true;P=advance();if(P===l){w=true}continue}if(w===true||P===l){D++;while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;advance();continue}if(P===l){D++;continue}if(w!==true&&P===i&&(P=advance())===i){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(w!==true&&P===a){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===E){D--;if(D===0){w=false;L=K.isBrace=true;G=true;break}}}if(C===true){continue}break}if(P===p){y.push(H);$.push(K);K={value:\"\",depth:0,isGlob:false};if(G===true)continue;if(M===i&&H===v+1){v+=2;continue}d=H+1;continue}if(u.noext!==true){const t=P===_||P===s||P===o||P===R||P===c;if(t===true&&peek()===f){O=K.isGlob=true;k=K.isExtglob=true;G=true;if(P===c&&H===v){B=true}if(C===true){while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;P=advance();continue}if(P===h){O=K.isGlob=true;G=true;break}}continue}break}}if(P===o){if(M===o)m=K.isGlobstar=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===R){O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===A){while(eos()!==true&&(t=advance())){if(t===r){N=K.backslashes=true;advance();continue}if(t===g){T=K.isBracket=true;O=K.isGlob=true;G=true;break}}if(C===true){continue}break}if(u.nonegate!==true&&P===c&&H===v){I=K.negated=true;v++;continue}if(u.noparen!==true&&P===f){O=K.isGlob=true;if(C===true){while(eos()!==true&&(P=advance())){if(P===f){N=K.backslashes=true;P=advance();continue}if(P===h){G=true;break}}continue}break}if(O===true){G=true;if(C===true){continue}break}}if(u.noext===true){k=false;O=false}let U=S;let X=\"\";let F=\"\";if(v>0){X=S.slice(0,v);S=S.slice(v);d-=v}if(U&&O===true&&d>0){U=S.slice(0,d);F=S.slice(d)}else if(O===true){U=\"\";F=S}else{U=S}if(U&&U!==\"\"&&U!==\"/\"&&U!==S){if(isPathSeparator(U.charCodeAt(U.length-1))){U=U.slice(0,-1)}}if(u.unescape===true){if(F)F=n.removeBackslashes(F);if(U&&N===true){U=n.removeBackslashes(U)}}const Q={prefix:X,input:t,start:v,base:U,glob:F,isBrace:L,isBracket:T,isGlob:O,isExtglob:k,isGlobstar:m,negated:I,negatedExtglob:B};if(u.tokens===true){Q.maxDepth=0;if(!isPathSeparator(P)){$.push(K)}Q.tokens=$}if(u.parts===true||u.tokens===true){let e;for(let n=0;n<y.length;n++){const o=e?e+1:v;const s=y[n];const r=t.slice(o,s);if(u.tokens){if(n===0&&v!==0){$[n].isPrefix=true;$[n].value=X}else{$[n].value=r}depth($[n]);Q.maxDepth+=$[n].depth}if(n!==0||r!==\"\"){x.push(r)}e=s}if(e&&e+1<t.length){const n=t.slice(e+1);x.push(n);if(u.tokens){$[$.length-1].value=n;depth($[$.length-1]);Q.maxDepth+=$[$.length-1].depth}}Q.slashes=y;Q.parts=x}return Q};t.exports=scan},96:(t,e,u)=>{const{REGEX_BACKSLASH:n,REGEX_REMOVE_BACKSLASH:o,REGEX_SPECIAL_CHARS:s,REGEX_SPECIAL_CHARS_GLOBAL:r}=u(154);e.isObject=t=>t!==null&&typeof t===\"object\"&&!Array.isArray(t);e.hasRegexChars=t=>s.test(t);e.isRegexChar=t=>t.length===1&&e.hasRegexChars(t);e.escapeRegex=t=>t.replace(r,\"\\\\$1\");e.toPosixSlashes=t=>t.replace(n,\"/\");e.removeBackslashes=t=>t.replace(o,(t=>t===\"\\\\\"?\"\":t));e.escapeLast=(t,u,n)=>{const o=t.lastIndexOf(u,n);if(o===-1)return t;if(t[o-1]===\"\\\\\")return e.escapeLast(t,u,o-1);return`${t.slice(0,o)}\\\\${t.slice(o)}`};e.removePrefix=(t,e={})=>{let u=t;if(u.startsWith(\"./\")){u=u.slice(2);e.prefix=\"./\"}return u};e.wrapOutput=(t,e={},u={})=>{const n=u.contains?\"\":\"^\";const o=u.contains?\"\":\"$\";let s=`${n}(?:${t})${o}`;if(e.negated===true){s=`(?:^(?!${s}).*$)`}return s};e.basename=(t,{windows:e}={})=>{const u=t.split(e?/[\\\\/]/:\"/\");const n=u[u.length-1];if(n===\"\"){return u[u.length-2]}return n}}};var e={};function __nccwpck_require__(u){var n=e[u];if(n!==undefined){return n.exports}var o=e[u]={exports:{}};var s=true;try{t[u](o,o.exports,__nccwpck_require__);s=false}finally{if(s)delete e[u]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var u=__nccwpck_require__(170);module.exports=u})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGljb21hdGNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUEsTUFBTSxhQUFhLE9BQU8sY0FBYyxlQUFlLHFCQUFxQix1REFBdUQseUNBQXlDLGtDQUFrQyxVQUFVLE9BQU8sZ0JBQWdCLE9BQU8sV0FBVyxPQUFPLE9BQU8sb0JBQW9CLGNBQWMsZ0NBQWdDLGlEQUFpRCxHQUFHLDBCQUEwQixnQkFBZ0IsMkJBQTJCLG9CQUFvQixTQUFTLGdCQUFnQixhQUFhLEVBQUUsR0FBRyxjQUFjLGNBQWMsY0FBYyxjQUFjLGdCQUFnQixlQUFlLGNBQWMsRUFBRSxLQUFLLGdCQUFnQixFQUFFLEdBQUcsV0FBVyxHQUFHLElBQUksRUFBRSxFQUFFLEVBQUUsY0FBYyxFQUFFLEdBQUcsY0FBYyxFQUFFLEVBQUUsRUFBRSxHQUFHLGNBQWMsR0FBRyxJQUFJLEVBQUUsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLFdBQVcsRUFBRSxJQUFJLFlBQVksU0FBUyx3TUFBd00sU0FBUyx1QkFBdUIsRUFBRSxtQkFBbUIsRUFBRSxrQkFBa0IsR0FBRyxJQUFJLE1BQU0sRUFBRSxtQkFBbUIsRUFBRSx1QkFBdUIsRUFBRSxJQUFJLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMkJBQTJCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEVBQUUseUJBQXlCLEVBQUUsc0JBQXNCLEVBQUUsZ0JBQWdCLFNBQVMseUxBQXlMLGFBQWEsRUFBRSw4RUFBOEUsV0FBVyxzRUFBc0UscURBQXFELHlDQUF5QyxnR0FBZ0csNEVBQTRFLHVDQUF1QyxtM0JBQW0zQixPQUFPLEtBQUss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Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTQuMi4xX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjFfc2Fzc0AxLjc3LjIvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9waWNvbWF0Y2gvaW5kZXguanM/NWI1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgdD17MTcwOih0LGUsdSk9Pntjb25zdCBuPXUoNTEwKTtjb25zdCBpc1dpbmRvd3M9KCk9PntpZih0eXBlb2YgbmF2aWdhdG9yIT09XCJ1bmRlZmluZWRcIiYmbmF2aWdhdG9yLnBsYXRmb3JtKXtjb25zdCB0PW5hdmlnYXRvci5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO3JldHVybiB0PT09XCJ3aW4zMlwifHx0PT09XCJ3aW5kb3dzXCJ9aWYodHlwZW9mIHByb2Nlc3MhPT1cInVuZGVmaW5lZFwiJiZwcm9jZXNzLnBsYXRmb3JtKXtyZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybT09PVwid2luMzJcIn1yZXR1cm4gZmFsc2V9O2Z1bmN0aW9uIHBpY29tYXRjaCh0LGUsdT1mYWxzZSl7aWYoZSYmKGUud2luZG93cz09PW51bGx8fGUud2luZG93cz09PXVuZGVmaW5lZCkpe2U9ey4uLmUsd2luZG93czppc1dpbmRvd3MoKX19cmV0dXJuIG4odCxlLHUpfU9iamVjdC5hc3NpZ24ocGljb21hdGNoLG4pO3QuZXhwb3J0cz1waWNvbWF0Y2h9LDE1NDp0PT57Y29uc3QgZT1cIlxcXFxcXFxcL1wiO2NvbnN0IHU9YFteJHtlfV1gO2NvbnN0IG49XCJcXFxcLlwiO2NvbnN0IG89XCJcXFxcK1wiO2NvbnN0IHM9XCJcXFxcP1wiO2NvbnN0IHI9XCJcXFxcL1wiO2NvbnN0IGE9XCIoPz0uKVwiO2NvbnN0IGk9XCJbXi9dXCI7Y29uc3QgYz1gKD86JHtyfXwkKWA7Y29uc3QgcD1gKD86Xnwke3J9KWA7Y29uc3QgbD1gJHtufXsxLDJ9JHtjfWA7Y29uc3QgZj1gKD8hJHtufSlgO2NvbnN0IEE9YCg/ISR7cH0ke2x9KWA7Y29uc3QgXz1gKD8hJHtufXswLDF9JHtjfSlgO2NvbnN0IFI9YCg/ISR7bH0pYDtjb25zdCBFPWBbXi4ke3J9XWA7Y29uc3QgaD1gJHtpfSo/YDtjb25zdCBnPVwiL1wiO2NvbnN0IGI9e0RPVF9MSVRFUkFMOm4sUExVU19MSVRFUkFMOm8sUU1BUktfTElURVJBTDpzLFNMQVNIX0xJVEVSQUw6cixPTkVfQ0hBUjphLFFNQVJLOmksRU5EX0FOQ0hPUjpjLERPVFNfU0xBU0g6bCxOT19ET1Q6ZixOT19ET1RTOkEsTk9fRE9UX1NMQVNIOl8sTk9fRE9UU19TTEFTSDpSLFFNQVJLX05PX0RPVDpFLFNUQVI6aCxTVEFSVF9BTkNIT1I6cCxTRVA6Z307Y29uc3QgQz17Li4uYixTTEFTSF9MSVRFUkFMOmBbJHtlfV1gLFFNQVJLOnUsU1RBUjpgJHt1fSo/YCxET1RTX1NMQVNIOmAke259ezEsMn0oPzpbJHtlfV18JClgLE5PX0RPVDpgKD8hJHtufSlgLE5PX0RPVFM6YCg/ISg/Ol58WyR7ZX1dKSR7bn17MSwyfSg/Olske2V9XXwkKSlgLE5PX0RPVF9TTEFTSDpgKD8hJHtufXswLDF9KD86WyR7ZX1dfCQpKWAsTk9fRE9UU19TTEFTSDpgKD8hJHtufXsxLDJ9KD86WyR7ZX1dfCQpKWAsUU1BUktfTk9fRE9UOmBbXi4ke2V9XWAsU1RBUlRfQU5DSE9SOmAoPzpefFske2V9XSlgLEVORF9BTkNIT1I6YCg/Olske2V9XXwkKWAsU0VQOlwiXFxcXFwifTtjb25zdCB5PXthbG51bTpcImEtekEtWjAtOVwiLGFscGhhOlwiYS16QS1aXCIsYXNjaWk6XCJcXFxceDAwLVxcXFx4N0ZcIixibGFuazpcIiBcXFxcdFwiLGNudHJsOlwiXFxcXHgwMC1cXFxceDFGXFxcXHg3RlwiLGRpZ2l0OlwiMC05XCIsZ3JhcGg6XCJcXFxceDIxLVxcXFx4N0VcIixsb3dlcjpcImEtelwiLHByaW50OlwiXFxcXHgyMC1cXFxceDdFIFwiLHB1bmN0OlwiXFxcXC0hXFxcIiMkJSYnKClcXFxcKissLi86Ozw9Pj9AW1xcXFxdXl9ge3x9flwiLHNwYWNlOlwiIFxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGZcIix1cHBlcjpcIkEtWlwiLHdvcmQ6XCJBLVphLXowLTlfXCIseGRpZ2l0OlwiQS1GYS1mMC05XCJ9O3QuZXhwb3J0cz17TUFYX0xFTkdUSDoxMDI0KjY0LFBPU0lYX1JFR0VYX1NPVVJDRTp5LFJFR0VYX0JBQ0tTTEFTSDovXFxcXCg/IVsqKz9eJHt9KHwpW1xcXV0pL2csUkVHRVhfTk9OX1NQRUNJQUxfQ0hBUlM6L15bXkAhW1xcXS4sJCorP157fSgpfFxcXFwvXSsvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6L1stKis/Ll4ke30ofClbXFxdXS8sUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGOi8oXFxcXD8pKChcXFcpKFxcMyopKS9nLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOi8oWy0qKz8uXiR7fSh8KVtcXF1dKS9nLFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6Lyg/OlxcWy4qP1teXFxcXF1cXF18XFxcXCg/PS4pKS9nLFJFUExBQ0VNRU5UUzp7XCIqKipcIjpcIipcIixcIioqLyoqXCI6XCIqKlwiLFwiKiovKiovKipcIjpcIioqXCJ9LENIQVJfMDo0OCxDSEFSXzk6NTcsQ0hBUl9VUFBFUkNBU0VfQTo2NSxDSEFSX0xPV0VSQ0FTRV9BOjk3LENIQVJfVVBQRVJDQVNFX1o6OTAsQ0hBUl9MT1dFUkNBU0VfWjoxMjIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOjQwLENIQVJfUklHSFRfUEFSRU5USEVTRVM6NDEsQ0hBUl9BU1RFUklTSzo0MixDSEFSX0FNUEVSU0FORDozOCxDSEFSX0FUOjY0LENIQVJfQkFDS1dBUkRfU0xBU0g6OTIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46MTMsQ0hBUl9DSVJDVU1GTEVYX0FDQ0VOVDo5NCxDSEFSX0NPTE9OOjU4LENIQVJfQ09NTUE6NDQsQ0hBUl9ET1Q6NDYsQ0hBUl9ET1VCTEVfUVVPVEU6MzQsQ0hBUl9FUVVBTDo2MSxDSEFSX0VYQ0xBTUFUSU9OX01BUks6MzMsQ0hBUl9GT1JNX0ZFRUQ6MTIsQ0hBUl9GT1JXQVJEX1NMQVNIOjQ3LENIQVJfR1JBVkVfQUNDRU5UOjk2LENIQVJfSEFTSDozNSxDSEFSX0hZUEhFTl9NSU5VUzo0NSxDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDo2MCxDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6MTIzLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDo5MSxDSEFSX0xJTkVfRkVFRDoxMCxDSEFSX05PX0JSRUFLX1NQQUNFOjE2MCxDSEFSX1BFUkNFTlQ6MzcsQ0hBUl9QTFVTOjQzLENIQVJfUVVFU1RJT05fTUFSSzo2MyxDSEFSX1JJR0hUX0FOR0xFX0JSQUNLRVQ6NjIsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRToxMjUsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDo5MyxDSEFSX1NFTUlDT0xPTjo1OSxDSEFSX1NJTkdMRV9RVU9URTozOSxDSEFSX1NQQUNFOjMyLENIQVJfVEFCOjksQ0hBUl9VTkRFUlNDT1JFOjk1LENIQVJfVkVSVElDQUxfTElORToxMjQsQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0U6NjUyNzksZXh0Z2xvYkNoYXJzKHQpe3JldHVybntcIiFcIjp7dHlwZTpcIm5lZ2F0ZVwiLG9wZW46XCIoPzooPyEoPzpcIixjbG9zZTpgKSkke3QuU1RBUn0pYH0sXCI/XCI6e3R5cGU6XCJxbWFya1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIik/XCJ9LFwiK1wiOnt0eXBlOlwicGx1c1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIikrXCJ9LFwiKlwiOnt0eXBlOlwic3RhclwiLG9wZW46XCIoPzpcIixjbG9zZTpcIikqXCJ9LFwiQFwiOnt0eXBlOlwiYXRcIixvcGVuOlwiKD86XCIsY2xvc2U6XCIpXCJ9fX0sZ2xvYkNoYXJzKHQpe3JldHVybiB0PT09dHJ1ZT9DOmJ9fX0sNjk3Oih0LGUsdSk9Pntjb25zdCBuPXUoMTU0KTtjb25zdCBvPXUoOTYpO2NvbnN0e01BWF9MRU5HVEg6cyxQT1NJWF9SRUdFWF9TT1VSQ0U6cixSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzphLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjppLFJFUExBQ0VNRU5UUzpjfT1uO2NvbnN0IGV4cGFuZFJhbmdlPSh0LGUpPT57aWYodHlwZW9mIGUuZXhwYW5kUmFuZ2U9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBlLmV4cGFuZFJhbmdlKC4uLnQsZSl9dC5zb3J0KCk7Y29uc3QgdT1gWyR7dC5qb2luKFwiLVwiKX1dYDt0cnl7bmV3IFJlZ0V4cCh1KX1jYXRjaChlKXtyZXR1cm4gdC5tYXAoKHQ9Pm8uZXNjYXBlUmVnZXgodCkpKS5qb2luKFwiLi5cIil9cmV0dXJuIHV9O2NvbnN0IHN5bnRheEVycm9yPSh0LGUpPT5gTWlzc2luZyAke3R9OiBcIiR7ZX1cIiAtIHVzZSBcIlxcXFxcXFxcJHtlfVwiIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc2A7Y29uc3QgcGFyc2U9KHQsZSk9PntpZih0eXBlb2YgdCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKX10PWNbdF18fHQ7Y29uc3QgdT17Li4uZX07Y29uc3QgcD10eXBlb2YgdS5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsdS5tYXhMZW5ndGgpOnM7bGV0IGw9dC5sZW5ndGg7aWYobD5wKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtsfSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke3B9YCl9Y29uc3QgZj17dHlwZTpcImJvc1wiLHZhbHVlOlwiXCIsb3V0cHV0OnUucHJlcGVuZHx8XCJcIn07Y29uc3QgQT1bZl07Y29uc3QgXz11LmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgUj1uLmdsb2JDaGFycyh1LndpbmRvd3MpO2NvbnN0IEU9bi5leHRnbG9iQ2hhcnMoUik7Y29uc3R7RE9UX0xJVEVSQUw6aCxQTFVTX0xJVEVSQUw6ZyxTTEFTSF9MSVRFUkFMOmIsT05FX0NIQVI6QyxET1RTX1NMQVNIOnksTk9fRE9UOiQsTk9fRE9UX1NMQVNIOngsTk9fRE9UU19TTEFTSDpTLFFNQVJLOkgsUU1BUktfTk9fRE9UOnYsU1RBUjpkLFNUQVJUX0FOQ0hPUjpMfT1SO2NvbnN0IGdsb2JzdGFyPXQ9PmAoJHtffSg/Oig/ISR7TH0ke3QuZG90P3k6aH0pLikqPylgO2NvbnN0IFQ9dS5kb3Q/XCJcIjokO2NvbnN0IE89dS5kb3Q/SDp2O2xldCBrPXUuYmFzaD09PXRydWU/Z2xvYnN0YXIodSk6ZDtpZih1LmNhcHR1cmUpe2s9YCgke2t9KWB9aWYodHlwZW9mIHUubm9leHQ9PT1cImJvb2xlYW5cIil7dS5ub2V4dGdsb2I9dS5ub2V4dH1jb25zdCBtPXtpbnB1dDp0LGluZGV4Oi0xLHN0YXJ0OjAsZG90OnUuZG90PT09dHJ1ZSxjb25zdW1lZDpcIlwiLG91dHB1dDpcIlwiLHByZWZpeDpcIlwiLGJhY2t0cmFjazpmYWxzZSxuZWdhdGVkOmZhbHNlLGJyYWNrZXRzOjAsYnJhY2VzOjAscGFyZW5zOjAscXVvdGVzOjAsZ2xvYnN0YXI6ZmFsc2UsdG9rZW5zOkF9O3Q9by5yZW1vdmVQcmVmaXgodCxtKTtsPXQubGVuZ3RoO2NvbnN0IHc9W107Y29uc3QgTj1bXTtjb25zdCBJPVtdO2xldCBCPWY7bGV0IEc7Y29uc3QgZW9zPSgpPT5tLmluZGV4PT09bC0xO2NvbnN0IEQ9bS5wZWVrPShlPTEpPT50W20uaW5kZXgrZV07Y29uc3QgTT1tLmFkdmFuY2U9KCk9PnRbKyttLmluZGV4XXx8XCJcIjtjb25zdCByZW1haW5pbmc9KCk9PnQuc2xpY2UobS5pbmRleCsxKTtjb25zdCBjb25zdW1lPSh0PVwiXCIsZT0wKT0+e20uY29uc3VtZWQrPXQ7bS5pbmRleCs9ZX07Y29uc3QgYXBwZW5kPXQ9PnttLm91dHB1dCs9dC5vdXRwdXQhPW51bGw/dC5vdXRwdXQ6dC52YWx1ZTtjb25zdW1lKHQudmFsdWUpfTtjb25zdCBuZWdhdGU9KCk9PntsZXQgdD0xO3doaWxlKEQoKT09PVwiIVwiJiYoRCgyKSE9PVwiKFwifHxEKDMpPT09XCI/XCIpKXtNKCk7bS5zdGFydCsrO3QrK31pZih0JTI9PT0wKXtyZXR1cm4gZmFsc2V9bS5uZWdhdGVkPXRydWU7bS5zdGFydCsrO3JldHVybiB0cnVlfTtjb25zdCBpbmNyZW1lbnQ9dD0+e21bdF0rKztJLnB1c2godCl9O2NvbnN0IGRlY3JlbWVudD10PT57bVt0XS0tO0kucG9wKCl9O2NvbnN0IHB1c2g9dD0+e2lmKEIudHlwZT09PVwiZ2xvYnN0YXJcIil7Y29uc3QgZT1tLmJyYWNlcz4wJiYodC50eXBlPT09XCJjb21tYVwifHx0LnR5cGU9PT1cImJyYWNlXCIpO2NvbnN0IHU9dC5leHRnbG9iPT09dHJ1ZXx8dy5sZW5ndGgmJih0LnR5cGU9PT1cInBpcGVcInx8dC50eXBlPT09XCJwYXJlblwiKTtpZih0LnR5cGUhPT1cInNsYXNoXCImJnQudHlwZSE9PVwicGFyZW5cIiYmIWUmJiF1KXttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC1CLm91dHB1dC5sZW5ndGgpO0IudHlwZT1cInN0YXJcIjtCLnZhbHVlPVwiKlwiO0Iub3V0cHV0PWs7bS5vdXRwdXQrPUIub3V0cHV0fX1pZih3Lmxlbmd0aCYmdC50eXBlIT09XCJwYXJlblwiKXt3W3cubGVuZ3RoLTFdLmlubmVyKz10LnZhbHVlfWlmKHQudmFsdWV8fHQub3V0cHV0KWFwcGVuZCh0KTtpZihCJiZCLnR5cGU9PT1cInRleHRcIiYmdC50eXBlPT09XCJ0ZXh0XCIpe0Iub3V0cHV0PShCLm91dHB1dHx8Qi52YWx1ZSkrdC52YWx1ZTtCLnZhbHVlKz10LnZhbHVlO3JldHVybn10LnByZXY9QjtBLnB1c2godCk7Qj10fTtjb25zdCBleHRnbG9iT3Blbj0odCxlKT0+e2NvbnN0IG49ey4uLkVbZV0sY29uZGl0aW9uczoxLGlubmVyOlwiXCJ9O24ucHJldj1CO24ucGFyZW5zPW0ucGFyZW5zO24ub3V0cHV0PW0ub3V0cHV0O2NvbnN0IG89KHUuY2FwdHVyZT9cIihcIjpcIlwiKStuLm9wZW47aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6dCx2YWx1ZTplLG91dHB1dDptLm91dHB1dD9cIlwiOkN9KTtwdXNoKHt0eXBlOlwicGFyZW5cIixleHRnbG9iOnRydWUsdmFsdWU6TSgpLG91dHB1dDpvfSk7dy5wdXNoKG4pfTtjb25zdCBleHRnbG9iQ2xvc2U9dD0+e2xldCBuPXQuY2xvc2UrKHUuY2FwdHVyZT9cIilcIjpcIlwiKTtsZXQgbztpZih0LnR5cGU9PT1cIm5lZ2F0ZVwiKXtsZXQgcz1rO2lmKHQuaW5uZXImJnQuaW5uZXIubGVuZ3RoPjEmJnQuaW5uZXIuaW5jbHVkZXMoXCIvXCIpKXtzPWdsb2JzdGFyKHUpfWlmKHMhPT1rfHxlb3MoKXx8L15cXCkrJC8udGVzdChyZW1haW5pbmcoKSkpe249dC5jbG9zZT1gKSQpKSR7c31gfWlmKHQuaW5uZXIuaW5jbHVkZXMoXCIqXCIpJiYobz1yZW1haW5pbmcoKSkmJi9eXFwuW15cXFxcLy5dKyQvLnRlc3Qobykpe2NvbnN0IHU9cGFyc2Uobyx7Li4uZSxmYXN0cGF0aHM6ZmFsc2V9KS5vdXRwdXQ7bj10LmNsb3NlPWApJHt1fSkke3N9KWB9aWYodC5wcmV2LnR5cGU9PT1cImJvc1wiKXttLm5lZ2F0ZWRFeHRnbG9iPXRydWV9fXB1c2goe3R5cGU6XCJwYXJlblwiLGV4dGdsb2I6dHJ1ZSx2YWx1ZTpHLG91dHB1dDpufSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpfTtpZih1LmZhc3RwYXRocyE9PWZhbHNlJiYhLyheWyohXXxbLygpW1xcXXt9XCJdKS8udGVzdCh0KSl7bGV0IG49ZmFsc2U7bGV0IHM9dC5yZXBsYWNlKGksKCh0LGUsdSxvLHMscik9PntpZihvPT09XCJcXFxcXCIpe249dHJ1ZTtyZXR1cm4gdH1pZihvPT09XCI/XCIpe2lmKGUpe3JldHVybiBlK28rKHM/SC5yZXBlYXQocy5sZW5ndGgpOlwiXCIpfWlmKHI9PT0wKXtyZXR1cm4gTysocz9ILnJlcGVhdChzLmxlbmd0aCk6XCJcIil9cmV0dXJuIEgucmVwZWF0KHUubGVuZ3RoKX1pZihvPT09XCIuXCIpe3JldHVybiBoLnJlcGVhdCh1Lmxlbmd0aCl9aWYobz09PVwiKlwiKXtpZihlKXtyZXR1cm4gZStvKyhzP2s6XCJcIil9cmV0dXJuIGt9cmV0dXJuIGU/dDpgXFxcXCR7dH1gfSkpO2lmKG49PT10cnVlKXtpZih1LnVuZXNjYXBlPT09dHJ1ZSl7cz1zLnJlcGxhY2UoL1xcXFwvZyxcIlwiKX1lbHNle3M9cy5yZXBsYWNlKC9cXFxcKy9nLCh0PT50Lmxlbmd0aCUyPT09MD9cIlxcXFxcXFxcXCI6dD9cIlxcXFxcIjpcIlwiKSl9fWlmKHM9PT10JiZ1LmNvbnRhaW5zPT09dHJ1ZSl7bS5vdXRwdXQ9dDtyZXR1cm4gbX1tLm91dHB1dD1vLndyYXBPdXRwdXQocyxtLGUpO3JldHVybiBtfXdoaWxlKCFlb3MoKSl7Rz1NKCk7aWYoRz09PVwiXFwwXCIpe2NvbnRpbnVlfWlmKEc9PT1cIlxcXFxcIil7Y29uc3QgdD1EKCk7aWYodD09PVwiL1wiJiZ1LmJhc2ghPT10cnVlKXtjb250aW51ZX1pZih0PT09XCIuXCJ8fHQ9PT1cIjtcIil7Y29udGludWV9aWYoIXQpe0crPVwiXFxcXFwiO3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6R30pO2NvbnRpbnVlfWNvbnN0IGU9L15cXFxcKy8uZXhlYyhyZW1haW5pbmcoKSk7bGV0IG49MDtpZihlJiZlWzBdLmxlbmd0aD4yKXtuPWVbMF0ubGVuZ3RoO20uaW5kZXgrPW47aWYobiUyIT09MCl7Rys9XCJcXFxcXCJ9fWlmKHUudW5lc2NhcGU9PT10cnVlKXtHPU0oKX1lbHNle0crPU0oKX1pZihtLmJyYWNrZXRzPT09MCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9fWlmKG0uYnJhY2tldHM+MCYmKEchPT1cIl1cInx8Qi52YWx1ZT09PVwiW1wifHxCLnZhbHVlPT09XCJbXlwiKSl7aWYodS5wb3NpeCE9PWZhbHNlJiZHPT09XCI6XCIpe2NvbnN0IHQ9Qi52YWx1ZS5zbGljZSgxKTtpZih0LmluY2x1ZGVzKFwiW1wiKSl7Qi5wb3NpeD10cnVlO2lmKHQuaW5jbHVkZXMoXCI6XCIpKXtjb25zdCB0PUIudmFsdWUubGFzdEluZGV4T2YoXCJbXCIpO2NvbnN0IGU9Qi52YWx1ZS5zbGljZSgwLHQpO2NvbnN0IHU9Qi52YWx1ZS5zbGljZSh0KzIpO2NvbnN0IG49clt1XTtpZihuKXtCLnZhbHVlPWUrbjttLmJhY2t0cmFjaz10cnVlO00oKTtpZighZi5vdXRwdXQmJkEuaW5kZXhPZihCKT09PTEpe2Yub3V0cHV0PUN9Y29udGludWV9fX19aWYoRz09PVwiW1wiJiZEKCkhPT1cIjpcInx8Rz09PVwiLVwiJiZEKCk9PT1cIl1cIil7Rz1gXFxcXCR7R31gfWlmKEc9PT1cIl1cIiYmKEIudmFsdWU9PT1cIltcInx8Qi52YWx1ZT09PVwiW15cIikpe0c9YFxcXFwke0d9YH1pZih1LnBvc2l4PT09dHJ1ZSYmRz09PVwiIVwiJiZCLnZhbHVlPT09XCJbXCIpe0c9XCJeXCJ9Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtjb250aW51ZX1pZihtLnF1b3Rlcz09PTEmJkchPT0nXCInKXtHPW8uZXNjYXBlUmVnZXgoRyk7Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09J1wiJyl7bS5xdW90ZXM9bS5xdW90ZXM9PT0xPzA6MTtpZih1LmtlZXBRdW90ZXM9PT10cnVlKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KX1jb250aW51ZX1pZihHPT09XCIoXCIpe2luY3JlbWVudChcInBhcmVuc1wiKTtwdXNoKHt0eXBlOlwicGFyZW5cIix2YWx1ZTpHfSk7Y29udGludWV9aWYoRz09PVwiKVwiKXtpZihtLnBhcmVucz09PTAmJnUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCIoXCIpKX1jb25zdCB0PXdbdy5sZW5ndGgtMV07aWYodCYmbS5wYXJlbnM9PT10LnBhcmVucysxKXtleHRnbG9iQ2xvc2Uody5wb3AoKSk7Y29udGludWV9cHVzaCh7dHlwZTpcInBhcmVuXCIsdmFsdWU6RyxvdXRwdXQ6bS5wYXJlbnM/XCIpXCI6XCJcXFxcKVwifSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpO2NvbnRpbnVlfWlmKEc9PT1cIltcIil7aWYodS5ub2JyYWNrZXQ9PT10cnVlfHwhcmVtYWluaW5nKCkuaW5jbHVkZXMoXCJdXCIpKXtpZih1Lm5vYnJhY2tldCE9PXRydWUmJnUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJdXCIpKX1HPWBcXFxcJHtHfWB9ZWxzZXtpbmNyZW1lbnQoXCJicmFja2V0c1wiKX1wdXNoKHt0eXBlOlwiYnJhY2tldFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCJdXCIpe2lmKHUubm9icmFja2V0PT09dHJ1ZXx8QiYmQi50eXBlPT09XCJicmFja2V0XCImJkIudmFsdWUubGVuZ3RoPT09MSl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpgXFxcXCR7R31gfSk7Y29udGludWV9aWYobS5icmFja2V0cz09PTApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCJbXCIpKX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkcsb3V0cHV0OmBcXFxcJHtHfWB9KTtjb250aW51ZX1kZWNyZW1lbnQoXCJicmFja2V0c1wiKTtjb25zdCB0PUIudmFsdWUuc2xpY2UoMSk7aWYoQi5wb3NpeCE9PXRydWUmJnRbMF09PT1cIl5cIiYmIXQuaW5jbHVkZXMoXCIvXCIpKXtHPWAvJHtHfWB9Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtpZih1LmxpdGVyYWxCcmFja2V0cz09PWZhbHNlfHxvLmhhc1JlZ2V4Q2hhcnModCkpe2NvbnRpbnVlfWNvbnN0IGU9by5lc2NhcGVSZWdleChCLnZhbHVlKTttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC1CLnZhbHVlLmxlbmd0aCk7aWYodS5saXRlcmFsQnJhY2tldHM9PT10cnVlKXttLm91dHB1dCs9ZTtCLnZhbHVlPWU7Y29udGludWV9Qi52YWx1ZT1gKCR7X30ke2V9fCR7Qi52YWx1ZX0pYDttLm91dHB1dCs9Qi52YWx1ZTtjb250aW51ZX1pZihHPT09XCJ7XCImJnUubm9icmFjZSE9PXRydWUpe2luY3JlbWVudChcImJyYWNlc1wiKTtjb25zdCB0PXt0eXBlOlwiYnJhY2VcIix2YWx1ZTpHLG91dHB1dDpcIihcIixvdXRwdXRJbmRleDptLm91dHB1dC5sZW5ndGgsdG9rZW5zSW5kZXg6bS50b2tlbnMubGVuZ3RofTtOLnB1c2godCk7cHVzaCh0KTtjb250aW51ZX1pZihHPT09XCJ9XCIpe2NvbnN0IHQ9TltOLmxlbmd0aC0xXTtpZih1Lm5vYnJhY2U9PT10cnVlfHwhdCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpHfSk7Y29udGludWV9bGV0IGU9XCIpXCI7aWYodC5kb3RzPT09dHJ1ZSl7Y29uc3QgdD1BLnNsaWNlKCk7Y29uc3Qgbj1bXTtmb3IobGV0IGU9dC5sZW5ndGgtMTtlPj0wO2UtLSl7QS5wb3AoKTtpZih0W2VdLnR5cGU9PT1cImJyYWNlXCIpe2JyZWFrfWlmKHRbZV0udHlwZSE9PVwiZG90c1wiKXtuLnVuc2hpZnQodFtlXS52YWx1ZSl9fWU9ZXhwYW5kUmFuZ2Uobix1KTttLmJhY2t0cmFjaz10cnVlfWlmKHQuY29tbWEhPT10cnVlJiZ0LmRvdHMhPT10cnVlKXtjb25zdCB1PW0ub3V0cHV0LnNsaWNlKDAsdC5vdXRwdXRJbmRleCk7Y29uc3Qgbj1tLnRva2Vucy5zbGljZSh0LnRva2Vuc0luZGV4KTt0LnZhbHVlPXQub3V0cHV0PVwiXFxcXHtcIjtHPWU9XCJcXFxcfVwiO20ub3V0cHV0PXU7Zm9yKGNvbnN0IHQgb2Ygbil7bS5vdXRwdXQrPXQub3V0cHV0fHx0LnZhbHVlfX1wdXNoKHt0eXBlOlwiYnJhY2VcIix2YWx1ZTpHLG91dHB1dDplfSk7ZGVjcmVtZW50KFwiYnJhY2VzXCIpO04ucG9wKCk7Y29udGludWV9aWYoRz09PVwifFwiKXtpZih3Lmxlbmd0aD4wKXt3W3cubGVuZ3RoLTFdLmNvbmRpdGlvbnMrK31wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCIsXCIpe2xldCB0PUc7Y29uc3QgZT1OW04ubGVuZ3RoLTFdO2lmKGUmJklbSS5sZW5ndGgtMV09PT1cImJyYWNlc1wiKXtlLmNvbW1hPXRydWU7dD1cInxcIn1wdXNoKHt0eXBlOlwiY29tbWFcIix2YWx1ZTpHLG91dHB1dDp0fSk7Y29udGludWV9aWYoRz09PVwiL1wiKXtpZihCLnR5cGU9PT1cImRvdFwiJiZtLmluZGV4PT09bS5zdGFydCsxKXttLnN0YXJ0PW0uaW5kZXgrMTttLmNvbnN1bWVkPVwiXCI7bS5vdXRwdXQ9XCJcIjtBLnBvcCgpO0I9Zjtjb250aW51ZX1wdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpHLG91dHB1dDpifSk7Y29udGludWV9aWYoRz09PVwiLlwiKXtpZihtLmJyYWNlcz4wJiZCLnR5cGU9PT1cImRvdFwiKXtpZihCLnZhbHVlPT09XCIuXCIpQi5vdXRwdXQ9aDtjb25zdCB0PU5bTi5sZW5ndGgtMV07Qi50eXBlPVwiZG90c1wiO0Iub3V0cHV0Kz1HO0IudmFsdWUrPUc7dC5kb3RzPXRydWU7Y29udGludWV9aWYobS5icmFjZXMrbS5wYXJlbnM9PT0wJiZCLnR5cGUhPT1cImJvc1wiJiZCLnR5cGUhPT1cInNsYXNoXCIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6aH0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJkb3RcIix2YWx1ZTpHLG91dHB1dDpofSk7Y29udGludWV9aWYoRz09PVwiP1wiKXtjb25zdCB0PUImJkIudmFsdWU9PT1cIihcIjtpZighdCYmdS5ub2V4dGdsb2IhPT10cnVlJiZEKCk9PT1cIihcIiYmRCgyKSE9PVwiP1wiKXtleHRnbG9iT3BlbihcInFtYXJrXCIsRyk7Y29udGludWV9aWYoQiYmQi50eXBlPT09XCJwYXJlblwiKXtjb25zdCB0PUQoKTtsZXQgZT1HO2lmKEIudmFsdWU9PT1cIihcIiYmIS9bIT08Ol0vLnRlc3QodCl8fHQ9PT1cIjxcIiYmIS88KFshPV18XFx3Kz4pLy50ZXN0KHJlbWFpbmluZygpKSl7ZT1gXFxcXCR7R31gfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6ZX0pO2NvbnRpbnVlfWlmKHUuZG90IT09dHJ1ZSYmKEIudHlwZT09PVwic2xhc2hcInx8Qi50eXBlPT09XCJib3NcIikpe3B1c2goe3R5cGU6XCJxbWFya1wiLHZhbHVlOkcsb3V0cHV0OnZ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicW1hcmtcIix2YWx1ZTpHLG91dHB1dDpIfSk7Y29udGludWV9aWYoRz09PVwiIVwiKXtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJkQoKT09PVwiKFwiKXtpZihEKDIpIT09XCI/XCJ8fCEvWyE9PDpdLy50ZXN0KEQoMykpKXtleHRnbG9iT3BlbihcIm5lZ2F0ZVwiLEcpO2NvbnRpbnVlfX1pZih1Lm5vbmVnYXRlIT09dHJ1ZSYmbS5pbmRleD09PTApe25lZ2F0ZSgpO2NvbnRpbnVlfX1pZihHPT09XCIrXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCImJkQoMikhPT1cIj9cIil7ZXh0Z2xvYk9wZW4oXCJwbHVzXCIsRyk7Y29udGludWV9aWYoQiYmQi52YWx1ZT09PVwiKFwifHx1LnJlZ2V4PT09ZmFsc2Upe3B1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6RyxvdXRwdXQ6Z30pO2NvbnRpbnVlfWlmKEImJihCLnR5cGU9PT1cImJyYWNrZXRcInx8Qi50eXBlPT09XCJwYXJlblwifHxCLnR5cGU9PT1cImJyYWNlXCIpfHxtLnBhcmVucz4wKXtwdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOkd9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOmd9KTtjb250aW51ZX1pZihHPT09XCJAXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCImJkQoMikhPT1cIj9cIil7cHVzaCh7dHlwZTpcImF0XCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHIT09XCIqXCIpe2lmKEc9PT1cIiRcInx8Rz09PVwiXlwiKXtHPWBcXFxcJHtHfWB9Y29uc3QgdD1hLmV4ZWMocmVtYWluaW5nKCkpO2lmKHQpe0crPXRbMF07bS5pbmRleCs9dFswXS5sZW5ndGh9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiZ2xvYnN0YXJcInx8Qi5zdGFyPT09dHJ1ZSkpe0IudHlwZT1cInN0YXJcIjtCLnN0YXI9dHJ1ZTtCLnZhbHVlKz1HO0Iub3V0cHV0PWs7bS5iYWNrdHJhY2s9dHJ1ZTttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1sZXQgZT1yZW1haW5pbmcoKTtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJi9eXFwoW14/XS8udGVzdChlKSl7ZXh0Z2xvYk9wZW4oXCJzdGFyXCIsRyk7Y29udGludWV9aWYoQi50eXBlPT09XCJzdGFyXCIpe2lmKHUubm9nbG9ic3Rhcj09PXRydWUpe2NvbnN1bWUoRyk7Y29udGludWV9Y29uc3Qgbj1CLnByZXY7Y29uc3Qgbz1uLnByZXY7Y29uc3Qgcz1uLnR5cGU9PT1cInNsYXNoXCJ8fG4udHlwZT09PVwiYm9zXCI7Y29uc3Qgcj1vJiYoby50eXBlPT09XCJzdGFyXCJ8fG8udHlwZT09PVwiZ2xvYnN0YXJcIik7aWYodS5iYXNoPT09dHJ1ZSYmKCFzfHxlWzBdJiZlWzBdIT09XCIvXCIpKXtwdXNoKHt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1jb25zdCBhPW0uYnJhY2VzPjAmJihuLnR5cGU9PT1cImNvbW1hXCJ8fG4udHlwZT09PVwiYnJhY2VcIik7Y29uc3QgaT13Lmxlbmd0aCYmKG4udHlwZT09PVwicGlwZVwifHxuLnR5cGU9PT1cInBhcmVuXCIpO2lmKCFzJiZuLnR5cGUhPT1cInBhcmVuXCImJiFhJiYhaSl7cHVzaCh7dHlwZTpcInN0YXJcIix2YWx1ZTpHLG91dHB1dDpcIlwifSk7Y29udGludWV9d2hpbGUoZS5zbGljZSgwLDMpPT09XCIvKipcIil7Y29uc3QgdT10W20uaW5kZXgrNF07aWYodSYmdSE9PVwiL1wiKXticmVha31lPWUuc2xpY2UoMyk7Y29uc3VtZShcIi8qKlwiLDMpfWlmKG4udHlwZT09PVwiYm9zXCImJmVvcygpKXtCLnR5cGU9XCJnbG9ic3RhclwiO0IudmFsdWUrPUc7Qi5vdXRwdXQ9Z2xvYnN0YXIodSk7bS5vdXRwdXQ9Qi5vdXRwdXQ7bS5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoRyk7Y29udGludWV9aWYobi50eXBlPT09XCJzbGFzaFwiJiZuLnByZXYudHlwZSE9PVwiYm9zXCImJiFyJiZlb3MoKSl7bS5vdXRwdXQ9bS5vdXRwdXQuc2xpY2UoMCwtKG4ub3V0cHV0K0Iub3V0cHV0KS5sZW5ndGgpO24ub3V0cHV0PWAoPzoke24ub3V0cHV0fWA7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLm91dHB1dD1nbG9ic3Rhcih1KSsodS5zdHJpY3RTbGFzaGVzP1wiKVwiOlwifCQpXCIpO0IudmFsdWUrPUc7bS5nbG9ic3Rhcj10cnVlO20ub3V0cHV0Kz1uLm91dHB1dCtCLm91dHB1dDtjb25zdW1lKEcpO2NvbnRpbnVlfWlmKG4udHlwZT09PVwic2xhc2hcIiYmbi5wcmV2LnR5cGUhPT1cImJvc1wiJiZlWzBdPT09XCIvXCIpe2NvbnN0IHQ9ZVsxXSE9PXZvaWQgMD9cInwkXCI6XCJcIjttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC0obi5vdXRwdXQrQi5vdXRwdXQpLmxlbmd0aCk7bi5vdXRwdXQ9YCg/OiR7bi5vdXRwdXR9YDtCLnR5cGU9XCJnbG9ic3RhclwiO0Iub3V0cHV0PWAke2dsb2JzdGFyKHUpfSR7Yn18JHtifSR7dH0pYDtCLnZhbHVlKz1HO20ub3V0cHV0Kz1uLm91dHB1dCtCLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHK00oKSk7cHVzaCh7dHlwZTpcInNsYXNoXCIsdmFsdWU6XCIvXCIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1pZihuLnR5cGU9PT1cImJvc1wiJiZlWzBdPT09XCIvXCIpe0IudHlwZT1cImdsb2JzdGFyXCI7Qi52YWx1ZSs9RztCLm91dHB1dD1gKD86Xnwke2J9fCR7Z2xvYnN0YXIodSl9JHtifSlgO20ub3V0cHV0PUIub3V0cHV0O20uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEcrTSgpKTtwdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpcIi9cIixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfW0ub3V0cHV0PW0ub3V0cHV0LnNsaWNlKDAsLUIub3V0cHV0Lmxlbmd0aCk7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLm91dHB1dD1nbG9ic3Rhcih1KTtCLnZhbHVlKz1HO20ub3V0cHV0Kz1CLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1jb25zdCBuPXt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0Omt9O2lmKHUuYmFzaD09PXRydWUpe24ub3V0cHV0PVwiLio/XCI7aWYoQi50eXBlPT09XCJib3NcInx8Qi50eXBlPT09XCJzbGFzaFwiKXtuLm91dHB1dD1UK24ub3V0cHV0fXB1c2gobik7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiYnJhY2tldFwifHxCLnR5cGU9PT1cInBhcmVuXCIpJiZ1LnJlZ2V4PT09dHJ1ZSl7bi5vdXRwdXQ9RztwdXNoKG4pO2NvbnRpbnVlfWlmKG0uaW5kZXg9PT1tLnN0YXJ0fHxCLnR5cGU9PT1cInNsYXNoXCJ8fEIudHlwZT09PVwiZG90XCIpe2lmKEIudHlwZT09PVwiZG90XCIpe20ub3V0cHV0Kz14O0Iub3V0cHV0Kz14fWVsc2UgaWYodS5kb3Q9PT10cnVlKXttLm91dHB1dCs9UztCLm91dHB1dCs9U31lbHNle20ub3V0cHV0Kz1UO0Iub3V0cHV0Kz1UfWlmKEQoKSE9PVwiKlwiKXttLm91dHB1dCs9QztCLm91dHB1dCs9Q319cHVzaChuKX13aGlsZShtLmJyYWNrZXRzPjApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIl1cIikpO20ub3V0cHV0PW8uZXNjYXBlTGFzdChtLm91dHB1dCxcIltcIik7ZGVjcmVtZW50KFwiYnJhY2tldHNcIil9d2hpbGUobS5wYXJlbnM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiKVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwiKFwiKTtkZWNyZW1lbnQoXCJwYXJlbnNcIil9d2hpbGUobS5icmFjZXM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwifVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwie1wiKTtkZWNyZW1lbnQoXCJicmFjZXNcIil9aWYodS5zdHJpY3RTbGFzaGVzIT09dHJ1ZSYmKEIudHlwZT09PVwic3RhclwifHxCLnR5cGU9PT1cImJyYWNrZXRcIikpe3B1c2goe3R5cGU6XCJtYXliZV9zbGFzaFwiLHZhbHVlOlwiXCIsb3V0cHV0OmAke2J9P2B9KX1pZihtLmJhY2t0cmFjaz09PXRydWUpe20ub3V0cHV0PVwiXCI7Zm9yKGNvbnN0IHQgb2YgbS50b2tlbnMpe20ub3V0cHV0Kz10Lm91dHB1dCE9bnVsbD90Lm91dHB1dDp0LnZhbHVlO2lmKHQuc3VmZml4KXttLm91dHB1dCs9dC5zdWZmaXh9fX1yZXR1cm4gbX07cGFyc2UuZmFzdHBhdGhzPSh0LGUpPT57Y29uc3QgdT17Li4uZX07Y29uc3Qgcj10eXBlb2YgdS5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsdS5tYXhMZW5ndGgpOnM7Y29uc3QgYT10Lmxlbmd0aDtpZihhPnIpe3Rocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoOiAke2F9LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7cn1gKX10PWNbdF18fHQ7Y29uc3R7RE9UX0xJVEVSQUw6aSxTTEFTSF9MSVRFUkFMOnAsT05FX0NIQVI6bCxET1RTX1NMQVNIOmYsTk9fRE9UOkEsTk9fRE9UUzpfLE5PX0RPVFNfU0xBU0g6UixTVEFSOkUsU1RBUlRfQU5DSE9SOmh9PW4uZ2xvYkNoYXJzKHUud2luZG93cyk7Y29uc3QgZz11LmRvdD9fOkE7Y29uc3QgYj11LmRvdD9SOkE7Y29uc3QgQz11LmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgeT17bmVnYXRlZDpmYWxzZSxwcmVmaXg6XCJcIn07bGV0ICQ9dS5iYXNoPT09dHJ1ZT9cIi4qP1wiOkU7aWYodS5jYXB0dXJlKXskPWAoJHskfSlgfWNvbnN0IGdsb2JzdGFyPXQ9PntpZih0Lm5vZ2xvYnN0YXI9PT10cnVlKXJldHVybiAkO3JldHVybmAoJHtDfSg/Oig/ISR7aH0ke3QuZG90P2Y6aX0pLikqPylgfTtjb25zdCBjcmVhdGU9dD0+e3N3aXRjaCh0KXtjYXNlXCIqXCI6cmV0dXJuYCR7Z30ke2x9JHskfWA7Y2FzZVwiLipcIjpyZXR1cm5gJHtpfSR7bH0keyR9YDtjYXNlXCIqLipcIjpyZXR1cm5gJHtnfSR7JH0ke2l9JHtsfSR7JH1gO2Nhc2VcIiovKlwiOnJldHVybmAke2d9JHskfSR7cH0ke2x9JHtifSR7JH1gO2Nhc2VcIioqXCI6cmV0dXJuIGcrZ2xvYnN0YXIodSk7Y2FzZVwiKiovKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2J9JHtsfSR7JH1gO2Nhc2VcIioqLyouKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2J9JHskfSR7aX0ke2x9JHskfWA7Y2FzZVwiKiovLipcIjpyZXR1cm5gKD86JHtnfSR7Z2xvYnN0YXIodSl9JHtwfSk/JHtpfSR7bH0keyR9YDtkZWZhdWx0Ontjb25zdCBlPS9eKC4qPylcXC4oXFx3KykkLy5leGVjKHQpO2lmKCFlKXJldHVybjtjb25zdCB1PWNyZWF0ZShlWzFdKTtpZighdSlyZXR1cm47cmV0dXJuIHUraStlWzJdfX19O2NvbnN0IHg9by5yZW1vdmVQcmVmaXgodCx5KTtsZXQgUz1jcmVhdGUoeCk7aWYoUyYmdS5zdHJpY3RTbGFzaGVzIT09dHJ1ZSl7Uys9YCR7cH0/YH1yZXR1cm4gU307dC5leHBvcnRzPXBhcnNlfSw1MTA6KHQsZSx1KT0+e2NvbnN0IG49dSg3MTYpO2NvbnN0IG89dSg2OTcpO2NvbnN0IHM9dSg5Nik7Y29uc3Qgcj11KDE1NCk7Y29uc3QgaXNPYmplY3Q9dD0+dCYmdHlwZW9mIHQ9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheSh0KTtjb25zdCBwaWNvbWF0Y2g9KHQsZSx1PWZhbHNlKT0+e2lmKEFycmF5LmlzQXJyYXkodCkpe2NvbnN0IG49dC5tYXAoKHQ9PnBpY29tYXRjaCh0LGUsdSkpKTtjb25zdCBhcnJheU1hdGNoZXI9dD0+e2Zvcihjb25zdCBlIG9mIG4pe2NvbnN0IHU9ZSh0KTtpZih1KXJldHVybiB1fXJldHVybiBmYWxzZX07cmV0dXJuIGFycmF5TWF0Y2hlcn1jb25zdCBuPWlzT2JqZWN0KHQpJiZ0LnRva2VucyYmdC5pbnB1dDtpZih0PT09XCJcInx8dHlwZW9mIHQhPT1cInN0cmluZ1wiJiYhbil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpfWNvbnN0IG89ZXx8e307Y29uc3Qgcz1vLndpbmRvd3M7Y29uc3Qgcj1uP3BpY29tYXRjaC5jb21waWxlUmUodCxlKTpwaWNvbWF0Y2gubWFrZVJlKHQsZSxmYWxzZSx0cnVlKTtjb25zdCBhPXIuc3RhdGU7ZGVsZXRlIHIuc3RhdGU7bGV0IGlzSWdub3JlZD0oKT0+ZmFsc2U7aWYoby5pZ25vcmUpe2NvbnN0IHQ9ey4uLmUsaWdub3JlOm51bGwsb25NYXRjaDpudWxsLG9uUmVzdWx0Om51bGx9O2lzSWdub3JlZD1waWNvbWF0Y2goby5pZ25vcmUsdCx1KX1jb25zdCBtYXRjaGVyPSh1LG49ZmFsc2UpPT57Y29uc3R7aXNNYXRjaDppLG1hdGNoOmMsb3V0cHV0OnB9PXBpY29tYXRjaC50ZXN0KHUscixlLHtnbG9iOnQscG9zaXg6c30pO2NvbnN0IGw9e2dsb2I6dCxzdGF0ZTphLHJlZ2V4OnIscG9zaXg6cyxpbnB1dDp1LG91dHB1dDpwLG1hdGNoOmMsaXNNYXRjaDppfTtpZih0eXBlb2Ygby5vblJlc3VsdD09PVwiZnVuY3Rpb25cIil7by5vblJlc3VsdChsKX1pZihpPT09ZmFsc2Upe2wuaXNNYXRjaD1mYWxzZTtyZXR1cm4gbj9sOmZhbHNlfWlmKGlzSWdub3JlZCh1KSl7aWYodHlwZW9mIG8ub25JZ25vcmU9PT1cImZ1bmN0aW9uXCIpe28ub25JZ25vcmUobCl9bC5pc01hdGNoPWZhbHNlO3JldHVybiBuP2w6ZmFsc2V9aWYodHlwZW9mIG8ub25NYXRjaD09PVwiZnVuY3Rpb25cIil7by5vbk1hdGNoKGwpfXJldHVybiBuP2w6dHJ1ZX07aWYodSl7bWF0Y2hlci5zdGF0ZT1hfXJldHVybiBtYXRjaGVyfTtwaWNvbWF0Y2gudGVzdD0odCxlLHUse2dsb2I6bixwb3NpeDpvfT17fSk9PntpZih0eXBlb2YgdCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBpbnB1dCB0byBiZSBhIHN0cmluZ1wiKX1pZih0PT09XCJcIil7cmV0dXJue2lzTWF0Y2g6ZmFsc2Usb3V0cHV0OlwiXCJ9fWNvbnN0IHI9dXx8e307Y29uc3QgYT1yLmZvcm1hdHx8KG8/cy50b1Bvc2l4U2xhc2hlczpudWxsKTtsZXQgaT10PT09bjtsZXQgYz1pJiZhP2EodCk6dDtpZihpPT09ZmFsc2Upe2M9YT9hKHQpOnQ7aT1jPT09bn1pZihpPT09ZmFsc2V8fHIuY2FwdHVyZT09PXRydWUpe2lmKHIubWF0Y2hCYXNlPT09dHJ1ZXx8ci5iYXNlbmFtZT09PXRydWUpe2k9cGljb21hdGNoLm1hdGNoQmFzZSh0LGUsdSxvKX1lbHNle2k9ZS5leGVjKGMpfX1yZXR1cm57aXNNYXRjaDpCb29sZWFuKGkpLG1hdGNoOmksb3V0cHV0OmN9fTtwaWNvbWF0Y2gubWF0Y2hCYXNlPSh0LGUsdSk9Pntjb25zdCBuPWUgaW5zdGFuY2VvZiBSZWdFeHA/ZTpwaWNvbWF0Y2gubWFrZVJlKGUsdSk7cmV0dXJuIG4udGVzdChzLmJhc2VuYW1lKHQpKX07cGljb21hdGNoLmlzTWF0Y2g9KHQsZSx1KT0+cGljb21hdGNoKGUsdSkodCk7cGljb21hdGNoLnBhcnNlPSh0LGUpPT57aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdC5tYXAoKHQ9PnBpY29tYXRjaC5wYXJzZSh0LGUpKSk7cmV0dXJuIG8odCx7Li4uZSxmYXN0cGF0aHM6ZmFsc2V9KX07cGljb21hdGNoLnNjYW49KHQsZSk9Pm4odCxlKTtwaWNvbWF0Y2guY29tcGlsZVJlPSh0LGUsdT1mYWxzZSxuPWZhbHNlKT0+e2lmKHU9PT10cnVlKXtyZXR1cm4gdC5vdXRwdXR9Y29uc3Qgbz1lfHx7fTtjb25zdCBzPW8uY29udGFpbnM/XCJcIjpcIl5cIjtjb25zdCByPW8uY29udGFpbnM/XCJcIjpcIiRcIjtsZXQgYT1gJHtzfSg/OiR7dC5vdXRwdXR9KSR7cn1gO2lmKHQmJnQubmVnYXRlZD09PXRydWUpe2E9YF4oPyEke2F9KS4qJGB9Y29uc3QgaT1waWNvbWF0Y2gudG9SZWdleChhLGUpO2lmKG49PT10cnVlKXtpLnN0YXRlPXR9cmV0dXJuIGl9O3BpY29tYXRjaC5tYWtlUmU9KHQsZT17fSx1PWZhbHNlLG49ZmFsc2UpPT57aWYoIXR8fHR5cGVvZiB0IT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbm9uLWVtcHR5IHN0cmluZ1wiKX1sZXQgcz17bmVnYXRlZDpmYWxzZSxmYXN0cGF0aHM6dHJ1ZX07aWYoZS5mYXN0cGF0aHMhPT1mYWxzZSYmKHRbMF09PT1cIi5cInx8dFswXT09PVwiKlwiKSl7cy5vdXRwdXQ9by5mYXN0cGF0aHModCxlKX1pZighcy5vdXRwdXQpe3M9byh0LGUpfXJldHVybiBwaWNvbWF0Y2guY29tcGlsZVJlKHMsZSx1LG4pfTtwaWNvbWF0Y2gudG9SZWdleD0odCxlKT0+e3RyeXtjb25zdCB1PWV8fHt9O3JldHVybiBuZXcgUmVnRXhwKHQsdS5mbGFnc3x8KHUubm9jYXNlP1wiaVwiOlwiXCIpKX1jYXRjaCh0KXtpZihlJiZlLmRlYnVnPT09dHJ1ZSl0aHJvdyB0O3JldHVybi8kXi99fTtwaWNvbWF0Y2guY29uc3RhbnRzPXI7dC5leHBvcnRzPXBpY29tYXRjaH0sNzE2Oih0LGUsdSk9Pntjb25zdCBuPXUoOTYpO2NvbnN0e0NIQVJfQVNURVJJU0s6byxDSEFSX0FUOnMsQ0hBUl9CQUNLV0FSRF9TTEFTSDpyLENIQVJfQ09NTUE6YSxDSEFSX0RPVDppLENIQVJfRVhDTEFNQVRJT05fTUFSSzpjLENIQVJfRk9SV0FSRF9TTEFTSDpwLENIQVJfTEVGVF9DVVJMWV9CUkFDRTpsLENIQVJfTEVGVF9QQVJFTlRIRVNFUzpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUExVUzpfLENIQVJfUVVFU1RJT05fTUFSSzpSLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6RSxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmgsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpnfT11KDE1NCk7Y29uc3QgaXNQYXRoU2VwYXJhdG9yPXQ9PnQ9PT1wfHx0PT09cjtjb25zdCBkZXB0aD10PT57aWYodC5pc1ByZWZpeCE9PXRydWUpe3QuZGVwdGg9dC5pc0dsb2JzdGFyP0luZmluaXR5OjF9fTtjb25zdCBzY2FuPSh0LGUpPT57Y29uc3QgdT1lfHx7fTtjb25zdCBiPXQubGVuZ3RoLTE7Y29uc3QgQz11LnBhcnRzPT09dHJ1ZXx8dS5zY2FuVG9FbmQ9PT10cnVlO2NvbnN0IHk9W107Y29uc3QgJD1bXTtjb25zdCB4PVtdO2xldCBTPXQ7bGV0IEg9LTE7bGV0IHY9MDtsZXQgZD0wO2xldCBMPWZhbHNlO2xldCBUPWZhbHNlO2xldCBPPWZhbHNlO2xldCBrPWZhbHNlO2xldCBtPWZhbHNlO2xldCB3PWZhbHNlO2xldCBOPWZhbHNlO2xldCBJPWZhbHNlO2xldCBCPWZhbHNlO2xldCBHPWZhbHNlO2xldCBEPTA7bGV0IE07bGV0IFA7bGV0IEs9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2NvbnN0IGVvcz0oKT0+SD49Yjtjb25zdCBwZWVrPSgpPT5TLmNoYXJDb2RlQXQoSCsxKTtjb25zdCBhZHZhbmNlPSgpPT57TT1QO3JldHVybiBTLmNoYXJDb2RlQXQoKytIKX07d2hpbGUoSDxiKXtQPWFkdmFuY2UoKTtsZXQgdDtpZihQPT09cil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7aWYoUD09PWwpe3c9dHJ1ZX1jb250aW51ZX1pZih3PT09dHJ1ZXx8UD09PWwpe0QrKzt3aGlsZShlb3MoKSE9PXRydWUmJihQPWFkdmFuY2UoKSkpe2lmKFA9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWwpe0QrKztjb250aW51ZX1pZih3IT09dHJ1ZSYmUD09PWkmJihQPWFkdmFuY2UoKSk9PT1pKXtMPUsuaXNCcmFjZT10cnVlO089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKHchPT10cnVlJiZQPT09YSl7TD1LLmlzQnJhY2U9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2lmKEM9PT10cnVlKXtjb250aW51ZX1icmVha31pZihQPT09RSl7RC0tO2lmKEQ9PT0wKXt3PWZhbHNlO0w9Sy5pc0JyYWNlPXRydWU7Rz10cnVlO2JyZWFrfX19aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1wKXt5LnB1c2goSCk7JC5wdXNoKEspO0s9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2lmKEc9PT10cnVlKWNvbnRpbnVlO2lmKE09PT1pJiZIPT09disxKXt2Kz0yO2NvbnRpbnVlfWQ9SCsxO2NvbnRpbnVlfWlmKHUubm9leHQhPT10cnVlKXtjb25zdCB0PVA9PT1ffHxQPT09c3x8UD09PW98fFA9PT1SfHxQPT09YztpZih0PT09dHJ1ZSYmcGVlaygpPT09Zil7Tz1LLmlzR2xvYj10cnVlO2s9Sy5pc0V4dGdsb2I9dHJ1ZTtHPXRydWU7aWYoUD09PWMmJkg9PT12KXtCPXRydWV9aWYoQz09PXRydWUpe3doaWxlKGVvcygpIT09dHJ1ZSYmKFA9YWR2YW5jZSgpKSl7aWYoUD09PXIpe049Sy5iYWNrc2xhc2hlcz10cnVlO1A9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKFA9PT1oKXtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha319aWYoUD09PW8pe2lmKE09PT1vKW09Sy5pc0dsb2JzdGFyPXRydWU7Tz1LLmlzR2xvYj10cnVlO0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoUD09PVIpe089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1BKXt3aGlsZShlb3MoKSE9PXRydWUmJih0PWFkdmFuY2UoKSkpe2lmKHQ9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYodD09PWcpe1Q9Sy5pc0JyYWNrZXQ9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2JyZWFrfX1pZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYodS5ub25lZ2F0ZSE9PXRydWUmJlA9PT1jJiZIPT09dil7ST1LLm5lZ2F0ZWQ9dHJ1ZTt2Kys7Y29udGludWV9aWYodS5ub3BhcmVuIT09dHJ1ZSYmUD09PWYpe089Sy5pc0dsb2I9dHJ1ZTtpZihDPT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoUD1hZHZhbmNlKCkpKXtpZihQPT09Zil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWgpe0c9dHJ1ZTticmVha319Y29udGludWV9YnJlYWt9aWYoTz09PXRydWUpe0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9fWlmKHUubm9leHQ9PT10cnVlKXtrPWZhbHNlO089ZmFsc2V9bGV0IFU9UztsZXQgWD1cIlwiO2xldCBGPVwiXCI7aWYodj4wKXtYPVMuc2xpY2UoMCx2KTtTPVMuc2xpY2Uodik7ZC09dn1pZihVJiZPPT09dHJ1ZSYmZD4wKXtVPVMuc2xpY2UoMCxkKTtGPVMuc2xpY2UoZCl9ZWxzZSBpZihPPT09dHJ1ZSl7VT1cIlwiO0Y9U31lbHNle1U9U31pZihVJiZVIT09XCJcIiYmVSE9PVwiL1wiJiZVIT09Uyl7aWYoaXNQYXRoU2VwYXJhdG9yKFUuY2hhckNvZGVBdChVLmxlbmd0aC0xKSkpe1U9VS5zbGljZSgwLC0xKX19aWYodS51bmVzY2FwZT09PXRydWUpe2lmKEYpRj1uLnJlbW92ZUJhY2tzbGFzaGVzKEYpO2lmKFUmJk49PT10cnVlKXtVPW4ucmVtb3ZlQmFja3NsYXNoZXMoVSl9fWNvbnN0IFE9e3ByZWZpeDpYLGlucHV0OnQsc3RhcnQ6dixiYXNlOlUsZ2xvYjpGLGlzQnJhY2U6TCxpc0JyYWNrZXQ6VCxpc0dsb2I6Tyxpc0V4dGdsb2I6ayxpc0dsb2JzdGFyOm0sbmVnYXRlZDpJLG5lZ2F0ZWRFeHRnbG9iOkJ9O2lmKHUudG9rZW5zPT09dHJ1ZSl7US5tYXhEZXB0aD0wO2lmKCFpc1BhdGhTZXBhcmF0b3IoUCkpeyQucHVzaChLKX1RLnRva2Vucz0kfWlmKHUucGFydHM9PT10cnVlfHx1LnRva2Vucz09PXRydWUpe2xldCBlO2ZvcihsZXQgbj0wO248eS5sZW5ndGg7bisrKXtjb25zdCBvPWU/ZSsxOnY7Y29uc3Qgcz15W25dO2NvbnN0IHI9dC5zbGljZShvLHMpO2lmKHUudG9rZW5zKXtpZihuPT09MCYmdiE9PTApeyRbbl0uaXNQcmVmaXg9dHJ1ZTskW25dLnZhbHVlPVh9ZWxzZXskW25dLnZhbHVlPXJ9ZGVwdGgoJFtuXSk7US5tYXhEZXB0aCs9JFtuXS5kZXB0aH1pZihuIT09MHx8ciE9PVwiXCIpe3gucHVzaChyKX1lPXN9aWYoZSYmZSsxPHQubGVuZ3RoKXtjb25zdCBuPXQuc2xpY2UoZSsxKTt4LnB1c2gobik7aWYodS50b2tlbnMpeyRbJC5sZW5ndGgtMV0udmFsdWU9bjtkZXB0aCgkWyQubGVuZ3RoLTFdKTtRLm1heERlcHRoKz0kWyQubGVuZ3RoLTFdLmRlcHRofX1RLnNsYXNoZXM9eTtRLnBhcnRzPXh9cmV0dXJuIFF9O3QuZXhwb3J0cz1zY2FufSw5NjoodCxlLHUpPT57Y29uc3R7UkVHRVhfQkFDS1NMQVNIOm4sUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSDpvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6cyxSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDpyfT11KDE1NCk7ZS5pc09iamVjdD10PT50IT09bnVsbCYmdHlwZW9mIHQ9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheSh0KTtlLmhhc1JlZ2V4Q2hhcnM9dD0+cy50ZXN0KHQpO2UuaXNSZWdleENoYXI9dD0+dC5sZW5ndGg9PT0xJiZlLmhhc1JlZ2V4Q2hhcnModCk7ZS5lc2NhcGVSZWdleD10PT50LnJlcGxhY2UocixcIlxcXFwkMVwiKTtlLnRvUG9zaXhTbGFzaGVzPXQ9PnQucmVwbGFjZShuLFwiL1wiKTtlLnJlbW92ZUJhY2tzbGFzaGVzPXQ9PnQucmVwbGFjZShvLCh0PT50PT09XCJcXFxcXCI/XCJcIjp0KSk7ZS5lc2NhcGVMYXN0PSh0LHUsbik9Pntjb25zdCBvPXQubGFzdEluZGV4T2YodSxuKTtpZihvPT09LTEpcmV0dXJuIHQ7aWYodFtvLTFdPT09XCJcXFxcXCIpcmV0dXJuIGUuZXNjYXBlTGFzdCh0LHUsby0xKTtyZXR1cm5gJHt0LnNsaWNlKDAsbyl9XFxcXCR7dC5zbGljZShvKX1gfTtlLnJlbW92ZVByZWZpeD0odCxlPXt9KT0+e2xldCB1PXQ7aWYodS5zdGFydHNXaXRoKFwiLi9cIikpe3U9dS5zbGljZSgyKTtlLnByZWZpeD1cIi4vXCJ9cmV0dXJuIHV9O2Uud3JhcE91dHB1dD0odCxlPXt9LHU9e30pPT57Y29uc3Qgbj11LmNvbnRhaW5zP1wiXCI6XCJeXCI7Y29uc3Qgbz11LmNvbnRhaW5zP1wiXCI6XCIkXCI7bGV0IHM9YCR7bn0oPzoke3R9KSR7b31gO2lmKGUubmVnYXRlZD09PXRydWUpe3M9YCg/Ol4oPyEke3N9KS4qJClgfXJldHVybiBzfTtlLmJhc2VuYW1lPSh0LHt3aW5kb3dzOmV9PXt9KT0+e2NvbnN0IHU9dC5zcGxpdChlPy9bXFxcXC9dLzpcIi9cIik7Y29uc3Qgbj11W3UubGVuZ3RoLTFdO2lmKG49PT1cIlwiKXtyZXR1cm4gdVt1Lmxlbmd0aC0yXX1yZXR1cm4gbn19fTt2YXIgZT17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHUpe3ZhciBuPWVbdV07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgbz1lW3VdPXtleHBvcnRzOnt9fTt2YXIgcz10cnVlO3RyeXt0W3VdKG8sby5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO3M9ZmFsc2V9ZmluYWxseXtpZihzKWRlbGV0ZSBlW3VdfXJldHVybiBvLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB1PV9fbmNjd3Bja19yZXF1aXJlX18oMTcwKTttb2R1bGUuZXhwb3J0cz11fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/picomatch/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/process/browser.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/process/browser.js ***!
  \***************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuNzcuMi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz84ODM1Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/container/Styles.scss":
/*!*************************************************!*\
  !*** ./src/components/ui/container/Styles.scss ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"a212e55a6eb2\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL2NvbnRhaW5lci9TdHlsZXMuc2NzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdWkvY29udGFpbmVyL1N0eWxlcy5zY3NzPzJkYjEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJhMjEyZTU1YTZlYjJcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/container/Styles.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/styles/globals.scss":
/*!*********************************!*\
  !*** ./src/styles/globals.scss ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"3b7ffba4ec5c\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdHlsZXMvZ2xvYmFscy5zY3NzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxjQUFjO0FBQzdCLElBQUksSUFBVSxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3R5bGVzL2dsb2JhbHMuc2Nzcz81ZTc4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiM2I3ZmZiYTRlYzVjXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/styles/globals.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/callback/Callback.module.scss":
/*!******************************************************!*\
  !*** ./src/components/callback/Callback.module.scss ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"form\":\"Callback_form___YomO\",\"form__text\":\"Callback_form__text__ZKMy1\",\"form__inputs\":\"Callback_form__inputs__eRDB9\",\"form__input\":\"Callback_form__input__3_Dal\",\"form__theme\":\"Callback_form__theme__OW8Vc\",\"form__label\":\"Callback_form__label__M1iJQ\",\"form__themeTypes\":\"Callback_form__themeTypes__uo0H_\",\"form__textarea\":\"Callback_form__textarea__wQtqK\",\"form__actions\":\"Callback_form__actions__HzOIc\",\"form__privacy\":\"Callback_form__privacy__MN_fz\"};\n    if(true) {\n      // 1716545547149\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"8b0818341759\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2NhbGxiYWNrL0NhbGxiYWNrLm1vZHVsZS5zY3NzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCO0FBQ2xCLE9BQU8sSUFBVTtBQUNqQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHNYQUFxTixjQUFjLHNEQUFzRDtBQUN2VCxNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2NhbGxiYWNrL0NhbGxiYWNrLm1vZHVsZS5zY3NzP2ZiYjQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcImZvcm1cIjpcIkNhbGxiYWNrX2Zvcm1fX19Zb21PXCIsXCJmb3JtX190ZXh0XCI6XCJDYWxsYmFja19mb3JtX190ZXh0X19aS015MVwiLFwiZm9ybV9faW5wdXRzXCI6XCJDYWxsYmFja19mb3JtX19pbnB1dHNfX2VSREI5XCIsXCJmb3JtX19pbnB1dFwiOlwiQ2FsbGJhY2tfZm9ybV9faW5wdXRfXzNfRGFsXCIsXCJmb3JtX190aGVtZVwiOlwiQ2FsbGJhY2tfZm9ybV9fdGhlbWVfX09XOFZjXCIsXCJmb3JtX19sYWJlbFwiOlwiQ2FsbGJhY2tfZm9ybV9fbGFiZWxfX00xaUpRXCIsXCJmb3JtX190aGVtZVR5cGVzXCI6XCJDYWxsYmFja19mb3JtX190aGVtZVR5cGVzX191bzBIX1wiLFwiZm9ybV9fdGV4dGFyZWFcIjpcIkNhbGxiYWNrX2Zvcm1fX3RleHRhcmVhX193UXRxS1wiLFwiZm9ybV9fYWN0aW9uc1wiOlwiQ2FsbGJhY2tfZm9ybV9fYWN0aW9uc19fSHpPSWNcIixcImZvcm1fX3ByaXZhY3lcIjpcIkNhbGxiYWNrX2Zvcm1fX3ByaXZhY3lfX01OX2Z6XCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3MTY1NDU1NDcxNDlcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovVXNlcnMvNzk1MzMvRGVza3RvcC9mcm9udC1yYmFuZC9yYmFuZC9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuNzcuMi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgXG5tb2R1bGUuZXhwb3J0cy5fX2NoZWNrc3VtID0gXCI4YjA4MTgzNDE3NTlcIlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/callback/Callback.module.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/contact/contact.module.scss":
/*!****************************************************!*\
  !*** ./src/components/contact/contact.module.scss ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"contact\":\"contact_contact__yeABA\",\"contact__time\":\"contact_contact__time__l1f_N\",\"contact__contentInfo\":\"contact_contact__contentInfo__qteEm\",\"contact__contentInfoBox\":\"contact_contact__contentInfoBox__16xQl\",\"contact__contentInfoAddress\":\"contact_contact__contentInfoAddress__YOLik\"};\n    if(true) {\n      // 1716545547145\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"5c6a216d6856\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2NvbnRhY3QvY29udGFjdC5tb2R1bGUuc2NzcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQjtBQUNsQixPQUFPLElBQVU7QUFDakI7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxzWEFBcU4sY0FBYyxzREFBc0Q7QUFDdlQsTUFBTSxVQUFVO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9jb250YWN0L2NvbnRhY3QubW9kdWxlLnNjc3M/MjRlYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbm1vZHVsZS5leHBvcnRzID0ge1wiY29udGFjdFwiOlwiY29udGFjdF9jb250YWN0X195ZUFCQVwiLFwiY29udGFjdF9fdGltZVwiOlwiY29udGFjdF9jb250YWN0X190aW1lX19sMWZfTlwiLFwiY29udGFjdF9fY29udGVudEluZm9cIjpcImNvbnRhY3RfY29udGFjdF9fY29udGVudEluZm9fX3F0ZUVtXCIsXCJjb250YWN0X19jb250ZW50SW5mb0JveFwiOlwiY29udGFjdF9jb250YWN0X19jb250ZW50SW5mb0JveF9fMTZ4UWxcIixcImNvbnRhY3RfX2NvbnRlbnRJbmZvQWRkcmVzc1wiOlwiY29udGFjdF9jb250YWN0X19jb250ZW50SW5mb0FkZHJlc3NfX1lPTGlrXCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3MTY1NDU1NDcxNDVcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovVXNlcnMvNzk1MzMvRGVza3RvcC9mcm9udC1yYmFuZC9yYmFuZC9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuNzcuMi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgXG5tb2R1bGUuZXhwb3J0cy5fX2NoZWNrc3VtID0gXCI1YzZhMjE2ZDY4NTZcIlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/contact/contact.module.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/contacts/Contacts.module.scss":
/*!******************************************************!*\
  !*** ./src/components/contacts/Contacts.module.scss ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"contacts\":\"Contacts_contacts__ulTh_\",\"contacts_dark\":\"Contacts_contacts_dark__MV9ff\",\"contacts__container\":\"Contacts_contacts__container__egpK_\",\"contacts__content\":\"Contacts_contacts__content__qEvJy\"};\n    if(true) {\n      // 1716545546910\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"2a5ad290337a\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2NvbnRhY3RzL0NvbnRhY3RzLm1vZHVsZS5zY3NzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCO0FBQ2xCLE9BQU8sSUFBVTtBQUNqQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHNYQUFxTixjQUFjLHNEQUFzRDtBQUN2VCxNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2NvbnRhY3RzL0NvbnRhY3RzLm1vZHVsZS5zY3NzPzgxZjYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcImNvbnRhY3RzXCI6XCJDb250YWN0c19jb250YWN0c19fdWxUaF9cIixcImNvbnRhY3RzX2RhcmtcIjpcIkNvbnRhY3RzX2NvbnRhY3RzX2RhcmtfX01WOWZmXCIsXCJjb250YWN0c19fY29udGFpbmVyXCI6XCJDb250YWN0c19jb250YWN0c19fY29udGFpbmVyX19lZ3BLX1wiLFwiY29udGFjdHNfX2NvbnRlbnRcIjpcIkNvbnRhY3RzX2NvbnRhY3RzX19jb250ZW50X19xRXZKeVwifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzE2NTQ1NTQ2OTEwXG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIkM6L1VzZXJzLzc5NTMzL0Rlc2t0b3AvZnJvbnQtcmJhbmQvcmJhbmQvbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTQuMi4xX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjFfc2Fzc0AxLjc3LjIvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIvX25leHQvXCIsXCJlc01vZHVsZVwiOmZhbHNlLFwibG9jYWxzXCI6dHJ1ZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBcbiAgICB9XG4gIFxubW9kdWxlLmV4cG9ydHMuX19jaGVja3N1bSA9IFwiMmE1YWQyOTAzMzdhXCJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/contacts/Contacts.module.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/footer/styles.module.scss":
/*!**************************************************!*\
  !*** ./src/components/footer/styles.module.scss ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"footer\":\"styles_footer__1cZ8q\",\"footer__container\":\"styles_footer__container__GQGKm\",\"footer__company\":\"styles_footer__company__wrIjH\",\"footer__logo\":\"styles_footer__logo__ecMtg\",\"footer__companyText\":\"styles_footer__companyText__COHgM\",\"footer__content\":\"styles_footer__content__JdMYB\",\"footer__contacts\":\"styles_footer__contacts__TRfXL\",\"footer__socials\":\"styles_footer__socials__Tr6HU\",\"footer__services\":\"styles_footer__services__RTWxS\",\"footer__contactsTop\":\"styles_footer__contactsTop__H58LX\",\"footer__contactsPhone\":\"styles_footer__contactsPhone__O2qju\",\"footer__contactsOperating\":\"styles_footer__contactsOperating__kPv_7\",\"footer__contactsMail\":\"styles_footer__contactsMail__C3h4f\",\"footer__socialsItem\":\"styles_footer__socialsItem__eUaz9\",\"footer__servicesItem\":\"styles_footer__servicesItem__1k0EE\",\"footer__servicesItemLink\":\"styles_footer__servicesItemLink__Ygc0q\",\"footer__info\":\"styles_footer__info__YYtrs\",\"footer__reviews\":\"styles_footer__reviews__RqwF4\",\"footer__reviewsText\":\"styles_footer__reviewsText__9Nyf5\",\"footer__reviewsLinks\":\"styles_footer__reviewsLinks__QHX_i\",\"footer__reviewsItem\":\"styles_footer__reviewsItem__r_QE_\",\"footer__reviewsItemImg\":\"styles_footer__reviewsItemImg__IUIJG\",\"footer__copyright\":\"styles_footer__copyright__HgqFC\"};\n    if(true) {\n      // 1716545546731\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"3fbb7f942e22\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Zvb3Rlci9zdHlsZXMubW9kdWxlLnNjc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsc1hBQXFOLGNBQWMsc0RBQXNEO0FBQ3ZULE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvZm9vdGVyL3N0eWxlcy5tb2R1bGUuc2Nzcz8zYWM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJmb290ZXJcIjpcInN0eWxlc19mb290ZXJfXzFjWjhxXCIsXCJmb290ZXJfX2NvbnRhaW5lclwiOlwic3R5bGVzX2Zvb3Rlcl9fY29udGFpbmVyX19HUUdLbVwiLFwiZm9vdGVyX19jb21wYW55XCI6XCJzdHlsZXNfZm9vdGVyX19jb21wYW55X193cklqSFwiLFwiZm9vdGVyX19sb2dvXCI6XCJzdHlsZXNfZm9vdGVyX19sb2dvX19lY010Z1wiLFwiZm9vdGVyX19jb21wYW55VGV4dFwiOlwic3R5bGVzX2Zvb3Rlcl9fY29tcGFueVRleHRfX0NPSGdNXCIsXCJmb290ZXJfX2NvbnRlbnRcIjpcInN0eWxlc19mb290ZXJfX2NvbnRlbnRfX0pkTVlCXCIsXCJmb290ZXJfX2NvbnRhY3RzXCI6XCJzdHlsZXNfZm9vdGVyX19jb250YWN0c19fVFJmWExcIixcImZvb3Rlcl9fc29jaWFsc1wiOlwic3R5bGVzX2Zvb3Rlcl9fc29jaWFsc19fVHI2SFVcIixcImZvb3Rlcl9fc2VydmljZXNcIjpcInN0eWxlc19mb290ZXJfX3NlcnZpY2VzX19SVFd4U1wiLFwiZm9vdGVyX19jb250YWN0c1RvcFwiOlwic3R5bGVzX2Zvb3Rlcl9fY29udGFjdHNUb3BfX0g1OExYXCIsXCJmb290ZXJfX2NvbnRhY3RzUGhvbmVcIjpcInN0eWxlc19mb290ZXJfX2NvbnRhY3RzUGhvbmVfX08ycWp1XCIsXCJmb290ZXJfX2NvbnRhY3RzT3BlcmF0aW5nXCI6XCJzdHlsZXNfZm9vdGVyX19jb250YWN0c09wZXJhdGluZ19fa1B2XzdcIixcImZvb3Rlcl9fY29udGFjdHNNYWlsXCI6XCJzdHlsZXNfZm9vdGVyX19jb250YWN0c01haWxfX0MzaDRmXCIsXCJmb290ZXJfX3NvY2lhbHNJdGVtXCI6XCJzdHlsZXNfZm9vdGVyX19zb2NpYWxzSXRlbV9fZVVhejlcIixcImZvb3Rlcl9fc2VydmljZXNJdGVtXCI6XCJzdHlsZXNfZm9vdGVyX19zZXJ2aWNlc0l0ZW1fXzFrMEVFXCIsXCJmb290ZXJfX3NlcnZpY2VzSXRlbUxpbmtcIjpcInN0eWxlc19mb290ZXJfX3NlcnZpY2VzSXRlbUxpbmtfX1lnYzBxXCIsXCJmb290ZXJfX2luZm9cIjpcInN0eWxlc19mb290ZXJfX2luZm9fX1lZdHJzXCIsXCJmb290ZXJfX3Jldmlld3NcIjpcInN0eWxlc19mb290ZXJfX3Jldmlld3NfX1Jxd0Y0XCIsXCJmb290ZXJfX3Jldmlld3NUZXh0XCI6XCJzdHlsZXNfZm9vdGVyX19yZXZpZXdzVGV4dF9fOU55ZjVcIixcImZvb3Rlcl9fcmV2aWV3c0xpbmtzXCI6XCJzdHlsZXNfZm9vdGVyX19yZXZpZXdzTGlua3NfX1FIWF9pXCIsXCJmb290ZXJfX3Jldmlld3NJdGVtXCI6XCJzdHlsZXNfZm9vdGVyX19yZXZpZXdzSXRlbV9fcl9RRV9cIixcImZvb3Rlcl9fcmV2aWV3c0l0ZW1JbWdcIjpcInN0eWxlc19mb290ZXJfX3Jldmlld3NJdGVtSW1nX19JVUlKR1wiLFwiZm9vdGVyX19jb3B5cmlnaHRcIjpcInN0eWxlc19mb290ZXJfX2NvcHlyaWdodF9fSGdxRkNcIn07XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTcxNjU0NTU0NjczMVxuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCJDOi9Vc2Vycy83OTUzMy9EZXNrdG9wL2Zyb250LXJiYW5kL3JiYW5kL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiL19uZXh0L1wiLFwiZXNNb2R1bGVcIjpmYWxzZSxcImxvY2Fsc1wiOnRydWV9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgXG4gICAgfVxuICBcbm1vZHVsZS5leHBvcnRzLl9fY2hlY2tzdW0gPSBcIjNmYmI3Zjk0MmUyMlwiXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/footer/styles.module.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/header/styles.module.scss":
/*!**************************************************!*\
  !*** ./src/components/header/styles.module.scss ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"header\":\"styles_header__fpulf\",\"header_black\":\"styles_header_black__U1QYD\",\"header_fixed\":\"styles_header_fixed__wpKQd\",\"header_show\":\"styles_header_show__QDYj6\",\"header_transition\":\"styles_header_transition__lRyNo\",\"header__container\":\"styles_header__container__ECLsw\",\"header__right\":\"styles_header__right__e7cmS\",\"header__left\":\"styles_header__left__xxf_5\",\"header__logo\":\"styles_header__logo__BzK66\",\"header__nav\":\"styles_header__nav__jKni5\",\"header__list\":\"styles_header__list__d6IEn\",\"header__listItem\":\"styles_header__listItem__ZKwAl\",\"header__listItemLink\":\"styles_header__listItemLink__my1oe\",\"header__burger\":\"styles_header__burger__54zZF\",\"header__getLangs\":\"styles_header__getLangs__MLeH8\",\"header__getCity\":\"styles_header__getCity__V7_ol\",\"header__getProject\":\"styles_header__getProject__2str2\",\"header__getProject_hover\":\"styles_header__getProject_hover__8uCJ0\",\"header__getProjectHover\":\"styles_header__getProjectHover__phKr2\",\"header__getProjectMain\":\"styles_header__getProjectMain__Itzbj\"};\n    if(true) {\n      // 1716545546737\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"82bb21174c16\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2hlYWRlci9zdHlsZXMubW9kdWxlLnNjc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsc1hBQXFOLGNBQWMsc0RBQXNEO0FBQ3ZULE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvaGVhZGVyL3N0eWxlcy5tb2R1bGUuc2Nzcz8wN2ViIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJoZWFkZXJcIjpcInN0eWxlc19oZWFkZXJfX2ZwdWxmXCIsXCJoZWFkZXJfYmxhY2tcIjpcInN0eWxlc19oZWFkZXJfYmxhY2tfX1UxUVlEXCIsXCJoZWFkZXJfZml4ZWRcIjpcInN0eWxlc19oZWFkZXJfZml4ZWRfX3dwS1FkXCIsXCJoZWFkZXJfc2hvd1wiOlwic3R5bGVzX2hlYWRlcl9zaG93X19RRFlqNlwiLFwiaGVhZGVyX3RyYW5zaXRpb25cIjpcInN0eWxlc19oZWFkZXJfdHJhbnNpdGlvbl9fbFJ5Tm9cIixcImhlYWRlcl9fY29udGFpbmVyXCI6XCJzdHlsZXNfaGVhZGVyX19jb250YWluZXJfX0VDTHN3XCIsXCJoZWFkZXJfX3JpZ2h0XCI6XCJzdHlsZXNfaGVhZGVyX19yaWdodF9fZTdjbVNcIixcImhlYWRlcl9fbGVmdFwiOlwic3R5bGVzX2hlYWRlcl9fbGVmdF9feHhmXzVcIixcImhlYWRlcl9fbG9nb1wiOlwic3R5bGVzX2hlYWRlcl9fbG9nb19fQnpLNjZcIixcImhlYWRlcl9fbmF2XCI6XCJzdHlsZXNfaGVhZGVyX19uYXZfX2pLbmk1XCIsXCJoZWFkZXJfX2xpc3RcIjpcInN0eWxlc19oZWFkZXJfX2xpc3RfX2Q2SUVuXCIsXCJoZWFkZXJfX2xpc3RJdGVtXCI6XCJzdHlsZXNfaGVhZGVyX19saXN0SXRlbV9fWkt3QWxcIixcImhlYWRlcl9fbGlzdEl0ZW1MaW5rXCI6XCJzdHlsZXNfaGVhZGVyX19saXN0SXRlbUxpbmtfX215MW9lXCIsXCJoZWFkZXJfX2J1cmdlclwiOlwic3R5bGVzX2hlYWRlcl9fYnVyZ2VyX181NHpaRlwiLFwiaGVhZGVyX19nZXRMYW5nc1wiOlwic3R5bGVzX2hlYWRlcl9fZ2V0TGFuZ3NfX01MZUg4XCIsXCJoZWFkZXJfX2dldENpdHlcIjpcInN0eWxlc19oZWFkZXJfX2dldENpdHlfX1Y3X29sXCIsXCJoZWFkZXJfX2dldFByb2plY3RcIjpcInN0eWxlc19oZWFkZXJfX2dldFByb2plY3RfXzJzdHIyXCIsXCJoZWFkZXJfX2dldFByb2plY3RfaG92ZXJcIjpcInN0eWxlc19oZWFkZXJfX2dldFByb2plY3RfaG92ZXJfXzh1Q0owXCIsXCJoZWFkZXJfX2dldFByb2plY3RIb3ZlclwiOlwic3R5bGVzX2hlYWRlcl9fZ2V0UHJvamVjdEhvdmVyX19waEtyMlwiLFwiaGVhZGVyX19nZXRQcm9qZWN0TWFpblwiOlwic3R5bGVzX2hlYWRlcl9fZ2V0UHJvamVjdE1haW5fX0l0emJqXCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3MTY1NDU1NDY3MzdcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovVXNlcnMvNzk1MzMvRGVza3RvcC9mcm9udC1yYmFuZC9yYmFuZC9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuNzcuMi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgXG5tb2R1bGUuZXhwb3J0cy5fX2NoZWNrc3VtID0gXCI4MmJiMjExNzRjMTZcIlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/header/styles.module.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/localization/styles.module.scss":
/*!********************************************************!*\
  !*** ./src/components/localization/styles.module.scss ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"localization\":\"styles_localization__jUm6h\",\"localization__container\":\"styles_localization__container__z_omh\",\"localization__locales_centered\":\"styles_localization__locales_centered__BPNcE\",\"localization__label\":\"styles_localization__label__YtGSl\",\"localization__locales\":\"styles_localization__locales__iqrJ1\",\"localization__localesItem\":\"styles_localization__localesItem__K_X_6\",\"localization__localesItemCountry\":\"styles_localization__localesItemCountry__K5i0W\",\"localization__localesItemState\":\"styles_localization__localesItemState__CsIUg\",\"localization__localesItemState_active\":\"styles_localization__localesItemState_active__pHXDZ\",\"localization__localesItemCountry_active\":\"styles_localization__localesItemCountry_active__j_uqN\",\"localization__localesItemCity\":\"styles_localization__localesItemCity__qA_L4\",\"localization__localesItemCity_active\":\"styles_localization__localesItemCity_active__r_QWu\",\"localization__anotherСity\":\"styles_localization__another_ity__BaQjc\",\"localization__anotherСity_active\":\"styles_localization__another_ity_active__rJSEf\"};\n    if(true) {\n      // 1716545546912\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"22ad967ca801\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2xvY2FsaXphdGlvbi9zdHlsZXMubW9kdWxlLnNjc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsc1hBQXFOLGNBQWMsc0RBQXNEO0FBQ3ZULE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvbG9jYWxpemF0aW9uL3N0eWxlcy5tb2R1bGUuc2Nzcz9mZjg4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJsb2NhbGl6YXRpb25cIjpcInN0eWxlc19sb2NhbGl6YXRpb25fX2pVbTZoXCIsXCJsb2NhbGl6YXRpb25fX2NvbnRhaW5lclwiOlwic3R5bGVzX2xvY2FsaXphdGlvbl9fY29udGFpbmVyX196X29taFwiLFwibG9jYWxpemF0aW9uX19sb2NhbGVzX2NlbnRlcmVkXCI6XCJzdHlsZXNfbG9jYWxpemF0aW9uX19sb2NhbGVzX2NlbnRlcmVkX19CUE5jRVwiLFwibG9jYWxpemF0aW9uX19sYWJlbFwiOlwic3R5bGVzX2xvY2FsaXphdGlvbl9fbGFiZWxfX1l0R1NsXCIsXCJsb2NhbGl6YXRpb25fX2xvY2FsZXNcIjpcInN0eWxlc19sb2NhbGl6YXRpb25fX2xvY2FsZXNfX2lxckoxXCIsXCJsb2NhbGl6YXRpb25fX2xvY2FsZXNJdGVtXCI6XCJzdHlsZXNfbG9jYWxpemF0aW9uX19sb2NhbGVzSXRlbV9fS19YXzZcIixcImxvY2FsaXphdGlvbl9fbG9jYWxlc0l0ZW1Db3VudHJ5XCI6XCJzdHlsZXNfbG9jYWxpemF0aW9uX19sb2NhbGVzSXRlbUNvdW50cnlfX0s1aTBXXCIsXCJsb2NhbGl6YXRpb25fX2xvY2FsZXNJdGVtU3RhdGVcIjpcInN0eWxlc19sb2NhbGl6YXRpb25fX2xvY2FsZXNJdGVtU3RhdGVfX0NzSVVnXCIsXCJsb2NhbGl6YXRpb25fX2xvY2FsZXNJdGVtU3RhdGVfYWN0aXZlXCI6XCJzdHlsZXNfbG9jYWxpemF0aW9uX19sb2NhbGVzSXRlbVN0YXRlX2FjdGl2ZV9fcEhYRFpcIixcImxvY2FsaXphdGlvbl9fbG9jYWxlc0l0ZW1Db3VudHJ5X2FjdGl2ZVwiOlwic3R5bGVzX2xvY2FsaXphdGlvbl9fbG9jYWxlc0l0ZW1Db3VudHJ5X2FjdGl2ZV9fal91cU5cIixcImxvY2FsaXphdGlvbl9fbG9jYWxlc0l0ZW1DaXR5XCI6XCJzdHlsZXNfbG9jYWxpemF0aW9uX19sb2NhbGVzSXRlbUNpdHlfX3FBX0w0XCIsXCJsb2NhbGl6YXRpb25fX2xvY2FsZXNJdGVtQ2l0eV9hY3RpdmVcIjpcInN0eWxlc19sb2NhbGl6YXRpb25fX2xvY2FsZXNJdGVtQ2l0eV9hY3RpdmVfX3JfUVd1XCIsXCJsb2NhbGl6YXRpb25fX2Fub3RoZXLQoWl0eVwiOlwic3R5bGVzX2xvY2FsaXphdGlvbl9fYW5vdGhlcl9pdHlfX0JhUWpjXCIsXCJsb2NhbGl6YXRpb25fX2Fub3RoZXLQoWl0eV9hY3RpdmVcIjpcInN0eWxlc19sb2NhbGl6YXRpb25fX2Fub3RoZXJfaXR5X2FjdGl2ZV9fckpTRWZcIn07XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTcxNjU0NTU0NjkxMlxuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCJDOi9Vc2Vycy83OTUzMy9EZXNrdG9wL2Zyb250LXJiYW5kL3JiYW5kL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiL19uZXh0L1wiLFwiZXNNb2R1bGVcIjpmYWxzZSxcImxvY2Fsc1wiOnRydWV9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgXG4gICAgfVxuICBcbm1vZHVsZS5leHBvcnRzLl9fY2hlY2tzdW0gPSBcIjIyYWQ5NjdjYTgwMVwiXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/localization/styles.module.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/button/Button.module.scss":
/*!*****************************************************!*\
  !*** ./src/components/ui/button/Button.module.scss ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"button\":\"Button_button__9Ya7B\",\"button__follower\":\"Button_button__follower__Q8SIc\"};\n    if(true) {\n      // 1716545546913\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"9968da9ec3d4\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL2J1dHRvbi9CdXR0b24ubW9kdWxlLnNjc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsc1hBQXFOLGNBQWMsc0RBQXNEO0FBQ3ZULE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdWkvYnV0dG9uL0J1dHRvbi5tb2R1bGUuc2Nzcz83OGRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJidXR0b25cIjpcIkJ1dHRvbl9idXR0b25fXzlZYTdCXCIsXCJidXR0b25fX2ZvbGxvd2VyXCI6XCJCdXR0b25fYnV0dG9uX19mb2xsb3dlcl9fUThTSWNcIn07XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTcxNjU0NTU0NjkxM1xuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCJDOi9Vc2Vycy83OTUzMy9EZXNrdG9wL2Zyb250LXJiYW5kL3JiYW5kL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiL19uZXh0L1wiLFwiZXNNb2R1bGVcIjpmYWxzZSxcImxvY2Fsc1wiOnRydWV9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgXG4gICAgfVxuICBcbm1vZHVsZS5leHBvcnRzLl9fY2hlY2tzdW0gPSBcIjk5NjhkYTllYzNkNFwiXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/button/Button.module.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/input/input.module.scss":
/*!***************************************************!*\
  !*** ./src/components/ui/input/input.module.scss ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"input\":\"input_input__zyT9L\",\"input__label\":\"input_input__label__RFrbf\",\"input__input\":\"input_input__input__G9NX2\",\"input_focused\":\"input_input_focused__IXWbI\"};\n    if(true) {\n      // 1716545547354\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"76aff979d966\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL2lucHV0L2lucHV0Lm1vZHVsZS5zY3NzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCO0FBQ2xCLE9BQU8sSUFBVTtBQUNqQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHNYQUFxTixjQUFjLHNEQUFzRDtBQUN2VCxNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3VpL2lucHV0L2lucHV0Lm1vZHVsZS5zY3NzPzc3NjUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcImlucHV0XCI6XCJpbnB1dF9pbnB1dF9fenlUOUxcIixcImlucHV0X19sYWJlbFwiOlwiaW5wdXRfaW5wdXRfX2xhYmVsX19SRnJiZlwiLFwiaW5wdXRfX2lucHV0XCI6XCJpbnB1dF9pbnB1dF9faW5wdXRfX0c5TlgyXCIsXCJpbnB1dF9mb2N1c2VkXCI6XCJpbnB1dF9pbnB1dF9mb2N1c2VkX19JWFdiSVwifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzE2NTQ1NTQ3MzU0XG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIkM6L1VzZXJzLzc5NTMzL0Rlc2t0b3AvZnJvbnQtcmJhbmQvcmJhbmQvbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTQuMi4xX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjFfc2Fzc0AxLjc3LjIvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIvX25leHQvXCIsXCJlc01vZHVsZVwiOmZhbHNlLFwibG9jYWxzXCI6dHJ1ZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBcbiAgICB9XG4gIFxubW9kdWxlLmV4cG9ydHMuX19jaGVja3N1bSA9IFwiNzZhZmY5NzlkOTY2XCJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/input/input.module.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/switcher/switcher.module.scss":
/*!*********************************************************!*\
  !*** ./src/components/ui/switcher/switcher.module.scss ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"switcher\":\"switcher_switcher__26yrN\",\"switcher__container\":\"switcher_switcher__container__uPaOE\",\"switcher__state\":\"switcher_switcher__state__fTqMI\",\"switcher__stateRing\":\"switcher_switcher__stateRing__gAYsL\"};\n    if(true) {\n      // 1716545547356\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"379f790da8ed\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL3N3aXRjaGVyL3N3aXRjaGVyLm1vZHVsZS5zY3NzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCO0FBQ2xCLE9BQU8sSUFBVTtBQUNqQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHNYQUFxTixjQUFjLHNEQUFzRDtBQUN2VCxNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3VpL3N3aXRjaGVyL3N3aXRjaGVyLm1vZHVsZS5zY3NzPzgzNWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcInN3aXRjaGVyXCI6XCJzd2l0Y2hlcl9zd2l0Y2hlcl9fMjZ5ck5cIixcInN3aXRjaGVyX19jb250YWluZXJcIjpcInN3aXRjaGVyX3N3aXRjaGVyX19jb250YWluZXJfX3VQYU9FXCIsXCJzd2l0Y2hlcl9fc3RhdGVcIjpcInN3aXRjaGVyX3N3aXRjaGVyX19zdGF0ZV9fZlRxTUlcIixcInN3aXRjaGVyX19zdGF0ZVJpbmdcIjpcInN3aXRjaGVyX3N3aXRjaGVyX19zdGF0ZVJpbmdfX2dBWXNMXCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3MTY1NDU1NDczNTZcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovVXNlcnMvNzk1MzMvRGVza3RvcC9mcm9udC1yYmFuZC9yYmFuZC9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuNzcuMi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgXG5tb2R1bGUuZXhwb3J0cy5fX2NoZWNrc3VtID0gXCIzNzlmNzkwZGE4ZWRcIlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/switcher/switcher.module.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/uploadFile/UploadFile.module.scss":
/*!*************************************************************!*\
  !*** ./src/components/ui/uploadFile/UploadFile.module.scss ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"upload\":\"UploadFile_upload__AZoA1\",\"upload__label\":\"UploadFile_upload__label__1zPnX\",\"upload__text\":\"UploadFile_upload__text__r13BG\",\"upload__content\":\"UploadFile_upload__content__lNL4A\",\"upload__contentItem\":\"UploadFile_upload__contentItem__c4hSz\",\"upload__contentItem_loading\":\"UploadFile_upload__contentItem_loading__oEDu8\",\"upload__icon\":\"UploadFile_upload__icon__blvYd\"};\n    if(true) {\n      // 1716545547357\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"dd6e0ac74f8b\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL3VwbG9hZEZpbGUvVXBsb2FkRmlsZS5tb2R1bGUuc2NzcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQjtBQUNsQixPQUFPLElBQVU7QUFDakI7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxzWEFBcU4sY0FBYyxzREFBc0Q7QUFDdlQsTUFBTSxVQUFVO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy91aS91cGxvYWRGaWxlL1VwbG9hZEZpbGUubW9kdWxlLnNjc3M/NDMxZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbm1vZHVsZS5leHBvcnRzID0ge1widXBsb2FkXCI6XCJVcGxvYWRGaWxlX3VwbG9hZF9fQVpvQTFcIixcInVwbG9hZF9fbGFiZWxcIjpcIlVwbG9hZEZpbGVfdXBsb2FkX19sYWJlbF9fMXpQblhcIixcInVwbG9hZF9fdGV4dFwiOlwiVXBsb2FkRmlsZV91cGxvYWRfX3RleHRfX3IxM0JHXCIsXCJ1cGxvYWRfX2NvbnRlbnRcIjpcIlVwbG9hZEZpbGVfdXBsb2FkX19jb250ZW50X19sTkw0QVwiLFwidXBsb2FkX19jb250ZW50SXRlbVwiOlwiVXBsb2FkRmlsZV91cGxvYWRfX2NvbnRlbnRJdGVtX19jNGhTelwiLFwidXBsb2FkX19jb250ZW50SXRlbV9sb2FkaW5nXCI6XCJVcGxvYWRGaWxlX3VwbG9hZF9fY29udGVudEl0ZW1fbG9hZGluZ19fb0VEdThcIixcInVwbG9hZF9faWNvblwiOlwiVXBsb2FkRmlsZV91cGxvYWRfX2ljb25fX2JsdllkXCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3MTY1NDU1NDczNTdcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovVXNlcnMvNzk1MzMvRGVza3RvcC9mcm9udC1yYmFuZC9yYmFuZC9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuNzcuMi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgXG5tb2R1bGUuZXhwb3J0cy5fX2NoZWNrc3VtID0gXCJkZDZlMGFjNzRmOGJcIlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/uploadFile/UploadFile.module.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/__barrel_optimize__?names=Icon!=!./node_modules/.pnpm/@iconify+react@4.1.1_react@18.3.1/node_modules/@iconify/react/dist/iconify.mjs":
/*!********************************************************************************************************************************************!*\
  !*** __barrel_optimize__?names=Icon!=!./node_modules/.pnpm/@iconify+react@4.1.1_react@18.3.1/node_modules/@iconify/react/dist/iconify.mjs ***!
  \********************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Icon: function() { return /* reexport safe */ C_Users_79533_Desktop_front_rband_rband_node_modules_pnpm_iconify_react_4_1_1_react_18_3_1_node_modules_iconify_react_dist_iconify_mjs__WEBPACK_IMPORTED_MODULE_0__.Icon; },\n/* harmony export */   InlineIcon: function() { return /* reexport safe */ C_Users_79533_Desktop_front_rband_rband_node_modules_pnpm_iconify_react_4_1_1_react_18_3_1_node_modules_iconify_react_dist_iconify_mjs__WEBPACK_IMPORTED_MODULE_0__.InlineIcon; },\n/* harmony export */   _api: function() { return /* reexport safe */ C_Users_79533_Desktop_front_rband_rband_node_modules_pnpm_iconify_react_4_1_1_react_18_3_1_node_modules_iconify_react_dist_iconify_mjs__WEBPACK_IMPORTED_MODULE_0__._api; },\n/* harmony export */   addAPIProvider: function() { return /* reexport safe */ C_Users_79533_Desktop_front_rband_rband_node_modules_pnpm_iconify_react_4_1_1_react_18_3_1_node_modules_iconify_react_dist_iconify_mjs__WEBPACK_IMPORTED_MODULE_0__.addAPIProvider; },\n/* harmony export */   addCollection: function() { return /* reexport safe */ C_Users_79533_Desktop_front_rband_rband_node_modules_pnpm_iconify_react_4_1_1_react_18_3_1_node_modules_iconify_react_dist_iconify_mjs__WEBPACK_IMPORTED_MODULE_0__.addCollection; },\n/* harmony export */   addIcon: function() { return /* reexport safe */ C_Users_79533_Desktop_front_rband_rband_node_modules_pnpm_iconify_react_4_1_1_react_18_3_1_node_modules_iconify_react_dist_iconify_mjs__WEBPACK_IMPORTED_MODULE_0__.addIcon; },\n/* harmony export */   buildIcon: function() { return /* reexport safe */ C_Users_79533_Desktop_front_rband_rband_node_modules_pnpm_iconify_react_4_1_1_react_18_3_1_node_modules_iconify_react_dist_iconify_mjs__WEBPACK_IMPORTED_MODULE_0__.buildIcon; },\n/* harmony export */   calculateSize: function() { return /* reexport safe */ C_Users_79533_Desktop_front_rband_rband_node_modules_pnpm_iconify_react_4_1_1_react_18_3_1_node_modules_iconify_react_dist_iconify_mjs__WEBPACK_IMPORTED_MODULE_0__.calculateSize; },\n/* harmony export */   disableCache: function() { return /* reexport safe */ C_Users_79533_Desktop_front_rband_rband_node_modules_pnpm_iconify_react_4_1_1_react_18_3_1_node_modules_iconify_react_dist_iconify_mjs__WEBPACK_IMPORTED_MODULE_0__.disableCache; },\n/* harmony export */   enableCache: function() { return /* reexport safe */ C_Users_79533_Desktop_front_rband_rband_node_modules_pnpm_iconify_react_4_1_1_react_18_3_1_node_modules_iconify_react_dist_iconify_mjs__WEBPACK_IMPORTED_MODULE_0__.enableCache; },\n/* harmony export */   getIcon: function() { return /* reexport safe */ C_Users_79533_Desktop_front_rband_rband_node_modules_pnpm_iconify_react_4_1_1_react_18_3_1_node_modules_iconify_react_dist_iconify_mjs__WEBPACK_IMPORTED_MODULE_0__.getIcon; },\n/* harmony export */   iconExists: function() { return /* reexport safe */ C_Users_79533_Desktop_front_rband_rband_node_modules_pnpm_iconify_react_4_1_1_react_18_3_1_node_modules_iconify_react_dist_iconify_mjs__WEBPACK_IMPORTED_MODULE_0__.iconExists; },\n/* harmony export */   listIcons: function() { return /* reexport safe */ C_Users_79533_Desktop_front_rband_rband_node_modules_pnpm_iconify_react_4_1_1_react_18_3_1_node_modules_iconify_react_dist_iconify_mjs__WEBPACK_IMPORTED_MODULE_0__.listIcons; },\n/* harmony export */   loadIcon: function() { return /* reexport safe */ C_Users_79533_Desktop_front_rband_rband_node_modules_pnpm_iconify_react_4_1_1_react_18_3_1_node_modules_iconify_react_dist_iconify_mjs__WEBPACK_IMPORTED_MODULE_0__.loadIcon; },\n/* harmony export */   loadIcons: function() { return /* reexport safe */ C_Users_79533_Desktop_front_rband_rband_node_modules_pnpm_iconify_react_4_1_1_react_18_3_1_node_modules_iconify_react_dist_iconify_mjs__WEBPACK_IMPORTED_MODULE_0__.loadIcons; },\n/* harmony export */   replaceIDs: function() { return /* reexport safe */ C_Users_79533_Desktop_front_rband_rband_node_modules_pnpm_iconify_react_4_1_1_react_18_3_1_node_modules_iconify_react_dist_iconify_mjs__WEBPACK_IMPORTED_MODULE_0__.replaceIDs; }\n/* harmony export */ });\n/* harmony import */ var C_Users_79533_Desktop_front_rband_rband_node_modules_pnpm_iconify_react_4_1_1_react_18_3_1_node_modules_iconify_react_dist_iconify_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/.pnpm/@iconify+react@4.1.1_react@18.3.1/node_modules/@iconify/react/dist/iconify.mjs */ \"(app-pages-browser)/./node_modules/.pnpm/@iconify+react@4.1.1_react@18.3.1/node_modules/@iconify/react/dist/iconify.mjs\");\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS9fX2JhcnJlbF9vcHRpbWl6ZV9fP25hbWVzPUljb24hPSEuL25vZGVfbW9kdWxlcy8ucG5wbS9AaWNvbmlmeStyZWFjdEA0LjEuMV9yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL0BpY29uaWZ5L3JlYWN0L2Rpc3QvaWNvbmlmeS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BpY29uaWZ5K3JlYWN0QDQuMS4xX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvQGljb25pZnkvcmVhY3QvZGlzdC9pY29uaWZ5Lm1qcz84ZDU2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCJDOlxcXFxVc2Vyc1xcXFw3OTUzM1xcXFxEZXNrdG9wXFxcXGZyb250LXJiYW5kXFxcXHJiYW5kXFxcXG5vZGVfbW9kdWxlc1xcXFwucG5wbVxcXFxAaWNvbmlmeStyZWFjdEA0LjEuMV9yZWFjdEAxOC4zLjFcXFxcbm9kZV9tb2R1bGVzXFxcXEBpY29uaWZ5XFxcXHJlYWN0XFxcXGRpc3RcXFxcaWNvbmlmeS5tanNcIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/__barrel_optimize__?names=Icon!=!./node_modules/.pnpm/@iconify+react@4.1.1_react@18.3.1/node_modules/@iconify/react/dist/iconify.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/add-locale.js":
/*!********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/add-locale.js ***!
  \********************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_to_consumable_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"addLocale\", ({\n    enumerable: true,\n    get: function get() {\n        return addLocale;\n    }\n}));\nvar _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/normalize-trailing-slash.js\");\nvar addLocale = function addLocale(path) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (false) { var _require; }\n    return path;\n};\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=add-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FkZC1sb2NhbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7NkNBR2FBOzs7ZUFBQUE7OztrREFGOEI7QUFFcEMsSUFBTUEsWUFBdUIsbUJBQUNDLElBQUFBO3FDQUFTQyxPQUFBQSxJQUFBQSxNQUFBQSxPQUFBQSxJQUFBQSxPQUFBQSxJQUFBQSxJQUFBQSxPQUFBQSxHQUFBQSxPQUFBQSxNQUFBQSxPQUFBQTtRQUFBQSxJQUFBQSxDQUFBQSxPQUFBQSxFQUFBQSxHQUFBQSxTQUFBQSxDQUFBQSxLQUFBQTs7SUFDNUMsSUFBSUMsS0FBK0IsRUFBRSxpQkFJckM7SUFDQSxPQUFPRjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L2FkZC1sb2NhbGUudHM/ZmFhZSJdLCJuYW1lcyI6WyJhZGRMb2NhbGUiLCJwYXRoIiwiYXJncyIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwicmVxdWlyZSIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/add-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/get-domain-locale.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/get-domain-locale.js ***!
  \***************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getDomainLocale\", ({\n    enumerable: true,\n    get: function get() {\n        return getDomainLocale;\n    }\n}));\nvar _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/normalize-trailing-slash.js\");\nvar basePath =  false || \"\";\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) { var finalLocale, proto, domain, target, detectDomainLocale, normalizeLocalePath; } else {\n        return false;\n    }\n}\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2dldC1kb21haW4tbG9jYWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7bURBT2dCQTs7O2VBQUFBOzs7a0RBSjJCO0FBRTNDLElBQU1DLFdBQVdDLE1BQW1DLElBQWU7QUFFNUQsU0FBU0YsZ0JBQ2RLLElBQVksRUFDWkMsTUFBdUIsRUFDdkJDLE9BQWtCLEVBQ2xCQyxhQUE4QjtJQUU5QixJQUFJTixLQUErQixFQUFFLG9GQWdCckMsTUFBTztRQUNMLE9BQU87SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L2dldC1kb21haW4tbG9jYWxlLnRzPzFkNGUiXSwibmFtZXMiOlsiZ2V0RG9tYWluTG9jYWxlIiwiYmFzZVBhdGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInBhdGgiLCJsb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwicmVxdWlyZSIsImRldGVjdERvbWFpbkxvY2FsZSIsInRhcmdldCIsImRldGVjdGVkTG9jYWxlIiwiZG9tYWluIiwidW5kZWZpbmVkIiwicHJvdG8iLCJodHRwIiwiZmluYWxMb2NhbGUiLCJkZWZhdWx0TG9jYWxlIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/image-component.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/image-component.js ***!
  \*************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\nvar _object_without_properties = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_without_properties.js\");\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nvar _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_to_consumable_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Image\", ({\n    enumerable: true,\n    get: function get() {\n        return Image;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-runtime.js\");\nvar _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\"));\nvar _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react-dom/index.js\"));\nvar _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/head */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/head.js\"));\nvar _getimgprops = __webpack_require__(/*! ../shared/lib/get-img-props */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/get-img-props.js\");\nvar _imageconfig = __webpack_require__(/*! ../shared/lib/image-config */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config.js\");\nvar _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nvar _warnonce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils/warn-once.js\");\nvar _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nvar _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-loader.js\"));\n// This is replaced by webpack define plugin\nvar configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[{\"protocol\":\"https\",\"hostname\":\"upload.wikimedia.org\",\"pathname\":\"/wikipedia/**\"}]};\nif (typeof window === \"undefined\") {\n    globalThis.__NEXT_IMAGE_IMPORTED = true;\n}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput) {\n    var src = img == null ? void 0 : img.src;\n    if (!img || img[\"data-loaded-src\"] === src) {\n        return;\n    }\n    img[\"data-loaded-src\"] = src;\n    var p = \"decode\" in img ? img.decode() : Promise.resolve();\n    p[\"catch\"](function() {}).then(function() {\n        if (!img.parentElement || !img.isConnected) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (placeholder !== \"empty\") {\n            setBlurComplete(true);\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            var event = new Event(\"load\");\n            Object.defineProperty(event, \"target\", {\n                writable: false,\n                value: img\n            });\n            var prevented = false;\n            var stopped = false;\n            onLoadRef.current(_object_spread_props._(_object_spread._({}, event), {\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: function() {\n                    return prevented;\n                },\n                isPropagationStopped: function() {\n                    return stopped;\n                },\n                persist: function() {},\n                preventDefault: function() {\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: function() {\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            }));\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            var origSrc = new URL(src, \"http://n\").searchParams.get(\"url\") || src;\n            if (img.getAttribute(\"data-nimg\") === \"fill\") {\n                if (!unoptimized && (!sizesInput || sizesInput === \"100vw\")) {\n                    var widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        if (sizesInput === \"100vw\") {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" prop and \"sizes\" prop of \"100vw\", but image is not rendered at full viewport width. Please adjust \"sizes\" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        } else {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        }\n                    }\n                }\n                if (img.parentElement) {\n                    var position = window.getComputedStyle(img.parentElement).position;\n                    var valid = [\n                        \"absolute\",\n                        \"fixed\",\n                        \"relative\"\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and parent element with invalid \"position\". Provided \"' + position + '\" should be one of ' + valid.map(String).join(\",\") + \".\");\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');\n                }\n            }\n            var heightModified = img.height.toString() !== img.getAttribute(\"height\");\n            var widthModified = img.width.toString() !== img.getAttribute(\"width\");\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.');\n            }\n        }\n    });\n}\nfunction getDynamicProps(fetchPriority) {\n    var _react_version_split = _sliced_to_array._(_react.version.split(\".\", 2), 2), majorStr = _react_version_split[0], minorStr = _react_version_split[1];\n    var major = parseInt(majorStr, 10);\n    var minor = parseInt(minorStr, 10);\n    if (major > 18 || major === 18 && minor >= 3) {\n        // In React 18.3.0 or newer, we must use camelCase\n        // prop to avoid \"Warning: Invalid DOM property\".\n        // See https://github.com/facebook/react/pull/25927\n        return {\n            fetchPriority: fetchPriority\n        };\n    }\n    // In React 18.2.0 or older, we must use lowercase prop\n    // to avoid \"Warning: Invalid DOM property\".\n    return {\n        fetchpriority: fetchPriority\n    };\n}\nvar ImageElement = /*#__PURE__*/ (0, _react.forwardRef)(function(param, forwardedRef) {\n    var src = param.src, srcSet = param.srcSet, sizes = param.sizes, height = param.height, width = param.width, decoding = param.decoding, className = param.className, style = param.style, fetchPriority = param.fetchPriority, placeholder = param.placeholder, loading = param.loading, unoptimized = param.unoptimized, fill = param.fill, onLoadRef = param.onLoadRef, onLoadingCompleteRef = param.onLoadingCompleteRef, setBlurComplete = param.setBlurComplete, setShowAltText = param.setShowAltText, sizesInput = param.sizesInput, onLoad = param.onLoad, onError = param.onError, rest = _object_without_properties._(param, [\n        \"src\",\n        \"srcSet\",\n        \"sizes\",\n        \"height\",\n        \"width\",\n        \"decoding\",\n        \"className\",\n        \"style\",\n        \"fetchPriority\",\n        \"placeholder\",\n        \"loading\",\n        \"unoptimized\",\n        \"fill\",\n        \"onLoadRef\",\n        \"onLoadingCompleteRef\",\n        \"setBlurComplete\",\n        \"setShowAltText\",\n        \"sizesInput\",\n        \"onLoad\",\n        \"onError\"\n    ]);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"img\", _object_spread_props._(_object_spread._({}, rest, getDynamicProps(fetchPriority)), {\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading: loading,\n        width: width,\n        height: height,\n        decoding: decoding,\n        \"data-nimg\": fill ? \"fill\" : \"1\",\n        className: className,\n        style: style,\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes: sizes,\n        srcSet: srcSet,\n        src: src,\n        ref: (0, _react.useCallback)(function(img) {\n            if (forwardedRef) {\n                if (typeof forwardedRef === \"function\") forwardedRef(img);\n                else if (typeof forwardedRef === \"object\") {\n                    // @ts-ignore - .current is read only it's usually assigned by react internally\n                    forwardedRef.current = img;\n                }\n            }\n            if (!img) {\n                return;\n            }\n            if (onError) {\n                // If the image has an error before react hydrates, then the error is lost.\n                // The workaround is to wait until the image is mounted which is after hydration,\n                // then we set the src again to trigger the error handler (if there was an error).\n                // eslint-disable-next-line no-self-assign\n                img.src = img.src;\n            }\n            if (true) {\n                if (!src) {\n                    console.error('Image is missing required \"src\" property:', img);\n                }\n                if (img.getAttribute(\"alt\") === null) {\n                    console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n                }\n            }\n            if (img.complete) {\n                handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n            }\n        }, [\n            src,\n            placeholder,\n            onLoadRef,\n            onLoadingCompleteRef,\n            setBlurComplete,\n            onError,\n            unoptimized,\n            sizesInput,\n            forwardedRef\n        ]),\n        onLoad: function(event) {\n            var img = event.currentTarget;\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n        },\n        onError: function(event) {\n            // if the real image fails to load, this will ensure \"alt\" is visible\n            setShowAltText(true);\n            if (placeholder !== \"empty\") {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    }));\n});\nfunction ImagePreload(param) {\n    var isAppRouter = param.isAppRouter, imgAttributes = param.imgAttributes;\n    var opts = _object_spread._({\n        as: \"image\",\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: imgAttributes.crossOrigin,\n        referrerPolicy: imgAttributes.referrerPolicy\n    }, getDynamicProps(imgAttributes.fetchPriority));\n    if (isAppRouter && _reactdom[\"default\"].preload) {\n        // See https://github.com/facebook/react/pull/26940\n        _reactdom[\"default\"].preload(imgAttributes.src, opts);\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head[\"default\"], {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", _object_spread._({\n            rel: \"preload\",\n            // Note how we omit the `href` attribute, as it would only be relevant\n            // for browsers that do not support `imagesrcset`, and in those cases\n            // it would cause the incorrect image to be preloaded.\n            //\n            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n            href: imgAttributes.srcSet ? undefined : imgAttributes.src\n        }, opts), \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)\n    });\n}\n_c = ImagePreload;\nvar Image = /*#__PURE__*/ (0, _react.forwardRef)(function(props, forwardedRef) {\n    var pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);\n    // We're in the app directory if there is no pages router.\n    var isAppRouter = !pagesRouter;\n    var configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);\n    var config = (0, _react.useMemo)(function() {\n        var c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        var allSizes = _to_consumable_array._(c.deviceSizes).concat(_to_consumable_array._(c.imageSizes)).sort(function(a, b) {\n            return a - b;\n        });\n        var deviceSizes = c.deviceSizes.sort(function(a, b) {\n            return a - b;\n        });\n        return _object_spread_props._(_object_spread._({}, c), {\n            allSizes: allSizes,\n            deviceSizes: deviceSizes\n        });\n    }, [\n        configContext\n    ]);\n    var onLoad = props.onLoad, onLoadingComplete = props.onLoadingComplete;\n    var onLoadRef = (0, _react.useRef)(onLoad);\n    (0, _react.useEffect)(function() {\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    var onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    (0, _react.useEffect)(function() {\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    var _ref = _sliced_to_array._((0, _react.useState)(false), 2), blurComplete = _ref[0], setBlurComplete = _ref[1];\n    var _ref1 = _sliced_to_array._((0, _react.useState)(false), 2), showAltText = _ref1[0], setShowAltText = _ref1[1];\n    var _ref2 = (0, _getimgprops.getImgProps)(props, {\n        defaultLoader: _imageloader[\"default\"],\n        imgConf: config,\n        blurComplete: blurComplete,\n        showAltText: showAltText\n    }), imgAttributes = _ref2.props, imgMeta = _ref2.meta;\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, _object_spread_props._(_object_spread._({}, imgAttributes), {\n                unoptimized: imgMeta.unoptimized,\n                placeholder: imgMeta.placeholder,\n                fill: imgMeta.fill,\n                onLoadRef: onLoadRef,\n                onLoadingCompleteRef: onLoadingCompleteRef,\n                setBlurComplete: setBlurComplete,\n                setShowAltText: setShowAltText,\n                sizesInput: props.sizes,\n                ref: forwardedRef\n            })),\n            imgMeta.priority ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {\n                isAppRouter: isAppRouter,\n                imgAttributes: imgAttributes\n            }) : null\n        ]\n    });\n});\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=image-component.js.map\nvar _c;\n$RefreshReg$(_c, \"ImagePreload\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLWNvbXBvbmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZFQWFpQjttREFDV0EsQ0FBQSxDQUFBQyxtQkFBQUEsQ0FBQTt1Q0FZTzs7dUNBRVZBLG1CQUFBQSxDQUFBOzs7QUFNekIsSUFBQUMsZUFBQSxjQUFBQyx5QkFBNENILENBQUEsQ0FBQUMsbUJBQUFBLENBQUE7QUFDNUMsNENBQThCRztBQUU5QixJQUFJQyxZQUFPQywyU0FBd0I7SUFDL0JFLE9BQUFBLFdBQW1CQyxhQUFBQTtJQUN2QkQsV0FBQUMscUJBQUE7QUFtQkE7QUFDQSwwRUFBaUQ7QUFDakQsaURBR0VDO1NBTUFDLGNBQVlDLEdBQUFBLEVBQUFBLFdBQUFBLEVBQUFBLFNBQVEsRUFBQUMsb0JBQUEsRUFBQUMsZUFBQSxFQUFBQyxXQUFBLEVBQUFDLFVBQUE7SUFDcEIsSUFBS0osTUFBT0EsT0FBSSxnQkFBa0JBLElBQUtLLEdBQUFBO1FBQ3JDLENBQUFMLE9BQUFBLEdBQUEsd0JBQUFLLEtBQUE7UUFDRjtJQUNBTDtJQUNBQSxHQUFBLG1CQUFzQkEsR0FBQUE7SUFDdEJNLElBQUVDLElBQU0sWUFBZVAsTUFBQUEsSUFBQVEsTUFBQSxLQUFBQyxRQUFBQyxPQUFBO2NBQ3JCLENBQUksWUFBS0MsR0FBQUEsSUFBQUEsQ0FBQUE7WUFDUCxDQUFBWCxJQUFBVyxhQUFBLEtBQUFYLElBQUFZLFdBQUEsRUFBd0M7WUFDeEMsd0NBQXVCO1lBQ3ZCO1lBQ0Esc0NBQXNCO1lBQ3RCO1lBQ0E7WUFDRjtRQUNBO1lBQ0VWLGdCQUFnQjtZQUNsQkEsZ0JBQUE7UUFDQTtZQUNFSixhQUFBLGdCQUFBQSxVQUFBZSxPQUFBLEVB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QztRQUNSaEYsT0FBQUEsU0FBVWUsRUFBTztRQUNoQmYsVUFBQWUsT0FBQSxHQUFBaUU7O1FBQVFBO0tBRVg7SUFFQXdDLElBQUFBLHVCQUFVLElBQUFmLE9BQUFnQixNQUFBLEVBQUFDO1FBQ1J2SCxPQUFBQSxTQUFBQSxFQUFBQTtRQUNDQSxxQkFBQVksT0FBQSxHQUFBMkc7O1FBQW1CQTtLQUV0QjtJQUNBLElBQXNDQywwQkFBQUEsQ0FBQUEsR0FBQUEsT0FBQUEsUUFBUyxjQUF4Q0MsZUFBK0JELFNBQWxCMUMsa0JBQWtCMEM7SUFFdEMsSUFBb0NFLDJCQUFBQSxDQUFBQSxHQUFBQSxPQUFZQyxRQUFBQSxFQUFBQSxZQUExQ0YsY0FBOEJDLFVBQXJCekMsaUJBQXFCeUM7UUFDckIsWUFBQUUsYUFBQUQsV0FBQSxFQUFBRSxPQUFBO1FBQ2JDLGVBQVNyQixZQUFBQSxDQUFBQSxVQUFBQTtRQUNUc0IsU0FBQUE7UUFDQU4sY0FBQUE7UUFDRkEsYUFBQUE7SUFFQSxJQU5FTyxnQkFBYSxNQUFiQSxPQUFBQSxVQUFhLE1BQWJBOzs7dUJBVVUvQyxHQUFBQSxDQUFBQSxHQUFBQSxZQUFhZCxHQUFBLEVBQUE4RCxjQUFBLDRDQUNqQi9IO2dCQUNBMEUsYUFBYThDLFFBQVE5QyxXQUFXO2dCQUNoQ3NELGFBQU1SLFFBQVk5QyxXQUFBO2dCQUNsQi9FLE1BQUFBLFFBQVdBLElBQUFBO2dCQUNYRyxXQUFBQTtnQkFDQUMsc0JBQWlCQTtnQkFDakI2RSxpQkFBZ0JBO2dCQUNoQjNFLGdCQUFZMEg7Z0JBQ1p2RCxZQUFLRSxNQUFBQSxLQUFBQTs7O29CQUtMZ0IsUUFBQUEsR0FBYUEsV0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsWUFBQUEsR0FBQUEsRUFBQUEsY0FBQUE7Z0JBQ2JQLGFBQUFBOytCQUVBQTs7O0lBR1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9jbGllbnQvaW1hZ2UtY29tcG9uZW50LnRzeD81MWUxIl0sIm5hbWVzIjpbIl8iLCJyZXF1aXJlIiwiX2ltYWdlbG9hZGVyIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiX19ORVhUX0lNQUdFX09QVFMiLCJjb25maWdFbnYiLCJ3aW5kb3ciLCJlbnYiLCJnbG9iYWxUaGlzIiwiX19ORVhUX0lNQUdFX0lNUE9SVEVEIiwib25Mb2FkUmVmIiwiaGFuZGxlTG9hZGluZyIsImltZyIsIm9uTG9hZGluZ0NvbXBsZXRlUmVmIiwic2V0Qmx1ckNvbXBsZXRlIiwidW5vcHRpbWl6ZWQiLCJzaXplc0lucHV0Iiwic3JjIiwicCIsImNhdGNoIiwiZGVjb2RlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwYXJlbnRFbGVtZW50IiwiaXNDb25uZWN0ZWQiLCJjdXJyZW50IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJldmVudCIsIndyaXRhYmxlIiwidmFsdWUiLCJzdG9wcGVkIiwibmF0aXZlRXZlbnQiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0IiwiaXNEZWZhdWx0UHJldmVudGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJwcmV2ZW50ZWQiLCJwZXJzaXN0IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJwcm9jZXNzIiwiZ2V0QXR0cmlidXRlIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwiZ2V0Iiwid2lkdGhWaWV3cG9ydFJhdGlvIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJpbm5lcldpZHRoIiwid2Fybk9uY2UiLCJfd2Fybm9uY2UiLCJvcmlnU3JjIiwidmFsaWQiLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJtYXAiLCJTdHJpbmciLCJqb2luIiwid2lkdGhNb2RpZmllZCIsInRvU3RyaW5nIiwiaGVpZ2h0TW9kaWZpZWQiLCJnZXREeW5hbWljUHJvcHMiLCJtaW5vclN0ciIsInZlcnNpb24iLCJtYWpvclN0ciIsInNwbGl0IiwibWFqb3IiLCJwYXJzZUludCIsIm1pbm9yIiwiZmV0Y2hQcmlvcml0eSIsImZldGNocHJpb3JpdHkiLCJoZWlnaHQiLCJkZWNvZGluZyIsImNsYXNzTmFtZSIsInN0eWxlIiwic3JjU2V0Iiwic2l6ZXMiLCJyZXN0IiwiX2pzeHJ1bnRpbWUiLCJqc3giLCJsb2FkaW5nIiwiZGF0YS1uaW1nIiwicmVmIiwidXNlQ2FsbGJhY2siLCJmb3J3YXJkZWRSZWYiLCJvbkVycm9yIiwiY29uc29sZSIsImVycm9yIiwicGxhY2Vob2xkZXIiLCJvbkxvYWQiLCJzZXRTaG93QWx0VGV4dCIsIkltYWdlUHJlbG9hZCIsInBhcmFtIiwiaW1nQXR0cmlidXRlcyIsIm9wdHMiLCJhcyIsImltYWdlU3JjU2V0IiwiaW1hZ2VTaXplcyIsImNyb3NzT3JpZ2luIiwicmVmZXJyZXJQb2xpY3kiLCJpc0FwcFJvdXRlciIsIl9yZWFjdGRvbSIsImRlZmF1bHQiLCJwcmVsb2FkIiwiUmVhY3RET00iLCJfaGVhZCIsImxpbmsiLCJyZWwiLCJocmVmIiwidW5kZWZpbmVkIiwiSW1hZ2UiLCJ1c2VDb250ZXh0IiwicGFnZXNSb3V0ZXIiLCJSb3V0ZXJDb250ZXh0IiwiX3JlYWN0IiwiX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiY29uZmlnQ29udGV4dCIsImNvbmZpZyIsInVzZU1lbW8iLCJfaW1hZ2Vjb25maWdjb250ZXh0c2hhcmVkcnVudGltZSIsIkltYWdlQ29uZmlnQ29udGV4dCIsImFsbFNpemVzIiwiX2ltYWdlY29uZmlnIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiZGV2aWNlU2l6ZXMiLCJjIiwic29ydCIsImEiLCJiIiwidXNlRWZmZWN0IiwidXNlUmVmIiwib25Mb2FkaW5nQ29tcGxldGUiLCJ1c2VTdGF0ZSIsInNob3dBbHRUZXh0IiwiaW1nTWV0YSIsImdldEltZ1Byb3BzIiwiX2dldGltZ3Byb3BzIiwicHJvcHMiLCJpbWdDb25mIiwiYmx1ckNvbXBsZXRlIiwiZGVmYXVsdExvYWRlciIsIkltYWdlRWxlbWVudCIsImZpbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/image-component.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/link.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/link.js ***!
  \**************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\nvar _object_without_properties = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_without_properties.js\");\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nvar _type_of = __webpack_require__(/*! @swc/helpers/_/_type_of */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_type_of.js\");\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function get() {\n        return _default;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-runtime.js\");\nvar _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\"));\nvar _resolvehref = __webpack_require__(/*! ./resolve-href */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/resolve-href.js\");\nvar _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nvar _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils.js\");\nvar _addlocale = __webpack_require__(/*! ./add-locale */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/add-locale.js\");\nvar _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nvar _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nvar _useintersection = __webpack_require__(/*! ./use-intersection */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/use-intersection.js\");\nvar _getdomainlocale = __webpack_require__(/*! ./get-domain-locale */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/get-domain-locale.js\");\nvar _addbasepath = __webpack_require__(/*! ./add-base-path */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/add-base-path.js\");\nvar _routerreducertypes = __webpack_require__(/*! ./components/router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nvar prefetched = new Set();\nfunction prefetch(router, href, as, options, appOptions, isAppRouter) {\n    if (typeof window === \"undefined\") {\n        return;\n    }\n    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    if (!isAppRouter && !(0, _islocalurl.isLocalURL)(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        var locale = typeof options.locale !== \"undefined\" ? options.locale : \"locale\" in router ? router.locale : undefined;\n        var prefetchedKey = href + \"%\" + as + \"%\" + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    var prefetchPromise = isAppRouter ? router.prefetch(href, appOptions) : router.prefetch(href, as, options);\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    Promise.resolve(prefetchPromise)[\"catch\"](function(err) {\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    var eventTarget = event.currentTarget;\n    var target = eventTarget.getAttribute(\"target\");\n    return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter) {\n    var nodeName = e.currentTarget.nodeName;\n    // anchors inside an svg have a lowercase nodeName\n    var isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    !isAppRouter && !(0, _islocalurl.isLocalURL)(href))) {\n        // ignore click for browser’s default behavior\n        return;\n    }\n    e.preventDefault();\n    var navigate = function() {\n        // If the router is an NextRouter instance it will have `beforePopState`\n        var routerScroll = scroll != null ? scroll : true;\n        if (\"beforePopState\" in router) {\n            router[replace ? \"replace\" : \"push\"](href, as, {\n                shallow: shallow,\n                locale: locale,\n                scroll: routerScroll\n            });\n        } else {\n            router[replace ? \"replace\" : \"push\"](as || href, {\n                scroll: routerScroll\n            });\n        }\n    };\n    if (isAppRouter) {\n        _react[\"default\"].startTransition(navigate);\n    } else {\n        navigate();\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === \"string\") {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\n/**\n * A React component that extends the HTML `<a>` element to provide [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)\n * and client-side navigation between routes.\n *\n * It is the primary way to navigate between routes in Next.js.\n *\n * Read more: [Next.js docs: `<Link>`](https://nextjs.org/docs/app/api-reference/components/link)\n */ var Link = /*#__PURE__*/ _s(_react[\"default\"].forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n    _s();\n    var children;\n    var hrefProp = props.href, asProp = props.as, childrenProp = props.children, tmp = props.prefetch, prefetchProp = tmp === void 0 ? null : tmp, passHref = props.passHref, replace = props.replace, shallow = props.shallow, scroll = props.scroll, locale = props.locale, onClick = props.onClick, onMouseEnterProp = props.onMouseEnter, onTouchStartProp = props.onTouchStart, _props_legacyBehavior = props.legacyBehavior, legacyBehavior = _props_legacyBehavior === void 0 ? false : _props_legacyBehavior, restProps = _object_without_properties._(props, [\n        \"href\",\n        \"as\",\n        \"children\",\n        \"prefetch\",\n        \"passHref\",\n        \"replace\",\n        \"shallow\",\n        \"scroll\",\n        \"locale\",\n        \"onClick\",\n        \"onMouseEnter\",\n        \"onTouchStart\",\n        \"legacyBehavior\"\n    ]);\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n        children = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            children: children\n        });\n    }\n    var pagesRouter = _react[\"default\"].useContext(_routercontextsharedruntime.RouterContext);\n    var appRouter = _react[\"default\"].useContext(_approutercontextsharedruntime.AppRouterContext);\n    var router = pagesRouter != null ? pagesRouter : appRouter;\n    // We're in the app directory if there is no pages router.\n    var isAppRouter = !pagesRouter;\n    var prefetchEnabled = prefetchProp !== false;\n    /**\n     * The possible states for prefetch are:\n     * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n     * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n     * - false: we will not prefetch if in the viewport at all\n     */ var appPrefetchKind = prefetchProp === null ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;\n    if (true) {\n        var createPropError = function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + (typeof window !== \"undefined\" ? \"\\nOpen your browser's console to view the Component stack trace.\" : \"\"));\n        };\n        // TypeScript trick for type-guarding:\n        var requiredPropsGuard = {\n            href: true\n        };\n        var requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach(function(key) {\n            if (key === \"href\") {\n                if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`string` or `object`\",\n                        actual: props[key] === null ? \"null\" : _type_of._(props[key])\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                var _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        var optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        var optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach(function(key) {\n            var valType = _type_of._(props[key]);\n            if (key === \"as\") {\n                if (props[key] && valType !== \"string\" && valType !== \"object\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`string` or `object`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"locale\") {\n                if (props[key] && valType !== \"string\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`string`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n                if (props[key] && valType !== \"function\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`function`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n                if (props[key] != null && valType !== \"boolean\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`boolean`\",\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                var _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        var hasWarned = _react[\"default\"].useRef(false);\n        if (props.prefetch && !hasWarned.current && !isAppRouter) {\n            hasWarned.current = true;\n            console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n        }\n    }\n    if (true) {\n        if (isAppRouter && !asProp) {\n            var href;\n            if (typeof hrefProp === \"string\") {\n                href = hrefProp;\n            } else if (typeof hrefProp === \"object\" && typeof hrefProp.pathname === \"string\") {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                var hasDynamicSegment = href.split(\"/\").some(function(segment) {\n                    return segment.startsWith(\"[\") && segment.endsWith(\"]\");\n                });\n                if (hasDynamicSegment) {\n                    throw new Error(\"Dynamic href `\" + href + \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\");\n                }\n            }\n        }\n    }\n    var _react_default_useMemo = _react[\"default\"].useMemo(function() {\n        if (!pagesRouter) {\n            var resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n        var _ref = _sliced_to_array._((0, _resolvehref.resolveHref)(pagesRouter, hrefProp, true), 2), resolvedHref1 = _ref[0], resolvedAs = _ref[1];\n        return {\n            href: resolvedHref1,\n            as: asProp ? (0, _resolvehref.resolveHref)(pagesRouter, asProp) : resolvedAs || resolvedHref1\n        };\n    }, [\n        pagesRouter,\n        hrefProp,\n        asProp\n    ]), href1 = _react_default_useMemo.href, as = _react_default_useMemo.as;\n    var previousHref = _react[\"default\"].useRef(href1);\n    var previousAs = _react[\"default\"].useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    var child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n            }\n            try {\n                child = _react[\"default\"].Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\");\n                }\n                throw new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + (typeof window !== \"undefined\" ? \" \\nOpen your browser's console to view the Component stack trace.\" : \"\"));\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === \"a\") {\n                throw new Error(\"Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor\");\n            }\n        }\n    }\n    var childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n    var _ref = _sliced_to_array._((0, _useintersection.useIntersection)({\n        rootMargin: \"200px\"\n    }), 3), setIntersectionRef = _ref[0], isVisible = _ref[1], resetVisible = _ref[2];\n    var setRef = _react[\"default\"].useCallback(function(el) {\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href1) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href1;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === \"function\") childRef(el);\n            else if (typeof childRef === \"object\") {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href1,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react[\"default\"].useEffect(function() {\n        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n        if (true) {\n            return;\n        }\n        if (!router) {\n            return;\n        }\n        // If we don't need to prefetch the URL, don't do prefetch.\n        if (!isVisible || !prefetchEnabled) {\n            return;\n        }\n        // Prefetch the URL.\n        prefetch(router, href1, as, {\n            locale: locale\n        }, {\n            kind: appPrefetchKind\n        }, isAppRouter);\n    }, [\n        as,\n        href1,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        pagesRouter == null ? void 0 : pagesRouter.locale,\n        router,\n        isAppRouter,\n        appPrefetchKind\n    ]);\n    var childProps = {\n        ref: setRef,\n        onClick: function(e) {\n            if (true) {\n                if (!e) {\n                    throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                }\n            }\n            if (!legacyBehavior && typeof onClick === \"function\") {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href1, as, replace, shallow, scroll, locale, isAppRouter);\n        },\n        onMouseEnter: function(e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === \"function\") {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if ((!prefetchEnabled || \"development\" === \"development\") && isAppRouter) {\n                return;\n            }\n            prefetch(router, href1, as, {\n                locale: locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        },\n        onTouchStart:  false ? 0 : function onTouchStart(e) {\n            if (!legacyBehavior && typeof onTouchStartProp === \"function\") {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href1, as, {\n                locale: locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n        var curLocale = typeof locale !== \"undefined\" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        var localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getdomainlocale.getDomainLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n        childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react[\"default\"].cloneElement(child, childProps) : /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", _object_spread_props._(_object_spread._({}, restProps, childProps), {\n        children: children\n    }));\n}, \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\")), \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\");\n_c1 = Link;\nvar _default = Link;\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xpbmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyQkFTNEJBLHlCQUFBQyxDQUFBLENBQUFDLG1CQUFBQSxDQUFBO3VDQUNEO3NDQUNEO3FDQUNJOzs7O3FDQVFFQSxtQkFBQUEsQ0FBQTsyQ0FDQTsyQ0FDSjs7QUEyRjVCLElBQU1DLHNCQUFpQkMsbUJBQUFBLENBQUFBLHNQQUFBQTtBQVV2QixJQUFBRCxhQUNFRSxJQUFBQTtTQU9JQyxTQUFPQyxNQUFBQSxFQUFXQyxJQUFBLEVBQUFDLEVBQUEsRUFBQUMsT0FBYSxFQUFBQyxVQUFBLEVBQUFDLFdBQUE7UUFDakMsT0FBQUwsV0FBQTtRQUNGO0lBRUE7SUFDQSxnSkFBdUM7UUFDckMsQ0FBQUssZUFBQSxLQUFBQyxZQUFBQyxVQUFBLEVBQUFOLE9BQUE7UUFDRjtJQUVBO0lBQ0EsNEVBQVk7SUFDWixZQUFLRTtRQUNILENBQUFBLFFBQU1LLHFCQUNKO1FBQ0EsSUFBQUEsU0FPRixPQUFNQyxRQUFBQSxNQUFBQSxLQUFnQlIsY0FBa0JFLFFBQU1LLE1BQUFBLEdBQUFBLFlBQUFBLFNBQUFBLE9BQUFBLE1BQUFBLEdBQUFBO1FBRTlDLElBQUFDLGdCQUFBUixPQUFBLE1BQUFDLEtBQUEsTUFBQU07UUFDQSxrRUFBbUM7WUFDakNaLFdBQUFjLEdBQUEsQ0FBQUQsZ0JBQUE7WUFDRjtRQUVBO1FBQ0FiLCtCQUFlYTtRQUNqQmIsV0FBQWUsR0FBQSxDQUFBRjtJQUVBO0lBSUEsSUFBQUcsa0JBQUFQLGNBQUFQLE9BQUFDLFFBQUEsQ0FBQUUsTUFBdURHLGNBQUFOLE9BQUFDLFFBQUEsQ0FBQUUsTUFBQUMsSUFBQUM7SUFDdkQ7SUFDQSwwREFB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QUEsU0FBQThDLGVBQXVFLGdCQUFBQSxZQUFBOUMsTUFBQTtRQUN2RSx1RUFBdUU7UUFDdkUsdUVBQ2VtSDtRQVFmRixJQUFBQSxlQUNFRyxDQUFBQSxlQUNBQyxPQUFBQSxLQUFBQSxJQUFBQSxZQUFZQyxjQUFBQSxLQUFBQSxDQUFBQSxHQUFTQyxpQkFBZ0J6RSxlQUFBQSxFQUFBQSxJQUFBQSxXQUFBQSxlQUFhMEUsT0FBQUEsS0FBYSxJQUFBMUUsWUFBQTJFLE9BQUEsRUFBQTNFLGVBQUEsZ0JBQUFBLFlBQUE0RSxhQUFBO1FBQ25FVCxXQUFBeEgsSUFBQSxHQUFBMkgsZ0JBQUEsSUFBQU8sYUFBQU4sV0FBQSxNQUFBTyxXQUFBTixTQUFBLEVBQUE1SCxJQUFBd0gsV0FBQXBFLGVBQUEsZ0JBQUFBLFlBQUEwRSxhQUFBO0lBRUE7V0FHU0ssaUJBQVMsY0FBQTdGLE1BQUFDLENBQUFBLFVBQUEsQ0FBQTZGLFlBQUEsQ0FBQXRDLE9BQUF5QixjQUFBLGtCQUFBYyxZQUFBQyxHQUFBLG1EQUFNZiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2NsaWVudC9saW5rLnRzeD9hY2YwIl0sIm5hbWVzIjpbIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsIl8iLCJyZXF1aXJlIiwicHJlZmV0Y2hlZCIsIlNldCIsInJvdXRlciIsInByZWZldGNoIiwid2luZG93IiwiaHJlZiIsImFzIiwib3B0aW9ucyIsImFwcE9wdGlvbnMiLCJpc0FwcFJvdXRlciIsIl9pc2xvY2FsdXJsIiwiaXNMb2NhbFVSTCIsImxvY2FsZSIsInByZWZldGNoZWRLZXkiLCJoYXMiLCJhZGQiLCJwcmVmZXRjaFByb21pc2UiLCJQcm9taXNlIiwiZXJyIiwicHJvY2VzcyIsImVudiIsImNhdGNoIiwiaXNNb2RpZmllZEV2ZW50IiwiZXZlbnQiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0IiwiZXZlbnRUYXJnZXQiLCJuYXRpdmVFdmVudCIsIndoaWNoIiwibWV0YUtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsImxpbmtDbGlja2VkIiwiZSIsInJlcGxhY2UiLCJzaGFsbG93Iiwic2Nyb2xsIiwibm9kZU5hbWUiLCJpc0FuY2hvck5vZGVOYW1lIiwicHJldmVudERlZmF1bHQiLCJuYXZpZ2F0ZSIsInJvdXRlclNjcm9sbCIsIlJlYWN0IiwiX3JlYWN0IiwiZGVmYXVsdCIsInN0YXJ0VHJhbnNpdGlvbiIsImZvcm1hdFN0cmluZ09yVXJsIiwidXJsT2JqT3JTdHJpbmciLCJfZm9ybWF0dXJsIiwiZm9ybWF0VXJsIiwiY2hpbGRyZW4iLCJjaGlsZHJlblByb3AiLCJsZWdhY3lCZWhhdmlvciIsImEiLCJhcHBSb3V0ZXIiLCJ1c2VDb250ZXh0IiwiQXBwUm91dGVyQ29udGV4dCIsInBhZ2VzUm91dGVyIiwicHJlZmV0Y2hFbmFibGVkIiwicHJlZmV0Y2hQcm9wIiwiX3JvdXRlcnJlZHVjZXJ0eXBlcyIsIlByZWZldGNoS2luZCIsIkFVVE8iLCJGVUxMIiwiYXJncyIsImNyZWF0ZVByb3BFcnJvciIsIkVycm9yIiwia2V5IiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJyZXF1aXJlZFByb3BzIiwiT2JqZWN0IiwicHJvcHMiLCJwYXNzSHJlZiIsIm9uQ2xpY2siLCJvbk1vdXNlRW50ZXIiLCJvblRvdWNoU3RhcnQiLCJvcHRpb25hbFByb3BzIiwidmFsVHlwZSIsImhhc1dhcm5lZCIsImN1cnJlbnQiLCJjb25zb2xlIiwid2FybiIsImFzUHJvcCIsImhyZWZQcm9wIiwicGF0aG5hbWUiLCJoYXNEeW5hbWljU2VnbWVudCIsInNwbGl0Iiwic29tZSIsInNlZ21lbnQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJ1c2VNZW1vIiwicmVzb2x2ZWRIcmVmIiwiX3Jlc29sdmVocmVmIiwicmVzb2x2ZUhyZWYiLCJyZXNvbHZlZEFzIiwicHJldmlvdXNBcyIsInVzZVJlZiIsImNoaWxkIiwiTk9ERV9FTlYiLCJDaGlsZHJlbiIsIm9ubHkiLCJ0eXBlIiwiY2hpbGRSZWYiLCJzZXRJbnRlcnNlY3Rpb25SZWYiLCJpc1Zpc2libGUiLCJyZXNldFZpc2libGUiLCJ1c2VJbnRlcnNlY3Rpb24iLCJfdXNlaW50ZXJzZWN0aW9uIiwicm9vdE1hcmdpbiIsInNldFJlZiIsInVzZUNhbGxiYWNrIiwiZWwiLCJwcmV2aW91c0hyZWYiLCJ1c2VFZmZlY3QiLCJhcHBQcmVmZXRjaEtpbmQiLCJyZWYiLCJkZWZhdWx0UHJldmVudGVkIiwib25Nb3VzZUVudGVyUHJvcCIsInByaW9yaXR5IiwiYnlwYXNzUHJlZmV0Y2hlZENoZWNrIiwib25Ub3VjaFN0YXJ0UHJvcCIsInVuZGVmaW5lZCIsImNoaWxkUHJvcHMiLCJjdXJMb2NhbGUiLCJpc0xvY2FsZURvbWFpbiIsImxvY2FsZURvbWFpbiIsImFkZEJhc2VQYXRoIiwiYWRkTG9jYWxlIiwiX2dldGRvbWFpbmxvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsIl9hZGRiYXNlcGF0aCIsIl9hZGRsb2NhbGUiLCJyZXN0UHJvcHMiLCJjbG9uZUVsZW1lbnQiLCJfanN4cnVudGltZSIsImpzeCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/request-idle-callback.js":
/*!*******************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/request-idle-callback.js ***!
  \*******************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    cancelIdleCallback: function cancelIdleCallback1() {\n        return cancelIdleCallback;\n    },\n    requestIdleCallback: function requestIdleCallback1() {\n        return requestIdleCallback;\n    }\n});\nvar requestIdleCallback = typeof self !== \"undefined\" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    var start = Date.now();\n    return self.setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function timeRemaining() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nvar cancelIdleCallback = typeof self !== \"undefined\" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFnQmFBLG9CQUFrQixTQUFsQkE7ZUFBQUE7O0lBaEJBQyxxQkFBbUIsU0FBbkJBO2VBQUFBOzs7QUFBTixJQUFNQSxzQkFDWCxPQUFRQyxTQUFTLGVBQ2ZBLEtBQUtELG1CQUFtQixJQUN4QkMsS0FBS0QsbUJBQW1CLENBQUNFLElBQUksQ0FBQ0MsV0FDaEMsU0FBVUMsRUFBdUI7SUFDL0IsSUFBSUMsUUFBUUMsS0FBS0MsR0FBRztJQUNwQixPQUFPTixLQUFLTyxVQUFVLENBQUM7UUFDckJKLEdBQUc7WUFDREssWUFBWTtZQUNaQyxlQUFlLFNBQWZBO2dCQUNFLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLEtBQU1OLENBQUFBLEtBQUtDLEdBQUcsS0FBS0YsS0FBQUE7WUFDeEM7UUFDRjtJQUNGLEdBQUc7QUFDTDtBQUVLLElBQU1OLHFCQUNYLE9BQVFFLFNBQVMsZUFDZkEsS0FBS0Ysa0JBQWtCLElBQ3ZCRSxLQUFLRixrQkFBa0IsQ0FBQ0csSUFBSSxDQUFDQyxXQUMvQixTQUFVVSxFQUFVO0lBQ2xCLE9BQU9DLGFBQWFEO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay50cz8wNWY0Il0sIm5hbWVzIjpbImNhbmNlbElkbGVDYWxsYmFjayIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJzZWxmIiwiYmluZCIsIndpbmRvdyIsImNiIiwic3RhcnQiLCJEYXRlIiwibm93Iiwic2V0VGltZW91dCIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiTWF0aCIsIm1heCIsImlkIiwiY2xlYXJUaW1lb3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/resolve-href.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/resolve-href.js ***!
  \**********************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"resolveHref\", ({\n    enumerable: true,\n    get: function get() {\n        return resolveHref;\n    }\n}));\nvar _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nvar _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nvar _omit = __webpack_require__(/*! ../shared/lib/router/utils/omit */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/omit.js\");\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils.js\");\nvar _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/normalize-trailing-slash.js\");\nvar _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nvar _utils1 = __webpack_require__(/*! ../shared/lib/router/utils */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/index.js\");\nvar _interpolateas = __webpack_require__(/*! ../shared/lib/router/utils/interpolate-as */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    var base;\n    var urlAsString = typeof href === \"string\" ? href : (0, _formaturl.formatWithValidation)(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    var urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    var urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    var urlParts = urlAsStringNoProto.split(\"?\", 1);\n    if ((urlParts[0] || \"\").match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n        var normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : \"\") + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith(\"#\") ? router.asPath : router.pathname, \"http://n\");\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL(\"/\", \"http://n\");\n    }\n    try {\n        var finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n        var interpolatedAs = \"\";\n        if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            var query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n            var _ref = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query), result = _ref.result, params = _ref.params;\n            if (result) {\n                interpolatedAs = (0, _formaturl.formatWithValidation)({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: (0, _omit.omit)(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        var resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=resolve-href.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3Jlc29sdmUtaHJlZi5qcyIsIm1hcHBpbmdzIjoiOzs7OytDQXlCZ0JBOzs7ZUFBQUE7Ozt1Q0F2QnVCO3FDQUNGO2dDQUNoQjtpQ0FDb0I7a0RBQ0U7c0NBQ2hCO2tDQUNJO3lDQUNEO0FBZ0J2QixTQUFTQSxZQUNkQyxNQUFrQixFQUNsQkMsSUFBUyxFQUNUQyxTQUFtQjtJQUVuQiw0Q0FBNEM7SUFDNUMsSUFBSUM7SUFDSixJQUFJQyxjQUFjLE9BQU9ILFNBQVMsV0FBV0EsT0FBT0ksQ0FBQUEsR0FBQUEsV0FBQUEsb0JBQW9CLEVBQUNKO0lBRXpFLDZEQUE2RDtJQUM3RCxtREFBbUQ7SUFDbkQsSUFBTUssZ0JBQWdCRixZQUFZRyxLQUFLLENBQUM7SUFDeEMsSUFBTUMscUJBQXFCRixnQkFDdkJGLFlBQVlLLEtBQUssQ0FBQ0gsYUFBYSxDQUFDLEVBQUUsQ0FBQ0ksTUFBTSxJQUN6Q047SUFFSixJQUFNTyxXQUFXSCxtQkFBbUJJLEtBQUssQ0FBQyxLQUFLO0lBRS9DLElBQUksQ0FBQ0QsUUFBUSxDQUFDLEVBQUUsSUFBSSxJQUFJSixLQUFLLENBQUMsY0FBYztRQUMxQ00sUUFBUUMsS0FBSyxDQUNYLG1CQUFpQlYsY0FBWSx1Q0FBb0NKLE9BQU9lLFFBQVEsR0FBQztRQUVuRixJQUFNQyxnQkFBZ0JDLENBQUFBLEdBQUFBLE9BQUFBLHdCQUF3QixFQUFDVDtRQUMvQ0osY0FBYyxDQUFDRSxnQkFBZ0JBLGFBQWEsQ0FBQyxFQUFFLEdBQUcsTUFBTVU7SUFDMUQ7SUFFQSwyREFBMkQ7SUFDM0QsSUFBSSxDQUFDRSxDQUFBQSxHQUFBQSxZQUFBQSxVQUFVLEVBQUNkLGNBQWM7UUFDNUIsT0FBUUYsWUFBWTtZQUFDRTtTQUFZLEdBQUdBO0lBQ3RDO0lBRUEsSUFBSTtRQUNGRCxPQUFPLElBQUlnQixJQUNUZixZQUFZZ0IsVUFBVSxDQUFDLE9BQU9wQixPQUFPcUIsTUFBTSxHQUFHckIsT0FBT2UsUUFBUSxFQUM3RDtJQUVKLEVBQUUsT0FBT08sR0FBRztRQUNWLGtEQUFrRDtRQUNsRG5CLE9BQU8sSUFBSWdCLElBQUksS0FBSztJQUN0QjtJQUVBLElBQUk7UUFDRixJQUFNSSxXQUFXLElBQUlKLElBQUlmLGFBQWFEO1FBQ3RDb0IsU0FBU1IsUUFBUSxHQUFHUyxDQUFBQSxHQUFBQSx3QkFBQUEsMEJBQTBCLEVBQUNELFNBQVNSLFFBQVE7UUFDaEUsSUFBSVUsaUJBQWlCO1FBRXJCLElBQ0VDLENBQUFBLEdBQUFBLFFBQUFBLGNBQWMsRUFBQ0gsU0FBU1IsUUFBUSxLQUNoQ1EsU0FBU0ksWUFBWSxJQUNyQnpCLFdBQ0E7WUFDQSxJQUFNMEIsUUFBUUMsQ0FBQUEsR0FBQUEsYUFBQUEsc0JBQXNCLEVBQUNOLFNBQVNJLFlBQVk7WUFFMUQsSUFBMkJHLE9BQUFBLENBQUFBLEdBQUFBLGVBQUFBLGFBQWEsRUFDdENQLFNBQVNSLFFBQVEsRUFDakJRLFNBQVNSLFFBQVEsRUFDakJhLFFBSE1HLFNBQW1CRCxLQUFuQkMsUUFBUUMsU0FBV0YsS0FBWEU7WUFNaEIsSUFBSUQsUUFBUTtnQkFDVk4saUJBQWlCcEIsQ0FBQUEsR0FBQUEsV0FBQUEsb0JBQW9CLEVBQUM7b0JBQ3BDVSxVQUFVZ0I7b0JBQ1ZFLE1BQU1WLFNBQVNVLElBQUk7b0JBQ25CTCxPQUFPTSxDQUFBQSxHQUFBQSxNQUFBQSxJQUFJLEVBQUNOLE9BQU9JO2dCQUNyQjtZQUNGO1FBQ0Y7UUFFQSxvRUFBb0U7UUFDcEUsSUFBTUcsZUFDSlosU0FBU2EsTUFBTSxLQUFLakMsS0FBS2lDLE1BQU0sR0FDM0JiLFNBQVN0QixJQUFJLENBQUNRLEtBQUssQ0FBQ2MsU0FBU2EsTUFBTSxDQUFDMUIsTUFBTSxJQUMxQ2EsU0FBU3RCLElBQUk7UUFFbkIsT0FBT0MsWUFDSDtZQUFDaUM7WUFBY1Ysa0JBQWtCVTtTQUFhLEdBQzlDQTtJQUNOLEVBQUUsT0FBT2IsR0FBRztRQUNWLE9BQU9wQixZQUFZO1lBQUNFO1NBQVksR0FBR0E7SUFDckM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2NsaWVudC9yZXNvbHZlLWhyZWYudHM/ZTZkMiJdLCJuYW1lcyI6WyJyZXNvbHZlSHJlZiIsInJvdXRlciIsImhyZWYiLCJyZXNvbHZlQXMiLCJiYXNlIiwidXJsQXNTdHJpbmciLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsInVybFByb3RvTWF0Y2giLCJtYXRjaCIsInVybEFzU3RyaW5nTm9Qcm90byIsInNsaWNlIiwibGVuZ3RoIiwidXJsUGFydHMiLCJzcGxpdCIsImNvbnNvbGUiLCJlcnJvciIsInBhdGhuYW1lIiwibm9ybWFsaXplZFVybCIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsImlzTG9jYWxVUkwiLCJVUkwiLCJzdGFydHNXaXRoIiwiYXNQYXRoIiwiXyIsImZpbmFsVXJsIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJpbnRlcnBvbGF0ZWRBcyIsImlzRHluYW1pY1JvdXRlIiwic2VhcmNoUGFyYW1zIiwicXVlcnkiLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IiwiaW50ZXJwb2xhdGVBcyIsInJlc3VsdCIsInBhcmFtcyIsImhhc2giLCJvbWl0IiwicmVzb2x2ZWRIcmVmIiwib3JpZ2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/resolve-href.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/use-intersection.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/use-intersection.js ***!
  \**************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useIntersection\", ({\n    enumerable: true,\n    get: function get() {\n        return useIntersection;\n    }\n}));\nvar _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\nvar _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/request-idle-callback.js\");\nvar hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nvar observers = new Map();\nvar idList = [];\nfunction createObserver(options) {\n    var id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    var existing = idList.find(function(obj) {\n        return obj.root === id.root && obj.margin === id.margin;\n    });\n    var instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    var elements = new Map();\n    var observer = new IntersectionObserver(function(entries) {\n        entries.forEach(function(entry) {\n            var callback = elements.get(entry.target);\n            var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id: id,\n        observer: observer,\n        elements: elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    var _createObserver = createObserver(options), id = _createObserver.id, observer = _createObserver.observer, elements = _createObserver.elements;\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements[\"delete\"](element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers[\"delete\"](id);\n            var index = idList.findIndex(function(obj) {\n                return obj.root === id.root && obj.margin === id.margin;\n            });\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    var rootRef = param.rootRef, rootMargin = param.rootMargin, disabled = param.disabled;\n    var isDisabled = disabled || !hasIntersectionObserver;\n    var _ref = _sliced_to_array._((0, _react.useState)(false), 2), visible = _ref[0], setVisible = _ref[1];\n    var elementRef = (0, _react.useRef)(null);\n    var setElement = (0, _react.useCallback)(function(element) {\n        elementRef.current = element;\n    }, []);\n    (0, _react.useEffect)(function() {\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            var element = elementRef.current;\n            if (element && element.tagName) {\n                var unobserve = observe(element, function(isVisible) {\n                    return isVisible && setVisible(isVisible);\n                }, {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin: rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                var idleCallback = (0, _requestidlecallback.requestIdleCallback)(function() {\n                    return setVisible(true);\n                });\n                return function() {\n                    return (0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n                };\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    var resetVisible = (0, _react.useCallback)(function() {\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7bURBK0ZnQkE7OztlQUFBQTs7O2lDQS9GeUM7K0NBSWxEO0FBcUJQLElBQU1DLDBCQUEwQixPQUFPQyx5QkFBeUI7QUFFaEUsSUFBTUMsWUFBWSxJQUFJQztBQUN0QixJQUFNQyxTQUF1QixFQUFFO0FBRS9CLFNBQVNDLGVBQWVDLE9BQW9DO0lBQzFELElBQU1DLEtBQUs7UUFDVEMsTUFBTUYsUUFBUUUsSUFBSSxJQUFJO1FBQ3RCQyxRQUFRSCxRQUFRSSxVQUFVLElBQUk7SUFDaEM7SUFDQSxJQUFNQyxXQUFXUCxPQUFPUSxJQUFJLENBQzFCLFNBQUNDO2VBQVFBLElBQUlMLElBQUksS0FBS0QsR0FBR0MsSUFBSSxJQUFJSyxJQUFJSixNQUFNLEtBQUtGLEdBQUdFLE1BQU07O0lBRTNELElBQUlLO0lBRUosSUFBSUgsVUFBVTtRQUNaRyxXQUFXWixVQUFVYSxHQUFHLENBQUNKO1FBQ3pCLElBQUlHLFVBQVU7WUFDWixPQUFPQTtRQUNUO0lBQ0Y7SUFFQSxJQUFNRSxXQUFXLElBQUliO0lBQ3JCLElBQU1jLFdBQVcsSUFBSWhCLHFCQUFxQixTQUFDaUI7UUFDekNBLFFBQVFDLE9BQU8sQ0FBQyxTQUFDQztZQUNmLElBQU1DLFdBQVdMLFNBQVNELEdBQUcsQ0FBQ0ssTUFBTUUsTUFBTTtZQUMxQyxJQUFNQyxZQUFZSCxNQUFNSSxjQUFjLElBQUlKLE1BQU1LLGlCQUFpQixHQUFHO1lBQ3BFLElBQUlKLFlBQVlFLFdBQVc7Z0JBQ3pCRixTQUFTRTtZQUNYO1FBQ0Y7SUFDRixHQUFHakI7SUFDSFEsV0FBVztRQUNUUCxJQUFBQTtRQUNBVSxVQUFBQTtRQUNBRCxVQUFBQTtJQUNGO0lBRUFaLE9BQU9zQixJQUFJLENBQUNuQjtJQUNaTCxVQUFVeUIsR0FBRyxDQUFDcEIsSUFBSU87SUFDbEIsT0FBT0E7QUFDVDtBQUVBLFNBQVNjLFFBQ1BDLE9BQWdCLEVBQ2hCUixRQUF5QixFQUN6QmYsT0FBb0M7SUFFcEMsSUFBbUNELGtCQUFBQSxlQUFlQyxVQUExQ0MsS0FBMkJGLGdCQUEzQkUsSUFBSVUsV0FBdUJaLGdCQUF2QlksVUFBVUQsV0FBYVgsZ0JBQWJXO0lBQ3RCQSxTQUFTVyxHQUFHLENBQUNFLFNBQVNSO0lBRXRCSixTQUFTVyxPQUFPLENBQUNDO0lBQ2pCLE9BQU8sU0FBU0M7UUFDZGQsUUFBU2UsQ0FBQUEsU0FBTSxDQUFDRjtRQUNoQlosU0FBU2EsU0FBUyxDQUFDRDtRQUVuQix1REFBdUQ7UUFDdkQsSUFBSWIsU0FBU2dCLElBQUksS0FBSyxHQUFHO1lBQ3ZCZixTQUFTZ0IsVUFBVTtZQUNuQi9CLFNBQVU2QixDQUFBQSxTQUFNLENBQUN4QjtZQUNqQixJQUFNMkIsUUFBUTlCLE9BQU8rQixTQUFTLENBQzVCLFNBQUN0Qjt1QkFBUUEsSUFBSUwsSUFBSSxLQUFLRCxHQUFHQyxJQUFJLElBQUlLLElBQUlKLE1BQU0sS0FBS0YsR0FBR0UsTUFBTTs7WUFFM0QsSUFBSXlCLFFBQVEsQ0FBQyxHQUFHO2dCQUNkOUIsT0FBT2dDLE1BQU0sQ0FBQ0YsT0FBTztZQUN2QjtRQUNGO0lBQ0Y7QUFDRjtBQUVPLFNBQVNuQyxnQkFBbUNzQyxLQUlqQztJQUppQyxJQUNqREMsVUFEaURELE1BQ2pEQyxTQUNBNUIsYUFGaUQyQixNQUVqRDNCLFlBQ0E2QixXQUhpREYsTUFHakRFO0lBRUEsSUFBTUMsYUFBc0JELFlBQVksQ0FBQ3ZDO0lBRXpDLElBQThCeUMsMEJBQUFBLENBQUFBLEdBQUFBLE9BQUFBLFFBQVEsRUFBQyxZQUFoQ0MsVUFBdUJELFNBQWRFLGFBQWNGO0lBQzlCLElBQU1HLGFBQWFDLENBQUFBLEdBQUFBLE9BQUFBLE1BQU0sRUFBVztJQUNwQyxJQUFNQyxhQUFhQyxDQUFBQSxHQUFBQSxPQUFBQSxXQUFXLEVBQUMsU0FBQ2xCO1FBQzlCZSxXQUFXSSxPQUFPLEdBQUduQjtJQUN2QixHQUFHLEVBQUU7SUFFTG9CLENBQUFBLEdBQUFBLE9BQUFBLFNBQVMsRUFBQztRQUNSLElBQUlqRCx5QkFBeUI7WUFDM0IsSUFBSXdDLGNBQWNFLFNBQVM7WUFFM0IsSUFBTWIsVUFBVWUsV0FBV0ksT0FBTztZQUNsQyxJQUFJbkIsV0FBV0EsUUFBUXFCLE9BQU8sRUFBRTtnQkFDOUIsSUFBTXBCLFlBQVlGLFFBQ2hCQyxTQUNBLFNBQUNOOzJCQUFjQSxhQUFhb0IsV0FBV3BCO21CQUN2QztvQkFBRWYsTUFBTThCLFdBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFFBQVNVLE9BQU87b0JBQUV0QyxZQUFBQTtnQkFBVztnQkFHdkMsT0FBT29CO1lBQ1Q7UUFDRixPQUFPO1lBQ0wsSUFBSSxDQUFDWSxTQUFTO2dCQUNaLElBQU1TLGVBQWVDLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBbUIsRUFBQzsyQkFBTVQsV0FBVzs7Z0JBQzFELE9BQU87MkJBQU1VLENBQUFBLEdBQUFBLHFCQUFBQSxrQkFBa0IsRUFBQ0Y7O1lBQ2xDO1FBQ0Y7SUFDQSx1REFBdUQ7SUFDekQsR0FBRztRQUFDWDtRQUFZOUI7UUFBWTRCO1FBQVNJO1FBQVNFLFdBQVdJLE9BQU87S0FBQztJQUVqRSxJQUFNTSxlQUFlUCxDQUFBQSxHQUFBQSxPQUFBQSxXQUFXLEVBQUM7UUFDL0JKLFdBQVc7SUFDYixHQUFHLEVBQUU7SUFFTCxPQUFPO1FBQUNHO1FBQVlKO1FBQVNZO0tBQWE7QUFDNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9jbGllbnQvdXNlLWludGVyc2VjdGlvbi50c3g/NTdlZSJdLCJuYW1lcyI6WyJ1c2VJbnRlcnNlY3Rpb24iLCJoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwib2JzZXJ2ZXJzIiwiTWFwIiwiaWRMaXN0IiwiY3JlYXRlT2JzZXJ2ZXIiLCJvcHRpb25zIiwiaWQiLCJyb290IiwibWFyZ2luIiwicm9vdE1hcmdpbiIsImV4aXN0aW5nIiwiZmluZCIsIm9iaiIsImluc3RhbmNlIiwiZ2V0IiwiZWxlbWVudHMiLCJvYnNlcnZlciIsImVudHJpZXMiLCJmb3JFYWNoIiwiZW50cnkiLCJjYWxsYmFjayIsInRhcmdldCIsImlzVmlzaWJsZSIsImlzSW50ZXJzZWN0aW5nIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJwdXNoIiwic2V0Iiwib2JzZXJ2ZSIsImVsZW1lbnQiLCJ1bm9ic2VydmUiLCJkZWxldGUiLCJzaXplIiwiZGlzY29ubmVjdCIsImluZGV4IiwiZmluZEluZGV4Iiwic3BsaWNlIiwicGFyYW0iLCJyb290UmVmIiwiZGlzYWJsZWQiLCJpc0Rpc2FibGVkIiwidXNlU3RhdGUiLCJ2aXNpYmxlIiwic2V0VmlzaWJsZSIsImVsZW1lbnRSZWYiLCJ1c2VSZWYiLCJzZXRFbGVtZW50IiwidXNlQ2FsbGJhY2siLCJjdXJyZW50IiwidXNlRWZmZWN0IiwidGFnTmFtZSIsImlkbGVDYWxsYmFjayIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJyZXNldFZpc2libGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/amp-context.shared-runtime.js":
/*!****************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/amp-context.shared-runtime.js ***!
  \****************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AmpStateContext\", ({\n    enumerable: true,\n    get: function get() {\n        return AmpStateContext;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\"));\nvar AmpStateContext = _react[\"default\"].createContext({});\nif (true) {\n    AmpStateContext.displayName = \"AmpStateContext\";\n} //# sourceMappingURL=amp-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQUVhQTs7O2VBQUFBOzs7OzBFQUZLO0FBRVgsSUFBTUEsa0JBQXNDQyxNQUFBQSxDQUFBQSxVQUFLLENBQUNDLGFBQWEsQ0FBQyxDQUFDO0FBRXhFLElBQUlDLElBQXlCLEVBQWM7SUFDekNILGdCQUFnQkksV0FBVyxHQUFHO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS50cz85NjQxIl0sIm5hbWVzIjpbIkFtcFN0YXRlQ29udGV4dCIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/amp-mode.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/amp-mode.js ***!
  \**********************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isInAmpMode\", ({\n    enumerable: true,\n    get: function get() {\n        return isInAmpMode;\n    }\n}));\nfunction isInAmpMode(param) {\n    var _ref = param === void 0 ? {} : param, _ref_ampFirst = _ref.ampFirst, ampFirst = _ref_ampFirst === void 0 ? false : _ref_ampFirst, _ref_hybrid = _ref.hybrid, hybrid = _ref_hybrid === void 0 ? false : _ref_hybrid, _ref_hasQuery = _ref.hasQuery, hasQuery = _ref_hasQuery === void 0 ? false : _ref_hasQuery;\n    return ampFirst || hybrid && hasQuery;\n} //# sourceMappingURL=amp-mode.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtbW9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7OytDQUFnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0EsWUFBWUMsS0FBQTtJQUFBLElBQUFBLE9BQUFBLFVBQUEsU0FJeEIsQ0FBQyxJQUp1QkEsdUJBQUFBLEtBQzFCQyxVQUFBQSxzQ0FBVyxxQ0FEZUQsS0FFMUJFLFFBQUFBLGtDQUFTLHFDQUZpQkYsS0FHMUJHLFVBQUFBLHNDQUFXO0lBRVgsT0FBT0YsWUFBYUMsVUFBVUM7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2FtcC1tb2RlLnRzP2NlMDQiXSwibmFtZXMiOlsiaXNJbkFtcE1vZGUiLCJwYXJhbSIsImFtcEZpcnN0IiwiaHlicmlkIiwiaGFzUXVlcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/amp-mode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/app-dynamic.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/app-dynamic.js ***!
  \*************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function get() {\n        return dynamic;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-runtime.js\");\nvar _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\"));\nvar _loadable = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./lazy-dynamic/loadable */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/lazy-dynamic/loadable.js\"));\nfunction dynamic(dynamicOptions, options) {\n    var _mergedOptions_loadableGenerated;\n    var loadableOptions = {\n        // A loading component is not required, so we default it\n        loading: function(param) {\n            var error = param.error, isLoading = param.isLoading, pastDelay = param.pastDelay;\n            if (!pastDelay) return null;\n            if (true) {\n                if (isLoading) {\n                    return null;\n                }\n                if (error) {\n                    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"p\", {\n                        children: [\n                            error.message,\n                            /*#__PURE__*/ (0, _jsxruntime.jsx)(\"br\", {}),\n                            error.stack\n                        ]\n                    });\n                }\n            }\n            return null;\n        }\n    };\n    if (typeof dynamicOptions === \"function\") {\n        loadableOptions.loader = dynamicOptions;\n    }\n    var mergedOptions = _object_spread._({}, loadableOptions, options);\n    return (0, _loadable[\"default\"])(_object_spread_props._(_object_spread._({}, mergedOptions), {\n        modules: (_mergedOptions_loadableGenerated = mergedOptions.loadableGenerated) == null ? void 0 : _mergedOptions_loadableGenerated.modules\n    }));\n}\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=app-dynamic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hcHAtZHluYW1pYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7MkNBaUNBOzs7ZUFBd0JBOzs7OzswRUFqQ047NkVBQ0c7QUFnQ04sU0FBU0EsUUFDdEJDLGNBQTZDLEVBQzdDQyxPQUEyQjtRQW1DaEJDO0lBakNYLElBQUlDLGtCQUFzQztRQUN4Qyx3REFBd0Q7UUFDeERDLFNBQVMsU0FBQUM7Z0JBQUdDLFFBQTZCRCxNQUE3QkMsT0FBT0MsWUFBc0JGLE1BQXRCRSxXQUFXQyxZQUFXSCxNQUFYRztZQUM1QixJQUFJLENBQUNBLFdBQVcsT0FBTztZQUN2QixJQUFJQyxJQUF5QixFQUFjO2dCQUN6QyxJQUFJRixXQUFXO29CQUNiLE9BQU87Z0JBQ1Q7Z0JBQ0EsSUFBSUQsT0FBTztvQkFDVCxPQUNFLFdBREYsR0FDRSxJQUFBSSxZQUFBQyxJQUFBLEVBQUNDLEtBQUFBOzs0QkFDRU4sTUFBTU8sT0FBTzswQ0FDZCxJQUFBSCxZQUFBSSxHQUFBLEVBQUNDLE1BQUFBLENBQUFBOzRCQUNBVCxNQUFNVSxLQUFLOzs7Z0JBR2xCO1lBQ0Y7WUFDQSxPQUFPO1FBQ1Q7SUFDRjtJQUVBLElBQUksT0FBT2hCLG1CQUFtQixZQUFZO1FBQ3hDRyxnQkFBZ0JjLE1BQU0sR0FBR2pCO0lBQzNCO0lBRUEsSUFBTUUsZ0JBQWdCLHFCQUNqQkMsaUJBQ0FGO0lBR0wsT0FBT2lCLENBQUFBLEdBQUFBLFNBQUFBLENBQUFBLFVBQVEsRUFBQyw0Q0FDWGhCO1FBQ0hpQixTQUFPLENBQUVqQixtQ0FBQUEsY0FBY2tCLGlCQUFpQixxQkFBL0JsQixpQ0FBaUNpQixPQUFPOztBQUVyRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvYXBwLWR5bmFtaWMudHN4P2M1NjUiXSwibmFtZXMiOlsiZHluYW1pYyIsImR5bmFtaWNPcHRpb25zIiwib3B0aW9ucyIsIm1lcmdlZE9wdGlvbnMiLCJsb2FkYWJsZU9wdGlvbnMiLCJsb2FkaW5nIiwicGFyYW0iLCJlcnJvciIsImlzTG9hZGluZyIsInBhc3REZWxheSIsInByb2Nlc3MiLCJfanN4cnVudGltZSIsImpzeHMiLCJwIiwibWVzc2FnZSIsImpzeCIsImJyIiwic3RhY2siLCJsb2FkZXIiLCJMb2FkYWJsZSIsIm1vZHVsZXMiLCJsb2FkYWJsZUdlbmVyYXRlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/app-dynamic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/escape-regexp.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/escape-regexp.js ***!
  \***************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// regexp is based on https://github.com/sindresorhus/escape-string-regexp\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"escapeStringRegexp\", ({\n    enumerable: true,\n    get: function get() {\n        return escapeStringRegexp;\n    }\n}));\nvar reHasRegExp = /[|\\\\{}()[\\]^$+*?.-]/;\nvar reReplaceRegExp = /[|\\\\{}()[\\]^$+*?.-]/g;\nfunction escapeStringRegexp(str) {\n    // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23\n    if (reHasRegExp.test(str)) {\n        return str.replace(reReplaceRegExp, \"\\\\$&\");\n    }\n    return str;\n} //# sourceMappingURL=escape-regexp.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLmpzIiwibWFwcGluZ3MiOiJBQUFBLDBFQUEwRTs7Ozs7c0RBSTFEQTs7O2VBQUFBOzs7QUFIaEIsSUFBTUMsY0FBYztBQUNwQixJQUFNQyxrQkFBa0I7QUFFakIsU0FBU0YsbUJBQW1CRyxHQUFXO0lBQzVDLCtHQUErRztJQUMvRyxJQUFJRixZQUFZRyxJQUFJLENBQUNELE1BQU07UUFDekIsT0FBT0EsSUFBSUUsT0FBTyxDQUFDSCxpQkFBaUI7SUFDdEM7SUFDQSxPQUFPQztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLnRzP2RjYjEiXSwibmFtZXMiOlsiZXNjYXBlU3RyaW5nUmVnZXhwIiwicmVIYXNSZWdFeHAiLCJyZVJlcGxhY2VSZWdFeHAiLCJzdHIiLCJ0ZXN0IiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/escape-regexp.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/get-img-props.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/get-img-props.js ***!
  \***************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\nvar _object_without_properties = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_without_properties.js\");\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nvar _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_to_consumable_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImgProps\", ({\n    enumerable: true,\n    get: function get() {\n        return getImgProps;\n    }\n}));\nvar _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils/warn-once.js\");\nvar _imageblursvg = __webpack_require__(/*! ./image-blur-svg */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-blur-svg.js\");\nvar _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config.js\");\nvar VALID_LOADING_VALUES = [\n    \"lazy\",\n    \"eager\",\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src[\"default\"] !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\nvar allImgs = new Map();\nvar perfObserver;\nfunction getInt(x) {\n    if (typeof x === \"undefined\") {\n        return x;\n    }\n    if (typeof x === \"number\") {\n        return Number.isFinite(x) ? x : NaN;\n    }\n    if (typeof x === \"string\" && /^[0-9]+$/.test(x)) {\n        return parseInt(x, 10);\n    }\n    return NaN;\n}\nfunction getWidths(param, width, sizes) {\n    var deviceSizes = param.deviceSizes, allSizes = param.allSizes;\n    if (sizes) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        var viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        var percentSizes = [];\n        for(var match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            var _Math;\n            var smallestRatio = (_Math = Math).min.apply(_Math, _to_consumable_array._(percentSizes)) * 0.01;\n            return {\n                widths: allSizes.filter(function(s) {\n                    return s >= deviceSizes[0] * smallestRatio;\n                }),\n                kind: \"w\"\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: \"w\"\n        };\n    }\n    if (typeof width !== \"number\") {\n        return {\n            widths: deviceSizes,\n            kind: \"w\"\n        };\n    }\n    var widths = _to_consumable_array._(new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n    // > blue colors. Showing a 3x resolution image in the app vs a 2x\n    // > resolution image will be visually the same, though the 3x image\n    // > takes significantly more data. Even true 3x resolution screens are\n    // > wasteful as the human eye cannot see that level of detail without\n    // > something like a magnifying glass.\n    // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n    [\n        width,\n        width * 2 /*, width * 3*/ \n    ].map(function(w) {\n        return allSizes.find(function(p) {\n            return p >= w;\n        }) || allSizes[allSizes.length - 1];\n    })));\n    return {\n        widths: widths,\n        kind: \"x\"\n    };\n}\nfunction generateImgAttrs(param) {\n    var config = param.config, src = param.src, unoptimized = param.unoptimized, width = param.width, quality = param.quality, sizes = param.sizes, loader = param.loader;\n    if (unoptimized) {\n        return {\n            src: src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    var _getWidths = getWidths(config, width, sizes), widths = _getWidths.widths, kind = _getWidths.kind;\n    var last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n        srcSet: widths.map(function(w, i) {\n            return loader({\n                config: config,\n                src: src,\n                quality: quality,\n                width: w\n            }) + \" \" + (kind === \"w\" ? w : i + 1) + kind;\n        }).join(\", \"),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config: config,\n            src: src,\n            quality: quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getImgProps(param, _state) {\n    var src = param.src, sizes = param.sizes, _param_unoptimized = param.unoptimized, unoptimized = _param_unoptimized === void 0 ? false : _param_unoptimized, _param_priority = param.priority, priority = _param_priority === void 0 ? false : _param_priority, loading = param.loading, className = param.className, quality = param.quality, width = param.width, height = param.height, _param_fill = param.fill, fill = _param_fill === void 0 ? false : _param_fill, style = param.style, overrideSrc = param.overrideSrc, onLoad = param.onLoad, onLoadingComplete = param.onLoadingComplete, _param_placeholder = param.placeholder, placeholder = _param_placeholder === void 0 ? \"empty\" : _param_placeholder, blurDataURL = param.blurDataURL, fetchPriority = param.fetchPriority, layout = param.layout, objectFit = param.objectFit, objectPosition = param.objectPosition, lazyBoundary = param.lazyBoundary, lazyRoot = param.lazyRoot, rest = _object_without_properties._(param, [\n        \"src\",\n        \"sizes\",\n        \"unoptimized\",\n        \"priority\",\n        \"loading\",\n        \"className\",\n        \"quality\",\n        \"width\",\n        \"height\",\n        \"fill\",\n        \"style\",\n        \"overrideSrc\",\n        \"onLoad\",\n        \"onLoadingComplete\",\n        \"placeholder\",\n        \"blurDataURL\",\n        \"fetchPriority\",\n        \"layout\",\n        \"objectFit\",\n        \"objectPosition\",\n        \"lazyBoundary\",\n        \"lazyRoot\"\n    ]);\n    var imgConf = _state.imgConf, showAltText = _state.showAltText, blurComplete = _state.blurComplete, defaultLoader = _state.defaultLoader;\n    var config;\n    var c = imgConf || _imageconfig.imageConfigDefault;\n    if (\"allSizes\" in c) {\n        config = c;\n    } else {\n        var allSizes = _to_consumable_array._(c.deviceSizes).concat(_to_consumable_array._(c.imageSizes)).sort(function(a, b) {\n            return a - b;\n        });\n        var deviceSizes = c.deviceSizes.sort(function(a, b) {\n            return a - b;\n        });\n        config = _object_spread_props._(_object_spread._({}, c), {\n            allSizes: allSizes,\n            deviceSizes: deviceSizes\n        });\n    }\n    if (typeof defaultLoader === \"undefined\") {\n        throw new Error(\"images.loaderFile detected but the file is missing default export.\\nRead more: https://nextjs.org/docs/messages/invalid-images-config\");\n    }\n    var loader = rest.loader || defaultLoader;\n    // Remove property so it's not spread on <img> element\n    delete rest.loader;\n    delete rest.srcSet;\n    // This special value indicates that the user\n    // didn't define a \"loader\" prop or \"loader\" config.\n    var isDefaultLoader = \"__next_img_default\" in loader;\n    if (isDefaultLoader) {\n        if (config.loader === \"custom\") {\n            throw new Error('Image with src \"' + src + '\" is missing \"loader\" prop.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n        }\n    } else {\n        // The user defined a \"loader\" prop or config.\n        // Since the config object is internal only, we\n        // must not pass it to the user-defined \"loader\".\n        var customImageLoader = loader;\n        loader = function(obj) {\n            var _ = obj.config, opts = _object_without_properties._(obj, [\n                \"config\"\n            ]);\n            return customImageLoader(opts);\n        };\n    }\n    if (layout) {\n        if (layout === \"fill\") {\n            fill = true;\n        }\n        var layoutToStyle = {\n            intrinsic: {\n                maxWidth: \"100%\",\n                height: \"auto\"\n            },\n            responsive: {\n                width: \"100%\",\n                height: \"auto\"\n            }\n        };\n        var layoutToSizes = {\n            responsive: \"100vw\",\n            fill: \"100vw\"\n        };\n        var layoutStyle = layoutToStyle[layout];\n        if (layoutStyle) {\n            style = _object_spread._({}, style, layoutStyle);\n        }\n        var layoutSizes = layoutToSizes[layout];\n        if (layoutSizes && !sizes) {\n            sizes = layoutSizes;\n        }\n    }\n    var staticSrc = \"\";\n    var widthInt = getInt(width);\n    var heightInt = getInt(height);\n    var blurWidth;\n    var blurHeight;\n    if (isStaticImport(src)) {\n        var staticImageData = isStaticRequire(src) ? src[\"default\"] : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \" + JSON.stringify(staticImageData));\n        }\n        if (!staticImageData.height || !staticImageData.width) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \" + JSON.stringify(staticImageData));\n        }\n        blurWidth = staticImageData.blurWidth;\n        blurHeight = staticImageData.blurHeight;\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!fill) {\n            if (!widthInt && !heightInt) {\n                widthInt = staticImageData.width;\n                heightInt = staticImageData.height;\n            } else if (widthInt && !heightInt) {\n                var ratio = widthInt / staticImageData.width;\n                heightInt = Math.round(staticImageData.height * ratio);\n            } else if (!widthInt && heightInt) {\n                var ratio1 = heightInt / staticImageData.height;\n                widthInt = Math.round(staticImageData.width * ratio1);\n            }\n        }\n    }\n    src = typeof src === \"string\" ? src : staticSrc;\n    var isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n    if (!src || src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    if (isDefaultLoader && src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        unoptimized = true;\n    }\n    if (priority) {\n        fetchPriority = \"high\";\n    }\n    var qualityInt = getInt(quality);\n    if (true) {\n        if (config.output === \"export\" && isDefaultLoader && !unoptimized) {\n            throw new Error(\"Image Optimization using the default loader is not compatible with `{ output: 'export' }`.\\n  Possible solutions:\\n    - Remove `{ output: 'export' }` and run \\\"next start\\\" to run server mode including the Image Optimization API.\\n    - Configure `{ images: { unoptimized: true } }` in `next.config.js` to disable the Image Optimization API.\\n  Read more: https://nextjs.org/docs/messages/export-image-api\");\n        }\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            unoptimized = true;\n        } else {\n            if (fill) {\n                if (width) {\n                    throw new Error('Image with src \"' + src + '\" has both \"width\" and \"fill\" properties. Only one should be used.');\n                }\n                if (height) {\n                    throw new Error('Image with src \"' + src + '\" has both \"height\" and \"fill\" properties. Only one should be used.');\n                }\n                if ((style == null ? void 0 : style.position) && style.position !== \"absolute\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.width) && style.width !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.height) && style.height !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.');\n                }\n            } else {\n                if (typeof widthInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"width\" property.');\n                } else if (isNaN(widthInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"width\" property. Expected a numeric value in pixels but received \"' + width + '\".');\n                }\n                if (typeof heightInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"height\" property.');\n                } else if (isNaN(heightInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"height\" property. Expected a numeric value in pixels but received \"' + height + '\".');\n                }\n            }\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"loading\" property. Provided \"' + loading + '\" should be one of ' + VALID_LOADING_VALUES.map(String).join(\",\") + \".\");\n        }\n        if (priority && loading === \"lazy\") {\n            throw new Error('Image with src \"' + src + '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.');\n        }\n        if (placeholder !== \"empty\" && placeholder !== \"blur\" && !placeholder.startsWith(\"data:image/\")) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"placeholder\" property \"' + placeholder + '\".');\n        }\n        if (placeholder !== \"empty\") {\n            if (widthInt && heightInt && widthInt * heightInt < 1600) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is smaller than 40x40. Consider removing the \"placeholder\" property to improve performance.');\n            }\n        }\n        if (placeholder === \"blur\" && !blurDataURL) {\n            var VALID_BLUR_EXT = [\n                \"jpeg\",\n                \"png\",\n                \"webp\",\n                \"avif\"\n            ] // should match next-image-loader\n            ;\n            throw new Error('Image with src \"' + src + '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n        Possible solutions:\\n          - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n          - Change the \"src\" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(\",\") + ' (animated images not supported)\\n          - Remove the \"placeholder\" property, effectively no blur effect\\n        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url');\n        }\n        if (\"ref\" in rest) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using unsupported \"ref\" property. Consider using the \"onLoad\" property instead.');\n        }\n        if (!unoptimized && !isDefaultLoader) {\n            var urlStr = loader({\n                config: config,\n                src: src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            var url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        if (onLoadingComplete) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using deprecated \"onLoadingComplete\" property. Please use the \"onLoad\" property instead.');\n        }\n        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n        try {\n            for(var _iterator = Object.entries({\n                layout: layout,\n                objectFit: objectFit,\n                objectPosition: objectPosition,\n                lazyBoundary: lazyBoundary,\n                lazyRoot: lazyRoot\n            })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var _step_value = _sliced_to_array._(_step.value, 2), legacyKey = _step_value[0], legacyValue = _step_value[1];\n                if (legacyValue) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has legacy prop \"' + legacyKey + '\". Did you forget to run the codemod?' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13\");\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                    _iterator[\"return\"]();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n        if (typeof window !== \"undefined\" && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver(function(entryList) {\n                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n                try {\n                    for(var _iterator = entryList.getEntries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                        var entry = _step.value;\n                        var _entry_element;\n                        // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                        var imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || \"\";\n                        var lcpImage = allImgs.get(imgSrc);\n                        if (lcpImage && !lcpImage.priority && lcpImage.placeholder === \"empty\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n                            // https://web.dev/lcp/#measure-lcp-in-javascript\n                            (0, _warnonce.warnOnce)('Image with src \"' + lcpImage.src + '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.' + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally{\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                            _iterator[\"return\"]();\n                        }\n                    } finally{\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: \"largest-contentful-paint\",\n                    buffered: true\n                });\n            } catch (err) {\n                // Log error but don't crash the app\n                console.error(err);\n            }\n        }\n    }\n    var imgStyle = Object.assign(fill ? {\n        position: \"absolute\",\n        height: \"100%\",\n        width: \"100%\",\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        objectFit: objectFit,\n        objectPosition: objectPosition\n    } : {}, showAltText ? {} : {\n        color: \"transparent\"\n    }, style);\n    var backgroundImage = !blurComplete && placeholder !== \"empty\" ? placeholder === \"blur\" ? 'url(\"data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({\n        widthInt: widthInt,\n        heightInt: heightInt,\n        blurWidth: blurWidth,\n        blurHeight: blurHeight,\n        blurDataURL: blurDataURL || \"\",\n        objectFit: imgStyle.objectFit\n    }) + '\")' : 'url(\"' + placeholder + '\")' // assume `data:image/`\n     : null;\n    var placeholderStyle = backgroundImage ? {\n        backgroundSize: imgStyle.objectFit || \"cover\",\n        backgroundPosition: imgStyle.objectPosition || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage: backgroundImage\n    } : {};\n    if (true) {\n        if (placeholderStyle.backgroundImage && placeholder === \"blur\" && (blurDataURL == null ? void 0 : blurDataURL.startsWith(\"/\"))) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            placeholderStyle.backgroundImage = 'url(\"' + blurDataURL + '\")';\n        }\n    }\n    var imgAttributes = generateImgAttrs({\n        config: config,\n        src: src,\n        unoptimized: unoptimized,\n        width: widthInt,\n        quality: qualityInt,\n        sizes: sizes,\n        loader: loader\n    });\n    if (true) {\n        if (typeof window !== \"undefined\") {\n            var fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src: src,\n                priority: priority,\n                placeholder: placeholder\n            });\n        }\n    }\n    var props = _object_spread_props._(_object_spread._({}, rest), {\n        loading: isLazy ? \"lazy\" : loading,\n        fetchPriority: fetchPriority,\n        width: widthInt,\n        height: heightInt,\n        decoding: \"async\",\n        className: className,\n        style: _object_spread._({}, imgStyle, placeholderStyle),\n        sizes: imgAttributes.sizes,\n        srcSet: imgAttributes.srcSet,\n        src: overrideSrc || imgAttributes.src\n    });\n    var meta = {\n        unoptimized: unoptimized,\n        priority: priority,\n        placeholder: placeholder,\n        fill: fill\n    };\n    return {\n        props: props,\n        meta: meta\n    };\n} //# sourceMappingURL=get-img-props.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OzsrQ0EyT2dCQTs7O2VBQUFBOzs7b0NBM09TO3dDQUNPO3VDQUNHO0FBNkVuQyxJQUFNQyx1QkFBdUI7SUFBQztJQUFRO0lBQVNDO0NBQVU7QUFrQnpELFNBQVNDLGdCQUNQQyxHQUFvQztJQUVwQyxPQUFPQSxHQUF1QkMsQ0FBQUEsVUFBTyxLQUFLSDtBQUM1QztBQUVBLFNBQVNJLGtCQUNQRixHQUFvQztJQUVwQyxPQUFPQSxJQUF5QkEsR0FBRyxLQUFLRjtBQUMxQztBQUVBLFNBQVNLLGVBQWVILEdBQTBCO0lBQ2hELE9BQ0UsT0FBT0EsUUFBUSxZQUNkRCxDQUFBQSxnQkFBZ0JDLFFBQ2ZFLGtCQUFrQkYsSUFBQUE7QUFFeEI7QUFFQSxJQUFNSSxVQUFVLElBQUlDO0FBSXBCLElBQUlDO0FBRUosU0FBU0MsT0FBT0MsQ0FBVTtJQUN4QixJQUFJLE9BQU9BLE1BQU0sYUFBYTtRQUM1QixPQUFPQTtJQUNUO0lBQ0EsSUFBSSxPQUFPQSxNQUFNLFVBQVU7UUFDekIsT0FBT0MsT0FBT0MsUUFBUSxDQUFDRixLQUFLQSxJQUFJRztJQUNsQztJQUNBLElBQUksT0FBT0gsTUFBTSxZQUFZLFdBQVdJLElBQUksQ0FBQ0osSUFBSTtRQUMvQyxPQUFPSyxTQUFTTCxHQUFHO0lBQ3JCO0lBQ0EsT0FBT0c7QUFDVDtBQUVBLFNBQVNHLFVBQ1BDLEtBQXNDLEVBQ3RDQyxLQUF5QixFQUN6QkMsS0FBeUI7SUFGekIsSUFBRUMsY0FBRkgsTUFBRUcsYUFBYUMsV0FBZkosTUFBZUk7SUFJZixJQUFJRixPQUFPO1FBQ1QseURBQXlEO1FBQ3pELElBQU1H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QSxJQUFJOEQsSUFBeUIsRUFBYztRQUN6QyxJQUFJLE9BQU9rQixXQUFXLGFBQWE7WUFDakMsSUFBSTRCO1lBQ0osSUFBSTtnQkFDRkEsVUFBVSxJQUFJcEMsSUFBSW1DLGNBQWNySixHQUFHO1lBQ3JDLEVBQUUsT0FBT3VKLEdBQUc7Z0JBQ1ZELFVBQVUsSUFBSXBDLElBQUltQyxjQUFjckosR0FBRyxFQUFFMEgsT0FBTzhCLFFBQVEsQ0FBQ0MsSUFBSTtZQUMzRDtZQUNBckosUUFBUXNKLEdBQUcsQ0FBQ0osUUFBUUcsSUFBSSxFQUFFO2dCQUFFekosS0FBQUE7Z0JBQUtnRCxVQUFBQTtnQkFBVVMsYUFBQUE7WUFBWTtRQUN6RDtJQUNGO0lBRUEsSUFBTWtHLFFBQWtCLDRDQUNuQjFGO1FBQ0hoQixTQUFTa0QsU0FBUyxTQUFTbEQ7UUFDM0JVLGVBQUFBO1FBQ0EzQyxPQUFPMEU7UUFDUHZDLFFBQVF3QztRQUNSaUUsVUFBVTtRQUNWMUcsV0FBQUE7UUFDQUcsT0FBTyxxQkFBS21GLFVBQWFTO1FBQ3pCaEksT0FBT29JLGNBQWNwSSxLQUFLO1FBQzFCMEIsUUFBUTBHLGNBQWMxRyxNQUFNO1FBQzVCM0MsS0FBS3NELGVBQWUrRixjQUFjckosR0FBRzs7SUFFdkMsSUFBTTZKLE9BQU87UUFBRXJILGFBQUFBO1FBQWFRLFVBQUFBO1FBQVVTLGFBQUFBO1FBQWFMLE1BQUFBO0lBQUs7SUFDeEQsT0FBTztRQUFFdUcsT0FBQUE7UUFBT0UsTUFBQUE7SUFBSztBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvZ2V0LWltZy1wcm9wcy50cz9lYzkxIl0sIm5hbWVzIjpbImdldEltZ1Byb3BzIiwiVkFMSURfTE9BRElOR19WQUxVRVMiLCJ1bmRlZmluZWQiLCJpc1N0YXRpY1JlcXVpcmUiLCJzcmMiLCJkZWZhdWx0IiwiaXNTdGF0aWNJbWFnZURhdGEiLCJpc1N0YXRpY0ltcG9ydCIsImFsbEltZ3MiLCJNYXAiLCJwZXJmT2JzZXJ2ZXIiLCJnZXRJbnQiLCJ4IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJOYU4iLCJ0ZXN0IiwicGFyc2VJbnQiLCJnZXRXaWR0aHMiLCJwYXJhbSIsIndpZHRoIiwic2l6ZXMiLCJkZXZpY2VTaXplcyIsImFsbFNpemVzIiwidmlld3BvcnRXaWR0aFJlIiwicGVyY2VudFNpemVzIiwibWF0Y2giLCJleGVjIiwicHVzaCIsImxlbmd0aCIsIk1hdGgiLCJzbWFsbGVzdFJhdGlvIiwibWluIiwid2lkdGhzIiwiZmlsdGVyIiwicyIsImtpbmQiLCJTZXQiLCJtYXAiLCJ3IiwiZmluZCIsInAiLCJnZW5lcmF0ZUltZ0F0dHJzIiwiY29uZmlnIiwidW5vcHRpbWl6ZWQiLCJxdWFsaXR5IiwibG9hZGVyIiwic3JjU2V0IiwibGFzdCIsImkiLCJqb2luIiwiX3N0YXRlIiwicHJpb3JpdHkiLCJsb2FkaW5nIiwiY2xhc3NOYW1lIiwiaGVpZ2h0IiwiZmlsbCIsInN0eWxlIiwib3ZlcnJpZGVTcmMiLCJvbkxvYWQiLCJvbkxvYWRpbmdDb21wbGV0ZSIsInBsYWNlaG9sZGVyIiwiYmx1ckRhdGFVUkwiLCJmZXRjaFByaW9yaXR5IiwibGF5b3V0Iiwib2JqZWN0Rml0Iiwib2JqZWN0UG9zaXRpb24iLCJsYXp5Qm91bmRhcnkiLCJsYXp5Um9vdCIsInJlc3QiLCJpbWdDb25mIiwic2hvd0FsdFRleHQiLCJibHVyQ29tcGxldGUiLCJkZWZhdWx0TG9hZGVyIiwiYyIsImltYWdlQ29uZmlnRGVmYXVsdCIsImltYWdlU2l6ZXMiLCJzb3J0IiwiYSIsImIiLCJFcnJvciIsImlzRGVmYXVsdExvYWRlciIsImN1c3RvbUltYWdlTG9hZGVyIiwib2JqIiwiXyIsIm9wdHMiLCJsYXlvdXRUb1N0eWxlIiwiaW50cmluc2ljIiwibWF4V2lkdGgiLCJyZXNwb25zaXZlIiwibGF5b3V0VG9TaXplcyIsImxheW91dFN0eWxlIiwibGF5b3V0U2l6ZXMiLCJzdGF0aWNTcmMiLCJ3aWR0aEludCIsImhlaWdodEludCIsImJsdXJXaWR0aCIsImJsdXJIZWlnaHQiLCJzdGF0aWNJbWFnZURhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwicmF0aW8iLCJyb3VuZCIsImlzTGF6eSIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsImRhbmdlcm91c2x5QWxsb3dTVkciLCJxdWFsaXR5SW50IiwicHJvY2VzcyIsIm91dHB1dCIsInBvc2l0aW9uIiwiaXNOYU4iLCJpbmNsdWRlcyIsIlN0cmluZyIsIndhcm5PbmNlIiwiVkFMSURfQkxVUl9FWFQiLCJ1cmxTdHIiLCJ1cmwiLCJVUkwiLCJlcnIiLCJwYXRobmFtZSIsInNlYXJjaCIsIk9iamVjdCIsImVudHJpZXMiLCJsZWdhY3lLZXkiLCJsZWdhY3lWYWx1ZSIsIndpbmRvdyIsIlBlcmZvcm1hbmNlT2JzZXJ2ZXIiLCJlbnRyeUxpc3QiLCJnZXRFbnRyaWVzIiwiZW50cnkiLCJpbWdTcmMiLCJlbGVtZW50IiwibGNwSW1hZ2UiLCJnZXQiLCJvYnNlcnZlIiwidHlwZSIsImJ1ZmZlcmVkIiwiY29uc29sZSIsImVycm9yIiwiaW1nU3R5bGUiLCJhc3NpZ24iLCJsZWZ0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJjb2xvciIsImJhY2tncm91bmRJbWFnZSIsImdldEltYWdlQmx1clN2ZyIsInBsYWNlaG9sZGVyU3R5bGUiLCJiYWNrZ3JvdW5kU2l6ZSIsImJhY2tncm91bmRQb3NpdGlvbiIsImJhY2tncm91bmRSZXBlYXQiLCJpbWdBdHRyaWJ1dGVzIiwiZnVsbFVybCIsImUiLCJsb2NhdGlvbiIsImhyZWYiLCJzZXQiLCJwcm9wcyIsImRlY29kaW5nIiwibWV0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/get-img-props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/head.js":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/head.js ***!
  \******************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    \"default\": function _default1() {\n        return _default;\n    },\n    defaultHead: function defaultHead1() {\n        return defaultHead;\n    }\n});\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-runtime.js\");\nvar _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\"));\nvar _sideeffect = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./side-effect */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/side-effect.js\"));\nvar _ampcontextsharedruntime = __webpack_require__(/*! ./amp-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\");\nvar _headmanagercontextsharedruntime = __webpack_require__(/*! ./head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nvar _ampmode = __webpack_require__(/*! ./amp-mode */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/amp-mode.js\");\nvar _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils/warn-once.js\");\nfunction defaultHead(inAmpMode) {\n    if (inAmpMode === void 0) inAmpMode = false;\n    var head = [\n        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            charSet: \"utf-8\"\n        })\n    ];\n    if (!inAmpMode) {\n        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            name: \"viewport\",\n            content: \"width=device-width\"\n        }));\n    }\n    return head;\n}\nfunction onlyReactElement(list, child) {\n    // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n    if (typeof child === \"string\" || typeof child === \"number\") {\n        return list;\n    }\n    // Adds support for React.Fragment\n    if (child.type === _react[\"default\"].Fragment) {\n        return list.concat(_react[\"default\"].Children.toArray(child.props.children).reduce(function(fragmentList, fragmentChild) {\n            if (typeof fragmentChild === \"string\" || typeof fragmentChild === \"number\") {\n                return fragmentList;\n            }\n            return fragmentList.concat(fragmentChild);\n        }, []));\n    }\n    return list.concat(child);\n}\nvar METATYPES = [\n    \"name\",\n    \"httpEquiv\",\n    \"charSet\",\n    \"itemProp\"\n];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/ function unique() {\n    var keys = new Set();\n    var tags = new Set();\n    var metaTypes = new Set();\n    var metaCategories = {};\n    return function(h) {\n        var isUnique = true;\n        var hasKey = false;\n        if (h.key && typeof h.key !== \"number\" && h.key.indexOf(\"$\") > 0) {\n            hasKey = true;\n            var key = h.key.slice(h.key.indexOf(\"$\") + 1);\n            if (keys.has(key)) {\n                isUnique = false;\n            } else {\n                keys.add(key);\n            }\n        }\n        // eslint-disable-next-line default-case\n        switch(h.type){\n            case \"title\":\n            case \"base\":\n                if (tags.has(h.type)) {\n                    isUnique = false;\n                } else {\n                    tags.add(h.type);\n                }\n                break;\n            case \"meta\":\n                for(var i = 0, len = METATYPES.length; i < len; i++){\n                    var metatype = METATYPES[i];\n                    if (!h.props.hasOwnProperty(metatype)) continue;\n                    if (metatype === \"charSet\") {\n                        if (metaTypes.has(metatype)) {\n                            isUnique = false;\n                        } else {\n                            metaTypes.add(metatype);\n                        }\n                    } else {\n                        var category = h.props[metatype];\n                        var categories = metaCategories[metatype] || new Set();\n                        if ((metatype !== \"name\" || !hasKey) && categories.has(category)) {\n                            isUnique = false;\n                        } else {\n                            categories.add(category);\n                            metaCategories[metatype] = categories;\n                        }\n                    }\n                }\n                break;\n        }\n        return isUnique;\n    };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */ function reduceComponents(headChildrenElements, props) {\n    var inAmpMode = props.inAmpMode;\n    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map(function(c, i) {\n        var key = c.key || i;\n        if (false) { var newProps; }\n        if (true) {\n            // omit JSON-LD structured data snippets from the warning\n            if (c.type === \"script\" && c.props[\"type\"] !== \"application/ld+json\") {\n                var srcMessage = c.props[\"src\"] ? '<script> tag with src=\"' + c.props[\"src\"] + '\"' : \"inline <script>\";\n                (0, _warnonce.warnOnce)(\"Do not add <script> tags using next/head (see \" + srcMessage + \"). Use next/script instead. \\nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component\");\n            } else if (c.type === \"link\" && c.props[\"rel\"] === \"stylesheet\") {\n                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel=\"stylesheet\"> tag with href=\"' + c.props[\"href\"] + '\"). Use Document instead. \\nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');\n            }\n        }\n        return /*#__PURE__*/ _react[\"default\"].cloneElement(c, {\n            key: key\n        });\n    });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */ function Head(param) {\n    var children = param.children;\n    var ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);\n    var headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect[\"default\"], {\n        reduceComponentsToState: reduceComponents,\n        headManager: headManager,\n        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),\n        children: children\n    });\n}\n_c = Head;\nvar _default = Head;\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=head.js.map\nvar _c;\n$RefreshReg$(_c, \"Head\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9oZWFkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztRQXFNQUEsU0FBbUI7OztJQXhMSEM7aUJBQUFBOzs7Ozs7Ozt5REFUZ0JDLENBQUEsQ0FBQUMsbUJBQUFBLENBQUE7O3VDQUVKQSxtQkFBQUEsQ0FBQTs7QUFPckIsSUFBQUMsWUFBU0gsbUJBQUFBLENBQVlJLDRMQUFBQTtTQUFBQSxZQUFBQSxTQUFBQTtJQUMxQixJQUFBQSxjQUFhLFFBQUFBLFlBQUE7O21CQUFPQyxHQUFRLElBQUFDLFlBQUFDLEdBQUE7O1FBQVc7S0FDdkM7UUFDRUMsQ0FBQUEsV0FBUzthQUFPQyxJQUFBQSxDQUFLLGtCQUFBSCxZQUFBQyxHQUFBO1lBQVdHLE1BQUFBOztRQUNsQztJQUNBO0lBQ0YsT0FBQUY7QUFFQTtTQUlFRyxpQkFBQUMsSUFBQSxFQUFBQyxLQUFBO0lBQ0EsOEZBQTREO1FBQzFELE9BQU9ELFVBQUFBLFlBQUFBLE9BQUFBLFVBQUFBLFVBQUFBO1FBQ1QsT0FBQUE7SUFDQTtJQUNBLGtDQUF5QkU7UUFDdkJELE1BQUFFLElBQU9ILEtBQUtJLE1BQ1ZDLENBQUFBLFVBQUEsQ0FBQUgsUUFBQTtRQUNBSSxPQUFBQSxLQUFBQSxNQUFNQyxDQUVKQyxNQUNFQyxDQUFBQSxVQUFBQSxDQUNBQyxRQUFBQSxDQUFBQSxPQUFBQSxDQUFBQSxNQUFBQSxLQUFBQSxDQUFBQSxRQUFBQSxFQUFBQSxNQUFBQSx3QkFHU0E7Z0JBR1AsT0FBT0Qsa0JBQUFBLFlBQUFBLE9BQUFBLGtCQUFBQSxVQUFBQTtnQkFDVCxPQUFBQTtZQUNBO1lBRUYsT0FBRUEsYUFBQUwsTUFBQSxDQUFBTTtRQUdSO0lBQ0E7SUFDRixPQUFB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SUFDWixlQUFpQkUsTUFBWEQ7SUFDTixJQUFNRSxXQUFBQSxDQUFBQSxHQUFjRCxPQUFBQSxVQUFBQSxFQUFBQSx5QkFBV0UsZUFBQUE7SUFDL0IsSUFBQUQsY0FBQSxDQUNFLEdBQUF6QyxPQUFBd0MsVUFBQSxFQUFDRyxpQ0FBTUQsa0JBQUE7V0FDTEUsV0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsWUFBeUJDLEdBQUFBLEVBQUFBLFdBQUFBLENBQUFBLFVBQUFBLEVBQUFBO1FBQ3pCSix5QkFBYUE7UUFDYnpELGFBQVc4RDttQkFFVlQsQ0FBQUEsR0FBQUEsU0FBQUEsV0FBQUEsRUFBQUE7O0lBR1A7O0tBWmdCQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvaGVhZC50c3g/MzY3MCJdLCJuYW1lcyI6WyJleHBvcnRzIiwiZGVmYXVsdEhlYWQiLCJfIiwicmVxdWlyZSIsIl93YXJub25jZSIsImluQW1wTW9kZSIsImNoYXJTZXQiLCJfanN4cnVudGltZSIsImpzeCIsImhlYWQiLCJuYW1lIiwiY29udGVudCIsIm9ubHlSZWFjdEVsZW1lbnQiLCJsaXN0IiwiY2hpbGQiLCJGcmFnbWVudCIsInR5cGUiLCJjb25jYXQiLCJkZWZhdWx0IiwiUmVhY3QiLCJDaGlsZHJlbiIsIl9yZWFjdCIsImZyYWdtZW50TGlzdCIsImZyYWdtZW50Q2hpbGQiLCJNRVRBVFlQRVMiLCJrZXlzIiwidGFncyIsIlNldCIsIm1ldGFUeXBlcyIsIm1ldGFDYXRlZ29yaWVzIiwiaCIsImlzVW5pcXVlIiwiaGFzS2V5Iiwia2V5IiwiaW5kZXhPZiIsImFkZCIsImkiLCJtZXRhdHlwZSIsImxlbiIsImhhc093blByb3BlcnR5IiwiY2F0ZWdvcmllcyIsImhhcyIsImNhdGVnb3J5IiwicHJvcHMiLCJoZWFkQ2hpbGRyZW5FbGVtZW50cyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImMiLCJfX05FWFRfT1BUSU1JWkVfRk9OVFMiLCJzb21lIiwidXJsIiwibmV3UHJvcHMiLCJzdGFydHNXaXRoIiwidW5kZWZpbmVkIiwiY2xvbmVFbGVtZW50Iiwic3JjTWVzc2FnZSIsIndhcm5PbmNlIiwiY2hpbGRyZW4iLCJwYXJhbSIsImFtcFN0YXRlIiwidXNlQ29udGV4dCIsImhlYWRNYW5hZ2VyIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiRWZmZWN0IiwicmVkdWNlQ29tcG9uZW50c1RvU3RhdGUiLCJyZWR1Y2VDb21wb25lbnRzIiwiaXNJbkFtcE1vZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/head.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-blur-svg.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-blur-svg.js ***!
  \****************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * A shared function, used on both client and server, to generate a SVG blur placeholder.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImageBlurSvg\", ({\n    enumerable: true,\n    get: function get() {\n        return getImageBlurSvg;\n    }\n}));\nfunction getImageBlurSvg(param) {\n    var widthInt = param.widthInt, heightInt = param.heightInt, blurWidth = param.blurWidth, blurHeight = param.blurHeight, blurDataURL = param.blurDataURL, objectFit = param.objectFit;\n    var std = 20;\n    var svgWidth = blurWidth ? blurWidth * 40 : widthInt;\n    var svgHeight = blurHeight ? blurHeight * 40 : heightInt;\n    var viewBox = svgWidth && svgHeight ? \"viewBox='0 0 \" + svgWidth + \" \" + svgHeight + \"'\" : \"\";\n    var preserveAspectRatio = viewBox ? \"none\" : objectFit === \"contain\" ? \"xMidYMid\" : objectFit === \"cover\" ? \"xMidYMid slice\" : \"none\";\n    return \"%3Csvg xmlns='http://www.w3.org/2000/svg' \" + viewBox + \"%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='\" + preserveAspectRatio + \"' style='filter: url(%23b);' href='\" + blurDataURL + \"'/%3E%3C/svg%3E\";\n} //# sourceMappingURL=image-blur-svg.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQzs7OzttREFDZUE7OztlQUFBQTs7O0FBQVQsU0FBU0EsZ0JBQWdCQyxLQWMvQjtJQWQrQixJQUM5QkMsV0FEOEJELE1BQzlCQyxVQUNBQyxZQUY4QkYsTUFFOUJFLFdBQ0FDLFlBSDhCSCxNQUc5QkcsV0FDQUMsYUFKOEJKLE1BSTlCSSxZQUNBQyxjQUw4QkwsTUFLOUJLLGFBQ0FDLFlBTjhCTixNQU05Qk07SUFTQSxJQUFNQyxNQUFNO0lBQ1osSUFBTUMsV0FBV0wsWUFBWUEsWUFBWSxLQUFLRjtJQUM5QyxJQUFNUSxZQUFZTCxhQUFhQSxhQUFhLEtBQUtGO0lBRWpELElBQU1RLFVBQ0pGLFlBQVlDLFlBQVksa0JBQWdCRCxXQUFTLE1BQUdDLFlBQVUsTUFBSztJQUNyRSxJQUFNRSxzQkFBc0JELFVBQ3hCLFNBQ0FKLGNBQWMsWUFDZCxhQUNBQSxjQUFjLFVBQ2QsbUJBQ0E7SUFFSixPQUFPLCtDQUE2Q0ksVUFBUSw4RkFBMkZILE1BQUksb1FBQWlRQSxNQUFJLGdHQUE2Rkksc0JBQW9CLHdDQUFxQ04sY0FBWTtBQUNwa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2ltYWdlLWJsdXItc3ZnLnRzP2M3OWMiXSwibmFtZXMiOlsiZ2V0SW1hZ2VCbHVyU3ZnIiwicGFyYW0iLCJ3aWR0aEludCIsImhlaWdodEludCIsImJsdXJXaWR0aCIsImJsdXJIZWlnaHQiLCJibHVyRGF0YVVSTCIsIm9iamVjdEZpdCIsInN0ZCIsInN2Z1dpZHRoIiwic3ZnSGVpZ2h0Iiwidmlld0JveCIsInByZXNlcnZlQXNwZWN0UmF0aW8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-blur-svg.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js":
/*!*************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js ***!
  \*************************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ImageConfigContext\", ({\n    enumerable: true,\n    get: function get() {\n        return ImageConfigContext;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\"));\nvar _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config.js\");\nvar ImageConfigContext = _react[\"default\"].createContext(_imageconfig.imageConfigDefault);\nif (true) {\n    ImageConfigContext.displayName = \"ImageConfigContext\";\n} //# sourceMappingURL=image-config-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O3NEQUlhQTs7O2VBQUFBOzs7OzBFQUpLO3VDQUVpQjtBQUU1QixJQUFNQSxxQkFDWEMsTUFBQUEsQ0FBQUEsVUFBSyxDQUFDQyxhQUFhLENBQXNCQyxhQUFBQSxrQkFBa0I7QUFFN0QsSUFBSUMsSUFBeUIsRUFBYztJQUN6Q0osbUJBQW1CSyxXQUFXLEdBQUc7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0LnNoYXJlZC1ydW50aW1lLnRzPzNkNzUiXSwibmFtZXMiOlsiSW1hZ2VDb25maWdDb250ZXh0IiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwiaW1hZ2VDb25maWdEZWZhdWx0IiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config.js ***!
  \**************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    VALID_LOADERS: function VALID_LOADERS1() {\n        return VALID_LOADERS;\n    },\n    imageConfigDefault: function imageConfigDefault1() {\n        return imageConfigDefault;\n    }\n});\nvar VALID_LOADERS = [\n    \"default\",\n    \"imgix\",\n    \"cloudinary\",\n    \"akamai\",\n    \"custom\"\n];\nvar imageConfigDefault = {\n    deviceSizes: [\n        640,\n        750,\n        828,\n        1080,\n        1200,\n        1920,\n        2048,\n        3840\n    ],\n    imageSizes: [\n        16,\n        32,\n        48,\n        64,\n        96,\n        128,\n        256,\n        384\n    ],\n    path: \"/_next/image\",\n    loader: \"default\",\n    loaderFile: \"\",\n    domains: [],\n    disableStaticImages: false,\n    minimumCacheTTL: 60,\n    formats: [\n        \"image/webp\"\n    ],\n    dangerouslyAllowSVG: false,\n    contentSecurityPolicy: \"script-src 'none'; frame-src 'none'; sandbox;\",\n    contentDispositionType: \"inline\",\n    remotePatterns: [],\n    unoptimized: false\n}; //# sourceMappingURL=image-config.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBQWFBLGVBQWEsU0FBYkE7ZUFBQUE7O0lBc0dBQyxvQkFBa0IsU0FBbEJBO2VBQUFBOzs7QUF0R04sSUFBTUQsZ0JBQWdCO0lBQzNCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQWdHTSxJQUFNQyxxQkFBMEM7SUFDckRDLGFBQWE7UUFBQztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO0tBQUs7SUFDMURDLFlBQVk7UUFBQztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSztRQUFLO0tBQUk7SUFDL0NDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxZQUFZO0lBQ1pDLFNBQVMsRUFBRTtJQUNYQyxxQkFBcUI7SUFDckJDLGlCQUFpQjtJQUNqQkMsU0FBUztRQUFDO0tBQWE7SUFDdkJDLHFCQUFxQjtJQUNyQkMsdUJBQXdCO0lBQ3hCQyx3QkFBd0I7SUFDeEJDLGdCQUFnQixFQUFFO0lBQ2xCQyxhQUFhO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy50cz8xMzRhIl0sIm5hbWVzIjpbIlZBTElEX0xPQURFUlMiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJkZXZpY2VTaXplcyIsImltYWdlU2l6ZXMiLCJwYXRoIiwibG9hZGVyIiwibG9hZGVyRmlsZSIsImRvbWFpbnMiLCJkaXNhYmxlU3RhdGljSW1hZ2VzIiwibWluaW11bUNhY2hlVFRMIiwiZm9ybWF0cyIsImRhbmdlcm91c2x5QWxsb3dTVkciLCJjb250ZW50U2VjdXJpdHlQb2xpY3kiLCJjb250ZW50RGlzcG9zaXRpb25UeXBlIiwicmVtb3RlUGF0dGVybnMiLCJ1bm9wdGltaXplZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-loader.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-loader.js ***!
  \**************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function get() {\n        return _default;\n    }\n}));\nfunction defaultLoader(param) {\n    var config = param.config, src = param.src, width = param.width, quality = param.quality;\n    if (true) {\n        var missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push(\"src\");\n        if (!width) missingValues.push(\"width\");\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \" + missingValues.join(\", \") + \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \" + JSON.stringify({\n                src: src,\n                width: width,\n                quality: quality\n            }));\n        }\n        if (src.startsWith(\"//\")) {\n            throw new Error('Failed to parse src \"' + src + '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)');\n        }\n        if (!src.startsWith(\"/\") && (config.domains || config.remotePatterns)) {\n            var parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"' + src + '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)');\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                var hasMatch = (__webpack_require__(/*! ./match-remote-pattern */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/match-remote-pattern.js\").hasMatch);\n                if (!hasMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw new Error(\"Invalid src prop (\" + src + ') on `next/image`, hostname \"' + parsedSrc.hostname + '\" is not configured under images in your `next.config.js`\\n' + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n                }\n            }\n        }\n    }\n    return config.path + \"?url=\" + encodeURIComponent(src) + \"&w=\" + width + \"&q=\" + (quality || 75) + ( false ? 0 : \"\");\n}\n// We use this to determine if the import is the default loader\n// or a custom loader defined by the user in next.config.js\ndefaultLoader.__next_img_default = true;\nvar _default = defaultLoader; //# sourceMappingURL=image-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7OzsyQ0F3RUE7OztlQUFBQTs7O0FBdEVBLFNBQVNDLGNBQWNDLEtBS007SUFMTixJQUNyQkMsU0FEcUJELE1BQ3JCQyxRQUNBQyxNQUZxQkYsTUFFckJFLEtBQ0FDLFFBSHFCSCxNQUdyQkcsT0FDQUMsVUFKcUJKLE1BSXJCSTtJQUVBLElBQUlDLElBQXlCLEVBQWM7UUFDekMsSUFBTUMsZ0JBQWdCLEVBQUU7UUFFeEIseURBQXlEO1FBQ3pELElBQUksQ0FBQ0osS0FBS0ksY0FBY0MsSUFBSSxDQUFDO1FBQzdCLElBQUksQ0FBQ0osT0FBT0csY0FBY0MsSUFBSSxDQUFDO1FBRS9CLElBQUlELGNBQWNFLE1BQU0sR0FBRyxHQUFHO1lBQzVCLE1BQU0sSUFBSUMsTUFDUixzQ0FBb0NILGNBQWNJLElBQUksQ0FDcEQsUUFDQSxnR0FBK0ZDLEtBQUtDLFNBQVMsQ0FDN0c7Z0JBQUVWLEtBQUFBO2dCQUFLQyxPQUFBQTtnQkFBT0MsU0FBQUE7WUFBUTtRQUc1QjtRQUVBLElBQUlGLElBQUlXLFVBQVUsQ0FBQyxPQUFPO1lBQ3hCLE1BQU0sSUFBSUosTUFDUiwwQkFBd0JQLE1BQUk7UUFFaEM7UUFFQSxJQUFJLENBQUNBLElBQUlXLFVBQVUsQ0FBQyxRQUFTWixDQUFBQSxPQUFPYSxPQUFPLElBQUliLE9BQU9jLGNBQWMsR0FBRztZQUNyRSxJQUFJQztZQUNKLElBQUk7Z0JBQ0ZBLFlBQVksSUFBSUMsSUFBSWY7WUFDdEIsRUFBRSxPQUFPZ0IsS0FBSztnQkFDWkMsUUFBUUMsS0FBSyxDQUFDRjtnQkFDZCxNQUFNLElBQUlULE1BQ1IsMEJBQXdCUCxNQUFJO1lBRWhDO1lBRUEsSUFDRUcsSUFFNkIsRUFDN0I7Z0JBQ0EsdUVBQXVFO2dCQUN2RSxJQUFNLFdBQWVtQixzT0FBYkQ7Z0JBQ1IsSUFBSSxDQUFDQSxTQUFTdEIsT0FBT2EsT0FBTyxFQUFFYixPQUFPYyxjQUFjLEVBQUVDLFlBQVk7b0JBQy9ELE1BQU0sSUFBSVAsTUFDUix1QkFBcUJQLE1BQUksa0NBQWlDYyxVQUFVUyxRQUFRLEdBQUMsZ0VBQzFFO2dCQUVQO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsT0FBT3hCLE9BQVV5QixJQUFJLEdBQUMsVUFBT0MsbUJBQW1CekIsT0FBSyxRQUFLQyxRQUFNLFFBQzlEQyxDQUFBQSxXQUFXLE1BRVhDLENBQUFBLE1BQThCLEdBQzFCLENBQXNDLEdBQ3RDO0FBRVI7QUFFQSwrREFBK0Q7QUFDL0QsMkRBQTJEO0FBQzNETixjQUFjOEIsa0JBQWtCLEdBQUc7SUFFbkMvQixXQUFlQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyLnRzP2QyODAiXSwibmFtZXMiOlsiX2RlZmF1bHQiLCJkZWZhdWx0TG9hZGVyIiwicGFyYW0iLCJjb25maWciLCJzcmMiLCJ3aWR0aCIsInF1YWxpdHkiLCJwcm9jZXNzIiwibWlzc2luZ1ZhbHVlcyIsInB1c2giLCJsZW5ndGgiLCJFcnJvciIsImpvaW4iLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhcnRzV2l0aCIsImRvbWFpbnMiLCJyZW1vdGVQYXR0ZXJucyIsInBhcnNlZFNyYyIsIlVSTCIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsImVudiIsIk5FWFRfUlVOVElNRSIsImhhc01hdGNoIiwicmVxdWlyZSIsImhvc3RuYW1lIiwicGF0aCIsImVuY29kZVVSSUNvbXBvbmVudCIsIk5FWFRfREVQTE9ZTUVOVF9JRCIsIl9fbmV4dF9pbWdfZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-loader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js":
/*!*************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js ***!
  \*************************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"BailoutToCSR\", ({\n    enumerable: true,\n    get: function get() {\n        return BailoutToCSR;\n    }\n}));\nvar _bailouttocsr = __webpack_require__(/*! ./bailout-to-csr */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nfunction BailoutToCSR(param) {\n    var reason = param.reason, children = param.children;\n    if (typeof window === \"undefined\") {\n        throw new _bailouttocsr.BailoutToCSRError(reason);\n    }\n    return children;\n} //# sourceMappingURL=dynamic-bailout-to-csr.js.map\n_c = BailoutToCSR;\nvar _c;\n$RefreshReg$(_c, \"BailoutToCSR\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9sYXp5LWR5bmFtaWMvZHluYW1pYy1iYWlsb3V0LXRvLWNzci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBY08sSUFBQUEsZ0JBQXNCQyxtQkFBQUEsQ0FBdUM7U0FBdkNDLGFBQVVDLEtBQVE7SUFDN0MsSUFBSUMsU0FBa0JDLE1BQWxCRCxRQUFPRSxXQUFXRCxNQUFYQztRQUNULE9BQU1BLFdBQUlDLGFBQUFBO1FBQ1osVUFBQVAsY0FBQU8saUJBQUEsQ0FBQUg7SUFFQTtJQUNGLE9BQUFEOztLQU42QkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2xhenktZHluYW1pYy9keW5hbWljLWJhaWxvdXQtdG8tY3NyLnRzeD80ZmY0Il0sIm5hbWVzIjpbIl9iYWlsb3V0dG9jc3IiLCJyZXF1aXJlIiwiQmFpbG91dFRvQ1NSIiwiY2hpbGRyZW4iLCJyZWFzb24iLCJwYXJhbSIsIndpbmRvdyIsIkJhaWxvdXRUb0NTUkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/lazy-dynamic/loadable.js":
/*!***********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/lazy-dynamic/loadable.js ***!
  \***********************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function get() {\n        return _default;\n    }\n}));\nvar _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-runtime.js\");\nvar _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\nvar _dynamicbailouttocsr = __webpack_require__(/*! ./dynamic-bailout-to-csr */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js\");\nvar _preloadcss = __webpack_require__(/*! ./preload-css */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/lazy-dynamic/preload-css.js\");\n// Normalize loader to return the module as form { default: Component } for `React.lazy`.\n// Also for backward compatible since next/dynamic allows to resolve a component directly with loader\n// Client component reference proxy need to be converted to a module.\nfunction convertModule(mod) {\n    // Check \"default\" prop before accessing it, as it could be client reference proxy that could break it reference.\n    // Cases:\n    // mod: { default: Component }\n    // mod: Component\n    // mod: { $$typeof, default: proxy(Component) }\n    // mod: proxy(Component)\n    var hasDefault = mod && \"default\" in mod;\n    return {\n        \"default\": hasDefault ? mod[\"default\"] : mod\n    };\n}\nvar defaultOptions = {\n    loader: function() {\n        return Promise.resolve(convertModule(function() {\n            return null;\n        }));\n    },\n    loading: null,\n    ssr: true\n};\nfunction Loadable(options) {\n    var opts = _object_spread._({}, defaultOptions, options);\n    var Lazy = /*#__PURE__*/ (0, _react.lazy)(function() {\n        return opts.loader().then(convertModule);\n    });\n    var Loading = opts.loading;\n    function LoadableComponent(props) {\n        var fallbackElement = Loading ? /*#__PURE__*/ (0, _jsxruntime.jsx)(Loading, {\n            isLoading: true,\n            pastDelay: true,\n            error: null\n        }) : null;\n        var children = opts.ssr ? /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n            children: [\n                typeof window === \"undefined\" ? /*#__PURE__*/ (0, _jsxruntime.jsx)(_preloadcss.PreloadCss, {\n                    moduleIds: opts.modules\n                }) : null,\n                /*#__PURE__*/ (0, _jsxruntime.jsx)(Lazy, _object_spread._({}, props))\n            ]\n        }) : /*#__PURE__*/ (0, _jsxruntime.jsx)(_dynamicbailouttocsr.BailoutToCSR, {\n            reason: \"next/dynamic\",\n            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Lazy, _object_spread._({}, props))\n        });\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {\n            fallback: fallbackElement,\n            children: children\n        });\n    }\n    LoadableComponent.displayName = \"LoadableComponent\";\n    return LoadableComponent;\n}\n_c = Loadable;\nvar _default = Loadable; //# sourceMappingURL=loadable.js.map\nvar _c;\n$RefreshReg$(_c, \"Loadable\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9sYXp5LWR5bmFtaWMvbG9hZGFibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7MkNBd0VBOzs7ZUFBQUE7Ozs7aUNBeEUrQjsrQ0FDRjtzQ0FFRjtBQUUzQix5RkFBeUY7QUFDekYscUdBQXFHO0FBQ3JHLHFFQUFxRTtBQUNyRSxTQUFTQyxjQUNQQyxHQUE0RDtJQUk1RCxpSEFBaUg7SUFDakgsU0FBUztJQUNULDhCQUE4QjtJQUM5QixpQkFBaUI7SUFDakIsK0NBQStDO0lBQy9DLHdCQUF3QjtJQUN4QixJQUFNQyxhQUFhRCxPQUFPLGFBQWFBO0lBQ3ZDLE9BQU87UUFDTEUsV0FBU0QsYUFDTEQsR0FBNEJFLENBQUFBLFVBQU8sR0FDbENGO0lBQ1A7QUFDRjtBQUVBLElBQU1HLGlCQUFpQjtJQUNyQkMsUUFBUTtlQUFNQyxRQUFRQyxPQUFPLENBQUNQLGNBQWM7bUJBQU07OztJQUNsRFEsU0FBUztJQUNUQyxLQUFLO0FBQ1A7QUFTQSxTQUFTQyxTQUFTQyxPQUF3QjtJQUN4QyxJQUFNQyxPQUFPLHFCQUFLUixnQkFBbUJPO0lBQ3JDLElBQU1FLE9BQU9DLFdBQVBELEdBQU9DLENBQUFBLEdBQUFBLE9BQUFBLElBQUksRUFBQztlQUFNRixLQUFLUCxNQUFNLEdBQUdVLElBQUksQ0FBQ2Y7O0lBQzNDLElBQU1nQixVQUFVSixLQUFLSixPQUFPO0lBRTVCLFNBQVNTLGtCQUFrQkMsS0FBVTtRQUNuQyxJQUFNQyxrQkFBa0JILFVBQ3RCLFdBRHNCQSxHQUN0QixJQUFBSSxZQUFBQyxHQUFBLEVBQUNMLFNBQUFBO1lBQVFNLFdBQVc7WUFBTUMsV0FBVztZQUFNQyxPQUFPO2FBQ2hEO1FBRUosSUFBTUMsV0FBV2IsS0FBS0gsR0FBRyxHQUN2QixXQUR1QixHQUN2QixJQUFBVyxZQUFBTSxJQUFBLEVBQUFOLFlBQUFPLFFBQUE7O2dCQUVHLE9BQU9DLFdBQVcsY0FDakIsV0FEaUIsR0FDakIsSUFBQVIsWUFBQUMsR0FBQSxFQUFDUSxZQUFBQSxVQUFVO29CQUFDQyxXQUFXbEIsS0FBS21CLE9BQU87cUJBQ2pDOzhCQUNKLElBQUFYLFlBQUFDLEdBQUEsRUFBQ1IsTUFBQUEscUJBQVNLOzthQUdaLGtCQUFBRSxZQUFBQyxHQUFBLEVBQUNXLHFCQUFBQSxZQUFZO1lBQUNDLFFBQU87c0JBQ25CLGtCQUFBYixZQUFBQyxHQUFBLEVBQUNSLE1BQUFBLHFCQUFTSzs7UUFJZCxPQUFPLFdBQVAsR0FBTyxJQUFBRSxZQUFBQyxHQUFBLEVBQUNhLE9BQUFBLFFBQVE7WUFBQ0MsVUFBVWhCO3NCQUFrQk07O0lBQy9DO0lBRUFSLGtCQUFrQm1CLFdBQVcsR0FBRztJQUVoQyxPQUFPbkI7QUFDVDtLQTlCU1A7SUFnQ1RYLFdBQWVXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9sYXp5LWR5bmFtaWMvbG9hZGFibGUudHN4PzY3ZjQiXSwibmFtZXMiOlsiX2RlZmF1bHQiLCJjb252ZXJ0TW9kdWxlIiwibW9kIiwiaGFzRGVmYXVsdCIsImRlZmF1bHQiLCJkZWZhdWx0T3B0aW9ucyIsImxvYWRlciIsIlByb21pc2UiLCJyZXNvbHZlIiwibG9hZGluZyIsInNzciIsIkxvYWRhYmxlIiwib3B0aW9ucyIsIm9wdHMiLCJMYXp5IiwibGF6eSIsInRoZW4iLCJMb2FkaW5nIiwiTG9hZGFibGVDb21wb25lbnQiLCJwcm9wcyIsImZhbGxiYWNrRWxlbWVudCIsIl9qc3hydW50aW1lIiwianN4IiwiaXNMb2FkaW5nIiwicGFzdERlbGF5IiwiZXJyb3IiLCJjaGlsZHJlbiIsImpzeHMiLCJGcmFnbWVudCIsIndpbmRvdyIsIlByZWxvYWRDc3MiLCJtb2R1bGVJZHMiLCJtb2R1bGVzIiwiQmFpbG91dFRvQ1NSIiwicmVhc29uIiwiU3VzcGVuc2UiLCJmYWxsYmFjayIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/lazy-dynamic/loadable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/lazy-dynamic/preload-css.js":
/*!**************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/lazy-dynamic/preload-css.js ***!
  \**************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_to_consumable_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"PreloadCss\", ({\n    enumerable: true,\n    get: function get() {\n        return PreloadCss;\n    }\n}));\nvar _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-runtime.js\");\nfunction PreloadCss(param) {\n    var moduleIds = param.moduleIds;\n    // Early return in client compilation and only load requestStore on server side\n    if (typeof window !== \"undefined\") {\n        return null;\n    }\n    var getExpectedRequestStore = (__webpack_require__(/*! ../../../client/components/request-async-storage.external */ \"(shared)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/components/request-async-storage.external.js\").getExpectedRequestStore);\n    var requestStore = getExpectedRequestStore();\n    var allFiles = [];\n    // Search the current dynamic call unique key id in react loadable manifest,\n    // and find the corresponding CSS files to preload\n    if (requestStore.reactLoadableManifest && moduleIds) {\n        var manifest = requestStore.reactLoadableManifest;\n        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n        try {\n            for(var _iterator = moduleIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var key = _step.value;\n                var _allFiles;\n                if (!manifest[key]) continue;\n                var cssFiles = manifest[key].files.filter(function(file) {\n                    return file.endsWith(\".css\");\n                });\n                (_allFiles = allFiles).push.apply(_allFiles, _to_consumable_array._(cssFiles));\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                    _iterator[\"return\"]();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n    }\n    if (allFiles.length === 0) {\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: allFiles.map(function(file) {\n            return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n                // @ts-ignore\n                precedence: \"dynamic\",\n                rel: \"stylesheet\",\n                href: requestStore.assetPrefix + \"/_next/\" + encodeURI(file),\n                as: \"style\"\n            }, file);\n        })\n    });\n} //# sourceMappingURL=preload-css.js.map\n_c = PreloadCss;\nvar _c;\n$RefreshReg$(_c, \"PreloadCss\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9sYXp5LWR5bmFtaWMvcHJlbG9hZC1jc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFFTyxJQUFBQSxjQUFvQkMsbUJBQUFBLENBQWtEO1NBQWxEQyxXQUFXQyxLQUFYO0lBQ3pCLGdCQUFBQSxNQUFBQztJQUNBLCtFQUFtQztRQUNqQyxPQUFPQyxXQUFBO1FBQ1Q7SUFDQTtJQUdBLElBQU1DLDBCQUFlQyw4UkFBZkQ7SUFFTixJQUFNRSxlQUFhRDtJQUVuQixJQUFBQyxXQUFBO0lBQ0EsNEVBQWtEO0lBQ2xELGtEQUEwQ0o7UUFDeENFLGFBQU1HLHFCQUF3QkMsSUFBQUEsV0FBQUE7UUFDOUIsSUFBS0QsV0FBTUUsYUFBa0JELHFCQUFBO1lBQzNCOztvQkFBQSxZQUFjQyw4QkFBZCx3R0FBb0I7Z0JBQXBCLElBQUtGLE1BQUw7b0JBS0ZEO2dCQUpFLEtBQUFDLFFBQU1HLENBQUFBLElBQVdILEVBQUFBO2dCQUdqQkQsSUFBQUEsV0FBaUJJLFFBQUFBLENBQUFBLElBQUFBLENBQUFBLEtBQUFBLENBQUFBLE1BQUFBLENBQUFBLFNBQUFBOzJCQUFBQSxLQUFBQSxRQUFBQSxDQUFBQTs7Z0JBQ25CSixDQUFBQSxZQUFBQSxVQUFBSyxJQUFBLENBQUFMLE1BQUFBLFdBQUEsdUJBQUFJO1lBQ0Y7O1lBTkk7WUFBQTs7O3FCQUFBO29CQUFBOzs7b0JBQUE7MEJBQUE7Ozs7SUFRSjtRQUNFSixTQUFPTSxNQUFBO1FBQ1Q7SUFFQTtXQUVLTixXQUFBQSxHQUFBQSxDQUFBQSxHQUFTTyxZQUFLQyxHQUFBQSxFQUFBQSxZQUFBQSxRQUFBQSxFQUFBQTtrQkFDYlIsU0FBQU8sR0FBQSxVQUFBQzttQkFHaUIsa0JBQUFoQixZQUFBaUIsR0FBQTtnQkFDYkMsYUFBWTtnQkFDWkMsWUFBSTtnQkFDSkMsS0FBQUE7Z0JBQ0FDLE1BQUdmLGFBQUFnQixXQUFBLGVBQUFDLFVBQUFQO2dCQUxFQSxJQUFBQTtZQVFYLEdBQUFBOztJQUdOOztLQTdDMkJkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9sYXp5LWR5bmFtaWMvcHJlbG9hZC1jc3MudHN4P2RlNWMiXSwibmFtZXMiOlsiX2pzeHJ1bnRpbWUiLCJyZXF1aXJlIiwiUHJlbG9hZENzcyIsInBhcmFtIiwibW9kdWxlSWRzIiwid2luZG93IiwicmVxdWVzdFN0b3JlIiwiZ2V0RXhwZWN0ZWRSZXF1ZXN0U3RvcmUiLCJhbGxGaWxlcyIsIm1hbmlmZXN0IiwicmVhY3RMb2FkYWJsZU1hbmlmZXN0Iiwia2V5IiwiY3NzRmlsZXMiLCJwdXNoIiwibGVuZ3RoIiwibWFwIiwiZmlsZSIsImpzeCIsInByZWNlZGVuY2UiLCJyZWwiLCJocmVmIiwiYXMiLCJhc3NldFByZWZpeCIsImVuY29kZVVSSSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/lazy-dynamic/preload-css.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!**********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \**********************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasMatch: function hasMatch1() {\n        return hasMatch;\n    },\n    matchRemotePattern: function matchRemotePattern1() {\n        return matchRemotePattern;\n    }\n});\nvar _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchRemotePattern(pattern, url) {\n    if (pattern.protocol !== undefined) {\n        var actualProto = url.protocol.slice(0, -1);\n        if (pattern.protocol !== actualProto) {\n            return false;\n        }\n    }\n    if (pattern.port !== undefined) {\n        if (pattern.port !== url.port) {\n            return false;\n        }\n    }\n    if (pattern.hostname === undefined) {\n        throw new Error(\"Pattern should define hostname but found\\n\" + JSON.stringify(pattern));\n    } else {\n        if (!(0, _picomatch.makeRe)(pattern.hostname).test(url.hostname)) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : \"**\", {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasMatch(domains, remotePatterns, url) {\n    return domains.some(function(domain) {\n        return url.hostname === domain;\n    }) || remotePatterns.some(function(p) {\n        return matchRemotePattern(p, url);\n    });\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1yZW1vdGUtcGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFpQ2dCQSxVQUFRLFNBQVJBO2VBQUFBOztJQTlCQUMsb0JBQWtCLFNBQWxCQTtlQUFBQTs7O3FDQUZPO0FBRWhCLFNBQVNBLG1CQUFtQkMsT0FBc0IsRUFBRUMsR0FBUTtJQUNqRSxJQUFJRCxRQUFRRSxRQUFRLEtBQUtDLFdBQVc7UUFDbEMsSUFBTUMsY0FBY0gsSUFBSUMsUUFBUSxDQUFDRyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQzNDLElBQUlMLFFBQVFFLFFBQVEsS0FBS0UsYUFBYTtZQUNwQyxPQUFPO1FBQ1Q7SUFDRjtJQUNBLElBQUlKLFFBQVFNLElBQUksS0FBS0gsV0FBVztRQUM5QixJQUFJSCxRQUFRTSxJQUFJLEtBQUtMLElBQUlLLElBQUksRUFBRTtZQUM3QixPQUFPO1FBQ1Q7SUFDRjtJQUVBLElBQUlOLFFBQVFPLFFBQVEsS0FBS0osV0FBVztRQUNsQyxNQUFNLElBQUlLLE1BQ1IsK0NBQTZDQyxLQUFLQyxTQUFTLENBQUNWO0lBRWhFLE9BQU87UUFDTCxJQUFJLENBQUNXLENBQUFBLEdBQUFBLFdBQUFBLE1BQU0sRUFBQ1gsUUFBUU8sUUFBUSxFQUFFSyxJQUFJLENBQUNYLElBQUlNLFFBQVEsR0FBRztZQUNoRCxPQUFPO1FBQ1Q7SUFDRjtRQUVZUDtJQUFaLElBQUksQ0FBQ1csQ0FBQUEsR0FBQUEsV0FBQUEsTUFBTSxFQUFDWCxDQUFBQSxvQkFBQUEsUUFBUWEsUUFBUSxZQUFoQmIsb0JBQW9CLE1BQU07UUFBRWMsS0FBSztJQUFLLEdBQUdGLElBQUksQ0FBQ1gsSUFBSVksUUFBUSxHQUFHO1FBQ3ZFLE9BQU87SUFDVDtJQUVBLE9BQU87QUFDVDtBQUVPLFNBQVNmLFNBQ2RpQixPQUFpQixFQUNqQkMsY0FBK0IsRUFDL0JmLEdBQVE7SUFFUixPQUNFYyxRQUFRRSxJQUFJLENBQUMsU0FBQ0M7ZUFBV2pCLElBQUlNLFFBQVEsS0FBS1c7VUFDMUNGLGVBQWVDLElBQUksQ0FBQyxTQUFDRTtlQUFNcEIsbUJBQW1Cb0IsR0FBR2xCOztBQUVyRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvbWF0Y2gtcmVtb3RlLXBhdHRlcm4udHM/ZDYxZCJdLCJuYW1lcyI6WyJoYXNNYXRjaCIsIm1hdGNoUmVtb3RlUGF0dGVybiIsInBhdHRlcm4iLCJ1cmwiLCJwcm90b2NvbCIsInVuZGVmaW5lZCIsImFjdHVhbFByb3RvIiwic2xpY2UiLCJwb3J0IiwiaG9zdG5hbWUiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJtYWtlUmUiLCJ0ZXN0IiwicGF0aG5hbWUiLCJkb3QiLCJkb21haW5zIiwicmVtb3RlUGF0dGVybnMiLCJzb21lIiwiZG9tYWluIiwicCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!*******************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \*******************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function get() {\n        return RouterContext;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\"));\nvar RouterContext = _react[\"default\"].createContext(null);\nif (true) {\n    RouterContext.displayName = \"RouterContext\";\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O2lEQUdhQTs7O2VBQUFBOzs7OzBFQUhLO0FBR1gsSUFBTUEsZ0JBQWdCQyxNQUFBQSxDQUFBQSxVQUFLLENBQUNDLGFBQWEsQ0FBb0I7QUFFcEUsSUFBSUMsSUFBeUIsRUFBYztJQUN6Q0gsY0FBY0ksV0FBVyxHQUFHO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS50cz82MzZjIl0sIm5hbWVzIjpbIlJvdXRlckNvbnRleHQiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \*************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatUrl: function formatUrl1() {\n        return formatUrl;\n    },\n    formatWithValidation: function formatWithValidation1() {\n        return formatWithValidation;\n    },\n    urlObjectKeys: function urlObjectKeys1() {\n        return urlObjectKeys;\n    }\n});\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./querystring */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/querystring.js\"));\nvar slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    var auth = urlObj.auth, hostname = urlObj.hostname;\n    var protocol = urlObj.protocol || \"\";\n    var pathname = urlObj.pathname || \"\";\n    var hash = urlObj.hash || \"\";\n    var query = urlObj.query || \"\";\n    var host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, \":\") + \"@\" : \"\";\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(\":\") ? \"[\" + hostname + \"]\" : hostname);\n        if (urlObj.port) {\n            host += \":\" + urlObj.port;\n        }\n    }\n    if (query && typeof query === \"object\") {\n        query = String(_querystring.urlQueryToSearchParams(query));\n    }\n    var search = urlObj.search || query && \"?\" + query || \"\";\n    if (protocol && !protocol.endsWith(\":\")) protocol += \":\";\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = \"//\" + (host || \"\");\n        if (pathname && pathname[0] !== \"/\") pathname = \"/\" + pathname;\n    } else if (!host) {\n        host = \"\";\n    }\n    if (hash && hash[0] !== \"#\") hash = \"#\" + hash;\n    if (search && search[0] !== \"?\") search = \"?\" + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace(\"#\", \"%23\");\n    return \"\" + protocol + host + pathname + search + hash;\n}\nvar urlObjectKeys = [\n    \"auth\",\n    \"hash\",\n    \"host\",\n    \"hostname\",\n    \"href\",\n    \"path\",\n    \"pathname\",\n    \"port\",\n    \"protocol\",\n    \"query\",\n    \"search\",\n    \"slashes\"\n];\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === \"object\") {\n            Object.keys(url).forEach(function(key) {\n                if (!urlObjectKeys.includes(key)) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \" + key);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx1Q0FBdUM7QUFDdkMsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5Qzs7Ozs7Ozs7Ozs7OztJQVF6QkEsV0FBUyxTQUFUQTtlQUFBQTs7SUE2REFDLHNCQUFvQixTQUFwQkE7ZUFBQUE7O0lBZkhDLGVBQWEsU0FBYkE7ZUFBQUE7Ozs7aUZBbERnQjtBQUU3QixJQUFNQyxtQkFBbUI7QUFFbEIsU0FBU0gsVUFBVUksTUFBaUI7SUFDekMsSUFBTUMsT0FBbUJELE9BQW5CQyxNQUFNQyxXQUFhRixPQUFiRTtJQUNaLElBQUlDLFdBQVdILE9BQU9HLFFBQVEsSUFBSTtJQUNsQyxJQUFJQyxXQUFXSixPQUFPSSxRQUFRLElBQUk7SUFDbEMsSUFBSUMsT0FBT0wsT0FBT0ssSUFBSSxJQUFJO0lBQzFCLElBQUlDLFFBQVFOLE9BQU9NLEtBQUssSUFBSTtJQUM1QixJQUFJQyxPQUF1QjtJQUUzQk4sT0FBT0EsT0FBT08sbUJBQW1CUCxNQUFNUSxPQUFPLENBQUMsUUFBUSxPQUFPLE1BQU07SUFFcEUsSUFBSVQsT0FBT08sSUFBSSxFQUFFO1FBQ2ZBLE9BQU9OLE9BQU9ELE9BQU9PLElBQUk7SUFDM0IsT0FBTyxJQUFJTCxVQUFVO1FBQ25CSyxPQUFPTixPQUFRLEVBQUNDLFNBQVNRLE9BQU8sQ0FBQyxPQUFPLE1BQUlSLFdBQVMsTUFBS0EsUUFBQUE7UUFDMUQsSUFBSUYsT0FBT1csSUFBSSxFQUFFO1lBQ2ZKLFFBQVEsTUFBTVAsT0FBT1csSUFBSTtRQUMzQjtJQUNGO0lBRUEsSUFBSUwsU0FBUyxPQUFPQSxVQUFVLFVBQVU7UUFDdENBLFFBQVFNLE9BQU9DLGFBQVlDLHNCQUFzQixDQUFDUjtJQUNwRDtJQUVBLElBQUlTLFNBQVNmLE9BQU9lLE1BQU0sSUFBS1QsU0FBUyxNQUFJQSxTQUFZO0lBRXhELElBQUlILFlBQVksQ0FBQ0EsU0FBU2EsUUFBUSxDQUFDLE1BQU1iLFlBQVk7SUFFckQsSUFDRUgsT0FBT2lCLE9BQU8sSUFDYixDQUFDLENBQUNkLFlBQVlKLGlCQUFpQm1CLElBQUksQ0FBQ2YsU0FBQUEsS0FBY0ksU0FBUyxPQUM1RDtRQUNBQSxPQUFPLE9BQVFBLENBQUFBLFFBQVE7UUFDdkIsSUFBSUgsWUFBWUEsUUFBUSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxXQUFXLE1BQU1BO0lBQ3hELE9BQU8sSUFBSSxDQUFDRyxNQUFNO1FBQ2hCQSxPQUFPO0lBQ1Q7SUFFQSxJQUFJRixRQUFRQSxJQUFJLENBQUMsRUFBRSxLQUFLLEtBQUtBLE9BQU8sTUFBTUE7SUFDMUMsSUFBSVUsVUFBVUEsTUFBTSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxTQUFTLE1BQU1BO0lBRWhEWCxXQUFXQSxTQUFTSyxPQUFPLENBQUMsU0FBU0Q7SUFDckNPLFNBQVNBLE9BQU9OLE9BQU8sQ0FBQyxLQUFLO0lBRTdCLE9BQU8sS0FBR04sV0FBV0ksT0FBT0gsV0FBV1csU0FBU1Y7QUFDbEQ7QUFFTyxJQUFNUCxnQkFBZ0I7SUFDM0I7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFTSxTQUFTRCxxQkFBcUJzQixHQUFjO0lBQ2pELElBQUlDLElBQXlCLEVBQWU7UUFDMUMsSUFBSUQsUUFBUSxRQUFRLE9BQU9BLFFBQVEsVUFBVTtZQUMzQ0UsT0FBT0MsSUFBSSxDQUFDSCxLQUFLSSxPQUFPLENBQUMsU0FBQ0M7Z0JBQ3hCLElBQUksQ0FBQzFCLGNBQWMyQixRQUFRLENBQUNELE1BQU07b0JBQ2hDRSxRQUFRQyxJQUFJLENBQ1YsdURBQXFESDtnQkFFekQ7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPNUIsVUFBVXVCO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC50cz8xYjg3Il0sIm5hbWVzIjpbImZvcm1hdFVybCIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwidXJsT2JqZWN0S2V5cyIsInNsYXNoZWRQcm90b2NvbHMiLCJ1cmxPYmoiLCJhdXRoIiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInBhdGhuYW1lIiwiaGFzaCIsInF1ZXJ5IiwiaG9zdCIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlcGxhY2UiLCJpbmRleE9mIiwicG9ydCIsIlN0cmluZyIsInF1ZXJ5c3RyaW5nIiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsInNlYXJjaCIsImVuZHNXaXRoIiwic2xhc2hlcyIsInRlc3QiLCJ1cmwiLCJwcm9jZXNzIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJpbmNsdWRlcyIsImNvbnNvbGUiLCJ3YXJuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/format-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/index.js":
/*!********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/index.js ***!
  \********************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getSortedRoutes: function getSortedRoutes() {\n        return _sortedroutes.getSortedRoutes;\n    },\n    isDynamicRoute: function isDynamicRoute() {\n        return _isdynamic.isDynamicRoute;\n    }\n});\nvar _sortedroutes = __webpack_require__(/*! ./sorted-routes */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\");\nvar _isdynamic = __webpack_require__(/*! ./is-dynamic */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\"); //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBQVNBLGlCQUFlLFNBQWZBO2VBQUFBLGNBQUFBLGVBQWU7O0lBQ2ZDLGdCQUFjLFNBQWRBO2VBQUFBLFdBQUFBLGNBQWM7Ozt3Q0FEUztxQ0FDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2luZGV4LnRzPzcyZDUiXSwibmFtZXMiOlsiZ2V0U29ydGVkUm91dGVzIiwiaXNEeW5hbWljUm91dGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/interpolate-as.js":
/*!*****************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/interpolate-as.js ***!
  \*****************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"interpolateAs\", ({\n    enumerable: true,\n    get: function get() {\n        return interpolateAs;\n    }\n}));\nvar _routematcher = __webpack_require__(/*! ./route-matcher */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nvar _routeregex = __webpack_require__(/*! ./route-regex */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nfunction interpolateAs(route, asPathname, query) {\n    var interpolatedRoute = \"\";\n    var dynamicRegex = (0, _routeregex.getRouteRegex)(route);\n    var dynamicGroups = dynamicRegex.groups;\n    var dynamicMatches = (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : \"\") || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    var params = Object.keys(dynamicGroups);\n    if (!params.every(function(param) {\n        var value = dynamicMatches[param] || \"\";\n        var _dynamicGroups_param = dynamicGroups[param], repeat = _dynamicGroups_param.repeat, optional = _dynamicGroups_param.optional;\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        var replaced = \"[\" + (repeat ? \"...\" : \"\") + param + \"]\";\n        if (optional) {\n            replaced = (!value ? \"/\" : \"\") + \"[\" + replaced + \"]\";\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        function(segment) {\n            return encodeURIComponent(segment);\n        }).join(\"/\") : encodeURIComponent(value)) || \"/\");\n    })) {\n        interpolatedRoute = \"\" // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params: params,\n        result: interpolatedRoute\n    };\n} //# sourceMappingURL=interpolate-as.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJwb2xhdGUtYXMuanMiLCJtYXBwaW5ncyI6Ijs7OztpREFLZ0JBOzs7ZUFBQUE7Ozt3Q0FIZ0I7c0NBQ0Y7QUFFdkIsU0FBU0EsY0FDZEMsS0FBYSxFQUNiQyxVQUFrQixFQUNsQkMsS0FBcUI7SUFFckIsSUFBSUMsb0JBQW9CO0lBRXhCLElBQU1DLGVBQWVDLENBQUFBLEdBQUFBLFlBQUFBLGFBQWEsRUFBQ0w7SUFDbkMsSUFBTU0sZ0JBQWdCRixhQUFhRyxNQUFNO0lBQ3pDLElBQU1DLGlCQUVIUCxDQUFBQSxlQUFlRCxRQUFRUyxDQUFBQSxHQUFBQSxjQUFBQSxlQUFlLEVBQUNMLGNBQWNILGNBQWMsT0FDcEUsZ0RBQWdEO0lBQ2hELHNFQUFzRTtJQUN0RUM7SUFFRkMsb0JBQW9CSDtJQUNwQixJQUFNVSxTQUFTQyxPQUFPQyxJQUFJLENBQUNOO0lBRTNCLElBQ0UsQ0FBQ0ksT0FBT0csS0FBSyxDQUFDLFNBQUNDO1FBQ2IsSUFBSUMsUUFBUVAsY0FBYyxDQUFDTSxNQUFNLElBQUk7UUFDckMsSUFBNkJSLHVCQUFBQSxhQUFhLENBQUNRLE1BQU0sRUFBekNFLFNBQXFCVixxQkFBckJVLFFBQVFDLFdBQWFYLHFCQUFiVztRQUVoQixpQ0FBaUM7UUFDakMsMERBQTBEO1FBQzFELElBQUlDLFdBQVcsTUFBSUYsQ0FBQUEsU0FBUyxRQUFRLE1BQUtGLFFBQU07UUFDL0MsSUFBSUcsVUFBVTtZQUNaQyxXQUFXLENBQUcsQ0FBQ0gsUUFBUSxNQUFNLE1BQUcsTUFBR0csV0FBUztRQUM5QztRQUNBLElBQUlGLFVBQVUsQ0FBQ0csTUFBTUMsT0FBTyxDQUFDTCxRQUFRQSxRQUFRO1lBQUNBO1NBQU07UUFFcEQsT0FDRSxDQUFDRSxZQUFZSCxTQUFTTixjQUFBQSxLQUN0Qiw2Q0FBNkM7UUFDNUNMLENBQUFBLG9CQUNDQSxrQkFBbUJrQixPQUFPLENBQ3hCSCxVQUNBRixTQUNJRCxNQUNHTyxHQUFHLENBRUYsdURBQXVEO1FBQ3ZELGtEQUFrRDtRQUNsRCxvQ0FBb0M7UUFDcEMsU0FBQ0M7bUJBQVlDLG1CQUFtQkQ7V0FFakNFLElBQUksQ0FBQyxPQUNSRCxtQkFBbUJULFdBQ3BCO0lBRVgsSUFDQTtRQUNBWixvQkFBb0IsR0FBRyxtQ0FBbUM7O0lBRTFELHVFQUF1RTtJQUN2RSxrREFBa0Q7SUFDcEQ7SUFDQSxPQUFPO1FBQ0xPLFFBQUFBO1FBQ0FnQixRQUFRdkI7SUFDVjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJwb2xhdGUtYXMudHM/OWUzMSJdLCJuYW1lcyI6WyJpbnRlcnBvbGF0ZUFzIiwicm91dGUiLCJhc1BhdGhuYW1lIiwicXVlcnkiLCJpbnRlcnBvbGF0ZWRSb3V0ZSIsImR5bmFtaWNSZWdleCIsImdldFJvdXRlUmVnZXgiLCJkeW5hbWljR3JvdXBzIiwiZ3JvdXBzIiwiZHluYW1pY01hdGNoZXMiLCJnZXRSb3V0ZU1hdGNoZXIiLCJwYXJhbXMiLCJPYmplY3QiLCJrZXlzIiwiZXZlcnkiLCJwYXJhbSIsInZhbHVlIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJyZXBsYWNlZCIsIkFycmF5IiwiaXNBcnJheSIsInJlcGxhY2UiLCJtYXAiLCJzZWdtZW50IiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwiam9pbiIsInJlc3VsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js ***!
  \*************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isDynamicRoute\", ({\n    enumerable: true,\n    get: function get() {\n        return isDynamicRoute;\n    }\n}));\nvar _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/server/future/helpers/interception-routes.js\");\n// Identify /[param]/ in route string\nvar TEST_ROUTE = /\\/\\[[^/]+?\\](?=\\/|$)/;\nfunction isDynamicRoute(route) {\n    if ((0, _interceptionroutes.isInterceptionRouteAppPath)(route)) {\n        route = (0, _interceptionroutes.extractInterceptionRouteInformation)(route).interceptedRoute;\n    }\n    return TEST_ROUTE.test(route);\n} //# sourceMappingURL=is-dynamic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy5qcyIsIm1hcHBpbmdzIjoiOzs7O2tEQVFnQkE7OztlQUFBQTs7OzhDQUxUO0FBRVAscUNBQXFDO0FBQ3JDLElBQU1DLGFBQWE7QUFFWixTQUFTRCxlQUFlRSxLQUFhO0lBQzFDLElBQUlDLENBQUFBLEdBQUFBLG9CQUFBQSwwQkFBMEIsRUFBQ0QsUUFBUTtRQUNyQ0EsUUFBUUUsQ0FBQUEsR0FBQUEsb0JBQUFBLG1DQUFtQyxFQUFDRixPQUFPRyxnQkFBZ0I7SUFDckU7SUFFQSxPQUFPSixXQUFXSyxJQUFJLENBQUNKO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy50cz84MmRjIl0sIm5hbWVzIjpbImlzRHluYW1pY1JvdXRlIiwiVEVTVF9ST1VURSIsInJvdXRlIiwiaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgiLCJleHRyYWN0SW50ZXJjZXB0aW9uUm91dGVJbmZvcm1hdGlvbiIsImludGVyY2VwdGVkUm91dGUiLCJ0ZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/is-local-url.js":
/*!***************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/is-local-url.js ***!
  \***************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isLocalURL\", ({\n    enumerable: true,\n    get: function get() {\n        return isLocalURL;\n    }\n}));\nvar _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils.js\");\nvar _hasbasepath = __webpack_require__(/*! ../../../../client/has-base-path */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/has-base-path.js\");\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils.isAbsoluteUrl)(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        var locationOrigin = (0, _utils.getLocationOrigin)();\n        var resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n} //# sourceMappingURL=is-local-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7OENBTWdCQTs7O2VBQUFBOzs7aUNBTmlDO3VDQUNyQjtBQUtyQixTQUFTQSxXQUFXQyxHQUFXO0lBQ3BDLGdFQUFnRTtJQUNoRSxJQUFJLENBQUNDLENBQUFBLEdBQUFBLE9BQUFBLGFBQWEsRUFBQ0QsTUFBTSxPQUFPO0lBQ2hDLElBQUk7UUFDRiw0REFBNEQ7UUFDNUQsSUFBTUUsaUJBQWlCQyxDQUFBQSxHQUFBQSxPQUFBQSxpQkFBaUI7UUFDeEMsSUFBTUMsV0FBVyxJQUFJQyxJQUFJTCxLQUFLRTtRQUM5QixPQUFPRSxTQUFTRSxNQUFNLEtBQUtKLGtCQUFrQkssQ0FBQUEsR0FBQUEsYUFBQUEsV0FBVyxFQUFDSCxTQUFTSSxRQUFRO0lBQzVFLEVBQUUsT0FBT0MsR0FBRztRQUNWLE9BQU87SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLnRzPzA0ZTUiXSwibmFtZXMiOlsiaXNMb2NhbFVSTCIsInVybCIsImlzQWJzb2x1dGVVcmwiLCJsb2NhdGlvbk9yaWdpbiIsImdldExvY2F0aW9uT3JpZ2luIiwicmVzb2x2ZWQiLCJVUkwiLCJvcmlnaW4iLCJoYXNCYXNlUGF0aCIsInBhdGhuYW1lIiwiXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/is-local-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/omit.js":
/*!*******************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/omit.js ***!
  \*******************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"omit\", ({\n    enumerable: true,\n    get: function get() {\n        return omit;\n    }\n}));\nfunction omit(object, keys) {\n    var omitted = {};\n    Object.keys(object).forEach(function(key) {\n        if (!keys.includes(key)) {\n            omitted[key] = object[key];\n        }\n    });\n    return omitted;\n} //# sourceMappingURL=omit.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvb21pdC5qcyIsIm1hcHBpbmdzIjoiOzs7O3dDQUFnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0EsS0FDZEMsTUFBUyxFQUNUQyxJQUFTO0lBRVQsSUFBTUMsVUFBc0MsQ0FBQztJQUM3Q0MsT0FBT0YsSUFBSSxDQUFDRCxRQUFRSSxPQUFPLENBQUMsU0FBQ0M7UUFDM0IsSUFBSSxDQUFDSixLQUFLSyxRQUFRLENBQUNELE1BQVc7WUFDNUJILE9BQU8sQ0FBQ0csSUFBSSxHQUFHTCxNQUFNLENBQUNLLElBQUk7UUFDNUI7SUFDRjtJQUNBLE9BQU9IO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9vbWl0LnRzP2I3YTgiXSwibmFtZXMiOlsib21pdCIsIm9iamVjdCIsImtleXMiLCJvbWl0dGVkIiwiT2JqZWN0IiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/omit.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!**************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \**************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    assign: function assign1() {\n        return assign;\n    },\n    searchParamsToUrlQuery: function searchParamsToUrlQuery1() {\n        return searchParamsToUrlQuery;\n    },\n    urlQueryToSearchParams: function urlQueryToSearchParams1() {\n        return urlQueryToSearchParams;\n    }\n});\nfunction searchParamsToUrlQuery(searchParams) {\n    var query = {};\n    searchParams.forEach(function(value, key) {\n        if (typeof query[key] === \"undefined\") {\n            query[key] = value;\n        } else if (Array.isArray(query[key])) {\n            query[key].push(value);\n        } else {\n            query[key] = [\n                query[key],\n                value\n            ];\n        }\n    });\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === \"string\" || typeof param === \"number\" && !isNaN(param) || typeof param === \"boolean\") {\n        return String(param);\n    } else {\n        return \"\";\n    }\n}\nfunction urlQueryToSearchParams(urlQuery) {\n    var result = new URLSearchParams();\n    Object.entries(urlQuery).forEach(function(param) {\n        var _param = _sliced_to_array._(param, 2), key = _param[0], value = _param[1];\n        if (Array.isArray(value)) {\n            value.forEach(function(item) {\n                return result.append(key, stringifyUrlQueryParam(item));\n            });\n        } else {\n            result.set(key, stringifyUrlQueryParam(value));\n        }\n    });\n    return result;\n}\nfunction assign(target) {\n    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        searchParamsList[_key - 1] = arguments[_key];\n    }\n    searchParamsList.forEach(function(searchParams) {\n        Array.from(searchParams.keys()).forEach(function(key) {\n            return target[\"delete\"](key);\n        });\n        searchParams.forEach(function(value, key) {\n            return target.append(key, value);\n        });\n    });\n    return target;\n} //# sourceMappingURL=querystring.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztJQTRDZ0JBLFFBQU0sU0FBTkE7ZUFBQUE7O0lBMUNBQyx3QkFBc0IsU0FBdEJBO2VBQUFBOztJQTRCQUMsd0JBQXNCLFNBQXRCQTtlQUFBQTs7O0FBNUJULFNBQVNELHVCQUNkRSxZQUE2QjtJQUU3QixJQUFNQyxRQUF3QixDQUFDO0lBQy9CRCxhQUFhRSxPQUFPLENBQUMsU0FBQ0MsT0FBT0M7UUFDM0IsSUFBSSxPQUFPSCxLQUFLLENBQUNHLElBQUksS0FBSyxhQUFhO1lBQ3JDSCxLQUFLLENBQUNHLElBQUksR0FBR0Q7UUFDZixPQUFPLElBQUlFLE1BQU1DLE9BQU8sQ0FBQ0wsS0FBSyxDQUFDRyxJQUFJLEdBQUc7WUFDbENILEtBQUssQ0FBQ0csSUFBSSxDQUFjRyxJQUFJLENBQUNKO1FBQ2pDLE9BQU87WUFDTEYsS0FBSyxDQUFDRyxJQUFJLEdBQUc7Z0JBQUNILEtBQUssQ0FBQ0csSUFBSTtnQkFBWUQ7YUFBTTtRQUM1QztJQUNGO0lBQ0EsT0FBT0Y7QUFDVDtBQUVBLFNBQVNPLHVCQUF1QkMsS0FBYztJQUM1QyxJQUNFLE9BQU9BLFVBQVUsWUFDaEIsT0FBT0EsVUFBVSxZQUFZLENBQUNDLE1BQU1ELFVBQ3JDLE9BQU9BLFVBQVUsV0FDakI7UUFDQSxPQUFPRSxPQUFPRjtJQUNoQixPQUFPO1FBQ0wsT0FBTztJQUNUO0FBQ0Y7QUFFTyxTQUFTVix1QkFDZGEsUUFBd0I7SUFFeEIsSUFBTUMsU0FBUyxJQUFJQztJQUNuQkMsT0FBT0MsT0FBTyxDQUFDSixVQUFVVixPQUFPLENBQUMsU0FBQU87WUFBYUEsNEJBQUFBLFdBQVhMLE1BQVdLLFdBQU5OLFFBQU1NO1FBQzVDLElBQUlKLE1BQU1DLE9BQU8sQ0FBQ0gsUUFBUTtZQUN4QkEsTUFBTUQsT0FBTyxDQUFDLFNBQUNlO3VCQUFTSixPQUFPSyxNQUFNLENBQUNkLEtBQUtJLHVCQUF1QlM7O1FBQ3BFLE9BQU87WUFDTEosT0FBT00sR0FBRyxDQUFDZixLQUFLSSx1QkFBdUJMO1FBQ3pDO0lBQ0Y7SUFDQSxPQUFPVTtBQUNUO0FBRU8sU0FBU2hCLE9BQ2R1QixNQUF1QjtJQUN2QixRQUFBQyxPQUFBQyxVQUFBQyxNQUFBLEVBQUFDLG1CQUFBLElBQUFuQixNQUFBZ0IsT0FBQSxJQUFBQSxPQUFBLFFBQUFJLE9BQUEsR0FBQUEsT0FBQUosTUFBQUksT0FBQTtRQUFHRCxnQkFBQUEsQ0FBSEMsT0FBQSxLQUFBSCxTQUFBLENBQUFHLEtBQXNDOztJQUV0Q0QsaUJBQWlCdEIsT0FBTyxDQUFDLFNBQUNGO1FBQ3hCSyxNQUFNcUIsSUFBSSxDQUFDMUIsYUFBYTJCLElBQUksSUFBSXpCLE9BQU8sQ0FBQyxTQUFDRTttQkFBUWdCLE1BQU9RLENBQUFBLFNBQU0sQ0FBQ3hCOztRQUMvREosYUFBYUUsT0FBTyxDQUFDLFNBQUNDLE9BQU9DO21CQUFRZ0IsT0FBT0YsTUFBTSxDQUFDZCxLQUFLRDs7SUFDMUQ7SUFDQSxPQUFPaUI7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nLnRzPzgyZmEiXSwibmFtZXMiOlsiYXNzaWduIiwic2VhcmNoUGFyYW1zVG9VcmxRdWVyeSIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJzZWFyY2hQYXJhbXMiLCJxdWVyeSIsImZvckVhY2giLCJ2YWx1ZSIsImtleSIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJzdHJpbmdpZnlVcmxRdWVyeVBhcmFtIiwicGFyYW0iLCJpc05hTiIsIlN0cmluZyIsInVybFF1ZXJ5IiwicmVzdWx0IiwiVVJMU2VhcmNoUGFyYW1zIiwiT2JqZWN0IiwiZW50cmllcyIsIml0ZW0iLCJhcHBlbmQiLCJzZXQiLCJ0YXJnZXQiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic2VhcmNoUGFyYW1zTGlzdCIsIl9rZXkiLCJmcm9tIiwia2V5cyIsImRlbGV0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/querystring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/route-matcher.js":
/*!****************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/route-matcher.js ***!
  \****************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getRouteMatcher\", ({\n    enumerable: true,\n    get: function get() {\n        return getRouteMatcher;\n    }\n}));\nvar _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils.js\");\nfunction getRouteMatcher(param) {\n    var re = param.re, groups = param.groups;\n    return function(pathname) {\n        var routeMatch = re.exec(pathname);\n        if (!routeMatch) {\n            return false;\n        }\n        var decode = function(param) {\n            try {\n                return decodeURIComponent(param);\n            } catch (_) {\n                throw new _utils.DecodeError(\"failed to decode param\");\n            }\n        };\n        var params = {};\n        Object.keys(groups).forEach(function(slugName) {\n            var g = groups[slugName];\n            var m = routeMatch[g.pos];\n            if (m !== undefined) {\n                params[slugName] = ~m.indexOf(\"/\") ? m.split(\"/\").map(function(entry) {\n                    return decode(entry);\n                }) : g.repeat ? [\n                    decode(m)\n                ] : decode(m);\n            }\n        });\n        return params;\n    };\n} //# sourceMappingURL=route-matcher.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQVdnQkE7OztlQUFBQTs7O2lDQVZZO0FBVXJCLFNBQVNBLGdCQUFnQkMsS0FBMEI7SUFBMUIsSUFBRUMsS0FBRkQsTUFBRUMsSUFBSUMsU0FBTkYsTUFBTUU7SUFDcEMsT0FBTyxTQUFDQztRQUNOLElBQU1DLGFBQWFILEdBQUdJLElBQUksQ0FBQ0Y7UUFDM0IsSUFBSSxDQUFDQyxZQUFZO1lBQ2YsT0FBTztRQUNUO1FBRUEsSUFBTUUsU0FBUyxTQUFDTjtZQUNkLElBQUk7Z0JBQ0YsT0FBT08sbUJBQW1CUDtZQUM1QixFQUFFLE9BQU9RLEdBQUc7Z0JBQ1YsTUFBTSxJQUFJQyxPQUFBQSxXQUFXLENBQUM7WUFDeEI7UUFDRjtRQUNBLElBQU1DLFNBQXFELENBQUM7UUFFNURDLE9BQU9DLElBQUksQ0FBQ1YsUUFBUVcsT0FBTyxDQUFDLFNBQUNDO1lBQzNCLElBQU1DLElBQUliLE1BQU0sQ0FBQ1ksU0FBUztZQUMxQixJQUFNRSxJQUFJWixVQUFVLENBQUNXLEVBQUVFLEdBQUcsQ0FBQztZQUMzQixJQUFJRCxNQUFNRSxXQUFXO2dCQUNuQlIsTUFBTSxDQUFDSSxTQUFTLEdBQUcsQ0FBQ0UsRUFBRUcsT0FBTyxDQUFDLE9BQzFCSCxFQUFFSSxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDLFNBQUNDOzJCQUFVaEIsT0FBT2dCO3FCQUNuQ1AsRUFBRVEsTUFBTSxHQUNSO29CQUFDakIsT0FBT1U7aUJBQUcsR0FDWFYsT0FBT1U7WUFDYjtRQUNGO1FBQ0EsT0FBT047SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci50cz8zMTc5Il0sIm5hbWVzIjpbImdldFJvdXRlTWF0Y2hlciIsInBhcmFtIiwicmUiLCJncm91cHMiLCJwYXRobmFtZSIsInJvdXRlTWF0Y2giLCJleGVjIiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiXyIsIkRlY29kZUVycm9yIiwicGFyYW1zIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJzbHVnTmFtZSIsImciLCJtIiwicG9zIiwidW5kZWZpbmVkIiwiaW5kZXhPZiIsInNwbGl0IiwibWFwIiwiZW50cnkiLCJyZXBlYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/route-matcher.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/route-regex.js":
/*!**************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/route-regex.js ***!
  \**************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getNamedMiddlewareRegex: function getNamedMiddlewareRegex1() {\n        return getNamedMiddlewareRegex;\n    },\n    getNamedRouteRegex: function getNamedRouteRegex1() {\n        return getNamedRouteRegex;\n    },\n    getRouteRegex: function getRouteRegex1() {\n        return getRouteRegex;\n    }\n});\nvar _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/server/future/helpers/interception-routes.js\");\nvar _escaperegexp = __webpack_require__(/*! ../../escape-regexp */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/escape-regexp.js\");\nvar _removetrailingslash = __webpack_require__(/*! ./remove-trailing-slash */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nvar NEXT_QUERY_PARAM_PREFIX = \"nxtP\";\nvar NEXT_INTERCEPTION_MARKER_PREFIX = \"nxtI\";\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n */ function parseParameter(param) {\n    var optional = param.startsWith(\"[\") && param.endsWith(\"]\");\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    var repeat = param.startsWith(\"...\");\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat: repeat,\n        optional: optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    var segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    var groups = {};\n    var groupIndex = 1;\n    return {\n        parameterizedRoute: segments.map(function(segment) {\n            var markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find(function(m) {\n                return segment.startsWith(m);\n            });\n            var paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (markerMatch && paramMatches) {\n                var _parseParameter = parseParameter(paramMatches[1]), key = _parseParameter.key, optional = _parseParameter.optional, repeat = _parseParameter.repeat;\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat: repeat,\n                    optional: optional\n                };\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\";\n            } else if (paramMatches) {\n                var _parseParameter1 = parseParameter(paramMatches[1]), key1 = _parseParameter1.key, repeat1 = _parseParameter1.repeat, optional1 = _parseParameter1.optional;\n                groups[key1] = {\n                    pos: groupIndex++,\n                    repeat: repeat1,\n                    optional: optional1\n                };\n                return repeat1 ? optional1 ? \"(?:/(.+?))?\" : \"/(.+?)\" : \"/([^/]+?)\";\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        groups: groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    var _getParametrizedRoute = getParametrizedRoute(normalizedRoute), parameterizedRoute = _getParametrizedRoute.parameterizedRoute, groups = _getParametrizedRoute.groups;\n    return {\n        re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n        groups: groups\n    };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */ function buildGetSafeRouteKey() {\n    var i = 0;\n    return function() {\n        var routeKey = \"\";\n        var j = ++i;\n        while(j > 0){\n            routeKey += String.fromCharCode(97 + (j - 1) % 26);\n            j = Math.floor((j - 1) / 26);\n        }\n        return routeKey;\n    };\n}\nfunction getSafeKeyFromSegment(param) {\n    var interceptionMarker = param.interceptionMarker, getSafeRouteKey = param.getSafeRouteKey, segment = param.segment, routeKeys = param.routeKeys, keyPrefix = param.keyPrefix;\n    var _parseParameter = parseParameter(segment), key = _parseParameter.key, optional = _parseParameter.optional, repeat = _parseParameter.repeat;\n    // replace any non-word characters since they can break\n    // the named regex\n    var cleanedKey = key.replace(/\\W/g, \"\");\n    if (keyPrefix) {\n        cleanedKey = \"\" + keyPrefix + cleanedKey;\n    }\n    var invalidKey = false;\n    // check if the key is still invalid and fallback to using a known\n    // safe key\n    if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n        invalidKey = true;\n    }\n    if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n        invalidKey = true;\n    }\n    if (invalidKey) {\n        cleanedKey = getSafeRouteKey();\n    }\n    if (keyPrefix) {\n        routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n    } else {\n        routeKeys[cleanedKey] = key;\n    }\n    // if the segment has an interception marker, make sure that's part of the regex pattern\n    // this is to ensure that the route with the interception marker doesn't incorrectly match\n    // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])\n    var interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : \"\";\n    return repeat ? optional ? \"(?:/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?))?\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?)\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">[^/]+?)\";\n}\nfunction getNamedParametrizedRoute(route, prefixRouteKeys) {\n    var segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    var getSafeRouteKey = buildGetSafeRouteKey();\n    var routeKeys = {};\n    return {\n        namedParameterizedRoute: segments.map(function(segment) {\n            var hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some(function(m) {\n                return segment.startsWith(m);\n            });\n            var paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (hasInterceptionMarker && paramMatches) {\n                var _segment_split = _sliced_to_array._(segment.split(paramMatches[0]), 1), usedMarker = _segment_split[0];\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey: getSafeRouteKey,\n                    interceptionMarker: usedMarker,\n                    segment: paramMatches[1],\n                    routeKeys: routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n                });\n            } else if (paramMatches) {\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey: getSafeRouteKey,\n                    segment: paramMatches[1],\n                    routeKeys: routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined\n                });\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        routeKeys: routeKeys\n    };\n}\nfunction getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n    var result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n    return _object_spread_props._(_object_spread._({}, getRouteRegex(normalizedRoute)), {\n        namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n        routeKeys: result.routeKeys\n    });\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n    var parameterizedRoute = getParametrizedRoute(normalizedRoute).parameterizedRoute;\n    var _options_catchAll = options.catchAll, catchAll = _options_catchAll === void 0 ? true : _options_catchAll;\n    if (parameterizedRoute === \"/\") {\n        var catchAllRegex = catchAll ? \".*\" : \"\";\n        return {\n            namedRegex: \"^/\" + catchAllRegex + \"$\"\n        };\n    }\n    var namedParameterizedRoute = getNamedParametrizedRoute(normalizedRoute, false).namedParameterizedRoute;\n    var catchAllGroupedRegex = catchAll ? \"(?:(/.*)?)\" : \"\";\n    return {\n        namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n    };\n} //# sourceMappingURL=route-regex.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMk5nQkEseUJBQXVCLFNBQXZCQTtlQUFBQTs7SUFoQkFDLG9CQUFrQixTQUFsQkE7ZUFBQUE7O0lBbklBQyxlQUFhLFNBQWJBO2VBQUFBOzs7OENBeEUyQjt3Q0FDUjsrQ0FDQztBQUVwQyxJQUFNQywwQkFBMEI7QUFDaEMsSUFBTUMsa0NBQWtDO0FBYXhDOzs7Ozs7O0NBT0MsR0FDRCxTQUFTQyxlQUFlQyxLQUFhO0lBQ25DLElBQU1DLFdBQVdELE1BQU1FLFVBQVUsQ0FBQyxRQUFRRixNQUFNRyxRQUFRLENBQUM7SUFDekQsSUFBSUYsVUFBVTtRQUNaRCxRQUFRQSxNQUFNSSxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQzFCO0lBQ0EsSUFBTUMsU0FBU0wsTUFBTUUsVUFBVSxDQUFDO0lBQ2hDLElBQUlHLFFBQVE7UUFDVkwsUUFBUUEsTUFBTUksS0FBSyxDQUFDO0lBQ3RCO0lBQ0EsT0FBTztRQUFFRSxLQUFLTjtRQUFPSyxRQUFBQTtRQUFRSixVQUFBQTtJQUFTO0FBQ3hDO0FBRUEsU0FBU00scUJBQXFCQyxLQUFhO0lBQ3pDLElBQU1DLFdBQVdDLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBbUIsRUFBQ0YsT0FBT0osS0FBSyxDQUFDLEdBQUdPLEtBQUssQ0FBQztJQUMzRCxJQUFNQyxTQUF5QyxDQUFDO0lBQ2hELElBQUlDLGFBQWE7SUFDakIsT0FBTztRQUNMQyxvQkFBb0JMLFNBQ2pCTSxHQUFHLENBQUMsU0FBQ0M7WUFDSixJQUFNQyxjQUFjQyxvQkFBQUEsMEJBQTBCLENBQUNDLElBQUksQ0FB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Q0YsT0FBTztnQkFDTCxPQUFPLE1BQUkvQixDQUFBQSxHQUFBQSxjQUFBQSxrQkFBa0IsRUFBQ1I7WUFDaEM7UUFDRixHQUNDUyxJQUFJLENBQUM7UUFDUmUsV0FBQUE7SUFDRjtBQUNGO0FBVU8sU0FBUzdDLG1CQUNkK0IsZUFBdUIsRUFDdkI4QixjQUF1QjtJQUV2QixJQUFNQyxTQUFTUiwwQkFBMEJ2QixpQkFBaUI4QjtJQUMxRCxPQUFPLDRDQUNGNUQsY0FBYzhCO1FBQ2pCZ0MsWUFBWSxNQUFJRCxPQUFPTix1QkFBdUIsR0FBQztRQUMvQ1gsV0FBV2lCLE9BQU9qQixTQUFTOztBQUUvQjtBQU1PLFNBQVM5Qyx3QkFDZGdDLGVBQXVCLEVBQ3ZCaUMsT0FFQztJQUVELElBQU0scUJBQXlCcEQscUJBQXFCbUIsaUJBQTVDWjtJQUNSLHdCQUE0QjZDLFFBQXBCQyxVQUFBQSwwQ0FBVztJQUNuQixJQUFJOUMsdUJBQXVCLEtBQUs7UUFDOUIsSUFBSStDLGdCQUFnQkQsV0FBVyxPQUFPO1FBQ3RDLE9BQU87WUFDTEYsWUFBWSxPQUFLRyxnQkFBYztRQUNqQztJQUNGO0lBRUEsSUFBTSwwQkFBOEJaLDBCQUNsQ3ZCLGlCQUNBLE9BRk15QjtJQUlSLElBQUlXLHVCQUF1QkYsV0FBVyxlQUFlO0lBQ3JELE9BQU87UUFDTEYsWUFBWSxNQUFJUCwwQkFBMEJXLHVCQUFxQjtJQUNqRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXgudHM/MTZhMSJdLCJuYW1lcyI6WyJnZXROYW1lZE1pZGRsZXdhcmVSZWdleCIsImdldE5hbWVkUm91dGVSZWdleCIsImdldFJvdXRlUmVnZXgiLCJORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCIsIk5FWFRfSU5URVJDRVBUSU9OX01BUktFUl9QUkVGSVgiLCJwYXJzZVBhcmFtZXRlciIsInBhcmFtIiwib3B0aW9uYWwiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJzbGljZSIsInJlcGVhdCIsImtleSIsImdldFBhcmFtZXRyaXplZFJvdXRlIiwicm91dGUiLCJzZWdtZW50cyIsInJlbW92ZVRyYWlsaW5nU2xhc2giLCJzcGxpdCIsImdyb3VwcyIsImdyb3VwSW5kZXgiLCJwYXJhbWV0ZXJpemVkUm91dGUiLCJtYXAiLCJzZWdtZW50IiwibWFya2VyTWF0Y2giLCJJTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUyIsImZpbmQiLCJtIiwicGFyYW1NYXRjaGVzIiwibWF0Y2giLCJwb3MiLCJlc2NhcGVTdHJpbmdSZWdleHAiLCJqb2luIiwibm9ybWFsaXplZFJvdXRlIiwicmUiLCJSZWdFeHAiLCJidWlsZEdldFNhZmVSb3V0ZUtleSIsImkiLCJyb3V0ZUtleSIsImoiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJNYXRoIiwiZmxvb3IiLCJnZXRTYWZlS2V5RnJvbVNlZ21lbnQiLCJpbnRlcmNlcHRpb25NYXJrZXIiLCJnZXRTYWZlUm91dGVLZXkiLCJyb3V0ZUtleXMiLCJrZXlQcmVmaXgiLCJjbGVhbmVkS2V5IiwicmVwbGFjZSIsImludmFsaWRLZXkiLCJsZW5ndGgiLCJpc05hTiIsInBhcnNlSW50IiwiaW50ZXJjZXB0aW9uUHJlZml4IiwiZ2V0TmFtZWRQYXJhbWV0cml6ZWRSb3V0ZSIsInByZWZpeFJvdXRlS2V5cyIsIm5hbWVkUGFyYW1ldGVyaXplZFJvdXRlIiwiaGFzSW50ZXJjZXB0aW9uTWFya2VyIiwic29tZSIsInVzZWRNYXJrZXIiLCJ1bmRlZmluZWQiLCJwcmVmaXhSb3V0ZUtleSIsInJlc3VsdCIsIm5hbWVkUmVnZXgiLCJvcHRpb25zIiwiY2F0Y2hBbGwiLCJjYXRjaEFsbFJlZ2V4IiwiY2F0Y2hBbGxHcm91cGVkUmVnZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/route-regex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js":
/*!****************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js ***!
  \****************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_class_call_check.js\");\nvar _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_create_class.js\");\nvar _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_to_consumable_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getSortedRoutes\", ({\n    enumerable: true,\n    get: function get() {\n        return getSortedRoutes;\n    }\n}));\nvar UrlNode = /*#__PURE__*/ function() {\n    function UrlNode() {\n        _class_call_check._(this, UrlNode);\n        this.placeholder = true;\n        this.children = new Map();\n        this.slugName = null;\n        this.restSlugName = null;\n        this.optionalRestSlugName = null;\n    }\n    _create_class._(UrlNode, [\n        {\n            key: \"insert\",\n            value: function insert(urlPath) {\n                this._insert(urlPath.split(\"/\").filter(Boolean), [], false);\n            }\n        },\n        {\n            key: \"smoosh\",\n            value: function smoosh() {\n                return this._smoosh();\n            }\n        },\n        {\n            key: \"_smoosh\",\n            value: function _smoosh(prefix) {\n                var _this = this;\n                if (prefix === void 0) prefix = \"/\";\n                var childrenPaths = _to_consumable_array._(this.children.keys()).sort();\n                if (this.slugName !== null) {\n                    childrenPaths.splice(childrenPaths.indexOf(\"[]\"), 1);\n                }\n                if (this.restSlugName !== null) {\n                    childrenPaths.splice(childrenPaths.indexOf(\"[...]\"), 1);\n                }\n                if (this.optionalRestSlugName !== null) {\n                    childrenPaths.splice(childrenPaths.indexOf(\"[[...]]\"), 1);\n                }\n                var routes = childrenPaths.map(function(c) {\n                    return _this.children.get(c)._smoosh(\"\" + prefix + c + \"/\");\n                }).reduce(function(prev, curr) {\n                    return _to_consumable_array._(prev).concat(_to_consumable_array._(curr));\n                }, []);\n                if (this.slugName !== null) {\n                    var _routes;\n                    (_routes = routes).push.apply(_routes, _to_consumable_array._(this.children.get(\"[]\")._smoosh(prefix + \"[\" + this.slugName + \"]/\")));\n                }\n                if (!this.placeholder) {\n                    var r = prefix === \"/\" ? \"/\" : prefix.slice(0, -1);\n                    if (this.optionalRestSlugName != null) {\n                        throw new Error('You cannot define a route with the same specificity as a optional catch-all route (\"' + r + '\" and \"' + r + \"[[...\" + this.optionalRestSlugName + ']]\").');\n                    }\n                    routes.unshift(r);\n                }\n                if (this.restSlugName !== null) {\n                    var _routes1;\n                    (_routes1 = routes).push.apply(_routes1, _to_consumable_array._(this.children.get(\"[...]\")._smoosh(prefix + \"[...\" + this.restSlugName + \"]/\")));\n                }\n                if (this.optionalRestSlugName !== null) {\n                    var _routes2;\n                    (_routes2 = routes).push.apply(_routes2, _to_consumable_array._(this.children.get(\"[[...]]\")._smoosh(prefix + \"[[...\" + this.optionalRestSlugName + \"]]/\")));\n                }\n                return routes;\n            }\n        },\n        {\n            key: \"_insert\",\n            value: function _insert(urlPaths, slugNames, isCatchAll) {\n                if (urlPaths.length === 0) {\n                    this.placeholder = false;\n                    return;\n                }\n                if (isCatchAll) {\n                    throw new Error(\"Catch-all must be the last part of the URL.\");\n                }\n                // The next segment in the urlPaths list\n                var nextSegment = urlPaths[0];\n                // Check if the segment matches `[something]`\n                if (nextSegment.startsWith(\"[\") && nextSegment.endsWith(\"]\")) {\n                    var handleSlug = function handleSlug(previousSlug, nextSlug) {\n                        if (previousSlug !== null) {\n                            // If the specific segment already has a slug but the slug is not `something`\n                            // This prevents collisions like:\n                            // pages/[post]/index.js\n                            // pages/[id]/index.js\n                            // Because currently multiple dynamic params on the same segment level are not supported\n                            if (previousSlug !== nextSlug) {\n                                // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n                                throw new Error(\"You cannot use different slug names for the same dynamic path ('\" + previousSlug + \"' !== '\" + nextSlug + \"').\");\n                            }\n                        }\n                        slugNames.forEach(function(slug) {\n                            if (slug === nextSlug) {\n                                throw new Error('You cannot have the same slug name \"' + nextSlug + '\" repeat within a single dynamic path');\n                            }\n                            if (slug.replace(/\\W/g, \"\") === nextSegment.replace(/\\W/g, \"\")) {\n                                throw new Error('You cannot have the slug names \"' + slug + '\" and \"' + nextSlug + '\" differ only by non-word symbols within a single dynamic path');\n                            }\n                        });\n                        slugNames.push(nextSlug);\n                    };\n                    // Strip `[` and `]`, leaving only `something`\n                    var segmentName = nextSegment.slice(1, -1);\n                    var isOptional = false;\n                    if (segmentName.startsWith(\"[\") && segmentName.endsWith(\"]\")) {\n                        // Strip optional `[` and `]`, leaving only `something`\n                        segmentName = segmentName.slice(1, -1);\n                        isOptional = true;\n                    }\n                    if (segmentName.startsWith(\"...\")) {\n                        // Strip `...`, leaving only `something`\n                        segmentName = segmentName.substring(3);\n                        isCatchAll = true;\n                    }\n                    if (segmentName.startsWith(\"[\") || segmentName.endsWith(\"]\")) {\n                        throw new Error(\"Segment names may not start or end with extra brackets ('\" + segmentName + \"').\");\n                    }\n                    if (segmentName.startsWith(\".\")) {\n                        throw new Error(\"Segment names may not start with erroneous periods ('\" + segmentName + \"').\");\n                    }\n                    if (isCatchAll) {\n                        if (isOptional) {\n                            if (this.restSlugName != null) {\n                                throw new Error('You cannot use both an required and optional catch-all route at the same level (\"[...' + this.restSlugName + ']\" and \"' + urlPaths[0] + '\" ).');\n                            }\n                            handleSlug(this.optionalRestSlugName, segmentName);\n                            // slugName is kept as it can only be one particular slugName\n                            this.optionalRestSlugName = segmentName;\n                            // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n                            nextSegment = \"[[...]]\";\n                        } else {\n                            if (this.optionalRestSlugName != null) {\n                                throw new Error('You cannot use both an optional and required catch-all route at the same level (\"[[...' + this.optionalRestSlugName + ']]\" and \"' + urlPaths[0] + '\").');\n                            }\n                            handleSlug(this.restSlugName, segmentName);\n                            // slugName is kept as it can only be one particular slugName\n                            this.restSlugName = segmentName;\n                            // nextSegment is overwritten to [...] so that it can later be sorted specifically\n                            nextSegment = \"[...]\";\n                        }\n                    } else {\n                        if (isOptional) {\n                            throw new Error('Optional route parameters are not yet supported (\"' + urlPaths[0] + '\").');\n                        }\n                        handleSlug(this.slugName, segmentName);\n                        // slugName is kept as it can only be one particular slugName\n                        this.slugName = segmentName;\n                        // nextSegment is overwritten to [] so that it can later be sorted specifically\n                        nextSegment = \"[]\";\n                    }\n                }\n                // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n                if (!this.children.has(nextSegment)) {\n                    this.children.set(nextSegment, new UrlNode());\n                }\n                this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n            }\n        }\n    ]);\n    return UrlNode;\n}();\nfunction getSortedRoutes(normalizedPages) {\n    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n    // Only 1 dynamic segment per nesting level\n    // So in the case that is test/integration/dynamic-routing it'll be this:\n    // pages/[post]/comments.js\n    // pages/blog/[post]/comment/[id].js\n    // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n    // So in this case `UrlNode` created here has `this.slugName === 'post'`\n    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n    // Instead what has to be passed through is the upwards path's dynamic names\n    var root = new UrlNode();\n    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n    normalizedPages.forEach(function(pagePath) {\n        return root.insert(pagePath);\n    });\n    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n    return root.smoosh();\n} //# sourceMappingURL=sorted-routes.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvc29ydGVkLXJvdXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O21EQXFNZ0JBOzs7ZUFBQUE7OztBQXJNaEI7YUFBTUM7a0NBQUFBO2FBQ0pDLFdBQUFBLEdBQXVCO2FBQ3ZCQyxRQUFBQSxHQUFpQyxJQUFJQzthQUNyQ0MsUUFBQUEsR0FBMEI7YUFDMUJDLFlBQUFBLEdBQThCO2FBQzlCQyxvQkFBQUEsR0FBc0M7O29CQUxsQ047O1lBT0pPLEtBQUFBO21CQUFBQSxTQUFBQSxPQUFPQyxPQUFlO2dCQUNwQixJQUFJLENBQUNDLE9BQU8sQ0FBQ0QsUUFBUUUsS0FBSyxDQUFDLEtBQUtDLE1BQU0sQ0FBQ0MsVUFBVSxFQUFFLEVBQUU7WUFDdkQ7OztZQUVBQyxLQUFBQTttQkFBQUEsU0FBQUE7Z0JBQ0UsT0FBTyxJQUFJLENBQUNDLE9BQU87WUFDckI7OztZQUVRQSxLQUFBQTttQkFBQUEsU0FBQUEsUUFBUUMsTUFBb0I7O2dCQUFwQkEsSUFBQUEsV0FBQUEsS0FBQUEsR0FBQUEsU0FBaUI7Z0JBQy9CLElBQU1DLGdCQUFnQix1QkFBSSxJQUFJLENBQUNkLFFBQVEsQ0FBQ2UsSUFBSSxJQUFJQyxJQUFJO2dCQUNwRCxJQUFJLElBQUksQ0FBQ2QsUUFBUSxLQUFLLE1BQU07b0JBQzFCWSxjQUFjRyxNQUFNLENBQUNILGNBQWNJLE9BQU8sQ0FBQyxPQUFPO2dCQUNwRDtnQkFDQSxJQUFJLElBQUksQ0FBQ2YsWUFBWSxLQUFLLE1BQU07b0JBQzlCVyxjQUFjRyxNQUFNLENBQUNILGNBQWNJLE9BQU8sQ0FBQyxVQUFVO2dCQUN2RDtnQkFDQSxJQUFJLElBQUksQ0FBQ2Qsb0JBQW9CLEtB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S3ZDLE1BQU07QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9zb3J0ZWQtcm91dGVzLnRzP2Q1M2IiXSwibmFtZXMiOlsiZ2V0U29ydGVkUm91dGVzIiwiVXJsTm9kZSIsInBsYWNlaG9sZGVyIiwiY2hpbGRyZW4iLCJNYXAiLCJzbHVnTmFtZSIsInJlc3RTbHVnTmFtZSIsIm9wdGlvbmFsUmVzdFNsdWdOYW1lIiwiaW5zZXJ0IiwidXJsUGF0aCIsIl9pbnNlcnQiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJzbW9vc2giLCJfc21vb3NoIiwicHJlZml4IiwiY2hpbGRyZW5QYXRocyIsImtleXMiLCJzb3J0Iiwic3BsaWNlIiwiaW5kZXhPZiIsInJvdXRlcyIsIm1hcCIsImMiLCJnZXQiLCJyZWR1Y2UiLCJwcmV2IiwiY3VyciIsInB1c2giLCJyIiwic2xpY2UiLCJFcnJvciIsInVuc2hpZnQiLCJ1cmxQYXRocyIsInNsdWdOYW1lcyIsImlzQ2F0Y2hBbGwiLCJsZW5ndGgiLCJuZXh0U2VnbWVudCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsImhhbmRsZVNsdWciLCJwcmV2aW91c1NsdWciLCJuZXh0U2x1ZyIsImZvckVhY2giLCJzbHVnIiwicmVwbGFjZSIsInNlZ21lbnROYW1lIiwiaXNPcHRpb25hbCIsInN1YnN0cmluZyIsImhhcyIsInNldCIsIm5vcm1hbGl6ZWRQYWdlcyIsInJvb3QiLCJwYWdlUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/side-effect.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/side-effect.js ***!
  \*************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function get() {\n        return SideEffect;\n    }\n}));\nvar _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\nvar isServer = typeof window === \"undefined\";\nvar useClientOnlyLayoutEffect = isServer ? function() {} : _react.useLayoutEffect;\nvar useClientOnlyEffect = isServer ? function() {} : _react.useEffect;\nfunction SideEffect(props) {\n    _s();\n    var headManager = props.headManager, reduceComponentsToState = props.reduceComponentsToState;\n    function emitChange() {\n        if (headManager && headManager.mountedInstances) {\n            var headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n            headManager.updateHead(reduceComponentsToState(headElements, props));\n        }\n    }\n    if (isServer) {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        emitChange();\n    }\n    useClientOnlyLayoutEffect(function() {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        return function() {\n            var _headManager_mountedInstances;\n            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances[\"delete\"](props.children);\n        };\n    });\n    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n    // being rendered, we only trigger the method from the last one.\n    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n    // singleton in the layout effect pass, and actually trigger it in the effect pass.\n    useClientOnlyLayoutEffect(function() {\n        if (headManager) {\n            headManager._pendingUpdate = emitChange;\n        }\n        return function() {\n            if (headManager) {\n                headManager._pendingUpdate = emitChange;\n            }\n        };\n    });\n    useClientOnlyEffect(function() {\n        if (headManager && headManager._pendingUpdate) {\n            headManager._pendingUpdate();\n            headManager._pendingUpdate = null;\n        }\n        return function() {\n            if (headManager && headManager._pendingUpdate) {\n                headManager._pendingUpdate();\n                headManager._pendingUpdate = null;\n            }\n        };\n    });\n    return null;\n} //# sourceMappingURL=side-effect.js.map\n_s(SideEffect, \"gHVkikNHNxjVdD11eJBzaqkCiPY=\", false, function() {\n    return [\n        useClientOnlyLayoutEffect,\n        useClientOnlyLayoutEffect,\n        useClientOnlyEffect\n    ];\n});\n_c = SideEffect;\nvar _c;\n$RefreshReg$(_c, \"SideEffect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9zaWRlLWVmZmVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7MkNBb0JBOzs7ZUFBd0JBOzs7aUNBbkI2QjtBQWVyRCxJQUFNQyxXQUFXLE9BQU9DLFdBQVc7QUFDbkMsSUFBTUMsNEJBQTRCRixXQUFXLFlBQU8sSUFBSUcsT0FBQUEsZUFBZTtBQUN2RSxJQUFNQyxzQkFBc0JKLFdBQVcsWUFBTyxJQUFJSyxPQUFBQSxTQUFTO0FBRTVDLFNBQVNOLFdBQVdPLEtBQXNCOztJQUN2RCxJQUFRQyxjQUF5Q0QsTUFBekNDLGFBQWFDLDBCQUE0QkYsTUFBNUJFO0lBRXJCLFNBQVNDO1FBQ1AsSUFBSUYsZUFBZUEsWUFBWUcsZ0JBQWdCLEVBQUU7WUFDL0MsSUFBTUMsZUFBZUMsT0FBQUEsUUFBUSxDQUFDQyxPQUFPLENBQ25DQyxNQUFNQyxJQUFJLENBQUNSLFlBQVlHLGdCQUFnQixFQUEwQk0sTUFBTSxDQUNyRUM7WUFHSlYsWUFBWVcsVUFBVSxDQUFDVix3QkFBd0JHLGNBQWNMO1FBQy9EO0lBQ0Y7SUFFQSxJQUFJTixVQUFVO1lBQ1pPO1FBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBZ0IscUJBQTdCSCw4QkFBK0JZLEdBQUcsQ0FBQ2IsTUFBTWMsUUFBUTtRQUNqRFg7SUFDRjtJQUVBUCwwQkFBMEI7WUFDeEJLO1FBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBZ0IscUJBQTdCSCw4QkFBK0JZLEdBQUcsQ0FBQ2IsTUFBTWMsUUFBUTtRQUNqRCxPQUFPO2dCQUNMYjtZQUFBQSxlQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSxnQ0FBQUEsWUFBYUcsZ0JBQWdCLHFCQUE3QkgsNkJBQStCYyxDQUFBQSxTQUFNLENBQUNmLE1BQU1jLFFBQVE7UUFDdEQ7SUFDRjtJQUVBLGtGQUFrRjtJQUNsRixvRkFBb0Y7SUFDcEYsZ0VBQWdFO0lBQ2hFLHFGQUFxRjtJQUNyRixtRkFBbUY7SUFDbkZsQiwwQkFBMEI7UUFDeEIsSUFBSUssYUFBYTtZQUNmQSxZQUFZZSxjQUFjLEdBQUdiO1FBQy9CO1FBQ0EsT0FBTztZQUNMLElBQUlGLGFBQWE7Z0JBQ2ZBLFlBQVllLGNBQWMsR0FBR2I7WUFDL0I7UUFDRjtJQUNGO0lBRUFMLG9CQUFvQjtRQUNsQixJQUFJRyxlQUFlQSxZQUFZZSxjQUFjLEVBQUU7WUFDN0NmLFlBQVllLGNBQWM7WUFDMUJmLFlBQVllLGNBQWMsR0FBRztRQUMvQjtRQUNBLE9BQU87WUFDTCxJQUFJZixlQUFlQSxZQUFZZSxjQUFjLEVBQUU7Z0JBQzdDZixZQUFZZSxjQUFjO2dCQUMxQmYsWUFBWWUsY0FBYyxHQUFHO1lBQy9CO1FBQ0Y7SUFDRjtJQUVBLE9BQU87QUFDVDtHQXhEd0J2Qjs7UUFtQnRCRztRQVlBQTtRQVdBRTs7O0tBMUNzQkwiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3NpZGUtZWZmZWN0LnRzeD9lOGRkIl0sIm5hbWVzIjpbIlNpZGVFZmZlY3QiLCJpc1NlcnZlciIsIndpbmRvdyIsInVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VDbGllbnRPbmx5RWZmZWN0IiwidXNlRWZmZWN0IiwicHJvcHMiLCJoZWFkTWFuYWdlciIsInJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIiwiZW1pdENoYW5nZSIsIm1vdW50ZWRJbnN0YW5jZXMiLCJoZWFkRWxlbWVudHMiLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJBcnJheSIsImZyb20iLCJmaWx0ZXIiLCJCb29sZWFuIiwidXBkYXRlSGVhZCIsImFkZCIsImNoaWxkcmVuIiwiZGVsZXRlIiwiX3BlbmRpbmdVcGRhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/side-effect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils.js":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils.js ***!
  \*******************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _async_to_generator = __webpack_require__(/*! @swc/helpers/_/_async_to_generator */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_async_to_generator.js\");\nvar _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_class_call_check.js\");\nvar _inherits = __webpack_require__(/*! @swc/helpers/_/_inherits */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_inherits.js\");\nvar _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_to_consumable_array.js\");\nvar _wrap_native_super = __webpack_require__(/*! @swc/helpers/_/_wrap_native_super */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_wrap_native_super.js\");\nvar _create_super = __webpack_require__(/*! @swc/helpers/_/_create_super */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_create_super.js\");\nvar _ts_generator = __webpack_require__(/*! @swc/helpers/_/_ts_generator */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_ts_generator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DecodeError: function DecodeError1() {\n        return DecodeError;\n    },\n    MiddlewareNotFoundError: function MiddlewareNotFoundError1() {\n        return MiddlewareNotFoundError;\n    },\n    MissingStaticPage: function MissingStaticPage1() {\n        return MissingStaticPage;\n    },\n    NormalizeError: function NormalizeError1() {\n        return NormalizeError;\n    },\n    PageNotFoundError: function PageNotFoundError1() {\n        return PageNotFoundError;\n    },\n    SP: function SP1() {\n        return SP;\n    },\n    ST: function ST1() {\n        return ST;\n    },\n    WEB_VITALS: function WEB_VITALS1() {\n        return WEB_VITALS;\n    },\n    execOnce: function execOnce1() {\n        return execOnce;\n    },\n    getDisplayName: function getDisplayName1() {\n        return getDisplayName;\n    },\n    getLocationOrigin: function getLocationOrigin1() {\n        return getLocationOrigin;\n    },\n    getURL: function getURL1() {\n        return getURL;\n    },\n    isAbsoluteUrl: function isAbsoluteUrl1() {\n        return isAbsoluteUrl;\n    },\n    isResSent: function isResSent1() {\n        return isResSent;\n    },\n    loadGetInitialProps: function loadGetInitialProps1() {\n        return loadGetInitialProps;\n    },\n    normalizeRepeatedSlashes: function normalizeRepeatedSlashes1() {\n        return normalizeRepeatedSlashes;\n    },\n    stringifyError: function stringifyError1() {\n        return stringifyError;\n    }\n});\nvar WEB_VITALS = [\n    \"CLS\",\n    \"FCP\",\n    \"FID\",\n    \"INP\",\n    \"LCP\",\n    \"TTFB\"\n];\nfunction execOnce(fn) {\n    var used = false;\n    var result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn.apply(void 0, _to_consumable_array._(args));\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nvar ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nvar isAbsoluteUrl = function(url) {\n    return ABSOLUTE_URL_REGEX.test(url);\n};\nfunction getLocationOrigin() {\n    var _window_location = window.location, protocol = _window_location.protocol, hostname = _window_location.hostname, port = _window_location.port;\n    return protocol + \"//\" + hostname + (port ? \":\" + port : \"\");\n}\nfunction getURL() {\n    var href = window.location.href;\n    var origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === \"string\" ? Component : Component.displayName || Component.name || \"Unknown\";\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    var urlParts = url.split(\"?\");\n    var urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, \"/\").replace(/\\/\\/+/g, \"/\") + (urlParts[1] ? \"?\" + urlParts.slice(1).join(\"?\") : \"\");\n}\nfunction loadGetInitialProps(App, ctx) {\n    return _loadGetInitialProps.apply(this, arguments);\n}\nfunction _loadGetInitialProps() {\n    _loadGetInitialProps = _async_to_generator._(function(App, ctx) {\n        var _App_prototype, message, res, _tmp, props, message1;\n        return _ts_generator._(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    if (true) {\n                        ;\n                        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {\n                            message = '\"' + getDisplayName(App) + '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';\n                            throw new Error(message);\n                        }\n                    }\n                    // when called from _app `ctx` is nested in `ctx`\n                    res = ctx.res || ctx.ctx && ctx.ctx.res;\n                    if (!!App.getInitialProps) return [\n                        3,\n                        3\n                    ];\n                    if (!(ctx.ctx && ctx.Component)) return [\n                        3,\n                        2\n                    ];\n                    _tmp = {};\n                    return [\n                        4,\n                        loadGetInitialProps(ctx.Component, ctx.ctx)\n                    ];\n                case 1:\n                    // @ts-ignore pageProps default\n                    return [\n                        2,\n                        (_tmp.pageProps = _state.sent(), _tmp)\n                    ];\n                case 2:\n                    return [\n                        2,\n                        {}\n                    ];\n                case 3:\n                    return [\n                        4,\n                        App.getInitialProps(ctx)\n                    ];\n                case 4:\n                    props = _state.sent();\n                    if (res && isResSent(res)) {\n                        return [\n                            2,\n                            props\n                        ];\n                    }\n                    if (!props) {\n                        message1 = '\"' + getDisplayName(App) + '.getInitialProps()\" should resolve to an object. But found \"' + props + '\" instead.';\n                        throw new Error(message1);\n                    }\n                    if (true) {\n                        if (Object.keys(props).length === 0 && !ctx.ctx) {\n                            console.warn(\"\" + getDisplayName(App) + \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\");\n                        }\n                    }\n                    return [\n                        2,\n                        props\n                    ];\n            }\n        });\n    });\n    return _loadGetInitialProps.apply(this, arguments);\n}\nvar SP = typeof performance !== \"undefined\";\nvar ST = SP && [\n    \"mark\",\n    \"measure\",\n    \"getEntriesByName\"\n].every(function(method) {\n    return typeof performance[method] === \"function\";\n});\nvar DecodeError = /*#__PURE__*/ function(Error1) {\n    _inherits._(DecodeError, Error1);\n    var _super = _create_super._(DecodeError);\n    function DecodeError() {\n        _class_call_check._(this, DecodeError);\n        return _super.apply(this, arguments);\n    }\n    return DecodeError;\n}(_wrap_native_super._(Error));\nvar NormalizeError = /*#__PURE__*/ function(Error1) {\n    _inherits._(NormalizeError, Error1);\n    var _super = _create_super._(NormalizeError);\n    function NormalizeError() {\n        _class_call_check._(this, NormalizeError);\n        return _super.apply(this, arguments);\n    }\n    return NormalizeError;\n}(_wrap_native_super._(Error));\nvar PageNotFoundError = /*#__PURE__*/ function(Error1) {\n    _inherits._(PageNotFoundError, Error1);\n    var _super = _create_super._(PageNotFoundError);\n    function PageNotFoundError(page) {\n        _class_call_check._(this, PageNotFoundError);\n        var _this;\n        _this = _super.call(this);\n        _this.code = \"ENOENT\";\n        _this.name = \"PageNotFoundError\";\n        _this.message = \"Cannot find module for page: \" + page;\n        return _this;\n    }\n    return PageNotFoundError;\n}(_wrap_native_super._(Error));\nvar MissingStaticPage = /*#__PURE__*/ function(Error1) {\n    _inherits._(MissingStaticPage, Error1);\n    var _super = _create_super._(MissingStaticPage);\n    function MissingStaticPage(page, message) {\n        _class_call_check._(this, MissingStaticPage);\n        var _this;\n        _this = _super.call(this);\n        _this.message = \"Failed to load static file for page: \" + page + \" \" + message;\n        return _this;\n    }\n    return MissingStaticPage;\n}(_wrap_native_super._(Error));\nvar MiddlewareNotFoundError = /*#__PURE__*/ function(Error1) {\n    _inherits._(MiddlewareNotFoundError, Error1);\n    var _super = _create_super._(MiddlewareNotFoundError);\n    function MiddlewareNotFoundError() {\n        _class_call_check._(this, MiddlewareNotFoundError);\n        var _this;\n        _this = _super.call(this);\n        _this.code = \"ENOENT\";\n        _this.message = \"Cannot find the middleware module\";\n        return _this;\n    }\n    return MiddlewareNotFoundError;\n}(_wrap_native_super._(Error));\nfunction stringifyError(error) {\n    return JSON.stringify({\n        message: error.message,\n        stack: error.stack\n    });\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBb2FhQSxhQUFXLFNBQVhBO2VBQUFBOztJQW9CQUMseUJBQXVCLFNBQXZCQTtlQUFBQTs7SUFQQUMsbUJBQWlCLFNBQWpCQTtlQUFBQTs7SUFaQUMsZ0JBQWMsU0FBZEE7ZUFBQUE7O0lBQ0FDLG1CQUFpQixTQUFqQkE7ZUFBQUE7O0lBVEFDLElBQUUsU0FBRkE7ZUFBQUE7O0lBQ0FDLElBQUUsU0FBRkE7ZUFBQUE7O0lBbFhBQyxZQUFVLFNBQVZBO2VBQUFBOztJQXNRR0MsVUFBUSxTQUFSQTtlQUFBQTs7SUErQkFDLGdCQUFjLFNBQWRBO2VBQUFBOztJQVhBQyxtQkFBaUIsU0FBakJBO2VBQUFBOztJQUtBQyxRQUFNLFNBQU5BO2VBQUFBOztJQVBIQyxlQUFhLFNBQWJBO2VBQUFBOztJQW1CR0MsV0FBUyxTQUFUQTtlQUFBQTs7SUFrQk1DLHFCQUFtQixTQUFuQkE7ZUFBQUE7O0lBZE5DLDBCQUF3QixTQUF4QkE7ZUFBQUE7O0lBK0dBQyxnQkFBYyxTQUFkQTtlQUFBQTs7O0FBOVpULElBQU1ULGFBQWE7SUFBQztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87Q0FBTztBQXNROUQsU0FBU0MsU0FDZFMsRUFBSztJQUVMLElBQUlDLE9BQU87SUFDWCxJQUFJQztJQUVKLE9BQVE7eUNBQUlDLE9BQUFBLElBQUFBLE1BQUFBLE9BQUFBLE9BQUFBLEdBQUFBLE9BQUFBLE1BQUFBLE9BQUFBO1lBQUFBLElBQUFBLENBQUFBLEtBQUFBLEdBQUFBLFNBQUFBLENBQUFBLEtBQUFBOztRQUNWLElBQUksQ0FBQ0YsTUFBTTtZQUNUQSxPQUFP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SUFBTVQsS0FBSyxPQUFPcUQsZ0JBQWdCO0FBQ2xDLElBQU1wRCxLQUNYRCxNQUNBO0lBQUU7SUFBUTtJQUFXO0NBQW1CLENBQVdzRCxLQUFLLENBQ3RELFNBQUNDO1dBQVcsT0FBT0YsV0FBVyxDQUFDRSxPQUFPLEtBQUs7O0FBR3hDO2dCQUFNNUQ7aUNBQUFBO2FBQUFBO2tDQUFBQTs7O1dBQUFBO3VCQUFvQm9EO0FBQzFCO2dCQUFNakQ7aUNBQUFBO2FBQUFBO2tDQUFBQTs7O1dBQUFBO3VCQUF1QmlEO0FBQzdCO2dCQUFNaEQ7aUNBQUFBO2FBQUFBLGtCQUdDeUQsSUFBWTtrQ0FIYnpEOzs7UUFLVCxNQUFLMEQsSUFBSSxHQUFHO1FBQ1osTUFBSzNCLElBQUksR0FBRztRQUNaLE1BQUtZLE9BQU8sR0FBRyxrQ0FBZ0NjOzs7V0FQdEN6RDt1QkFBMEJnRDtBQVdoQztnQkFBTWxEO2lDQUFBQTthQUFBQSxrQkFDQzJELElBQVksRUFBRWQsT0FBZTtrQ0FEOUI3Qzs7O1FBR1QsTUFBSzZDLE9BQU8sR0FBRywwQ0FBd0NjLE9BQUssTUFBR2Q7OztXQUh0RDdDO3VCQUEwQmtEO0FBT2hDO2dCQUFNbkQ7aUNBQUFBO2FBQUFBO2tDQUFBQTs7O1FBSVQsTUFBSzZELElBQUksR0FBRztRQUNaLE1BQUtmLE9BQU8sR0FBSTs7O1dBTFA5Qzt1QkFBZ0NtRDtBQWtCdEMsU0FBU3BDLGVBQWUrQyxLQUFZO0lBQ3pDLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQztRQUFFbEIsU0FBU2dCLE1BQU1oQixPQUFPO1FBQUVtQixPQUFPSCxNQUFNRyxLQUFLO0lBQUM7QUFDckUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3V0aWxzLnRzPzFiZDUiXSwibmFtZXMiOlsiRGVjb2RlRXJyb3IiLCJNaWRkbGV3YXJlTm90Rm91bmRFcnJvciIsIk1pc3NpbmdTdGF0aWNQYWdlIiwiTm9ybWFsaXplRXJyb3IiLCJQYWdlTm90Rm91bmRFcnJvciIsIlNQIiwiU1QiLCJXRUJfVklUQUxTIiwiZXhlY09uY2UiLCJnZXREaXNwbGF5TmFtZSIsImdldExvY2F0aW9uT3JpZ2luIiwiZ2V0VVJMIiwiaXNBYnNvbHV0ZVVybCIsImlzUmVzU2VudCIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMiLCJzdHJpbmdpZnlFcnJvciIsImZuIiwidXNlZCIsInJlc3VsdCIsImFyZ3MiLCJBQlNPTFVURV9VUkxfUkVHRVgiLCJ1cmwiLCJ0ZXN0Iiwid2luZG93IiwibG9jYXRpb24iLCJwcm90b2NvbCIsImhvc3RuYW1lIiwicG9ydCIsImhyZWYiLCJvcmlnaW4iLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJDb21wb25lbnQiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJyZXMiLCJmaW5pc2hlZCIsImhlYWRlcnNTZW50IiwidXJsUGFydHMiLCJzcGxpdCIsInVybE5vUXVlcnkiLCJyZXBsYWNlIiwic2xpY2UiLCJqb2luIiwiQXBwIiwiY3R4IiwibWVzc2FnZSIsInByb3BzIiwicHJvY2VzcyIsInByb3RvdHlwZSIsImdldEluaXRpYWxQcm9wcyIsIkVycm9yIiwicGFnZVByb3BzIiwiT2JqZWN0Iiwia2V5cyIsImNvbnNvbGUiLCJ3YXJuIiwicGVyZm9ybWFuY2UiLCJldmVyeSIsIm1ldGhvZCIsInBhZ2UiLCJjb2RlIiwiZXJyb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/callback/Callback.tsx":
/*!**********************************************!*\
  !*** ./src/components/callback/Callback.tsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Callback: function() { return /* binding */ Callback; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var _ui_button_Button__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ui/button/Button */ \"(app-pages-browser)/./src/components/ui/button/Button.tsx\");\n/* harmony import */ var _ui_input_Input__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ui/input/Input */ \"(app-pages-browser)/./src/components/ui/input/Input.tsx\");\n/* harmony import */ var _ui_switcher_Switcher__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ui/switcher/Switcher */ \"(app-pages-browser)/./src/components/ui/switcher/Switcher.tsx\");\n/* harmony import */ var _ui_uploadFile_UploadFile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ui/uploadFile/UploadFile */ \"(app-pages-browser)/./src/components/ui/uploadFile/UploadFile.tsx\");\n/* harmony import */ var _Callback_module_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Callback.module.scss */ \"(app-pages-browser)/./src/components/callback/Callback.module.scss\");\n/* harmony import */ var _Callback_module_scss__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_Callback_module_scss__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\n\nfunction Callback(param) {\n    var _this = this;\n    var switchers = param.switchers, inputs = param.inputs, title = param.title, text = param.text;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n        action: \"\",\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])((_Callback_module_scss__WEBPACK_IMPORTED_MODULE_6___default().form)),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"site-title-3\", (_Callback_module_scss__WEBPACK_IMPORTED_MODULE_6___default().form__title)),\n                children: title\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\callback\\\\Callback.tsx\",\n                lineNumber: 17,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                className: (_Callback_module_scss__WEBPACK_IMPORTED_MODULE_6___default().form__text),\n                children: text\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\callback\\\\Callback.tsx\",\n                lineNumber: 18,\n                columnNumber: 4\n            }, this),\n            (inputs === null || inputs === void 0 ? void 0 : inputs.length) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_Callback_module_scss__WEBPACK_IMPORTED_MODULE_6___default().form__inputs),\n                children: inputs.map(function(input) {\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_input_Input__WEBPACK_IMPORTED_MODULE_3__.Input, {\n                        type: input.type,\n                        name: input.name,\n                        placeholder: input.placeholder,\n                        id: input.id,\n                        className: (_Callback_module_scss__WEBPACK_IMPORTED_MODULE_6___default().form__input)\n                    }, input.name, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\callback\\\\Callback.tsx\",\n                        lineNumber: 22,\n                        columnNumber: 7\n                    }, _this);\n                })\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\callback\\\\Callback.tsx\",\n                lineNumber: 20,\n                columnNumber: 5\n            }, this),\n            (switchers === null || switchers === void 0 ? void 0 : switchers.length) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_Callback_module_scss__WEBPACK_IMPORTED_MODULE_6___default().form__theme),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: (_Callback_module_scss__WEBPACK_IMPORTED_MODULE_6___default().form__label),\n                        children: \"Тип проекта\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\callback\\\\Callback.tsx\",\n                        lineNumber: 36,\n                        columnNumber: 6\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_Callback_module_scss__WEBPACK_IMPORTED_MODULE_6___default().form__themeTypes),\n                        children: switchers.map(function(switcher) {\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_switcher_Switcher__WEBPACK_IMPORTED_MODULE_4__.Switcher, (0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_7__._)({}, switcher), switcher.id, false, {\n                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\callback\\\\Callback.tsx\",\n                                lineNumber: 39,\n                                columnNumber: 8\n                            }, _this);\n                        })\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\callback\\\\Callback.tsx\",\n                        lineNumber: 37,\n                        columnNumber: 6\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\callback\\\\Callback.tsx\",\n                lineNumber: 35,\n                columnNumber: 5\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_Callback_module_scss__WEBPACK_IMPORTED_MODULE_6___default().form__textarea),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: (_Callback_module_scss__WEBPACK_IMPORTED_MODULE_6___default().form__label),\n                        children: \"Кратко о проекте\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\callback\\\\Callback.tsx\",\n                        lineNumber: 49,\n                        columnNumber: 5\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"textarea\", {\n                        name: \"message\",\n                        id: \"message\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\callback\\\\Callback.tsx\",\n                        lineNumber: 50,\n                        columnNumber: 5\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\callback\\\\Callback.tsx\",\n                lineNumber: 48,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_uploadFile_UploadFile__WEBPACK_IMPORTED_MODULE_5__.UploadFile, {}, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\callback\\\\Callback.tsx\",\n                lineNumber: 55,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_Callback_module_scss__WEBPACK_IMPORTED_MODULE_6___default().form__actions),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: (_Callback_module_scss__WEBPACK_IMPORTED_MODULE_6___default().form__privacy),\n                        children: [\n                            \"Отправляя форму, я соглашаюсь c\\xa0\",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                children: \"правилами обработки данных\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\callback\\\\Callback.tsx\",\n                                lineNumber: 59,\n                                columnNumber: 6\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\callback\\\\Callback.tsx\",\n                        lineNumber: 57,\n                        columnNumber: 5\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_button_Button__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                        className: (_Callback_module_scss__WEBPACK_IMPORTED_MODULE_6___default().form__submit),\n                        children: \"Отправить заявку\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\callback\\\\Callback.tsx\",\n                        lineNumber: 61,\n                        columnNumber: 5\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\callback\\\\Callback.tsx\",\n                lineNumber: 56,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\callback\\\\Callback.tsx\",\n        lineNumber: 13,\n        columnNumber: 3\n    }, this);\n}\n_c = Callback;\nvar _c;\n$RefreshReg$(_c, \"Callback\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2NhbGxiYWNrL0NhbGxiYWNrLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBcUI7QUFFdUI7QUFDSDtBQUNTO0FBQ007QUFFWjtBQUdyQyxTQUFTTSxTQUFTLEtBQTZDOztRQUEzQ0MsWUFBRixNQUFFQSxXQUFXQyxTQUFiLE1BQWFBLFFBQVFDLFFBQXJCLE1BQXFCQSxPQUFPQyxPQUE1QixNQUE0QkE7SUFDcEQscUJBQ0MsOERBQUNDO1FBQ0FDLFFBQU87UUFDUEMsV0FBV2IsZ0RBQUVBLENBQUNLLG1FQUFZOzswQkFFMUIsOERBQUNTO2dCQUFHRCxXQUFXYixnREFBRUEsQ0FBQyxnQkFBZ0JLLDBFQUFtQjswQkFBSUk7Ozs7OzswQkFDekQsOERBQUNPO2dCQUFFSCxXQUFXUix5RUFBa0I7MEJBQUdLOzs7Ozs7WUFDbENGLENBQUFBLG1CQUFBQSw2QkFBQUEsT0FBUVUsTUFBTSxtQkFDZCw4REFBQ0M7Z0JBQUlOLFdBQVdSLDJFQUFvQjswQkFDbENHLE9BQU9hLEdBQUcsQ0FBQ0MsU0FBQUE7eUNBQ1gsOERBQUNwQixrREFBS0E7d0JBRUxxQixNQUFNRCxNQUFNQyxJQUFJO3dCQUNoQkMsTUFBTUYsTUFBTUUsSUFBSTt3QkFDaEJDLGFBQWFILE1BQU1HLFdBQVc7d0JBQzlCQyxJQUFJSixNQUFNSSxFQUFFO3dCQUNaYixXQUFXUiwwRUFBbUI7dUJBTHpCaUIsTUFBTUUsSUFBSTs7Ozs7Ozs7Ozs7WUFXbEJqQixDQUFBQSxzQkFBQUEsZ0NBQUFBLFVBQVdXLE1BQU0sbUJBQ2pCLDhEQUFDQztnQkFBSU4sV0FBV1IsMEVBQW1COztrQ0FDbEMsOERBQUN3Qjt3QkFBS2hCLFdBQVdSLDBFQUFtQjtrQ0FBRTs7Ozs7O2tDQUN0Qyw4REFBQ2M7d0JBQUlOLFdBQVdSLCtFQUF3QjtrQ0FDdENFLFVBQVVjLEdBQUcsQ0FBQ1csU0FBQUE7aURBQ2QsOERBQUM3QiwyREFBUUEsRUFBQUEsNkRBQUFBLEtBRUo2QixXQURDQSxTQUFTTixFQUFFOzs7Ozs7Ozs7Ozs7Ozs7OzswQkFRckIsOERBQUNQO2dCQUFJTixXQUFXUiw2RUFBc0I7O2tDQUNyQyw4REFBQ3dCO3dCQUFLaEIsV0FBV1IsMEVBQW1CO2tDQUFFOzs7Ozs7a0NBQ3RDLDhEQUFDNkI7d0JBQ0FWLE1BQUs7d0JBQ0xFLElBQUc7Ozs7Ozs7Ozs7OzswQkFHTCw4REFBQ3RCLGlFQUFVQTs7Ozs7MEJBQ1gsOERBQUNlO2dCQUFJTixXQUFXUiw0RUFBcUI7O2tDQUNwQyw4REFBQ1c7d0JBQUVILFdBQVdSLDRFQUFxQjs7NEJBQUU7MENBRXBDLDhEQUFDd0I7MENBQUs7Ozs7Ozs7Ozs7OztrQ0FFUCw4REFBQzVCLHFEQUFNQTt3QkFBQ1ksV0FBV1IsMkVBQW9CO2tDQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJN0M7S0F0RGdCQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9jYWxsYmFjay9DYWxsYmFjay50c3g/NThiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY24gZnJvbSAnY2xzeCdcclxuXHJcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gJy4uL3VpL2J1dHRvbi9CdXR0b24nXHJcbmltcG9ydCB7IElucHV0IH0gZnJvbSAnLi4vdWkvaW5wdXQvSW5wdXQnXHJcbmltcG9ydCB7IFN3aXRjaGVyIH0gZnJvbSAnLi4vdWkvc3dpdGNoZXIvU3dpdGNoZXInXHJcbmltcG9ydCB7IFVwbG9hZEZpbGUgfSBmcm9tICcuLi91aS91cGxvYWRGaWxlL1VwbG9hZEZpbGUnXHJcblxyXG5pbXBvcnQgY2xhc3NlcyBmcm9tICcuL0NhbGxiYWNrLm1vZHVsZS5zY3NzJ1xyXG5pbXBvcnQgeyBJQ2FsbGJhY2sgfSBmcm9tICcuL2NhbGxiYWNrLnR5cGVzJ1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENhbGxiYWNrKHsgc3dpdGNoZXJzLCBpbnB1dHMsIHRpdGxlLCB0ZXh0IH06IElDYWxsYmFjaykge1xyXG5cdHJldHVybiAoXHJcblx0XHQ8Zm9ybVxyXG5cdFx0XHRhY3Rpb249JydcclxuXHRcdFx0Y2xhc3NOYW1lPXtjbihjbGFzc2VzLmZvcm0pfVxyXG5cdFx0PlxyXG5cdFx0XHQ8aDMgY2xhc3NOYW1lPXtjbignc2l0ZS10aXRsZS0zJywgY2xhc3Nlcy5mb3JtX190aXRsZSl9Pnt0aXRsZX08L2gzPlxyXG5cdFx0XHQ8cCBjbGFzc05hbWU9e2NsYXNzZXMuZm9ybV9fdGV4dH0+e3RleHR9PC9wPlxyXG5cdFx0XHR7aW5wdXRzPy5sZW5ndGggJiYgKFxyXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzLmZvcm1fX2lucHV0c30+XHJcblx0XHRcdFx0XHR7aW5wdXRzLm1hcChpbnB1dCA9PiAoXHJcblx0XHRcdFx0XHRcdDxJbnB1dFxyXG5cdFx0XHRcdFx0XHRcdGtleT17aW5wdXQubmFtZX1cclxuXHRcdFx0XHRcdFx0XHR0eXBlPXtpbnB1dC50eXBlfVxyXG5cdFx0XHRcdFx0XHRcdG5hbWU9e2lucHV0Lm5hbWV9XHJcblx0XHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9e2lucHV0LnBsYWNlaG9sZGVyfVxyXG5cdFx0XHRcdFx0XHRcdGlkPXtpbnB1dC5pZH1cclxuXHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzZXMuZm9ybV9faW5wdXR9XHJcblx0XHRcdFx0XHRcdC8+XHJcblx0XHRcdFx0XHQpKX1cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0KX1cclxuXHJcblx0XHRcdHtzd2l0Y2hlcnM/Lmxlbmd0aCAmJiAoXHJcblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuZm9ybV9fdGhlbWV9PlxyXG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPXtjbGFzc2VzLmZvcm1fX2xhYmVsfT7QotC40L8g0L/RgNC+0LXQutGC0LA8L3NwYW4+XHJcblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlcy5mb3JtX190aGVtZVR5cGVzfT5cclxuXHRcdFx0XHRcdFx0e3N3aXRjaGVycy5tYXAoc3dpdGNoZXIgPT4gKFxyXG5cdFx0XHRcdFx0XHRcdDxTd2l0Y2hlclxyXG5cdFx0XHRcdFx0XHRcdFx0a2V5PXtzd2l0Y2hlci5pZH1cclxuXHRcdFx0XHRcdFx0XHRcdHsuLi5zd2l0Y2hlcn1cclxuXHRcdFx0XHRcdFx0XHQvPlxyXG5cdFx0XHRcdFx0XHQpKX1cclxuXHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHQpfVxyXG5cclxuXHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuZm9ybV9fdGV4dGFyZWF9PlxyXG5cdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT17Y2xhc3Nlcy5mb3JtX19sYWJlbH0+0JrRgNCw0YLQutC+INC+INC/0YDQvtC10LrRgtC1PC9zcGFuPlxyXG5cdFx0XHRcdDx0ZXh0YXJlYVxyXG5cdFx0XHRcdFx0bmFtZT0nbWVzc2FnZSdcclxuXHRcdFx0XHRcdGlkPSdtZXNzYWdlJ1xyXG5cdFx0XHRcdD48L3RleHRhcmVhPlxyXG5cdFx0XHQ8L2Rpdj5cclxuXHRcdFx0PFVwbG9hZEZpbGUgLz5cclxuXHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuZm9ybV9fYWN0aW9uc30+XHJcblx0XHRcdFx0PHAgY2xhc3NOYW1lPXtjbGFzc2VzLmZvcm1fX3ByaXZhY3l9PlxyXG5cdFx0XHRcdFx00J7RgtC/0YDQsNCy0LvRj9GPINGE0L7RgNC80YMsINGPINGB0L7Qs9C70LDRiNCw0Y7RgdGMIGPCoFxyXG5cdFx0XHRcdFx0PHNwYW4+0L/RgNCw0LLQuNC70LDQvNC4INC+0LHRgNCw0LHQvtGC0LrQuCDQtNCw0L3QvdGL0YU8L3NwYW4+XHJcblx0XHRcdFx0PC9wPlxyXG5cdFx0XHRcdDxCdXR0b24gY2xhc3NOYW1lPXtjbGFzc2VzLmZvcm1fX3N1Ym1pdH0+0J7RgtC/0YDQsNCy0LjRgtGMINC30LDRj9Cy0LrRgzwvQnV0dG9uPlxyXG5cdFx0XHQ8L2Rpdj5cclxuXHRcdDwvZm9ybT5cclxuXHQpXHJcbn1cclxuIl0sIm5hbWVzIjpbImNuIiwiQnV0dG9uIiwiSW5wdXQiLCJTd2l0Y2hlciIsIlVwbG9hZEZpbGUiLCJjbGFzc2VzIiwiQ2FsbGJhY2siLCJzd2l0Y2hlcnMiLCJpbnB1dHMiLCJ0aXRsZSIsInRleHQiLCJmb3JtIiwiYWN0aW9uIiwiY2xhc3NOYW1lIiwiaDMiLCJmb3JtX190aXRsZSIsInAiLCJmb3JtX190ZXh0IiwibGVuZ3RoIiwiZGl2IiwiZm9ybV9faW5wdXRzIiwibWFwIiwiaW5wdXQiLCJ0eXBlIiwibmFtZSIsInBsYWNlaG9sZGVyIiwiaWQiLCJmb3JtX19pbnB1dCIsImZvcm1fX3RoZW1lIiwic3BhbiIsImZvcm1fX2xhYmVsIiwiZm9ybV9fdGhlbWVUeXBlcyIsInN3aXRjaGVyIiwiZm9ybV9fdGV4dGFyZWEiLCJ0ZXh0YXJlYSIsImZvcm1fX2FjdGlvbnMiLCJmb3JtX19wcml2YWN5IiwiZm9ybV9fc3VibWl0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/callback/Callback.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/contact/Contact.tsx":
/*!********************************************!*\
  !*** ./src/components/contact/Contact.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Contact: function() { return /* binding */ Contact; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/link.js\");\n/* harmony import */ var _ui_IconComponent_IconComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ui/IconComponent/IconComponent */ \"(app-pages-browser)/./src/components/ui/IconComponent/IconComponent.tsx\");\n/* harmony import */ var _contact_module_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./contact.module.scss */ \"(app-pages-browser)/./src/components/contact/contact.module.scss\");\n/* harmony import */ var _contact_module_scss__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_contact_module_scss__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\nfunction Contact(param) {\n    var isAddress = param.isAddress;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_contact_module_scss__WEBPACK_IMPORTED_MODULE_4___default().contact),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"site-title-3\", (_contact_module_scss__WEBPACK_IMPORTED_MODULE_4___default().contact__title)),\n                children: \"Контакты\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\contact\\\\Contact.tsx\",\n                lineNumber: 11,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                className: (_contact_module_scss__WEBPACK_IMPORTED_MODULE_4___default().contact__time),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_IconComponent_IconComponent__WEBPACK_IMPORTED_MODULE_3__.IconComponent, {\n                        icon: \"tabler:clock\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\contact\\\\Contact.tsx\",\n                        lineNumber: 13,\n                        columnNumber: 5\n                    }, this),\n                    \"Пн-Пт: 10:00-18:00\"\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\contact\\\\Contact.tsx\",\n                lineNumber: 12,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_contact_module_scss__WEBPACK_IMPORTED_MODULE_4___default().contact__contentInfo),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_contact_module_scss__WEBPACK_IMPORTED_MODULE_4___default().contact__contentInfoBox),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                target: \"_blank\",\n                                href: \"tel:+74951091202\",\n                                children: \"+7 495 109 12 02\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\contact\\\\Contact.tsx\",\n                                lineNumber: 18,\n                                columnNumber: 6\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                target: \"_blank\",\n                                href: \"https://wa.me/+74832590366\",\n                                children: \"WhatsApp\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\contact\\\\Contact.tsx\",\n                                lineNumber: 24,\n                                columnNumber: 6\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                target: \"_blank\",\n                                href: \"https://t.me/rband_pro\",\n                                children: \"Telegram\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\contact\\\\Contact.tsx\",\n                                lineNumber: 30,\n                                columnNumber: 6\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\contact\\\\Contact.tsx\",\n                        lineNumber: 17,\n                        columnNumber: 5\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_contact_module_scss__WEBPACK_IMPORTED_MODULE_4___default().contact__contentInfoBox),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                target: \"_blank\",\n                                href: \"mailto:mail@rband.pro\",\n                                children: \"mail@rband.pro\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\contact\\\\Contact.tsx\",\n                                lineNumber: 38,\n                                columnNumber: 6\n                            }, this),\n                            isAddress && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: (_contact_module_scss__WEBPACK_IMPORTED_MODULE_4___default().contact__contentInfoAddress),\n                                children: \"Россия, Брянск, ул. Осовиахима, 3г\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\contact\\\\Contact.tsx\",\n                                lineNumber: 45,\n                                columnNumber: 7\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\contact\\\\Contact.tsx\",\n                        lineNumber: 37,\n                        columnNumber: 5\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\contact\\\\Contact.tsx\",\n                lineNumber: 16,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\contact\\\\Contact.tsx\",\n        lineNumber: 10,\n        columnNumber: 3\n    }, this);\n}\n_c = Contact;\nvar _c;\n$RefreshReg$(_c, \"Contact\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2NvbnRhY3QvQ29udGFjdC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBcUI7QUFDTztBQUVxQztBQUV0QjtBQUVwQyxTQUFTSSxRQUFRLEtBQXFDO1FBQXJDLGtCQUFFQztJQUN6QixxQkFDQyw4REFBQ0M7UUFBSUMsV0FBV0oscUVBQWU7OzBCQUM5Qiw4REFBQ007Z0JBQUdGLFdBQVdQLGdEQUFFQSxDQUFDLGdCQUFnQkcsNEVBQXNCOzBCQUFHOzs7Ozs7MEJBQzNELDhEQUFDUTtnQkFBRUosV0FBV0osMkVBQXFCOztrQ0FDbEMsOERBQUNELDBFQUFhQTt3QkFBQ1csTUFBSzs7Ozs7O29CQUFpQjs7Ozs7OzswQkFHdEMsOERBQUNQO2dCQUFJQyxXQUFXSixrRkFBNEI7O2tDQUMzQyw4REFBQ0c7d0JBQUlDLFdBQVdKLHFGQUErQjs7MENBQzlDLDhEQUFDRixpREFBSUE7Z0NBQ0plLFFBQU87Z0NBQ1BDLE1BQUs7MENBQ0w7Ozs7OzswQ0FHRCw4REFBQ2hCLGlEQUFJQTtnQ0FDSmUsUUFBTztnQ0FDUEMsTUFBSzswQ0FDTDs7Ozs7OzBDQUdELDhEQUFDaEIsaURBQUlBO2dDQUNKZSxRQUFPO2dDQUNQQyxNQUFLOzBDQUNMOzs7Ozs7Ozs7Ozs7a0NBSUYsOERBQUNYO3dCQUFJQyxXQUFXSixxRkFBK0I7OzBDQUM5Qyw4REFBQ0YsaURBQUlBO2dDQUNKZSxRQUFPO2dDQUNQQyxNQUFLOzBDQUNMOzs7Ozs7NEJBR0FaLDJCQUNBLDhEQUFDTTtnQ0FBRUosV0FBV0oseUZBQW1DOzBDQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFRekQ7S0E3Q2dCQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9jb250YWN0L0NvbnRhY3QudHN4P2Q1YTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNuIGZyb20gJ2Nsc3gnXHJcbmltcG9ydCBMaW5rIGZyb20gJ25leHQvbGluaydcclxuXHJcbmltcG9ydCB7IEljb25Db21wb25lbnQgfSBmcm9tICcuLi91aS9JY29uQ29tcG9uZW50L0ljb25Db21wb25lbnQnXHJcblxyXG5pbXBvcnQgY2xhc3NlcyBmcm9tICcuL2NvbnRhY3QubW9kdWxlLnNjc3MnXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ29udGFjdCh7IGlzQWRkcmVzcyB9OiB7IGlzQWRkcmVzczogYm9vbGVhbiB9KSB7XHJcblx0cmV0dXJuIChcclxuXHRcdDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzLmNvbnRhY3R9PlxyXG5cdFx0XHQ8aDEgY2xhc3NOYW1lPXtjbignc2l0ZS10aXRsZS0zJywgY2xhc3Nlcy5jb250YWN0X190aXRsZSl9PtCa0L7QvdGC0LDQutGC0Ys8L2gxPlxyXG5cdFx0XHQ8cCBjbGFzc05hbWU9e2NsYXNzZXMuY29udGFjdF9fdGltZX0+XHJcblx0XHRcdFx0PEljb25Db21wb25lbnQgaWNvbj0ndGFibGVyOmNsb2NrJyAvPlxyXG5cdFx0XHRcdNCf0L0t0J/RgjogMTA6MDAtMTg6MDBcclxuXHRcdFx0PC9wPlxyXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlcy5jb250YWN0X19jb250ZW50SW5mb30+XHJcblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuY29udGFjdF9fY29udGVudEluZm9Cb3h9PlxyXG5cdFx0XHRcdFx0PExpbmtcclxuXHRcdFx0XHRcdFx0dGFyZ2V0PSdfYmxhbmsnXHJcblx0XHRcdFx0XHRcdGhyZWY9J3RlbDorNzQ5NTEwOTEyMDInXHJcblx0XHRcdFx0XHQ+XHJcblx0XHRcdFx0XHRcdCs3IDQ5NSAxMDkgMTIgMDJcclxuXHRcdFx0XHRcdDwvTGluaz5cclxuXHRcdFx0XHRcdDxMaW5rXHJcblx0XHRcdFx0XHRcdHRhcmdldD0nX2JsYW5rJ1xyXG5cdFx0XHRcdFx0XHRocmVmPSdodHRwczovL3dhLm1lLys3NDgzMjU5MDM2NidcclxuXHRcdFx0XHRcdD5cclxuXHRcdFx0XHRcdFx0V2hhdHNBcHBcclxuXHRcdFx0XHRcdDwvTGluaz5cclxuXHRcdFx0XHRcdDxMaW5rXHJcblx0XHRcdFx0XHRcdHRhcmdldD0nX2JsYW5rJ1xyXG5cdFx0XHRcdFx0XHRocmVmPSdodHRwczovL3QubWUvcmJhbmRfcHJvJ1xyXG5cdFx0XHRcdFx0PlxyXG5cdFx0XHRcdFx0XHRUZWxlZ3JhbVxyXG5cdFx0XHRcdFx0PC9MaW5rPlxyXG5cdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzLmNvbnRhY3RfX2NvbnRlbnRJbmZvQm94fT5cclxuXHRcdFx0XHRcdDxMaW5rXHJcblx0XHRcdFx0XHRcdHRhcmdldD0nX2JsYW5rJ1xyXG5cdFx0XHRcdFx0XHRocmVmPSdtYWlsdG86bWFpbEByYmFuZC5wcm8nXHJcblx0XHRcdFx0XHQ+XHJcblx0XHRcdFx0XHRcdG1haWxAcmJhbmQucHJvXHJcblx0XHRcdFx0XHQ8L0xpbms+XHJcblx0XHRcdFx0XHR7aXNBZGRyZXNzICYmIChcclxuXHRcdFx0XHRcdFx0PHAgY2xhc3NOYW1lPXtjbGFzc2VzLmNvbnRhY3RfX2NvbnRlbnRJbmZvQWRkcmVzc30+XHJcblx0XHRcdFx0XHRcdFx00KDQvtGB0YHQuNGPLCDQkdGA0Y/QvdGB0LosINGD0LsuINCe0YHQvtCy0LjQsNGF0LjQvNCwLCAz0LNcclxuXHRcdFx0XHRcdFx0PC9wPlxyXG5cdFx0XHRcdFx0KX1cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0PC9kaXY+XHJcblx0XHQ8L2Rpdj5cclxuXHQpXHJcbn1cclxuIl0sIm5hbWVzIjpbImNuIiwiTGluayIsIkljb25Db21wb25lbnQiLCJjbGFzc2VzIiwiQ29udGFjdCIsImlzQWRkcmVzcyIsImRpdiIsImNsYXNzTmFtZSIsImNvbnRhY3QiLCJoMSIsImNvbnRhY3RfX3RpdGxlIiwicCIsImNvbnRhY3RfX3RpbWUiLCJpY29uIiwiY29udGFjdF9fY29udGVudEluZm8iLCJjb250YWN0X19jb250ZW50SW5mb0JveCIsInRhcmdldCIsImhyZWYiLCJjb250YWN0X19jb250ZW50SW5mb0FkZHJlc3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/contact/Contact.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/contacts/Contacts.tsx":
/*!**********************************************!*\
  !*** ./src/components/contacts/Contacts.tsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Contacts: function() { return /* binding */ Contacts; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var _components_callback_Callback__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/callback/Callback */ \"(app-pages-browser)/./src/components/callback/Callback.tsx\");\n/* harmony import */ var _components_contact_Contact__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/contact/Contact */ \"(app-pages-browser)/./src/components/contact/Contact.tsx\");\n/* harmony import */ var _components_ui_container_Container__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/ui/container/Container */ \"(app-pages-browser)/./src/components/ui/container/Container.tsx\");\n/* harmony import */ var _Contacts_module_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Contacts.module.scss */ \"(app-pages-browser)/./src/components/contacts/Contacts.module.scss\");\n/* harmony import */ var _Contacts_module_scss__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_Contacts_module_scss__WEBPACK_IMPORTED_MODULE_5__);\n\n\n\n\n\n\n\nfunction Contacts(param) {\n    var _param_theme = param.theme, theme = _param_theme === void 0 ? \"light\" : _param_theme, callback = param.callback, contact = param.contact;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])((_Contacts_module_scss__WEBPACK_IMPORTED_MODULE_5___default().contacts), theme === \"dark\" && \"dark\"),\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_container_Container__WEBPACK_IMPORTED_MODULE_4__.Container, {\n            variant: \"xl\",\n            className: (_Contacts_module_scss__WEBPACK_IMPORTED_MODULE_5___default().contacts__container),\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_contact_Contact__WEBPACK_IMPORTED_MODULE_3__.Contact, {\n                    isAddress: contact.isAddress\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\contacts\\\\Contacts.tsx\",\n                    lineNumber: 26,\n                    columnNumber: 5\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_callback_Callback__WEBPACK_IMPORTED_MODULE_2__.Callback, (0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_6__._)({}, callback), void 0, false, {\n                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\contacts\\\\Contacts.tsx\",\n                    lineNumber: 27,\n                    columnNumber: 5\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\contacts\\\\Contacts.tsx\",\n            lineNumber: 22,\n            columnNumber: 4\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\contacts\\\\Contacts.tsx\",\n        lineNumber: 21,\n        columnNumber: 3\n    }, this);\n}\n_c = Contacts;\nvar _c;\n$RefreshReg$(_c, \"Contacts\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2NvbnRhY3RzL0NvbnRhY3RzLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFxQjtBQUVvQztBQUNIO0FBQ1M7QUFJbkI7QUFVckMsU0FBU0ssU0FBUyxLQUFpRDt1QkFBakQsTUFBRUMsT0FBQUEsa0NBQVEsd0JBQVNDLFdBQW5CLE1BQW1CQSxVQUFVQyxVQUE3QixNQUE2QkE7SUFDckQscUJBQ0MsOERBQUNDO1FBQVFDLFdBQVdWLGdEQUFFQSxDQUFDSSx1RUFBZ0IsRUFBRUUsVUFBVSxVQUFVO2tCQUM1RCw0RUFBQ0gseUVBQVNBO1lBQ1RTLFNBQVE7WUFDUkYsV0FBV04sa0ZBQTJCOzs4QkFFdEMsOERBQUNGLGdFQUFPQTtvQkFBQ1ksV0FBV04sUUFBUU0sU0FBUzs7Ozs7OzhCQUNyQyw4REFBQ2IsbUVBQVFBLEVBQUFBLDZEQUFBQSxLQUFLTTs7Ozs7Ozs7Ozs7Ozs7OztBQUlsQjtLQVpnQkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvY29udGFjdHMvQ29udGFjdHMudHN4P2M1OGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNuIGZyb20gJ2Nsc3gnXHJcblxyXG5pbXBvcnQgeyBDYWxsYmFjayB9IGZyb20gJ0AvY29tcG9uZW50cy9jYWxsYmFjay9DYWxsYmFjaydcclxuaW1wb3J0IHsgQ29udGFjdCB9IGZyb20gJ0AvY29tcG9uZW50cy9jb250YWN0L0NvbnRhY3QnXHJcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJ0AvY29tcG9uZW50cy91aS9jb250YWluZXIvQ29udGFpbmVyJ1xyXG5cclxuaW1wb3J0IHsgSUNhbGxiYWNrIH0gZnJvbSAnLi4vY2FsbGJhY2svY2FsbGJhY2sudHlwZXMnXHJcblxyXG5pbXBvcnQgY2xhc3NlcyBmcm9tICcuL0NvbnRhY3RzLm1vZHVsZS5zY3NzJ1xyXG5cclxuaW50ZXJmYWNlIElDb250YWN0cyB7XHJcblx0dGhlbWU/OiAnZGFyaycgfCAnbGlnaHQnXHJcblx0Y29udGFjdDoge1xyXG5cdFx0aXNBZGRyZXNzOiBib29sZWFuXHJcblx0fVxyXG5cdGNhbGxiYWNrOiBJQ2FsbGJhY2tcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENvbnRhY3RzKHsgdGhlbWUgPSAnbGlnaHQnLCBjYWxsYmFjaywgY29udGFjdCB9OiBJQ29udGFjdHMpIHtcclxuXHRyZXR1cm4gKFxyXG5cdFx0PHNlY3Rpb24gY2xhc3NOYW1lPXtjbihjbGFzc2VzLmNvbnRhY3RzLCB0aGVtZSA9PT0gJ2RhcmsnICYmICdkYXJrJyl9PlxyXG5cdFx0XHQ8Q29udGFpbmVyXHJcblx0XHRcdFx0dmFyaWFudD0neGwnXHJcblx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc2VzLmNvbnRhY3RzX19jb250YWluZXJ9XHJcblx0XHRcdD5cclxuXHRcdFx0XHQ8Q29udGFjdCBpc0FkZHJlc3M9e2NvbnRhY3QuaXNBZGRyZXNzfSAvPlxyXG5cdFx0XHRcdDxDYWxsYmFjayB7Li4uY2FsbGJhY2t9IC8+XHJcblx0XHRcdDwvQ29udGFpbmVyPlxyXG5cdFx0PC9zZWN0aW9uPlxyXG5cdClcclxufVxyXG4iXSwibmFtZXMiOlsiY24iLCJDYWxsYmFjayIsIkNvbnRhY3QiLCJDb250YWluZXIiLCJjbGFzc2VzIiwiQ29udGFjdHMiLCJ0aGVtZSIsImNhbGxiYWNrIiwiY29udGFjdCIsInNlY3Rpb24iLCJjbGFzc05hbWUiLCJjb250YWN0cyIsInZhcmlhbnQiLCJjb250YWN0c19fY29udGFpbmVyIiwiaXNBZGRyZXNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/contacts/Contacts.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/header/Header.tsx":
/*!******************************************!*\
  !*** ./src/components/header/Header.tsx ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Header: function() { return /* binding */ Header; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _barrel_optimize_names_Icon_iconify_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=Icon!=!@iconify/react */ \"(app-pages-browser)/__barrel_optimize__?names=Icon!=!./node_modules/.pnpm/@iconify+react@4.1.1_react@18.3.1/node_modules/@iconify/react/dist/iconify.mjs\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/link.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _constants_headerBlack_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/constants/headerBlack.constants */ \"(app-pages-browser)/./src/constants/headerBlack.constants.ts\");\n/* harmony import */ var _hooks_useScroll__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/hooks/useScroll */ \"(app-pages-browser)/./src/hooks/useScroll.ts\");\n/* harmony import */ var _contacts_Contacts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../contacts/Contacts */ \"(app-pages-browser)/./src/components/contacts/Contacts.tsx\");\n/* harmony import */ var _localization_Localization__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../localization/Localization */ \"(app-pages-browser)/./src/components/localization/Localization.tsx\");\n/* harmony import */ var _ui_container_Container__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../ui/container/Container */ \"(app-pages-browser)/./src/components/ui/container/Container.tsx\");\n/* harmony import */ var _HeaderNav__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./HeaderNav */ \"(app-pages-browser)/./src/components/header/HeaderNav.tsx\");\n/* harmony import */ var _menu_data__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./menu.data */ \"(app-pages-browser)/./src/components/header/menu.data.ts\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./styles.module.scss */ \"(app-pages-browser)/./src/components/header/styles.module.scss\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_styles_module_scss__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var _contexts_Modal_context__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @/contexts/Modal.context */ \"(app-pages-browser)/./src/contexts/Modal.context.ts\");\n/* __next_internal_client_entry_do_not_use__ Header auto */ \n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Header() {\n    _s();\n    var _useState = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_15__._)((0,react__WEBPACK_IMPORTED_MODULE_5__.useState)(false), 2), isFixed = _useState[0], setIsFixed = _useState[1];\n    var _useState1 = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_15__._)((0,react__WEBPACK_IMPORTED_MODULE_5__.useState)(false), 2), isLoaded = _useState1[0], setIsLoaded = _useState1[1];\n    var _useState2 = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_15__._)((0,react__WEBPACK_IMPORTED_MODULE_5__.useState)(true), 2), isTranslate = _useState2[0], setIsTranslate = _useState2[1];\n    var _useState3 = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_15__._)((0,react__WEBPACK_IMPORTED_MODULE_5__.useState)(false), 2), isShow = _useState3[0], setIsShow = _useState3[1];\n    var _useState4 = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_15__._)((0,react__WEBPACK_IMPORTED_MODULE_5__.useState)(false), 2), isTransition = _useState4[0], setIsTransition = _useState4[1];\n    var _useState5 = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_15__._)((0,react__WEBPACK_IMPORTED_MODULE_5__.useState)(false), 2), isHover = _useState5[0], setIsHover = _useState5[1];\n    var _useScroll = (0,_hooks_useScroll__WEBPACK_IMPORTED_MODULE_7__.useScroll)(), scroll = _useScroll.scroll, setScroll = _useScroll.setScroll;\n    var pathname = (0,next_navigation__WEBPACK_IMPORTED_MODULE_4__.usePathname)();\n    var open = (0,react__WEBPACK_IMPORTED_MODULE_5__.useContext)(_contexts_Modal_context__WEBPACK_IMPORTED_MODULE_14__.ModalContext).open;\n    var currentScroll = 0;\n    var handleScroll = function(e) {\n        var window1 = e.currentTarget;\n        var header = document.querySelector(\"header\");\n        if (currentScroll > window1.scrollY) {\n            setIsShow(true);\n        } else {\n            setIsShow(false);\n        }\n        setScroll(window1.scrollY);\n        if (header && window1.scrollY > header.clientHeight) {\n            setIsFixed(true);\n        } else if (window1.scrollY <= 1) {\n            setIsFixed(false);\n            setIsShow(false);\n        }\n        currentScroll = window1.scrollY;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_5__.useEffect)(function() {\n        if (isFixed) {\n            setTimeout(function() {\n                return setIsTransition(true);\n            }, 200);\n        } else {\n            setIsTransition(false);\n        }\n    }, [\n        isFixed\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_5__.useEffect)(function() {\n        window.addEventListener(\"scroll\", handleScroll);\n        setIsLoaded(true);\n        return function() {\n            window.removeEventListener(\"scroll\", handleScroll);\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])((_styles_module_scss__WEBPACK_IMPORTED_MODULE_13___default().header), isFixed ? (_styles_module_scss__WEBPACK_IMPORTED_MODULE_13___default().header_fixed) : \"\", isShow ? (_styles_module_scss__WEBPACK_IMPORTED_MODULE_13___default().header_show) : \"\", isTransition ? (_styles_module_scss__WEBPACK_IMPORTED_MODULE_13___default().header_transition) : \"\", _constants_headerBlack_constants__WEBPACK_IMPORTED_MODULE_6__.headerBlack.includes(pathname) || isFixed ? (_styles_module_scss__WEBPACK_IMPORTED_MODULE_13___default().header_black) : \"\"),\n        onTransitionEnd: function() {\n            return setIsTranslate(false);\n        },\n        style: !isLoaded ? {\n            transform: \"translateY(-100%)\",\n            opacity: \"0\"\n        } : isTranslate && scroll <= 0 ? {\n            transition: \"all 0.5s 1.9s ease\"\n        } : {},\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_container_Container__WEBPACK_IMPORTED_MODULE_10__.Container, {\n            variant: \"xl\",\n            className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_13___default().header__container),\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_13___default().header__left),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                            className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_13___default().header__logo),\n                            href: \"/\",\n                            children: \"RBAND\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\Header.tsx\",\n                            lineNumber: 95,\n                            columnNumber: 6\n                        }, this),\n                        _menu_data__WEBPACK_IMPORTED_MODULE_12__.menu.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_HeaderNav__WEBPACK_IMPORTED_MODULE_11__.HeaderNav, {}, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\Header.tsx\",\n                            lineNumber: 101,\n                            columnNumber: 26\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\Header.tsx\",\n                    lineNumber: 94,\n                    columnNumber: 5\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_13___default().header__right),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_13___default().header__getLangs),\n                            onClick: function() {\n                                return open(/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_localization_Localization__WEBPACK_IMPORTED_MODULE_9__.Localization, {\n                                    country: _menu_data__WEBPACK_IMPORTED_MODULE_12__.localesCountry\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\Header.tsx\",\n                                    lineNumber: 106,\n                                    columnNumber: 27\n                                }, void 0));\n                            },\n                            children: \"RU\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\Header.tsx\",\n                            lineNumber: 104,\n                            columnNumber: 6\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_13___default().header__getCity),\n                            onClick: function() {\n                                return open(/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_localization_Localization__WEBPACK_IMPORTED_MODULE_9__.Localization, {\n                                    regions: _menu_data__WEBPACK_IMPORTED_MODULE_12__.localesRegions\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\Header.tsx\",\n                                    lineNumber: 113,\n                                    columnNumber: 27\n                                }, void 0));\n                            },\n                            children: \"Екатеринбург\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\Header.tsx\",\n                            lineNumber: 111,\n                            columnNumber: 6\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])((_styles_module_scss__WEBPACK_IMPORTED_MODULE_13___default().header__getProject), isHover && (_styles_module_scss__WEBPACK_IMPORTED_MODULE_13___default().header__getProject_hover)),\n                            onMouseEnter: function() {\n                                return setIsHover(true);\n                            },\n                            onMouseLeave: function() {\n                                return setIsHover(false);\n                            },\n                            onClick: function() {\n                                return open(/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_contacts_Contacts__WEBPACK_IMPORTED_MODULE_8__.Contacts, {\n                                    theme: \"dark\",\n                                    contact: {\n                                        isAddress: false\n                                    },\n                                    callback: _menu_data__WEBPACK_IMPORTED_MODULE_12__.call\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\Header.tsx\",\n                                    lineNumber: 126,\n                                    columnNumber: 9\n                                }, void 0));\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_13___default().header__getProjectHover),\n                                    children: \"Поехали!\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\Header.tsx\",\n                                    lineNumber: 134,\n                                    columnNumber: 7\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_13___default().header__getProjectMain),\n                                    children: \"Начать проект\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\Header.tsx\",\n                                    lineNumber: 135,\n                                    columnNumber: 7\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\Header.tsx\",\n                            lineNumber: 117,\n                            columnNumber: 6\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_13___default().header__burger),\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Icon_iconify_react__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n                                icon: \"clarity:menu-line\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\Header.tsx\",\n                                lineNumber: 140,\n                                columnNumber: 7\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\Header.tsx\",\n                            lineNumber: 139,\n                            columnNumber: 6\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\Header.tsx\",\n                    lineNumber: 103,\n                    columnNumber: 5\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\Header.tsx\",\n            lineNumber: 90,\n            columnNumber: 4\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\Header.tsx\",\n        lineNumber: 73,\n        columnNumber: 3\n    }, this);\n}\n_s(Header, \"/TCCt2b4P7fg7+iUsJUkQJPBULQ=\", false, function() {\n    return [\n        _hooks_useScroll__WEBPACK_IMPORTED_MODULE_7__.useScroll,\n        next_navigation__WEBPACK_IMPORTED_MODULE_4__.usePathname\n    ];\n});\n_c = Header;\nvar _c;\n$RefreshReg$(_c, \"Header\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2hlYWRlci9IZWFkZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFcUM7QUFDaEI7QUFDTztBQUNpQjtBQUNVO0FBRVE7QUFFbEI7QUFFRTtBQUNZO0FBQ047QUFFZDtBQUNpQztBQUM5QjtBQUNhO0FBRWhELFNBQVNtQjs7SUFDZixJQUE4QmIsWUFBQUEsZ0VBQUFBLENBQUFBLCtDQUFRQSxDQUFDLFlBQWhDYyxVQUF1QmQsY0FBZGUsYUFBY2Y7SUFDOUIsSUFBZ0NBLGFBQUFBLGdFQUFBQSxDQUFBQSwrQ0FBUUEsQ0FBQyxZQUFsQ2dCLFdBQXlCaEIsZUFBZmlCLGNBQWVqQjtJQUNoQyxJQUFzQ0EsYUFBQUEsZ0VBQUFBLENBQUFBLCtDQUFRQSxDQUFDLFdBQXhDa0IsY0FBK0JsQixlQUFsQm1CLGlCQUFrQm5CO0lBQ3RDLElBQTRCQSxhQUFBQSxnRUFBQUEsQ0FBQUEsK0NBQVFBLENBQUMsWUFBOUJvQixTQUFxQnBCLGVBQWJxQixZQUFhckI7SUFDNUIsSUFBd0NBLGFBQUFBLGdFQUFBQSxDQUFBQSwrQ0FBUUEsQ0FBQyxZQUExQ3NCLGVBQWlDdEIsZUFBbkJ1QixrQkFBbUJ2QjtJQUN4QyxJQUE4QkEsYUFBQUEsZ0VBQUFBLENBQUFBLCtDQUFRQSxDQUFDLFlBQWhDd0IsVUFBdUJ4QixlQUFkeUIsYUFBY3pCO0lBQzlCLElBQThCRSxhQUFBQSwyREFBU0EsSUFBL0J3QixTQUFzQnhCLFdBQXRCd0IsUUFBUUMsWUFBY3pCLFdBQWR5QjtJQUNoQixJQUFNQyxXQUFXL0IsNERBQVdBO0lBRTVCLElBQU0sT0FBV0MsaURBQVVBLENBQUNjLGtFQUFZQSxFQUFoQ2lCO0lBRVIsSUFBSUMsZ0JBQWdCO0lBQ3BCLElBQU1DLGVBQWUsU0FBQ0M7UUFDckIsSUFBTUMsVUFBU0QsRUFBRUUsYUFBYTtRQUM5QixJQUFNQyxTQUFTQyxTQUFTQyxhQUFhLENBQUM7UUFFdEMs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UmJnQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9oZWFkZXIvSGVhZGVyLnRzeD9kODMzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG5cclxuaW1wb3J0IHsgSWNvbiB9IGZyb20gJ0BpY29uaWZ5L3JlYWN0J1xyXG5pbXBvcnQgY24gZnJvbSAnY2xzeCdcclxuaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJ1xyXG5pbXBvcnQgeyB1c2VQYXRobmFtZSB9IGZyb20gJ25leHQvbmF2aWdhdGlvbidcclxuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xyXG5cclxuaW1wb3J0IHsgaGVhZGVyQmxhY2sgfSBmcm9tICdAL2NvbnN0YW50cy9oZWFkZXJCbGFjay5jb25zdGFudHMnXHJcblxyXG5pbXBvcnQgeyB1c2VTY3JvbGwgfSBmcm9tICdAL2hvb2tzL3VzZVNjcm9sbCdcclxuXHJcbmltcG9ydCB7IENvbnRhY3RzIH0gZnJvbSAnLi4vY29udGFjdHMvQ29udGFjdHMnXHJcbmltcG9ydCB7IExvY2FsaXphdGlvbiB9IGZyb20gJy4uL2xvY2FsaXphdGlvbi9Mb2NhbGl6YXRpb24nXHJcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJy4uL3VpL2NvbnRhaW5lci9Db250YWluZXInXHJcblxyXG5pbXBvcnQgeyBIZWFkZXJOYXYgfSBmcm9tICcuL0hlYWRlck5hdidcclxuaW1wb3J0IHsgY2FsbCwgbG9jYWxlc0NvdW50cnksIGxvY2FsZXNSZWdpb25zLCBtZW51IH0gZnJvbSAnLi9tZW51LmRhdGEnXHJcbmltcG9ydCBjbGFzc2VzIGZyb20gJy4vc3R5bGVzLm1vZHVsZS5zY3NzJ1xyXG5pbXBvcnQgeyBNb2RhbENvbnRleHQgfSBmcm9tICdAL2NvbnRleHRzL01vZGFsLmNvbnRleHQnXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gSGVhZGVyKCkge1xyXG5cdGNvbnN0IFtpc0ZpeGVkLCBzZXRJc0ZpeGVkXSA9IHVzZVN0YXRlKGZhbHNlKVxyXG5cdGNvbnN0IFtpc0xvYWRlZCwgc2V0SXNMb2FkZWRdID0gdXNlU3RhdGUoZmFsc2UpXHJcblx0Y29uc3QgW2lzVHJhbnNsYXRlLCBzZXRJc1RyYW5zbGF0ZV0gPSB1c2VTdGF0ZSh0cnVlKVxyXG5cdGNvbnN0IFtpc1Nob3csIHNldElzU2hvd10gPSB1c2VTdGF0ZShmYWxzZSlcclxuXHRjb25zdCBbaXNUcmFuc2l0aW9uLCBzZXRJc1RyYW5zaXRpb25dID0gdXNlU3RhdGUoZmFsc2UpXHJcblx0Y29uc3QgW2lzSG92ZXIsIHNldElzSG92ZXJdID0gdXNlU3RhdGUoZmFsc2UpXHJcblx0Y29uc3QgeyBzY3JvbGwsIHNldFNjcm9sbCB9ID0gdXNlU2Nyb2xsKClcclxuXHRjb25zdCBwYXRobmFtZSA9IHVzZVBhdGhuYW1lKClcclxuXHJcblx0Y29uc3QgeyBvcGVuIH0gPSB1c2VDb250ZXh0KE1vZGFsQ29udGV4dClcclxuXHJcblx0bGV0IGN1cnJlbnRTY3JvbGwgPSAwXHJcblx0Y29uc3QgaGFuZGxlU2Nyb2xsID0gKGU6IEV2ZW50KSA9PiB7XHJcblx0XHRjb25zdCB3aW5kb3cgPSBlLmN1cnJlbnRUYXJnZXQgYXMgV2luZG93XHJcblx0XHRjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkZXInKVxyXG5cclxuXHRcdGlmIChjdXJyZW50U2Nyb2xsID4gd2luZG93LnNjcm9sbFkpIHtcclxuXHRcdFx0c2V0SXNTaG93KHRydWUpXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzZXRJc1Nob3coZmFsc2UpXHJcblx0XHR9XHJcblx0XHRzZXRTY3JvbGwod2luZG93LnNjcm9sbFkpXHJcblx0XHRpZiAoaGVhZGVyICYmIHdpbmRvdy5zY3JvbGxZID4gaGVhZGVyLmNsaWVudEhlaWdodCkge1xyXG5cdFx0XHRzZXRJc0ZpeGVkKHRydWUpXHJcblx0XHR9IGVsc2UgaWYgKHdpbmRvdy5zY3JvbGxZIDw9IDEpIHtcclxuXHRcdFx0c2V0SXNGaXhlZChmYWxzZSlcclxuXHRcdFx0c2V0SXNTaG93KGZhbHNlKVxyXG5cdFx0fVxyXG5cclxuXHRcdGN1cnJlbnRTY3JvbGwgPSB3aW5kb3cuc2Nyb2xsWVxyXG5cdH1cclxuXHJcblx0dXNlRWZmZWN0KCgpID0+IHtcclxuXHRcdGlmIChpc0ZpeGVkKSB7XHJcblx0XHRcdHNldFRpbWVvdXQoKCkgPT4gc2V0SXNUcmFuc2l0aW9uKHRydWUpLCAyMDApXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzZXRJc1RyYW5zaXRpb24oZmFsc2UpXHJcblx0XHR9XHJcblx0fSwgW2lzRml4ZWRdKVxyXG5cclxuXHR1c2VFZmZlY3QoKCkgPT4ge1xyXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbClcclxuXHRcdHNldElzTG9hZGVkKHRydWUpXHJcblxyXG5cdFx0cmV0dXJuICgpID0+IHtcclxuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbClcclxuXHRcdH1cclxuXHR9LCBbXSlcclxuXHJcblx0cmV0dXJuIChcclxuXHRcdDxoZWFkZXJcclxuXHRcdFx0Y2xhc3NOYW1lPXtjbihcclxuXHRcdFx0XHRjbGFzc2VzLmhlYWRlcixcclxuXHRcdFx0XHRpc0ZpeGVkID8gY2xhc3Nlcy5oZWFkZXJfZml4ZWQgOiAnJyxcclxuXHRcdFx0XHRpc1Nob3cgPyBjbGFzc2VzLmhlYWRlcl9zaG93IDogJycsXHJcblx0XHRcdFx0aXNUcmFuc2l0aW9uID8gY2xhc3Nlcy5oZWFkZXJfdHJhbnNpdGlvbiA6ICcnLFxyXG5cdFx0XHRcdGhlYWRlckJsYWNrLmluY2x1ZGVzKHBhdGhuYW1lKSB8fCBpc0ZpeGVkID8gY2xhc3Nlcy5oZWFkZXJfYmxhY2sgOiAnJ1xyXG5cdFx0XHQpfVxyXG5cdFx0XHRvblRyYW5zaXRpb25FbmQ9eygpID0+IHNldElzVHJhbnNsYXRlKGZhbHNlKX1cclxuXHRcdFx0c3R5bGU9e1xyXG5cdFx0XHRcdCFpc0xvYWRlZFxyXG5cdFx0XHRcdFx0PyB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoLTEwMCUpJywgb3BhY2l0eTogJzAnIH1cclxuXHRcdFx0XHRcdDogaXNUcmFuc2xhdGUgJiYgc2Nyb2xsIDw9IDBcclxuXHRcdFx0XHRcdFx0PyB7IHRyYW5zaXRpb246ICdhbGwgMC41cyAxLjlzIGVhc2UnIH1cclxuXHRcdFx0XHRcdFx0OiB7fVxyXG5cdFx0XHR9XHJcblx0XHQ+XHJcblx0XHRcdDxDb250YWluZXJcclxuXHRcdFx0XHR2YXJpYW50PSd4bCdcclxuXHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzZXMuaGVhZGVyX19jb250YWluZXJ9XHJcblx0XHRcdD5cclxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlcy5oZWFkZXJfX2xlZnR9PlxyXG5cdFx0XHRcdFx0PExpbmtcclxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc2VzLmhlYWRlcl9fbG9nb31cclxuXHRcdFx0XHRcdFx0aHJlZj0nLydcclxuXHRcdFx0XHRcdD5cclxuXHRcdFx0XHRcdFx0UkJBTkRcclxuXHRcdFx0XHRcdDwvTGluaz5cclxuXHRcdFx0XHRcdHttZW51Lmxlbmd0aCA+IDAgJiYgPEhlYWRlck5hdiAvPn1cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlcy5oZWFkZXJfX3JpZ2h0fT5cclxuXHRcdFx0XHRcdDxidXR0b25cclxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc2VzLmhlYWRlcl9fZ2V0TGFuZ3N9XHJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eygpID0+IG9wZW4oPExvY2FsaXphdGlvbiBjb3VudHJ5PXtsb2NhbGVzQ291bnRyeX0gLz4pfVxyXG5cdFx0XHRcdFx0PlxyXG5cdFx0XHRcdFx0XHRSVVxyXG5cdFx0XHRcdFx0PC9idXR0b24+XHJcblxyXG5cdFx0XHRcdFx0PGJ1dHRvblxyXG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzZXMuaGVhZGVyX19nZXRDaXR5fVxyXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsoKSA9PiBvcGVuKDxMb2NhbGl6YXRpb24gcmVnaW9ucz17bG9jYWxlc1JlZ2lvbnN9IC8+KX1cclxuXHRcdFx0XHRcdD5cclxuXHRcdFx0XHRcdFx00JXQutCw0YLQtdGA0LjQvdCx0YPRgNCzXHJcblx0XHRcdFx0XHQ8L2J1dHRvbj5cclxuXHRcdFx0XHRcdDxidXR0b25cclxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXtjbihcclxuXHRcdFx0XHRcdFx0XHRjbGFzc2VzLmhlYWRlcl9fZ2V0UHJvamVjdCxcclxuXHRcdFx0XHRcdFx0XHRpc0hvdmVyICYmIGNsYXNzZXMuaGVhZGVyX19nZXRQcm9qZWN0X2hvdmVyXHJcblx0XHRcdFx0XHRcdCl9XHJcblx0XHRcdFx0XHRcdG9uTW91c2VFbnRlcj17KCkgPT4gc2V0SXNIb3Zlcih0cnVlKX1cclxuXHRcdFx0XHRcdFx0b25Nb3VzZUxlYXZlPXsoKSA9PiBzZXRJc0hvdmVyKGZhbHNlKX1cclxuXHRcdFx0XHRcdFx0b25DbGljaz17KCkgPT5cclxuXHRcdFx0XHRcdFx0XHRvcGVuKFxyXG5cdFx0XHRcdFx0XHRcdFx0PENvbnRhY3RzXHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW1lPSdkYXJrJ1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRjb250YWN0PXt7IGlzQWRkcmVzczogZmFsc2UgfX1cclxuXHRcdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2s9e2NhbGx9XHJcblx0XHRcdFx0XHRcdFx0XHQvPlxyXG5cdFx0XHRcdFx0XHRcdClcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0PlxyXG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9e2NsYXNzZXMuaGVhZGVyX19nZXRQcm9qZWN0SG92ZXJ9PtCf0L7QtdGF0LDQu9C4ITwvc3Bhbj5cclxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPXtjbGFzc2VzLmhlYWRlcl9fZ2V0UHJvamVjdE1haW59PlxyXG5cdFx0XHRcdFx0XHRcdNCd0LDRh9Cw0YLRjCDQv9GA0L7QtdC60YJcclxuXHRcdFx0XHRcdFx0PC9zcGFuPlxyXG5cdFx0XHRcdFx0PC9idXR0b24+XHJcblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlcy5oZWFkZXJfX2J1cmdlcn0+XHJcblx0XHRcdFx0XHRcdDxJY29uIGljb249J2NsYXJpdHk6bWVudS1saW5lJyAvPlxyXG5cdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdDwvQ29udGFpbmVyPlxyXG5cdFx0PC9oZWFkZXI+XHJcblx0KVxyXG59XHJcbiJdLCJuYW1lcyI6WyJJY29uIiwiY24iLCJMaW5rIiwidXNlUGF0aG5hbWUiLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJoZWFkZXJCbGFjayIsInVzZVNjcm9sbCIsIkNvbnRhY3RzIiwiTG9jYWxpemF0aW9uIiwiQ29udGFpbmVyIiwiSGVhZGVyTmF2IiwiY2FsbCIsImxvY2FsZXNDb3VudHJ5IiwibG9jYWxlc1JlZ2lvbnMiLCJtZW51IiwiY2xhc3NlcyIsIk1vZGFsQ29udGV4dCIsIkhlYWRlciIsImlzRml4ZWQiLCJzZXRJc0ZpeGVkIiwiaXNMb2FkZWQiLCJzZXRJc0xvYWRlZCIsImlzVHJhbnNsYXRlIiwic2V0SXNUcmFuc2xhdGUiLCJpc1Nob3ciLCJzZXRJc1Nob3ciLCJpc1RyYW5zaXRpb24iLCJzZXRJc1RyYW5zaXRpb24iLCJpc0hvdmVyIiwic2V0SXNIb3ZlciIsInNjcm9sbCIsInNldFNjcm9sbCIsInBhdGhuYW1lIiwib3BlbiIsImN1cnJlbnRTY3JvbGwiLCJoYW5kbGVTY3JvbGwiLCJlIiwid2luZG93IiwiY3VycmVudFRhcmdldCIsImhlYWRlciIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsInNjcm9sbFkiLCJjbGllbnRIZWlnaHQiLCJzZXRUaW1lb3V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjbGFzc05hbWUiLCJoZWFkZXJfZml4ZWQiLCJoZWFkZXJfc2hvdyIsImhlYWRlcl90cmFuc2l0aW9uIiwiaW5jbHVkZXMiLCJoZWFkZXJfYmxhY2siLCJvblRyYW5zaXRpb25FbmQiLCJzdHlsZSIsInRyYW5zZm9ybSIsIm9wYWNpdHkiLCJ0cmFuc2l0aW9uIiwidmFyaWFudCIsImhlYWRlcl9fY29udGFpbmVyIiwiZGl2IiwiaGVhZGVyX19sZWZ0IiwiaGVhZGVyX19sb2dvIiwiaHJlZiIsImxlbmd0aCIsImhlYWRlcl9fcmlnaHQiLCJidXR0b24iLCJoZWFkZXJfX2dldExhbmdzIiwib25DbGljayIsImNvdW50cnkiLCJoZWFkZXJfX2dldENpdHkiLCJyZWdpb25zIiwiaGVhZGVyX19nZXRQcm9qZWN0IiwiaGVhZGVyX19nZXRQcm9qZWN0X2hvdmVyIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwidGhlbWUiLCJjb250YWN0IiwiaXNBZGRyZXNzIiwiY2FsbGJhY2siLCJzcGFuIiwiaGVhZGVyX19nZXRQcm9qZWN0SG92ZXIiLCJoZWFkZXJfX2dldFByb2plY3RNYWluIiwiaGVhZGVyX19idXJnZXIiLCJpY29uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/header/Header.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/header/HeaderNav.tsx":
/*!*********************************************!*\
  !*** ./src/components/header/HeaderNav.tsx ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HeaderNav: function() { return /* binding */ HeaderNav; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\n/* harmony import */ var _swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _HeaderNavItem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HeaderNavItem */ \"(app-pages-browser)/./src/components/header/HeaderNavItem.tsx\");\n/* harmony import */ var _menu_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./menu.data */ \"(app-pages-browser)/./src/components/header/menu.data.ts\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./styles.module.scss */ \"(app-pages-browser)/./src/components/header/styles.module.scss\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_styles_module_scss__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n\n\nfunction HeaderNav() {\n    var _this = this;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n        className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_4___default().header__nav),\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n            className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_4___default().header__list),\n            children: _menu_data__WEBPACK_IMPORTED_MODULE_3__.menu.map(function(m, i) {\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(_HeaderNavItem__WEBPACK_IMPORTED_MODULE_2__.HeaderNavItem, (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_5__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_6__._)({}, m), {\n                    key: i,\n                    __source: {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\HeaderNav.tsx\",\n                        lineNumber: 10,\n                        columnNumber: 6\n                    },\n                    __self: _this\n                }));\n            })\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\HeaderNav.tsx\",\n            lineNumber: 8,\n            columnNumber: 4\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\HeaderNav.tsx\",\n        lineNumber: 7,\n        columnNumber: 3\n    }, this);\n}\n_c = HeaderNav;\nvar _c;\n$RefreshReg$(_c, \"HeaderNav\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2hlYWRlci9IZWFkZXJOYXYudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStDO0FBQ2I7QUFDUTtBQUVuQyxTQUFTRzs7SUFDZixxQkFDQyw4REFBQ0M7UUFBSUMsV0FBV0gsd0VBQW1CO2tCQUNsQyw0RUFBQ0s7WUFBR0YsV0FBV0gseUVBQW9CO3NCQUNqQ0QsNENBQUlBLENBQUNRLEdBQUcsQ0FBQyxTQUFDQyxHQUFHQztxQ0FDYixxREFBQ1gseURBQWFBLEVBQUFBLG1FQUFBQSxDQUFBQSw2REFBQUEsS0FDVFU7b0JBQ0pFLEtBQUtEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTVg7S0FiZ0JSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2hlYWRlci9IZWFkZXJOYXYudHN4PzllOTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGVhZGVyTmF2SXRlbSB9IGZyb20gJy4vSGVhZGVyTmF2SXRlbSdcclxuaW1wb3J0IHsgbWVudSB9IGZyb20gJy4vbWVudS5kYXRhJ1xyXG5pbXBvcnQgY2xhc3NlcyBmcm9tICcuL3N0eWxlcy5tb2R1bGUuc2NzcydcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBIZWFkZXJOYXYoKSB7XHJcblx0cmV0dXJuIChcclxuXHRcdDxuYXYgY2xhc3NOYW1lPXtjbGFzc2VzLmhlYWRlcl9fbmF2fT5cclxuXHRcdFx0PHVsIGNsYXNzTmFtZT17Y2xhc3Nlcy5oZWFkZXJfX2xpc3R9PlxyXG5cdFx0XHRcdHttZW51Lm1hcCgobSwgaSkgPT4gKFxyXG5cdFx0XHRcdFx0PEhlYWRlck5hdkl0ZW1cclxuXHRcdFx0XHRcdFx0ey4uLm19XHJcblx0XHRcdFx0XHRcdGtleT17aX1cclxuXHRcdFx0XHRcdC8+XHJcblx0XHRcdFx0KSl9XHJcblx0XHRcdDwvdWw+XHJcblx0XHQ8L25hdj5cclxuXHQpXHJcbn1cclxuIl0sIm5hbWVzIjpbIkhlYWRlck5hdkl0ZW0iLCJtZW51IiwiY2xhc3NlcyIsIkhlYWRlck5hdiIsIm5hdiIsImNsYXNzTmFtZSIsImhlYWRlcl9fbmF2IiwidWwiLCJoZWFkZXJfX2xpc3QiLCJtYXAiLCJtIiwiaSIsImtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/header/HeaderNav.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/header/HeaderNavItem.tsx":
/*!*************************************************!*\
  !*** ./src/components/header/HeaderNavItem.tsx ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HeaderNavItem: function() { return /* binding */ HeaderNavItem; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/link.js\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./styles.module.scss */ \"(app-pages-browser)/./src/components/header/styles.module.scss\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_styles_module_scss__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nfunction HeaderNavItem(param) {\n    var href = param.href, title = param.title;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n        className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_2___default().header__listItem),\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n            href: href,\n            className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_2___default().header__listItemLink),\n            children: title\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\HeaderNavItem.tsx\",\n            lineNumber: 13,\n            columnNumber: 4\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\header\\\\HeaderNavItem.tsx\",\n        lineNumber: 12,\n        columnNumber: 3\n    }, this);\n}\n_c = HeaderNavItem;\nvar _c;\n$RefreshReg$(_c, \"HeaderNavItem\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2hlYWRlci9IZWFkZXJOYXZJdGVtLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBNEI7QUFFYztBQU9uQyxTQUFTRSxjQUFjLEtBQTBCO1FBQXhCQyxPQUFGLE1BQUVBLE1BQU1DLFFBQVIsTUFBUUE7SUFDckMscUJBQ0MsOERBQUNDO1FBQUdDLFdBQVdMLDZFQUF3QjtrQkFDdEMsNEVBQUNELGlEQUFJQTtZQUNKRyxNQUFNQTtZQUNORyxXQUFXTCxpRkFBNEI7c0JBRXRDRzs7Ozs7Ozs7Ozs7QUFJTDtLQVhnQkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvaGVhZGVyL0hlYWRlck5hdkl0ZW0udHN4P2JiYjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJ1xyXG5cclxuaW1wb3J0IGNsYXNzZXMgZnJvbSAnLi9zdHlsZXMubW9kdWxlLnNjc3MnXHJcblxyXG50eXBlIFR5cGVQcm9wcyA9IHtcclxuXHRocmVmOiBzdHJpbmdcclxuXHR0aXRsZTogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBIZWFkZXJOYXZJdGVtKHsgaHJlZiwgdGl0bGUgfTogVHlwZVByb3BzKSB7XHJcblx0cmV0dXJuIChcclxuXHRcdDxsaSBjbGFzc05hbWU9e2NsYXNzZXMuaGVhZGVyX19saXN0SXRlbX0+XHJcblx0XHRcdDxMaW5rXHJcblx0XHRcdFx0aHJlZj17aHJlZn1cclxuXHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzZXMuaGVhZGVyX19saXN0SXRlbUxpbmt9XHJcblx0XHRcdD5cclxuXHRcdFx0XHR7dGl0bGV9XHJcblx0XHRcdDwvTGluaz5cclxuXHRcdDwvbGk+XHJcblx0KVxyXG59XHJcbiJdLCJuYW1lcyI6WyJMaW5rIiwiY2xhc3NlcyIsIkhlYWRlck5hdkl0ZW0iLCJocmVmIiwidGl0bGUiLCJsaSIsImNsYXNzTmFtZSIsImhlYWRlcl9fbGlzdEl0ZW0iLCJoZWFkZXJfX2xpc3RJdGVtTGluayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/header/HeaderNavItem.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/header/menu.data.ts":
/*!********************************************!*\
  !*** ./src/components/header/menu.data.ts ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   call: function() { return /* binding */ call; },\n/* harmony export */   localesCountry: function() { return /* binding */ localesCountry; },\n/* harmony export */   localesRegions: function() { return /* binding */ localesRegions; },\n/* harmony export */   menu: function() { return /* binding */ menu; }\n/* harmony export */ });\nvar menu = [\n    {\n        href: \"/asdas\",\n        title: \"Услуги\"\n    },\n    {\n        href: \"#\",\n        title: \"Мы\"\n    },\n    {\n        href: \"#\",\n        title: \"Проекты\"\n    },\n    {\n        href: \"#\",\n        title: \"Блог\"\n    },\n    {\n        href: \"#\",\n        title: \"Отзывы\"\n    },\n    {\n        href: \"/contacts\",\n        title: \"Контакты\"\n    }\n];\nvar switchers = [\n    {\n        id: \"web-service\",\n        label: \"Сайт или web-сервис\",\n        name: \"type-project\",\n        isChecked: true\n    },\n    {\n        id: \"internet-promotion\",\n        label: \"Интернет-продвижение\",\n        name: \"type-project\",\n        isChecked: false\n    },\n    {\n        id: \"Design-logo-or-branding\",\n        label: \"Дизайн, лого или брендинг\",\n        name: \"type-project\",\n        isChecked: false\n    }\n];\nvar inputs = [\n    {\n        placeholder: \"Имя *\",\n        id: \"name\",\n        name: \"name\",\n        type: \"text\"\n    },\n    {\n        placeholder: \"Телефон *\",\n        id: \"phone\",\n        name: \"phone\",\n        type: \"phone\"\n    }\n];\nvar call = {\n    title: \"Написать в RBAND\",\n    text: \"Расскажите о\\xa0своём проекте или предложении. Сообщение сразу попадёт к\\xa0нужному специалисту или руководителю.\",\n    switchers: switchers,\n    inputs: inputs\n};\nvar localesRegions = [\n    {\n        country: \"Srbija\",\n        href: \"/\",\n        cities: [\n            {\n                title: \"Beograd\",\n                href: \"/\"\n            },\n            {\n                title: \"Novi Sad\",\n                href: \"/\"\n            },\n            {\n                title: \"Niš\",\n                href: \"/\"\n            },\n            {\n                title: \"Kragujevac\",\n                href: \"/\"\n            },\n            {\n                title: \"Subotica\",\n                href: \"/\"\n            }\n        ]\n    },\n    {\n        country: \"Montenegro\",\n        href: \"/\",\n        cities: [\n            {\n                title: \"Bar\",\n                href: \"/\"\n            },\n            {\n                title: \"Podgorica\",\n                href: \"/\"\n            },\n            {\n                title: \"Tivat\",\n                href: \"/\"\n            },\n            {\n                title: \"Budva\",\n                href: \"/\"\n            },\n            {\n                title: \"Kotor\",\n                href: \"/\"\n            },\n            {\n                title: \"Herceg Novi\",\n                href: \"/\"\n            },\n            {\n                title: \"Nikšić\",\n                href: \"/\"\n            }\n        ]\n    },\n    {\n        country: \"Hrvatska\",\n        href: \"/\",\n        cities: [\n            {\n                title: \"Zagreb\",\n                href: \"/\"\n            },\n            {\n                title: \"Dubrovnik\",\n                href: \"/\"\n            },\n            {\n                title: \"Split\",\n                href: \"/\"\n            },\n            {\n                title: \"Rijeka\",\n                href: \"/\"\n            },\n            {\n                title: \"Zadar\",\n                href: \"/\"\n            }\n        ]\n    }\n];\nvar localesCountry = [\n    {\n        title: \"Русский\",\n        href: \"/\"\n    },\n    {\n        title: \"English\",\n        href: \"/\"\n    },\n    {\n        title: \"Srpski\",\n        href: \"/\"\n    }\n];\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2hlYWRlci9tZW51LmRhdGEudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUdPLElBQU1BLE9BQU87SUFDbkI7UUFDQ0MsTUFBTTtRQUNOQyxPQUFPO0lBQ1I7SUFDQTtRQUNDRCxNQUFNO1FBQ05DLE9BQU87SUFDUjtJQUNBO1FBQ0NELE1BQU07UUFDTkMsT0FBTztJQUNSO0lBQ0E7UUFDQ0QsTUFBTTtRQUNOQyxPQUFPO0lBQ1I7SUFDQTtRQUNDRCxNQUFNO1FBQ05DLE9BQU87SUFDUjtJQUNBO1FBQ0NELE1BQU07UUFDTkMsT0FBTztJQUNSO0NBQ0E7QUFFRCxJQUFNQyxZQUFpQztJQUN0QztRQUNDQyxJQUFJO1FBQ0pDLE9BQU87UUFDUEMsTUFBTTtRQUNOQyxXQUFXO0lBQ1o7SUFDQTtRQUNDSCxJQUFJO1FBQ0pDLE9BQU87UUFDUEMsTUFBTTtRQUNOQyxXQUFXO0lBQ1o7SUFDQTtRQUNDSCxJQUFJO1FBQ0pDLE9BQU87UUFDUEMsTUFBTTtRQUNOQyxXQUFXO0lBQ1o7Q0FDQTtBQUVELElBQU1DLFNBQTJCO0lBQ2hDO1FBQ0NDLGFBQWE7UUFDYkwsSUFBSTtRQUNKRSxNQUFNO1FBQ05JLE1BQU07SUFDUDtJQUNBO1FBQ0NELGFBQWE7UUFDYkwsSUFBSTtRQUNKRSxNQUFNO1FBQ05JLE1BQU07SUFDUDtDQUNBO0FBRU0sSUFBTUMsT0FBTztJQUNuQlQsT0FBTztJQUNQVSxNQUFNO0lBQ05ULFdBQVdBO0lBQ1hLLFFBQVFBO0FBQ1QsRUFBQztBQUVNLElBQU1LLGlCQUFpQjtJQUM3QjtRQUNDQyxTQUFTO1FBQ1RiLE1BQU07UUFDTmMsUUFBUTtZQUNQO2dCQUNDYixPQUFPO2dCQUNQRCxNQUFNO1lBQ1A7WUFDQTtnQkFDQ0MsT0FBTztnQkFDUEQsTUFBTTtZQUNQO1lBQ0E7Z0JBQ0NDLE9BQU87Z0JBQ1BELE1BQU07WUFDUDtZQUNBO2dCQUNDQyxPQUFPO2dCQUNQRCxNQUFNO1lBQ1A7WUFDQTtnQkFDQ0MsT0FBTztnQkFDUEQsTUFBTTtZQUNQO1NBQ0E7SUFDRjtJQUNBO1FBQ0NhLFNBQVM7UUFDVGIsTUFBTTtRQUNOYyxRQUFRO1lBQ1A7Z0JBQ0NiLE9BQU87Z0JBQ1BELE1BQU07WUFDUDtZQUNBO2dCQUNDQyxPQUFPO2dCQUNQRCxNQUFNO1lBQ1A7WUFDQTtnQkFDQ0MsT0FBTztnQkFDUEQsTUFBTTtZQUNQO1lBQ0E7Z0JBQ0NDLE9BQU87Z0JBQ1BELE1BQU07WUFDUDtZQUNBO2dCQUNDQyxPQUFPO2dCQUNQRCxNQUFNO1lBQ1A7WUFDQTtnQkFDQ0MsT0FBTztnQkFDUEQsTUFBTTtZQUNQO1lBQ0E7Z0JBQ0NDLE9BQU87Z0JBQ1BELE1BQU07WUFDUDtTQUNBO0lBQ0Y7SUFDQTtRQUNDYSxTQUFTO1FBQ1RiLE1BQU07UUFDTmMsUUFBUTtZQUNQO2dCQUNDYixPQUFPO2dCQUNQRCxNQUFNO1lBQ1A7WUFDQTtnQkFDQ0MsT0FBTztnQkFDUEQsTUFBTTtZQUNQO1lBQ0E7Z0JBQ0NDLE9BQU87Z0JBQ1BELE1BQU07WUFDUDtZQUNBO2dCQUNDQyxPQUFPO2dCQUNQRCxNQUFNO1lBQ1A7WUFDQTtnQkFDQ0MsT0FBTztnQkFDUEQsTUFBTTtZQUNQO1NBQ0E7SUFDRjtDQUNBO0FBQ00sSUFBTWUsaUJBQWlCO0lBQzdCO1FBQ0NkLE9BQU87UUFDUEQsTUFBTTtJQUNQO0lBQ0E7UUFDQ0MsT0FBTztRQUNQRCxNQUFNO0lBQ1A7SUFDQTtRQUNDQyxPQUFPO1FBQ1BELE1BQU07SUFDUDtDQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2hlYWRlci9tZW51LmRhdGEudHM/YTE2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUeXBlSW5wdXQgfSBmcm9tICcuLi91aS9pbnB1dC9pbnB1dC50eXBlcydcclxuaW1wb3J0IHsgVHlwZVN3aXRjaGVyIH0gZnJvbSAnLi4vdWkvc3dpdGNoZXIvc3dpdGNoZXIudHlwZXMnXHJcblxyXG5leHBvcnQgY29uc3QgbWVudSA9IFtcclxuXHR7XHJcblx0XHRocmVmOiAnL2FzZGFzJyxcclxuXHRcdHRpdGxlOiAn0KPRgdC70YPQs9C4J1xyXG5cdH0sXHJcblx0e1xyXG5cdFx0aHJlZjogJyMnLFxyXG5cdFx0dGl0bGU6ICfQnNGLJ1xyXG5cdH0sXHJcblx0e1xyXG5cdFx0aHJlZjogJyMnLFxyXG5cdFx0dGl0bGU6ICfQn9GA0L7QtdC60YLRiydcclxuXHR9LFxyXG5cdHtcclxuXHRcdGhyZWY6ICcjJyxcclxuXHRcdHRpdGxlOiAn0JHQu9C+0LMnXHJcblx0fSxcclxuXHR7XHJcblx0XHRocmVmOiAnIycsXHJcblx0XHR0aXRsZTogJ9Ce0YLQt9GL0LLRiydcclxuXHR9LFxyXG5cdHtcclxuXHRcdGhyZWY6ICcvY29udGFjdHMnLFxyXG5cdFx0dGl0bGU6ICfQmtC+0L3RgtCw0LrRgtGLJ1xyXG5cdH1cclxuXVxyXG5cclxuY29uc3Qgc3dpdGNoZXJzOiBBcnJheTxUeXBlU3dpdGNoZXI+ID0gW1xyXG5cdHtcclxuXHRcdGlkOiAnd2ViLXNlcnZpY2UnLFxyXG5cdFx0bGFiZWw6ICfQodCw0LnRgiDQuNC70Lggd2ViLdGB0LXRgNCy0LjRgScsXHJcblx0XHRuYW1lOiAndHlwZS1wcm9qZWN0JyxcclxuXHRcdGlzQ2hlY2tlZDogdHJ1ZVxyXG5cdH0sXHJcblx0e1xyXG5cdFx0aWQ6ICdpbnRlcm5ldC1wcm9tb3Rpb24nLFxyXG5cdFx0bGFiZWw6ICfQmNC90YLQtdGA0L3QtdGCLdC/0YDQvtC00LLQuNC20LXQvdC40LUnLFxyXG5cdFx0bmFtZTogJ3R5cGUtcHJvamVjdCcsXHJcblx0XHRpc0NoZWNrZWQ6IGZhbHNlXHJcblx0fSxcclxuXHR7XHJcblx0XHRpZDogJ0Rlc2lnbi1sb2dvLW9yLWJyYW5kaW5nJyxcclxuXHRcdGxhYmVsOiAn0JTQuNC30LDQudC9LCDQu9C+0LPQviDQuNC70Lgg0LHRgNC10L3QtNC40L3QsycsXHJcblx0XHRuYW1lOiAndHlwZS1wcm9qZWN0JyxcclxuXHRcdGlzQ2hlY2tlZDogZmFsc2VcclxuXHR9XHJcbl1cclxuXHJcbmNvbnN0IGlucHV0czogQXJyYXk8VHlwZUlucHV0PiA9IFtcclxuXHR7XHJcblx0XHRwbGFjZWhvbGRlcjogJ9CY0LzRjyAqJyxcclxuXHRcdGlkOiAnbmFtZScsXHJcblx0XHRuYW1lOiAnbmFtZScsXHJcblx0XHR0eXBlOiAndGV4dCdcclxuXHR9LFxyXG5cdHtcclxuXHRcdHBsYWNlaG9sZGVyOiAn0KLQtdC70LXRhNC+0L0gKicsXHJcblx0XHRpZDogJ3Bob25lJyxcclxuXHRcdG5hbWU6ICdwaG9uZScsXHJcblx0XHR0eXBlOiAncGhvbmUnXHJcblx0fVxyXG5dXHJcblxyXG5leHBvcnQgY29uc3QgY2FsbCA9IHtcclxuXHR0aXRsZTogJ9Cd0LDQv9C40YHQsNGC0Ywg0LIgUkJBTkQnLFxyXG5cdHRleHQ6ICfQoNCw0YHRgdC60LDQttC40YLQtSDQvsKg0YHQstC+0ZHQvCDQv9GA0L7QtdC60YLQtSDQuNC70Lgg0L/RgNC10LTQu9C+0LbQtdC90LjQuC4g0KHQvtC+0LHRidC10L3QuNC1INGB0YDQsNC30YMg0L/QvtC/0LDQtNGR0YIg0LrCoNC90YPQttC90L7QvNGDINGB0L/QtdGG0LjQsNC70LjRgdGC0YMg0LjQu9C4INGA0YPQutC+0LLQvtC00LjRgtC10LvRji4nLFxyXG5cdHN3aXRjaGVyczogc3dpdGNoZXJzLFxyXG5cdGlucHV0czogaW5wdXRzXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBsb2NhbGVzUmVnaW9ucyA9IFtcclxuXHR7XHJcblx0XHRjb3VudHJ5OiAnU3JiaWphJyxcclxuXHRcdGhyZWY6ICcvJyxcclxuXHRcdGNpdGllczogW1xyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGl0bGU6ICdCZW9ncmFkJyxcclxuXHRcdFx0XHRocmVmOiAnLydcclxuXHRcdFx0fSxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRpdGxlOiAnTm92aSBTYWQnLFxyXG5cdFx0XHRcdGhyZWY6ICcvJ1xyXG5cdFx0XHR9LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGl0bGU6ICdOacWhJyxcclxuXHRcdFx0XHRocmVmOiAnLydcclxuXHRcdFx0fSxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRpdGxlOiAnS3JhZ3VqZXZhYycsXHJcblx0XHRcdFx0aHJlZjogJy8nXHJcblx0XHRcdH0sXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aXRsZTogJ1N1Ym90aWNhJyxcclxuXHRcdFx0XHRocmVmOiAnLydcclxuXHRcdFx0fVxyXG5cdFx0XVxyXG5cdH0sXHJcblx0e1xyXG5cdFx0Y291bnRyeTogJ01vbnRlbmVncm8nLFxyXG5cdFx0aHJlZjogJy8nLFxyXG5cdFx0Y2l0aWVzOiBbXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aXRsZTogJ0JhcicsXHJcblx0XHRcdFx0aHJlZjogJy8nXHJcblx0XHRcdH0sXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aXRsZTogJ1BvZGdvcmljYScsXHJcblx0XHRcdFx0aHJlZjogJy8nXHJcblx0XHRcdH0sXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aXRsZTogJ1RpdmF0JyxcclxuXHRcdFx0XHRocmVmOiAnLydcclxuXHRcdFx0fSxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRpdGxlOiAnQnVkdmEnLFxyXG5cdFx0XHRcdGhyZWY6ICcvJ1xyXG5cdFx0XHR9LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGl0bGU6ICdLb3RvcicsXHJcblx0XHRcdFx0aHJlZjogJy8nXHJcblx0XHRcdH0sXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aXRsZTogJ0hlcmNlZyBOb3ZpJyxcclxuXHRcdFx0XHRocmVmOiAnLydcclxuXHRcdFx0fSxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRpdGxlOiAnTmlrxaFpxIcnLFxyXG5cdFx0XHRcdGhyZWY6ICcvJ1xyXG5cdFx0XHR9XHJcblx0XHRdXHJcblx0fSxcclxuXHR7XHJcblx0XHRjb3VudHJ5OiAnSHJ2YXRza2EnLFxyXG5cdFx0aHJlZjogJy8nLFxyXG5cdFx0Y2l0aWVzOiBbXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aXRsZTogJ1phZ3JlYicsXHJcblx0XHRcdFx0aHJlZjogJy8nXHJcblx0XHRcdH0sXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aXRsZTogJ0R1YnJvdm5paycsXHJcblx0XHRcdFx0aHJlZjogJy8nXHJcblx0XHRcdH0sXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aXRsZTogJ1NwbGl0JyxcclxuXHRcdFx0XHRocmVmOiAnLydcclxuXHRcdFx0fSxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRpdGxlOiAnUmlqZWthJyxcclxuXHRcdFx0XHRocmVmOiAnLydcclxuXHRcdFx0fSxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRpdGxlOiAnWmFkYXInLFxyXG5cdFx0XHRcdGhyZWY6ICcvJ1xyXG5cdFx0XHR9XHJcblx0XHRdXHJcblx0fVxyXG5dXHJcbmV4cG9ydCBjb25zdCBsb2NhbGVzQ291bnRyeSA9IFtcclxuXHR7XHJcblx0XHR0aXRsZTogJ9Cg0YPRgdGB0LrQuNC5JyxcclxuXHRcdGhyZWY6ICcvJ1xyXG5cdH0sXHJcblx0e1xyXG5cdFx0dGl0bGU6ICdFbmdsaXNoJyxcclxuXHRcdGhyZWY6ICcvJ1xyXG5cdH0sXHJcblx0e1xyXG5cdFx0dGl0bGU6ICdTcnBza2knLFxyXG5cdFx0aHJlZjogJy8nXHJcblx0fVxyXG5dXHJcbiJdLCJuYW1lcyI6WyJtZW51IiwiaHJlZiIsInRpdGxlIiwic3dpdGNoZXJzIiwiaWQiLCJsYWJlbCIsIm5hbWUiLCJpc0NoZWNrZWQiLCJpbnB1dHMiLCJwbGFjZWhvbGRlciIsInR5cGUiLCJjYWxsIiwidGV4dCIsImxvY2FsZXNSZWdpb25zIiwiY291bnRyeSIsImNpdGllcyIsImxvY2FsZXNDb3VudHJ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/header/menu.data.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/localization/Localization.tsx":
/*!******************************************************!*\
  !*** ./src/components/localization/Localization.tsx ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Localization: function() { return /* binding */ Localization; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/link.js\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./styles.module.scss */ \"(app-pages-browser)/./src/components/localization/styles.module.scss\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_styles_module_scss__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nfunction Localization(param) {\n    var _this = this;\n    var regions = param.regions, country = param.country;\n    console.log(regions, country);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default().localization),\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default().localization__container),\n            children: [\n                regions && regions.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default().localization__label),\n                            children: \"Выберите город\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\localization\\\\Localization.tsx\",\n                            lineNumber: 14,\n                            columnNumber: 7\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default().localization__locales),\n                            children: regions.length && regions.map(function(locale, index) {\n                                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default().localization__localesItem),\n                                    children: [\n                                        locale && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                            className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default().localization__localesItemCountry),\n                                            href: locale.href,\n                                            children: locale.country\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\localization\\\\Localization.tsx\",\n                                            lineNumber: 24,\n                                            columnNumber: 13\n                                        }, _this),\n                                        locale.cities.length > 0 && locale.cities.map(function(city) {\n                                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                                href: city.href,\n                                                className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default().localization__localesItemCity),\n                                                children: city.title\n                                            }, city.title, false, {\n                                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\localization\\\\Localization.tsx\",\n                                                lineNumber: 33,\n                                                columnNumber: 14\n                                            }, _this);\n                                        })\n                                    ]\n                                }, index, true, {\n                                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\localization\\\\Localization.tsx\",\n                                    lineNumber: 19,\n                                    columnNumber: 11\n                                }, _this);\n                            })\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\localization\\\\Localization.tsx\",\n                            lineNumber: 15,\n                            columnNumber: 7\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                            href: \"#\",\n                            className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default()[\"localization__anotherСity\"]),\n                            children: \"Drugi grad\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\localization\\\\Localization.tsx\",\n                            lineNumber: 45,\n                            columnNumber: 7\n                        }, this)\n                    ]\n                }, void 0, true),\n                country && country.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])((_styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default().localization__locales), (_styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default().localization__locales_centered)),\n                    children: country.map(function(count) {\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default().localization__localesItem),\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                href: count.href,\n                                className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default().localization__localesItemState),\n                                children: count.title\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\localization\\\\Localization.tsx\",\n                                lineNumber: 66,\n                                columnNumber: 9\n                            }, _this)\n                        }, count.title, false, {\n                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\localization\\\\Localization.tsx\",\n                            lineNumber: 62,\n                            columnNumber: 8\n                        }, _this);\n                    })\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\localization\\\\Localization.tsx\",\n                    lineNumber: 55,\n                    columnNumber: 6\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\localization\\\\Localization.tsx\",\n            lineNumber: 11,\n            columnNumber: 4\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\localization\\\\Localization.tsx\",\n        lineNumber: 10,\n        columnNumber: 3\n    }, this);\n}\n_c = Localization;\nvar _c;\n$RefreshReg$(_c, \"Localization\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2xvY2FsaXphdGlvbi9Mb2NhbGl6YXRpb24udHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBcUI7QUFDTztBQUdjO0FBRW5DLFNBQVNHLGFBQWEsS0FBbUM7O1FBQWpDQyxVQUFGLE1BQUVBLFNBQVNDLFVBQVgsTUFBV0E7SUFDdkNDLFFBQVFDLEdBQUcsQ0FBQ0gsU0FBU0M7SUFDckIscUJBQ0MsOERBQUNHO1FBQUlDLFdBQVdQLHlFQUFvQjtrQkFDbkMsNEVBQUNNO1lBQUlDLFdBQVdQLG9GQUErQjs7Z0JBQzdDRSxXQUFXQSxRQUFRUSxNQUFNLEdBQUcsbUJBQzVCOztzQ0FDQyw4REFBQ0o7NEJBQUlDLFdBQVdQLGdGQUEyQjtzQ0FBRTs7Ozs7O3NDQUM3Qyw4REFBQ007NEJBQUlDLFdBQVdQLGtGQUE2QjtzQ0FDM0NFLFFBQVFRLE1BQU0sSUFDZFIsUUFBUVcsR0FBRyxDQUFDLFNBQUNDLFFBQVFDO2dDQUNwQixxQkFDQyw4REFBQ1Q7b0NBQ0FDLFdBQVdQLHNGQUFpQzs7d0NBRzNDYyx3QkFDQSw4REFBQ2YsaURBQUlBOzRDQUNKUSxXQUFXUCw2RkFBd0M7NENBQ25Ea0IsTUFBTUosT0FBT0ksSUFBSTtzREFFaEJKLE9BQU9YLE9BQU87Ozs7Ozt3Q0FHaEJXLE9BQU9LLE1BQU0sQ0FBQ1QsTUFBTSxHQUFHLEtBQ3ZCSSxPQUFPSyxNQUFNLENBQUNOLEdBQUcsQ0FBQ08sU0FBQUE7aUVBQ2pCLDhEQUFDckIsaURBQUlBO2dEQUVKbUIsTUFBTUUsS0FBS0YsSUFBSTtnREFDZlgsV0FBV1AsMEZBQXFDOzBEQUUvQ29CLEtBQUtFLEtBQUs7K0NBSk5GLEtBQUtFLEtBQUs7Ozs7Ozs7bUNBYmJQOzs7Ozs0QkFzQlI7Ozs7OztzQ0FFRiw4REFBQ2hCLGlEQUFJQTs0QkFDSm1CLE1BQUs7NEJBQ0xYLFdBQVdQLHlGQUFpQztzQ0FDNUM7Ozs7Ozs7O2dCQU1GRyxXQUFXQSxRQUFRTyxNQUFNLEdBQUcsbUJBQzVCLDhEQUFDSjtvQkFDQUMsV0FBV1QsZ0RBQUVBLENBQ1pFLGtGQUE2QixFQUM3QkEsMkZBQXNDOzhCQUd0Q0csUUFBUVUsR0FBRyxDQUFDWSxTQUFBQTs2Q0FDWiw4REFBQ25COzRCQUNBQyxXQUFXUCxzRkFBaUM7c0NBRzVDLDRFQUFDRCxpREFBSUE7Z0NBQ0ptQixNQUFNTyxNQUFNUCxJQUFJO2dDQUNoQlgsV0FBV1AsMkZBQXNDOzBDQUVoRHlCLE1BQU1ILEtBQUs7Ozs7OzsyQkFOUkcsTUFBTUgsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWV4QjtLQXhFZ0JyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9sb2NhbGl6YXRpb24vTG9jYWxpemF0aW9uLnRzeD9jMmU0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjbiBmcm9tICdjbHN4J1xyXG5pbXBvcnQgTGluayBmcm9tICduZXh0L2xpbmsnXHJcblxyXG5pbXBvcnQgeyBJTG9jYWxpemF0aW9uIH0gZnJvbSAnLi9sb2NhbGl6YXRpb24udHlwZXMnXHJcbmltcG9ydCBjbGFzc2VzIGZyb20gJy4vc3R5bGVzLm1vZHVsZS5zY3NzJ1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIExvY2FsaXphdGlvbih7IHJlZ2lvbnMsIGNvdW50cnkgfTogSUxvY2FsaXphdGlvbikge1xyXG5cdGNvbnNvbGUubG9nKHJlZ2lvbnMsIGNvdW50cnkpXHJcblx0cmV0dXJuIChcclxuXHRcdDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzLmxvY2FsaXphdGlvbn0+XHJcblx0XHRcdDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzLmxvY2FsaXphdGlvbl9fY29udGFpbmVyfT5cclxuXHRcdFx0XHR7cmVnaW9ucyAmJiByZWdpb25zLmxlbmd0aCA+IDAgJiYgKFxyXG5cdFx0XHRcdFx0PD5cclxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMubG9jYWxpemF0aW9uX19sYWJlbH0+0JLRi9Cx0LXRgNC40YLQtSDQs9C+0YDQvtC0PC9kaXY+XHJcblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzLmxvY2FsaXphdGlvbl9fbG9jYWxlc30+XHJcblx0XHRcdFx0XHRcdFx0e3JlZ2lvbnMubGVuZ3RoICYmXHJcblx0XHRcdFx0XHRcdFx0XHRyZWdpb25zLm1hcCgobG9jYWxlLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxkaXZcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17Y2xhc3Nlcy5sb2NhbGl6YXRpb25fX2xvY2FsZXNJdGVtfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5PXtpbmRleH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ+XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7bG9jYWxlICYmIChcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PExpbmtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzZXMubG9jYWxpemF0aW9uX19sb2NhbGVzSXRlbUNvdW50cnl9XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aHJlZj17bG9jYWxlLmhyZWZ9XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdD5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7bG9jYWxlLmNvdW50cnl9XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvTGluaz5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCl9XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7bG9jYWxlLmNpdGllcy5sZW5ndGggPiAwICYmXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGxvY2FsZS5jaXRpZXMubWFwKGNpdHkgPT4gKFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxMaW5rXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRrZXk9e2NpdHkudGl0bGV9XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRocmVmPXtjaXR5LmhyZWZ9XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzZXMubG9jYWxpemF0aW9uX19sb2NhbGVzSXRlbUNpdHl9XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0e2NpdHkudGl0bGV9XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PC9MaW5rPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpKX1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdFx0XHRcdFx0KVxyXG5cdFx0XHRcdFx0XHRcdFx0fSl9XHJcblx0XHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdFx0XHQ8TGlua1xyXG5cdFx0XHRcdFx0XHRcdGhyZWY9JyMnXHJcblx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc2VzLmxvY2FsaXphdGlvbl9fYW5vdGhlctChaXR5fVxyXG5cdFx0XHRcdFx0XHQ+XHJcblx0XHRcdFx0XHRcdFx0RHJ1Z2kgZ3JhZFxyXG5cdFx0XHRcdFx0XHQ8L0xpbms+XHJcblx0XHRcdFx0XHQ8Lz5cclxuXHRcdFx0XHQpfVxyXG5cclxuXHRcdFx0XHR7Y291bnRyeSAmJiBjb3VudHJ5Lmxlbmd0aCA+IDAgJiYgKFxyXG5cdFx0XHRcdFx0PGRpdlxyXG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9e2NuKFxyXG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMubG9jYWxpemF0aW9uX19sb2NhbGVzLFxyXG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMubG9jYWxpemF0aW9uX19sb2NhbGVzX2NlbnRlcmVkXHJcblx0XHRcdFx0XHRcdCl9XHJcblx0XHRcdFx0XHQ+XHJcblx0XHRcdFx0XHRcdHtjb3VudHJ5Lm1hcChjb3VudCA9PiAoXHJcblx0XHRcdFx0XHRcdFx0PGRpdlxyXG5cdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc2VzLmxvY2FsaXphdGlvbl9fbG9jYWxlc0l0ZW19XHJcblx0XHRcdFx0XHRcdFx0XHRrZXk9e2NvdW50LnRpdGxlfVxyXG5cdFx0XHRcdFx0XHRcdD5cclxuXHRcdFx0XHRcdFx0XHRcdDxMaW5rXHJcblx0XHRcdFx0XHRcdFx0XHRcdGhyZWY9e2NvdW50LmhyZWZ9XHJcblx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17Y2xhc3Nlcy5sb2NhbGl6YXRpb25fX2xvY2FsZXNJdGVtU3RhdGV9XHJcblx0XHRcdFx0XHRcdFx0XHQ+XHJcblx0XHRcdFx0XHRcdFx0XHRcdHtjb3VudC50aXRsZX1cclxuXHRcdFx0XHRcdFx0XHRcdDwvTGluaz5cclxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdFx0KSl9XHJcblx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHQpfVxyXG5cdFx0XHQ8L2Rpdj5cclxuXHRcdDwvZGl2PlxyXG5cdClcclxufVxyXG4iXSwibmFtZXMiOlsiY24iLCJMaW5rIiwiY2xhc3NlcyIsIkxvY2FsaXphdGlvbiIsInJlZ2lvbnMiLCJjb3VudHJ5IiwiY29uc29sZSIsImxvZyIsImRpdiIsImNsYXNzTmFtZSIsImxvY2FsaXphdGlvbiIsImxvY2FsaXphdGlvbl9fY29udGFpbmVyIiwibGVuZ3RoIiwibG9jYWxpemF0aW9uX19sYWJlbCIsImxvY2FsaXphdGlvbl9fbG9jYWxlcyIsIm1hcCIsImxvY2FsZSIsImluZGV4IiwibG9jYWxpemF0aW9uX19sb2NhbGVzSXRlbSIsImxvY2FsaXphdGlvbl9fbG9jYWxlc0l0ZW1Db3VudHJ5IiwiaHJlZiIsImNpdGllcyIsImNpdHkiLCJsb2NhbGl6YXRpb25fX2xvY2FsZXNJdGVtQ2l0eSIsInRpdGxlIiwibG9jYWxpemF0aW9uX19hbm90aGVy0KFpdHkiLCJsb2NhbGl6YXRpb25fX2xvY2FsZXNfY2VudGVyZWQiLCJjb3VudCIsImxvY2FsaXphdGlvbl9fbG9jYWxlc0l0ZW1TdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/localization/Localization.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/IconComponent/IconComponent.tsx":
/*!***********************************************************!*\
  !*** ./src/components/ui/IconComponent/IconComponent.tsx ***!
  \***********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IconComponent: function() { return /* binding */ IconComponent; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _iconify_react_dist_iconify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iconify/react/dist/iconify.js */ \"(app-pages-browser)/./node_modules/.pnpm/@iconify+react@4.1.1_react@18.3.1/node_modules/@iconify/react/dist/iconify.js\");\n/* __next_internal_client_entry_do_not_use__ IconComponent auto */ \n\nfunction IconComponent(param) {\n    var icon = param.icon;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_iconify_react_dist_iconify_js__WEBPACK_IMPORTED_MODULE_1__.Icon, {\n        icon: icon,\n        children: \"Icon\"\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\IconComponent\\\\IconComponent.tsx\",\n        lineNumber: 6,\n        columnNumber: 9\n    }, this);\n}\n_c = IconComponent;\nvar _c;\n$RefreshReg$(_c, \"IconComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL0ljb25Db21wb25lbnQvSWNvbkNvbXBvbmVudC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUVxRDtBQUU5QyxTQUFTQyxjQUFjLEtBQTBCO1FBQTFCLGFBQUVDO0lBQy9CLHFCQUFPLDhEQUFDRixnRUFBSUE7UUFBQ0UsTUFBTUE7a0JBQU07Ozs7OztBQUMxQjtLQUZnQkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdWkvSWNvbkNvbXBvbmVudC9JY29uQ29tcG9uZW50LnRzeD8yYWYwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG5cclxuaW1wb3J0IHsgSWNvbiB9IGZyb20gJ0BpY29uaWZ5L3JlYWN0L2Rpc3QvaWNvbmlmeS5qcydcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBJY29uQ29tcG9uZW50KHsgaWNvbiB9OiB7IGljb246IHN0cmluZyB9KSB7XHJcblx0cmV0dXJuIDxJY29uIGljb249e2ljb259Pkljb248L0ljb24+XHJcbn1cclxuIl0sIm5hbWVzIjpbIkljb24iLCJJY29uQ29tcG9uZW50IiwiaWNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/IconComponent/IconComponent.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/button/Button.tsx":
/*!*********************************************!*\
  !*** ./src/components/ui/button/Button.tsx ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: function() { return /* binding */ Button; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _gsap_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @gsap/react */ \"(app-pages-browser)/./node_modules/.pnpm/@gsap+react@2.1.1/node_modules/@gsap/react/src/index.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var gsap_all__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gsap/all */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/all.js\");\n/* harmony import */ var gsap_all__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! gsap/all */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Observer.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _Button_module_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Button.module.scss */ \"(app-pages-browser)/./src/components/ui/button/Button.module.scss\");\n/* harmony import */ var _Button_module_scss__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_Button_module_scss__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ Button auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\ngsap_all__WEBPACK_IMPORTED_MODULE_5__[\"default\"].registerPlugin(gsap_all__WEBPACK_IMPORTED_MODULE_6__.Observer);\nfunction Button(param) {\n    var className = param.className, children = param.children;\n    _s();\n    var buttonRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    var followerRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    (0,_gsap_react__WEBPACK_IMPORTED_MODULE_1__.useGSAP)(function() {\n        gsap_all__WEBPACK_IMPORTED_MODULE_6__.Observer.create({\n            target: buttonRef.current,\n            type: \"pointer\",\n            onMove: function(self) {\n                gsap_all__WEBPACK_IMPORTED_MODULE_5__[\"default\"].to(followerRef.current, {\n                    duration: 0,\n                    delay: 0,\n                    translateX: // @ts-ignore\n                    self.event.layerX / buttonRef.current.clientWidth * 100 + \"%\",\n                    translateY: // @ts-ignore\n                    self.event.layerY / buttonRef.current.clientHeight * 100 + \"%\"\n                });\n            },\n            onHover: function(self) {\n                gsap_all__WEBPACK_IMPORTED_MODULE_5__[\"default\"].to(followerRef.current, {\n                    duration: 0.3,\n                    delay: 0,\n                    scale: 1\n                });\n            },\n            onHoverEnd: function(self) {\n                gsap_all__WEBPACK_IMPORTED_MODULE_5__[\"default\"].to(followerRef.current, {\n                    duration: 0.3,\n                    delay: 0,\n                    scale: 0\n                });\n            }\n        });\n    }, {\n        scope: buttonRef,\n        dependencies: []\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])((_Button_module_scss__WEBPACK_IMPORTED_MODULE_4___default().button), className),\n        ref: buttonRef,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_Button_module_scss__WEBPACK_IMPORTED_MODULE_4___default().button__follower),\n                ref: followerRef\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\button\\\\Button.tsx\",\n                lineNumber: 60,\n                columnNumber: 4\n            }, this),\n            children\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\button\\\\Button.tsx\",\n        lineNumber: 56,\n        columnNumber: 3\n    }, this);\n}\n_s(Button, \"TyTrjn40Km3a6xFdnGkidyihL4w=\", false, function() {\n    return [\n        _gsap_react__WEBPACK_IMPORTED_MODULE_1__.useGSAP\n    ];\n});\n_c = Button;\nvar _c;\n$RefreshReg$(_c, \"Button\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL2J1dHRvbi9CdXR0b24udHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUVxQztBQUNoQjtBQUNvQjtBQUN3QjtBQUV2QjtBQUUxQ0UsZ0RBQUlBLENBQUNJLGNBQWMsQ0FBQ0gsOENBQVFBO0FBRXJCLFNBQVNJLE9BQU8sS0FHa0Q7UUFGeEVDLFlBRHNCLE1BQ3RCQSxXQUNBQyxXQUZzQixNQUV0QkE7O0lBRUEsSUFBTUMsWUFBWU4sNkNBQU1BO0lBQ3hCLElBQU1PLGNBQWNQLDZDQUFNQTtJQUUxQkosb0RBQU9BLENBQ047UUFDQ0csOENBQVFBLENBQUNTLE1BQU0sQ0FBQztZQUNmQyxRQUFRSCxVQUFVSSxPQUFPO1lBQ3pCQyxNQUFNO1lBRU5DLFFBQVEsU0FBQ0M7Z0JBQ1JmLGdEQUFJQSxDQUFDZ0IsRUFBRSxDQUFDUCxZQUFZRyxPQUFPLEVBQUU7b0JBQzVCSyxVQUFVO29CQUNWQyxPQUFPO29CQUNQQyxZQUVDLGFBRGE7b0JBQ1pKLEtBQUtLLEtBQUssQ0FBQ0MsTUFBTSxHQUFHYixVQUFVSSxPQUFPLENBQUNVLFdBQVcsR0FBSSxNQUFNO29CQUM3REMsWUFFQyxhQURhO29CQUNaUixLQUFLSyxLQUFLLENBQUNJLE1BQU0sR0FBR2hCLFVBQVVJLE9BQU8sQ0FBQ2EsWUFBWSxHQUFJLE1BQU07Z0JBQy9EO1lBQ0Q7WUFDQUMsU0FBUyxTQUFDWDtnQkFDVGYsZ0RBQUlBLENBQUNnQixFQUFFLENBQUNQLFlBQVlHLE9BQU8sRUFBRTtvQkFDNUJLLFVBQVU7b0JBQ1ZDLE9BQU87b0JBQ1BTLE9BQU87Z0JBQ1I7WUFDRDtZQUNBQyxZQUFZLFNBQUNiO2dCQUNaZixnREFBSUEsQ0FBQ2dCLEVBQUUsQ0FBQ1AsWUFBWUcsT0FBTyxFQUFFO29CQUM1QkssVUFBVTtvQkFDVkMsT0FBTztvQkFDUFMsT0FBTztnQkFDUjtZQUNEO1FBQ0Q7SUFDRCxHQUNBO1FBQUVFLE9BQU9yQjtRQUFXc0IsY0FBYyxFQUFFO0lBQUM7SUFFdEMscUJBQ0MsOERBQUNDO1FBQ0F6QixXQUFXUCxnREFBRUEsQ0FBQ0ksbUVBQWMsRUFBRUc7UUFDOUIwQixLQUFLeEI7OzBCQUVMLDhEQUFDeUI7Z0JBQ0EzQixXQUFXSCw2RUFBd0I7Z0JBQ25DNkIsS0FBS3ZCOzs7Ozs7WUFFTEY7Ozs7Ozs7QUFHSjtHQXZEZ0JGOztRQU9mUCxnREFBT0E7OztLQVBRTyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy91aS9idXR0b24vQnV0dG9uLnRzeD9kZjBiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG5cclxuaW1wb3J0IHsgdXNlR1NBUCB9IGZyb20gJ0Bnc2FwL3JlYWN0J1xyXG5pbXBvcnQgY24gZnJvbSAnY2xzeCdcclxuaW1wb3J0IGdzYXAsIHsgT2JzZXJ2ZXIgfSBmcm9tICdnc2FwL2FsbCdcclxuaW1wb3J0IHsgSFRNTEF0dHJpYnV0ZXMsIFByb3BzV2l0aENoaWxkcmVuLCB1c2VSZWYgfSBmcm9tICdyZWFjdCdcclxuXHJcbmltcG9ydCBjbGFzc2VzIGZyb20gJy4vQnV0dG9uLm1vZHVsZS5zY3NzJ1xyXG5cclxuZ3NhcC5yZWdpc3RlclBsdWdpbihPYnNlcnZlcilcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBCdXR0b24oe1xyXG5cdGNsYXNzTmFtZSxcclxuXHRjaGlsZHJlblxyXG59OiBQcm9wc1dpdGhDaGlsZHJlbjxIVE1MQXR0cmlidXRlczxIVE1MQnV0dG9uRWxlbWVudCB8IEhUTUxMaW5rRWxlbWVudD4+KSB7XHJcblx0Y29uc3QgYnV0dG9uUmVmID0gdXNlUmVmPGFueT4oKVxyXG5cdGNvbnN0IGZvbGxvd2VyUmVmID0gdXNlUmVmPGFueT4oKVxyXG5cclxuXHR1c2VHU0FQKFxyXG5cdFx0KCkgPT4ge1xyXG5cdFx0XHRPYnNlcnZlci5jcmVhdGUoe1xyXG5cdFx0XHRcdHRhcmdldDogYnV0dG9uUmVmLmN1cnJlbnQsXHJcblx0XHRcdFx0dHlwZTogJ3BvaW50ZXInLFxyXG5cclxuXHRcdFx0XHRvbk1vdmU6IChzZWxmOiBPYnNlcnZlcikgPT4ge1xyXG5cdFx0XHRcdFx0Z3NhcC50byhmb2xsb3dlclJlZi5jdXJyZW50LCB7XHJcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiAwLFxyXG5cdFx0XHRcdFx0XHRkZWxheTogMCxcclxuXHRcdFx0XHRcdFx0dHJhbnNsYXRlWDpcclxuXHRcdFx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHRcdFx0XHRcdFx0KHNlbGYuZXZlbnQubGF5ZXJYIC8gYnV0dG9uUmVmLmN1cnJlbnQuY2xpZW50V2lkdGgpICogMTAwICsgJyUnLFxyXG5cdFx0XHRcdFx0XHR0cmFuc2xhdGVZOlxyXG5cdFx0XHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdFx0XHRcdFx0XHQoc2VsZi5ldmVudC5sYXllclkgLyBidXR0b25SZWYuY3VycmVudC5jbGllbnRIZWlnaHQpICogMTAwICsgJyUnXHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0b25Ib3ZlcjogKHNlbGY6IE9ic2VydmVyKSA9PiB7XHJcblx0XHRcdFx0XHRnc2FwLnRvKGZvbGxvd2VyUmVmLmN1cnJlbnQsIHtcclxuXHRcdFx0XHRcdFx0ZHVyYXRpb246IDAuMyxcclxuXHRcdFx0XHRcdFx0ZGVsYXk6IDAsXHJcblx0XHRcdFx0XHRcdHNjYWxlOiAxXHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0b25Ib3ZlckVuZDogKHNlbGY6IE9ic2VydmVyKSA9PiB7XHJcblx0XHRcdFx0XHRnc2FwLnRvKGZvbGxvd2VyUmVmLmN1cnJlbnQsIHtcclxuXHRcdFx0XHRcdFx0ZHVyYXRpb246IDAuMyxcclxuXHRcdFx0XHRcdFx0ZGVsYXk6IDAsXHJcblx0XHRcdFx0XHRcdHNjYWxlOiAwXHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSlcclxuXHRcdH0sXHJcblx0XHR7IHNjb3BlOiBidXR0b25SZWYsIGRlcGVuZGVuY2llczogW10gfVxyXG5cdClcclxuXHRyZXR1cm4gKFxyXG5cdFx0PGJ1dHRvblxyXG5cdFx0XHRjbGFzc05hbWU9e2NuKGNsYXNzZXMuYnV0dG9uLCBjbGFzc05hbWUpfVxyXG5cdFx0XHRyZWY9e2J1dHRvblJlZn1cclxuXHRcdD5cclxuXHRcdFx0PGRpdlxyXG5cdFx0XHRcdGNsYXNzTmFtZT17Y2xhc3Nlcy5idXR0b25fX2ZvbGxvd2VyfVxyXG5cdFx0XHRcdHJlZj17Zm9sbG93ZXJSZWZ9XHJcblx0XHRcdD48L2Rpdj5cclxuXHRcdFx0e2NoaWxkcmVufVxyXG5cdFx0PC9idXR0b24+XHJcblx0KVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VHU0FQIiwiY24iLCJnc2FwIiwiT2JzZXJ2ZXIiLCJ1c2VSZWYiLCJjbGFzc2VzIiwicmVnaXN0ZXJQbHVnaW4iLCJCdXR0b24iLCJjbGFzc05hbWUiLCJjaGlsZHJlbiIsImJ1dHRvblJlZiIsImZvbGxvd2VyUmVmIiwiY3JlYXRlIiwidGFyZ2V0IiwiY3VycmVudCIsInR5cGUiLCJvbk1vdmUiLCJzZWxmIiwidG8iLCJkdXJhdGlvbiIsImRlbGF5IiwidHJhbnNsYXRlWCIsImV2ZW50IiwibGF5ZXJYIiwiY2xpZW50V2lkdGgiLCJ0cmFuc2xhdGVZIiwibGF5ZXJZIiwiY2xpZW50SGVpZ2h0Iiwib25Ib3ZlciIsInNjYWxlIiwib25Ib3ZlckVuZCIsInNjb3BlIiwiZGVwZW5kZW5jaWVzIiwiYnV0dG9uIiwicmVmIiwiZGl2IiwiYnV0dG9uX19mb2xsb3dlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/button/Button.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/container/Container.tsx":
/*!***************************************************!*\
  !*** ./src/components/ui/container/Container.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Container: function() { return /* binding */ Container; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\n/* harmony import */ var _swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\n/* harmony import */ var _swc_helpers_object_without_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_without_properties.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var _Styles_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Styles.scss */ \"(app-pages-browser)/./src/components/ui/container/Styles.scss\");\n\n\n\n\n\n\nfunction Container(_param) {\n    var variant = _param.variant, children = _param.children, className = _param.className, rest = (0,_swc_helpers_object_without_properties__WEBPACK_IMPORTED_MODULE_3__._)(_param, [\n        \"variant\",\n        \"children\",\n        \"className\"\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_4__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_5__._)({\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(variant ? \"container-\" + variant : \"container\", className)\n    }, rest), {\n        children: children\n    }), void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\container\\\\Container.tsx\",\n        lineNumber: 12,\n        columnNumber: 3\n    }, this);\n}\n_c = Container;\nvar _c;\n$RefreshReg$(_c, \"Container\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL2NvbnRhaW5lci9Db250YWluZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXNCO0FBQ0M7QUFHaEIsU0FBU0MsVUFBVTtRQUN6QkMsVUFEeUIsT0FDekJBLFNBQ0FDLFdBRnlCLE9BRXpCQSxVQUNBQyxZQUh5QixPQUd6QkEsV0FDR0MsT0FBQUEseUVBQUFBLENBSnNCO1FBQ3pCSDtRQUNBQztRQUNBQzs7SUFHQSxxQkFDQyw4REFBQ0UsT0FBQUEsbUVBQUFBLENBQUFBLDZEQUFBQTtRQUNBRixXQUFXSixnREFBRUEsQ0FBQ0UsVUFBVSxlQUFlQSxVQUFVLGFBQWFFO09BQzFEQztrQkFFSEY7Ozs7OztBQUdKO0tBZGdCRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy91aS9jb250YWluZXIvQ29udGFpbmVyLnRzeD8zZmVlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjbiBmcm9tICdjbHN4JztcclxuaW1wb3J0ICcuL1N0eWxlcy5zY3NzJztcclxuaW1wb3J0IHsgSUNvbnRhaW5lciB9IGZyb20gJy4vY29udGFpbmVyLnR5cGVzJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDb250YWluZXIoe1xyXG5cdHZhcmlhbnQsXHJcblx0Y2hpbGRyZW4sXHJcblx0Y2xhc3NOYW1lLFxyXG5cdC4uLnJlc3RcclxufTogSUNvbnRhaW5lcikge1xyXG5cdHJldHVybiAoXHJcblx0XHQ8ZGl2XHJcblx0XHRcdGNsYXNzTmFtZT17Y24odmFyaWFudCA/ICdjb250YWluZXItJyArIHZhcmlhbnQgOiAnY29udGFpbmVyJywgY2xhc3NOYW1lKX1cclxuXHRcdFx0ey4uLnJlc3R9XHJcblx0XHQ+XHJcblx0XHRcdHtjaGlsZHJlbn1cclxuXHRcdDwvZGl2PlxyXG5cdCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbImNuIiwiQ29udGFpbmVyIiwidmFyaWFudCIsImNoaWxkcmVuIiwiY2xhc3NOYW1lIiwicmVzdCIsImRpdiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/container/Container.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/input/Input.tsx":
/*!*******************************************!*\
  !*** ./src/components/ui/input/Input.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Input: function() { return /* binding */ Input; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\n/* harmony import */ var _swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\n/* harmony import */ var _swc_helpers_object_without_properties__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_without_properties.js\");\n/* harmony import */ var _swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _input_module_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./input.module.scss */ \"(app-pages-browser)/./src/components/ui/input/input.module.scss\");\n/* harmony import */ var _input_module_scss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_input_module_scss__WEBPACK_IMPORTED_MODULE_3__);\n/* __next_internal_client_entry_do_not_use__ Input auto */ \n\n\n\n\nvar _s = $RefreshSig$();\n\n\n\nfunction Input(_param) {\n    var placeholder = _param.placeholder, className = _param.className, rest = (0,_swc_helpers_object_without_properties__WEBPACK_IMPORTED_MODULE_4__._)(_param, [\n        \"placeholder\",\n        \"className\"\n    ]);\n    _s();\n    var _useState = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_5__._)((0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false), 2), isFocused = _useState[0], setIsFocused = _useState[1];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])((_input_module_scss__WEBPACK_IMPORTED_MODULE_3___default().input), isFocused && (_input_module_scss__WEBPACK_IMPORTED_MODULE_3___default().input_focused), className),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                htmlFor: rest.id,\n                className: (_input_module_scss__WEBPACK_IMPORTED_MODULE_3___default().input__label),\n                children: placeholder\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\input\\\\Input.tsx\",\n                lineNumber: 19,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_6__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_7__._)({}, rest), {\n                onFocus: function() {\n                    return setIsFocused(true);\n                },\n                onBlur: function(e) {\n                    return !e.target.value && setIsFocused(!isFocused);\n                },\n                className: (_input_module_scss__WEBPACK_IMPORTED_MODULE_3___default().input__input)\n            }), void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\input\\\\Input.tsx\",\n                lineNumber: 25,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\input\\\\Input.tsx\",\n        lineNumber: 12,\n        columnNumber: 3\n    }, this);\n}\n_s(Input, \"taoS6m9NZex5dx3pinefKTdpShE=\");\n_c = Input;\nvar _c;\n$RefreshReg$(_c, \"Input\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL2lucHV0L0lucHV0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVxQjtBQUNXO0FBRVM7QUFHbEMsU0FBU0csTUFBTTtRQUFFQyxjQUFGLE9BQUVBLGFBQWFDLFlBQWYsT0FBZUEsV0FBY0MsT0FBQUEseUVBQUFBLENBQTdCO1FBQUVGO1FBQWFDOzs7SUFDcEMsSUFBa0NKLFlBQUFBLCtEQUFBQSxDQUFBQSwrQ0FBUUEsQ0FBQyxZQUFwQ00sWUFBMkJOLGNBQWhCTyxlQUFnQlA7SUFDbEMscUJBQ0MsOERBQUNRO1FBQ0FKLFdBQVdMLGdEQUFFQSxDQUNaRSxpRUFBYSxFQUNiSyxhQUFhTCx5RUFBcUIsRUFDbENHOzswQkFHRCw4REFBQ087Z0JBQ0FDLFNBQVNQLEtBQUtRLEVBQUU7Z0JBQ2hCVCxXQUFXSCx3RUFBb0I7MEJBRTlCRTs7Ozs7OzBCQUVGLDhEQUFDTSxTQUFBQSxtRUFBQUEsQ0FBQUEsNkRBQUFBLEtBQ0lKO2dCQUNKVSxTQUFTOzJCQUFNUixhQUFhOztnQkFDNUJTLFFBQVFDLFNBQUFBOzJCQUFLLENBQUNBLEVBQUVDLE1BQU0sQ0FBQ0MsS0FBSyxJQUFJWixhQUFhLENBQUNEOztnQkFDOUNGLFdBQVdILHdFQUFvQjs7Ozs7Ozs7Ozs7O0FBSW5DO0dBeEJnQkM7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdWkvaW5wdXQvSW5wdXQudHN4P2NlYjYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXHJcblxyXG5pbXBvcnQgY24gZnJvbSAnY2xzeCdcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcclxuXHJcbmltcG9ydCBjbGFzc2VzIGZyb20gJy4vaW5wdXQubW9kdWxlLnNjc3MnXHJcbmltcG9ydCB7IFR5cGVJbnB1dCB9IGZyb20gJy4vaW5wdXQudHlwZXMnXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gSW5wdXQoeyBwbGFjZWhvbGRlciwgY2xhc3NOYW1lLCAuLi5yZXN0IH06IFR5cGVJbnB1dCkge1xyXG5cdGNvbnN0IFtpc0ZvY3VzZWQsIHNldElzRm9jdXNlZF0gPSB1c2VTdGF0ZShmYWxzZSlcclxuXHRyZXR1cm4gKFxyXG5cdFx0PGRpdlxyXG5cdFx0XHRjbGFzc05hbWU9e2NuKFxyXG5cdFx0XHRcdGNsYXNzZXMuaW5wdXQsXHJcblx0XHRcdFx0aXNGb2N1c2VkICYmIGNsYXNzZXMuaW5wdXRfZm9jdXNlZCxcclxuXHRcdFx0XHRjbGFzc05hbWVcclxuXHRcdFx0KX1cclxuXHRcdD5cclxuXHRcdFx0PGxhYmVsXHJcblx0XHRcdFx0aHRtbEZvcj17cmVzdC5pZH1cclxuXHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzZXMuaW5wdXRfX2xhYmVsfVxyXG5cdFx0XHQ+XHJcblx0XHRcdFx0e3BsYWNlaG9sZGVyfVxyXG5cdFx0XHQ8L2xhYmVsPlxyXG5cdFx0XHQ8aW5wdXRcclxuXHRcdFx0XHR7Li4ucmVzdH1cclxuXHRcdFx0XHRvbkZvY3VzPXsoKSA9PiBzZXRJc0ZvY3VzZWQodHJ1ZSl9XHJcblx0XHRcdFx0b25CbHVyPXtlID0+ICFlLnRhcmdldC52YWx1ZSAmJiBzZXRJc0ZvY3VzZWQoIWlzRm9jdXNlZCl9XHJcblx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc2VzLmlucHV0X19pbnB1dH1cclxuXHRcdFx0Lz5cclxuXHRcdDwvZGl2PlxyXG5cdClcclxufVxyXG4iXSwibmFtZXMiOlsiY24iLCJ1c2VTdGF0ZSIsImNsYXNzZXMiLCJJbnB1dCIsInBsYWNlaG9sZGVyIiwiY2xhc3NOYW1lIiwicmVzdCIsImlzRm9jdXNlZCIsInNldElzRm9jdXNlZCIsImRpdiIsImlucHV0IiwiaW5wdXRfZm9jdXNlZCIsImxhYmVsIiwiaHRtbEZvciIsImlkIiwiaW5wdXRfX2xhYmVsIiwib25Gb2N1cyIsIm9uQmx1ciIsImUiLCJ0YXJnZXQiLCJ2YWx1ZSIsImlucHV0X19pbnB1dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/input/Input.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/switcher/Switcher.tsx":
/*!*************************************************!*\
  !*** ./src/components/ui/switcher/Switcher.tsx ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Switcher: function() { return /* binding */ Switcher; },\n/* harmony export */   SwitcherComponent: function() { return /* binding */ SwitcherComponent; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _switcher_module_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./switcher.module.scss */ \"(app-pages-browser)/./src/components/ui/switcher/switcher.module.scss\");\n/* harmony import */ var _switcher_module_scss__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_switcher_module_scss__WEBPACK_IMPORTED_MODULE_2__);\nvar _this = undefined;\n\n\n\nvar SwitcherComponent = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(_c = function(param, ref) {\n    var id = param.id, label = param.label, name = param.name, _param_type = param.type, type = _param_type === void 0 ? \"radio\" : _param_type, isChecked = param.isChecked;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n        htmlFor: id,\n        className: (_switcher_module_scss__WEBPACK_IMPORTED_MODULE_2___default().switcher),\n        ref: ref,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_switcher_module_scss__WEBPACK_IMPORTED_MODULE_2___default().switcher__container),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_switcher_module_scss__WEBPACK_IMPORTED_MODULE_2___default().switcher__state),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_switcher_module_scss__WEBPACK_IMPORTED_MODULE_2___default().switcher__stateRing)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\switcher\\\\Switcher.tsx\",\n                            lineNumber: 16,\n                            columnNumber: 7\n                        }, _this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\switcher\\\\Switcher.tsx\",\n                        lineNumber: 15,\n                        columnNumber: 6\n                    }, _this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        id: id,\n                        type: type,\n                        name: name,\n                        defaultChecked: isChecked,\n                        value: label,\n                        hidden: true\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\switcher\\\\Switcher.tsx\",\n                        lineNumber: 18,\n                        columnNumber: 6\n                    }, _this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\switcher\\\\Switcher.tsx\",\n                lineNumber: 14,\n                columnNumber: 5\n            }, _this),\n            label\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\switcher\\\\Switcher.tsx\",\n        lineNumber: 9,\n        columnNumber: 4\n    }, _this);\n});\n_c1 = SwitcherComponent;\nSwitcherComponent.displayName = \"switcher\";\nvar Switcher = SwitcherComponent;\nvar _c, _c1;\n$RefreshReg$(_c, \"SwitcherComponent$forwardRef\");\n$RefreshReg$(_c1, \"SwitcherComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL3N3aXRjaGVyL1N3aXRjaGVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBa0M7QUFFVTtBQUdyQyxJQUFNRSxrQ0FBb0JGLGlEQUFVQSxNQUMxQyxnQkFBK0RHO1FBQTVEQyxXQUFBQSxJQUFJQyxjQUFBQSxPQUFPQyxhQUFBQSwwQkFBTUMsTUFBQUEsZ0NBQU8sdUJBQVNDLGtCQUFBQTtJQUNuQyxxQkFDQyw4REFBQ0g7UUFDQUksU0FBU0w7UUFDVE0sV0FBV1QsdUVBQWdCO1FBQzNCRSxLQUFLQTs7MEJBRUwsOERBQUNTO2dCQUFJRixXQUFXVCxrRkFBMkI7O2tDQUMxQyw4REFBQ1c7d0JBQUlGLFdBQVdULDhFQUF1QjtrQ0FDdEMsNEVBQUNXOzRCQUFJRixXQUFXVCxrRkFBMkI7Ozs7Ozs7Ozs7O2tDQUU1Qyw4REFBQ2U7d0JBQ0FaLElBQUlBO3dCQUNKRyxNQUFNQTt3QkFDTkQsTUFBTUE7d0JBQ05XLGdCQUFnQlQ7d0JBQ2hCVSxPQUFPYjt3QkFDUGMsTUFBTTs7Ozs7Ozs7Ozs7O1lBSVBkOzs7Ozs7O0FBR0osR0FDQTs7QUFDREgsa0JBQWtCa0IsV0FBVyxHQUFHO0FBQ3pCLElBQU1DLFdBQVduQixrQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdWkvc3dpdGNoZXIvU3dpdGNoZXIudHN4P2NiMWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0J1xyXG5cclxuaW1wb3J0IGNsYXNzZXMgZnJvbSAnLi9zd2l0Y2hlci5tb2R1bGUuc2NzcydcclxuaW1wb3J0IHsgVHlwZVN3aXRjaGVyIH0gZnJvbSAnLi9zd2l0Y2hlci50eXBlcydcclxuXHJcbmV4cG9ydCBjb25zdCBTd2l0Y2hlckNvbXBvbmVudCA9IGZvcndhcmRSZWYoXHJcblx0KHsgaWQsIGxhYmVsLCBuYW1lLCB0eXBlID0gJ3JhZGlvJywgaXNDaGVja2VkIH06IFR5cGVTd2l0Y2hlciwgcmVmOiBhbnkpID0+IHtcclxuXHRcdHJldHVybiAoXHJcblx0XHRcdDxsYWJlbFxyXG5cdFx0XHRcdGh0bWxGb3I9e2lkfVxyXG5cdFx0XHRcdGNsYXNzTmFtZT17Y2xhc3Nlcy5zd2l0Y2hlcn1cclxuXHRcdFx0XHRyZWY9e3JlZn1cclxuXHRcdFx0PlxyXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzLnN3aXRjaGVyX19jb250YWluZXJ9PlxyXG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuc3dpdGNoZXJfX3N0YXRlfT5cclxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuc3dpdGNoZXJfX3N0YXRlUmluZ30+PC9kaXY+XHJcblx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdDxpbnB1dFxyXG5cdFx0XHRcdFx0XHRpZD17aWR9XHJcblx0XHRcdFx0XHRcdHR5cGU9e3R5cGV9XHJcblx0XHRcdFx0XHRcdG5hbWU9e25hbWV9XHJcblx0XHRcdFx0XHRcdGRlZmF1bHRDaGVja2VkPXtpc0NoZWNrZWR9XHJcblx0XHRcdFx0XHRcdHZhbHVlPXtsYWJlbH1cclxuXHRcdFx0XHRcdFx0aGlkZGVuXHJcblx0XHRcdFx0XHQvPlxyXG5cdFx0XHRcdDwvZGl2PlxyXG5cclxuXHRcdFx0XHR7bGFiZWx9XHJcblx0XHRcdDwvbGFiZWw+XHJcblx0XHQpXHJcblx0fVxyXG4pXHJcblN3aXRjaGVyQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ3N3aXRjaGVyJ1xyXG5leHBvcnQgY29uc3QgU3dpdGNoZXIgPSBTd2l0Y2hlckNvbXBvbmVudFxyXG4iXSwibmFtZXMiOlsiZm9yd2FyZFJlZiIsImNsYXNzZXMiLCJTd2l0Y2hlckNvbXBvbmVudCIsInJlZiIsImlkIiwibGFiZWwiLCJuYW1lIiwidHlwZSIsImlzQ2hlY2tlZCIsImh0bWxGb3IiLCJjbGFzc05hbWUiLCJzd2l0Y2hlciIsImRpdiIsInN3aXRjaGVyX19jb250YWluZXIiLCJzd2l0Y2hlcl9fc3RhdGUiLCJzd2l0Y2hlcl9fc3RhdGVSaW5nIiwiaW5wdXQiLCJkZWZhdWx0Q2hlY2tlZCIsInZhbHVlIiwiaGlkZGVuIiwiZGlzcGxheU5hbWUiLCJTd2l0Y2hlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/switcher/Switcher.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/uploadFile/UploadFile.tsx":
/*!*****************************************************!*\
  !*** ./src/components/ui/uploadFile/UploadFile.tsx ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UploadFile: function() { return /* binding */ UploadFile; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _constants_fileAccept_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/constants/fileAccept.constants */ \"(app-pages-browser)/./src/constants/fileAccept.constants.ts\");\n/* harmony import */ var _IconComponent_IconComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../IconComponent/IconComponent */ \"(app-pages-browser)/./src/components/ui/IconComponent/IconComponent.tsx\");\n/* harmony import */ var _UploadFile_module_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./UploadFile.module.scss */ \"(app-pages-browser)/./src/components/ui/uploadFile/UploadFile.module.scss\");\n/* harmony import */ var _UploadFile_module_scss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_UploadFile_module_scss__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _UploadFileContent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UploadFileContent */ \"(app-pages-browser)/./src/components/ui/uploadFile/UploadFileContent.tsx\");\n/* harmony import */ var _UploadFileContentItem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./UploadFileContentItem */ \"(app-pages-browser)/./src/components/ui/uploadFile/UploadFileContentItem.tsx\");\n\n\n\n\n\n\n\nvar items = [\n    {\n        isPending: false,\n        text: \"Документ техническое задание о проекте.pdf\"\n    },\n    {\n        isPending: true,\n        text: \"Документ техническое задание о проекте.pdf\"\n    }\n];\nfunction UploadFile() {\n    var _this = this;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_UploadFile_module_scss__WEBPACK_IMPORTED_MODULE_3___default().upload),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                htmlFor: \"file\",\n                className: (_UploadFile_module_scss__WEBPACK_IMPORTED_MODULE_3___default().upload__label),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_IconComponent_IconComponent__WEBPACK_IMPORTED_MODULE_2__.IconComponent, {\n                        icon: \"ant-design:paper-clip-outlined\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\uploadFile\\\\UploadFile.tsx\",\n                        lineNumber: 27,\n                        columnNumber: 5\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_UploadFile_module_scss__WEBPACK_IMPORTED_MODULE_3___default().upload__text),\n                        children: [\n                            \"Прикрепить файл\",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                children: \"0 из 20Мб (0 из 5 файлов: doc, pdf, zip)\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\uploadFile\\\\UploadFile.tsx\",\n                                lineNumber: 30,\n                                columnNumber: 6\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\uploadFile\\\\UploadFile.tsx\",\n                        lineNumber: 28,\n                        columnNumber: 5\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        type: \"file\",\n                        id: \"file\",\n                        className: (_UploadFile_module_scss__WEBPACK_IMPORTED_MODULE_3___default().upload__input),\n                        multiple: true,\n                        hidden: true,\n                        accept: _constants_fileAccept_constants__WEBPACK_IMPORTED_MODULE_1__.fileAccept\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\uploadFile\\\\UploadFile.tsx\",\n                        lineNumber: 32,\n                        columnNumber: 5\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\uploadFile\\\\UploadFile.tsx\",\n                lineNumber: 23,\n                columnNumber: 4\n            }, this),\n            items.length && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_UploadFileContent__WEBPACK_IMPORTED_MODULE_4__.UploadFileContent, {\n                children: items.map(function(item, index) {\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_UploadFileContentItem__WEBPACK_IMPORTED_MODULE_5__.UploadFileContentItem, (0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_6__._)({}, item), index, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\uploadFile\\\\UploadFile.tsx\",\n                        lineNumber: 44,\n                        columnNumber: 7\n                    }, _this);\n                })\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\uploadFile\\\\UploadFile.tsx\",\n                lineNumber: 42,\n                columnNumber: 5\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\uploadFile\\\\UploadFile.tsx\",\n        lineNumber: 22,\n        columnNumber: 3\n    }, this);\n}\n_c = UploadFile;\nvar _c;\n$RefreshReg$(_c, \"UploadFile\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL3VwbG9hZEZpbGUvVXBsb2FkRmlsZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBNkQ7QUFFQztBQUVoQjtBQUNTO0FBQ1E7QUFFL0QsSUFBTUssUUFBUTtJQUNiO1FBQ0NDLFdBQVc7UUFDWEMsTUFBTTtJQUNQO0lBQ0E7UUFDQ0QsV0FBVztRQUNYQyxNQUFNO0lBQ1A7Q0FDQTtBQUVNLFNBQVNDOztJQUNmLHFCQUNDLDhEQUFDQztRQUFJQyxXQUFXUix1RUFBYzs7MEJBQzdCLDhEQUFDVTtnQkFDQUMsU0FBUTtnQkFDUkgsV0FBV1IsOEVBQXFCOztrQ0FFaEMsOERBQUNELHVFQUFhQTt3QkFBQ2MsTUFBSzs7Ozs7O2tDQUNwQiw4REFBQ047d0JBQUlDLFdBQVdSLDZFQUFvQjs7NEJBQUU7MENBRXJDLDhEQUFDZTswQ0FBSzs7Ozs7Ozs7Ozs7O2tDQUVQLDhEQUFDQzt3QkFDQUMsTUFBSzt3QkFDTEMsSUFBRzt3QkFDSFYsV0FBV1IsOEVBQXFCO3dCQUNoQ29CLFFBQVE7d0JBQ1JDLE1BQU07d0JBQ05DLFFBQVF4Qix1RUFBVUE7Ozs7Ozs7Ozs7OztZQUduQkssTUFBTW9CLE1BQU0sa0JBQ1osOERBQUN0QixpRUFBaUJBOzBCQUNoQkUsTUFBTXFCLEdBQUcsQ0FBQyxTQUFDQyxNQUFNQzt5Q0FDakIsOERBQUN4Qix5RUFBcUJBLEVBQUFBLDZEQUFBQSxLQUVqQnVCLE9BRENDOzs7Ozs7Ozs7Ozs7Ozs7OztBQVFaO0tBakNnQnBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3VpL3VwbG9hZEZpbGUvVXBsb2FkRmlsZS50c3g/ZjBhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmaWxlQWNjZXB0IH0gZnJvbSAnQC9jb25zdGFudHMvZmlsZUFjY2VwdC5jb25zdGFudHMnXHJcblxyXG5pbXBvcnQgeyBJY29uQ29tcG9uZW50IH0gZnJvbSAnLi4vSWNvbkNvbXBvbmVudC9JY29uQ29tcG9uZW50J1xyXG5cclxuaW1wb3J0IGNsYXNzZXMgZnJvbSAnLi9VcGxvYWRGaWxlLm1vZHVsZS5zY3NzJ1xyXG5pbXBvcnQgeyBVcGxvYWRGaWxlQ29udGVudCB9IGZyb20gJy4vVXBsb2FkRmlsZUNvbnRlbnQnXHJcbmltcG9ydCB7IFVwbG9hZEZpbGVDb250ZW50SXRlbSB9IGZyb20gJy4vVXBsb2FkRmlsZUNvbnRlbnRJdGVtJ1xyXG5cclxuY29uc3QgaXRlbXMgPSBbXHJcblx0e1xyXG5cdFx0aXNQZW5kaW5nOiBmYWxzZSxcclxuXHRcdHRleHQ6ICfQlNC+0LrRg9C80LXQvdGCINGC0LXRhdC90LjRh9C10YHQutC+0LUg0LfQsNC00LDQvdC40LUg0L4g0L/RgNC+0LXQutGC0LUucGRmJ1xyXG5cdH0sXHJcblx0e1xyXG5cdFx0aXNQZW5kaW5nOiB0cnVlLFxyXG5cdFx0dGV4dDogJ9CU0L7QutGD0LzQtdC90YIg0YLQtdGF0L3QuNGH0LXRgdC60L7QtSDQt9Cw0LTQsNC90LjQtSDQviDQv9GA0L7QtdC60YLQtS5wZGYnXHJcblx0fVxyXG5dXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gVXBsb2FkRmlsZSgpIHtcclxuXHRyZXR1cm4gKFxyXG5cdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMudXBsb2FkfT5cclxuXHRcdFx0PGxhYmVsXHJcblx0XHRcdFx0aHRtbEZvcj0nZmlsZSdcclxuXHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzZXMudXBsb2FkX19sYWJlbH1cclxuXHRcdFx0PlxyXG5cdFx0XHRcdDxJY29uQ29tcG9uZW50IGljb249J2FudC1kZXNpZ246cGFwZXItY2xpcC1vdXRsaW5lZCcgLz5cclxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlcy51cGxvYWRfX3RleHR9PlxyXG5cdFx0XHRcdFx00J/RgNC40LrRgNC10L/QuNGC0Ywg0YTQsNC50LtcclxuXHRcdFx0XHRcdDxzcGFuPjAg0LjQtyAyMNCc0LEgKDAg0LjQtyA1INGE0LDQudC70L7QsjogZG9jLCBwZGYsIHppcCk8L3NwYW4+XHJcblx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0PGlucHV0XHJcblx0XHRcdFx0XHR0eXBlPSdmaWxlJ1xyXG5cdFx0XHRcdFx0aWQ9J2ZpbGUnXHJcblx0XHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzZXMudXBsb2FkX19pbnB1dH1cclxuXHRcdFx0XHRcdG11bHRpcGxlXHJcblx0XHRcdFx0XHRoaWRkZW5cclxuXHRcdFx0XHRcdGFjY2VwdD17ZmlsZUFjY2VwdH1cclxuXHRcdFx0XHQvPlxyXG5cdFx0XHQ8L2xhYmVsPlxyXG5cdFx0XHR7aXRlbXMubGVuZ3RoICYmIChcclxuXHRcdFx0XHQ8VXBsb2FkRmlsZUNvbnRlbnQ+XHJcblx0XHRcdFx0XHR7aXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT4gKFxyXG5cdFx0XHRcdFx0XHQ8VXBsb2FkRmlsZUNvbnRlbnRJdGVtXHJcblx0XHRcdFx0XHRcdFx0a2V5PXtpbmRleH1cclxuXHRcdFx0XHRcdFx0XHR7Li4uaXRlbX1cclxuXHRcdFx0XHRcdFx0Lz5cclxuXHRcdFx0XHRcdCkpfVxyXG5cdFx0XHRcdDwvVXBsb2FkRmlsZUNvbnRlbnQ+XHJcblx0XHRcdCl9XHJcblx0XHQ8L2Rpdj5cclxuXHQpXHJcbn1cclxuIl0sIm5hbWVzIjpbImZpbGVBY2NlcHQiLCJJY29uQ29tcG9uZW50IiwiY2xhc3NlcyIsIlVwbG9hZEZpbGVDb250ZW50IiwiVXBsb2FkRmlsZUNvbnRlbnRJdGVtIiwiaXRlbXMiLCJpc1BlbmRpbmciLCJ0ZXh0IiwiVXBsb2FkRmlsZSIsImRpdiIsImNsYXNzTmFtZSIsInVwbG9hZCIsImxhYmVsIiwiaHRtbEZvciIsInVwbG9hZF9fbGFiZWwiLCJpY29uIiwidXBsb2FkX190ZXh0Iiwic3BhbiIsImlucHV0IiwidHlwZSIsImlkIiwidXBsb2FkX19pbnB1dCIsIm11bHRpcGxlIiwiaGlkZGVuIiwiYWNjZXB0IiwibGVuZ3RoIiwibWFwIiwiaXRlbSIsImluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/uploadFile/UploadFile.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/uploadFile/UploadFileContent.tsx":
/*!************************************************************!*\
  !*** ./src/components/ui/uploadFile/UploadFileContent.tsx ***!
  \************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UploadFileContent: function() { return /* binding */ UploadFileContent; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _UploadFile_module_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UploadFile.module.scss */ \"(app-pages-browser)/./src/components/ui/uploadFile/UploadFile.module.scss\");\n/* harmony import */ var _UploadFile_module_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_UploadFile_module_scss__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction UploadFileContent(param) {\n    var children = param.children;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_UploadFile_module_scss__WEBPACK_IMPORTED_MODULE_1___default().upload__content),\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\uploadFile\\\\UploadFileContent.tsx\",\n        lineNumber: 6,\n        columnNumber: 9\n    }, this);\n}\n_c = UploadFileContent;\nvar _c;\n$RefreshReg$(_c, \"UploadFileContent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL3VwbG9hZEZpbGUvVXBsb2FkRmlsZUNvbnRlbnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBRThDO0FBRXZDLFNBQVNDLGtCQUFrQixLQUErQjtRQUEvQixpQkFBRUM7SUFDbkMscUJBQU8sOERBQUNDO1FBQUlDLFdBQVdKLGdGQUF1QjtrQkFBR0U7Ozs7OztBQUNsRDtLQUZnQkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdWkvdXBsb2FkRmlsZS9VcGxvYWRGaWxlQ29udGVudC50c3g/MzcxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcm9wc1dpdGhDaGlsZHJlbiB9IGZyb20gJ3JlYWN0J1xyXG5cclxuaW1wb3J0IGNsYXNzZXMgZnJvbSAnLi9VcGxvYWRGaWxlLm1vZHVsZS5zY3NzJ1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFVwbG9hZEZpbGVDb250ZW50KHsgY2hpbGRyZW4gfTogUHJvcHNXaXRoQ2hpbGRyZW4pIHtcclxuXHRyZXR1cm4gPGRpdiBjbGFzc05hbWU9e2NsYXNzZXMudXBsb2FkX19jb250ZW50fT57Y2hpbGRyZW59PC9kaXY+XHJcbn1cclxuIl0sIm5hbWVzIjpbImNsYXNzZXMiLCJVcGxvYWRGaWxlQ29udGVudCIsImNoaWxkcmVuIiwiZGl2IiwiY2xhc3NOYW1lIiwidXBsb2FkX19jb250ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/uploadFile/UploadFileContent.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/uploadFile/UploadFileContentItem.tsx":
/*!****************************************************************!*\
  !*** ./src/components/ui/uploadFile/UploadFileContentItem.tsx ***!
  \****************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UploadFileContentItem: function() { return /* binding */ UploadFileContentItem; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var _IconComponent_IconComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../IconComponent/IconComponent */ \"(app-pages-browser)/./src/components/ui/IconComponent/IconComponent.tsx\");\n/* harmony import */ var _UploadFile_module_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./UploadFile.module.scss */ \"(app-pages-browser)/./src/components/ui/uploadFile/UploadFile.module.scss\");\n/* harmony import */ var _UploadFile_module_scss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_UploadFile_module_scss__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nfunction UploadFileContentItem(param) {\n    var isPending = param.isPending, text = param.text;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])((_UploadFile_module_scss__WEBPACK_IMPORTED_MODULE_3___default().upload__contentItem), isPending && (_UploadFile_module_scss__WEBPACK_IMPORTED_MODULE_3___default().upload__contentItem_loading)),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_UploadFile_module_scss__WEBPACK_IMPORTED_MODULE_3___default().upload__icon),\n                children: isPending ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_IconComponent_IconComponent__WEBPACK_IMPORTED_MODULE_2__.IconComponent, {\n                    icon: \"line-md:loading-twotone-loop\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\uploadFile\\\\UploadFileContentItem.tsx\",\n                    lineNumber: 25,\n                    columnNumber: 6\n                }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_IconComponent_IconComponent__WEBPACK_IMPORTED_MODULE_2__.IconComponent, {\n                    icon: \"basil:cross-outline\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\uploadFile\\\\UploadFileContentItem.tsx\",\n                    lineNumber: 27,\n                    columnNumber: 6\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\uploadFile\\\\UploadFileContentItem.tsx\",\n                lineNumber: 23,\n                columnNumber: 4\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                children: text\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\uploadFile\\\\UploadFileContentItem.tsx\",\n                lineNumber: 30,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\uploadFile\\\\UploadFileContentItem.tsx\",\n        lineNumber: 17,\n        columnNumber: 3\n    }, this);\n}\n_c = UploadFileContentItem;\nvar _c;\n$RefreshReg$(_c, \"UploadFileContentItem\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL3VwbG9hZEZpbGUvVXBsb2FkRmlsZUNvbnRlbnRJdGVtLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXFCO0FBRXlDO0FBRWhCO0FBT3ZDLFNBQVNHLHNCQUFzQixLQUdiO1FBRnhCQyxZQURxQyxNQUNyQ0EsV0FDQUMsT0FGcUMsTUFFckNBO0lBRUEscUJBQ0MsOERBQUNDO1FBQ0FDLFdBQVdQLGdEQUFFQSxDQUNaRSxvRkFBMkIsRUFDM0JFLGFBQWFGLDRGQUFtQzs7MEJBR2pELDhEQUFDSTtnQkFBSUMsV0FBV0wsNkVBQW9COzBCQUNsQ0UsMEJBQ0EsOERBQUNILHVFQUFhQTtvQkFBQ1UsTUFBSzs7Ozs7eUNBRXBCLDhEQUFDVix1RUFBYUE7b0JBQUNVLE1BQUs7Ozs7Ozs7Ozs7OzBCQUd0Qiw4REFBQ0M7MEJBQU1QOzs7Ozs7Ozs7Ozs7QUFHVjtLQXJCZ0JGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3VpL3VwbG9hZEZpbGUvVXBsb2FkRmlsZUNvbnRlbnRJdGVtLnRzeD83OGRkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjbiBmcm9tICdjbHN4J1xyXG5cclxuaW1wb3J0IHsgSWNvbkNvbXBvbmVudCB9IGZyb20gJy4uL0ljb25Db21wb25lbnQvSWNvbkNvbXBvbmVudCdcclxuXHJcbmltcG9ydCBjbGFzc2VzIGZyb20gJy4vVXBsb2FkRmlsZS5tb2R1bGUuc2NzcydcclxuXHJcbmludGVyZmFjZSBJVXBsb2FkRmlsZUNvbnRlbnRJdGVtIHtcclxuXHRpc1BlbmRpbmc6IGJvb2xlYW5cclxuXHR0ZXh0OiBzdHJpbmdcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFVwbG9hZEZpbGVDb250ZW50SXRlbSh7XHJcblx0aXNQZW5kaW5nLFxyXG5cdHRleHRcclxufTogSVVwbG9hZEZpbGVDb250ZW50SXRlbSkge1xyXG5cdHJldHVybiAoXHJcblx0XHQ8ZGl2XHJcblx0XHRcdGNsYXNzTmFtZT17Y24oXHJcblx0XHRcdFx0Y2xhc3Nlcy51cGxvYWRfX2NvbnRlbnRJdGVtLFxyXG5cdFx0XHRcdGlzUGVuZGluZyAmJiBjbGFzc2VzLnVwbG9hZF9fY29udGVudEl0ZW1fbG9hZGluZ1xyXG5cdFx0XHQpfVxyXG5cdFx0PlxyXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlcy51cGxvYWRfX2ljb259PlxyXG5cdFx0XHRcdHtpc1BlbmRpbmcgPyAoXHJcblx0XHRcdFx0XHQ8SWNvbkNvbXBvbmVudCBpY29uPSdsaW5lLW1kOmxvYWRpbmctdHdvdG9uZS1sb29wJyAvPlxyXG5cdFx0XHRcdCkgOiAoXHJcblx0XHRcdFx0XHQ8SWNvbkNvbXBvbmVudCBpY29uPSdiYXNpbDpjcm9zcy1vdXRsaW5lJyAvPlxyXG5cdFx0XHRcdCl9XHJcblx0XHRcdDwvZGl2PlxyXG5cdFx0XHQ8c3Bhbj57dGV4dH08L3NwYW4+XHJcblx0XHQ8L2Rpdj5cclxuXHQpXHJcbn1cclxuIl0sIm5hbWVzIjpbImNuIiwiSWNvbkNvbXBvbmVudCIsImNsYXNzZXMiLCJVcGxvYWRGaWxlQ29udGVudEl0ZW0iLCJpc1BlbmRpbmciLCJ0ZXh0IiwiZGl2IiwiY2xhc3NOYW1lIiwidXBsb2FkX19jb250ZW50SXRlbSIsInVwbG9hZF9fY29udGVudEl0ZW1fbG9hZGluZyIsInVwbG9hZF9faWNvbiIsImljb24iLCJzcGFuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/uploadFile/UploadFileContentItem.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/constants/fileAccept.constants.ts":
/*!***********************************************!*\
  !*** ./src/constants/fileAccept.constants.ts ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fileAccept: function() { return /* binding */ fileAccept; }\n/* harmony export */ });\nvar fileAccept = \"image/*,.png,.jpg,.jpeg,.doc,.pdf,.zip,.rar\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb25zdGFudHMvZmlsZUFjY2VwdC5jb25zdGFudHMudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLElBQU1BLGFBQWEsOENBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb25zdGFudHMvZmlsZUFjY2VwdC5jb25zdGFudHMudHM/M2IyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgZmlsZUFjY2VwdCA9ICdpbWFnZS8qLC5wbmcsLmpwZywuanBlZywuZG9jLC5wZGYsLnppcCwucmFyJ1xyXG4iXSwibmFtZXMiOlsiZmlsZUFjY2VwdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/constants/fileAccept.constants.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/constants/headerBlack.constants.ts":
/*!************************************************!*\
  !*** ./src/constants/headerBlack.constants.ts ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   headerBlack: function() { return /* binding */ headerBlack; }\n/* harmony export */ });\nvar headerBlack = [\n    \"/contacts\"\n];\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb25zdGFudHMvaGVhZGVyQmxhY2suY29uc3RhbnRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxJQUFNQSxjQUFjO0lBQUM7Q0FBWSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29uc3RhbnRzL2hlYWRlckJsYWNrLmNvbnN0YW50cy50cz83YTY5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBoZWFkZXJCbGFjayA9IFsnL2NvbnRhY3RzJ11cclxuIl0sIm5hbWVzIjpbImhlYWRlckJsYWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/constants/headerBlack.constants.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/contexts/Modal.context.ts":
/*!***************************************!*\
  !*** ./src/contexts/Modal.context.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ModalContext: function() { return /* binding */ ModalContext; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nvar ModalContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    open: function(children) {},\n    close: function() {}\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9Nb2RhbC5jb250ZXh0LnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFtRDtBQUU1QyxJQUFNQyxlQUFlRCxvREFBYUEsQ0FBQztJQUN6Q0UsTUFBTSxTQUFDQyxXQUE0QjtJQUNuQ0MsT0FBTyxZQUFPO0FBQ2YsR0FBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29udGV4dHMvTW9kYWwuY29udGV4dC50cz9kZGVmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlYWN0RWxlbWVudCwgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0J1xyXG5cclxuZXhwb3J0IGNvbnN0IE1vZGFsQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xyXG5cdG9wZW46IChjaGlsZHJlbjogUmVhY3RFbGVtZW50KSA9PiB7fSxcclxuXHRjbG9zZTogKCkgPT4ge31cclxufSlcclxuIl0sIm5hbWVzIjpbImNyZWF0ZUNvbnRleHQiLCJNb2RhbENvbnRleHQiLCJvcGVuIiwiY2hpbGRyZW4iLCJjbG9zZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/Modal.context.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/useScroll.ts":
/*!********************************!*\
  !*** ./src/hooks/useScroll.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useScroll: function() { return /* binding */ useScroll; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction useScroll() {\n    var _useState = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_1__._)((0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), 2), scroll = _useState[0], setScroll = _useState[1];\n    var handleScroll = function(e) {\n        setScroll(e.currentTarget.scrollY);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        window.addEventListener(\"scroll\", handleScroll);\n        setScroll(window.scrollY);\n        return function() {\n            window.removeEventListener(\"scroll\", handleScroll);\n        };\n    }, []);\n    return {\n        scroll: scroll,\n        setScroll: setScroll\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VTY3JvbGwudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMkM7QUFFcEMsU0FBU0U7SUFDZixJQUE0QkQsWUFBQUEsK0RBQUFBLENBQUFBLCtDQUFRQSxDQUFTLFFBQXRDRSxTQUFxQkYsY0FBYkcsWUFBYUg7SUFFNUIsSUFBTUksZUFBZSxTQUFDQztRQUNyQkYsVUFBVSxFQUFHRyxhQUFhLENBQVlDLE9BQU87SUFDOUM7SUFFQVIsZ0RBQVNBLENBQUM7UUFDVFMsT0FBT0MsZ0JBQWdCLENBQUMsVUFBVUw7UUFDbENELFVBQVVLLE9BQU9ELE9BQU87UUFFeEIsT0FBTztZQUNOQyxPQUFPRSxtQkFBbUIsQ0FBQyxVQUFVTjtRQUN0QztJQUNELEdBQUcsRUFBRTtJQUNMLE9BQU87UUFBRUYsUUFBQUE7UUFBUUMsV0FBQUE7SUFBVTtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaG9va3MvdXNlU2Nyb2xsLnRzPzI3ODIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNjcm9sbCgpIHtcclxuXHRjb25zdCBbc2Nyb2xsLCBzZXRTY3JvbGxdID0gdXNlU3RhdGU8bnVtYmVyPigwKVxyXG5cclxuXHRjb25zdCBoYW5kbGVTY3JvbGwgPSAoZTogRXZlbnQpID0+IHtcclxuXHRcdHNldFNjcm9sbCgoZS5jdXJyZW50VGFyZ2V0IGFzIFdpbmRvdykuc2Nyb2xsWSlcclxuXHR9XHJcblxyXG5cdHVzZUVmZmVjdCgoKSA9PiB7XHJcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKVxyXG5cdFx0c2V0U2Nyb2xsKHdpbmRvdy5zY3JvbGxZKVxyXG5cclxuXHRcdHJldHVybiAoKSA9PiB7XHJcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVTY3JvbGwpXHJcblx0XHR9XHJcblx0fSwgW10pXHJcblx0cmV0dXJuIHsgc2Nyb2xsLCBzZXRTY3JvbGwgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZVNjcm9sbCIsInNjcm9sbCIsInNldFNjcm9sbCIsImhhbmRsZVNjcm9sbCIsImUiLCJjdXJyZW50VGFyZ2V0Iiwic2Nyb2xsWSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useScroll.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/providers/Modal.provider.tsx":
/*!******************************************!*\
  !*** ./src/providers/Modal.provider.tsx ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ModalProvider; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dynamic */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/app-dynamic.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _contexts_Modal_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/contexts/Modal.context */ \"(app-pages-browser)/./src/contexts/Modal.context.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\nvar _s = $RefreshSig$();\n\n\n\nvar ComponentModal = (0,next_dynamic__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(function() {\n    return Promise.all(/*! import() */[__webpack_require__.e(\"css-src_components_ui_modal_styles_module_scss\"), __webpack_require__.e(\"_app-pages-browser_src_components_ui_modal_Modal_tsx\")]).then(__webpack_require__.bind(__webpack_require__, /*! ../components/ui/modal/Modal */ \"(app-pages-browser)/./src/components/ui/modal/Modal.tsx\"));\n}, {\n    loadableGenerated: {\n        modules: [\n            \"providers\\\\Modal.provider.tsx -> \" + \"../components/ui/modal/Modal\"\n        ]\n    },\n    ssr: false\n});\n_c = ComponentModal;\nfunction ModalProvider(param) {\n    var children = param.children;\n    _s();\n    var _useState = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_4__._)((0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false), 2), isOpen = _useState[0], setIsOpen = _useState[1];\n    var _useState1 = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_4__._)((0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(), 2), content = _useState1[0], setContent = _useState1[1];\n    var open = function(children) {\n        setIsOpen(true);\n        setContent(children);\n    };\n    var close = function() {\n        setIsOpen(false);\n    };\n    var valueModalProvider = {\n        open: open,\n        close: close\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_contexts_Modal_context__WEBPACK_IMPORTED_MODULE_3__.ModalContext.Provider, {\n        value: valueModalProvider,\n        children: [\n            children,\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ComponentModal, {\n                isOpen: isOpen,\n                setIsOpen: setIsOpen,\n                children: content\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\providers\\\\Modal.provider.tsx\",\n                lineNumber: 33,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\providers\\\\Modal.provider.tsx\",\n        lineNumber: 31,\n        columnNumber: 3\n    }, this);\n}\n_s(ModalProvider, \"mA90pLeG9QLbgHUZGhATlaTqXx0=\");\n_c1 = ModalProvider;\nvar _c, _c1;\n$RefreshReg$(_c, \"ComponentModal\");\n$RefreshReg$(_c1, \"ModalProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9wcm92aWRlcnMvTW9kYWwucHJvdmlkZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFa0M7QUFDK0I7QUFFVjtBQUV2RCxJQUFNRyxpQkFBaUJILHdEQUFPQSxDQUFDO1dBQU0sdVVBQU87Ozs7Ozs7SUFDM0NJLEtBQUs7O0tBREFEO0FBSVMsU0FBU0UsY0FBYyxLQUErQjtRQUEvQixpQkFBRUM7O0lBQ3ZDLElBQTRCTCxZQUFBQSwrREFBQUEsQ0FBQUEsK0NBQVFBLENBQVUsWUFBdkNNLFNBQXFCTixjQUFiTyxZQUFhUDtJQUM1QixJQUE4QkEsYUFBQUEsK0RBQUFBLENBQUFBLCtDQUFRQSxRQUEvQlEsVUFBdUJSLGVBQWRTLGFBQWNUO0lBRTlCLElBQU1VLE9BQU8sU0FBQ0w7UUFDYkUsVUFBVTtRQUNWRSxXQUFXSjtJQUNaO0lBRUEsSUFBTU0sUUFBUTtRQUNiSixVQUFVO0lBQ1g7SUFFQSxJQUFNSyxxQkFBcUI7UUFDMUJGLE1BQUFBO1FBQ0FDLE9BQUFBO0lBQ0Q7SUFFQSxxQkFDQyw4REFBQ1YsaUVBQVlBLENBQUNZLFFBQVE7UUFBQ0MsT0FBT0Y7O1lBQzVCUDswQkFDRCw4REFBQ0g7Z0JBQ0FJLFFBQVFBO2dCQUNSQyxXQUFXQTswQkFFVkM7Ozs7Ozs7Ozs7OztBQUlMO0dBN0J3Qko7TUFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3Byb3ZpZGVycy9Nb2RhbC5wcm92aWRlci50c3g/NjI4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCBkeW5hbWljIGZyb20gJ25leHQvZHluYW1pYydcclxuaW1wb3J0IHsgUHJvcHNXaXRoQ2hpbGRyZW4sIFJlYWN0RWxlbWVudCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcclxuXHJcbmltcG9ydCB7IE1vZGFsQ29udGV4dCB9IGZyb20gJ0AvY29udGV4dHMvTW9kYWwuY29udGV4dCdcclxuXHJcbmNvbnN0IENvbXBvbmVudE1vZGFsID0gZHluYW1pYygoKSA9PiBpbXBvcnQoJy4uL2NvbXBvbmVudHMvdWkvbW9kYWwvTW9kYWwnKSwge1xyXG5cdHNzcjogZmFsc2VcclxufSlcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1vZGFsUHJvdmlkZXIoeyBjaGlsZHJlbiB9OiBQcm9wc1dpdGhDaGlsZHJlbikge1xyXG5cdGNvbnN0IFtpc09wZW4sIHNldElzT3Blbl0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSlcclxuXHRjb25zdCBbY29udGVudCwgc2V0Q29udGVudF0gPSB1c2VTdGF0ZTxSZWFjdEVsZW1lbnQ+KClcclxuXHJcblx0Y29uc3Qgb3BlbiA9IChjaGlsZHJlbjogUmVhY3RFbGVtZW50KSA9PiB7XHJcblx0XHRzZXRJc09wZW4odHJ1ZSlcclxuXHRcdHNldENvbnRlbnQoY2hpbGRyZW4pXHJcblx0fVxyXG5cclxuXHRjb25zdCBjbG9zZSA9ICgpID0+IHtcclxuXHRcdHNldElzT3BlbihmYWxzZSlcclxuXHR9XHJcblxyXG5cdGNvbnN0IHZhbHVlTW9kYWxQcm92aWRlciA9IHtcclxuXHRcdG9wZW4sXHJcblx0XHRjbG9zZVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIChcclxuXHRcdDxNb2RhbENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3ZhbHVlTW9kYWxQcm92aWRlcn0+XHJcblx0XHRcdHtjaGlsZHJlbn1cclxuXHRcdFx0PENvbXBvbmVudE1vZGFsXHJcblx0XHRcdFx0aXNPcGVuPXtpc09wZW59XHJcblx0XHRcdFx0c2V0SXNPcGVuPXtzZXRJc09wZW59XHJcblx0XHRcdD5cclxuXHRcdFx0XHR7Y29udGVudH1cclxuXHRcdFx0PC9Db21wb25lbnRNb2RhbD5cclxuXHRcdDwvTW9kYWxDb250ZXh0LlByb3ZpZGVyPlxyXG5cdClcclxufVxyXG4iXSwibmFtZXMiOlsiZHluYW1pYyIsInVzZVN0YXRlIiwiTW9kYWxDb250ZXh0IiwiQ29tcG9uZW50TW9kYWwiLCJzc3IiLCJNb2RhbFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJpc09wZW4iLCJzZXRJc09wZW4iLCJjb250ZW50Iiwic2V0Q29udGVudCIsIm9wZW4iLCJjbG9zZSIsInZhbHVlTW9kYWxQcm92aWRlciIsIlByb3ZpZGVyIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/providers/Modal.provider.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/providers/SmoothScroll.provider.tsx":
/*!*************************************************!*\
  !*** ./src/providers/SmoothScroll.provider.tsx ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ SmoothScrollProvider; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var lenis_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lenis/react */ \"(app-pages-browser)/./node_modules/.pnpm/lenis@1.0.45_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/lenis/dist/lenis-react.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\nfunction SmoothScrollProvider(param) {\n    var children = param.children;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(lenis_react__WEBPACK_IMPORTED_MODULE_1__.ReactLenis, {\n        root: true,\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\providers\\\\SmoothScroll.provider.tsx\",\n        lineNumber: 8,\n        columnNumber: 3\n    }, this);\n}\n_c = SmoothScrollProvider;\nvar _c;\n$RefreshReg$(_c, \"SmoothScrollProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9wcm92aWRlcnMvU21vb3RoU2Nyb2xsLnByb3ZpZGVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBRXdDO0FBR3pCLFNBQVNDLHFCQUFxQixLQUErQjtRQUEvQixpQkFBRUM7SUFDOUMscUJBQ0MsOERBQUNGLG1EQUFVQTtRQUNWRyxJQUFJO2tCQUdIRDs7Ozs7O0FBR0o7S0FUd0JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9wcm92aWRlcnMvU21vb3RoU2Nyb2xsLnByb3ZpZGVyLnRzeD9iZThkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG5cclxuaW1wb3J0IHsgUmVhY3RMZW5pcyB9IGZyb20gJ2xlbmlzL3JlYWN0J1xyXG5pbXBvcnQgeyBQcm9wc1dpdGhDaGlsZHJlbiB9IGZyb20gJ3JlYWN0J1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU21vb3RoU2Nyb2xsUHJvdmlkZXIoeyBjaGlsZHJlbiB9OiBQcm9wc1dpdGhDaGlsZHJlbikge1xyXG5cdHJldHVybiAoXHJcblx0XHQ8UmVhY3RMZW5pc1xyXG5cdFx0XHRyb290XHJcblx0XHRcdC8vIG9wdGlvbnM9e3sgIH19XHJcblx0XHQ+XHJcblx0XHRcdHtjaGlsZHJlbn1cclxuXHRcdDwvUmVhY3RMZW5pcz5cclxuXHQpXHJcbn1cclxuIl0sIm5hbWVzIjpbIlJlYWN0TGVuaXMiLCJTbW9vdGhTY3JvbGxQcm92aWRlciIsImNoaWxkcmVuIiwicm9vdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/providers/SmoothScroll.provider.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/providers/providers.tsx":
/*!*************************************!*\
  !*** ./src/providers/providers.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Providers: function() { return /* binding */ Providers; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/queryClient.js\");\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+react-query@5.36.2_react@18.3.1/node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Modal_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Modal.provider */ \"(app-pages-browser)/./src/providers/Modal.provider.tsx\");\n/* harmony import */ var _SmoothScroll_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SmoothScroll.provider */ \"(app-pages-browser)/./src/providers/SmoothScroll.provider.tsx\");\n/* __next_internal_client_entry_do_not_use__ Providers auto */ \n\nvar _s = $RefreshSig$();\n\n\n\n\nfunction Providers(param) {\n    var children = param.children;\n    _s();\n    var _useState = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_4__._)((0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new _tanstack_react_query__WEBPACK_IMPORTED_MODULE_5__.QueryClient({\n        defaultOptions: {\n            queries: {\n                refetchOnWindowFocus: false\n            }\n        }\n    })), 1), client = _useState[0];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_tanstack_react_query__WEBPACK_IMPORTED_MODULE_6__.QueryClientProvider, {\n        client: client,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_SmoothScroll_provider__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Modal_provider__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                children: children\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\providers\\\\providers.tsx\",\n                lineNumber: 22,\n                columnNumber: 5\n            }, this)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\providers\\\\providers.tsx\",\n            lineNumber: 21,\n            columnNumber: 4\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\providers\\\\providers.tsx\",\n        lineNumber: 20,\n        columnNumber: 3\n    }, this);\n}\n_s(Providers, \"E8hdK8iAcH9YxCoIL1f0MKh16hk=\");\n_c = Providers;\nvar _c;\n$RefreshReg$(_c, \"Providers\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9wcm92aWRlcnMvcHJvdmlkZXJzLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFFd0U7QUFDckI7QUFFUDtBQUNjO0FBRW5ELFNBQVNLLFVBQVUsS0FBK0I7UUFBL0IsaUJBQUVDOztJQUMzQixJQUFpQkosWUFBQUEsK0RBQUFBLENBQUFBLCtDQUFRQSxDQUN4QixJQUFJRiw4REFBV0EsQ0FBQztRQUNmTyxnQkFBZ0I7WUFDZkMsU0FBUztnQkFDUkMsc0JBQXNCO1lBQ3ZCO1FBQ0Q7SUFDRCxTQVBNQyxTQUFVUjtJQVNqQixxQkFDQyw4REFBQ0Qsc0VBQW1CQTtRQUFDUyxRQUFRQTtrQkFDNUIsNEVBQUNOLDhEQUFvQkE7c0JBQ3BCLDRFQUFDRCx1REFBYUE7MEJBQUVHOzs7Ozs7Ozs7Ozs7Ozs7O0FBS3BCO0dBbEJnQkQ7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3Byb3ZpZGVycy9wcm92aWRlcnMudHN4PzY0YWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXHJcblxyXG5pbXBvcnQgeyBRdWVyeUNsaWVudCwgUXVlcnlDbGllbnRQcm92aWRlciB9IGZyb20gJ0B0YW5zdGFjay9yZWFjdC1xdWVyeSdcclxuaW1wb3J0IHsgUHJvcHNXaXRoQ2hpbGRyZW4sIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXHJcblxyXG5pbXBvcnQgTW9kYWxQcm92aWRlciBmcm9tICcuL01vZGFsLnByb3ZpZGVyJ1xyXG5pbXBvcnQgU21vb3RoU2Nyb2xsUHJvdmlkZXIgZnJvbSAnLi9TbW9vdGhTY3JvbGwucHJvdmlkZXInXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gUHJvdmlkZXJzKHsgY2hpbGRyZW4gfTogUHJvcHNXaXRoQ2hpbGRyZW4pIHtcclxuXHRjb25zdCBbY2xpZW50XSA9IHVzZVN0YXRlKFxyXG5cdFx0bmV3IFF1ZXJ5Q2xpZW50KHtcclxuXHRcdFx0ZGVmYXVsdE9wdGlvbnM6IHtcclxuXHRcdFx0XHRxdWVyaWVzOiB7XHJcblx0XHRcdFx0XHRyZWZldGNoT25XaW5kb3dGb2N1czogZmFsc2VcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pXHJcblx0KVxyXG5cdHJldHVybiAoXHJcblx0XHQ8UXVlcnlDbGllbnRQcm92aWRlciBjbGllbnQ9e2NsaWVudH0+XHJcblx0XHRcdDxTbW9vdGhTY3JvbGxQcm92aWRlcj5cclxuXHRcdFx0XHQ8TW9kYWxQcm92aWRlcj57Y2hpbGRyZW59PC9Nb2RhbFByb3ZpZGVyPlxyXG5cdFx0XHQ8L1Ntb290aFNjcm9sbFByb3ZpZGVyPlxyXG5cdFx0XHR7LyogPFJlYWN0UXVlcnlEZXZ0b29scyBpbml0aWFsSXNPcGVuPXtmYWxzZX0gLz4gKi99XHJcblx0XHQ8L1F1ZXJ5Q2xpZW50UHJvdmlkZXI+XHJcblx0KVxyXG59XHJcbiJdLCJuYW1lcyI6WyJRdWVyeUNsaWVudCIsIlF1ZXJ5Q2xpZW50UHJvdmlkZXIiLCJ1c2VTdGF0ZSIsIk1vZGFsUHJvdmlkZXIiLCJTbW9vdGhTY3JvbGxQcm92aWRlciIsIlByb3ZpZGVycyIsImNoaWxkcmVuIiwiZGVmYXVsdE9wdGlvbnMiLCJxdWVyaWVzIiwicmVmZXRjaE9uV2luZG93Rm9jdXMiLCJjbGllbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/providers/providers.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/font/google/target.css?{\"path\":\"src\\\\app\\\\layout.tsx\",\"import\":\"Montserrat\",\"arguments\":[{\"subsets\":[\"latin\",\"cyrillic\"],\"variable\":\"--font-montserrat\"}],\"variableName\":\"montserrat\"}":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/font/google/target.css?{"path":"src\\app\\layout.tsx","import":"Montserrat","arguments":[{"subsets":["latin","cyrillic"],"variable":"--font-montserrat"}],"variableName":"montserrat"} ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__Montserrat_44ac37', '__Montserrat_Fallback_44ac37'\",\"fontStyle\":\"normal\"},\"className\":\"__className_44ac37\",\"variable\":\"__variable_44ac37\"};\n    if(true) {\n      // 1716545546725\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwic3JjXFxcXGFwcFxcXFxsYXlvdXQudHN4XCIsXCJpbXBvcnRcIjpcIk1vbnRzZXJyYXRcIixcImFyZ3VtZW50c1wiOlt7XCJzdWJzZXRzXCI6W1wibGF0aW5cIixcImN5cmlsbGljXCJdLFwidmFyaWFibGVcIjpcIi0tZm9udC1tb250c2VycmF0XCJ9XSxcInZhcmlhYmxlTmFtZVwiOlwibW9udHNlcnJhdFwifSIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQixTQUFTLDBGQUEwRjtBQUNySCxPQUFPLElBQVU7QUFDakI7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxzWEFBcU4sY0FBYyxzREFBc0Q7QUFDdlQsTUFBTSxVQUFVO0FBQ2hCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuNzcuMi9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzPzM0MTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcInN0eWxlXCI6e1wiZm9udEZhbWlseVwiOlwiJ19fTW9udHNlcnJhdF80NGFjMzcnLCAnX19Nb250c2VycmF0X0ZhbGxiYWNrXzQ0YWMzNydcIixcImZvbnRTdHlsZVwiOlwibm9ybWFsXCJ9LFwiY2xhc3NOYW1lXCI6XCJfX2NsYXNzTmFtZV80NGFjMzdcIixcInZhcmlhYmxlXCI6XCJfX3ZhcmlhYmxlXzQ0YWMzN1wifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzE2NTQ1NTQ2NzI1XG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIkM6L1VzZXJzLzc5NTMzL0Rlc2t0b3AvZnJvbnQtcmJhbmQvcmJhbmQvbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTQuMi4xX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjFfc2Fzc0AxLjc3LjIvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIvX25leHQvXCIsXCJlc01vZHVsZVwiOmZhbHNlLFwibG9jYWxzXCI6dHJ1ZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/font/google/target.css?{\"path\":\"src\\\\app\\\\layout.tsx\",\"import\":\"Montserrat\",\"arguments\":[{\"subsets\":[\"latin\",\"cyrillic\"],\"variable\":\"--font-montserrat\"}],\"variableName\":\"montserrat\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/font/local/target.css?{\"path\":\"src\\\\app\\\\layout.tsx\",\"import\":\"\",\"arguments\":[{\"src\":[{\"path\":\"../fonts/IntroBlackCaps.ttf\"},{\"path\":\"../fonts/IntroBlackCaps.woff\"},{\"path\":\"../fonts/IntroBlackCaps.woff2\"}],\"variable\":\"--font-intro\",\"style\":\"normal\",\"weight\":\"900\"}],\"variableName\":\"intro\"}":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/font/local/target.css?{"path":"src\\app\\layout.tsx","import":"","arguments":[{"src":[{"path":"../fonts/IntroBlackCaps.ttf"},{"path":"../fonts/IntroBlackCaps.woff"},{"path":"../fonts/IntroBlackCaps.woff2"}],"variable":"--font-intro","style":"normal","weight":"900"}],"variableName":"intro"} ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'__intro_634dd6', '__intro_Fallback_634dd6'\"},\"className\":\"__className_634dd6\",\"variable\":\"__variable_634dd6\"};\n    if(true) {\n      // 1716545546727\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvbG9jYWwvdGFyZ2V0LmNzcz97XCJwYXRoXCI6XCJzcmNcXFxcYXBwXFxcXGxheW91dC50c3hcIixcImltcG9ydFwiOlwiXCIsXCJhcmd1bWVudHNcIjpbe1wic3JjXCI6W3tcInBhdGhcIjpcIi4uL2ZvbnRzL0ludHJvQmxhY2tDYXBzLnR0ZlwifSx7XCJwYXRoXCI6XCIuLi9mb250cy9JbnRyb0JsYWNrQ2Fwcy53b2ZmXCJ9LHtcInBhdGhcIjpcIi4uL2ZvbnRzL0ludHJvQmxhY2tDYXBzLndvZmYyXCJ9XSxcInZhcmlhYmxlXCI6XCItLWZvbnQtaW50cm9cIixcInN0eWxlXCI6XCJub3JtYWxcIixcIndlaWdodFwiOlwiOTAwXCJ9XSxcInZhcmlhYmxlTmFtZVwiOlwiaW50cm9cIn0iLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0IsU0FBUywyREFBMkQ7QUFDdEYsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsc1hBQXFOLGNBQWMsc0RBQXNEO0FBQ3ZULE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTQuMi4xX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjFfc2Fzc0AxLjc3LjIvbm9kZV9tb2R1bGVzL25leHQvZm9udC9sb2NhbC90YXJnZXQuY3NzPzA3ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcInN0eWxlXCI6e1wiZm9udEZhbWlseVwiOlwiJ19faW50cm9fNjM0ZGQ2JywgJ19faW50cm9fRmFsbGJhY2tfNjM0ZGQ2J1wifSxcImNsYXNzTmFtZVwiOlwiX19jbGFzc05hbWVfNjM0ZGQ2XCIsXCJ2YXJpYWJsZVwiOlwiX192YXJpYWJsZV82MzRkZDZcIn07XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTcxNjU0NTU0NjcyN1xuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCJDOi9Vc2Vycy83OTUzMy9EZXNrdG9wL2Zyb250LXJiYW5kL3JiYW5kL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiL19uZXh0L1wiLFwiZXNNb2R1bGVcIjpmYWxzZSxcImxvY2Fsc1wiOnRydWV9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgXG4gICAgfVxuICAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/font/local/target.css?{\"path\":\"src\\\\app\\\\layout.tsx\",\"import\":\"\",\"arguments\":[{\"src\":[{\"path\":\"../fonts/IntroBlackCaps.ttf\"},{\"path\":\"../fonts/IntroBlackCaps.woff\"},{\"path\":\"../fonts/IntroBlackCaps.woff2\"}],\"variable\":\"--font-intro\",\"style\":\"normal\",\"weight\":\"900\"}],\"variableName\":\"intro\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!*******************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*******************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyw2TEFBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz82YTBlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!*********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \*********************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSxxUkFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTQuMi4xX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjFfc2Fzc0AxLjc3LjIvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/NjdhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@darkroom.engineering+tempus@0.0.46/node_modules/@darkroom.engineering/tempus/dist/tempus.modern.mjs":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@darkroom.engineering+tempus@0.0.46/node_modules/@darkroom.engineering/tempus/dist/tempus.modern.mjs ***!
  \*********************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ a; }\n/* harmony export */ });\nvar a=\"undefined\"!=typeof window&&new class{constructor(){this.raf=a=>{requestAnimationFrame(this.raf);const t=a-this.now;this.now=a;for(let s=0;s<this.callbacks.length;s++)this.callbacks[s].callback(a,t)},this.callbacks=[],this.now=performance.now(),requestAnimationFrame(this.raf)}add(a,t=0){return this.callbacks.push({callback:a,priority:t}),this.callbacks.sort((a,t)=>a.priority-t.priority),()=>this.remove(a)}remove(a){this.callbacks=this.callbacks.filter(({callback:t})=>a!==t)}};\n//# sourceMappingURL=tempus.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AZGFya3Jvb20uZW5naW5lZXJpbmcrdGVtcHVzQDAuMC40Ni9ub2RlX21vZHVsZXMvQGRhcmtyb29tLmVuZ2luZWVyaW5nL3RlbXB1cy9kaXN0L3RlbXB1cy5tb2Rlcm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSw0Q0FBNEMsY0FBYyxhQUFhLGdDQUFnQyxtQkFBbUIsV0FBVyxZQUFZLHdCQUF3QixvQ0FBb0MsOEVBQThFLFdBQVcsNEJBQTRCLHNCQUFzQix1RUFBdUUsVUFBVSx1Q0FBdUMsV0FBVyxZQUFpQztBQUM1ZiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQGRhcmtyb29tLmVuZ2luZWVyaW5nK3RlbXB1c0AwLjAuNDYvbm9kZV9tb2R1bGVzL0BkYXJrcm9vbS5lbmdpbmVlcmluZy90ZW1wdXMvZGlzdC90ZW1wdXMubW9kZXJuLm1qcz82OWE3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBhPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJm5ldyBjbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMucmFmPWE9PntyZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yYWYpO2NvbnN0IHQ9YS10aGlzLm5vdzt0aGlzLm5vdz1hO2ZvcihsZXQgcz0wO3M8dGhpcy5jYWxsYmFja3MubGVuZ3RoO3MrKyl0aGlzLmNhbGxiYWNrc1tzXS5jYWxsYmFjayhhLHQpfSx0aGlzLmNhbGxiYWNrcz1bXSx0aGlzLm5vdz1wZXJmb3JtYW5jZS5ub3coKSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yYWYpfWFkZChhLHQ9MCl7cmV0dXJuIHRoaXMuY2FsbGJhY2tzLnB1c2goe2NhbGxiYWNrOmEscHJpb3JpdHk6dH0pLHRoaXMuY2FsbGJhY2tzLnNvcnQoKGEsdCk9PmEucHJpb3JpdHktdC5wcmlvcml0eSksKCk9PnRoaXMucmVtb3ZlKGEpfXJlbW92ZShhKXt0aGlzLmNhbGxiYWNrcz10aGlzLmNhbGxiYWNrcy5maWx0ZXIoKHtjYWxsYmFjazp0fSk9PmEhPT10KX19O2V4cG9ydHthIGFzIGRlZmF1bHR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVtcHVzLm1vZGVybi5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@darkroom.engineering+tempus@0.0.46/node_modules/@darkroom.engineering/tempus/dist/tempus.modern.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@iconify+react@4.1.1_react@18.3.1/node_modules/@iconify/react/dist/iconify.mjs":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@iconify+react@4.1.1_react@18.3.1/node_modules/@iconify/react/dist/iconify.mjs ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Icon: function() { return /* binding */ Icon; },\n/* harmony export */   InlineIcon: function() { return /* binding */ InlineIcon; },\n/* harmony export */   _api: function() { return /* binding */ _api; },\n/* harmony export */   addAPIProvider: function() { return /* binding */ addAPIProvider; },\n/* harmony export */   addCollection: function() { return /* binding */ addCollection; },\n/* harmony export */   addIcon: function() { return /* binding */ addIcon; },\n/* harmony export */   buildIcon: function() { return /* binding */ iconToSVG; },\n/* harmony export */   calculateSize: function() { return /* binding */ calculateSize; },\n/* harmony export */   disableCache: function() { return /* binding */ disableCache; },\n/* harmony export */   enableCache: function() { return /* binding */ enableCache; },\n/* harmony export */   getIcon: function() { return /* binding */ getIcon; },\n/* harmony export */   iconExists: function() { return /* binding */ iconExists; },\n/* harmony export */   listIcons: function() { return /* binding */ listIcons; },\n/* harmony export */   loadIcon: function() { return /* binding */ loadIcon; },\n/* harmony export */   loadIcons: function() { return /* binding */ loadIcons; },\n/* harmony export */   replaceIDs: function() { return /* binding */ replaceIDs; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_call_check__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_class_call_check.js\");\n/* harmony import */ var _swc_helpers_create_class__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/_/_create_class */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_create_class.js\");\n/* harmony import */ var _swc_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_inherits */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_inherits.js\");\n/* harmony import */ var _swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\n/* harmony import */ var _swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\n/* harmony import */ var _swc_helpers_type_of__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_type_of */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_type_of.js\");\n/* harmony import */ var _swc_helpers_create_super__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @swc/helpers/_/_create_super */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_create_super.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n\n\n\n\n\n\n\n\nvar matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;\nvar stringToIcon = function(value, validate, allowSimpleName) {\n    var provider = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"\";\n    var colonSeparated = value.split(\":\");\n    if (value.slice(0, 1) === \"@\") {\n        if (colonSeparated.length < 2 || colonSeparated.length > 3) {\n            return null;\n        }\n        provider = colonSeparated.shift().slice(1);\n    }\n    if (colonSeparated.length > 3 || !colonSeparated.length) {\n        return null;\n    }\n    if (colonSeparated.length > 1) {\n        var name2 = colonSeparated.pop();\n        var prefix = colonSeparated.pop();\n        var result = {\n            // Allow provider without '@': \"provider:prefix:name\"\n            provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,\n            prefix: prefix,\n            name: name2\n        };\n        return validate && !validateIconName(result) ? null : result;\n    }\n    var name = colonSeparated[0];\n    var dashSeparated = name.split(\"-\");\n    if (dashSeparated.length > 1) {\n        var result1 = {\n            provider: provider,\n            prefix: dashSeparated.shift(),\n            name: dashSeparated.join(\"-\")\n        };\n        return validate && !validateIconName(result1) ? null : result1;\n    }\n    if (allowSimpleName && provider === \"\") {\n        var result2 = {\n            provider: provider,\n            prefix: \"\",\n            name: name\n        };\n        return validate && !validateIconName(result2, allowSimpleName) ? null : result2;\n    }\n    return null;\n};\nvar validateIconName = function(icon, allowSimpleName) {\n    if (!icon) {\n        return false;\n    }\n    return !!((icon.provider === \"\" || icon.provider.match(matchIconName)) && (allowSimpleName && icon.prefix === \"\" || icon.prefix.match(matchIconName)) && icon.name.match(matchIconName));\n};\nvar defaultIconDimensions = Object.freeze({\n    left: 0,\n    top: 0,\n    width: 16,\n    height: 16\n});\nvar defaultIconTransformations = Object.freeze({\n    rotate: 0,\n    vFlip: false,\n    hFlip: false\n});\nvar defaultIconProps = Object.freeze((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, defaultIconDimensions, defaultIconTransformations));\nvar defaultExtendedIconProps = Object.freeze((0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_2__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, defaultIconProps), {\n    body: \"\",\n    hidden: false\n}));\nfunction mergeIconTransformations(obj1, obj2) {\n    var result = {};\n    if (!obj1.hFlip !== !obj2.hFlip) {\n        result.hFlip = true;\n    }\n    if (!obj1.vFlip !== !obj2.vFlip) {\n        result.vFlip = true;\n    }\n    var rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;\n    if (rotate) {\n        result.rotate = rotate;\n    }\n    return result;\n}\nfunction mergeIconData(parent, child) {\n    var result = mergeIconTransformations(parent, child);\n    for(var key in defaultExtendedIconProps){\n        if (key in defaultIconTransformations) {\n            if (key in parent && !(key in result)) {\n                result[key] = defaultIconTransformations[key];\n            }\n        } else if (key in child) {\n            result[key] = child[key];\n        } else if (key in parent) {\n            result[key] = parent[key];\n        }\n    }\n    return result;\n}\nfunction getIconsTree(data, names) {\n    var icons = data.icons;\n    var aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n    var resolved = /* @__PURE__ */ Object.create(null);\n    function resolve(name) {\n        if (icons[name]) {\n            return resolved[name] = [];\n        }\n        if (!(name in resolved)) {\n            resolved[name] = null;\n            var parent = aliases[name] && aliases[name].parent;\n            var value = parent && resolve(parent);\n            if (value) {\n                resolved[name] = [\n                    parent\n                ].concat(value);\n            }\n        }\n        return resolved[name];\n    }\n    (names || Object.keys(icons).concat(Object.keys(aliases))).forEach(resolve);\n    return resolved;\n}\nfunction internalGetIconData(data, name, tree) {\n    var icons = data.icons;\n    var aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n    var currentProps = {};\n    function parse(name2) {\n        currentProps = mergeIconData(icons[name2] || aliases[name2], currentProps);\n    }\n    parse(name);\n    tree.forEach(parse);\n    return mergeIconData(data, currentProps);\n}\nfunction parseIconSet(data, callback) {\n    var names = [];\n    if (typeof data !== \"object\" || typeof data.icons !== \"object\") {\n        return names;\n    }\n    if (data.not_found instanceof Array) {\n        data.not_found.forEach(function(name) {\n            callback(name, null);\n            names.push(name);\n        });\n    }\n    var tree = getIconsTree(data);\n    for(var name in tree){\n        var item = tree[name];\n        if (item) {\n            callback(name, internalGetIconData(data, name, item));\n            names.push(name);\n        }\n    }\n    return names;\n}\nvar optionalPropertyDefaults = (0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({\n    provider: \"\",\n    aliases: {},\n    not_found: {}\n}, defaultIconDimensions);\nfunction checkOptionalProps(item, defaults) {\n    for(var prop in defaults){\n        if (prop in item && (0,_swc_helpers_type_of__WEBPACK_IMPORTED_MODULE_3__._)(item[prop]) !== (0,_swc_helpers_type_of__WEBPACK_IMPORTED_MODULE_3__._)(defaults[prop])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction quicklyValidateIconSet(obj) {\n    if (typeof obj !== \"object\" || obj === null) {\n        return null;\n    }\n    var data = obj;\n    if (typeof data.prefix !== \"string\" || !obj.icons || typeof obj.icons !== \"object\") {\n        return null;\n    }\n    if (!checkOptionalProps(obj, optionalPropertyDefaults)) {\n        return null;\n    }\n    var icons = data.icons;\n    for(var name in icons){\n        var icon = icons[name];\n        if (!name.match(matchIconName) || typeof icon.body !== \"string\" || !checkOptionalProps(icon, defaultExtendedIconProps)) {\n            return null;\n        }\n    }\n    var aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n    for(var name1 in aliases){\n        var icon1 = aliases[name1];\n        var parent = icon1.parent;\n        if (!name1.match(matchIconName) || typeof parent !== \"string\" || !icons[parent] && !aliases[parent] || !checkOptionalProps(icon1, defaultExtendedIconProps)) {\n            return null;\n        }\n    }\n    return data;\n}\nvar dataStorage = /* @__PURE__ */ Object.create(null);\nfunction newStorage(provider, prefix) {\n    return {\n        provider: provider,\n        prefix: prefix,\n        icons: /* @__PURE__ */ Object.create(null),\n        missing: /* @__PURE__ */ new Set()\n    };\n}\nfunction getStorage(provider, prefix) {\n    var providerStorage = dataStorage[provider] || (dataStorage[provider] = /* @__PURE__ */ Object.create(null));\n    return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));\n}\nfunction addIconSet(storage, data) {\n    if (!quicklyValidateIconSet(data)) {\n        return [];\n    }\n    return parseIconSet(data, function(name, icon) {\n        if (icon) {\n            storage.icons[name] = icon;\n        } else {\n            storage.missing.add(name);\n        }\n    });\n}\nfunction addIconToStorage(storage, name, icon) {\n    try {\n        if (typeof icon.body === \"string\") {\n            storage.icons[name] = (0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, icon);\n            return true;\n        }\n    } catch (err) {}\n    return false;\n}\nfunction listIcons(provider, prefix) {\n    var allIcons = [];\n    var providers = typeof provider === \"string\" ? [\n        provider\n    ] : Object.keys(dataStorage);\n    providers.forEach(function(provider2) {\n        var prefixes = typeof provider2 === \"string\" && typeof prefix === \"string\" ? [\n            prefix\n        ] : Object.keys(dataStorage[provider2] || {});\n        prefixes.forEach(function(prefix2) {\n            var storage = getStorage(provider2, prefix2);\n            allIcons = allIcons.concat(Object.keys(storage.icons).map(function(name) {\n                return (provider2 !== \"\" ? \"@\" + provider2 + \":\" : \"\") + prefix2 + \":\" + name;\n            }));\n        });\n    });\n    return allIcons;\n}\nvar simpleNames = false;\nfunction allowSimpleNames(allow) {\n    if (typeof allow === \"boolean\") {\n        simpleNames = allow;\n    }\n    return simpleNames;\n}\nfunction getIconData(name) {\n    var icon = typeof name === \"string\" ? stringToIcon(name, true, simpleNames) : name;\n    if (icon) {\n        var storage = getStorage(icon.provider, icon.prefix);\n        var iconName = icon.name;\n        return storage.icons[iconName] || (storage.missing.has(iconName) ? null : void 0);\n    }\n}\nfunction addIcon(name, data) {\n    var icon = stringToIcon(name, true, simpleNames);\n    if (!icon) {\n        return false;\n    }\n    var storage = getStorage(icon.provider, icon.prefix);\n    return addIconToStorage(storage, icon.name, data);\n}\nfunction addCollection(data, provider) {\n    if (typeof data !== \"object\") {\n        return false;\n    }\n    if (typeof provider !== \"string\") {\n        provider = data.provider || \"\";\n    }\n    if (simpleNames && !provider && !data.prefix) {\n        var added = false;\n        if (quicklyValidateIconSet(data)) {\n            data.prefix = \"\";\n            parseIconSet(data, function(name, icon) {\n                if (icon && addIcon(name, icon)) {\n                    added = true;\n                }\n            });\n        }\n        return added;\n    }\n    var prefix = data.prefix;\n    if (!validateIconName({\n        provider: provider,\n        prefix: prefix,\n        name: \"a\"\n    })) {\n        return false;\n    }\n    var storage = getStorage(provider, prefix);\n    return !!addIconSet(storage, data);\n}\nfunction iconExists(name) {\n    return !!getIconData(name);\n}\nfunction getIcon(name) {\n    var result = getIconData(name);\n    return result ? (0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, defaultIconProps, result) : null;\n}\nvar defaultIconSizeCustomisations = Object.freeze({\n    width: null,\n    height: null\n});\nvar defaultIconCustomisations = Object.freeze((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, defaultIconSizeCustomisations, defaultIconTransformations));\nvar unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;\nvar unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;\nfunction calculateSize(size, ratio, precision) {\n    if (ratio === 1) {\n        return size;\n    }\n    precision = precision || 100;\n    if (typeof size === \"number\") {\n        return Math.ceil(size * ratio * precision) / precision;\n    }\n    if (typeof size !== \"string\") {\n        return size;\n    }\n    var oldParts = size.split(unitsSplit);\n    if (oldParts === null || !oldParts.length) {\n        return size;\n    }\n    var newParts = [];\n    var code = oldParts.shift();\n    var isNumber = unitsTest.test(code);\n    while(true){\n        if (isNumber) {\n            var num = parseFloat(code);\n            if (isNaN(num)) {\n                newParts.push(code);\n            } else {\n                newParts.push(Math.ceil(num * ratio * precision) / precision);\n            }\n        } else {\n            newParts.push(code);\n        }\n        code = oldParts.shift();\n        if (code === void 0) {\n            return newParts.join(\"\");\n        }\n        isNumber = !isNumber;\n    }\n}\nvar isUnsetKeyword = function(value) {\n    return value === \"unset\" || value === \"undefined\" || value === \"none\";\n};\nfunction iconToSVG(icon, customisations) {\n    var fullIcon = (0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, defaultIconProps, icon);\n    var fullCustomisations = (0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, defaultIconCustomisations, customisations);\n    var box = {\n        left: fullIcon.left,\n        top: fullIcon.top,\n        width: fullIcon.width,\n        height: fullIcon.height\n    };\n    var body = fullIcon.body;\n    [\n        fullIcon,\n        fullCustomisations\n    ].forEach(function(props) {\n        var transformations = [];\n        var hFlip = props.hFlip;\n        var vFlip = props.vFlip;\n        var rotation = props.rotate;\n        if (hFlip) {\n            if (vFlip) {\n                rotation += 2;\n            } else {\n                transformations.push(\"translate(\" + (box.width + box.left).toString() + \" \" + (0 - box.top).toString() + \")\");\n                transformations.push(\"scale(-1 1)\");\n                box.top = box.left = 0;\n            }\n        } else if (vFlip) {\n            transformations.push(\"translate(\" + (0 - box.left).toString() + \" \" + (box.height + box.top).toString() + \")\");\n            transformations.push(\"scale(1 -1)\");\n            box.top = box.left = 0;\n        }\n        var tempValue;\n        if (rotation < 0) {\n            rotation -= Math.floor(rotation / 4) * 4;\n        }\n        rotation = rotation % 4;\n        switch(rotation){\n            case 1:\n                tempValue = box.height / 2 + box.top;\n                transformations.unshift(\"rotate(90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n                break;\n            case 2:\n                transformations.unshift(\"rotate(180 \" + (box.width / 2 + box.left).toString() + \" \" + (box.height / 2 + box.top).toString() + \")\");\n                break;\n            case 3:\n                tempValue = box.width / 2 + box.left;\n                transformations.unshift(\"rotate(-90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n                break;\n        }\n        if (rotation % 2 === 1) {\n            if (box.left !== box.top) {\n                tempValue = box.left;\n                box.left = box.top;\n                box.top = tempValue;\n            }\n            if (box.width !== box.height) {\n                tempValue = box.width;\n                box.width = box.height;\n                box.height = tempValue;\n            }\n        }\n        if (transformations.length) {\n            body = '<g transform=\"' + transformations.join(\" \") + '\">' + body + \"</g>\";\n        }\n    });\n    var customisationsWidth = fullCustomisations.width;\n    var customisationsHeight = fullCustomisations.height;\n    var boxWidth = box.width;\n    var boxHeight = box.height;\n    var width;\n    var height;\n    if (customisationsWidth === null) {\n        height = customisationsHeight === null ? \"1em\" : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n        width = calculateSize(height, boxWidth / boxHeight);\n    } else {\n        width = customisationsWidth === \"auto\" ? boxWidth : customisationsWidth;\n        height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n    }\n    var attributes = {};\n    var setAttr = function(prop, value) {\n        if (!isUnsetKeyword(value)) {\n            attributes[prop] = value.toString();\n        }\n    };\n    setAttr(\"width\", width);\n    setAttr(\"height\", height);\n    attributes.viewBox = box.left.toString() + \" \" + box.top.toString() + \" \" + boxWidth.toString() + \" \" + boxHeight.toString();\n    return {\n        attributes: attributes,\n        body: body\n    };\n}\nvar regex = /\\sid=\"(\\S+)\"/g;\nvar randomPrefix = \"IconifyId\" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);\nvar counter = 0;\nfunction replaceIDs(body) {\n    var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : randomPrefix;\n    var ids = [];\n    var match;\n    while(match = regex.exec(body)){\n        ids.push(match[1]);\n    }\n    if (!ids.length) {\n        return body;\n    }\n    var suffix = \"suffix\" + (Math.random() * 16777216 | Date.now()).toString(16);\n    ids.forEach(function(id) {\n        var newID = typeof prefix === \"function\" ? prefix(id) : prefix + (counter++).toString();\n        var escapedID = id.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n        body = body.replace(// Allowed characters before id: [#;\"]\n        // Allowed characters after id: [)\"], .[a-z]\n        new RegExp('([#;\"])(' + escapedID + ')([\")]|\\\\.[a-z])', \"g\"), \"$1\" + newID + suffix + \"$3\");\n    });\n    body = body.replace(new RegExp(suffix, \"g\"), \"\");\n    return body;\n}\nvar storage = /* @__PURE__ */ Object.create(null);\nfunction setAPIModule(provider, item) {\n    storage[provider] = item;\n}\nfunction getAPIModule(provider) {\n    return storage[provider] || storage[\"\"];\n}\nfunction createAPIConfig(source) {\n    var resources;\n    if (typeof source.resources === \"string\") {\n        resources = [\n            source.resources\n        ];\n    } else {\n        resources = source.resources;\n        if (!(resources instanceof Array) || !resources.length) {\n            return null;\n        }\n    }\n    var result = {\n        // API hosts\n        resources: resources,\n        // Root path\n        path: source.path || \"/\",\n        // URL length limit\n        maxURL: source.maxURL || 500,\n        // Timeout before next host is used.\n        rotate: source.rotate || 750,\n        // Timeout before failing query.\n        timeout: source.timeout || 5e3,\n        // Randomise default API end point.\n        random: source.random === true,\n        // Start index\n        index: source.index || 0,\n        // Receive data after time out (used if time out kicks in first, then API module sends data anyway).\n        dataAfterTimeout: source.dataAfterTimeout !== false\n    };\n    return result;\n}\nvar configStorage = /* @__PURE__ */ Object.create(null);\nvar fallBackAPISources = [\n    \"https://api.simplesvg.com\",\n    \"https://api.unisvg.com\"\n];\nvar fallBackAPI = [];\nwhile(fallBackAPISources.length > 0){\n    if (fallBackAPISources.length === 1) {\n        fallBackAPI.push(fallBackAPISources.shift());\n    } else {\n        if (Math.random() > 0.5) {\n            fallBackAPI.push(fallBackAPISources.shift());\n        } else {\n            fallBackAPI.push(fallBackAPISources.pop());\n        }\n    }\n}\nconfigStorage[\"\"] = createAPIConfig({\n    resources: [\n        \"https://api.iconify.design\"\n    ].concat(fallBackAPI)\n});\nfunction addAPIProvider(provider, customConfig) {\n    var config = createAPIConfig(customConfig);\n    if (config === null) {\n        return false;\n    }\n    configStorage[provider] = config;\n    return true;\n}\nfunction getAPIConfig(provider) {\n    return configStorage[provider];\n}\nfunction listAPIProviders() {\n    return Object.keys(configStorage);\n}\nvar detectFetch = function() {\n    var callback;\n    try {\n        callback = fetch;\n        if (typeof callback === \"function\") {\n            return callback;\n        }\n    } catch (err) {}\n};\nvar fetchModule = detectFetch();\nfunction setFetch(fetch2) {\n    fetchModule = fetch2;\n}\nfunction getFetch() {\n    return fetchModule;\n}\nfunction calculateMaxLength(provider, prefix) {\n    var config = getAPIConfig(provider);\n    if (!config) {\n        return 0;\n    }\n    var result;\n    if (!config.maxURL) {\n        result = 0;\n    } else {\n        var maxHostLength = 0;\n        config.resources.forEach(function(item) {\n            var host = item;\n            maxHostLength = Math.max(maxHostLength, host.length);\n        });\n        var url = prefix + \".json?icons=\";\n        result = config.maxURL - maxHostLength - config.path.length - url.length;\n    }\n    return result;\n}\nfunction shouldAbort(status) {\n    return status === 404;\n}\nvar prepare = function(provider, prefix, icons) {\n    var results = [];\n    var maxLength = calculateMaxLength(provider, prefix);\n    var type = \"icons\";\n    var item = {\n        type: type,\n        provider: provider,\n        prefix: prefix,\n        icons: []\n    };\n    var length = 0;\n    icons.forEach(function(name, index) {\n        length += name.length + 1;\n        if (length >= maxLength && index > 0) {\n            results.push(item);\n            item = {\n                type: type,\n                provider: provider,\n                prefix: prefix,\n                icons: []\n            };\n            length = name.length;\n        }\n        item.icons.push(name);\n    });\n    results.push(item);\n    return results;\n};\nfunction getPath(provider) {\n    if (typeof provider === \"string\") {\n        var config = getAPIConfig(provider);\n        if (config) {\n            return config.path;\n        }\n    }\n    return \"/\";\n}\nvar send = function(host, params, callback) {\n    if (!fetchModule) {\n        callback(\"abort\", 424);\n        return;\n    }\n    var path = getPath(params.provider);\n    switch(params.type){\n        case \"icons\":\n            {\n                var prefix = params.prefix;\n                var icons = params.icons;\n                var iconsList = icons.join(\",\");\n                var urlParams = new URLSearchParams({\n                    icons: iconsList\n                });\n                path += prefix + \".json?\" + urlParams.toString();\n                break;\n            }\n        case \"custom\":\n            {\n                var uri = params.uri;\n                path += uri.slice(0, 1) === \"/\" ? uri.slice(1) : uri;\n                break;\n            }\n        default:\n            callback(\"abort\", 400);\n            return;\n    }\n    var defaultError = 503;\n    fetchModule(host + path).then(function(response) {\n        var status = response.status;\n        if (status !== 200) {\n            setTimeout(function() {\n                callback(shouldAbort(status) ? \"abort\" : \"next\", status);\n            });\n            return;\n        }\n        defaultError = 501;\n        return response.json();\n    }).then(function(data) {\n        if (typeof data !== \"object\" || data === null) {\n            setTimeout(function() {\n                if (data === 404) {\n                    callback(\"abort\", data);\n                } else {\n                    callback(\"next\", defaultError);\n                }\n            });\n            return;\n        }\n        setTimeout(function() {\n            callback(\"success\", data);\n        });\n    })[\"catch\"](function() {\n        callback(\"next\", defaultError);\n    });\n};\nvar fetchAPIModule = {\n    prepare: prepare,\n    send: send\n};\nfunction sortIcons(icons) {\n    var result = {\n        loaded: [],\n        missing: [],\n        pending: []\n    };\n    var storage = /* @__PURE__ */ Object.create(null);\n    icons.sort(function(a, b) {\n        if (a.provider !== b.provider) {\n            return a.provider.localeCompare(b.provider);\n        }\n        if (a.prefix !== b.prefix) {\n            return a.prefix.localeCompare(b.prefix);\n        }\n        return a.name.localeCompare(b.name);\n    });\n    var lastIcon = {\n        provider: \"\",\n        prefix: \"\",\n        name: \"\"\n    };\n    icons.forEach(function(icon) {\n        if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {\n            return;\n        }\n        lastIcon = icon;\n        var provider = icon.provider;\n        var prefix = icon.prefix;\n        var name = icon.name;\n        var providerStorage = storage[provider] || (storage[provider] = /* @__PURE__ */ Object.create(null));\n        var localStorage = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));\n        var list;\n        if (name in localStorage.icons) {\n            list = result.loaded;\n        } else if (prefix === \"\" || localStorage.missing.has(name)) {\n            list = result.missing;\n        } else {\n            list = result.pending;\n        }\n        var item = {\n            provider: provider,\n            prefix: prefix,\n            name: name\n        };\n        list.push(item);\n    });\n    return result;\n}\nfunction removeCallback(storages, id) {\n    storages.forEach(function(storage) {\n        var items = storage.loaderCallbacks;\n        if (items) {\n            storage.loaderCallbacks = items.filter(function(row) {\n                return row.id !== id;\n            });\n        }\n    });\n}\nfunction updateCallbacks(storage) {\n    if (!storage.pendingCallbacksFlag) {\n        storage.pendingCallbacksFlag = true;\n        setTimeout(function() {\n            storage.pendingCallbacksFlag = false;\n            var items = storage.loaderCallbacks ? storage.loaderCallbacks.slice(0) : [];\n            if (!items.length) {\n                return;\n            }\n            var hasPending = false;\n            var provider = storage.provider;\n            var prefix = storage.prefix;\n            items.forEach(function(item) {\n                var icons = item.icons;\n                var oldLength = icons.pending.length;\n                icons.pending = icons.pending.filter(function(icon) {\n                    if (icon.prefix !== prefix) {\n                        return true;\n                    }\n                    var name = icon.name;\n                    if (storage.icons[name]) {\n                        icons.loaded.push({\n                            provider: provider,\n                            prefix: prefix,\n                            name: name\n                        });\n                    } else if (storage.missing.has(name)) {\n                        icons.missing.push({\n                            provider: provider,\n                            prefix: prefix,\n                            name: name\n                        });\n                    } else {\n                        hasPending = true;\n                        return true;\n                    }\n                    return false;\n                });\n                if (icons.pending.length !== oldLength) {\n                    if (!hasPending) {\n                        removeCallback([\n                            storage\n                        ], item.id);\n                    }\n                    item.callback(icons.loaded.slice(0), icons.missing.slice(0), icons.pending.slice(0), item.abort);\n                }\n            });\n        });\n    }\n}\nvar idCounter = 0;\nfunction storeCallback(callback, icons, pendingSources) {\n    var id = idCounter++;\n    var abort = removeCallback.bind(null, pendingSources, id);\n    if (!icons.pending.length) {\n        return abort;\n    }\n    var item = {\n        id: id,\n        icons: icons,\n        callback: callback,\n        abort: abort\n    };\n    pendingSources.forEach(function(storage) {\n        (storage.loaderCallbacks || (storage.loaderCallbacks = [])).push(item);\n    });\n    return abort;\n}\nfunction listToIcons(list) {\n    var validate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, simpleNames = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    var result = [];\n    list.forEach(function(item) {\n        var icon = typeof item === \"string\" ? stringToIcon(item, validate, simpleNames) : item;\n        if (icon) {\n            result.push(icon);\n        }\n    });\n    return result;\n}\n// src/config.ts\nvar defaultConfig = {\n    resources: [],\n    index: 0,\n    timeout: 2e3,\n    rotate: 750,\n    random: false,\n    dataAfterTimeout: false\n};\n// src/query.ts\nfunction sendQuery(config, payload, query, done) {\n    var resourcesCount = config.resources.length;\n    var startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;\n    var resources;\n    if (config.random) {\n        var list = config.resources.slice(0);\n        resources = [];\n        while(list.length > 1){\n            var nextIndex = Math.floor(Math.random() * list.length);\n            resources.push(list[nextIndex]);\n            list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));\n        }\n        resources = resources.concat(list);\n    } else {\n        resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));\n    }\n    var startTime = Date.now();\n    var status = \"pending\";\n    var queriesSent = 0;\n    var lastError;\n    var timer = null;\n    var queue = [];\n    var doneCallbacks = [];\n    if (typeof done === \"function\") {\n        doneCallbacks.push(done);\n    }\n    function resetTimer() {\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n        }\n    }\n    function abort() {\n        if (status === \"pending\") {\n            status = \"aborted\";\n        }\n        resetTimer();\n        queue.forEach(function(item) {\n            if (item.status === \"pending\") {\n                item.status = \"aborted\";\n            }\n        });\n        queue = [];\n    }\n    function subscribe(callback, overwrite) {\n        if (overwrite) {\n            doneCallbacks = [];\n        }\n        if (typeof callback === \"function\") {\n            doneCallbacks.push(callback);\n        }\n    }\n    function getQueryStatus() {\n        return {\n            startTime: startTime,\n            payload: payload,\n            status: status,\n            queriesSent: queriesSent,\n            queriesPending: queue.length,\n            subscribe: subscribe,\n            abort: abort\n        };\n    }\n    function failQuery() {\n        status = \"failed\";\n        doneCallbacks.forEach(function(callback) {\n            callback(void 0, lastError);\n        });\n    }\n    function clearQueue() {\n        queue.forEach(function(item) {\n            if (item.status === \"pending\") {\n                item.status = \"aborted\";\n            }\n        });\n        queue = [];\n    }\n    function moduleResponse(item, response, data) {\n        var isError = response !== \"success\";\n        queue = queue.filter(function(queued) {\n            return queued !== item;\n        });\n        switch(status){\n            case \"pending\":\n                break;\n            case \"failed\":\n                if (isError || !config.dataAfterTimeout) {\n                    return;\n                }\n                break;\n            default:\n                return;\n        }\n        if (response === \"abort\") {\n            lastError = data;\n            failQuery();\n            return;\n        }\n        if (isError) {\n            lastError = data;\n            if (!queue.length) {\n                if (!resources.length) {\n                    failQuery();\n                } else {\n                    execNext();\n                }\n            }\n            return;\n        }\n        resetTimer();\n        clearQueue();\n        if (!config.random) {\n            var index = config.resources.indexOf(item.resource);\n            if (index !== -1 && index !== config.index) {\n                config.index = index;\n            }\n        }\n        status = \"completed\";\n        doneCallbacks.forEach(function(callback) {\n            callback(data);\n        });\n    }\n    function execNext() {\n        if (status !== \"pending\") {\n            return;\n        }\n        resetTimer();\n        var resource = resources.shift();\n        if (resource === void 0) {\n            if (queue.length) {\n                timer = setTimeout(function() {\n                    resetTimer();\n                    if (status === \"pending\") {\n                        clearQueue();\n                        failQuery();\n                    }\n                }, config.timeout);\n                return;\n            }\n            failQuery();\n            return;\n        }\n        var item = {\n            status: \"pending\",\n            resource: resource,\n            callback: function(status2, data) {\n                moduleResponse(item, status2, data);\n            }\n        };\n        queue.push(item);\n        queriesSent++;\n        timer = setTimeout(execNext, config.rotate);\n        query(resource, payload, item.callback);\n    }\n    setTimeout(execNext);\n    return getQueryStatus;\n}\n// src/index.ts\nfunction initRedundancy(cfg) {\n    var config = (0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, defaultConfig, cfg);\n    var queries = [];\n    function cleanup() {\n        queries = queries.filter(function(item) {\n            return item().status === \"pending\";\n        });\n    }\n    function query(payload, queryCallback, doneCallback) {\n        var query2 = sendQuery(config, payload, queryCallback, function(data, error) {\n            cleanup();\n            if (doneCallback) {\n                doneCallback(data, error);\n            }\n        });\n        queries.push(query2);\n        return query2;\n    }\n    function find(callback) {\n        return queries.find(function(value) {\n            return callback(value);\n        }) || null;\n    }\n    var instance = {\n        query: query,\n        find: find,\n        setIndex: function(index) {\n            config.index = index;\n        },\n        getIndex: function() {\n            return config.index;\n        },\n        cleanup: cleanup\n    };\n    return instance;\n}\nfunction emptyCallback$1() {}\nvar redundancyCache = /* @__PURE__ */ Object.create(null);\nfunction getRedundancyCache(provider) {\n    if (!redundancyCache[provider]) {\n        var config = getAPIConfig(provider);\n        if (!config) {\n            return;\n        }\n        var redundancy = initRedundancy(config);\n        var cachedReundancy = {\n            config: config,\n            redundancy: redundancy\n        };\n        redundancyCache[provider] = cachedReundancy;\n    }\n    return redundancyCache[provider];\n}\nfunction sendAPIQuery(target, query, callback) {\n    var redundancy;\n    var send;\n    if (typeof target === \"string\") {\n        var api = getAPIModule(target);\n        if (!api) {\n            callback(void 0, 424);\n            return emptyCallback$1;\n        }\n        send = api.send;\n        var cached = getRedundancyCache(target);\n        if (cached) {\n            redundancy = cached.redundancy;\n        }\n    } else {\n        var config = createAPIConfig(target);\n        if (config) {\n            redundancy = initRedundancy(config);\n            var moduleKey = target.resources ? target.resources[0] : \"\";\n            var api1 = getAPIModule(moduleKey);\n            if (api1) {\n                send = api1.send;\n            }\n        }\n    }\n    if (!redundancy || !send) {\n        callback(void 0, 424);\n        return emptyCallback$1;\n    }\n    return redundancy.query(query, send, callback)().abort;\n}\nvar browserCacheVersion = \"iconify2\";\nvar browserCachePrefix = \"iconify\";\nvar browserCacheCountKey = browserCachePrefix + \"-count\";\nvar browserCacheVersionKey = browserCachePrefix + \"-version\";\nvar browserStorageHour = 36e5;\nvar browserStorageCacheExpiration = 168;\nfunction getStoredItem(func, key) {\n    try {\n        return func.getItem(key);\n    } catch (err) {}\n}\nfunction setStoredItem(func, key, value) {\n    try {\n        func.setItem(key, value);\n        return true;\n    } catch (err) {}\n}\nfunction removeStoredItem(func, key) {\n    try {\n        func.removeItem(key);\n    } catch (err) {}\n}\nfunction setBrowserStorageItemsCount(storage, value) {\n    return setStoredItem(storage, browserCacheCountKey, value.toString());\n}\nfunction getBrowserStorageItemsCount(storage) {\n    return parseInt(getStoredItem(storage, browserCacheCountKey)) || 0;\n}\nvar browserStorageConfig = {\n    local: true,\n    session: true\n};\nvar browserStorageEmptyItems = {\n    local: /* @__PURE__ */ new Set(),\n    session: /* @__PURE__ */ new Set()\n};\nvar browserStorageStatus = false;\nfunction setBrowserStorageStatus(status) {\n    browserStorageStatus = status;\n}\nvar _window = typeof window === \"undefined\" ? {} : window;\nfunction getBrowserStorage(key) {\n    var attr = key + \"Storage\";\n    try {\n        if (_window && _window[attr] && typeof _window[attr].length === \"number\") {\n            return _window[attr];\n        }\n    } catch (err) {}\n    browserStorageConfig[key] = false;\n}\nfunction iterateBrowserStorage(key, callback) {\n    var func = getBrowserStorage(key);\n    if (!func) {\n        return;\n    }\n    var version = getStoredItem(func, browserCacheVersionKey);\n    if (version !== browserCacheVersion) {\n        if (version) {\n            var total2 = getBrowserStorageItemsCount(func);\n            for(var i = 0; i < total2; i++){\n                removeStoredItem(func, browserCachePrefix + i.toString());\n            }\n        }\n        setStoredItem(func, browserCacheVersionKey, browserCacheVersion);\n        setBrowserStorageItemsCount(func, 0);\n        return;\n    }\n    var minTime = Math.floor(Date.now() / browserStorageHour) - browserStorageCacheExpiration;\n    var parseItem = function(index) {\n        var name = browserCachePrefix + index.toString();\n        var item = getStoredItem(func, name);\n        if (typeof item !== \"string\") {\n            return;\n        }\n        try {\n            var data = JSON.parse(item);\n            if (typeof data === \"object\" && typeof data.cached === \"number\" && data.cached > minTime && typeof data.provider === \"string\" && typeof data.data === \"object\" && typeof data.data.prefix === \"string\" && // Valid item: run callback\n            callback(data, index)) {\n                return true;\n            }\n        } catch (err) {}\n        removeStoredItem(func, name);\n    };\n    var total = getBrowserStorageItemsCount(func);\n    for(var i1 = total - 1; i1 >= 0; i1--){\n        if (!parseItem(i1)) {\n            if (i1 === total - 1) {\n                total--;\n                setBrowserStorageItemsCount(func, total);\n            } else {\n                browserStorageEmptyItems[key].add(i1);\n            }\n        }\n    }\n}\nfunction initBrowserStorage() {\n    if (browserStorageStatus) {\n        return;\n    }\n    setBrowserStorageStatus(true);\n    for(var key in browserStorageConfig){\n        iterateBrowserStorage(key, function(item) {\n            var iconSet = item.data;\n            var provider = item.provider;\n            var prefix = iconSet.prefix;\n            var storage = getStorage(provider, prefix);\n            if (!addIconSet(storage, iconSet).length) {\n                return false;\n            }\n            var lastModified = iconSet.lastModified || -1;\n            storage.lastModifiedCached = storage.lastModifiedCached ? Math.min(storage.lastModifiedCached, lastModified) : lastModified;\n            return true;\n        });\n    }\n}\nfunction updateLastModified(storage, lastModified) {\n    var lastValue = storage.lastModifiedCached;\n    if (// Matches or newer\n    lastValue && lastValue >= lastModified) {\n        return lastValue === lastModified;\n    }\n    storage.lastModifiedCached = lastModified;\n    if (lastValue) {\n        for(var key in browserStorageConfig){\n            iterateBrowserStorage(key, function(item) {\n                var iconSet = item.data;\n                return item.provider !== storage.provider || iconSet.prefix !== storage.prefix || iconSet.lastModified === lastModified;\n            });\n        }\n    }\n    return true;\n}\nfunction storeInBrowserStorage(storage, data) {\n    if (!browserStorageStatus) {\n        initBrowserStorage();\n    }\n    function store(key) {\n        var func;\n        if (!browserStorageConfig[key] || !(func = getBrowserStorage(key))) {\n            return;\n        }\n        var set = browserStorageEmptyItems[key];\n        var index;\n        if (set.size) {\n            set[\"delete\"](index = Array.from(set).shift());\n        } else {\n            index = getBrowserStorageItemsCount(func);\n            if (!setBrowserStorageItemsCount(func, index + 1)) {\n                return;\n            }\n        }\n        var item = {\n            cached: Math.floor(Date.now() / browserStorageHour),\n            provider: storage.provider,\n            data: data\n        };\n        return setStoredItem(func, browserCachePrefix + index.toString(), JSON.stringify(item));\n    }\n    if (data.lastModified && !updateLastModified(storage, data.lastModified)) {\n        return;\n    }\n    if (!Object.keys(data.icons).length) {\n        return;\n    }\n    if (data.not_found) {\n        data = Object.assign({}, data);\n        delete data.not_found;\n    }\n    if (!store(\"local\")) {\n        store(\"session\");\n    }\n}\nfunction emptyCallback() {}\nfunction loadedNewIcons(storage) {\n    if (!storage.iconsLoaderFlag) {\n        storage.iconsLoaderFlag = true;\n        setTimeout(function() {\n            storage.iconsLoaderFlag = false;\n            updateCallbacks(storage);\n        });\n    }\n}\nfunction loadNewIcons(storage, icons) {\n    if (!storage.iconsToLoad) {\n        storage.iconsToLoad = icons;\n    } else {\n        storage.iconsToLoad = storage.iconsToLoad.concat(icons).sort();\n    }\n    if (!storage.iconsQueueFlag) {\n        storage.iconsQueueFlag = true;\n        setTimeout(function() {\n            storage.iconsQueueFlag = false;\n            var provider = storage.provider, prefix = storage.prefix;\n            var icons2 = storage.iconsToLoad;\n            delete storage.iconsToLoad;\n            var api;\n            if (!icons2 || !(api = getAPIModule(provider))) {\n                return;\n            }\n            var params = api.prepare(provider, prefix, icons2);\n            params.forEach(function(item) {\n                sendAPIQuery(provider, item, function(data) {\n                    if (typeof data !== \"object\") {\n                        item.icons.forEach(function(name) {\n                            storage.missing.add(name);\n                        });\n                    } else {\n                        try {\n                            var parsed = addIconSet(storage, data);\n                            if (!parsed.length) {\n                                return;\n                            }\n                            var pending = storage.pendingIcons;\n                            if (pending) {\n                                parsed.forEach(function(name) {\n                                    pending[\"delete\"](name);\n                                });\n                            }\n                            storeInBrowserStorage(storage, data);\n                        } catch (err) {\n                            console.error(err);\n                        }\n                    }\n                    loadedNewIcons(storage);\n                });\n            });\n        });\n    }\n}\nvar loadIcons = function(icons, callback) {\n    var cleanedIcons = listToIcons(icons, true, allowSimpleNames());\n    var sortedIcons = sortIcons(cleanedIcons);\n    if (!sortedIcons.pending.length) {\n        var callCallback = true;\n        if (callback) {\n            setTimeout(function() {\n                if (callCallback) {\n                    callback(sortedIcons.loaded, sortedIcons.missing, sortedIcons.pending, emptyCallback);\n                }\n            });\n        }\n        return function() {\n            callCallback = false;\n        };\n    }\n    var newIcons = /* @__PURE__ */ Object.create(null);\n    var sources = [];\n    var lastProvider, lastPrefix;\n    sortedIcons.pending.forEach(function(icon) {\n        var provider = icon.provider, prefix = icon.prefix;\n        if (prefix === lastPrefix && provider === lastProvider) {\n            return;\n        }\n        lastProvider = provider;\n        lastPrefix = prefix;\n        sources.push(getStorage(provider, prefix));\n        var providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */ Object.create(null));\n        if (!providerNewIcons[prefix]) {\n            providerNewIcons[prefix] = [];\n        }\n    });\n    sortedIcons.pending.forEach(function(icon) {\n        var provider = icon.provider, prefix = icon.prefix, name = icon.name;\n        var storage = getStorage(provider, prefix);\n        var pendingQueue = storage.pendingIcons || (storage.pendingIcons = /* @__PURE__ */ new Set());\n        if (!pendingQueue.has(name)) {\n            pendingQueue.add(name);\n            newIcons[provider][prefix].push(name);\n        }\n    });\n    sources.forEach(function(storage) {\n        var provider = storage.provider, prefix = storage.prefix;\n        if (newIcons[provider][prefix].length) {\n            loadNewIcons(storage, newIcons[provider][prefix]);\n        }\n    });\n    return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;\n};\nvar loadIcon = function(icon) {\n    return new Promise(function(fulfill, reject) {\n        var iconObj = typeof icon === \"string\" ? stringToIcon(icon, true) : icon;\n        if (!iconObj) {\n            reject(icon);\n            return;\n        }\n        loadIcons([\n            iconObj || icon\n        ], function(loaded) {\n            if (loaded.length && iconObj) {\n                var data = getIconData(iconObj);\n                if (data) {\n                    fulfill((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, defaultIconProps, data));\n                    return;\n                }\n            }\n            reject(icon);\n        });\n    });\n};\nfunction toggleBrowserCache(storage, value) {\n    switch(storage){\n        case \"local\":\n        case \"session\":\n            browserStorageConfig[storage] = value;\n            break;\n        case \"all\":\n            for(var key in browserStorageConfig){\n                browserStorageConfig[key] = value;\n            }\n            break;\n    }\n}\nfunction mergeCustomisations(defaults, item) {\n    var result = (0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, defaults);\n    for(var key in item){\n        var value = item[key];\n        var valueType = typeof value === \"undefined\" ? \"undefined\" : (0,_swc_helpers_type_of__WEBPACK_IMPORTED_MODULE_3__._)(value);\n        if (key in defaultIconSizeCustomisations) {\n            if (value === null || value && (valueType === \"string\" || valueType === \"number\")) {\n                result[key] = value;\n            }\n        } else if (valueType === (0,_swc_helpers_type_of__WEBPACK_IMPORTED_MODULE_3__._)(result[key])) {\n            result[key] = key === \"rotate\" ? value % 4 : value;\n        }\n    }\n    return result;\n}\nvar separator = /[\\s,]+/;\nfunction flipFromString(custom, flip) {\n    flip.split(separator).forEach(function(str) {\n        var value = str.trim();\n        switch(value){\n            case \"horizontal\":\n                custom.hFlip = true;\n                break;\n            case \"vertical\":\n                custom.vFlip = true;\n                break;\n        }\n    });\n}\nfunction rotateFromString(value) {\n    var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    var units = value.replace(/^-?[0-9.]*/, \"\");\n    function cleanup(value2) {\n        while(value2 < 0){\n            value2 += 4;\n        }\n        return value2 % 4;\n    }\n    if (units === \"\") {\n        var num = parseInt(value);\n        return isNaN(num) ? 0 : cleanup(num);\n    } else if (units !== value) {\n        var split = 0;\n        switch(units){\n            case \"%\":\n                split = 25;\n                break;\n            case \"deg\":\n                split = 90;\n        }\n        if (split) {\n            var num1 = parseFloat(value.slice(0, value.length - units.length));\n            if (isNaN(num1)) {\n                return 0;\n            }\n            num1 = num1 / split;\n            return num1 % 1 === 0 ? cleanup(num1) : 0;\n        }\n    }\n    return defaultValue;\n}\nfunction iconToHTML(body, attributes) {\n    var renderAttribsHTML = body.indexOf(\"xlink:\") === -1 ? \"\" : ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n    for(var attr in attributes){\n        renderAttribsHTML += \" \" + attr + '=\"' + attributes[attr] + '\"';\n    }\n    return '<svg xmlns=\"http://www.w3.org/2000/svg\"' + renderAttribsHTML + \">\" + body + \"</svg>\";\n}\nfunction encodeSVGforURL(svg) {\n    return svg.replace(/\"/g, \"'\").replace(/%/g, \"%25\").replace(/#/g, \"%23\").replace(/</g, \"%3C\").replace(/>/g, \"%3E\").replace(/\\s+/g, \" \");\n}\nfunction svgToData(svg) {\n    return \"data:image/svg+xml,\" + encodeSVGforURL(svg);\n}\nfunction svgToURL(svg) {\n    return 'url(\"' + svgToData(svg) + '\")';\n}\nvar policy;\nfunction createPolicy() {\n    try {\n        policy = window.trustedTypes.createPolicy(\"iconify\", {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            createHTML: function(s) {\n                return s;\n            }\n        });\n    } catch (err) {\n        policy = null;\n    }\n}\nfunction cleanUpInnerHTML(html) {\n    if (policy === void 0) {\n        createPolicy();\n    }\n    return policy ? policy.createHTML(html) : html;\n}\nvar defaultExtendedIconCustomisations = (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_2__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, defaultIconCustomisations), {\n    inline: false\n});\n/**\n * Default SVG attributes\n */ var svgDefaults = {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    xmlnsXlink: \"http://www.w3.org/1999/xlink\",\n    \"aria-hidden\": true,\n    role: \"img\"\n};\n/**\n * Style modes\n */ var commonProps = {\n    display: \"inline-block\"\n};\nvar monotoneProps = {\n    backgroundColor: \"currentColor\"\n};\nvar coloredProps = {\n    backgroundColor: \"transparent\"\n};\n// Dynamically add common props to variables above\nvar propsToAdd = {\n    Image: \"var(--svg)\",\n    Repeat: \"no-repeat\",\n    Size: \"100% 100%\"\n};\nvar propsToAddTo = {\n    WebkitMask: monotoneProps,\n    mask: monotoneProps,\n    background: coloredProps\n};\nfor(var prefix in propsToAddTo){\n    var list = propsToAddTo[prefix];\n    for(var prop in propsToAdd){\n        list[prefix + prop] = propsToAdd[prop];\n    }\n}\n/**\n * Default values for customisations for inline icon\n */ var inlineDefaults = (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_2__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, defaultExtendedIconCustomisations), {\n    inline: true\n});\n/**\n * Fix size: add 'px' to numbers\n */ function fixSize(value) {\n    return value + (value.match(/^[-0-9.]+$/) ? \"px\" : \"\");\n}\n/**\n * Render icon\n */ var render = function(// Icon must be validated before calling this function\nicon, // Partial properties\nprops, // True if icon should have vertical-align added\ninline, // Optional reference for SVG/SPAN, extracted by React.forwardRef()\nref) {\n    // Get default properties\n    var defaultProps = inline ? inlineDefaults : defaultExtendedIconCustomisations;\n    // Get all customisations\n    var customisations = mergeCustomisations(defaultProps, props);\n    // Check mode\n    var mode = props.mode || \"svg\";\n    // Create style\n    var style = {};\n    var customStyle = props.style || {};\n    // Create SVG component properties\n    var componentProps = (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_2__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, mode === \"svg\" ? svgDefaults : {}), {\n        ref: ref\n    });\n    // Get element properties\n    for(var key in props){\n        var value = props[key];\n        if (value === void 0) {\n            continue;\n        }\n        switch(key){\n            // Properties to ignore\n            case \"icon\":\n            case \"style\":\n            case \"children\":\n            case \"onLoad\":\n            case \"mode\":\n            case \"_ref\":\n            case \"_inline\":\n                break;\n            // Boolean attributes\n            case \"inline\":\n            case \"hFlip\":\n            case \"vFlip\":\n                customisations[key] = value === true || value === \"true\" || value === 1;\n                break;\n            // Flip as string: 'horizontal,vertical'\n            case \"flip\":\n                if (typeof value === \"string\") {\n                    flipFromString(customisations, value);\n                }\n                break;\n            // Color: copy to style\n            case \"color\":\n                style.color = value;\n                break;\n            // Rotation as string\n            case \"rotate\":\n                if (typeof value === \"string\") {\n                    customisations[key] = rotateFromString(value);\n                } else if (typeof value === \"number\") {\n                    customisations[key] = value;\n                }\n                break;\n            // Remove aria-hidden\n            case \"ariaHidden\":\n            case \"aria-hidden\":\n                if (value !== true && value !== \"true\") {\n                    delete componentProps[\"aria-hidden\"];\n                }\n                break;\n            // Copy missing property if it does not exist in customisations\n            default:\n                if (defaultProps[key] === void 0) {\n                    componentProps[key] = value;\n                }\n        }\n    }\n    // Generate icon\n    var item = iconToSVG(icon, customisations);\n    var renderAttribs = item.attributes;\n    // Inline display\n    if (customisations.inline) {\n        style.verticalAlign = \"-0.125em\";\n    }\n    if (mode === \"svg\") {\n        // Add style\n        componentProps.style = (0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, style, customStyle);\n        // Add icon stuff\n        Object.assign(componentProps, renderAttribs);\n        // Counter for ids based on \"id\" property to render icons consistently on server and client\n        var localCounter = 0;\n        var id = props.id;\n        if (typeof id === \"string\") {\n            // Convert '-' to '_' to avoid errors in animations\n            id = id.replace(/-/g, \"_\");\n        }\n        // Add icon stuff\n        componentProps.dangerouslySetInnerHTML = {\n            __html: cleanUpInnerHTML(replaceIDs(item.body, id ? function() {\n                return id + \"ID\" + localCounter++;\n            } : \"iconifyReact\"))\n        };\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", componentProps);\n    }\n    // Render <span> with style\n    var body = icon.body, width = icon.width, height = icon.height;\n    var useMask = mode === \"mask\" || (mode === \"bg\" ? false : body.indexOf(\"currentColor\") !== -1);\n    // Generate SVG\n    var html = iconToHTML(body, (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_2__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, renderAttribs), {\n        width: width + \"\",\n        height: height + \"\"\n    }));\n    // Generate style\n    componentProps.style = (0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)((0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_2__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, style), {\n        \"--svg\": svgToURL(html),\n        width: fixSize(renderAttribs.width),\n        height: fixSize(renderAttribs.height)\n    }), commonProps, useMask ? monotoneProps : coloredProps, customStyle);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", componentProps);\n};\n/**\n * Enable cache\n */ function enableCache(storage) {\n    toggleBrowserCache(storage, true);\n}\n/**\n * Disable cache\n */ function disableCache(storage) {\n    toggleBrowserCache(storage, false);\n}\n/**\n * Initialise stuff\n */ // Enable short names\nallowSimpleNames(true);\n// Set API module\nsetAPIModule(\"\", fetchAPIModule);\n/**\n * Browser stuff\n */ if (typeof document !== \"undefined\" && typeof window !== \"undefined\") {\n    // Set cache and load existing cache\n    initBrowserStorage();\n    var _window1 = window;\n    // Load icons from global \"IconifyPreload\"\n    if (_window1.IconifyPreload !== void 0) {\n        var preload = _window1.IconifyPreload;\n        var err = \"Invalid IconifyPreload syntax.\";\n        if (typeof preload === \"object\" && preload !== null) {\n            (preload instanceof Array ? preload : [\n                preload\n            ]).forEach(function(item) {\n                try {\n                    if (// Check if item is an object and not null/array\n                    typeof item !== \"object\" || item === null || item instanceof Array || // Check for 'icons' and 'prefix'\n                    typeof item.icons !== \"object\" || typeof item.prefix !== \"string\" || // Add icon set\n                    !addCollection(item)) {\n                        console.error(err);\n                    }\n                } catch (e) {\n                    console.error(err);\n                }\n            });\n        }\n    }\n    // Set API from global \"IconifyProviders\"\n    if (_window1.IconifyProviders !== void 0) {\n        var providers = _window1.IconifyProviders;\n        if (typeof providers === \"object\" && providers !== null) {\n            for(var key in providers){\n                var err1 = \"IconifyProviders[\" + key + \"] is invalid.\";\n                try {\n                    var value = providers[key];\n                    if (typeof value !== \"object\" || !value || value.resources === void 0) {\n                        continue;\n                    }\n                    if (!addAPIProvider(key, value)) {\n                        console.error(err1);\n                    }\n                } catch (e) {\n                    console.error(err1);\n                }\n            }\n        }\n    }\n}\nvar IconComponent = /*#__PURE__*/ function(_React_Component) {\n    \"use strict\";\n    (0,_swc_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__._)(IconComponent, _React_Component);\n    var _super = (0,_swc_helpers_create_super__WEBPACK_IMPORTED_MODULE_5__._)(IconComponent);\n    function IconComponent(props) {\n        (0,_swc_helpers_class_call_check__WEBPACK_IMPORTED_MODULE_6__._)(this, IconComponent);\n        var _this;\n        _this = _super.call(this, props);\n        _this.state = {\n            // Render placeholder before component is mounted\n            icon: null\n        };\n        return _this;\n    }\n    (0,_swc_helpers_create_class__WEBPACK_IMPORTED_MODULE_7__._)(IconComponent, [\n        {\n            /**\n     * Abort loading icon\n     */ key: \"_abortLoading\",\n            value: function _abortLoading() {\n                if (this._loading) {\n                    this._loading.abort();\n                    this._loading = null;\n                }\n            }\n        },\n        {\n            /**\n     * Update state\n     */ key: \"_setData\",\n            value: function _setData(icon) {\n                if (this.state.icon !== icon) {\n                    this.setState({\n                        icon: icon\n                    });\n                }\n            }\n        },\n        {\n            /**\n     * Check if icon should be loaded\n     */ key: \"_checkIcon\",\n            value: function _checkIcon(changed) {\n                var state = this.state;\n                var icon = this.props.icon;\n                // Icon is an object\n                if (typeof icon === \"object\" && icon !== null && typeof icon.body === \"string\") {\n                    // Stop loading\n                    this._icon = \"\";\n                    this._abortLoading();\n                    if (changed || state.icon === null) {\n                        // Set data if it was changed\n                        this._setData({\n                            data: icon\n                        });\n                    }\n                    return;\n                }\n                // Invalid icon?\n                var iconName;\n                if (typeof icon !== \"string\" || (iconName = stringToIcon(icon, false, true)) === null) {\n                    this._abortLoading();\n                    this._setData(null);\n                    return;\n                }\n                // Load icon\n                var data = getIconData(iconName);\n                if (!data) {\n                    // Icon data is not available\n                    if (!this._loading || this._loading.name !== icon) {\n                        // New icon to load\n                        this._abortLoading();\n                        this._icon = \"\";\n                        this._setData(null);\n                        if (data !== null) {\n                            // Icon was not loaded\n                            this._loading = {\n                                name: icon,\n                                abort: loadIcons([\n                                    iconName\n                                ], this._checkIcon.bind(this, false))\n                            };\n                        }\n                    }\n                    return;\n                }\n                // Icon data is available\n                if (this._icon !== icon || state.icon === null) {\n                    // New icon or icon has been loaded\n                    this._abortLoading();\n                    this._icon = icon;\n                    // Add classes\n                    var classes = [\n                        \"iconify\"\n                    ];\n                    if (iconName.prefix !== \"\") {\n                        classes.push(\"iconify--\" + iconName.prefix);\n                    }\n                    if (iconName.provider !== \"\") {\n                        classes.push(\"iconify--\" + iconName.provider);\n                    }\n                    // Set data\n                    this._setData({\n                        data: data,\n                        classes: classes\n                    });\n                    if (this.props.onLoad) {\n                        this.props.onLoad(icon);\n                    }\n                }\n            }\n        },\n        {\n            /**\n     * Component mounted\n     */ key: \"componentDidMount\",\n            value: function componentDidMount() {\n                this._checkIcon(false);\n            }\n        },\n        {\n            /**\n     * Component updated\n     */ key: \"componentDidUpdate\",\n            value: function componentDidUpdate(oldProps) {\n                if (oldProps.icon !== this.props.icon) {\n                    this._checkIcon(true);\n                }\n            }\n        },\n        {\n            /**\n     * Abort loading\n     */ key: \"componentWillUnmount\",\n            value: function componentWillUnmount() {\n                this._abortLoading();\n            }\n        },\n        {\n            /**\n     * Render\n     */ key: \"render\",\n            value: function render1() {\n                var props = this.props;\n                var icon = this.state.icon;\n                if (icon === null) {\n                    // Render placeholder\n                    return props.children ? props.children : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {});\n                }\n                // Add classes\n                var newProps = props;\n                if (icon.classes) {\n                    newProps = (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_2__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, props), {\n                        className: (typeof props.className === \"string\" ? props.className + \" \" : \"\") + icon.classes.join(\" \")\n                    });\n                }\n                // Render icon\n                return render((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, defaultIconProps, icon.data), newProps, props._inline, props._ref);\n            }\n        }\n    ]);\n    return IconComponent;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n/**\n * Block icon\n *\n * @param props - Component properties\n */ var Icon = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(_c = function Icon(props, ref) {\n    var newProps = (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_2__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, props), {\n        _ref: ref,\n        _inline: false\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(IconComponent, newProps);\n});\n_c1 = Icon;\n/**\n * Inline icon (has negative verticalAlign that makes it behave like icon font)\n *\n * @param props - Component properties\n */ var InlineIcon = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(_c2 = function InlineIcon(props, ref) {\n    var newProps = (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_2__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_1__._)({}, props), {\n        _ref: ref,\n        _inline: true\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(IconComponent, newProps);\n});\n_c3 = InlineIcon;\n/**\n * Internal API\n */ var _api = {\n    getAPIConfig: getAPIConfig,\n    setAPIModule: setAPIModule,\n    sendAPIQuery: sendAPIQuery,\n    setFetch: setFetch,\n    getFetch: getFetch,\n    listAPIProviders: listAPIProviders\n};\n\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"Icon$React.forwardRef\");\n$RefreshReg$(_c1, \"Icon\");\n$RefreshReg$(_c2, \"InlineIcon$React.forwardRef\");\n$RefreshReg$(_c3, \"InlineIcon\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AaWNvbmlmeStyZWFjdEA0LjEuMV9yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL0BpY29uaWZ5L3JlYWN0L2Rpc3QvaWNvbmlmeS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQjtBQUUxQixJQUFNQyxnQkFBZ0I7QUFDdEIsSUFBTUMsZUFBZSxTQUFDQyxPQUFPQyxVQUFVQztRQUFpQkMsNEVBQVc7SUFDakUsSUFBTUMsaUJBQWlCSixNQUFNSyxLQUFLLENBQUM7SUFDbkMsSUFBSUwsTUFBTU0sS0FBSyxDQUFDLEdBQUcsT0FBTyxLQUFLO1FBQzdCLElBQUlGLGVBQWVHLE1BQU0sR0FBRyxLQUFLSCxlQUFlRyxNQUFNLEdBQUcsR0FBRztZQUMxRCxPQUFPO1FBQ1Q7UUFDQUosV0FBV0MsZUFBZUksS0FBSyxHQUFHRixLQUFLLENBQUM7SUFDMUM7SUFDQSxJQUFJRixlQUFlRyxNQUFNLEdBQUcsS0FBSyxDQUFDSCxlQUFlRyxNQUFNLEVBQUU7UUFDdkQsT0FBTztJQUNUO0lBQ0EsSUFBSUgsZUFBZUcsTUFBTSxHQUFHLEdBQUc7UUFDN0IsSUFBTUUsUUFBUUwsZUFBZU0sR0FBRztRQUNoQyxJQUFNQyxTQUFTUCxlQUFlTSxHQUFHO1FBQ2pDLElBQU1FLFNBQVM7WUFDYixxREFBcUQ7WUFDckRULFVBQVVDLGVBQWVHLE1BQU0sR0FBRyxJQUFJSCxjQUFjLENBQUMsRUFBRSxHQUFHRDtZQUMxRFEsUUFBQUE7WUFDQUUsTUFBTUo7UUFDUjtRQUNBLE9BQU9SLFlBQVksQ0FBQ2EsaUJBQWlCRixVQUFVLE9BQU9BO0lBQ3hEO0lBQ0EsSUFBTUMsT0FBT1QsY0FBYyxDQUFDLEVBQUU7SUFDOUIsSUFBTVcsZ0JBQWdCRixLQUFLUixLQUFLLENBQUM7SUFDakMsSUFBSVUsY0FBY1IsTUFBTSxHQUFHLEdBQUc7UUFDNUIsSUFBTUssVUFBUztZQUNi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LENBQUNrYSxlQUFlZ0I7QUFDOUM7O0FBQ0E7Ozs7Q0FJQyxHQUNELElBQU1PLDJCQUFhemIsNkNBQWdCLE9BQUMsU0FBU3liLFdBQVc3VCxLQUFLLEVBQUVpUixHQUFHO0lBQzlELElBQU1xQyxXQUFXLHNJQUNWdFQ7UUFDSHlULE1BQU14QztRQUNOdUMsU0FBUzs7SUFFYixxQkFBT3BiLGdEQUFtQixDQUFDa2EsZUFBZWdCO0FBQzlDOztBQUNBOztDQUVDLEdBQ0QsSUFBTVEsT0FBTztJQUNUalIsY0FBQUE7SUFDQWhCLGNBQUFBO0lBQ0F5SCxjQUFBQTtJQUNBcEcsVUFBQUE7SUFDQUUsVUFBQUE7SUFDQU4sa0JBQUFBO0FBQ0o7QUFFNk0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BpY29uaWZ5K3JlYWN0QDQuMS4xX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvQGljb25pZnkvcmVhY3QvZGlzdC9pY29uaWZ5Lm1qcz84ZDU2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IG1hdGNoSWNvbk5hbWUgPSAvXlthLXowLTldKygtW2EtejAtOV0rKSokLztcbmNvbnN0IHN0cmluZ1RvSWNvbiA9ICh2YWx1ZSwgdmFsaWRhdGUsIGFsbG93U2ltcGxlTmFtZSwgcHJvdmlkZXIgPSBcIlwiKSA9PiB7XG4gIGNvbnN0IGNvbG9uU2VwYXJhdGVkID0gdmFsdWUuc3BsaXQoXCI6XCIpO1xuICBpZiAodmFsdWUuc2xpY2UoMCwgMSkgPT09IFwiQFwiKSB7XG4gICAgaWYgKGNvbG9uU2VwYXJhdGVkLmxlbmd0aCA8IDIgfHwgY29sb25TZXBhcmF0ZWQubGVuZ3RoID4gMykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHByb3ZpZGVyID0gY29sb25TZXBhcmF0ZWQuc2hpZnQoKS5zbGljZSgxKTtcbiAgfVxuICBpZiAoY29sb25TZXBhcmF0ZWQubGVuZ3RoID4gMyB8fCAhY29sb25TZXBhcmF0ZWQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGNvbG9uU2VwYXJhdGVkLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBuYW1lMiA9IGNvbG9uU2VwYXJhdGVkLnBvcCgpO1xuICAgIGNvbnN0IHByZWZpeCA9IGNvbG9uU2VwYXJhdGVkLnBvcCgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIC8vIEFsbG93IHByb3ZpZGVyIHdpdGhvdXQgJ0AnOiBcInByb3ZpZGVyOnByZWZpeDpuYW1lXCJcbiAgICAgIHByb3ZpZGVyOiBjb2xvblNlcGFyYXRlZC5sZW5ndGggPiAwID8gY29sb25TZXBhcmF0ZWRbMF0gOiBwcm92aWRlcixcbiAgICAgIHByZWZpeCxcbiAgICAgIG5hbWU6IG5hbWUyXG4gICAgfTtcbiAgICByZXR1cm4gdmFsaWRhdGUgJiYgIXZhbGlkYXRlSWNvbk5hbWUocmVzdWx0KSA/IG51bGwgOiByZXN1bHQ7XG4gIH1cbiAgY29uc3QgbmFtZSA9IGNvbG9uU2VwYXJhdGVkWzBdO1xuICBjb25zdCBkYXNoU2VwYXJhdGVkID0gbmFtZS5zcGxpdChcIi1cIik7XG4gIGlmIChkYXNoU2VwYXJhdGVkLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBwcm92aWRlcixcbiAgICAgIHByZWZpeDogZGFzaFNlcGFyYXRlZC5zaGlmdCgpLFxuICAgICAgbmFtZTogZGFzaFNlcGFyYXRlZC5qb2luKFwiLVwiKVxuICAgIH07XG4gICAgcmV0dXJuIHZhbGlkYXRlICYmICF2YWxpZGF0ZUljb25OYW1lKHJlc3VsdCkgPyBudWxsIDogcmVzdWx0O1xuICB9XG4gIGlmIChhbGxvd1NpbXBsZU5hbWUgJiYgcHJvdmlkZXIgPT09IFwiXCIpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBwcm92aWRlcixcbiAgICAgIHByZWZpeDogXCJcIixcbiAgICAgIG5hbWVcbiAgICB9O1xuICAgIHJldHVybiB2YWxpZGF0ZSAmJiAhdmFsaWRhdGVJY29uTmFtZShyZXN1bHQsIGFsbG93U2ltcGxlTmFtZSkgPyBudWxsIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbmNvbnN0IHZhbGlkYXRlSWNvbk5hbWUgPSAoaWNvbiwgYWxsb3dTaW1wbGVOYW1lKSA9PiB7XG4gIGlmICghaWNvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gISEoKGljb24ucHJvdmlkZXIgPT09IFwiXCIgfHwgaWNvbi5wcm92aWRlci5tYXRjaChtYXRjaEljb25OYW1lKSkgJiYgKGFsbG93U2ltcGxlTmFtZSAmJiBpY29uLnByZWZpeCA9PT0gXCJcIiB8fCBpY29uLnByZWZpeC5tYXRjaChtYXRjaEljb25OYW1lKSkgJiYgaWNvbi5uYW1lLm1hdGNoKG1hdGNoSWNvbk5hbWUpKTtcbn07XG5cbmNvbnN0IGRlZmF1bHRJY29uRGltZW5zaW9ucyA9IE9iamVjdC5mcmVlemUoXG4gIHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbiAgICB3aWR0aDogMTYsXG4gICAgaGVpZ2h0OiAxNlxuICB9XG4pO1xuY29uc3QgZGVmYXVsdEljb25UcmFuc2Zvcm1hdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgcm90YXRlOiAwLFxuICB2RmxpcDogZmFsc2UsXG4gIGhGbGlwOiBmYWxzZVxufSk7XG5jb25zdCBkZWZhdWx0SWNvblByb3BzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIC4uLmRlZmF1bHRJY29uRGltZW5zaW9ucyxcbiAgLi4uZGVmYXVsdEljb25UcmFuc2Zvcm1hdGlvbnNcbn0pO1xuY29uc3QgZGVmYXVsdEV4dGVuZGVkSWNvblByb3BzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIC4uLmRlZmF1bHRJY29uUHJvcHMsXG4gIGJvZHk6IFwiXCIsXG4gIGhpZGRlbjogZmFsc2Vcbn0pO1xuXG5mdW5jdGlvbiBtZXJnZUljb25UcmFuc2Zvcm1hdGlvbnMob2JqMSwgb2JqMikge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgaWYgKCFvYmoxLmhGbGlwICE9PSAhb2JqMi5oRmxpcCkge1xuICAgIHJlc3VsdC5oRmxpcCA9IHRydWU7XG4gIH1cbiAgaWYgKCFvYmoxLnZGbGlwICE9PSAhb2JqMi52RmxpcCkge1xuICAgIHJlc3VsdC52RmxpcCA9IHRydWU7XG4gIH1cbiAgY29uc3Qgcm90YXRlID0gKChvYmoxLnJvdGF0ZSB8fCAwKSArIChvYmoyLnJvdGF0ZSB8fCAwKSkgJSA0O1xuICBpZiAocm90YXRlKSB7XG4gICAgcmVzdWx0LnJvdGF0ZSA9IHJvdGF0ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtZXJnZUljb25EYXRhKHBhcmVudCwgY2hpbGQpIHtcbiAgY29uc3QgcmVzdWx0ID0gbWVyZ2VJY29uVHJhbnNmb3JtYXRpb25zKHBhcmVudCwgY2hpbGQpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0RXh0ZW5kZWRJY29uUHJvcHMpIHtcbiAgICBpZiAoa2V5IGluIGRlZmF1bHRJY29uVHJhbnNmb3JtYXRpb25zKSB7XG4gICAgICBpZiAoa2V5IGluIHBhcmVudCAmJiAhKGtleSBpbiByZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gZGVmYXVsdEljb25UcmFuc2Zvcm1hdGlvbnNba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSBpbiBjaGlsZCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBjaGlsZFtrZXldO1xuICAgIH0gZWxzZSBpZiAoa2V5IGluIHBhcmVudCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBwYXJlbnRba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0SWNvbnNUcmVlKGRhdGEsIG5hbWVzKSB7XG4gIGNvbnN0IGljb25zID0gZGF0YS5pY29ucztcbiAgY29uc3QgYWxpYXNlcyA9IGRhdGEuYWxpYXNlcyB8fCAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgcmVzb2x2ZWQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZnVuY3Rpb24gcmVzb2x2ZShuYW1lKSB7XG4gICAgaWYgKGljb25zW25hbWVdKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRbbmFtZV0gPSBbXTtcbiAgICB9XG4gICAgaWYgKCEobmFtZSBpbiByZXNvbHZlZCkpIHtcbiAgICAgIHJlc29sdmVkW25hbWVdID0gbnVsbDtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGFsaWFzZXNbbmFtZV0gJiYgYWxpYXNlc1tuYW1lXS5wYXJlbnQ7XG4gICAgICBjb25zdCB2YWx1ZSA9IHBhcmVudCAmJiByZXNvbHZlKHBhcmVudCk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZWRbbmFtZV0gPSBbcGFyZW50XS5jb25jYXQodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZWRbbmFtZV07XG4gIH1cbiAgKG5hbWVzIHx8IE9iamVjdC5rZXlzKGljb25zKS5jb25jYXQoT2JqZWN0LmtleXMoYWxpYXNlcykpKS5mb3JFYWNoKHJlc29sdmUpO1xuICByZXR1cm4gcmVzb2x2ZWQ7XG59XG5cbmZ1bmN0aW9uIGludGVybmFsR2V0SWNvbkRhdGEoZGF0YSwgbmFtZSwgdHJlZSkge1xuICBjb25zdCBpY29ucyA9IGRhdGEuaWNvbnM7XG4gIGNvbnN0IGFsaWFzZXMgPSBkYXRhLmFsaWFzZXMgfHwgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBjdXJyZW50UHJvcHMgPSB7fTtcbiAgZnVuY3Rpb24gcGFyc2UobmFtZTIpIHtcbiAgICBjdXJyZW50UHJvcHMgPSBtZXJnZUljb25EYXRhKFxuICAgICAgaWNvbnNbbmFtZTJdIHx8IGFsaWFzZXNbbmFtZTJdLFxuICAgICAgY3VycmVudFByb3BzXG4gICAgKTtcbiAgfVxuICBwYXJzZShuYW1lKTtcbiAgdHJlZS5mb3JFYWNoKHBhcnNlKTtcbiAgcmV0dXJuIG1lcmdlSWNvbkRhdGEoZGF0YSwgY3VycmVudFByb3BzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VJY29uU2V0KGRhdGEsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IG5hbWVzID0gW107XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZGF0YS5pY29ucyAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBuYW1lcztcbiAgfVxuICBpZiAoZGF0YS5ub3RfZm91bmQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGRhdGEubm90X2ZvdW5kLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIGNhbGxiYWNrKG5hbWUsIG51bGwpO1xuICAgICAgbmFtZXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCB0cmVlID0gZ2V0SWNvbnNUcmVlKGRhdGEpO1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gdHJlZSkge1xuICAgIGNvbnN0IGl0ZW0gPSB0cmVlW25hbWVdO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBjYWxsYmFjayhuYW1lLCBpbnRlcm5hbEdldEljb25EYXRhKGRhdGEsIG5hbWUsIGl0ZW0pKTtcbiAgICAgIG5hbWVzLnB1c2gobmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuYW1lcztcbn1cblxuY29uc3Qgb3B0aW9uYWxQcm9wZXJ0eURlZmF1bHRzID0ge1xuICBwcm92aWRlcjogXCJcIixcbiAgYWxpYXNlczoge30sXG4gIG5vdF9mb3VuZDoge30sXG4gIC4uLmRlZmF1bHRJY29uRGltZW5zaW9uc1xufTtcbmZ1bmN0aW9uIGNoZWNrT3B0aW9uYWxQcm9wcyhpdGVtLCBkZWZhdWx0cykge1xuICBmb3IgKGNvbnN0IHByb3AgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAocHJvcCBpbiBpdGVtICYmIHR5cGVvZiBpdGVtW3Byb3BdICE9PSB0eXBlb2YgZGVmYXVsdHNbcHJvcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBxdWlja2x5VmFsaWRhdGVJY29uU2V0KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBkYXRhID0gb2JqO1xuICBpZiAodHlwZW9mIGRhdGEucHJlZml4ICE9PSBcInN0cmluZ1wiIHx8ICFvYmouaWNvbnMgfHwgdHlwZW9mIG9iai5pY29ucyAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghY2hlY2tPcHRpb25hbFByb3BzKG9iaiwgb3B0aW9uYWxQcm9wZXJ0eURlZmF1bHRzKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGljb25zID0gZGF0YS5pY29ucztcbiAgZm9yIChjb25zdCBuYW1lIGluIGljb25zKSB7XG4gICAgY29uc3QgaWNvbiA9IGljb25zW25hbWVdO1xuICAgIGlmICghbmFtZS5tYXRjaChtYXRjaEljb25OYW1lKSB8fCB0eXBlb2YgaWNvbi5ib2R5ICE9PSBcInN0cmluZ1wiIHx8ICFjaGVja09wdGlvbmFsUHJvcHMoXG4gICAgICBpY29uLFxuICAgICAgZGVmYXVsdEV4dGVuZGVkSWNvblByb3BzXG4gICAgKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGNvbnN0IGFsaWFzZXMgPSBkYXRhLmFsaWFzZXMgfHwgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3QgbmFtZSBpbiBhbGlhc2VzKSB7XG4gICAgY29uc3QgaWNvbiA9IGFsaWFzZXNbbmFtZV07XG4gICAgY29uc3QgcGFyZW50ID0gaWNvbi5wYXJlbnQ7XG4gICAgaWYgKCFuYW1lLm1hdGNoKG1hdGNoSWNvbk5hbWUpIHx8IHR5cGVvZiBwYXJlbnQgIT09IFwic3RyaW5nXCIgfHwgIWljb25zW3BhcmVudF0gJiYgIWFsaWFzZXNbcGFyZW50XSB8fCAhY2hlY2tPcHRpb25hbFByb3BzKFxuICAgICAgaWNvbixcbiAgICAgIGRlZmF1bHRFeHRlbmRlZEljb25Qcm9wc1xuICAgICkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuY29uc3QgZGF0YVN0b3JhZ2UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIG5ld1N0b3JhZ2UocHJvdmlkZXIsIHByZWZpeCkge1xuICByZXR1cm4ge1xuICAgIHByb3ZpZGVyLFxuICAgIHByZWZpeCxcbiAgICBpY29uczogLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgbWlzc2luZzogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSB7XG4gIGNvbnN0IHByb3ZpZGVyU3RvcmFnZSA9IGRhdGFTdG9yYWdlW3Byb3ZpZGVyXSB8fCAoZGF0YVN0b3JhZ2VbcHJvdmlkZXJdID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICByZXR1cm4gcHJvdmlkZXJTdG9yYWdlW3ByZWZpeF0gfHwgKHByb3ZpZGVyU3RvcmFnZVtwcmVmaXhdID0gbmV3U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSk7XG59XG5mdW5jdGlvbiBhZGRJY29uU2V0KHN0b3JhZ2UsIGRhdGEpIHtcbiAgaWYgKCFxdWlja2x5VmFsaWRhdGVJY29uU2V0KGRhdGEpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBwYXJzZUljb25TZXQoZGF0YSwgKG5hbWUsIGljb24pID0+IHtcbiAgICBpZiAoaWNvbikge1xuICAgICAgc3RvcmFnZS5pY29uc1tuYW1lXSA9IGljb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3JhZ2UubWlzc2luZy5hZGQobmFtZSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZEljb25Ub1N0b3JhZ2Uoc3RvcmFnZSwgbmFtZSwgaWNvbikge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgaWNvbi5ib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBzdG9yYWdlLmljb25zW25hbWVdID0geyAuLi5pY29uIH07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGxpc3RJY29ucyhwcm92aWRlciwgcHJlZml4KSB7XG4gIGxldCBhbGxJY29ucyA9IFtdO1xuICBjb25zdCBwcm92aWRlcnMgPSB0eXBlb2YgcHJvdmlkZXIgPT09IFwic3RyaW5nXCIgPyBbcHJvdmlkZXJdIDogT2JqZWN0LmtleXMoZGF0YVN0b3JhZ2UpO1xuICBwcm92aWRlcnMuZm9yRWFjaCgocHJvdmlkZXIyKSA9PiB7XG4gICAgY29uc3QgcHJlZml4ZXMgPSB0eXBlb2YgcHJvdmlkZXIyID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwcmVmaXggPT09IFwic3RyaW5nXCIgPyBbcHJlZml4XSA6IE9iamVjdC5rZXlzKGRhdGFTdG9yYWdlW3Byb3ZpZGVyMl0gfHwge30pO1xuICAgIHByZWZpeGVzLmZvckVhY2goKHByZWZpeDIpID0+IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHByb3ZpZGVyMiwgcHJlZml4Mik7XG4gICAgICBhbGxJY29ucyA9IGFsbEljb25zLmNvbmNhdChcbiAgICAgICAgT2JqZWN0LmtleXMoc3RvcmFnZS5pY29ucykubWFwKFxuICAgICAgICAgIChuYW1lKSA9PiAocHJvdmlkZXIyICE9PSBcIlwiID8gXCJAXCIgKyBwcm92aWRlcjIgKyBcIjpcIiA6IFwiXCIpICsgcHJlZml4MiArIFwiOlwiICsgbmFtZVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGFsbEljb25zO1xufVxuXG5sZXQgc2ltcGxlTmFtZXMgPSBmYWxzZTtcbmZ1bmN0aW9uIGFsbG93U2ltcGxlTmFtZXMoYWxsb3cpIHtcbiAgaWYgKHR5cGVvZiBhbGxvdyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICBzaW1wbGVOYW1lcyA9IGFsbG93O1xuICB9XG4gIHJldHVybiBzaW1wbGVOYW1lcztcbn1cbmZ1bmN0aW9uIGdldEljb25EYXRhKG5hbWUpIHtcbiAgY29uc3QgaWNvbiA9IHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiID8gc3RyaW5nVG9JY29uKG5hbWUsIHRydWUsIHNpbXBsZU5hbWVzKSA6IG5hbWU7XG4gIGlmIChpY29uKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UoaWNvbi5wcm92aWRlciwgaWNvbi5wcmVmaXgpO1xuICAgIGNvbnN0IGljb25OYW1lID0gaWNvbi5uYW1lO1xuICAgIHJldHVybiBzdG9yYWdlLmljb25zW2ljb25OYW1lXSB8fCAoc3RvcmFnZS5taXNzaW5nLmhhcyhpY29uTmFtZSkgPyBudWxsIDogdm9pZCAwKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkSWNvbihuYW1lLCBkYXRhKSB7XG4gIGNvbnN0IGljb24gPSBzdHJpbmdUb0ljb24obmFtZSwgdHJ1ZSwgc2ltcGxlTmFtZXMpO1xuICBpZiAoIWljb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UoaWNvbi5wcm92aWRlciwgaWNvbi5wcmVmaXgpO1xuICByZXR1cm4gYWRkSWNvblRvU3RvcmFnZShzdG9yYWdlLCBpY29uLm5hbWUsIGRhdGEpO1xufVxuZnVuY3Rpb24gYWRkQ29sbGVjdGlvbihkYXRhLCBwcm92aWRlcikge1xuICBpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm92aWRlciAhPT0gXCJzdHJpbmdcIikge1xuICAgIHByb3ZpZGVyID0gZGF0YS5wcm92aWRlciB8fCBcIlwiO1xuICB9XG4gIGlmIChzaW1wbGVOYW1lcyAmJiAhcHJvdmlkZXIgJiYgIWRhdGEucHJlZml4KSB7XG4gICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgaWYgKHF1aWNrbHlWYWxpZGF0ZUljb25TZXQoZGF0YSkpIHtcbiAgICAgIGRhdGEucHJlZml4ID0gXCJcIjtcbiAgICAgIHBhcnNlSWNvblNldChkYXRhLCAobmFtZSwgaWNvbikgPT4ge1xuICAgICAgICBpZiAoaWNvbiAmJiBhZGRJY29uKG5hbWUsIGljb24pKSB7XG4gICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZGVkO1xuICB9XG4gIGNvbnN0IHByZWZpeCA9IGRhdGEucHJlZml4O1xuICBpZiAoIXZhbGlkYXRlSWNvbk5hbWUoe1xuICAgIHByb3ZpZGVyLFxuICAgIHByZWZpeCxcbiAgICBuYW1lOiBcImFcIlxuICB9KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzdG9yYWdlID0gZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KTtcbiAgcmV0dXJuICEhYWRkSWNvblNldChzdG9yYWdlLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIGljb25FeGlzdHMobmFtZSkge1xuICByZXR1cm4gISFnZXRJY29uRGF0YShuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldEljb24obmFtZSkge1xuICBjb25zdCByZXN1bHQgPSBnZXRJY29uRGF0YShuYW1lKTtcbiAgcmV0dXJuIHJlc3VsdCA/IHtcbiAgICAuLi5kZWZhdWx0SWNvblByb3BzLFxuICAgIC4uLnJlc3VsdFxuICB9IDogbnVsbDtcbn1cblxuY29uc3QgZGVmYXVsdEljb25TaXplQ3VzdG9taXNhdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgd2lkdGg6IG51bGwsXG4gIGhlaWdodDogbnVsbFxufSk7XG5jb25zdCBkZWZhdWx0SWNvbkN1c3RvbWlzYXRpb25zID0gT2JqZWN0LmZyZWV6ZSh7XG4gIC8vIERpbWVuc2lvbnNcbiAgLi4uZGVmYXVsdEljb25TaXplQ3VzdG9taXNhdGlvbnMsXG4gIC8vIFRyYW5zZm9ybWF0aW9uc1xuICAuLi5kZWZhdWx0SWNvblRyYW5zZm9ybWF0aW9uc1xufSk7XG5cbmNvbnN0IHVuaXRzU3BsaXQgPSAvKC0/WzAtOS5dKlswLTldK1swLTkuXSopL2c7XG5jb25zdCB1bml0c1Rlc3QgPSAvXi0/WzAtOS5dKlswLTldK1swLTkuXSokL2c7XG5mdW5jdGlvbiBjYWxjdWxhdGVTaXplKHNpemUsIHJhdGlvLCBwcmVjaXNpb24pIHtcbiAgaWYgKHJhdGlvID09PSAxKSB7XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cbiAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDEwMDtcbiAgaWYgKHR5cGVvZiBzaXplID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbChzaXplICogcmF0aW8gKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzaXplO1xuICB9XG4gIGNvbnN0IG9sZFBhcnRzID0gc2l6ZS5zcGxpdCh1bml0c1NwbGl0KTtcbiAgaWYgKG9sZFBhcnRzID09PSBudWxsIHx8ICFvbGRQYXJ0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICBjb25zdCBuZXdQYXJ0cyA9IFtdO1xuICBsZXQgY29kZSA9IG9sZFBhcnRzLnNoaWZ0KCk7XG4gIGxldCBpc051bWJlciA9IHVuaXRzVGVzdC50ZXN0KGNvZGUpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChpc051bWJlcikge1xuICAgICAgY29uc3QgbnVtID0gcGFyc2VGbG9hdChjb2RlKTtcbiAgICAgIGlmIChpc05hTihudW0pKSB7XG4gICAgICAgIG5ld1BhcnRzLnB1c2goY29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdQYXJ0cy5wdXNoKE1hdGguY2VpbChudW0gKiByYXRpbyAqIHByZWNpc2lvbikgLyBwcmVjaXNpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdQYXJ0cy5wdXNoKGNvZGUpO1xuICAgIH1cbiAgICBjb2RlID0gb2xkUGFydHMuc2hpZnQoKTtcbiAgICBpZiAoY29kZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbmV3UGFydHMuam9pbihcIlwiKTtcbiAgICB9XG4gICAgaXNOdW1iZXIgPSAhaXNOdW1iZXI7XG4gIH1cbn1cblxuY29uc3QgaXNVbnNldEtleXdvcmQgPSAodmFsdWUpID0+IHZhbHVlID09PSBcInVuc2V0XCIgfHwgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgdmFsdWUgPT09IFwibm9uZVwiO1xuZnVuY3Rpb24gaWNvblRvU1ZHKGljb24sIGN1c3RvbWlzYXRpb25zKSB7XG4gIGNvbnN0IGZ1bGxJY29uID0ge1xuICAgIC4uLmRlZmF1bHRJY29uUHJvcHMsXG4gICAgLi4uaWNvblxuICB9O1xuICBjb25zdCBmdWxsQ3VzdG9taXNhdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdEljb25DdXN0b21pc2F0aW9ucyxcbiAgICAuLi5jdXN0b21pc2F0aW9uc1xuICB9O1xuICBjb25zdCBib3ggPSB7XG4gICAgbGVmdDogZnVsbEljb24ubGVmdCxcbiAgICB0b3A6IGZ1bGxJY29uLnRvcCxcbiAgICB3aWR0aDogZnVsbEljb24ud2lkdGgsXG4gICAgaGVpZ2h0OiBmdWxsSWNvbi5oZWlnaHRcbiAgfTtcbiAgbGV0IGJvZHkgPSBmdWxsSWNvbi5ib2R5O1xuICBbZnVsbEljb24sIGZ1bGxDdXN0b21pc2F0aW9uc10uZm9yRWFjaCgocHJvcHMpID0+IHtcbiAgICBjb25zdCB0cmFuc2Zvcm1hdGlvbnMgPSBbXTtcbiAgICBjb25zdCBoRmxpcCA9IHByb3BzLmhGbGlwO1xuICAgIGNvbnN0IHZGbGlwID0gcHJvcHMudkZsaXA7XG4gICAgbGV0IHJvdGF0aW9uID0gcHJvcHMucm90YXRlO1xuICAgIGlmIChoRmxpcCkge1xuICAgICAgaWYgKHZGbGlwKSB7XG4gICAgICAgIHJvdGF0aW9uICs9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaChcbiAgICAgICAgICBcInRyYW5zbGF0ZShcIiArIChib3gud2lkdGggKyBib3gubGVmdCkudG9TdHJpbmcoKSArIFwiIFwiICsgKDAgLSBib3gudG9wKS50b1N0cmluZygpICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgdHJhbnNmb3JtYXRpb25zLnB1c2goXCJzY2FsZSgtMSAxKVwiKTtcbiAgICAgICAgYm94LnRvcCA9IGJveC5sZWZ0ID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZGbGlwKSB7XG4gICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaChcbiAgICAgICAgXCJ0cmFuc2xhdGUoXCIgKyAoMCAtIGJveC5sZWZ0KS50b1N0cmluZygpICsgXCIgXCIgKyAoYm94LmhlaWdodCArIGJveC50b3ApLnRvU3RyaW5nKCkgKyBcIilcIlxuICAgICAgKTtcbiAgICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKFwic2NhbGUoMSAtMSlcIik7XG4gICAgICBib3gudG9wID0gYm94LmxlZnQgPSAwO1xuICAgIH1cbiAgICBsZXQgdGVtcFZhbHVlO1xuICAgIGlmIChyb3RhdGlvbiA8IDApIHtcbiAgICAgIHJvdGF0aW9uIC09IE1hdGguZmxvb3Iocm90YXRpb24gLyA0KSAqIDQ7XG4gICAgfVxuICAgIHJvdGF0aW9uID0gcm90YXRpb24gJSA0O1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdGVtcFZhbHVlID0gYm94LmhlaWdodCAvIDIgKyBib3gudG9wO1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbnMudW5zaGlmdChcbiAgICAgICAgICBcInJvdGF0ZSg5MCBcIiArIHRlbXBWYWx1ZS50b1N0cmluZygpICsgXCIgXCIgKyB0ZW1wVmFsdWUudG9TdHJpbmcoKSArIFwiKVwiXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB0cmFuc2Zvcm1hdGlvbnMudW5zaGlmdChcbiAgICAgICAgICBcInJvdGF0ZSgxODAgXCIgKyAoYm94LndpZHRoIC8gMiArIGJveC5sZWZ0KS50b1N0cmluZygpICsgXCIgXCIgKyAoYm94LmhlaWdodCAvIDIgKyBib3gudG9wKS50b1N0cmluZygpICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHRlbXBWYWx1ZSA9IGJveC53aWR0aCAvIDIgKyBib3gubGVmdDtcbiAgICAgICAgdHJhbnNmb3JtYXRpb25zLnVuc2hpZnQoXG4gICAgICAgICAgXCJyb3RhdGUoLTkwIFwiICsgdGVtcFZhbHVlLnRvU3RyaW5nKCkgKyBcIiBcIiArIHRlbXBWYWx1ZS50b1N0cmluZygpICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChyb3RhdGlvbiAlIDIgPT09IDEpIHtcbiAgICAgIGlmIChib3gubGVmdCAhPT0gYm94LnRvcCkge1xuICAgICAgICB0ZW1wVmFsdWUgPSBib3gubGVmdDtcbiAgICAgICAgYm94LmxlZnQgPSBib3gudG9wO1xuICAgICAgICBib3gudG9wID0gdGVtcFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGJveC53aWR0aCAhPT0gYm94LmhlaWdodCkge1xuICAgICAgICB0ZW1wVmFsdWUgPSBib3gud2lkdGg7XG4gICAgICAgIGJveC53aWR0aCA9IGJveC5oZWlnaHQ7XG4gICAgICAgIGJveC5oZWlnaHQgPSB0ZW1wVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICBib2R5ID0gJzxnIHRyYW5zZm9ybT1cIicgKyB0cmFuc2Zvcm1hdGlvbnMuam9pbihcIiBcIikgKyAnXCI+JyArIGJvZHkgKyBcIjwvZz5cIjtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBjdXN0b21pc2F0aW9uc1dpZHRoID0gZnVsbEN1c3RvbWlzYXRpb25zLndpZHRoO1xuICBjb25zdCBjdXN0b21pc2F0aW9uc0hlaWdodCA9IGZ1bGxDdXN0b21pc2F0aW9ucy5oZWlnaHQ7XG4gIGNvbnN0IGJveFdpZHRoID0gYm94LndpZHRoO1xuICBjb25zdCBib3hIZWlnaHQgPSBib3guaGVpZ2h0O1xuICBsZXQgd2lkdGg7XG4gIGxldCBoZWlnaHQ7XG4gIGlmIChjdXN0b21pc2F0aW9uc1dpZHRoID09PSBudWxsKSB7XG4gICAgaGVpZ2h0ID0gY3VzdG9taXNhdGlvbnNIZWlnaHQgPT09IG51bGwgPyBcIjFlbVwiIDogY3VzdG9taXNhdGlvbnNIZWlnaHQgPT09IFwiYXV0b1wiID8gYm94SGVpZ2h0IDogY3VzdG9taXNhdGlvbnNIZWlnaHQ7XG4gICAgd2lkdGggPSBjYWxjdWxhdGVTaXplKGhlaWdodCwgYm94V2lkdGggLyBib3hIZWlnaHQpO1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gY3VzdG9taXNhdGlvbnNXaWR0aCA9PT0gXCJhdXRvXCIgPyBib3hXaWR0aCA6IGN1c3RvbWlzYXRpb25zV2lkdGg7XG4gICAgaGVpZ2h0ID0gY3VzdG9taXNhdGlvbnNIZWlnaHQgPT09IG51bGwgPyBjYWxjdWxhdGVTaXplKHdpZHRoLCBib3hIZWlnaHQgLyBib3hXaWR0aCkgOiBjdXN0b21pc2F0aW9uc0hlaWdodCA9PT0gXCJhdXRvXCIgPyBib3hIZWlnaHQgOiBjdXN0b21pc2F0aW9uc0hlaWdodDtcbiAgfVxuICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gIGNvbnN0IHNldEF0dHIgPSAocHJvcCwgdmFsdWUpID0+IHtcbiAgICBpZiAoIWlzVW5zZXRLZXl3b3JkKHZhbHVlKSkge1xuICAgICAgYXR0cmlidXRlc1twcm9wXSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9O1xuICBzZXRBdHRyKFwid2lkdGhcIiwgd2lkdGgpO1xuICBzZXRBdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gIGF0dHJpYnV0ZXMudmlld0JveCA9IGJveC5sZWZ0LnRvU3RyaW5nKCkgKyBcIiBcIiArIGJveC50b3AudG9TdHJpbmcoKSArIFwiIFwiICsgYm94V2lkdGgudG9TdHJpbmcoKSArIFwiIFwiICsgYm94SGVpZ2h0LnRvU3RyaW5nKCk7XG4gIHJldHVybiB7XG4gICAgYXR0cmlidXRlcyxcbiAgICBib2R5XG4gIH07XG59XG5cbmNvbnN0IHJlZ2V4ID0gL1xcc2lkPVwiKFxcUyspXCIvZztcbmNvbnN0IHJhbmRvbVByZWZpeCA9IFwiSWNvbmlmeUlkXCIgKyBEYXRlLm5vdygpLnRvU3RyaW5nKDE2KSArIChNYXRoLnJhbmRvbSgpICogMTY3NzcyMTYgfCAwKS50b1N0cmluZygxNik7XG5sZXQgY291bnRlciA9IDA7XG5mdW5jdGlvbiByZXBsYWNlSURzKGJvZHksIHByZWZpeCA9IHJhbmRvbVByZWZpeCkge1xuICBjb25zdCBpZHMgPSBbXTtcbiAgbGV0IG1hdGNoO1xuICB3aGlsZSAobWF0Y2ggPSByZWdleC5leGVjKGJvZHkpKSB7XG4gICAgaWRzLnB1c2gobWF0Y2hbMV0pO1xuICB9XG4gIGlmICghaWRzLmxlbmd0aCkge1xuICAgIHJldHVybiBib2R5O1xuICB9XG4gIGNvbnN0IHN1ZmZpeCA9IFwic3VmZml4XCIgKyAoTWF0aC5yYW5kb20oKSAqIDE2Nzc3MjE2IHwgRGF0ZS5ub3coKSkudG9TdHJpbmcoMTYpO1xuICBpZHMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICBjb25zdCBuZXdJRCA9IHR5cGVvZiBwcmVmaXggPT09IFwiZnVuY3Rpb25cIiA/IHByZWZpeChpZCkgOiBwcmVmaXggKyAoY291bnRlcisrKS50b1N0cmluZygpO1xuICAgIGNvbnN0IGVzY2FwZWRJRCA9IGlkLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbiAgICBib2R5ID0gYm9keS5yZXBsYWNlKFxuICAgICAgLy8gQWxsb3dlZCBjaGFyYWN0ZXJzIGJlZm9yZSBpZDogWyM7XCJdXG4gICAgICAvLyBBbGxvd2VkIGNoYXJhY3RlcnMgYWZ0ZXIgaWQ6IFspXCJdLCAuW2Etel1cbiAgICAgIG5ldyBSZWdFeHAoJyhbIztcIl0pKCcgKyBlc2NhcGVkSUQgKyAnKShbXCIpXXxcXFxcLlthLXpdKScsIFwiZ1wiKSxcbiAgICAgIFwiJDFcIiArIG5ld0lEICsgc3VmZml4ICsgXCIkM1wiXG4gICAgKTtcbiAgfSk7XG4gIGJvZHkgPSBib2R5LnJlcGxhY2UobmV3IFJlZ0V4cChzdWZmaXgsIFwiZ1wiKSwgXCJcIik7XG4gIHJldHVybiBib2R5O1xufVxuXG5jb25zdCBzdG9yYWdlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBzZXRBUElNb2R1bGUocHJvdmlkZXIsIGl0ZW0pIHtcbiAgc3RvcmFnZVtwcm92aWRlcl0gPSBpdGVtO1xufVxuZnVuY3Rpb24gZ2V0QVBJTW9kdWxlKHByb3ZpZGVyKSB7XG4gIHJldHVybiBzdG9yYWdlW3Byb3ZpZGVyXSB8fCBzdG9yYWdlW1wiXCJdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBUElDb25maWcoc291cmNlKSB7XG4gIGxldCByZXNvdXJjZXM7XG4gIGlmICh0eXBlb2Ygc291cmNlLnJlc291cmNlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJlc291cmNlcyA9IFtzb3VyY2UucmVzb3VyY2VzXTtcbiAgfSBlbHNlIHtcbiAgICByZXNvdXJjZXMgPSBzb3VyY2UucmVzb3VyY2VzO1xuICAgIGlmICghKHJlc291cmNlcyBpbnN0YW5jZW9mIEFycmF5KSB8fCAhcmVzb3VyY2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAvLyBBUEkgaG9zdHNcbiAgICByZXNvdXJjZXMsXG4gICAgLy8gUm9vdCBwYXRoXG4gICAgcGF0aDogc291cmNlLnBhdGggfHwgXCIvXCIsXG4gICAgLy8gVVJMIGxlbmd0aCBsaW1pdFxuICAgIG1heFVSTDogc291cmNlLm1heFVSTCB8fCA1MDAsXG4gICAgLy8gVGltZW91dCBiZWZvcmUgbmV4dCBob3N0IGlzIHVzZWQuXG4gICAgcm90YXRlOiBzb3VyY2Uucm90YXRlIHx8IDc1MCxcbiAgICAvLyBUaW1lb3V0IGJlZm9yZSBmYWlsaW5nIHF1ZXJ5LlxuICAgIHRpbWVvdXQ6IHNvdXJjZS50aW1lb3V0IHx8IDVlMyxcbiAgICAvLyBSYW5kb21pc2UgZGVmYXVsdCBBUEkgZW5kIHBvaW50LlxuICAgIHJhbmRvbTogc291cmNlLnJhbmRvbSA9PT0gdHJ1ZSxcbiAgICAvLyBTdGFydCBpbmRleFxuICAgIGluZGV4OiBzb3VyY2UuaW5kZXggfHwgMCxcbiAgICAvLyBSZWNlaXZlIGRhdGEgYWZ0ZXIgdGltZSBvdXQgKHVzZWQgaWYgdGltZSBvdXQga2lja3MgaW4gZmlyc3QsIHRoZW4gQVBJIG1vZHVsZSBzZW5kcyBkYXRhIGFueXdheSkuXG4gICAgZGF0YUFmdGVyVGltZW91dDogc291cmNlLmRhdGFBZnRlclRpbWVvdXQgIT09IGZhbHNlXG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBjb25maWdTdG9yYWdlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBmYWxsQmFja0FQSVNvdXJjZXMgPSBbXG4gIFwiaHR0cHM6Ly9hcGkuc2ltcGxlc3ZnLmNvbVwiLFxuICBcImh0dHBzOi8vYXBpLnVuaXN2Zy5jb21cIlxuXTtcbmNvbnN0IGZhbGxCYWNrQVBJID0gW107XG53aGlsZSAoZmFsbEJhY2tBUElTb3VyY2VzLmxlbmd0aCA+IDApIHtcbiAgaWYgKGZhbGxCYWNrQVBJU291cmNlcy5sZW5ndGggPT09IDEpIHtcbiAgICBmYWxsQmFja0FQSS5wdXNoKGZhbGxCYWNrQVBJU291cmNlcy5zaGlmdCgpKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgZmFsbEJhY2tBUEkucHVzaChmYWxsQmFja0FQSVNvdXJjZXMuc2hpZnQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZhbGxCYWNrQVBJLnB1c2goZmFsbEJhY2tBUElTb3VyY2VzLnBvcCgpKTtcbiAgICB9XG4gIH1cbn1cbmNvbmZpZ1N0b3JhZ2VbXCJcIl0gPSBjcmVhdGVBUElDb25maWcoe1xuICByZXNvdXJjZXM6IFtcImh0dHBzOi8vYXBpLmljb25pZnkuZGVzaWduXCJdLmNvbmNhdChmYWxsQmFja0FQSSlcbn0pO1xuZnVuY3Rpb24gYWRkQVBJUHJvdmlkZXIocHJvdmlkZXIsIGN1c3RvbUNvbmZpZykge1xuICBjb25zdCBjb25maWcgPSBjcmVhdGVBUElDb25maWcoY3VzdG9tQ29uZmlnKTtcbiAgaWYgKGNvbmZpZyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25maWdTdG9yYWdlW3Byb3ZpZGVyXSA9IGNvbmZpZztcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRBUElDb25maWcocHJvdmlkZXIpIHtcbiAgcmV0dXJuIGNvbmZpZ1N0b3JhZ2VbcHJvdmlkZXJdO1xufVxuZnVuY3Rpb24gbGlzdEFQSVByb3ZpZGVycygpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbmZpZ1N0b3JhZ2UpO1xufVxuXG5jb25zdCBkZXRlY3RGZXRjaCA9ICgpID0+IHtcbiAgbGV0IGNhbGxiYWNrO1xuICB0cnkge1xuICAgIGNhbGxiYWNrID0gZmV0Y2g7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgfVxufTtcbmxldCBmZXRjaE1vZHVsZSA9IGRldGVjdEZldGNoKCk7XG5mdW5jdGlvbiBzZXRGZXRjaChmZXRjaDIpIHtcbiAgZmV0Y2hNb2R1bGUgPSBmZXRjaDI7XG59XG5mdW5jdGlvbiBnZXRGZXRjaCgpIHtcbiAgcmV0dXJuIGZldGNoTW9kdWxlO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlTWF4TGVuZ3RoKHByb3ZpZGVyLCBwcmVmaXgpIHtcbiAgY29uc3QgY29uZmlnID0gZ2V0QVBJQ29uZmlnKHByb3ZpZGVyKTtcbiAgaWYgKCFjb25maWcpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgcmVzdWx0O1xuICBpZiAoIWNvbmZpZy5tYXhVUkwpIHtcbiAgICByZXN1bHQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGxldCBtYXhIb3N0TGVuZ3RoID0gMDtcbiAgICBjb25maWcucmVzb3VyY2VzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IGhvc3QgPSBpdGVtO1xuICAgICAgbWF4SG9zdExlbmd0aCA9IE1hdGgubWF4KG1heEhvc3RMZW5ndGgsIGhvc3QubGVuZ3RoKTtcbiAgICB9KTtcbiAgICBjb25zdCB1cmwgPSBwcmVmaXggKyBcIi5qc29uP2ljb25zPVwiO1xuICAgIHJlc3VsdCA9IGNvbmZpZy5tYXhVUkwgLSBtYXhIb3N0TGVuZ3RoIC0gY29uZmlnLnBhdGgubGVuZ3RoIC0gdXJsLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2hvdWxkQWJvcnQoc3RhdHVzKSB7XG4gIHJldHVybiBzdGF0dXMgPT09IDQwNDtcbn1cbmNvbnN0IHByZXBhcmUgPSAocHJvdmlkZXIsIHByZWZpeCwgaWNvbnMpID0+IHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBjb25zdCBtYXhMZW5ndGggPSBjYWxjdWxhdGVNYXhMZW5ndGgocHJvdmlkZXIsIHByZWZpeCk7XG4gIGNvbnN0IHR5cGUgPSBcImljb25zXCI7XG4gIGxldCBpdGVtID0ge1xuICAgIHR5cGUsXG4gICAgcHJvdmlkZXIsXG4gICAgcHJlZml4LFxuICAgIGljb25zOiBbXVxuICB9O1xuICBsZXQgbGVuZ3RoID0gMDtcbiAgaWNvbnMuZm9yRWFjaCgobmFtZSwgaW5kZXgpID0+IHtcbiAgICBsZW5ndGggKz0gbmFtZS5sZW5ndGggKyAxO1xuICAgIGlmIChsZW5ndGggPj0gbWF4TGVuZ3RoICYmIGluZGV4ID4gMCkge1xuICAgICAgcmVzdWx0cy5wdXNoKGl0ZW0pO1xuICAgICAgaXRlbSA9IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgaWNvbnM6IFtdXG4gICAgICB9O1xuICAgICAgbGVuZ3RoID0gbmFtZS5sZW5ndGg7XG4gICAgfVxuICAgIGl0ZW0uaWNvbnMucHVzaChuYW1lKTtcbiAgfSk7XG4gIHJlc3VsdHMucHVzaChpdGVtKTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuZnVuY3Rpb24gZ2V0UGF0aChwcm92aWRlcikge1xuICBpZiAodHlwZW9mIHByb3ZpZGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgY29uZmlnID0gZ2V0QVBJQ29uZmlnKHByb3ZpZGVyKTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICByZXR1cm4gY29uZmlnLnBhdGg7XG4gICAgfVxuICB9XG4gIHJldHVybiBcIi9cIjtcbn1cbmNvbnN0IHNlbmQgPSAoaG9zdCwgcGFyYW1zLCBjYWxsYmFjaykgPT4ge1xuICBpZiAoIWZldGNoTW9kdWxlKSB7XG4gICAgY2FsbGJhY2soXCJhYm9ydFwiLCA0MjQpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgcGF0aCA9IGdldFBhdGgocGFyYW1zLnByb3ZpZGVyKTtcbiAgc3dpdGNoIChwYXJhbXMudHlwZSkge1xuICAgIGNhc2UgXCJpY29uc1wiOiB7XG4gICAgICBjb25zdCBwcmVmaXggPSBwYXJhbXMucHJlZml4O1xuICAgICAgY29uc3QgaWNvbnMgPSBwYXJhbXMuaWNvbnM7XG4gICAgICBjb25zdCBpY29uc0xpc3QgPSBpY29ucy5qb2luKFwiLFwiKTtcbiAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBpY29uczogaWNvbnNMaXN0XG4gICAgICB9KTtcbiAgICAgIHBhdGggKz0gcHJlZml4ICsgXCIuanNvbj9cIiArIHVybFBhcmFtcy50b1N0cmluZygpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJjdXN0b21cIjoge1xuICAgICAgY29uc3QgdXJpID0gcGFyYW1zLnVyaTtcbiAgICAgIHBhdGggKz0gdXJpLnNsaWNlKDAsIDEpID09PSBcIi9cIiA/IHVyaS5zbGljZSgxKSA6IHVyaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgY2FsbGJhY2soXCJhYm9ydFwiLCA0MDApO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIGxldCBkZWZhdWx0RXJyb3IgPSA1MDM7XG4gIGZldGNoTW9kdWxlKGhvc3QgKyBwYXRoKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgIGNvbnN0IHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICBpZiAoc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjYWxsYmFjayhzaG91bGRBYm9ydChzdGF0dXMpID8gXCJhYm9ydFwiIDogXCJuZXh0XCIsIHN0YXR1cyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVmYXVsdEVycm9yID0gNTAxO1xuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH0pLnRoZW4oKGRhdGEpID0+IHtcbiAgICBpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChkYXRhID09PSA0MDQpIHtcbiAgICAgICAgICBjYWxsYmFjayhcImFib3J0XCIsIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKFwibmV4dFwiLCBkZWZhdWx0RXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjYWxsYmFjayhcInN1Y2Nlc3NcIiwgZGF0YSk7XG4gICAgfSk7XG4gIH0pLmNhdGNoKCgpID0+IHtcbiAgICBjYWxsYmFjayhcIm5leHRcIiwgZGVmYXVsdEVycm9yKTtcbiAgfSk7XG59O1xuY29uc3QgZmV0Y2hBUElNb2R1bGUgPSB7XG4gIHByZXBhcmUsXG4gIHNlbmRcbn07XG5cbmZ1bmN0aW9uIHNvcnRJY29ucyhpY29ucykge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgbG9hZGVkOiBbXSxcbiAgICBtaXNzaW5nOiBbXSxcbiAgICBwZW5kaW5nOiBbXVxuICB9O1xuICBjb25zdCBzdG9yYWdlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGljb25zLnNvcnQoKGEsIGIpID0+IHtcbiAgICBpZiAoYS5wcm92aWRlciAhPT0gYi5wcm92aWRlcikge1xuICAgICAgcmV0dXJuIGEucHJvdmlkZXIubG9jYWxlQ29tcGFyZShiLnByb3ZpZGVyKTtcbiAgICB9XG4gICAgaWYgKGEucHJlZml4ICE9PSBiLnByZWZpeCkge1xuICAgICAgcmV0dXJuIGEucHJlZml4LmxvY2FsZUNvbXBhcmUoYi5wcmVmaXgpO1xuICAgIH1cbiAgICByZXR1cm4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKTtcbiAgfSk7XG4gIGxldCBsYXN0SWNvbiA9IHtcbiAgICBwcm92aWRlcjogXCJcIixcbiAgICBwcmVmaXg6IFwiXCIsXG4gICAgbmFtZTogXCJcIlxuICB9O1xuICBpY29ucy5mb3JFYWNoKChpY29uKSA9PiB7XG4gICAgaWYgKGxhc3RJY29uLm5hbWUgPT09IGljb24ubmFtZSAmJiBsYXN0SWNvbi5wcmVmaXggPT09IGljb24ucHJlZml4ICYmIGxhc3RJY29uLnByb3ZpZGVyID09PSBpY29uLnByb3ZpZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxhc3RJY29uID0gaWNvbjtcbiAgICBjb25zdCBwcm92aWRlciA9IGljb24ucHJvdmlkZXI7XG4gICAgY29uc3QgcHJlZml4ID0gaWNvbi5wcmVmaXg7XG4gICAgY29uc3QgbmFtZSA9IGljb24ubmFtZTtcbiAgICBjb25zdCBwcm92aWRlclN0b3JhZ2UgPSBzdG9yYWdlW3Byb3ZpZGVyXSB8fCAoc3RvcmFnZVtwcm92aWRlcl0gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgY29uc3QgbG9jYWxTdG9yYWdlID0gcHJvdmlkZXJTdG9yYWdlW3ByZWZpeF0gfHwgKHByb3ZpZGVyU3RvcmFnZVtwcmVmaXhdID0gZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSk7XG4gICAgbGV0IGxpc3Q7XG4gICAgaWYgKG5hbWUgaW4gbG9jYWxTdG9yYWdlLmljb25zKSB7XG4gICAgICBsaXN0ID0gcmVzdWx0LmxvYWRlZDtcbiAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gXCJcIiB8fCBsb2NhbFN0b3JhZ2UubWlzc2luZy5oYXMobmFtZSkpIHtcbiAgICAgIGxpc3QgPSByZXN1bHQubWlzc2luZztcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdCA9IHJlc3VsdC5wZW5kaW5nO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0ge1xuICAgICAgcHJvdmlkZXIsXG4gICAgICBwcmVmaXgsXG4gICAgICBuYW1lXG4gICAgfTtcbiAgICBsaXN0LnB1c2goaXRlbSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZW1vdmVDYWxsYmFjayhzdG9yYWdlcywgaWQpIHtcbiAgc3RvcmFnZXMuZm9yRWFjaCgoc3RvcmFnZSkgPT4ge1xuICAgIGNvbnN0IGl0ZW1zID0gc3RvcmFnZS5sb2FkZXJDYWxsYmFja3M7XG4gICAgaWYgKGl0ZW1zKSB7XG4gICAgICBzdG9yYWdlLmxvYWRlckNhbGxiYWNrcyA9IGl0ZW1zLmZpbHRlcigocm93KSA9PiByb3cuaWQgIT09IGlkKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FsbGJhY2tzKHN0b3JhZ2UpIHtcbiAgaWYgKCFzdG9yYWdlLnBlbmRpbmdDYWxsYmFja3NGbGFnKSB7XG4gICAgc3RvcmFnZS5wZW5kaW5nQ2FsbGJhY2tzRmxhZyA9IHRydWU7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzdG9yYWdlLnBlbmRpbmdDYWxsYmFja3NGbGFnID0gZmFsc2U7XG4gICAgICBjb25zdCBpdGVtcyA9IHN0b3JhZ2UubG9hZGVyQ2FsbGJhY2tzID8gc3RvcmFnZS5sb2FkZXJDYWxsYmFja3Muc2xpY2UoMCkgOiBbXTtcbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBoYXNQZW5kaW5nID0gZmFsc2U7XG4gICAgICBjb25zdCBwcm92aWRlciA9IHN0b3JhZ2UucHJvdmlkZXI7XG4gICAgICBjb25zdCBwcmVmaXggPSBzdG9yYWdlLnByZWZpeDtcbiAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgaWNvbnMgPSBpdGVtLmljb25zO1xuICAgICAgICBjb25zdCBvbGRMZW5ndGggPSBpY29ucy5wZW5kaW5nLmxlbmd0aDtcbiAgICAgICAgaWNvbnMucGVuZGluZyA9IGljb25zLnBlbmRpbmcuZmlsdGVyKChpY29uKSA9PiB7XG4gICAgICAgICAgaWYgKGljb24ucHJlZml4ICE9PSBwcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBuYW1lID0gaWNvbi5uYW1lO1xuICAgICAgICAgIGlmIChzdG9yYWdlLmljb25zW25hbWVdKSB7XG4gICAgICAgICAgICBpY29ucy5sb2FkZWQucHVzaCh7XG4gICAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RvcmFnZS5taXNzaW5nLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgaWNvbnMubWlzc2luZy5wdXNoKHtcbiAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhc1BlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpY29ucy5wZW5kaW5nLmxlbmd0aCAhPT0gb2xkTGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCFoYXNQZW5kaW5nKSB7XG4gICAgICAgICAgICByZW1vdmVDYWxsYmFjayhbc3RvcmFnZV0sIGl0ZW0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtLmNhbGxiYWNrKFxuICAgICAgICAgICAgaWNvbnMubG9hZGVkLnNsaWNlKDApLFxuICAgICAgICAgICAgaWNvbnMubWlzc2luZy5zbGljZSgwKSxcbiAgICAgICAgICAgIGljb25zLnBlbmRpbmcuc2xpY2UoMCksXG4gICAgICAgICAgICBpdGVtLmFib3J0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmxldCBpZENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gc3RvcmVDYWxsYmFjayhjYWxsYmFjaywgaWNvbnMsIHBlbmRpbmdTb3VyY2VzKSB7XG4gIGNvbnN0IGlkID0gaWRDb3VudGVyKys7XG4gIGNvbnN0IGFib3J0ID0gcmVtb3ZlQ2FsbGJhY2suYmluZChudWxsLCBwZW5kaW5nU291cmNlcywgaWQpO1xuICBpZiAoIWljb25zLnBlbmRpbmcubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFib3J0O1xuICB9XG4gIGNvbnN0IGl0ZW0gPSB7XG4gICAgaWQsXG4gICAgaWNvbnMsXG4gICAgY2FsbGJhY2ssXG4gICAgYWJvcnRcbiAgfTtcbiAgcGVuZGluZ1NvdXJjZXMuZm9yRWFjaCgoc3RvcmFnZSkgPT4ge1xuICAgIChzdG9yYWdlLmxvYWRlckNhbGxiYWNrcyB8fCAoc3RvcmFnZS5sb2FkZXJDYWxsYmFja3MgPSBbXSkpLnB1c2goaXRlbSk7XG4gIH0pO1xuICByZXR1cm4gYWJvcnQ7XG59XG5cbmZ1bmN0aW9uIGxpc3RUb0ljb25zKGxpc3QsIHZhbGlkYXRlID0gdHJ1ZSwgc2ltcGxlTmFtZXMgPSBmYWxzZSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgY29uc3QgaWNvbiA9IHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiID8gc3RyaW5nVG9JY29uKGl0ZW0sIHZhbGlkYXRlLCBzaW1wbGVOYW1lcykgOiBpdGVtO1xuICAgIGlmIChpY29uKSB7XG4gICAgICByZXN1bHQucHVzaChpY29uKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvY29uZmlnLnRzXG52YXIgZGVmYXVsdENvbmZpZyA9IHtcbiAgcmVzb3VyY2VzOiBbXSxcbiAgaW5kZXg6IDAsXG4gIHRpbWVvdXQ6IDJlMyxcbiAgcm90YXRlOiA3NTAsXG4gIHJhbmRvbTogZmFsc2UsXG4gIGRhdGFBZnRlclRpbWVvdXQ6IGZhbHNlXG59O1xuXG4vLyBzcmMvcXVlcnkudHNcbmZ1bmN0aW9uIHNlbmRRdWVyeShjb25maWcsIHBheWxvYWQsIHF1ZXJ5LCBkb25lKSB7XG4gIGNvbnN0IHJlc291cmNlc0NvdW50ID0gY29uZmlnLnJlc291cmNlcy5sZW5ndGg7XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSBjb25maWcucmFuZG9tID8gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcmVzb3VyY2VzQ291bnQpIDogY29uZmlnLmluZGV4O1xuICBsZXQgcmVzb3VyY2VzO1xuICBpZiAoY29uZmlnLnJhbmRvbSkge1xuICAgIGxldCBsaXN0ID0gY29uZmlnLnJlc291cmNlcy5zbGljZSgwKTtcbiAgICByZXNvdXJjZXMgPSBbXTtcbiAgICB3aGlsZSAobGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBuZXh0SW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsaXN0Lmxlbmd0aCk7XG4gICAgICByZXNvdXJjZXMucHVzaChsaXN0W25leHRJbmRleF0pO1xuICAgICAgbGlzdCA9IGxpc3Quc2xpY2UoMCwgbmV4dEluZGV4KS5jb25jYXQobGlzdC5zbGljZShuZXh0SW5kZXggKyAxKSk7XG4gICAgfVxuICAgIHJlc291cmNlcyA9IHJlc291cmNlcy5jb25jYXQobGlzdCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzb3VyY2VzID0gY29uZmlnLnJlc291cmNlcy5zbGljZShzdGFydEluZGV4KS5jb25jYXQoY29uZmlnLnJlc291cmNlcy5zbGljZSgwLCBzdGFydEluZGV4KSk7XG4gIH1cbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgbGV0IHN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICBsZXQgcXVlcmllc1NlbnQgPSAwO1xuICBsZXQgbGFzdEVycm9yO1xuICBsZXQgdGltZXIgPSBudWxsO1xuICBsZXQgcXVldWUgPSBbXTtcbiAgbGV0IGRvbmVDYWxsYmFja3MgPSBbXTtcbiAgaWYgKHR5cGVvZiBkb25lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBkb25lQ2FsbGJhY2tzLnB1c2goZG9uZSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVzZXRUaW1lcigpIHtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIGlmIChzdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICBzdGF0dXMgPSBcImFib3J0ZWRcIjtcbiAgICB9XG4gICAgcmVzZXRUaW1lcigpO1xuICAgIHF1ZXVlLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgaXRlbS5zdGF0dXMgPSBcImFib3J0ZWRcIjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBxdWV1ZSA9IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShjYWxsYmFjaywgb3ZlcndyaXRlKSB7XG4gICAgaWYgKG92ZXJ3cml0ZSkge1xuICAgICAgZG9uZUNhbGxiYWNrcyA9IFtdO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGRvbmVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFF1ZXJ5U3RhdHVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydFRpbWUsXG4gICAgICBwYXlsb2FkLFxuICAgICAgc3RhdHVzLFxuICAgICAgcXVlcmllc1NlbnQsXG4gICAgICBxdWVyaWVzUGVuZGluZzogcXVldWUubGVuZ3RoLFxuICAgICAgc3Vic2NyaWJlLFxuICAgICAgYWJvcnRcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGZhaWxRdWVyeSgpIHtcbiAgICBzdGF0dXMgPSBcImZhaWxlZFwiO1xuICAgIGRvbmVDYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcbiAgICAgIGNhbGxiYWNrKHZvaWQgMCwgbGFzdEVycm9yKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhclF1ZXVlKCkge1xuICAgIHF1ZXVlLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgaXRlbS5zdGF0dXMgPSBcImFib3J0ZWRcIjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBxdWV1ZSA9IFtdO1xuICB9XG4gIGZ1bmN0aW9uIG1vZHVsZVJlc3BvbnNlKGl0ZW0sIHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgY29uc3QgaXNFcnJvciA9IHJlc3BvbnNlICE9PSBcInN1Y2Nlc3NcIjtcbiAgICBxdWV1ZSA9IHF1ZXVlLmZpbHRlcigocXVldWVkKSA9PiBxdWV1ZWQgIT09IGl0ZW0pO1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgaWYgKGlzRXJyb3IgfHwgIWNvbmZpZy5kYXRhQWZ0ZXJUaW1lb3V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UgPT09IFwiYWJvcnRcIikge1xuICAgICAgbGFzdEVycm9yID0gZGF0YTtcbiAgICAgIGZhaWxRdWVyeSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcikge1xuICAgICAgbGFzdEVycm9yID0gZGF0YTtcbiAgICAgIGlmICghcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGlmICghcmVzb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgIGZhaWxRdWVyeSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4ZWNOZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzZXRUaW1lcigpO1xuICAgIGNsZWFyUXVldWUoKTtcbiAgICBpZiAoIWNvbmZpZy5yYW5kb20pIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gY29uZmlnLnJlc291cmNlcy5pbmRleE9mKGl0ZW0ucmVzb3VyY2UpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJiBpbmRleCAhPT0gY29uZmlnLmluZGV4KSB7XG4gICAgICAgIGNvbmZpZy5pbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0dXMgPSBcImNvbXBsZXRlZFwiO1xuICAgIGRvbmVDYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcbiAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGV4ZWNOZXh0KCkge1xuICAgIGlmIChzdGF0dXMgIT09IFwicGVuZGluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc2V0VGltZXIoKTtcbiAgICBjb25zdCByZXNvdXJjZSA9IHJlc291cmNlcy5zaGlmdCgpO1xuICAgIGlmIChyZXNvdXJjZSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcmVzZXRUaW1lcigpO1xuICAgICAgICAgIGlmIChzdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICBjbGVhclF1ZXVlKCk7XG4gICAgICAgICAgICBmYWlsUXVlcnkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGNvbmZpZy50aW1lb3V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZmFpbFF1ZXJ5KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgICAgcmVzb3VyY2UsXG4gICAgICBjYWxsYmFjazogKHN0YXR1czIsIGRhdGEpID0+IHtcbiAgICAgICAgbW9kdWxlUmVzcG9uc2UoaXRlbSwgc3RhdHVzMiwgZGF0YSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBxdWV1ZS5wdXNoKGl0ZW0pO1xuICAgIHF1ZXJpZXNTZW50Kys7XG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWNOZXh0LCBjb25maWcucm90YXRlKTtcbiAgICBxdWVyeShyZXNvdXJjZSwgcGF5bG9hZCwgaXRlbS5jYWxsYmFjayk7XG4gIH1cbiAgc2V0VGltZW91dChleGVjTmV4dCk7XG4gIHJldHVybiBnZXRRdWVyeVN0YXR1cztcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5mdW5jdGlvbiBpbml0UmVkdW5kYW5jeShjZmcpIHtcbiAgY29uc3QgY29uZmlnID0ge1xuICAgIC4uLmRlZmF1bHRDb25maWcsXG4gICAgLi4uY2ZnXG4gIH07XG4gIGxldCBxdWVyaWVzID0gW107XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgcXVlcmllcyA9IHF1ZXJpZXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtKCkuc3RhdHVzID09PSBcInBlbmRpbmdcIik7XG4gIH1cbiAgZnVuY3Rpb24gcXVlcnkocGF5bG9hZCwgcXVlcnlDYWxsYmFjaywgZG9uZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcXVlcnkyID0gc2VuZFF1ZXJ5KFxuICAgICAgY29uZmlnLFxuICAgICAgcGF5bG9hZCxcbiAgICAgIHF1ZXJ5Q2FsbGJhY2ssXG4gICAgICAoZGF0YSwgZXJyb3IpID0+IHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBpZiAoZG9uZUNhbGxiYWNrKSB7XG4gICAgICAgICAgZG9uZUNhbGxiYWNrKGRhdGEsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgcXVlcmllcy5wdXNoKHF1ZXJ5Mik7XG4gICAgcmV0dXJuIHF1ZXJ5MjtcbiAgfVxuICBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHF1ZXJpZXMuZmluZCgodmFsdWUpID0+IHtcbiAgICAgIHJldHVybiBjYWxsYmFjayh2YWx1ZSk7XG4gICAgfSkgfHwgbnVsbDtcbiAgfVxuICBjb25zdCBpbnN0YW5jZSA9IHtcbiAgICBxdWVyeSxcbiAgICBmaW5kLFxuICAgIHNldEluZGV4OiAoaW5kZXgpID0+IHtcbiAgICAgIGNvbmZpZy5pbmRleCA9IGluZGV4O1xuICAgIH0sXG4gICAgZ2V0SW5kZXg6ICgpID0+IGNvbmZpZy5pbmRleCxcbiAgICBjbGVhbnVwXG4gIH07XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gZW1wdHlDYWxsYmFjayQxKCkge1xufVxuY29uc3QgcmVkdW5kYW5jeUNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBnZXRSZWR1bmRhbmN5Q2FjaGUocHJvdmlkZXIpIHtcbiAgaWYgKCFyZWR1bmRhbmN5Q2FjaGVbcHJvdmlkZXJdKSB7XG4gICAgY29uc3QgY29uZmlnID0gZ2V0QVBJQ29uZmlnKHByb3ZpZGVyKTtcbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWR1bmRhbmN5ID0gaW5pdFJlZHVuZGFuY3koY29uZmlnKTtcbiAgICBjb25zdCBjYWNoZWRSZXVuZGFuY3kgPSB7XG4gICAgICBjb25maWcsXG4gICAgICByZWR1bmRhbmN5XG4gICAgfTtcbiAgICByZWR1bmRhbmN5Q2FjaGVbcHJvdmlkZXJdID0gY2FjaGVkUmV1bmRhbmN5O1xuICB9XG4gIHJldHVybiByZWR1bmRhbmN5Q2FjaGVbcHJvdmlkZXJdO1xufVxuZnVuY3Rpb24gc2VuZEFQSVF1ZXJ5KHRhcmdldCwgcXVlcnksIGNhbGxiYWNrKSB7XG4gIGxldCByZWR1bmRhbmN5O1xuICBsZXQgc2VuZDtcbiAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBhcGkgPSBnZXRBUElNb2R1bGUodGFyZ2V0KTtcbiAgICBpZiAoIWFwaSkge1xuICAgICAgY2FsbGJhY2sodm9pZCAwLCA0MjQpO1xuICAgICAgcmV0dXJuIGVtcHR5Q2FsbGJhY2skMTtcbiAgICB9XG4gICAgc2VuZCA9IGFwaS5zZW5kO1xuICAgIGNvbnN0IGNhY2hlZCA9IGdldFJlZHVuZGFuY3lDYWNoZSh0YXJnZXQpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJlZHVuZGFuY3kgPSBjYWNoZWQucmVkdW5kYW5jeTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY29uZmlnID0gY3JlYXRlQVBJQ29uZmlnKHRhcmdldCk7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgcmVkdW5kYW5jeSA9IGluaXRSZWR1bmRhbmN5KGNvbmZpZyk7XG4gICAgICBjb25zdCBtb2R1bGVLZXkgPSB0YXJnZXQucmVzb3VyY2VzID8gdGFyZ2V0LnJlc291cmNlc1swXSA6IFwiXCI7XG4gICAgICBjb25zdCBhcGkgPSBnZXRBUElNb2R1bGUobW9kdWxlS2V5KTtcbiAgICAgIGlmIChhcGkpIHtcbiAgICAgICAgc2VuZCA9IGFwaS5zZW5kO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIXJlZHVuZGFuY3kgfHwgIXNlbmQpIHtcbiAgICBjYWxsYmFjayh2b2lkIDAsIDQyNCk7XG4gICAgcmV0dXJuIGVtcHR5Q2FsbGJhY2skMTtcbiAgfVxuICByZXR1cm4gcmVkdW5kYW5jeS5xdWVyeShxdWVyeSwgc2VuZCwgY2FsbGJhY2spKCkuYWJvcnQ7XG59XG5cbmNvbnN0IGJyb3dzZXJDYWNoZVZlcnNpb24gPSBcImljb25pZnkyXCI7XG5jb25zdCBicm93c2VyQ2FjaGVQcmVmaXggPSBcImljb25pZnlcIjtcbmNvbnN0IGJyb3dzZXJDYWNoZUNvdW50S2V5ID0gYnJvd3NlckNhY2hlUHJlZml4ICsgXCItY291bnRcIjtcbmNvbnN0IGJyb3dzZXJDYWNoZVZlcnNpb25LZXkgPSBicm93c2VyQ2FjaGVQcmVmaXggKyBcIi12ZXJzaW9uXCI7XG5jb25zdCBicm93c2VyU3RvcmFnZUhvdXIgPSAzNmU1O1xuY29uc3QgYnJvd3NlclN0b3JhZ2VDYWNoZUV4cGlyYXRpb24gPSAxNjg7XG5cbmZ1bmN0aW9uIGdldFN0b3JlZEl0ZW0oZnVuYywga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZ1bmMuZ2V0SXRlbShrZXkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgfVxufVxuZnVuY3Rpb24gc2V0U3RvcmVkSXRlbShmdW5jLCBrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgZnVuYy5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlU3RvcmVkSXRlbShmdW5jLCBrZXkpIHtcbiAgdHJ5IHtcbiAgICBmdW5jLnJlbW92ZUl0ZW0oa2V5KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QnJvd3NlclN0b3JhZ2VJdGVtc0NvdW50KHN0b3JhZ2UsIHZhbHVlKSB7XG4gIHJldHVybiBzZXRTdG9yZWRJdGVtKHN0b3JhZ2UsIGJyb3dzZXJDYWNoZUNvdW50S2V5LCB2YWx1ZS50b1N0cmluZygpKTtcbn1cbmZ1bmN0aW9uIGdldEJyb3dzZXJTdG9yYWdlSXRlbXNDb3VudChzdG9yYWdlKSB7XG4gIHJldHVybiBwYXJzZUludChnZXRTdG9yZWRJdGVtKHN0b3JhZ2UsIGJyb3dzZXJDYWNoZUNvdW50S2V5KSkgfHwgMDtcbn1cblxuY29uc3QgYnJvd3NlclN0b3JhZ2VDb25maWcgPSB7XG4gIGxvY2FsOiB0cnVlLFxuICBzZXNzaW9uOiB0cnVlXG59O1xuY29uc3QgYnJvd3NlclN0b3JhZ2VFbXB0eUl0ZW1zID0ge1xuICBsb2NhbDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgc2Vzc2lvbjogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxufTtcbmxldCBicm93c2VyU3RvcmFnZVN0YXR1cyA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0QnJvd3NlclN0b3JhZ2VTdGF0dXMoc3RhdHVzKSB7XG4gIGJyb3dzZXJTdG9yYWdlU3RhdHVzID0gc3RhdHVzO1xufVxuXG5sZXQgX3dpbmRvdyA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyB7fSA6IHdpbmRvdztcbmZ1bmN0aW9uIGdldEJyb3dzZXJTdG9yYWdlKGtleSkge1xuICBjb25zdCBhdHRyID0ga2V5ICsgXCJTdG9yYWdlXCI7XG4gIHRyeSB7XG4gICAgaWYgKF93aW5kb3cgJiYgX3dpbmRvd1thdHRyXSAmJiB0eXBlb2YgX3dpbmRvd1thdHRyXS5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBfd2luZG93W2F0dHJdO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gIH1cbiAgYnJvd3NlclN0b3JhZ2VDb25maWdba2V5XSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpdGVyYXRlQnJvd3NlclN0b3JhZ2Uoa2V5LCBjYWxsYmFjaykge1xuICBjb25zdCBmdW5jID0gZ2V0QnJvd3NlclN0b3JhZ2Uoa2V5KTtcbiAgaWYgKCFmdW5jKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHZlcnNpb24gPSBnZXRTdG9yZWRJdGVtKGZ1bmMsIGJyb3dzZXJDYWNoZVZlcnNpb25LZXkpO1xuICBpZiAodmVyc2lvbiAhPT0gYnJvd3NlckNhY2hlVmVyc2lvbikge1xuICAgIGlmICh2ZXJzaW9uKSB7XG4gICAgICBjb25zdCB0b3RhbDIgPSBnZXRCcm93c2VyU3RvcmFnZUl0ZW1zQ291bnQoZnVuYyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsMjsgaSsrKSB7XG4gICAgICAgIHJlbW92ZVN0b3JlZEl0ZW0oZnVuYywgYnJvd3NlckNhY2hlUHJlZml4ICsgaS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0U3RvcmVkSXRlbShmdW5jLCBicm93c2VyQ2FjaGVWZXJzaW9uS2V5LCBicm93c2VyQ2FjaGVWZXJzaW9uKTtcbiAgICBzZXRCcm93c2VyU3RvcmFnZUl0ZW1zQ291bnQoZnVuYywgMCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG1pblRpbWUgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyBicm93c2VyU3RvcmFnZUhvdXIpIC0gYnJvd3NlclN0b3JhZ2VDYWNoZUV4cGlyYXRpb247XG4gIGNvbnN0IHBhcnNlSXRlbSA9IChpbmRleCkgPT4ge1xuICAgIGNvbnN0IG5hbWUgPSBicm93c2VyQ2FjaGVQcmVmaXggKyBpbmRleC50b1N0cmluZygpO1xuICAgIGNvbnN0IGl0ZW0gPSBnZXRTdG9yZWRJdGVtKGZ1bmMsIG5hbWUpO1xuICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoaXRlbSk7XG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGRhdGEuY2FjaGVkID09PSBcIm51bWJlclwiICYmIGRhdGEuY2FjaGVkID4gbWluVGltZSAmJiB0eXBlb2YgZGF0YS5wcm92aWRlciA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZGF0YS5kYXRhID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBkYXRhLmRhdGEucHJlZml4ID09PSBcInN0cmluZ1wiICYmIC8vIFZhbGlkIGl0ZW06IHJ1biBjYWxsYmFja1xuICAgICAgY2FsbGJhY2soZGF0YSwgaW5kZXgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgIH1cbiAgICByZW1vdmVTdG9yZWRJdGVtKGZ1bmMsIG5hbWUpO1xuICB9O1xuICBsZXQgdG90YWwgPSBnZXRCcm93c2VyU3RvcmFnZUl0ZW1zQ291bnQoZnVuYyk7XG4gIGZvciAobGV0IGkgPSB0b3RhbCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKCFwYXJzZUl0ZW0oaSkpIHtcbiAgICAgIGlmIChpID09PSB0b3RhbCAtIDEpIHtcbiAgICAgICAgdG90YWwtLTtcbiAgICAgICAgc2V0QnJvd3NlclN0b3JhZ2VJdGVtc0NvdW50KGZ1bmMsIHRvdGFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyb3dzZXJTdG9yYWdlRW1wdHlJdGVtc1trZXldLmFkZChpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEJyb3dzZXJTdG9yYWdlKCkge1xuICBpZiAoYnJvd3NlclN0b3JhZ2VTdGF0dXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2V0QnJvd3NlclN0b3JhZ2VTdGF0dXModHJ1ZSk7XG4gIGZvciAoY29uc3Qga2V5IGluIGJyb3dzZXJTdG9yYWdlQ29uZmlnKSB7XG4gICAgaXRlcmF0ZUJyb3dzZXJTdG9yYWdlKGtleSwgKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IGljb25TZXQgPSBpdGVtLmRhdGE7XG4gICAgICBjb25zdCBwcm92aWRlciA9IGl0ZW0ucHJvdmlkZXI7XG4gICAgICBjb25zdCBwcmVmaXggPSBpY29uU2V0LnByZWZpeDtcbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKFxuICAgICAgICBwcm92aWRlcixcbiAgICAgICAgcHJlZml4XG4gICAgICApO1xuICAgICAgaWYgKCFhZGRJY29uU2V0KHN0b3JhZ2UsIGljb25TZXQpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBsYXN0TW9kaWZpZWQgPSBpY29uU2V0Lmxhc3RNb2RpZmllZCB8fCAtMTtcbiAgICAgIHN0b3JhZ2UubGFzdE1vZGlmaWVkQ2FjaGVkID0gc3RvcmFnZS5sYXN0TW9kaWZpZWRDYWNoZWQgPyBNYXRoLm1pbihzdG9yYWdlLmxhc3RNb2RpZmllZENhY2hlZCwgbGFzdE1vZGlmaWVkKSA6IGxhc3RNb2RpZmllZDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxhc3RNb2RpZmllZChzdG9yYWdlLCBsYXN0TW9kaWZpZWQpIHtcbiAgY29uc3QgbGFzdFZhbHVlID0gc3RvcmFnZS5sYXN0TW9kaWZpZWRDYWNoZWQ7XG4gIGlmIChcbiAgICAvLyBNYXRjaGVzIG9yIG5ld2VyXG4gICAgbGFzdFZhbHVlICYmIGxhc3RWYWx1ZSA+PSBsYXN0TW9kaWZpZWRcbiAgKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZSA9PT0gbGFzdE1vZGlmaWVkO1xuICB9XG4gIHN0b3JhZ2UubGFzdE1vZGlmaWVkQ2FjaGVkID0gbGFzdE1vZGlmaWVkO1xuICBpZiAobGFzdFZhbHVlKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYnJvd3NlclN0b3JhZ2VDb25maWcpIHtcbiAgICAgIGl0ZXJhdGVCcm93c2VyU3RvcmFnZShrZXksIChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGljb25TZXQgPSBpdGVtLmRhdGE7XG4gICAgICAgIHJldHVybiBpdGVtLnByb3ZpZGVyICE9PSBzdG9yYWdlLnByb3ZpZGVyIHx8IGljb25TZXQucHJlZml4ICE9PSBzdG9yYWdlLnByZWZpeCB8fCBpY29uU2V0Lmxhc3RNb2RpZmllZCA9PT0gbGFzdE1vZGlmaWVkO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc3RvcmVJbkJyb3dzZXJTdG9yYWdlKHN0b3JhZ2UsIGRhdGEpIHtcbiAgaWYgKCFicm93c2VyU3RvcmFnZVN0YXR1cykge1xuICAgIGluaXRCcm93c2VyU3RvcmFnZSgpO1xuICB9XG4gIGZ1bmN0aW9uIHN0b3JlKGtleSkge1xuICAgIGxldCBmdW5jO1xuICAgIGlmICghYnJvd3NlclN0b3JhZ2VDb25maWdba2V5XSB8fCAhKGZ1bmMgPSBnZXRCcm93c2VyU3RvcmFnZShrZXkpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZXQgPSBicm93c2VyU3RvcmFnZUVtcHR5SXRlbXNba2V5XTtcbiAgICBsZXQgaW5kZXg7XG4gICAgaWYgKHNldC5zaXplKSB7XG4gICAgICBzZXQuZGVsZXRlKGluZGV4ID0gQXJyYXkuZnJvbShzZXQpLnNoaWZ0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleCA9IGdldEJyb3dzZXJTdG9yYWdlSXRlbXNDb3VudChmdW5jKTtcbiAgICAgIGlmICghc2V0QnJvd3NlclN0b3JhZ2VJdGVtc0NvdW50KGZ1bmMsIGluZGV4ICsgMSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpdGVtID0ge1xuICAgICAgY2FjaGVkOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyBicm93c2VyU3RvcmFnZUhvdXIpLFxuICAgICAgcHJvdmlkZXI6IHN0b3JhZ2UucHJvdmlkZXIsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gc2V0U3RvcmVkSXRlbShcbiAgICAgIGZ1bmMsXG4gICAgICBicm93c2VyQ2FjaGVQcmVmaXggKyBpbmRleC50b1N0cmluZygpLFxuICAgICAgSlNPTi5zdHJpbmdpZnkoaXRlbSlcbiAgICApO1xuICB9XG4gIGlmIChkYXRhLmxhc3RNb2RpZmllZCAmJiAhdXBkYXRlTGFzdE1vZGlmaWVkKHN0b3JhZ2UsIGRhdGEubGFzdE1vZGlmaWVkKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIU9iamVjdC5rZXlzKGRhdGEuaWNvbnMpLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZGF0YS5ub3RfZm91bmQpIHtcbiAgICBkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YSk7XG4gICAgZGVsZXRlIGRhdGEubm90X2ZvdW5kO1xuICB9XG4gIGlmICghc3RvcmUoXCJsb2NhbFwiKSkge1xuICAgIHN0b3JlKFwic2Vzc2lvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbXB0eUNhbGxiYWNrKCkge1xufVxuZnVuY3Rpb24gbG9hZGVkTmV3SWNvbnMoc3RvcmFnZSkge1xuICBpZiAoIXN0b3JhZ2UuaWNvbnNMb2FkZXJGbGFnKSB7XG4gICAgc3RvcmFnZS5pY29uc0xvYWRlckZsYWcgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc3RvcmFnZS5pY29uc0xvYWRlckZsYWcgPSBmYWxzZTtcbiAgICAgIHVwZGF0ZUNhbGxiYWNrcyhzdG9yYWdlKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gbG9hZE5ld0ljb25zKHN0b3JhZ2UsIGljb25zKSB7XG4gIGlmICghc3RvcmFnZS5pY29uc1RvTG9hZCkge1xuICAgIHN0b3JhZ2UuaWNvbnNUb0xvYWQgPSBpY29ucztcbiAgfSBlbHNlIHtcbiAgICBzdG9yYWdlLmljb25zVG9Mb2FkID0gc3RvcmFnZS5pY29uc1RvTG9hZC5jb25jYXQoaWNvbnMpLnNvcnQoKTtcbiAgfVxuICBpZiAoIXN0b3JhZ2UuaWNvbnNRdWV1ZUZsYWcpIHtcbiAgICBzdG9yYWdlLmljb25zUXVldWVGbGFnID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHN0b3JhZ2UuaWNvbnNRdWV1ZUZsYWcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHsgcHJvdmlkZXIsIHByZWZpeCB9ID0gc3RvcmFnZTtcbiAgICAgIGNvbnN0IGljb25zMiA9IHN0b3JhZ2UuaWNvbnNUb0xvYWQ7XG4gICAgICBkZWxldGUgc3RvcmFnZS5pY29uc1RvTG9hZDtcbiAgICAgIGxldCBhcGk7XG4gICAgICBpZiAoIWljb25zMiB8fCAhKGFwaSA9IGdldEFQSU1vZHVsZShwcm92aWRlcikpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmFtcyA9IGFwaS5wcmVwYXJlKHByb3ZpZGVyLCBwcmVmaXgsIGljb25zMik7XG4gICAgICBwYXJhbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBzZW5kQVBJUXVlcnkocHJvdmlkZXIsIGl0ZW0sIChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpdGVtLmljb25zLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgc3RvcmFnZS5taXNzaW5nLmFkZChuYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBhZGRJY29uU2V0KFxuICAgICAgICAgICAgICAgIHN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoIXBhcnNlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcGVuZGluZyA9IHN0b3JhZ2UucGVuZGluZ0ljb25zO1xuICAgICAgICAgICAgICBpZiAocGVuZGluZykge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICBwZW5kaW5nLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdG9yZUluQnJvd3NlclN0b3JhZ2Uoc3RvcmFnZSwgZGF0YSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsb2FkZWROZXdJY29ucyhzdG9yYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgbG9hZEljb25zID0gKGljb25zLCBjYWxsYmFjaykgPT4ge1xuICBjb25zdCBjbGVhbmVkSWNvbnMgPSBsaXN0VG9JY29ucyhpY29ucywgdHJ1ZSwgYWxsb3dTaW1wbGVOYW1lcygpKTtcbiAgY29uc3Qgc29ydGVkSWNvbnMgPSBzb3J0SWNvbnMoY2xlYW5lZEljb25zKTtcbiAgaWYgKCFzb3J0ZWRJY29ucy5wZW5kaW5nLmxlbmd0aCkge1xuICAgIGxldCBjYWxsQ2FsbGJhY2sgPSB0cnVlO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChjYWxsQ2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgIHNvcnRlZEljb25zLmxvYWRlZCxcbiAgICAgICAgICAgIHNvcnRlZEljb25zLm1pc3NpbmcsXG4gICAgICAgICAgICBzb3J0ZWRJY29ucy5wZW5kaW5nLFxuICAgICAgICAgICAgZW1wdHlDYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FsbENhbGxiYWNrID0gZmFsc2U7XG4gICAgfTtcbiAgfVxuICBjb25zdCBuZXdJY29ucyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBzb3VyY2VzID0gW107XG4gIGxldCBsYXN0UHJvdmlkZXIsIGxhc3RQcmVmaXg7XG4gIHNvcnRlZEljb25zLnBlbmRpbmcuZm9yRWFjaCgoaWNvbikgPT4ge1xuICAgIGNvbnN0IHsgcHJvdmlkZXIsIHByZWZpeCB9ID0gaWNvbjtcbiAgICBpZiAocHJlZml4ID09PSBsYXN0UHJlZml4ICYmIHByb3ZpZGVyID09PSBsYXN0UHJvdmlkZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGFzdFByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgbGFzdFByZWZpeCA9IHByZWZpeDtcbiAgICBzb3VyY2VzLnB1c2goZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSk7XG4gICAgY29uc3QgcHJvdmlkZXJOZXdJY29ucyA9IG5ld0ljb25zW3Byb3ZpZGVyXSB8fCAobmV3SWNvbnNbcHJvdmlkZXJdID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIGlmICghcHJvdmlkZXJOZXdJY29uc1twcmVmaXhdKSB7XG4gICAgICBwcm92aWRlck5ld0ljb25zW3ByZWZpeF0gPSBbXTtcbiAgICB9XG4gIH0pO1xuICBzb3J0ZWRJY29ucy5wZW5kaW5nLmZvckVhY2goKGljb24pID0+IHtcbiAgICBjb25zdCB7IHByb3ZpZGVyLCBwcmVmaXgsIG5hbWUgfSA9IGljb247XG4gICAgY29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UocHJvdmlkZXIsIHByZWZpeCk7XG4gICAgY29uc3QgcGVuZGluZ1F1ZXVlID0gc3RvcmFnZS5wZW5kaW5nSWNvbnMgfHwgKHN0b3JhZ2UucGVuZGluZ0ljb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgaWYgKCFwZW5kaW5nUXVldWUuaGFzKG5hbWUpKSB7XG4gICAgICBwZW5kaW5nUXVldWUuYWRkKG5hbWUpO1xuICAgICAgbmV3SWNvbnNbcHJvdmlkZXJdW3ByZWZpeF0ucHVzaChuYW1lKTtcbiAgICB9XG4gIH0pO1xuICBzb3VyY2VzLmZvckVhY2goKHN0b3JhZ2UpID0+IHtcbiAgICBjb25zdCB7IHByb3ZpZGVyLCBwcmVmaXggfSA9IHN0b3JhZ2U7XG4gICAgaWYgKG5ld0ljb25zW3Byb3ZpZGVyXVtwcmVmaXhdLmxlbmd0aCkge1xuICAgICAgbG9hZE5ld0ljb25zKHN0b3JhZ2UsIG5ld0ljb25zW3Byb3ZpZGVyXVtwcmVmaXhdKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2FsbGJhY2sgPyBzdG9yZUNhbGxiYWNrKGNhbGxiYWNrLCBzb3J0ZWRJY29ucywgc291cmNlcykgOiBlbXB0eUNhbGxiYWNrO1xufTtcbmNvbnN0IGxvYWRJY29uID0gKGljb24pID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChmdWxmaWxsLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpY29uT2JqID0gdHlwZW9mIGljb24gPT09IFwic3RyaW5nXCIgPyBzdHJpbmdUb0ljb24oaWNvbiwgdHJ1ZSkgOiBpY29uO1xuICAgIGlmICghaWNvbk9iaikge1xuICAgICAgcmVqZWN0KGljb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2FkSWNvbnMoW2ljb25PYmogfHwgaWNvbl0sIChsb2FkZWQpID0+IHtcbiAgICAgIGlmIChsb2FkZWQubGVuZ3RoICYmIGljb25PYmopIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEljb25EYXRhKGljb25PYmopO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIGZ1bGZpbGwoe1xuICAgICAgICAgICAgLi4uZGVmYXVsdEljb25Qcm9wcyxcbiAgICAgICAgICAgIC4uLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlamVjdChpY29uKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiB0b2dnbGVCcm93c2VyQ2FjaGUoc3RvcmFnZSwgdmFsdWUpIHtcbiAgc3dpdGNoIChzdG9yYWdlKSB7XG4gICAgY2FzZSBcImxvY2FsXCI6XG4gICAgY2FzZSBcInNlc3Npb25cIjpcbiAgICAgIGJyb3dzZXJTdG9yYWdlQ29uZmlnW3N0b3JhZ2VdID0gdmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYWxsXCI6XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBicm93c2VyU3RvcmFnZUNvbmZpZykge1xuICAgICAgICBicm93c2VyU3RvcmFnZUNvbmZpZ1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUN1c3RvbWlzYXRpb25zKGRlZmF1bHRzLCBpdGVtKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAuLi5kZWZhdWx0c1xuICB9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBpdGVtKSB7XG4gICAgY29uc3QgdmFsdWUgPSBpdGVtW2tleV07XG4gICAgY29uc3QgdmFsdWVUeXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGlmIChrZXkgaW4gZGVmYXVsdEljb25TaXplQ3VzdG9taXNhdGlvbnMpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSAmJiAodmFsdWVUeXBlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlVHlwZSA9PT0gXCJudW1iZXJcIikpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gdHlwZW9mIHJlc3VsdFtrZXldKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGtleSA9PT0gXCJyb3RhdGVcIiA/IHZhbHVlICUgNCA6IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBzZXBhcmF0b3IgPSAvW1xccyxdKy87XG5mdW5jdGlvbiBmbGlwRnJvbVN0cmluZyhjdXN0b20sIGZsaXApIHtcbiAgZmxpcC5zcGxpdChzZXBhcmF0b3IpLmZvckVhY2goKHN0cikgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gc3RyLnRyaW0oKTtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiaG9yaXpvbnRhbFwiOlxuICAgICAgICBjdXN0b20uaEZsaXAgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgICBjdXN0b20udkZsaXAgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByb3RhdGVGcm9tU3RyaW5nKHZhbHVlLCBkZWZhdWx0VmFsdWUgPSAwKSB7XG4gIGNvbnN0IHVuaXRzID0gdmFsdWUucmVwbGFjZSgvXi0/WzAtOS5dKi8sIFwiXCIpO1xuICBmdW5jdGlvbiBjbGVhbnVwKHZhbHVlMikge1xuICAgIHdoaWxlICh2YWx1ZTIgPCAwKSB7XG4gICAgICB2YWx1ZTIgKz0gNDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlMiAlIDQ7XG4gIH1cbiAgaWYgKHVuaXRzID09PSBcIlwiKSB7XG4gICAgY29uc3QgbnVtID0gcGFyc2VJbnQodmFsdWUpO1xuICAgIHJldHVybiBpc05hTihudW0pID8gMCA6IGNsZWFudXAobnVtKTtcbiAgfSBlbHNlIGlmICh1bml0cyAhPT0gdmFsdWUpIHtcbiAgICBsZXQgc3BsaXQgPSAwO1xuICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgIHNwbGl0ID0gMjU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRlZ1wiOlxuICAgICAgICBzcGxpdCA9IDkwO1xuICAgIH1cbiAgICBpZiAoc3BsaXQpIHtcbiAgICAgIGxldCBudW0gPSBwYXJzZUZsb2F0KHZhbHVlLnNsaWNlKDAsIHZhbHVlLmxlbmd0aCAtIHVuaXRzLmxlbmd0aCkpO1xuICAgICAgaWYgKGlzTmFOKG51bSkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBudW0gPSBudW0gLyBzcGxpdDtcbiAgICAgIHJldHVybiBudW0gJSAxID09PSAwID8gY2xlYW51cChudW0pIDogMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gaWNvblRvSFRNTChib2R5LCBhdHRyaWJ1dGVzKSB7XG4gIGxldCByZW5kZXJBdHRyaWJzSFRNTCA9IGJvZHkuaW5kZXhPZihcInhsaW5rOlwiKSA9PT0gLTEgPyBcIlwiIDogJyB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIic7XG4gIGZvciAoY29uc3QgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgcmVuZGVyQXR0cmlic0hUTUwgKz0gXCIgXCIgKyBhdHRyICsgJz1cIicgKyBhdHRyaWJ1dGVzW2F0dHJdICsgJ1wiJztcbiAgfVxuICByZXR1cm4gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiJyArIHJlbmRlckF0dHJpYnNIVE1MICsgXCI+XCIgKyBib2R5ICsgXCI8L3N2Zz5cIjtcbn1cblxuZnVuY3Rpb24gZW5jb2RlU1ZHZm9yVVJMKHN2Zykge1xuICByZXR1cm4gc3ZnLnJlcGxhY2UoL1wiL2csIFwiJ1wiKS5yZXBsYWNlKC8lL2csIFwiJTI1XCIpLnJlcGxhY2UoLyMvZywgXCIlMjNcIikucmVwbGFjZSgvPC9nLCBcIiUzQ1wiKS5yZXBsYWNlKC8+L2csIFwiJTNFXCIpLnJlcGxhY2UoL1xccysvZywgXCIgXCIpO1xufVxuZnVuY3Rpb24gc3ZnVG9EYXRhKHN2Zykge1xuICByZXR1cm4gXCJkYXRhOmltYWdlL3N2Zyt4bWwsXCIgKyBlbmNvZGVTVkdmb3JVUkwoc3ZnKTtcbn1cbmZ1bmN0aW9uIHN2Z1RvVVJMKHN2Zykge1xuICByZXR1cm4gJ3VybChcIicgKyBzdmdUb0RhdGEoc3ZnKSArICdcIiknO1xufVxuXG5sZXQgcG9saWN5O1xuZnVuY3Rpb24gY3JlYXRlUG9saWN5KCkge1xuICB0cnkge1xuICAgIHBvbGljeSA9IHdpbmRvdy50cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KFwiaWNvbmlmeVwiLCB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgIGNyZWF0ZUhUTUw6IChzKSA9PiBzXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHBvbGljeSA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFuVXBJbm5lckhUTUwoaHRtbCkge1xuICBpZiAocG9saWN5ID09PSB2b2lkIDApIHtcbiAgICBjcmVhdGVQb2xpY3koKTtcbiAgfVxuICByZXR1cm4gcG9saWN5ID8gcG9saWN5LmNyZWF0ZUhUTUwoaHRtbCkgOiBodG1sO1xufVxuXG5jb25zdCBkZWZhdWx0RXh0ZW5kZWRJY29uQ3VzdG9taXNhdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdEljb25DdXN0b21pc2F0aW9ucyxcbiAgICBpbmxpbmU6IGZhbHNlLFxufTtcblxuLyoqXG4gKiBEZWZhdWx0IFNWRyBhdHRyaWJ1dGVzXG4gKi9cbmNvbnN0IHN2Z0RlZmF1bHRzID0ge1xuICAgICd4bWxucyc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gICAgJ3htbG5zWGxpbmsnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAncm9sZSc6ICdpbWcnLFxufTtcbi8qKlxuICogU3R5bGUgbW9kZXNcbiAqL1xuY29uc3QgY29tbW9uUHJvcHMgPSB7XG4gICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG59O1xuY29uc3QgbW9ub3RvbmVQcm9wcyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxufTtcbmNvbnN0IGNvbG9yZWRQcm9wcyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXG59O1xuLy8gRHluYW1pY2FsbHkgYWRkIGNvbW1vbiBwcm9wcyB0byB2YXJpYWJsZXMgYWJvdmVcbmNvbnN0IHByb3BzVG9BZGQgPSB7XG4gICAgSW1hZ2U6ICd2YXIoLS1zdmcpJyxcbiAgICBSZXBlYXQ6ICduby1yZXBlYXQnLFxuICAgIFNpemU6ICcxMDAlIDEwMCUnLFxufTtcbmNvbnN0IHByb3BzVG9BZGRUbyA9IHtcbiAgICBXZWJraXRNYXNrOiBtb25vdG9uZVByb3BzLFxuICAgIG1hc2s6IG1vbm90b25lUHJvcHMsXG4gICAgYmFja2dyb3VuZDogY29sb3JlZFByb3BzLFxufTtcbmZvciAoY29uc3QgcHJlZml4IGluIHByb3BzVG9BZGRUbykge1xuICAgIGNvbnN0IGxpc3QgPSBwcm9wc1RvQWRkVG9bcHJlZml4XTtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHNUb0FkZCkge1xuICAgICAgICBsaXN0W3ByZWZpeCArIHByb3BdID0gcHJvcHNUb0FkZFtwcm9wXTtcbiAgICB9XG59XG4vKipcbiAqIERlZmF1bHQgdmFsdWVzIGZvciBjdXN0b21pc2F0aW9ucyBmb3IgaW5saW5lIGljb25cbiAqL1xuY29uc3QgaW5saW5lRGVmYXVsdHMgPSB7XG4gICAgLi4uZGVmYXVsdEV4dGVuZGVkSWNvbkN1c3RvbWlzYXRpb25zLFxuICAgIGlubGluZTogdHJ1ZSxcbn07XG4vKipcbiAqIEZpeCBzaXplOiBhZGQgJ3B4JyB0byBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIGZpeFNpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgKyAodmFsdWUubWF0Y2goL15bLTAtOS5dKyQvKSA/ICdweCcgOiAnJyk7XG59XG4vKipcbiAqIFJlbmRlciBpY29uXG4gKi9cbmNvbnN0IHJlbmRlciA9IChcbi8vIEljb24gbXVzdCBiZSB2YWxpZGF0ZWQgYmVmb3JlIGNhbGxpbmcgdGhpcyBmdW5jdGlvblxuaWNvbiwgXG4vLyBQYXJ0aWFsIHByb3BlcnRpZXNcbnByb3BzLCBcbi8vIFRydWUgaWYgaWNvbiBzaG91bGQgaGF2ZSB2ZXJ0aWNhbC1hbGlnbiBhZGRlZFxuaW5saW5lLCBcbi8vIE9wdGlvbmFsIHJlZmVyZW5jZSBmb3IgU1ZHL1NQQU4sIGV4dHJhY3RlZCBieSBSZWFjdC5mb3J3YXJkUmVmKClcbnJlZikgPT4ge1xuICAgIC8vIEdldCBkZWZhdWx0IHByb3BlcnRpZXNcbiAgICBjb25zdCBkZWZhdWx0UHJvcHMgPSBpbmxpbmVcbiAgICAgICAgPyBpbmxpbmVEZWZhdWx0c1xuICAgICAgICA6IGRlZmF1bHRFeHRlbmRlZEljb25DdXN0b21pc2F0aW9ucztcbiAgICAvLyBHZXQgYWxsIGN1c3RvbWlzYXRpb25zXG4gICAgY29uc3QgY3VzdG9taXNhdGlvbnMgPSBtZXJnZUN1c3RvbWlzYXRpb25zKGRlZmF1bHRQcm9wcywgcHJvcHMpO1xuICAgIC8vIENoZWNrIG1vZGVcbiAgICBjb25zdCBtb2RlID0gcHJvcHMubW9kZSB8fCAnc3ZnJztcbiAgICAvLyBDcmVhdGUgc3R5bGVcbiAgICBjb25zdCBzdHlsZSA9IHt9O1xuICAgIGNvbnN0IGN1c3RvbVN0eWxlID0gcHJvcHMuc3R5bGUgfHwge307XG4gICAgLy8gQ3JlYXRlIFNWRyBjb21wb25lbnQgcHJvcGVydGllc1xuICAgIGNvbnN0IGNvbXBvbmVudFByb3BzID0ge1xuICAgICAgICAuLi4obW9kZSA9PT0gJ3N2ZycgPyBzdmdEZWZhdWx0cyA6IHt9KSxcbiAgICAgICAgcmVmLFxuICAgIH07XG4gICAgLy8gR2V0IGVsZW1lbnQgcHJvcGVydGllc1xuICAgIGZvciAobGV0IGtleSBpbiBwcm9wcykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3BzW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgLy8gUHJvcGVydGllcyB0byBpZ25vcmVcbiAgICAgICAgICAgIGNhc2UgJ2ljb24nOlxuICAgICAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgICAgY2FzZSAnb25Mb2FkJzpcbiAgICAgICAgICAgIGNhc2UgJ21vZGUnOlxuICAgICAgICAgICAgY2FzZSAnX3JlZic6XG4gICAgICAgICAgICBjYXNlICdfaW5saW5lJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIEJvb2xlYW4gYXR0cmlidXRlc1xuICAgICAgICAgICAgY2FzZSAnaW5saW5lJzpcbiAgICAgICAgICAgIGNhc2UgJ2hGbGlwJzpcbiAgICAgICAgICAgIGNhc2UgJ3ZGbGlwJzpcbiAgICAgICAgICAgICAgICBjdXN0b21pc2F0aW9uc1trZXldID1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIEZsaXAgYXMgc3RyaW5nOiAnaG9yaXpvbnRhbCx2ZXJ0aWNhbCdcbiAgICAgICAgICAgIGNhc2UgJ2ZsaXAnOlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsaXBGcm9tU3RyaW5nKGN1c3RvbWlzYXRpb25zLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gQ29sb3I6IGNvcHkgdG8gc3R5bGVcbiAgICAgICAgICAgIGNhc2UgJ2NvbG9yJzpcbiAgICAgICAgICAgICAgICBzdHlsZS5jb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gUm90YXRpb24gYXMgc3RyaW5nXG4gICAgICAgICAgICBjYXNlICdyb3RhdGUnOlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbWlzYXRpb25zW2tleV0gPSByb3RhdGVGcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21pc2F0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGFyaWEtaGlkZGVuXG4gICAgICAgICAgICBjYXNlICdhcmlhSGlkZGVuJzpcbiAgICAgICAgICAgIGNhc2UgJ2FyaWEtaGlkZGVuJzpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUgJiYgdmFsdWUgIT09ICd0cnVlJykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29tcG9uZW50UHJvcHNbJ2FyaWEtaGlkZGVuJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gQ29weSBtaXNzaW5nIHByb3BlcnR5IGlmIGl0IGRvZXMgbm90IGV4aXN0IGluIGN1c3RvbWlzYXRpb25zXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0UHJvcHNba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFByb3BzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2VuZXJhdGUgaWNvblxuICAgIGNvbnN0IGl0ZW0gPSBpY29uVG9TVkcoaWNvbiwgY3VzdG9taXNhdGlvbnMpO1xuICAgIGNvbnN0IHJlbmRlckF0dHJpYnMgPSBpdGVtLmF0dHJpYnV0ZXM7XG4gICAgLy8gSW5saW5lIGRpc3BsYXlcbiAgICBpZiAoY3VzdG9taXNhdGlvbnMuaW5saW5lKSB7XG4gICAgICAgIHN0eWxlLnZlcnRpY2FsQWxpZ24gPSAnLTAuMTI1ZW0nO1xuICAgIH1cbiAgICBpZiAobW9kZSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgLy8gQWRkIHN0eWxlXG4gICAgICAgIGNvbXBvbmVudFByb3BzLnN0eWxlID0ge1xuICAgICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICAgICAuLi5jdXN0b21TdHlsZSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQWRkIGljb24gc3R1ZmZcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb21wb25lbnRQcm9wcywgcmVuZGVyQXR0cmlicyk7XG4gICAgICAgIC8vIENvdW50ZXIgZm9yIGlkcyBiYXNlZCBvbiBcImlkXCIgcHJvcGVydHkgdG8gcmVuZGVyIGljb25zIGNvbnNpc3RlbnRseSBvbiBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgICAgICBsZXQgbG9jYWxDb3VudGVyID0gMDtcbiAgICAgICAgbGV0IGlkID0gcHJvcHMuaWQ7XG4gICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0ICctJyB0byAnXycgdG8gYXZvaWQgZXJyb3JzIGluIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIGlkID0gaWQucmVwbGFjZSgvLS9nLCAnXycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBpY29uIHN0dWZmXG4gICAgICAgIGNvbXBvbmVudFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID0ge1xuICAgICAgICAgICAgX19odG1sOiBjbGVhblVwSW5uZXJIVE1MKHJlcGxhY2VJRHMoaXRlbS5ib2R5LCBpZCA/ICgpID0+IGlkICsgJ0lEJyArIGxvY2FsQ291bnRlcisrIDogJ2ljb25pZnlSZWFjdCcpKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3N2ZycsIGNvbXBvbmVudFByb3BzKTtcbiAgICB9XG4gICAgLy8gUmVuZGVyIDxzcGFuPiB3aXRoIHN0eWxlXG4gICAgY29uc3QgeyBib2R5LCB3aWR0aCwgaGVpZ2h0IH0gPSBpY29uO1xuICAgIGNvbnN0IHVzZU1hc2sgPSBtb2RlID09PSAnbWFzaycgfHxcbiAgICAgICAgKG1vZGUgPT09ICdiZycgPyBmYWxzZSA6IGJvZHkuaW5kZXhPZignY3VycmVudENvbG9yJykgIT09IC0xKTtcbiAgICAvLyBHZW5lcmF0ZSBTVkdcbiAgICBjb25zdCBodG1sID0gaWNvblRvSFRNTChib2R5LCB7XG4gICAgICAgIC4uLnJlbmRlckF0dHJpYnMsXG4gICAgICAgIHdpZHRoOiB3aWR0aCArICcnLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCArICcnLFxuICAgIH0pO1xuICAgIC8vIEdlbmVyYXRlIHN0eWxlXG4gICAgY29tcG9uZW50UHJvcHMuc3R5bGUgPSB7XG4gICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAnLS1zdmcnOiBzdmdUb1VSTChodG1sKSxcbiAgICAgICAgJ3dpZHRoJzogZml4U2l6ZShyZW5kZXJBdHRyaWJzLndpZHRoKSxcbiAgICAgICAgJ2hlaWdodCc6IGZpeFNpemUocmVuZGVyQXR0cmlicy5oZWlnaHQpLFxuICAgICAgICAuLi5jb21tb25Qcm9wcyxcbiAgICAgICAgLi4uKHVzZU1hc2sgPyBtb25vdG9uZVByb3BzIDogY29sb3JlZFByb3BzKSxcbiAgICAgICAgLi4uY3VzdG9tU3R5bGUsXG4gICAgfTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgnc3BhbicsIGNvbXBvbmVudFByb3BzKTtcbn07XG5cbi8qKlxuICogRW5hYmxlIGNhY2hlXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUNhY2hlKHN0b3JhZ2UpIHtcbiAgICB0b2dnbGVCcm93c2VyQ2FjaGUoc3RvcmFnZSwgdHJ1ZSk7XG59XG4vKipcbiAqIERpc2FibGUgY2FjaGVcbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUNhY2hlKHN0b3JhZ2UpIHtcbiAgICB0b2dnbGVCcm93c2VyQ2FjaGUoc3RvcmFnZSwgZmFsc2UpO1xufVxuLyoqXG4gKiBJbml0aWFsaXNlIHN0dWZmXG4gKi9cbi8vIEVuYWJsZSBzaG9ydCBuYW1lc1xuYWxsb3dTaW1wbGVOYW1lcyh0cnVlKTtcbi8vIFNldCBBUEkgbW9kdWxlXG5zZXRBUElNb2R1bGUoJycsIGZldGNoQVBJTW9kdWxlKTtcbi8qKlxuICogQnJvd3NlciBzdHVmZlxuICovXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIFNldCBjYWNoZSBhbmQgbG9hZCBleGlzdGluZyBjYWNoZVxuICAgIGluaXRCcm93c2VyU3RvcmFnZSgpO1xuICAgIGNvbnN0IF93aW5kb3cgPSB3aW5kb3c7XG4gICAgLy8gTG9hZCBpY29ucyBmcm9tIGdsb2JhbCBcIkljb25pZnlQcmVsb2FkXCJcbiAgICBpZiAoX3dpbmRvdy5JY29uaWZ5UHJlbG9hZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHByZWxvYWQgPSBfd2luZG93Lkljb25pZnlQcmVsb2FkO1xuICAgICAgICBjb25zdCBlcnIgPSAnSW52YWxpZCBJY29uaWZ5UHJlbG9hZCBzeW50YXguJztcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVsb2FkID09PSAnb2JqZWN0JyAmJiBwcmVsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAocHJlbG9hZCBpbnN0YW5jZW9mIEFycmF5ID8gcHJlbG9hZCA6IFtwcmVsb2FkXSkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXRlbSBpcyBhbiBvYmplY3QgYW5kIG5vdCBudWxsL2FycmF5XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSBpbnN0YW5jZW9mIEFycmF5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgJ2ljb25zJyBhbmQgJ3ByZWZpeCdcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVtLmljb25zICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGl0ZW0ucHJlZml4ICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGljb24gc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAhYWRkQ29sbGVjdGlvbihpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTZXQgQVBJIGZyb20gZ2xvYmFsIFwiSWNvbmlmeVByb3ZpZGVyc1wiXG4gICAgaWYgKF93aW5kb3cuSWNvbmlmeVByb3ZpZGVycyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVycyA9IF93aW5kb3cuSWNvbmlmeVByb3ZpZGVycztcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcnMgPT09ICdvYmplY3QnICYmIHByb3ZpZGVycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9ICdJY29uaWZ5UHJvdmlkZXJzWycgKyBrZXkgKyAnXSBpcyBpbnZhbGlkLic7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm92aWRlcnNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICF2YWx1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucmVzb3VyY2VzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWRkQVBJUHJvdmlkZXIoa2V5LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgSWNvbkNvbXBvbmVudCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgLy8gUmVuZGVyIHBsYWNlaG9sZGVyIGJlZm9yZSBjb21wb25lbnQgaXMgbW91bnRlZFxuICAgICAgICAgICAgaWNvbjogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWJvcnQgbG9hZGluZyBpY29uXG4gICAgICovXG4gICAgX2Fib3J0TG9hZGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xvYWRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRpbmcuYWJvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBzdGF0ZVxuICAgICAqL1xuICAgIF9zZXREYXRhKGljb24pIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuaWNvbiAhPT0gaWNvbikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgaWNvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGljb24gc2hvdWxkIGJlIGxvYWRlZFxuICAgICAqL1xuICAgIF9jaGVja0ljb24oY2hhbmdlZCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IGljb24gPSB0aGlzLnByb3BzLmljb247XG4gICAgICAgIC8vIEljb24gaXMgYW4gb2JqZWN0XG4gICAgICAgIGlmICh0eXBlb2YgaWNvbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIGljb24gIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBpY29uLmJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBTdG9wIGxvYWRpbmdcbiAgICAgICAgICAgIHRoaXMuX2ljb24gPSAnJztcbiAgICAgICAgICAgIHRoaXMuX2Fib3J0TG9hZGluZygpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWQgfHwgc3RhdGUuaWNvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFNldCBkYXRhIGlmIGl0IHdhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGljb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW52YWxpZCBpY29uP1xuICAgICAgICBsZXQgaWNvbk5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgaWNvbiAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIChpY29uTmFtZSA9IHN0cmluZ1RvSWNvbihpY29uLCBmYWxzZSwgdHJ1ZSkpID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9hYm9ydExvYWRpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldERhdGEobnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9hZCBpY29uXG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRJY29uRGF0YShpY29uTmFtZSk7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgLy8gSWNvbiBkYXRhIGlzIG5vdCBhdmFpbGFibGVcbiAgICAgICAgICAgIGlmICghdGhpcy5fbG9hZGluZyB8fCB0aGlzLl9sb2FkaW5nLm5hbWUgIT09IGljb24pIHtcbiAgICAgICAgICAgICAgICAvLyBOZXcgaWNvbiB0byBsb2FkXG4gICAgICAgICAgICAgICAgdGhpcy5fYWJvcnRMb2FkaW5nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faWNvbiA9ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldERhdGEobnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWNvbiB3YXMgbm90IGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2FkaW5nID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogaWNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0OiBsb2FkSWNvbnMoW2ljb25OYW1lXSwgdGhpcy5fY2hlY2tJY29uLmJpbmQodGhpcywgZmFsc2UpKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWNvbiBkYXRhIGlzIGF2YWlsYWJsZVxuICAgICAgICBpZiAodGhpcy5faWNvbiAhPT0gaWNvbiB8fCBzdGF0ZS5pY29uID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBOZXcgaWNvbiBvciBpY29uIGhhcyBiZWVuIGxvYWRlZFxuICAgICAgICAgICAgdGhpcy5fYWJvcnRMb2FkaW5nKCk7XG4gICAgICAgICAgICB0aGlzLl9pY29uID0gaWNvbjtcbiAgICAgICAgICAgIC8vIEFkZCBjbGFzc2VzXG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gWydpY29uaWZ5J107XG4gICAgICAgICAgICBpZiAoaWNvbk5hbWUucHJlZml4ICE9PSAnJykge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnaWNvbmlmeS0tJyArIGljb25OYW1lLnByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWNvbk5hbWUucHJvdmlkZXIgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdpY29uaWZ5LS0nICsgaWNvbk5hbWUucHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IGRhdGFcbiAgICAgICAgICAgIHRoaXMuX3NldERhdGEoe1xuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgY2xhc3NlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQoaWNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IG1vdW50ZWRcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tJY29uKGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IHVwZGF0ZWRcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRVcGRhdGUob2xkUHJvcHMpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzLmljb24gIT09IHRoaXMucHJvcHMuaWNvbikge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tJY29uKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFib3J0IGxvYWRpbmdcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5fYWJvcnRMb2FkaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlclxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBpY29uID0gdGhpcy5zdGF0ZS5pY29uO1xuICAgICAgICBpZiAoaWNvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUmVuZGVyIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICAgICAgICA/IHByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICAgICAgOiBSZWFjdC5jcmVhdGVFbGVtZW50KCdzcGFuJywge30pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBjbGFzc2VzXG4gICAgICAgIGxldCBuZXdQcm9wcyA9IHByb3BzO1xuICAgICAgICBpZiAoaWNvbi5jbGFzc2VzKSB7XG4gICAgICAgICAgICBuZXdQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICh0eXBlb2YgcHJvcHMuY2xhc3NOYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IHByb3BzLmNsYXNzTmFtZSArICcgJ1xuICAgICAgICAgICAgICAgICAgICA6ICcnKSArIGljb24uY2xhc3Nlcy5qb2luKCcgJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmRlciBpY29uXG4gICAgICAgIHJldHVybiByZW5kZXIoe1xuICAgICAgICAgICAgLi4uZGVmYXVsdEljb25Qcm9wcyxcbiAgICAgICAgICAgIC4uLmljb24uZGF0YSxcbiAgICAgICAgfSwgbmV3UHJvcHMsIHByb3BzLl9pbmxpbmUsIHByb3BzLl9yZWYpO1xuICAgIH1cbn1cbi8qKlxuICogQmxvY2sgaWNvblxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIENvbXBvbmVudCBwcm9wZXJ0aWVzXG4gKi9cbmNvbnN0IEljb24gPSBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEljb24ocHJvcHMsIHJlZikge1xuICAgIGNvbnN0IG5ld1Byb3BzID0ge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgX3JlZjogcmVmLFxuICAgICAgICBfaW5saW5lOiBmYWxzZSxcbiAgICB9O1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25Db21wb25lbnQsIG5ld1Byb3BzKTtcbn0pO1xuLyoqXG4gKiBJbmxpbmUgaWNvbiAoaGFzIG5lZ2F0aXZlIHZlcnRpY2FsQWxpZ24gdGhhdCBtYWtlcyBpdCBiZWhhdmUgbGlrZSBpY29uIGZvbnQpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gQ29tcG9uZW50IHByb3BlcnRpZXNcbiAqL1xuY29uc3QgSW5saW5lSWNvbiA9IFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gSW5saW5lSWNvbihwcm9wcywgcmVmKSB7XG4gICAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBfcmVmOiByZWYsXG4gICAgICAgIF9pbmxpbmU6IHRydWUsXG4gICAgfTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQ29tcG9uZW50LCBuZXdQcm9wcyk7XG59KTtcbi8qKlxuICogSW50ZXJuYWwgQVBJXG4gKi9cbmNvbnN0IF9hcGkgPSB7XG4gICAgZ2V0QVBJQ29uZmlnLFxuICAgIHNldEFQSU1vZHVsZSxcbiAgICBzZW5kQVBJUXVlcnksXG4gICAgc2V0RmV0Y2gsXG4gICAgZ2V0RmV0Y2gsXG4gICAgbGlzdEFQSVByb3ZpZGVycyxcbn07XG5cbmV4cG9ydCB7IEljb24sIElubGluZUljb24sIF9hcGksIGFkZEFQSVByb3ZpZGVyLCBhZGRDb2xsZWN0aW9uLCBhZGRJY29uLCBpY29uVG9TVkcgYXMgYnVpbGRJY29uLCBjYWxjdWxhdGVTaXplLCBkaXNhYmxlQ2FjaGUsIGVuYWJsZUNhY2hlLCBnZXRJY29uLCBpY29uRXhpc3RzLCBsaXN0SWNvbnMsIGxvYWRJY29uLCBsb2FkSWNvbnMsIHJlcGxhY2VJRHMgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIm1hdGNoSWNvbk5hbWUiLCJzdHJpbmdUb0ljb24iLCJ2YWx1ZSIsInZhbGlkYXRlIiwiYWxsb3dTaW1wbGVOYW1lIiwicHJvdmlkZXIiLCJjb2xvblNlcGFyYXRlZCIsInNwbGl0Iiwic2xpY2UiLCJsZW5ndGgiLCJzaGlmdCIsIm5hbWUyIiwicG9wIiwicHJlZml4IiwicmVzdWx0IiwibmFtZSIsInZhbGlkYXRlSWNvbk5hbWUiLCJkYXNoU2VwYXJhdGVkIiwiam9pbiIsImljb24iLCJtYXRjaCIsImRlZmF1bHRJY29uRGltZW5zaW9ucyIsIk9iamVjdCIsImZyZWV6ZSIsImxlZnQiLCJ0b3AiLCJ3aWR0aCIsImhlaWdodCIsImRlZmF1bHRJY29uVHJhbnNmb3JtYXRpb25zIiwicm90YXRlIiwidkZsaXAiLCJoRmxpcCIsImRlZmF1bHRJY29uUHJvcHMiLCJkZWZhdWx0RXh0ZW5kZWRJY29uUHJvcHMiLCJib2R5IiwiaGlkZGVuIiwibWVyZ2VJY29uVHJhbnNmb3JtYXRpb25zIiwib2JqMSIsIm9iajIiLCJtZXJnZUljb25EYXRhIiwicGFyZW50IiwiY2hpbGQiLCJrZXkiLCJnZXRJY29uc1RyZWUiLCJkYXRhIiwibmFtZXMiLCJpY29ucyIsImFsaWFzZXMiLCJjcmVhdGUiLCJyZXNvbHZlZCIsInJlc29sdmUiLCJjb25jYXQiLCJrZXlzIiwiZm9yRWFjaCIsImludGVybmFsR2V0SWNvbkRhdGEiLCJ0cmVlIiwiY3VycmVudFByb3BzIiwicGFyc2UiLCJwYXJzZUljb25TZXQiLCJjYWxsYmFjayIsIm5vdF9mb3VuZCIsIkFycmF5IiwicHVzaCIsIml0ZW0iLCJvcHRpb25hbFByb3BlcnR5RGVmYXVsdHMiLCJjaGVja09wdGlvbmFsUHJvcHMiLCJkZWZhdWx0cyIsInByb3AiLCJxdWlja2x5VmFsaWRhdGVJY29uU2V0Iiwib2JqIiwiZGF0YVN0b3JhZ2UiLCJuZXdTdG9yYWdlIiwibWlzc2luZyIsIlNldCIsImdldFN0b3JhZ2UiLCJwcm92aWRlclN0b3JhZ2UiLCJhZGRJY29uU2V0Iiwic3RvcmFnZSIsImFkZCIsImFkZEljb25Ub1N0b3JhZ2UiLCJlcnIiLCJsaXN0SWNvbnMiLCJhbGxJY29ucyIsInByb3ZpZGVycyIsInByb3ZpZGVyMiIsInByZWZpeGVzIiwicHJlZml4MiIsIm1hcCIsInNpbXBsZU5hbWVzIiwiYWxsb3dTaW1wbGVOYW1lcyIsImFsbG93IiwiZ2V0SWNvbkRhdGEiLCJpY29uTmFtZSIsImhhcyIsImFkZEljb24iLCJhZGRDb2xsZWN0aW9uIiwiYWRkZWQiLCJpY29uRXhpc3RzIiwiZ2V0SWNvbiIsImRlZmF1bHRJY29uU2l6ZUN1c3RvbWlzYXRpb25zIiwiZGVmYXVsdEljb25DdXN0b21pc2F0aW9ucyIsInVuaXRzU3BsaXQiLCJ1bml0c1Rlc3QiLCJjYWxjdWxhdGVTaXplIiwic2l6ZSIsInJhdGlvIiwicHJlY2lzaW9uIiwiTWF0aCIsImNlaWwiLCJvbGRQYXJ0cyIsIm5ld1BhcnRzIiwiY29kZSIsImlzTnVtYmVyIiwidGVzdCIsIm51bSIsInBhcnNlRmxvYXQiLCJpc05hTiIsImlzVW5zZXRLZXl3b3JkIiwiaWNvblRvU1ZHIiwiY3VzdG9taXNhdGlvbnMiLCJmdWxsSWNvbiIsImZ1bGxDdXN0b21pc2F0aW9ucyIsImJveCIsInByb3BzIiwidHJhbnNmb3JtYXRpb25zIiwicm90YXRpb24iLCJ0b1N0cmluZyIsInRlbXBWYWx1ZSIsImZsb29yIiwidW5zaGlmdCIsImN1c3RvbWlzYXRpb25zV2lkdGgiLCJjdXN0b21pc2F0aW9uc0hlaWdodCIsImJveFdpZHRoIiwiYm94SGVpZ2h0IiwiYXR0cmlidXRlcyIsInNldEF0dHIiLCJ2aWV3Qm94IiwicmVnZXgiLCJyYW5kb21QcmVmaXgiLCJEYXRlIiwibm93IiwicmFuZG9tIiwiY291bnRlciIsInJlcGxhY2VJRHMiLCJpZHMiLCJleGVjIiwic3VmZml4IiwiaWQiLCJuZXdJRCIsImVzY2FwZWRJRCIsInJlcGxhY2UiLCJSZWdFeHAiLCJzZXRBUElNb2R1bGUiLCJnZXRBUElNb2R1bGUiLCJjcmVhdGVBUElDb25maWciLCJzb3VyY2UiLCJyZXNvdXJjZXMiLCJwYXRoIiwibWF4VVJMIiwidGltZW91dCIsImluZGV4IiwiZGF0YUFmdGVyVGltZW91dCIsImNvbmZpZ1N0b3JhZ2UiLCJmYWxsQmFja0FQSVNvdXJjZXMiLCJmYWxsQmFja0FQSSIsImFkZEFQSVByb3ZpZGVyIiwiY3VzdG9tQ29uZmlnIiwiY29uZmlnIiwiZ2V0QVBJQ29uZmlnIiwibGlzdEFQSVByb3ZpZGVycyIsImRldGVjdEZldGNoIiwiZmV0Y2giLCJmZXRjaE1vZHVsZSIsInNldEZldGNoIiwiZmV0Y2gyIiwiZ2V0RmV0Y2giLCJjYWxjdWxhdGVNYXhMZW5ndGgiLCJtYXhIb3N0TGVuZ3RoIiwiaG9zdCIsIm1heCIsInVybCIsInNob3VsZEFib3J0Iiwic3RhdHVzIiwicHJlcGFyZSIsInJlc3VsdHMiLCJtYXhMZW5ndGgiLCJ0eXBlIiwiZ2V0UGF0aCIsInNlbmQiLCJwYXJhbXMiLCJpY29uc0xpc3QiLCJ1cmxQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ1cmkiLCJkZWZhdWx0RXJyb3IiLCJ0aGVuIiwicmVzcG9uc2UiLCJzZXRUaW1lb3V0IiwianNvbiIsImNhdGNoIiwiZmV0Y2hBUElNb2R1bGUiLCJzb3J0SWNvbnMiLCJsb2FkZWQiLCJwZW5kaW5nIiwic29ydCIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsImxhc3RJY29uIiwibG9jYWxTdG9yYWdlIiwibGlzdCIsInJlbW92ZUNhbGxiYWNrIiwic3RvcmFnZXMiLCJpdGVtcyIsImxvYWRlckNhbGxiYWNrcyIsImZpbHRlciIsInJvdyIsInVwZGF0ZUNhbGxiYWNrcyIsInBlbmRpbmdDYWxsYmFja3NGbGFnIiwiaGFzUGVuZGluZyIsIm9sZExlbmd0aCIsImFib3J0IiwiaWRDb3VudGVyIiwic3RvcmVDYWxsYmFjayIsInBlbmRpbmdTb3VyY2VzIiwiYmluZCIsImxpc3RUb0ljb25zIiwiZGVmYXVsdENvbmZpZyIsInNlbmRRdWVyeSIsInBheWxvYWQiLCJxdWVyeSIsImRvbmUiLCJyZXNvdXJjZXNDb3VudCIsInN0YXJ0SW5kZXgiLCJuZXh0SW5kZXgiLCJzdGFydFRpbWUiLCJxdWVyaWVzU2VudCIsImxhc3RFcnJvciIsInRpbWVyIiwicXVldWUiLCJkb25lQ2FsbGJhY2tzIiwicmVzZXRUaW1lciIsImNsZWFyVGltZW91dCIsInN1YnNjcmliZSIsIm92ZXJ3cml0ZSIsImdldFF1ZXJ5U3RhdHVzIiwicXVlcmllc1BlbmRpbmciLCJmYWlsUXVlcnkiLCJjbGVhclF1ZXVlIiwibW9kdWxlUmVzcG9uc2UiLCJpc0Vycm9yIiwicXVldWVkIiwiZXhlY05leHQiLCJpbmRleE9mIiwicmVzb3VyY2UiLCJzdGF0dXMyIiwiaW5pdFJlZHVuZGFuY3kiLCJjZmciLCJxdWVyaWVzIiwiY2xlYW51cCIsInF1ZXJ5Q2FsbGJhY2siLCJkb25lQ2FsbGJhY2siLCJxdWVyeTIiLCJlcnJvciIsImZpbmQiLCJpbnN0YW5jZSIsInNldEluZGV4IiwiZ2V0SW5kZXgiLCJlbXB0eUNhbGxiYWNrJDEiLCJyZWR1bmRhbmN5Q2FjaGUiLCJnZXRSZWR1bmRhbmN5Q2FjaGUiLCJyZWR1bmRhbmN5IiwiY2FjaGVkUmV1bmRhbmN5Iiwic2VuZEFQSVF1ZXJ5IiwidGFyZ2V0IiwiYXBpIiwiY2FjaGVkIiwibW9kdWxlS2V5IiwiYnJvd3NlckNhY2hlVmVyc2lvbiIsImJyb3dzZXJDYWNoZVByZWZpeCIsImJyb3dzZXJDYWNoZUNvdW50S2V5IiwiYnJvd3NlckNhY2hlVmVyc2lvbktleSIsImJyb3dzZXJTdG9yYWdlSG91ciIsImJyb3dzZXJTdG9yYWdlQ2FjaGVFeHBpcmF0aW9uIiwiZ2V0U3RvcmVkSXRlbSIsImZ1bmMiLCJnZXRJdGVtIiwic2V0U3RvcmVkSXRlbSIsInNldEl0ZW0iLCJyZW1vdmVTdG9yZWRJdGVtIiwicmVtb3ZlSXRlbSIsInNldEJyb3dzZXJTdG9yYWdlSXRlbXNDb3VudCIsImdldEJyb3dzZXJTdG9yYWdlSXRlbXNDb3VudCIsInBhcnNlSW50IiwiYnJvd3NlclN0b3JhZ2VDb25maWciLCJsb2NhbCIsInNlc3Npb24iLCJicm93c2VyU3RvcmFnZUVtcHR5SXRlbXMiLCJicm93c2VyU3RvcmFnZVN0YXR1cyIsInNldEJyb3dzZXJTdG9yYWdlU3RhdHVzIiwiX3dpbmRvdyIsIndpbmRvdyIsImdldEJyb3dzZXJTdG9yYWdlIiwiYXR0ciIsIml0ZXJhdGVCcm93c2VyU3RvcmFnZSIsInZlcnNpb24iLCJ0b3RhbDIiLCJpIiwibWluVGltZSIsInBhcnNlSXRlbSIsIkpTT04iLCJ0b3RhbCIsImluaXRCcm93c2VyU3RvcmFnZSIsImljb25TZXQiLCJsYXN0TW9kaWZpZWQiLCJsYXN0TW9kaWZpZWRDYWNoZWQiLCJtaW4iLCJ1cGRhdGVMYXN0TW9kaWZpZWQiLCJsYXN0VmFsdWUiLCJzdG9yZUluQnJvd3NlclN0b3JhZ2UiLCJzdG9yZSIsInNldCIsImRlbGV0ZSIsImZyb20iLCJzdHJpbmdpZnkiLCJhc3NpZ24iLCJlbXB0eUNhbGxiYWNrIiwibG9hZGVkTmV3SWNvbnMiLCJpY29uc0xvYWRlckZsYWciLCJsb2FkTmV3SWNvbnMiLCJpY29uc1RvTG9hZCIsImljb25zUXVldWVGbGFnIiwiaWNvbnMyIiwicGFyc2VkIiwicGVuZGluZ0ljb25zIiwiY29uc29sZSIsImxvYWRJY29ucyIsImNsZWFuZWRJY29ucyIsInNvcnRlZEljb25zIiwiY2FsbENhbGxiYWNrIiwibmV3SWNvbnMiLCJzb3VyY2VzIiwibGFzdFByb3ZpZGVyIiwibGFzdFByZWZpeCIsInByb3ZpZGVyTmV3SWNvbnMiLCJwZW5kaW5nUXVldWUiLCJsb2FkSWNvbiIsIlByb21pc2UiLCJmdWxmaWxsIiwicmVqZWN0IiwiaWNvbk9iaiIsInRvZ2dsZUJyb3dzZXJDYWNoZSIsIm1lcmdlQ3VzdG9taXNhdGlvbnMiLCJ2YWx1ZVR5cGUiLCJzZXBhcmF0b3IiLCJmbGlwRnJvbVN0cmluZyIsImN1c3RvbSIsImZsaXAiLCJzdHIiLCJ0cmltIiwicm90YXRlRnJvbVN0cmluZyIsImRlZmF1bHRWYWx1ZSIsInVuaXRzIiwidmFsdWUyIiwiaWNvblRvSFRNTCIsInJlbmRlckF0dHJpYnNIVE1MIiwiZW5jb2RlU1ZHZm9yVVJMIiwic3ZnIiwic3ZnVG9EYXRhIiwic3ZnVG9VUkwiLCJwb2xpY3kiLCJjcmVhdGVQb2xpY3kiLCJ0cnVzdGVkVHlwZXMiLCJjcmVhdGVIVE1MIiwicyIsImNsZWFuVXBJbm5lckhUTUwiLCJodG1sIiwiZGVmYXVsdEV4dGVuZGVkSWNvbkN1c3RvbWlzYXRpb25zIiwiaW5saW5lIiwic3ZnRGVmYXVsdHMiLCJjb21tb25Qcm9wcyIsImRpc3BsYXkiLCJtb25vdG9uZVByb3BzIiwiYmFja2dyb3VuZENvbG9yIiwiY29sb3JlZFByb3BzIiwicHJvcHNUb0FkZCIsIkltYWdlIiwiUmVwZWF0IiwiU2l6ZSIsInByb3BzVG9BZGRUbyIsIldlYmtpdE1hc2siLCJtYXNrIiwiYmFja2dyb3VuZCIsImlubGluZURlZmF1bHRzIiwiZml4U2l6ZSIsInJlbmRlciIsInJlZiIsImRlZmF1bHRQcm9wcyIsIm1vZGUiLCJzdHlsZSIsImN1c3RvbVN0eWxlIiwiY29tcG9uZW50UHJvcHMiLCJjb2xvciIsInJlbmRlckF0dHJpYnMiLCJ2ZXJ0aWNhbEFsaWduIiwibG9jYWxDb3VudGVyIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJfX2h0bWwiLCJjcmVhdGVFbGVtZW50IiwidXNlTWFzayIsImVuYWJsZUNhY2hlIiwiZGlzYWJsZUNhY2hlIiwiZG9jdW1lbnQiLCJJY29uaWZ5UHJlbG9hZCIsInByZWxvYWQiLCJlIiwiSWNvbmlmeVByb3ZpZGVycyIsIkljb25Db21wb25lbnQiLCJzdGF0ZSIsIl9hYm9ydExvYWRpbmciLCJfbG9hZGluZyIsIl9zZXREYXRhIiwic2V0U3RhdGUiLCJfY2hlY2tJY29uIiwiY2hhbmdlZCIsIl9pY29uIiwiY2xhc3NlcyIsIm9uTG9hZCIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50RGlkVXBkYXRlIiwib2xkUHJvcHMiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImNoaWxkcmVuIiwibmV3UHJvcHMiLCJjbGFzc05hbWUiLCJfaW5saW5lIiwiX3JlZiIsIkNvbXBvbmVudCIsIkljb24iLCJmb3J3YXJkUmVmIiwiSW5saW5lSWNvbiIsIl9hcGkiLCJidWlsZEljb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@iconify+react@4.1.1_react@18.3.1/node_modules/@iconify/react/dist/iconify.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/focusManager.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/focusManager.js ***!
  \***********************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FocusManager: function() { return /* binding */ FocusManager; },\n/* harmony export */   focusManager: function() { return /* binding */ focusManager; }\n/* harmony export */ });\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/focusManager.ts\n\n\nvar FocusManager = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  #focused;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onFocus) => {\n      if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isServer && window.addEventListener) {\n        const listener = () => onFocus();\n        window.addEventListener(\"visibilitychange\", listener, false);\n        return () => {\n          window.removeEventListener(\"visibilitychange\", listener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup((focused) => {\n      if (typeof focused === \"boolean\") {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n  setFocused(focused) {\n    const changed = this.#focused !== focused;\n    if (changed) {\n      this.#focused = focused;\n      this.onFocus();\n    }\n  }\n  onFocus() {\n    const isFocused = this.isFocused();\n    this.listeners.forEach((listener) => {\n      listener(isFocused);\n    });\n  }\n  isFocused() {\n    if (typeof this.#focused === \"boolean\") {\n      return this.#focused;\n    }\n    return globalThis.document?.visibilityState !== \"hidden\";\n  }\n};\nvar focusManager = new FocusManager();\n\n//# sourceMappingURL=focusManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcXVlcnktY29yZUA1LjM2LjEvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9mb2N1c01hbmFnZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ2lEO0FBQ1g7QUFDdEMsaUNBQWlDLDBEQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0NBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcXVlcnktY29yZUA1LjM2LjEvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9mb2N1c01hbmFnZXIuanM/M2ZhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZm9jdXNNYW5hZ2VyLnRzXG5pbXBvcnQgeyBTdWJzY3JpYmFibGUgfSBmcm9tIFwiLi9zdWJzY3JpYmFibGUuanNcIjtcbmltcG9ydCB7IGlzU2VydmVyIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbnZhciBGb2N1c01hbmFnZXIgPSBjbGFzcyBleHRlbmRzIFN1YnNjcmliYWJsZSB7XG4gICNmb2N1c2VkO1xuICAjY2xlYW51cDtcbiAgI3NldHVwO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI3NldHVwID0gKG9uRm9jdXMpID0+IHtcbiAgICAgIGlmICghaXNTZXJ2ZXIgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoKSA9PiBvbkZvY3VzKCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfTtcbiAgfVxuICBvblN1YnNjcmliZSgpIHtcbiAgICBpZiAoIXRoaXMuI2NsZWFudXApIHtcbiAgICAgIHRoaXMuc2V0RXZlbnRMaXN0ZW5lcih0aGlzLiNzZXR1cCk7XG4gICAgfVxuICB9XG4gIG9uVW5zdWJzY3JpYmUoKSB7XG4gICAgaWYgKCF0aGlzLmhhc0xpc3RlbmVycygpKSB7XG4gICAgICB0aGlzLiNjbGVhbnVwPy4oKTtcbiAgICAgIHRoaXMuI2NsZWFudXAgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHNldEV2ZW50TGlzdGVuZXIoc2V0dXApIHtcbiAgICB0aGlzLiNzZXR1cCA9IHNldHVwO1xuICAgIHRoaXMuI2NsZWFudXA/LigpO1xuICAgIHRoaXMuI2NsZWFudXAgPSBzZXR1cCgoZm9jdXNlZCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBmb2N1c2VkID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICB0aGlzLnNldEZvY3VzZWQoZm9jdXNlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uRm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzZXRGb2N1c2VkKGZvY3VzZWQpIHtcbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy4jZm9jdXNlZCAhPT0gZm9jdXNlZDtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy4jZm9jdXNlZCA9IGZvY3VzZWQ7XG4gICAgICB0aGlzLm9uRm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgb25Gb2N1cygpIHtcbiAgICBjb25zdCBpc0ZvY3VzZWQgPSB0aGlzLmlzRm9jdXNlZCgpO1xuICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICBsaXN0ZW5lcihpc0ZvY3VzZWQpO1xuICAgIH0pO1xuICB9XG4gIGlzRm9jdXNlZCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuI2ZvY3VzZWQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gdGhpcy4jZm9jdXNlZDtcbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuZG9jdW1lbnQ/LnZpc2liaWxpdHlTdGF0ZSAhPT0gXCJoaWRkZW5cIjtcbiAgfVxufTtcbnZhciBmb2N1c01hbmFnZXIgPSBuZXcgRm9jdXNNYW5hZ2VyKCk7XG5leHBvcnQge1xuICBGb2N1c01hbmFnZXIsXG4gIGZvY3VzTWFuYWdlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzTWFuYWdlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/focusManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js ***!
  \********************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasNextPage: function() { return /* binding */ hasNextPage; },\n/* harmony export */   hasPreviousPage: function() { return /* binding */ hasPreviousPage; },\n/* harmony export */   infiniteQueryBehavior: function() { return /* binding */ infiniteQueryBehavior; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/infiniteQueryBehavior.ts\n\nfunction infiniteQueryBehavior(pages) {\n  return {\n    onFetch: (context, query) => {\n      const fetchFn = async () => {\n        const options = context.options;\n        const direction = context.fetchOptions?.meta?.fetchMore?.direction;\n        const oldPages = context.state.data?.pages || [];\n        const oldPageParams = context.state.data?.pageParams || [];\n        const empty = { pages: [], pageParams: [] };\n        let cancelled = false;\n        const addSignalProperty = (object) => {\n          Object.defineProperty(object, \"signal\", {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true;\n              } else {\n                context.signal.addEventListener(\"abort\", () => {\n                  cancelled = true;\n                });\n              }\n              return context.signal;\n            }\n          });\n        };\n        const queryFn = context.options.queryFn && context.options.queryFn !== _utils_js__WEBPACK_IMPORTED_MODULE_0__.skipToken ? context.options.queryFn : () => {\n          if (true) {\n            if (context.options.queryFn === _utils_js__WEBPACK_IMPORTED_MODULE_0__.skipToken) {\n              console.error(\n                `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${context.options.queryHash}'`\n              );\n            }\n          }\n          return Promise.reject(\n            new Error(`Missing queryFn: '${context.options.queryHash}'`)\n          );\n        };\n        const fetchPage = async (data, param, previous) => {\n          if (cancelled) {\n            return Promise.reject();\n          }\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data);\n          }\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            direction: previous ? \"backward\" : \"forward\",\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          const page = await queryFn(\n            queryFnContext\n          );\n          const { maxPages } = context.options;\n          const addTo = previous ? _utils_js__WEBPACK_IMPORTED_MODULE_0__.addToStart : _utils_js__WEBPACK_IMPORTED_MODULE_0__.addToEnd;\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          };\n        };\n        let result;\n        if (direction && oldPages.length) {\n          const previous = direction === \"backward\";\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams\n          };\n          const param = pageParamFn(options, oldData);\n          result = await fetchPage(oldData, param, previous);\n        } else {\n          result = await fetchPage(\n            empty,\n            oldPageParams[0] ?? options.initialPageParam\n          );\n          const remainingPages = pages ?? oldPages.length;\n          for (let i = 1; i < remainingPages; i++) {\n            const param = getNextPageParam(options, result);\n            result = await fetchPage(result, param);\n          }\n        }\n        return result;\n      };\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn,\n            {\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal\n            },\n            query\n          );\n        };\n      } else {\n        context.fetchFn = fetchFn;\n      }\n    }\n  };\n}\nfunction getNextPageParam(options, { pages, pageParams }) {\n  const lastIndex = pages.length - 1;\n  return options.getNextPageParam(\n    pages[lastIndex],\n    pages,\n    pageParams[lastIndex],\n    pageParams\n  );\n}\nfunction getPreviousPageParam(options, { pages, pageParams }) {\n  return options.getPreviousPageParam?.(\n    pages[0],\n    pages,\n    pageParams[0],\n    pageParams\n  );\n}\nfunction hasNextPage(options, data) {\n  if (!data)\n    return false;\n  return getNextPageParam(options, data) != null;\n}\nfunction hasPreviousPage(options, data) {\n  if (!data || !options.getPreviousPageParam)\n    return false;\n  return getPreviousPageParam(options, data) != null;\n}\n\n//# sourceMappingURL=infiniteQueryBehavior.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcXVlcnktY29yZUA1LjM2LjEvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9pbmZpbml0ZVF1ZXJ5QmVoYXZpb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQzZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSwrRUFBK0UsZ0RBQVM7QUFDeEYsY0FBYyxJQUFxQztBQUNuRCw0Q0FBNEMsZ0RBQVM7QUFDckQ7QUFDQSx5SEFBeUgsMEJBQTBCO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDBCQUEwQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCLG1DQUFtQyxpREFBVSxHQUFHLCtDQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG1CQUFtQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRhbnN0YWNrK3F1ZXJ5LWNvcmVANS4zNi4xL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vaW5maW5pdGVRdWVyeUJlaGF2aW9yLmpzP2NlN2IiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZmluaXRlUXVlcnlCZWhhdmlvci50c1xuaW1wb3J0IHsgYWRkVG9FbmQsIGFkZFRvU3RhcnQsIHNraXBUb2tlbiB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5mdW5jdGlvbiBpbmZpbml0ZVF1ZXJ5QmVoYXZpb3IocGFnZXMpIHtcbiAgcmV0dXJuIHtcbiAgICBvbkZldGNoOiAoY29udGV4dCwgcXVlcnkpID0+IHtcbiAgICAgIGNvbnN0IGZldGNoRm4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGNvbnRleHQuZmV0Y2hPcHRpb25zPy5tZXRhPy5mZXRjaE1vcmU/LmRpcmVjdGlvbjtcbiAgICAgICAgY29uc3Qgb2xkUGFnZXMgPSBjb250ZXh0LnN0YXRlLmRhdGE/LnBhZ2VzIHx8IFtdO1xuICAgICAgICBjb25zdCBvbGRQYWdlUGFyYW1zID0gY29udGV4dC5zdGF0ZS5kYXRhPy5wYWdlUGFyYW1zIHx8IFtdO1xuICAgICAgICBjb25zdCBlbXB0eSA9IHsgcGFnZXM6IFtdLCBwYWdlUGFyYW1zOiBbXSB9O1xuICAgICAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGFkZFNpZ25hbFByb3BlcnR5ID0gKG9iamVjdCkgPT4ge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIFwic2lnbmFsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGNvbnRleHQuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnNpZ25hbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcXVlcnlGbiA9IGNvbnRleHQub3B0aW9ucy5xdWVyeUZuICYmIGNvbnRleHQub3B0aW9ucy5xdWVyeUZuICE9PSBza2lwVG9rZW4gPyBjb250ZXh0Lm9wdGlvbnMucXVlcnlGbiA6ICgpID0+IHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5vcHRpb25zLnF1ZXJ5Rm4gPT09IHNraXBUb2tlbikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gaW52b2tlIHF1ZXJ5Rm4gd2hlbiBzZXQgdG8gc2tpcFRva2VuLiBUaGlzIGlzIGxpa2VseSBhIGNvbmZpZ3VyYXRpb24gZXJyb3IuIFF1ZXJ5IGhhc2g6ICcke2NvbnRleHQub3B0aW9ucy5xdWVyeUhhc2h9J2BcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgICAgbmV3IEVycm9yKGBNaXNzaW5nIHF1ZXJ5Rm46ICcke2NvbnRleHQub3B0aW9ucy5xdWVyeUhhc2h9J2ApXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmV0Y2hQYWdlID0gYXN5bmMgKGRhdGEsIHBhcmFtLCBwcmV2aW91cykgPT4ge1xuICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyYW0gPT0gbnVsbCAmJiBkYXRhLnBhZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcXVlcnlGbkNvbnRleHQgPSB7XG4gICAgICAgICAgICBxdWVyeUtleTogY29udGV4dC5xdWVyeUtleSxcbiAgICAgICAgICAgIHBhZ2VQYXJhbTogcGFyYW0sXG4gICAgICAgICAgICBkaXJlY3Rpb246IHByZXZpb3VzID8gXCJiYWNrd2FyZFwiIDogXCJmb3J3YXJkXCIsXG4gICAgICAgICAgICBtZXRhOiBjb250ZXh0Lm9wdGlvbnMubWV0YVxuICAgICAgICAgIH07XG4gICAgICAgICAgYWRkU2lnbmFsUHJvcGVydHkocXVlcnlGbkNvbnRleHQpO1xuICAgICAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBxdWVyeUZuKFxuICAgICAgICAgICAgcXVlcnlGbkNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IHsgbWF4UGFnZXMgfSA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgICAgICBjb25zdCBhZGRUbyA9IHByZXZpb3VzID8gYWRkVG9TdGFydCA6IGFkZFRvRW5kO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYWdlczogYWRkVG8oZGF0YS5wYWdlcywgcGFnZSwgbWF4UGFnZXMpLFxuICAgICAgICAgICAgcGFnZVBhcmFtczogYWRkVG8oZGF0YS5wYWdlUGFyYW1zLCBwYXJhbSwgbWF4UGFnZXMpXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmJiBvbGRQYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGRpcmVjdGlvbiA9PT0gXCJiYWNrd2FyZFwiO1xuICAgICAgICAgIGNvbnN0IHBhZ2VQYXJhbUZuID0gcHJldmlvdXMgPyBnZXRQcmV2aW91c1BhZ2VQYXJhbSA6IGdldE5leHRQYWdlUGFyYW07XG4gICAgICAgICAgY29uc3Qgb2xkRGF0YSA9IHtcbiAgICAgICAgICAgIHBhZ2VzOiBvbGRQYWdlcyxcbiAgICAgICAgICAgIHBhZ2VQYXJhbXM6IG9sZFBhZ2VQYXJhbXNcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHBhcmFtID0gcGFnZVBhcmFtRm4ob3B0aW9ucywgb2xkRGF0YSk7XG4gICAgICAgICAgcmVzdWx0ID0gYXdhaXQgZmV0Y2hQYWdlKG9sZERhdGEsIHBhcmFtLCBwcmV2aW91cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gYXdhaXQgZmV0Y2hQYWdlKFxuICAgICAgICAgICAgZW1wdHksXG4gICAgICAgICAgICBvbGRQYWdlUGFyYW1zWzBdID8/IG9wdGlvbnMuaW5pdGlhbFBhZ2VQYXJhbVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgcmVtYWluaW5nUGFnZXMgPSBwYWdlcyA/PyBvbGRQYWdlcy5sZW5ndGg7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByZW1haW5pbmdQYWdlczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IGdldE5leHRQYWdlUGFyYW0ob3B0aW9ucywgcmVzdWx0KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGZldGNoUGFnZShyZXN1bHQsIHBhcmFtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBpZiAoY29udGV4dC5vcHRpb25zLnBlcnNpc3Rlcikge1xuICAgICAgICBjb250ZXh0LmZldGNoRm4gPSAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQub3B0aW9ucy5wZXJzaXN0ZXI/LihcbiAgICAgICAgICAgIGZldGNoRm4sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHF1ZXJ5S2V5OiBjb250ZXh0LnF1ZXJ5S2V5LFxuICAgICAgICAgICAgICBtZXRhOiBjb250ZXh0Lm9wdGlvbnMubWV0YSxcbiAgICAgICAgICAgICAgc2lnbmFsOiBjb250ZXh0LnNpZ25hbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuZmV0Y2hGbiA9IGZldGNoRm47XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0TmV4dFBhZ2VQYXJhbShvcHRpb25zLCB7IHBhZ2VzLCBwYWdlUGFyYW1zIH0pIHtcbiAgY29uc3QgbGFzdEluZGV4ID0gcGFnZXMubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIG9wdGlvbnMuZ2V0TmV4dFBhZ2VQYXJhbShcbiAgICBwYWdlc1tsYXN0SW5kZXhdLFxuICAgIHBhZ2VzLFxuICAgIHBhZ2VQYXJhbXNbbGFzdEluZGV4XSxcbiAgICBwYWdlUGFyYW1zXG4gICk7XG59XG5mdW5jdGlvbiBnZXRQcmV2aW91c1BhZ2VQYXJhbShvcHRpb25zLCB7IHBhZ2VzLCBwYWdlUGFyYW1zIH0pIHtcbiAgcmV0dXJuIG9wdGlvbnMuZ2V0UHJldmlvdXNQYWdlUGFyYW0/LihcbiAgICBwYWdlc1swXSxcbiAgICBwYWdlcyxcbiAgICBwYWdlUGFyYW1zWzBdLFxuICAgIHBhZ2VQYXJhbXNcbiAgKTtcbn1cbmZ1bmN0aW9uIGhhc05leHRQYWdlKG9wdGlvbnMsIGRhdGEpIHtcbiAgaWYgKCFkYXRhKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGdldE5leHRQYWdlUGFyYW0ob3B0aW9ucywgZGF0YSkgIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGhhc1ByZXZpb3VzUGFnZShvcHRpb25zLCBkYXRhKSB7XG4gIGlmICghZGF0YSB8fCAhb3B0aW9ucy5nZXRQcmV2aW91c1BhZ2VQYXJhbSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBnZXRQcmV2aW91c1BhZ2VQYXJhbShvcHRpb25zLCBkYXRhKSAhPSBudWxsO1xufVxuZXhwb3J0IHtcbiAgaGFzTmV4dFBhZ2UsXG4gIGhhc1ByZXZpb3VzUGFnZSxcbiAgaW5maW5pdGVRdWVyeUJlaGF2aW9yXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5maW5pdGVRdWVyeUJlaGF2aW9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/mutation.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/mutation.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mutation: function() { return /* binding */ Mutation; },\n/* harmony export */   getDefaultState: function() { return /* binding */ getDefaultState; }\n/* harmony export */ });\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _removable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./removable.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/removable.js\");\n/* harmony import */ var _retryer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./retryer.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/retryer.js\");\n// src/mutation.ts\n\n\n\nvar Mutation = class extends _removable_js__WEBPACK_IMPORTED_MODULE_0__.Removable {\n  #observers;\n  #mutationCache;\n  #retryer;\n  constructor(config) {\n    super();\n    this.mutationId = config.mutationId;\n    this.#mutationCache = config.mutationCache;\n    this.#observers = [];\n    this.state = config.state || getDefaultState();\n    this.setOptions(config.options);\n    this.scheduleGc();\n  }\n  setOptions(options) {\n    this.options = options;\n    this.updateGcTime(this.options.gcTime);\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  addObserver(observer) {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer);\n      this.clearGcTimeout();\n      this.#mutationCache.notify({\n        type: \"observerAdded\",\n        mutation: this,\n        observer\n      });\n    }\n  }\n  removeObserver(observer) {\n    this.#observers = this.#observers.filter((x) => x !== observer);\n    this.scheduleGc();\n    this.#mutationCache.notify({\n      type: \"observerRemoved\",\n      mutation: this,\n      observer\n    });\n  }\n  optionalRemove() {\n    if (!this.#observers.length) {\n      if (this.state.status === \"pending\") {\n        this.scheduleGc();\n      } else {\n        this.#mutationCache.remove(this);\n      }\n    }\n  }\n  continue() {\n    return this.#retryer?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before\n    this.execute(this.state.variables);\n  }\n  async execute(variables) {\n    this.#retryer = (0,_retryer_js__WEBPACK_IMPORTED_MODULE_1__.createRetryer)({\n      fn: () => {\n        if (!this.options.mutationFn) {\n          return Promise.reject(new Error(\"No mutationFn found\"));\n        }\n        return this.options.mutationFn(variables);\n      },\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: \"failed\", failureCount, error });\n      },\n      onPause: () => {\n        this.#dispatch({ type: \"pause\" });\n      },\n      onContinue: () => {\n        this.#dispatch({ type: \"continue\" });\n      },\n      retry: this.options.retry ?? 0,\n      retryDelay: this.options.retryDelay,\n      networkMode: this.options.networkMode,\n      canRun: () => this.#mutationCache.canRun(this)\n    });\n    const restored = this.state.status === \"pending\";\n    const isPaused = !this.#retryer.canStart();\n    try {\n      if (!restored) {\n        this.#dispatch({ type: \"pending\", variables, isPaused });\n        await this.#mutationCache.config.onMutate?.(\n          variables,\n          this\n        );\n        const context = await this.options.onMutate?.(variables);\n        if (context !== this.state.context) {\n          this.#dispatch({\n            type: \"pending\",\n            context,\n            variables,\n            isPaused\n          });\n        }\n      }\n      const data = await this.#retryer.start();\n      await this.#mutationCache.config.onSuccess?.(\n        data,\n        variables,\n        this.state.context,\n        this\n      );\n      await this.options.onSuccess?.(data, variables, this.state.context);\n      await this.#mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this\n      );\n      await this.options.onSettled?.(data, null, variables, this.state.context);\n      this.#dispatch({ type: \"success\", data });\n      return data;\n    } catch (error) {\n      try {\n        await this.#mutationCache.config.onError?.(\n          error,\n          variables,\n          this.state.context,\n          this\n        );\n        await this.options.onError?.(\n          error,\n          variables,\n          this.state.context\n        );\n        await this.#mutationCache.config.onSettled?.(\n          void 0,\n          error,\n          this.state.variables,\n          this.state.context,\n          this\n        );\n        await this.options.onSettled?.(\n          void 0,\n          error,\n          variables,\n          this.state.context\n        );\n        throw error;\n      } finally {\n        this.#dispatch({ type: \"error\", error });\n      }\n    } finally {\n      this.#mutationCache.runNext(this);\n    }\n  }\n  #dispatch(action) {\n    const reducer = (state) => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            isPaused: true\n          };\n        case \"continue\":\n          return {\n            ...state,\n            isPaused: false\n          };\n        case \"pending\":\n          return {\n            ...state,\n            context: action.context,\n            data: void 0,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: action.isPaused,\n            status: \"pending\",\n            variables: action.variables,\n            submittedAt: Date.now()\n          };\n        case \"success\":\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: \"success\",\n            isPaused: false\n          };\n        case \"error\":\n          return {\n            ...state,\n            data: void 0,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: \"error\"\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__.notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onMutationUpdate(action);\n      });\n      this.#mutationCache.notify({\n        mutation: this,\n        type: \"updated\",\n        action\n      });\n    });\n  }\n};\nfunction getDefaultState() {\n  return {\n    context: void 0,\n    data: void 0,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: \"idle\",\n    variables: void 0,\n    submittedAt: 0\n  };\n}\n\n//# sourceMappingURL=mutation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcXVlcnktY29yZUA1LjM2LjEvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9tdXRhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ21EO0FBQ1I7QUFDRTtBQUM3Qyw2QkFBNkIsb0RBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwREFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EseUJBQXlCLHFDQUFxQztBQUM5RCxPQUFPO0FBQ1A7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QyxPQUFPO0FBQ1A7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzQ0FBc0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNERBQWE7QUFDakI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRhbnN0YWNrK3F1ZXJ5LWNvcmVANS4zNi4xL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vbXV0YXRpb24uanM/MDZkOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbXV0YXRpb24udHNcbmltcG9ydCB7IG5vdGlmeU1hbmFnZXIgfSBmcm9tIFwiLi9ub3RpZnlNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBSZW1vdmFibGUgfSBmcm9tIFwiLi9yZW1vdmFibGUuanNcIjtcbmltcG9ydCB7IGNyZWF0ZVJldHJ5ZXIgfSBmcm9tIFwiLi9yZXRyeWVyLmpzXCI7XG52YXIgTXV0YXRpb24gPSBjbGFzcyBleHRlbmRzIFJlbW92YWJsZSB7XG4gICNvYnNlcnZlcnM7XG4gICNtdXRhdGlvbkNhY2hlO1xuICAjcmV0cnllcjtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm11dGF0aW9uSWQgPSBjb25maWcubXV0YXRpb25JZDtcbiAgICB0aGlzLiNtdXRhdGlvbkNhY2hlID0gY29uZmlnLm11dGF0aW9uQ2FjaGU7XG4gICAgdGhpcy4jb2JzZXJ2ZXJzID0gW107XG4gICAgdGhpcy5zdGF0ZSA9IGNvbmZpZy5zdGF0ZSB8fCBnZXREZWZhdWx0U3RhdGUoKTtcbiAgICB0aGlzLnNldE9wdGlvbnMoY29uZmlnLm9wdGlvbnMpO1xuICAgIHRoaXMuc2NoZWR1bGVHYygpO1xuICB9XG4gIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy51cGRhdGVHY1RpbWUodGhpcy5vcHRpb25zLmdjVGltZSk7XG4gIH1cbiAgZ2V0IG1ldGEoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5tZXRhO1xuICB9XG4gIGFkZE9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgaWYgKCF0aGlzLiNvYnNlcnZlcnMuaW5jbHVkZXMob2JzZXJ2ZXIpKSB7XG4gICAgICB0aGlzLiNvYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICB0aGlzLmNsZWFyR2NUaW1lb3V0KCk7XG4gICAgICB0aGlzLiNtdXRhdGlvbkNhY2hlLm5vdGlmeSh7XG4gICAgICAgIHR5cGU6IFwib2JzZXJ2ZXJBZGRlZFwiLFxuICAgICAgICBtdXRhdGlvbjogdGhpcyxcbiAgICAgICAgb2JzZXJ2ZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZW1vdmVPYnNlcnZlcihvYnNlcnZlcikge1xuICAgIHRoaXMuI29ic2VydmVycyA9IHRoaXMuI29ic2VydmVycy5maWx0ZXIoKHgpID0+IHggIT09IG9ic2VydmVyKTtcbiAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgICB0aGlzLiNtdXRhdGlvbkNhY2hlLm5vdGlmeSh7XG4gICAgICB0eXBlOiBcIm9ic2VydmVyUmVtb3ZlZFwiLFxuICAgICAgbXV0YXRpb246IHRoaXMsXG4gICAgICBvYnNlcnZlclxuICAgIH0pO1xuICB9XG4gIG9wdGlvbmFsUmVtb3ZlKCkge1xuICAgIGlmICghdGhpcy4jb2JzZXJ2ZXJzLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuI211dGF0aW9uQ2FjaGUucmVtb3ZlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb250aW51ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmV0cnllcj8uY29udGludWUoKSA/PyAvLyBjb250aW51aW5nIGEgbXV0YXRpb24gYXNzdW1lcyB0aGF0IHZhcmlhYmxlcyBhcmUgc2V0LCBtdXRhdGlvbiBtdXN0IGhhdmUgYmVlbiBkZWh5ZHJhdGVkIGJlZm9yZVxuICAgIHRoaXMuZXhlY3V0ZSh0aGlzLnN0YXRlLnZhcmlhYmxlcyk7XG4gIH1cbiAgYXN5bmMgZXhlY3V0ZSh2YXJpYWJsZXMpIHtcbiAgICB0aGlzLiNyZXRyeWVyID0gY3JlYXRlUmV0cnllcih7XG4gICAgICBmbjogKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5tdXRhdGlvbkZuKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk5vIG11dGF0aW9uRm4gZm91bmRcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubXV0YXRpb25Gbih2YXJpYWJsZXMpO1xuICAgICAgfSxcbiAgICAgIG9uRmFpbDogKGZhaWx1cmVDb3VudCwgZXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcImZhaWxlZFwiLCBmYWlsdXJlQ291bnQsIGVycm9yIH0pO1xuICAgICAgfSxcbiAgICAgIG9uUGF1c2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcInBhdXNlXCIgfSk7XG4gICAgICB9LFxuICAgICAgb25Db250aW51ZTogKCkgPT4ge1xuICAgICAgICB0aGlzLiNkaXNwYXRjaCh7IHR5cGU6IFwiY29udGludWVcIiB9KTtcbiAgICAgIH0sXG4gICAgICByZXRyeTogdGhpcy5vcHRpb25zLnJldHJ5ID8/IDAsXG4gICAgICByZXRyeURlbGF5OiB0aGlzLm9wdGlvbnMucmV0cnlEZWxheSxcbiAgICAgIG5ldHdvcmtNb2RlOiB0aGlzLm9wdGlvbnMubmV0d29ya01vZGUsXG4gICAgICBjYW5SdW46ICgpID0+IHRoaXMuI211dGF0aW9uQ2FjaGUuY2FuUnVuKHRoaXMpXG4gICAgfSk7XG4gICAgY29uc3QgcmVzdG9yZWQgPSB0aGlzLnN0YXRlLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCI7XG4gICAgY29uc3QgaXNQYXVzZWQgPSAhdGhpcy4jcmV0cnllci5jYW5TdGFydCgpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXJlc3RvcmVkKSB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoKHsgdHlwZTogXCJwZW5kaW5nXCIsIHZhcmlhYmxlcywgaXNQYXVzZWQgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuI211dGF0aW9uQ2FjaGUuY29uZmlnLm9uTXV0YXRlPy4oXG4gICAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGF3YWl0IHRoaXMub3B0aW9ucy5vbk11dGF0ZT8uKHZhcmlhYmxlcyk7XG4gICAgICAgIGlmIChjb250ZXh0ICE9PSB0aGlzLnN0YXRlLmNvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLiNkaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiBcInBlbmRpbmdcIixcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICB2YXJpYWJsZXMsXG4gICAgICAgICAgICBpc1BhdXNlZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jcmV0cnllci5zdGFydCgpO1xuICAgICAgYXdhaXQgdGhpcy4jbXV0YXRpb25DYWNoZS5jb25maWcub25TdWNjZXNzPy4oXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHZhcmlhYmxlcyxcbiAgICAgICAgdGhpcy5zdGF0ZS5jb250ZXh0LFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgICAgYXdhaXQgdGhpcy5vcHRpb25zLm9uU3VjY2Vzcz8uKGRhdGEsIHZhcmlhYmxlcywgdGhpcy5zdGF0ZS5jb250ZXh0KTtcbiAgICAgIGF3YWl0IHRoaXMuI211dGF0aW9uQ2FjaGUuY29uZmlnLm9uU2V0dGxlZD8uKFxuICAgICAgICBkYXRhLFxuICAgICAgICBudWxsLFxuICAgICAgICB0aGlzLnN0YXRlLnZhcmlhYmxlcyxcbiAgICAgICAgdGhpcy5zdGF0ZS5jb250ZXh0LFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgICAgYXdhaXQgdGhpcy5vcHRpb25zLm9uU2V0dGxlZD8uKGRhdGEsIG51bGwsIHZhcmlhYmxlcywgdGhpcy5zdGF0ZS5jb250ZXh0KTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoKHsgdHlwZTogXCJzdWNjZXNzXCIsIGRhdGEgfSk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy4jbXV0YXRpb25DYWNoZS5jb25maWcub25FcnJvcj8uKFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHZhcmlhYmxlcyxcbiAgICAgICAgICB0aGlzLnN0YXRlLmNvbnRleHQsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgICBhd2FpdCB0aGlzLm9wdGlvbnMub25FcnJvcj8uKFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHZhcmlhYmxlcyxcbiAgICAgICAgICB0aGlzLnN0YXRlLmNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgdGhpcy4jbXV0YXRpb25DYWNoZS5jb25maWcub25TZXR0bGVkPy4oXG4gICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHRoaXMuc3RhdGUudmFyaWFibGVzLFxuICAgICAgICAgIHRoaXMuc3RhdGUuY29udGV4dCxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IHRoaXMub3B0aW9ucy5vblNldHRsZWQ/LihcbiAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICAgIHRoaXMuc3RhdGUuY29udGV4dFxuICAgICAgICApO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvciB9KTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy4jbXV0YXRpb25DYWNoZS5ydW5OZXh0KHRoaXMpO1xuICAgIH1cbiAgfVxuICAjZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgY29uc3QgcmVkdWNlciA9IChzdGF0ZSkgPT4ge1xuICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgZmFpbHVyZUNvdW50OiBhY3Rpb24uZmFpbHVyZUNvdW50LFxuICAgICAgICAgICAgZmFpbHVyZVJlYXNvbjogYWN0aW9uLmVycm9yXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInBhdXNlXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgaXNQYXVzZWQ6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiY29udGludWVcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBpc1BhdXNlZDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGNvbnRleHQ6IGFjdGlvbi5jb250ZXh0LFxuICAgICAgICAgICAgZGF0YTogdm9pZCAwLFxuICAgICAgICAgICAgZmFpbHVyZUNvdW50OiAwLFxuICAgICAgICAgICAgZmFpbHVyZVJlYXNvbjogbnVsbCxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgaXNQYXVzZWQ6IGFjdGlvbi5pc1BhdXNlZCxcbiAgICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgICB2YXJpYWJsZXM6IGFjdGlvbi52YXJpYWJsZXMsXG4gICAgICAgICAgICBzdWJtaXR0ZWRBdDogRGF0ZS5ub3coKVxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgZGF0YTogYWN0aW9uLmRhdGEsXG4gICAgICAgICAgICBmYWlsdXJlQ291bnQ6IDAsXG4gICAgICAgICAgICBmYWlsdXJlUmVhc29uOiBudWxsLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgaXNQYXVzZWQ6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgZGF0YTogdm9pZCAwLFxuICAgICAgICAgICAgZXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgICAgIGZhaWx1cmVDb3VudDogc3RhdGUuZmFpbHVyZUNvdW50ICsgMSxcbiAgICAgICAgICAgIGZhaWx1cmVSZWFzb246IGFjdGlvbi5lcnJvcixcbiAgICAgICAgICAgIGlzUGF1c2VkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXR1czogXCJlcnJvclwiXG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc3RhdGUgPSByZWR1Y2VyKHRoaXMuc3RhdGUpO1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy4jb2JzZXJ2ZXJzLmZvckVhY2goKG9ic2VydmVyKSA9PiB7XG4gICAgICAgIG9ic2VydmVyLm9uTXV0YXRpb25VcGRhdGUoYWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4jbXV0YXRpb25DYWNoZS5ub3RpZnkoe1xuICAgICAgICBtdXRhdGlvbjogdGhpcyxcbiAgICAgICAgdHlwZTogXCJ1cGRhdGVkXCIsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBnZXREZWZhdWx0U3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgY29udGV4dDogdm9pZCAwLFxuICAgIGRhdGE6IHZvaWQgMCxcbiAgICBlcnJvcjogbnVsbCxcbiAgICBmYWlsdXJlQ291bnQ6IDAsXG4gICAgZmFpbHVyZVJlYXNvbjogbnVsbCxcbiAgICBpc1BhdXNlZDogZmFsc2UsXG4gICAgc3RhdHVzOiBcImlkbGVcIixcbiAgICB2YXJpYWJsZXM6IHZvaWQgMCxcbiAgICBzdWJtaXR0ZWRBdDogMFxuICB9O1xufVxuZXhwb3J0IHtcbiAgTXV0YXRpb24sXG4gIGdldERlZmF1bHRTdGF0ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11dGF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/mutation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/mutationCache.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/mutationCache.js ***!
  \************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MutationCache: function() { return /* binding */ MutationCache; }\n/* harmony export */ });\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _mutation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mutation.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/mutation.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n// src/mutationCache.ts\n\n\n\n\nvar MutationCache = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#mutations = /* @__PURE__ */ new Map();\n    this.#mutationId = Date.now();\n  }\n  #mutations;\n  #mutationId;\n  build(client, options, state) {\n    const mutation = new _mutation_js__WEBPACK_IMPORTED_MODULE_1__.Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state\n    });\n    this.add(mutation);\n    return mutation;\n  }\n  add(mutation) {\n    const scope = scopeFor(mutation);\n    const mutations = this.#mutations.get(scope) ?? [];\n    mutations.push(mutation);\n    this.#mutations.set(scope, mutations);\n    this.notify({ type: \"added\", mutation });\n  }\n  remove(mutation) {\n    const scope = scopeFor(mutation);\n    if (this.#mutations.has(scope)) {\n      const mutations = this.#mutations.get(scope)?.filter((x) => x !== mutation);\n      if (mutations) {\n        if (mutations.length === 0) {\n          this.#mutations.delete(scope);\n        } else {\n          this.#mutations.set(scope, mutations);\n        }\n      }\n    }\n    this.notify({ type: \"removed\", mutation });\n  }\n  canRun(mutation) {\n    const firstPendingMutation = this.#mutations.get(scopeFor(mutation))?.find((m) => m.state.status === \"pending\");\n    return !firstPendingMutation || firstPendingMutation === mutation;\n  }\n  runNext(mutation) {\n    const foundMutation = this.#mutations.get(scopeFor(mutation))?.find((m) => m !== mutation && m.state.isPaused);\n    return foundMutation?.continue() ?? Promise.resolve();\n  }\n  clear() {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__.notifyManager.batch(() => {\n      this.getAll().forEach((mutation) => {\n        this.remove(mutation);\n      });\n    });\n  }\n  getAll() {\n    return [...this.#mutations.values()].flat();\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (mutation) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.matchMutation)(defaultedFilters, mutation)\n    );\n  }\n  findAll(filters = {}) {\n    return this.getAll().filter((mutation) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.matchMutation)(filters, mutation));\n  }\n  notify(event) {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__.notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  resumePausedMutations() {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);\n    return _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__.notifyManager.batch(\n      () => Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(_utils_js__WEBPACK_IMPORTED_MODULE_3__.noop))\n      )\n    );\n  }\n};\nfunction scopeFor(mutation) {\n  return mutation.options.scope?.id ?? String(mutation.mutationId);\n}\n\n//# sourceMappingURL=mutationCache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcXVlcnktY29yZUA1LjM2LjEvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9tdXRhdGlvbkNhY2hlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDbUQ7QUFDVjtBQUNRO0FBQ0E7QUFDakQsa0NBQWtDLDBEQUFZO0FBQzlDLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtEQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0REFBYTtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0Esb0JBQW9CLHdEQUFhO0FBQ2pDO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsOENBQThDLHdEQUFhO0FBQzNEO0FBQ0E7QUFDQSxJQUFJLDREQUFhO0FBQ2pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNERBQWE7QUFDeEI7QUFDQSxvRUFBb0UsMkNBQUk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcXVlcnktY29yZUA1LjM2LjEvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9tdXRhdGlvbkNhY2hlLmpzPzM0YjYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL211dGF0aW9uQ2FjaGUudHNcbmltcG9ydCB7IG5vdGlmeU1hbmFnZXIgfSBmcm9tIFwiLi9ub3RpZnlNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBNdXRhdGlvbiB9IGZyb20gXCIuL211dGF0aW9uLmpzXCI7XG5pbXBvcnQgeyBtYXRjaE11dGF0aW9uLCBub29wIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IFN1YnNjcmliYWJsZSB9IGZyb20gXCIuL3N1YnNjcmliYWJsZS5qc1wiO1xudmFyIE11dGF0aW9uQ2FjaGUgPSBjbGFzcyBleHRlbmRzIFN1YnNjcmliYWJsZSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLiNtdXRhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuI211dGF0aW9uSWQgPSBEYXRlLm5vdygpO1xuICB9XG4gICNtdXRhdGlvbnM7XG4gICNtdXRhdGlvbklkO1xuICBidWlsZChjbGllbnQsIG9wdGlvbnMsIHN0YXRlKSB7XG4gICAgY29uc3QgbXV0YXRpb24gPSBuZXcgTXV0YXRpb24oe1xuICAgICAgbXV0YXRpb25DYWNoZTogdGhpcyxcbiAgICAgIG11dGF0aW9uSWQ6ICsrdGhpcy4jbXV0YXRpb25JZCxcbiAgICAgIG9wdGlvbnM6IGNsaWVudC5kZWZhdWx0TXV0YXRpb25PcHRpb25zKG9wdGlvbnMpLFxuICAgICAgc3RhdGVcbiAgICB9KTtcbiAgICB0aGlzLmFkZChtdXRhdGlvbik7XG4gICAgcmV0dXJuIG11dGF0aW9uO1xuICB9XG4gIGFkZChtdXRhdGlvbikge1xuICAgIGNvbnN0IHNjb3BlID0gc2NvcGVGb3IobXV0YXRpb24pO1xuICAgIGNvbnN0IG11dGF0aW9ucyA9IHRoaXMuI211dGF0aW9ucy5nZXQoc2NvcGUpID8/IFtdO1xuICAgIG11dGF0aW9ucy5wdXNoKG11dGF0aW9uKTtcbiAgICB0aGlzLiNtdXRhdGlvbnMuc2V0KHNjb3BlLCBtdXRhdGlvbnMpO1xuICAgIHRoaXMubm90aWZ5KHsgdHlwZTogXCJhZGRlZFwiLCBtdXRhdGlvbiB9KTtcbiAgfVxuICByZW1vdmUobXV0YXRpb24pIHtcbiAgICBjb25zdCBzY29wZSA9IHNjb3BlRm9yKG11dGF0aW9uKTtcbiAgICBpZiAodGhpcy4jbXV0YXRpb25zLmhhcyhzY29wZSkpIHtcbiAgICAgIGNvbnN0IG11dGF0aW9ucyA9IHRoaXMuI211dGF0aW9ucy5nZXQoc2NvcGUpPy5maWx0ZXIoKHgpID0+IHggIT09IG11dGF0aW9uKTtcbiAgICAgIGlmIChtdXRhdGlvbnMpIHtcbiAgICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLiNtdXRhdGlvbnMuZGVsZXRlKHNjb3BlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiNtdXRhdGlvbnMuc2V0KHNjb3BlLCBtdXRhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubm90aWZ5KHsgdHlwZTogXCJyZW1vdmVkXCIsIG11dGF0aW9uIH0pO1xuICB9XG4gIGNhblJ1bihtdXRhdGlvbikge1xuICAgIGNvbnN0IGZpcnN0UGVuZGluZ011dGF0aW9uID0gdGhpcy4jbXV0YXRpb25zLmdldChzY29wZUZvcihtdXRhdGlvbikpPy5maW5kKChtKSA9PiBtLnN0YXRlLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpO1xuICAgIHJldHVybiAhZmlyc3RQZW5kaW5nTXV0YXRpb24gfHwgZmlyc3RQZW5kaW5nTXV0YXRpb24gPT09IG11dGF0aW9uO1xuICB9XG4gIHJ1bk5leHQobXV0YXRpb24pIHtcbiAgICBjb25zdCBmb3VuZE11dGF0aW9uID0gdGhpcy4jbXV0YXRpb25zLmdldChzY29wZUZvcihtdXRhdGlvbikpPy5maW5kKChtKSA9PiBtICE9PSBtdXRhdGlvbiAmJiBtLnN0YXRlLmlzUGF1c2VkKTtcbiAgICByZXR1cm4gZm91bmRNdXRhdGlvbj8uY29udGludWUoKSA/PyBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMuZ2V0QWxsKCkuZm9yRWFjaCgobXV0YXRpb24pID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmUobXV0YXRpb24pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0QWxsKCkge1xuICAgIHJldHVybiBbLi4udGhpcy4jbXV0YXRpb25zLnZhbHVlcygpXS5mbGF0KCk7XG4gIH1cbiAgZmluZChmaWx0ZXJzKSB7XG4gICAgY29uc3QgZGVmYXVsdGVkRmlsdGVycyA9IHsgZXhhY3Q6IHRydWUsIC4uLmZpbHRlcnMgfTtcbiAgICByZXR1cm4gdGhpcy5nZXRBbGwoKS5maW5kKFxuICAgICAgKG11dGF0aW9uKSA9PiBtYXRjaE11dGF0aW9uKGRlZmF1bHRlZEZpbHRlcnMsIG11dGF0aW9uKVxuICAgICk7XG4gIH1cbiAgZmluZEFsbChmaWx0ZXJzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBbGwoKS5maWx0ZXIoKG11dGF0aW9uKSA9PiBtYXRjaE11dGF0aW9uKGZpbHRlcnMsIG11dGF0aW9uKSk7XG4gIH1cbiAgbm90aWZ5KGV2ZW50KSB7XG4gICAgbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICBsaXN0ZW5lcihldmVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXN1bWVQYXVzZWRNdXRhdGlvbnMoKSB7XG4gICAgY29uc3QgcGF1c2VkTXV0YXRpb25zID0gdGhpcy5nZXRBbGwoKS5maWx0ZXIoKHgpID0+IHguc3RhdGUuaXNQYXVzZWQpO1xuICAgIHJldHVybiBub3RpZnlNYW5hZ2VyLmJhdGNoKFxuICAgICAgKCkgPT4gUHJvbWlzZS5hbGwoXG4gICAgICAgIHBhdXNlZE11dGF0aW9ucy5tYXAoKG11dGF0aW9uKSA9PiBtdXRhdGlvbi5jb250aW51ZSgpLmNhdGNoKG5vb3ApKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBzY29wZUZvcihtdXRhdGlvbikge1xuICByZXR1cm4gbXV0YXRpb24ub3B0aW9ucy5zY29wZT8uaWQgPz8gU3RyaW5nKG11dGF0aW9uLm11dGF0aW9uSWQpO1xufVxuZXhwb3J0IHtcbiAgTXV0YXRpb25DYWNoZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11dGF0aW9uQ2FjaGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/mutationCache.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/notifyManager.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/notifyManager.js ***!
  \************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createNotifyManager: function() { return /* binding */ createNotifyManager; },\n/* harmony export */   notifyManager: function() { return /* binding */ notifyManager; }\n/* harmony export */ });\n// src/notifyManager.ts\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n  let notifyFn = (callback) => {\n    callback();\n  };\n  let batchNotifyFn = (callback) => {\n    callback();\n  };\n  let scheduleFn = (cb) => setTimeout(cb, 0);\n  const setScheduler = (fn) => {\n    scheduleFn = fn;\n  };\n  const batch = (callback) => {\n    let result;\n    transactions++;\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n      if (!transactions) {\n        flush();\n      }\n    }\n    return result;\n  };\n  const schedule = (callback) => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleFn(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  const batchCalls = (callback) => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n    if (originalQueue.length) {\n      scheduleFn(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  const setNotifyFunction = (fn) => {\n    notifyFn = fn;\n  };\n  const setBatchNotifyFunction = (fn) => {\n    batchNotifyFn = fn;\n  };\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction,\n    setScheduler\n  };\n}\nvar notifyManager = createNotifyManager();\n\n//# sourceMappingURL=notifyManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcXVlcnktY29yZUA1LjM2LjEvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9ub3RpZnlNYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcXVlcnktY29yZUA1LjM2LjEvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9ub3RpZnlNYW5hZ2VyLmpzP2Y4ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL25vdGlmeU1hbmFnZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZU5vdGlmeU1hbmFnZXIoKSB7XG4gIGxldCBxdWV1ZSA9IFtdO1xuICBsZXQgdHJhbnNhY3Rpb25zID0gMDtcbiAgbGV0IG5vdGlmeUZuID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgY2FsbGJhY2soKTtcbiAgfTtcbiAgbGV0IGJhdGNoTm90aWZ5Rm4gPSAoY2FsbGJhY2spID0+IHtcbiAgICBjYWxsYmFjaygpO1xuICB9O1xuICBsZXQgc2NoZWR1bGVGbiA9IChjYikgPT4gc2V0VGltZW91dChjYiwgMCk7XG4gIGNvbnN0IHNldFNjaGVkdWxlciA9IChmbikgPT4ge1xuICAgIHNjaGVkdWxlRm4gPSBmbjtcbiAgfTtcbiAgY29uc3QgYmF0Y2ggPSAoY2FsbGJhY2spID0+IHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyYW5zYWN0aW9ucysrO1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBjYWxsYmFjaygpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cmFuc2FjdGlvbnMtLTtcbiAgICAgIGlmICghdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIGNvbnN0IHNjaGVkdWxlID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgaWYgKHRyYW5zYWN0aW9ucykge1xuICAgICAgcXVldWUucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlRm4oKCkgPT4ge1xuICAgICAgICBub3RpZnlGbihjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGJhdGNoQ2FsbHMgPSAoY2FsbGJhY2spID0+IHtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgIHNjaGVkdWxlKCgpID0+IHtcbiAgICAgICAgY2FsbGJhY2soLi4uYXJncyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuICBjb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSBbXTtcbiAgICBpZiAob3JpZ2luYWxRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHNjaGVkdWxlRm4oKCkgPT4ge1xuICAgICAgICBiYXRjaE5vdGlmeUZuKCgpID0+IHtcbiAgICAgICAgICBvcmlnaW5hbFF1ZXVlLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBub3RpZnlGbihjYWxsYmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzZXROb3RpZnlGdW5jdGlvbiA9IChmbikgPT4ge1xuICAgIG5vdGlmeUZuID0gZm47XG4gIH07XG4gIGNvbnN0IHNldEJhdGNoTm90aWZ5RnVuY3Rpb24gPSAoZm4pID0+IHtcbiAgICBiYXRjaE5vdGlmeUZuID0gZm47XG4gIH07XG4gIHJldHVybiB7XG4gICAgYmF0Y2gsXG4gICAgYmF0Y2hDYWxscyxcbiAgICBzY2hlZHVsZSxcbiAgICBzZXROb3RpZnlGdW5jdGlvbixcbiAgICBzZXRCYXRjaE5vdGlmeUZ1bmN0aW9uLFxuICAgIHNldFNjaGVkdWxlclxuICB9O1xufVxudmFyIG5vdGlmeU1hbmFnZXIgPSBjcmVhdGVOb3RpZnlNYW5hZ2VyKCk7XG5leHBvcnQge1xuICBjcmVhdGVOb3RpZnlNYW5hZ2VyLFxuICBub3RpZnlNYW5hZ2VyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm90aWZ5TWFuYWdlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/notifyManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/onlineManager.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/onlineManager.js ***!
  \************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OnlineManager: function() { return /* binding */ OnlineManager; },\n/* harmony export */   onlineManager: function() { return /* binding */ onlineManager; }\n/* harmony export */ });\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/onlineManager.ts\n\n\nvar OnlineManager = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  #online = true;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onOnline) => {\n      if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isServer && window.addEventListener) {\n        const onlineListener = () => onOnline(true);\n        const offlineListener = () => onOnline(false);\n        window.addEventListener(\"online\", onlineListener, false);\n        window.addEventListener(\"offline\", offlineListener, false);\n        return () => {\n          window.removeEventListener(\"online\", onlineListener);\n          window.removeEventListener(\"offline\", offlineListener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup(this.setOnline.bind(this));\n  }\n  setOnline(online) {\n    const changed = this.#online !== online;\n    if (changed) {\n      this.#online = online;\n      this.listeners.forEach((listener) => {\n        listener(online);\n      });\n    }\n  }\n  isOnline() {\n    return this.#online;\n  }\n};\nvar onlineManager = new OnlineManager();\n\n//# sourceMappingURL=onlineManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcXVlcnktY29yZUA1LjM2LjEvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9vbmxpbmVNYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNpRDtBQUNYO0FBQ3RDLGtDQUFrQywwREFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtDQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRhbnN0YWNrK3F1ZXJ5LWNvcmVANS4zNi4xL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vb25saW5lTWFuYWdlci5qcz8zODIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9vbmxpbmVNYW5hZ2VyLnRzXG5pbXBvcnQgeyBTdWJzY3JpYmFibGUgfSBmcm9tIFwiLi9zdWJzY3JpYmFibGUuanNcIjtcbmltcG9ydCB7IGlzU2VydmVyIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbnZhciBPbmxpbmVNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBTdWJzY3JpYmFibGUge1xuICAjb25saW5lID0gdHJ1ZTtcbiAgI2NsZWFudXA7XG4gICNzZXR1cDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNzZXR1cCA9IChvbk9ubGluZSkgPT4ge1xuICAgICAgaWYgKCFpc1NlcnZlciAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBvbmxpbmVMaXN0ZW5lciA9ICgpID0+IG9uT25saW5lKHRydWUpO1xuICAgICAgICBjb25zdCBvZmZsaW5lTGlzdGVuZXIgPSAoKSA9PiBvbk9ubGluZShmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsIG9ubGluZUxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBvZmZsaW5lTGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBvbmxpbmVMaXN0ZW5lcik7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIG9mZmxpbmVMaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfTtcbiAgfVxuICBvblN1YnNjcmliZSgpIHtcbiAgICBpZiAoIXRoaXMuI2NsZWFudXApIHtcbiAgICAgIHRoaXMuc2V0RXZlbnRMaXN0ZW5lcih0aGlzLiNzZXR1cCk7XG4gICAgfVxuICB9XG4gIG9uVW5zdWJzY3JpYmUoKSB7XG4gICAgaWYgKCF0aGlzLmhhc0xpc3RlbmVycygpKSB7XG4gICAgICB0aGlzLiNjbGVhbnVwPy4oKTtcbiAgICAgIHRoaXMuI2NsZWFudXAgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHNldEV2ZW50TGlzdGVuZXIoc2V0dXApIHtcbiAgICB0aGlzLiNzZXR1cCA9IHNldHVwO1xuICAgIHRoaXMuI2NsZWFudXA/LigpO1xuICAgIHRoaXMuI2NsZWFudXAgPSBzZXR1cCh0aGlzLnNldE9ubGluZS5iaW5kKHRoaXMpKTtcbiAgfVxuICBzZXRPbmxpbmUob25saW5lKSB7XG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuI29ubGluZSAhPT0gb25saW5lO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLiNvbmxpbmUgPSBvbmxpbmU7XG4gICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICBsaXN0ZW5lcihvbmxpbmUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlzT25saW5lKCkge1xuICAgIHJldHVybiB0aGlzLiNvbmxpbmU7XG4gIH1cbn07XG52YXIgb25saW5lTWFuYWdlciA9IG5ldyBPbmxpbmVNYW5hZ2VyKCk7XG5leHBvcnQge1xuICBPbmxpbmVNYW5hZ2VyLFxuICBvbmxpbmVNYW5hZ2VyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25saW5lTWFuYWdlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/onlineManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/query.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/query.js ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Query: function() { return /* binding */ Query; },\n/* harmony export */   fetchState: function() { return /* binding */ fetchState; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _retryer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./retryer.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/retryer.js\");\n/* harmony import */ var _removable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./removable.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/removable.js\");\n// src/query.ts\n\n\n\n\nvar Query = class extends _removable_js__WEBPACK_IMPORTED_MODULE_0__.Removable {\n  #initialState;\n  #revertState;\n  #cache;\n  #retryer;\n  #defaultOptions;\n  #abortSignalConsumed;\n  constructor(config) {\n    super();\n    this.#abortSignalConsumed = false;\n    this.#defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.#cache = config.cache;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.#initialState = config.state || getDefaultState(this.options);\n    this.state = this.#initialState;\n    this.scheduleGc();\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  setOptions(options) {\n    this.options = { ...this.#defaultOptions, ...options };\n    this.updateGcTime(this.options.gcTime);\n  }\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === \"idle\") {\n      this.#cache.remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.replaceData)(this.state.data, newData, this.options);\n    this.#dispatch({\n      data,\n      type: \"success\",\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    this.#dispatch({ type: \"setState\", state, setStateOptions });\n  }\n  cancel(options) {\n    const promise = this.#retryer?.promise;\n    this.#retryer?.cancel(options);\n    return promise ? promise.then(_utils_js__WEBPACK_IMPORTED_MODULE_1__.noop).catch(_utils_js__WEBPACK_IMPORTED_MODULE_1__.noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({ silent: true });\n  }\n  reset() {\n    this.destroy();\n    this.setState(this.#initialState);\n  }\n  isActive() {\n    return this.observers.some((observer) => observer.options.enabled !== false);\n  }\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n  isStale() {\n    if (this.state.isInvalidated) {\n      return true;\n    }\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale\n      );\n    }\n    return this.state.data === void 0;\n  }\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || this.state.data === void 0 || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.timeUntilStale)(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  onOnline() {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer);\n      this.clearGcTimeout();\n      this.#cache.notify({ type: \"observerAdded\", query: this, observer });\n    }\n  }\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer);\n      if (!this.observers.length) {\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true });\n          } else {\n            this.#retryer.cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      this.#cache.notify({ type: \"observerRemoved\", query: this, observer });\n    }\n  }\n  getObserversCount() {\n    return this.observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: \"invalidate\" });\n    }\n  }\n  fetch(options, fetchOptions) {\n    if (this.state.fetchStatus !== \"idle\") {\n      if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {\n        this.cancel({ silent: true });\n      } else if (this.#retryer) {\n        this.#retryer.continueRetry();\n        return this.#retryer.promise;\n      }\n    }\n    if (options) {\n      this.setOptions(options);\n    }\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn);\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n    if (true) {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`\n        );\n      }\n    }\n    const abortController = new AbortController();\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      meta: this.meta\n    };\n    const addSignalProperty = (object) => {\n      Object.defineProperty(object, \"signal\", {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true;\n          return abortController.signal;\n        }\n      });\n    };\n    addSignalProperty(queryFnContext);\n    const fetchFn = () => {\n      if (true) {\n        if (this.options.queryFn === _utils_js__WEBPACK_IMPORTED_MODULE_1__.skipToken) {\n          console.error(\n            `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${this.options.queryHash}'`\n          );\n        }\n      }\n      if (!this.options.queryFn || this.options.queryFn === _utils_js__WEBPACK_IMPORTED_MODULE_1__.skipToken) {\n        return Promise.reject(\n          new Error(`Missing queryFn: '${this.options.queryHash}'`)\n        );\n      }\n      this.#abortSignalConsumed = false;\n      if (this.options.persister) {\n        return this.options.persister(\n          this.options.queryFn,\n          queryFnContext,\n          this\n        );\n      }\n      return this.options.queryFn(\n        queryFnContext\n      );\n    };\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    this.options.behavior?.onFetch(\n      context,\n      this\n    );\n    this.#revertState = this.state;\n    if (this.state.fetchStatus === \"idle\" || this.state.fetchMeta !== context.fetchOptions?.meta) {\n      this.#dispatch({ type: \"fetch\", meta: context.fetchOptions?.meta });\n    }\n    const onError = (error) => {\n      if (!((0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.isCancelledError)(error) && error.silent)) {\n        this.#dispatch({\n          type: \"error\",\n          error\n        });\n      }\n      if (!(0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.isCancelledError)(error)) {\n        this.#cache.config.onError?.(\n          error,\n          this\n        );\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error,\n          this\n        );\n      }\n      if (!this.isFetchingOptimistic) {\n        this.scheduleGc();\n      }\n      this.isFetchingOptimistic = false;\n    };\n    this.#retryer = (0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.createRetryer)({\n      fn: context.fetchFn,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === void 0) {\n          if (true) {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`\n            );\n          }\n          onError(new Error(`${this.queryHash} data is undefined`));\n          return;\n        }\n        this.setData(data);\n        this.#cache.config.onSuccess?.(data, this);\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error,\n          this\n        );\n        if (!this.isFetchingOptimistic) {\n          this.scheduleGc();\n        }\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: \"failed\", failureCount, error });\n      },\n      onPause: () => {\n        this.#dispatch({ type: \"pause\" });\n      },\n      onContinue: () => {\n        this.#dispatch({ type: \"continue\" });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true\n    });\n    return this.#retryer.start();\n  }\n  #dispatch(action) {\n    const reducer = (state) => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            fetchStatus: \"paused\"\n          };\n        case \"continue\":\n          return {\n            ...state,\n            fetchStatus: \"fetching\"\n          };\n        case \"fetch\":\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null\n          };\n        case \"success\":\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: \"success\",\n            ...!action.manual && {\n              fetchStatus: \"idle\",\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            }\n          };\n        case \"error\":\n          const error = action.error;\n          if ((0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.isCancelledError)(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: \"idle\" };\n          }\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: \"idle\",\n            status: \"error\"\n          };\n        case \"invalidate\":\n          return {\n            ...state,\n            isInvalidated: true\n          };\n        case \"setState\":\n          return {\n            ...state,\n            ...action.state\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate();\n      });\n      this.#cache.notify({ query: this, type: \"updated\", action });\n    });\n  }\n};\nfunction fetchState(data, options) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: (0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.canFetch)(options.networkMode) ? \"fetching\" : \"paused\",\n    ...data === void 0 && {\n      error: null,\n      status: \"pending\"\n    }\n  };\n}\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  const hasData = data !== void 0;\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\n\n//# sourceMappingURL=query.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcXVlcnktY29yZUA1LjM2LjEvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9xdWVyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUMwRTtBQUN2QjtBQUNzQjtBQUM5QjtBQUMzQywwQkFBMEIsb0RBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNEQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBDQUEwQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyQ0FBSSxRQUFRLDJDQUFJO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UseURBQWM7QUFDcEY7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhDQUE4QztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQWdEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQyxxQ0FBcUMsZ0RBQVM7QUFDOUM7QUFDQSxxSEFBcUgsdUJBQXVCO0FBQzVJO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxnREFBUztBQUNyRTtBQUNBLHlDQUF5Qyx1QkFBdUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQWlEO0FBQ3hFO0FBQ0E7QUFDQSxZQUFZLDZEQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxXQUFXLDZEQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQXFDO0FBQ25EO0FBQ0EsdUpBQXVKLGVBQWU7QUFDdEs7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHlCQUF5QixxQ0FBcUM7QUFDOUQsT0FBTztBQUNQO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEMsT0FBTztBQUNQO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkRBQWdCO0FBQzlCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFhO0FBQ2pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkJBQTJCLHNDQUFzQztBQUNqRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRhbnN0YWNrK3F1ZXJ5LWNvcmVANS4zNi4xL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcXVlcnkuanM/MDYwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcXVlcnkudHNcbmltcG9ydCB7IG5vb3AsIHJlcGxhY2VEYXRhLCBza2lwVG9rZW4sIHRpbWVVbnRpbFN0YWxlIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IG5vdGlmeU1hbmFnZXIgfSBmcm9tIFwiLi9ub3RpZnlNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBjYW5GZXRjaCwgY3JlYXRlUmV0cnllciwgaXNDYW5jZWxsZWRFcnJvciB9IGZyb20gXCIuL3JldHJ5ZXIuanNcIjtcbmltcG9ydCB7IFJlbW92YWJsZSB9IGZyb20gXCIuL3JlbW92YWJsZS5qc1wiO1xudmFyIFF1ZXJ5ID0gY2xhc3MgZXh0ZW5kcyBSZW1vdmFibGUge1xuICAjaW5pdGlhbFN0YXRlO1xuICAjcmV2ZXJ0U3RhdGU7XG4gICNjYWNoZTtcbiAgI3JldHJ5ZXI7XG4gICNkZWZhdWx0T3B0aW9ucztcbiAgI2Fib3J0U2lnbmFsQ29uc3VtZWQ7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jYWJvcnRTaWduYWxDb25zdW1lZCA9IGZhbHNlO1xuICAgIHRoaXMuI2RlZmF1bHRPcHRpb25zID0gY29uZmlnLmRlZmF1bHRPcHRpb25zO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhjb25maWcub3B0aW9ucyk7XG4gICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICB0aGlzLiNjYWNoZSA9IGNvbmZpZy5jYWNoZTtcbiAgICB0aGlzLnF1ZXJ5S2V5ID0gY29uZmlnLnF1ZXJ5S2V5O1xuICAgIHRoaXMucXVlcnlIYXNoID0gY29uZmlnLnF1ZXJ5SGFzaDtcbiAgICB0aGlzLiNpbml0aWFsU3RhdGUgPSBjb25maWcuc3RhdGUgfHwgZ2V0RGVmYXVsdFN0YXRlKHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuI2luaXRpYWxTdGF0ZTtcbiAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgfVxuICBnZXQgbWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLm1ldGE7XG4gIH1cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi50aGlzLiNkZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMudXBkYXRlR2NUaW1lKHRoaXMub3B0aW9ucy5nY1RpbWUpO1xuICB9XG4gIG9wdGlvbmFsUmVtb3ZlKCkge1xuICAgIGlmICghdGhpcy5vYnNlcnZlcnMubGVuZ3RoICYmIHRoaXMuc3RhdGUuZmV0Y2hTdGF0dXMgPT09IFwiaWRsZVwiKSB7XG4gICAgICB0aGlzLiNjYWNoZS5yZW1vdmUodGhpcyk7XG4gICAgfVxuICB9XG4gIHNldERhdGEobmV3RGF0YSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRhdGEgPSByZXBsYWNlRGF0YSh0aGlzLnN0YXRlLmRhdGEsIG5ld0RhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy4jZGlzcGF0Y2goe1xuICAgICAgZGF0YSxcbiAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgZGF0YVVwZGF0ZWRBdDogb3B0aW9ucz8udXBkYXRlZEF0LFxuICAgICAgbWFudWFsOiBvcHRpb25zPy5tYW51YWxcbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBzZXRTdGF0ZShzdGF0ZSwgc2V0U3RhdGVPcHRpb25zKSB7XG4gICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcInNldFN0YXRlXCIsIHN0YXRlLCBzZXRTdGF0ZU9wdGlvbnMgfSk7XG4gIH1cbiAgY2FuY2VsKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy4jcmV0cnllcj8ucHJvbWlzZTtcbiAgICB0aGlzLiNyZXRyeWVyPy5jYW5jZWwob3B0aW9ucyk7XG4gICAgcmV0dXJuIHByb21pc2UgPyBwcm9taXNlLnRoZW4obm9vcCkuY2F0Y2gobm9vcCkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmNhbmNlbCh7IHNpbGVudDogdHJ1ZSB9KTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB0aGlzLnNldFN0YXRlKHRoaXMuI2luaXRpYWxTdGF0ZSk7XG4gIH1cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLnNvbWUoKG9ic2VydmVyKSA9PiBvYnNlcnZlci5vcHRpb25zLmVuYWJsZWQgIT09IGZhbHNlKTtcbiAgfVxuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE9ic2VydmVyc0NvdW50KCkgPiAwICYmICF0aGlzLmlzQWN0aXZlKCk7XG4gIH1cbiAgaXNTdGFsZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5pc0ludmFsaWRhdGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0T2JzZXJ2ZXJzQ291bnQoKSA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLm9ic2VydmVycy5zb21lKFxuICAgICAgICAob2JzZXJ2ZXIpID0+IG9ic2VydmVyLmdldEN1cnJlbnRSZXN1bHQoKS5pc1N0YWxlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5kYXRhID09PSB2b2lkIDA7XG4gIH1cbiAgaXNTdGFsZUJ5VGltZShzdGFsZVRpbWUgPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNJbnZhbGlkYXRlZCB8fCB0aGlzLnN0YXRlLmRhdGEgPT09IHZvaWQgMCB8fCAhdGltZVVudGlsU3RhbGUodGhpcy5zdGF0ZS5kYXRhVXBkYXRlZEF0LCBzdGFsZVRpbWUpO1xuICB9XG4gIG9uRm9jdXMoKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVycy5maW5kKCh4KSA9PiB4LnNob3VsZEZldGNoT25XaW5kb3dGb2N1cygpKTtcbiAgICBvYnNlcnZlcj8ucmVmZXRjaCh7IGNhbmNlbFJlZmV0Y2g6IGZhbHNlIH0pO1xuICAgIHRoaXMuI3JldHJ5ZXI/LmNvbnRpbnVlKCk7XG4gIH1cbiAgb25PbmxpbmUoKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVycy5maW5kKCh4KSA9PiB4LnNob3VsZEZldGNoT25SZWNvbm5lY3QoKSk7XG4gICAgb2JzZXJ2ZXI/LnJlZmV0Y2goeyBjYW5jZWxSZWZldGNoOiBmYWxzZSB9KTtcbiAgICB0aGlzLiNyZXRyeWVyPy5jb250aW51ZSgpO1xuICB9XG4gIGFkZE9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVycy5pbmNsdWRlcyhvYnNlcnZlcikpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgICAgdGhpcy5jbGVhckdjVGltZW91dCgpO1xuICAgICAgdGhpcy4jY2FjaGUubm90aWZ5KHsgdHlwZTogXCJvYnNlcnZlckFkZGVkXCIsIHF1ZXJ5OiB0aGlzLCBvYnNlcnZlciB9KTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICBpZiAodGhpcy5vYnNlcnZlcnMuaW5jbHVkZXMob2JzZXJ2ZXIpKSB7XG4gICAgICB0aGlzLm9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzLmZpbHRlcigoeCkgPT4geCAhPT0gb2JzZXJ2ZXIpO1xuICAgICAgaWYgKCF0aGlzLm9ic2VydmVycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3JldHJ5ZXIpIHtcbiAgICAgICAgICBpZiAodGhpcy4jYWJvcnRTaWduYWxDb25zdW1lZCkge1xuICAgICAgICAgICAgdGhpcy4jcmV0cnllci5jYW5jZWwoeyByZXZlcnQ6IHRydWUgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI3JldHJ5ZXIuY2FuY2VsUmV0cnkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZUdjKCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNjYWNoZS5ub3RpZnkoeyB0eXBlOiBcIm9ic2VydmVyUmVtb3ZlZFwiLCBxdWVyeTogdGhpcywgb2JzZXJ2ZXIgfSk7XG4gICAgfVxuICB9XG4gIGdldE9ic2VydmVyc0NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLm9ic2VydmVycy5sZW5ndGg7XG4gIH1cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuaXNJbnZhbGlkYXRlZCkge1xuICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcImludmFsaWRhdGVcIiB9KTtcbiAgICB9XG4gIH1cbiAgZmV0Y2gob3B0aW9ucywgZmV0Y2hPcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuZmV0Y2hTdGF0dXMgIT09IFwiaWRsZVwiKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5kYXRhICE9PSB2b2lkIDAgJiYgZmV0Y2hPcHRpb25zPy5jYW5jZWxSZWZldGNoKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKHsgc2lsZW50OiB0cnVlIH0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLiNyZXRyeWVyKSB7XG4gICAgICAgIHRoaXMuI3JldHJ5ZXIuY29udGludWVSZXRyeSgpO1xuICAgICAgICByZXR1cm4gdGhpcy4jcmV0cnllci5wcm9taXNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5xdWVyeUZuKSB7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXJzLmZpbmQoKHgpID0+IHgub3B0aW9ucy5xdWVyeUZuKTtcbiAgICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMob2JzZXJ2ZXIub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMucXVlcnlLZXkpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYEFzIG9mIHY0LCBxdWVyeUtleSBuZWVkcyB0byBiZSBhbiBBcnJheS4gSWYgeW91IGFyZSB1c2luZyBhIHN0cmluZyBsaWtlICdyZXBvRGF0YScsIHBsZWFzZSBjaGFuZ2UgaXQgdG8gYW4gQXJyYXksIGUuZy4gWydyZXBvRGF0YSddYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgcXVlcnlGbkNvbnRleHQgPSB7XG4gICAgICBxdWVyeUtleTogdGhpcy5xdWVyeUtleSxcbiAgICAgIG1ldGE6IHRoaXMubWV0YVxuICAgIH07XG4gICAgY29uc3QgYWRkU2lnbmFsUHJvcGVydHkgPSAob2JqZWN0KSA9PiB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBcInNpZ25hbFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuI2Fib3J0U2lnbmFsQ29uc3VtZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGFkZFNpZ25hbFByb3BlcnR5KHF1ZXJ5Rm5Db250ZXh0KTtcbiAgICBjb25zdCBmZXRjaEZuID0gKCkgPT4ge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnF1ZXJ5Rm4gPT09IHNraXBUb2tlbikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBgQXR0ZW1wdGVkIHRvIGludm9rZSBxdWVyeUZuIHdoZW4gc2V0IHRvIHNraXBUb2tlbi4gVGhpcyBpcyBsaWtlbHkgYSBjb25maWd1cmF0aW9uIGVycm9yLiBRdWVyeSBoYXNoOiAnJHt0aGlzLm9wdGlvbnMucXVlcnlIYXNofSdgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucXVlcnlGbiB8fCB0aGlzLm9wdGlvbnMucXVlcnlGbiA9PT0gc2tpcFRva2VuKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgICBuZXcgRXJyb3IoYE1pc3NpbmcgcXVlcnlGbjogJyR7dGhpcy5vcHRpb25zLnF1ZXJ5SGFzaH0nYClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2Fib3J0U2lnbmFsQ29uc3VtZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVyc2lzdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucGVyc2lzdGVyKFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5xdWVyeUZuLFxuICAgICAgICAgIHF1ZXJ5Rm5Db250ZXh0LFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucXVlcnlGbihcbiAgICAgICAgcXVlcnlGbkNvbnRleHRcbiAgICAgICk7XG4gICAgfTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgcXVlcnlLZXk6IHRoaXMucXVlcnlLZXksXG4gICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgIGZldGNoRm5cbiAgICB9O1xuICAgIGFkZFNpZ25hbFByb3BlcnR5KGNvbnRleHQpO1xuICAgIHRoaXMub3B0aW9ucy5iZWhhdmlvcj8ub25GZXRjaChcbiAgICAgIGNvbnRleHQsXG4gICAgICB0aGlzXG4gICAgKTtcbiAgICB0aGlzLiNyZXZlcnRTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHRoaXMuc3RhdGUuZmV0Y2hTdGF0dXMgPT09IFwiaWRsZVwiIHx8IHRoaXMuc3RhdGUuZmV0Y2hNZXRhICE9PSBjb250ZXh0LmZldGNoT3B0aW9ucz8ubWV0YSkge1xuICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcImZldGNoXCIsIG1ldGE6IGNvbnRleHQuZmV0Y2hPcHRpb25zPy5tZXRhIH0pO1xuICAgIH1cbiAgICBjb25zdCBvbkVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICBpZiAoIShpc0NhbmNlbGxlZEVycm9yKGVycm9yKSAmJiBlcnJvci5zaWxlbnQpKSB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQ2FuY2VsbGVkRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHRoaXMuI2NhY2hlLmNvbmZpZy5vbkVycm9yPy4oXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgICB0aGlzLiNjYWNoZS5jb25maWcub25TZXR0bGVkPy4oXG4gICAgICAgICAgdGhpcy5zdGF0ZS5kYXRhLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5pc0ZldGNoaW5nT3B0aW1pc3RpYykge1xuICAgICAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNGZXRjaGluZ09wdGltaXN0aWMgPSBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3JldHJ5ZXIgPSBjcmVhdGVSZXRyeWVyKHtcbiAgICAgIGZuOiBjb250ZXh0LmZldGNoRm4sXG4gICAgICBhYm9ydDogYWJvcnRDb250cm9sbGVyLmFib3J0LmJpbmQoYWJvcnRDb250cm9sbGVyKSxcbiAgICAgIG9uU3VjY2VzczogKGRhdGEpID0+IHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIGBRdWVyeSBkYXRhIGNhbm5vdCBiZSB1bmRlZmluZWQuIFBsZWFzZSBtYWtlIHN1cmUgdG8gcmV0dXJuIGEgdmFsdWUgb3RoZXIgdGhhbiB1bmRlZmluZWQgZnJvbSB5b3VyIHF1ZXJ5IGZ1bmN0aW9uLiBBZmZlY3RlZCBxdWVyeSBrZXk6ICR7dGhpcy5xdWVyeUhhc2h9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb25FcnJvcihuZXcgRXJyb3IoYCR7dGhpcy5xdWVyeUhhc2h9IGRhdGEgaXMgdW5kZWZpbmVkYCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldERhdGEoZGF0YSk7XG4gICAgICAgIHRoaXMuI2NhY2hlLmNvbmZpZy5vblN1Y2Nlc3M/LihkYXRhLCB0aGlzKTtcbiAgICAgICAgdGhpcy4jY2FjaGUuY29uZmlnLm9uU2V0dGxlZD8uKFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgdGhpcy5zdGF0ZS5lcnJvcixcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICAgIGlmICghdGhpcy5pc0ZldGNoaW5nT3B0aW1pc3RpYykge1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGVHYygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNGZXRjaGluZ09wdGltaXN0aWMgPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yLFxuICAgICAgb25GYWlsOiAoZmFpbHVyZUNvdW50LCBlcnJvcikgPT4ge1xuICAgICAgICB0aGlzLiNkaXNwYXRjaCh7IHR5cGU6IFwiZmFpbGVkXCIsIGZhaWx1cmVDb3VudCwgZXJyb3IgfSk7XG4gICAgICB9LFxuICAgICAgb25QYXVzZTogKCkgPT4ge1xuICAgICAgICB0aGlzLiNkaXNwYXRjaCh7IHR5cGU6IFwicGF1c2VcIiB9KTtcbiAgICAgIH0sXG4gICAgICBvbkNvbnRpbnVlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoKHsgdHlwZTogXCJjb250aW51ZVwiIH0pO1xuICAgICAgfSxcbiAgICAgIHJldHJ5OiBjb250ZXh0Lm9wdGlvbnMucmV0cnksXG4gICAgICByZXRyeURlbGF5OiBjb250ZXh0Lm9wdGlvbnMucmV0cnlEZWxheSxcbiAgICAgIG5ldHdvcmtNb2RlOiBjb250ZXh0Lm9wdGlvbnMubmV0d29ya01vZGUsXG4gICAgICBjYW5SdW46ICgpID0+IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy4jcmV0cnllci5zdGFydCgpO1xuICB9XG4gICNkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBjb25zdCByZWR1Y2VyID0gKHN0YXRlKSA9PiB7XG4gICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBmZXRjaEZhaWx1cmVDb3VudDogYWN0aW9uLmZhaWx1cmVDb3VudCxcbiAgICAgICAgICAgIGZldGNoRmFpbHVyZVJlYXNvbjogYWN0aW9uLmVycm9yXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInBhdXNlXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgZmV0Y2hTdGF0dXM6IFwicGF1c2VkXCJcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiY29udGludWVcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBmZXRjaFN0YXR1czogXCJmZXRjaGluZ1wiXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImZldGNoXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgLi4uZmV0Y2hTdGF0ZShzdGF0ZS5kYXRhLCB0aGlzLm9wdGlvbnMpLFxuICAgICAgICAgICAgZmV0Y2hNZXRhOiBhY3Rpb24ubWV0YSA/PyBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBkYXRhOiBhY3Rpb24uZGF0YSxcbiAgICAgICAgICAgIGRhdGFVcGRhdGVDb3VudDogc3RhdGUuZGF0YVVwZGF0ZUNvdW50ICsgMSxcbiAgICAgICAgICAgIGRhdGFVcGRhdGVkQXQ6IGFjdGlvbi5kYXRhVXBkYXRlZEF0ID8/IERhdGUubm93KCksXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIGlzSW52YWxpZGF0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgIC4uLiFhY3Rpb24ubWFudWFsICYmIHtcbiAgICAgICAgICAgICAgZmV0Y2hTdGF0dXM6IFwiaWRsZVwiLFxuICAgICAgICAgICAgICBmZXRjaEZhaWx1cmVDb3VudDogMCxcbiAgICAgICAgICAgICAgZmV0Y2hGYWlsdXJlUmVhc29uOiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBhY3Rpb24uZXJyb3I7XG4gICAgICAgICAgaWYgKGlzQ2FuY2VsbGVkRXJyb3IoZXJyb3IpICYmIGVycm9yLnJldmVydCAmJiB0aGlzLiNyZXZlcnRTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4udGhpcy4jcmV2ZXJ0U3RhdGUsIGZldGNoU3RhdHVzOiBcImlkbGVcIiB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGVycm9yVXBkYXRlQ291bnQ6IHN0YXRlLmVycm9yVXBkYXRlQ291bnQgKyAxLFxuICAgICAgICAgICAgZXJyb3JVcGRhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgICBmZXRjaEZhaWx1cmVDb3VudDogc3RhdGUuZmV0Y2hGYWlsdXJlQ291bnQgKyAxLFxuICAgICAgICAgICAgZmV0Y2hGYWlsdXJlUmVhc29uOiBlcnJvcixcbiAgICAgICAgICAgIGZldGNoU3RhdHVzOiBcImlkbGVcIixcbiAgICAgICAgICAgIHN0YXR1czogXCJlcnJvclwiXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImludmFsaWRhdGVcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBpc0ludmFsaWRhdGVkOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInNldFN0YXRlXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgLi4uYWN0aW9uLnN0YXRlXG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc3RhdGUgPSByZWR1Y2VyKHRoaXMuc3RhdGUpO1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5vYnNlcnZlcnMuZm9yRWFjaCgob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgb2JzZXJ2ZXIub25RdWVyeVVwZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLiNjYWNoZS5ub3RpZnkoeyBxdWVyeTogdGhpcywgdHlwZTogXCJ1cGRhdGVkXCIsIGFjdGlvbiB9KTtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZldGNoU3RhdGUoZGF0YSwgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGZldGNoRmFpbHVyZUNvdW50OiAwLFxuICAgIGZldGNoRmFpbHVyZVJlYXNvbjogbnVsbCxcbiAgICBmZXRjaFN0YXR1czogY2FuRmV0Y2gob3B0aW9ucy5uZXR3b3JrTW9kZSkgPyBcImZldGNoaW5nXCIgOiBcInBhdXNlZFwiLFxuICAgIC4uLmRhdGEgPT09IHZvaWQgMCAmJiB7XG4gICAgICBlcnJvcjogbnVsbCxcbiAgICAgIHN0YXR1czogXCJwZW5kaW5nXCJcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0U3RhdGUob3B0aW9ucykge1xuICBjb25zdCBkYXRhID0gdHlwZW9mIG9wdGlvbnMuaW5pdGlhbERhdGEgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMuaW5pdGlhbERhdGEoKSA6IG9wdGlvbnMuaW5pdGlhbERhdGE7XG4gIGNvbnN0IGhhc0RhdGEgPSBkYXRhICE9PSB2b2lkIDA7XG4gIGNvbnN0IGluaXRpYWxEYXRhVXBkYXRlZEF0ID0gaGFzRGF0YSA/IHR5cGVvZiBvcHRpb25zLmluaXRpYWxEYXRhVXBkYXRlZEF0ID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLmluaXRpYWxEYXRhVXBkYXRlZEF0KCkgOiBvcHRpb25zLmluaXRpYWxEYXRhVXBkYXRlZEF0IDogMDtcbiAgcmV0dXJuIHtcbiAgICBkYXRhLFxuICAgIGRhdGFVcGRhdGVDb3VudDogMCxcbiAgICBkYXRhVXBkYXRlZEF0OiBoYXNEYXRhID8gaW5pdGlhbERhdGFVcGRhdGVkQXQgPz8gRGF0ZS5ub3coKSA6IDAsXG4gICAgZXJyb3I6IG51bGwsXG4gICAgZXJyb3JVcGRhdGVDb3VudDogMCxcbiAgICBlcnJvclVwZGF0ZWRBdDogMCxcbiAgICBmZXRjaEZhaWx1cmVDb3VudDogMCxcbiAgICBmZXRjaEZhaWx1cmVSZWFzb246IG51bGwsXG4gICAgZmV0Y2hNZXRhOiBudWxsLFxuICAgIGlzSW52YWxpZGF0ZWQ6IGZhbHNlLFxuICAgIHN0YXR1czogaGFzRGF0YSA/IFwic3VjY2Vzc1wiIDogXCJwZW5kaW5nXCIsXG4gICAgZmV0Y2hTdGF0dXM6IFwiaWRsZVwiXG4gIH07XG59XG5leHBvcnQge1xuICBRdWVyeSxcbiAgZmV0Y2hTdGF0ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/query.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/queryCache.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/queryCache.js ***!
  \*********************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryCache: function() { return /* binding */ QueryCache; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _query_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./query.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/query.js\");\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n// src/queryCache.ts\n\n\n\n\nvar QueryCache = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#queries = /* @__PURE__ */ new Map();\n  }\n  #queries;\n  build(client, options, state) {\n    const queryKey = options.queryKey;\n    const queryHash = options.queryHash ?? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashQueryKeyByOptions)(queryKey, options);\n    let query = this.get(queryHash);\n    if (!query) {\n      query = new _query_js__WEBPACK_IMPORTED_MODULE_2__.Query({\n        cache: this,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n    return query;\n  }\n  add(query) {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query);\n      this.notify({\n        type: \"added\",\n        query\n      });\n    }\n  }\n  remove(query) {\n    const queryInMap = this.#queries.get(query.queryHash);\n    if (queryInMap) {\n      query.destroy();\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash);\n      }\n      this.notify({ type: \"removed\", query });\n    }\n  }\n  clear() {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query);\n      });\n    });\n  }\n  get(queryHash) {\n    return this.#queries.get(queryHash);\n  }\n  getAll() {\n    return [...this.#queries.values()];\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (query) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.matchQuery)(defaultedFilters, query)\n    );\n  }\n  findAll(filters = {}) {\n    const queries = this.getAll();\n    return Object.keys(filters).length > 0 ? queries.filter((query) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.matchQuery)(filters, query)) : queries;\n  }\n  notify(event) {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  onFocus() {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus();\n      });\n    });\n  }\n  onOnline() {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline();\n      });\n    });\n  }\n};\n\n//# sourceMappingURL=queryCache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcXVlcnktY29yZUA1LjM2LjEvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9xdWVyeUNhY2hlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDK0Q7QUFDNUI7QUFDZ0I7QUFDRjtBQUNqRCwrQkFBK0IsMERBQVk7QUFDM0MseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdFQUFxQjtBQUNoRTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLElBQUksNERBQWE7QUFDakI7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLGlCQUFpQixxREFBVTtBQUMzQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsdUVBQXVFLHFEQUFVO0FBQ2pGO0FBQ0E7QUFDQSxJQUFJLDREQUFhO0FBQ2pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJLDREQUFhO0FBQ2pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJLDREQUFhO0FBQ2pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcXVlcnktY29yZUA1LjM2LjEvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9xdWVyeUNhY2hlLmpzPzNmNWEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3F1ZXJ5Q2FjaGUudHNcbmltcG9ydCB7IGhhc2hRdWVyeUtleUJ5T3B0aW9ucywgbWF0Y2hRdWVyeSB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBRdWVyeSB9IGZyb20gXCIuL3F1ZXJ5LmpzXCI7XG5pbXBvcnQgeyBub3RpZnlNYW5hZ2VyIH0gZnJvbSBcIi4vbm90aWZ5TWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgU3Vic2NyaWJhYmxlIH0gZnJvbSBcIi4vc3Vic2NyaWJhYmxlLmpzXCI7XG52YXIgUXVlcnlDYWNoZSA9IGNsYXNzIGV4dGVuZHMgU3Vic2NyaWJhYmxlIHtcbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuI3F1ZXJpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gICNxdWVyaWVzO1xuICBidWlsZChjbGllbnQsIG9wdGlvbnMsIHN0YXRlKSB7XG4gICAgY29uc3QgcXVlcnlLZXkgPSBvcHRpb25zLnF1ZXJ5S2V5O1xuICAgIGNvbnN0IHF1ZXJ5SGFzaCA9IG9wdGlvbnMucXVlcnlIYXNoID8/IGhhc2hRdWVyeUtleUJ5T3B0aW9ucyhxdWVyeUtleSwgb3B0aW9ucyk7XG4gICAgbGV0IHF1ZXJ5ID0gdGhpcy5nZXQocXVlcnlIYXNoKTtcbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICBxdWVyeSA9IG5ldyBRdWVyeSh7XG4gICAgICAgIGNhY2hlOiB0aGlzLFxuICAgICAgICBxdWVyeUtleSxcbiAgICAgICAgcXVlcnlIYXNoLFxuICAgICAgICBvcHRpb25zOiBjbGllbnQuZGVmYXVsdFF1ZXJ5T3B0aW9ucyhvcHRpb25zKSxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGRlZmF1bHRPcHRpb25zOiBjbGllbnQuZ2V0UXVlcnlEZWZhdWx0cyhxdWVyeUtleSlcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hZGQocXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cbiAgYWRkKHF1ZXJ5KSB7XG4gICAgaWYgKCF0aGlzLiNxdWVyaWVzLmhhcyhxdWVyeS5xdWVyeUhhc2gpKSB7XG4gICAgICB0aGlzLiNxdWVyaWVzLnNldChxdWVyeS5xdWVyeUhhc2gsIHF1ZXJ5KTtcbiAgICAgIHRoaXMubm90aWZ5KHtcbiAgICAgICAgdHlwZTogXCJhZGRlZFwiLFxuICAgICAgICBxdWVyeVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlbW92ZShxdWVyeSkge1xuICAgIGNvbnN0IHF1ZXJ5SW5NYXAgPSB0aGlzLiNxdWVyaWVzLmdldChxdWVyeS5xdWVyeUhhc2gpO1xuICAgIGlmIChxdWVyeUluTWFwKSB7XG4gICAgICBxdWVyeS5kZXN0cm95KCk7XG4gICAgICBpZiAocXVlcnlJbk1hcCA9PT0gcXVlcnkpIHtcbiAgICAgICAgdGhpcy4jcXVlcmllcy5kZWxldGUocXVlcnkucXVlcnlIYXNoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubm90aWZ5KHsgdHlwZTogXCJyZW1vdmVkXCIsIHF1ZXJ5IH0pO1xuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMuZ2V0QWxsKCkuZm9yRWFjaCgocXVlcnkpID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmUocXVlcnkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0KHF1ZXJ5SGFzaCkge1xuICAgIHJldHVybiB0aGlzLiNxdWVyaWVzLmdldChxdWVyeUhhc2gpO1xuICB9XG4gIGdldEFsbCgpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuI3F1ZXJpZXMudmFsdWVzKCldO1xuICB9XG4gIGZpbmQoZmlsdGVycykge1xuICAgIGNvbnN0IGRlZmF1bHRlZEZpbHRlcnMgPSB7IGV4YWN0OiB0cnVlLCAuLi5maWx0ZXJzIH07XG4gICAgcmV0dXJuIHRoaXMuZ2V0QWxsKCkuZmluZChcbiAgICAgIChxdWVyeSkgPT4gbWF0Y2hRdWVyeShkZWZhdWx0ZWRGaWx0ZXJzLCBxdWVyeSlcbiAgICApO1xuICB9XG4gIGZpbmRBbGwoZmlsdGVycyA9IHt9KSB7XG4gICAgY29uc3QgcXVlcmllcyA9IHRoaXMuZ2V0QWxsKCk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGZpbHRlcnMpLmxlbmd0aCA+IDAgPyBxdWVyaWVzLmZpbHRlcigocXVlcnkpID0+IG1hdGNoUXVlcnkoZmlsdGVycywgcXVlcnkpKSA6IHF1ZXJpZXM7XG4gIH1cbiAgbm90aWZ5KGV2ZW50KSB7XG4gICAgbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICBsaXN0ZW5lcihldmVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBvbkZvY3VzKCkge1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5nZXRBbGwoKS5mb3JFYWNoKChxdWVyeSkgPT4ge1xuICAgICAgICBxdWVyeS5vbkZvY3VzKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBvbk9ubGluZSgpIHtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMuZ2V0QWxsKCkuZm9yRWFjaCgocXVlcnkpID0+IHtcbiAgICAgICAgcXVlcnkub25PbmxpbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgUXVlcnlDYWNoZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5Q2FjaGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/queryCache.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/queryClient.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/queryClient.js ***!
  \**********************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryClient: function() { return /* binding */ QueryClient; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _queryCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./queryCache.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/queryCache.js\");\n/* harmony import */ var _mutationCache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mutationCache.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/mutationCache.js\");\n/* harmony import */ var _focusManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./focusManager.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/focusManager.js\");\n/* harmony import */ var _onlineManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./onlineManager.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/onlineManager.js\");\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _infiniteQueryBehavior_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./infiniteQueryBehavior.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js\");\n// src/queryClient.ts\n\n\n\n\n\n\n\nvar QueryClient = class {\n  #queryCache;\n  #mutationCache;\n  #defaultOptions;\n  #queryDefaults;\n  #mutationDefaults;\n  #mountCount;\n  #unsubscribeFocus;\n  #unsubscribeOnline;\n  constructor(config = {}) {\n    this.#queryCache = config.queryCache || new _queryCache_js__WEBPACK_IMPORTED_MODULE_0__.QueryCache();\n    this.#mutationCache = config.mutationCache || new _mutationCache_js__WEBPACK_IMPORTED_MODULE_1__.MutationCache();\n    this.#defaultOptions = config.defaultOptions || {};\n    this.#queryDefaults = /* @__PURE__ */ new Map();\n    this.#mutationDefaults = /* @__PURE__ */ new Map();\n    this.#mountCount = 0;\n  }\n  mount() {\n    this.#mountCount++;\n    if (this.#mountCount !== 1)\n      return;\n    this.#unsubscribeFocus = _focusManager_js__WEBPACK_IMPORTED_MODULE_2__.focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations();\n        this.#queryCache.onFocus();\n      }\n    });\n    this.#unsubscribeOnline = _onlineManager_js__WEBPACK_IMPORTED_MODULE_3__.onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations();\n        this.#queryCache.onOnline();\n      }\n    });\n  }\n  unmount() {\n    this.#mountCount--;\n    if (this.#mountCount !== 0)\n      return;\n    this.#unsubscribeFocus?.();\n    this.#unsubscribeFocus = void 0;\n    this.#unsubscribeOnline?.();\n    this.#unsubscribeOnline = void 0;\n  }\n  isFetching(filters) {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: \"fetching\" }).length;\n  }\n  isMutating(filters) {\n    return this.#mutationCache.findAll({ ...filters, status: \"pending\" }).length;\n  }\n  getQueryData(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(options.queryHash)?.state.data;\n  }\n  ensureQueryData(options) {\n    const cachedData = this.getQueryData(options.queryKey);\n    if (cachedData === void 0)\n      return this.fetchQuery(options);\n    else {\n      const defaultedOptions = this.defaultQueryOptions(options);\n      const query = this.#queryCache.build(this, defaultedOptions);\n      if (options.revalidateIfStale && query.isStaleByTime(defaultedOptions.staleTime)) {\n        void this.prefetchQuery(defaultedOptions);\n      }\n      return Promise.resolve(cachedData);\n    }\n  }\n  getQueriesData(filters) {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n  setQueryData(queryKey, updater, options) {\n    const defaultedOptions = this.defaultQueryOptions({ queryKey });\n    const query = this.#queryCache.get(\n      defaultedOptions.queryHash\n    );\n    const prevData = query?.state.data;\n    const data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.functionalUpdate)(updater, prevData);\n    if (data === void 0) {\n      return void 0;\n    }\n    return this.#queryCache.build(this, defaultedOptions).setData(data, { ...options, manual: true });\n  }\n  setQueriesData(filters, updater, options) {\n    return _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map(({ queryKey }) => [\n        queryKey,\n        this.setQueryData(queryKey, updater, options)\n      ])\n    );\n  }\n  getQueryState(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(options.queryHash)?.state;\n  }\n  removeQueries(filters) {\n    const queryCache = this.#queryCache;\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query);\n      });\n    });\n  }\n  resetQueries(filters, options) {\n    const queryCache = this.#queryCache;\n    const refetchFilters = {\n      type: \"active\",\n      ...filters\n    };\n    return _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n  cancelQueries(filters = {}, cancelOptions = {}) {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions };\n    const promises = _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions))\n    );\n    return Promise.all(promises).then(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop).catch(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n  }\n  invalidateQueries(filters = {}, options = {}) {\n    return _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate();\n      });\n      if (filters.refetchType === \"none\") {\n        return Promise.resolve();\n      }\n      const refetchFilters = {\n        ...filters,\n        type: filters.refetchType ?? filters.type ?? \"active\"\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n  refetchQueries(filters = {}, options) {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options?.cancelRefetch ?? true\n    };\n    const promises = _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(\n      () => this.#queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {\n        let promise = query.fetch(void 0, fetchOptions);\n        if (!fetchOptions.throwOnError) {\n          promise = promise.catch(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n        }\n        return query.state.fetchStatus === \"paused\" ? Promise.resolve() : promise;\n      })\n    );\n    return Promise.all(promises).then(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n  }\n  fetchQuery(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    if (defaultedOptions.retry === void 0) {\n      defaultedOptions.retry = false;\n    }\n    const query = this.#queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n  prefetchQuery(options) {\n    return this.fetchQuery(options).then(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop).catch(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n  }\n  fetchInfiniteQuery(options) {\n    options.behavior = (0,_infiniteQueryBehavior_js__WEBPACK_IMPORTED_MODULE_6__.infiniteQueryBehavior)(options.pages);\n    return this.fetchQuery(options);\n  }\n  prefetchInfiniteQuery(options) {\n    return this.fetchInfiniteQuery(options).then(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop).catch(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n  }\n  resumePausedMutations() {\n    if (_onlineManager_js__WEBPACK_IMPORTED_MODULE_3__.onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations();\n    }\n    return Promise.resolve();\n  }\n  getQueryCache() {\n    return this.#queryCache;\n  }\n  getMutationCache() {\n    return this.#mutationCache;\n  }\n  getDefaultOptions() {\n    return this.#defaultOptions;\n  }\n  setDefaultOptions(options) {\n    this.#defaultOptions = options;\n  }\n  setQueryDefaults(queryKey, options) {\n    this.#queryDefaults.set((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.hashKey)(queryKey), {\n      queryKey,\n      defaultOptions: options\n    });\n  }\n  getQueryDefaults(queryKey) {\n    const defaults = [...this.#queryDefaults.values()];\n    let result = {};\n    defaults.forEach((queryDefault) => {\n      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.partialMatchKey)(queryKey, queryDefault.queryKey)) {\n        result = { ...result, ...queryDefault.defaultOptions };\n      }\n    });\n    return result;\n  }\n  setMutationDefaults(mutationKey, options) {\n    this.#mutationDefaults.set((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.hashKey)(mutationKey), {\n      mutationKey,\n      defaultOptions: options\n    });\n  }\n  getMutationDefaults(mutationKey) {\n    const defaults = [...this.#mutationDefaults.values()];\n    let result = {};\n    defaults.forEach((queryDefault) => {\n      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.partialMatchKey)(mutationKey, queryDefault.mutationKey)) {\n        result = { ...result, ...queryDefault.defaultOptions };\n      }\n    });\n    return result;\n  }\n  defaultQueryOptions(options) {\n    if (options._defaulted) {\n      return options;\n    }\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.hashQueryKeyByOptions)(\n        defaultedOptions.queryKey,\n        defaultedOptions\n      );\n    }\n    if (defaultedOptions.refetchOnReconnect === void 0) {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== \"always\";\n    }\n    if (defaultedOptions.throwOnError === void 0) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense;\n    }\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = \"offlineFirst\";\n    }\n    if (defaultedOptions.enabled !== true && defaultedOptions.queryFn === _utils_js__WEBPACK_IMPORTED_MODULE_4__.skipToken) {\n      defaultedOptions.enabled = false;\n    }\n    return defaultedOptions;\n  }\n  defaultMutationOptions(options) {\n    if (options?._defaulted) {\n      return options;\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n  clear() {\n    this.#queryCache.clear();\n    this.#mutationCache.clear();\n  }\n};\n\n//# sourceMappingURL=queryClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcXVlcnktY29yZUA1LjM2LjEvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9xdWVyeUNsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBUW9CO0FBQ3lCO0FBQ007QUFDRjtBQUNFO0FBQ0E7QUFDZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLGdEQUFnRCxzREFBVTtBQUMxRCxzREFBc0QsNERBQWE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBEQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhCQUE4Qiw0REFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFDQUFxQztBQUMzRTtBQUNBO0FBQ0EseUNBQXlDLCtCQUErQjtBQUN4RTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdEQUF3RCxVQUFVO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJEQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsMEJBQTBCO0FBQ3BHO0FBQ0E7QUFDQSxXQUFXLDREQUFhO0FBQ3hCLHFEQUFxRCxVQUFVO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0REFBYTtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNERBQWE7QUFDeEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQscUNBQXFDO0FBQ3JDLHFCQUFxQiw0REFBYTtBQUNsQztBQUNBO0FBQ0Esc0NBQXNDLDJDQUFJLFFBQVEsMkNBQUk7QUFDdEQ7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QyxXQUFXLDREQUFhO0FBQ3hCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMkNBQUk7QUFDdEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNDQUFzQywyQ0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywyQ0FBSSxRQUFRLDJDQUFJO0FBQ3pEO0FBQ0E7QUFDQSx1QkFBdUIsZ0ZBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwyQ0FBSSxRQUFRLDJDQUFJO0FBQ2pFO0FBQ0E7QUFDQSxRQUFRLDREQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0RBQU87QUFDbkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwREFBZTtBQUN6QixtQkFBbUI7QUFDbkI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtEQUFPO0FBQ3RDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMERBQWU7QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdFQUFxQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxnREFBUztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRhbnN0YWNrK3F1ZXJ5LWNvcmVANS4zNi4xL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcXVlcnlDbGllbnQuanM/NTQ1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcXVlcnlDbGllbnQudHNcbmltcG9ydCB7XG4gIGZ1bmN0aW9uYWxVcGRhdGUsXG4gIGhhc2hLZXksXG4gIGhhc2hRdWVyeUtleUJ5T3B0aW9ucyxcbiAgbm9vcCxcbiAgcGFydGlhbE1hdGNoS2V5LFxuICBza2lwVG9rZW5cbn0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IFF1ZXJ5Q2FjaGUgfSBmcm9tIFwiLi9xdWVyeUNhY2hlLmpzXCI7XG5pbXBvcnQgeyBNdXRhdGlvbkNhY2hlIH0gZnJvbSBcIi4vbXV0YXRpb25DYWNoZS5qc1wiO1xuaW1wb3J0IHsgZm9jdXNNYW5hZ2VyIH0gZnJvbSBcIi4vZm9jdXNNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBvbmxpbmVNYW5hZ2VyIH0gZnJvbSBcIi4vb25saW5lTWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgbm90aWZ5TWFuYWdlciB9IGZyb20gXCIuL25vdGlmeU1hbmFnZXIuanNcIjtcbmltcG9ydCB7IGluZmluaXRlUXVlcnlCZWhhdmlvciB9IGZyb20gXCIuL2luZmluaXRlUXVlcnlCZWhhdmlvci5qc1wiO1xudmFyIFF1ZXJ5Q2xpZW50ID0gY2xhc3Mge1xuICAjcXVlcnlDYWNoZTtcbiAgI211dGF0aW9uQ2FjaGU7XG4gICNkZWZhdWx0T3B0aW9ucztcbiAgI3F1ZXJ5RGVmYXVsdHM7XG4gICNtdXRhdGlvbkRlZmF1bHRzO1xuICAjbW91bnRDb3VudDtcbiAgI3Vuc3Vic2NyaWJlRm9jdXM7XG4gICN1bnN1YnNjcmliZU9ubGluZTtcbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICB0aGlzLiNxdWVyeUNhY2hlID0gY29uZmlnLnF1ZXJ5Q2FjaGUgfHwgbmV3IFF1ZXJ5Q2FjaGUoKTtcbiAgICB0aGlzLiNtdXRhdGlvbkNhY2hlID0gY29uZmlnLm11dGF0aW9uQ2FjaGUgfHwgbmV3IE11dGF0aW9uQ2FjaGUoKTtcbiAgICB0aGlzLiNkZWZhdWx0T3B0aW9ucyA9IGNvbmZpZy5kZWZhdWx0T3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLiNxdWVyeURlZmF1bHRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLiNtdXRhdGlvbkRlZmF1bHRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLiNtb3VudENvdW50ID0gMDtcbiAgfVxuICBtb3VudCgpIHtcbiAgICB0aGlzLiNtb3VudENvdW50Kys7XG4gICAgaWYgKHRoaXMuI21vdW50Q291bnQgIT09IDEpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy4jdW5zdWJzY3JpYmVGb2N1cyA9IGZvY3VzTWFuYWdlci5zdWJzY3JpYmUoYXN5bmMgKGZvY3VzZWQpID0+IHtcbiAgICAgIGlmIChmb2N1c2VkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVzdW1lUGF1c2VkTXV0YXRpb25zKCk7XG4gICAgICAgIHRoaXMuI3F1ZXJ5Q2FjaGUub25Gb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuI3Vuc3Vic2NyaWJlT25saW5lID0gb25saW5lTWFuYWdlci5zdWJzY3JpYmUoYXN5bmMgKG9ubGluZSkgPT4ge1xuICAgICAgaWYgKG9ubGluZSkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlc3VtZVBhdXNlZE11dGF0aW9ucygpO1xuICAgICAgICB0aGlzLiNxdWVyeUNhY2hlLm9uT25saW5lKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdW5tb3VudCgpIHtcbiAgICB0aGlzLiNtb3VudENvdW50LS07XG4gICAgaWYgKHRoaXMuI21vdW50Q291bnQgIT09IDApXG4gICAgICByZXR1cm47XG4gICAgdGhpcy4jdW5zdWJzY3JpYmVGb2N1cz8uKCk7XG4gICAgdGhpcy4jdW5zdWJzY3JpYmVGb2N1cyA9IHZvaWQgMDtcbiAgICB0aGlzLiN1bnN1YnNjcmliZU9ubGluZT8uKCk7XG4gICAgdGhpcy4jdW5zdWJzY3JpYmVPbmxpbmUgPSB2b2lkIDA7XG4gIH1cbiAgaXNGZXRjaGluZyhmaWx0ZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMuI3F1ZXJ5Q2FjaGUuZmluZEFsbCh7IC4uLmZpbHRlcnMsIGZldGNoU3RhdHVzOiBcImZldGNoaW5nXCIgfSkubGVuZ3RoO1xuICB9XG4gIGlzTXV0YXRpbmcoZmlsdGVycykge1xuICAgIHJldHVybiB0aGlzLiNtdXRhdGlvbkNhY2hlLmZpbmRBbGwoeyAuLi5maWx0ZXJzLCBzdGF0dXM6IFwicGVuZGluZ1wiIH0pLmxlbmd0aDtcbiAgfVxuICBnZXRRdWVyeURhdGEocXVlcnlLZXkpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5kZWZhdWx0UXVlcnlPcHRpb25zKHsgcXVlcnlLZXkgfSk7XG4gICAgcmV0dXJuIHRoaXMuI3F1ZXJ5Q2FjaGUuZ2V0KG9wdGlvbnMucXVlcnlIYXNoKT8uc3RhdGUuZGF0YTtcbiAgfVxuICBlbnN1cmVRdWVyeURhdGEob3B0aW9ucykge1xuICAgIGNvbnN0IGNhY2hlZERhdGEgPSB0aGlzLmdldFF1ZXJ5RGF0YShvcHRpb25zLnF1ZXJ5S2V5KTtcbiAgICBpZiAoY2FjaGVkRGF0YSA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hRdWVyeShvcHRpb25zKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRlZE9wdGlvbnMgPSB0aGlzLmRlZmF1bHRRdWVyeU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICBjb25zdCBxdWVyeSA9IHRoaXMuI3F1ZXJ5Q2FjaGUuYnVpbGQodGhpcywgZGVmYXVsdGVkT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5yZXZhbGlkYXRlSWZTdGFsZSAmJiBxdWVyeS5pc1N0YWxlQnlUaW1lKGRlZmF1bHRlZE9wdGlvbnMuc3RhbGVUaW1lKSkge1xuICAgICAgICB2b2lkIHRoaXMucHJlZmV0Y2hRdWVyeShkZWZhdWx0ZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGVkRGF0YSk7XG4gICAgfVxuICB9XG4gIGdldFF1ZXJpZXNEYXRhKGZpbHRlcnMpIHtcbiAgICByZXR1cm4gdGhpcy4jcXVlcnlDYWNoZS5maW5kQWxsKGZpbHRlcnMpLm1hcCgoeyBxdWVyeUtleSwgc3RhdGUgfSkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IHN0YXRlLmRhdGE7XG4gICAgICByZXR1cm4gW3F1ZXJ5S2V5LCBkYXRhXTtcbiAgICB9KTtcbiAgfVxuICBzZXRRdWVyeURhdGEocXVlcnlLZXksIHVwZGF0ZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0ZWRPcHRpb25zID0gdGhpcy5kZWZhdWx0UXVlcnlPcHRpb25zKHsgcXVlcnlLZXkgfSk7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLiNxdWVyeUNhY2hlLmdldChcbiAgICAgIGRlZmF1bHRlZE9wdGlvbnMucXVlcnlIYXNoXG4gICAgKTtcbiAgICBjb25zdCBwcmV2RGF0YSA9IHF1ZXJ5Py5zdGF0ZS5kYXRhO1xuICAgIGNvbnN0IGRhdGEgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIHByZXZEYXRhKTtcbiAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jcXVlcnlDYWNoZS5idWlsZCh0aGlzLCBkZWZhdWx0ZWRPcHRpb25zKS5zZXREYXRhKGRhdGEsIHsgLi4ub3B0aW9ucywgbWFudWFsOiB0cnVlIH0pO1xuICB9XG4gIHNldFF1ZXJpZXNEYXRhKGZpbHRlcnMsIHVwZGF0ZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbm90aWZ5TWFuYWdlci5iYXRjaChcbiAgICAgICgpID0+IHRoaXMuI3F1ZXJ5Q2FjaGUuZmluZEFsbChmaWx0ZXJzKS5tYXAoKHsgcXVlcnlLZXkgfSkgPT4gW1xuICAgICAgICBxdWVyeUtleSxcbiAgICAgICAgdGhpcy5zZXRRdWVyeURhdGEocXVlcnlLZXksIHVwZGF0ZXIsIG9wdGlvbnMpXG4gICAgICBdKVxuICAgICk7XG4gIH1cbiAgZ2V0UXVlcnlTdGF0ZShxdWVyeUtleSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmRlZmF1bHRRdWVyeU9wdGlvbnMoeyBxdWVyeUtleSB9KTtcbiAgICByZXR1cm4gdGhpcy4jcXVlcnlDYWNoZS5nZXQob3B0aW9ucy5xdWVyeUhhc2gpPy5zdGF0ZTtcbiAgfVxuICByZW1vdmVRdWVyaWVzKGZpbHRlcnMpIHtcbiAgICBjb25zdCBxdWVyeUNhY2hlID0gdGhpcy4jcXVlcnlDYWNoZTtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHF1ZXJ5Q2FjaGUuZmluZEFsbChmaWx0ZXJzKS5mb3JFYWNoKChxdWVyeSkgPT4ge1xuICAgICAgICBxdWVyeUNhY2hlLnJlbW92ZShxdWVyeSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXNldFF1ZXJpZXMoZmlsdGVycywgb3B0aW9ucykge1xuICAgIGNvbnN0IHF1ZXJ5Q2FjaGUgPSB0aGlzLiNxdWVyeUNhY2hlO1xuICAgIGNvbnN0IHJlZmV0Y2hGaWx0ZXJzID0ge1xuICAgICAgdHlwZTogXCJhY3RpdmVcIixcbiAgICAgIC4uLmZpbHRlcnNcbiAgICB9O1xuICAgIHJldHVybiBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHF1ZXJ5Q2FjaGUuZmluZEFsbChmaWx0ZXJzKS5mb3JFYWNoKChxdWVyeSkgPT4ge1xuICAgICAgICBxdWVyeS5yZXNldCgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5yZWZldGNoUXVlcmllcyhyZWZldGNoRmlsdGVycywgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cbiAgY2FuY2VsUXVlcmllcyhmaWx0ZXJzID0ge30sIGNhbmNlbE9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGRlZmF1bHRlZENhbmNlbE9wdGlvbnMgPSB7IHJldmVydDogdHJ1ZSwgLi4uY2FuY2VsT3B0aW9ucyB9O1xuICAgIGNvbnN0IHByb21pc2VzID0gbm90aWZ5TWFuYWdlci5iYXRjaChcbiAgICAgICgpID0+IHRoaXMuI3F1ZXJ5Q2FjaGUuZmluZEFsbChmaWx0ZXJzKS5tYXAoKHF1ZXJ5KSA9PiBxdWVyeS5jYW5jZWwoZGVmYXVsdGVkQ2FuY2VsT3B0aW9ucykpXG4gICAgKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4obm9vcCkuY2F0Y2gobm9vcCk7XG4gIH1cbiAgaW52YWxpZGF0ZVF1ZXJpZXMoZmlsdGVycyA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLiNxdWVyeUNhY2hlLmZpbmRBbGwoZmlsdGVycykuZm9yRWFjaCgocXVlcnkpID0+IHtcbiAgICAgICAgcXVlcnkuaW52YWxpZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBpZiAoZmlsdGVycy5yZWZldGNoVHlwZSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVmZXRjaEZpbHRlcnMgPSB7XG4gICAgICAgIC4uLmZpbHRlcnMsXG4gICAgICAgIHR5cGU6IGZpbHRlcnMucmVmZXRjaFR5cGUgPz8gZmlsdGVycy50eXBlID8/IFwiYWN0aXZlXCJcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5yZWZldGNoUXVlcmllcyhyZWZldGNoRmlsdGVycywgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cbiAgcmVmZXRjaFF1ZXJpZXMoZmlsdGVycyA9IHt9LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZmV0Y2hPcHRpb25zID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGNhbmNlbFJlZmV0Y2g6IG9wdGlvbnM/LmNhbmNlbFJlZmV0Y2ggPz8gdHJ1ZVxuICAgIH07XG4gICAgY29uc3QgcHJvbWlzZXMgPSBub3RpZnlNYW5hZ2VyLmJhdGNoKFxuICAgICAgKCkgPT4gdGhpcy4jcXVlcnlDYWNoZS5maW5kQWxsKGZpbHRlcnMpLmZpbHRlcigocXVlcnkpID0+ICFxdWVyeS5pc0Rpc2FibGVkKCkpLm1hcCgocXVlcnkpID0+IHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBxdWVyeS5mZXRjaCh2b2lkIDAsIGZldGNoT3B0aW9ucyk7XG4gICAgICAgIGlmICghZmV0Y2hPcHRpb25zLnRocm93T25FcnJvcikge1xuICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLmNhdGNoKG5vb3ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWVyeS5zdGF0ZS5mZXRjaFN0YXR1cyA9PT0gXCJwYXVzZWRcIiA/IFByb21pc2UucmVzb2x2ZSgpIDogcHJvbWlzZTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4obm9vcCk7XG4gIH1cbiAgZmV0Y2hRdWVyeShvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmYXVsdGVkT3B0aW9ucyA9IHRoaXMuZGVmYXVsdFF1ZXJ5T3B0aW9ucyhvcHRpb25zKTtcbiAgICBpZiAoZGVmYXVsdGVkT3B0aW9ucy5yZXRyeSA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWZhdWx0ZWRPcHRpb25zLnJldHJ5ID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy4jcXVlcnlDYWNoZS5idWlsZCh0aGlzLCBkZWZhdWx0ZWRPcHRpb25zKTtcbiAgICByZXR1cm4gcXVlcnkuaXNTdGFsZUJ5VGltZShkZWZhdWx0ZWRPcHRpb25zLnN0YWxlVGltZSkgPyBxdWVyeS5mZXRjaChkZWZhdWx0ZWRPcHRpb25zKSA6IFByb21pc2UucmVzb2x2ZShxdWVyeS5zdGF0ZS5kYXRhKTtcbiAgfVxuICBwcmVmZXRjaFF1ZXJ5KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaFF1ZXJ5KG9wdGlvbnMpLnRoZW4obm9vcCkuY2F0Y2gobm9vcCk7XG4gIH1cbiAgZmV0Y2hJbmZpbml0ZVF1ZXJ5KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLmJlaGF2aW9yID0gaW5maW5pdGVRdWVyeUJlaGF2aW9yKG9wdGlvbnMucGFnZXMpO1xuICAgIHJldHVybiB0aGlzLmZldGNoUXVlcnkob3B0aW9ucyk7XG4gIH1cbiAgcHJlZmV0Y2hJbmZpbml0ZVF1ZXJ5KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEluZmluaXRlUXVlcnkob3B0aW9ucykudGhlbihub29wKS5jYXRjaChub29wKTtcbiAgfVxuICByZXN1bWVQYXVzZWRNdXRhdGlvbnMoKSB7XG4gICAgaWYgKG9ubGluZU1hbmFnZXIuaXNPbmxpbmUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuI211dGF0aW9uQ2FjaGUucmVzdW1lUGF1c2VkTXV0YXRpb25zKCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBnZXRRdWVyeUNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLiNxdWVyeUNhY2hlO1xuICB9XG4gIGdldE11dGF0aW9uQ2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI211dGF0aW9uQ2FjaGU7XG4gIH1cbiAgZ2V0RGVmYXVsdE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RlZmF1bHRPcHRpb25zO1xuICB9XG4gIHNldERlZmF1bHRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLiNkZWZhdWx0T3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgc2V0UXVlcnlEZWZhdWx0cyhxdWVyeUtleSwgb3B0aW9ucykge1xuICAgIHRoaXMuI3F1ZXJ5RGVmYXVsdHMuc2V0KGhhc2hLZXkocXVlcnlLZXkpLCB7XG4gICAgICBxdWVyeUtleSxcbiAgICAgIGRlZmF1bHRPcHRpb25zOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgZ2V0UXVlcnlEZWZhdWx0cyhxdWVyeUtleSkge1xuICAgIGNvbnN0IGRlZmF1bHRzID0gWy4uLnRoaXMuI3F1ZXJ5RGVmYXVsdHMudmFsdWVzKCldO1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBkZWZhdWx0cy5mb3JFYWNoKChxdWVyeURlZmF1bHQpID0+IHtcbiAgICAgIGlmIChwYXJ0aWFsTWF0Y2hLZXkocXVlcnlLZXksIHF1ZXJ5RGVmYXVsdC5xdWVyeUtleSkpIHtcbiAgICAgICAgcmVzdWx0ID0geyAuLi5yZXN1bHQsIC4uLnF1ZXJ5RGVmYXVsdC5kZWZhdWx0T3B0aW9ucyB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc2V0TXV0YXRpb25EZWZhdWx0cyhtdXRhdGlvbktleSwgb3B0aW9ucykge1xuICAgIHRoaXMuI211dGF0aW9uRGVmYXVsdHMuc2V0KGhhc2hLZXkobXV0YXRpb25LZXkpLCB7XG4gICAgICBtdXRhdGlvbktleSxcbiAgICAgIGRlZmF1bHRPcHRpb25zOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgZ2V0TXV0YXRpb25EZWZhdWx0cyhtdXRhdGlvbktleSkge1xuICAgIGNvbnN0IGRlZmF1bHRzID0gWy4uLnRoaXMuI211dGF0aW9uRGVmYXVsdHMudmFsdWVzKCldO1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBkZWZhdWx0cy5mb3JFYWNoKChxdWVyeURlZmF1bHQpID0+IHtcbiAgICAgIGlmIChwYXJ0aWFsTWF0Y2hLZXkobXV0YXRpb25LZXksIHF1ZXJ5RGVmYXVsdC5tdXRhdGlvbktleSkpIHtcbiAgICAgICAgcmVzdWx0ID0geyAuLi5yZXN1bHQsIC4uLnF1ZXJ5RGVmYXVsdC5kZWZhdWx0T3B0aW9ucyB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVmYXVsdFF1ZXJ5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuX2RlZmF1bHRlZCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRlZE9wdGlvbnMgPSB7XG4gICAgICAuLi50aGlzLiNkZWZhdWx0T3B0aW9ucy5xdWVyaWVzLFxuICAgICAgLi4udGhpcy5nZXRRdWVyeURlZmF1bHRzKG9wdGlvbnMucXVlcnlLZXkpLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIF9kZWZhdWx0ZWQ6IHRydWVcbiAgICB9O1xuICAgIGlmICghZGVmYXVsdGVkT3B0aW9ucy5xdWVyeUhhc2gpIHtcbiAgICAgIGRlZmF1bHRlZE9wdGlvbnMucXVlcnlIYXNoID0gaGFzaFF1ZXJ5S2V5QnlPcHRpb25zKFxuICAgICAgICBkZWZhdWx0ZWRPcHRpb25zLnF1ZXJ5S2V5LFxuICAgICAgICBkZWZhdWx0ZWRPcHRpb25zXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdGVkT3B0aW9ucy5yZWZldGNoT25SZWNvbm5lY3QgPT09IHZvaWQgMCkge1xuICAgICAgZGVmYXVsdGVkT3B0aW9ucy5yZWZldGNoT25SZWNvbm5lY3QgPSBkZWZhdWx0ZWRPcHRpb25zLm5ldHdvcmtNb2RlICE9PSBcImFsd2F5c1wiO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdGVkT3B0aW9ucy50aHJvd09uRXJyb3IgPT09IHZvaWQgMCkge1xuICAgICAgZGVmYXVsdGVkT3B0aW9ucy50aHJvd09uRXJyb3IgPSAhIWRlZmF1bHRlZE9wdGlvbnMuc3VzcGVuc2U7XG4gICAgfVxuICAgIGlmICghZGVmYXVsdGVkT3B0aW9ucy5uZXR3b3JrTW9kZSAmJiBkZWZhdWx0ZWRPcHRpb25zLnBlcnNpc3Rlcikge1xuICAgICAgZGVmYXVsdGVkT3B0aW9ucy5uZXR3b3JrTW9kZSA9IFwib2ZmbGluZUZpcnN0XCI7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0ZWRPcHRpb25zLmVuYWJsZWQgIT09IHRydWUgJiYgZGVmYXVsdGVkT3B0aW9ucy5xdWVyeUZuID09PSBza2lwVG9rZW4pIHtcbiAgICAgIGRlZmF1bHRlZE9wdGlvbnMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdGVkT3B0aW9ucztcbiAgfVxuICBkZWZhdWx0TXV0YXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucz8uX2RlZmF1bHRlZCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLiNkZWZhdWx0T3B0aW9ucy5tdXRhdGlvbnMsXG4gICAgICAuLi5vcHRpb25zPy5tdXRhdGlvbktleSAmJiB0aGlzLmdldE11dGF0aW9uRGVmYXVsdHMob3B0aW9ucy5tdXRhdGlvbktleSksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgX2RlZmF1bHRlZDogdHJ1ZVxuICAgIH07XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy4jcXVlcnlDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuI211dGF0aW9uQ2FjaGUuY2xlYXIoKTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIFF1ZXJ5Q2xpZW50XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnlDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/queryClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/removable.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/removable.js ***!
  \********************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Removable: function() { return /* binding */ Removable; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/removable.ts\n\nvar Removable = class {\n  #gcTimeout;\n  destroy() {\n    this.clearGcTimeout();\n  }\n  scheduleGc() {\n    this.clearGcTimeout();\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isValidTimeout)(this.gcTime)) {\n      this.#gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.gcTime);\n    }\n  }\n  updateGcTime(newGcTime) {\n    this.gcTime = Math.max(\n      this.gcTime || 0,\n      newGcTime ?? (_utils_js__WEBPACK_IMPORTED_MODULE_0__.isServer ? Infinity : 5 * 60 * 1e3)\n    );\n  }\n  clearGcTimeout() {\n    if (this.#gcTimeout) {\n      clearTimeout(this.#gcTimeout);\n      this.#gcTimeout = void 0;\n    }\n  }\n};\n\n//# sourceMappingURL=removable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcXVlcnktY29yZUA1LjM2LjEvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9yZW1vdmFibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQWM7QUFDdEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0YW5zdGFjaytxdWVyeS1jb3JlQDUuMzYuMS9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL3JlbW92YWJsZS5qcz8xMDAwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9yZW1vdmFibGUudHNcbmltcG9ydCB7IGlzU2VydmVyLCBpc1ZhbGlkVGltZW91dCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG52YXIgUmVtb3ZhYmxlID0gY2xhc3Mge1xuICAjZ2NUaW1lb3V0O1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2xlYXJHY1RpbWVvdXQoKTtcbiAgfVxuICBzY2hlZHVsZUdjKCkge1xuICAgIHRoaXMuY2xlYXJHY1RpbWVvdXQoKTtcbiAgICBpZiAoaXNWYWxpZFRpbWVvdXQodGhpcy5nY1RpbWUpKSB7XG4gICAgICB0aGlzLiNnY1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5vcHRpb25hbFJlbW92ZSgpO1xuICAgICAgfSwgdGhpcy5nY1RpbWUpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVHY1RpbWUobmV3R2NUaW1lKSB7XG4gICAgdGhpcy5nY1RpbWUgPSBNYXRoLm1heChcbiAgICAgIHRoaXMuZ2NUaW1lIHx8IDAsXG4gICAgICBuZXdHY1RpbWUgPz8gKGlzU2VydmVyID8gSW5maW5pdHkgOiA1ICogNjAgKiAxZTMpXG4gICAgKTtcbiAgfVxuICBjbGVhckdjVGltZW91dCgpIHtcbiAgICBpZiAodGhpcy4jZ2NUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jZ2NUaW1lb3V0KTtcbiAgICAgIHRoaXMuI2djVGltZW91dCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbn07XG5leHBvcnQge1xuICBSZW1vdmFibGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmFibGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/removable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/retryer.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/retryer.js ***!
  \******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CancelledError: function() { return /* binding */ CancelledError; },\n/* harmony export */   canFetch: function() { return /* binding */ canFetch; },\n/* harmony export */   createRetryer: function() { return /* binding */ createRetryer; },\n/* harmony export */   isCancelledError: function() { return /* binding */ isCancelledError; }\n/* harmony export */ });\n/* harmony import */ var _focusManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./focusManager.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/focusManager.js\");\n/* harmony import */ var _onlineManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./onlineManager.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/onlineManager.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/retryer.ts\n\n\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1e3 * 2 ** failureCount, 3e4);\n}\nfunction canFetch(networkMode) {\n  return (networkMode ?? \"online\") === \"online\" ? _onlineManager_js__WEBPACK_IMPORTED_MODULE_0__.onlineManager.isOnline() : true;\n}\nvar CancelledError = class {\n  constructor(options) {\n    this.revert = options?.revert;\n    this.silent = options?.silent;\n  }\n};\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n  const cancel = (cancelOptions) => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort?.();\n    }\n  };\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n  const canContinue = () => _focusManager_js__WEBPACK_IMPORTED_MODULE_1__.focusManager.isFocused() && (config.networkMode === \"always\" || _onlineManager_js__WEBPACK_IMPORTED_MODULE_0__.onlineManager.isOnline()) && config.canRun();\n  const canStart = () => canFetch(config.networkMode) && config.canRun();\n  const resolve = (value) => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess?.(value);\n      continueFn?.();\n      promiseResolve(value);\n    }\n  };\n  const reject = (value) => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError?.(value);\n      continueFn?.();\n      promiseReject(value);\n    }\n  };\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        if (isResolved || canContinue()) {\n          continueResolve(value);\n        }\n      };\n      config.onPause?.();\n    }).then(() => {\n      continueFn = void 0;\n      if (!isResolved) {\n        config.onContinue?.();\n      }\n    });\n  };\n  const run = () => {\n    if (isResolved) {\n      return;\n    }\n    let promiseOrValue;\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {\n      if (isResolved) {\n        return;\n      }\n      const retry = config.retry ?? (_utils_js__WEBPACK_IMPORTED_MODULE_2__.isServer ? 0 : 3);\n      const retryDelay = config.retryDelay ?? defaultRetryDelay;\n      const delay = typeof retryDelay === \"function\" ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === \"number\" && failureCount < retry || typeof retry === \"function\" && retry(failureCount, error);\n      if (isRetryCancelled || !shouldRetry) {\n        reject(error);\n        return;\n      }\n      failureCount++;\n      config.onFail?.(failureCount, error);\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.sleep)(delay).then(() => {\n        return canContinue() ? void 0 : pause();\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  };\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      continueFn?.();\n      return promise;\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      if (canStart()) {\n        run();\n      } else {\n        pause().then(run);\n      }\n      return promise;\n    }\n  };\n}\n\n//# sourceMappingURL=retryer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcXVlcnktY29yZUA1LjM2LjEvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9yZXRyeWVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNpRDtBQUNFO0FBQ047QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsNERBQWE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMERBQVksb0RBQW9ELDREQUFhO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLCtDQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0RBQUs7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcXVlcnktY29yZUA1LjM2LjEvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9yZXRyeWVyLmpzP2NhMTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3JldHJ5ZXIudHNcbmltcG9ydCB7IGZvY3VzTWFuYWdlciB9IGZyb20gXCIuL2ZvY3VzTWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgb25saW5lTWFuYWdlciB9IGZyb20gXCIuL29ubGluZU1hbmFnZXIuanNcIjtcbmltcG9ydCB7IGlzU2VydmVyLCBzbGVlcCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5mdW5jdGlvbiBkZWZhdWx0UmV0cnlEZWxheShmYWlsdXJlQ291bnQpIHtcbiAgcmV0dXJuIE1hdGgubWluKDFlMyAqIDIgKiogZmFpbHVyZUNvdW50LCAzZTQpO1xufVxuZnVuY3Rpb24gY2FuRmV0Y2gobmV0d29ya01vZGUpIHtcbiAgcmV0dXJuIChuZXR3b3JrTW9kZSA/PyBcIm9ubGluZVwiKSA9PT0gXCJvbmxpbmVcIiA/IG9ubGluZU1hbmFnZXIuaXNPbmxpbmUoKSA6IHRydWU7XG59XG52YXIgQ2FuY2VsbGVkRXJyb3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnJldmVydCA9IG9wdGlvbnM/LnJldmVydDtcbiAgICB0aGlzLnNpbGVudCA9IG9wdGlvbnM/LnNpbGVudDtcbiAgfVxufTtcbmZ1bmN0aW9uIGlzQ2FuY2VsbGVkRXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQ2FuY2VsbGVkRXJyb3I7XG59XG5mdW5jdGlvbiBjcmVhdGVSZXRyeWVyKGNvbmZpZykge1xuICBsZXQgaXNSZXRyeUNhbmNlbGxlZCA9IGZhbHNlO1xuICBsZXQgZmFpbHVyZUNvdW50ID0gMDtcbiAgbGV0IGlzUmVzb2x2ZWQgPSBmYWxzZTtcbiAgbGV0IGNvbnRpbnVlRm47XG4gIGxldCBwcm9taXNlUmVzb2x2ZTtcbiAgbGV0IHByb21pc2VSZWplY3Q7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgob3V0ZXJSZXNvbHZlLCBvdXRlclJlamVjdCkgPT4ge1xuICAgIHByb21pc2VSZXNvbHZlID0gb3V0ZXJSZXNvbHZlO1xuICAgIHByb21pc2VSZWplY3QgPSBvdXRlclJlamVjdDtcbiAgfSk7XG4gIGNvbnN0IGNhbmNlbCA9IChjYW5jZWxPcHRpb25zKSA9PiB7XG4gICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICByZWplY3QobmV3IENhbmNlbGxlZEVycm9yKGNhbmNlbE9wdGlvbnMpKTtcbiAgICAgIGNvbmZpZy5hYm9ydD8uKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBjYW5jZWxSZXRyeSA9ICgpID0+IHtcbiAgICBpc1JldHJ5Q2FuY2VsbGVkID0gdHJ1ZTtcbiAgfTtcbiAgY29uc3QgY29udGludWVSZXRyeSA9ICgpID0+IHtcbiAgICBpc1JldHJ5Q2FuY2VsbGVkID0gZmFsc2U7XG4gIH07XG4gIGNvbnN0IGNhbkNvbnRpbnVlID0gKCkgPT4gZm9jdXNNYW5hZ2VyLmlzRm9jdXNlZCgpICYmIChjb25maWcubmV0d29ya01vZGUgPT09IFwiYWx3YXlzXCIgfHwgb25saW5lTWFuYWdlci5pc09ubGluZSgpKSAmJiBjb25maWcuY2FuUnVuKCk7XG4gIGNvbnN0IGNhblN0YXJ0ID0gKCkgPT4gY2FuRmV0Y2goY29uZmlnLm5ldHdvcmtNb2RlKSAmJiBjb25maWcuY2FuUnVuKCk7XG4gIGNvbnN0IHJlc29sdmUgPSAodmFsdWUpID0+IHtcbiAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcbiAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgY29uZmlnLm9uU3VjY2Vzcz8uKHZhbHVlKTtcbiAgICAgIGNvbnRpbnVlRm4/LigpO1xuICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVqZWN0ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgIGNvbmZpZy5vbkVycm9yPy4odmFsdWUpO1xuICAgICAgY29udGludWVGbj8uKCk7XG4gICAgICBwcm9taXNlUmVqZWN0KHZhbHVlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdXNlID0gKCkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoY29udGludWVSZXNvbHZlKSA9PiB7XG4gICAgICBjb250aW51ZUZuID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChpc1Jlc29sdmVkIHx8IGNhbkNvbnRpbnVlKCkpIHtcbiAgICAgICAgICBjb250aW51ZVJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uZmlnLm9uUGF1c2U/LigpO1xuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgY29udGludWVGbiA9IHZvaWQgMDtcbiAgICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgICBjb25maWcub25Db250aW51ZT8uKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHJ1biA9ICgpID0+IHtcbiAgICBpZiAoaXNSZXNvbHZlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcHJvbWlzZU9yVmFsdWU7XG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2VPclZhbHVlID0gY29uZmlnLmZuKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHByb21pc2VPclZhbHVlID0gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgICBQcm9taXNlLnJlc29sdmUocHJvbWlzZU9yVmFsdWUpLnRoZW4ocmVzb2x2ZSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBpZiAoaXNSZXNvbHZlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZXRyeSA9IGNvbmZpZy5yZXRyeSA/PyAoaXNTZXJ2ZXIgPyAwIDogMyk7XG4gICAgICBjb25zdCByZXRyeURlbGF5ID0gY29uZmlnLnJldHJ5RGVsYXkgPz8gZGVmYXVsdFJldHJ5RGVsYXk7XG4gICAgICBjb25zdCBkZWxheSA9IHR5cGVvZiByZXRyeURlbGF5ID09PSBcImZ1bmN0aW9uXCIgPyByZXRyeURlbGF5KGZhaWx1cmVDb3VudCwgZXJyb3IpIDogcmV0cnlEZWxheTtcbiAgICAgIGNvbnN0IHNob3VsZFJldHJ5ID0gcmV0cnkgPT09IHRydWUgfHwgdHlwZW9mIHJldHJ5ID09PSBcIm51bWJlclwiICYmIGZhaWx1cmVDb3VudCA8IHJldHJ5IHx8IHR5cGVvZiByZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHJldHJ5KGZhaWx1cmVDb3VudCwgZXJyb3IpO1xuICAgICAgaWYgKGlzUmV0cnlDYW5jZWxsZWQgfHwgIXNob3VsZFJldHJ5KSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZhaWx1cmVDb3VudCsrO1xuICAgICAgY29uZmlnLm9uRmFpbD8uKGZhaWx1cmVDb3VudCwgZXJyb3IpO1xuICAgICAgc2xlZXAoZGVsYXkpLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gY2FuQ29udGludWUoKSA/IHZvaWQgMCA6IHBhdXNlKCk7XG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKGlzUmV0cnlDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ1bigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIGNhbmNlbCxcbiAgICBjb250aW51ZTogKCkgPT4ge1xuICAgICAgY29udGludWVGbj8uKCk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9LFxuICAgIGNhbmNlbFJldHJ5LFxuICAgIGNvbnRpbnVlUmV0cnksXG4gICAgY2FuU3RhcnQsXG4gICAgc3RhcnQ6ICgpID0+IHtcbiAgICAgIGlmIChjYW5TdGFydCgpKSB7XG4gICAgICAgIHJ1bigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF1c2UoKS50aGVuKHJ1bik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gIH07XG59XG5leHBvcnQge1xuICBDYW5jZWxsZWRFcnJvcixcbiAgY2FuRmV0Y2gsXG4gIGNyZWF0ZVJldHJ5ZXIsXG4gIGlzQ2FuY2VsbGVkRXJyb3Jcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeWVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/retryer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/subscribable.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/subscribable.js ***!
  \***********************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Subscribable: function() { return /* binding */ Subscribable; }\n/* harmony export */ });\n// src/subscribable.ts\nvar Subscribable = class {\n  constructor() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.subscribe = this.subscribe.bind(this);\n  }\n  subscribe(listener) {\n    this.listeners.add(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners.delete(listener);\n      this.onUnsubscribe();\n    };\n  }\n  hasListeners() {\n    return this.listeners.size > 0;\n  }\n  onSubscribe() {\n  }\n  onUnsubscribe() {\n  }\n};\n\n//# sourceMappingURL=subscribable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcXVlcnktY29yZUA1LjM2LjEvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9zdWJzY3JpYmFibGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRhbnN0YWNrK3F1ZXJ5LWNvcmVANS4zNi4xL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vc3Vic2NyaWJhYmxlLmpzPzlhYWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3N1YnNjcmliYWJsZS50c1xudmFyIFN1YnNjcmliYWJsZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuc3Vic2NyaWJlID0gdGhpcy5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgfVxuICBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIHRoaXMub25TdWJzY3JpYmUoKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5saXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMub25VbnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH1cbiAgaGFzTGlzdGVuZXJzKCkge1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5zaXplID4gMDtcbiAgfVxuICBvblN1YnNjcmliZSgpIHtcbiAgfVxuICBvblVuc3Vic2NyaWJlKCkge1xuICB9XG59O1xuZXhwb3J0IHtcbiAgU3Vic2NyaWJhYmxlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJhYmxlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/subscribable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/utils.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/utils.js ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addToEnd: function() { return /* binding */ addToEnd; },\n/* harmony export */   addToStart: function() { return /* binding */ addToStart; },\n/* harmony export */   functionalUpdate: function() { return /* binding */ functionalUpdate; },\n/* harmony export */   hashKey: function() { return /* binding */ hashKey; },\n/* harmony export */   hashQueryKeyByOptions: function() { return /* binding */ hashQueryKeyByOptions; },\n/* harmony export */   isPlainArray: function() { return /* binding */ isPlainArray; },\n/* harmony export */   isPlainObject: function() { return /* binding */ isPlainObject; },\n/* harmony export */   isServer: function() { return /* binding */ isServer; },\n/* harmony export */   isValidTimeout: function() { return /* binding */ isValidTimeout; },\n/* harmony export */   keepPreviousData: function() { return /* binding */ keepPreviousData; },\n/* harmony export */   matchMutation: function() { return /* binding */ matchMutation; },\n/* harmony export */   matchQuery: function() { return /* binding */ matchQuery; },\n/* harmony export */   noop: function() { return /* binding */ noop; },\n/* harmony export */   partialMatchKey: function() { return /* binding */ partialMatchKey; },\n/* harmony export */   replaceData: function() { return /* binding */ replaceData; },\n/* harmony export */   replaceEqualDeep: function() { return /* binding */ replaceEqualDeep; },\n/* harmony export */   shallowEqualObjects: function() { return /* binding */ shallowEqualObjects; },\n/* harmony export */   skipToken: function() { return /* binding */ skipToken; },\n/* harmony export */   sleep: function() { return /* binding */ sleep; },\n/* harmony export */   timeUntilStale: function() { return /* binding */ timeUntilStale; }\n/* harmony export */ });\n// src/utils.ts\nvar isServer = typeof window === \"undefined\" || \"Deno\" in globalThis;\nfunction noop() {\n  return void 0;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === \"number\" && value >= 0 && value !== Infinity;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = \"all\",\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n  if (type !== \"all\") {\n    const isActive = query.isActive();\n    if (type === \"active\" && !isActive) {\n      return false;\n    }\n    if (type === \"inactive\" && isActive) {\n      return false;\n    }\n  }\n  if (typeof stale === \"boolean\" && query.isStale() !== stale) {\n    return false;\n  }\n  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const { exact, status, predicate, mutationKey } = filters;\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n  if (status && mutation.state.status !== status) {\n    return false;\n  }\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = options?.queryKeyHashFn || hashKey;\n  return hashFn(queryKey);\n}\nfunction hashKey(queryKey) {\n  return JSON.stringify(\n    queryKey,\n    (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n      result[key] = val[key];\n      return result;\n    }, {}) : val\n  );\n}\nfunction partialMatchKey(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some((key) => !partialMatchKey(a[key], b[key]));\n  }\n  return false;\n}\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n  const array = isPlainArray(a) && isPlainArray(b);\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aItems = array ? a : Object.keys(a);\n    const aSize = aItems.length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      if ((!array && aItems.includes(key) || array) && a[key] === void 0 && b[key] === void 0) {\n        copy[key] = void 0;\n        equalItems++;\n      } else {\n        copy[key] = replaceEqualDeep(a[key], b[key]);\n        if (copy[key] === a[key] && a[key] !== void 0) {\n          equalItems++;\n        }\n      }\n    }\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n  return b;\n}\nfunction shallowEqualObjects(a, b) {\n  if (!b || Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n}\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n  const ctor = o.constructor;\n  if (ctor === void 0) {\n    return true;\n  }\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n  if (!prot.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n  if (Object.getPrototypeOf(o) !== Object.prototype) {\n    return false;\n  }\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction sleep(ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\nfunction replaceData(prevData, data, options) {\n  if (typeof options.structuralSharing === \"function\") {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    return replaceEqualDeep(prevData, data);\n  }\n  return data;\n}\nfunction keepPreviousData(previousData) {\n  return previousData;\n}\nfunction addToEnd(items, item, max = 0) {\n  const newItems = [...items, item];\n  return max && newItems.length > max ? newItems.slice(1) : newItems;\n}\nfunction addToStart(items, item, max = 0) {\n  const newItems = [item, ...items];\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;\n}\nvar skipToken = Symbol();\n\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcXVlcnktY29yZUA1LjM2LjEvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3Q0FBd0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXNCRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcXVlcnktY29yZUA1LjM2LjEvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi91dGlscy5qcz8zYTI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91dGlscy50c1xudmFyIGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBcIkRlbm9cIiBpbiBnbG9iYWxUaGlzO1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgaW5wdXQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1cGRhdGVyID09PSBcImZ1bmN0aW9uXCIgPyB1cGRhdGVyKGlucHV0KSA6IHVwZGF0ZXI7XG59XG5mdW5jdGlvbiBpc1ZhbGlkVGltZW91dCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIHZhbHVlID49IDAgJiYgdmFsdWUgIT09IEluZmluaXR5O1xufVxuZnVuY3Rpb24gdGltZVVudGlsU3RhbGUodXBkYXRlZEF0LCBzdGFsZVRpbWUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KHVwZGF0ZWRBdCArIChzdGFsZVRpbWUgfHwgMCkgLSBEYXRlLm5vdygpLCAwKTtcbn1cbmZ1bmN0aW9uIG1hdGNoUXVlcnkoZmlsdGVycywgcXVlcnkpIHtcbiAgY29uc3Qge1xuICAgIHR5cGUgPSBcImFsbFwiLFxuICAgIGV4YWN0LFxuICAgIGZldGNoU3RhdHVzLFxuICAgIHByZWRpY2F0ZSxcbiAgICBxdWVyeUtleSxcbiAgICBzdGFsZVxuICB9ID0gZmlsdGVycztcbiAgaWYgKHF1ZXJ5S2V5KSB7XG4gICAgaWYgKGV4YWN0KSB7XG4gICAgICBpZiAocXVlcnkucXVlcnlIYXNoICE9PSBoYXNoUXVlcnlLZXlCeU9wdGlvbnMocXVlcnlLZXksIHF1ZXJ5Lm9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFwYXJ0aWFsTWF0Y2hLZXkocXVlcnkucXVlcnlLZXksIHF1ZXJ5S2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZSAhPT0gXCJhbGxcIikge1xuICAgIGNvbnN0IGlzQWN0aXZlID0gcXVlcnkuaXNBY3RpdmUoKTtcbiAgICBpZiAodHlwZSA9PT0gXCJhY3RpdmVcIiAmJiAhaXNBY3RpdmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiaW5hY3RpdmVcIiAmJiBpc0FjdGl2ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHN0YWxlID09PSBcImJvb2xlYW5cIiAmJiBxdWVyeS5pc1N0YWxlKCkgIT09IHN0YWxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmZXRjaFN0YXR1cyAmJiBmZXRjaFN0YXR1cyAhPT0gcXVlcnkuc3RhdGUuZmV0Y2hTdGF0dXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHByZWRpY2F0ZSAmJiAhcHJlZGljYXRlKHF1ZXJ5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hdGNoTXV0YXRpb24oZmlsdGVycywgbXV0YXRpb24pIHtcbiAgY29uc3QgeyBleGFjdCwgc3RhdHVzLCBwcmVkaWNhdGUsIG11dGF0aW9uS2V5IH0gPSBmaWx0ZXJzO1xuICBpZiAobXV0YXRpb25LZXkpIHtcbiAgICBpZiAoIW11dGF0aW9uLm9wdGlvbnMubXV0YXRpb25LZXkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGV4YWN0KSB7XG4gICAgICBpZiAoaGFzaEtleShtdXRhdGlvbi5vcHRpb25zLm11dGF0aW9uS2V5KSAhPT0gaGFzaEtleShtdXRhdGlvbktleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXBhcnRpYWxNYXRjaEtleShtdXRhdGlvbi5vcHRpb25zLm11dGF0aW9uS2V5LCBtdXRhdGlvbktleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXR1cyAmJiBtdXRhdGlvbi5zdGF0ZS5zdGF0dXMgIT09IHN0YXR1cykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocHJlZGljYXRlICYmICFwcmVkaWNhdGUobXV0YXRpb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaGFzaFF1ZXJ5S2V5QnlPcHRpb25zKHF1ZXJ5S2V5LCBvcHRpb25zKSB7XG4gIGNvbnN0IGhhc2hGbiA9IG9wdGlvbnM/LnF1ZXJ5S2V5SGFzaEZuIHx8IGhhc2hLZXk7XG4gIHJldHVybiBoYXNoRm4ocXVlcnlLZXkpO1xufVxuZnVuY3Rpb24gaGFzaEtleShxdWVyeUtleSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXG4gICAgcXVlcnlLZXksXG4gICAgKF8sIHZhbCkgPT4gaXNQbGFpbk9iamVjdCh2YWwpID8gT2JqZWN0LmtleXModmFsKS5zb3J0KCkucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWxba2V5XTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pIDogdmFsXG4gICk7XG59XG5mdW5jdGlvbiBwYXJ0aWFsTWF0Y2hLZXkoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYiA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiAhT2JqZWN0LmtleXMoYikuc29tZSgoa2V5KSA9PiAhcGFydGlhbE1hdGNoS2V5KGFba2V5XSwgYltrZXldKSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmVwbGFjZUVxdWFsRGVlcChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgY29uc3QgYXJyYXkgPSBpc1BsYWluQXJyYXkoYSkgJiYgaXNQbGFpbkFycmF5KGIpO1xuICBpZiAoYXJyYXkgfHwgaXNQbGFpbk9iamVjdChhKSAmJiBpc1BsYWluT2JqZWN0KGIpKSB7XG4gICAgY29uc3QgYUl0ZW1zID0gYXJyYXkgPyBhIDogT2JqZWN0LmtleXMoYSk7XG4gICAgY29uc3QgYVNpemUgPSBhSXRlbXMubGVuZ3RoO1xuICAgIGNvbnN0IGJJdGVtcyA9IGFycmF5ID8gYiA6IE9iamVjdC5rZXlzKGIpO1xuICAgIGNvbnN0IGJTaXplID0gYkl0ZW1zLmxlbmd0aDtcbiAgICBjb25zdCBjb3B5ID0gYXJyYXkgPyBbXSA6IHt9O1xuICAgIGxldCBlcXVhbEl0ZW1zID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJTaXplOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGFycmF5ID8gaSA6IGJJdGVtc1tpXTtcbiAgICAgIGlmICgoIWFycmF5ICYmIGFJdGVtcy5pbmNsdWRlcyhrZXkpIHx8IGFycmF5KSAmJiBhW2tleV0gPT09IHZvaWQgMCAmJiBiW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICBjb3B5W2tleV0gPSB2b2lkIDA7XG4gICAgICAgIGVxdWFsSXRlbXMrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvcHlba2V5XSA9IHJlcGxhY2VFcXVhbERlZXAoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICBpZiAoY29weVtrZXldID09PSBhW2tleV0gJiYgYVtrZXldICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBlcXVhbEl0ZW1zKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFTaXplID09PSBiU2l6ZSAmJiBlcXVhbEl0ZW1zID09PSBhU2l6ZSA/IGEgOiBjb3B5O1xuICB9XG4gIHJldHVybiBiO1xufVxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsT2JqZWN0cyhhLCBiKSB7XG4gIGlmICghYiB8fCBPYmplY3Qua2V5cyhhKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgaWYgKGFba2V5XSAhPT0gYltrZXldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXNQbGFpbkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG8pIHtcbiAgaWYgKCFoYXNPYmplY3RQcm90b3R5cGUobykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgY3RvciA9IG8uY29uc3RydWN0b3I7XG4gIGlmIChjdG9yID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBwcm90ID0gY3Rvci5wcm90b3R5cGU7XG4gIGlmICghaGFzT2JqZWN0UHJvdG90eXBlKHByb3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghcHJvdC5oYXNPd25Qcm9wZXJ0eShcImlzUHJvdG90eXBlT2ZcIikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihvKSAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGhhc09iamVjdFByb3RvdHlwZShvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBzbGVlcChtcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZXBsYWNlRGF0YShwcmV2RGF0YSwgZGF0YSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMuc3RydWN0dXJhbFNoYXJpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBvcHRpb25zLnN0cnVjdHVyYWxTaGFyaW5nKHByZXZEYXRhLCBkYXRhKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLnN0cnVjdHVyYWxTaGFyaW5nICE9PSBmYWxzZSkge1xuICAgIHJldHVybiByZXBsYWNlRXF1YWxEZWVwKHByZXZEYXRhLCBkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGtlZXBQcmV2aW91c0RhdGEocHJldmlvdXNEYXRhKSB7XG4gIHJldHVybiBwcmV2aW91c0RhdGE7XG59XG5mdW5jdGlvbiBhZGRUb0VuZChpdGVtcywgaXRlbSwgbWF4ID0gMCkge1xuICBjb25zdCBuZXdJdGVtcyA9IFsuLi5pdGVtcywgaXRlbV07XG4gIHJldHVybiBtYXggJiYgbmV3SXRlbXMubGVuZ3RoID4gbWF4ID8gbmV3SXRlbXMuc2xpY2UoMSkgOiBuZXdJdGVtcztcbn1cbmZ1bmN0aW9uIGFkZFRvU3RhcnQoaXRlbXMsIGl0ZW0sIG1heCA9IDApIHtcbiAgY29uc3QgbmV3SXRlbXMgPSBbaXRlbSwgLi4uaXRlbXNdO1xuICByZXR1cm4gbWF4ICYmIG5ld0l0ZW1zLmxlbmd0aCA+IG1heCA/IG5ld0l0ZW1zLnNsaWNlKDAsIC0xKSA6IG5ld0l0ZW1zO1xufVxudmFyIHNraXBUb2tlbiA9IFN5bWJvbCgpO1xuZXhwb3J0IHtcbiAgYWRkVG9FbmQsXG4gIGFkZFRvU3RhcnQsXG4gIGZ1bmN0aW9uYWxVcGRhdGUsXG4gIGhhc2hLZXksXG4gIGhhc2hRdWVyeUtleUJ5T3B0aW9ucyxcbiAgaXNQbGFpbkFycmF5LFxuICBpc1BsYWluT2JqZWN0LFxuICBpc1NlcnZlcixcbiAgaXNWYWxpZFRpbWVvdXQsXG4gIGtlZXBQcmV2aW91c0RhdGEsXG4gIG1hdGNoTXV0YXRpb24sXG4gIG1hdGNoUXVlcnksXG4gIG5vb3AsXG4gIHBhcnRpYWxNYXRjaEtleSxcbiAgcmVwbGFjZURhdGEsXG4gIHJlcGxhY2VFcXVhbERlZXAsXG4gIHNoYWxsb3dFcXVhbE9iamVjdHMsXG4gIHNraXBUb2tlbixcbiAgc2xlZXAsXG4gIHRpbWVVbnRpbFN0YWxlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@tanstack+query-core@5.36.1/node_modules/@tanstack/query-core/build/modern/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@tanstack+react-query@5.36.2_react@18.3.1/node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tanstack+react-query@5.36.2_react@18.3.1/node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js ***!
  \*********************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryClientContext: function() { return /* binding */ QueryClientContext; },\n/* harmony export */   QueryClientProvider: function() { return /* binding */ QueryClientProvider; },\n/* harmony export */   useQueryClient: function() { return /* binding */ useQueryClient; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ QueryClientContext,QueryClientProvider,useQueryClient auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$();\n// src/QueryClientProvider.tsx\n\n\nvar QueryClientContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nvar useQueryClient = function(queryClient) {\n    _s();\n    var client = react__WEBPACK_IMPORTED_MODULE_0__.useContext(QueryClientContext);\n    if (queryClient) {\n        return queryClient;\n    }\n    if (!client) {\n        throw new Error(\"No QueryClient set, use QueryClientProvider to set one\");\n    }\n    return client;\n};\n_s(useQueryClient, \"6C1IqtdJdCPZ/voWsX/6r3Oc32M=\");\nvar QueryClientProvider = function(param) {\n    var client = param.client, children = param.children;\n    _s1();\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        client.mount();\n        return function() {\n            client.unmount();\n        };\n    }, [\n        client\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(QueryClientContext.Provider, {\n        value: client,\n        children: children\n    });\n};\n_s1(QueryClientProvider, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = QueryClientProvider;\n //# sourceMappingURL=QueryClientProvider.js.map\nvar _c;\n$RefreshReg$(_c, \"QueryClientProvider\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srcmVhY3QtcXVlcnlANS4zNi4yX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5L2J1aWxkL21vZGVybi9RdWVyeUNsaWVudFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDdUI7QUF1Q25CO0FBbkNHLElBQU1FLG1DQUEyQkYsZ0RBQUEsQ0FDdEM7QUFHSyxJQUFNSSxpQkFBaUIsU0FBQ0M7O0lBQzdCLElBQU1DLFNBQWVOLDZDQUFBLENBQVdFO0lBRWhDLElBQUlHLGFBQWE7UUFDZixPQUFPQTtJQUNUO0lBRUEsSUFBSSxDQUFDQyxRQUFRO1FBQ1gsTUFBTSxJQUFJRSxNQUFNO0lBQ2xCO0lBRUEsT0FBT0Y7QUFDVDtHQVphRjtBQW1CTixJQUFNSyxzQkFBc0I7UUFDakNILGVBQUFBLFFBQ0FJLGlCQUFBQTs7SUFFTVYsNENBQUEsQ0FBVTtRQUNkTSxPQUFPTSxLQUFBO1FBQ1AsT0FBTztZQUNMTixPQUFPTyxPQUFBO1FBQ1Q7SUFDRixHQUFHO1FBQUNQO0tBQU87SUFFWCxPQUNFLGdCQUFBTCxzREFBQUEsQ0FBQ0MsbUJBQW1CWSxRQUFBLEVBQW5CO1FBQTRCQyxPQUFPVDtRQUNqQ0ksVUFBQUE7SUFBQTtBQUdQO0lBaEJhRDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL1F1ZXJ5Q2xpZW50UHJvdmlkZXIudHN4Pzk5ZWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHR5cGUgeyBRdWVyeUNsaWVudCB9IGZyb20gJ0B0YW5zdGFjay9xdWVyeS1jb3JlJ1xuXG5leHBvcnQgY29uc3QgUXVlcnlDbGllbnRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxRdWVyeUNsaWVudCB8IHVuZGVmaW5lZD4oXG4gIHVuZGVmaW5lZCxcbilcblxuZXhwb3J0IGNvbnN0IHVzZVF1ZXJ5Q2xpZW50ID0gKHF1ZXJ5Q2xpZW50PzogUXVlcnlDbGllbnQpID0+IHtcbiAgY29uc3QgY2xpZW50ID0gUmVhY3QudXNlQ29udGV4dChRdWVyeUNsaWVudENvbnRleHQpXG5cbiAgaWYgKHF1ZXJ5Q2xpZW50KSB7XG4gICAgcmV0dXJuIHF1ZXJ5Q2xpZW50XG4gIH1cblxuICBpZiAoIWNsaWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gUXVlcnlDbGllbnQgc2V0LCB1c2UgUXVlcnlDbGllbnRQcm92aWRlciB0byBzZXQgb25lJylcbiAgfVxuXG4gIHJldHVybiBjbGllbnRcbn1cblxuZXhwb3J0IHR5cGUgUXVlcnlDbGllbnRQcm92aWRlclByb3BzID0ge1xuICBjbGllbnQ6IFF1ZXJ5Q2xpZW50XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlXG59XG5cbmV4cG9ydCBjb25zdCBRdWVyeUNsaWVudFByb3ZpZGVyID0gKHtcbiAgY2xpZW50LFxuICBjaGlsZHJlbixcbn06IFF1ZXJ5Q2xpZW50UHJvdmlkZXJQcm9wcyk6IFJlYWN0LkpTWC5FbGVtZW50ID0+IHtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjbGllbnQubW91bnQoKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGllbnQudW5tb3VudCgpXG4gICAgfVxuICB9LCBbY2xpZW50XSlcblxuICByZXR1cm4gKFxuICAgIDxRdWVyeUNsaWVudENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NsaWVudH0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9RdWVyeUNsaWVudENvbnRleHQuUHJvdmlkZXI+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsImpzeCIsIlF1ZXJ5Q2xpZW50Q29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VRdWVyeUNsaWVudCIsInF1ZXJ5Q2xpZW50IiwiY2xpZW50IiwidXNlQ29udGV4dCIsIkVycm9yIiwiUXVlcnlDbGllbnRQcm92aWRlciIsImNoaWxkcmVuIiwidXNlRWZmZWN0IiwibW91bnQiLCJ1bm1vdW50IiwiUHJvdmlkZXIiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@tanstack+react-query@5.36.2_react@18.3.1/node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: function() { return /* binding */ clsx; }\n/* harmony export */ });\nfunction r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}/* harmony default export */ __webpack_exports__[\"default\"] = (clsx);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9jbHN4QDIuMS4xL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGNBQWMsYUFBYSwrQ0FBK0MsZ0RBQWdELGVBQWUsUUFBUSxJQUFJLDBDQUEwQyx5Q0FBeUMsU0FBZ0IsZ0JBQWdCLHdDQUF3QyxJQUFJLG1EQUFtRCxTQUFTLCtEQUFlLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nsc3hAMi4xLjEvbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm1qcz8wNjYyIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKXt2YXIgbz1lLmxlbmd0aDtmb3IodD0wO3Q8bzt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpfWVsc2UgZm9yKGYgaW4gZSllW2ZdJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCIsbz1hcmd1bWVudHMubGVuZ3RoO2Y8bztmKyspKGU9YXJndW1lbnRzW2ZdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/lenis@1.0.45_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/lenis/dist/lenis-react.mjs":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/lenis@1.0.45_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/lenis/dist/lenis-react.mjs ***!
  \*****************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Lenis: function() { return /* binding */ m; },\n/* harmony export */   LenisContext: function() { return /* binding */ p; },\n/* harmony export */   ReactLenis: function() { return /* binding */ m; },\n/* harmony export */   \"default\": function() { return /* binding */ m; },\n/* harmony export */   useLenis: function() { return /* binding */ useLenis; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var _darkroom_engineering_tempus__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @darkroom.engineering/tempus */ \"(app-pages-browser)/./node_modules/.pnpm/@darkroom.engineering+tempus@0.0.46/node_modules/@darkroom.engineering/tempus/dist/tempus.modern.mjs\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var lenis__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lenis */ \"(app-pages-browser)/./node_modules/.pnpm/lenis@1.0.45_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/lenis/dist/lenis.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n\"function\"==typeof SuppressedError&&SuppressedError;const p=(0,react__WEBPACK_IMPORTED_MODULE_2__.createContext)(null),d=new class Store{constructor(r){this.listeners=[],this.state=r}set(r){this.state=r;for(let r of this.listeners)r(this.state)}subscribe(r){return this.listeners=[...this.listeners,r],()=>{this.listeners=this.listeners.filter((e=>e!==r))}}get(){return this.state}}({});function useCurrentLenis(){const r=(0,react__WEBPACK_IMPORTED_MODULE_2__.useContext)(p),e=function useStore(r){const[e,t]=(0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(r.get());return (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)((()=>r.subscribe((r=>t(r)))),[r]),e}(d);return null!=r?r:e}function useLenis(r,e=[],t=0){const{lenis:n,addCallback:s,removeCallback:o}=useCurrentLenis();return (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)((()=>{if(r&&s&&o&&n)return s(r,t),r(n),()=>{o(r)}}),[n,s,o,t,...e]),n}const m=(0,react__WEBPACK_IMPORTED_MODULE_2__.forwardRef)(((o,i)=>{var{children:f,root:m=!1,options:b={},autoRaf:h=!0,rafPriority:y=0,className:v}=o,g=function __rest(r,e){var t={};for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&e.indexOf(n)<0&&(t[n]=r[n]);if(null!=r&&\"function\"==typeof Object.getOwnPropertySymbols){var s=0;for(n=Object.getOwnPropertySymbols(r);s<n.length;s++)e.indexOf(n[s])<0&&Object.prototype.propertyIsEnumerable.call(r,n[s])&&(t[n[s]]=r[n[s]])}return t}(o,[\"children\",\"root\",\"options\",\"autoRaf\",\"rafPriority\",\"className\"]);const O=(0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null),k=(0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null),[N,j]=(0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(void 0),C=(0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)([]),w=(0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(((r,e)=>{C.current.push({callback:r,priority:e}),C.current.sort(((r,e)=>r.priority-e.priority))}),[]),S=(0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)((r=>{C.current=C.current.filter((e=>e.callback!==r))}),[]);(0,react__WEBPACK_IMPORTED_MODULE_2__.useImperativeHandle)(i,(()=>({wrapper:O.current,content:k.current,lenis:N})),[N]),(0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)((()=>{const r=new lenis__WEBPACK_IMPORTED_MODULE_3__[\"default\"](Object.assign(Object.assign({},b),!m&&{wrapper:O.current,content:k.current}));return j(r),()=>{r.destroy(),j(void 0)}}),[m,JSON.stringify(b)]),(0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)((()=>{if(N&&h)return _darkroom_engineering_tempus__WEBPACK_IMPORTED_MODULE_4__[\"default\"].add((r=>{null==N||N.raf(r)}),y)}),[N,h,y]),(0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)((()=>{if(m&&N)return d.set({lenis:N,addCallback:w,removeCallback:S}),()=>d.set({})}),[m,N,w,S]);const P=(0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)((r=>{for(let e=0;e<C.current.length;e++)C.current[e].callback(r)}),[]);(0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)((()=>(null==N||N.on(\"scroll\",P),()=>{null==N||N.off(\"scroll\",P)})),[N,P]);const x=(0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)((()=>{O.current&&(O.current.className=(0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(null==N?void 0:N.className,v))}),[N,v]);return (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)((()=>(x(),null==N||N.on(\"className change\",x),()=>{null==N||N.off(\"className change\",x)})),[N,x]),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(p.Provider,{value:{lenis:N,addCallback:w,removeCallback:S},children:m?f:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\",Object.assign({ref:O,className:(0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(null==N?void 0:N.className,v)},g,{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\",{ref:k,children:f})}))})}));\n//# sourceMappingURL=lenis-react.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9sZW5pc0AxLjAuNDVfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvbGVuaXMvZGlzdC9sZW5pcy1yZWFjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFzUixvREFBb0QsUUFBUSxvREFBQyx5QkFBeUIsZUFBZSwrQkFBK0IsT0FBTyxhQUFhLDBDQUEwQyxhQUFhLGlEQUFpRCxrREFBa0QsTUFBTSxtQkFBbUIsR0FBRyxFQUFFLDJCQUEyQixRQUFRLGlEQUFDLDJCQUEyQixXQUFXLCtDQUFDLFVBQVUsT0FBTyxnREFBQyxxQ0FBcUMsSUFBSSxtQkFBbUIsOEJBQThCLE1BQU0sdUNBQXVDLG1CQUFtQixPQUFPLGdEQUFDLE9BQU8sc0NBQXNDLE1BQU0sb0JBQW9CLFFBQVEsaURBQUMsVUFBVSxJQUFJLGlDQUFpQywwQ0FBMEMsMEJBQTBCLFNBQVMsc0ZBQXNGLDZEQUE2RCxRQUFRLHNDQUFzQyxXQUFXLDZGQUE2RixTQUFTLHNFQUFzRSxRQUFRLDZDQUFDLFNBQVMsNkNBQUMsYUFBYSwrQ0FBQyxXQUFXLDZDQUFDLE9BQU8sa0RBQUMsVUFBVSxnQkFBZ0Isc0JBQXNCLGlEQUFpRCxRQUFRLGtEQUFDLE1BQU0sZ0RBQWdELE1BQU0sMERBQUMsVUFBVSw0Q0FBNEMsUUFBUSxnREFBQyxPQUFPLFlBQVksNkNBQUMsK0JBQStCLFNBQVMsb0NBQW9DLEdBQUcsaUJBQWlCLHVCQUF1Qix5QkFBeUIsZ0RBQUMsT0FBTyxlQUFlLG9FQUFDLFVBQVUsa0JBQWtCLEtBQUssV0FBVyxnREFBQyxPQUFPLHNCQUFzQix1Q0FBdUMsY0FBYyxFQUFFLGFBQWEsUUFBUSxrREFBQyxNQUFNLFlBQVksbUJBQW1CLDZCQUE2QixNQUFNLGdEQUFDLHNDQUFzQywyQkFBMkIsVUFBVSxRQUFRLGtEQUFDLE9BQU8sZ0NBQWdDLGdEQUFDLGdDQUFnQyxTQUFTLE9BQU8sZ0RBQUMsb0RBQW9ELHFDQUFxQyxVQUFVLHNEQUFDLGFBQWEsT0FBTyx1Q0FBdUMsY0FBYyxzREFBQyxzQkFBc0IsZ0JBQWdCLGdEQUFDLCtCQUErQixJQUFJLFNBQVMsc0RBQUMsUUFBUSxpQkFBaUIsRUFBRSxHQUFHLEVBQUUsR0FBOEU7QUFDN25GIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9sZW5pc0AxLjAuNDVfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvbGVuaXMvZGlzdC9sZW5pcy1yZWFjdC5tanM/OGRjNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7anN4IGFzIHJ9ZnJvbVwicmVhY3QvanN4LXJ1bnRpbWVcIjtpbXBvcnQgZSBmcm9tXCJAZGFya3Jvb20uZW5naW5lZXJpbmcvdGVtcHVzXCI7aW1wb3J0IHQgZnJvbVwiY2xzeFwiO2ltcG9ydCBuIGZyb21cImxlbmlzXCI7aW1wb3J0e3VzZVN0YXRlIGFzIHMsdXNlRWZmZWN0IGFzIGwsY3JlYXRlQ29udGV4dCBhcyBvLGZvcndhcmRSZWYgYXMgaSx1c2VSZWYgYXMgYyx1c2VDYWxsYmFjayBhcyBhLHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgdSx1c2VDb250ZXh0IGFzIGZ9ZnJvbVwicmVhY3RcIjtcImZ1bmN0aW9uXCI9PXR5cGVvZiBTdXBwcmVzc2VkRXJyb3ImJlN1cHByZXNzZWRFcnJvcjtjb25zdCBwPW8obnVsbCksZD1uZXcgY2xhc3MgU3RvcmV7Y29uc3RydWN0b3Iocil7dGhpcy5saXN0ZW5lcnM9W10sdGhpcy5zdGF0ZT1yfXNldChyKXt0aGlzLnN0YXRlPXI7Zm9yKGxldCByIG9mIHRoaXMubGlzdGVuZXJzKXIodGhpcy5zdGF0ZSl9c3Vic2NyaWJlKHIpe3JldHVybiB0aGlzLmxpc3RlbmVycz1bLi4udGhpcy5saXN0ZW5lcnMscl0sKCk9Pnt0aGlzLmxpc3RlbmVycz10aGlzLmxpc3RlbmVycy5maWx0ZXIoKGU9PmUhPT1yKSl9fWdldCgpe3JldHVybiB0aGlzLnN0YXRlfX0oe30pO2Z1bmN0aW9uIHVzZUN1cnJlbnRMZW5pcygpe2NvbnN0IHI9ZihwKSxlPWZ1bmN0aW9uIHVzZVN0b3JlKHIpe2NvbnN0W2UsdF09cyhyLmdldCgpKTtyZXR1cm4gbCgoKCk9PnIuc3Vic2NyaWJlKChyPT50KHIpKSkpLFtyXSksZX0oZCk7cmV0dXJuIG51bGwhPXI/cjplfWZ1bmN0aW9uIHVzZUxlbmlzKHIsZT1bXSx0PTApe2NvbnN0e2xlbmlzOm4sYWRkQ2FsbGJhY2s6cyxyZW1vdmVDYWxsYmFjazpvfT11c2VDdXJyZW50TGVuaXMoKTtyZXR1cm4gbCgoKCk9PntpZihyJiZzJiZvJiZuKXJldHVybiBzKHIsdCkscihuKSwoKT0+e28ocil9fSksW24scyxvLHQsLi4uZV0pLG59Y29uc3QgbT1pKCgobyxpKT0+e3ZhcntjaGlsZHJlbjpmLHJvb3Q6bT0hMSxvcHRpb25zOmI9e30sYXV0b1JhZjpoPSEwLHJhZlByaW9yaXR5Onk9MCxjbGFzc05hbWU6dn09byxnPWZ1bmN0aW9uIF9fcmVzdChyLGUpe3ZhciB0PXt9O2Zvcih2YXIgbiBpbiByKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLG4pJiZlLmluZGV4T2Yobik8MCYmKHRbbl09cltuXSk7aWYobnVsbCE9ciYmXCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIHM9MDtmb3Iobj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHIpO3M8bi5sZW5ndGg7cysrKWUuaW5kZXhPZihuW3NdKTwwJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocixuW3NdKSYmKHRbbltzXV09cltuW3NdXSl9cmV0dXJuIHR9KG8sW1wiY2hpbGRyZW5cIixcInJvb3RcIixcIm9wdGlvbnNcIixcImF1dG9SYWZcIixcInJhZlByaW9yaXR5XCIsXCJjbGFzc05hbWVcIl0pO2NvbnN0IE89YyhudWxsKSxrPWMobnVsbCksW04sal09cyh2b2lkIDApLEM9YyhbXSksdz1hKCgocixlKT0+e0MuY3VycmVudC5wdXNoKHtjYWxsYmFjazpyLHByaW9yaXR5OmV9KSxDLmN1cnJlbnQuc29ydCgoKHIsZSk9PnIucHJpb3JpdHktZS5wcmlvcml0eSkpfSksW10pLFM9YSgocj0+e0MuY3VycmVudD1DLmN1cnJlbnQuZmlsdGVyKChlPT5lLmNhbGxiYWNrIT09cikpfSksW10pO3UoaSwoKCk9Pih7d3JhcHBlcjpPLmN1cnJlbnQsY29udGVudDprLmN1cnJlbnQsbGVuaXM6Tn0pKSxbTl0pLGwoKCgpPT57Y29uc3Qgcj1uZXcgbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYiksIW0mJnt3cmFwcGVyOk8uY3VycmVudCxjb250ZW50OmsuY3VycmVudH0pKTtyZXR1cm4gaihyKSwoKT0+e3IuZGVzdHJveSgpLGoodm9pZCAwKX19KSxbbSxKU09OLnN0cmluZ2lmeShiKV0pLGwoKCgpPT57aWYoTiYmaClyZXR1cm4gZS5hZGQoKHI9PntudWxsPT1OfHxOLnJhZihyKX0pLHkpfSksW04saCx5XSksbCgoKCk9PntpZihtJiZOKXJldHVybiBkLnNldCh7bGVuaXM6TixhZGRDYWxsYmFjazp3LHJlbW92ZUNhbGxiYWNrOlN9KSwoKT0+ZC5zZXQoe30pfSksW20sTix3LFNdKTtjb25zdCBQPWEoKHI9Pntmb3IobGV0IGU9MDtlPEMuY3VycmVudC5sZW5ndGg7ZSsrKUMuY3VycmVudFtlXS5jYWxsYmFjayhyKX0pLFtdKTtsKCgoKT0+KG51bGw9PU58fE4ub24oXCJzY3JvbGxcIixQKSwoKT0+e251bGw9PU58fE4ub2ZmKFwic2Nyb2xsXCIsUCl9KSksW04sUF0pO2NvbnN0IHg9YSgoKCk9PntPLmN1cnJlbnQmJihPLmN1cnJlbnQuY2xhc3NOYW1lPXQobnVsbD09Tj92b2lkIDA6Ti5jbGFzc05hbWUsdikpfSksW04sdl0pO3JldHVybiBsKCgoKT0+KHgoKSxudWxsPT1OfHxOLm9uKFwiY2xhc3NOYW1lIGNoYW5nZVwiLHgpLCgpPT57bnVsbD09Tnx8Ti5vZmYoXCJjbGFzc05hbWUgY2hhbmdlXCIseCl9KSksW04seF0pLHIocC5Qcm92aWRlcix7dmFsdWU6e2xlbmlzOk4sYWRkQ2FsbGJhY2s6dyxyZW1vdmVDYWxsYmFjazpTfSxjaGlsZHJlbjptP2Y6cihcImRpdlwiLE9iamVjdC5hc3NpZ24oe3JlZjpPLGNsYXNzTmFtZTp0KG51bGw9PU4/dm9pZCAwOk4uY2xhc3NOYW1lLHYpfSxnLHtjaGlsZHJlbjpyKFwiZGl2XCIse3JlZjprLGNoaWxkcmVuOmZ9KX0pKX0pfSkpO2V4cG9ydHttIGFzIExlbmlzLHAgYXMgTGVuaXNDb250ZXh0LG0gYXMgUmVhY3RMZW5pcyxtIGFzIGRlZmF1bHQsdXNlTGVuaXN9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVuaXMtcmVhY3QubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/lenis@1.0.45_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/lenis/dist/lenis-react.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/lenis@1.0.45_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/lenis/dist/lenis.mjs":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/lenis@1.0.45_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/lenis/dist/lenis.mjs ***!
  \***********************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ e; }\n/* harmony export */ });\nvar __assign=function(){return __assign=Object.assign||function __assign(t){for(var e,i=1,o=arguments.length;i<o;i++)for(var s in e=arguments[i])Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s]);return t},__assign.apply(this,arguments)};\"function\"==typeof SuppressedError&&SuppressedError;function clamp(t,e,i){return Math.max(t,Math.min(e,i))}class Animate{advance(t){if(!this.isRunning)return;let e=!1;if(this.lerp)this.value=function damp(t,e,i,o){return function lerp(t,e,i){return(1-i)*t+i*e}(t,e,1-Math.exp(-i*o))}(this.value,this.to,60*this.lerp,t),Math.round(this.value)===this.to&&(this.value=this.to,e=!0);else{this.currentTime+=t;const i=clamp(0,this.currentTime/this.duration,1);e=i>=1;const o=e?1:this.easing(i);this.value=this.from+(this.to-this.from)*o}e&&this.stop(),this.onUpdate?.(this.value,e)}stop(){this.isRunning=!1}fromTo(t,e,{lerp:i=.1,duration:o=1,easing:s=(t=>t),onStart:n,onUpdate:r}){this.from=this.value=t,this.to=e,this.lerp=i,this.duration=o,this.easing=s,this.currentTime=0,this.isRunning=!0,n?.(),this.onUpdate=r}}class Dimensions{constructor({wrapper:t,content:e,autoResize:i=!0,debounce:o=250}={}){this.wrapper=t,this.content=e,i&&(this.debouncedResize=function debounce(t,e){let i;return function(){let o=arguments,s=this;clearTimeout(i),i=setTimeout((function(){t.apply(s,o)}),e)}}(this.resize,o),this.wrapper===window?window.addEventListener(\"resize\",this.debouncedResize,!1):(this.wrapperResizeObserver=new ResizeObserver(this.debouncedResize),this.wrapperResizeObserver.observe(this.wrapper)),this.contentResizeObserver=new ResizeObserver(this.debouncedResize),this.contentResizeObserver.observe(this.content)),this.resize()}destroy(){this.wrapperResizeObserver?.disconnect(),this.contentResizeObserver?.disconnect(),window.removeEventListener(\"resize\",this.debouncedResize,!1)}resize=()=>{this.onWrapperResize(),this.onContentResize()};onWrapperResize=()=>{this.wrapper===window?(this.width=window.innerWidth,this.height=window.innerHeight):(this.width=this.wrapper.clientWidth,this.height=this.wrapper.clientHeight)};onContentResize=()=>{this.wrapper===window?(this.scrollHeight=this.content.scrollHeight,this.scrollWidth=this.content.scrollWidth):(this.scrollHeight=this.wrapper.scrollHeight,this.scrollWidth=this.wrapper.scrollWidth)};get limit(){return{x:this.scrollWidth-this.width,y:this.scrollHeight-this.height}}}class Emitter{constructor(){this.events={}}emit(t,...e){let i=this.events[t]||[];for(let t=0,o=i.length;t<o;t++)i[t](...e)}on(t,e){return this.events[t]?.push(e)||(this.events[t]=[e]),()=>{this.events[t]=this.events[t]?.filter((t=>e!==t))}}off(t,e){this.events[t]=this.events[t]?.filter((t=>e!==t))}destroy(){this.events={}}}const t=100/6;class VirtualScroll{constructor(t,{wheelMultiplier:e=1,touchMultiplier:i=1}){this.element=t,this.wheelMultiplier=e,this.touchMultiplier=i,this.touchStart={x:null,y:null},this.emitter=new Emitter,window.addEventListener(\"resize\",this.onWindowResize,!1),this.onWindowResize(),this.element.addEventListener(\"wheel\",this.onWheel,{passive:!1}),this.element.addEventListener(\"touchstart\",this.onTouchStart,{passive:!1}),this.element.addEventListener(\"touchmove\",this.onTouchMove,{passive:!1}),this.element.addEventListener(\"touchend\",this.onTouchEnd,{passive:!1})}on(t,e){return this.emitter.on(t,e)}destroy(){this.emitter.destroy(),window.removeEventListener(\"resize\",this.onWindowResize,!1),this.element.removeEventListener(\"wheel\",this.onWheel,{passive:!1}),this.element.removeEventListener(\"touchstart\",this.onTouchStart,{passive:!1}),this.element.removeEventListener(\"touchmove\",this.onTouchMove,{passive:!1}),this.element.removeEventListener(\"touchend\",this.onTouchEnd,{passive:!1})}onTouchStart=t=>{const{clientX:e,clientY:i}=t.targetTouches?t.targetTouches[0]:t;this.touchStart.x=e,this.touchStart.y=i,this.lastDelta={x:0,y:0},this.emitter.emit(\"scroll\",{deltaX:0,deltaY:0,event:t})};onTouchMove=t=>{const{clientX:e,clientY:i}=t.targetTouches?t.targetTouches[0]:t,o=-(e-this.touchStart.x)*this.touchMultiplier,s=-(i-this.touchStart.y)*this.touchMultiplier;this.touchStart.x=e,this.touchStart.y=i,this.lastDelta={x:o,y:s},this.emitter.emit(\"scroll\",{deltaX:o,deltaY:s,event:t})};onTouchEnd=t=>{this.emitter.emit(\"scroll\",{deltaX:this.lastDelta.x,deltaY:this.lastDelta.y,event:t})};onWheel=e=>{let{deltaX:i,deltaY:o,deltaMode:s}=e;i*=1===s?t:2===s?this.windowWidth:1,o*=1===s?t:2===s?this.windowHeight:1,i*=this.wheelMultiplier,o*=this.wheelMultiplier,this.emitter.emit(\"scroll\",{deltaX:i,deltaY:o,event:e})};onWindowResize=()=>{this.windowWidth=window.innerWidth,this.windowHeight=window.innerHeight}}var e=function(){function Lenis(t){var e=void 0===t?{}:t,i=e.wrapper,o=void 0===i?window:i,s=e.content,n=void 0===s?document.documentElement:s,r=e.wheelEventsTarget,l=void 0===r?o:r,h=e.eventsTarget,a=void 0===h?l:h,c=e.smoothWheel,p=void 0===c||c,u=e.syncTouch,d=void 0!==u&&u,m=e.syncTouchLerp,v=void 0===m?.075:m,g=e.touchInertiaMultiplier,f=void 0===g?35:g,S=e.duration,w=e.easing,y=void 0===w?function(t){return Math.min(1,1.001-Math.pow(2,-10*t))}:w,b=e.lerp,L=void 0===b?!S&&.1:b,_=e.infinite,z=void 0!==_&&_,E=e.orientation,T=void 0===E?\"vertical\":E,M=e.gestureOrientation,R=void 0===M?\"vertical\":M,O=e.touchMultiplier,W=void 0===O?1:O,x=e.wheelMultiplier,H=void 0===x?1:x,N=e.autoResize,k=void 0===N||N,C=e.__experimental__naiveDimensions,j=void 0!==C&&C,P=this;this.__isSmooth=!1,this.__isScrolling=!1,this.__isStopped=!1,this.__isLocked=!1,this.onVirtualScroll=function(t){var e=t.deltaX,i=t.deltaY,o=t.event;if(!o.ctrlKey){var s=o.type.includes(\"touch\"),n=o.type.includes(\"wheel\");if(P.options.syncTouch&&s&&\"touchstart\"===o.type&&!P.isStopped&&!P.isLocked)P.reset();else{var r=0===e&&0===i,l=\"vertical\"===P.options.gestureOrientation&&0===i||\"horizontal\"===P.options.gestureOrientation&&0===e;if(!r&&!l){var h=o.composedPath();if(!(h=h.slice(0,h.indexOf(P.rootElement))).find((function(t){var e,i,o,r,l;return(null===(e=t.hasAttribute)||void 0===e?void 0:e.call(t,\"data-lenis-prevent\"))||s&&(null===(i=t.hasAttribute)||void 0===i?void 0:i.call(t,\"data-lenis-prevent-touch\"))||n&&(null===(o=t.hasAttribute)||void 0===o?void 0:o.call(t,\"data-lenis-prevent-wheel\"))||(null===(r=t.classList)||void 0===r?void 0:r.contains(\"lenis\"))&&!(null===(l=t.classList)||void 0===l?void 0:l.contains(\"lenis-stopped\"))})))if(P.isStopped||P.isLocked)o.preventDefault();else{if(P.isSmooth=P.options.syncTouch&&s||P.options.smoothWheel&&n,!P.isSmooth)return P.isScrolling=!1,void P.animate.stop();o.preventDefault();var a=i;\"both\"===P.options.gestureOrientation?a=Math.abs(i)>Math.abs(e)?i:e:\"horizontal\"===P.options.gestureOrientation&&(a=e);var c=s&&P.options.syncTouch,p=s&&\"touchend\"===o.type&&Math.abs(a)>5;p&&(a=P.velocity*P.options.touchInertiaMultiplier),P.scrollTo(P.targetScroll+a,__assign({programmatic:!1},c?{lerp:p?P.options.syncTouchLerp:1}:{lerp:P.options.lerp,duration:P.options.duration,easing:P.options.easing}))}}}}},this.onNativeScroll=function(){if(!P.__preventNextScrollEvent&&!P.isScrolling){var t=P.animatedScroll;P.animatedScroll=P.targetScroll=P.actualScroll,P.velocity=0,P.direction=Math.sign(P.animatedScroll-t),P.emit()}},window.lenisVersion=\"1.0.45\",o!==document.documentElement&&o!==document.body||(o=window),this.options={wrapper:o,content:n,wheelEventsTarget:l,eventsTarget:a,smoothWheel:p,syncTouch:d,syncTouchLerp:v,touchInertiaMultiplier:f,duration:S,easing:y,lerp:L,infinite:z,gestureOrientation:R,orientation:T,touchMultiplier:W,wheelMultiplier:H,autoResize:k,__experimental__naiveDimensions:j},this.animate=new Animate,this.emitter=new Emitter,this.dimensions=new Dimensions({wrapper:o,content:n,autoResize:k}),this.toggleClassName(\"lenis\",!0),this.velocity=0,this.isLocked=!1,this.isStopped=!1,this.isSmooth=d||p,this.isScrolling=!1,this.targetScroll=this.animatedScroll=this.actualScroll,this.options.wrapper.addEventListener(\"scroll\",this.onNativeScroll,!1),this.virtualScroll=new VirtualScroll(a,{touchMultiplier:W,wheelMultiplier:H}),this.virtualScroll.on(\"scroll\",this.onVirtualScroll)}return Lenis.prototype.destroy=function(){this.emitter.destroy(),this.options.wrapper.removeEventListener(\"scroll\",this.onNativeScroll,!1),this.virtualScroll.destroy(),this.dimensions.destroy(),this.toggleClassName(\"lenis\",!1),this.toggleClassName(\"lenis-smooth\",!1),this.toggleClassName(\"lenis-scrolling\",!1),this.toggleClassName(\"lenis-stopped\",!1),this.toggleClassName(\"lenis-locked\",!1)},Lenis.prototype.on=function(t,e){return this.emitter.on(t,e)},Lenis.prototype.off=function(t,e){return this.emitter.off(t,e)},Lenis.prototype.setScroll=function(t){this.isHorizontal?this.rootElement.scrollLeft=t:this.rootElement.scrollTop=t},Lenis.prototype.resize=function(){this.dimensions.resize()},Lenis.prototype.emit=function(){this.emitter.emit(\"scroll\",this)},Lenis.prototype.reset=function(){this.isLocked=!1,this.isScrolling=!1,this.animatedScroll=this.targetScroll=this.actualScroll,this.velocity=0,this.animate.stop()},Lenis.prototype.start=function(){this.isStopped&&(this.isStopped=!1,this.reset())},Lenis.prototype.stop=function(){this.isStopped||(this.isStopped=!0,this.animate.stop(),this.reset())},Lenis.prototype.raf=function(t){var e=t-(this.time||t);this.time=t,this.animate.advance(.001*e)},Lenis.prototype.scrollTo=function(t,e){var i=this,o=void 0===e?{}:e,s=o.offset,n=void 0===s?0:s,r=o.immediate,l=void 0!==r&&r,h=o.lock,a=void 0!==h&&h,c=o.duration,p=void 0===c?this.options.duration:c,u=o.easing,d=void 0===u?this.options.easing:u,m=o.lerp,v=void 0===m?!p&&this.options.lerp:m,g=o.onComplete,f=o.force,S=void 0!==f&&f,w=o.programmatic,y=void 0===w||w;if(!this.isStopped&&!this.isLocked||S){if([\"top\",\"left\",\"start\"].includes(t))t=0;else if([\"bottom\",\"right\",\"end\"].includes(t))t=this.limit;else{var b=void 0;if(\"string\"==typeof t?b=document.querySelector(t):(null==t?void 0:t.nodeType)&&(b=t),b){if(this.options.wrapper!==window){var L=this.options.wrapper.getBoundingClientRect();n-=this.isHorizontal?L.left:L.top}var _=b.getBoundingClientRect();t=(this.isHorizontal?_.left:_.top)+this.animatedScroll}}if(\"number\"==typeof t){if(t+=n,t=Math.round(t),this.options.infinite?y&&(this.targetScroll=this.animatedScroll=this.scroll):t=clamp(0,t,this.limit),l)return this.animatedScroll=this.targetScroll=t,this.setScroll(this.scroll),this.reset(),void(null==g||g(this));if(!y){if(t===this.targetScroll)return;this.targetScroll=t}this.animate.fromTo(this.animatedScroll,t,{duration:p,easing:d,lerp:v,onStart:function(){a&&(i.isLocked=!0),i.isScrolling=!0},onUpdate:function(t,e){i.isScrolling=!0,i.velocity=t-i.animatedScroll,i.direction=Math.sign(i.velocity),i.animatedScroll=t,i.setScroll(i.scroll),y&&(i.targetScroll=t),e||i.emit(),e&&(i.reset(),i.emit(),null==g||g(i),i.__preventNextScrollEvent=!0,requestAnimationFrame((function(){delete i.__preventNextScrollEvent})))}})}}},Object.defineProperty(Lenis.prototype,\"rootElement\",{get:function(){return this.options.wrapper===window?document.documentElement:this.options.wrapper},enumerable:!1,configurable:!0}),Object.defineProperty(Lenis.prototype,\"limit\",{get:function(){return this.options.__experimental__naiveDimensions?this.isHorizontal?this.rootElement.scrollWidth-this.rootElement.clientWidth:this.rootElement.scrollHeight-this.rootElement.clientHeight:this.dimensions.limit[this.isHorizontal?\"x\":\"y\"]},enumerable:!1,configurable:!0}),Object.defineProperty(Lenis.prototype,\"isHorizontal\",{get:function(){return\"horizontal\"===this.options.orientation},enumerable:!1,configurable:!0}),Object.defineProperty(Lenis.prototype,\"actualScroll\",{get:function(){return this.isHorizontal?this.rootElement.scrollLeft:this.rootElement.scrollTop},enumerable:!1,configurable:!0}),Object.defineProperty(Lenis.prototype,\"scroll\",{get:function(){return this.options.infinite?function modulo(t,e){return(t%e+e)%e}(this.animatedScroll,this.limit):this.animatedScroll},enumerable:!1,configurable:!0}),Object.defineProperty(Lenis.prototype,\"progress\",{get:function(){return 0===this.limit?1:this.scroll/this.limit},enumerable:!1,configurable:!0}),Object.defineProperty(Lenis.prototype,\"isSmooth\",{get:function(){return this.__isSmooth},set:function(t){this.__isSmooth!==t&&(this.__isSmooth=t,this.toggleClassName(\"lenis-smooth\",t))},enumerable:!1,configurable:!0}),Object.defineProperty(Lenis.prototype,\"isScrolling\",{get:function(){return this.__isScrolling},set:function(t){this.__isScrolling!==t&&(this.__isScrolling=t,this.toggleClassName(\"lenis-scrolling\",t))},enumerable:!1,configurable:!0}),Object.defineProperty(Lenis.prototype,\"isStopped\",{get:function(){return this.__isStopped},set:function(t){this.__isStopped!==t&&(this.__isStopped=t,this.toggleClassName(\"lenis-stopped\",t))},enumerable:!1,configurable:!0}),Object.defineProperty(Lenis.prototype,\"isLocked\",{get:function(){return this.__isLocked},set:function(t){this.__isLocked!==t&&(this.__isLocked=t,this.toggleClassName(\"lenis-locked\",t))},enumerable:!1,configurable:!0}),Object.defineProperty(Lenis.prototype,\"className\",{get:function(){var t=\"lenis\";return this.isStopped&&(t+=\" lenis-stopped\"),this.isLocked&&(t+=\" lenis-locked\"),this.isScrolling&&(t+=\" lenis-scrolling\"),this.isSmooth&&(t+=\" lenis-smooth\"),t},enumerable:!1,configurable:!0}),Lenis.prototype.toggleClassName=function(t,e){this.rootElement.classList.toggle(t,e),this.emitter.emit(\"className change\",this)},Lenis}();\n//# sourceMappingURL=lenis.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9sZW5pc0AxLjAuNDVfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvbGVuaXMvZGlzdC9sZW5pcy5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHdCQUF3QixvREFBb0QsaUNBQWlDLElBQUksdUZBQXVGLFNBQVMsaUNBQWlDLG9EQUFvRCxzQkFBc0IsaUNBQWlDLGNBQWMsV0FBVywwQkFBMEIsU0FBUywrQ0FBK0MsNEJBQTRCLGtCQUFrQix1QkFBdUIsZ0dBQWdHLEtBQUssb0JBQW9CLGtEQUFrRCxPQUFPLDJCQUEyQiwyQ0FBMkMsNkNBQTZDLE9BQU8sa0JBQWtCLFlBQVksNERBQTRELEVBQUUsdUlBQXVJLGlCQUFpQixhQUFhLG1EQUFtRCxHQUFHLEVBQUUsOEVBQThFLE1BQU0sa0JBQWtCLHVCQUF1Qix5Q0FBeUMsYUFBYSxNQUFNLDJWQUEyVixVQUFVLCtJQUErSSxZQUFZLCtDQUErQyxxQkFBcUIsaUtBQWlLLHFCQUFxQix1TUFBdU0sWUFBWSxPQUFPLGdFQUFnRSxjQUFjLGNBQWMsZUFBZSxhQUFhLHlCQUF5Qix1QkFBdUIsSUFBSSxlQUFlLFFBQVEsMERBQTBELG1EQUFtRCxTQUFTLGtEQUFrRCxVQUFVLGdCQUFnQixjQUFjLG9CQUFvQixlQUFlLHdDQUF3QyxFQUFFLDhFQUE4RSxjQUFjLDZKQUE2SixXQUFXLGdFQUFnRSxXQUFXLDhEQUE4RCxXQUFXLDREQUE0RCxXQUFXLEVBQUUsUUFBUSw0QkFBNEIsVUFBVSwwSUFBMEksV0FBVyxtRUFBbUUsV0FBVyxpRUFBaUUsV0FBVywrREFBK0QsV0FBVyxFQUFFLGlCQUFpQixNQUFNLG9CQUFvQixzQ0FBc0Msd0RBQXdELFFBQVEsNkJBQTZCLDBCQUEwQixHQUFHLGdCQUFnQixNQUFNLG9CQUFvQixrSUFBa0ksd0RBQXdELFFBQVEsNkJBQTZCLDBCQUEwQixHQUFHLGVBQWUsNEJBQTRCLHdEQUF3RCxHQUFHLFlBQVksSUFBSSw4QkFBOEIsR0FBRyxxSkFBcUosMEJBQTBCLEdBQUcsb0JBQW9CLHlFQUF5RSxpQkFBaUIsa0JBQWtCLG1CQUFtQixvV0FBb1csMkNBQTJDLDhUQUE4VCxpSEFBaUgsb0NBQW9DLGVBQWUsMERBQTBELHNGQUFzRixLQUFLLDBIQUEwSCxXQUFXLHVCQUF1Qiw4REFBOEQsY0FBYywrWUFBK1ksaURBQWlELEtBQUsseUhBQXlILG1CQUFtQixRQUFRLHVIQUF1SCxxRUFBcUUseUZBQXlGLGdCQUFnQixJQUFJLGlDQUFpQyxFQUFFLHdFQUF3RSxPQUFPLGdDQUFnQyxnREFBZ0QsdUJBQXVCLGdIQUFnSCx3R0FBd0csc1JBQXNSLG1GQUFtRixpQ0FBaUMsb1NBQW9TLG9DQUFvQyx1REFBdUQsMENBQTBDLDZWQUE2VixrQ0FBa0MsNEJBQTRCLG1DQUFtQyw2QkFBNkIsdUNBQXVDLDZFQUE2RSxtQ0FBbUMseUJBQXlCLGlDQUFpQyxpQ0FBaUMsa0NBQWtDLGlJQUFpSSxrQ0FBa0MsaURBQWlELGlDQUFpQyxxRUFBcUUsaUNBQWlDLHVCQUF1Qix5Q0FBeUMsd0NBQXdDLDBCQUEwQiw4U0FBOFMsdUNBQXVDLDBDQUEwQywwREFBMEQsS0FBSyxhQUFhLHdGQUF3RixrQ0FBa0MsbURBQW1ELGtDQUFrQyxnQ0FBZ0Msd0RBQXdELHVCQUF1Qiw4T0FBOE8sT0FBTyxnQ0FBZ0Msb0JBQW9CLDJDQUEyQyw4Q0FBOEMsb0NBQW9DLHdCQUF3QixpUUFBaVEsa0NBQWtDLEtBQUssSUFBSSxzREFBc0QsZUFBZSxtRkFBbUYsK0JBQStCLGlEQUFpRCxlQUFlLDZPQUE2TywrQkFBK0Isd0RBQXdELGVBQWUsOENBQThDLCtCQUErQix3REFBd0QsZUFBZSxnRkFBZ0YsK0JBQStCLGtEQUFrRCxlQUFlLGtEQUFrRCxnQkFBZ0IscURBQXFELCtCQUErQixvREFBb0QsZUFBZSwrQ0FBK0MsK0JBQStCLG9EQUFvRCxlQUFlLHVCQUF1QixpQkFBaUIsZ0ZBQWdGLCtCQUErQix1REFBdUQsZUFBZSwwQkFBMEIsaUJBQWlCLHlGQUF5RiwrQkFBK0IscURBQXFELGVBQWUsd0JBQXdCLGlCQUFpQixtRkFBbUYsK0JBQStCLG9EQUFvRCxlQUFlLHVCQUF1QixpQkFBaUIsZ0ZBQWdGLCtCQUErQixxREFBcUQsZUFBZSxjQUFjLGlLQUFpSywrQkFBK0IsZ0RBQWdELGtGQUFrRixPQUFPLEdBQXdCO0FBQzdpYSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbGVuaXNAMS4wLjQ1X3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL2xlbmlzL2Rpc3QvbGVuaXMubWpzPzIwNTIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXNzaWduPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXNzaWduPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uIF9fYXNzaWduKHQpe2Zvcih2YXIgZSxpPTEsbz1hcmd1bWVudHMubGVuZ3RoO2k8bztpKyspZm9yKHZhciBzIGluIGU9YXJndW1lbnRzW2ldKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHMpJiYodFtzXT1lW3NdKTtyZXR1cm4gdH0sX19hc3NpZ24uYXBwbHkodGhpcyxhcmd1bWVudHMpfTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBTdXBwcmVzc2VkRXJyb3ImJlN1cHByZXNzZWRFcnJvcjtmdW5jdGlvbiBjbGFtcCh0LGUsaSl7cmV0dXJuIE1hdGgubWF4KHQsTWF0aC5taW4oZSxpKSl9Y2xhc3MgQW5pbWF0ZXthZHZhbmNlKHQpe2lmKCF0aGlzLmlzUnVubmluZylyZXR1cm47bGV0IGU9ITE7aWYodGhpcy5sZXJwKXRoaXMudmFsdWU9ZnVuY3Rpb24gZGFtcCh0LGUsaSxvKXtyZXR1cm4gZnVuY3Rpb24gbGVycCh0LGUsaSl7cmV0dXJuKDEtaSkqdCtpKmV9KHQsZSwxLU1hdGguZXhwKC1pKm8pKX0odGhpcy52YWx1ZSx0aGlzLnRvLDYwKnRoaXMubGVycCx0KSxNYXRoLnJvdW5kKHRoaXMudmFsdWUpPT09dGhpcy50byYmKHRoaXMudmFsdWU9dGhpcy50byxlPSEwKTtlbHNle3RoaXMuY3VycmVudFRpbWUrPXQ7Y29uc3QgaT1jbGFtcCgwLHRoaXMuY3VycmVudFRpbWUvdGhpcy5kdXJhdGlvbiwxKTtlPWk+PTE7Y29uc3Qgbz1lPzE6dGhpcy5lYXNpbmcoaSk7dGhpcy52YWx1ZT10aGlzLmZyb20rKHRoaXMudG8tdGhpcy5mcm9tKSpvfWUmJnRoaXMuc3RvcCgpLHRoaXMub25VcGRhdGU/Lih0aGlzLnZhbHVlLGUpfXN0b3AoKXt0aGlzLmlzUnVubmluZz0hMX1mcm9tVG8odCxlLHtsZXJwOmk9LjEsZHVyYXRpb246bz0xLGVhc2luZzpzPSh0PT50KSxvblN0YXJ0Om4sb25VcGRhdGU6cn0pe3RoaXMuZnJvbT10aGlzLnZhbHVlPXQsdGhpcy50bz1lLHRoaXMubGVycD1pLHRoaXMuZHVyYXRpb249byx0aGlzLmVhc2luZz1zLHRoaXMuY3VycmVudFRpbWU9MCx0aGlzLmlzUnVubmluZz0hMCxuPy4oKSx0aGlzLm9uVXBkYXRlPXJ9fWNsYXNzIERpbWVuc2lvbnN7Y29uc3RydWN0b3Ioe3dyYXBwZXI6dCxjb250ZW50OmUsYXV0b1Jlc2l6ZTppPSEwLGRlYm91bmNlOm89MjUwfT17fSl7dGhpcy53cmFwcGVyPXQsdGhpcy5jb250ZW50PWUsaSYmKHRoaXMuZGVib3VuY2VkUmVzaXplPWZ1bmN0aW9uIGRlYm91bmNlKHQsZSl7bGV0IGk7cmV0dXJuIGZ1bmN0aW9uKCl7bGV0IG89YXJndW1lbnRzLHM9dGhpcztjbGVhclRpbWVvdXQoaSksaT1zZXRUaW1lb3V0KChmdW5jdGlvbigpe3QuYXBwbHkocyxvKX0pLGUpfX0odGhpcy5yZXNpemUsbyksdGhpcy53cmFwcGVyPT09d2luZG93P3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5kZWJvdW5jZWRSZXNpemUsITEpOih0aGlzLndyYXBwZXJSZXNpemVPYnNlcnZlcj1uZXcgUmVzaXplT2JzZXJ2ZXIodGhpcy5kZWJvdW5jZWRSZXNpemUpLHRoaXMud3JhcHBlclJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy53cmFwcGVyKSksdGhpcy5jb250ZW50UmVzaXplT2JzZXJ2ZXI9bmV3IFJlc2l6ZU9ic2VydmVyKHRoaXMuZGVib3VuY2VkUmVzaXplKSx0aGlzLmNvbnRlbnRSZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuY29udGVudCkpLHRoaXMucmVzaXplKCl9ZGVzdHJveSgpe3RoaXMud3JhcHBlclJlc2l6ZU9ic2VydmVyPy5kaXNjb25uZWN0KCksdGhpcy5jb250ZW50UmVzaXplT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHRoaXMuZGVib3VuY2VkUmVzaXplLCExKX1yZXNpemU9KCk9Pnt0aGlzLm9uV3JhcHBlclJlc2l6ZSgpLHRoaXMub25Db250ZW50UmVzaXplKCl9O29uV3JhcHBlclJlc2l6ZT0oKT0+e3RoaXMud3JhcHBlcj09PXdpbmRvdz8odGhpcy53aWR0aD13aW5kb3cuaW5uZXJXaWR0aCx0aGlzLmhlaWdodD13aW5kb3cuaW5uZXJIZWlnaHQpOih0aGlzLndpZHRoPXRoaXMud3JhcHBlci5jbGllbnRXaWR0aCx0aGlzLmhlaWdodD10aGlzLndyYXBwZXIuY2xpZW50SGVpZ2h0KX07b25Db250ZW50UmVzaXplPSgpPT57dGhpcy53cmFwcGVyPT09d2luZG93Pyh0aGlzLnNjcm9sbEhlaWdodD10aGlzLmNvbnRlbnQuc2Nyb2xsSGVpZ2h0LHRoaXMuc2Nyb2xsV2lkdGg9dGhpcy5jb250ZW50LnNjcm9sbFdpZHRoKToodGhpcy5zY3JvbGxIZWlnaHQ9dGhpcy53cmFwcGVyLnNjcm9sbEhlaWdodCx0aGlzLnNjcm9sbFdpZHRoPXRoaXMud3JhcHBlci5zY3JvbGxXaWR0aCl9O2dldCBsaW1pdCgpe3JldHVybnt4OnRoaXMuc2Nyb2xsV2lkdGgtdGhpcy53aWR0aCx5OnRoaXMuc2Nyb2xsSGVpZ2h0LXRoaXMuaGVpZ2h0fX19Y2xhc3MgRW1pdHRlcntjb25zdHJ1Y3Rvcigpe3RoaXMuZXZlbnRzPXt9fWVtaXQodCwuLi5lKXtsZXQgaT10aGlzLmV2ZW50c1t0XXx8W107Zm9yKGxldCB0PTAsbz1pLmxlbmd0aDt0PG87dCsrKWlbdF0oLi4uZSl9b24odCxlKXtyZXR1cm4gdGhpcy5ldmVudHNbdF0/LnB1c2goZSl8fCh0aGlzLmV2ZW50c1t0XT1bZV0pLCgpPT57dGhpcy5ldmVudHNbdF09dGhpcy5ldmVudHNbdF0/LmZpbHRlcigodD0+ZSE9PXQpKX19b2ZmKHQsZSl7dGhpcy5ldmVudHNbdF09dGhpcy5ldmVudHNbdF0/LmZpbHRlcigodD0+ZSE9PXQpKX1kZXN0cm95KCl7dGhpcy5ldmVudHM9e319fWNvbnN0IHQ9MTAwLzY7Y2xhc3MgVmlydHVhbFNjcm9sbHtjb25zdHJ1Y3Rvcih0LHt3aGVlbE11bHRpcGxpZXI6ZT0xLHRvdWNoTXVsdGlwbGllcjppPTF9KXt0aGlzLmVsZW1lbnQ9dCx0aGlzLndoZWVsTXVsdGlwbGllcj1lLHRoaXMudG91Y2hNdWx0aXBsaWVyPWksdGhpcy50b3VjaFN0YXJ0PXt4Om51bGwseTpudWxsfSx0aGlzLmVtaXR0ZXI9bmV3IEVtaXR0ZXIsd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIix0aGlzLm9uV2luZG93UmVzaXplLCExKSx0aGlzLm9uV2luZG93UmVzaXplKCksdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLHRoaXMub25XaGVlbCx7cGFzc2l2ZTohMX0pLHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLHRoaXMub25Ub3VjaFN0YXJ0LHtwYXNzaXZlOiExfSksdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIix0aGlzLm9uVG91Y2hNb3ZlLHtwYXNzaXZlOiExfSksdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLHRoaXMub25Ub3VjaEVuZCx7cGFzc2l2ZTohMX0pfW9uKHQsZSl7cmV0dXJuIHRoaXMuZW1pdHRlci5vbih0LGUpfWRlc3Ryb3koKXt0aGlzLmVtaXR0ZXIuZGVzdHJveSgpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5vbldpbmRvd1Jlc2l6ZSwhMSksdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLHRoaXMub25XaGVlbCx7cGFzc2l2ZTohMX0pLHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLHRoaXMub25Ub3VjaFN0YXJ0LHtwYXNzaXZlOiExfSksdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIix0aGlzLm9uVG91Y2hNb3ZlLHtwYXNzaXZlOiExfSksdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLHRoaXMub25Ub3VjaEVuZCx7cGFzc2l2ZTohMX0pfW9uVG91Y2hTdGFydD10PT57Y29uc3R7Y2xpZW50WDplLGNsaWVudFk6aX09dC50YXJnZXRUb3VjaGVzP3QudGFyZ2V0VG91Y2hlc1swXTp0O3RoaXMudG91Y2hTdGFydC54PWUsdGhpcy50b3VjaFN0YXJ0Lnk9aSx0aGlzLmxhc3REZWx0YT17eDowLHk6MH0sdGhpcy5lbWl0dGVyLmVtaXQoXCJzY3JvbGxcIix7ZGVsdGFYOjAsZGVsdGFZOjAsZXZlbnQ6dH0pfTtvblRvdWNoTW92ZT10PT57Y29uc3R7Y2xpZW50WDplLGNsaWVudFk6aX09dC50YXJnZXRUb3VjaGVzP3QudGFyZ2V0VG91Y2hlc1swXTp0LG89LShlLXRoaXMudG91Y2hTdGFydC54KSp0aGlzLnRvdWNoTXVsdGlwbGllcixzPS0oaS10aGlzLnRvdWNoU3RhcnQueSkqdGhpcy50b3VjaE11bHRpcGxpZXI7dGhpcy50b3VjaFN0YXJ0Lng9ZSx0aGlzLnRvdWNoU3RhcnQueT1pLHRoaXMubGFzdERlbHRhPXt4Om8seTpzfSx0aGlzLmVtaXR0ZXIuZW1pdChcInNjcm9sbFwiLHtkZWx0YVg6byxkZWx0YVk6cyxldmVudDp0fSl9O29uVG91Y2hFbmQ9dD0+e3RoaXMuZW1pdHRlci5lbWl0KFwic2Nyb2xsXCIse2RlbHRhWDp0aGlzLmxhc3REZWx0YS54LGRlbHRhWTp0aGlzLmxhc3REZWx0YS55LGV2ZW50OnR9KX07b25XaGVlbD1lPT57bGV0e2RlbHRhWDppLGRlbHRhWTpvLGRlbHRhTW9kZTpzfT1lO2kqPTE9PT1zP3Q6Mj09PXM/dGhpcy53aW5kb3dXaWR0aDoxLG8qPTE9PT1zP3Q6Mj09PXM/dGhpcy53aW5kb3dIZWlnaHQ6MSxpKj10aGlzLndoZWVsTXVsdGlwbGllcixvKj10aGlzLndoZWVsTXVsdGlwbGllcix0aGlzLmVtaXR0ZXIuZW1pdChcInNjcm9sbFwiLHtkZWx0YVg6aSxkZWx0YVk6byxldmVudDplfSl9O29uV2luZG93UmVzaXplPSgpPT57dGhpcy53aW5kb3dXaWR0aD13aW5kb3cuaW5uZXJXaWR0aCx0aGlzLndpbmRvd0hlaWdodD13aW5kb3cuaW5uZXJIZWlnaHR9fXZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gTGVuaXModCl7dmFyIGU9dm9pZCAwPT09dD97fTp0LGk9ZS53cmFwcGVyLG89dm9pZCAwPT09aT93aW5kb3c6aSxzPWUuY29udGVudCxuPXZvaWQgMD09PXM/ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OnMscj1lLndoZWVsRXZlbnRzVGFyZ2V0LGw9dm9pZCAwPT09cj9vOnIsaD1lLmV2ZW50c1RhcmdldCxhPXZvaWQgMD09PWg/bDpoLGM9ZS5zbW9vdGhXaGVlbCxwPXZvaWQgMD09PWN8fGMsdT1lLnN5bmNUb3VjaCxkPXZvaWQgMCE9PXUmJnUsbT1lLnN5bmNUb3VjaExlcnAsdj12b2lkIDA9PT1tPy4wNzU6bSxnPWUudG91Y2hJbmVydGlhTXVsdGlwbGllcixmPXZvaWQgMD09PWc/MzU6ZyxTPWUuZHVyYXRpb24sdz1lLmVhc2luZyx5PXZvaWQgMD09PXc/ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGgubWluKDEsMS4wMDEtTWF0aC5wb3coMiwtMTAqdCkpfTp3LGI9ZS5sZXJwLEw9dm9pZCAwPT09Yj8hUyYmLjE6YixfPWUuaW5maW5pdGUsej12b2lkIDAhPT1fJiZfLEU9ZS5vcmllbnRhdGlvbixUPXZvaWQgMD09PUU/XCJ2ZXJ0aWNhbFwiOkUsTT1lLmdlc3R1cmVPcmllbnRhdGlvbixSPXZvaWQgMD09PU0/XCJ2ZXJ0aWNhbFwiOk0sTz1lLnRvdWNoTXVsdGlwbGllcixXPXZvaWQgMD09PU8/MTpPLHg9ZS53aGVlbE11bHRpcGxpZXIsSD12b2lkIDA9PT14PzE6eCxOPWUuYXV0b1Jlc2l6ZSxrPXZvaWQgMD09PU58fE4sQz1lLl9fZXhwZXJpbWVudGFsX19uYWl2ZURpbWVuc2lvbnMsaj12b2lkIDAhPT1DJiZDLFA9dGhpczt0aGlzLl9faXNTbW9vdGg9ITEsdGhpcy5fX2lzU2Nyb2xsaW5nPSExLHRoaXMuX19pc1N0b3BwZWQ9ITEsdGhpcy5fX2lzTG9ja2VkPSExLHRoaXMub25WaXJ0dWFsU2Nyb2xsPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZGVsdGFYLGk9dC5kZWx0YVksbz10LmV2ZW50O2lmKCFvLmN0cmxLZXkpe3ZhciBzPW8udHlwZS5pbmNsdWRlcyhcInRvdWNoXCIpLG49by50eXBlLmluY2x1ZGVzKFwid2hlZWxcIik7aWYoUC5vcHRpb25zLnN5bmNUb3VjaCYmcyYmXCJ0b3VjaHN0YXJ0XCI9PT1vLnR5cGUmJiFQLmlzU3RvcHBlZCYmIVAuaXNMb2NrZWQpUC5yZXNldCgpO2Vsc2V7dmFyIHI9MD09PWUmJjA9PT1pLGw9XCJ2ZXJ0aWNhbFwiPT09UC5vcHRpb25zLmdlc3R1cmVPcmllbnRhdGlvbiYmMD09PWl8fFwiaG9yaXpvbnRhbFwiPT09UC5vcHRpb25zLmdlc3R1cmVPcmllbnRhdGlvbiYmMD09PWU7aWYoIXImJiFsKXt2YXIgaD1vLmNvbXBvc2VkUGF0aCgpO2lmKCEoaD1oLnNsaWNlKDAsaC5pbmRleE9mKFAucm9vdEVsZW1lbnQpKSkuZmluZCgoZnVuY3Rpb24odCl7dmFyIGUsaSxvLHIsbDtyZXR1cm4obnVsbD09PShlPXQuaGFzQXR0cmlidXRlKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5jYWxsKHQsXCJkYXRhLWxlbmlzLXByZXZlbnRcIikpfHxzJiYobnVsbD09PShpPXQuaGFzQXR0cmlidXRlKXx8dm9pZCAwPT09aT92b2lkIDA6aS5jYWxsKHQsXCJkYXRhLWxlbmlzLXByZXZlbnQtdG91Y2hcIikpfHxuJiYobnVsbD09PShvPXQuaGFzQXR0cmlidXRlKXx8dm9pZCAwPT09bz92b2lkIDA6by5jYWxsKHQsXCJkYXRhLWxlbmlzLXByZXZlbnQtd2hlZWxcIikpfHwobnVsbD09PShyPXQuY2xhc3NMaXN0KXx8dm9pZCAwPT09cj92b2lkIDA6ci5jb250YWlucyhcImxlbmlzXCIpKSYmIShudWxsPT09KGw9dC5jbGFzc0xpc3QpfHx2b2lkIDA9PT1sP3ZvaWQgMDpsLmNvbnRhaW5zKFwibGVuaXMtc3RvcHBlZFwiKSl9KSkpaWYoUC5pc1N0b3BwZWR8fFAuaXNMb2NrZWQpby5wcmV2ZW50RGVmYXVsdCgpO2Vsc2V7aWYoUC5pc1Ntb290aD1QLm9wdGlvbnMuc3luY1RvdWNoJiZzfHxQLm9wdGlvbnMuc21vb3RoV2hlZWwmJm4sIVAuaXNTbW9vdGgpcmV0dXJuIFAuaXNTY3JvbGxpbmc9ITEsdm9pZCBQLmFuaW1hdGUuc3RvcCgpO28ucHJldmVudERlZmF1bHQoKTt2YXIgYT1pO1wiYm90aFwiPT09UC5vcHRpb25zLmdlc3R1cmVPcmllbnRhdGlvbj9hPU1hdGguYWJzKGkpPk1hdGguYWJzKGUpP2k6ZTpcImhvcml6b250YWxcIj09PVAub3B0aW9ucy5nZXN0dXJlT3JpZW50YXRpb24mJihhPWUpO3ZhciBjPXMmJlAub3B0aW9ucy5zeW5jVG91Y2gscD1zJiZcInRvdWNoZW5kXCI9PT1vLnR5cGUmJk1hdGguYWJzKGEpPjU7cCYmKGE9UC52ZWxvY2l0eSpQLm9wdGlvbnMudG91Y2hJbmVydGlhTXVsdGlwbGllciksUC5zY3JvbGxUbyhQLnRhcmdldFNjcm9sbCthLF9fYXNzaWduKHtwcm9ncmFtbWF0aWM6ITF9LGM/e2xlcnA6cD9QLm9wdGlvbnMuc3luY1RvdWNoTGVycDoxfTp7bGVycDpQLm9wdGlvbnMubGVycCxkdXJhdGlvbjpQLm9wdGlvbnMuZHVyYXRpb24sZWFzaW5nOlAub3B0aW9ucy5lYXNpbmd9KSl9fX19fSx0aGlzLm9uTmF0aXZlU2Nyb2xsPWZ1bmN0aW9uKCl7aWYoIVAuX19wcmV2ZW50TmV4dFNjcm9sbEV2ZW50JiYhUC5pc1Njcm9sbGluZyl7dmFyIHQ9UC5hbmltYXRlZFNjcm9sbDtQLmFuaW1hdGVkU2Nyb2xsPVAudGFyZ2V0U2Nyb2xsPVAuYWN0dWFsU2Nyb2xsLFAudmVsb2NpdHk9MCxQLmRpcmVjdGlvbj1NYXRoLnNpZ24oUC5hbmltYXRlZFNjcm9sbC10KSxQLmVtaXQoKX19LHdpbmRvdy5sZW5pc1ZlcnNpb249XCIxLjAuNDVcIixvIT09ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZvIT09ZG9jdW1lbnQuYm9keXx8KG89d2luZG93KSx0aGlzLm9wdGlvbnM9e3dyYXBwZXI6byxjb250ZW50Om4sd2hlZWxFdmVudHNUYXJnZXQ6bCxldmVudHNUYXJnZXQ6YSxzbW9vdGhXaGVlbDpwLHN5bmNUb3VjaDpkLHN5bmNUb3VjaExlcnA6dix0b3VjaEluZXJ0aWFNdWx0aXBsaWVyOmYsZHVyYXRpb246UyxlYXNpbmc6eSxsZXJwOkwsaW5maW5pdGU6eixnZXN0dXJlT3JpZW50YXRpb246UixvcmllbnRhdGlvbjpULHRvdWNoTXVsdGlwbGllcjpXLHdoZWVsTXVsdGlwbGllcjpILGF1dG9SZXNpemU6ayxfX2V4cGVyaW1lbnRhbF9fbmFpdmVEaW1lbnNpb25zOmp9LHRoaXMuYW5pbWF0ZT1uZXcgQW5pbWF0ZSx0aGlzLmVtaXR0ZXI9bmV3IEVtaXR0ZXIsdGhpcy5kaW1lbnNpb25zPW5ldyBEaW1lbnNpb25zKHt3cmFwcGVyOm8sY29udGVudDpuLGF1dG9SZXNpemU6a30pLHRoaXMudG9nZ2xlQ2xhc3NOYW1lKFwibGVuaXNcIiwhMCksdGhpcy52ZWxvY2l0eT0wLHRoaXMuaXNMb2NrZWQ9ITEsdGhpcy5pc1N0b3BwZWQ9ITEsdGhpcy5pc1Ntb290aD1kfHxwLHRoaXMuaXNTY3JvbGxpbmc9ITEsdGhpcy50YXJnZXRTY3JvbGw9dGhpcy5hbmltYXRlZFNjcm9sbD10aGlzLmFjdHVhbFNjcm9sbCx0aGlzLm9wdGlvbnMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsdGhpcy5vbk5hdGl2ZVNjcm9sbCwhMSksdGhpcy52aXJ0dWFsU2Nyb2xsPW5ldyBWaXJ0dWFsU2Nyb2xsKGEse3RvdWNoTXVsdGlwbGllcjpXLHdoZWVsTXVsdGlwbGllcjpIfSksdGhpcy52aXJ0dWFsU2Nyb2xsLm9uKFwic2Nyb2xsXCIsdGhpcy5vblZpcnR1YWxTY3JvbGwpfXJldHVybiBMZW5pcy5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZW1pdHRlci5kZXN0cm95KCksdGhpcy5vcHRpb25zLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHRoaXMub25OYXRpdmVTY3JvbGwsITEpLHRoaXMudmlydHVhbFNjcm9sbC5kZXN0cm95KCksdGhpcy5kaW1lbnNpb25zLmRlc3Ryb3koKSx0aGlzLnRvZ2dsZUNsYXNzTmFtZShcImxlbmlzXCIsITEpLHRoaXMudG9nZ2xlQ2xhc3NOYW1lKFwibGVuaXMtc21vb3RoXCIsITEpLHRoaXMudG9nZ2xlQ2xhc3NOYW1lKFwibGVuaXMtc2Nyb2xsaW5nXCIsITEpLHRoaXMudG9nZ2xlQ2xhc3NOYW1lKFwibGVuaXMtc3RvcHBlZFwiLCExKSx0aGlzLnRvZ2dsZUNsYXNzTmFtZShcImxlbmlzLWxvY2tlZFwiLCExKX0sTGVuaXMucHJvdG90eXBlLm9uPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW1pdHRlci5vbih0LGUpfSxMZW5pcy5wcm90b3R5cGUub2ZmPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW1pdHRlci5vZmYodCxlKX0sTGVuaXMucHJvdG90eXBlLnNldFNjcm9sbD1mdW5jdGlvbih0KXt0aGlzLmlzSG9yaXpvbnRhbD90aGlzLnJvb3RFbGVtZW50LnNjcm9sbExlZnQ9dDp0aGlzLnJvb3RFbGVtZW50LnNjcm9sbFRvcD10fSxMZW5pcy5wcm90b3R5cGUucmVzaXplPWZ1bmN0aW9uKCl7dGhpcy5kaW1lbnNpb25zLnJlc2l6ZSgpfSxMZW5pcy5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbigpe3RoaXMuZW1pdHRlci5lbWl0KFwic2Nyb2xsXCIsdGhpcyl9LExlbmlzLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMuaXNMb2NrZWQ9ITEsdGhpcy5pc1Njcm9sbGluZz0hMSx0aGlzLmFuaW1hdGVkU2Nyb2xsPXRoaXMudGFyZ2V0U2Nyb2xsPXRoaXMuYWN0dWFsU2Nyb2xsLHRoaXMudmVsb2NpdHk9MCx0aGlzLmFuaW1hdGUuc3RvcCgpfSxMZW5pcy5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24oKXt0aGlzLmlzU3RvcHBlZCYmKHRoaXMuaXNTdG9wcGVkPSExLHRoaXMucmVzZXQoKSl9LExlbmlzLnByb3RvdHlwZS5zdG9wPWZ1bmN0aW9uKCl7dGhpcy5pc1N0b3BwZWR8fCh0aGlzLmlzU3RvcHBlZD0hMCx0aGlzLmFuaW1hdGUuc3RvcCgpLHRoaXMucmVzZXQoKSl9LExlbmlzLnByb3RvdHlwZS5yYWY9ZnVuY3Rpb24odCl7dmFyIGU9dC0odGhpcy50aW1lfHx0KTt0aGlzLnRpbWU9dCx0aGlzLmFuaW1hdGUuYWR2YW5jZSguMDAxKmUpfSxMZW5pcy5wcm90b3R5cGUuc2Nyb2xsVG89ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzLG89dm9pZCAwPT09ZT97fTplLHM9by5vZmZzZXQsbj12b2lkIDA9PT1zPzA6cyxyPW8uaW1tZWRpYXRlLGw9dm9pZCAwIT09ciYmcixoPW8ubG9jayxhPXZvaWQgMCE9PWgmJmgsYz1vLmR1cmF0aW9uLHA9dm9pZCAwPT09Yz90aGlzLm9wdGlvbnMuZHVyYXRpb246Yyx1PW8uZWFzaW5nLGQ9dm9pZCAwPT09dT90aGlzLm9wdGlvbnMuZWFzaW5nOnUsbT1vLmxlcnAsdj12b2lkIDA9PT1tPyFwJiZ0aGlzLm9wdGlvbnMubGVycDptLGc9by5vbkNvbXBsZXRlLGY9by5mb3JjZSxTPXZvaWQgMCE9PWYmJmYsdz1vLnByb2dyYW1tYXRpYyx5PXZvaWQgMD09PXd8fHc7aWYoIXRoaXMuaXNTdG9wcGVkJiYhdGhpcy5pc0xvY2tlZHx8Uyl7aWYoW1widG9wXCIsXCJsZWZ0XCIsXCJzdGFydFwiXS5pbmNsdWRlcyh0KSl0PTA7ZWxzZSBpZihbXCJib3R0b21cIixcInJpZ2h0XCIsXCJlbmRcIl0uaW5jbHVkZXModCkpdD10aGlzLmxpbWl0O2Vsc2V7dmFyIGI9dm9pZCAwO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0P2I9ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0KToobnVsbD09dD92b2lkIDA6dC5ub2RlVHlwZSkmJihiPXQpLGIpe2lmKHRoaXMub3B0aW9ucy53cmFwcGVyIT09d2luZG93KXt2YXIgTD10aGlzLm9wdGlvbnMud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtuLT10aGlzLmlzSG9yaXpvbnRhbD9MLmxlZnQ6TC50b3B9dmFyIF89Yi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt0PSh0aGlzLmlzSG9yaXpvbnRhbD9fLmxlZnQ6Xy50b3ApK3RoaXMuYW5pbWF0ZWRTY3JvbGx9fWlmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXtpZih0Kz1uLHQ9TWF0aC5yb3VuZCh0KSx0aGlzLm9wdGlvbnMuaW5maW5pdGU/eSYmKHRoaXMudGFyZ2V0U2Nyb2xsPXRoaXMuYW5pbWF0ZWRTY3JvbGw9dGhpcy5zY3JvbGwpOnQ9Y2xhbXAoMCx0LHRoaXMubGltaXQpLGwpcmV0dXJuIHRoaXMuYW5pbWF0ZWRTY3JvbGw9dGhpcy50YXJnZXRTY3JvbGw9dCx0aGlzLnNldFNjcm9sbCh0aGlzLnNjcm9sbCksdGhpcy5yZXNldCgpLHZvaWQobnVsbD09Z3x8Zyh0aGlzKSk7aWYoIXkpe2lmKHQ9PT10aGlzLnRhcmdldFNjcm9sbClyZXR1cm47dGhpcy50YXJnZXRTY3JvbGw9dH10aGlzLmFuaW1hdGUuZnJvbVRvKHRoaXMuYW5pbWF0ZWRTY3JvbGwsdCx7ZHVyYXRpb246cCxlYXNpbmc6ZCxsZXJwOnYsb25TdGFydDpmdW5jdGlvbigpe2EmJihpLmlzTG9ja2VkPSEwKSxpLmlzU2Nyb2xsaW5nPSEwfSxvblVwZGF0ZTpmdW5jdGlvbih0LGUpe2kuaXNTY3JvbGxpbmc9ITAsaS52ZWxvY2l0eT10LWkuYW5pbWF0ZWRTY3JvbGwsaS5kaXJlY3Rpb249TWF0aC5zaWduKGkudmVsb2NpdHkpLGkuYW5pbWF0ZWRTY3JvbGw9dCxpLnNldFNjcm9sbChpLnNjcm9sbCkseSYmKGkudGFyZ2V0U2Nyb2xsPXQpLGV8fGkuZW1pdCgpLGUmJihpLnJlc2V0KCksaS5lbWl0KCksbnVsbD09Z3x8ZyhpKSxpLl9fcHJldmVudE5leHRTY3JvbGxFdmVudD0hMCxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKGZ1bmN0aW9uKCl7ZGVsZXRlIGkuX19wcmV2ZW50TmV4dFNjcm9sbEV2ZW50fSkpKX19KX19fSxPYmplY3QuZGVmaW5lUHJvcGVydHkoTGVuaXMucHJvdG90eXBlLFwicm9vdEVsZW1lbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9ucy53cmFwcGVyPT09d2luZG93P2RvY3VtZW50LmRvY3VtZW50RWxlbWVudDp0aGlzLm9wdGlvbnMud3JhcHBlcn0sZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoTGVuaXMucHJvdG90eXBlLFwibGltaXRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5fX2V4cGVyaW1lbnRhbF9fbmFpdmVEaW1lbnNpb25zP3RoaXMuaXNIb3Jpem9udGFsP3RoaXMucm9vdEVsZW1lbnQuc2Nyb2xsV2lkdGgtdGhpcy5yb290RWxlbWVudC5jbGllbnRXaWR0aDp0aGlzLnJvb3RFbGVtZW50LnNjcm9sbEhlaWdodC10aGlzLnJvb3RFbGVtZW50LmNsaWVudEhlaWdodDp0aGlzLmRpbWVuc2lvbnMubGltaXRbdGhpcy5pc0hvcml6b250YWw/XCJ4XCI6XCJ5XCJdfSxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMZW5pcy5wcm90b3R5cGUsXCJpc0hvcml6b250YWxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCJob3Jpem9udGFsXCI9PT10aGlzLm9wdGlvbnMub3JpZW50YXRpb259LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KExlbmlzLnByb3RvdHlwZSxcImFjdHVhbFNjcm9sbFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0hvcml6b250YWw/dGhpcy5yb290RWxlbWVudC5zY3JvbGxMZWZ0OnRoaXMucm9vdEVsZW1lbnQuc2Nyb2xsVG9wfSxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMZW5pcy5wcm90b3R5cGUsXCJzY3JvbGxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5pbmZpbml0ZT9mdW5jdGlvbiBtb2R1bG8odCxlKXtyZXR1cm4odCVlK2UpJWV9KHRoaXMuYW5pbWF0ZWRTY3JvbGwsdGhpcy5saW1pdCk6dGhpcy5hbmltYXRlZFNjcm9sbH0sZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoTGVuaXMucHJvdG90eXBlLFwicHJvZ3Jlc3NcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLmxpbWl0PzE6dGhpcy5zY3JvbGwvdGhpcy5saW1pdH0sZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoTGVuaXMucHJvdG90eXBlLFwiaXNTbW9vdGhcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX19pc1Ntb290aH0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX19pc1Ntb290aCE9PXQmJih0aGlzLl9faXNTbW9vdGg9dCx0aGlzLnRvZ2dsZUNsYXNzTmFtZShcImxlbmlzLXNtb290aFwiLHQpKX0sZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoTGVuaXMucHJvdG90eXBlLFwiaXNTY3JvbGxpbmdcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX19pc1Njcm9sbGluZ30sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX19pc1Njcm9sbGluZyE9PXQmJih0aGlzLl9faXNTY3JvbGxpbmc9dCx0aGlzLnRvZ2dsZUNsYXNzTmFtZShcImxlbmlzLXNjcm9sbGluZ1wiLHQpKX0sZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoTGVuaXMucHJvdG90eXBlLFwiaXNTdG9wcGVkXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9faXNTdG9wcGVkfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fX2lzU3RvcHBlZCE9PXQmJih0aGlzLl9faXNTdG9wcGVkPXQsdGhpcy50b2dnbGVDbGFzc05hbWUoXCJsZW5pcy1zdG9wcGVkXCIsdCkpfSxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMZW5pcy5wcm90b3R5cGUsXCJpc0xvY2tlZFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fX2lzTG9ja2VkfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fX2lzTG9ja2VkIT09dCYmKHRoaXMuX19pc0xvY2tlZD10LHRoaXMudG9nZ2xlQ2xhc3NOYW1lKFwibGVuaXMtbG9ja2VkXCIsdCkpfSxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMZW5pcy5wcm90b3R5cGUsXCJjbGFzc05hbWVcIix7Z2V0OmZ1bmN0aW9uKCl7dmFyIHQ9XCJsZW5pc1wiO3JldHVybiB0aGlzLmlzU3RvcHBlZCYmKHQrPVwiIGxlbmlzLXN0b3BwZWRcIiksdGhpcy5pc0xvY2tlZCYmKHQrPVwiIGxlbmlzLWxvY2tlZFwiKSx0aGlzLmlzU2Nyb2xsaW5nJiYodCs9XCIgbGVuaXMtc2Nyb2xsaW5nXCIpLHRoaXMuaXNTbW9vdGgmJih0Kz1cIiBsZW5pcy1zbW9vdGhcIiksdH0sZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxMZW5pcy5wcm90b3R5cGUudG9nZ2xlQ2xhc3NOYW1lPWZ1bmN0aW9uKHQsZSl7dGhpcy5yb290RWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKHQsZSksdGhpcy5lbWl0dGVyLmVtaXQoXCJjbGFzc05hbWUgY2hhbmdlXCIsdGhpcyl9LExlbmlzfSgpO2V4cG9ydHtlIGFzIGRlZmF1bHR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVuaXMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/lenis@1.0.45_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/lenis/dist/lenis.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["css-src_components_typography_typography_scss-src_components_ui_container_Styles_scss-node_mo-774d2c","css-src_components_callback_Callback_module_scss-src_components_contact_contact_module_scss-s-399a2a","css-src_styles_globals_scss-src_components_footer_styles_module_scss-src_components_header_st-1e9007","main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Cnode_modules%5C%5C.pnpm%5C%5Cnext%4014.2.1_react-dom%4018.3.1_react%4018.3.1__react%4018.3.1_sass%401.77.2%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Cimage-component.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Cnode_modules%5C%5C.pnpm%5C%5Cnext%4014.2.1_react-dom%4018.3.1_react%4018.3.1__react%4018.3.1_sass%401.77.2%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Clink.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Cnode_modules%5C%5C.pnpm%5C%5Cnext%4014.2.1_react-dom%4018.3.1_react%4018.3.1__react%4018.3.1_sass%401.77.2%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Clocal%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%5C%5C%5C%5Capp%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22src%5C%22%3A%5B%7B%5C%22path%5C%22%3A%5C%22..%2Ffonts%2FIntroBlackCaps.ttf%5C%22%7D%2C%7B%5C%22path%5C%22%3A%5C%22..%2Ffonts%2FIntroBlackCaps.woff%5C%22%7D%2C%7B%5C%22path%5C%22%3A%5C%22..%2Ffonts%2FIntroBlackCaps.woff2%5C%22%7D%5D%2C%5C%22variable%5C%22%3A%5C%22--font-intro%5C%22%2C%5C%22style%5C%22%3A%5C%22normal%5C%22%2C%5C%22weight%5C%22%3A%5C%22900%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22intro%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Cnode_modules%5C%5C.pnpm%5C%5Cnext%4014.2.1_react-dom%4018.3.1_react%4018.3.1__react%4018.3.1_sass%401.77.2%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%5C%5C%5C%5Capp%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Montserrat%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%2C%5C%22cyrillic%5C%22%5D%2C%5C%22variable%5C%22%3A%5C%22--font-montserrat%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22montserrat%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cheader%5C%5CHeader.tsx%22%2C%22ids%22%3A%5B%22Header%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cui%5C%5Ccontainer%5C%5CStyles.scss%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cfooter%5C%5Cstyles.module.scss%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Cproviders%5C%5Cproviders.tsx%22%2C%22ids%22%3A%5B%22Providers%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Cstyles%5C%5Cglobals.scss%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);