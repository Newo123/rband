/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cabout%5C%5CAbout.tsx%22%2C%22ids%22%3A%5B%22About%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cdescriptor%5C%5CDescriptor.tsx%22%2C%22ids%22%3A%5B%22Descriptor%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cmotivations%5C%5CMotivations.tsx%22%2C%22ids%22%3A%5B%22Motivations%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cour-projects%5C%5CProjects.tsx%22%2C%22ids%22%3A%5B%22Projects%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cpartners%5C%5CPartners.tsx%22%2C%22ids%22%3A%5B%22Partners%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cui%5C%5CHeading%5C%5CHeading.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cui%5C%5Creference%5C%5CReference.tsx%22%2C%22ids%22%3A%5B%22Reference%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cuseful%5C%5CUseful.module.scss%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cuseful%5C%5CUsefulSlider.tsx%22%2C%22ids%22%3A%5B%22UsefulSlider%22%5D%7D&server=false!":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cabout%5C%5CAbout.tsx%22%2C%22ids%22%3A%5B%22About%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cdescriptor%5C%5CDescriptor.tsx%22%2C%22ids%22%3A%5B%22Descriptor%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cmotivations%5C%5CMotivations.tsx%22%2C%22ids%22%3A%5B%22Motivations%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cour-projects%5C%5CProjects.tsx%22%2C%22ids%22%3A%5B%22Projects%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cpartners%5C%5CPartners.tsx%22%2C%22ids%22%3A%5B%22Partners%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cui%5C%5CHeading%5C%5CHeading.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cui%5C%5Creference%5C%5CReference.tsx%22%2C%22ids%22%3A%5B%22Reference%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cuseful%5C%5CUseful.module.scss%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cuseful%5C%5CUsefulSlider.tsx%22%2C%22ids%22%3A%5B%22UsefulSlider%22%5D%7D&server=false! ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/about/About.tsx */ \"(app-pages-browser)/./src/components/about/About.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/descriptor/Descriptor.tsx */ \"(app-pages-browser)/./src/components/descriptor/Descriptor.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/motivations/Motivations.tsx */ \"(app-pages-browser)/./src/components/motivations/Motivations.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/our-projects/Projects.tsx */ \"(app-pages-browser)/./src/components/our-projects/Projects.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/partners/Partners.tsx */ \"(app-pages-browser)/./src/components/partners/Partners.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/ui/Heading/Heading.tsx */ \"(app-pages-browser)/./src/components/ui/Heading/Heading.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/ui/reference/Reference.tsx */ \"(app-pages-browser)/./src/components/ui/reference/Reference.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./src/components/useful/Useful.module.scss */ \"(app-pages-browser)/./src/components/useful/Useful.module.scss\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/useful/UsefulSlider.tsx */ \"(app-pages-browser)/./src/components/useful/UsefulSlider.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDNzk1MzMlNUMlNUNEZXNrdG9wJTVDJTVDZnJvbnQtcmJhbmQlNUMlNUNyYmFuZCU1QyU1Q3NyYyU1QyU1Q2NvbXBvbmVudHMlNUMlNUNhYm91dCU1QyU1Q0Fib3V0LnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiUyMkFib3V0JTIyJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkMlM0ElNUMlNUNVc2VycyU1QyU1Qzc5NTMzJTVDJTVDRGVza3RvcCU1QyU1Q2Zyb250LXJiYW5kJTVDJTVDcmJhbmQlNUMlNUNzcmMlNUMlNUNjb21wb25lbnRzJTVDJTVDZGVzY3JpcHRvciU1QyU1Q0Rlc2NyaXB0b3IudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyRGVzY3JpcHRvciUyMiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjJDJTNBJTVDJTVDVXNlcnMlNUMlNUM3OTUzMyU1QyU1Q0Rlc2t0b3AlNUMlNUNmcm9udC1yYmFuZCU1QyU1Q3JiYW5kJTVDJTVDc3JjJTVDJTVDY29tcG9uZW50cyU1QyU1Q21vdGl2YXRpb25zJTVDJTVDTW90aXZhdGlvbnMudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyTW90aXZhdGlvbnMlMjIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDNzk1MzMlNUMlNUNEZXNrdG9wJTVDJTVDZnJvbnQtcmJhbmQlNUMlNUNyYmFuZCU1QyU1Q3NyYyU1QyU1Q2NvbXBvbmVudHMlNUMlNUNvdXItcHJvamVjdHMlNUMlNUNQcm9qZWN0cy50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJQcm9qZWN0cyUyMiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjJDJTNBJTVDJTVDVXNlcnMlNUMlNUM3OTUzMyU1QyU1Q0Rlc2t0b3AlNUMlNUNmcm9udC1yYmFuZCU1QyU1Q3JiYW5kJTVDJTVDc3JjJTVDJTVDY29tcG9uZW50cyU1QyU1Q3BhcnRuZXJzJTVDJTVDUGFydG5lcnMudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyUGFydG5lcnMlMjIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDNzk1MzMlNUMlNUNEZXNrdG9wJTVDJTVDZnJvbnQtcmJhbmQlNUMlNUNyYmFuZCU1QyU1Q3NyYyU1QyU1Q2NvbXBvbmVudHMlNUMlNUN1aSU1QyU1Q0hlYWRpbmclNUMlNUNIZWFkaW5nLnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiUyMmRlZmF1bHQlMjIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDNzk1MzMlNUMlNUNEZXNrdG9wJTVDJTVDZnJvbnQtcmJhbmQlNUMlNUNyYmFuZCU1QyU1Q3NyYyU1QyU1Q2NvbXBvbmVudHMlNUMlNUN1aSU1QyU1Q3JlZmVyZW5jZSU1QyU1Q1JlZmVyZW5jZS50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJSZWZlcmVuY2UlMjIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDNzk1MzMlNUMlNUNEZXNrdG9wJTVDJTVDZnJvbnQtcmJhbmQlNUMlNUNyYmFuZCU1QyU1Q3NyYyU1QyU1Q2NvbXBvbmVudHMlNUMlNUN1c2VmdWwlNUMlNUNVc2VmdWwubW9kdWxlLnNjc3MlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDNzk1MzMlNUMlNUNEZXNrdG9wJTVDJTVDZnJvbnQtcmJhbmQlNUMlNUNyYmFuZCU1QyU1Q3NyYyU1QyU1Q2NvbXBvbmVudHMlNUMlNUN1c2VmdWwlNUMlNUNVc2VmdWxTbGlkZXIudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyVXNlZnVsU2xpZGVyJTIyJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsMExBQWdKO0FBQ2hKO0FBQ0EsOE1BQStKO0FBQy9KO0FBQ0Esa05BQWtLO0FBQ2xLO0FBQ0EsOE1BQTZKO0FBQzdKO0FBQ0Esc01BQXlKO0FBQ3pKO0FBQ0Esd01BQTBKO0FBQzFKO0FBQ0EsZ05BQWdLO0FBQ2hLO0FBQ0Esb05BQStIO0FBQy9IO0FBQ0EsME1BQStKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/NWNhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiwgd2VicGFja0V4cG9ydHM6IFtcIkFib3V0XCJdICovIFwiQzpcXFxcVXNlcnNcXFxcNzk1MzNcXFxcRGVza3RvcFxcXFxmcm9udC1yYmFuZFxcXFxyYmFuZFxcXFxzcmNcXFxcY29tcG9uZW50c1xcXFxhYm91dFxcXFxBYm91dC50c3hcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiwgd2VicGFja0V4cG9ydHM6IFtcIkRlc2NyaXB0b3JcIl0gKi8gXCJDOlxcXFxVc2Vyc1xcXFw3OTUzM1xcXFxEZXNrdG9wXFxcXGZyb250LXJiYW5kXFxcXHJiYW5kXFxcXHNyY1xcXFxjb21wb25lbnRzXFxcXGRlc2NyaXB0b3JcXFxcRGVzY3JpcHRvci50c3hcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiwgd2VicGFja0V4cG9ydHM6IFtcIk1vdGl2YXRpb25zXCJdICovIFwiQzpcXFxcVXNlcnNcXFxcNzk1MzNcXFxcRGVza3RvcFxcXFxmcm9udC1yYmFuZFxcXFxyYmFuZFxcXFxzcmNcXFxcY29tcG9uZW50c1xcXFxtb3RpdmF0aW9uc1xcXFxNb3RpdmF0aW9ucy50c3hcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiwgd2VicGFja0V4cG9ydHM6IFtcIlByb2plY3RzXCJdICovIFwiQzpcXFxcVXNlcnNcXFxcNzk1MzNcXFxcRGVza3RvcFxcXFxmcm9udC1yYmFuZFxcXFxyYmFuZFxcXFxzcmNcXFxcY29tcG9uZW50c1xcXFxvdXItcHJvamVjdHNcXFxcUHJvamVjdHMudHN4XCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJQYXJ0bmVyc1wiXSAqLyBcIkM6XFxcXFVzZXJzXFxcXDc5NTMzXFxcXERlc2t0b3BcXFxcZnJvbnQtcmJhbmRcXFxccmJhbmRcXFxcc3JjXFxcXGNvbXBvbmVudHNcXFxccGFydG5lcnNcXFxcUGFydG5lcnMudHN4XCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJkZWZhdWx0XCJdICovIFwiQzpcXFxcVXNlcnNcXFxcNzk1MzNcXFxcRGVza3RvcFxcXFxmcm9udC1yYmFuZFxcXFxyYmFuZFxcXFxzcmNcXFxcY29tcG9uZW50c1xcXFx1aVxcXFxIZWFkaW5nXFxcXEhlYWRpbmcudHN4XCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJSZWZlcmVuY2VcIl0gKi8gXCJDOlxcXFxVc2Vyc1xcXFw3OTUzM1xcXFxEZXNrdG9wXFxcXGZyb250LXJiYW5kXFxcXHJiYW5kXFxcXHNyY1xcXFxjb21wb25lbnRzXFxcXHVpXFxcXHJlZmVyZW5jZVxcXFxSZWZlcmVuY2UudHN4XCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJDOlxcXFxVc2Vyc1xcXFw3OTUzM1xcXFxEZXNrdG9wXFxcXGZyb250LXJiYW5kXFxcXHJiYW5kXFxcXHNyY1xcXFxjb21wb25lbnRzXFxcXHVzZWZ1bFxcXFxVc2VmdWwubW9kdWxlLnNjc3NcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiwgd2VicGFja0V4cG9ydHM6IFtcIlVzZWZ1bFNsaWRlclwiXSAqLyBcIkM6XFxcXFVzZXJzXFxcXDc5NTMzXFxcXERlc2t0b3BcXFxcZnJvbnQtcmJhbmRcXFxccmJhbmRcXFxcc3JjXFxcXGNvbXBvbmVudHNcXFxcdXNlZnVsXFxcXFVzZWZ1bFNsaWRlci50c3hcIik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cabout%5C%5CAbout.tsx%22%2C%22ids%22%3A%5B%22About%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cdescriptor%5C%5CDescriptor.tsx%22%2C%22ids%22%3A%5B%22Descriptor%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cmotivations%5C%5CMotivations.tsx%22%2C%22ids%22%3A%5B%22Motivations%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cour-projects%5C%5CProjects.tsx%22%2C%22ids%22%3A%5B%22Projects%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cpartners%5C%5CPartners.tsx%22%2C%22ids%22%3A%5B%22Partners%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cui%5C%5CHeading%5C%5CHeading.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cui%5C%5Creference%5C%5CReference.tsx%22%2C%22ids%22%3A%5B%22Reference%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cuseful%5C%5CUseful.module.scss%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cuseful%5C%5CUsefulSlider.tsx%22%2C%22ids%22%3A%5B%22UsefulSlider%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@gsap+react@2.1.1/node_modules/@gsap/react/src/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/@gsap+react@2.1.1/node_modules/@gsap/react/src/index.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGSAP: function() { return /* binding */ useGSAP; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gsap */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js\");\n/*!\n * @gsap/react 2.1.1\n * https://gsap.com\n *\n * Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\n\n\nlet useIsomorphicLayoutEffect = typeof window !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n    isConfig = value => value && !Array.isArray(value) && typeof(value) === \"object\",\n    emptyArray = [],\n    defaultConfig = {},\n    _gsap = gsap__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; // accommodates situations where different versions of GSAP may be loaded, so a user can gsap.registerPlugin(useGSAP);\n\nconst useGSAP = (callback, dependencies = emptyArray) => {\n  let config = defaultConfig;\n  if (isConfig(callback)) {\n    config = callback;\n    callback = null;\n    dependencies = \"dependencies\" in config ? config.dependencies : emptyArray;\n  } else if (isConfig(dependencies)) {\n    config = dependencies;\n    dependencies = \"dependencies\" in config ? config.dependencies : emptyArray;\n  }\n  (callback && typeof callback !== \"function\") && console.warn(\"First parameter must be a function or config object\");\n  const { scope, revertOnUpdate } = config,\n        mounted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false),\n        context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(_gsap.context(() => { }, scope)),\n        contextSafe = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)((func) => context.current.add(null, func)),\n        deferCleanup = dependencies && dependencies.length && !revertOnUpdate;\n  useIsomorphicLayoutEffect(() => {\n    callback && context.current.add(callback, scope);\n    if (!deferCleanup || !mounted.current) { // React renders bottom-up, thus there could be hooks with dependencies that run BEFORE the component mounts, thus cleanup wouldn't occur since a hook with an empty dependency Array would only run once the component mounts.\n      return () => context.current.revert();\n    }\n  }, dependencies);\n  deferCleanup && useIsomorphicLayoutEffect(() => {\n      mounted.current = true;\n      return () => context.current.revert();\n    }, emptyArray);\n  return { context: context.current, contextSafe: contextSafe.current };\n};\nuseGSAP.register = core => { _gsap = core; };\nuseGSAP.headless = true; // doesn't require the window to be registered.\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AZ3NhcCtyZWFjdEAyLjEuMS9ub2RlX21vZHVsZXMvQGdzYXAvcmVhY3Qvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMyRDtBQUNuQzs7QUFFeEIsZ0VBQWdFLGtEQUFlLEdBQUcsNENBQVM7QUFDM0Y7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixZQUFZLDRDQUFJLEVBQUU7O0FBRVg7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEMsa0JBQWtCLDZDQUFNO0FBQ3hCLGtCQUFrQiw2Q0FBTSx3QkFBd0I7QUFDaEQsc0JBQXNCLDZDQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXO0FBQ1g7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AZ3NhcCtyZWFjdEAyLjEuMS9ub2RlX21vZHVsZXMvQGdzYXAvcmVhY3Qvc3JjL2luZGV4LmpzPzBiOGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAZ3NhcC9yZWFjdCAyLjEuMVxuICogaHR0cHM6Ly9nc2FwLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDA4LTIwMjQsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3NhcC5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR1NBUCBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgZ3NhcCBmcm9tIFwiZ3NhcFwiO1xuXG5sZXQgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3QsXG4gICAgaXNDb25maWcgPSB2YWx1ZSA9PiB2YWx1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mKHZhbHVlKSA9PT0gXCJvYmplY3RcIixcbiAgICBlbXB0eUFycmF5ID0gW10sXG4gICAgZGVmYXVsdENvbmZpZyA9IHt9LFxuICAgIF9nc2FwID0gZ3NhcDsgLy8gYWNjb21tb2RhdGVzIHNpdHVhdGlvbnMgd2hlcmUgZGlmZmVyZW50IHZlcnNpb25zIG9mIEdTQVAgbWF5IGJlIGxvYWRlZCwgc28gYSB1c2VyIGNhbiBnc2FwLnJlZ2lzdGVyUGx1Z2luKHVzZUdTQVApO1xuXG5leHBvcnQgY29uc3QgdXNlR1NBUCA9IChjYWxsYmFjaywgZGVwZW5kZW5jaWVzID0gZW1wdHlBcnJheSkgPT4ge1xuICBsZXQgY29uZmlnID0gZGVmYXVsdENvbmZpZztcbiAgaWYgKGlzQ29uZmlnKGNhbGxiYWNrKSkge1xuICAgIGNvbmZpZyA9IGNhbGxiYWNrO1xuICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICBkZXBlbmRlbmNpZXMgPSBcImRlcGVuZGVuY2llc1wiIGluIGNvbmZpZyA/IGNvbmZpZy5kZXBlbmRlbmNpZXMgOiBlbXB0eUFycmF5O1xuICB9IGVsc2UgaWYgKGlzQ29uZmlnKGRlcGVuZGVuY2llcykpIHtcbiAgICBjb25maWcgPSBkZXBlbmRlbmNpZXM7XG4gICAgZGVwZW5kZW5jaWVzID0gXCJkZXBlbmRlbmNpZXNcIiBpbiBjb25maWcgPyBjb25maWcuZGVwZW5kZW5jaWVzIDogZW1wdHlBcnJheTtcbiAgfVxuICAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpICYmIGNvbnNvbGUud2FybihcIkZpcnN0IHBhcmFtZXRlciBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgY29uZmlnIG9iamVjdFwiKTtcbiAgY29uc3QgeyBzY29wZSwgcmV2ZXJ0T25VcGRhdGUgfSA9IGNvbmZpZyxcbiAgICAgICAgbW91bnRlZCA9IHVzZVJlZihmYWxzZSksXG4gICAgICAgIGNvbnRleHQgPSB1c2VSZWYoX2dzYXAuY29udGV4dCgoKSA9PiB7IH0sIHNjb3BlKSksXG4gICAgICAgIGNvbnRleHRTYWZlID0gdXNlUmVmKChmdW5jKSA9PiBjb250ZXh0LmN1cnJlbnQuYWRkKG51bGwsIGZ1bmMpKSxcbiAgICAgICAgZGVmZXJDbGVhbnVwID0gZGVwZW5kZW5jaWVzICYmIGRlcGVuZGVuY2llcy5sZW5ndGggJiYgIXJldmVydE9uVXBkYXRlO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjYWxsYmFjayAmJiBjb250ZXh0LmN1cnJlbnQuYWRkKGNhbGxiYWNrLCBzY29wZSk7XG4gICAgaWYgKCFkZWZlckNsZWFudXAgfHwgIW1vdW50ZWQuY3VycmVudCkgeyAvLyBSZWFjdCByZW5kZXJzIGJvdHRvbS11cCwgdGh1cyB0aGVyZSBjb3VsZCBiZSBob29rcyB3aXRoIGRlcGVuZGVuY2llcyB0aGF0IHJ1biBCRUZPUkUgdGhlIGNvbXBvbmVudCBtb3VudHMsIHRodXMgY2xlYW51cCB3b3VsZG4ndCBvY2N1ciBzaW5jZSBhIGhvb2sgd2l0aCBhbiBlbXB0eSBkZXBlbmRlbmN5IEFycmF5IHdvdWxkIG9ubHkgcnVuIG9uY2UgdGhlIGNvbXBvbmVudCBtb3VudHMuXG4gICAgICByZXR1cm4gKCkgPT4gY29udGV4dC5jdXJyZW50LnJldmVydCgpO1xuICAgIH1cbiAgfSwgZGVwZW5kZW5jaWVzKTtcbiAgZGVmZXJDbGVhbnVwICYmIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgbW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIHJldHVybiAoKSA9PiBjb250ZXh0LmN1cnJlbnQucmV2ZXJ0KCk7XG4gICAgfSwgZW1wdHlBcnJheSk7XG4gIHJldHVybiB7IGNvbnRleHQ6IGNvbnRleHQuY3VycmVudCwgY29udGV4dFNhZmU6IGNvbnRleHRTYWZlLmN1cnJlbnQgfTtcbn07XG51c2VHU0FQLnJlZ2lzdGVyID0gY29yZSA9PiB7IF9nc2FwID0gY29yZTsgfTtcbnVzZUdTQVAuaGVhZGxlc3MgPSB0cnVlOyAvLyBkb2Vzbid0IHJlcXVpcmUgdGhlIHdpbmRvdyB0byBiZSByZWdpc3RlcmVkLlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@gsap+react@2.1.1/node_modules/@gsap/react/src/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSPlugin.js":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSPlugin.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CSSPlugin: function() { return /* binding */ CSSPlugin; },\n/* harmony export */   _createElement: function() { return /* binding */ _createElement; },\n/* harmony export */   _getBBox: function() { return /* binding */ _getBBox; },\n/* harmony export */   checkPrefix: function() { return /* binding */ _checkPropPrefix; },\n/* harmony export */   \"default\": function() { return /* binding */ CSSPlugin; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_type_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_type_of */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_type_of.js\");\n/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/gsap-core.js\");\n/*!\n * CSSPlugin 3.12.5\n * https://gsap.com\n *\n * Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ \n\nvar _win, _doc, _docElement, _pluginInitted, _tempDiv, _tempDivStyler, _recentSetterPlugin, _reverting, _windowExists = function _windowExists() {\n    return typeof window !== \"undefined\";\n}, _transformProps = {}, _RAD2DEG = 180 / Math.PI, _DEG2RAD = Math.PI / 180, _atan2 = Math.atan2, _bigNum = 1e8, _capsExp = /([A-Z])/g, _horizontalExp = /(left|right|width|margin|padding|x)/i, _complexExp = /[\\s,\\(]\\S/, _propertyAliases = {\n    autoAlpha: \"opacity,visibility\",\n    scale: \"scaleX,scaleY\",\n    alpha: \"opacity\"\n}, _renderCSSProp = function _renderCSSProp(ratio, data) {\n    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\n}, _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {\n    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\n}, _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {\n    return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);\n}, //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)\n_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {\n    var value = data.s + data.c * ratio;\n    data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);\n}, _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {\n    return data.set(data.t, data.p, ratio ? data.e : data.b, data);\n}, _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {\n    return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);\n}, _setterCSSStyle = function _setterCSSStyle(target, property, value) {\n    return target.style[property] = value;\n}, _setterCSSProp = function _setterCSSProp(target, property, value) {\n    return target.style.setProperty(property, value);\n}, _setterTransform = function _setterTransform(target, property, value) {\n    return target._gsap[property] = value;\n}, _setterScale = function _setterScale(target, property, value) {\n    return target._gsap.scaleX = target._gsap.scaleY = value;\n}, _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {\n    var cache = target._gsap;\n    cache.scaleX = cache.scaleY = value;\n    cache.renderTransform(ratio, cache);\n}, _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {\n    var cache = target._gsap;\n    cache[property] = value;\n    cache.renderTransform(ratio, cache);\n}, _transformProp = \"transform\", _transformOriginProp = _transformProp + \"Origin\", _saveStyle = function _saveStyle(property, isNotCSS) {\n    var _this = this;\n    var target = this.target, style = target.style, cache = target._gsap;\n    if (property in _transformProps && style) {\n        this.tfm = this.tfm || {};\n        if (property !== \"transform\") {\n            property = _propertyAliases[property] || property;\n            ~property.indexOf(\",\") ? property.split(\",\").forEach(function(a) {\n                return _this.tfm[a] = _get(target, a);\n            }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property); // note: scale would map to \"scaleX,scaleY\", thus we loop and apply them both.\n            property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);\n        } else {\n            return _propertyAliases.transform.split(\",\").forEach(function(p) {\n                return _saveStyle.call(_this, p, isNotCSS);\n            });\n        }\n        if (this.props.indexOf(_transformProp) >= 0) {\n            return;\n        }\n        if (cache.svg) {\n            this.svgo = target.getAttribute(\"data-svg-origin\");\n            this.props.push(_transformOriginProp, isNotCSS, \"\");\n        }\n        property = _transformProp;\n    }\n    (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);\n}, _removeIndependentTransforms = function _removeIndependentTransforms(style) {\n    if (style.translate) {\n        style.removeProperty(\"translate\");\n        style.removeProperty(\"scale\");\n        style.removeProperty(\"rotate\");\n    }\n}, _revertStyle = function _revertStyle() {\n    var props = this.props, target = this.target, style = target.style, cache = target._gsap, i, p;\n    for(i = 0; i < props.length; i += 3){\n        // stored like this: property, isNotCSS, value\n        props[i + 1] ? target[props[i]] = props[i + 2] : props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === \"--\" ? props[i] : props[i].replace(_capsExp, \"-$1\").toLowerCase());\n    }\n    if (this.tfm) {\n        for(p in this.tfm){\n            cache[p] = this.tfm[p];\n        }\n        if (cache.svg) {\n            cache.renderTransform();\n            target.setAttribute(\"data-svg-origin\", this.svgo || \"\");\n        }\n        i = _reverting();\n        if ((!i || !i.isStart) && !style[_transformProp]) {\n            _removeIndependentTransforms(style);\n            if (cache.zOrigin && style[_transformOriginProp]) {\n                style[_transformOriginProp] += \" \" + cache.zOrigin + \"px\"; // since we're uncaching, we must put the zOrigin back into the transformOrigin so that we can pull it out accurately when we parse again. Otherwise, we'd lose the z portion of the origin since we extract it to protect from Safari bugs.\n                cache.zOrigin = 0;\n                cache.renderTransform();\n            }\n            cache.uncache = 1; // if it's a startAt that's being reverted in the _initTween() of the core, we don't need to uncache transforms. This is purely a performance optimization.\n        }\n    }\n}, _getStyleSaver = function _getStyleSaver(target, properties) {\n    var saver = {\n        target: target,\n        props: [],\n        revert: _revertStyle,\n        save: _saveStyle\n    };\n    target._gsap || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.getCache(target); // just make sure there's a _gsap cache defined because we read from it in _saveStyle() and it's more efficient to just check it here once.\n    properties && properties.split(\",\").forEach(function(p) {\n        return saver.save(p);\n    });\n    return saver;\n}, _supports3D, _createElement = function _createElement(type, ns) {\n    var e = _doc.createElementNS ? _doc.createElementNS((ns || \"http://www.w3.org/1999/xhtml\").replace(/^https/, \"http\"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making \"style\" inaccessible.\n    return e && e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://gsap.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).\n}, _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {\n    var cs = getComputedStyle(target);\n    return cs[property] || cs.getPropertyValue(property.replace(_capsExp, \"-$1\").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || \"\"; //css variables may not need caps swapped out for dashes and lowercase.\n}, _prefixes = \"O,Moz,ms,Ms,Webkit\".split(\",\"), _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {\n    var e = element || _tempDiv, s = e.style, i = 5;\n    if (property in s && !preferPrefix) {\n        return property;\n    }\n    property = property.charAt(0).toUpperCase() + property.substr(1);\n    while(i-- && !(_prefixes[i] + property in s)){}\n    return i < 0 ? null : (i === 3 ? \"ms\" : i >= 0 ? _prefixes[i] : \"\") + property;\n}, _initCore = function _initCore() {\n    if (_windowExists() && window.document) {\n        _win = window;\n        _doc = _win.document;\n        _docElement = _doc.documentElement;\n        _tempDiv = _createElement(\"div\") || {\n            style: {}\n        };\n        _tempDivStyler = _createElement(\"div\");\n        _transformProp = _checkPropPrefix(_transformProp);\n        _transformOriginProp = _transformProp + \"Origin\";\n        _tempDiv.style.cssText = \"border-width:0;line-height:0;position:absolute;padding:0\"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.\n        _supports3D = !!_checkPropPrefix(\"perspective\");\n        _reverting = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.reverting;\n        _pluginInitted = 1;\n    }\n}, _getBBoxHack = function _getBBoxHack(swapIfPossible) {\n    //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).\n    var svg = _createElement(\"svg\", this.ownerSVGElement && this.ownerSVGElement.getAttribute(\"xmlns\") || \"http://www.w3.org/2000/svg\"), oldParent = this.parentNode, oldSibling = this.nextSibling, oldCSS = this.style.cssText, bbox;\n    _docElement.appendChild(svg);\n    svg.appendChild(this);\n    this.style.display = \"block\";\n    if (swapIfPossible) {\n        try {\n            bbox = this.getBBox();\n            this._gsapBBox = this.getBBox; //store the original\n            this.getBBox = _getBBoxHack;\n        } catch (e) {}\n    } else if (this._gsapBBox) {\n        bbox = this._gsapBBox();\n    }\n    if (oldParent) {\n        if (oldSibling) {\n            oldParent.insertBefore(this, oldSibling);\n        } else {\n            oldParent.appendChild(this);\n        }\n    }\n    _docElement.removeChild(svg);\n    this.style.cssText = oldCSS;\n    return bbox;\n}, _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {\n    var i = attributesArray.length;\n    while(i--){\n        if (target.hasAttribute(attributesArray[i])) {\n            return target.getAttribute(attributesArray[i]);\n        }\n    }\n}, _getBBox = function _getBBox(target) {\n    var bounds;\n    try {\n        bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118\n    } catch (error) {\n        bounds = _getBBoxHack.call(target, true);\n    }\n    bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.\n    return bounds && !bounds.width && !bounds.x && !bounds.y ? {\n        x: +_getAttributeFallbacks(target, [\n            \"x\",\n            \"cx\",\n            \"x1\"\n        ]) || 0,\n        y: +_getAttributeFallbacks(target, [\n            \"y\",\n            \"cy\",\n            \"y1\"\n        ]) || 0,\n        width: 0,\n        height: 0\n    } : bounds;\n}, _isSVG = function _isSVG(e) {\n    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));\n}, //reports if the element is an SVG on which getBBox() actually works\n_removeProperty = function _removeProperty(target, property) {\n    if (property) {\n        var style = target.style, first2Chars;\n        if (property in _transformProps && property !== _transformOriginProp) {\n            property = _transformProp;\n        }\n        if (style.removeProperty) {\n            first2Chars = property.substr(0, 2);\n            if (first2Chars === \"ms\" || property.substr(0, 6) === \"webkit\") {\n                //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be \"ms-transform\" instead of \"-ms-transform\" for IE9, for example)\n                property = \"-\" + property;\n            }\n            style.removeProperty(first2Chars === \"--\" ? property : property.replace(_capsExp, \"-$1\").toLowerCase());\n        } else {\n            //note: old versions of IE use \"removeAttribute()\" instead of \"removeProperty()\"\n            style.removeAttribute(property);\n        }\n    }\n}, _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {\n    var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);\n    plugin._pt = pt;\n    pt.b = beginning;\n    pt.e = end;\n    plugin._props.push(property);\n    return pt;\n}, _nonConvertibleUnits = {\n    deg: 1,\n    rad: 1,\n    turn: 1\n}, _nonStandardLayouts = {\n    grid: 1,\n    flex: 1\n}, //takes a single value like 20px and converts it to the unit specified, like \"%\", returning only the numeric amount.\n_convertToUnit = function _convertToUnit(target, property, value, unit) {\n    var curValue = parseFloat(value) || 0, curUnit = (value + \"\").trim().substr((curValue + \"\").length) || \"px\", // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()\n    style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === \"svg\", measureProperty = (isRootSVG ? \"client\" : \"offset\") + (horizontal ? \"Width\" : \"Height\"), amount = 100, toPixels = unit === \"px\", toPercent = unit === \"%\", px, parent, cache, isSVG;\n    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {\n        return curValue;\n    }\n    curUnit !== \"px\" && !toPixels && (curValue = _convertToUnit(target, property, value, \"px\"));\n    isSVG = target.getCTM && _isSVG(target);\n    if ((toPercent || curUnit === \"%\") && (_transformProps[property] || ~property.indexOf(\"adius\"))) {\n        px = isSVG ? target.getBBox()[horizontal ? \"width\" : \"height\"] : target[measureProperty];\n        return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPercent ? curValue / px * amount : curValue / 100 * px);\n    }\n    style[horizontal ? \"width\" : \"height\"] = amount + (toPixels ? curUnit : unit);\n    parent = ~property.indexOf(\"adius\") || unit === \"em\" && target.appendChild && !isRootSVG ? target : target.parentNode;\n    if (isSVG) {\n        parent = (target.ownerSVGElement || {}).parentNode;\n    }\n    if (!parent || parent === _doc || !parent.appendChild) {\n        parent = _doc.body;\n    }\n    cache = parent._gsap;\n    if (cache && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time && !cache.uncache) {\n        return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(curValue / cache.width * amount);\n    } else {\n        if (toPercent && (property === \"height\" || property === \"width\")) {\n            // if we're dealing with width/height that's inside a container with padding and/or it's a flexbox/grid container, we must apply it to the target itself rather than the _tempDiv in order to ensure complete accuracy, factoring in the parent's padding.\n            var v = target.style[property];\n            target.style[property] = amount + unit;\n            px = target[measureProperty];\n            v ? target.style[property] = v : _removeProperty(target, property);\n        } else {\n            (toPercent || curUnit === \"%\") && !_nonStandardLayouts[_getComputedProperty(parent, \"display\")] && (style.position = _getComputedProperty(target, \"position\"));\n            parent === target && (style.position = \"static\"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.\n            parent.appendChild(_tempDiv);\n            px = _tempDiv[measureProperty];\n            parent.removeChild(_tempDiv);\n            style.position = \"absolute\";\n        }\n        if (horizontal && toPercent) {\n            cache = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(parent);\n            cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time;\n            cache.width = parent[measureProperty];\n        }\n    }\n    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);\n}, _get = function _get(target, property, unit, uncache) {\n    var value;\n    _pluginInitted || _initCore();\n    if (property in _propertyAliases && property !== \"transform\") {\n        property = _propertyAliases[property];\n        if (~property.indexOf(\",\")) {\n            property = property.split(\",\")[0];\n        }\n    }\n    if (_transformProps[property] && property !== \"transform\") {\n        value = _parseTransform(target, uncache);\n        value = property !== \"transformOrigin\" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + \" \" + value.zOrigin + \"px\";\n    } else {\n        value = target.style[property];\n        if (!value || value === \"auto\" || uncache || ~(value + \"\").indexOf(\"calc(\")) {\n            value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getProperty)(target, property) || (property === \"opacity\" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius\n        }\n    }\n    return unit && !~(value + \"\").trim().indexOf(\" \") ? _convertToUnit(target, property, value, unit) + unit : value;\n}, _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {\n    // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\n    if (!start || start === \"none\") {\n        // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style (\"clipPath\" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as \"none\" whereas WebkitClipPath reports accurately like \"ellipse(100% 0% at 50% 0%)\", so in this case we must SWITCH to using the prefixed property instead. See https://gsap.com/forums/topic/18310-clippath-doesnt-work-on-ios/\n        var p = _checkPropPrefix(prop, target, 1), s = p && _getComputedProperty(target, p, 1);\n        if (s && s !== start) {\n            prop = p;\n            start = s;\n        } else if (prop === \"borderColor\") {\n            start = _getComputedProperty(target, \"borderTopColor\"); // Firefox bug: always reports \"borderColor\" as \"\", so we must fall back to borderTopColor. See https://gsap.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/\n        }\n    }\n    var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._renderComplexString), index = 0, matchIndex = 0, a, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;\n    pt.b = start;\n    pt.e = end;\n    start += \"\"; // ensure values are strings\n    end += \"\";\n    if (end === \"auto\") {\n        startValue = target.style[prop];\n        target.style[prop] = end;\n        end = _getComputedProperty(target, prop) || end;\n        startValue ? target.style[prop] = startValue : _removeProperty(target, prop);\n    }\n    a = [\n        start,\n        end\n    ];\n    (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorStringFilter)(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().\n    start = a[0];\n    end = a[1];\n    startValues = start.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];\n    endValues = end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];\n    if (endValues.length) {\n        while(result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.exec(end)){\n            endValue = result[0];\n            chunk = end.substring(index, result.index);\n            if (color) {\n                color = (color + 1) % 5;\n            } else if (chunk.substr(-5) === \"rgba(\" || chunk.substr(-5) === \"hsla(\") {\n                color = 1;\n            }\n            if (endValue !== (startValue = startValues[matchIndex++] || \"\")) {\n                startNum = parseFloat(startValue) || 0;\n                startUnit = startValue.substr((startNum + \"\").length);\n                endValue.charAt(1) === \"=\" && (endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, endValue) + startUnit);\n                endNum = parseFloat(endValue);\n                endUnit = endValue.substr((endNum + \"\").length);\n                index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.lastIndex - endUnit.length;\n                if (!endUnit) {\n                    //if something like \"perspective:300\" is passed in and we must add a unit to the end\n                    endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[prop] || startUnit;\n                    if (index === end.length) {\n                        end += endUnit;\n                        pt.e += endUnit;\n                    }\n                }\n                if (startUnit !== endUnit) {\n                    startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;\n                } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.\n                pt._pt = {\n                    _next: pt._pt,\n                    p: chunk || matchIndex === 1 ? chunk : \",\",\n                    //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n                    s: startNum,\n                    c: endNum - startNum,\n                    m: color && color < 4 || prop === \"zIndex\" ? Math.round : 0\n                };\n            }\n        }\n        pt.c = index < end.length ? end.substring(index, end.length) : \"\"; //we use the \"c\" of the PropTween to store the final part of the string (after the last number)\n    } else {\n        pt.r = prop === \"display\" && end === \"none\" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;\n    }\n    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).\n    this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus \"this\" would refer to the plugin.\n    return pt;\n}, _keywordToPercent = {\n    top: \"0%\",\n    bottom: \"100%\",\n    left: \"0%\",\n    right: \"100%\",\n    center: \"50%\"\n}, _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {\n    var split = value.split(\" \"), x = split[0], y = split[1] || \"50%\";\n    if (x === \"top\" || x === \"bottom\" || y === \"left\" || y === \"right\") {\n        //the user provided them in the wrong order, so flip them\n        value = x;\n        x = y;\n        y = value;\n    }\n    split[0] = _keywordToPercent[x] || x;\n    split[1] = _keywordToPercent[y] || y;\n    return split.join(\" \");\n}, _renderClearProps = function _renderClearProps(ratio, data) {\n    if (data.tween && data.tween._time === data.tween._dur) {\n        var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i;\n        if (props === \"all\" || props === true) {\n            style.cssText = \"\";\n            clearTransforms = 1;\n        } else {\n            props = props.split(\",\");\n            i = props.length;\n            while(--i > -1){\n                prop = props[i];\n                if (_transformProps[prop]) {\n                    clearTransforms = 1;\n                    prop = prop === \"transformOrigin\" ? _transformOriginProp : _transformProp;\n                }\n                _removeProperty(target, prop);\n            }\n        }\n        if (clearTransforms) {\n            _removeProperty(target, _transformProp);\n            if (cache) {\n                cache.svg && target.removeAttribute(\"transform\");\n                _parseTransform(target, 1); // force all the cached values back to \"normal\"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.\n                cache.uncache = 1;\n                _removeIndependentTransforms(style);\n            }\n        }\n    }\n}, // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.\n_specialProps = {\n    clearProps: function clearProps(plugin, target, property, endValue, tween) {\n        if (tween.data !== \"isFromStart\") {\n            var pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);\n            pt.u = endValue;\n            pt.pr = -10;\n            pt.tween = tween;\n            plugin._props.push(property);\n            return 1;\n        }\n    }\n}, /*\n * --------------------------------------------------------------------------------------\n * TRANSFORMS\n * --------------------------------------------------------------------------------------\n */ _identity2DMatrix = [\n    1,\n    0,\n    0,\n    1,\n    0,\n    0\n], _rotationalProperties = {}, _isNullTransform = function _isNullTransform(value) {\n    return value === \"matrix(1, 0, 0, 1, 0, 0)\" || value === \"none\" || !value;\n}, _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {\n    var matrixString = _getComputedProperty(target, _transformProp);\n    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numExp).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round);\n}, _getMatrix = function _getMatrix(target, force2D) {\n    var cache = target._gsap || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent, nextSibling, temp, addedToDOM;\n    if (cache.svg && target.getAttribute(\"transform\")) {\n        temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like \"translate(50,60) rotate(135,0,0)\" are parsed because it mashes it into a matrix.\n        matrix = [\n            temp.a,\n            temp.b,\n            temp.c,\n            temp.d,\n            temp.e,\n            temp.f\n        ];\n        return matrix.join(\",\") === \"1,0,0,1,0,0\" ? _identity2DMatrix : matrix;\n    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {\n        //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n        //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not \"none\". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).\n        temp = style.display;\n        style.display = \"block\";\n        parent = target.parentNode;\n        if (!parent || !target.offsetParent) {\n            // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375\n            addedToDOM = 1; //flag\n            nextSibling = target.nextElementSibling;\n            _docElement.appendChild(target); //we must add it to the DOM in order to get values properly\n        }\n        matrix = _getComputedTransformMatrixAsArray(target);\n        temp ? style.display = temp : _removeProperty(target, \"display\");\n        if (addedToDOM) {\n            nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);\n        }\n    }\n    return force2D && matrix.length > 6 ? [\n        matrix[0],\n        matrix[1],\n        matrix[4],\n        matrix[5],\n        matrix[12],\n        matrix[13]\n    ] : matrix;\n}, _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {\n    var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a = matrix[0], b = matrix[1], c = matrix[2], d = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(\" \"), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x, y;\n    if (!originIsAbsolute) {\n        bounds = _getBBox(target);\n        xOrigin = bounds.x + (~originSplit[0].indexOf(\"%\") ? xOrigin / 100 * bounds.width : xOrigin);\n        yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf(\"%\") ? yOrigin / 100 * bounds.height : yOrigin); // if (!(\"xOrigin\" in cache) && (xOrigin || yOrigin)) { // added in 3.12.3, reverted in 3.12.4; requires more exploration\n    // \txOrigin -= bounds.x;\n    // \tyOrigin -= bounds.y;\n    // }\n    } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {\n        //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.\n        x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;\n        y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;\n        xOrigin = x;\n        yOrigin = y; // theory: we only had to do this for smoothing and it assumes that the previous one was not originIsAbsolute.\n    }\n    if (smooth || smooth !== false && cache.smooth) {\n        tx = xOrigin - xOriginOld;\n        ty = yOrigin - yOriginOld;\n        cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;\n        cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;\n    } else {\n        cache.xOffset = cache.yOffset = 0;\n    }\n    cache.xOrigin = xOrigin;\n    cache.yOrigin = yOrigin;\n    cache.smooth = !!smooth;\n    cache.origin = origin;\n    cache.originIsAbsolute = !!originIsAbsolute;\n    target.style[_transformOriginProp] = \"0px 0px\"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).\n    if (pluginToAddPropTweensTo) {\n        _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOrigin\", xOriginOld, xOrigin);\n        _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOrigin\", yOriginOld, yOrigin);\n        _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOffset\", xOffsetOld, cache.xOffset);\n        _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOffset\", yOffsetOld, cache.yOffset);\n    }\n    target.setAttribute(\"data-svg-origin\", xOrigin + \" \" + yOrigin);\n}, _parseTransform = function _parseTransform(target, uncache) {\n    var cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.GSCache(target);\n    if (\"x\" in cache && !uncache && !cache.uncache) {\n        return cache;\n    }\n    var style = target.style, invertedScaleX = cache.scaleX < 0, px = \"px\", deg = \"deg\", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || \"0\", x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;\n    x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;\n    scaleX = scaleY = 1;\n    cache.svg = !!(target.getCTM && _isSVG(target));\n    if (cs.translate) {\n        // accommodate independent transforms by combining them into normal ones.\n        if (cs.translate !== \"none\" || cs.scale !== \"none\" || cs.rotate !== \"none\") {\n            style[_transformProp] = (cs.translate !== \"none\" ? \"translate3d(\" + (cs.translate + \" 0 0\").split(\" \").slice(0, 3).join(\", \") + \") \" : \"\") + (cs.rotate !== \"none\" ? \"rotate(\" + cs.rotate + \") \" : \"\") + (cs.scale !== \"none\" ? \"scale(\" + cs.scale.split(\" \").join(\",\") + \") \" : \"\") + (cs[_transformProp] !== \"none\" ? cs[_transformProp] : \"\");\n        }\n        style.scale = style.rotate = style.translate = \"none\";\n    }\n    matrix = _getMatrix(target, cache.svg);\n    if (cache.svg) {\n        if (cache.uncache) {\n            // if cache.uncache is true (and maybe if origin is 0,0), we need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + \"px \" + (cache.yOrigin - bbox.y) + \"px\". Previously we let the data-svg-origin stay instead, but when introducing revert(), it complicated things.\n            t2 = target.getBBox();\n            origin = cache.xOrigin - t2.x + \"px \" + (cache.yOrigin - t2.y) + \"px\";\n            t1 = \"\";\n        } else {\n            t1 = !uncache && target.getAttribute(\"data-svg-origin\"); //  Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.\n        }\n        _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);\n    }\n    xOrigin = cache.xOrigin || 0;\n    yOrigin = cache.yOrigin || 0;\n    if (matrix !== _identity2DMatrix) {\n        a = matrix[0]; //a11\n        b = matrix[1]; //a21\n        c = matrix[2]; //a31\n        d = matrix[3]; //a41\n        x = a12 = matrix[4];\n        y = a22 = matrix[5]; //2D matrix\n        if (matrix.length === 6) {\n            scaleX = Math.sqrt(a * a + b * b);\n            scaleY = Math.sqrt(d * d + c * c);\n            rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).\n            skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;\n            skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));\n            if (cache.svg) {\n                x -= xOrigin - (xOrigin * a + yOrigin * c);\n                y -= yOrigin - (xOrigin * b + yOrigin * d);\n            } //3D matrix\n        } else {\n            a32 = matrix[6];\n            a42 = matrix[7];\n            a13 = matrix[8];\n            a23 = matrix[9];\n            a33 = matrix[10];\n            a43 = matrix[11];\n            x = matrix[12];\n            y = matrix[13];\n            z = matrix[14];\n            angle = _atan2(a32, a33);\n            rotationX = angle * _RAD2DEG; //rotationX\n            if (angle) {\n                cos = Math.cos(-angle);\n                sin = Math.sin(-angle);\n                t1 = a12 * cos + a13 * sin;\n                t2 = a22 * cos + a23 * sin;\n                t3 = a32 * cos + a33 * sin;\n                a13 = a12 * -sin + a13 * cos;\n                a23 = a22 * -sin + a23 * cos;\n                a33 = a32 * -sin + a33 * cos;\n                a43 = a42 * -sin + a43 * cos;\n                a12 = t1;\n                a22 = t2;\n                a32 = t3;\n            } //rotationY\n            angle = _atan2(-c, a33);\n            rotationY = angle * _RAD2DEG;\n            if (angle) {\n                cos = Math.cos(-angle);\n                sin = Math.sin(-angle);\n                t1 = a * cos - a13 * sin;\n                t2 = b * cos - a23 * sin;\n                t3 = c * cos - a33 * sin;\n                a43 = d * sin + a43 * cos;\n                a = t1;\n                b = t2;\n                c = t3;\n            } //rotationZ\n            angle = _atan2(b, a);\n            rotation = angle * _RAD2DEG;\n            if (angle) {\n                cos = Math.cos(angle);\n                sin = Math.sin(angle);\n                t1 = a * cos + b * sin;\n                t2 = a12 * cos + a22 * sin;\n                b = b * cos - a * sin;\n                a22 = a22 * cos - a12 * sin;\n                a = t1;\n                a12 = t2;\n            }\n            if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {\n                //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.\n                rotationX = rotation = 0;\n                rotationY = 180 - rotationY;\n            }\n            scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a * a + b * b + c * c));\n            scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a22 * a22 + a32 * a32));\n            angle = _atan2(a12, a22);\n            skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;\n            perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;\n        }\n        if (cache.svg) {\n            //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).\n            t1 = target.getAttribute(\"transform\");\n            cache.forceCSS = target.setAttribute(\"transform\", \"\") || !_isNullTransform(_getComputedProperty(target, _transformProp));\n            t1 && target.setAttribute(\"transform\", t1);\n        }\n    }\n    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {\n        if (invertedScaleX) {\n            scaleX *= -1;\n            skewX += rotation <= 0 ? 180 : -180;\n            rotation += rotation <= 0 ? 180 : -180;\n        } else {\n            scaleY *= -1;\n            skewX += skewX <= 0 ? 180 : -180;\n        }\n    }\n    uncache = uncache || cache.uncache;\n    cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;\n    cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;\n    cache.z = z + px;\n    cache.scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleX);\n    cache.scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleY);\n    cache.rotation = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotation) + deg;\n    cache.rotationX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationX) + deg;\n    cache.rotationY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationY) + deg;\n    cache.skewX = skewX + deg;\n    cache.skewY = skewY + deg;\n    cache.transformPerspective = perspective + px;\n    if (cache.zOrigin = parseFloat(origin.split(\" \")[2]) || !uncache && cache.zOrigin || 0) {\n        style[_transformOriginProp] = _firstTwoOnly(origin);\n    }\n    cache.xOffset = cache.yOffset = 0;\n    cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.force3D;\n    cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;\n    cache.uncache = 0;\n    return cache;\n}, _firstTwoOnly = function _firstTwoOnly(value) {\n    return (value = value.split(\" \"))[0] + \" \" + value[1];\n}, //for handling transformOrigin values, stripping out the 3rd dimension\n_addPxTranslate = function _addPxTranslate(target, start, value) {\n    var unit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(start);\n    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(parseFloat(start) + parseFloat(_convertToUnit(target, \"x\", value + \"px\", unit))) + unit;\n}, _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {\n    cache.z = \"0px\";\n    cache.rotationY = cache.rotationX = \"0deg\";\n    cache.force3D = 0;\n    _renderCSSTransforms(ratio, cache);\n}, _zeroDeg = \"0deg\", _zeroPx = \"0px\", _endParenthesis = \") \", _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {\n    var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x = _ref.x, y = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = \"\", use3D = force3D === \"auto\" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)\n    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {\n        var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;\n        angle = parseFloat(rotationX) * _DEG2RAD;\n        cos = Math.cos(angle);\n        x = _addPxTranslate(target, x, a13 * cos * -zOrigin);\n        y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);\n        z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);\n    }\n    if (transformPerspective !== _zeroPx) {\n        transforms += \"perspective(\" + transformPerspective + _endParenthesis;\n    }\n    if (xPercent || yPercent) {\n        transforms += \"translate(\" + xPercent + \"%, \" + yPercent + \"%) \";\n    }\n    if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {\n        transforms += z !== _zeroPx || use3D ? \"translate3d(\" + x + \", \" + y + \", \" + z + \") \" : \"translate(\" + x + \", \" + y + _endParenthesis;\n    }\n    if (rotation !== _zeroDeg) {\n        transforms += \"rotate(\" + rotation + _endParenthesis;\n    }\n    if (rotationY !== _zeroDeg) {\n        transforms += \"rotateY(\" + rotationY + _endParenthesis;\n    }\n    if (rotationX !== _zeroDeg) {\n        transforms += \"rotateX(\" + rotationX + _endParenthesis;\n    }\n    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {\n        transforms += \"skew(\" + skewX + \", \" + skewY + _endParenthesis;\n    }\n    if (scaleX !== 1 || scaleY !== 1) {\n        transforms += \"scale(\" + scaleX + \", \" + scaleY + _endParenthesis;\n    }\n    target.style[_transformProp] = transforms || \"translate(0, 0)\";\n}, _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {\n    var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x = _ref2.x, y = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x), ty = parseFloat(y), a11, a21, a12, a22, temp;\n    rotation = parseFloat(rotation);\n    skewX = parseFloat(skewX);\n    skewY = parseFloat(skewY);\n    if (skewY) {\n        //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.\n        skewY = parseFloat(skewY);\n        skewX += skewY;\n        rotation += skewY;\n    }\n    if (rotation || skewX) {\n        rotation *= _DEG2RAD;\n        skewX *= _DEG2RAD;\n        a11 = Math.cos(rotation) * scaleX;\n        a21 = Math.sin(rotation) * scaleX;\n        a12 = Math.sin(rotation - skewX) * -scaleY;\n        a22 = Math.cos(rotation - skewX) * scaleY;\n        if (skewX) {\n            skewY *= _DEG2RAD;\n            temp = Math.tan(skewX - skewY);\n            temp = Math.sqrt(1 + temp * temp);\n            a12 *= temp;\n            a22 *= temp;\n            if (skewY) {\n                temp = Math.tan(skewY);\n                temp = Math.sqrt(1 + temp * temp);\n                a11 *= temp;\n                a21 *= temp;\n            }\n        }\n        a11 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a11);\n        a21 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a21);\n        a12 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a12);\n        a22 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a22);\n    } else {\n        a11 = scaleX;\n        a22 = scaleY;\n        a21 = a12 = 0;\n    }\n    if (tx && !~(x + \"\").indexOf(\"px\") || ty && !~(y + \"\").indexOf(\"px\")) {\n        tx = _convertToUnit(target, \"x\", x, \"px\");\n        ty = _convertToUnit(target, \"y\", y, \"px\");\n    }\n    if (xOrigin || yOrigin || xOffset || yOffset) {\n        tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);\n        ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);\n    }\n    if (xPercent || yPercent) {\n        //The SVG spec doesn't support percentage-based translation in the \"transform\" attribute, so we merge it into the translation to simulate it.\n        temp = target.getBBox();\n        tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xPercent / 100 * temp.width);\n        ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yPercent / 100 * temp.height);\n    }\n    temp = \"matrix(\" + a11 + \",\" + a21 + \",\" + a12 + \",\" + a22 + \",\" + tx + \",\" + ty + \")\";\n    target.setAttribute(\"transform\", temp);\n    forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the transform attribute changes!)\n}, _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {\n    var cap = 360, isString = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf(\"rad\") ? _RAD2DEG : 1), change = endNum - startNum, finalValue = startNum + change + \"deg\", direction, pt;\n    if (isString) {\n        direction = endValue.split(\"_\")[1];\n        if (direction === \"short\") {\n            change %= cap;\n            if (change !== change % (cap / 2)) {\n                change += change < 0 ? cap : -cap;\n            }\n        }\n        if (direction === \"cw\" && change < 0) {\n            change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;\n        } else if (direction === \"ccw\" && change > 0) {\n            change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;\n        }\n    }\n    plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);\n    pt.e = finalValue;\n    pt.u = \"deg\";\n    plugin._props.push(property);\n    return pt;\n}, _assign = function _assign(target, source) {\n    // Internet Explorer doesn't have Object.assign(), so we recreate it here.\n    for(var p in source){\n        target[p] = source[p];\n    }\n    return target;\n}, _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {\n    //for handling cases where someone passes in a whole transform string, like transform: \"scale(2, 3) rotate(20deg) translateY(30em)\"\n    var startCache = _assign({}, target._gsap), exclude = \"perspective,force3D,transformOrigin,svgOrigin\", style = target.style, endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit;\n    if (startCache.svg) {\n        startValue = target.getAttribute(\"transform\");\n        target.setAttribute(\"transform\", \"\");\n        style[_transformProp] = transforms;\n        endCache = _parseTransform(target, 1);\n        _removeProperty(target, _transformProp);\n        target.setAttribute(\"transform\", startValue);\n    } else {\n        startValue = getComputedStyle(target)[_transformProp];\n        style[_transformProp] = transforms;\n        endCache = _parseTransform(target, 1);\n        style[_transformProp] = startValue;\n    }\n    for(p in _transformProps){\n        startValue = startCache[p];\n        endValue = endCache[p];\n        if (startValue !== endValue && exclude.indexOf(p) < 0) {\n            //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.\n            startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);\n            endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);\n            startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);\n            endNum = parseFloat(endValue);\n            plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);\n            plugin._pt.u = endUnit || 0;\n            plugin._props.push(p);\n        }\n    }\n    _assign(endCache, startCache);\n}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.\n(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(\"padding,margin,Width,Radius\", function(name, index) {\n    var t = \"Top\", r = \"Right\", b = \"Bottom\", l = \"Left\", props = (index < 3 ? [\n        t,\n        r,\n        b,\n        l\n    ] : [\n        t + l,\n        t + r,\n        b + r,\n        b + l\n    ]).map(function(side) {\n        return index < 2 ? name + side : \"border\" + side + name;\n    });\n    _specialProps[index > 1 ? \"border\" + name : name] = function(plugin, target, property, endValue, tween) {\n        var a, vars;\n        if (arguments.length < 4) {\n            // getter, passed target, property, and unit (from _get())\n            a = props.map(function(prop) {\n                return _get(plugin, prop, property);\n            });\n            vars = a.join(\" \");\n            return vars.split(a[0]).length === 5 ? a[0] : vars;\n        }\n        a = (endValue + \"\").split(\" \");\n        vars = {};\n        props.forEach(function(prop, i) {\n            return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];\n        });\n        plugin.init(target, vars, tween);\n    };\n});\nvar CSSPlugin = {\n    name: \"css\",\n    register: _initCore,\n    targetTest: function targetTest(target) {\n        return target.style && target.nodeType;\n    },\n    init: function init(target, vars, tween, index, targets) {\n        var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps;\n        _pluginInitted || _initCore(); // we may call init() multiple times on the same plugin instance, like when adding special properties, so make sure we don't overwrite the revert data or inlineProps\n        this.styles = this.styles || _getStyleSaver(target);\n        inlineProps = this.styles.props;\n        this.tween = tween;\n        for(p in vars){\n            if (p === \"autoRound\") {\n                continue;\n            }\n            endValue = vars[p];\n            if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._plugins[p] && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._checkPlugin)(p, vars, tween, index, target, targets)) {\n                continue;\n            }\n            type = typeof endValue === \"undefined\" ? \"undefined\" : (0,_swc_helpers_type_of__WEBPACK_IMPORTED_MODULE_1__._)(endValue);\n            specialProp = _specialProps[p];\n            if (type === \"function\") {\n                endValue = endValue.call(tween, index, target, targets);\n                type = typeof endValue === \"undefined\" ? \"undefined\" : (0,_swc_helpers_type_of__WEBPACK_IMPORTED_MODULE_1__._)(endValue);\n            }\n            if (type === \"string\" && ~endValue.indexOf(\"random(\")) {\n                endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(endValue);\n            }\n            if (specialProp) {\n                specialProp(this, target, p, endValue, tween) && (hasPriority = 1);\n            } else if (p.substr(0, 2) === \"--\") {\n                //CSS variable\n                startValue = (getComputedStyle(target).getPropertyValue(p) + \"\").trim();\n                endValue += \"\";\n                _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.lastIndex = 0;\n                if (!_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.test(startValue)) {\n                    // colors don't have units\n                    startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);\n                    endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);\n                }\n                endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);\n                this.add(style, \"setProperty\", startValue, endValue, index, targets, 0, 0, p);\n                props.push(p);\n                inlineProps.push(p, 0, style[p]);\n            } else if (type !== \"undefined\") {\n                if (startAt && p in startAt) {\n                    // in case someone hard-codes a complex value as the start, like top: \"calc(2vh / 2)\". Without this, it'd use the computed value (always in px)\n                    startValue = typeof startAt[p] === \"function\" ? startAt[p].call(tween, index, target, targets) : startAt[p];\n                    (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(startValue) && ~startValue.indexOf(\"random(\") && (startValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(startValue));\n                    (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue + \"\") || startValue === \"auto\" || (startValue += _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(_get(target, p)) || \"\"); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.\n                    (startValue + \"\").charAt(1) === \"=\" && (startValue = _get(target, p)); // can't work with relative values\n                } else {\n                    startValue = _get(target, p);\n                }\n                startNum = parseFloat(startValue);\n                relative = type === \"string\" && endValue.charAt(1) === \"=\" && endValue.substr(0, 2);\n                relative && (endValue = endValue.substr(2));\n                endNum = parseFloat(endValue);\n                if (p in _propertyAliases) {\n                    if (p === \"autoAlpha\") {\n                        //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.\n                        if (startNum === 1 && _get(target, \"visibility\") === \"hidden\" && endNum) {\n                            //if visibility is initially set to \"hidden\", we should interpret that as intent to make opacity 0 (a convenience)\n                            startNum = 0;\n                        }\n                        inlineProps.push(\"visibility\", 0, style.visibility);\n                        _addNonTweeningPT(this, style, \"visibility\", startNum ? \"inherit\" : \"hidden\", endNum ? \"inherit\" : \"hidden\", !endNum);\n                    }\n                    if (p !== \"scale\" && p !== \"transform\") {\n                        p = _propertyAliases[p];\n                        ~p.indexOf(\",\") && (p = p.split(\",\")[0]);\n                    }\n                }\n                isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---\n                if (isTransformRelated) {\n                    this.styles.save(p);\n                    if (!transformPropTween) {\n                        cache = target._gsap;\n                        cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:\"translateX(50vw)\"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.\n                        smooth = vars.smoothOrigin !== false && cache.smooth;\n                        transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)\n                        transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.\n                    }\n                    if (p === \"scale\") {\n                        this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, cache, \"scaleY\", cache.scaleY, (relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);\n                        this._pt.u = 0;\n                        props.push(\"scaleY\", p);\n                        p += \"X\";\n                    } else if (p === \"transformOrigin\") {\n                        inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);\n                        endValue = _convertKeywordsToPercentages(endValue); //in case something like \"left top\" or \"bottom right\" is passed in. Convert to percentages.\n                        if (cache.svg) {\n                            _applySVGOrigin(target, endValue, 0, smooth, 0, this);\n                        } else {\n                            endUnit = parseFloat(endValue.split(\" \")[2]) || 0; //handle the zOrigin separately!\n                            endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, \"zOrigin\", cache.zOrigin, endUnit);\n                            _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));\n                        }\n                        continue;\n                    } else if (p === \"svgOrigin\") {\n                        _applySVGOrigin(target, endValue, 1, smooth, 0, this);\n                        continue;\n                    } else if (p in _rotationalProperties) {\n                        _addRotationalPropTween(this, cache, p, startNum, relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endValue) : endValue);\n                        continue;\n                    } else if (p === \"smoothOrigin\") {\n                        _addNonTweeningPT(this, cache, \"smooth\", cache.smooth, endValue);\n                        continue;\n                    } else if (p === \"force3D\") {\n                        cache[p] = endValue;\n                        continue;\n                    } else if (p === \"transform\") {\n                        _addRawTransformPTs(this, endValue, target);\n                        continue;\n                    }\n                } else if (!(p in style)) {\n                    p = _checkPropPrefix(p) || p;\n                }\n                if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {\n                    startUnit = (startValue + \"\").substr((startNum + \"\").length);\n                    endNum || (endNum = 0); // protect against NaN\n                    endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] : startUnit);\n                    startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));\n                    this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === \"px\" || p === \"zIndex\") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);\n                    this._pt.u = endUnit || 0;\n                    if (startUnit !== endUnit && endUnit !== \"%\") {\n                        //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a \"b\" (beginning) property and point to a render method that handles that. (performance optimization)\n                        this._pt.b = startValue;\n                        this._pt.r = _renderCSSPropWithBeginning;\n                    }\n                } else if (!(p in style)) {\n                    if (p in target) {\n                        //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.\n                        this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);\n                    } else if (p !== \"parseTransform\") {\n                        (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._missingPlugin)(p, endValue);\n                        continue;\n                    }\n                } else {\n                    _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);\n                }\n                isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p]));\n                props.push(p);\n            }\n        }\n        hasPriority && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._sortPropTweensByPriority)(this);\n    },\n    render: function render(ratio, data) {\n        if (data.tween._time || !_reverting()) {\n            var pt = data._pt;\n            while(pt){\n                pt.r(ratio, pt.d);\n                pt = pt._next;\n            }\n        } else {\n            data.styles.revert();\n        }\n    },\n    get: _get,\n    aliases: _propertyAliases,\n    getSetter: function getSetter(target, property, plugin) {\n        //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like \"x\" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.\n        var p = _propertyAliases[property];\n        p && p.indexOf(\",\") < 0 && (property = p);\n        return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, \"x\")) ? plugin && _recentSetterPlugin === plugin ? property === \"scale\" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === \"scale\" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf(\"-\") ? _setterCSSProp : (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getSetter)(target, property);\n    },\n    core: {\n        _removeProperty: _removeProperty,\n        _getMatrix: _getMatrix\n    }\n};\n_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.utils.checkPrefix = _checkPropPrefix;\n_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.getStyleSaver = _getStyleSaver;\n(function(positionAndScale, rotation, others, aliases) {\n    var all = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(positionAndScale + \",\" + rotation + \",\" + others, function(name) {\n        _transformProps[name] = 1;\n    });\n    (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(rotation, function(name) {\n        _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = \"deg\";\n        _rotationalProperties[name] = 1;\n    });\n    _propertyAliases[all[13]] = positionAndScale + \",\" + rotation;\n    (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(aliases, function(name) {\n        var split = name.split(\":\");\n        _propertyAliases[split[1]] = all[split[0]];\n    });\n})(\"x,y,z,scale,scaleX,scaleY,xPercent,yPercent\", \"rotation,rotationX,rotationY,skewX,skewY\", \"transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective\", \"0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY\");\n(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(\"x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective\", function(name) {\n    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = \"px\";\n});\n_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(CSSPlugin);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9DU1NQbHVnaW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCO0FBRU07QUFFeEIsSUFBSTJCLE1BQ0FDLE1BQ0FDLGFBQ0FDLGdCQUNBQyxVQUNBQyxnQkFDQUMscUJBQ0FDLFlBQ0FDLGdCQUFnQixTQUFTQTtJQUMzQixPQUFPLE9BQU9DLFdBQVc7QUFDM0IsR0FDSUMsa0JBQWtCLENBQUMsR0FDbkJDLFdBQVcsTUFBTUMsS0FBS0MsRUFBRSxFQUN4QkMsV0FBV0YsS0FBS0MsRUFBRSxHQUFHLEtBQ3JCRSxTQUFTSCxLQUFLSSxLQUFLLEVBQ25CQyxVQUFVLEtBQ1ZDLFdBQVcsWUFDWEMsaUJBQWlCLHdDQUNqQkMsY0FBYyxhQUNkQyxtQkFBbUI7SUFDckJDLFdBQVc7SUFDWEMsT0FBTztJQUNQQyxPQUFPO0FBQ1QsR0FDSUMsaUJBQWlCLFNBQVNBLGVBQWVDLEtBQUssRUFBRUMsSUFBSTtJQUN0RCxPQUFPQSxLQUFLQyxHQUFHLENBQUNELEtBQUtFLENBQUMsRUFBRUYsS0FBS0csQ0FBQyxFQUFFbEIsS0FBS21CLEtBQUssQ0FBQyxDQUFDSixLQUFLSyxDQUFDLEdBQUdMLEtBQUtNLENBQUMsR0FBR1AsS0FBSSxJQUFLLFNBQVMsUUFBUUMsS0FBS08sQ0FBQyxFQUFFUDtBQUNsRyxHQUNJUSxxQkFBcUIsU0FBU0EsbUJBQW1CVCxLQUFLLEVBQUVDLElBQUk7SUFDOUQsT0FBT0EsS0FBS0MsR0FBRyxDQUFDRCxLQUFLRSxDQUFDLEVBQUVGLEtBQUtHLENBQUMsRUFBRUosVUFBVSxJQUFJQyxLQUFLUyxDQUFDLEdBQUd4QixLQUFLbUIsS0FBSyxDQUFDLENBQUNKLEtBQUtLLENBQUMsR0FBR0wsS0FBS00sQ0FBQyxHQUFHUCxLQUFJLElBQUssU0FBUyxRQUFRQyxLQUFLTyxDQUFDLEVB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dkksK0NBQUlBLENBQUMwSCxJQUFJLENBQUNnUSxhQUFhLEdBQUdyUTtBQUV6QixVQUFVc1EsZ0JBQWdCLEVBQUV6RixRQUFRLEVBQUUwRixNQUFNLEVBQUVOLE9BQU87SUFDcEQsSUFBSU8sTUFBTXBYLDJEQUFZQSxDQUFDa1gsbUJBQW1CLE1BQU16RixXQUFXLE1BQU0wRixRQUFRLFNBQVVqQyxJQUFJO1FBQ3JGdFQsZUFBZSxDQUFDc1QsS0FBSyxHQUFHO0lBQzFCO0lBRUFsViwyREFBWUEsQ0FBQ3lSLFVBQVUsU0FBVXlELElBQUk7UUFDbkMxVSxrREFBT0EsQ0FBQzBOLEtBQUssQ0FBQ2dILEtBQUssR0FBRztRQUN0QjVGLHFCQUFxQixDQUFDNEYsS0FBSyxHQUFHO0lBQ2hDO0lBRUEzUyxnQkFBZ0IsQ0FBQzZVLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBR0YsbUJBQW1CLE1BQU16RjtJQUVyRHpSLDJEQUFZQSxDQUFDNlcsU0FBUyxTQUFVM0IsSUFBSTtRQUNsQyxJQUFJL1AsUUFBUStQLEtBQUsvUCxLQUFLLENBQUM7UUFDdkI1QyxnQkFBZ0IsQ0FBQzRDLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBR2lTLEdBQUcsQ0FBQ2pTLEtBQUssQ0FBQyxFQUFFLENBQUM7SUFDNUM7QUFDRixHQUFHLCtDQUErQyw0Q0FBNEMsaUZBQWlGO0FBRS9LbkYsMkRBQVlBLENBQUMsZ0ZBQWdGLFNBQVVrVixJQUFJO0lBQ3pHMVUsa0RBQU9BLENBQUMwTixLQUFLLENBQUNnSCxLQUFLLEdBQUc7QUFDeEI7QUFFQTNWLCtDQUFJQSxDQUFDOFgsY0FBYyxDQUFDN0I7QUFDdUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dzYXBAMy4xMi41L25vZGVfbW9kdWxlcy9nc2FwL0NTU1BsdWdpbi5qcz8yZDdkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ1NTUGx1Z2luIDMuMTIuNVxuICogaHR0cHM6Ly9nc2FwLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDA4LTIwMjQsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3NhcC5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR1NBUCBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCB7IGdzYXAsIF9nZXRQcm9wZXJ0eSwgX251bUV4cCwgX251bVdpdGhVbml0RXhwLCBnZXRVbml0LCBfaXNTdHJpbmcsIF9pc1VuZGVmaW5lZCwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIF9yZWxFeHAsIF9mb3JFYWNoTmFtZSwgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSwgX2NvbG9yU3RyaW5nRmlsdGVyLCBfY2hlY2tQbHVnaW4sIF9yZXBsYWNlUmFuZG9tLCBfcGx1Z2lucywgR1NDYWNoZSwgUHJvcFR3ZWVuLCBfY29uZmlnLCBfdGlja2VyLCBfcm91bmQsIF9taXNzaW5nUGx1Z2luLCBfZ2V0U2V0dGVyLCBfZ2V0Q2FjaGUsIF9jb2xvckV4cCwgX3BhcnNlUmVsYXRpdmUsIF9zZXREZWZhdWx0cywgX3JlbW92ZUxpbmtlZExpc3RJdGVtIC8vZm9yIHRoZSBjb21tZW50ZWQtb3V0IGNsYXNzTmFtZSBmZWF0dXJlLlxufSBmcm9tIFwiLi9nc2FwLWNvcmUuanNcIjtcblxudmFyIF93aW4sXG4gICAgX2RvYyxcbiAgICBfZG9jRWxlbWVudCxcbiAgICBfcGx1Z2luSW5pdHRlZCxcbiAgICBfdGVtcERpdixcbiAgICBfdGVtcERpdlN0eWxlcixcbiAgICBfcmVjZW50U2V0dGVyUGx1Z2luLFxuICAgIF9yZXZlcnRpbmcsXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfdHJhbnNmb3JtUHJvcHMgPSB7fSxcbiAgICBfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG4gICAgX0RFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLFxuICAgIF9hdGFuMiA9IE1hdGguYXRhbjIsXG4gICAgX2JpZ051bSA9IDFlOCxcbiAgICBfY2Fwc0V4cCA9IC8oW0EtWl0pL2csXG4gICAgX2hvcml6b250YWxFeHAgPSAvKGxlZnR8cmlnaHR8d2lkdGh8bWFyZ2lufHBhZGRpbmd8eCkvaSxcbiAgICBfY29tcGxleEV4cCA9IC9bXFxzLFxcKF1cXFMvLFxuICAgIF9wcm9wZXJ0eUFsaWFzZXMgPSB7XG4gIGF1dG9BbHBoYTogXCJvcGFjaXR5LHZpc2liaWxpdHlcIixcbiAgc2NhbGU6IFwic2NhbGVYLHNjYWxlWVwiLFxuICBhbHBoYTogXCJvcGFjaXR5XCJcbn0sXG4gICAgX3JlbmRlckNTU1Byb3AgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTUHJvcChyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwICsgZGF0YS51LCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlclByb3BXaXRoRW5kID0gZnVuY3Rpb24gX3JlbmRlclByb3BXaXRoRW5kKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPT09IDEgPyBkYXRhLmUgOiBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCArIGRhdGEudSwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZyA9IGZ1bmN0aW9uIF9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZyhyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvID8gTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDAgKyBkYXRhLnUgOiBkYXRhLmIsIGRhdGEpO1xufSxcbiAgICAvL2lmIHVuaXRzIGNoYW5nZSwgd2UgbmVlZCBhIHdheSB0byByZW5kZXIgdGhlIG9yaWdpbmFsIHVuaXQvdmFsdWUgd2hlbiB0aGUgdHdlZW4gZ29lcyBhbGwgdGhlIHdheSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgKHJhdGlvOjApXG5fcmVuZGVyUm91bmRlZENTU1Byb3AgPSBmdW5jdGlvbiBfcmVuZGVyUm91bmRlZENTU1Byb3AocmF0aW8sIGRhdGEpIHtcbiAgdmFyIHZhbHVlID0gZGF0YS5zICsgZGF0YS5jICogcmF0aW87XG4gIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCB+fih2YWx1ZSArICh2YWx1ZSA8IDAgPyAtLjUgOiAuNSkpICsgZGF0YS51LCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlck5vblR3ZWVuaW5nVmFsdWUgPSBmdW5jdGlvbiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZShyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvID8gZGF0YS5lIDogZGF0YS5iLCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQgPSBmdW5jdGlvbiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZChyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvICE9PSAxID8gZGF0YS5iIDogZGF0YS5lLCBkYXRhKTtcbn0sXG4gICAgX3NldHRlckNTU1N0eWxlID0gZnVuY3Rpb24gX3NldHRlckNTU1N0eWxlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG59LFxuICAgIF9zZXR0ZXJDU1NQcm9wID0gZnVuY3Rpb24gX3NldHRlckNTU1Byb3AodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xufSxcbiAgICBfc2V0dGVyVHJhbnNmb3JtID0gZnVuY3Rpb24gX3NldHRlclRyYW5zZm9ybSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0Ll9nc2FwW3Byb3BlcnR5XSA9IHZhbHVlO1xufSxcbiAgICBfc2V0dGVyU2NhbGUgPSBmdW5jdGlvbiBfc2V0dGVyU2NhbGUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5fZ3NhcC5zY2FsZVggPSB0YXJnZXQuX2dzYXAuc2NhbGVZID0gdmFsdWU7XG59LFxuICAgIF9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIgPSBmdW5jdGlvbiBfc2V0dGVyU2NhbGVXaXRoUmVuZGVyKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhLCByYXRpbykge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXA7XG4gIGNhY2hlLnNjYWxlWCA9IGNhY2hlLnNjYWxlWSA9IHZhbHVlO1xuICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0ocmF0aW8sIGNhY2hlKTtcbn0sXG4gICAgX3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIgPSBmdW5jdGlvbiBfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlcih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSwgcmF0aW8pIHtcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuICBjYWNoZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgY2FjaGUucmVuZGVyVHJhbnNmb3JtKHJhdGlvLCBjYWNoZSk7XG59LFxuICAgIF90cmFuc2Zvcm1Qcm9wID0gXCJ0cmFuc2Zvcm1cIixcbiAgICBfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF90cmFuc2Zvcm1Qcm9wICsgXCJPcmlnaW5cIixcbiAgICBfc2F2ZVN0eWxlID0gZnVuY3Rpb24gX3NhdmVTdHlsZShwcm9wZXJ0eSwgaXNOb3RDU1MpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQsXG4gICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuXG4gIGlmIChwcm9wZXJ0eSBpbiBfdHJhbnNmb3JtUHJvcHMgJiYgc3R5bGUpIHtcbiAgICB0aGlzLnRmbSA9IHRoaXMudGZtIHx8IHt9O1xuXG4gICAgaWYgKHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICBwcm9wZXJ0eSA9IF9wcm9wZXJ0eUFsaWFzZXNbcHJvcGVydHldIHx8IHByb3BlcnR5O1xuICAgICAgfnByb3BlcnR5LmluZGV4T2YoXCIsXCIpID8gcHJvcGVydHkuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnRmbVthXSA9IF9nZXQodGFyZ2V0LCBhKTtcbiAgICAgIH0pIDogdGhpcy50Zm1bcHJvcGVydHldID0gY2FjaGUueCA/IGNhY2hlW3Byb3BlcnR5XSA6IF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSk7IC8vIG5vdGU6IHNjYWxlIHdvdWxkIG1hcCB0byBcInNjYWxlWCxzY2FsZVlcIiwgdGh1cyB3ZSBsb29wIGFuZCBhcHBseSB0aGVtIGJvdGguXG5cbiAgICAgIHByb3BlcnR5ID09PSBfdHJhbnNmb3JtT3JpZ2luUHJvcCAmJiAodGhpcy50Zm0uek9yaWdpbiA9IGNhY2hlLnpPcmlnaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX3Byb3BlcnR5QWxpYXNlcy50cmFuc2Zvcm0uc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIF9zYXZlU3R5bGUuY2FsbChfdGhpcywgcCwgaXNOb3RDU1MpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMuaW5kZXhPZihfdHJhbnNmb3JtUHJvcCkgPj0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgIHRoaXMuc3ZnbyA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIik7XG4gICAgICB0aGlzLnByb3BzLnB1c2goX3RyYW5zZm9ybU9yaWdpblByb3AsIGlzTm90Q1NTLCBcIlwiKTtcbiAgICB9XG5cbiAgICBwcm9wZXJ0eSA9IF90cmFuc2Zvcm1Qcm9wO1xuICB9XG5cbiAgKHN0eWxlIHx8IGlzTm90Q1NTKSAmJiB0aGlzLnByb3BzLnB1c2gocHJvcGVydHksIGlzTm90Q1NTLCBzdHlsZVtwcm9wZXJ0eV0pO1xufSxcbiAgICBfcmVtb3ZlSW5kZXBlbmRlbnRUcmFuc2Zvcm1zID0gZnVuY3Rpb24gX3JlbW92ZUluZGVwZW5kZW50VHJhbnNmb3JtcyhzdHlsZSkge1xuICBpZiAoc3R5bGUudHJhbnNsYXRlKSB7XG4gICAgc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0cmFuc2xhdGVcIik7XG4gICAgc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJzY2FsZVwiKTtcbiAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eShcInJvdGF0ZVwiKTtcbiAgfVxufSxcbiAgICBfcmV2ZXJ0U3R5bGUgPSBmdW5jdGlvbiBfcmV2ZXJ0U3R5bGUoKSB7XG4gIHZhciBwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldCxcbiAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICBpLFxuICAgICAgcDtcblxuICBmb3IgKGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAvLyBzdG9yZWQgbGlrZSB0aGlzOiBwcm9wZXJ0eSwgaXNOb3RDU1MsIHZhbHVlXG4gICAgcHJvcHNbaSArIDFdID8gdGFyZ2V0W3Byb3BzW2ldXSA9IHByb3BzW2kgKyAyXSA6IHByb3BzW2kgKyAyXSA/IHN0eWxlW3Byb3BzW2ldXSA9IHByb3BzW2kgKyAyXSA6IHN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3BzW2ldLnN1YnN0cigwLCAyKSA9PT0gXCItLVwiID8gcHJvcHNbaV0gOiBwcm9wc1tpXS5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIGlmICh0aGlzLnRmbSkge1xuICAgIGZvciAocCBpbiB0aGlzLnRmbSkge1xuICAgICAgY2FjaGVbcF0gPSB0aGlzLnRmbVtwXTtcbiAgICB9XG5cbiAgICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0oKTtcbiAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIiwgdGhpcy5zdmdvIHx8IFwiXCIpO1xuICAgIH1cblxuICAgIGkgPSBfcmV2ZXJ0aW5nKCk7XG5cbiAgICBpZiAoKCFpIHx8ICFpLmlzU3RhcnQpICYmICFzdHlsZVtfdHJhbnNmb3JtUHJvcF0pIHtcbiAgICAgIF9yZW1vdmVJbmRlcGVuZGVudFRyYW5zZm9ybXMoc3R5bGUpO1xuXG4gICAgICBpZiAoY2FjaGUuek9yaWdpbiAmJiBzdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0pIHtcbiAgICAgICAgc3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdICs9IFwiIFwiICsgY2FjaGUuek9yaWdpbiArIFwicHhcIjsgLy8gc2luY2Ugd2UncmUgdW5jYWNoaW5nLCB3ZSBtdXN0IHB1dCB0aGUgek9yaWdpbiBiYWNrIGludG8gdGhlIHRyYW5zZm9ybU9yaWdpbiBzbyB0aGF0IHdlIGNhbiBwdWxsIGl0IG91dCBhY2N1cmF0ZWx5IHdoZW4gd2UgcGFyc2UgYWdhaW4uIE90aGVyd2lzZSwgd2UnZCBsb3NlIHRoZSB6IHBvcnRpb24gb2YgdGhlIG9yaWdpbiBzaW5jZSB3ZSBleHRyYWN0IGl0IHRvIHByb3RlY3QgZnJvbSBTYWZhcmkgYnVncy5cblxuICAgICAgICBjYWNoZS56T3JpZ2luID0gMDtcbiAgICAgICAgY2FjaGUucmVuZGVyVHJhbnNmb3JtKCk7XG4gICAgICB9XG5cbiAgICAgIGNhY2hlLnVuY2FjaGUgPSAxOyAvLyBpZiBpdCdzIGEgc3RhcnRBdCB0aGF0J3MgYmVpbmcgcmV2ZXJ0ZWQgaW4gdGhlIF9pbml0VHdlZW4oKSBvZiB0aGUgY29yZSwgd2UgZG9uJ3QgbmVlZCB0byB1bmNhY2hlIHRyYW5zZm9ybXMuIFRoaXMgaXMgcHVyZWx5IGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLlxuICAgIH1cbiAgfVxufSxcbiAgICBfZ2V0U3R5bGVTYXZlciA9IGZ1bmN0aW9uIF9nZXRTdHlsZVNhdmVyKHRhcmdldCwgcHJvcGVydGllcykge1xuICB2YXIgc2F2ZXIgPSB7XG4gICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgcHJvcHM6IFtdLFxuICAgIHJldmVydDogX3JldmVydFN0eWxlLFxuICAgIHNhdmU6IF9zYXZlU3R5bGVcbiAgfTtcbiAgdGFyZ2V0Ll9nc2FwIHx8IGdzYXAuY29yZS5nZXRDYWNoZSh0YXJnZXQpOyAvLyBqdXN0IG1ha2Ugc3VyZSB0aGVyZSdzIGEgX2dzYXAgY2FjaGUgZGVmaW5lZCBiZWNhdXNlIHdlIHJlYWQgZnJvbSBpdCBpbiBfc2F2ZVN0eWxlKCkgYW5kIGl0J3MgbW9yZSBlZmZpY2llbnQgdG8ganVzdCBjaGVjayBpdCBoZXJlIG9uY2UuXG5cbiAgcHJvcGVydGllcyAmJiBwcm9wZXJ0aWVzLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHNhdmVyLnNhdmUocCk7XG4gIH0pO1xuICByZXR1cm4gc2F2ZXI7XG59LFxuICAgIF9zdXBwb3J0czNELFxuICAgIF9jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQodHlwZSwgbnMpIHtcbiAgdmFyIGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyA/IF9kb2MuY3JlYXRlRWxlbWVudE5TKChucyB8fCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIikucmVwbGFjZSgvXmh0dHBzLywgXCJodHRwXCIpLCB0eXBlKSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIHNlcnZlcnMgc3dhcCBpbiBodHRwcyBmb3IgaHR0cCBpbiB0aGUgbmFtZXNwYWNlIHdoaWNoIGNhbiBicmVhayB0aGluZ3MsIG1ha2luZyBcInN0eWxlXCIgaW5hY2Nlc3NpYmxlLlxuXG4gIHJldHVybiBlICYmIGUuc3R5bGUgPyBlIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpOyAvL3NvbWUgZW52aXJvbm1lbnRzIHdvbid0IGFsbG93IGFjY2VzcyB0byB0aGUgZWxlbWVudCdzIHN0eWxlIHdoZW4gY3JlYXRlZCB3aXRoIGEgbmFtZXNwYWNlIGluIHdoaWNoIGNhc2Ugd2UgZGVmYXVsdCB0byB0aGUgc3RhbmRhcmQgY3JlYXRlRWxlbWVudCgpIHRvIHdvcmsgYXJvdW5kIHRoZSBpc3N1ZS4gQWxzbyBub3RlIHRoYXQgd2hlbiBHU0FQIGlzIGVtYmVkZGVkIGRpcmVjdGx5IGluc2lkZSBhbiBTVkcgZmlsZSwgY3JlYXRlRWxlbWVudCgpIHdvbid0IGFsbG93IGFjY2VzcyB0byB0aGUgc3R5bGUgb2JqZWN0IGluIEZpcmVmb3ggKHNlZSBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8yMDIxNS1wcm9ibGVtLXVzaW5nLXR3ZWVubWF4LWluLXN0YW5kYWxvbmUtc2VsZi1jb250YWluaW5nLXN2Zy1maWxlLWVyci1jYW5ub3Qtc2V0LXByb3BlcnR5LWNzc3RleHQtb2YtdW5kZWZpbmVkLykuXG59LFxuICAgIF9nZXRDb21wdXRlZFByb3BlcnR5ID0gZnVuY3Rpb24gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgc2tpcFByZWZpeEZhbGxiYWNrKSB7XG4gIHZhciBjcyA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgcmV0dXJuIGNzW3Byb3BlcnR5XSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5LnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpIHx8IGNzLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpIHx8ICFza2lwUHJlZml4RmFsbGJhY2sgJiYgX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfY2hlY2tQcm9wUHJlZml4KHByb3BlcnR5KSB8fCBwcm9wZXJ0eSwgMSkgfHwgXCJcIjsgLy9jc3MgdmFyaWFibGVzIG1heSBub3QgbmVlZCBjYXBzIHN3YXBwZWQgb3V0IGZvciBkYXNoZXMgYW5kIGxvd2VyY2FzZS5cbn0sXG4gICAgX3ByZWZpeGVzID0gXCJPLE1veixtcyxNcyxXZWJraXRcIi5zcGxpdChcIixcIiksXG4gICAgX2NoZWNrUHJvcFByZWZpeCA9IGZ1bmN0aW9uIF9jaGVja1Byb3BQcmVmaXgocHJvcGVydHksIGVsZW1lbnQsIHByZWZlclByZWZpeCkge1xuICB2YXIgZSA9IGVsZW1lbnQgfHwgX3RlbXBEaXYsXG4gICAgICBzID0gZS5zdHlsZSxcbiAgICAgIGkgPSA1O1xuXG4gIGlmIChwcm9wZXJ0eSBpbiBzICYmICFwcmVmZXJQcmVmaXgpIHtcbiAgICByZXR1cm4gcHJvcGVydHk7XG4gIH1cblxuICBwcm9wZXJ0eSA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc3Vic3RyKDEpO1xuXG4gIHdoaWxlIChpLS0gJiYgIShfcHJlZml4ZXNbaV0gKyBwcm9wZXJ0eSBpbiBzKSkge31cblxuICByZXR1cm4gaSA8IDAgPyBudWxsIDogKGkgPT09IDMgPyBcIm1zXCIgOiBpID49IDAgPyBfcHJlZml4ZXNbaV0gOiBcIlwiKSArIHByb3BlcnR5O1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoKSB7XG4gIGlmIChfd2luZG93RXhpc3RzKCkgJiYgd2luZG93LmRvY3VtZW50KSB7XG4gICAgX3dpbiA9IHdpbmRvdztcbiAgICBfZG9jID0gX3dpbi5kb2N1bWVudDtcbiAgICBfZG9jRWxlbWVudCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIF90ZW1wRGl2ID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIikgfHwge1xuICAgICAgc3R5bGU6IHt9XG4gICAgfTtcbiAgICBfdGVtcERpdlN0eWxlciA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIF90cmFuc2Zvcm1Qcm9wID0gX2NoZWNrUHJvcFByZWZpeChfdHJhbnNmb3JtUHJvcCk7XG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfdHJhbnNmb3JtUHJvcCArIFwiT3JpZ2luXCI7XG4gICAgX3RlbXBEaXYuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyLXdpZHRoOjA7bGluZS1oZWlnaHQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtwYWRkaW5nOjBcIjsgLy9tYWtlIHN1cmUgdG8gb3ZlcnJpZGUgY2VydGFpbiBwcm9wZXJ0aWVzIHRoYXQgbWF5IGNvbnRhbWluYXRlIG1lYXN1cmVtZW50cywgaW4gY2FzZSB0aGUgdXNlciBoYXMgb3ZlcnJlYWNoaW5nIHN0eWxlIHNoZWV0cy5cblxuICAgIF9zdXBwb3J0czNEID0gISFfY2hlY2tQcm9wUHJlZml4KFwicGVyc3BlY3RpdmVcIik7XG4gICAgX3JldmVydGluZyA9IGdzYXAuY29yZS5yZXZlcnRpbmc7XG4gICAgX3BsdWdpbkluaXR0ZWQgPSAxO1xuICB9XG59LFxuICAgIF9nZXRCQm94SGFjayA9IGZ1bmN0aW9uIF9nZXRCQm94SGFjayhzd2FwSWZQb3NzaWJsZSkge1xuICAvL3dvcmtzIGFyb3VuZCBpc3N1ZXMgaW4gc29tZSBicm93c2VycyAobGlrZSBGaXJlZm94KSB0aGF0IGRvbid0IGNvcnJlY3RseSByZXBvcnQgZ2V0QkJveCgpIG9uIFNWRyBlbGVtZW50cyBpbnNpZGUgYSA8ZGVmcz4gZWxlbWVudCBhbmQvb3IgPG1hc2s+LiBXZSB0cnkgY3JlYXRpbmcgYW4gU1ZHLCBhZGRpbmcgaXQgdG8gdGhlIGRvY3VtZW50RWxlbWVudCBhbmQgdG9zcyB0aGUgZWxlbWVudCBpbiB0aGVyZSBzbyB0aGF0IGl0J3MgZGVmaW5pdGVseSBwYXJ0IG9mIHRoZSByZW5kZXJpbmcgdHJlZSwgdGhlbiBncmFiIHRoZSBiYm94IGFuZCBpZiBpdCB3b3Jrcywgd2UgYWN0dWFsbHkgc3dhcCBvdXQgdGhlIG9yaWdpbmFsIGdldEJCb3goKSBtZXRob2QgZm9yIG91ciBvd24gdGhhdCBkb2VzIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW5ldmVyIGdldEJCb3ggaXMgbmVlZGVkLiBUaGlzIGhlbHBzIGVuc3VyZSB0aGF0IHBlcmZvcm1hbmNlIGlzIG9wdGltYWwgKG9ubHkgZG8gYWxsIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW4gYWJzb2x1dGVseSBuZWNlc3NhcnkuLi5tb3N0IGVsZW1lbnRzIGRvbid0IG5lZWQgaXQpLlxuICB2YXIgc3ZnID0gX2NyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgdGhpcy5vd25lclNWR0VsZW1lbnQgJiYgdGhpcy5vd25lclNWR0VsZW1lbnQuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKSxcbiAgICAgIG9sZFBhcmVudCA9IHRoaXMucGFyZW50Tm9kZSxcbiAgICAgIG9sZFNpYmxpbmcgPSB0aGlzLm5leHRTaWJsaW5nLFxuICAgICAgb2xkQ1NTID0gdGhpcy5zdHlsZS5jc3NUZXh0LFxuICAgICAgYmJveDtcblxuICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZChzdmcpO1xuXG4gIHN2Zy5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gIGlmIChzd2FwSWZQb3NzaWJsZSkge1xuICAgIHRyeSB7XG4gICAgICBiYm94ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgICB0aGlzLl9nc2FwQkJveCA9IHRoaXMuZ2V0QkJveDsgLy9zdG9yZSB0aGUgb3JpZ2luYWxcblxuICAgICAgdGhpcy5nZXRCQm94ID0gX2dldEJCb3hIYWNrO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0gZWxzZSBpZiAodGhpcy5fZ3NhcEJCb3gpIHtcbiAgICBiYm94ID0gdGhpcy5fZ3NhcEJCb3goKTtcbiAgfVxuXG4gIGlmIChvbGRQYXJlbnQpIHtcbiAgICBpZiAob2xkU2libGluZykge1xuICAgICAgb2xkUGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBvbGRTaWJsaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkUGFyZW50LmFwcGVuZENoaWxkKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHN2Zyk7XG5cbiAgdGhpcy5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTO1xuICByZXR1cm4gYmJveDtcbn0sXG4gICAgX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyA9IGZ1bmN0aW9uIF9nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBhdHRyaWJ1dGVzQXJyYXkpIHtcbiAgdmFyIGkgPSBhdHRyaWJ1dGVzQXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVzQXJyYXlbaV0pKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVzQXJyYXlbaV0pO1xuICAgIH1cbiAgfVxufSxcbiAgICBfZ2V0QkJveCA9IGZ1bmN0aW9uIF9nZXRCQm94KHRhcmdldCkge1xuICB2YXIgYm91bmRzO1xuXG4gIHRyeSB7XG4gICAgYm91bmRzID0gdGFyZ2V0LmdldEJCb3goKTsgLy9GaXJlZm94IHRocm93cyBlcnJvcnMgaWYgeW91IHRyeSBjYWxsaW5nIGdldEJCb3goKSBvbiBhbiBTVkcgZWxlbWVudCB0aGF0J3Mgbm90IHJlbmRlcmVkIChsaWtlIGluIGEgPHN5bWJvbD4gb3IgPGRlZnM+KS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjEyMTE4XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgYm91bmRzID0gX2dldEJCb3hIYWNrLmNhbGwodGFyZ2V0LCB0cnVlKTtcbiAgfVxuXG4gIGJvdW5kcyAmJiAoYm91bmRzLndpZHRoIHx8IGJvdW5kcy5oZWlnaHQpIHx8IHRhcmdldC5nZXRCQm94ID09PSBfZ2V0QkJveEhhY2sgfHwgKGJvdW5kcyA9IF9nZXRCQm94SGFjay5jYWxsKHRhcmdldCwgdHJ1ZSkpOyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgbWlzcmVwb3J0IHRoZSBib3VuZHMgaWYgdGhlIGVsZW1lbnQgaGFzIHplcm8gd2lkdGggYW5kIGhlaWdodCAoaXQganVzdCBhc3N1bWVzIGl0J3MgYXQgeDowLCB5OjApLCB0aHVzIHdlIG5lZWQgdG8gbWFudWFsbHkgZ3JhYiB0aGUgcG9zaXRpb24gaW4gdGhhdCBjYXNlLlxuXG4gIHJldHVybiBib3VuZHMgJiYgIWJvdW5kcy53aWR0aCAmJiAhYm91bmRzLnggJiYgIWJvdW5kcy55ID8ge1xuICAgIHg6ICtfZ2V0QXR0cmlidXRlRmFsbGJhY2tzKHRhcmdldCwgW1wieFwiLCBcImN4XCIsIFwieDFcIl0pIHx8IDAsXG4gICAgeTogK19nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBbXCJ5XCIsIFwiY3lcIiwgXCJ5MVwiXSkgfHwgMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSA6IGJvdW5kcztcbn0sXG4gICAgX2lzU1ZHID0gZnVuY3Rpb24gX2lzU1ZHKGUpIHtcbiAgcmV0dXJuICEhKGUuZ2V0Q1RNICYmICghZS5wYXJlbnROb2RlIHx8IGUub3duZXJTVkdFbGVtZW50KSAmJiBfZ2V0QkJveChlKSk7XG59LFxuICAgIC8vcmVwb3J0cyBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkcgb24gd2hpY2ggZ2V0QkJveCgpIGFjdHVhbGx5IHdvcmtzXG5fcmVtb3ZlUHJvcGVydHkgPSBmdW5jdGlvbiBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkpIHtcbiAgICB2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgIGZpcnN0MkNoYXJzO1xuXG4gICAgaWYgKHByb3BlcnR5IGluIF90cmFuc2Zvcm1Qcm9wcyAmJiBwcm9wZXJ0eSAhPT0gX3RyYW5zZm9ybU9yaWdpblByb3ApIHtcbiAgICAgIHByb3BlcnR5ID0gX3RyYW5zZm9ybVByb3A7XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlLnJlbW92ZVByb3BlcnR5KSB7XG4gICAgICBmaXJzdDJDaGFycyA9IHByb3BlcnR5LnN1YnN0cigwLCAyKTtcblxuICAgICAgaWYgKGZpcnN0MkNoYXJzID09PSBcIm1zXCIgfHwgcHJvcGVydHkuc3Vic3RyKDAsIDYpID09PSBcIndlYmtpdFwiKSB7XG4gICAgICAgIC8vTWljcm9zb2Z0IGFuZCBzb21lIFdlYmtpdCBicm93c2VycyBkb24ndCBjb25mb3JtIHRvIHRoZSBzdGFuZGFyZCBvZiBjYXBpdGFsaXppbmcgdGhlIGZpcnN0IHByZWZpeCBjaGFyYWN0ZXIsIHNvIHdlIGFkanVzdCBzbyB0aGF0IHdoZW4gd2UgcHJlZml4IHRoZSBjYXBzIHdpdGggYSBkYXNoLCBpdCdzIGNvcnJlY3QgKG90aGVyd2lzZSBpdCdkIGJlIFwibXMtdHJhbnNmb3JtXCIgaW5zdGVhZCBvZiBcIi1tcy10cmFuc2Zvcm1cIiBmb3IgSUU5LCBmb3IgZXhhbXBsZSlcbiAgICAgICAgcHJvcGVydHkgPSBcIi1cIiArIHByb3BlcnR5O1xuICAgICAgfVxuXG4gICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eShmaXJzdDJDaGFycyA9PT0gXCItLVwiID8gcHJvcGVydHkgOiBwcm9wZXJ0eS5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy9ub3RlOiBvbGQgdmVyc2lvbnMgb2YgSUUgdXNlIFwicmVtb3ZlQXR0cmlidXRlKClcIiBpbnN0ZWFkIG9mIFwicmVtb3ZlUHJvcGVydHkoKVwiXG4gICAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUocHJvcGVydHkpO1xuICAgIH1cbiAgfVxufSxcbiAgICBfYWRkTm9uVHdlZW5pbmdQVCA9IGZ1bmN0aW9uIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgYmVnaW5uaW5nLCBlbmQsIG9ubHlTZXRBdEVuZCkge1xuICB2YXIgcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIDAsIDEsIG9ubHlTZXRBdEVuZCA/IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kIDogX3JlbmRlck5vblR3ZWVuaW5nVmFsdWUpO1xuICBwbHVnaW4uX3B0ID0gcHQ7XG4gIHB0LmIgPSBiZWdpbm5pbmc7XG4gIHB0LmUgPSBlbmQ7XG5cbiAgcGx1Z2luLl9wcm9wcy5wdXNoKHByb3BlcnR5KTtcblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9ub25Db252ZXJ0aWJsZVVuaXRzID0ge1xuICBkZWc6IDEsXG4gIHJhZDogMSxcbiAgdHVybjogMVxufSxcbiAgICBfbm9uU3RhbmRhcmRMYXlvdXRzID0ge1xuICBncmlkOiAxLFxuICBmbGV4OiAxXG59LFxuICAgIC8vdGFrZXMgYSBzaW5nbGUgdmFsdWUgbGlrZSAyMHB4IGFuZCBjb252ZXJ0cyBpdCB0byB0aGUgdW5pdCBzcGVjaWZpZWQsIGxpa2UgXCIlXCIsIHJldHVybmluZyBvbmx5IHRoZSBudW1lcmljIGFtb3VudC5cbl9jb252ZXJ0VG9Vbml0ID0gZnVuY3Rpb24gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHVuaXQpIHtcbiAgdmFyIGN1clZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMCxcbiAgICAgIGN1clVuaXQgPSAodmFsdWUgKyBcIlwiKS50cmltKCkuc3Vic3RyKChjdXJWYWx1ZSArIFwiXCIpLmxlbmd0aCkgfHwgXCJweFwiLFxuICAgICAgLy8gc29tZSBicm93c2VycyBsZWF2ZSBleHRyYSB3aGl0ZXNwYWNlIGF0IHRoZSBiZWdpbm5pbmcgb2YgQ1NTIHZhcmlhYmxlcywgaGVuY2UgdGhlIG5lZWQgdG8gdHJpbSgpXG4gIHN0eWxlID0gX3RlbXBEaXYuc3R5bGUsXG4gICAgICBob3Jpem9udGFsID0gX2hvcml6b250YWxFeHAudGVzdChwcm9wZXJ0eSksXG4gICAgICBpc1Jvb3RTVkcgPSB0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiLFxuICAgICAgbWVhc3VyZVByb3BlcnR5ID0gKGlzUm9vdFNWRyA/IFwiY2xpZW50XCIgOiBcIm9mZnNldFwiKSArIChob3Jpem9udGFsID8gXCJXaWR0aFwiIDogXCJIZWlnaHRcIiksXG4gICAgICBhbW91bnQgPSAxMDAsXG4gICAgICB0b1BpeGVscyA9IHVuaXQgPT09IFwicHhcIixcbiAgICAgIHRvUGVyY2VudCA9IHVuaXQgPT09IFwiJVwiLFxuICAgICAgcHgsXG4gICAgICBwYXJlbnQsXG4gICAgICBjYWNoZSxcbiAgICAgIGlzU1ZHO1xuXG4gIGlmICh1bml0ID09PSBjdXJVbml0IHx8ICFjdXJWYWx1ZSB8fCBfbm9uQ29udmVydGlibGVVbml0c1t1bml0XSB8fCBfbm9uQ29udmVydGlibGVVbml0c1tjdXJVbml0XSkge1xuICAgIHJldHVybiBjdXJWYWx1ZTtcbiAgfVxuXG4gIGN1clVuaXQgIT09IFwicHhcIiAmJiAhdG9QaXhlbHMgJiYgKGN1clZhbHVlID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIFwicHhcIikpO1xuICBpc1NWRyA9IHRhcmdldC5nZXRDVE0gJiYgX2lzU1ZHKHRhcmdldCk7XG5cbiAgaWYgKCh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldIHx8IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikpKSB7XG4gICAgcHggPSBpc1NWRyA/IHRhcmdldC5nZXRCQm94KClbaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdIDogdGFyZ2V0W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgcmV0dXJuIF9yb3VuZCh0b1BlcmNlbnQgPyBjdXJWYWx1ZSAvIHB4ICogYW1vdW50IDogY3VyVmFsdWUgLyAxMDAgKiBweCk7XG4gIH1cblxuICBzdHlsZVtob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gPSBhbW91bnQgKyAodG9QaXhlbHMgPyBjdXJVbml0IDogdW5pdCk7XG4gIHBhcmVudCA9IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikgfHwgdW5pdCA9PT0gXCJlbVwiICYmIHRhcmdldC5hcHBlbmRDaGlsZCAmJiAhaXNSb290U1ZHID8gdGFyZ2V0IDogdGFyZ2V0LnBhcmVudE5vZGU7XG5cbiAgaWYgKGlzU1ZHKSB7XG4gICAgcGFyZW50ID0gKHRhcmdldC5vd25lclNWR0VsZW1lbnQgfHwge30pLnBhcmVudE5vZGU7XG4gIH1cblxuICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT09IF9kb2MgfHwgIXBhcmVudC5hcHBlbmRDaGlsZCkge1xuICAgIHBhcmVudCA9IF9kb2MuYm9keTtcbiAgfVxuXG4gIGNhY2hlID0gcGFyZW50Ll9nc2FwO1xuXG4gIGlmIChjYWNoZSAmJiB0b1BlcmNlbnQgJiYgY2FjaGUud2lkdGggJiYgaG9yaXpvbnRhbCAmJiBjYWNoZS50aW1lID09PSBfdGlja2VyLnRpbWUgJiYgIWNhY2hlLnVuY2FjaGUpIHtcbiAgICByZXR1cm4gX3JvdW5kKGN1clZhbHVlIC8gY2FjaGUud2lkdGggKiBhbW91bnQpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0b1BlcmNlbnQgJiYgKHByb3BlcnR5ID09PSBcImhlaWdodFwiIHx8IHByb3BlcnR5ID09PSBcIndpZHRoXCIpKSB7XG4gICAgICAvLyBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggd2lkdGgvaGVpZ2h0IHRoYXQncyBpbnNpZGUgYSBjb250YWluZXIgd2l0aCBwYWRkaW5nIGFuZC9vciBpdCdzIGEgZmxleGJveC9ncmlkIGNvbnRhaW5lciwgd2UgbXVzdCBhcHBseSBpdCB0byB0aGUgdGFyZ2V0IGl0c2VsZiByYXRoZXIgdGhhbiB0aGUgX3RlbXBEaXYgaW4gb3JkZXIgdG8gZW5zdXJlIGNvbXBsZXRlIGFjY3VyYWN5LCBmYWN0b3JpbmcgaW4gdGhlIHBhcmVudCdzIHBhZGRpbmcuXG4gICAgICB2YXIgdiA9IHRhcmdldC5zdHlsZVtwcm9wZXJ0eV07XG4gICAgICB0YXJnZXQuc3R5bGVbcHJvcGVydHldID0gYW1vdW50ICsgdW5pdDtcbiAgICAgIHB4ID0gdGFyZ2V0W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgICB2ID8gdGFyZ2V0LnN0eWxlW3Byb3BlcnR5XSA9IHYgOiBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmICFfbm9uU3RhbmRhcmRMYXlvdXRzW19nZXRDb21wdXRlZFByb3BlcnR5KHBhcmVudCwgXCJkaXNwbGF5XCIpXSAmJiAoc3R5bGUucG9zaXRpb24gPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIFwicG9zaXRpb25cIikpO1xuICAgICAgcGFyZW50ID09PSB0YXJnZXQgJiYgKHN0eWxlLnBvc2l0aW9uID0gXCJzdGF0aWNcIik7IC8vIGxpa2UgZm9yIGJvcmRlclJhZGl1cywgaWYgaXQncyBhICUgd2UgbXVzdCBoYXZlIGl0IHJlbGF0aXZlIHRvIHRoZSB0YXJnZXQgaXRzZWxmIGJ1dCB0aGF0IG1heSBub3QgaGF2ZSBwb3NpdGlvbjogcmVsYXRpdmUgb3IgcG9zaXRpb246IGFic29sdXRlIGluIHdoaWNoIGNhc2UgaXQnZCBnbyB1cCB0aGUgY2hhaW4gdW50aWwgaXQgZmluZHMgaXRzIG9mZnNldFBhcmVudCAoYmFkKS4gcG9zaXRpb246IHN0YXRpYyBwcm90ZWN0cyBhZ2FpbnN0IHRoYXQuXG5cbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChfdGVtcERpdik7XG4gICAgICBweCA9IF90ZW1wRGl2W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoX3RlbXBEaXYpO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgfVxuXG4gICAgaWYgKGhvcml6b250YWwgJiYgdG9QZXJjZW50KSB7XG4gICAgICBjYWNoZSA9IF9nZXRDYWNoZShwYXJlbnQpO1xuICAgICAgY2FjaGUudGltZSA9IF90aWNrZXIudGltZTtcbiAgICAgIGNhY2hlLndpZHRoID0gcGFyZW50W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9yb3VuZCh0b1BpeGVscyA/IHB4ICogY3VyVmFsdWUgLyBhbW91bnQgOiBweCAmJiBjdXJWYWx1ZSA/IGFtb3VudCAvIHB4ICogY3VyVmFsdWUgOiAwKTtcbn0sXG4gICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICB2YXIgdmFsdWU7XG4gIF9wbHVnaW5Jbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuXG4gIGlmIChwcm9wZXJ0eSBpbiBfcHJvcGVydHlBbGlhc2VzICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgcHJvcGVydHkgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XTtcblxuICAgIGlmICh+cHJvcGVydHkuaW5kZXhPZihcIixcIikpIHtcbiAgICAgIHByb3BlcnR5ID0gcHJvcGVydHkuc3BsaXQoXCIsXCIpWzBdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgdmFsdWUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB1bmNhY2hlKTtcbiAgICB2YWx1ZSA9IHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybU9yaWdpblwiID8gdmFsdWVbcHJvcGVydHldIDogdmFsdWUuc3ZnID8gdmFsdWUub3JpZ2luIDogX2ZpcnN0VHdvT25seShfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSkgKyBcIiBcIiArIHZhbHVlLnpPcmlnaW4gKyBcInB4XCI7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0YXJnZXQuc3R5bGVbcHJvcGVydHldO1xuXG4gICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJhdXRvXCIgfHwgdW5jYWNoZSB8fCB+KHZhbHVlICsgXCJcIikuaW5kZXhPZihcImNhbGMoXCIpKSB7XG4gICAgICB2YWx1ZSA9IF9zcGVjaWFsUHJvcHNbcHJvcGVydHldICYmIF9zcGVjaWFsUHJvcHNbcHJvcGVydHldKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHx8IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHx8IF9nZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSB8fCAocHJvcGVydHkgPT09IFwib3BhY2l0eVwiID8gMSA6IDApOyAvLyBub3RlOiBzb21lIGJyb3dzZXJzLCBsaWtlIEZpcmVmb3gsIGRvbid0IHJlcG9ydCBib3JkZXJSYWRpdXMgY29ycmVjdGx5ISBJbnN0ZWFkLCBpdCBvbmx5IHJlcG9ydHMgZXZlcnkgY29ybmVyIGxpa2UgIGJvcmRlclRvcExlZnRSYWRpdXNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5pdCAmJiAhfih2YWx1ZSArIFwiXCIpLnRyaW0oKS5pbmRleE9mKFwiIFwiKSA/IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCB1bml0KSArIHVuaXQgOiB2YWx1ZTtcbn0sXG4gICAgX3R3ZWVuQ29tcGxleENTU1N0cmluZyA9IGZ1bmN0aW9uIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcodGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kKSB7XG4gIC8vIG5vdGU6IHdlIGNhbGwgX3R3ZWVuQ29tcGxleENTU1N0cmluZy5jYWxsKHBsdWdpbkluc3RhbmNlLi4uKSB0byBlbnN1cmUgdGhhdCBpdCdzIHNjb3BlZCBwcm9wZXJseS4gV2UgbWF5IGNhbGwgaXQgZnJvbSB3aXRoaW4gYSBwbHVnaW4gdG9vLCB0aHVzIFwidGhpc1wiIHdvdWxkIHJlZmVyIHRvIHRoZSBwbHVnaW4uXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPT09IFwibm9uZVwiKSB7XG4gICAgLy8gc29tZSBicm93c2VycyBsaWtlIFNhZmFyaSBhY3R1YWxseSBQUkVGRVIgdGhlIHByZWZpeGVkIHByb3BlcnR5IGFuZCBtaXMtcmVwb3J0IHRoZSB1bnByZWZpeGVkIHZhbHVlIGxpa2UgY2xpcFBhdGggKEJVRykuIEluIG90aGVyIHdvcmRzLCBldmVuIHRob3VnaCBjbGlwUGF0aCBleGlzdHMgaW4gdGhlIHN0eWxlIChcImNsaXBQYXRoXCIgaW4gdGFyZ2V0LnN0eWxlKSBhbmQgaXQncyBzZXQgaW4gdGhlIENTUyBwcm9wZXJseSAoYWxvbmcgd2l0aCAtd2Via2l0LWNsaXAtcGF0aCksIFNhZmFyaSByZXBvcnRzIGNsaXBQYXRoIGFzIFwibm9uZVwiIHdoZXJlYXMgV2Via2l0Q2xpcFBhdGggcmVwb3J0cyBhY2N1cmF0ZWx5IGxpa2UgXCJlbGxpcHNlKDEwMCUgMCUgYXQgNTAlIDAlKVwiLCBzbyBpbiB0aGlzIGNhc2Ugd2UgbXVzdCBTV0lUQ0ggdG8gdXNpbmcgdGhlIHByZWZpeGVkIHByb3BlcnR5IGluc3RlYWQuIFNlZSBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8xODMxMC1jbGlwcGF0aC1kb2VzbnQtd29yay1vbi1pb3MvXG4gICAgdmFyIHAgPSBfY2hlY2tQcm9wUHJlZml4KHByb3AsIHRhcmdldCwgMSksXG4gICAgICAgIHMgPSBwICYmIF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcCwgMSk7XG5cbiAgICBpZiAocyAmJiBzICE9PSBzdGFydCkge1xuICAgICAgcHJvcCA9IHA7XG4gICAgICBzdGFydCA9IHM7XG4gICAgfSBlbHNlIGlmIChwcm9wID09PSBcImJvcmRlckNvbG9yXCIpIHtcbiAgICAgIHN0YXJ0ID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBcImJvcmRlclRvcENvbG9yXCIpOyAvLyBGaXJlZm94IGJ1ZzogYWx3YXlzIHJlcG9ydHMgXCJib3JkZXJDb2xvclwiIGFzIFwiXCIsIHNvIHdlIG11c3QgZmFsbCBiYWNrIHRvIGJvcmRlclRvcENvbG9yLiBTZWUgaHR0cHM6Ly9nc2FwLmNvbS9mb3J1bXMvdG9waWMvMjQ1ODMtaG93LXRvLXJldHVybi1jb2xvcnMtdGhhdC1pLWhhZC1hZnRlci1yZXZlcnNlL1xuICAgIH1cbiAgfVxuXG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldC5zdHlsZSwgcHJvcCwgMCwgMSwgX3JlbmRlckNvbXBsZXhTdHJpbmcpLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgbWF0Y2hJbmRleCA9IDAsXG4gICAgICBhLFxuICAgICAgcmVzdWx0LFxuICAgICAgc3RhcnRWYWx1ZXMsXG4gICAgICBzdGFydE51bSxcbiAgICAgIGNvbG9yLFxuICAgICAgc3RhcnRWYWx1ZSxcbiAgICAgIGVuZFZhbHVlLFxuICAgICAgZW5kTnVtLFxuICAgICAgY2h1bmssXG4gICAgICBlbmRVbml0LFxuICAgICAgc3RhcnRVbml0LFxuICAgICAgZW5kVmFsdWVzO1xuICBwdC5iID0gc3RhcnQ7XG4gIHB0LmUgPSBlbmQ7XG4gIHN0YXJ0ICs9IFwiXCI7IC8vIGVuc3VyZSB2YWx1ZXMgYXJlIHN0cmluZ3NcblxuICBlbmQgKz0gXCJcIjtcblxuICBpZiAoZW5kID09PSBcImF1dG9cIikge1xuICAgIHN0YXJ0VmFsdWUgPSB0YXJnZXQuc3R5bGVbcHJvcF07XG4gICAgdGFyZ2V0LnN0eWxlW3Byb3BdID0gZW5kO1xuICAgIGVuZCA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcHJvcCkgfHwgZW5kO1xuICAgIHN0YXJ0VmFsdWUgPyB0YXJnZXQuc3R5bGVbcHJvcF0gPSBzdGFydFZhbHVlIDogX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcHJvcCk7XG4gIH1cblxuICBhID0gW3N0YXJ0LCBlbmRdO1xuXG4gIF9jb2xvclN0cmluZ0ZpbHRlcihhKTsgLy8gcGFzcyBhbiBhcnJheSB3aXRoIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHZhbHVlcyBhbmQgbGV0IHRoZSBmaWx0ZXIgZG8gd2hhdGV2ZXIgaXQgbmVlZHMgdG8gdGhlIHZhbHVlcy4gSWYgY29sb3JzIGFyZSBmb3VuZCwgaXQgcmV0dXJucyB0cnVlIGFuZCB0aGVuIHdlIG11c3QgbWF0Y2ggd2hlcmUgdGhlIGNvbG9yIHNob3dzIHVwIG9yZGVyLXdpc2UgYmVjYXVzZSBmb3IgdGhpbmdzIGxpa2UgYm94U2hhZG93LCBzb21ldGltZXMgdGhlIGJyb3dzZXIgcHJvdmlkZXMgdGhlIGNvbXB1dGVkIHZhbHVlcyB3aXRoIHRoZSBjb2xvciBGSVJTVCwgYnV0IHRoZSB1c2VyIHByb3ZpZGVzIGl0IHdpdGggdGhlIGNvbG9yIExBU1QsIHNvIGZsaXAgdGhlbSBpZiBuZWNlc3NhcnkuIFNhbWUgZm9yIGRyb3Atc2hhZG93KCkuXG5cblxuICBzdGFydCA9IGFbMF07XG4gIGVuZCA9IGFbMV07XG4gIHN0YXJ0VmFsdWVzID0gc3RhcnQubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcbiAgZW5kVmFsdWVzID0gZW5kLm1hdGNoKF9udW1XaXRoVW5pdEV4cCkgfHwgW107XG5cbiAgaWYgKGVuZFZhbHVlcy5sZW5ndGgpIHtcbiAgICB3aGlsZSAocmVzdWx0ID0gX251bVdpdGhVbml0RXhwLmV4ZWMoZW5kKSkge1xuICAgICAgZW5kVmFsdWUgPSByZXN1bHRbMF07XG4gICAgICBjaHVuayA9IGVuZC5zdWJzdHJpbmcoaW5kZXgsIHJlc3VsdC5pbmRleCk7XG5cbiAgICAgIGlmIChjb2xvcikge1xuICAgICAgICBjb2xvciA9IChjb2xvciArIDEpICUgNTtcbiAgICAgIH0gZWxzZSBpZiAoY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJyZ2JhKFwiIHx8IGNodW5rLnN1YnN0cigtNSkgPT09IFwiaHNsYShcIikge1xuICAgICAgICBjb2xvciA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRWYWx1ZSAhPT0gKHN0YXJ0VmFsdWUgPSBzdGFydFZhbHVlc1ttYXRjaEluZGV4KytdIHx8IFwiXCIpKSB7XG4gICAgICAgIHN0YXJ0TnVtID0gcGFyc2VGbG9hdChzdGFydFZhbHVlKSB8fCAwO1xuICAgICAgICBzdGFydFVuaXQgPSBzdGFydFZhbHVlLnN1YnN0cigoc3RhcnROdW0gKyBcIlwiKS5sZW5ndGgpO1xuICAgICAgICBlbmRWYWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiICYmIChlbmRWYWx1ZSA9IF9wYXJzZVJlbGF0aXZlKHN0YXJ0TnVtLCBlbmRWYWx1ZSkgKyBzdGFydFVuaXQpO1xuICAgICAgICBlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKTtcbiAgICAgICAgZW5kVW5pdCA9IGVuZFZhbHVlLnN1YnN0cigoZW5kTnVtICsgXCJcIikubGVuZ3RoKTtcbiAgICAgICAgaW5kZXggPSBfbnVtV2l0aFVuaXRFeHAubGFzdEluZGV4IC0gZW5kVW5pdC5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCFlbmRVbml0KSB7XG4gICAgICAgICAgLy9pZiBzb21ldGhpbmcgbGlrZSBcInBlcnNwZWN0aXZlOjMwMFwiIGlzIHBhc3NlZCBpbiBhbmQgd2UgbXVzdCBhZGQgYSB1bml0IHRvIHRoZSBlbmRcbiAgICAgICAgICBlbmRVbml0ID0gZW5kVW5pdCB8fCBfY29uZmlnLnVuaXRzW3Byb3BdIHx8IHN0YXJ0VW5pdDtcblxuICAgICAgICAgIGlmIChpbmRleCA9PT0gZW5kLmxlbmd0aCkge1xuICAgICAgICAgICAgZW5kICs9IGVuZFVuaXQ7XG4gICAgICAgICAgICBwdC5lICs9IGVuZFVuaXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCkge1xuICAgICAgICAgIHN0YXJ0TnVtID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wLCBzdGFydFZhbHVlLCBlbmRVbml0KSB8fCAwO1xuICAgICAgICB9IC8vIHRoZXNlIG5lc3RlZCBQcm9wVHdlZW5zIGFyZSBoYW5kbGVkIGluIGEgc3BlY2lhbCB3YXkgLSB3ZSdsbCBuZXZlciBhY3R1YWxseSBjYWxsIGEgcmVuZGVyIG9yIHNldHRlciBtZXRob2Qgb24gdGhlbS4gV2UnbGwganVzdCBsb29wIHRocm91Z2ggdGhlbSBpbiB0aGUgcGFyZW50IGNvbXBsZXggc3RyaW5nIFByb3BUd2VlbidzIHJlbmRlciBtZXRob2QuXG5cblxuICAgICAgICBwdC5fcHQgPSB7XG4gICAgICAgICAgX25leHQ6IHB0Ll9wdCxcbiAgICAgICAgICBwOiBjaHVuayB8fCBtYXRjaEluZGV4ID09PSAxID8gY2h1bmsgOiBcIixcIixcbiAgICAgICAgICAvL25vdGU6IFNWRyBzcGVjIGFsbG93cyBvbWlzc2lvbiBvZiBjb21tYS9zcGFjZSB3aGVuIGEgbmVnYXRpdmUgc2lnbiBpcyB3ZWRnZWQgYmV0d2VlbiB0d28gbnVtYmVycywgbGlrZSAyLjUtNS4zIGluc3RlYWQgb2YgMi41LC01LjMgYnV0IHdoZW4gdHdlZW5pbmcsIHRoZSBuZWdhdGl2ZSB2YWx1ZSBtYXkgc3dpdGNoIHRvIHBvc2l0aXZlLCBzbyB3ZSBpbnNlcnQgdGhlIGNvbW1hIGp1c3QgaW4gY2FzZS5cbiAgICAgICAgICBzOiBzdGFydE51bSxcbiAgICAgICAgICBjOiBlbmROdW0gLSBzdGFydE51bSxcbiAgICAgICAgICBtOiBjb2xvciAmJiBjb2xvciA8IDQgfHwgcHJvcCA9PT0gXCJ6SW5kZXhcIiA/IE1hdGgucm91bmQgOiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHQuYyA9IGluZGV4IDwgZW5kLmxlbmd0aCA/IGVuZC5zdWJzdHJpbmcoaW5kZXgsIGVuZC5sZW5ndGgpIDogXCJcIjsgLy93ZSB1c2UgdGhlIFwiY1wiIG9mIHRoZSBQcm9wVHdlZW4gdG8gc3RvcmUgdGhlIGZpbmFsIHBhcnQgb2YgdGhlIHN0cmluZyAoYWZ0ZXIgdGhlIGxhc3QgbnVtYmVyKVxuICB9IGVsc2Uge1xuICAgIHB0LnIgPSBwcm9wID09PSBcImRpc3BsYXlcIiAmJiBlbmQgPT09IFwibm9uZVwiID8gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQgOiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZTtcbiAgfVxuXG4gIF9yZWxFeHAudGVzdChlbmQpICYmIChwdC5lID0gMCk7IC8vaWYgdGhlIGVuZCBzdHJpbmcgY29udGFpbnMgcmVsYXRpdmUgdmFsdWVzIG9yIGR5bmFtaWMgcmFuZG9tKC4uLikgdmFsdWVzLCBkZWxldGUgdGhlIGVuZCBpdCBzbyB0aGF0IG9uIHRoZSBmaW5hbCByZW5kZXIgd2UgZG9uJ3QgYWN0dWFsbHkgc2V0IGl0IHRvIHRoZSBzdHJpbmcgd2l0aCArPSBvciAtPSBjaGFyYWN0ZXJzIChmb3JjZXMgaXQgdG8gdXNlIHRoZSBjYWxjdWxhdGVkIHZhbHVlKS5cblxuICB0aGlzLl9wdCA9IHB0OyAvL3N0YXJ0IHRoZSBsaW5rZWQgbGlzdCB3aXRoIHRoaXMgbmV3IFByb3BUd2Vlbi4gUmVtZW1iZXIsIHdlIGNhbGwgX3R3ZWVuQ29tcGxleENTU1N0cmluZy5jYWxsKHBsdWdpbkluc3RhbmNlLi4uKSB0byBlbnN1cmUgdGhhdCBpdCdzIHNjb3BlZCBwcm9wZXJseS4gV2UgbWF5IGNhbGwgaXQgZnJvbSB3aXRoaW4gYW5vdGhlciBwbHVnaW4gdG9vLCB0aHVzIFwidGhpc1wiIHdvdWxkIHJlZmVyIHRvIHRoZSBwbHVnaW4uXG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfa2V5d29yZFRvUGVyY2VudCA9IHtcbiAgdG9wOiBcIjAlXCIsXG4gIGJvdHRvbTogXCIxMDAlXCIsXG4gIGxlZnQ6IFwiMCVcIixcbiAgcmlnaHQ6IFwiMTAwJVwiLFxuICBjZW50ZXI6IFwiNTAlXCJcbn0sXG4gICAgX2NvbnZlcnRLZXl3b3Jkc1RvUGVyY2VudGFnZXMgPSBmdW5jdGlvbiBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyh2YWx1ZSkge1xuICB2YXIgc3BsaXQgPSB2YWx1ZS5zcGxpdChcIiBcIiksXG4gICAgICB4ID0gc3BsaXRbMF0sXG4gICAgICB5ID0gc3BsaXRbMV0gfHwgXCI1MCVcIjtcblxuICBpZiAoeCA9PT0gXCJ0b3BcIiB8fCB4ID09PSBcImJvdHRvbVwiIHx8IHkgPT09IFwibGVmdFwiIHx8IHkgPT09IFwicmlnaHRcIikge1xuICAgIC8vdGhlIHVzZXIgcHJvdmlkZWQgdGhlbSBpbiB0aGUgd3Jvbmcgb3JkZXIsIHNvIGZsaXAgdGhlbVxuICAgIHZhbHVlID0geDtcbiAgICB4ID0geTtcbiAgICB5ID0gdmFsdWU7XG4gIH1cblxuICBzcGxpdFswXSA9IF9rZXl3b3JkVG9QZXJjZW50W3hdIHx8IHg7XG4gIHNwbGl0WzFdID0gX2tleXdvcmRUb1BlcmNlbnRbeV0gfHwgeTtcbiAgcmV0dXJuIHNwbGl0LmpvaW4oXCIgXCIpO1xufSxcbiAgICBfcmVuZGVyQ2xlYXJQcm9wcyA9IGZ1bmN0aW9uIF9yZW5kZXJDbGVhclByb3BzKHJhdGlvLCBkYXRhKSB7XG4gIGlmIChkYXRhLnR3ZWVuICYmIGRhdGEudHdlZW4uX3RpbWUgPT09IGRhdGEudHdlZW4uX2R1cikge1xuICAgIHZhciB0YXJnZXQgPSBkYXRhLnQsXG4gICAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgICBwcm9wcyA9IGRhdGEudSxcbiAgICAgICAgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICAgIHByb3AsXG4gICAgICAgIGNsZWFyVHJhbnNmb3JtcyxcbiAgICAgICAgaTtcblxuICAgIGlmIChwcm9wcyA9PT0gXCJhbGxcIiB8fCBwcm9wcyA9PT0gdHJ1ZSkge1xuICAgICAgc3R5bGUuY3NzVGV4dCA9IFwiXCI7XG4gICAgICBjbGVhclRyYW5zZm9ybXMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wcyA9IHByb3BzLnNwbGl0KFwiLFwiKTtcbiAgICAgIGkgPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICBwcm9wID0gcHJvcHNbaV07XG5cbiAgICAgICAgaWYgKF90cmFuc2Zvcm1Qcm9wc1twcm9wXSkge1xuICAgICAgICAgIGNsZWFyVHJhbnNmb3JtcyA9IDE7XG4gICAgICAgICAgcHJvcCA9IHByb3AgPT09IFwidHJhbnNmb3JtT3JpZ2luXCIgPyBfdHJhbnNmb3JtT3JpZ2luUHJvcCA6IF90cmFuc2Zvcm1Qcm9wO1xuICAgICAgICB9XG5cbiAgICAgICAgX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcHJvcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNsZWFyVHJhbnNmb3Jtcykge1xuICAgICAgX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApO1xuXG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgY2FjaGUuc3ZnICYmIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG5cbiAgICAgICAgX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSk7IC8vIGZvcmNlIGFsbCB0aGUgY2FjaGVkIHZhbHVlcyBiYWNrIHRvIFwibm9ybWFsXCIvaWRlbnRpdHksIG90aGVyd2lzZSBpZiB0aGVyZSdzIGFub3RoZXIgdHdlZW4gdGhhdCdzIGFscmVhZHkgc2V0IHRvIHJlbmRlciB0cmFuc2Zvcm1zIG9uIHRoaXMgZWxlbWVudCwgaXQgY291bGQgZGlzcGxheSB0aGUgd3JvbmcgdmFsdWVzLlxuXG5cbiAgICAgICAgY2FjaGUudW5jYWNoZSA9IDE7XG5cbiAgICAgICAgX3JlbW92ZUluZGVwZW5kZW50VHJhbnNmb3JtcyhzdHlsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59LFxuICAgIC8vIG5vdGU6IHNwZWNpYWxQcm9wcyBzaG91bGQgcmV0dXJuIDEgaWYgKGFuZCBvbmx5IGlmKSB0aGV5IGhhdmUgYSBub24temVybyBwcmlvcml0eS4gSXQgaW5kaWNhdGVzIHdlIG5lZWQgdG8gc29ydCB0aGUgbGlua2VkIGxpc3QuXG5fc3BlY2lhbFByb3BzID0ge1xuICBjbGVhclByb3BzOiBmdW5jdGlvbiBjbGVhclByb3BzKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgZW5kVmFsdWUsIHR3ZWVuKSB7XG4gICAgaWYgKHR3ZWVuLmRhdGEgIT09IFwiaXNGcm9tU3RhcnRcIikge1xuICAgICAgdmFyIHB0ID0gcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgMCwgMCwgX3JlbmRlckNsZWFyUHJvcHMpO1xuICAgICAgcHQudSA9IGVuZFZhbHVlO1xuICAgICAgcHQucHIgPSAtMTA7XG4gICAgICBwdC50d2VlbiA9IHR3ZWVuO1xuXG4gICAgICBwbHVnaW4uX3Byb3BzLnB1c2gocHJvcGVydHkpO1xuXG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH1cbiAgLyogY2xhc3NOYW1lIGZlYXR1cmUgKGFib3V0IDAuNGtiIGd6aXBwZWQpLlxuICAsIGNsYXNzTmFtZShwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGVuZFZhbHVlLCB0d2Vlbikge1xuICBcdGxldCBfcmVuZGVyQ2xhc3NOYW1lID0gKHJhdGlvLCBkYXRhKSA9PiB7XG4gIFx0XHRcdGRhdGEuY3NzLnJlbmRlcihyYXRpbywgZGF0YS5jc3MpO1xuICBcdFx0XHRpZiAoIXJhdGlvIHx8IHJhdGlvID09PSAxKSB7XG4gIFx0XHRcdFx0bGV0IGlubGluZSA9IGRhdGEucm12LFxuICBcdFx0XHRcdFx0dGFyZ2V0ID0gZGF0YS50LFxuICBcdFx0XHRcdFx0cDtcbiAgXHRcdFx0XHR0YXJnZXQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgcmF0aW8gPyBkYXRhLmUgOiBkYXRhLmIpO1xuICBcdFx0XHRcdGZvciAocCBpbiBpbmxpbmUpIHtcbiAgXHRcdFx0XHRcdF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIHApO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSxcbiAgXHRcdF9nZXRBbGxTdHlsZXMgPSAodGFyZ2V0KSA9PiB7XG4gIFx0XHRcdGxldCBzdHlsZXMgPSB7fSxcbiAgXHRcdFx0XHRjb21wdXRlZCA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KSxcbiAgXHRcdFx0XHRwO1xuICBcdFx0XHRmb3IgKHAgaW4gY29tcHV0ZWQpIHtcbiAgXHRcdFx0XHRpZiAoaXNOYU4ocCkgJiYgcCAhPT0gXCJjc3NUZXh0XCIgJiYgcCAhPT0gXCJsZW5ndGhcIikge1xuICBcdFx0XHRcdFx0c3R5bGVzW3BdID0gY29tcHV0ZWRbcF07XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHRcdF9zZXREZWZhdWx0cyhzdHlsZXMsIF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpKTtcbiAgXHRcdFx0cmV0dXJuIHN0eWxlcztcbiAgXHRcdH0sXG4gIFx0XHRzdGFydENsYXNzTGlzdCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSxcbiAgXHRcdHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICBcdFx0Y3NzVGV4dCA9IHN0eWxlLmNzc1RleHQsXG4gIFx0XHRjYWNoZSA9IHRhcmdldC5fZ3NhcCxcbiAgXHRcdGNsYXNzUFQgPSBjYWNoZS5jbGFzc1BULFxuICBcdFx0aW5saW5lVG9SZW1vdmVBdEVuZCA9IHt9LFxuICBcdFx0ZGF0YSA9IHt0OnRhcmdldCwgcGx1Z2luOnBsdWdpbiwgcm12OmlubGluZVRvUmVtb3ZlQXRFbmQsIGI6c3RhcnRDbGFzc0xpc3QsIGU6KGVuZFZhbHVlLmNoYXJBdCgxKSAhPT0gXCI9XCIpID8gZW5kVmFsdWUgOiBzdGFydENsYXNzTGlzdC5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoPzpcXFxcc3xeKVwiICsgZW5kVmFsdWUuc3Vic3RyKDIpICsgXCIoPyFbXFxcXHctXSlcIiksIFwiXCIpICsgKChlbmRWYWx1ZS5jaGFyQXQoMCkgPT09IFwiK1wiKSA/IFwiIFwiICsgZW5kVmFsdWUuc3Vic3RyKDIpIDogXCJcIil9LFxuICBcdFx0Y2hhbmdpbmdWYXJzID0ge30sXG4gIFx0XHRzdGFydFZhcnMgPSBfZ2V0QWxsU3R5bGVzKHRhcmdldCksXG4gIFx0XHR0cmFuc2Zvcm1SZWxhdGVkID0gLyh0cmFuc2Zvcm18cGVyc3BlY3RpdmUpL2ksXG4gIFx0XHRlbmRWYXJzLCBwO1xuICBcdGlmIChjbGFzc1BUKSB7XG4gIFx0XHRjbGFzc1BULnIoMSwgY2xhc3NQVC5kKTtcbiAgXHRcdF9yZW1vdmVMaW5rZWRMaXN0SXRlbShjbGFzc1BULmQucGx1Z2luLCBjbGFzc1BULCBcIl9wdFwiKTtcbiAgXHR9XG4gIFx0dGFyZ2V0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGRhdGEuZSk7XG4gIFx0ZW5kVmFycyA9IF9nZXRBbGxTdHlsZXModGFyZ2V0LCB0cnVlKTtcbiAgXHR0YXJnZXQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgc3RhcnRDbGFzc0xpc3QpO1xuICBcdGZvciAocCBpbiBlbmRWYXJzKSB7XG4gIFx0XHRpZiAoZW5kVmFyc1twXSAhPT0gc3RhcnRWYXJzW3BdICYmICF0cmFuc2Zvcm1SZWxhdGVkLnRlc3QocCkpIHtcbiAgXHRcdFx0Y2hhbmdpbmdWYXJzW3BdID0gZW5kVmFyc1twXTtcbiAgXHRcdFx0aWYgKCFzdHlsZVtwXSAmJiBzdHlsZVtwXSAhPT0gXCIwXCIpIHtcbiAgXHRcdFx0XHRpbmxpbmVUb1JlbW92ZUF0RW5kW3BdID0gMTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgXHRjYWNoZS5jbGFzc1BUID0gcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBcImNsYXNzTmFtZVwiLCAwLCAwLCBfcmVuZGVyQ2xhc3NOYW1lLCBkYXRhLCAwLCAtMTEpO1xuICBcdGlmIChzdHlsZS5jc3NUZXh0ICE9PSBjc3NUZXh0KSB7IC8vb25seSBhcHBseSBpZiB0aGluZ3MgY2hhbmdlLiBPdGhlcndpc2UsIGluIGNhc2VzIGxpa2UgYSBiYWNrZ3JvdW5kLWltYWdlIHRoYXQncyBwdWxsZWQgZHluYW1pY2FsbHksIGl0IGNvdWxkIGNhdXNlIGEgcmVmcmVzaC4gU2VlIGh0dHBzOi8vZ3NhcC5jb20vZm9ydW1zL3RvcGljLzIwMzY4LXBvc3NpYmxlLWdzYXAtYnVnLXN3aXRjaGluZy1jbGFzc25hbWVzLWluLWNocm9tZS8uXG4gIFx0XHRzdHlsZS5jc3NUZXh0ID0gY3NzVGV4dDsgLy93ZSByZWNvcmRlZCBjc3NUZXh0IGJlZm9yZSB3ZSBzd2FwcGVkIGNsYXNzZXMgYW5kIHJhbiBfZ2V0QWxsU3R5bGVzKCkgYmVjYXVzZSBpbiBjYXNlcyB3aGVuIGEgY2xhc3NOYW1lIHR3ZWVuIGlzIG92ZXJ3cml0dGVuLCB3ZSByZW1vdmUgYWxsIHRoZSByZWxhdGVkIHR3ZWVuaW5nIHByb3BlcnRpZXMgZnJvbSB0aGF0IGNsYXNzIGNoYW5nZSAob3RoZXJ3aXNlIGNsYXNzLXNwZWNpZmljIHN0dWZmIGNhbid0IG92ZXJyaWRlIHByb3BlcnRpZXMgd2UndmUgZGlyZWN0bHkgc2V0IG9uIHRoZSB0YXJnZXQncyBzdHlsZSBvYmplY3QgZHVlIHRvIHNwZWNpZmljaXR5KS5cbiAgXHR9XG4gIFx0X3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgdHJ1ZSk7IC8vdG8gY2xlYXIgdGhlIGNhY2hpbmcgb2YgdHJhbnNmb3Jtc1xuICBcdGRhdGEuY3NzID0gbmV3IGdzYXAucGx1Z2lucy5jc3MoKTtcbiAgXHRkYXRhLmNzcy5pbml0KHRhcmdldCwgY2hhbmdpbmdWYXJzLCB0d2Vlbik7XG4gIFx0cGx1Z2luLl9wcm9wcy5wdXNoKC4uLmRhdGEuY3NzLl9wcm9wcyk7XG4gIFx0cmV0dXJuIDE7XG4gIH1cbiAgKi9cblxufSxcblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUUkFOU0ZPUk1TXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5faWRlbnRpdHkyRE1hdHJpeCA9IFsxLCAwLCAwLCAxLCAwLCAwXSxcbiAgICBfcm90YXRpb25hbFByb3BlcnRpZXMgPSB7fSxcbiAgICBfaXNOdWxsVHJhbnNmb3JtID0gZnVuY3Rpb24gX2lzTnVsbFRyYW5zZm9ybSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IFwibWF0cml4KDEsIDAsIDAsIDEsIDAsIDApXCIgfHwgdmFsdWUgPT09IFwibm9uZVwiIHx8ICF2YWx1ZTtcbn0sXG4gICAgX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSA9IGZ1bmN0aW9uIF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkodGFyZ2V0KSB7XG4gIHZhciBtYXRyaXhTdHJpbmcgPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKTtcblxuICByZXR1cm4gX2lzTnVsbFRyYW5zZm9ybShtYXRyaXhTdHJpbmcpID8gX2lkZW50aXR5MkRNYXRyaXggOiBtYXRyaXhTdHJpbmcuc3Vic3RyKDcpLm1hdGNoKF9udW1FeHApLm1hcChfcm91bmQpO1xufSxcbiAgICBfZ2V0TWF0cml4ID0gZnVuY3Rpb24gX2dldE1hdHJpeCh0YXJnZXQsIGZvcmNlMkQpIHtcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwIHx8IF9nZXRDYWNoZSh0YXJnZXQpLFxuICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICBtYXRyaXggPSBfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5KHRhcmdldCksXG4gICAgICBwYXJlbnQsXG4gICAgICBuZXh0U2libGluZyxcbiAgICAgIHRlbXAsXG4gICAgICBhZGRlZFRvRE9NO1xuXG4gIGlmIChjYWNoZS5zdmcgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKSkge1xuICAgIHRlbXAgPSB0YXJnZXQudHJhbnNmb3JtLmJhc2VWYWwuY29uc29saWRhdGUoKS5tYXRyaXg7IC8vZW5zdXJlcyB0aGF0IGV2ZW4gY29tcGxleCB2YWx1ZXMgbGlrZSBcInRyYW5zbGF0ZSg1MCw2MCkgcm90YXRlKDEzNSwwLDApXCIgYXJlIHBhcnNlZCBiZWNhdXNlIGl0IG1hc2hlcyBpdCBpbnRvIGEgbWF0cml4LlxuXG4gICAgbWF0cml4ID0gW3RlbXAuYSwgdGVtcC5iLCB0ZW1wLmMsIHRlbXAuZCwgdGVtcC5lLCB0ZW1wLmZdO1xuICAgIHJldHVybiBtYXRyaXguam9pbihcIixcIikgPT09IFwiMSwwLDAsMSwwLDBcIiA/IF9pZGVudGl0eTJETWF0cml4IDogbWF0cml4O1xuICB9IGVsc2UgaWYgKG1hdHJpeCA9PT0gX2lkZW50aXR5MkRNYXRyaXggJiYgIXRhcmdldC5vZmZzZXRQYXJlbnQgJiYgdGFyZ2V0ICE9PSBfZG9jRWxlbWVudCAmJiAhY2FjaGUuc3ZnKSB7XG4gICAgLy9ub3RlOiBpZiBvZmZzZXRQYXJlbnQgaXMgbnVsbCwgdGhhdCBtZWFucyB0aGUgZWxlbWVudCBpc24ndCBpbiB0aGUgbm9ybWFsIGRvY3VtZW50IGZsb3csIGxpa2UgaWYgaXQgaGFzIGRpc3BsYXk6bm9uZSBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBoYXMgZGlzcGxheTpub25lKS4gRmlyZWZveCByZXR1cm5zIG51bGwgZm9yIGdldENvbXB1dGVkU3R5bGUoKSBpZiB0aGUgZWxlbWVudCBpcyBpbiBhbiBpZnJhbWUgdGhhdCBoYXMgZGlzcGxheTpub25lLiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NDgzOTdcbiAgICAvL2Jyb3dzZXJzIGRvbid0IHJlcG9ydCB0cmFuc2Zvcm1zIGFjY3VyYXRlbHkgdW5sZXNzIHRoZSBlbGVtZW50IGlzIGluIHRoZSBET00gYW5kIGhhcyBhIGRpc3BsYXkgdmFsdWUgdGhhdCdzIG5vdCBcIm5vbmVcIi4gRmlyZWZveCBhbmQgTWljcm9zb2Z0IGJyb3dzZXJzIGhhdmUgYSBwYXJ0aWFsIGJ1ZyB3aGVyZSB0aGV5J2xsIHJlcG9ydCB0cmFuc2Zvcm1zIGV2ZW4gaWYgZGlzcGxheTpub25lIEJVVCBub3QgYW55IHBlcmNlbnRhZ2UtYmFzZWQgdmFsdWVzIGxpa2UgdHJhbnNsYXRlKC01MCUsIDhweCkgd2lsbCBiZSByZXBvcnRlZCBhcyBpZiBpdCdzIHRyYW5zbGF0ZSgwLCA4cHgpLlxuICAgIHRlbXAgPSBzdHlsZS5kaXNwbGF5O1xuICAgIHN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgcGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG5cbiAgICBpZiAoIXBhcmVudCB8fCAhdGFyZ2V0Lm9mZnNldFBhcmVudCkge1xuICAgICAgLy8gbm90ZTogaW4gMy4zLjAgd2Ugc3dpdGNoZWQgdGFyZ2V0Lm9mZnNldFBhcmVudCB0byBfZG9jLmJvZHkuY29udGFpbnModGFyZ2V0KSB0byBhdm9pZCBbc29tZXRpbWVzIHVubmVjZXNzYXJ5XSBNdXRhdGlvbk9ic2VydmVyIGNhbGxzIGJ1dCB0aGF0IHdhc24ndCBhZGVxdWF0ZSBiZWNhdXNlIHRoZXJlIGFyZSBlZGdlIGNhc2VzIHdoZXJlIG5lc3RlZCBwb3NpdGlvbjogZml4ZWQgZWxlbWVudHMgbmVlZCB0byBnZXQgcmVwYXJlbnRlZCB0byBhY2N1cmF0ZWx5IHNlbnNlIHRyYW5zZm9ybXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JlZW5zb2NrL0dTQVAvaXNzdWVzLzM4OCBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2dyZWVuc29jay9HU0FQL2lzc3Vlcy8zNzVcbiAgICAgIGFkZGVkVG9ET00gPSAxOyAvL2ZsYWdcblxuICAgICAgbmV4dFNpYmxpbmcgPSB0YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nO1xuXG4gICAgICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZCh0YXJnZXQpOyAvL3dlIG11c3QgYWRkIGl0IHRvIHRoZSBET00gaW4gb3JkZXIgdG8gZ2V0IHZhbHVlcyBwcm9wZXJseVxuXG4gICAgfVxuXG4gICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpO1xuICAgIHRlbXAgPyBzdHlsZS5kaXNwbGF5ID0gdGVtcCA6IF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIFwiZGlzcGxheVwiKTtcblxuICAgIGlmIChhZGRlZFRvRE9NKSB7XG4gICAgICBuZXh0U2libGluZyA/IHBhcmVudC5pbnNlcnRCZWZvcmUodGFyZ2V0LCBuZXh0U2libGluZykgOiBwYXJlbnQgPyBwYXJlbnQuYXBwZW5kQ2hpbGQodGFyZ2V0KSA6IF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcmNlMkQgJiYgbWF0cml4Lmxlbmd0aCA+IDYgPyBbbWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFs0XSwgbWF0cml4WzVdLCBtYXRyaXhbMTJdLCBtYXRyaXhbMTNdXSA6IG1hdHJpeDtcbn0sXG4gICAgX2FwcGx5U1ZHT3JpZ2luID0gZnVuY3Rpb24gX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgb3JpZ2luLCBvcmlnaW5Jc0Fic29sdXRlLCBzbW9vdGgsIG1hdHJpeEFycmF5LCBwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbykge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICBtYXRyaXggPSBtYXRyaXhBcnJheSB8fCBfZ2V0TWF0cml4KHRhcmdldCwgdHJ1ZSksXG4gICAgICB4T3JpZ2luT2xkID0gY2FjaGUueE9yaWdpbiB8fCAwLFxuICAgICAgeU9yaWdpbk9sZCA9IGNhY2hlLnlPcmlnaW4gfHwgMCxcbiAgICAgIHhPZmZzZXRPbGQgPSBjYWNoZS54T2Zmc2V0IHx8IDAsXG4gICAgICB5T2Zmc2V0T2xkID0gY2FjaGUueU9mZnNldCB8fCAwLFxuICAgICAgYSA9IG1hdHJpeFswXSxcbiAgICAgIGIgPSBtYXRyaXhbMV0sXG4gICAgICBjID0gbWF0cml4WzJdLFxuICAgICAgZCA9IG1hdHJpeFszXSxcbiAgICAgIHR4ID0gbWF0cml4WzRdLFxuICAgICAgdHkgPSBtYXRyaXhbNV0sXG4gICAgICBvcmlnaW5TcGxpdCA9IG9yaWdpbi5zcGxpdChcIiBcIiksXG4gICAgICB4T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW5TcGxpdFswXSkgfHwgMCxcbiAgICAgIHlPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpblNwbGl0WzFdKSB8fCAwLFxuICAgICAgYm91bmRzLFxuICAgICAgZGV0ZXJtaW5hbnQsXG4gICAgICB4LFxuICAgICAgeTtcblxuICBpZiAoIW9yaWdpbklzQWJzb2x1dGUpIHtcbiAgICBib3VuZHMgPSBfZ2V0QkJveCh0YXJnZXQpO1xuICAgIHhPcmlnaW4gPSBib3VuZHMueCArICh+b3JpZ2luU3BsaXRbMF0uaW5kZXhPZihcIiVcIikgPyB4T3JpZ2luIC8gMTAwICogYm91bmRzLndpZHRoIDogeE9yaWdpbik7XG4gICAgeU9yaWdpbiA9IGJvdW5kcy55ICsgKH4ob3JpZ2luU3BsaXRbMV0gfHwgb3JpZ2luU3BsaXRbMF0pLmluZGV4T2YoXCIlXCIpID8geU9yaWdpbiAvIDEwMCAqIGJvdW5kcy5oZWlnaHQgOiB5T3JpZ2luKTsgLy8gaWYgKCEoXCJ4T3JpZ2luXCIgaW4gY2FjaGUpICYmICh4T3JpZ2luIHx8IHlPcmlnaW4pKSB7IC8vIGFkZGVkIGluIDMuMTIuMywgcmV2ZXJ0ZWQgaW4gMy4xMi40OyByZXF1aXJlcyBtb3JlIGV4cGxvcmF0aW9uXG4gICAgLy8gXHR4T3JpZ2luIC09IGJvdW5kcy54O1xuICAgIC8vIFx0eU9yaWdpbiAtPSBib3VuZHMueTtcbiAgICAvLyB9XG4gIH0gZWxzZSBpZiAobWF0cml4ICE9PSBfaWRlbnRpdHkyRE1hdHJpeCAmJiAoZGV0ZXJtaW5hbnQgPSBhICogZCAtIGIgKiBjKSkge1xuICAgIC8vaWYgaXQncyB6ZXJvIChsaWtlIGlmIHNjYWxlWCBhbmQgc2NhbGVZIGFyZSB6ZXJvKSwgc2tpcCBpdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBkaXZpZGluZyBieSB6ZXJvLlxuICAgIHggPSB4T3JpZ2luICogKGQgLyBkZXRlcm1pbmFudCkgKyB5T3JpZ2luICogKC1jIC8gZGV0ZXJtaW5hbnQpICsgKGMgKiB0eSAtIGQgKiB0eCkgLyBkZXRlcm1pbmFudDtcbiAgICB5ID0geE9yaWdpbiAqICgtYiAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoYSAvIGRldGVybWluYW50KSAtIChhICogdHkgLSBiICogdHgpIC8gZGV0ZXJtaW5hbnQ7XG4gICAgeE9yaWdpbiA9IHg7XG4gICAgeU9yaWdpbiA9IHk7IC8vIHRoZW9yeTogd2Ugb25seSBoYWQgdG8gZG8gdGhpcyBmb3Igc21vb3RoaW5nIGFuZCBpdCBhc3N1bWVzIHRoYXQgdGhlIHByZXZpb3VzIG9uZSB3YXMgbm90IG9yaWdpbklzQWJzb2x1dGUuXG4gIH1cblxuICBpZiAoc21vb3RoIHx8IHNtb290aCAhPT0gZmFsc2UgJiYgY2FjaGUuc21vb3RoKSB7XG4gICAgdHggPSB4T3JpZ2luIC0geE9yaWdpbk9sZDtcbiAgICB0eSA9IHlPcmlnaW4gLSB5T3JpZ2luT2xkO1xuICAgIGNhY2hlLnhPZmZzZXQgPSB4T2Zmc2V0T2xkICsgKHR4ICogYSArIHR5ICogYykgLSB0eDtcbiAgICBjYWNoZS55T2Zmc2V0ID0geU9mZnNldE9sZCArICh0eCAqIGIgKyB0eSAqIGQpIC0gdHk7XG4gIH0gZWxzZSB7XG4gICAgY2FjaGUueE9mZnNldCA9IGNhY2hlLnlPZmZzZXQgPSAwO1xuICB9XG5cbiAgY2FjaGUueE9yaWdpbiA9IHhPcmlnaW47XG4gIGNhY2hlLnlPcmlnaW4gPSB5T3JpZ2luO1xuICBjYWNoZS5zbW9vdGggPSAhIXNtb290aDtcbiAgY2FjaGUub3JpZ2luID0gb3JpZ2luO1xuICBjYWNoZS5vcmlnaW5Jc0Fic29sdXRlID0gISFvcmlnaW5Jc0Fic29sdXRlO1xuICB0YXJnZXQuc3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdID0gXCIwcHggMHB4XCI7IC8vb3RoZXJ3aXNlLCBpZiBzb21lb25lIHNldHMgIGFuIG9yaWdpbiB2aWEgQ1NTLCBpdCB3aWxsIGxpa2VseSBpbnRlcmZlcmUgd2l0aCB0aGUgU1ZHIHRyYW5zZm9ybSBhdHRyaWJ1dGUgb25lcyAoYmVjYXVzZSByZW1lbWJlciwgd2UncmUgYmFraW5nIHRoZSBvcmlnaW4gaW50byB0aGUgbWF0cml4KCkgdmFsdWUpLlxuXG4gIGlmIChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbykge1xuICAgIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ4T3JpZ2luXCIsIHhPcmlnaW5PbGQsIHhPcmlnaW4pO1xuXG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInlPcmlnaW5cIiwgeU9yaWdpbk9sZCwgeU9yaWdpbik7XG5cbiAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieE9mZnNldFwiLCB4T2Zmc2V0T2xkLCBjYWNoZS54T2Zmc2V0KTtcblxuICAgIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ5T2Zmc2V0XCIsIHlPZmZzZXRPbGQsIGNhY2hlLnlPZmZzZXQpO1xuICB9XG5cbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiLCB4T3JpZ2luICsgXCIgXCIgKyB5T3JpZ2luKTtcbn0sXG4gICAgX3BhcnNlVHJhbnNmb3JtID0gZnVuY3Rpb24gX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgdW5jYWNoZSkge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXAgfHwgbmV3IEdTQ2FjaGUodGFyZ2V0KTtcblxuICBpZiAoXCJ4XCIgaW4gY2FjaGUgJiYgIXVuY2FjaGUgJiYgIWNhY2hlLnVuY2FjaGUpIHtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH1cblxuICB2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICBpbnZlcnRlZFNjYWxlWCA9IGNhY2hlLnNjYWxlWCA8IDAsXG4gICAgICBweCA9IFwicHhcIixcbiAgICAgIGRlZyA9IFwiZGVnXCIsXG4gICAgICBjcyA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KSxcbiAgICAgIG9yaWdpbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybU9yaWdpblByb3ApIHx8IFwiMFwiLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB6LFxuICAgICAgc2NhbGVYLFxuICAgICAgc2NhbGVZLFxuICAgICAgcm90YXRpb24sXG4gICAgICByb3RhdGlvblgsXG4gICAgICByb3RhdGlvblksXG4gICAgICBza2V3WCxcbiAgICAgIHNrZXdZLFxuICAgICAgcGVyc3BlY3RpdmUsXG4gICAgICB4T3JpZ2luLFxuICAgICAgeU9yaWdpbixcbiAgICAgIG1hdHJpeCxcbiAgICAgIGFuZ2xlLFxuICAgICAgY29zLFxuICAgICAgc2luLFxuICAgICAgYSxcbiAgICAgIGIsXG4gICAgICBjLFxuICAgICAgZCxcbiAgICAgIGExMixcbiAgICAgIGEyMixcbiAgICAgIHQxLFxuICAgICAgdDIsXG4gICAgICB0MyxcbiAgICAgIGExMyxcbiAgICAgIGEyMyxcbiAgICAgIGEzMyxcbiAgICAgIGE0MixcbiAgICAgIGE0MyxcbiAgICAgIGEzMjtcbiAgeCA9IHkgPSB6ID0gcm90YXRpb24gPSByb3RhdGlvblggPSByb3RhdGlvblkgPSBza2V3WCA9IHNrZXdZID0gcGVyc3BlY3RpdmUgPSAwO1xuICBzY2FsZVggPSBzY2FsZVkgPSAxO1xuICBjYWNoZS5zdmcgPSAhISh0YXJnZXQuZ2V0Q1RNICYmIF9pc1NWRyh0YXJnZXQpKTtcblxuICBpZiAoY3MudHJhbnNsYXRlKSB7XG4gICAgLy8gYWNjb21tb2RhdGUgaW5kZXBlbmRlbnQgdHJhbnNmb3JtcyBieSBjb21iaW5pbmcgdGhlbSBpbnRvIG5vcm1hbCBvbmVzLlxuICAgIGlmIChjcy50cmFuc2xhdGUgIT09IFwibm9uZVwiIHx8IGNzLnNjYWxlICE9PSBcIm5vbmVcIiB8fCBjcy5yb3RhdGUgIT09IFwibm9uZVwiKSB7XG4gICAgICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSAoY3MudHJhbnNsYXRlICE9PSBcIm5vbmVcIiA/IFwidHJhbnNsYXRlM2QoXCIgKyAoY3MudHJhbnNsYXRlICsgXCIgMCAwXCIpLnNwbGl0KFwiIFwiKS5zbGljZSgwLCAzKS5qb2luKFwiLCBcIikgKyBcIikgXCIgOiBcIlwiKSArIChjcy5yb3RhdGUgIT09IFwibm9uZVwiID8gXCJyb3RhdGUoXCIgKyBjcy5yb3RhdGUgKyBcIikgXCIgOiBcIlwiKSArIChjcy5zY2FsZSAhPT0gXCJub25lXCIgPyBcInNjYWxlKFwiICsgY3Muc2NhbGUuc3BsaXQoXCIgXCIpLmpvaW4oXCIsXCIpICsgXCIpIFwiIDogXCJcIikgKyAoY3NbX3RyYW5zZm9ybVByb3BdICE9PSBcIm5vbmVcIiA/IGNzW190cmFuc2Zvcm1Qcm9wXSA6IFwiXCIpO1xuICAgIH1cblxuICAgIHN0eWxlLnNjYWxlID0gc3R5bGUucm90YXRlID0gc3R5bGUudHJhbnNsYXRlID0gXCJub25lXCI7XG4gIH1cblxuICBtYXRyaXggPSBfZ2V0TWF0cml4KHRhcmdldCwgY2FjaGUuc3ZnKTtcblxuICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgaWYgKGNhY2hlLnVuY2FjaGUpIHtcbiAgICAgIC8vIGlmIGNhY2hlLnVuY2FjaGUgaXMgdHJ1ZSAoYW5kIG1heWJlIGlmIG9yaWdpbiBpcyAwLDApLCB3ZSBuZWVkIHRvIHNldCBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IChjYWNoZS54T3JpZ2luIC0gYmJveC54KSArIFwicHggXCIgKyAoY2FjaGUueU9yaWdpbiAtIGJib3gueSkgKyBcInB4XCIuIFByZXZpb3VzbHkgd2UgbGV0IHRoZSBkYXRhLXN2Zy1vcmlnaW4gc3RheSBpbnN0ZWFkLCBidXQgd2hlbiBpbnRyb2R1Y2luZyByZXZlcnQoKSwgaXQgY29tcGxpY2F0ZWQgdGhpbmdzLlxuICAgICAgdDIgPSB0YXJnZXQuZ2V0QkJveCgpO1xuICAgICAgb3JpZ2luID0gY2FjaGUueE9yaWdpbiAtIHQyLnggKyBcInB4IFwiICsgKGNhY2hlLnlPcmlnaW4gLSB0Mi55KSArIFwicHhcIjtcbiAgICAgIHQxID0gXCJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdDEgPSAhdW5jYWNoZSAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIpOyAvLyAgUmVtZW1iZXIsIHRvIHdvcmsgYXJvdW5kIGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzIHdlIGFsd2F5cyBmb3JjZSBTVkcgZWxlbWVudHMnIHRyYW5zZm9ybU9yaWdpbiB0byAwLDAgYW5kIG9mZnNldCB0aGUgdHJhbnNsYXRpb24gYWNjb3JkaW5nbHkuXG4gICAgfVxuXG4gICAgX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgdDEgfHwgb3JpZ2luLCAhIXQxIHx8IGNhY2hlLm9yaWdpbklzQWJzb2x1dGUsIGNhY2hlLnNtb290aCAhPT0gZmFsc2UsIG1hdHJpeCk7XG4gIH1cblxuICB4T3JpZ2luID0gY2FjaGUueE9yaWdpbiB8fCAwO1xuICB5T3JpZ2luID0gY2FjaGUueU9yaWdpbiB8fCAwO1xuXG4gIGlmIChtYXRyaXggIT09IF9pZGVudGl0eTJETWF0cml4KSB7XG4gICAgYSA9IG1hdHJpeFswXTsgLy9hMTFcblxuICAgIGIgPSBtYXRyaXhbMV07IC8vYTIxXG5cbiAgICBjID0gbWF0cml4WzJdOyAvL2EzMVxuXG4gICAgZCA9IG1hdHJpeFszXTsgLy9hNDFcblxuICAgIHggPSBhMTIgPSBtYXRyaXhbNF07XG4gICAgeSA9IGEyMiA9IG1hdHJpeFs1XTsgLy8yRCBtYXRyaXhcblxuICAgIGlmIChtYXRyaXgubGVuZ3RoID09PSA2KSB7XG4gICAgICBzY2FsZVggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gICAgICBzY2FsZVkgPSBNYXRoLnNxcnQoZCAqIGQgKyBjICogYyk7XG4gICAgICByb3RhdGlvbiA9IGEgfHwgYiA/IF9hdGFuMihiLCBhKSAqIF9SQUQyREVHIDogMDsgLy9ub3RlOiBpZiBzY2FsZVggaXMgMCwgd2UgY2Fubm90IGFjY3VyYXRlbHkgbWVhc3VyZSByb3RhdGlvbi4gU2FtZSBmb3Igc2tld1ggd2l0aCBhIHNjYWxlWSBvZiAwLiBUaGVyZWZvcmUsIHdlIGRlZmF1bHQgdG8gdGhlIHByZXZpb3VzbHkgcmVjb3JkZWQgdmFsdWUgKG9yIHplcm8gaWYgdGhhdCBkb2Vzbid0IGV4aXN0KS5cblxuICAgICAgc2tld1ggPSBjIHx8IGQgPyBfYXRhbjIoYywgZCkgKiBfUkFEMkRFRyArIHJvdGF0aW9uIDogMDtcbiAgICAgIHNrZXdYICYmIChzY2FsZVkgKj0gTWF0aC5hYnMoTWF0aC5jb3Moc2tld1ggKiBfREVHMlJBRCkpKTtcblxuICAgICAgaWYgKGNhY2hlLnN2Zykge1xuICAgICAgICB4IC09IHhPcmlnaW4gLSAoeE9yaWdpbiAqIGEgKyB5T3JpZ2luICogYyk7XG4gICAgICAgIHkgLT0geU9yaWdpbiAtICh4T3JpZ2luICogYiArIHlPcmlnaW4gKiBkKTtcbiAgICAgIH0gLy8zRCBtYXRyaXhcblxuICAgIH0gZWxzZSB7XG4gICAgICBhMzIgPSBtYXRyaXhbNl07XG4gICAgICBhNDIgPSBtYXRyaXhbN107XG4gICAgICBhMTMgPSBtYXRyaXhbOF07XG4gICAgICBhMjMgPSBtYXRyaXhbOV07XG4gICAgICBhMzMgPSBtYXRyaXhbMTBdO1xuICAgICAgYTQzID0gbWF0cml4WzExXTtcbiAgICAgIHggPSBtYXRyaXhbMTJdO1xuICAgICAgeSA9IG1hdHJpeFsxM107XG4gICAgICB6ID0gbWF0cml4WzE0XTtcbiAgICAgIGFuZ2xlID0gX2F0YW4yKGEzMiwgYTMzKTtcbiAgICAgIHJvdGF0aW9uWCA9IGFuZ2xlICogX1JBRDJERUc7IC8vcm90YXRpb25YXG5cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICBjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuICAgICAgICBzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuICAgICAgICB0MSA9IGExMiAqIGNvcyArIGExMyAqIHNpbjtcbiAgICAgICAgdDIgPSBhMjIgKiBjb3MgKyBhMjMgKiBzaW47XG4gICAgICAgIHQzID0gYTMyICogY29zICsgYTMzICogc2luO1xuICAgICAgICBhMTMgPSBhMTIgKiAtc2luICsgYTEzICogY29zO1xuICAgICAgICBhMjMgPSBhMjIgKiAtc2luICsgYTIzICogY29zO1xuICAgICAgICBhMzMgPSBhMzIgKiAtc2luICsgYTMzICogY29zO1xuICAgICAgICBhNDMgPSBhNDIgKiAtc2luICsgYTQzICogY29zO1xuICAgICAgICBhMTIgPSB0MTtcbiAgICAgICAgYTIyID0gdDI7XG4gICAgICAgIGEzMiA9IHQzO1xuICAgICAgfSAvL3JvdGF0aW9uWVxuXG5cbiAgICAgIGFuZ2xlID0gX2F0YW4yKC1jLCBhMzMpO1xuICAgICAgcm90YXRpb25ZID0gYW5nbGUgKiBfUkFEMkRFRztcblxuICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gICAgICAgIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG4gICAgICAgIHQxID0gYSAqIGNvcyAtIGExMyAqIHNpbjtcbiAgICAgICAgdDIgPSBiICogY29zIC0gYTIzICogc2luO1xuICAgICAgICB0MyA9IGMgKiBjb3MgLSBhMzMgKiBzaW47XG4gICAgICAgIGE0MyA9IGQgKiBzaW4gKyBhNDMgKiBjb3M7XG4gICAgICAgIGEgPSB0MTtcbiAgICAgICAgYiA9IHQyO1xuICAgICAgICBjID0gdDM7XG4gICAgICB9IC8vcm90YXRpb25aXG5cblxuICAgICAgYW5nbGUgPSBfYXRhbjIoYiwgYSk7XG4gICAgICByb3RhdGlvbiA9IGFuZ2xlICogX1JBRDJERUc7XG5cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdDEgPSBhICogY29zICsgYiAqIHNpbjtcbiAgICAgICAgdDIgPSBhMTIgKiBjb3MgKyBhMjIgKiBzaW47XG4gICAgICAgIGIgPSBiICogY29zIC0gYSAqIHNpbjtcbiAgICAgICAgYTIyID0gYTIyICogY29zIC0gYTEyICogc2luO1xuICAgICAgICBhID0gdDE7XG4gICAgICAgIGExMiA9IHQyO1xuICAgICAgfVxuXG4gICAgICBpZiAocm90YXRpb25YICYmIE1hdGguYWJzKHJvdGF0aW9uWCkgKyBNYXRoLmFicyhyb3RhdGlvbikgPiAzNTkuOSkge1xuICAgICAgICAvL3doZW4gcm90YXRpb25ZIGlzIHNldCwgaXQgd2lsbCBvZnRlbiBiZSBwYXJzZWQgYXMgMTgwIGRlZ3JlZXMgZGlmZmVyZW50IHRoYW4gaXQgc2hvdWxkIGJlLCBhbmQgcm90YXRpb25YIGFuZCByb3RhdGlvbiBib3RoIGJlaW5nIDE4MCAoaXQgbG9va3MgdGhlIHNhbWUpLCBzbyB3ZSBhZGp1c3QgZm9yIHRoYXQgaGVyZS5cbiAgICAgICAgcm90YXRpb25YID0gcm90YXRpb24gPSAwO1xuICAgICAgICByb3RhdGlvblkgPSAxODAgLSByb3RhdGlvblk7XG4gICAgICB9XG5cbiAgICAgIHNjYWxlWCA9IF9yb3VuZChNYXRoLnNxcnQoYSAqIGEgKyBiICogYiArIGMgKiBjKSk7XG4gICAgICBzY2FsZVkgPSBfcm91bmQoTWF0aC5zcXJ0KGEyMiAqIGEyMiArIGEzMiAqIGEzMikpO1xuICAgICAgYW5nbGUgPSBfYXRhbjIoYTEyLCBhMjIpO1xuICAgICAgc2tld1ggPSBNYXRoLmFicyhhbmdsZSkgPiAwLjAwMDIgPyBhbmdsZSAqIF9SQUQyREVHIDogMDtcbiAgICAgIHBlcnNwZWN0aXZlID0gYTQzID8gMSAvIChhNDMgPCAwID8gLWE0MyA6IGE0MykgOiAwO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgIC8vc2Vuc2UgaWYgdGhlcmUgYXJlIENTUyB0cmFuc2Zvcm1zIGFwcGxpZWQgb24gYW4gU1ZHIGVsZW1lbnQgaW4gd2hpY2ggY2FzZSB3ZSBtdXN0IG92ZXJ3cml0ZSB0aGVtIHdoZW4gcmVuZGVyaW5nLiBUaGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSBpcyBtb3JlIHJlbGlhYmxlIGNyb3NzLWJyb3dzZXIsIGJ1dCB3ZSBjYW4ndCBqdXN0IHJlbW92ZSB0aGUgQ1NTIG9uZXMgYmVjYXVzZSB0aGV5IG1heSBiZSBhcHBsaWVkIGluIGEgQ1NTIHJ1bGUgc29tZXdoZXJlIChub3QganVzdCBpbmxpbmUpLlxuICAgICAgdDEgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuICAgICAgY2FjaGUuZm9yY2VDU1MgPSB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwiXCIpIHx8ICFfaXNOdWxsVHJhbnNmb3JtKF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApKTtcbiAgICAgIHQxICYmIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdDEpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChNYXRoLmFicyhza2V3WCkgPiA5MCAmJiBNYXRoLmFicyhza2V3WCkgPCAyNzApIHtcbiAgICBpZiAoaW52ZXJ0ZWRTY2FsZVgpIHtcbiAgICAgIHNjYWxlWCAqPSAtMTtcbiAgICAgIHNrZXdYICs9IHJvdGF0aW9uIDw9IDAgPyAxODAgOiAtMTgwO1xuICAgICAgcm90YXRpb24gKz0gcm90YXRpb24gPD0gMCA/IDE4MCA6IC0xODA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlWSAqPSAtMTtcbiAgICAgIHNrZXdYICs9IHNrZXdYIDw9IDAgPyAxODAgOiAtMTgwO1xuICAgIH1cbiAgfVxuXG4gIHVuY2FjaGUgPSB1bmNhY2hlIHx8IGNhY2hlLnVuY2FjaGU7XG4gIGNhY2hlLnggPSB4IC0gKChjYWNoZS54UGVyY2VudCA9IHggJiYgKCF1bmNhY2hlICYmIGNhY2hlLnhQZXJjZW50IHx8IChNYXRoLnJvdW5kKHRhcmdldC5vZmZzZXRXaWR0aCAvIDIpID09PSBNYXRoLnJvdW5kKC14KSA/IC01MCA6IDApKSkgPyB0YXJnZXQub2Zmc2V0V2lkdGggKiBjYWNoZS54UGVyY2VudCAvIDEwMCA6IDApICsgcHg7XG4gIGNhY2hlLnkgPSB5IC0gKChjYWNoZS55UGVyY2VudCA9IHkgJiYgKCF1bmNhY2hlICYmIGNhY2hlLnlQZXJjZW50IHx8IChNYXRoLnJvdW5kKHRhcmdldC5vZmZzZXRIZWlnaHQgLyAyKSA9PT0gTWF0aC5yb3VuZCgteSkgPyAtNTAgOiAwKSkpID8gdGFyZ2V0Lm9mZnNldEhlaWdodCAqIGNhY2hlLnlQZXJjZW50IC8gMTAwIDogMCkgKyBweDtcbiAgY2FjaGUueiA9IHogKyBweDtcbiAgY2FjaGUuc2NhbGVYID0gX3JvdW5kKHNjYWxlWCk7XG4gIGNhY2hlLnNjYWxlWSA9IF9yb3VuZChzY2FsZVkpO1xuICBjYWNoZS5yb3RhdGlvbiA9IF9yb3VuZChyb3RhdGlvbikgKyBkZWc7XG4gIGNhY2hlLnJvdGF0aW9uWCA9IF9yb3VuZChyb3RhdGlvblgpICsgZGVnO1xuICBjYWNoZS5yb3RhdGlvblkgPSBfcm91bmQocm90YXRpb25ZKSArIGRlZztcbiAgY2FjaGUuc2tld1ggPSBza2V3WCArIGRlZztcbiAgY2FjaGUuc2tld1kgPSBza2V3WSArIGRlZztcbiAgY2FjaGUudHJhbnNmb3JtUGVyc3BlY3RpdmUgPSBwZXJzcGVjdGl2ZSArIHB4O1xuXG4gIGlmIChjYWNoZS56T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW4uc3BsaXQoXCIgXCIpWzJdKSB8fCAhdW5jYWNoZSAmJiBjYWNoZS56T3JpZ2luIHx8IDApIHtcbiAgICBzdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBfZmlyc3RUd29Pbmx5KG9yaWdpbik7XG4gIH1cblxuICBjYWNoZS54T2Zmc2V0ID0gY2FjaGUueU9mZnNldCA9IDA7XG4gIGNhY2hlLmZvcmNlM0QgPSBfY29uZmlnLmZvcmNlM0Q7XG4gIGNhY2hlLnJlbmRlclRyYW5zZm9ybSA9IGNhY2hlLnN2ZyA/IF9yZW5kZXJTVkdUcmFuc2Zvcm1zIDogX3N1cHBvcnRzM0QgPyBfcmVuZGVyQ1NTVHJhbnNmb3JtcyA6IF9yZW5kZXJOb24zRFRyYW5zZm9ybXM7XG4gIGNhY2hlLnVuY2FjaGUgPSAwO1xuICByZXR1cm4gY2FjaGU7XG59LFxuICAgIF9maXJzdFR3b09ubHkgPSBmdW5jdGlvbiBfZmlyc3RUd29Pbmx5KHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgPSB2YWx1ZS5zcGxpdChcIiBcIikpWzBdICsgXCIgXCIgKyB2YWx1ZVsxXTtcbn0sXG4gICAgLy9mb3IgaGFuZGxpbmcgdHJhbnNmb3JtT3JpZ2luIHZhbHVlcywgc3RyaXBwaW5nIG91dCB0aGUgM3JkIGRpbWVuc2lvblxuX2FkZFB4VHJhbnNsYXRlID0gZnVuY3Rpb24gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgc3RhcnQsIHZhbHVlKSB7XG4gIHZhciB1bml0ID0gZ2V0VW5pdChzdGFydCk7XG4gIHJldHVybiBfcm91bmQocGFyc2VGbG9hdChzdGFydCkgKyBwYXJzZUZsb2F0KF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ4XCIsIHZhbHVlICsgXCJweFwiLCB1bml0KSkpICsgdW5pdDtcbn0sXG4gICAgX3JlbmRlck5vbjNEVHJhbnNmb3JtcyA9IGZ1bmN0aW9uIF9yZW5kZXJOb24zRFRyYW5zZm9ybXMocmF0aW8sIGNhY2hlKSB7XG4gIGNhY2hlLnogPSBcIjBweFwiO1xuICBjYWNoZS5yb3RhdGlvblkgPSBjYWNoZS5yb3RhdGlvblggPSBcIjBkZWdcIjtcbiAgY2FjaGUuZm9yY2UzRCA9IDA7XG5cbiAgX3JlbmRlckNTU1RyYW5zZm9ybXMocmF0aW8sIGNhY2hlKTtcbn0sXG4gICAgX3plcm9EZWcgPSBcIjBkZWdcIixcbiAgICBfemVyb1B4ID0gXCIwcHhcIixcbiAgICBfZW5kUGFyZW50aGVzaXMgPSBcIikgXCIsXG4gICAgX3JlbmRlckNTU1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgdmFyIF9yZWYgPSBjYWNoZSB8fCB0aGlzLFxuICAgICAgeFBlcmNlbnQgPSBfcmVmLnhQZXJjZW50LFxuICAgICAgeVBlcmNlbnQgPSBfcmVmLnlQZXJjZW50LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICB6ID0gX3JlZi56LFxuICAgICAgcm90YXRpb24gPSBfcmVmLnJvdGF0aW9uLFxuICAgICAgcm90YXRpb25ZID0gX3JlZi5yb3RhdGlvblksXG4gICAgICByb3RhdGlvblggPSBfcmVmLnJvdGF0aW9uWCxcbiAgICAgIHNrZXdYID0gX3JlZi5za2V3WCxcbiAgICAgIHNrZXdZID0gX3JlZi5za2V3WSxcbiAgICAgIHNjYWxlWCA9IF9yZWYuc2NhbGVYLFxuICAgICAgc2NhbGVZID0gX3JlZi5zY2FsZVksXG4gICAgICB0cmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IF9yZWYudHJhbnNmb3JtUGVyc3BlY3RpdmUsXG4gICAgICBmb3JjZTNEID0gX3JlZi5mb3JjZTNELFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB6T3JpZ2luID0gX3JlZi56T3JpZ2luLFxuICAgICAgdHJhbnNmb3JtcyA9IFwiXCIsXG4gICAgICB1c2UzRCA9IGZvcmNlM0QgPT09IFwiYXV0b1wiICYmIHJhdGlvICYmIHJhdGlvICE9PSAxIHx8IGZvcmNlM0QgPT09IHRydWU7IC8vIFNhZmFyaSBoYXMgYSBidWcgdGhhdCBjYXVzZXMgaXQgbm90IHRvIHJlbmRlciAzRCB0cmFuc2Zvcm0tb3JpZ2luIHZhbHVlcyBwcm9wZXJseSwgc28gd2UgZm9yY2UgdGhlIHogb3JpZ2luIHRvIDAsIHJlY29yZCBpdCBpbiB0aGUgY2FjaGUsIGFuZCB0aGVuIGRvIHRoZSBtYXRoIGhlcmUgdG8gb2Zmc2V0IHRoZSB0cmFuc2xhdGUgdmFsdWVzIGFjY29yZGluZ2x5IChiYXNpY2FsbHkgZG8gdGhlIDNEIHRyYW5zZm9ybS1vcmlnaW4gcGFydCBtYW51YWxseSlcblxuXG4gIGlmICh6T3JpZ2luICYmIChyb3RhdGlvblggIT09IF96ZXJvRGVnIHx8IHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpKSB7XG4gICAgdmFyIGFuZ2xlID0gcGFyc2VGbG9hdChyb3RhdGlvblkpICogX0RFRzJSQUQsXG4gICAgICAgIGExMyA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgYTMzID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICBjb3M7XG5cbiAgICBhbmdsZSA9IHBhcnNlRmxvYXQocm90YXRpb25YKSAqIF9ERUcyUkFEO1xuICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICB4ID0gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgeCwgYTEzICogY29zICogLXpPcmlnaW4pO1xuICAgIHkgPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB5LCAtTWF0aC5zaW4oYW5nbGUpICogLXpPcmlnaW4pO1xuICAgIHogPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB6LCBhMzMgKiBjb3MgKiAtek9yaWdpbiArIHpPcmlnaW4pO1xuICB9XG5cbiAgaWYgKHRyYW5zZm9ybVBlcnNwZWN0aXZlICE9PSBfemVyb1B4KSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInBlcnNwZWN0aXZlKFwiICsgdHJhbnNmb3JtUGVyc3BlY3RpdmUgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAoeFBlcmNlbnQgfHwgeVBlcmNlbnQpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwidHJhbnNsYXRlKFwiICsgeFBlcmNlbnQgKyBcIiUsIFwiICsgeVBlcmNlbnQgKyBcIiUpIFwiO1xuICB9XG5cbiAgaWYgKHVzZTNEIHx8IHggIT09IF96ZXJvUHggfHwgeSAhPT0gX3plcm9QeCB8fCB6ICE9PSBfemVyb1B4KSB7XG4gICAgdHJhbnNmb3JtcyArPSB6ICE9PSBfemVyb1B4IHx8IHVzZTNEID8gXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcIiwgXCIgKyB5ICsgXCIsIFwiICsgeiArIFwiKSBcIiA6IFwidHJhbnNsYXRlKFwiICsgeCArIFwiLCBcIiArIHkgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAocm90YXRpb24gIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZShcIiArIHJvdGF0aW9uICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwicm90YXRlWShcIiArIHJvdGF0aW9uWSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChyb3RhdGlvblggIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZVgoXCIgKyByb3RhdGlvblggKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAoc2tld1ggIT09IF96ZXJvRGVnIHx8IHNrZXdZICE9PSBfemVyb0RlZykge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJza2V3KFwiICsgc2tld1ggKyBcIiwgXCIgKyBza2V3WSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInNjYWxlKFwiICsgc2NhbGVYICsgXCIsIFwiICsgc2NhbGVZICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgdGFyZ2V0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXMgfHwgXCJ0cmFuc2xhdGUoMCwgMClcIjtcbn0sXG4gICAgX3JlbmRlclNWR1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyU1ZHVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgdmFyIF9yZWYyID0gY2FjaGUgfHwgdGhpcyxcbiAgICAgIHhQZXJjZW50ID0gX3JlZjIueFBlcmNlbnQsXG4gICAgICB5UGVyY2VudCA9IF9yZWYyLnlQZXJjZW50LFxuICAgICAgeCA9IF9yZWYyLngsXG4gICAgICB5ID0gX3JlZjIueSxcbiAgICAgIHJvdGF0aW9uID0gX3JlZjIucm90YXRpb24sXG4gICAgICBza2V3WCA9IF9yZWYyLnNrZXdYLFxuICAgICAgc2tld1kgPSBfcmVmMi5za2V3WSxcbiAgICAgIHNjYWxlWCA9IF9yZWYyLnNjYWxlWCxcbiAgICAgIHNjYWxlWSA9IF9yZWYyLnNjYWxlWSxcbiAgICAgIHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHhPcmlnaW4gPSBfcmVmMi54T3JpZ2luLFxuICAgICAgeU9yaWdpbiA9IF9yZWYyLnlPcmlnaW4sXG4gICAgICB4T2Zmc2V0ID0gX3JlZjIueE9mZnNldCxcbiAgICAgIHlPZmZzZXQgPSBfcmVmMi55T2Zmc2V0LFxuICAgICAgZm9yY2VDU1MgPSBfcmVmMi5mb3JjZUNTUyxcbiAgICAgIHR4ID0gcGFyc2VGbG9hdCh4KSxcbiAgICAgIHR5ID0gcGFyc2VGbG9hdCh5KSxcbiAgICAgIGExMSxcbiAgICAgIGEyMSxcbiAgICAgIGExMixcbiAgICAgIGEyMixcbiAgICAgIHRlbXA7XG5cbiAgcm90YXRpb24gPSBwYXJzZUZsb2F0KHJvdGF0aW9uKTtcbiAgc2tld1ggPSBwYXJzZUZsb2F0KHNrZXdYKTtcbiAgc2tld1kgPSBwYXJzZUZsb2F0KHNrZXdZKTtcblxuICBpZiAoc2tld1kpIHtcbiAgICAvL2ZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBjb21iaW5lIGFsbCBza2V3aW5nIGludG8gdGhlIHNrZXdYIGFuZCByb3RhdGlvbiB2YWx1ZXMuIFJlbWVtYmVyLCBhIHNrZXdZIG9mIDEwIGRlZ3JlZXMgbG9va3MgdGhlIHNhbWUgYXMgYSByb3RhdGlvbiBvZiAxMCBkZWdyZWVzIHBsdXMgYSBza2V3WCBvZiAxMCBkZWdyZWVzLlxuICAgIHNrZXdZID0gcGFyc2VGbG9hdChza2V3WSk7XG4gICAgc2tld1ggKz0gc2tld1k7XG4gICAgcm90YXRpb24gKz0gc2tld1k7XG4gIH1cblxuICBpZiAocm90YXRpb24gfHwgc2tld1gpIHtcbiAgICByb3RhdGlvbiAqPSBfREVHMlJBRDtcbiAgICBza2V3WCAqPSBfREVHMlJBRDtcbiAgICBhMTEgPSBNYXRoLmNvcyhyb3RhdGlvbikgKiBzY2FsZVg7XG4gICAgYTIxID0gTWF0aC5zaW4ocm90YXRpb24pICogc2NhbGVYO1xuICAgIGExMiA9IE1hdGguc2luKHJvdGF0aW9uIC0gc2tld1gpICogLXNjYWxlWTtcbiAgICBhMjIgPSBNYXRoLmNvcyhyb3RhdGlvbiAtIHNrZXdYKSAqIHNjYWxlWTtcblxuICAgIGlmIChza2V3WCkge1xuICAgICAgc2tld1kgKj0gX0RFRzJSQUQ7XG4gICAgICB0ZW1wID0gTWF0aC50YW4oc2tld1ggLSBza2V3WSk7XG4gICAgICB0ZW1wID0gTWF0aC5zcXJ0KDEgKyB0ZW1wICogdGVtcCk7XG4gICAgICBhMTIgKj0gdGVtcDtcbiAgICAgIGEyMiAqPSB0ZW1wO1xuXG4gICAgICBpZiAoc2tld1kpIHtcbiAgICAgICAgdGVtcCA9IE1hdGgudGFuKHNrZXdZKTtcbiAgICAgICAgdGVtcCA9IE1hdGguc3FydCgxICsgdGVtcCAqIHRlbXApO1xuICAgICAgICBhMTEgKj0gdGVtcDtcbiAgICAgICAgYTIxICo9IHRlbXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYTExID0gX3JvdW5kKGExMSk7XG4gICAgYTIxID0gX3JvdW5kKGEyMSk7XG4gICAgYTEyID0gX3JvdW5kKGExMik7XG4gICAgYTIyID0gX3JvdW5kKGEyMik7XG4gIH0gZWxzZSB7XG4gICAgYTExID0gc2NhbGVYO1xuICAgIGEyMiA9IHNjYWxlWTtcbiAgICBhMjEgPSBhMTIgPSAwO1xuICB9XG5cbiAgaWYgKHR4ICYmICF+KHggKyBcIlwiKS5pbmRleE9mKFwicHhcIikgfHwgdHkgJiYgIX4oeSArIFwiXCIpLmluZGV4T2YoXCJweFwiKSkge1xuICAgIHR4ID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBcInhcIiwgeCwgXCJweFwiKTtcbiAgICB0eSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ5XCIsIHksIFwicHhcIik7XG4gIH1cblxuICBpZiAoeE9yaWdpbiB8fCB5T3JpZ2luIHx8IHhPZmZzZXQgfHwgeU9mZnNldCkge1xuICAgIHR4ID0gX3JvdW5kKHR4ICsgeE9yaWdpbiAtICh4T3JpZ2luICogYTExICsgeU9yaWdpbiAqIGExMikgKyB4T2Zmc2V0KTtcbiAgICB0eSA9IF9yb3VuZCh0eSArIHlPcmlnaW4gLSAoeE9yaWdpbiAqIGEyMSArIHlPcmlnaW4gKiBhMjIpICsgeU9mZnNldCk7XG4gIH1cblxuICBpZiAoeFBlcmNlbnQgfHwgeVBlcmNlbnQpIHtcbiAgICAvL1RoZSBTVkcgc3BlYyBkb2Vzbid0IHN1cHBvcnQgcGVyY2VudGFnZS1iYXNlZCB0cmFuc2xhdGlvbiBpbiB0aGUgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUsIHNvIHdlIG1lcmdlIGl0IGludG8gdGhlIHRyYW5zbGF0aW9uIHRvIHNpbXVsYXRlIGl0LlxuICAgIHRlbXAgPSB0YXJnZXQuZ2V0QkJveCgpO1xuICAgIHR4ID0gX3JvdW5kKHR4ICsgeFBlcmNlbnQgLyAxMDAgKiB0ZW1wLndpZHRoKTtcbiAgICB0eSA9IF9yb3VuZCh0eSArIHlQZXJjZW50IC8gMTAwICogdGVtcC5oZWlnaHQpO1xuICB9XG5cbiAgdGVtcCA9IFwibWF0cml4KFwiICsgYTExICsgXCIsXCIgKyBhMjEgKyBcIixcIiArIGExMiArIFwiLFwiICsgYTIyICsgXCIsXCIgKyB0eCArIFwiLFwiICsgdHkgKyBcIilcIjtcbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0ZW1wKTtcbiAgZm9yY2VDU1MgJiYgKHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0ZW1wKTsgLy9zb21lIGJyb3dzZXJzIHByaW9yaXRpemUgQ1NTIHRyYW5zZm9ybXMgb3ZlciB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZS4gV2hlbiB3ZSBzZW5zZSB0aGF0IHRoZSB1c2VyIGhhcyBDU1MgdHJhbnNmb3JtcyBhcHBsaWVkLCB3ZSBtdXN0IG92ZXJ3cml0ZSB0aGVtIHRoaXMgd2F5IChvdGhlcndpc2Ugc29tZSBicm93c2VyIHNpbXBseSB3b24ndCByZW5kZXIgdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUgY2hhbmdlcyEpXG59LFxuICAgIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4ocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBzdGFydE51bSwgZW5kVmFsdWUpIHtcbiAgdmFyIGNhcCA9IDM2MCxcbiAgICAgIGlzU3RyaW5nID0gX2lzU3RyaW5nKGVuZFZhbHVlKSxcbiAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpICogKGlzU3RyaW5nICYmIH5lbmRWYWx1ZS5pbmRleE9mKFwicmFkXCIpID8gX1JBRDJERUcgOiAxKSxcbiAgICAgIGNoYW5nZSA9IGVuZE51bSAtIHN0YXJ0TnVtLFxuICAgICAgZmluYWxWYWx1ZSA9IHN0YXJ0TnVtICsgY2hhbmdlICsgXCJkZWdcIixcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHB0O1xuXG4gIGlmIChpc1N0cmluZykge1xuICAgIGRpcmVjdGlvbiA9IGVuZFZhbHVlLnNwbGl0KFwiX1wiKVsxXTtcblxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwic2hvcnRcIikge1xuICAgICAgY2hhbmdlICU9IGNhcDtcblxuICAgICAgaWYgKGNoYW5nZSAhPT0gY2hhbmdlICUgKGNhcCAvIDIpKSB7XG4gICAgICAgIGNoYW5nZSArPSBjaGFuZ2UgPCAwID8gY2FwIDogLWNhcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uID09PSBcImN3XCIgJiYgY2hhbmdlIDwgMCkge1xuICAgICAgY2hhbmdlID0gKGNoYW5nZSArIGNhcCAqIF9iaWdOdW0pICUgY2FwIC0gfn4oY2hhbmdlIC8gY2FwKSAqIGNhcDtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gXCJjY3dcIiAmJiBjaGFuZ2UgPiAwKSB7XG4gICAgICBjaGFuZ2UgPSAoY2hhbmdlIC0gY2FwICogX2JpZ051bSkgJSBjYXAgLSB+fihjaGFuZ2UgLyBjYXApICogY2FwO1xuICAgIH1cbiAgfVxuXG4gIHBsdWdpbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnROdW0sIGNoYW5nZSwgX3JlbmRlclByb3BXaXRoRW5kKTtcbiAgcHQuZSA9IGZpbmFsVmFsdWU7XG4gIHB0LnUgPSBcImRlZ1wiO1xuXG4gIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfYXNzaWduID0gZnVuY3Rpb24gX2Fzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAvLyBJbnRlcm5ldCBFeHBsb3JlciBkb2Vzbid0IGhhdmUgT2JqZWN0LmFzc2lnbigpLCBzbyB3ZSByZWNyZWF0ZSBpdCBoZXJlLlxuICBmb3IgKHZhciBwIGluIHNvdXJjZSkge1xuICAgIHRhcmdldFtwXSA9IHNvdXJjZVtwXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59LFxuICAgIF9hZGRSYXdUcmFuc2Zvcm1QVHMgPSBmdW5jdGlvbiBfYWRkUmF3VHJhbnNmb3JtUFRzKHBsdWdpbiwgdHJhbnNmb3JtcywgdGFyZ2V0KSB7XG4gIC8vZm9yIGhhbmRsaW5nIGNhc2VzIHdoZXJlIHNvbWVvbmUgcGFzc2VzIGluIGEgd2hvbGUgdHJhbnNmb3JtIHN0cmluZywgbGlrZSB0cmFuc2Zvcm06IFwic2NhbGUoMiwgMykgcm90YXRlKDIwZGVnKSB0cmFuc2xhdGVZKDMwZW0pXCJcbiAgdmFyIHN0YXJ0Q2FjaGUgPSBfYXNzaWduKHt9LCB0YXJnZXQuX2dzYXApLFxuICAgICAgZXhjbHVkZSA9IFwicGVyc3BlY3RpdmUsZm9yY2UzRCx0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luXCIsXG4gICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgIGVuZENhY2hlLFxuICAgICAgcCxcbiAgICAgIHN0YXJ0VmFsdWUsXG4gICAgICBlbmRWYWx1ZSxcbiAgICAgIHN0YXJ0TnVtLFxuICAgICAgZW5kTnVtLFxuICAgICAgc3RhcnRVbml0LFxuICAgICAgZW5kVW5pdDtcblxuICBpZiAoc3RhcnRDYWNoZS5zdmcpIHtcbiAgICBzdGFydFZhbHVlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwiXCIpO1xuICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXM7XG4gICAgZW5kQ2FjaGUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKTtcblxuICAgIF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKTtcblxuICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgc3RhcnRWYWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRWYWx1ZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KVtfdHJhbnNmb3JtUHJvcF07XG4gICAgc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtcztcbiAgICBlbmRDYWNoZSA9IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpO1xuICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHN0YXJ0VmFsdWU7XG4gIH1cblxuICBmb3IgKHAgaW4gX3RyYW5zZm9ybVByb3BzKSB7XG4gICAgc3RhcnRWYWx1ZSA9IHN0YXJ0Q2FjaGVbcF07XG4gICAgZW5kVmFsdWUgPSBlbmRDYWNoZVtwXTtcblxuICAgIGlmIChzdGFydFZhbHVlICE9PSBlbmRWYWx1ZSAmJiBleGNsdWRlLmluZGV4T2YocCkgPCAwKSB7XG4gICAgICAvL3R3ZWVuaW5nIHRvIG5vIHBlcnNwZWN0aXZlIGdpdmVzIHZlcnkgdW5pbnR1aXRpdmUgcmVzdWx0cyAtIGp1c3Qga2VlcCB0aGUgc2FtZSBwZXJzcGVjdGl2ZSBpbiB0aGF0IGNhc2UuXG4gICAgICBzdGFydFVuaXQgPSBnZXRVbml0KHN0YXJ0VmFsdWUpO1xuICAgICAgZW5kVW5pdCA9IGdldFVuaXQoZW5kVmFsdWUpO1xuICAgICAgc3RhcnROdW0gPSBzdGFydFVuaXQgIT09IGVuZFVuaXQgPyBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpIDogcGFyc2VGbG9hdChzdGFydFZhbHVlKTtcbiAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xuICAgICAgcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgZW5kQ2FjaGUsIHAsIHN0YXJ0TnVtLCBlbmROdW0gLSBzdGFydE51bSwgX3JlbmRlckNTU1Byb3ApO1xuICAgICAgcGx1Z2luLl9wdC51ID0gZW5kVW5pdCB8fCAwO1xuXG4gICAgICBwbHVnaW4uX3Byb3BzLnB1c2gocCk7XG4gICAgfVxuICB9XG5cbiAgX2Fzc2lnbihlbmRDYWNoZSwgc3RhcnRDYWNoZSk7XG59OyAvLyBoYW5kbGUgc3BsaXR0aW5nIGFwYXJ0IHBhZGRpbmcsIG1hcmdpbiwgYm9yZGVyV2lkdGgsIGFuZCBib3JkZXJSYWRpdXMgaW50byB0aGVpciA0IGNvbXBvbmVudHMuIEZpcmVmb3gsIGZvciBleGFtcGxlLCB3b24ndCByZXBvcnQgYm9yZGVyUmFkaXVzIGNvcnJlY3RseSAtIGl0IHdpbGwgb25seSBkbyBib3JkZXJUb3BMZWZ0UmFkaXVzIGFuZCB0aGUgb3RoZXIgY29ybmVycy4gV2UgYWxzbyB3YW50IHRvIGhhbmRsZSBwYWRkaW5nVG9wLCBtYXJnaW5MZWZ0LCBib3JkZXJSaWdodFdpZHRoLCBldGMuXG5cblxuX2ZvckVhY2hOYW1lKFwicGFkZGluZyxtYXJnaW4sV2lkdGgsUmFkaXVzXCIsIGZ1bmN0aW9uIChuYW1lLCBpbmRleCkge1xuICB2YXIgdCA9IFwiVG9wXCIsXG4gICAgICByID0gXCJSaWdodFwiLFxuICAgICAgYiA9IFwiQm90dG9tXCIsXG4gICAgICBsID0gXCJMZWZ0XCIsXG4gICAgICBwcm9wcyA9IChpbmRleCA8IDMgPyBbdCwgciwgYiwgbF0gOiBbdCArIGwsIHQgKyByLCBiICsgciwgYiArIGxdKS5tYXAoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gaW5kZXggPCAyID8gbmFtZSArIHNpZGUgOiBcImJvcmRlclwiICsgc2lkZSArIG5hbWU7XG4gIH0pO1xuXG4gIF9zcGVjaWFsUHJvcHNbaW5kZXggPiAxID8gXCJib3JkZXJcIiArIG5hbWUgOiBuYW1lXSA9IGZ1bmN0aW9uIChwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGVuZFZhbHVlLCB0d2Vlbikge1xuICAgIHZhciBhLCB2YXJzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSB7XG4gICAgICAvLyBnZXR0ZXIsIHBhc3NlZCB0YXJnZXQsIHByb3BlcnR5LCBhbmQgdW5pdCAoZnJvbSBfZ2V0KCkpXG4gICAgICBhID0gcHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KHBsdWdpbiwgcHJvcCwgcHJvcGVydHkpO1xuICAgICAgfSk7XG4gICAgICB2YXJzID0gYS5qb2luKFwiIFwiKTtcbiAgICAgIHJldHVybiB2YXJzLnNwbGl0KGFbMF0pLmxlbmd0aCA9PT0gNSA/IGFbMF0gOiB2YXJzO1xuICAgIH1cblxuICAgIGEgPSAoZW5kVmFsdWUgKyBcIlwiKS5zcGxpdChcIiBcIik7XG4gICAgdmFycyA9IHt9O1xuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3AsIGkpIHtcbiAgICAgIHJldHVybiB2YXJzW3Byb3BdID0gYVtpXSA9IGFbaV0gfHwgYVsoaSAtIDEpIC8gMiB8IDBdO1xuICAgIH0pO1xuICAgIHBsdWdpbi5pbml0KHRhcmdldCwgdmFycywgdHdlZW4pO1xuICB9O1xufSk7XG5cbmV4cG9ydCB2YXIgQ1NTUGx1Z2luID0ge1xuICBuYW1lOiBcImNzc1wiLFxuICByZWdpc3RlcjogX2luaXRDb3JlLFxuICB0YXJnZXRUZXN0OiBmdW5jdGlvbiB0YXJnZXRUZXN0KHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQuc3R5bGUgJiYgdGFyZ2V0Lm5vZGVUeXBlO1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5fcHJvcHMsXG4gICAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgICBzdGFydEF0ID0gdHdlZW4udmFycy5zdGFydEF0LFxuICAgICAgICBzdGFydFZhbHVlLFxuICAgICAgICBlbmRWYWx1ZSxcbiAgICAgICAgZW5kTnVtLFxuICAgICAgICBzdGFydE51bSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc3BlY2lhbFByb3AsXG4gICAgICAgIHAsXG4gICAgICAgIHN0YXJ0VW5pdCxcbiAgICAgICAgZW5kVW5pdCxcbiAgICAgICAgcmVsYXRpdmUsXG4gICAgICAgIGlzVHJhbnNmb3JtUmVsYXRlZCxcbiAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuLFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgc21vb3RoLFxuICAgICAgICBoYXNQcmlvcml0eSxcbiAgICAgICAgaW5saW5lUHJvcHM7XG4gICAgX3BsdWdpbkluaXR0ZWQgfHwgX2luaXRDb3JlKCk7IC8vIHdlIG1heSBjYWxsIGluaXQoKSBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSBwbHVnaW4gaW5zdGFuY2UsIGxpa2Ugd2hlbiBhZGRpbmcgc3BlY2lhbCBwcm9wZXJ0aWVzLCBzbyBtYWtlIHN1cmUgd2UgZG9uJ3Qgb3ZlcndyaXRlIHRoZSByZXZlcnQgZGF0YSBvciBpbmxpbmVQcm9wc1xuXG4gICAgdGhpcy5zdHlsZXMgPSB0aGlzLnN0eWxlcyB8fCBfZ2V0U3R5bGVTYXZlcih0YXJnZXQpO1xuICAgIGlubGluZVByb3BzID0gdGhpcy5zdHlsZXMucHJvcHM7XG4gICAgdGhpcy50d2VlbiA9IHR3ZWVuO1xuXG4gICAgZm9yIChwIGluIHZhcnMpIHtcbiAgICAgIGlmIChwID09PSBcImF1dG9Sb3VuZFwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBlbmRWYWx1ZSA9IHZhcnNbcF07XG5cbiAgICAgIGlmIChfcGx1Z2luc1twXSAmJiBfY2hlY2tQbHVnaW4ocCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpKSB7XG4gICAgICAgIC8vIHBsdWdpbnNcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHR5cGUgPSB0eXBlb2YgZW5kVmFsdWU7XG4gICAgICBzcGVjaWFsUHJvcCA9IF9zcGVjaWFsUHJvcHNbcF07XG5cbiAgICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZW5kVmFsdWUgPSBlbmRWYWx1ZS5jYWxsKHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKTtcbiAgICAgICAgdHlwZSA9IHR5cGVvZiBlbmRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgfmVuZFZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG4gICAgICAgIGVuZFZhbHVlID0gX3JlcGxhY2VSYW5kb20oZW5kVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BlY2lhbFByb3ApIHtcbiAgICAgICAgc3BlY2lhbFByb3AodGhpcywgdGFyZ2V0LCBwLCBlbmRWYWx1ZSwgdHdlZW4pICYmIChoYXNQcmlvcml0eSA9IDEpO1xuICAgICAgfSBlbHNlIGlmIChwLnN1YnN0cigwLCAyKSA9PT0gXCItLVwiKSB7XG4gICAgICAgIC8vQ1NTIHZhcmlhYmxlXG4gICAgICAgIHN0YXJ0VmFsdWUgPSAoZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmdldFByb3BlcnR5VmFsdWUocCkgKyBcIlwiKS50cmltKCk7XG4gICAgICAgIGVuZFZhbHVlICs9IFwiXCI7XG4gICAgICAgIF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xuXG4gICAgICAgIGlmICghX2NvbG9yRXhwLnRlc3Qoc3RhcnRWYWx1ZSkpIHtcbiAgICAgICAgICAvLyBjb2xvcnMgZG9uJ3QgaGF2ZSB1bml0c1xuICAgICAgICAgIHN0YXJ0VW5pdCA9IGdldFVuaXQoc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgZW5kVW5pdCA9IGdldFVuaXQoZW5kVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5kVW5pdCA/IHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCAmJiAoc3RhcnRWYWx1ZSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkgKyBlbmRVbml0KSA6IHN0YXJ0VW5pdCAmJiAoZW5kVmFsdWUgKz0gc3RhcnRVbml0KTtcbiAgICAgICAgdGhpcy5hZGQoc3R5bGUsIFwic2V0UHJvcGVydHlcIiwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGluZGV4LCB0YXJnZXRzLCAwLCAwLCBwKTtcbiAgICAgICAgcHJvcHMucHVzaChwKTtcbiAgICAgICAgaW5saW5lUHJvcHMucHVzaChwLCAwLCBzdHlsZVtwXSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHN0YXJ0QXQgJiYgcCBpbiBzdGFydEF0KSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSBzb21lb25lIGhhcmQtY29kZXMgYSBjb21wbGV4IHZhbHVlIGFzIHRoZSBzdGFydCwgbGlrZSB0b3A6IFwiY2FsYygydmggLyAyKVwiLiBXaXRob3V0IHRoaXMsIGl0J2QgdXNlIHRoZSBjb21wdXRlZCB2YWx1ZSAoYWx3YXlzIGluIHB4KVxuICAgICAgICAgIHN0YXJ0VmFsdWUgPSB0eXBlb2Ygc3RhcnRBdFtwXSA9PT0gXCJmdW5jdGlvblwiID8gc3RhcnRBdFtwXS5jYWxsKHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSA6IHN0YXJ0QXRbcF07XG4gICAgICAgICAgX2lzU3RyaW5nKHN0YXJ0VmFsdWUpICYmIH5zdGFydFZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpICYmIChzdGFydFZhbHVlID0gX3JlcGxhY2VSYW5kb20oc3RhcnRWYWx1ZSkpO1xuICAgICAgICAgIGdldFVuaXQoc3RhcnRWYWx1ZSArIFwiXCIpIHx8IHN0YXJ0VmFsdWUgPT09IFwiYXV0b1wiIHx8IChzdGFydFZhbHVlICs9IF9jb25maWcudW5pdHNbcF0gfHwgZ2V0VW5pdChfZ2V0KHRhcmdldCwgcCkpIHx8IFwiXCIpOyAvLyBmb3IgY2FzZXMgd2hlbiBzb21lb25lIHBhc3NlcyBpbiBhIHVuaXRsZXNzIHZhbHVlIGxpa2Uge3g6IDEwMH07IGlmIHdlIHRyeSBzZXR0aW5nIHRyYW5zbGF0ZSgxMDAsIDBweCkgaXQgd29uJ3Qgd29yay5cblxuICAgICAgICAgIChzdGFydFZhbHVlICsgXCJcIikuY2hhckF0KDEpID09PSBcIj1cIiAmJiAoc3RhcnRWYWx1ZSA9IF9nZXQodGFyZ2V0LCBwKSk7IC8vIGNhbid0IHdvcmsgd2l0aCByZWxhdGl2ZSB2YWx1ZXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydFZhbHVlID0gX2dldCh0YXJnZXQsIHApO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpO1xuICAgICAgICByZWxhdGl2ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgJiYgZW5kVmFsdWUuY2hhckF0KDEpID09PSBcIj1cIiAmJiBlbmRWYWx1ZS5zdWJzdHIoMCwgMik7XG4gICAgICAgIHJlbGF0aXZlICYmIChlbmRWYWx1ZSA9IGVuZFZhbHVlLnN1YnN0cigyKSk7XG4gICAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xuXG4gICAgICAgIGlmIChwIGluIF9wcm9wZXJ0eUFsaWFzZXMpIHtcbiAgICAgICAgICBpZiAocCA9PT0gXCJhdXRvQWxwaGFcIikge1xuICAgICAgICAgICAgLy9zcGVjaWFsIGNhc2Ugd2hlcmUgd2UgY29udHJvbCB0aGUgdmlzaWJpbGl0eSBhbG9uZyB3aXRoIG9wYWNpdHkuIFdlIHN0aWxsIGFsbG93IHRoZSBvcGFjaXR5IHZhbHVlIHRvIHBhc3MgdGhyb3VnaCBhbmQgZ2V0IHR3ZWVuZWQuXG4gICAgICAgICAgICBpZiAoc3RhcnROdW0gPT09IDEgJiYgX2dldCh0YXJnZXQsIFwidmlzaWJpbGl0eVwiKSA9PT0gXCJoaWRkZW5cIiAmJiBlbmROdW0pIHtcbiAgICAgICAgICAgICAgLy9pZiB2aXNpYmlsaXR5IGlzIGluaXRpYWxseSBzZXQgdG8gXCJoaWRkZW5cIiwgd2Ugc2hvdWxkIGludGVycHJldCB0aGF0IGFzIGludGVudCB0byBtYWtlIG9wYWNpdHkgMCAoYSBjb252ZW5pZW5jZSlcbiAgICAgICAgICAgICAgc3RhcnROdW0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbmxpbmVQcm9wcy5wdXNoKFwidmlzaWJpbGl0eVwiLCAwLCBzdHlsZS52aXNpYmlsaXR5KTtcblxuICAgICAgICAgICAgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgc3R5bGUsIFwidmlzaWJpbGl0eVwiLCBzdGFydE51bSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIiwgZW5kTnVtID8gXCJpbmhlcml0XCIgOiBcImhpZGRlblwiLCAhZW5kTnVtKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocCAhPT0gXCJzY2FsZVwiICYmIHAgIT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICAgICAgICAgIHAgPSBfcHJvcGVydHlBbGlhc2VzW3BdO1xuICAgICAgICAgICAgfnAuaW5kZXhPZihcIixcIikgJiYgKHAgPSBwLnNwbGl0KFwiLFwiKVswXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaXNUcmFuc2Zvcm1SZWxhdGVkID0gcCBpbiBfdHJhbnNmb3JtUHJvcHM7IC8vLS0tIFRSQU5TRk9STS1SRUxBVEVEIC0tLVxuXG4gICAgICAgIGlmIChpc1RyYW5zZm9ybVJlbGF0ZWQpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlcy5zYXZlKHApO1xuXG4gICAgICAgICAgaWYgKCF0cmFuc2Zvcm1Qcm9wVHdlZW4pIHtcbiAgICAgICAgICAgIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuICAgICAgICAgICAgY2FjaGUucmVuZGVyVHJhbnNmb3JtICYmICF2YXJzLnBhcnNlVHJhbnNmb3JtIHx8IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHZhcnMucGFyc2VUcmFuc2Zvcm0pOyAvLyBpZiwgZm9yIGV4YW1wbGUsIGdzYXAuc2V0KC4uLiB7dHJhbnNmb3JtOlwidHJhbnNsYXRlWCg1MHZ3KVwifSksIHRoZSBfZ2V0KCkgY2FsbCBkb2Vzbid0IHBhcnNlIHRoZSB0cmFuc2Zvcm0sIHRodXMgY2FjaGUucmVuZGVyVHJhbnNmb3JtIHdvbid0IGJlIHNldCB5ZXQgc28gZm9yY2UgdGhlIHBhcnNpbmcgb2YgdGhlIHRyYW5zZm9ybSBoZXJlLlxuXG4gICAgICAgICAgICBzbW9vdGggPSB2YXJzLnNtb290aE9yaWdpbiAhPT0gZmFsc2UgJiYgY2FjaGUuc21vb3RoO1xuICAgICAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuID0gdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBzdHlsZSwgX3RyYW5zZm9ybVByb3AsIDAsIDEsIGNhY2hlLnJlbmRlclRyYW5zZm9ybSwgY2FjaGUsIDAsIC0xKTsgLy90aGUgZmlyc3QgdGltZSB0aHJvdWdoLCBjcmVhdGUgdGhlIHJlbmRlcmluZyBQcm9wVHdlZW4gc28gdGhhdCBpdCBydW5zIExBU1QgKGluIHRoZSBsaW5rZWQgbGlzdCwgd2Uga2VlcCBhZGRpbmcgdG8gdGhlIGJlZ2lubmluZylcblxuICAgICAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuLmRlcCA9IDE7IC8vZmxhZyBpdCBhcyBkZXBlbmRlbnQgc28gdGhhdCBpZiB0aGluZ3MgZ2V0IGtpbGxlZC9vdmVyd3JpdHRlbiBhbmQgdGhpcyBpcyB0aGUgb25seSBQcm9wVHdlZW4gbGVmdCwgd2UgY2FuIHNhZmVseSBraWxsIHRoZSB3aG9sZSB0d2Vlbi5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocCA9PT0gXCJzY2FsZVwiKSB7XG4gICAgICAgICAgICB0aGlzLl9wdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIGNhY2hlLCBcInNjYWxlWVwiLCBjYWNoZS5zY2FsZVksIChyZWxhdGl2ZSA/IF9wYXJzZVJlbGF0aXZlKGNhY2hlLnNjYWxlWSwgcmVsYXRpdmUgKyBlbmROdW0pIDogZW5kTnVtKSAtIGNhY2hlLnNjYWxlWSB8fCAwLCBfcmVuZGVyQ1NTUHJvcCk7XG4gICAgICAgICAgICB0aGlzLl9wdC51ID0gMDtcbiAgICAgICAgICAgIHByb3BzLnB1c2goXCJzY2FsZVlcIiwgcCk7XG4gICAgICAgICAgICBwICs9IFwiWFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIikge1xuICAgICAgICAgICAgaW5saW5lUHJvcHMucHVzaChfdHJhbnNmb3JtT3JpZ2luUHJvcCwgMCwgc3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdKTtcbiAgICAgICAgICAgIGVuZFZhbHVlID0gX2NvbnZlcnRLZXl3b3Jkc1RvUGVyY2VudGFnZXMoZW5kVmFsdWUpOyAvL2luIGNhc2Ugc29tZXRoaW5nIGxpa2UgXCJsZWZ0IHRvcFwiIG9yIFwiYm90dG9tIHJpZ2h0XCIgaXMgcGFzc2VkIGluLiBDb252ZXJ0IHRvIHBlcmNlbnRhZ2VzLlxuXG4gICAgICAgICAgICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgICAgICAgICAgIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIGVuZFZhbHVlLCAwLCBzbW9vdGgsIDAsIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZW5kVW5pdCA9IHBhcnNlRmxvYXQoZW5kVmFsdWUuc3BsaXQoXCIgXCIpWzJdKSB8fCAwOyAvL2hhbmRsZSB0aGUgek9yaWdpbiBzZXBhcmF0ZWx5IVxuXG4gICAgICAgICAgICAgIGVuZFVuaXQgIT09IGNhY2hlLnpPcmlnaW4gJiYgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgY2FjaGUsIFwiek9yaWdpblwiLCBjYWNoZS56T3JpZ2luLCBlbmRVbml0KTtcblxuICAgICAgICAgICAgICBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBzdHlsZSwgcCwgX2ZpcnN0VHdvT25seShzdGFydFZhbHVlKSwgX2ZpcnN0VHdvT25seShlbmRWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwic3ZnT3JpZ2luXCIpIHtcbiAgICAgICAgICAgIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIGVuZFZhbHVlLCAxLCBzbW9vdGgsIDAsIHRoaXMpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgaW4gX3JvdGF0aW9uYWxQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBfYWRkUm90YXRpb25hbFByb3BUd2Vlbih0aGlzLCBjYWNoZSwgcCwgc3RhcnROdW0sIHJlbGF0aXZlID8gX3BhcnNlUmVsYXRpdmUoc3RhcnROdW0sIHJlbGF0aXZlICsgZW5kVmFsdWUpIDogZW5kVmFsdWUpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwic21vb3RoT3JpZ2luXCIpIHtcbiAgICAgICAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIGNhY2hlLCBcInNtb290aFwiLCBjYWNoZS5zbW9vdGgsIGVuZFZhbHVlKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcImZvcmNlM0RcIikge1xuICAgICAgICAgICAgY2FjaGVbcF0gPSBlbmRWYWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgX2FkZFJhd1RyYW5zZm9ybVBUcyh0aGlzLCBlbmRWYWx1ZSwgdGFyZ2V0KTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEocCBpbiBzdHlsZSkpIHtcbiAgICAgICAgICBwID0gX2NoZWNrUHJvcFByZWZpeChwKSB8fCBwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzVHJhbnNmb3JtUmVsYXRlZCB8fCAoZW5kTnVtIHx8IGVuZE51bSA9PT0gMCkgJiYgKHN0YXJ0TnVtIHx8IHN0YXJ0TnVtID09PSAwKSAmJiAhX2NvbXBsZXhFeHAudGVzdChlbmRWYWx1ZSkgJiYgcCBpbiBzdHlsZSkge1xuICAgICAgICAgIHN0YXJ0VW5pdCA9IChzdGFydFZhbHVlICsgXCJcIikuc3Vic3RyKChzdGFydE51bSArIFwiXCIpLmxlbmd0aCk7XG4gICAgICAgICAgZW5kTnVtIHx8IChlbmROdW0gPSAwKTsgLy8gcHJvdGVjdCBhZ2FpbnN0IE5hTlxuXG4gICAgICAgICAgZW5kVW5pdCA9IGdldFVuaXQoZW5kVmFsdWUpIHx8IChwIGluIF9jb25maWcudW5pdHMgPyBfY29uZmlnLnVuaXRzW3BdIDogc3RhcnRVbml0KTtcbiAgICAgICAgICBzdGFydFVuaXQgIT09IGVuZFVuaXQgJiYgKHN0YXJ0TnVtID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwLCBzdGFydFZhbHVlLCBlbmRVbml0KSk7XG4gICAgICAgICAgdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBpc1RyYW5zZm9ybVJlbGF0ZWQgPyBjYWNoZSA6IHN0eWxlLCBwLCBzdGFydE51bSwgKHJlbGF0aXZlID8gX3BhcnNlUmVsYXRpdmUoc3RhcnROdW0sIHJlbGF0aXZlICsgZW5kTnVtKSA6IGVuZE51bSkgLSBzdGFydE51bSwgIWlzVHJhbnNmb3JtUmVsYXRlZCAmJiAoZW5kVW5pdCA9PT0gXCJweFwiIHx8IHAgPT09IFwiekluZGV4XCIpICYmIHZhcnMuYXV0b1JvdW5kICE9PSBmYWxzZSA/IF9yZW5kZXJSb3VuZGVkQ1NTUHJvcCA6IF9yZW5kZXJDU1NQcm9wKTtcbiAgICAgICAgICB0aGlzLl9wdC51ID0gZW5kVW5pdCB8fCAwO1xuXG4gICAgICAgICAgaWYgKHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCAmJiBlbmRVbml0ICE9PSBcIiVcIikge1xuICAgICAgICAgICAgLy93aGVuIHRoZSB0d2VlbiBnb2VzIGFsbCB0aGUgd2F5IGJhY2sgdG8gdGhlIGJlZ2lubmluZywgd2UgbmVlZCB0byByZXZlcnQgaXQgdG8gdGhlIE9MRC9PUklHSU5BTCB2YWx1ZSAod2l0aCB0aG9zZSB1bml0cykuIFdlIHJlY29yZCB0aGF0IGFzIGEgXCJiXCIgKGJlZ2lubmluZykgcHJvcGVydHkgYW5kIHBvaW50IHRvIGEgcmVuZGVyIG1ldGhvZCB0aGF0IGhhbmRsZXMgdGhhdC4gKHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbilcbiAgICAgICAgICAgIHRoaXMuX3B0LmIgPSBzdGFydFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcHQuciA9IF9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIShwIGluIHN0eWxlKSkge1xuICAgICAgICAgIGlmIChwIGluIHRhcmdldCkge1xuICAgICAgICAgICAgLy9tYXliZSBpdCdzIG5vdCBhIHN0eWxlIC0gaXQgY291bGQgYmUgYSBwcm9wZXJ0eSBhZGRlZCBkaXJlY3RseSB0byBhbiBlbGVtZW50IGluIHdoaWNoIGNhc2Ugd2UnbGwgdHJ5IHRvIGFuaW1hdGUgdGhhdC5cbiAgICAgICAgICAgIHRoaXMuYWRkKHRhcmdldCwgcCwgc3RhcnRWYWx1ZSB8fCB0YXJnZXRbcF0sIHJlbGF0aXZlID8gcmVsYXRpdmUgKyBlbmRWYWx1ZSA6IGVuZFZhbHVlLCBpbmRleCwgdGFyZ2V0cyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwICE9PSBcInBhcnNlVHJhbnNmb3JtXCIpIHtcbiAgICAgICAgICAgIF9taXNzaW5nUGx1Z2luKHAsIGVuZFZhbHVlKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcuY2FsbCh0aGlzLCB0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIHJlbGF0aXZlID8gcmVsYXRpdmUgKyBlbmRWYWx1ZSA6IGVuZFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzVHJhbnNmb3JtUmVsYXRlZCB8fCAocCBpbiBzdHlsZSA/IGlubGluZVByb3BzLnB1c2gocCwgMCwgc3R5bGVbcF0pIDogaW5saW5lUHJvcHMucHVzaChwLCAxLCBzdGFydFZhbHVlIHx8IHRhcmdldFtwXSkpO1xuICAgICAgICBwcm9wcy5wdXNoKHApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhc1ByaW9yaXR5ICYmIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkodGhpcyk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHJhdGlvLCBkYXRhKSB7XG4gICAgaWYgKGRhdGEudHdlZW4uX3RpbWUgfHwgIV9yZXZlcnRpbmcoKSkge1xuICAgICAgdmFyIHB0ID0gZGF0YS5fcHQ7XG5cbiAgICAgIHdoaWxlIChwdCkge1xuICAgICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5zdHlsZXMucmV2ZXJ0KCk7XG4gICAgfVxuICB9LFxuICBnZXQ6IF9nZXQsXG4gIGFsaWFzZXM6IF9wcm9wZXJ0eUFsaWFzZXMsXG4gIGdldFNldHRlcjogZnVuY3Rpb24gZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHksIHBsdWdpbikge1xuICAgIC8vcmV0dXJucyBhIHNldHRlciBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUgYW5kIGFwcGxpZXMgaXQgYWNjb3JkaW5nbHkuIFJlbWVtYmVyLCBwcm9wZXJ0aWVzIGxpa2UgXCJ4XCIgYXJlbid0IGFzIHNpbXBsZSBhcyB0YXJnZXQuc3R5bGUucHJvcGVydHkgPSB2YWx1ZSBiZWNhdXNlIHRoZXkndmUgZ290IHRvIGJlIGFwcGxpZWQgdG8gYSBwcm94eSBvYmplY3QgYW5kIHRoZW4gbWVyZ2VkIGludG8gYSB0cmFuc2Zvcm0gc3RyaW5nIGluIGEgcmVuZGVyZXIuXG4gICAgdmFyIHAgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XTtcbiAgICBwICYmIHAuaW5kZXhPZihcIixcIikgPCAwICYmIChwcm9wZXJ0eSA9IHApO1xuICAgIHJldHVybiBwcm9wZXJ0eSBpbiBfdHJhbnNmb3JtUHJvcHMgJiYgcHJvcGVydHkgIT09IF90cmFuc2Zvcm1PcmlnaW5Qcm9wICYmICh0YXJnZXQuX2dzYXAueCB8fCBfZ2V0KHRhcmdldCwgXCJ4XCIpKSA/IHBsdWdpbiAmJiBfcmVjZW50U2V0dGVyUGx1Z2luID09PSBwbHVnaW4gPyBwcm9wZXJ0eSA9PT0gXCJzY2FsZVwiID8gX3NldHRlclNjYWxlIDogX3NldHRlclRyYW5zZm9ybSA6IChfcmVjZW50U2V0dGVyUGx1Z2luID0gcGx1Z2luIHx8IHt9KSAmJiAocHJvcGVydHkgPT09IFwic2NhbGVcIiA/IF9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIgOiBfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlcikgOiB0YXJnZXQuc3R5bGUgJiYgIV9pc1VuZGVmaW5lZCh0YXJnZXQuc3R5bGVbcHJvcGVydHldKSA/IF9zZXR0ZXJDU1NTdHlsZSA6IH5wcm9wZXJ0eS5pbmRleE9mKFwiLVwiKSA/IF9zZXR0ZXJDU1NQcm9wIDogX2dldFNldHRlcih0YXJnZXQsIHByb3BlcnR5KTtcbiAgfSxcbiAgY29yZToge1xuICAgIF9yZW1vdmVQcm9wZXJ0eTogX3JlbW92ZVByb3BlcnR5LFxuICAgIF9nZXRNYXRyaXg6IF9nZXRNYXRyaXhcbiAgfVxufTtcbmdzYXAudXRpbHMuY2hlY2tQcmVmaXggPSBfY2hlY2tQcm9wUHJlZml4O1xuZ3NhcC5jb3JlLmdldFN0eWxlU2F2ZXIgPSBfZ2V0U3R5bGVTYXZlcjtcblxuKGZ1bmN0aW9uIChwb3NpdGlvbkFuZFNjYWxlLCByb3RhdGlvbiwgb3RoZXJzLCBhbGlhc2VzKSB7XG4gIHZhciBhbGwgPSBfZm9yRWFjaE5hbWUocG9zaXRpb25BbmRTY2FsZSArIFwiLFwiICsgcm90YXRpb24gKyBcIixcIiArIG90aGVycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBfdHJhbnNmb3JtUHJvcHNbbmFtZV0gPSAxO1xuICB9KTtcblxuICBfZm9yRWFjaE5hbWUocm90YXRpb24sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgX2NvbmZpZy51bml0c1tuYW1lXSA9IFwiZGVnXCI7XG4gICAgX3JvdGF0aW9uYWxQcm9wZXJ0aWVzW25hbWVdID0gMTtcbiAgfSk7XG5cbiAgX3Byb3BlcnR5QWxpYXNlc1thbGxbMTNdXSA9IHBvc2l0aW9uQW5kU2NhbGUgKyBcIixcIiArIHJvdGF0aW9uO1xuXG4gIF9mb3JFYWNoTmFtZShhbGlhc2VzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzcGxpdCA9IG5hbWUuc3BsaXQoXCI6XCIpO1xuICAgIF9wcm9wZXJ0eUFsaWFzZXNbc3BsaXRbMV1dID0gYWxsW3NwbGl0WzBdXTtcbiAgfSk7XG59KShcIngseSx6LHNjYWxlLHNjYWxlWCxzY2FsZVkseFBlcmNlbnQseVBlcmNlbnRcIiwgXCJyb3RhdGlvbixyb3RhdGlvblgscm90YXRpb25ZLHNrZXdYLHNrZXdZXCIsIFwidHJhbnNmb3JtLHRyYW5zZm9ybU9yaWdpbixzdmdPcmlnaW4sZm9yY2UzRCxzbW9vdGhPcmlnaW4sdHJhbnNmb3JtUGVyc3BlY3RpdmVcIiwgXCIwOnRyYW5zbGF0ZVgsMTp0cmFuc2xhdGVZLDI6dHJhbnNsYXRlWiw4OnJvdGF0ZSw4OnJvdGF0aW9uWiw4OnJvdGF0ZVosOTpyb3RhdGVYLDEwOnJvdGF0ZVlcIik7XG5cbl9mb3JFYWNoTmFtZShcIngseSx6LHRvcCxyaWdodCxib3R0b20sbGVmdCx3aWR0aCxoZWlnaHQsZm9udFNpemUscGFkZGluZyxtYXJnaW4scGVyc3BlY3RpdmVcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgX2NvbmZpZy51bml0c1tuYW1lXSA9IFwicHhcIjtcbn0pO1xuXG5nc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1BsdWdpbik7XG5leHBvcnQgeyBDU1NQbHVnaW4gYXMgZGVmYXVsdCwgX2dldEJCb3gsIF9jcmVhdGVFbGVtZW50LCBfY2hlY2tQcm9wUHJlZml4IGFzIGNoZWNrUHJlZml4IH07Il0sIm5hbWVzIjpbImdzYXAiLCJfZ2V0UHJvcGVydHkiLCJfbnVtRXhwIiwiX251bVdpdGhVbml0RXhwIiwiZ2V0VW5pdCIsIl9pc1N0cmluZyIsIl9pc1VuZGVmaW5lZCIsIl9yZW5kZXJDb21wbGV4U3RyaW5nIiwiX3JlbEV4cCIsIl9mb3JFYWNoTmFtZSIsIl9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkiLCJfY29sb3JTdHJpbmdGaWx0ZXIiLCJfY2hlY2tQbHVnaW4iLCJfcmVwbGFjZVJhbmRvbSIsIl9wbHVnaW5zIiwiR1NDYWNoZSIsIlByb3BUd2VlbiIsIl9jb25maWciLCJfdGlja2VyIiwiX3JvdW5kIiwiX21pc3NpbmdQbHVnaW4iLCJfZ2V0U2V0dGVyIiwiX2dldENhY2hlIiwiX2NvbG9yRXhwIiwiX3BhcnNlUmVsYXRpdmUiLCJfc2V0RGVmYXVsdHMiLCJfcmVtb3ZlTGlua2VkTGlzdEl0ZW0iLCJfd2luIiwiX2RvYyIsIl9kb2NFbGVtZW50IiwiX3BsdWdpbkluaXR0ZWQiLCJfdGVtcERpdiIsIl90ZW1wRGl2U3R5bGVyIiwiX3JlY2VudFNldHRlclBsdWdpbiIsIl9yZXZlcnRpbmciLCJfd2luZG93RXhpc3RzIiwid2luZG93IiwiX3RyYW5zZm9ybVByb3BzIiwiX1JBRDJERUciLCJNYXRoIiwiUEkiLCJfREVHMlJBRCIsIl9hdGFuMiIsImF0YW4yIiwiX2JpZ051bSIsIl9jYXBzRXhwIiwiX2hvcml6b250YWxFeHAiLCJfY29tcGxleEV4cCIsIl9wcm9wZXJ0eUFsaWFzZXMiLCJhdXRvQWxwaGEiLCJzY2FsZSIsImFscGhhIiwiX3JlbmRlckNTU1Byb3AiLCJyYXRpbyIsImRhdGEiLCJzZXQiLCJ0IiwicCIsInJvdW5kIiwicyIsImMiLCJ1IiwiX3JlbmRlclByb3BXaXRoRW5kIiwiZSIsIl9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZyIsImIiLCJfcmVuZGVyUm91bmRlZENTU1Byb3AiLCJ2YWx1ZSIsIl9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlIiwiX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQiLCJfc2V0dGVyQ1NTU3R5bGUiLCJ0YXJnZXQiLCJwcm9wZXJ0eSIsInN0eWxlIiwiX3NldHRlckNTU1Byb3AiLCJzZXRQcm9wZXJ0eSIsIl9zZXR0ZXJUcmFuc2Zvcm0iLCJfZ3NhcCIsIl9zZXR0ZXJTY2FsZSIsInNjYWxlWCIsInNjYWxlWSIsIl9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIiLCJjYWNoZSIsInJlbmRlclRyYW5zZm9ybSIsIl9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyIiwiX3RyYW5zZm9ybVByb3AiLCJfdHJhbnNmb3JtT3JpZ2luUHJvcCIsIl9zYXZlU3R5bGUiLCJpc05vdENTUyIsIl90aGlzIiwidGZtIiwiaW5kZXhPZiIsInNwbGl0IiwiZm9yRWFjaCIsImEiLCJfZ2V0IiwieCIsInpPcmlnaW4iLCJ0cmFuc2Zvcm0iLCJjYWxsIiwicHJvcHMiLCJzdmciLCJzdmdvIiwiZ2V0QXR0cmlidXRlIiwicHVzaCIsIl9yZW1vdmVJbmRlcGVuZGVudFRyYW5zZm9ybXMiLCJ0cmFuc2xhdGUiLCJyZW1vdmVQcm9wZXJ0eSIsIl9yZXZlcnRTdHlsZSIsImkiLCJsZW5ndGgiLCJzdWJzdHIiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJzZXRBdHRyaWJ1dGUiLCJpc1N0YXJ0IiwidW5jYWNoZSIsIl9nZXRTdHlsZVNhdmVyIiwicHJvcGVydGllcyIsInNhdmVyIiwicmV2ZXJ0Iiwic2F2ZSIsImNvcmUiLCJnZXRDYWNoZSIsIl9zdXBwb3J0czNEIiwiX2NyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwibnMiLCJjcmVhdGVFbGVtZW50TlMiLCJjcmVhdGVFbGVtZW50IiwiX2dldENvbXB1dGVkUHJvcGVydHkiLCJza2lwUHJlZml4RmFsbGJhY2siLCJjcyIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiX2NoZWNrUHJvcFByZWZpeCIsIl9wcmVmaXhlcyIsImVsZW1lbnQiLCJwcmVmZXJQcmVmaXgiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsIl9pbml0Q29yZSIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY3NzVGV4dCIsInJldmVydGluZyIsIl9nZXRCQm94SGFjayIsInN3YXBJZlBvc3NpYmxlIiwib3duZXJTVkdFbGVtZW50Iiwib2xkUGFyZW50IiwicGFyZW50Tm9kZSIsIm9sZFNpYmxpbmciLCJuZXh0U2libGluZyIsIm9sZENTUyIsImJib3giLCJhcHBlbmRDaGlsZCIsImRpc3BsYXkiLCJnZXRCQm94IiwiX2dzYXBCQm94IiwiaW5zZXJ0QmVmb3JlIiwicmVtb3ZlQ2hpbGQiLCJfZ2V0QXR0cmlidXRlRmFsbGJhY2tzIiwiYXR0cmlidXRlc0FycmF5IiwiaGFzQXR0cmlidXRlIiwiX2dldEJCb3giLCJib3VuZHMiLCJlcnJvciIsIndpZHRoIiwiaGVpZ2h0IiwieSIsIl9pc1NWRyIsImdldENUTSIsIl9yZW1vdmVQcm9wZXJ0eSIsImZpcnN0MkNoYXJzIiwicmVtb3ZlQXR0cmlidXRlIiwiX2FkZE5vblR3ZWVuaW5nUFQiLCJwbHVnaW4iLCJiZWdpbm5pbmciLCJlbmQiLCJvbmx5U2V0QXRFbmQiLCJwdCIsIl9wdCIsIl9wcm9wcyIsIl9ub25Db252ZXJ0aWJsZVVuaXRzIiwiZGVnIiwicmFkIiwidHVybiIsIl9ub25TdGFuZGFyZExheW91dHMiLCJncmlkIiwiZmxleCIsIl9jb252ZXJ0VG9Vbml0IiwidW5pdCIsImN1clZhbHVlIiwicGFyc2VGbG9hdCIsImN1clVuaXQiLCJ0cmltIiwiaG9yaXpvbnRhbCIsInRlc3QiLCJpc1Jvb3RTVkciLCJ0YWdOYW1lIiwibWVhc3VyZVByb3BlcnR5IiwiYW1vdW50IiwidG9QaXhlbHMiLCJ0b1BlcmNlbnQiLCJweCIsInBhcmVudCIsImlzU1ZHIiwiYm9keSIsInRpbWUiLCJ2IiwicG9zaXRpb24iLCJfcGFyc2VUcmFuc2Zvcm0iLCJvcmlnaW4iLCJfZmlyc3RUd29Pbmx5IiwiX3NwZWNpYWxQcm9wcyIsIl90d2VlbkNvbXBsZXhDU1NTdHJpbmciLCJwcm9wIiwic3RhcnQiLCJpbmRleCIsIm1hdGNoSW5kZXgiLCJyZXN1bHQiLCJzdGFydFZhbHVlcyIsInN0YXJ0TnVtIiwiY29sb3IiLCJzdGFydFZhbHVlIiwiZW5kVmFsdWUiLCJlbmROdW0iLCJjaHVuayIsImVuZFVuaXQiLCJzdGFydFVuaXQiLCJlbmRWYWx1ZXMiLCJtYXRjaCIsImV4ZWMiLCJzdWJzdHJpbmciLCJsYXN0SW5kZXgiLCJ1bml0cyIsIl9uZXh0IiwibSIsInIiLCJfa2V5d29yZFRvUGVyY2VudCIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsImNlbnRlciIsIl9jb252ZXJ0S2V5d29yZHNUb1BlcmNlbnRhZ2VzIiwiam9pbiIsIl9yZW5kZXJDbGVhclByb3BzIiwidHdlZW4iLCJfdGltZSIsIl9kdXIiLCJjbGVhclRyYW5zZm9ybXMiLCJjbGVhclByb3BzIiwicHIiLCJfaWRlbnRpdHkyRE1hdHJpeCIsIl9yb3RhdGlvbmFsUHJvcGVydGllcyIsIl9pc051bGxUcmFuc2Zvcm0iLCJfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5IiwibWF0cml4U3RyaW5nIiwibWFwIiwiX2dldE1hdHJpeCIsImZvcmNlMkQiLCJtYXRyaXgiLCJ0ZW1wIiwiYWRkZWRUb0RPTSIsImJhc2VWYWwiLCJjb25zb2xpZGF0ZSIsImQiLCJmIiwib2Zmc2V0UGFyZW50IiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiX2FwcGx5U1ZHT3JpZ2luIiwib3JpZ2luSXNBYnNvbHV0ZSIsInNtb290aCIsIm1hdHJpeEFycmF5IiwicGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8iLCJ4T3JpZ2luT2xkIiwieE9yaWdpbiIsInlPcmlnaW5PbGQiLCJ5T3JpZ2luIiwieE9mZnNldE9sZCIsInhPZmZzZXQiLCJ5T2Zmc2V0T2xkIiwieU9mZnNldCIsInR4IiwidHkiLCJvcmlnaW5TcGxpdCIsImRldGVybWluYW50IiwiaW52ZXJ0ZWRTY2FsZVgiLCJ6Iiwicm90YXRpb24iLCJyb3RhdGlvblgiLCJyb3RhdGlvblkiLCJza2V3WCIsInNrZXdZIiwicGVyc3BlY3RpdmUiLCJhbmdsZSIsImNvcyIsInNpbiIsImExMiIsImEyMiIsInQxIiwidDIiLCJ0MyIsImExMyIsImEyMyIsImEzMyIsImE0MiIsImE0MyIsImEzMiIsInJvdGF0ZSIsInNsaWNlIiwic3FydCIsImFicyIsImZvcmNlQ1NTIiwieFBlcmNlbnQiLCJvZmZzZXRXaWR0aCIsInlQZXJjZW50Iiwib2Zmc2V0SGVpZ2h0IiwidHJhbnNmb3JtUGVyc3BlY3RpdmUiLCJmb3JjZTNEIiwiX3JlbmRlclNWR1RyYW5zZm9ybXMiLCJfcmVuZGVyQ1NTVHJhbnNmb3JtcyIsIl9yZW5kZXJOb24zRFRyYW5zZm9ybXMiLCJfYWRkUHhUcmFuc2xhdGUiLCJfemVyb0RlZyIsIl96ZXJvUHgiLCJfZW5kUGFyZW50aGVzaXMiLCJfcmVmIiwidHJhbnNmb3JtcyIsInVzZTNEIiwiX3JlZjIiLCJhMTEiLCJhMjEiLCJ0YW4iLCJfYWRkUm90YXRpb25hbFByb3BUd2VlbiIsImNhcCIsImlzU3RyaW5nIiwiY2hhbmdlIiwiZmluYWxWYWx1ZSIsImRpcmVjdGlvbiIsIl9hc3NpZ24iLCJzb3VyY2UiLCJfYWRkUmF3VHJhbnNmb3JtUFRzIiwic3RhcnRDYWNoZSIsImV4Y2x1ZGUiLCJlbmRDYWNoZSIsIm5hbWUiLCJsIiwic2lkZSIsInZhcnMiLCJhcmd1bWVudHMiLCJpbml0IiwiQ1NTUGx1Z2luIiwicmVnaXN0ZXIiLCJ0YXJnZXRUZXN0Iiwibm9kZVR5cGUiLCJ0YXJnZXRzIiwic3RhcnRBdCIsInNwZWNpYWxQcm9wIiwicmVsYXRpdmUiLCJpc1RyYW5zZm9ybVJlbGF0ZWQiLCJ0cmFuc2Zvcm1Qcm9wVHdlZW4iLCJoYXNQcmlvcml0eSIsImlubGluZVByb3BzIiwic3R5bGVzIiwiYWRkIiwidmlzaWJpbGl0eSIsInBhcnNlVHJhbnNmb3JtIiwic21vb3RoT3JpZ2luIiwiZGVwIiwiYXV0b1JvdW5kIiwicmVuZGVyIiwiZ2V0IiwiYWxpYXNlcyIsImdldFNldHRlciIsInV0aWxzIiwiY2hlY2tQcmVmaXgiLCJnZXRTdHlsZVNhdmVyIiwicG9zaXRpb25BbmRTY2FsZSIsIm90aGVycyIsImFsbCIsInJlZ2lzdGVyUGx1Z2luIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSRulePlugin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSRulePlugin.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CSSRulePlugin: function() { return /* binding */ CSSRulePlugin; },\n/* harmony export */   \"default\": function() { return /* binding */ CSSRulePlugin; }\n/* harmony export */ });\n/*!\n * CSSRulePlugin 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var gsap, _coreInitted, _win, _doc, CSSPlugin, _windowExists = function _windowExists() {\n    return typeof window !== \"undefined\";\n}, _getGSAP = function _getGSAP() {\n    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _checkRegister = function _checkRegister() {\n    if (!_coreInitted) {\n        _initCore();\n        if (!CSSPlugin) {\n            console.warn(\"Please gsap.registerPlugin(CSSPlugin, CSSRulePlugin)\");\n        }\n    }\n    return _coreInitted;\n}, _initCore = function _initCore(core) {\n    gsap = core || _getGSAP();\n    if (_windowExists()) {\n        _win = window;\n        _doc = document;\n    }\n    if (gsap) {\n        CSSPlugin = gsap.plugins.css;\n        if (CSSPlugin) {\n            _coreInitted = 1;\n        }\n    }\n};\nvar CSSRulePlugin = {\n    version: \"3.12.5\",\n    name: \"cssRule\",\n    init: function init(target, value, tween, index, targets) {\n        if (!_checkRegister() || typeof target.cssText === \"undefined\") {\n            return false;\n        }\n        var div = target._gsProxy = target._gsProxy || _doc.createElement(\"div\");\n        this.ss = target;\n        this.style = div.style;\n        div.style.cssText = target.cssText;\n        CSSPlugin.prototype.init.call(this, div, value, tween, index, targets); //we just offload all the work to the regular CSSPlugin and then copy the cssText back over to the rule in the render() method. This allows us to have all of the updates to CSSPlugin automatically flow through to CSSRulePlugin instead of having to maintain both\n    },\n    render: function render(ratio, data) {\n        var pt = data._pt, style = data.style, ss = data.ss, i;\n        while(pt){\n            pt.r(ratio, pt.d);\n            pt = pt._next;\n        }\n        i = style.length;\n        while(--i > -1){\n            ss[style[i]] = style[style[i]];\n        }\n    },\n    getRule: function getRule(selector) {\n        _checkRegister();\n        var ruleProp = _doc.all ? \"rules\" : \"cssRules\", styleSheets = _doc.styleSheets, i = styleSheets.length, pseudo = selector.charAt(0) === \":\", j, curSS, cs, a;\n        selector = (pseudo ? \"\" : \",\") + selector.split(\"::\").join(\":\").toLowerCase() + \",\"; //note: old versions of IE report tag name selectors as upper case, so we just change everything to lowercase.\n        if (pseudo) {\n            a = [];\n        }\n        while(i--){\n            //Firefox may throw insecure operation errors when css is loaded from other domains, so try/catch.\n            try {\n                curSS = styleSheets[i][ruleProp];\n                if (!curSS) {\n                    continue;\n                }\n                j = curSS.length;\n            } catch (e) {\n                console.warn(e);\n                continue;\n            }\n            while(--j > -1){\n                cs = curSS[j];\n                if (cs.selectorText && (\",\" + cs.selectorText.split(\"::\").join(\":\").toLowerCase() + \",\").indexOf(selector) !== -1) {\n                    //note: IE adds an extra \":\" to pseudo selectors, so .myClass:after becomes .myClass::after, so we need to strip the extra one out.\n                    if (pseudo) {\n                        a.push(cs.style);\n                    } else {\n                        return cs.style;\n                    }\n                }\n            }\n        }\n        return a;\n    },\n    register: _initCore\n};\n_getGSAP() && gsap.registerPlugin(CSSRulePlugin);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9DU1NSdWxlUGx1Z2luLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7O0FBUUEsR0FFQSxrQkFBa0IsR0FDbEIsSUFBSUEsTUFDQUMsY0FDQUMsTUFDQUMsTUFDQUMsV0FDQUMsZ0JBQWdCLFNBQVNBO0lBQzNCLE9BQU8sT0FBT0MsV0FBVztBQUMzQixHQUNJQyxXQUFXLFNBQVNBO0lBQ3RCLE9BQU9QLFFBQVFLLG1CQUFvQkwsQ0FBQUEsT0FBT00sT0FBT04sSUFBSSxLQUFLQSxLQUFLUSxjQUFjLElBQUlSO0FBQ25GLEdBQ0lTLGlCQUFpQixTQUFTQTtJQUM1QixJQUFJLENBQUNSLGNBQWM7UUFDakJTO1FBRUEsSUFBSSxDQUFDTixXQUFXO1lBQ2RPLFFBQVFDLElBQUksQ0FBQztRQUNmO0lBQ0Y7SUFFQSxPQUFPWDtBQUNULEdBQ0lTLFlBQVksU0FBU0EsVUFBVUcsSUFBSTtJQUNyQ2IsT0FBT2EsUUFBUU47SUFFZixJQUFJRixpQkFBaUI7UUFDbkJILE9BQU9JO1FBQ1BILE9BQU9XO0lBQ1Q7SUFFQSxJQUFJZCxNQUFNO1FBQ1JJLFlBQVlKLEtBQUtlLE9BQU8sQ0FBQ0MsR0FBRztRQUU1QixJQUFJWixXQUFXO1lBQ2JILGVBQWU7UUFDakI7SUFDRjtBQUNGO0FBRU8sSUFBSWdCLGdCQUFnQjtJQUN6QkMsU0FBUztJQUNUQyxNQUFNO0lBQ05DLE1BQU0sU0FBU0EsS0FBS0MsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxPQUFPO1FBQ3RELElBQUksQ0FBQ2hCLG9CQUFvQixPQUFPWSxPQUFPSyxPQUFPLEtBQUssYUFBYTtZQUM5RCxPQUFPO1FBQ1Q7UUFFQSxJQUFJQyxNQUFNTixPQUFPTyxRQUFRLEdBQUdQLE9BQU9PLFFBQVEsSUFBSXpCLEtBQUswQixhQUFhLENBQUM7UUFFbEUsSUFBSSxDQUFDQyxFQUFFLEdBQUdUO1FBQ1YsSUFBSSxDQUFDVSxLQUFLLEdBQUdKLElBQUlJLEtBQUs7UUFDdEJKLElBQUlJLEtBQUssQ0FBQ0wsT0FBTyxHQUFHTCxPQUFPSyxPQUFPO1FBQ2xDdEIsVUFBVTRCLFNBQVMsQ0FBQ1osSUFBSSxDQUFDYSxJQUFJLENBQUMsSUFBSSxFQUFFTixLQUFLTCxPQUFPQyxPQUFPQyxPQUFPQyxVQUFVLHFRQUFxUTtJQUMvVTtJQUNBUyxRQUFRLFNBQVNBLE9BQU9DLEtBQUssRUFBRUMsSUFBSTtRQUNqQyxJQUFJQyxLQUFLRCxLQUFLRSxHQUFHLEVBQ2JQLFFBQVFLLEtBQUtMLEtBQUssRUFDbEJELEtBQUtNLEtBQUtOLEVBQUUsRUFDWlM7UUFFSixNQUFPRixHQUFJO1lBQ1RBLEdBQUdHLENBQUMsQ0FBQ0wsT0FBT0UsR0FBR0ksQ0FBQztZQUNoQkosS0FBS0EsR0FBR0ssS0FBSztRQUNmO1FBRUFILElBQUlSLE1BQU1ZLE1BQU07UUFFaEIsTUFBTyxFQUFFSixJQUFJLENBQUMsRUFBRztZQUNmVCxFQUFFLENBQUNDLEtBQUssQ0FBQ1EsRUFBRSxDQUFDLEdBQUdSLEtBQUssQ0FBQ0EsS0FBSyxDQUFDUSxFQUFFLENBQUM7UUFDaEM7SUFDRjtJQUNBSyxTQUFTLFNBQVNBLFFBQVFDLFFBQVE7UUFDaENwQztRQUVBLElBQUlxQyxXQUFXM0MsS0FBSzRDLEdBQUcsR0FBRyxVQUFVLFlBQ2hDQyxjQUFjN0MsS0FBSzZDLFdBQVcsRUFDOUJULElBQUlTLFlBQVlMLE1BQU0sRUFDdEJNLFNBQVNKLFNBQVNLLE1BQU0sQ0FBQyxPQUFPLEtBQ2hDQyxHQUNBQyxPQUNBQyxJQUNBQztRQUNKVCxXQUFXLENBQUNJLFNBQVMsS0FBSyxHQUFFLElBQUtKLFNBQVNVLEtBQUssQ0FBQyxNQUFNQyxJQUFJLENBQUMsS0FBS0MsV0FBVyxLQUFLLEtBQUssOEdBQThHO1FBRW5NLElBQUlSLFFBQVE7WUFDVkssSUFBSSxFQUFFO1FBQ1I7UUFFQSxNQUFPZixJQUFLO1lBQ1Ysa0dBQWtHO1lBQ2xHLElBQUk7Z0JBQ0ZhLFFBQVFKLFdBQVcsQ0FBQ1QsRUFBRSxDQUFDTyxTQUFTO2dCQUVoQyxJQUFJLENBQUNNLE9BQU87b0JBQ1Y7Z0JBQ0Y7Z0JBRUFELElBQUlDLE1BQU1ULE1BQU07WUFDbEIsRUFBRSxPQUFPZSxHQUFHO2dCQUNWL0MsUUFBUUMsSUFBSSxDQUFDOEM7Z0JBQ2I7WUFDRjtZQUVBLE1BQU8sRUFBRVAsSUFBSSxDQUFDLEVBQUc7Z0JBQ2ZFLEtBQUtELEtBQUssQ0FBQ0QsRUFBRTtnQkFFYixJQUFJRSxHQUFHTSxZQUFZLElBQUksQ0FBQyxNQUFNTixHQUFHTSxZQUFZLENBQUNKLEtBQUssQ0FBQyxNQUFNQyxJQUFJLENBQUMsS0FBS0MsV0FBVyxLQUFLLEdBQUUsRUFBR0csT0FBTyxDQUFDZixjQUFjLENBQUMsR0FBRztvQkFDakgsbUlBQW1JO29CQUNuSSxJQUFJSSxRQUFRO3dCQUNWSyxFQUFFTyxJQUFJLENBQUNSLEdBQUd0QixLQUFLO29CQUNqQixPQUFPO3dCQUNMLE9BQU9zQixHQUFHdEIsS0FBSztvQkFDakI7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsT0FBT3VCO0lBQ1Q7SUFDQVEsVUFBVXBEO0FBQ1osRUFBRTtBQUNGSCxjQUFjUCxLQUFLUSxjQUFjLENBQUNTO0FBQ0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dzYXBAMy4xMi41L25vZGVfbW9kdWxlcy9nc2FwL0NTU1J1bGVQbHVnaW4uanM/ZDNhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENTU1J1bGVQbHVnaW4gMy4xMi41XG4gKiBodHRwczovL2dzYXAuY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyNCwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9nc2FwLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHU0FQIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIGdzYXAsXG4gICAgX2NvcmVJbml0dGVkLFxuICAgIF93aW4sXG4gICAgX2RvYyxcbiAgICBDU1NQbHVnaW4sXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCBfd2luZG93RXhpc3RzKCkgJiYgKGdzYXAgPSB3aW5kb3cuZ3NhcCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbiAmJiBnc2FwO1xufSxcbiAgICBfY2hlY2tSZWdpc3RlciA9IGZ1bmN0aW9uIF9jaGVja1JlZ2lzdGVyKCkge1xuICBpZiAoIV9jb3JlSW5pdHRlZCkge1xuICAgIF9pbml0Q29yZSgpO1xuXG4gICAgaWYgKCFDU1NQbHVnaW4pIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlBsZWFzZSBnc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1BsdWdpbiwgQ1NTUnVsZVBsdWdpbilcIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9jb3JlSW5pdHRlZDtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKGNvcmUpIHtcbiAgZ3NhcCA9IGNvcmUgfHwgX2dldEdTQVAoKTtcblxuICBpZiAoX3dpbmRvd0V4aXN0cygpKSB7XG4gICAgX3dpbiA9IHdpbmRvdztcbiAgICBfZG9jID0gZG9jdW1lbnQ7XG4gIH1cblxuICBpZiAoZ3NhcCkge1xuICAgIENTU1BsdWdpbiA9IGdzYXAucGx1Z2lucy5jc3M7XG5cbiAgICBpZiAoQ1NTUGx1Z2luKSB7XG4gICAgICBfY29yZUluaXR0ZWQgPSAxO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IHZhciBDU1NSdWxlUGx1Z2luID0ge1xuICB2ZXJzaW9uOiBcIjMuMTIuNVwiLFxuICBuYW1lOiBcImNzc1J1bGVcIixcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhbHVlLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcbiAgICBpZiAoIV9jaGVja1JlZ2lzdGVyKCkgfHwgdHlwZW9mIHRhcmdldC5jc3NUZXh0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGRpdiA9IHRhcmdldC5fZ3NQcm94eSA9IHRhcmdldC5fZ3NQcm94eSB8fCBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICB0aGlzLnNzID0gdGFyZ2V0O1xuICAgIHRoaXMuc3R5bGUgPSBkaXYuc3R5bGU7XG4gICAgZGl2LnN0eWxlLmNzc1RleHQgPSB0YXJnZXQuY3NzVGV4dDtcbiAgICBDU1NQbHVnaW4ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBkaXYsIHZhbHVlLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpOyAvL3dlIGp1c3Qgb2ZmbG9hZCBhbGwgdGhlIHdvcmsgdG8gdGhlIHJlZ3VsYXIgQ1NTUGx1Z2luIGFuZCB0aGVuIGNvcHkgdGhlIGNzc1RleHQgYmFjayBvdmVyIHRvIHRoZSBydWxlIGluIHRoZSByZW5kZXIoKSBtZXRob2QuIFRoaXMgYWxsb3dzIHVzIHRvIGhhdmUgYWxsIG9mIHRoZSB1cGRhdGVzIHRvIENTU1BsdWdpbiBhdXRvbWF0aWNhbGx5IGZsb3cgdGhyb3VnaCB0byBDU1NSdWxlUGx1Z2luIGluc3RlYWQgb2YgaGF2aW5nIHRvIG1haW50YWluIGJvdGhcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocmF0aW8sIGRhdGEpIHtcbiAgICB2YXIgcHQgPSBkYXRhLl9wdCxcbiAgICAgICAgc3R5bGUgPSBkYXRhLnN0eWxlLFxuICAgICAgICBzcyA9IGRhdGEuc3MsXG4gICAgICAgIGk7XG5cbiAgICB3aGlsZSAocHQpIHtcbiAgICAgIHB0LnIocmF0aW8sIHB0LmQpO1xuICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICB9XG5cbiAgICBpID0gc3R5bGUubGVuZ3RoO1xuXG4gICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICBzc1tzdHlsZVtpXV0gPSBzdHlsZVtzdHlsZVtpXV07XG4gICAgfVxuICB9LFxuICBnZXRSdWxlOiBmdW5jdGlvbiBnZXRSdWxlKHNlbGVjdG9yKSB7XG4gICAgX2NoZWNrUmVnaXN0ZXIoKTtcblxuICAgIHZhciBydWxlUHJvcCA9IF9kb2MuYWxsID8gXCJydWxlc1wiIDogXCJjc3NSdWxlc1wiLFxuICAgICAgICBzdHlsZVNoZWV0cyA9IF9kb2Muc3R5bGVTaGVldHMsXG4gICAgICAgIGkgPSBzdHlsZVNoZWV0cy5sZW5ndGgsXG4gICAgICAgIHBzZXVkbyA9IHNlbGVjdG9yLmNoYXJBdCgwKSA9PT0gXCI6XCIsXG4gICAgICAgIGosXG4gICAgICAgIGN1clNTLFxuICAgICAgICBjcyxcbiAgICAgICAgYTtcbiAgICBzZWxlY3RvciA9IChwc2V1ZG8gPyBcIlwiIDogXCIsXCIpICsgc2VsZWN0b3Iuc3BsaXQoXCI6OlwiKS5qb2luKFwiOlwiKS50b0xvd2VyQ2FzZSgpICsgXCIsXCI7IC8vbm90ZTogb2xkIHZlcnNpb25zIG9mIElFIHJlcG9ydCB0YWcgbmFtZSBzZWxlY3RvcnMgYXMgdXBwZXIgY2FzZSwgc28gd2UganVzdCBjaGFuZ2UgZXZlcnl0aGluZyB0byBsb3dlcmNhc2UuXG5cbiAgICBpZiAocHNldWRvKSB7XG4gICAgICBhID0gW107XG4gICAgfVxuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgLy9GaXJlZm94IG1heSB0aHJvdyBpbnNlY3VyZSBvcGVyYXRpb24gZXJyb3JzIHdoZW4gY3NzIGlzIGxvYWRlZCBmcm9tIG90aGVyIGRvbWFpbnMsIHNvIHRyeS9jYXRjaC5cbiAgICAgIHRyeSB7XG4gICAgICAgIGN1clNTID0gc3R5bGVTaGVldHNbaV1bcnVsZVByb3BdO1xuXG4gICAgICAgIGlmICghY3VyU1MpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGogPSBjdXJTUy5sZW5ndGg7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICgtLWogPiAtMSkge1xuICAgICAgICBjcyA9IGN1clNTW2pdO1xuXG4gICAgICAgIGlmIChjcy5zZWxlY3RvclRleHQgJiYgKFwiLFwiICsgY3Muc2VsZWN0b3JUZXh0LnNwbGl0KFwiOjpcIikuam9pbihcIjpcIikudG9Mb3dlckNhc2UoKSArIFwiLFwiKS5pbmRleE9mKHNlbGVjdG9yKSAhPT0gLTEpIHtcbiAgICAgICAgICAvL25vdGU6IElFIGFkZHMgYW4gZXh0cmEgXCI6XCIgdG8gcHNldWRvIHNlbGVjdG9ycywgc28gLm15Q2xhc3M6YWZ0ZXIgYmVjb21lcyAubXlDbGFzczo6YWZ0ZXIsIHNvIHdlIG5lZWQgdG8gc3RyaXAgdGhlIGV4dHJhIG9uZSBvdXQuXG4gICAgICAgICAgaWYgKHBzZXVkbykge1xuICAgICAgICAgICAgYS5wdXNoKGNzLnN0eWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNzLnN0eWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9LFxuICByZWdpc3RlcjogX2luaXRDb3JlXG59O1xuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1J1bGVQbHVnaW4pO1xuZXhwb3J0IHsgQ1NTUnVsZVBsdWdpbiBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbImdzYXAiLCJfY29yZUluaXR0ZWQiLCJfd2luIiwiX2RvYyIsIkNTU1BsdWdpbiIsIl93aW5kb3dFeGlzdHMiLCJ3aW5kb3ciLCJfZ2V0R1NBUCIsInJlZ2lzdGVyUGx1Z2luIiwiX2NoZWNrUmVnaXN0ZXIiLCJfaW5pdENvcmUiLCJjb25zb2xlIiwid2FybiIsImNvcmUiLCJkb2N1bWVudCIsInBsdWdpbnMiLCJjc3MiLCJDU1NSdWxlUGx1Z2luIiwidmVyc2lvbiIsIm5hbWUiLCJpbml0IiwidGFyZ2V0IiwidmFsdWUiLCJ0d2VlbiIsImluZGV4IiwidGFyZ2V0cyIsImNzc1RleHQiLCJkaXYiLCJfZ3NQcm94eSIsImNyZWF0ZUVsZW1lbnQiLCJzcyIsInN0eWxlIiwicHJvdG90eXBlIiwiY2FsbCIsInJlbmRlciIsInJhdGlvIiwiZGF0YSIsInB0IiwiX3B0IiwiaSIsInIiLCJkIiwiX25leHQiLCJsZW5ndGgiLCJnZXRSdWxlIiwic2VsZWN0b3IiLCJydWxlUHJvcCIsImFsbCIsInN0eWxlU2hlZXRzIiwicHNldWRvIiwiY2hhckF0IiwiaiIsImN1clNTIiwiY3MiLCJhIiwic3BsaXQiLCJqb2luIiwidG9Mb3dlckNhc2UiLCJlIiwic2VsZWN0b3JUZXh0IiwiaW5kZXhPZiIsInB1c2giLCJyZWdpc3RlciIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSRulePlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CustomEase.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CustomEase.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomEase: function() { return /* binding */ CustomEase; },\n/* harmony export */   \"default\": function() { return /* binding */ CustomEase; }\n/* harmony export */ });\n/* harmony import */ var _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/paths.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/paths.js\");\n/*!\n * CustomEase 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ \nvar gsap, _coreInitted, _getGSAP = function _getGSAP() {\n    return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _initCore = function _initCore() {\n    gsap = _getGSAP();\n    if (gsap) {\n        gsap.registerEase(\"_CE\", CustomEase.create);\n        _coreInitted = 1;\n    } else {\n        console.warn(\"Please gsap.registerPlugin(CustomEase)\");\n    }\n}, _bigNum = 1e20, _round = function _round(value) {\n    return ~~(value * 1000 + (value < 0 ? -.5 : .5)) / 1000;\n}, _bonusValidated = 1, //<name>CustomEase</name>\n_numExp = /[-+=.]*\\d+[.e\\-+]*\\d*[e\\-+]*\\d*/gi, //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\n_needsParsingExp = /[cLlsSaAhHvVtTqQ]/g, _findMinimum = function _findMinimum(values) {\n    var l = values.length, min = _bigNum, i;\n    for(i = 1; i < l; i += 6){\n        +values[i] < min && (min = +values[i]);\n    }\n    return min;\n}, //takes all the points and translates/scales them so that the x starts at 0 and ends at 1.\n_normalize = function _normalize(values, height, originY) {\n    if (!originY && originY !== 0) {\n        originY = Math.max(+values[values.length - 1], +values[1]);\n    }\n    var tx = +values[0] * -1, ty = -originY, l = values.length, sx = 1 / (+values[l - 2] + tx), sy = -height || (Math.abs(+values[l - 1] - +values[1]) < 0.01 * (+values[l - 2] - +values[0]) ? _findMinimum(values) + ty : +values[l - 1] + ty), i;\n    if (sy) {\n        //typically y ends at 1 (so that the end values are reached)\n        sy = 1 / sy;\n    } else {\n        //in case the ease returns to its beginning value, scale everything proportionally\n        sy = -sx;\n    }\n    for(i = 0; i < l; i += 2){\n        values[i] = (+values[i] + tx) * sx;\n        values[i + 1] = (+values[i + 1] + ty) * sy;\n    }\n}, //note that this function returns point objects like {x, y} rather than working with segments which are arrays with alternating x, y values as in the similar function in paths.js\n_bezierToPoints = function _bezierToPoints(x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {\n    var x12 = (x1 + x2) / 2, y12 = (y1 + y2) / 2, x23 = (x2 + x3) / 2, y23 = (y2 + y3) / 2, x34 = (x3 + x4) / 2, y34 = (y3 + y4) / 2, x123 = (x12 + x23) / 2, y123 = (y12 + y23) / 2, x234 = (x23 + x34) / 2, y234 = (y23 + y34) / 2, x1234 = (x123 + x234) / 2, y1234 = (y123 + y234) / 2, dx = x4 - x1, dy = y4 - y1, d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx), d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx), length;\n    if (!points) {\n        points = [\n            {\n                x: x1,\n                y: y1\n            },\n            {\n                x: x4,\n                y: y4\n            }\n        ];\n        index = 1;\n    }\n    points.splice(index || points.length - 1, 0, {\n        x: x1234,\n        y: y1234\n    });\n    if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {\n        length = points.length;\n        _bezierToPoints(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);\n        _bezierToPoints(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 1 + (points.length - length));\n    }\n    return points;\n};\nvar CustomEase = /*#__PURE__*/ function() {\n    function CustomEase(id, data, config) {\n        _coreInitted || _initCore();\n        this.id = id;\n        _bonusValidated && this.setData(data, config);\n    }\n    var _proto = CustomEase.prototype;\n    _proto.setData = function setData(data, config) {\n        config = config || {};\n        data = data || \"0,0,1,1\";\n        var values = data.match(_numExp), closest = 1, points = [], lookup = [], precision = config.precision || 1, fast = precision <= 1, l, a1, a2, i, inc, j, point, prevPoint, p;\n        this.data = data;\n        if (_needsParsingExp.test(data) || ~data.indexOf(\"M\") && data.indexOf(\"C\") < 0) {\n            values = (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.stringToRawPath)(data)[0];\n        }\n        l = values.length;\n        if (l === 4) {\n            values.unshift(0, 0);\n            values.push(1, 1);\n            l = 8;\n        } else if ((l - 2) % 6) {\n            throw \"Invalid CustomEase\";\n        }\n        if (+values[0] !== 0 || +values[l - 2] !== 1) {\n            _normalize(values, config.height, config.originY);\n        }\n        this.segment = values;\n        for(i = 2; i < l; i += 6){\n            a1 = {\n                x: +values[i - 2],\n                y: +values[i - 1]\n            };\n            a2 = {\n                x: +values[i + 4],\n                y: +values[i + 5]\n            };\n            points.push(a1, a2);\n            _bezierToPoints(a1.x, a1.y, +values[i], +values[i + 1], +values[i + 2], +values[i + 3], a2.x, a2.y, 1 / (precision * 200000), points, points.length - 1);\n        }\n        l = points.length;\n        for(i = 0; i < l; i++){\n            point = points[i];\n            prevPoint = points[i - 1] || point;\n            if ((point.x > prevPoint.x || prevPoint.y !== point.y && prevPoint.x === point.x || point === prevPoint) && point.x <= 1) {\n                //if a point goes BACKWARD in time or is a duplicate, just drop it. Also it shouldn't go past 1 on the x axis, as could happen in a string like \"M0,0 C0,0 0.12,0.68 0.18,0.788 0.195,0.845 0.308,1 0.32,1 0.403,1.005 0.398,1 0.5,1 0.602,1 0.816,1.005 0.9,1 0.91,1 0.948,0.69 0.962,0.615 1.003,0.376 1,0 1,0\".\n                prevPoint.cx = point.x - prevPoint.x; //change in x between this point and the next point (performance optimization)\n                prevPoint.cy = point.y - prevPoint.y;\n                prevPoint.n = point;\n                prevPoint.nx = point.x; //next point's x value (performance optimization, making lookups faster in getRatio()). Remember, the lookup will always land on a spot where it's either this point or the very next one (never beyond that)\n                if (fast && i > 1 && Math.abs(prevPoint.cy / prevPoint.cx - points[i - 2].cy / points[i - 2].cx) > 2) {\n                    //if there's a sudden change in direction, prioritize accuracy over speed. Like a bounce ease - you don't want to risk the sampling chunks landing on each side of the bounce anchor and having it clipped off.\n                    fast = 0;\n                }\n                if (prevPoint.cx < closest) {\n                    if (!prevPoint.cx) {\n                        prevPoint.cx = 0.001; //avoids math problems in getRatio() (dividing by zero)\n                        if (i === l - 1) {\n                            //in case the final segment goes vertical RIGHT at the end, make sure we end at the end.\n                            prevPoint.x -= 0.001;\n                            closest = Math.min(closest, 0.001);\n                            fast = 0;\n                        }\n                    } else {\n                        closest = prevPoint.cx;\n                    }\n                }\n            } else {\n                points.splice(i--, 1);\n                l--;\n            }\n        }\n        l = 1 / closest + 1 | 0;\n        inc = 1 / l;\n        j = 0;\n        point = points[0];\n        if (fast) {\n            for(i = 0; i < l; i++){\n                //for fastest lookups, we just sample along the path at equal x (time) distance. Uses more memory and is slightly less accurate for anchors that don't land on the sampling points, but for the vast majority of eases it's excellent (and fast).\n                p = i * inc;\n                if (point.nx < p) {\n                    point = points[++j];\n                }\n                a1 = point.y + (p - point.x) / point.cx * point.cy;\n                lookup[i] = {\n                    x: p,\n                    cx: inc,\n                    y: a1,\n                    cy: 0,\n                    nx: 9\n                };\n                if (i) {\n                    lookup[i - 1].cy = a1 - lookup[i - 1].y;\n                }\n            }\n            lookup[l - 1].cy = points[points.length - 1].y - a1;\n        } else {\n            //this option is more accurate, ensuring that EVERY anchor is hit perfectly. Clipping across a bounce, for example, would never happen.\n            for(i = 0; i < l; i++){\n                //build a lookup table based on the smallest distance so that we can instantly find the appropriate point (well, it'll either be that point or the very next one). We'll look up based on the linear progress. So it's it's 0.5 and the lookup table has 100 elements, it'd be like lookup[Math.floor(0.5 * 100)]\n                if (point.nx < i * inc) {\n                    point = points[++j];\n                }\n                lookup[i] = point;\n            }\n            if (j < points.length - 1) {\n                lookup[i - 1] = points[points.length - 2];\n            }\n        } //this._calcEnd = (points[points.length-1].y !== 1 || points[0].y !== 0); //ensures that we don't run into floating point errors. As long as we're starting at 0 and ending at 1, tell GSAP to skip the final calculation and use 0/1 as the factor.\n        this.ease = function(p) {\n            var point = lookup[p * l | 0] || lookup[l - 1];\n            if (point.nx < p) {\n                point = point.n;\n            }\n            return point.y + (p - point.x) / point.cx * point.cy;\n        };\n        this.ease.custom = this;\n        this.id && gsap && gsap.registerEase(this.id, this.ease);\n        return this;\n    };\n    _proto.getSVGData = function getSVGData(config) {\n        return CustomEase.getSVGData(this, config);\n    };\n    CustomEase.create = function create(id, data, config) {\n        return new CustomEase(id, data, config).ease;\n    };\n    CustomEase.register = function register(core) {\n        gsap = core;\n        _initCore();\n    };\n    CustomEase.get = function get(id) {\n        return gsap.parseEase(id);\n    };\n    CustomEase.getSVGData = function getSVGData(ease, config) {\n        config = config || {};\n        var width = config.width || 100, height = config.height || 100, x = config.x || 0, y = (config.y || 0) + height, e = gsap.utils.toArray(config.path)[0], a, slope, i, inc, tx, ty, precision, threshold, prevX, prevY;\n        if (config.invert) {\n            height = -height;\n            y = 0;\n        }\n        if (typeof ease === \"string\") {\n            ease = gsap.parseEase(ease);\n        }\n        if (ease.custom) {\n            ease = ease.custom;\n        }\n        if (ease instanceof CustomEase) {\n            a = (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.rawPathToString)((0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)([\n                ease.segment\n            ], width, 0, 0, -height, x, y));\n        } else {\n            a = [\n                x,\n                y\n            ];\n            precision = Math.max(5, (config.precision || 1) * 200);\n            inc = 1 / precision;\n            precision += 2;\n            threshold = 5 / precision;\n            prevX = _round(x + inc * width);\n            prevY = _round(y + ease(inc) * -height);\n            slope = (prevY - y) / (prevX - x);\n            for(i = 2; i < precision; i++){\n                tx = _round(x + i * inc * width);\n                ty = _round(y + ease(i * inc) * -height);\n                if (Math.abs((ty - prevY) / (tx - prevX) - slope) > threshold || i === precision - 1) {\n                    //only add points when the slope changes beyond the threshold\n                    a.push(prevX, prevY);\n                    slope = (ty - prevY) / (tx - prevX);\n                }\n                prevX = tx;\n                prevY = ty;\n            }\n            a = \"M\" + a.join(\",\");\n        }\n        e && e.setAttribute(\"d\", a);\n        return a;\n    };\n    return CustomEase;\n}();\n_getGSAP() && gsap.registerPlugin(CustomEase);\nCustomEase.version = \"3.12.5\";\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9DdXN0b21FYXNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCLEdBQ29FO0FBRXRGLElBQUlHLE1BQ0FDLGNBQ0FDLFdBQVcsU0FBU0E7SUFDdEIsT0FBT0YsUUFBUSxPQUFPRyxXQUFXLGVBQWdCSCxDQUFBQSxPQUFPRyxPQUFPSCxJQUFJLEtBQUtBLEtBQUtJLGNBQWMsSUFBSUo7QUFDakcsR0FDSUssWUFBWSxTQUFTQTtJQUN2QkwsT0FBT0U7SUFFUCxJQUFJRixNQUFNO1FBQ1JBLEtBQUtNLFlBQVksQ0FBQyxPQUFPQyxXQUFXQyxNQUFNO1FBQzFDUCxlQUFlO0lBQ2pCLE9BQU87UUFDTFEsUUFBUUMsSUFBSSxDQUFDO0lBQ2Y7QUFDRixHQUNJQyxVQUFVLE1BQ1ZDLFNBQVMsU0FBU0EsT0FBT0MsS0FBSztJQUNoQyxPQUFPLENBQUMsQ0FBRUEsQ0FBQUEsUUFBUSxPQUFRQSxDQUFBQSxRQUFRLElBQUksQ0FBQyxLQUFLLEVBQUMsQ0FBQyxJQUFLO0FBQ3JELEdBQ0lDLGtCQUFrQixHQUNsQix5QkFBeUI7QUFDN0JDLFVBQVUscUNBQ04sMEhBQTBIO0FBQzlIQyxtQkFBbUIsc0JBQ2ZDLGVBQWUsU0FBU0EsYUFBYUMsTUFBTTtJQUM3QyxJQUFJQyxJQUFJRCxPQUFPRSxNQUFNLEVBQ2pCQyxNQUFNVixTQUNOVztJQUVKLElBQUtBLElBQUksR0FBR0EsSUFBSUgsR0FBR0csS0FBSyxFQUFHO1FBQ3pCLENBQUNKLE1BQU0sQ0FBQ0ksRUFBRSxHQUFHRCxPQUFRQSxDQUFBQSxNQUFNLENBQUNILE1BQU0sQ0FBQ0ksRUFBRTtJQUN2QztJQUVBLE9BQU9EO0FBQ1QsR0FDSSwwRkFBMEY7QUFDOUZFLGFBQWEsU0FBU0EsV0FBV0wsTUFBTSxFQUFFTSxNQUFNLEVBQUVDLE9BQU87SUFDdEQsSUFBSSxDQUFDQSxXQUFXQSxZQUFZLEdBQUc7UUFDN0JBLFVBQVVDLEtBQUtDLEdBQUcsQ0FBQyxDQUFDVCxNQUFNLENBQUNBLE9BQU9FLE1BQU0sR0FBRyxFQUFFLEVBQUUsQ0FBQ0YsTUFBTSxDQUFDLEVBQUU7SUFDM0Q7SUFFQSxJQUFJVSxLQUFLLENBQUNWLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUNuQlcsS0FBSyxDQUFDSixTQUNOTixJQUFJRCxPQUFPRSxNQUFNLEVBQ2pCVSxLQUFLLElBQUssRUFBQ1osTUFBTSxDQUFDQyxJQUFJLEVBQUUsR0FBR1MsRUFBQyxHQUM1QkcsS0FBSyxDQUFDUCxVQUFXRSxDQUFBQSxLQUFLTSxHQUFHLENBQUMsQ0FBQ2QsTUFBTSxDQUFDQyxJQUFJLEVBQUUsR0FBRyxDQUFDRCxNQUFNLENBQUMsRUFBRSxJQUFJLE9BQVEsRUFBQ0EsTUFBTSxDQUFDQyxJQUFJLEVBQUUsR0FBRyxDQUFDRCxNQUFNLENBQUMsRUFBRSxJQUFJRCxhQUFhQyxVQUFVVyxLQUFLLENBQUNYLE1BQU0sQ0FBQ0MsSUFBSSxFQUFFLEdBQUdVLEVBQUMsR0FDOUlQO0lBRUosSUFBSVMsSUFBSTtRQUNOLDREQUE0RDtRQUM1REEsS0FBSyxJQUFJQTtJQUNYLE9BQU87UUFDTCxrRkFBa0Y7UUFDbEZBLEtBQUssQ0FBQ0Q7SUFDUjtJQUVBLElBQUtSLElBQUksR0FBR0EsSUFBSUgsR0FBR0csS0FBSyxFQUFHO1FBQ3pCSixNQUFNLENBQUNJLEVBQUUsR0FBRyxDQUFDLENBQUNKLE1BQU0sQ0FBQ0ksRUFBRSxHQUFHTSxFQUFDLElBQUtFO1FBQ2hDWixNQUFNLENBQUNJLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQ0osTUFBTSxDQUFDSSxJQUFJLEVBQUUsR0FBR08sRUFBQyxJQUFLRTtJQUMxQztBQUNGLEdBQ0ksa0xBQWtMO0FBQ3RMRSxrQkFBa0IsU0FBU0EsZ0JBQWdCQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsU0FBUyxFQUFFQyxNQUFNLEVBQUVDLEtBQUs7SUFDakcsSUFBSUMsTUFBTSxDQUFDWCxLQUFLRSxFQUFDLElBQUssR0FDbEJVLE1BQU0sQ0FBQ1gsS0FBS0UsRUFBQyxJQUFLLEdBQ2xCVSxNQUFNLENBQUNYLEtBQUtFLEVBQUMsSUFBSyxHQUNsQlUsTUFBTSxDQUFDWCxLQUFLRSxFQUFDLElBQUssR0FDbEJVLE1BQU0sQ0FBQ1gsS0FBS0UsRUFBQyxJQUFLLEdBQ2xCVSxNQUFNLENBQUNYLEtBQUtFLEVBQUMsSUFBSyxHQUNsQlUsT0FBTyxDQUFDTixNQUFNRSxHQUFFLElBQUssR0FDckJLLE9BQU8sQ0FBQ04sTUFBTUUsR0FBRSxJQUFLLEdBQ3JCSyxPQUFPLENBQUNOLE1BQU1FLEdBQUUsSUFBSyxHQUNyQkssT0FBTyxDQUFDTixNQUFNRSxHQUFFLElBQUssR0FDckJLLFFBQVEsQ0FBQ0osT0FBT0UsSUFBRyxJQUFLLEdBQ3hCRyxRQUFRLENBQUNKLE9BQU9FLElBQUcsSUFBSyxHQUN4QkcsS0FBS2pCLEtBQUtOLElBQ1Z3QixLQUFLakIsS0FBS04sSUFDVndCLEtBQUtqQyxLQUFLTSxHQUFHLENBQUMsQ0FBQ0ksS0FBS0ksRUFBQyxJQUFLa0IsS0FBSyxDQUFDckIsS0FBS0ksRUFBQyxJQUFLZ0IsS0FDM0NHLEtBQUtsQyxLQUFLTSxHQUFHLENBQUMsQ0FBQ00sS0FBS0UsRUFBQyxJQUFLa0IsS0FBSyxDQUFDbkIsS0FBS0UsRUFBQyxJQUFLZ0IsS0FDM0NyQztJQUVKLElBQUksQ0FBQ3VCLFFBQVE7UUFDWEEsU0FBUztZQUFDO2dCQUNSa0IsR0FBRzNCO2dCQUNINEIsR0FBRzNCO1lBQ0w7WUFBRztnQkFDRDBCLEdBQUdyQjtnQkFDSHNCLEdBQUdyQjtZQUNMO1NBQUU7UUFDRkcsUUFBUTtJQUNWO0lBRUFELE9BQU9vQixNQUFNLENBQUNuQixTQUFTRCxPQUFPdkIsTUFBTSxHQUFHLEdBQUcsR0FBRztRQUMzQ3lDLEdBQUdOO1FBQ0hPLEdBQUdOO0lBQ0w7SUFFQSxJQUFJLENBQUNHLEtBQUtDLEVBQUMsSUFBTUQsQ0FBQUEsS0FBS0MsRUFBQyxJQUFLbEIsWUFBYWUsQ0FBQUEsS0FBS0EsS0FBS0MsS0FBS0EsRUFBQyxHQUFJO1FBQzNEdEMsU0FBU3VCLE9BQU92QixNQUFNO1FBRXRCYSxnQkFBZ0JDLElBQUlDLElBQUlVLEtBQUtDLEtBQUtLLE1BQU1DLE1BQU1HLE9BQU9DLE9BQU9kLFdBQVdDLFFBQVFDO1FBRS9FWCxnQkFBZ0JzQixPQUFPQyxPQUFPSCxNQUFNQyxNQUFNTCxLQUFLQyxLQUFLVixJQUFJQyxJQUFJQyxXQUFXQyxRQUFRQyxRQUFRLElBQUtELENBQUFBLE9BQU92QixNQUFNLEdBQUdBLE1BQUs7SUFDbkg7SUFFQSxPQUFPdUI7QUFDVDtBQUVPLElBQUlwQyxhQUFhLFdBQVcsR0FBRTtJQUNuQyxTQUFTQSxXQUFXeUQsRUFBRSxFQUFFQyxJQUFJLEVBQUVDLE1BQU07UUFDbENqRSxnQkFBZ0JJO1FBQ2hCLElBQUksQ0FBQzJELEVBQUUsR0FBR0E7UUFDVmxELG1CQUFtQixJQUFJLENBQUNxRCxPQUFPLENBQUNGLE1BQU1DO0lBQ3hDO0lBRUEsSUFBSUUsU0FBUzdELFdBQVc4RCxTQUFTO0lBRWpDRCxPQUFPRCxPQUFPLEdBQUcsU0FBU0EsUUFBUUYsSUFBSSxFQUFFQyxNQUFNO1FBQzVDQSxTQUFTQSxVQUFVLENBQUM7UUFDcEJELE9BQU9BLFFBQVE7UUFDZixJQUFJL0MsU0FBUytDLEtBQUtLLEtBQUssQ0FBQ3ZELFVBQ3BCd0QsVUFBVSxHQUNWNUIsU0FBUyxFQUFFLEVBQ1g2QixTQUFTLEVBQUUsRUFDWEMsWUFBWVAsT0FBT08sU0FBUyxJQUFJLEdBQ2hDQyxPQUFPRCxhQUFhLEdBQ3BCdEQsR0FDQXdELElBQ0FDLElBQ0F0RCxHQUNBdUQsS0FDQUMsR0FDQUMsT0FDQUMsV0FDQUM7UUFDSixJQUFJLENBQUNoQixJQUFJLEdBQUdBO1FBRVosSUFBSWpELGlCQUFpQmtFLElBQUksQ0FBQ2pCLFNBQVMsQ0FBQ0EsS0FBS2tCLE9BQU8sQ0FBQyxRQUFRbEIsS0FBS2tCLE9BQU8sQ0FBQyxPQUFPLEdBQUc7WUFDOUVqRSxTQUFTckIsZ0VBQWVBLENBQUNvRSxLQUFLLENBQUMsRUFBRTtRQUNuQztRQUVBOUMsSUFBSUQsT0FBT0UsTUFBTTtRQUVqQixJQUFJRCxNQUFNLEdBQUc7WUFDWEQsT0FBT2tFLE9BQU8sQ0FBQyxHQUFHO1lBQ2xCbEUsT0FBT21FLElBQUksQ0FBQyxHQUFHO1lBQ2ZsRSxJQUFJO1FBQ04sT0FBTyxJQUFJLENBQUNBLElBQUksS0FBSyxHQUFHO1lBQ3RCLE1BQU07UUFDUjtRQUVBLElBQUksQ0FBQ0QsTUFBTSxDQUFDLEVBQUUsS0FBSyxLQUFLLENBQUNBLE1BQU0sQ0FBQ0MsSUFBSSxFQUFFLEtBQUssR0FBRztZQUM1Q0ksV0FBV0wsUUFBUWdELE9BQU8xQyxNQUFNLEVBQUUwQyxPQUFPekMsT0FBTztRQUNsRDtRQUVBLElBQUksQ0FBQzZELE9BQU8sR0FBR3BFO1FBRWYsSUFBS0ksSUFBSSxHQUFHQSxJQUFJSCxHQUFHRyxLQUFLLEVBQUc7WUFDekJxRCxLQUFLO2dCQUNIZCxHQUFHLENBQUMzQyxNQUFNLENBQUNJLElBQUksRUFBRTtnQkFDakJ3QyxHQUFHLENBQUM1QyxNQUFNLENBQUNJLElBQUksRUFBRTtZQUNuQjtZQUNBc0QsS0FBSztnQkFDSGYsR0FBRyxDQUFDM0MsTUFBTSxDQUFDSSxJQUFJLEVBQUU7Z0JBQ2pCd0MsR0FBRyxDQUFDNUMsTUFBTSxDQUFDSSxJQUFJLEVBQUU7WUFDbkI7WUFDQXFCLE9BQU8wQyxJQUFJLENBQUNWLElBQUlDO1lBRWhCM0MsZ0JBQWdCMEMsR0FBR2QsQ0FBQyxFQUFFYyxHQUFHYixDQUFDLEVBQUUsQ0FBQzVDLE1BQU0sQ0FBQ0ksRUFBRSxFQUFFLENBQUNKLE1BQU0sQ0FBQ0ksSUFBSSxFQUFFLEVBQUUsQ0FBQ0osTUFBTSxDQUFDSSxJQUFJLEVBQUUsRUFBRSxDQUFDSixNQUFNLENBQUNJLElBQUksRUFBRSxFQUFFc0QsR0FBR2YsQ0FBQyxFQUFFZSxHQUFHZCxDQUFDLEVBQUUsSUFBS1csQ0FBQUEsWUFBWSxNQUFLLEdBQUk5QixRQUFRQSxPQUFPdkIsTUFBTSxHQUFHO1FBQ3hKO1FBRUFELElBQUl3QixPQUFPdkIsTUFBTTtRQUVqQixJQUFLRSxJQUFJLEdBQUdBLElBQUlILEdBQUdHLElBQUs7WUFDdEJ5RCxRQUFRcEMsTUFBTSxDQUFDckIsRUFBRTtZQUNqQjBELFlBQVlyQyxNQUFNLENBQUNyQixJQUFJLEVBQUUsSUFBSXlEO1lBRTdCLElBQUksQ0FBQ0EsTUFBTWxCLENBQUMsR0FBR21CLFVBQVVuQixDQUFDLElBQUltQixVQUFVbEIsQ0FBQyxLQUFLaUIsTUFBTWpCLENBQUMsSUFBSWtCLFVBQVVuQixDQUFDLEtBQUtrQixNQUFNbEIsQ0FBQyxJQUFJa0IsVUFBVUMsU0FBUSxLQUFNRCxNQUFNbEIsQ0FBQyxJQUFJLEdBQUc7Z0JBQ3hILGtUQUFrVDtnQkFDbFRtQixVQUFVTyxFQUFFLEdBQUdSLE1BQU1sQixDQUFDLEdBQUdtQixVQUFVbkIsQ0FBQyxFQUFFLDhFQUE4RTtnQkFFcEhtQixVQUFVUSxFQUFFLEdBQUdULE1BQU1qQixDQUFDLEdBQUdrQixVQUFVbEIsQ0FBQztnQkFDcENrQixVQUFVUyxDQUFDLEdBQUdWO2dCQUNkQyxVQUFVVSxFQUFFLEdBQUdYLE1BQU1sQixDQUFDLEVBQUUsNk1BQTZNO2dCQUVyTyxJQUFJYSxRQUFRcEQsSUFBSSxLQUFLSSxLQUFLTSxHQUFHLENBQUNnRCxVQUFVUSxFQUFFLEdBQUdSLFVBQVVPLEVBQUUsR0FBRzVDLE1BQU0sQ0FBQ3JCLElBQUksRUFBRSxDQUFDa0UsRUFBRSxHQUFHN0MsTUFBTSxDQUFDckIsSUFBSSxFQUFFLENBQUNpRSxFQUFFLElBQUksR0FBRztvQkFDcEcsK01BQStNO29CQUMvTWIsT0FBTztnQkFDVDtnQkFFQSxJQUFJTSxVQUFVTyxFQUFFLEdBQUdoQixTQUFTO29CQUMxQixJQUFJLENBQUNTLFVBQVVPLEVBQUUsRUFBRTt3QkFDakJQLFVBQVVPLEVBQUUsR0FBRyxPQUFPLHVEQUF1RDt3QkFFN0UsSUFBSWpFLE1BQU1ILElBQUksR0FBRzs0QkFDZix3RkFBd0Y7NEJBQ3hGNkQsVUFBVW5CLENBQUMsSUFBSTs0QkFDZlUsVUFBVTdDLEtBQUtMLEdBQUcsQ0FBQ2tELFNBQVM7NEJBQzVCRyxPQUFPO3dCQUNUO29CQUNGLE9BQU87d0JBQ0xILFVBQVVTLFVBQVVPLEVBQUU7b0JBQ3hCO2dCQUNGO1lBQ0YsT0FBTztnQkFDTDVDLE9BQU9vQixNQUFNLENBQUN6QyxLQUFLO2dCQUNuQkg7WUFDRjtRQUNGO1FBRUFBLElBQUksSUFBSW9ELFVBQVUsSUFBSTtRQUN0Qk0sTUFBTSxJQUFJMUQ7UUFDVjJELElBQUk7UUFDSkMsUUFBUXBDLE1BQU0sQ0FBQyxFQUFFO1FBRWpCLElBQUkrQixNQUFNO1lBQ1IsSUFBS3BELElBQUksR0FBR0EsSUFBSUgsR0FBR0csSUFBSztnQkFDdEIsaVBBQWlQO2dCQUNqUDJELElBQUkzRCxJQUFJdUQ7Z0JBRVIsSUFBSUUsTUFBTVcsRUFBRSxHQUFHVCxHQUFHO29CQUNoQkYsUUFBUXBDLE1BQU0sQ0FBQyxFQUFFbUMsRUFBRTtnQkFDckI7Z0JBRUFILEtBQUtJLE1BQU1qQixDQUFDLEdBQUcsQ0FBQ21CLElBQUlGLE1BQU1sQixDQUFDLElBQUlrQixNQUFNUSxFQUFFLEdBQUdSLE1BQU1TLEVBQUU7Z0JBQ2xEaEIsTUFBTSxDQUFDbEQsRUFBRSxHQUFHO29CQUNWdUMsR0FBR29CO29CQUNITSxJQUFJVjtvQkFDSmYsR0FBR2E7b0JBQ0hhLElBQUk7b0JBQ0pFLElBQUk7Z0JBQ047Z0JBRUEsSUFBSXBFLEdBQUc7b0JBQ0xrRCxNQUFNLENBQUNsRCxJQUFJLEVBQUUsQ0FBQ2tFLEVBQUUsR0FBR2IsS0FBS0gsTUFBTSxDQUFDbEQsSUFBSSxFQUFFLENBQUN3QyxDQUFDO2dCQUN6QztZQUNGO1lBRUFVLE1BQU0sQ0FBQ3JELElBQUksRUFBRSxDQUFDcUUsRUFBRSxHQUFHN0MsTUFBTSxDQUFDQSxPQUFPdkIsTUFBTSxHQUFHLEVBQUUsQ0FBQzBDLENBQUMsR0FBR2E7UUFDbkQsT0FBTztZQUNMLHVJQUF1STtZQUN2SSxJQUFLckQsSUFBSSxHQUFHQSxJQUFJSCxHQUFHRyxJQUFLO2dCQUN0QixpVEFBaVQ7Z0JBQ2pULElBQUl5RCxNQUFNVyxFQUFFLEdBQUdwRSxJQUFJdUQsS0FBSztvQkFDdEJFLFFBQVFwQyxNQUFNLENBQUMsRUFBRW1DLEVBQUU7Z0JBQ3JCO2dCQUVBTixNQUFNLENBQUNsRCxFQUFFLEdBQUd5RDtZQUNkO1lBRUEsSUFBSUQsSUFBSW5DLE9BQU92QixNQUFNLEdBQUcsR0FBRztnQkFDekJvRCxNQUFNLENBQUNsRCxJQUFJLEVBQUUsR0FBR3FCLE1BQU0sQ0FBQ0EsT0FBT3ZCLE1BQU0sR0FBRyxFQUFFO1lBQzNDO1FBQ0YsRUFBRSxvUEFBb1A7UUFHdFAsSUFBSSxDQUFDdUUsSUFBSSxHQUFHLFNBQVVWLENBQUM7WUFDckIsSUFBSUYsUUFBUVAsTUFBTSxDQUFDUyxJQUFJOUQsSUFBSSxFQUFFLElBQUlxRCxNQUFNLENBQUNyRCxJQUFJLEVBQUU7WUFFOUMsSUFBSTRELE1BQU1XLEVBQUUsR0FBR1QsR0FBRztnQkFDaEJGLFFBQVFBLE1BQU1VLENBQUM7WUFDakI7WUFFQSxPQUFPVixNQUFNakIsQ0FBQyxHQUFHLENBQUNtQixJQUFJRixNQUFNbEIsQ0FBQyxJQUFJa0IsTUFBTVEsRUFBRSxHQUFHUixNQUFNUyxFQUFFO1FBQ3REO1FBRUEsSUFBSSxDQUFDRyxJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJO1FBQ3ZCLElBQUksQ0FBQzVCLEVBQUUsSUFBSWhFLFFBQVFBLEtBQUtNLFlBQVksQ0FBQyxJQUFJLENBQUMwRCxFQUFFLEVBQUUsSUFBSSxDQUFDMkIsSUFBSTtRQUN2RCxPQUFPLElBQUk7SUFDYjtJQUVBdkIsT0FBT3lCLFVBQVUsR0FBRyxTQUFTQSxXQUFXM0IsTUFBTTtRQUM1QyxPQUFPM0QsV0FBV3NGLFVBQVUsQ0FBQyxJQUFJLEVBQUUzQjtJQUNyQztJQUVBM0QsV0FBV0MsTUFBTSxHQUFHLFNBQVNBLE9BQU93RCxFQUFFLEVBQUVDLElBQUksRUFBRUMsTUFBTTtRQUNsRCxPQUFPLElBQUkzRCxXQUFXeUQsSUFBSUMsTUFBTUMsUUFBUXlCLElBQUk7SUFDOUM7SUFFQXBGLFdBQVd1RixRQUFRLEdBQUcsU0FBU0EsU0FBU0MsSUFBSTtRQUMxQy9GLE9BQU8rRjtRQUVQMUY7SUFDRjtJQUVBRSxXQUFXeUYsR0FBRyxHQUFHLFNBQVNBLElBQUloQyxFQUFFO1FBQzlCLE9BQU9oRSxLQUFLaUcsU0FBUyxDQUFDakM7SUFDeEI7SUFFQXpELFdBQVdzRixVQUFVLEdBQUcsU0FBU0EsV0FBV0YsSUFBSSxFQUFFekIsTUFBTTtRQUN0REEsU0FBU0EsVUFBVSxDQUFDO1FBQ3BCLElBQUlnQyxRQUFRaEMsT0FBT2dDLEtBQUssSUFBSSxLQUN4QjFFLFNBQVMwQyxPQUFPMUMsTUFBTSxJQUFJLEtBQzFCcUMsSUFBSUssT0FBT0wsQ0FBQyxJQUFJLEdBQ2hCQyxJQUFJLENBQUNJLE9BQU9KLENBQUMsSUFBSSxLQUFLdEMsUUFDdEIyRSxJQUFJbkcsS0FBS29HLEtBQUssQ0FBQ0MsT0FBTyxDQUFDbkMsT0FBT29DLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFDdENDLEdBQ0FDLE9BQ0FsRixHQUNBdUQsS0FDQWpELElBQ0FDLElBQ0E0QyxXQUNBL0IsV0FDQStELE9BQ0FDO1FBRUosSUFBSXhDLE9BQU95QyxNQUFNLEVBQUU7WUFDakJuRixTQUFTLENBQUNBO1lBQ1ZzQyxJQUFJO1FBQ047UUFFQSxJQUFJLE9BQU82QixTQUFTLFVBQVU7WUFDNUJBLE9BQU8zRixLQUFLaUcsU0FBUyxDQUFDTjtRQUN4QjtRQUVBLElBQUlBLEtBQUtDLE1BQU0sRUFBRTtZQUNmRCxPQUFPQSxLQUFLQyxNQUFNO1FBQ3BCO1FBRUEsSUFBSUQsZ0JBQWdCcEYsWUFBWTtZQUM5QmdHLElBQUl6RyxnRUFBZUEsQ0FBQ0MsaUVBQWdCQSxDQUFDO2dCQUFDNEYsS0FBS0wsT0FBTzthQUFDLEVBQUVZLE9BQU8sR0FBRyxHQUFHLENBQUMxRSxRQUFRcUMsR0FBR0M7UUFDaEYsT0FBTztZQUNMeUMsSUFBSTtnQkFBQzFDO2dCQUFHQzthQUFFO1lBQ1ZXLFlBQVkvQyxLQUFLQyxHQUFHLENBQUMsR0FBRyxDQUFDdUMsT0FBT08sU0FBUyxJQUFJLEtBQUs7WUFDbERJLE1BQU0sSUFBSUo7WUFDVkEsYUFBYTtZQUNiL0IsWUFBWSxJQUFJK0I7WUFDaEJnQyxRQUFRN0YsT0FBT2lELElBQUlnQixNQUFNcUI7WUFDekJRLFFBQVE5RixPQUFPa0QsSUFBSTZCLEtBQUtkLE9BQU8sQ0FBQ3JEO1lBQ2hDZ0YsUUFBUSxDQUFDRSxRQUFRNUMsQ0FBQUEsSUFBTTJDLENBQUFBLFFBQVE1QyxDQUFBQTtZQUUvQixJQUFLdkMsSUFBSSxHQUFHQSxJQUFJbUQsV0FBV25ELElBQUs7Z0JBQzlCTSxLQUFLaEIsT0FBT2lELElBQUl2QyxJQUFJdUQsTUFBTXFCO2dCQUMxQnJFLEtBQUtqQixPQUFPa0QsSUFBSTZCLEtBQUtyRSxJQUFJdUQsT0FBTyxDQUFDckQ7Z0JBRWpDLElBQUlFLEtBQUtNLEdBQUcsQ0FBQyxDQUFDSCxLQUFLNkUsS0FBSSxJQUFNOUUsQ0FBQUEsS0FBSzZFLEtBQUksSUFBS0QsU0FBUzlELGFBQWFwQixNQUFNbUQsWUFBWSxHQUFHO29CQUNwRiw2REFBNkQ7b0JBQzdEOEIsRUFBRWxCLElBQUksQ0FBQ29CLE9BQU9DO29CQUNkRixRQUFRLENBQUMzRSxLQUFLNkUsS0FBSSxJQUFNOUUsQ0FBQUEsS0FBSzZFLEtBQUk7Z0JBQ25DO2dCQUVBQSxRQUFRN0U7Z0JBQ1I4RSxRQUFRN0U7WUFDVjtZQUVBMEUsSUFBSSxNQUFNQSxFQUFFSyxJQUFJLENBQUM7UUFDbkI7UUFFQVQsS0FBS0EsRUFBRVUsWUFBWSxDQUFDLEtBQUtOO1FBQ3pCLE9BQU9BO0lBQ1Q7SUFFQSxPQUFPaEc7QUFDVCxJQUFJO0FBQ0pMLGNBQWNGLEtBQUtJLGNBQWMsQ0FBQ0c7QUFDbENBLFdBQVd1RyxPQUFPLEdBQUc7QUFDWSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vZ3NhcEAzLjEyLjUvbm9kZV9tb2R1bGVzL2dzYXAvQ3VzdG9tRWFzZS5qcz8xYzZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ3VzdG9tRWFzZSAzLjEyLjVcbiAqIGh0dHBzOi8vZ3NhcC5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDI0LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dzYXAuY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdTQVAgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgeyBzdHJpbmdUb1Jhd1BhdGgsIHJhd1BhdGhUb1N0cmluZywgdHJhbnNmb3JtUmF3UGF0aCB9IGZyb20gXCIuL3V0aWxzL3BhdGhzLmpzXCI7XG5cbnZhciBnc2FwLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKCkge1xuICBnc2FwID0gX2dldEdTQVAoKTtcblxuICBpZiAoZ3NhcCkge1xuICAgIGdzYXAucmVnaXN0ZXJFYXNlKFwiX0NFXCIsIEN1c3RvbUVhc2UuY3JlYXRlKTtcbiAgICBfY29yZUluaXR0ZWQgPSAxO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybihcIlBsZWFzZSBnc2FwLnJlZ2lzdGVyUGx1Z2luKEN1c3RvbUVhc2UpXCIpO1xuICB9XG59LFxuICAgIF9iaWdOdW0gPSAxZTIwLFxuICAgIF9yb3VuZCA9IGZ1bmN0aW9uIF9yb3VuZCh2YWx1ZSkge1xuICByZXR1cm4gfn4odmFsdWUgKiAxMDAwICsgKHZhbHVlIDwgMCA/IC0uNSA6IC41KSkgLyAxMDAwO1xufSxcbiAgICBfYm9udXNWYWxpZGF0ZWQgPSAxLFxuICAgIC8vPG5hbWU+Q3VzdG9tRWFzZTwvbmFtZT5cbl9udW1FeHAgPSAvWy0rPS5dKlxcZCtbLmVcXC0rXSpcXGQqW2VcXC0rXSpcXGQqL2dpLFxuICAgIC8vZmluZHMgYW55IG51bWJlcnMsIGluY2x1ZGluZyBvbmVzIHRoYXQgc3RhcnQgd2l0aCArPSBvciAtPSwgbmVnYXRpdmUgbnVtYmVycywgYW5kIG9uZXMgaW4gc2NpZW50aWZpYyBub3RhdGlvbiBsaWtlIDFlLTguXG5fbmVlZHNQYXJzaW5nRXhwID0gL1tjTGxzU2FBaEh2VnRUcVFdL2csXG4gICAgX2ZpbmRNaW5pbXVtID0gZnVuY3Rpb24gX2ZpbmRNaW5pbXVtKHZhbHVlcykge1xuICB2YXIgbCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBtaW4gPSBfYmlnTnVtLFxuICAgICAgaTtcblxuICBmb3IgKGkgPSAxOyBpIDwgbDsgaSArPSA2KSB7XG4gICAgK3ZhbHVlc1tpXSA8IG1pbiAmJiAobWluID0gK3ZhbHVlc1tpXSk7XG4gIH1cblxuICByZXR1cm4gbWluO1xufSxcbiAgICAvL3Rha2VzIGFsbCB0aGUgcG9pbnRzIGFuZCB0cmFuc2xhdGVzL3NjYWxlcyB0aGVtIHNvIHRoYXQgdGhlIHggc3RhcnRzIGF0IDAgYW5kIGVuZHMgYXQgMS5cbl9ub3JtYWxpemUgPSBmdW5jdGlvbiBfbm9ybWFsaXplKHZhbHVlcywgaGVpZ2h0LCBvcmlnaW5ZKSB7XG4gIGlmICghb3JpZ2luWSAmJiBvcmlnaW5ZICE9PSAwKSB7XG4gICAgb3JpZ2luWSA9IE1hdGgubWF4KCt2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdLCArdmFsdWVzWzFdKTtcbiAgfVxuXG4gIHZhciB0eCA9ICt2YWx1ZXNbMF0gKiAtMSxcbiAgICAgIHR5ID0gLW9yaWdpblksXG4gICAgICBsID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIHN4ID0gMSAvICgrdmFsdWVzW2wgLSAyXSArIHR4KSxcbiAgICAgIHN5ID0gLWhlaWdodCB8fCAoTWF0aC5hYnMoK3ZhbHVlc1tsIC0gMV0gLSArdmFsdWVzWzFdKSA8IDAuMDEgKiAoK3ZhbHVlc1tsIC0gMl0gLSArdmFsdWVzWzBdKSA/IF9maW5kTWluaW11bSh2YWx1ZXMpICsgdHkgOiArdmFsdWVzW2wgLSAxXSArIHR5KSxcbiAgICAgIGk7XG5cbiAgaWYgKHN5KSB7XG4gICAgLy90eXBpY2FsbHkgeSBlbmRzIGF0IDEgKHNvIHRoYXQgdGhlIGVuZCB2YWx1ZXMgYXJlIHJlYWNoZWQpXG4gICAgc3kgPSAxIC8gc3k7XG4gIH0gZWxzZSB7XG4gICAgLy9pbiBjYXNlIHRoZSBlYXNlIHJldHVybnMgdG8gaXRzIGJlZ2lubmluZyB2YWx1ZSwgc2NhbGUgZXZlcnl0aGluZyBwcm9wb3J0aW9uYWxseVxuICAgIHN5ID0gLXN4O1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHZhbHVlc1tpXSA9ICgrdmFsdWVzW2ldICsgdHgpICogc3g7XG4gICAgdmFsdWVzW2kgKyAxXSA9ICgrdmFsdWVzW2kgKyAxXSArIHR5KSAqIHN5O1xuICB9XG59LFxuICAgIC8vbm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBwb2ludCBvYmplY3RzIGxpa2Uge3gsIHl9IHJhdGhlciB0aGFuIHdvcmtpbmcgd2l0aCBzZWdtZW50cyB3aGljaCBhcmUgYXJyYXlzIHdpdGggYWx0ZXJuYXRpbmcgeCwgeSB2YWx1ZXMgYXMgaW4gdGhlIHNpbWlsYXIgZnVuY3Rpb24gaW4gcGF0aHMuanNcbl9iZXppZXJUb1BvaW50cyA9IGZ1bmN0aW9uIF9iZXppZXJUb1BvaW50cyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIHRocmVzaG9sZCwgcG9pbnRzLCBpbmRleCkge1xuICB2YXIgeDEyID0gKHgxICsgeDIpIC8gMixcbiAgICAgIHkxMiA9ICh5MSArIHkyKSAvIDIsXG4gICAgICB4MjMgPSAoeDIgKyB4MykgLyAyLFxuICAgICAgeTIzID0gKHkyICsgeTMpIC8gMixcbiAgICAgIHgzNCA9ICh4MyArIHg0KSAvIDIsXG4gICAgICB5MzQgPSAoeTMgKyB5NCkgLyAyLFxuICAgICAgeDEyMyA9ICh4MTIgKyB4MjMpIC8gMixcbiAgICAgIHkxMjMgPSAoeTEyICsgeTIzKSAvIDIsXG4gICAgICB4MjM0ID0gKHgyMyArIHgzNCkgLyAyLFxuICAgICAgeTIzNCA9ICh5MjMgKyB5MzQpIC8gMixcbiAgICAgIHgxMjM0ID0gKHgxMjMgKyB4MjM0KSAvIDIsXG4gICAgICB5MTIzNCA9ICh5MTIzICsgeTIzNCkgLyAyLFxuICAgICAgZHggPSB4NCAtIHgxLFxuICAgICAgZHkgPSB5NCAtIHkxLFxuICAgICAgZDIgPSBNYXRoLmFicygoeDIgLSB4NCkgKiBkeSAtICh5MiAtIHk0KSAqIGR4KSxcbiAgICAgIGQzID0gTWF0aC5hYnMoKHgzIC0geDQpICogZHkgLSAoeTMgLSB5NCkgKiBkeCksXG4gICAgICBsZW5ndGg7XG5cbiAgaWYgKCFwb2ludHMpIHtcbiAgICBwb2ludHMgPSBbe1xuICAgICAgeDogeDEsXG4gICAgICB5OiB5MVxuICAgIH0sIHtcbiAgICAgIHg6IHg0LFxuICAgICAgeTogeTRcbiAgICB9XTtcbiAgICBpbmRleCA9IDE7XG4gIH1cblxuICBwb2ludHMuc3BsaWNlKGluZGV4IHx8IHBvaW50cy5sZW5ndGggLSAxLCAwLCB7XG4gICAgeDogeDEyMzQsXG4gICAgeTogeTEyMzRcbiAgfSk7XG5cbiAgaWYgKChkMiArIGQzKSAqIChkMiArIGQzKSA+IHRocmVzaG9sZCAqIChkeCAqIGR4ICsgZHkgKiBkeSkpIHtcbiAgICBsZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgX2JlemllclRvUG9pbnRzKHgxLCB5MSwgeDEyLCB5MTIsIHgxMjMsIHkxMjMsIHgxMjM0LCB5MTIzNCwgdGhyZXNob2xkLCBwb2ludHMsIGluZGV4KTtcblxuICAgIF9iZXppZXJUb1BvaW50cyh4MTIzNCwgeTEyMzQsIHgyMzQsIHkyMzQsIHgzNCwgeTM0LCB4NCwgeTQsIHRocmVzaG9sZCwgcG9pbnRzLCBpbmRleCArIDEgKyAocG9pbnRzLmxlbmd0aCAtIGxlbmd0aCkpO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn07XG5cbmV4cG9ydCB2YXIgQ3VzdG9tRWFzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEN1c3RvbUVhc2UoaWQsIGRhdGEsIGNvbmZpZykge1xuICAgIF9jb3JlSW5pdHRlZCB8fCBfaW5pdENvcmUoKTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgX2JvbnVzVmFsaWRhdGVkICYmIHRoaXMuc2V0RGF0YShkYXRhLCBjb25maWcpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEN1c3RvbUVhc2UucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXREYXRhID0gZnVuY3Rpb24gc2V0RGF0YShkYXRhLCBjb25maWcpIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgZGF0YSA9IGRhdGEgfHwgXCIwLDAsMSwxXCI7XG4gICAgdmFyIHZhbHVlcyA9IGRhdGEubWF0Y2goX251bUV4cCksXG4gICAgICAgIGNsb3Nlc3QgPSAxLFxuICAgICAgICBwb2ludHMgPSBbXSxcbiAgICAgICAgbG9va3VwID0gW10sXG4gICAgICAgIHByZWNpc2lvbiA9IGNvbmZpZy5wcmVjaXNpb24gfHwgMSxcbiAgICAgICAgZmFzdCA9IHByZWNpc2lvbiA8PSAxLFxuICAgICAgICBsLFxuICAgICAgICBhMSxcbiAgICAgICAgYTIsXG4gICAgICAgIGksXG4gICAgICAgIGluYyxcbiAgICAgICAgaixcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHByZXZQb2ludCxcbiAgICAgICAgcDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuXG4gICAgaWYgKF9uZWVkc1BhcnNpbmdFeHAudGVzdChkYXRhKSB8fCB+ZGF0YS5pbmRleE9mKFwiTVwiKSAmJiBkYXRhLmluZGV4T2YoXCJDXCIpIDwgMCkge1xuICAgICAgdmFsdWVzID0gc3RyaW5nVG9SYXdQYXRoKGRhdGEpWzBdO1xuICAgIH1cblxuICAgIGwgPSB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgaWYgKGwgPT09IDQpIHtcbiAgICAgIHZhbHVlcy51bnNoaWZ0KDAsIDApO1xuICAgICAgdmFsdWVzLnB1c2goMSwgMSk7XG4gICAgICBsID0gODtcbiAgICB9IGVsc2UgaWYgKChsIC0gMikgJSA2KSB7XG4gICAgICB0aHJvdyBcIkludmFsaWQgQ3VzdG9tRWFzZVwiO1xuICAgIH1cblxuICAgIGlmICgrdmFsdWVzWzBdICE9PSAwIHx8ICt2YWx1ZXNbbCAtIDJdICE9PSAxKSB7XG4gICAgICBfbm9ybWFsaXplKHZhbHVlcywgY29uZmlnLmhlaWdodCwgY29uZmlnLm9yaWdpblkpO1xuICAgIH1cblxuICAgIHRoaXMuc2VnbWVudCA9IHZhbHVlcztcblxuICAgIGZvciAoaSA9IDI7IGkgPCBsOyBpICs9IDYpIHtcbiAgICAgIGExID0ge1xuICAgICAgICB4OiArdmFsdWVzW2kgLSAyXSxcbiAgICAgICAgeTogK3ZhbHVlc1tpIC0gMV1cbiAgICAgIH07XG4gICAgICBhMiA9IHtcbiAgICAgICAgeDogK3ZhbHVlc1tpICsgNF0sXG4gICAgICAgIHk6ICt2YWx1ZXNbaSArIDVdXG4gICAgICB9O1xuICAgICAgcG9pbnRzLnB1c2goYTEsIGEyKTtcblxuICAgICAgX2JlemllclRvUG9pbnRzKGExLngsIGExLnksICt2YWx1ZXNbaV0sICt2YWx1ZXNbaSArIDFdLCArdmFsdWVzW2kgKyAyXSwgK3ZhbHVlc1tpICsgM10sIGEyLngsIGEyLnksIDEgLyAocHJlY2lzaW9uICogMjAwMDAwKSwgcG9pbnRzLCBwb2ludHMubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgbCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIHByZXZQb2ludCA9IHBvaW50c1tpIC0gMV0gfHwgcG9pbnQ7XG5cbiAgICAgIGlmICgocG9pbnQueCA+IHByZXZQb2ludC54IHx8IHByZXZQb2ludC55ICE9PSBwb2ludC55ICYmIHByZXZQb2ludC54ID09PSBwb2ludC54IHx8IHBvaW50ID09PSBwcmV2UG9pbnQpICYmIHBvaW50LnggPD0gMSkge1xuICAgICAgICAvL2lmIGEgcG9pbnQgZ29lcyBCQUNLV0FSRCBpbiB0aW1lIG9yIGlzIGEgZHVwbGljYXRlLCBqdXN0IGRyb3AgaXQuIEFsc28gaXQgc2hvdWxkbid0IGdvIHBhc3QgMSBvbiB0aGUgeCBheGlzLCBhcyBjb3VsZCBoYXBwZW4gaW4gYSBzdHJpbmcgbGlrZSBcIk0wLDAgQzAsMCAwLjEyLDAuNjggMC4xOCwwLjc4OCAwLjE5NSwwLjg0NSAwLjMwOCwxIDAuMzIsMSAwLjQwMywxLjAwNSAwLjM5OCwxIDAuNSwxIDAuNjAyLDEgMC44MTYsMS4wMDUgMC45LDEgMC45MSwxIDAuOTQ4LDAuNjkgMC45NjIsMC42MTUgMS4wMDMsMC4zNzYgMSwwIDEsMFwiLlxuICAgICAgICBwcmV2UG9pbnQuY3ggPSBwb2ludC54IC0gcHJldlBvaW50Lng7IC8vY2hhbmdlIGluIHggYmV0d2VlbiB0aGlzIHBvaW50IGFuZCB0aGUgbmV4dCBwb2ludCAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uKVxuXG4gICAgICAgIHByZXZQb2ludC5jeSA9IHBvaW50LnkgLSBwcmV2UG9pbnQueTtcbiAgICAgICAgcHJldlBvaW50Lm4gPSBwb2ludDtcbiAgICAgICAgcHJldlBvaW50Lm54ID0gcG9pbnQueDsgLy9uZXh0IHBvaW50J3MgeCB2YWx1ZSAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLCBtYWtpbmcgbG9va3VwcyBmYXN0ZXIgaW4gZ2V0UmF0aW8oKSkuIFJlbWVtYmVyLCB0aGUgbG9va3VwIHdpbGwgYWx3YXlzIGxhbmQgb24gYSBzcG90IHdoZXJlIGl0J3MgZWl0aGVyIHRoaXMgcG9pbnQgb3IgdGhlIHZlcnkgbmV4dCBvbmUgKG5ldmVyIGJleW9uZCB0aGF0KVxuXG4gICAgICAgIGlmIChmYXN0ICYmIGkgPiAxICYmIE1hdGguYWJzKHByZXZQb2ludC5jeSAvIHByZXZQb2ludC5jeCAtIHBvaW50c1tpIC0gMl0uY3kgLyBwb2ludHNbaSAtIDJdLmN4KSA+IDIpIHtcbiAgICAgICAgICAvL2lmIHRoZXJlJ3MgYSBzdWRkZW4gY2hhbmdlIGluIGRpcmVjdGlvbiwgcHJpb3JpdGl6ZSBhY2N1cmFjeSBvdmVyIHNwZWVkLiBMaWtlIGEgYm91bmNlIGVhc2UgLSB5b3UgZG9uJ3Qgd2FudCB0byByaXNrIHRoZSBzYW1wbGluZyBjaHVua3MgbGFuZGluZyBvbiBlYWNoIHNpZGUgb2YgdGhlIGJvdW5jZSBhbmNob3IgYW5kIGhhdmluZyBpdCBjbGlwcGVkIG9mZi5cbiAgICAgICAgICBmYXN0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2UG9pbnQuY3ggPCBjbG9zZXN0KSB7XG4gICAgICAgICAgaWYgKCFwcmV2UG9pbnQuY3gpIHtcbiAgICAgICAgICAgIHByZXZQb2ludC5jeCA9IDAuMDAxOyAvL2F2b2lkcyBtYXRoIHByb2JsZW1zIGluIGdldFJhdGlvKCkgKGRpdmlkaW5nIGJ5IHplcm8pXG5cbiAgICAgICAgICAgIGlmIChpID09PSBsIC0gMSkge1xuICAgICAgICAgICAgICAvL2luIGNhc2UgdGhlIGZpbmFsIHNlZ21lbnQgZ29lcyB2ZXJ0aWNhbCBSSUdIVCBhdCB0aGUgZW5kLCBtYWtlIHN1cmUgd2UgZW5kIGF0IHRoZSBlbmQuXG4gICAgICAgICAgICAgIHByZXZQb2ludC54IC09IDAuMDAxO1xuICAgICAgICAgICAgICBjbG9zZXN0ID0gTWF0aC5taW4oY2xvc2VzdCwgMC4wMDEpO1xuICAgICAgICAgICAgICBmYXN0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xvc2VzdCA9IHByZXZQb2ludC5jeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50cy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgbC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIGwgPSAxIC8gY2xvc2VzdCArIDEgfCAwO1xuICAgIGluYyA9IDEgLyBsO1xuICAgIGogPSAwO1xuICAgIHBvaW50ID0gcG9pbnRzWzBdO1xuXG4gICAgaWYgKGZhc3QpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgLy9mb3IgZmFzdGVzdCBsb29rdXBzLCB3ZSBqdXN0IHNhbXBsZSBhbG9uZyB0aGUgcGF0aCBhdCBlcXVhbCB4ICh0aW1lKSBkaXN0YW5jZS4gVXNlcyBtb3JlIG1lbW9yeSBhbmQgaXMgc2xpZ2h0bHkgbGVzcyBhY2N1cmF0ZSBmb3IgYW5jaG9ycyB0aGF0IGRvbid0IGxhbmQgb24gdGhlIHNhbXBsaW5nIHBvaW50cywgYnV0IGZvciB0aGUgdmFzdCBtYWpvcml0eSBvZiBlYXNlcyBpdCdzIGV4Y2VsbGVudCAoYW5kIGZhc3QpLlxuICAgICAgICBwID0gaSAqIGluYztcblxuICAgICAgICBpZiAocG9pbnQubnggPCBwKSB7XG4gICAgICAgICAgcG9pbnQgPSBwb2ludHNbKytqXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGExID0gcG9pbnQueSArIChwIC0gcG9pbnQueCkgLyBwb2ludC5jeCAqIHBvaW50LmN5O1xuICAgICAgICBsb29rdXBbaV0gPSB7XG4gICAgICAgICAgeDogcCxcbiAgICAgICAgICBjeDogaW5jLFxuICAgICAgICAgIHk6IGExLFxuICAgICAgICAgIGN5OiAwLFxuICAgICAgICAgIG54OiA5XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICBsb29rdXBbaSAtIDFdLmN5ID0gYTEgLSBsb29rdXBbaSAtIDFdLnk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbG9va3VwW2wgLSAxXS5jeSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0ueSAtIGExO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL3RoaXMgb3B0aW9uIGlzIG1vcmUgYWNjdXJhdGUsIGVuc3VyaW5nIHRoYXQgRVZFUlkgYW5jaG9yIGlzIGhpdCBwZXJmZWN0bHkuIENsaXBwaW5nIGFjcm9zcyBhIGJvdW5jZSwgZm9yIGV4YW1wbGUsIHdvdWxkIG5ldmVyIGhhcHBlbi5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgLy9idWlsZCBhIGxvb2t1cCB0YWJsZSBiYXNlZCBvbiB0aGUgc21hbGxlc3QgZGlzdGFuY2Ugc28gdGhhdCB3ZSBjYW4gaW5zdGFudGx5IGZpbmQgdGhlIGFwcHJvcHJpYXRlIHBvaW50ICh3ZWxsLCBpdCdsbCBlaXRoZXIgYmUgdGhhdCBwb2ludCBvciB0aGUgdmVyeSBuZXh0IG9uZSkuIFdlJ2xsIGxvb2sgdXAgYmFzZWQgb24gdGhlIGxpbmVhciBwcm9ncmVzcy4gU28gaXQncyBpdCdzIDAuNSBhbmQgdGhlIGxvb2t1cCB0YWJsZSBoYXMgMTAwIGVsZW1lbnRzLCBpdCdkIGJlIGxpa2UgbG9va3VwW01hdGguZmxvb3IoMC41ICogMTAwKV1cbiAgICAgICAgaWYgKHBvaW50Lm54IDwgaSAqIGluYykge1xuICAgICAgICAgIHBvaW50ID0gcG9pbnRzWysral07XG4gICAgICAgIH1cblxuICAgICAgICBsb29rdXBbaV0gPSBwb2ludDtcbiAgICAgIH1cblxuICAgICAgaWYgKGogPCBwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICBsb29rdXBbaSAtIDFdID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcbiAgICAgIH1cbiAgICB9IC8vdGhpcy5fY2FsY0VuZCA9IChwb2ludHNbcG9pbnRzLmxlbmd0aC0xXS55ICE9PSAxIHx8IHBvaW50c1swXS55ICE9PSAwKTsgLy9lbnN1cmVzIHRoYXQgd2UgZG9uJ3QgcnVuIGludG8gZmxvYXRpbmcgcG9pbnQgZXJyb3JzLiBBcyBsb25nIGFzIHdlJ3JlIHN0YXJ0aW5nIGF0IDAgYW5kIGVuZGluZyBhdCAxLCB0ZWxsIEdTQVAgdG8gc2tpcCB0aGUgZmluYWwgY2FsY3VsYXRpb24gYW5kIHVzZSAwLzEgYXMgdGhlIGZhY3Rvci5cblxuXG4gICAgdGhpcy5lYXNlID0gZnVuY3Rpb24gKHApIHtcbiAgICAgIHZhciBwb2ludCA9IGxvb2t1cFtwICogbCB8IDBdIHx8IGxvb2t1cFtsIC0gMV07XG5cbiAgICAgIGlmIChwb2ludC5ueCA8IHApIHtcbiAgICAgICAgcG9pbnQgPSBwb2ludC5uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9pbnQueSArIChwIC0gcG9pbnQueCkgLyBwb2ludC5jeCAqIHBvaW50LmN5O1xuICAgIH07XG5cbiAgICB0aGlzLmVhc2UuY3VzdG9tID0gdGhpcztcbiAgICB0aGlzLmlkICYmIGdzYXAgJiYgZ3NhcC5yZWdpc3RlckVhc2UodGhpcy5pZCwgdGhpcy5lYXNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZ2V0U1ZHRGF0YSA9IGZ1bmN0aW9uIGdldFNWR0RhdGEoY29uZmlnKSB7XG4gICAgcmV0dXJuIEN1c3RvbUVhc2UuZ2V0U1ZHRGF0YSh0aGlzLCBjb25maWcpO1xuICB9O1xuXG4gIEN1c3RvbUVhc2UuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGlkLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gbmV3IEN1c3RvbUVhc2UoaWQsIGRhdGEsIGNvbmZpZykuZWFzZTtcbiAgfTtcblxuICBDdXN0b21FYXNlLnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoY29yZSkge1xuICAgIGdzYXAgPSBjb3JlO1xuXG4gICAgX2luaXRDb3JlKCk7XG4gIH07XG5cbiAgQ3VzdG9tRWFzZS5nZXQgPSBmdW5jdGlvbiBnZXQoaWQpIHtcbiAgICByZXR1cm4gZ3NhcC5wYXJzZUVhc2UoaWQpO1xuICB9O1xuXG4gIEN1c3RvbUVhc2UuZ2V0U1ZHRGF0YSA9IGZ1bmN0aW9uIGdldFNWR0RhdGEoZWFzZSwgY29uZmlnKSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIHZhciB3aWR0aCA9IGNvbmZpZy53aWR0aCB8fCAxMDAsXG4gICAgICAgIGhlaWdodCA9IGNvbmZpZy5oZWlnaHQgfHwgMTAwLFxuICAgICAgICB4ID0gY29uZmlnLnggfHwgMCxcbiAgICAgICAgeSA9IChjb25maWcueSB8fCAwKSArIGhlaWdodCxcbiAgICAgICAgZSA9IGdzYXAudXRpbHMudG9BcnJheShjb25maWcucGF0aClbMF0sXG4gICAgICAgIGEsXG4gICAgICAgIHNsb3BlLFxuICAgICAgICBpLFxuICAgICAgICBpbmMsXG4gICAgICAgIHR4LFxuICAgICAgICB0eSxcbiAgICAgICAgcHJlY2lzaW9uLFxuICAgICAgICB0aHJlc2hvbGQsXG4gICAgICAgIHByZXZYLFxuICAgICAgICBwcmV2WTtcblxuICAgIGlmIChjb25maWcuaW52ZXJ0KSB7XG4gICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgeSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBlYXNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBlYXNlID0gZ3NhcC5wYXJzZUVhc2UoZWFzZSk7XG4gICAgfVxuXG4gICAgaWYgKGVhc2UuY3VzdG9tKSB7XG4gICAgICBlYXNlID0gZWFzZS5jdXN0b207XG4gICAgfVxuXG4gICAgaWYgKGVhc2UgaW5zdGFuY2VvZiBDdXN0b21FYXNlKSB7XG4gICAgICBhID0gcmF3UGF0aFRvU3RyaW5nKHRyYW5zZm9ybVJhd1BhdGgoW2Vhc2Uuc2VnbWVudF0sIHdpZHRoLCAwLCAwLCAtaGVpZ2h0LCB4LCB5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBbeCwgeV07XG4gICAgICBwcmVjaXNpb24gPSBNYXRoLm1heCg1LCAoY29uZmlnLnByZWNpc2lvbiB8fCAxKSAqIDIwMCk7XG4gICAgICBpbmMgPSAxIC8gcHJlY2lzaW9uO1xuICAgICAgcHJlY2lzaW9uICs9IDI7XG4gICAgICB0aHJlc2hvbGQgPSA1IC8gcHJlY2lzaW9uO1xuICAgICAgcHJldlggPSBfcm91bmQoeCArIGluYyAqIHdpZHRoKTtcbiAgICAgIHByZXZZID0gX3JvdW5kKHkgKyBlYXNlKGluYykgKiAtaGVpZ2h0KTtcbiAgICAgIHNsb3BlID0gKHByZXZZIC0geSkgLyAocHJldlggLSB4KTtcblxuICAgICAgZm9yIChpID0gMjsgaSA8IHByZWNpc2lvbjsgaSsrKSB7XG4gICAgICAgIHR4ID0gX3JvdW5kKHggKyBpICogaW5jICogd2lkdGgpO1xuICAgICAgICB0eSA9IF9yb3VuZCh5ICsgZWFzZShpICogaW5jKSAqIC1oZWlnaHQpO1xuXG4gICAgICAgIGlmIChNYXRoLmFicygodHkgLSBwcmV2WSkgLyAodHggLSBwcmV2WCkgLSBzbG9wZSkgPiB0aHJlc2hvbGQgfHwgaSA9PT0gcHJlY2lzaW9uIC0gMSkge1xuICAgICAgICAgIC8vb25seSBhZGQgcG9pbnRzIHdoZW4gdGhlIHNsb3BlIGNoYW5nZXMgYmV5b25kIHRoZSB0aHJlc2hvbGRcbiAgICAgICAgICBhLnB1c2gocHJldlgsIHByZXZZKTtcbiAgICAgICAgICBzbG9wZSA9ICh0eSAtIHByZXZZKSAvICh0eCAtIHByZXZYKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZYID0gdHg7XG4gICAgICAgIHByZXZZID0gdHk7XG4gICAgICB9XG5cbiAgICAgIGEgPSBcIk1cIiArIGEuam9pbihcIixcIik7XG4gICAgfVxuXG4gICAgZSAmJiBlLnNldEF0dHJpYnV0ZShcImRcIiwgYSk7XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgcmV0dXJuIEN1c3RvbUVhc2U7XG59KCk7XG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oQ3VzdG9tRWFzZSk7XG5DdXN0b21FYXNlLnZlcnNpb24gPSBcIjMuMTIuNVwiO1xuZXhwb3J0IHsgQ3VzdG9tRWFzZSBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbInN0cmluZ1RvUmF3UGF0aCIsInJhd1BhdGhUb1N0cmluZyIsInRyYW5zZm9ybVJhd1BhdGgiLCJnc2FwIiwiX2NvcmVJbml0dGVkIiwiX2dldEdTQVAiLCJ3aW5kb3ciLCJyZWdpc3RlclBsdWdpbiIsIl9pbml0Q29yZSIsInJlZ2lzdGVyRWFzZSIsIkN1c3RvbUVhc2UiLCJjcmVhdGUiLCJjb25zb2xlIiwid2FybiIsIl9iaWdOdW0iLCJfcm91bmQiLCJ2YWx1ZSIsIl9ib251c1ZhbGlkYXRlZCIsIl9udW1FeHAiLCJfbmVlZHNQYXJzaW5nRXhwIiwiX2ZpbmRNaW5pbXVtIiwidmFsdWVzIiwibCIsImxlbmd0aCIsIm1pbiIsImkiLCJfbm9ybWFsaXplIiwiaGVpZ2h0Iiwib3JpZ2luWSIsIk1hdGgiLCJtYXgiLCJ0eCIsInR5Iiwic3giLCJzeSIsImFicyIsIl9iZXppZXJUb1BvaW50cyIsIngxIiwieTEiLCJ4MiIsInkyIiwieDMiLCJ5MyIsIng0IiwieTQiLCJ0aHJlc2hvbGQiLCJwb2ludHMiLCJpbmRleCIsIngxMiIsInkxMiIsIngyMyIsInkyMyIsIngzNCIsInkzNCIsIngxMjMiLCJ5MTIzIiwieDIzNCIsInkyMzQiLCJ4MTIzNCIsInkxMjM0IiwiZHgiLCJkeSIsImQyIiwiZDMiLCJ4IiwieSIsInNwbGljZSIsImlkIiwiZGF0YSIsImNvbmZpZyIsInNldERhdGEiLCJfcHJvdG8iLCJwcm90b3R5cGUiLCJtYXRjaCIsImNsb3Nlc3QiLCJsb29rdXAiLCJwcmVjaXNpb24iLCJmYXN0IiwiYTEiLCJhMiIsImluYyIsImoiLCJwb2ludCIsInByZXZQb2ludCIsInAiLCJ0ZXN0IiwiaW5kZXhPZiIsInVuc2hpZnQiLCJwdXNoIiwic2VnbWVudCIsImN4IiwiY3kiLCJuIiwibngiLCJlYXNlIiwiY3VzdG9tIiwiZ2V0U1ZHRGF0YSIsInJlZ2lzdGVyIiwiY29yZSIsImdldCIsInBhcnNlRWFzZSIsIndpZHRoIiwiZSIsInV0aWxzIiwidG9BcnJheSIsInBhdGgiLCJhIiwic2xvcGUiLCJwcmV2WCIsInByZXZZIiwiaW52ZXJ0Iiwiam9pbiIsInNldEF0dHJpYnV0ZSIsInZlcnNpb24iLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CustomEase.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Draggable.js":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Draggable.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Draggable: function() { return /* binding */ Draggable; },\n/* harmony export */   \"default\": function() { return /* binding */ Draggable; }\n/* harmony export */ });\n/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/matrix.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/matrix.js\");\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n}\n/*!\n * Draggable 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n */ /* eslint-disable */ \nvar gsap, _win, _doc, _docElement, _body, _tempDiv, _placeholderDiv, _coreInitted, _checkPrefix, _toArray, _supportsPassive, _isTouchDevice, _touchEventLookup, _isMultiTouching, _isAndroid, InertiaPlugin, _defaultCursor, _supportsPointer, _context, _getStyleSaver, _dragCount = 0, _windowExists = function _windowExists() {\n    return typeof window !== \"undefined\";\n}, _getGSAP = function _getGSAP() {\n    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _isFunction = function _isFunction(value) {\n    return typeof value === \"function\";\n}, _isObject = function _isObject(value) {\n    return typeof value === \"object\";\n}, _isUndefined = function _isUndefined(value) {\n    return typeof value === \"undefined\";\n}, _emptyFunc = function _emptyFunc() {\n    return false;\n}, _transformProp = \"transform\", _transformOriginProp = \"transformOrigin\", _round = function _round(value) {\n    return Math.round(value * 10000) / 10000;\n}, _isArray = Array.isArray, _createElement = function _createElement(type, ns) {\n    var e = _doc.createElementNS ? _doc.createElementNS((ns || \"http://www.w3.org/1999/xhtml\").replace(/^https/, \"http\"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making \"style\" inaccessible.\n    return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://gsap.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).\n}, _RAD2DEG = 180 / Math.PI, _bigNum = 1e20, _identityMatrix = new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D(), _getTime = Date.now || function() {\n    return new Date().getTime();\n}, _renderQueue = [], _lookup = {}, //when a Draggable is created, the target gets a unique _gsDragID property that allows gets associated with the Draggable instance for quick lookups in Draggable.get(). This avoids circular references that could cause gc problems.\n_lookupCount = 0, _clickableTagExp = /^(?:a|input|textarea|button|select)$/i, _lastDragTime = 0, _temp1 = {}, // a simple object we reuse and populate (usually x/y properties) to conserve memory and improve performance.\n_windowProxy = {}, //memory/performance optimization - we reuse this object during autoScroll to store window-related bounds/offsets.\n_copy = function _copy(obj, factor) {\n    var copy = {}, p;\n    for(p in obj){\n        copy[p] = factor ? obj[p] * factor : obj[p];\n    }\n    return copy;\n}, _extend = function _extend(obj, defaults) {\n    for(var p in defaults){\n        if (!(p in obj)) {\n            obj[p] = defaults[p];\n        }\n    }\n    return obj;\n}, _setTouchActionForAllDescendants = function _setTouchActionForAllDescendants(elements, value) {\n    var i = elements.length, children;\n    while(i--){\n        value ? elements[i].style.touchAction = value : elements[i].style.removeProperty(\"touch-action\");\n        children = elements[i].children;\n        children && children.length && _setTouchActionForAllDescendants(children, value);\n    }\n}, _renderQueueTick = function _renderQueueTick() {\n    return _renderQueue.forEach(function(func) {\n        return func();\n    });\n}, _addToRenderQueue = function _addToRenderQueue(func) {\n    _renderQueue.push(func);\n    if (_renderQueue.length === 1) {\n        gsap.ticker.add(_renderQueueTick);\n    }\n}, _renderQueueTimeout = function _renderQueueTimeout() {\n    return !_renderQueue.length && gsap.ticker.remove(_renderQueueTick);\n}, _removeFromRenderQueue = function _removeFromRenderQueue(func) {\n    var i = _renderQueue.length;\n    while(i--){\n        if (_renderQueue[i] === func) {\n            _renderQueue.splice(i, 1);\n        }\n    }\n    gsap.to(_renderQueueTimeout, {\n        overwrite: true,\n        delay: 15,\n        duration: 0,\n        onComplete: _renderQueueTimeout,\n        data: \"_draggable\"\n    }); //remove the \"tick\" listener only after the render queue is empty for 15 seconds (to improve performance). Adding/removing it constantly for every click/touch wouldn't deliver optimal speed, and we also don't want the ticker to keep calling the render method when things are idle for long periods of time (we want to improve battery life on mobile devices).\n}, _setDefaults = function _setDefaults(obj, defaults) {\n    for(var p in defaults){\n        if (!(p in obj)) {\n            obj[p] = defaults[p];\n        }\n    }\n    return obj;\n}, _addListener = function _addListener(element, type, func, capture) {\n    if (element.addEventListener) {\n        var touchType = _touchEventLookup[type];\n        capture = capture || (_supportsPassive ? {\n            passive: false\n        } : null);\n        element.addEventListener(touchType || type, func, capture);\n        touchType && type !== touchType && element.addEventListener(type, func, capture); //some browsers actually support both, so must we. But pointer events cover all.\n    }\n}, _removeListener = function _removeListener(element, type, func, capture) {\n    if (element.removeEventListener) {\n        var touchType = _touchEventLookup[type];\n        element.removeEventListener(touchType || type, func, capture);\n        touchType && type !== touchType && element.removeEventListener(type, func, capture);\n    }\n}, _preventDefault = function _preventDefault(event) {\n    event.preventDefault && event.preventDefault();\n    event.preventManipulation && event.preventManipulation(); //for some Microsoft browsers\n}, _hasTouchID = function _hasTouchID(list, ID) {\n    var i = list.length;\n    while(i--){\n        if (list[i].identifier === ID) {\n            return true;\n        }\n    }\n}, _onMultiTouchDocumentEnd = function _onMultiTouchDocumentEnd(event) {\n    _isMultiTouching = event.touches && _dragCount < event.touches.length;\n    _removeListener(event.target, \"touchend\", _onMultiTouchDocumentEnd);\n}, _onMultiTouchDocument = function _onMultiTouchDocument(event) {\n    _isMultiTouching = event.touches && _dragCount < event.touches.length;\n    _addListener(event.target, \"touchend\", _onMultiTouchDocumentEnd);\n}, _getDocScrollTop = function _getDocScrollTop(doc) {\n    return _win.pageYOffset || doc.scrollTop || doc.documentElement.scrollTop || doc.body.scrollTop || 0;\n}, _getDocScrollLeft = function _getDocScrollLeft(doc) {\n    return _win.pageXOffset || doc.scrollLeft || doc.documentElement.scrollLeft || doc.body.scrollLeft || 0;\n}, _addScrollListener = function _addScrollListener(e, callback) {\n    _addListener(e, \"scroll\", callback);\n    if (!_isRoot(e.parentNode)) {\n        _addScrollListener(e.parentNode, callback);\n    }\n}, _removeScrollListener = function _removeScrollListener(e, callback) {\n    _removeListener(e, \"scroll\", callback);\n    if (!_isRoot(e.parentNode)) {\n        _removeScrollListener(e.parentNode, callback);\n    }\n}, _isRoot = function _isRoot(e) {\n    return !!(!e || e === _docElement || e.nodeType === 9 || e === _doc.body || e === _win || !e.nodeType || !e.parentNode);\n}, _getMaxScroll = function _getMaxScroll(element, axis) {\n    var dim = axis === \"x\" ? \"Width\" : \"Height\", scroll = \"scroll\" + dim, client = \"client\" + dim;\n    return Math.max(0, _isRoot(element) ? Math.max(_docElement[scroll], _body[scroll]) - (_win[\"inner\" + dim] || _docElement[client] || _body[client]) : element[scroll] - element[client]);\n}, _recordMaxScrolls = function _recordMaxScrolls(e, skipCurrent) {\n    //records _gsMaxScrollX and _gsMaxScrollY properties for the element and all ancestors up the chain so that we can cap it, otherwise dragging beyond the edges with autoScroll on can endlessly scroll.\n    var x = _getMaxScroll(e, \"x\"), y = _getMaxScroll(e, \"y\");\n    if (_isRoot(e)) {\n        e = _windowProxy;\n    } else {\n        _recordMaxScrolls(e.parentNode, skipCurrent);\n    }\n    e._gsMaxScrollX = x;\n    e._gsMaxScrollY = y;\n    if (!skipCurrent) {\n        e._gsScrollX = e.scrollLeft || 0;\n        e._gsScrollY = e.scrollTop || 0;\n    }\n}, _setStyle = function _setStyle(element, property, value) {\n    var style = element.style;\n    if (!style) {\n        return;\n    }\n    if (_isUndefined(style[property])) {\n        property = _checkPrefix(property, element) || property;\n    }\n    if (value == null) {\n        style.removeProperty && style.removeProperty(property.replace(/([A-Z])/g, \"-$1\").toLowerCase());\n    } else {\n        style[property] = value;\n    }\n}, _getComputedStyle = function _getComputedStyle(element) {\n    return _win.getComputedStyle(element instanceof Element ? element : element.host || (element.parentNode || {}).host || element);\n}, //the \"host\" stuff helps to accommodate ShadowDom objects.\n_tempRect = {}, //reuse to reduce garbage collection tasks\n_parseRect = function _parseRect(e) {\n    //accepts a DOM element, a mouse event, or a rectangle object and returns the corresponding rectangle with left, right, width, height, top, and bottom properties\n    if (e === _win) {\n        _tempRect.left = _tempRect.top = 0;\n        _tempRect.width = _tempRect.right = _docElement.clientWidth || e.innerWidth || _body.clientWidth || 0;\n        _tempRect.height = _tempRect.bottom = (e.innerHeight || 0) - 20 < _docElement.clientHeight ? _docElement.clientHeight : e.innerHeight || _body.clientHeight || 0;\n        return _tempRect;\n    }\n    var doc = e.ownerDocument || _doc, r = !_isUndefined(e.pageX) ? {\n        left: e.pageX - _getDocScrollLeft(doc),\n        top: e.pageY - _getDocScrollTop(doc),\n        right: e.pageX - _getDocScrollLeft(doc) + 1,\n        bottom: e.pageY - _getDocScrollTop(doc) + 1\n    } : !e.nodeType && !_isUndefined(e.left) && !_isUndefined(e.top) ? e : _toArray(e)[0].getBoundingClientRect();\n    if (_isUndefined(r.right) && !_isUndefined(r.width)) {\n        r.right = r.left + r.width;\n        r.bottom = r.top + r.height;\n    } else if (_isUndefined(r.width)) {\n        //some browsers don't include width and height properties. We can't just set them directly on r because some browsers throw errors, so create a new generic object.\n        r = {\n            width: r.right - r.left,\n            height: r.bottom - r.top,\n            right: r.right,\n            left: r.left,\n            bottom: r.bottom,\n            top: r.top\n        };\n    }\n    return r;\n}, _dispatchEvent = function _dispatchEvent(target, type, callbackName) {\n    var vars = target.vars, callback = vars[callbackName], listeners = target._listeners[type], result;\n    if (_isFunction(callback)) {\n        result = callback.apply(vars.callbackScope || target, vars[callbackName + \"Params\"] || [\n            target.pointerEvent\n        ]);\n    }\n    if (listeners && target.dispatchEvent(type) === false) {\n        result = false;\n    }\n    return result;\n}, _getBounds = function _getBounds(target, context) {\n    //accepts any of the following: a DOM element, jQuery object, selector text, or an object defining bounds as {top, left, width, height} or {minX, maxX, minY, maxY}. Returns an object with left, top, width, and height properties.\n    var e = _toArray(target)[0], top, left, offset;\n    if (!e.nodeType && e !== _win) {\n        if (!_isUndefined(target.left)) {\n            offset = {\n                x: 0,\n                y: 0\n            }; //_getOffsetTransformOrigin(context); //the bounds should be relative to the origin\n            return {\n                left: target.left - offset.x,\n                top: target.top - offset.y,\n                width: target.width,\n                height: target.height\n            };\n        }\n        left = target.min || target.minX || target.minRotation || 0;\n        top = target.min || target.minY || 0;\n        return {\n            left: left,\n            top: top,\n            width: (target.max || target.maxX || target.maxRotation || 0) - left,\n            height: (target.max || target.maxY || 0) - top\n        };\n    }\n    return _getElementBounds(e, context);\n}, _point1 = {}, //we reuse to minimize garbage collection tasks.\n_getElementBounds = function _getElementBounds(element, context) {\n    context = _toArray(context)[0];\n    var isSVG = element.getBBox && element.ownerSVGElement, doc = element.ownerDocument || _doc, left, right, top, bottom, matrix, p1, p2, p3, p4, bbox, width, height, cs;\n    if (element === _win) {\n        top = _getDocScrollTop(doc);\n        left = _getDocScrollLeft(doc);\n        right = left + (doc.documentElement.clientWidth || element.innerWidth || doc.body.clientWidth || 0);\n        bottom = top + ((element.innerHeight || 0) - 20 < doc.documentElement.clientHeight ? doc.documentElement.clientHeight : element.innerHeight || doc.body.clientHeight || 0); //some browsers (like Firefox) ignore absolutely positioned elements, and collapse the height of the documentElement, so it could be 8px, for example, if you have just an absolutely positioned div. In that case, we use the innerHeight to resolve this.\n    } else if (context === _win || _isUndefined(context)) {\n        return element.getBoundingClientRect();\n    } else {\n        left = top = 0;\n        if (isSVG) {\n            bbox = element.getBBox();\n            width = bbox.width;\n            height = bbox.height;\n        } else {\n            if (element.viewBox && (bbox = element.viewBox.baseVal)) {\n                left = bbox.x || 0;\n                top = bbox.y || 0;\n                width = bbox.width;\n                height = bbox.height;\n            }\n            if (!width) {\n                cs = _getComputedStyle(element);\n                bbox = cs.boxSizing === \"border-box\";\n                width = (parseFloat(cs.width) || element.clientWidth || 0) + (bbox ? 0 : parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth));\n                height = (parseFloat(cs.height) || element.clientHeight || 0) + (bbox ? 0 : parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth));\n            }\n        }\n        right = width;\n        bottom = height;\n    }\n    if (element === context) {\n        return {\n            left: left,\n            top: top,\n            width: right - left,\n            height: bottom - top\n        };\n    }\n    matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(context, true).multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(element));\n    p1 = matrix.apply({\n        x: left,\n        y: top\n    });\n    p2 = matrix.apply({\n        x: right,\n        y: top\n    });\n    p3 = matrix.apply({\n        x: right,\n        y: bottom\n    });\n    p4 = matrix.apply({\n        x: left,\n        y: bottom\n    });\n    left = Math.min(p1.x, p2.x, p3.x, p4.x);\n    top = Math.min(p1.y, p2.y, p3.y, p4.y);\n    return {\n        left: left,\n        top: top,\n        width: Math.max(p1.x, p2.x, p3.x, p4.x) - left,\n        height: Math.max(p1.y, p2.y, p3.y, p4.y) - top\n    };\n}, _parseInertia = function _parseInertia(draggable, snap, max, min, factor, forceZeroVelocity) {\n    var vars = {}, a, i, l;\n    if (snap) {\n        if (factor !== 1 && snap instanceof Array) {\n            //some data must be altered to make sense, like if the user passes in an array of rotational values in degrees, we must convert it to radians. Or for scrollLeft and scrollTop, we invert the values.\n            vars.end = a = [];\n            l = snap.length;\n            if (_isObject(snap[0])) {\n                //if the array is populated with objects, like points ({x:100, y:200}), make copies before multiplying by the factor, otherwise we'll mess up the originals and the user may reuse it elsewhere.\n                for(i = 0; i < l; i++){\n                    a[i] = _copy(snap[i], factor);\n                }\n            } else {\n                for(i = 0; i < l; i++){\n                    a[i] = snap[i] * factor;\n                }\n            }\n            max += 1.1; //allow 1.1 pixels of wiggle room when snapping in order to work around some browser inconsistencies in the way bounds are reported which can make them roughly a pixel off. For example, if \"snap:[-$('#menu').width(), 0]\" was defined and #menu had a wrapper that was used as the bounds, some browsers would be one pixel off, making the minimum -752 for example when snap was [-753,0], thus instead of snapping to -753, it would snap to 0 since -753 was below the minimum.\n            min -= 1.1;\n        } else if (_isFunction(snap)) {\n            vars.end = function(value) {\n                var result = snap.call(draggable, value), copy, p;\n                if (factor !== 1) {\n                    if (_isObject(result)) {\n                        copy = {};\n                        for(p in result){\n                            copy[p] = result[p] * factor;\n                        }\n                        result = copy;\n                    } else {\n                        result *= factor;\n                    }\n                }\n                return result; //we need to ensure that we can scope the function call to the Draggable instance itself so that users can access important values like maxX, minX, maxY, minY, x, and y from within that function.\n            };\n        } else {\n            vars.end = snap;\n        }\n    }\n    if (max || max === 0) {\n        vars.max = max;\n    }\n    if (min || min === 0) {\n        vars.min = min;\n    }\n    if (forceZeroVelocity) {\n        vars.velocity = 0;\n    }\n    return vars;\n}, _isClickable = function _isClickable(element) {\n    //sometimes it's convenient to mark an element as clickable by adding a data-clickable=\"true\" attribute (in which case we won't preventDefault() the mouse/touch event). This method checks if the element is an <a>, <input>, or <button> or has the data-clickable or contentEditable attribute set to true (or any of its parent elements).\n    var data;\n    return !element || !element.getAttribute || element === _body ? false : (data = element.getAttribute(\"data-clickable\")) === \"true\" || data !== \"false\" && (_clickableTagExp.test(element.nodeName + \"\") || element.getAttribute(\"contentEditable\") === \"true\") ? true : _isClickable(element.parentNode);\n}, _setSelectable = function _setSelectable(elements, selectable) {\n    var i = elements.length, e;\n    while(i--){\n        e = elements[i];\n        e.ondragstart = e.onselectstart = selectable ? null : _emptyFunc;\n        gsap.set(e, {\n            lazy: true,\n            userSelect: selectable ? \"text\" : \"none\"\n        });\n    }\n}, _isFixed = function _isFixed(element) {\n    if (_getComputedStyle(element).position === \"fixed\") {\n        return true;\n    }\n    element = element.parentNode;\n    if (element && element.nodeType === 1) {\n        // avoid document fragments which will throw an error.\n        return _isFixed(element);\n    }\n}, _supports3D, _addPaddingBR, //The ScrollProxy class wraps an element's contents into another div (we call it \"content\") that we either add padding when necessary or apply a translate3d() transform in order to overscroll (scroll past the boundaries). This allows us to simply set the scrollTop/scrollLeft (or top/left for easier reverse-axis orientation, which is what we do in Draggable) and it'll do all the work for us. For example, if we tried setting scrollTop to -100 on a normal DOM element, it wouldn't work - it'd look the same as setting it to 0, but if we set scrollTop of a ScrollProxy to -100, it'll give the correct appearance by either setting paddingTop of the wrapper to 100 or applying a 100-pixel translateY.\nScrollProxy = function ScrollProxy(element, vars) {\n    element = gsap.utils.toArray(element)[0];\n    vars = vars || {};\n    var content = document.createElement(\"div\"), style = content.style, node = element.firstChild, offsetTop = 0, offsetLeft = 0, prevTop = element.scrollTop, prevLeft = element.scrollLeft, scrollWidth = element.scrollWidth, scrollHeight = element.scrollHeight, extraPadRight = 0, maxLeft = 0, maxTop = 0, elementWidth, elementHeight, contentHeight, nextNode, transformStart, transformEnd;\n    if (_supports3D && vars.force3D !== false) {\n        transformStart = \"translate3d(\";\n        transformEnd = \"px,0px)\";\n    } else if (_transformProp) {\n        transformStart = \"translate(\";\n        transformEnd = \"px)\";\n    }\n    this.scrollTop = function(value, force) {\n        if (!arguments.length) {\n            return -this.top();\n        }\n        this.top(-value, force);\n    };\n    this.scrollLeft = function(value, force) {\n        if (!arguments.length) {\n            return -this.left();\n        }\n        this.left(-value, force);\n    };\n    this.left = function(value, force) {\n        if (!arguments.length) {\n            return -(element.scrollLeft + offsetLeft);\n        }\n        var dif = element.scrollLeft - prevLeft, oldOffset = offsetLeft;\n        if ((dif > 2 || dif < -2) && !force) {\n            //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.\n            prevLeft = element.scrollLeft;\n            gsap.killTweensOf(this, {\n                left: 1,\n                scrollLeft: 1\n            });\n            this.left(-prevLeft);\n            if (vars.onKill) {\n                vars.onKill();\n            }\n            return;\n        }\n        value = -value; //invert because scrolling works in the opposite direction\n        if (value < 0) {\n            offsetLeft = value - 0.5 | 0;\n            value = 0;\n        } else if (value > maxLeft) {\n            offsetLeft = value - maxLeft | 0;\n            value = maxLeft;\n        } else {\n            offsetLeft = 0;\n        }\n        if (offsetLeft || oldOffset) {\n            if (!this._skip) {\n                style[_transformProp] = transformStart + -offsetLeft + \"px,\" + -offsetTop + transformEnd;\n            }\n            if (offsetLeft + extraPadRight >= 0) {\n                style.paddingRight = offsetLeft + extraPadRight + \"px\";\n            }\n        }\n        element.scrollLeft = value | 0;\n        prevLeft = element.scrollLeft; //don't merge this with the line above because some browsers adjust the scrollLeft after it's set, so in order to be 100% accurate in tracking it, we need to ask the browser to report it.\n    };\n    this.top = function(value, force) {\n        if (!arguments.length) {\n            return -(element.scrollTop + offsetTop);\n        }\n        var dif = element.scrollTop - prevTop, oldOffset = offsetTop;\n        if ((dif > 2 || dif < -2) && !force) {\n            //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.\n            prevTop = element.scrollTop;\n            gsap.killTweensOf(this, {\n                top: 1,\n                scrollTop: 1\n            });\n            this.top(-prevTop);\n            if (vars.onKill) {\n                vars.onKill();\n            }\n            return;\n        }\n        value = -value; //invert because scrolling works in the opposite direction\n        if (value < 0) {\n            offsetTop = value - 0.5 | 0;\n            value = 0;\n        } else if (value > maxTop) {\n            offsetTop = value - maxTop | 0;\n            value = maxTop;\n        } else {\n            offsetTop = 0;\n        }\n        if (offsetTop || oldOffset) {\n            if (!this._skip) {\n                style[_transformProp] = transformStart + -offsetLeft + \"px,\" + -offsetTop + transformEnd;\n            }\n        }\n        element.scrollTop = value | 0;\n        prevTop = element.scrollTop;\n    };\n    this.maxScrollTop = function() {\n        return maxTop;\n    };\n    this.maxScrollLeft = function() {\n        return maxLeft;\n    };\n    this.disable = function() {\n        node = content.firstChild;\n        while(node){\n            nextNode = node.nextSibling;\n            element.appendChild(node);\n            node = nextNode;\n        }\n        if (element === content.parentNode) {\n            //in case disable() is called when it's already disabled.\n            element.removeChild(content);\n        }\n    };\n    this.enable = function() {\n        node = element.firstChild;\n        if (node === content) {\n            return;\n        }\n        while(node){\n            nextNode = node.nextSibling;\n            content.appendChild(node);\n            node = nextNode;\n        }\n        element.appendChild(content);\n        this.calibrate();\n    };\n    this.calibrate = function(force) {\n        var widthMatches = element.clientWidth === elementWidth, cs, x, y;\n        prevTop = element.scrollTop;\n        prevLeft = element.scrollLeft;\n        if (widthMatches && element.clientHeight === elementHeight && content.offsetHeight === contentHeight && scrollWidth === element.scrollWidth && scrollHeight === element.scrollHeight && !force) {\n            return; //no need to recalculate things if the width and height haven't changed.\n        }\n        if (offsetTop || offsetLeft) {\n            x = this.left();\n            y = this.top();\n            this.left(-element.scrollLeft);\n            this.top(-element.scrollTop);\n        }\n        cs = _getComputedStyle(element); //first, we need to remove any width constraints to see how the content naturally flows so that we can see if it's wider than the containing element. If so, we've got to record the amount of overage so that we can apply that as padding in order for browsers to correctly handle things. Then we switch back to a width of 100% (without that, some browsers don't flow the content correctly)\n        if (!widthMatches || force) {\n            style.display = \"block\";\n            style.width = \"auto\";\n            style.paddingRight = \"0px\";\n            extraPadRight = Math.max(0, element.scrollWidth - element.clientWidth); //if the content is wider than the container, we need to add the paddingLeft and paddingRight in order for things to behave correctly.\n            if (extraPadRight) {\n                extraPadRight += parseFloat(cs.paddingLeft) + (_addPaddingBR ? parseFloat(cs.paddingRight) : 0);\n            }\n        }\n        style.display = \"inline-block\";\n        style.position = \"relative\";\n        style.overflow = \"visible\";\n        style.verticalAlign = \"top\";\n        style.boxSizing = \"content-box\";\n        style.width = \"100%\";\n        style.paddingRight = extraPadRight + \"px\"; //some browsers neglect to factor in the bottom padding when calculating the scrollHeight, so we need to add that padding to the content when that happens. Allow a 2px margin for error\n        if (_addPaddingBR) {\n            style.paddingBottom = cs.paddingBottom;\n        }\n        elementWidth = element.clientWidth;\n        elementHeight = element.clientHeight;\n        scrollWidth = element.scrollWidth;\n        scrollHeight = element.scrollHeight;\n        maxLeft = element.scrollWidth - elementWidth;\n        maxTop = element.scrollHeight - elementHeight;\n        contentHeight = content.offsetHeight;\n        style.display = \"block\";\n        if (x || y) {\n            this.left(x);\n            this.top(y);\n        }\n    };\n    this.content = content;\n    this.element = element;\n    this._skip = false;\n    this.enable();\n}, _initCore = function _initCore(required) {\n    if (_windowExists() && document.body) {\n        var nav = window && window.navigator;\n        _win = window;\n        _doc = document;\n        _docElement = _doc.documentElement;\n        _body = _doc.body;\n        _tempDiv = _createElement(\"div\");\n        _supportsPointer = !!window.PointerEvent;\n        _placeholderDiv = _createElement(\"div\");\n        _placeholderDiv.style.cssText = \"visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;cursor:grab\";\n        _defaultCursor = _placeholderDiv.style.cursor === \"grab\" ? \"grab\" : \"move\";\n        _isAndroid = nav && nav.userAgent.toLowerCase().indexOf(\"android\") !== -1; //Android handles touch events in an odd way and it's virtually impossible to \"feature test\" so we resort to UA sniffing\n        _isTouchDevice = \"ontouchstart\" in _docElement && \"orientation\" in _win || nav && (nav.MaxTouchPoints > 0 || nav.msMaxTouchPoints > 0);\n        _addPaddingBR = function() {\n            //this function is in charge of analyzing browser behavior related to padding. It sets the _addPaddingBR to true if the browser doesn't normally factor in the bottom or right padding on the element inside the scrolling area, and it sets _addPaddingLeft to true if it's a browser that requires the extra offset (offsetLeft) to be added to the paddingRight (like Opera).\n            var div = _createElement(\"div\"), child = _createElement(\"div\"), childStyle = child.style, parent = _body, val;\n            childStyle.display = \"inline-block\";\n            childStyle.position = \"relative\";\n            div.style.cssText = \"width:90px;height:40px;padding:10px;overflow:auto;visibility:hidden\";\n            div.appendChild(child);\n            parent.appendChild(div);\n            val = child.offsetHeight + 18 > div.scrollHeight; //div.scrollHeight should be child.offsetHeight + 20 because of the 10px of padding on each side, but some browsers ignore one side. We allow a 2px margin of error.\n            parent.removeChild(div);\n            return val;\n        }();\n        _touchEventLookup = function(types) {\n            //we create an object that makes it easy to translate touch event types into their \"pointer\" counterparts if we're in a browser that uses those instead. Like IE10 uses \"MSPointerDown\" instead of \"touchstart\", for example.\n            var standard = types.split(\",\"), converted = (\"onpointerdown\" in _tempDiv ? \"pointerdown,pointermove,pointerup,pointercancel\" : \"onmspointerdown\" in _tempDiv ? \"MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel\" : types).split(\",\"), obj = {}, i = 4;\n            while(--i > -1){\n                obj[standard[i]] = converted[i];\n                obj[converted[i]] = standard[i];\n            } //to avoid problems in iOS 9, test to see if the browser supports the \"passive\" option on addEventListener().\n            try {\n                _docElement.addEventListener(\"test\", null, Object.defineProperty({}, \"passive\", {\n                    get: function get() {\n                        _supportsPassive = 1;\n                    }\n                }));\n            } catch (e) {}\n            return obj;\n        }(\"touchstart,touchmove,touchend,touchcancel\");\n        _addListener(_doc, \"touchcancel\", _emptyFunc); //some older Android devices intermittently stop dispatching \"touchmove\" events if we don't listen for \"touchcancel\" on the document. Very strange indeed.\n        _addListener(_win, \"touchmove\", _emptyFunc); //works around Safari bugs that still allow the page to scroll even when we preventDefault() on the touchmove event.\n        _body && _body.addEventListener(\"touchstart\", _emptyFunc); //works around Safari bug: https://gsap.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n        _addListener(_doc, \"contextmenu\", function() {\n            for(var p in _lookup){\n                if (_lookup[p].isPressed) {\n                    _lookup[p].endDrag();\n                }\n            }\n        });\n        gsap = _coreInitted = _getGSAP();\n    }\n    if (gsap) {\n        InertiaPlugin = gsap.plugins.inertia;\n        _context = gsap.core.context || function() {};\n        _checkPrefix = gsap.utils.checkPrefix;\n        _transformProp = _checkPrefix(_transformProp);\n        _transformOriginProp = _checkPrefix(_transformOriginProp);\n        _toArray = gsap.utils.toArray;\n        _getStyleSaver = gsap.core.getStyleSaver;\n        _supports3D = !!_checkPrefix(\"perspective\");\n    } else if (required) {\n        console.warn(\"Please gsap.registerPlugin(Draggable)\");\n    }\n};\nvar EventDispatcher = /*#__PURE__*/ function() {\n    function EventDispatcher(target) {\n        this._listeners = {};\n        this.target = target || this;\n    }\n    var _proto = EventDispatcher.prototype;\n    _proto.addEventListener = function addEventListener(type, callback) {\n        var list = this._listeners[type] || (this._listeners[type] = []);\n        if (!~list.indexOf(callback)) {\n            list.push(callback);\n        }\n    };\n    _proto.removeEventListener = function removeEventListener(type, callback) {\n        var list = this._listeners[type], i = list && list.indexOf(callback);\n        i >= 0 && list.splice(i, 1);\n    };\n    _proto.dispatchEvent = function dispatchEvent(type) {\n        var _this = this;\n        var result;\n        (this._listeners[type] || []).forEach(function(callback) {\n            return callback.call(_this, {\n                type: type,\n                target: _this.target\n            }) === false && (result = false);\n        });\n        return result; //if any of the callbacks return false, pass that along.\n    };\n    return EventDispatcher;\n}();\nvar Draggable = /*#__PURE__*/ function(_EventDispatcher) {\n    _inheritsLoose(Draggable, _EventDispatcher);\n    function Draggable(target, vars) {\n        var _this2;\n        _this2 = _EventDispatcher.call(this) || this;\n        _coreInitted || _initCore(1);\n        target = _toArray(target)[0]; //in case the target is a selector object or selector text\n        _this2.styles = _getStyleSaver && _getStyleSaver(target, \"transform,left,top\");\n        if (!InertiaPlugin) {\n            InertiaPlugin = gsap.plugins.inertia;\n        }\n        _this2.vars = vars = _copy(vars || {});\n        _this2.target = target;\n        _this2.x = _this2.y = _this2.rotation = 0;\n        _this2.dragResistance = parseFloat(vars.dragResistance) || 0;\n        _this2.edgeResistance = isNaN(vars.edgeResistance) ? 1 : parseFloat(vars.edgeResistance) || 0;\n        _this2.lockAxis = vars.lockAxis;\n        _this2.autoScroll = vars.autoScroll || 0;\n        _this2.lockedAxis = null;\n        _this2.allowEventDefault = !!vars.allowEventDefault;\n        gsap.getProperty(target, \"x\"); // to ensure that transforms are instantiated.\n        var type = (vars.type || \"x,y\").toLowerCase(), xyMode = ~type.indexOf(\"x\") || ~type.indexOf(\"y\"), rotationMode = type.indexOf(\"rotation\") !== -1, xProp = rotationMode ? \"rotation\" : xyMode ? \"x\" : \"left\", yProp = xyMode ? \"y\" : \"top\", allowX = !!(~type.indexOf(\"x\") || ~type.indexOf(\"left\") || type === \"scroll\"), allowY = !!(~type.indexOf(\"y\") || ~type.indexOf(\"top\") || type === \"scroll\"), minimumMovement = vars.minimumMovement || 2, self = _assertThisInitialized(_this2), triggers = _toArray(vars.trigger || vars.handle || target), killProps = {}, dragEndTime = 0, checkAutoScrollBounds = false, autoScrollMarginTop = vars.autoScrollMarginTop || 40, autoScrollMarginRight = vars.autoScrollMarginRight || 40, autoScrollMarginBottom = vars.autoScrollMarginBottom || 40, autoScrollMarginLeft = vars.autoScrollMarginLeft || 40, isClickable = vars.clickableTest || _isClickable, clickTime = 0, gsCache = target._gsap || gsap.core.getCache(target), isFixed = _isFixed(target), getPropAsNum = function getPropAsNum(property, unit) {\n            return parseFloat(gsCache.get(target, property, unit));\n        }, ownerDoc = target.ownerDocument || _doc, enabled, scrollProxy, startPointerX, startPointerY, startElementX, startElementY, hasBounds, hasDragCallback, hasMoveCallback, maxX, minX, maxY, minY, touch, touchID, rotationOrigin, dirty, old, snapX, snapY, snapXY, isClicking, touchEventTarget, matrix, interrupted, allowNativeTouchScrolling, touchDragAxis, isDispatching, clickDispatch, trustedClickDispatch, isPreventingDefault, innerMatrix, dragged, onContextMenu = function onContextMenu(e) {\n            //used to prevent long-touch from triggering a context menu.\n            // (self.isPressed && e.which < 2) && self.endDrag() // previously ended drag when context menu was triggered, but instead we should just stop propagation and prevent the default event behavior.\n            _preventDefault(e);\n            e.stopImmediatePropagation && e.stopImmediatePropagation();\n            return false;\n        }, //this method gets called on every tick of TweenLite.ticker which allows us to synchronize the renders to the core engine (which is typically synchronized with the display refresh via requestAnimationFrame). This is an optimization - it's better than applying the values inside the \"mousemove\" or \"touchmove\" event handler which may get called many times inbetween refreshes.\n        render = function render(suppressEvents) {\n            if (self.autoScroll && self.isDragging && (checkAutoScrollBounds || dirty)) {\n                var e = target, autoScrollFactor = self.autoScroll * 15, //multiplying by 15 just gives us a better \"feel\" speed-wise.\n                parent, isRoot, rect, pointerX, pointerY, changeX, changeY, gap;\n                checkAutoScrollBounds = false;\n                _windowProxy.scrollTop = _win.pageYOffset != null ? _win.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;\n                _windowProxy.scrollLeft = _win.pageXOffset != null ? _win.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;\n                pointerX = self.pointerX - _windowProxy.scrollLeft;\n                pointerY = self.pointerY - _windowProxy.scrollTop;\n                while(e && !isRoot){\n                    //walk up the chain and sense wherever the pointer is within 40px of an edge that's scrollable.\n                    isRoot = _isRoot(e.parentNode);\n                    parent = isRoot ? _windowProxy : e.parentNode;\n                    rect = isRoot ? {\n                        bottom: Math.max(_docElement.clientHeight, _win.innerHeight || 0),\n                        right: Math.max(_docElement.clientWidth, _win.innerWidth || 0),\n                        left: 0,\n                        top: 0\n                    } : parent.getBoundingClientRect();\n                    changeX = changeY = 0;\n                    if (allowY) {\n                        gap = parent._gsMaxScrollY - parent.scrollTop;\n                        if (gap < 0) {\n                            changeY = gap;\n                        } else if (pointerY > rect.bottom - autoScrollMarginBottom && gap) {\n                            checkAutoScrollBounds = true;\n                            changeY = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.bottom - pointerY) / autoScrollMarginBottom) | 0);\n                        } else if (pointerY < rect.top + autoScrollMarginTop && parent.scrollTop) {\n                            checkAutoScrollBounds = true;\n                            changeY = -Math.min(parent.scrollTop, autoScrollFactor * (1 - Math.max(0, pointerY - rect.top) / autoScrollMarginTop) | 0);\n                        }\n                        if (changeY) {\n                            parent.scrollTop += changeY;\n                        }\n                    }\n                    if (allowX) {\n                        gap = parent._gsMaxScrollX - parent.scrollLeft;\n                        if (gap < 0) {\n                            changeX = gap;\n                        } else if (pointerX > rect.right - autoScrollMarginRight && gap) {\n                            checkAutoScrollBounds = true;\n                            changeX = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.right - pointerX) / autoScrollMarginRight) | 0);\n                        } else if (pointerX < rect.left + autoScrollMarginLeft && parent.scrollLeft) {\n                            checkAutoScrollBounds = true;\n                            changeX = -Math.min(parent.scrollLeft, autoScrollFactor * (1 - Math.max(0, pointerX - rect.left) / autoScrollMarginLeft) | 0);\n                        }\n                        if (changeX) {\n                            parent.scrollLeft += changeX;\n                        }\n                    }\n                    if (isRoot && (changeX || changeY)) {\n                        _win.scrollTo(parent.scrollLeft, parent.scrollTop);\n                        setPointerPosition(self.pointerX + changeX, self.pointerY + changeY);\n                    }\n                    e = parent;\n                }\n            }\n            if (dirty) {\n                var x = self.x, y = self.y;\n                if (rotationMode) {\n                    self.deltaX = x - parseFloat(gsCache.rotation);\n                    self.rotation = x;\n                    gsCache.rotation = x + \"deg\";\n                    gsCache.renderTransform(1, gsCache);\n                } else {\n                    if (scrollProxy) {\n                        if (allowY) {\n                            self.deltaY = y - scrollProxy.top();\n                            scrollProxy.top(y);\n                        }\n                        if (allowX) {\n                            self.deltaX = x - scrollProxy.left();\n                            scrollProxy.left(x);\n                        }\n                    } else if (xyMode) {\n                        if (allowY) {\n                            self.deltaY = y - parseFloat(gsCache.y);\n                            gsCache.y = y + \"px\";\n                        }\n                        if (allowX) {\n                            self.deltaX = x - parseFloat(gsCache.x);\n                            gsCache.x = x + \"px\";\n                        }\n                        gsCache.renderTransform(1, gsCache);\n                    } else {\n                        if (allowY) {\n                            self.deltaY = y - parseFloat(target.style.top || 0);\n                            target.style.top = y + \"px\";\n                        }\n                        if (allowX) {\n                            self.deltaX = x - parseFloat(target.style.left || 0);\n                            target.style.left = x + \"px\";\n                        }\n                    }\n                }\n                if (hasDragCallback && !suppressEvents && !isDispatching) {\n                    isDispatching = true; //in case onDrag has an update() call (avoid endless loop)\n                    if (_dispatchEvent(self, \"drag\", \"onDrag\") === false) {\n                        if (allowX) {\n                            self.x -= self.deltaX;\n                        }\n                        if (allowY) {\n                            self.y -= self.deltaY;\n                        }\n                        render(true);\n                    }\n                    isDispatching = false;\n                }\n            }\n            dirty = false;\n        }, //copies the x/y from the element (whether that be transforms, top/left, or ScrollProxy's top/left) to the Draggable's x and y (and rotation if necessary) properties so that they reflect reality and it also (optionally) applies any snapping necessary. This is used by the InertiaPlugin tween in an onUpdate to ensure things are synced and snapped.\n        syncXY = function syncXY(skipOnUpdate, skipSnap) {\n            var x = self.x, y = self.y, snappedValue, cs;\n            if (!target._gsap) {\n                //just in case the _gsap cache got wiped, like if the user called clearProps on the transform or something (very rare).\n                gsCache = gsap.core.getCache(target);\n            }\n            gsCache.uncache && gsap.getProperty(target, \"x\"); // trigger a re-cache\n            if (xyMode) {\n                self.x = parseFloat(gsCache.x);\n                self.y = parseFloat(gsCache.y);\n            } else if (rotationMode) {\n                self.x = self.rotation = parseFloat(gsCache.rotation);\n            } else if (scrollProxy) {\n                self.y = scrollProxy.top();\n                self.x = scrollProxy.left();\n            } else {\n                self.y = parseFloat(target.style.top || (cs = _getComputedStyle(target)) && cs.top) || 0;\n                self.x = parseFloat(target.style.left || (cs || {}).left) || 0;\n            }\n            if ((snapX || snapY || snapXY) && !skipSnap && (self.isDragging || self.isThrowing)) {\n                if (snapXY) {\n                    _temp1.x = self.x;\n                    _temp1.y = self.y;\n                    snappedValue = snapXY(_temp1);\n                    if (snappedValue.x !== self.x) {\n                        self.x = snappedValue.x;\n                        dirty = true;\n                    }\n                    if (snappedValue.y !== self.y) {\n                        self.y = snappedValue.y;\n                        dirty = true;\n                    }\n                }\n                if (snapX) {\n                    snappedValue = snapX(self.x);\n                    if (snappedValue !== self.x) {\n                        self.x = snappedValue;\n                        if (rotationMode) {\n                            self.rotation = snappedValue;\n                        }\n                        dirty = true;\n                    }\n                }\n                if (snapY) {\n                    snappedValue = snapY(self.y);\n                    if (snappedValue !== self.y) {\n                        self.y = snappedValue;\n                    }\n                    dirty = true;\n                }\n            }\n            dirty && render(true);\n            if (!skipOnUpdate) {\n                self.deltaX = self.x - x;\n                self.deltaY = self.y - y;\n                _dispatchEvent(self, \"throwupdate\", \"onThrowUpdate\");\n            }\n        }, buildSnapFunc = function buildSnapFunc(snap, min, max, factor) {\n            if (min == null) {\n                min = -_bigNum;\n            }\n            if (max == null) {\n                max = _bigNum;\n            }\n            if (_isFunction(snap)) {\n                return function(n) {\n                    var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)\n                    return snap.call(self, (n > max ? max + (n - max) * edgeTolerance : n < min ? min + (n - min) * edgeTolerance : n) * factor) * factor;\n                };\n            }\n            if (_isArray(snap)) {\n                return function(n) {\n                    var i = snap.length, closest = 0, absDif = _bigNum, val, dif;\n                    while(--i > -1){\n                        val = snap[i];\n                        dif = val - n;\n                        if (dif < 0) {\n                            dif = -dif;\n                        }\n                        if (dif < absDif && val >= min && val <= max) {\n                            closest = i;\n                            absDif = dif;\n                        }\n                    }\n                    return snap[closest];\n                };\n            }\n            return isNaN(snap) ? function(n) {\n                return n;\n            } : function() {\n                return snap * factor;\n            };\n        }, buildPointSnapFunc = function buildPointSnapFunc(snap, minX, maxX, minY, maxY, radius, factor) {\n            radius = radius && radius < _bigNum ? radius * radius : _bigNum; //so we don't have to Math.sqrt() in the functions. Performance optimization.\n            if (_isFunction(snap)) {\n                return function(point) {\n                    var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance, x = point.x, y = point.y, result, dx, dy; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)\n                    point.x = x = x > maxX ? maxX + (x - maxX) * edgeTolerance : x < minX ? minX + (x - minX) * edgeTolerance : x;\n                    point.y = y = y > maxY ? maxY + (y - maxY) * edgeTolerance : y < minY ? minY + (y - minY) * edgeTolerance : y;\n                    result = snap.call(self, point);\n                    if (result !== point) {\n                        point.x = result.x;\n                        point.y = result.y;\n                    }\n                    if (factor !== 1) {\n                        point.x *= factor;\n                        point.y *= factor;\n                    }\n                    if (radius < _bigNum) {\n                        dx = point.x - x;\n                        dy = point.y - y;\n                        if (dx * dx + dy * dy > radius) {\n                            point.x = x;\n                            point.y = y;\n                        }\n                    }\n                    return point;\n                };\n            }\n            if (_isArray(snap)) {\n                return function(p) {\n                    var i = snap.length, closest = 0, minDist = _bigNum, x, y, point, dist;\n                    while(--i > -1){\n                        point = snap[i];\n                        x = point.x - p.x;\n                        y = point.y - p.y;\n                        dist = x * x + y * y;\n                        if (dist < minDist) {\n                            closest = i;\n                            minDist = dist;\n                        }\n                    }\n                    return minDist <= radius ? snap[closest] : p;\n                };\n            }\n            return function(n) {\n                return n;\n            };\n        }, calculateBounds = function calculateBounds() {\n            var bounds, targetBounds, snap, snapIsRaw;\n            hasBounds = false;\n            if (scrollProxy) {\n                scrollProxy.calibrate();\n                self.minX = minX = -scrollProxy.maxScrollLeft();\n                self.minY = minY = -scrollProxy.maxScrollTop();\n                self.maxX = maxX = self.maxY = maxY = 0;\n                hasBounds = true;\n            } else if (!!vars.bounds) {\n                bounds = _getBounds(vars.bounds, target.parentNode); //could be a selector/jQuery object or a DOM element or a generic object like {top:0, left:100, width:1000, height:800} or {minX:100, maxX:1100, minY:0, maxY:800}\n                if (rotationMode) {\n                    self.minX = minX = bounds.left;\n                    self.maxX = maxX = bounds.left + bounds.width;\n                    self.minY = minY = self.maxY = maxY = 0;\n                } else if (!_isUndefined(vars.bounds.maxX) || !_isUndefined(vars.bounds.maxY)) {\n                    bounds = vars.bounds;\n                    self.minX = minX = bounds.minX;\n                    self.minY = minY = bounds.minY;\n                    self.maxX = maxX = bounds.maxX;\n                    self.maxY = maxY = bounds.maxY;\n                } else {\n                    targetBounds = _getBounds(target, target.parentNode);\n                    self.minX = minX = Math.round(getPropAsNum(xProp, \"px\") + bounds.left - targetBounds.left);\n                    self.minY = minY = Math.round(getPropAsNum(yProp, \"px\") + bounds.top - targetBounds.top);\n                    self.maxX = maxX = Math.round(minX + (bounds.width - targetBounds.width));\n                    self.maxY = maxY = Math.round(minY + (bounds.height - targetBounds.height));\n                }\n                if (minX > maxX) {\n                    self.minX = maxX;\n                    self.maxX = maxX = minX;\n                    minX = self.minX;\n                }\n                if (minY > maxY) {\n                    self.minY = maxY;\n                    self.maxY = maxY = minY;\n                    minY = self.minY;\n                }\n                if (rotationMode) {\n                    self.minRotation = minX;\n                    self.maxRotation = maxX;\n                }\n                hasBounds = true;\n            }\n            if (vars.liveSnap) {\n                snap = vars.liveSnap === true ? vars.snap || {} : vars.liveSnap;\n                snapIsRaw = _isArray(snap) || _isFunction(snap);\n                if (rotationMode) {\n                    snapX = buildSnapFunc(snapIsRaw ? snap : snap.rotation, minX, maxX, 1);\n                    snapY = null;\n                } else {\n                    if (snap.points) {\n                        snapXY = buildPointSnapFunc(snapIsRaw ? snap : snap.points, minX, maxX, minY, maxY, snap.radius, scrollProxy ? -1 : 1);\n                    } else {\n                        if (allowX) {\n                            snapX = buildSnapFunc(snapIsRaw ? snap : snap.x || snap.left || snap.scrollLeft, minX, maxX, scrollProxy ? -1 : 1);\n                        }\n                        if (allowY) {\n                            snapY = buildSnapFunc(snapIsRaw ? snap : snap.y || snap.top || snap.scrollTop, minY, maxY, scrollProxy ? -1 : 1);\n                        }\n                    }\n                }\n            }\n        }, onThrowComplete = function onThrowComplete() {\n            self.isThrowing = false;\n            _dispatchEvent(self, \"throwcomplete\", \"onThrowComplete\");\n        }, onThrowInterrupt = function onThrowInterrupt() {\n            self.isThrowing = false;\n        }, animate = function animate(inertia, forceZeroVelocity) {\n            var snap, snapIsRaw, tween, overshootTolerance;\n            if (inertia && InertiaPlugin) {\n                if (inertia === true) {\n                    snap = vars.snap || vars.liveSnap || {};\n                    snapIsRaw = _isArray(snap) || _isFunction(snap);\n                    inertia = {\n                        resistance: (vars.throwResistance || vars.resistance || 1000) / (rotationMode ? 10 : 1)\n                    };\n                    if (rotationMode) {\n                        inertia.rotation = _parseInertia(self, snapIsRaw ? snap : snap.rotation, maxX, minX, 1, forceZeroVelocity);\n                    } else {\n                        if (allowX) {\n                            inertia[xProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.x || snap.left, maxX, minX, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === \"x\");\n                        }\n                        if (allowY) {\n                            inertia[yProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.y || snap.top, maxY, minY, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === \"y\");\n                        }\n                        if (snap.points || _isArray(snap) && _isObject(snap[0])) {\n                            inertia.linkedProps = xProp + \",\" + yProp;\n                            inertia.radius = snap.radius; //note: we also disable liveSnapping while throwing if there's a \"radius\" defined, otherwise it looks weird to have the item thrown past a snapping point but live-snapping mid-tween. We do this by altering the onUpdateParams so that \"skipSnap\" parameter is true for syncXY.\n                        }\n                    }\n                }\n                self.isThrowing = true;\n                overshootTolerance = !isNaN(vars.overshootTolerance) ? vars.overshootTolerance : vars.edgeResistance === 1 ? 0 : 1 - self.edgeResistance + 0.2;\n                if (!inertia.duration) {\n                    inertia.duration = {\n                        max: Math.max(vars.minDuration || 0, \"maxDuration\" in vars ? vars.maxDuration : 2),\n                        min: !isNaN(vars.minDuration) ? vars.minDuration : overshootTolerance === 0 || _isObject(inertia) && inertia.resistance > 1000 ? 0 : 0.5,\n                        overshoot: overshootTolerance\n                    };\n                }\n                self.tween = tween = gsap.to(scrollProxy || target, {\n                    inertia: inertia,\n                    data: \"_draggable\",\n                    inherit: false,\n                    onComplete: onThrowComplete,\n                    onInterrupt: onThrowInterrupt,\n                    onUpdate: vars.fastMode ? _dispatchEvent : syncXY,\n                    onUpdateParams: vars.fastMode ? [\n                        self,\n                        \"onthrowupdate\",\n                        \"onThrowUpdate\"\n                    ] : snap && snap.radius ? [\n                        false,\n                        true\n                    ] : []\n                });\n                if (!vars.fastMode) {\n                    if (scrollProxy) {\n                        scrollProxy._skip = true; // Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.\n                    }\n                    tween.render(1e9, true, true); // force to the end. Remember, the duration will likely change upon initting because that's when InertiaPlugin calculates it.\n                    syncXY(true, true);\n                    self.endX = self.x;\n                    self.endY = self.y;\n                    if (rotationMode) {\n                        self.endRotation = self.x;\n                    }\n                    tween.play(0);\n                    syncXY(true, true);\n                    if (scrollProxy) {\n                        scrollProxy._skip = false; //Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.\n                    }\n                }\n            } else if (hasBounds) {\n                self.applyBounds();\n            }\n        }, updateMatrix = function updateMatrix(shiftStart) {\n            var start = matrix, p;\n            matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target.parentNode, true);\n            if (shiftStart && self.isPressed && !matrix.equals(start || new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D())) {\n                //if the matrix changes WHILE the element is pressed, we must adjust the startPointerX and startPointerY accordingly, so we invert the original matrix and figure out where the pointerX and pointerY were in the global space, then apply the new matrix to get the updated coordinates.\n                p = start.inverse().apply({\n                    x: startPointerX,\n                    y: startPointerY\n                });\n                matrix.apply(p, p);\n                startPointerX = p.x;\n                startPointerY = p.y;\n            }\n            if (matrix.equals(_identityMatrix)) {\n                //if there are no transforms, we can optimize performance by not factoring in the matrix\n                matrix = null;\n            }\n        }, recordStartPositions = function recordStartPositions() {\n            var edgeTolerance = 1 - self.edgeResistance, offsetX = isFixed ? _getDocScrollLeft(ownerDoc) : 0, offsetY = isFixed ? _getDocScrollTop(ownerDoc) : 0, parsedOrigin, x, y;\n            if (xyMode) {\n                // in case the user set it as a different unit, like animating the x to \"100%\". We must convert it back to px!\n                gsCache.x = getPropAsNum(xProp, \"px\") + \"px\";\n                gsCache.y = getPropAsNum(yProp, \"px\") + \"px\";\n                gsCache.renderTransform();\n            }\n            updateMatrix(false);\n            _point1.x = self.pointerX - offsetX;\n            _point1.y = self.pointerY - offsetY;\n            matrix && matrix.apply(_point1, _point1);\n            startPointerX = _point1.x; //translate to local coordinate system\n            startPointerY = _point1.y;\n            if (dirty) {\n                setPointerPosition(self.pointerX, self.pointerY);\n                render(true);\n            }\n            innerMatrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target);\n            if (scrollProxy) {\n                calculateBounds();\n                startElementY = scrollProxy.top();\n                startElementX = scrollProxy.left();\n            } else {\n                //if the element is in the process of tweening, don't force snapping to occur because it could make it jump. Imagine the user throwing, then before it's done, clicking on the element in its inbetween state.\n                if (isTweening()) {\n                    syncXY(true, true);\n                    calculateBounds();\n                } else {\n                    self.applyBounds();\n                }\n                if (rotationMode) {\n                    parsedOrigin = target.ownerSVGElement ? [\n                        gsCache.xOrigin - target.getBBox().x,\n                        gsCache.yOrigin - target.getBBox().y\n                    ] : (_getComputedStyle(target)[_transformOriginProp] || \"0 0\").split(\" \");\n                    rotationOrigin = self.rotationOrigin = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target).apply({\n                        x: parseFloat(parsedOrigin[0]) || 0,\n                        y: parseFloat(parsedOrigin[1]) || 0\n                    });\n                    syncXY(true, true);\n                    x = self.pointerX - rotationOrigin.x - offsetX;\n                    y = rotationOrigin.y - self.pointerY + offsetY;\n                    startElementX = self.x; //starting rotation (x always refers to rotation in type:\"rotation\", measured in degrees)\n                    startElementY = self.y = Math.atan2(y, x) * _RAD2DEG;\n                } else {\n                    //parent = !isFixed && target.parentNode;\n                    //startScrollTop = parent ? parent.scrollTop || 0 : 0;\n                    //startScrollLeft = parent ? parent.scrollLeft || 0 : 0;\n                    startElementY = getPropAsNum(yProp, \"px\"); //record the starting top and left values so that we can just add the mouse's movement to them later.\n                    startElementX = getPropAsNum(xProp, \"px\");\n                }\n            }\n            if (hasBounds && edgeTolerance) {\n                if (startElementX > maxX) {\n                    startElementX = maxX + (startElementX - maxX) / edgeTolerance;\n                } else if (startElementX < minX) {\n                    startElementX = minX - (minX - startElementX) / edgeTolerance;\n                }\n                if (!rotationMode) {\n                    if (startElementY > maxY) {\n                        startElementY = maxY + (startElementY - maxY) / edgeTolerance;\n                    } else if (startElementY < minY) {\n                        startElementY = minY - (minY - startElementY) / edgeTolerance;\n                    }\n                }\n            }\n            self.startX = startElementX = _round(startElementX);\n            self.startY = startElementY = _round(startElementY);\n        }, isTweening = function isTweening() {\n            return self.tween && self.tween.isActive();\n        }, removePlaceholder = function removePlaceholder() {\n            if (_placeholderDiv.parentNode && !isTweening() && !self.isDragging) {\n                //_placeholderDiv just props open auto-scrolling containers so they don't collapse as the user drags left/up. We remove it after dragging (and throwing, if necessary) finishes.\n                _placeholderDiv.parentNode.removeChild(_placeholderDiv);\n            }\n        }, //called when the mouse is pressed (or touch starts)\n        onPress = function onPress(e, force) {\n            var i;\n            if (!enabled || self.isPressed || !e || (e.type === \"mousedown\" || e.type === \"pointerdown\") && !force && _getTime() - clickTime < 30 && _touchEventLookup[self.pointerEvent.type]) {\n                //when we DON'T preventDefault() in order to accommodate touch-scrolling and the user just taps, many browsers also fire a mousedown/mouseup sequence AFTER the touchstart/touchend sequence, thus it'd result in two quick \"click\" events being dispatched. This line senses that condition and halts it on the subsequent mousedown.\n                isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchstart, pointerdown, mousedown. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.\n                return;\n            }\n            interrupted = isTweening();\n            dragged = false; // we need to track whether or not it was dragged in this interaction so that if, for example, the user calls .endDrag() to FORCE it to stop and then they keep the mouse pressed down and eventually release, that would normally cause an onClick but we have to skip it in that case if there was dragging that occurred.\n            self.pointerEvent = e;\n            if (_touchEventLookup[e.type]) {\n                //note: on iOS, BOTH touchmove and mousemove are dispatched, but the mousemove has pageY and pageX of 0 which would mess up the calculations and needlessly hurt performance.\n                touchEventTarget = ~e.type.indexOf(\"touch\") ? e.currentTarget || e.target : ownerDoc; //pointer-based touches (for Microsoft browsers) don't remain locked to the original target like other browsers, so we must use the document instead. The event type would be \"MSPointerDown\" or \"pointerdown\".\n                _addListener(touchEventTarget, \"touchend\", onRelease);\n                _addListener(touchEventTarget, \"touchmove\", onMove); // possible future change if PointerEvents are more standardized: https://developer.mozilla.org/en-US/docs/Web/API/Element/setPointerCapture\n                _addListener(touchEventTarget, \"touchcancel\", onRelease);\n                _addListener(ownerDoc, \"touchstart\", _onMultiTouchDocument);\n            } else {\n                touchEventTarget = null;\n                _addListener(ownerDoc, \"mousemove\", onMove); //attach these to the document instead of the box itself so that if the user's mouse moves too quickly (and off of the box), things still work.\n            }\n            touchDragAxis = null;\n            if (!_supportsPointer || !touchEventTarget) {\n                _addListener(ownerDoc, \"mouseup\", onRelease);\n                e && e.target && _addListener(e.target, \"mouseup\", onRelease); //we also have to listen directly on the element because some browsers don't bubble up the event to the _doc on elements with contentEditable=\"true\"\n            }\n            isClicking = isClickable.call(self, e.target) && vars.dragClickables === false && !force;\n            if (isClicking) {\n                _addListener(e.target, \"change\", onRelease); //in some browsers, when you mousedown on a <select> element, no mouseup gets dispatched! So we listen for a \"change\" event instead.\n                _dispatchEvent(self, \"pressInit\", \"onPressInit\");\n                _dispatchEvent(self, \"press\", \"onPress\");\n                _setSelectable(triggers, true); //accommodates things like inputs and elements with contentEditable=\"true\" (otherwise user couldn't drag to select text)\n                isPreventingDefault = false;\n                return;\n            }\n            allowNativeTouchScrolling = !touchEventTarget || allowX === allowY || self.vars.allowNativeTouchScrolling === false || self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2) ? false : allowX ? \"y\" : \"x\"; //note: in Chrome, right-clicking (for a context menu) fires onPress and it doesn't have the event.which set properly, so we must look for event.ctrlKey. If the user wants to allow context menus we should of course sense it here and not allow native touch scrolling.\n            isPreventingDefault = !allowNativeTouchScrolling && !self.allowEventDefault;\n            if (isPreventingDefault) {\n                _preventDefault(e);\n                _addListener(_win, \"touchforcechange\", _preventDefault); //works around safari bug: https://gsap.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n            }\n            if (e.changedTouches) {\n                //touch events store the data slightly differently\n                e = touch = e.changedTouches[0];\n                touchID = e.identifier;\n            } else if (e.pointerId) {\n                touchID = e.pointerId; //for some Microsoft browsers\n            } else {\n                touch = touchID = null;\n            }\n            _dragCount++;\n            _addToRenderQueue(render); //causes the Draggable to render on each \"tick\" of gsap.ticker (performance optimization - updating values in a mousemove can cause them to happen too frequently, like multiple times between frame redraws which is wasteful, and it also prevents values from updating properly in IE8)\n            startPointerY = self.pointerY = e.pageY; //record the starting x and y so that we can calculate the movement from the original in _onMouseMove\n            startPointerX = self.pointerX = e.pageX;\n            _dispatchEvent(self, \"pressInit\", \"onPressInit\");\n            if (allowNativeTouchScrolling || self.autoScroll) {\n                _recordMaxScrolls(target.parentNode);\n            }\n            if (target.parentNode && self.autoScroll && !scrollProxy && !rotationMode && target.parentNode._gsMaxScrollX && !_placeholderDiv.parentNode && !target.getBBox) {\n                //add a placeholder div to prevent the parent container from collapsing when the user drags the element left.\n                _placeholderDiv.style.width = target.parentNode.scrollWidth + \"px\";\n                target.parentNode.appendChild(_placeholderDiv);\n            }\n            recordStartPositions();\n            self.tween && self.tween.kill();\n            self.isThrowing = false;\n            gsap.killTweensOf(scrollProxy || target, killProps, true); //in case the user tries to drag it before the last tween is done.\n            scrollProxy && gsap.killTweensOf(target, {\n                scrollTo: 1\n            }, true); //just in case the original target's scroll position is being tweened somewhere else.\n            self.tween = self.lockedAxis = null;\n            if (vars.zIndexBoost || !rotationMode && !scrollProxy && vars.zIndexBoost !== false) {\n                target.style.zIndex = Draggable.zIndex++;\n            }\n            self.isPressed = true;\n            hasDragCallback = !!(vars.onDrag || self._listeners.drag);\n            hasMoveCallback = !!(vars.onMove || self._listeners.move);\n            if (vars.cursor !== false || vars.activeCursor) {\n                i = triggers.length;\n                while(--i > -1){\n                    gsap.set(triggers[i], {\n                        cursor: vars.activeCursor || vars.cursor || (_defaultCursor === \"grab\" ? \"grabbing\" : _defaultCursor)\n                    });\n                }\n            }\n            _dispatchEvent(self, \"press\", \"onPress\");\n        }, //called every time the mouse/touch moves\n        onMove = function onMove(e) {\n            var originalEvent = e, touches, pointerX, pointerY, i, dx, dy;\n            if (!enabled || _isMultiTouching || !self.isPressed || !e) {\n                isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchmove, pointermove, mousemove. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.\n                return;\n            }\n            self.pointerEvent = e;\n            touches = e.changedTouches;\n            if (touches) {\n                //touch events store the data slightly differently\n                e = touches[0];\n                if (e !== touch && e.identifier !== touchID) {\n                    //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)\n                    i = touches.length;\n                    while(--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target){} // Some Android devices dispatch a touchstart AND pointerdown initially, and then only pointermove thus the touchID may not match because it was grabbed from the touchstart event whereas the pointer event is the one that the browser dispatches for move, so if the event target matches this Draggable's target, let it through.\n                    if (i < 0) {\n                        return;\n                    }\n                }\n            } else if (e.pointerId && touchID && e.pointerId !== touchID) {\n                //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)\n                return;\n            }\n            if (touchEventTarget && allowNativeTouchScrolling && !touchDragAxis) {\n                //Android browsers force us to decide on the first \"touchmove\" event if we should allow the default (scrolling) behavior or preventDefault(). Otherwise, a \"touchcancel\" will be fired and then no \"touchmove\" or \"touchend\" will fire during the scrolling (no good).\n                _point1.x = e.pageX - (isFixed ? _getDocScrollLeft(ownerDoc) : 0);\n                _point1.y = e.pageY - (isFixed ? _getDocScrollTop(ownerDoc) : 0);\n                matrix && matrix.apply(_point1, _point1);\n                pointerX = _point1.x;\n                pointerY = _point1.y;\n                dx = Math.abs(pointerX - startPointerX);\n                dy = Math.abs(pointerY - startPointerY);\n                if (dx !== dy && (dx > minimumMovement || dy > minimumMovement) || _isAndroid && allowNativeTouchScrolling === touchDragAxis) {\n                    touchDragAxis = dx > dy && allowX ? \"x\" : \"y\";\n                    if (allowNativeTouchScrolling && touchDragAxis !== allowNativeTouchScrolling) {\n                        _addListener(_win, \"touchforcechange\", _preventDefault); // prevents native touch scrolling from taking over if the user started dragging in the other direction in iOS Safari\n                    }\n                    if (self.vars.lockAxisOnTouchScroll !== false && allowX && allowY) {\n                        self.lockedAxis = touchDragAxis === \"x\" ? \"y\" : \"x\";\n                        _isFunction(self.vars.onLockAxis) && self.vars.onLockAxis.call(self, originalEvent);\n                    }\n                    if (_isAndroid && allowNativeTouchScrolling === touchDragAxis) {\n                        onRelease(originalEvent);\n                        return;\n                    }\n                }\n            }\n            if (!self.allowEventDefault && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling !== touchDragAxis) && originalEvent.cancelable !== false) {\n                _preventDefault(originalEvent);\n                isPreventingDefault = true;\n            } else if (isPreventingDefault) {\n                isPreventingDefault = false;\n            }\n            if (self.autoScroll) {\n                checkAutoScrollBounds = true;\n            }\n            setPointerPosition(e.pageX, e.pageY, hasMoveCallback);\n        }, setPointerPosition = function setPointerPosition(pointerX, pointerY, invokeOnMove) {\n            var dragTolerance = 1 - self.dragResistance, edgeTolerance = 1 - self.edgeResistance, prevPointerX = self.pointerX, prevPointerY = self.pointerY, prevStartElementY = startElementY, prevX = self.x, prevY = self.y, prevEndX = self.endX, prevEndY = self.endY, prevEndRotation = self.endRotation, prevDirty = dirty, xChange, yChange, x, y, dif, temp;\n            self.pointerX = pointerX;\n            self.pointerY = pointerY;\n            if (isFixed) {\n                pointerX -= _getDocScrollLeft(ownerDoc);\n                pointerY -= _getDocScrollTop(ownerDoc);\n            }\n            if (rotationMode) {\n                y = Math.atan2(rotationOrigin.y - pointerY, pointerX - rotationOrigin.x) * _RAD2DEG;\n                dif = self.y - y;\n                if (dif > 180) {\n                    startElementY -= 360;\n                    self.y = y;\n                } else if (dif < -180) {\n                    startElementY += 360;\n                    self.y = y;\n                }\n                if (self.x !== startElementX || Math.abs(startElementY - y) > minimumMovement) {\n                    self.y = y;\n                    x = startElementX + (startElementY - y) * dragTolerance;\n                } else {\n                    x = startElementX;\n                }\n            } else {\n                if (matrix) {\n                    temp = pointerX * matrix.a + pointerY * matrix.c + matrix.e;\n                    pointerY = pointerX * matrix.b + pointerY * matrix.d + matrix.f;\n                    pointerX = temp;\n                }\n                yChange = pointerY - startPointerY;\n                xChange = pointerX - startPointerX;\n                if (yChange < minimumMovement && yChange > -minimumMovement) {\n                    yChange = 0;\n                }\n                if (xChange < minimumMovement && xChange > -minimumMovement) {\n                    xChange = 0;\n                }\n                if ((self.lockAxis || self.lockedAxis) && (xChange || yChange)) {\n                    temp = self.lockedAxis;\n                    if (!temp) {\n                        self.lockedAxis = temp = allowX && Math.abs(xChange) > Math.abs(yChange) ? \"y\" : allowY ? \"x\" : null;\n                        if (temp && _isFunction(self.vars.onLockAxis)) {\n                            self.vars.onLockAxis.call(self, self.pointerEvent);\n                        }\n                    }\n                    if (temp === \"y\") {\n                        yChange = 0;\n                    } else if (temp === \"x\") {\n                        xChange = 0;\n                    }\n                }\n                x = _round(startElementX + xChange * dragTolerance);\n                y = _round(startElementY + yChange * dragTolerance);\n            }\n            if ((snapX || snapY || snapXY) && (self.x !== x || self.y !== y && !rotationMode)) {\n                if (snapXY) {\n                    _temp1.x = x;\n                    _temp1.y = y;\n                    temp = snapXY(_temp1);\n                    x = _round(temp.x);\n                    y = _round(temp.y);\n                }\n                if (snapX) {\n                    x = _round(snapX(x));\n                }\n                if (snapY) {\n                    y = _round(snapY(y));\n                }\n            }\n            if (hasBounds) {\n                if (x > maxX) {\n                    x = maxX + Math.round((x - maxX) * edgeTolerance);\n                } else if (x < minX) {\n                    x = minX + Math.round((x - minX) * edgeTolerance);\n                }\n                if (!rotationMode) {\n                    if (y > maxY) {\n                        y = Math.round(maxY + (y - maxY) * edgeTolerance);\n                    } else if (y < minY) {\n                        y = Math.round(minY + (y - minY) * edgeTolerance);\n                    }\n                }\n            }\n            if (self.x !== x || self.y !== y && !rotationMode) {\n                if (rotationMode) {\n                    self.endRotation = self.x = self.endX = x;\n                    dirty = true;\n                } else {\n                    if (allowY) {\n                        self.y = self.endY = y;\n                        dirty = true; //a flag that indicates we need to render the target next time the TweenLite.ticker dispatches a \"tick\" event (typically on a requestAnimationFrame) - this is a performance optimization (we shouldn't render on every move because sometimes many move events can get dispatched between screen refreshes, and that'd be wasteful to render every time)\n                    }\n                    if (allowX) {\n                        self.x = self.endX = x;\n                        dirty = true;\n                    }\n                }\n                if (!invokeOnMove || _dispatchEvent(self, \"move\", \"onMove\") !== false) {\n                    if (!self.isDragging && self.isPressed) {\n                        self.isDragging = dragged = true;\n                        _dispatchEvent(self, \"dragstart\", \"onDragStart\");\n                    }\n                } else {\n                    //revert because the onMove returned false!\n                    self.pointerX = prevPointerX;\n                    self.pointerY = prevPointerY;\n                    startElementY = prevStartElementY;\n                    self.x = prevX;\n                    self.y = prevY;\n                    self.endX = prevEndX;\n                    self.endY = prevEndY;\n                    self.endRotation = prevEndRotation;\n                    dirty = prevDirty;\n                }\n            }\n        }, //called when the mouse/touch is released\n        onRelease = function onRelease(e, force) {\n            if (!enabled || !self.isPressed || e && touchID != null && !force && (e.pointerId && e.pointerId !== touchID && e.target !== target || e.changedTouches && !_hasTouchID(e.changedTouches, touchID))) {\n                //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)\n                isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchend, pointerup, mouseup. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.\n                return;\n            }\n            self.isPressed = false;\n            var originalEvent = e, wasDragging = self.isDragging, isContextMenuRelease = self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2), placeholderDelayedCall = gsap.delayedCall(0.001, removePlaceholder), touches, i, syntheticEvent, eventTarget, syntheticClick;\n            if (touchEventTarget) {\n                _removeListener(touchEventTarget, \"touchend\", onRelease);\n                _removeListener(touchEventTarget, \"touchmove\", onMove);\n                _removeListener(touchEventTarget, \"touchcancel\", onRelease);\n                _removeListener(ownerDoc, \"touchstart\", _onMultiTouchDocument);\n            } else {\n                _removeListener(ownerDoc, \"mousemove\", onMove);\n            }\n            _removeListener(_win, \"touchforcechange\", _preventDefault);\n            if (!_supportsPointer || !touchEventTarget) {\n                _removeListener(ownerDoc, \"mouseup\", onRelease);\n                e && e.target && _removeListener(e.target, \"mouseup\", onRelease);\n            }\n            dirty = false;\n            if (wasDragging) {\n                dragEndTime = _lastDragTime = _getTime();\n                self.isDragging = false;\n            }\n            _removeFromRenderQueue(render);\n            if (isClicking && !isContextMenuRelease) {\n                if (e) {\n                    _removeListener(e.target, \"change\", onRelease);\n                    self.pointerEvent = originalEvent;\n                }\n                _setSelectable(triggers, false);\n                _dispatchEvent(self, \"release\", \"onRelease\");\n                _dispatchEvent(self, \"click\", \"onClick\");\n                isClicking = false;\n                return;\n            }\n            i = triggers.length;\n            while(--i > -1){\n                _setStyle(triggers[i], \"cursor\", vars.cursor || (vars.cursor !== false ? _defaultCursor : null));\n            }\n            _dragCount--;\n            if (e) {\n                touches = e.changedTouches;\n                if (touches) {\n                    //touch events store the data slightly differently\n                    e = touches[0];\n                    if (e !== touch && e.identifier !== touchID) {\n                        //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)\n                        i = touches.length;\n                        while(--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target){}\n                        if (i < 0 && !force) {\n                            return;\n                        }\n                    }\n                }\n                self.pointerEvent = originalEvent;\n                self.pointerX = e.pageX;\n                self.pointerY = e.pageY;\n            }\n            if (isContextMenuRelease && originalEvent) {\n                _preventDefault(originalEvent);\n                isPreventingDefault = true;\n                _dispatchEvent(self, \"release\", \"onRelease\");\n            } else if (originalEvent && !wasDragging) {\n                isPreventingDefault = false;\n                if (interrupted && (vars.snap || vars.bounds)) {\n                    //otherwise, if the user clicks on the object while it's animating to a snapped position, and then releases without moving 3 pixels, it will just stay there (it should animate/snap)\n                    animate(vars.inertia || vars.throwProps);\n                }\n                _dispatchEvent(self, \"release\", \"onRelease\");\n                if ((!_isAndroid || originalEvent.type !== \"touchmove\") && originalEvent.type.indexOf(\"cancel\") === -1) {\n                    //to accommodate native scrolling on Android devices, we have to immediately call onRelease() on the first touchmove event, but that shouldn't trigger a \"click\".\n                    _dispatchEvent(self, \"click\", \"onClick\");\n                    if (_getTime() - clickTime < 300) {\n                        _dispatchEvent(self, \"doubleclick\", \"onDoubleClick\");\n                    }\n                    eventTarget = originalEvent.target || target; //old IE uses srcElement\n                    clickTime = _getTime();\n                    syntheticClick = function syntheticClick() {\n                        // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular \"click\" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the \"real\"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the \"real\" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.\n                        if (clickTime !== clickDispatch && self.enabled() && !self.isPressed && !originalEvent.defaultPrevented) {\n                            if (eventTarget.click) {\n                                //some browsers (like mobile Safari) don't properly trigger the click event\n                                eventTarget.click();\n                            } else if (ownerDoc.createEvent) {\n                                syntheticEvent = ownerDoc.createEvent(\"MouseEvents\");\n                                syntheticEvent.initMouseEvent(\"click\", true, true, _win, 1, self.pointerEvent.screenX, self.pointerEvent.screenY, self.pointerX, self.pointerY, false, false, false, false, 0, null);\n                                eventTarget.dispatchEvent(syntheticEvent);\n                            }\n                        }\n                    };\n                    if (!_isAndroid && !originalEvent.defaultPrevented) {\n                        //iOS Safari requires the synthetic click to happen immediately or else it simply won't work, but Android doesn't play nice.\n                        gsap.delayedCall(0.05, syntheticClick); //in addition to the iOS bug workaround, there's a Firefox issue with clicking on things like a video to play, so we must fake a click event in a slightly delayed fashion. Previously, we listened for the \"click\" event with \"capture\" false which solved the video-click-to-play issue, but it would allow the \"click\" event to be dispatched twice like if you were using a jQuery.click() because that was handled in the capture phase, thus we had to switch to the capture phase to avoid the double-dispatching, but do the delayed synthetic click. Don't fire it too fast (like 0.00001) because we want to give the native event a chance to fire first as it's \"trusted\".\n                    }\n                }\n            } else {\n                animate(vars.inertia || vars.throwProps); //will skip if inertia/throwProps isn't defined or InertiaPlugin isn't loaded.\n                if (!self.allowEventDefault && originalEvent && (vars.dragClickables !== false || !isClickable.call(self, originalEvent.target)) && wasDragging && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling === touchDragAxis) && originalEvent.cancelable !== false) {\n                    isPreventingDefault = true;\n                    _preventDefault(originalEvent);\n                } else {\n                    isPreventingDefault = false;\n                }\n                _dispatchEvent(self, \"release\", \"onRelease\");\n            }\n            isTweening() && placeholderDelayedCall.duration(self.tween.duration()); //sync the timing so that the placeholder DIV gets\n            wasDragging && _dispatchEvent(self, \"dragend\", \"onDragEnd\");\n            return true;\n        }, updateScroll = function updateScroll(e) {\n            if (e && self.isDragging && !scrollProxy) {\n                var parent = e.target || target.parentNode, deltaX = parent.scrollLeft - parent._gsScrollX, deltaY = parent.scrollTop - parent._gsScrollY;\n                if (deltaX || deltaY) {\n                    if (matrix) {\n                        startPointerX -= deltaX * matrix.a + deltaY * matrix.c;\n                        startPointerY -= deltaY * matrix.d + deltaX * matrix.b;\n                    } else {\n                        startPointerX -= deltaX;\n                        startPointerY -= deltaY;\n                    }\n                    parent._gsScrollX += deltaX;\n                    parent._gsScrollY += deltaY;\n                    setPointerPosition(self.pointerX, self.pointerY);\n                }\n            }\n        }, onClick = function onClick(e) {\n            //this was a huge pain in the neck to align all the various browsers and their behaviors. Chrome, Firefox, Safari, Opera, Android, and Microsoft Edge all handle events differently! Some will only trigger native behavior (like checkbox toggling) from trusted events. Others don't even support isTrusted, but require 2 events to flow through before triggering native behavior. Edge treats everything as trusted but also mandates that 2 flow through to trigger the correct native behavior.\n            var time = _getTime(), recentlyClicked = time - clickTime < 100, recentlyDragged = time - dragEndTime < 50, alreadyDispatched = recentlyClicked && clickDispatch === clickTime, defaultPrevented = self.pointerEvent && self.pointerEvent.defaultPrevented, alreadyDispatchedTrusted = recentlyClicked && trustedClickDispatch === clickTime, trusted = e.isTrusted || e.isTrusted == null && recentlyClicked && alreadyDispatched; //note: Safari doesn't support isTrusted, and it won't properly execute native behavior (like toggling checkboxes) on the first synthetic \"click\" event - we must wait for the 2nd and treat it as trusted (but stop propagation at that point). Confusing, I know. Don't you love cross-browser compatibility challenges?\n            if ((alreadyDispatched || recentlyDragged && self.vars.suppressClickOnDrag !== false) && e.stopImmediatePropagation) {\n                e.stopImmediatePropagation();\n            }\n            if (recentlyClicked && !(self.pointerEvent && self.pointerEvent.defaultPrevented) && (!alreadyDispatched || trusted && !alreadyDispatchedTrusted)) {\n                //let the first click pass through unhindered. Let the next one only if it's trusted, then no more (stop quick-succession ones)\n                if (trusted && alreadyDispatched) {\n                    trustedClickDispatch = clickTime;\n                }\n                clickDispatch = clickTime;\n                return;\n            }\n            if (self.isPressed || recentlyDragged || recentlyClicked) {\n                if (!trusted || !e.detail || !recentlyClicked || defaultPrevented) {\n                    _preventDefault(e);\n                }\n            }\n            if (!recentlyClicked && !recentlyDragged && !dragged) {\n                // for script-triggered event dispatches, like element.click()\n                e && e.target && (self.pointerEvent = e);\n                _dispatchEvent(self, \"click\", \"onClick\");\n            }\n        }, localizePoint = function localizePoint(p) {\n            return matrix ? {\n                x: p.x * matrix.a + p.y * matrix.c + matrix.e,\n                y: p.x * matrix.b + p.y * matrix.d + matrix.f\n            } : {\n                x: p.x,\n                y: p.y\n            };\n        };\n        old = Draggable.get(target);\n        old && old.kill(); // avoids duplicates (an element can only be controlled by one Draggable)\n        //give the user access to start/stop dragging...\n        _this2.startDrag = function(event, align) {\n            var r1, r2, p1, p2;\n            onPress(event || self.pointerEvent, true); //if the pointer isn't on top of the element, adjust things accordingly\n            if (align && !self.hitTest(event || self.pointerEvent)) {\n                r1 = _parseRect(event || self.pointerEvent);\n                r2 = _parseRect(target);\n                p1 = localizePoint({\n                    x: r1.left + r1.width / 2,\n                    y: r1.top + r1.height / 2\n                });\n                p2 = localizePoint({\n                    x: r2.left + r2.width / 2,\n                    y: r2.top + r2.height / 2\n                });\n                startPointerX -= p1.x - p2.x;\n                startPointerY -= p1.y - p2.y;\n            }\n            if (!self.isDragging) {\n                self.isDragging = dragged = true;\n                _dispatchEvent(self, \"dragstart\", \"onDragStart\");\n            }\n        };\n        _this2.drag = onMove;\n        _this2.endDrag = function(e) {\n            return onRelease(e || self.pointerEvent, true);\n        };\n        _this2.timeSinceDrag = function() {\n            return self.isDragging ? 0 : (_getTime() - dragEndTime) / 1000;\n        };\n        _this2.timeSinceClick = function() {\n            return (_getTime() - clickTime) / 1000;\n        };\n        _this2.hitTest = function(target, threshold) {\n            return Draggable.hitTest(self.target, target, threshold);\n        };\n        _this2.getDirection = function(from, diagonalThreshold) {\n            //from can be \"start\" (default), \"velocity\", or an element\n            var mode = from === \"velocity\" && InertiaPlugin ? from : _isObject(from) && !rotationMode ? \"element\" : \"start\", xChange, yChange, ratio, direction, r1, r2;\n            if (mode === \"element\") {\n                r1 = _parseRect(self.target);\n                r2 = _parseRect(from);\n            }\n            xChange = mode === \"start\" ? self.x - startElementX : mode === \"velocity\" ? InertiaPlugin.getVelocity(target, xProp) : r1.left + r1.width / 2 - (r2.left + r2.width / 2);\n            if (rotationMode) {\n                return xChange < 0 ? \"counter-clockwise\" : \"clockwise\";\n            } else {\n                diagonalThreshold = diagonalThreshold || 2;\n                yChange = mode === \"start\" ? self.y - startElementY : mode === \"velocity\" ? InertiaPlugin.getVelocity(target, yProp) : r1.top + r1.height / 2 - (r2.top + r2.height / 2);\n                ratio = Math.abs(xChange / yChange);\n                direction = ratio < 1 / diagonalThreshold ? \"\" : xChange < 0 ? \"left\" : \"right\";\n                if (ratio < diagonalThreshold) {\n                    if (direction !== \"\") {\n                        direction += \"-\";\n                    }\n                    direction += yChange < 0 ? \"up\" : \"down\";\n                }\n            }\n            return direction;\n        };\n        _this2.applyBounds = function(newBounds, sticky) {\n            var x, y, forceZeroVelocity, e, parent, isRoot;\n            if (newBounds && vars.bounds !== newBounds) {\n                vars.bounds = newBounds;\n                return self.update(true, sticky);\n            }\n            syncXY(true);\n            calculateBounds();\n            if (hasBounds && !isTweening()) {\n                x = self.x;\n                y = self.y;\n                if (x > maxX) {\n                    x = maxX;\n                } else if (x < minX) {\n                    x = minX;\n                }\n                if (y > maxY) {\n                    y = maxY;\n                } else if (y < minY) {\n                    y = minY;\n                }\n                if (self.x !== x || self.y !== y) {\n                    forceZeroVelocity = true;\n                    self.x = self.endX = x;\n                    if (rotationMode) {\n                        self.endRotation = x;\n                    } else {\n                        self.y = self.endY = y;\n                    }\n                    dirty = true;\n                    render(true);\n                    if (self.autoScroll && !self.isDragging) {\n                        _recordMaxScrolls(target.parentNode);\n                        e = target;\n                        _windowProxy.scrollTop = _win.pageYOffset != null ? _win.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;\n                        _windowProxy.scrollLeft = _win.pageXOffset != null ? _win.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;\n                        while(e && !isRoot){\n                            //walk up the chain and sense wherever the scrollTop/scrollLeft exceeds the maximum.\n                            isRoot = _isRoot(e.parentNode);\n                            parent = isRoot ? _windowProxy : e.parentNode;\n                            if (allowY && parent.scrollTop > parent._gsMaxScrollY) {\n                                parent.scrollTop = parent._gsMaxScrollY;\n                            }\n                            if (allowX && parent.scrollLeft > parent._gsMaxScrollX) {\n                                parent.scrollLeft = parent._gsMaxScrollX;\n                            }\n                            e = parent;\n                        }\n                    }\n                }\n                if (self.isThrowing && (forceZeroVelocity || self.endX > maxX || self.endX < minX || self.endY > maxY || self.endY < minY)) {\n                    animate(vars.inertia || vars.throwProps, forceZeroVelocity);\n                }\n            }\n            return self;\n        };\n        _this2.update = function(applyBounds, sticky, ignoreExternalChanges) {\n            if (sticky && self.isPressed) {\n                // in case the element was repositioned in the document flow, thus its x/y may be identical but its position is actually quite different.\n                var m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target), p = innerMatrix.apply({\n                    x: self.x - startElementX,\n                    y: self.y - startElementY\n                }), m2 = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target.parentNode, true);\n                m2.apply({\n                    x: m.e - p.x,\n                    y: m.f - p.y\n                }, p);\n                self.x -= p.x - m2.e;\n                self.y -= p.y - m2.f;\n                render(true);\n                recordStartPositions();\n            }\n            var x = self.x, y = self.y;\n            updateMatrix(!sticky);\n            if (applyBounds) {\n                self.applyBounds();\n            } else {\n                dirty && ignoreExternalChanges && render(true);\n                syncXY(true);\n            }\n            if (sticky) {\n                setPointerPosition(self.pointerX, self.pointerY);\n                dirty && render(true);\n            }\n            if (self.isPressed && !sticky && (allowX && Math.abs(x - self.x) > 0.01 || allowY && Math.abs(y - self.y) > 0.01 && !rotationMode)) {\n                recordStartPositions();\n            }\n            if (self.autoScroll) {\n                _recordMaxScrolls(target.parentNode, self.isDragging);\n                checkAutoScrollBounds = self.isDragging;\n                render(true); //in case reparenting occurred.\n                _removeScrollListener(target, updateScroll);\n                _addScrollListener(target, updateScroll);\n            }\n            return self;\n        };\n        _this2.enable = function(type) {\n            var setVars = {\n                lazy: true\n            }, id, i, trigger;\n            if (vars.cursor !== false) {\n                setVars.cursor = vars.cursor || _defaultCursor;\n            }\n            if (gsap.utils.checkPrefix(\"touchCallout\")) {\n                setVars.touchCallout = \"none\";\n            }\n            if (type !== \"soft\") {\n                _setTouchActionForAllDescendants(triggers, allowX === allowY ? \"none\" : vars.allowNativeTouchScrolling && target.scrollHeight === target.clientHeight === (target.scrollWidth === target.clientHeight) || vars.allowEventDefault ? \"manipulation\" : allowX ? \"pan-y\" : \"pan-x\"); // Some browsers like Internet Explorer will fire a pointercancel event when the user attempts to drag when touchAction is \"manipulate\" because it's perceived as a pan. If the element has scrollable content in only one direction, we should use pan-x or pan-y accordingly so that the pointercancel doesn't prevent dragging.\n                i = triggers.length;\n                while(--i > -1){\n                    trigger = triggers[i];\n                    _supportsPointer || _addListener(trigger, \"mousedown\", onPress);\n                    _addListener(trigger, \"touchstart\", onPress);\n                    _addListener(trigger, \"click\", onClick, true); // note: used to pass true for capture but it prevented click-to-play-video functionality in Firefox.\n                    gsap.set(trigger, setVars);\n                    if (trigger.getBBox && trigger.ownerSVGElement && allowX !== allowY) {\n                        // a bug in chrome doesn't respect touch-action on SVG elements - it only works if we set it on the parent SVG.\n                        gsap.set(trigger.ownerSVGElement, {\n                            touchAction: vars.allowNativeTouchScrolling || vars.allowEventDefault ? \"manipulation\" : allowX ? \"pan-y\" : \"pan-x\"\n                        });\n                    }\n                    vars.allowContextMenu || _addListener(trigger, \"contextmenu\", onContextMenu);\n                }\n                _setSelectable(triggers, false);\n            }\n            _addScrollListener(target, updateScroll);\n            enabled = true;\n            if (InertiaPlugin && type !== \"soft\") {\n                InertiaPlugin.track(scrollProxy || target, xyMode ? \"x,y\" : rotationMode ? \"rotation\" : \"top,left\");\n            }\n            target._gsDragID = id = \"d\" + _lookupCount++;\n            _lookup[id] = self;\n            if (scrollProxy) {\n                scrollProxy.enable();\n                scrollProxy.element._gsDragID = id;\n            }\n            (vars.bounds || rotationMode) && recordStartPositions();\n            vars.bounds && self.applyBounds();\n            return self;\n        };\n        _this2.disable = function(type) {\n            var dragging = self.isDragging, i = triggers.length, trigger;\n            while(--i > -1){\n                _setStyle(triggers[i], \"cursor\", null);\n            }\n            if (type !== \"soft\") {\n                _setTouchActionForAllDescendants(triggers, null);\n                i = triggers.length;\n                while(--i > -1){\n                    trigger = triggers[i];\n                    _setStyle(trigger, \"touchCallout\", null);\n                    _removeListener(trigger, \"mousedown\", onPress);\n                    _removeListener(trigger, \"touchstart\", onPress);\n                    _removeListener(trigger, \"click\", onClick, true);\n                    _removeListener(trigger, \"contextmenu\", onContextMenu);\n                }\n                _setSelectable(triggers, true);\n                if (touchEventTarget) {\n                    _removeListener(touchEventTarget, \"touchcancel\", onRelease);\n                    _removeListener(touchEventTarget, \"touchend\", onRelease);\n                    _removeListener(touchEventTarget, \"touchmove\", onMove);\n                }\n                _removeListener(ownerDoc, \"mouseup\", onRelease);\n                _removeListener(ownerDoc, \"mousemove\", onMove);\n            }\n            _removeScrollListener(target, updateScroll);\n            enabled = false;\n            if (InertiaPlugin && type !== \"soft\") {\n                InertiaPlugin.untrack(scrollProxy || target, xyMode ? \"x,y\" : rotationMode ? \"rotation\" : \"top,left\");\n                self.tween && self.tween.kill();\n            }\n            scrollProxy && scrollProxy.disable();\n            _removeFromRenderQueue(render);\n            self.isDragging = self.isPressed = isClicking = false;\n            dragging && _dispatchEvent(self, \"dragend\", \"onDragEnd\");\n            return self;\n        };\n        _this2.enabled = function(value, type) {\n            return arguments.length ? value ? self.enable(type) : self.disable(type) : enabled;\n        };\n        _this2.kill = function() {\n            self.isThrowing = false;\n            self.tween && self.tween.kill();\n            self.disable();\n            gsap.set(triggers, {\n                clearProps: \"userSelect\"\n            });\n            delete _lookup[target._gsDragID];\n            return self;\n        };\n        _this2.revert = function() {\n            this.kill();\n            this.styles && this.styles.revert();\n        };\n        if (~type.indexOf(\"scroll\")) {\n            scrollProxy = _this2.scrollProxy = new ScrollProxy(target, _extend({\n                onKill: function onKill() {\n                    //ScrollProxy's onKill() gets called if/when the ScrollProxy senses that the user interacted with the scroll position manually (like using the scrollbar). IE9 doesn't fire the \"mouseup\" properly when users drag the scrollbar of an element, so this works around that issue.\n                    self.isPressed && onRelease(null);\n                }\n            }, vars)); //a bug in many Android devices' stock browser causes scrollTop to get forced back to 0 after it is altered via JS, so we set overflow to \"hidden\" on mobile/touch devices (they hide the scroll bar anyway). That works around the bug. (This bug is discussed at https://code.google.com/p/android/issues/detail?id=19625)\n            target.style.overflowY = allowY && !_isTouchDevice ? \"auto\" : \"hidden\";\n            target.style.overflowX = allowX && !_isTouchDevice ? \"auto\" : \"hidden\";\n            target = scrollProxy.content;\n        }\n        if (rotationMode) {\n            killProps.rotation = 1;\n        } else {\n            if (allowX) {\n                killProps[xProp] = 1;\n            }\n            if (allowY) {\n                killProps[yProp] = 1;\n            }\n        }\n        gsCache.force3D = \"force3D\" in vars ? vars.force3D : true; //otherwise, normal dragging would be in 2D and then as soon as it's released and there's an inertia tween, it'd jump to 3D which can create an initial jump due to the work the browser must to do layerize it.\n        _context(_assertThisInitialized(_this2));\n        _this2.enable();\n        return _this2;\n    }\n    Draggable.register = function register(core) {\n        gsap = core;\n        _initCore();\n    };\n    Draggable.create = function create(targets, vars) {\n        _coreInitted || _initCore(true);\n        return _toArray(targets).map(function(target) {\n            return new Draggable(target, vars);\n        });\n    };\n    Draggable.get = function get(target) {\n        return _lookup[(_toArray(target)[0] || {})._gsDragID];\n    };\n    Draggable.timeSinceDrag = function timeSinceDrag() {\n        return (_getTime() - _lastDragTime) / 1000;\n    };\n    Draggable.hitTest = function hitTest(obj1, obj2, threshold) {\n        if (obj1 === obj2) {\n            return false;\n        }\n        var r1 = _parseRect(obj1), r2 = _parseRect(obj2), top = r1.top, left = r1.left, right = r1.right, bottom = r1.bottom, width = r1.width, height = r1.height, isOutside = r2.left > right || r2.right < left || r2.top > bottom || r2.bottom < top, overlap, area, isRatio;\n        if (isOutside || !threshold) {\n            return !isOutside;\n        }\n        isRatio = (threshold + \"\").indexOf(\"%\") !== -1;\n        threshold = parseFloat(threshold) || 0;\n        overlap = {\n            left: Math.max(left, r2.left),\n            top: Math.max(top, r2.top)\n        };\n        overlap.width = Math.min(right, r2.right) - overlap.left;\n        overlap.height = Math.min(bottom, r2.bottom) - overlap.top;\n        if (overlap.width < 0 || overlap.height < 0) {\n            return false;\n        }\n        if (isRatio) {\n            threshold *= 0.01;\n            area = overlap.width * overlap.height;\n            return area >= width * height * threshold || area >= r2.width * r2.height * threshold;\n        }\n        return overlap.width > threshold && overlap.height > threshold;\n    };\n    return Draggable;\n}(EventDispatcher);\n_setDefaults(Draggable.prototype, {\n    pointerX: 0,\n    pointerY: 0,\n    startX: 0,\n    startY: 0,\n    deltaX: 0,\n    deltaY: 0,\n    isDragging: false,\n    isPressed: false\n});\nDraggable.zIndex = 1000;\nDraggable.version = \"3.12.5\";\n_getGSAP() && gsap.registerPlugin(Draggable);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9EcmFnZ2FibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsU0FBU0EsdUJBQXVCQyxJQUFJO0lBQUksSUFBSUEsU0FBUyxLQUFLLEdBQUc7UUFBRSxNQUFNLElBQUlDLGVBQWU7SUFBOEQ7SUFBRSxPQUFPRDtBQUFNO0FBRXJLLFNBQVNFLGVBQWVDLFFBQVEsRUFBRUMsVUFBVTtJQUFJRCxTQUFTRSxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0gsV0FBV0MsU0FBUztJQUFHRixTQUFTRSxTQUFTLENBQUNHLFdBQVcsR0FBR0w7SUFBVUEsU0FBU00sU0FBUyxHQUFHTDtBQUFZO0FBRXRMOzs7Ozs7OztDQVFDLEdBRUQsa0JBQWtCLEdBQzRDO0FBRTlELElBQUlRLE1BQ0FDLE1BQ0FDLE1BQ0FDLGFBQ0FDLE9BQ0FDLFVBQ0FDLGlCQUNBQyxjQUNBQyxjQUNBQyxVQUNBQyxrQkFDQUMsZ0JBQ0FDLG1CQUNBQyxrQkFDQUMsWUFDQUMsZUFDQUMsZ0JBQ0FDLGtCQUNBQyxVQUNBQyxnQkFDQUMsYUFBYSxHQUNiQyxnQkFBZ0IsU0FBU0E7SUFDM0IsT0FBTyxPQUFPQyxXQUFXO0FBQzNCLEdBQ0lDLFdBQVcsU0FBU0E7SUFDdEIsT0FBT3ZCLFFBQVFxQixtQkFBb0JyQixDQUFBQSxPQUFPc0IsT0FBT3RCLElBQUksS0FBS0EsS0FBS3dCLGNBQWMsSUFBSXhCO0FBQ25GLEdBQ0l5QixjQUFjLFNBQVNBLFlBQVlDLEtBQUs7SUFDMUMsT0FBTyxPQUFPQSxVQUFVO0FBQzFCLEdBQ0lDLFlBQVksU0FBU0EsVUFBVUQsS0FBSztJQUN0QyxPQUFPLE9BQU9BLFVBQVU7QUFDMUIsR0FDSUUsZUFBZSxTQUFTQSxhQUFhRixLQUFLO0lBQzVDLE9BQU8sT0FBT0EsVUFBVTtBQUMxQixHQUNJRyxhQUFhLFNBQVNBO0lBQ3hCLE9BQU87QUFDVCxHQUNJ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QVE1WixJQUFJO1FBQ3hENFosUUFBUXRaLE1BQU0sR0FBRzVILEtBQUtrSixHQUFHLENBQUNyQixRQUFRa1gsR0FBR2xYLE1BQU0sSUFBSXFaLFFBQVEzWixHQUFHO1FBRTFELElBQUkyWixRQUFRMVosS0FBSyxHQUFHLEtBQUswWixRQUFRdFosTUFBTSxHQUFHLEdBQUc7WUFDM0MsT0FBTztRQUNUO1FBRUEsSUFBSXdaLFNBQVM7WUFDWGpDLGFBQWE7WUFDYmdDLE9BQU9ELFFBQVExWixLQUFLLEdBQUcwWixRQUFRdFosTUFBTTtZQUNyQyxPQUFPdVosUUFBUTNaLFFBQVFJLFNBQVN1WCxhQUFhZ0MsUUFBUXBDLEdBQUd2WCxLQUFLLEdBQUd1WCxHQUFHblgsTUFBTSxHQUFHdVg7UUFDOUU7UUFFQSxPQUFPK0IsUUFBUTFaLEtBQUssR0FBRzJYLGFBQWErQixRQUFRdFosTUFBTSxHQUFHdVg7SUFDdkQ7SUFFQSxPQUFPN047QUFDVCxFQUFFSCxpQkFBaUI7QUFFbkJ4TixhQUFhMk4sVUFBVTlULFNBQVMsRUFBRTtJQUNoQzBZLFVBQVU7SUFDVkMsVUFBVTtJQUNWbUUsUUFBUTtJQUNSQyxRQUFRO0lBQ1I5RCxRQUFRO0lBQ1JFLFFBQVE7SUFDUmIsWUFBWTtJQUNacEYsV0FBVztBQUNiO0FBRUFZLFVBQVVnSyxNQUFNLEdBQUc7QUFDbkJoSyxVQUFVK1AsT0FBTyxHQUFHO0FBQ3BCL2hCLGNBQWN2QixLQUFLd0IsY0FBYyxDQUFDK1I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vZ3NhcEAzLjEyLjUvbm9kZV9tb2R1bGVzL2dzYXAvRHJhZ2dhYmxlLmpzP2FmZjciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKiFcbiAqIERyYWdnYWJsZSAzLjEyLjVcbiAqIGh0dHBzOi8vZ3NhcC5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDI0LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dzYXAuY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdTQVAgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IHsgZ2V0R2xvYmFsTWF0cml4LCBNYXRyaXgyRCB9IGZyb20gXCIuL3V0aWxzL21hdHJpeC5qc1wiO1xuXG52YXIgZ3NhcCxcbiAgICBfd2luLFxuICAgIF9kb2MsXG4gICAgX2RvY0VsZW1lbnQsXG4gICAgX2JvZHksXG4gICAgX3RlbXBEaXYsXG4gICAgX3BsYWNlaG9sZGVyRGl2LFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfY2hlY2tQcmVmaXgsXG4gICAgX3RvQXJyYXksXG4gICAgX3N1cHBvcnRzUGFzc2l2ZSxcbiAgICBfaXNUb3VjaERldmljZSxcbiAgICBfdG91Y2hFdmVudExvb2t1cCxcbiAgICBfaXNNdWx0aVRvdWNoaW5nLFxuICAgIF9pc0FuZHJvaWQsXG4gICAgSW5lcnRpYVBsdWdpbixcbiAgICBfZGVmYXVsdEN1cnNvcixcbiAgICBfc3VwcG9ydHNQb2ludGVyLFxuICAgIF9jb250ZXh0LFxuICAgIF9nZXRTdHlsZVNhdmVyLFxuICAgIF9kcmFnQ291bnQgPSAwLFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgX3dpbmRvd0V4aXN0cygpICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX2lzRnVuY3Rpb24gPSBmdW5jdGlvbiBfaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59LFxuICAgIF9pc09iamVjdCA9IGZ1bmN0aW9uIF9pc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufSxcbiAgICBfaXNVbmRlZmluZWQgPSBmdW5jdGlvbiBfaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2VtcHR5RnVuYyA9IGZ1bmN0aW9uIF9lbXB0eUZ1bmMoKSB7XG4gIHJldHVybiBmYWxzZTtcbn0sXG4gICAgX3RyYW5zZm9ybVByb3AgPSBcInRyYW5zZm9ybVwiLFxuICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gXCJ0cmFuc2Zvcm1PcmlnaW5cIixcbiAgICBfcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMCkgLyAxMDAwMDtcbn0sXG4gICAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5LFxuICAgIF9jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQodHlwZSwgbnMpIHtcbiAgdmFyIGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyA/IF9kb2MuY3JlYXRlRWxlbWVudE5TKChucyB8fCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIikucmVwbGFjZSgvXmh0dHBzLywgXCJodHRwXCIpLCB0eXBlKSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIHNlcnZlcnMgc3dhcCBpbiBodHRwcyBmb3IgaHR0cCBpbiB0aGUgbmFtZXNwYWNlIHdoaWNoIGNhbiBicmVhayB0aGluZ3MsIG1ha2luZyBcInN0eWxlXCIgaW5hY2Nlc3NpYmxlLlxuXG4gIHJldHVybiBlLnN0eWxlID8gZSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIGVudmlyb25tZW50cyB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIGVsZW1lbnQncyBzdHlsZSB3aGVuIGNyZWF0ZWQgd2l0aCBhIG5hbWVzcGFjZSBpbiB3aGljaCBjYXNlIHdlIGRlZmF1bHQgdG8gdGhlIHN0YW5kYXJkIGNyZWF0ZUVsZW1lbnQoKSB0byB3b3JrIGFyb3VuZCB0aGUgaXNzdWUuIEFsc28gbm90ZSB0aGF0IHdoZW4gR1NBUCBpcyBlbWJlZGRlZCBkaXJlY3RseSBpbnNpZGUgYW4gU1ZHIGZpbGUsIGNyZWF0ZUVsZW1lbnQoKSB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIHN0eWxlIG9iamVjdCBpbiBGaXJlZm94IChzZWUgaHR0cHM6Ly9nc2FwLmNvbS9mb3J1bXMvdG9waWMvMjAyMTUtcHJvYmxlbS11c2luZy10d2Vlbm1heC1pbi1zdGFuZGFsb25lLXNlbGYtY29udGFpbmluZy1zdmctZmlsZS1lcnItY2Fubm90LXNldC1wcm9wZXJ0eS1jc3N0ZXh0LW9mLXVuZGVmaW5lZC8pLlxufSxcbiAgICBfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG4gICAgX2JpZ051bSA9IDFlMjAsXG4gICAgX2lkZW50aXR5TWF0cml4ID0gbmV3IE1hdHJpeDJEKCksXG4gICAgX2dldFRpbWUgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbn0sXG4gICAgX3JlbmRlclF1ZXVlID0gW10sXG4gICAgX2xvb2t1cCA9IHt9LFxuICAgIC8vd2hlbiBhIERyYWdnYWJsZSBpcyBjcmVhdGVkLCB0aGUgdGFyZ2V0IGdldHMgYSB1bmlxdWUgX2dzRHJhZ0lEIHByb3BlcnR5IHRoYXQgYWxsb3dzIGdldHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBEcmFnZ2FibGUgaW5zdGFuY2UgZm9yIHF1aWNrIGxvb2t1cHMgaW4gRHJhZ2dhYmxlLmdldCgpLiBUaGlzIGF2b2lkcyBjaXJjdWxhciByZWZlcmVuY2VzIHRoYXQgY291bGQgY2F1c2UgZ2MgcHJvYmxlbXMuXG5fbG9va3VwQ291bnQgPSAwLFxuICAgIF9jbGlja2FibGVUYWdFeHAgPSAvXig/OmF8aW5wdXR8dGV4dGFyZWF8YnV0dG9ufHNlbGVjdCkkL2ksXG4gICAgX2xhc3REcmFnVGltZSA9IDAsXG4gICAgX3RlbXAxID0ge30sXG4gICAgLy8gYSBzaW1wbGUgb2JqZWN0IHdlIHJldXNlIGFuZCBwb3B1bGF0ZSAodXN1YWxseSB4L3kgcHJvcGVydGllcykgdG8gY29uc2VydmUgbWVtb3J5IGFuZCBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuX3dpbmRvd1Byb3h5ID0ge30sXG4gICAgLy9tZW1vcnkvcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIC0gd2UgcmV1c2UgdGhpcyBvYmplY3QgZHVyaW5nIGF1dG9TY3JvbGwgdG8gc3RvcmUgd2luZG93LXJlbGF0ZWQgYm91bmRzL29mZnNldHMuXG5fY29weSA9IGZ1bmN0aW9uIF9jb3B5KG9iaiwgZmFjdG9yKSB7XG4gIHZhciBjb3B5ID0ge30sXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiBvYmopIHtcbiAgICBjb3B5W3BdID0gZmFjdG9yID8gb2JqW3BdICogZmFjdG9yIDogb2JqW3BdO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIF9leHRlbmQgPSBmdW5jdGlvbiBfZXh0ZW5kKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIGlmICghKHAgaW4gb2JqKSkge1xuICAgICAgb2JqW3BdID0gZGVmYXVsdHNbcF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0sXG4gICAgX3NldFRvdWNoQWN0aW9uRm9yQWxsRGVzY2VuZGFudHMgPSBmdW5jdGlvbiBfc2V0VG91Y2hBY3Rpb25Gb3JBbGxEZXNjZW5kYW50cyhlbGVtZW50cywgdmFsdWUpIHtcbiAgdmFyIGkgPSBlbGVtZW50cy5sZW5ndGgsXG4gICAgICBjaGlsZHJlbjtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFsdWUgPyBlbGVtZW50c1tpXS5zdHlsZS50b3VjaEFjdGlvbiA9IHZhbHVlIDogZWxlbWVudHNbaV0uc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0b3VjaC1hY3Rpb25cIik7XG4gICAgY2hpbGRyZW4gPSBlbGVtZW50c1tpXS5jaGlsZHJlbjtcbiAgICBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggJiYgX3NldFRvdWNoQWN0aW9uRm9yQWxsRGVzY2VuZGFudHMoY2hpbGRyZW4sIHZhbHVlKTtcbiAgfVxufSxcbiAgICBfcmVuZGVyUXVldWVUaWNrID0gZnVuY3Rpb24gX3JlbmRlclF1ZXVlVGljaygpIHtcbiAgcmV0dXJuIF9yZW5kZXJRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmMoKTtcbiAgfSk7XG59LFxuICAgIF9hZGRUb1JlbmRlclF1ZXVlID0gZnVuY3Rpb24gX2FkZFRvUmVuZGVyUXVldWUoZnVuYykge1xuICBfcmVuZGVyUXVldWUucHVzaChmdW5jKTtcblxuICBpZiAoX3JlbmRlclF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgIGdzYXAudGlja2VyLmFkZChfcmVuZGVyUXVldWVUaWNrKTtcbiAgfVxufSxcbiAgICBfcmVuZGVyUXVldWVUaW1lb3V0ID0gZnVuY3Rpb24gX3JlbmRlclF1ZXVlVGltZW91dCgpIHtcbiAgcmV0dXJuICFfcmVuZGVyUXVldWUubGVuZ3RoICYmIGdzYXAudGlja2VyLnJlbW92ZShfcmVuZGVyUXVldWVUaWNrKTtcbn0sXG4gICAgX3JlbW92ZUZyb21SZW5kZXJRdWV1ZSA9IGZ1bmN0aW9uIF9yZW1vdmVGcm9tUmVuZGVyUXVldWUoZnVuYykge1xuICB2YXIgaSA9IF9yZW5kZXJRdWV1ZS5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChfcmVuZGVyUXVldWVbaV0gPT09IGZ1bmMpIHtcbiAgICAgIF9yZW5kZXJRdWV1ZS5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG5cbiAgZ3NhcC50byhfcmVuZGVyUXVldWVUaW1lb3V0LCB7XG4gICAgb3ZlcndyaXRlOiB0cnVlLFxuICAgIGRlbGF5OiAxNSxcbiAgICBkdXJhdGlvbjogMCxcbiAgICBvbkNvbXBsZXRlOiBfcmVuZGVyUXVldWVUaW1lb3V0LFxuICAgIGRhdGE6IFwiX2RyYWdnYWJsZVwiXG4gIH0pOyAvL3JlbW92ZSB0aGUgXCJ0aWNrXCIgbGlzdGVuZXIgb25seSBhZnRlciB0aGUgcmVuZGVyIHF1ZXVlIGlzIGVtcHR5IGZvciAxNSBzZWNvbmRzICh0byBpbXByb3ZlIHBlcmZvcm1hbmNlKS4gQWRkaW5nL3JlbW92aW5nIGl0IGNvbnN0YW50bHkgZm9yIGV2ZXJ5IGNsaWNrL3RvdWNoIHdvdWxkbid0IGRlbGl2ZXIgb3B0aW1hbCBzcGVlZCwgYW5kIHdlIGFsc28gZG9uJ3Qgd2FudCB0aGUgdGlja2VyIHRvIGtlZXAgY2FsbGluZyB0aGUgcmVuZGVyIG1ldGhvZCB3aGVuIHRoaW5ncyBhcmUgaWRsZSBmb3IgbG9uZyBwZXJpb2RzIG9mIHRpbWUgKHdlIHdhbnQgdG8gaW1wcm92ZSBiYXR0ZXJ5IGxpZmUgb24gbW9iaWxlIGRldmljZXMpLlxufSxcbiAgICBfc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiBfc2V0RGVmYXVsdHMob2JqLCBkZWZhdWx0cykge1xuICBmb3IgKHZhciBwIGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKCEocCBpbiBvYmopKSB7XG4gICAgICBvYmpbcF0gPSBkZWZhdWx0c1twXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBfYWRkTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgZnVuYywgY2FwdHVyZSkge1xuICBpZiAoZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgdmFyIHRvdWNoVHlwZSA9IF90b3VjaEV2ZW50TG9va3VwW3R5cGVdO1xuICAgIGNhcHR1cmUgPSBjYXB0dXJlIHx8IChfc3VwcG9ydHNQYXNzaXZlID8ge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9IDogbnVsbCk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRvdWNoVHlwZSB8fCB0eXBlLCBmdW5jLCBjYXB0dXJlKTtcbiAgICB0b3VjaFR5cGUgJiYgdHlwZSAhPT0gdG91Y2hUeXBlICYmIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jLCBjYXB0dXJlKTsgLy9zb21lIGJyb3dzZXJzIGFjdHVhbGx5IHN1cHBvcnQgYm90aCwgc28gbXVzdCB3ZS4gQnV0IHBvaW50ZXIgZXZlbnRzIGNvdmVyIGFsbC5cbiAgfVxufSxcbiAgICBfcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiBfcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgZnVuYywgY2FwdHVyZSkge1xuICBpZiAoZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgdmFyIHRvdWNoVHlwZSA9IF90b3VjaEV2ZW50TG9va3VwW3R5cGVdO1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0b3VjaFR5cGUgfHwgdHlwZSwgZnVuYywgY2FwdHVyZSk7XG4gICAgdG91Y2hUeXBlICYmIHR5cGUgIT09IHRvdWNoVHlwZSAmJiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZnVuYywgY2FwdHVyZSk7XG4gIH1cbn0sXG4gICAgX3ByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gX3ByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0ICYmIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnByZXZlbnRNYW5pcHVsYXRpb24gJiYgZXZlbnQucHJldmVudE1hbmlwdWxhdGlvbigpOyAvL2ZvciBzb21lIE1pY3Jvc29mdCBicm93c2Vyc1xufSxcbiAgICBfaGFzVG91Y2hJRCA9IGZ1bmN0aW9uIF9oYXNUb3VjaElEKGxpc3QsIElEKSB7XG4gIHZhciBpID0gbGlzdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChsaXN0W2ldLmlkZW50aWZpZXIgPT09IElEKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX29uTXVsdGlUb3VjaERvY3VtZW50RW5kID0gZnVuY3Rpb24gX29uTXVsdGlUb3VjaERvY3VtZW50RW5kKGV2ZW50KSB7XG4gIF9pc011bHRpVG91Y2hpbmcgPSBldmVudC50b3VjaGVzICYmIF9kcmFnQ291bnQgPCBldmVudC50b3VjaGVzLmxlbmd0aDtcblxuICBfcmVtb3ZlTGlzdGVuZXIoZXZlbnQudGFyZ2V0LCBcInRvdWNoZW5kXCIsIF9vbk11bHRpVG91Y2hEb2N1bWVudEVuZCk7XG59LFxuICAgIF9vbk11bHRpVG91Y2hEb2N1bWVudCA9IGZ1bmN0aW9uIF9vbk11bHRpVG91Y2hEb2N1bWVudChldmVudCkge1xuICBfaXNNdWx0aVRvdWNoaW5nID0gZXZlbnQudG91Y2hlcyAmJiBfZHJhZ0NvdW50IDwgZXZlbnQudG91Y2hlcy5sZW5ndGg7XG5cbiAgX2FkZExpc3RlbmVyKGV2ZW50LnRhcmdldCwgXCJ0b3VjaGVuZFwiLCBfb25NdWx0aVRvdWNoRG9jdW1lbnRFbmQpO1xufSxcbiAgICBfZ2V0RG9jU2Nyb2xsVG9wID0gZnVuY3Rpb24gX2dldERvY1Njcm9sbFRvcChkb2MpIHtcbiAgcmV0dXJuIF93aW4ucGFnZVlPZmZzZXQgfHwgZG9jLnNjcm9sbFRvcCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2MuYm9keS5zY3JvbGxUb3AgfHwgMDtcbn0sXG4gICAgX2dldERvY1Njcm9sbExlZnQgPSBmdW5jdGlvbiBfZ2V0RG9jU2Nyb2xsTGVmdChkb2MpIHtcbiAgcmV0dXJuIF93aW4ucGFnZVhPZmZzZXQgfHwgZG9jLnNjcm9sbExlZnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvYy5ib2R5LnNjcm9sbExlZnQgfHwgMDtcbn0sXG4gICAgX2FkZFNjcm9sbExpc3RlbmVyID0gZnVuY3Rpb24gX2FkZFNjcm9sbExpc3RlbmVyKGUsIGNhbGxiYWNrKSB7XG4gIF9hZGRMaXN0ZW5lcihlLCBcInNjcm9sbFwiLCBjYWxsYmFjayk7XG5cbiAgaWYgKCFfaXNSb290KGUucGFyZW50Tm9kZSkpIHtcbiAgICBfYWRkU2Nyb2xsTGlzdGVuZXIoZS5wYXJlbnROb2RlLCBjYWxsYmFjayk7XG4gIH1cbn0sXG4gICAgX3JlbW92ZVNjcm9sbExpc3RlbmVyID0gZnVuY3Rpb24gX3JlbW92ZVNjcm9sbExpc3RlbmVyKGUsIGNhbGxiYWNrKSB7XG4gIF9yZW1vdmVMaXN0ZW5lcihlLCBcInNjcm9sbFwiLCBjYWxsYmFjayk7XG5cbiAgaWYgKCFfaXNSb290KGUucGFyZW50Tm9kZSkpIHtcbiAgICBfcmVtb3ZlU2Nyb2xsTGlzdGVuZXIoZS5wYXJlbnROb2RlLCBjYWxsYmFjayk7XG4gIH1cbn0sXG4gICAgX2lzUm9vdCA9IGZ1bmN0aW9uIF9pc1Jvb3QoZSkge1xuICByZXR1cm4gISEoIWUgfHwgZSA9PT0gX2RvY0VsZW1lbnQgfHwgZS5ub2RlVHlwZSA9PT0gOSB8fCBlID09PSBfZG9jLmJvZHkgfHwgZSA9PT0gX3dpbiB8fCAhZS5ub2RlVHlwZSB8fCAhZS5wYXJlbnROb2RlKTtcbn0sXG4gICAgX2dldE1heFNjcm9sbCA9IGZ1bmN0aW9uIF9nZXRNYXhTY3JvbGwoZWxlbWVudCwgYXhpcykge1xuICB2YXIgZGltID0gYXhpcyA9PT0gXCJ4XCIgPyBcIldpZHRoXCIgOiBcIkhlaWdodFwiLFxuICAgICAgc2Nyb2xsID0gXCJzY3JvbGxcIiArIGRpbSxcbiAgICAgIGNsaWVudCA9IFwiY2xpZW50XCIgKyBkaW07XG4gIHJldHVybiBNYXRoLm1heCgwLCBfaXNSb290KGVsZW1lbnQpID8gTWF0aC5tYXgoX2RvY0VsZW1lbnRbc2Nyb2xsXSwgX2JvZHlbc2Nyb2xsXSkgLSAoX3dpbltcImlubmVyXCIgKyBkaW1dIHx8IF9kb2NFbGVtZW50W2NsaWVudF0gfHwgX2JvZHlbY2xpZW50XSkgOiBlbGVtZW50W3Njcm9sbF0gLSBlbGVtZW50W2NsaWVudF0pO1xufSxcbiAgICBfcmVjb3JkTWF4U2Nyb2xscyA9IGZ1bmN0aW9uIF9yZWNvcmRNYXhTY3JvbGxzKGUsIHNraXBDdXJyZW50KSB7XG4gIC8vcmVjb3JkcyBfZ3NNYXhTY3JvbGxYIGFuZCBfZ3NNYXhTY3JvbGxZIHByb3BlcnRpZXMgZm9yIHRoZSBlbGVtZW50IGFuZCBhbGwgYW5jZXN0b3JzIHVwIHRoZSBjaGFpbiBzbyB0aGF0IHdlIGNhbiBjYXAgaXQsIG90aGVyd2lzZSBkcmFnZ2luZyBiZXlvbmQgdGhlIGVkZ2VzIHdpdGggYXV0b1Njcm9sbCBvbiBjYW4gZW5kbGVzc2x5IHNjcm9sbC5cbiAgdmFyIHggPSBfZ2V0TWF4U2Nyb2xsKGUsIFwieFwiKSxcbiAgICAgIHkgPSBfZ2V0TWF4U2Nyb2xsKGUsIFwieVwiKTtcblxuICBpZiAoX2lzUm9vdChlKSkge1xuICAgIGUgPSBfd2luZG93UHJveHk7XG4gIH0gZWxzZSB7XG4gICAgX3JlY29yZE1heFNjcm9sbHMoZS5wYXJlbnROb2RlLCBza2lwQ3VycmVudCk7XG4gIH1cblxuICBlLl9nc01heFNjcm9sbFggPSB4O1xuICBlLl9nc01heFNjcm9sbFkgPSB5O1xuXG4gIGlmICghc2tpcEN1cnJlbnQpIHtcbiAgICBlLl9nc1Njcm9sbFggPSBlLnNjcm9sbExlZnQgfHwgMDtcbiAgICBlLl9nc1Njcm9sbFkgPSBlLnNjcm9sbFRvcCB8fCAwO1xuICB9XG59LFxuICAgIF9zZXRTdHlsZSA9IGZ1bmN0aW9uIF9zZXRTdHlsZShlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcblxuICBpZiAoIXN0eWxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKF9pc1VuZGVmaW5lZChzdHlsZVtwcm9wZXJ0eV0pKSB7XG4gICAgcHJvcGVydHkgPSBfY2hlY2tQcmVmaXgocHJvcGVydHksIGVsZW1lbnQpIHx8IHByb3BlcnR5O1xuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eSAmJiBzdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eS5yZXBsYWNlKC8oW0EtWl0pL2csIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICB9XG59LFxuICAgIF9nZXRDb21wdXRlZFN0eWxlID0gZnVuY3Rpb24gX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gX3dpbi5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50ID8gZWxlbWVudCA6IGVsZW1lbnQuaG9zdCB8fCAoZWxlbWVudC5wYXJlbnROb2RlIHx8IHt9KS5ob3N0IHx8IGVsZW1lbnQpO1xufSxcbiAgICAvL3RoZSBcImhvc3RcIiBzdHVmZiBoZWxwcyB0byBhY2NvbW1vZGF0ZSBTaGFkb3dEb20gb2JqZWN0cy5cbl90ZW1wUmVjdCA9IHt9LFxuICAgIC8vcmV1c2UgdG8gcmVkdWNlIGdhcmJhZ2UgY29sbGVjdGlvbiB0YXNrc1xuX3BhcnNlUmVjdCA9IGZ1bmN0aW9uIF9wYXJzZVJlY3QoZSkge1xuICAvL2FjY2VwdHMgYSBET00gZWxlbWVudCwgYSBtb3VzZSBldmVudCwgb3IgYSByZWN0YW5nbGUgb2JqZWN0IGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlY3RhbmdsZSB3aXRoIGxlZnQsIHJpZ2h0LCB3aWR0aCwgaGVpZ2h0LCB0b3AsIGFuZCBib3R0b20gcHJvcGVydGllc1xuICBpZiAoZSA9PT0gX3dpbikge1xuICAgIF90ZW1wUmVjdC5sZWZ0ID0gX3RlbXBSZWN0LnRvcCA9IDA7XG4gICAgX3RlbXBSZWN0LndpZHRoID0gX3RlbXBSZWN0LnJpZ2h0ID0gX2RvY0VsZW1lbnQuY2xpZW50V2lkdGggfHwgZS5pbm5lcldpZHRoIHx8IF9ib2R5LmNsaWVudFdpZHRoIHx8IDA7XG4gICAgX3RlbXBSZWN0LmhlaWdodCA9IF90ZW1wUmVjdC5ib3R0b20gPSAoZS5pbm5lckhlaWdodCB8fCAwKSAtIDIwIDwgX2RvY0VsZW1lbnQuY2xpZW50SGVpZ2h0ID8gX2RvY0VsZW1lbnQuY2xpZW50SGVpZ2h0IDogZS5pbm5lckhlaWdodCB8fCBfYm9keS5jbGllbnRIZWlnaHQgfHwgMDtcbiAgICByZXR1cm4gX3RlbXBSZWN0O1xuICB9XG5cbiAgdmFyIGRvYyA9IGUub3duZXJEb2N1bWVudCB8fCBfZG9jLFxuICAgICAgciA9ICFfaXNVbmRlZmluZWQoZS5wYWdlWCkgPyB7XG4gICAgbGVmdDogZS5wYWdlWCAtIF9nZXREb2NTY3JvbGxMZWZ0KGRvYyksXG4gICAgdG9wOiBlLnBhZ2VZIC0gX2dldERvY1Njcm9sbFRvcChkb2MpLFxuICAgIHJpZ2h0OiBlLnBhZ2VYIC0gX2dldERvY1Njcm9sbExlZnQoZG9jKSArIDEsXG4gICAgYm90dG9tOiBlLnBhZ2VZIC0gX2dldERvY1Njcm9sbFRvcChkb2MpICsgMVxuICB9IDogIWUubm9kZVR5cGUgJiYgIV9pc1VuZGVmaW5lZChlLmxlZnQpICYmICFfaXNVbmRlZmluZWQoZS50b3ApID8gZSA6IF90b0FycmF5KGUpWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gIGlmIChfaXNVbmRlZmluZWQoci5yaWdodCkgJiYgIV9pc1VuZGVmaW5lZChyLndpZHRoKSkge1xuICAgIHIucmlnaHQgPSByLmxlZnQgKyByLndpZHRoO1xuICAgIHIuYm90dG9tID0gci50b3AgKyByLmhlaWdodDtcbiAgfSBlbHNlIGlmIChfaXNVbmRlZmluZWQoci53aWR0aCkpIHtcbiAgICAvL3NvbWUgYnJvd3NlcnMgZG9uJ3QgaW5jbHVkZSB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXMuIFdlIGNhbid0IGp1c3Qgc2V0IHRoZW0gZGlyZWN0bHkgb24gciBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgdGhyb3cgZXJyb3JzLCBzbyBjcmVhdGUgYSBuZXcgZ2VuZXJpYyBvYmplY3QuXG4gICAgciA9IHtcbiAgICAgIHdpZHRoOiByLnJpZ2h0IC0gci5sZWZ0LFxuICAgICAgaGVpZ2h0OiByLmJvdHRvbSAtIHIudG9wLFxuICAgICAgcmlnaHQ6IHIucmlnaHQsXG4gICAgICBsZWZ0OiByLmxlZnQsXG4gICAgICBib3R0b206IHIuYm90dG9tLFxuICAgICAgdG9wOiByLnRvcFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gcjtcbn0sXG4gICAgX2Rpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiBfZGlzcGF0Y2hFdmVudCh0YXJnZXQsIHR5cGUsIGNhbGxiYWNrTmFtZSkge1xuICB2YXIgdmFycyA9IHRhcmdldC52YXJzLFxuICAgICAgY2FsbGJhY2sgPSB2YXJzW2NhbGxiYWNrTmFtZV0sXG4gICAgICBsaXN0ZW5lcnMgPSB0YXJnZXQuX2xpc3RlbmVyc1t0eXBlXSxcbiAgICAgIHJlc3VsdDtcblxuICBpZiAoX2lzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgcmVzdWx0ID0gY2FsbGJhY2suYXBwbHkodmFycy5jYWxsYmFja1Njb3BlIHx8IHRhcmdldCwgdmFyc1tjYWxsYmFja05hbWUgKyBcIlBhcmFtc1wiXSB8fCBbdGFyZ2V0LnBvaW50ZXJFdmVudF0pO1xuICB9XG5cbiAgaWYgKGxpc3RlbmVycyAmJiB0YXJnZXQuZGlzcGF0Y2hFdmVudCh0eXBlKSA9PT0gZmFsc2UpIHtcbiAgICByZXN1bHQgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59LFxuICAgIF9nZXRCb3VuZHMgPSBmdW5jdGlvbiBfZ2V0Qm91bmRzKHRhcmdldCwgY29udGV4dCkge1xuICAvL2FjY2VwdHMgYW55IG9mIHRoZSBmb2xsb3dpbmc6IGEgRE9NIGVsZW1lbnQsIGpRdWVyeSBvYmplY3QsIHNlbGVjdG9yIHRleHQsIG9yIGFuIG9iamVjdCBkZWZpbmluZyBib3VuZHMgYXMge3RvcCwgbGVmdCwgd2lkdGgsIGhlaWdodH0gb3Ige21pblgsIG1heFgsIG1pblksIG1heFl9LiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGxlZnQsIHRvcCwgd2lkdGgsIGFuZCBoZWlnaHQgcHJvcGVydGllcy5cbiAgdmFyIGUgPSBfdG9BcnJheSh0YXJnZXQpWzBdLFxuICAgICAgdG9wLFxuICAgICAgbGVmdCxcbiAgICAgIG9mZnNldDtcblxuICBpZiAoIWUubm9kZVR5cGUgJiYgZSAhPT0gX3dpbikge1xuICAgIGlmICghX2lzVW5kZWZpbmVkKHRhcmdldC5sZWZ0KSkge1xuICAgICAgb2Zmc2V0ID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9OyAvL19nZXRPZmZzZXRUcmFuc2Zvcm1PcmlnaW4oY29udGV4dCk7IC8vdGhlIGJvdW5kcyBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIG9yaWdpblxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiB0YXJnZXQubGVmdCAtIG9mZnNldC54LFxuICAgICAgICB0b3A6IHRhcmdldC50b3AgLSBvZmZzZXQueSxcbiAgICAgICAgd2lkdGg6IHRhcmdldC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0YXJnZXQuaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cblxuICAgIGxlZnQgPSB0YXJnZXQubWluIHx8IHRhcmdldC5taW5YIHx8IHRhcmdldC5taW5Sb3RhdGlvbiB8fCAwO1xuICAgIHRvcCA9IHRhcmdldC5taW4gfHwgdGFyZ2V0Lm1pblkgfHwgMDtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogbGVmdCxcbiAgICAgIHRvcDogdG9wLFxuICAgICAgd2lkdGg6ICh0YXJnZXQubWF4IHx8IHRhcmdldC5tYXhYIHx8IHRhcmdldC5tYXhSb3RhdGlvbiB8fCAwKSAtIGxlZnQsXG4gICAgICBoZWlnaHQ6ICh0YXJnZXQubWF4IHx8IHRhcmdldC5tYXhZIHx8IDApIC0gdG9wXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfZ2V0RWxlbWVudEJvdW5kcyhlLCBjb250ZXh0KTtcbn0sXG4gICAgX3BvaW50MSA9IHt9LFxuICAgIC8vd2UgcmV1c2UgdG8gbWluaW1pemUgZ2FyYmFnZSBjb2xsZWN0aW9uIHRhc2tzLlxuX2dldEVsZW1lbnRCb3VuZHMgPSBmdW5jdGlvbiBfZ2V0RWxlbWVudEJvdW5kcyhlbGVtZW50LCBjb250ZXh0KSB7XG4gIGNvbnRleHQgPSBfdG9BcnJheShjb250ZXh0KVswXTtcbiAgdmFyIGlzU1ZHID0gZWxlbWVudC5nZXRCQm94ICYmIGVsZW1lbnQub3duZXJTVkdFbGVtZW50LFxuICAgICAgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IF9kb2MsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHQsXG4gICAgICB0b3AsXG4gICAgICBib3R0b20sXG4gICAgICBtYXRyaXgsXG4gICAgICBwMSxcbiAgICAgIHAyLFxuICAgICAgcDMsXG4gICAgICBwNCxcbiAgICAgIGJib3gsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGNzO1xuXG4gIGlmIChlbGVtZW50ID09PSBfd2luKSB7XG4gICAgdG9wID0gX2dldERvY1Njcm9sbFRvcChkb2MpO1xuICAgIGxlZnQgPSBfZ2V0RG9jU2Nyb2xsTGVmdChkb2MpO1xuICAgIHJpZ2h0ID0gbGVmdCArIChkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IGVsZW1lbnQuaW5uZXJXaWR0aCB8fCBkb2MuYm9keS5jbGllbnRXaWR0aCB8fCAwKTtcbiAgICBib3R0b20gPSB0b3AgKyAoKGVsZW1lbnQuaW5uZXJIZWlnaHQgfHwgMCkgLSAyMCA8IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ID8gZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgOiBlbGVtZW50LmlubmVySGVpZ2h0IHx8IGRvYy5ib2R5LmNsaWVudEhlaWdodCB8fCAwKTsgLy9zb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpIGlnbm9yZSBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgZWxlbWVudHMsIGFuZCBjb2xsYXBzZSB0aGUgaGVpZ2h0IG9mIHRoZSBkb2N1bWVudEVsZW1lbnQsIHNvIGl0IGNvdWxkIGJlIDhweCwgZm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIGp1c3QgYW4gYWJzb2x1dGVseSBwb3NpdGlvbmVkIGRpdi4gSW4gdGhhdCBjYXNlLCB3ZSB1c2UgdGhlIGlubmVySGVpZ2h0IHRvIHJlc29sdmUgdGhpcy5cbiAgfSBlbHNlIGlmIChjb250ZXh0ID09PSBfd2luIHx8IF9pc1VuZGVmaW5lZChjb250ZXh0KSkge1xuICAgIHJldHVybiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9IGVsc2Uge1xuICAgIGxlZnQgPSB0b3AgPSAwO1xuXG4gICAgaWYgKGlzU1ZHKSB7XG4gICAgICBiYm94ID0gZWxlbWVudC5nZXRCQm94KCk7XG4gICAgICB3aWR0aCA9IGJib3gud2lkdGg7XG4gICAgICBoZWlnaHQgPSBiYm94LmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVsZW1lbnQudmlld0JveCAmJiAoYmJveCA9IGVsZW1lbnQudmlld0JveC5iYXNlVmFsKSkge1xuICAgICAgICBsZWZ0ID0gYmJveC54IHx8IDA7XG4gICAgICAgIHRvcCA9IGJib3gueSB8fCAwO1xuICAgICAgICB3aWR0aCA9IGJib3gud2lkdGg7XG4gICAgICAgIGhlaWdodCA9IGJib3guaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXdpZHRoKSB7XG4gICAgICAgIGNzID0gX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgICAgIGJib3ggPSBjcy5ib3hTaXppbmcgPT09IFwiYm9yZGVyLWJveFwiO1xuICAgICAgICB3aWR0aCA9IChwYXJzZUZsb2F0KGNzLndpZHRoKSB8fCBlbGVtZW50LmNsaWVudFdpZHRoIHx8IDApICsgKGJib3ggPyAwIDogcGFyc2VGbG9hdChjcy5ib3JkZXJMZWZ0V2lkdGgpICsgcGFyc2VGbG9hdChjcy5ib3JkZXJSaWdodFdpZHRoKSk7XG4gICAgICAgIGhlaWdodCA9IChwYXJzZUZsb2F0KGNzLmhlaWdodCkgfHwgZWxlbWVudC5jbGllbnRIZWlnaHQgfHwgMCkgKyAoYmJveCA/IDAgOiBwYXJzZUZsb2F0KGNzLmJvcmRlclRvcFdpZHRoKSArIHBhcnNlRmxvYXQoY3MuYm9yZGVyQm90dG9tV2lkdGgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByaWdodCA9IHdpZHRoO1xuICAgIGJvdHRvbSA9IGhlaWdodDtcbiAgfVxuXG4gIGlmIChlbGVtZW50ID09PSBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICB0b3A6IHRvcCxcbiAgICAgIHdpZHRoOiByaWdodCAtIGxlZnQsXG4gICAgICBoZWlnaHQ6IGJvdHRvbSAtIHRvcFxuICAgIH07XG4gIH1cblxuICBtYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoY29udGV4dCwgdHJ1ZSkubXVsdGlwbHkoZ2V0R2xvYmFsTWF0cml4KGVsZW1lbnQpKTtcbiAgcDEgPSBtYXRyaXguYXBwbHkoe1xuICAgIHg6IGxlZnQsXG4gICAgeTogdG9wXG4gIH0pO1xuICBwMiA9IG1hdHJpeC5hcHBseSh7XG4gICAgeDogcmlnaHQsXG4gICAgeTogdG9wXG4gIH0pO1xuICBwMyA9IG1hdHJpeC5hcHBseSh7XG4gICAgeDogcmlnaHQsXG4gICAgeTogYm90dG9tXG4gIH0pO1xuICBwNCA9IG1hdHJpeC5hcHBseSh7XG4gICAgeDogbGVmdCxcbiAgICB5OiBib3R0b21cbiAgfSk7XG4gIGxlZnQgPSBNYXRoLm1pbihwMS54LCBwMi54LCBwMy54LCBwNC54KTtcbiAgdG9wID0gTWF0aC5taW4ocDEueSwgcDIueSwgcDMueSwgcDQueSk7XG4gIHJldHVybiB7XG4gICAgbGVmdDogbGVmdCxcbiAgICB0b3A6IHRvcCxcbiAgICB3aWR0aDogTWF0aC5tYXgocDEueCwgcDIueCwgcDMueCwgcDQueCkgLSBsZWZ0LFxuICAgIGhlaWdodDogTWF0aC5tYXgocDEueSwgcDIueSwgcDMueSwgcDQueSkgLSB0b3BcbiAgfTtcbn0sXG4gICAgX3BhcnNlSW5lcnRpYSA9IGZ1bmN0aW9uIF9wYXJzZUluZXJ0aWEoZHJhZ2dhYmxlLCBzbmFwLCBtYXgsIG1pbiwgZmFjdG9yLCBmb3JjZVplcm9WZWxvY2l0eSkge1xuICB2YXIgdmFycyA9IHt9LFxuICAgICAgYSxcbiAgICAgIGksXG4gICAgICBsO1xuXG4gIGlmIChzbmFwKSB7XG4gICAgaWYgKGZhY3RvciAhPT0gMSAmJiBzbmFwIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIC8vc29tZSBkYXRhIG11c3QgYmUgYWx0ZXJlZCB0byBtYWtlIHNlbnNlLCBsaWtlIGlmIHRoZSB1c2VyIHBhc3NlcyBpbiBhbiBhcnJheSBvZiByb3RhdGlvbmFsIHZhbHVlcyBpbiBkZWdyZWVzLCB3ZSBtdXN0IGNvbnZlcnQgaXQgdG8gcmFkaWFucy4gT3IgZm9yIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCwgd2UgaW52ZXJ0IHRoZSB2YWx1ZXMuXG4gICAgICB2YXJzLmVuZCA9IGEgPSBbXTtcbiAgICAgIGwgPSBzbmFwLmxlbmd0aDtcblxuICAgICAgaWYgKF9pc09iamVjdChzbmFwWzBdKSkge1xuICAgICAgICAvL2lmIHRoZSBhcnJheSBpcyBwb3B1bGF0ZWQgd2l0aCBvYmplY3RzLCBsaWtlIHBvaW50cyAoe3g6MTAwLCB5OjIwMH0pLCBtYWtlIGNvcGllcyBiZWZvcmUgbXVsdGlwbHlpbmcgYnkgdGhlIGZhY3Rvciwgb3RoZXJ3aXNlIHdlJ2xsIG1lc3MgdXAgdGhlIG9yaWdpbmFscyBhbmQgdGhlIHVzZXIgbWF5IHJldXNlIGl0IGVsc2V3aGVyZS5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGFbaV0gPSBfY29weShzbmFwW2ldLCBmYWN0b3IpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgYVtpXSA9IHNuYXBbaV0gKiBmYWN0b3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWF4ICs9IDEuMTsgLy9hbGxvdyAxLjEgcGl4ZWxzIG9mIHdpZ2dsZSByb29tIHdoZW4gc25hcHBpbmcgaW4gb3JkZXIgdG8gd29yayBhcm91bmQgc29tZSBicm93c2VyIGluY29uc2lzdGVuY2llcyBpbiB0aGUgd2F5IGJvdW5kcyBhcmUgcmVwb3J0ZWQgd2hpY2ggY2FuIG1ha2UgdGhlbSByb3VnaGx5IGEgcGl4ZWwgb2ZmLiBGb3IgZXhhbXBsZSwgaWYgXCJzbmFwOlstJCgnI21lbnUnKS53aWR0aCgpLCAwXVwiIHdhcyBkZWZpbmVkIGFuZCAjbWVudSBoYWQgYSB3cmFwcGVyIHRoYXQgd2FzIHVzZWQgYXMgdGhlIGJvdW5kcywgc29tZSBicm93c2VycyB3b3VsZCBiZSBvbmUgcGl4ZWwgb2ZmLCBtYWtpbmcgdGhlIG1pbmltdW0gLTc1MiBmb3IgZXhhbXBsZSB3aGVuIHNuYXAgd2FzIFstNzUzLDBdLCB0aHVzIGluc3RlYWQgb2Ygc25hcHBpbmcgdG8gLTc1MywgaXQgd291bGQgc25hcCB0byAwIHNpbmNlIC03NTMgd2FzIGJlbG93IHRoZSBtaW5pbXVtLlxuXG4gICAgICBtaW4gLT0gMS4xO1xuICAgIH0gZWxzZSBpZiAoX2lzRnVuY3Rpb24oc25hcCkpIHtcbiAgICAgIHZhcnMuZW5kID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBzbmFwLmNhbGwoZHJhZ2dhYmxlLCB2YWx1ZSksXG4gICAgICAgICAgICBjb3B5LFxuICAgICAgICAgICAgcDtcblxuICAgICAgICBpZiAoZmFjdG9yICE9PSAxKSB7XG4gICAgICAgICAgaWYgKF9pc09iamVjdChyZXN1bHQpKSB7XG4gICAgICAgICAgICBjb3B5ID0ge307XG5cbiAgICAgICAgICAgIGZvciAocCBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgY29weVtwXSA9IHJlc3VsdFtwXSAqIGZhY3RvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gY29weTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICo9IGZhY3RvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0OyAvL3dlIG5lZWQgdG8gZW5zdXJlIHRoYXQgd2UgY2FuIHNjb3BlIHRoZSBmdW5jdGlvbiBjYWxsIHRvIHRoZSBEcmFnZ2FibGUgaW5zdGFuY2UgaXRzZWxmIHNvIHRoYXQgdXNlcnMgY2FuIGFjY2VzcyBpbXBvcnRhbnQgdmFsdWVzIGxpa2UgbWF4WCwgbWluWCwgbWF4WSwgbWluWSwgeCwgYW5kIHkgZnJvbSB3aXRoaW4gdGhhdCBmdW5jdGlvbi5cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhcnMuZW5kID0gc25hcDtcbiAgICB9XG4gIH1cblxuICBpZiAobWF4IHx8IG1heCA9PT0gMCkge1xuICAgIHZhcnMubWF4ID0gbWF4O1xuICB9XG5cbiAgaWYgKG1pbiB8fCBtaW4gPT09IDApIHtcbiAgICB2YXJzLm1pbiA9IG1pbjtcbiAgfVxuXG4gIGlmIChmb3JjZVplcm9WZWxvY2l0eSkge1xuICAgIHZhcnMudmVsb2NpdHkgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHZhcnM7XG59LFxuICAgIF9pc0NsaWNrYWJsZSA9IGZ1bmN0aW9uIF9pc0NsaWNrYWJsZShlbGVtZW50KSB7XG4gIC8vc29tZXRpbWVzIGl0J3MgY29udmVuaWVudCB0byBtYXJrIGFuIGVsZW1lbnQgYXMgY2xpY2thYmxlIGJ5IGFkZGluZyBhIGRhdGEtY2xpY2thYmxlPVwidHJ1ZVwiIGF0dHJpYnV0ZSAoaW4gd2hpY2ggY2FzZSB3ZSB3b24ndCBwcmV2ZW50RGVmYXVsdCgpIHRoZSBtb3VzZS90b3VjaCBldmVudCkuIFRoaXMgbWV0aG9kIGNoZWNrcyBpZiB0aGUgZWxlbWVudCBpcyBhbiA8YT4sIDxpbnB1dD4sIG9yIDxidXR0b24+IG9yIGhhcyB0aGUgZGF0YS1jbGlja2FibGUgb3IgY29udGVudEVkaXRhYmxlIGF0dHJpYnV0ZSBzZXQgdG8gdHJ1ZSAob3IgYW55IG9mIGl0cyBwYXJlbnQgZWxlbWVudHMpLlxuICB2YXIgZGF0YTtcbiAgcmV0dXJuICFlbGVtZW50IHx8ICFlbGVtZW50LmdldEF0dHJpYnV0ZSB8fCBlbGVtZW50ID09PSBfYm9keSA/IGZhbHNlIDogKGRhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY2xpY2thYmxlXCIpKSA9PT0gXCJ0cnVlXCIgfHwgZGF0YSAhPT0gXCJmYWxzZVwiICYmIChfY2xpY2thYmxlVGFnRXhwLnRlc3QoZWxlbWVudC5ub2RlTmFtZSArIFwiXCIpIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIpID09PSBcInRydWVcIikgPyB0cnVlIDogX2lzQ2xpY2thYmxlKGVsZW1lbnQucGFyZW50Tm9kZSk7XG59LFxuICAgIF9zZXRTZWxlY3RhYmxlID0gZnVuY3Rpb24gX3NldFNlbGVjdGFibGUoZWxlbWVudHMsIHNlbGVjdGFibGUpIHtcbiAgdmFyIGkgPSBlbGVtZW50cy5sZW5ndGgsXG4gICAgICBlO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBlID0gZWxlbWVudHNbaV07XG4gICAgZS5vbmRyYWdzdGFydCA9IGUub25zZWxlY3RzdGFydCA9IHNlbGVjdGFibGUgPyBudWxsIDogX2VtcHR5RnVuYztcbiAgICBnc2FwLnNldChlLCB7XG4gICAgICBsYXp5OiB0cnVlLFxuICAgICAgdXNlclNlbGVjdDogc2VsZWN0YWJsZSA/IFwidGV4dFwiIDogXCJub25lXCJcbiAgICB9KTtcbiAgfVxufSxcbiAgICBfaXNGaXhlZCA9IGZ1bmN0aW9uIF9pc0ZpeGVkKGVsZW1lbnQpIHtcbiAgaWYgKF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSBcImZpeGVkXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIC8vIGF2b2lkIGRvY3VtZW50IGZyYWdtZW50cyB3aGljaCB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIHJldHVybiBfaXNGaXhlZChlbGVtZW50KTtcbiAgfVxufSxcbiAgICBfc3VwcG9ydHMzRCxcbiAgICBfYWRkUGFkZGluZ0JSLFxuICAgIC8vVGhlIFNjcm9sbFByb3h5IGNsYXNzIHdyYXBzIGFuIGVsZW1lbnQncyBjb250ZW50cyBpbnRvIGFub3RoZXIgZGl2ICh3ZSBjYWxsIGl0IFwiY29udGVudFwiKSB0aGF0IHdlIGVpdGhlciBhZGQgcGFkZGluZyB3aGVuIG5lY2Vzc2FyeSBvciBhcHBseSBhIHRyYW5zbGF0ZTNkKCkgdHJhbnNmb3JtIGluIG9yZGVyIHRvIG92ZXJzY3JvbGwgKHNjcm9sbCBwYXN0IHRoZSBib3VuZGFyaWVzKS4gVGhpcyBhbGxvd3MgdXMgdG8gc2ltcGx5IHNldCB0aGUgc2Nyb2xsVG9wL3Njcm9sbExlZnQgKG9yIHRvcC9sZWZ0IGZvciBlYXNpZXIgcmV2ZXJzZS1heGlzIG9yaWVudGF0aW9uLCB3aGljaCBpcyB3aGF0IHdlIGRvIGluIERyYWdnYWJsZSkgYW5kIGl0J2xsIGRvIGFsbCB0aGUgd29yayBmb3IgdXMuIEZvciBleGFtcGxlLCBpZiB3ZSB0cmllZCBzZXR0aW5nIHNjcm9sbFRvcCB0byAtMTAwIG9uIGEgbm9ybWFsIERPTSBlbGVtZW50LCBpdCB3b3VsZG4ndCB3b3JrIC0gaXQnZCBsb29rIHRoZSBzYW1lIGFzIHNldHRpbmcgaXQgdG8gMCwgYnV0IGlmIHdlIHNldCBzY3JvbGxUb3Agb2YgYSBTY3JvbGxQcm94eSB0byAtMTAwLCBpdCdsbCBnaXZlIHRoZSBjb3JyZWN0IGFwcGVhcmFuY2UgYnkgZWl0aGVyIHNldHRpbmcgcGFkZGluZ1RvcCBvZiB0aGUgd3JhcHBlciB0byAxMDAgb3IgYXBwbHlpbmcgYSAxMDAtcGl4ZWwgdHJhbnNsYXRlWS5cblNjcm9sbFByb3h5ID0gZnVuY3Rpb24gU2Nyb2xsUHJveHkoZWxlbWVudCwgdmFycykge1xuICBlbGVtZW50ID0gZ3NhcC51dGlscy50b0FycmF5KGVsZW1lbnQpWzBdO1xuICB2YXJzID0gdmFycyB8fCB7fTtcbiAgdmFyIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgc3R5bGUgPSBjb250ZW50LnN0eWxlLFxuICAgICAgbm9kZSA9IGVsZW1lbnQuZmlyc3RDaGlsZCxcbiAgICAgIG9mZnNldFRvcCA9IDAsXG4gICAgICBvZmZzZXRMZWZ0ID0gMCxcbiAgICAgIHByZXZUb3AgPSBlbGVtZW50LnNjcm9sbFRvcCxcbiAgICAgIHByZXZMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsV2lkdGggPSBlbGVtZW50LnNjcm9sbFdpZHRoLFxuICAgICAgc2Nyb2xsSGVpZ2h0ID0gZWxlbWVudC5zY3JvbGxIZWlnaHQsXG4gICAgICBleHRyYVBhZFJpZ2h0ID0gMCxcbiAgICAgIG1heExlZnQgPSAwLFxuICAgICAgbWF4VG9wID0gMCxcbiAgICAgIGVsZW1lbnRXaWR0aCxcbiAgICAgIGVsZW1lbnRIZWlnaHQsXG4gICAgICBjb250ZW50SGVpZ2h0LFxuICAgICAgbmV4dE5vZGUsXG4gICAgICB0cmFuc2Zvcm1TdGFydCxcbiAgICAgIHRyYW5zZm9ybUVuZDtcblxuICBpZiAoX3N1cHBvcnRzM0QgJiYgdmFycy5mb3JjZTNEICE9PSBmYWxzZSkge1xuICAgIHRyYW5zZm9ybVN0YXJ0ID0gXCJ0cmFuc2xhdGUzZChcIjtcbiAgICB0cmFuc2Zvcm1FbmQgPSBcInB4LDBweClcIjtcbiAgfSBlbHNlIGlmIChfdHJhbnNmb3JtUHJvcCkge1xuICAgIHRyYW5zZm9ybVN0YXJ0ID0gXCJ0cmFuc2xhdGUoXCI7XG4gICAgdHJhbnNmb3JtRW5kID0gXCJweClcIjtcbiAgfVxuXG4gIHRoaXMuc2Nyb2xsVG9wID0gZnVuY3Rpb24gKHZhbHVlLCBmb3JjZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC10aGlzLnRvcCgpO1xuICAgIH1cblxuICAgIHRoaXMudG9wKC12YWx1ZSwgZm9yY2UpO1xuICB9O1xuXG4gIHRoaXMuc2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9yY2UpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtdGhpcy5sZWZ0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5sZWZ0KC12YWx1ZSwgZm9yY2UpO1xuICB9O1xuXG4gIHRoaXMubGVmdCA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9yY2UpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtKGVsZW1lbnQuc2Nyb2xsTGVmdCArIG9mZnNldExlZnQpO1xuICAgIH1cblxuICAgIHZhciBkaWYgPSBlbGVtZW50LnNjcm9sbExlZnQgLSBwcmV2TGVmdCxcbiAgICAgICAgb2xkT2Zmc2V0ID0gb2Zmc2V0TGVmdDtcblxuICAgIGlmICgoZGlmID4gMiB8fCBkaWYgPCAtMikgJiYgIWZvcmNlKSB7XG4gICAgICAvL2lmIHRoZSB1c2VyIGludGVyYWN0cyB3aXRoIHRoZSBzY3JvbGxiYXIgKG9yIHNvbWV0aGluZyBlbHNlIHNjcm9sbHMgaXQsIGxpa2UgdGhlIG1vdXNlIHdoZWVsKSwgd2Ugc2hvdWxkIGtpbGwgYW55IHR3ZWVucyBvZiB0aGUgU2Nyb2xsUHJveHkuXG4gICAgICBwcmV2TGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgIGdzYXAua2lsbFR3ZWVuc09mKHRoaXMsIHtcbiAgICAgICAgbGVmdDogMSxcbiAgICAgICAgc2Nyb2xsTGVmdDogMVxuICAgICAgfSk7XG4gICAgICB0aGlzLmxlZnQoLXByZXZMZWZ0KTtcblxuICAgICAgaWYgKHZhcnMub25LaWxsKSB7XG4gICAgICAgIHZhcnMub25LaWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IC12YWx1ZTsgLy9pbnZlcnQgYmVjYXVzZSBzY3JvbGxpbmcgd29ya3MgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuXG4gICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgb2Zmc2V0TGVmdCA9IHZhbHVlIC0gMC41IHwgMDtcbiAgICAgIHZhbHVlID0gMDtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID4gbWF4TGVmdCkge1xuICAgICAgb2Zmc2V0TGVmdCA9IHZhbHVlIC0gbWF4TGVmdCB8IDA7XG4gICAgICB2YWx1ZSA9IG1heExlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldExlZnQgPSAwO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXRMZWZ0IHx8IG9sZE9mZnNldCkge1xuICAgICAgaWYgKCF0aGlzLl9za2lwKSB7XG4gICAgICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybVN0YXJ0ICsgLW9mZnNldExlZnQgKyBcInB4LFwiICsgLW9mZnNldFRvcCArIHRyYW5zZm9ybUVuZDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9mZnNldExlZnQgKyBleHRyYVBhZFJpZ2h0ID49IDApIHtcbiAgICAgICAgc3R5bGUucGFkZGluZ1JpZ2h0ID0gb2Zmc2V0TGVmdCArIGV4dHJhUGFkUmlnaHQgKyBcInB4XCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gdmFsdWUgfCAwO1xuICAgIHByZXZMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0OyAvL2Rvbid0IG1lcmdlIHRoaXMgd2l0aCB0aGUgbGluZSBhYm92ZSBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgYWRqdXN0IHRoZSBzY3JvbGxMZWZ0IGFmdGVyIGl0J3Mgc2V0LCBzbyBpbiBvcmRlciB0byBiZSAxMDAlIGFjY3VyYXRlIGluIHRyYWNraW5nIGl0LCB3ZSBuZWVkIHRvIGFzayB0aGUgYnJvd3NlciB0byByZXBvcnQgaXQuXG4gIH07XG5cbiAgdGhpcy50b3AgPSBmdW5jdGlvbiAodmFsdWUsIGZvcmNlKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLShlbGVtZW50LnNjcm9sbFRvcCArIG9mZnNldFRvcCk7XG4gICAgfVxuXG4gICAgdmFyIGRpZiA9IGVsZW1lbnQuc2Nyb2xsVG9wIC0gcHJldlRvcCxcbiAgICAgICAgb2xkT2Zmc2V0ID0gb2Zmc2V0VG9wO1xuXG4gICAgaWYgKChkaWYgPiAyIHx8IGRpZiA8IC0yKSAmJiAhZm9yY2UpIHtcbiAgICAgIC8vaWYgdGhlIHVzZXIgaW50ZXJhY3RzIHdpdGggdGhlIHNjcm9sbGJhciAob3Igc29tZXRoaW5nIGVsc2Ugc2Nyb2xscyBpdCwgbGlrZSB0aGUgbW91c2Ugd2hlZWwpLCB3ZSBzaG91bGQga2lsbCBhbnkgdHdlZW5zIG9mIHRoZSBTY3JvbGxQcm94eS5cbiAgICAgIHByZXZUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgIGdzYXAua2lsbFR3ZWVuc09mKHRoaXMsIHtcbiAgICAgICAgdG9wOiAxLFxuICAgICAgICBzY3JvbGxUb3A6IDFcbiAgICAgIH0pO1xuICAgICAgdGhpcy50b3AoLXByZXZUb3ApO1xuXG4gICAgICBpZiAodmFycy5vbktpbGwpIHtcbiAgICAgICAgdmFycy5vbktpbGwoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhbHVlID0gLXZhbHVlOyAvL2ludmVydCBiZWNhdXNlIHNjcm9sbGluZyB3b3JrcyBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG5cbiAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICBvZmZzZXRUb3AgPSB2YWx1ZSAtIDAuNSB8IDA7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA+IG1heFRvcCkge1xuICAgICAgb2Zmc2V0VG9wID0gdmFsdWUgLSBtYXhUb3AgfCAwO1xuICAgICAgdmFsdWUgPSBtYXhUb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldFRvcCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldFRvcCB8fCBvbGRPZmZzZXQpIHtcbiAgICAgIGlmICghdGhpcy5fc2tpcCkge1xuICAgICAgICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1TdGFydCArIC1vZmZzZXRMZWZ0ICsgXCJweCxcIiArIC1vZmZzZXRUb3AgKyB0cmFuc2Zvcm1FbmQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxlbWVudC5zY3JvbGxUb3AgPSB2YWx1ZSB8IDA7XG4gICAgcHJldlRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICB9O1xuXG4gIHRoaXMubWF4U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtYXhUb3A7XG4gIH07XG5cbiAgdGhpcy5tYXhTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtYXhMZWZ0O1xuICB9O1xuXG4gIHRoaXMuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBub2RlID0gY29udGVudC5maXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICBub2RlID0gbmV4dE5vZGU7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQgPT09IGNvbnRlbnQucGFyZW50Tm9kZSkge1xuICAgICAgLy9pbiBjYXNlIGRpc2FibGUoKSBpcyBjYWxsZWQgd2hlbiBpdCdzIGFscmVhZHkgZGlzYWJsZWQuXG4gICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGNvbnRlbnQpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBub2RlID0gZWxlbWVudC5maXJzdENoaWxkO1xuXG4gICAgaWYgKG5vZGUgPT09IGNvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgbmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgY29udGVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgICB9XG5cbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIHRoaXMuY2FsaWJyYXRlKCk7XG4gIH07XG5cbiAgdGhpcy5jYWxpYnJhdGUgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICB2YXIgd2lkdGhNYXRjaGVzID0gZWxlbWVudC5jbGllbnRXaWR0aCA9PT0gZWxlbWVudFdpZHRoLFxuICAgICAgICBjcyxcbiAgICAgICAgeCxcbiAgICAgICAgeTtcbiAgICBwcmV2VG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgcHJldkxlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XG5cbiAgICBpZiAod2lkdGhNYXRjaGVzICYmIGVsZW1lbnQuY2xpZW50SGVpZ2h0ID09PSBlbGVtZW50SGVpZ2h0ICYmIGNvbnRlbnQub2Zmc2V0SGVpZ2h0ID09PSBjb250ZW50SGVpZ2h0ICYmIHNjcm9sbFdpZHRoID09PSBlbGVtZW50LnNjcm9sbFdpZHRoICYmIHNjcm9sbEhlaWdodCA9PT0gZWxlbWVudC5zY3JvbGxIZWlnaHQgJiYgIWZvcmNlKSB7XG4gICAgICByZXR1cm47IC8vbm8gbmVlZCB0byByZWNhbGN1bGF0ZSB0aGluZ3MgaWYgdGhlIHdpZHRoIGFuZCBoZWlnaHQgaGF2ZW4ndCBjaGFuZ2VkLlxuICAgIH1cblxuICAgIGlmIChvZmZzZXRUb3AgfHwgb2Zmc2V0TGVmdCkge1xuICAgICAgeCA9IHRoaXMubGVmdCgpO1xuICAgICAgeSA9IHRoaXMudG9wKCk7XG4gICAgICB0aGlzLmxlZnQoLWVsZW1lbnQuc2Nyb2xsTGVmdCk7XG4gICAgICB0aGlzLnRvcCgtZWxlbWVudC5zY3JvbGxUb3ApO1xuICAgIH1cblxuICAgIGNzID0gX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7IC8vZmlyc3QsIHdlIG5lZWQgdG8gcmVtb3ZlIGFueSB3aWR0aCBjb25zdHJhaW50cyB0byBzZWUgaG93IHRoZSBjb250ZW50IG5hdHVyYWxseSBmbG93cyBzbyB0aGF0IHdlIGNhbiBzZWUgaWYgaXQncyB3aWRlciB0aGFuIHRoZSBjb250YWluaW5nIGVsZW1lbnQuIElmIHNvLCB3ZSd2ZSBnb3QgdG8gcmVjb3JkIHRoZSBhbW91bnQgb2Ygb3ZlcmFnZSBzbyB0aGF0IHdlIGNhbiBhcHBseSB0aGF0IGFzIHBhZGRpbmcgaW4gb3JkZXIgZm9yIGJyb3dzZXJzIHRvIGNvcnJlY3RseSBoYW5kbGUgdGhpbmdzLiBUaGVuIHdlIHN3aXRjaCBiYWNrIHRvIGEgd2lkdGggb2YgMTAwJSAod2l0aG91dCB0aGF0LCBzb21lIGJyb3dzZXJzIGRvbid0IGZsb3cgdGhlIGNvbnRlbnQgY29ycmVjdGx5KVxuXG4gICAgaWYgKCF3aWR0aE1hdGNoZXMgfHwgZm9yY2UpIHtcbiAgICAgIHN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBzdHlsZS53aWR0aCA9IFwiYXV0b1wiO1xuICAgICAgc3R5bGUucGFkZGluZ1JpZ2h0ID0gXCIwcHhcIjtcbiAgICAgIGV4dHJhUGFkUmlnaHQgPSBNYXRoLm1heCgwLCBlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudC5jbGllbnRXaWR0aCk7IC8vaWYgdGhlIGNvbnRlbnQgaXMgd2lkZXIgdGhhbiB0aGUgY29udGFpbmVyLCB3ZSBuZWVkIHRvIGFkZCB0aGUgcGFkZGluZ0xlZnQgYW5kIHBhZGRpbmdSaWdodCBpbiBvcmRlciBmb3IgdGhpbmdzIHRvIGJlaGF2ZSBjb3JyZWN0bHkuXG5cbiAgICAgIGlmIChleHRyYVBhZFJpZ2h0KSB7XG4gICAgICAgIGV4dHJhUGFkUmlnaHQgKz0gcGFyc2VGbG9hdChjcy5wYWRkaW5nTGVmdCkgKyAoX2FkZFBhZGRpbmdCUiA/IHBhcnNlRmxvYXQoY3MucGFkZGluZ1JpZ2h0KSA6IDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgIHN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgIHN0eWxlLm92ZXJmbG93ID0gXCJ2aXNpYmxlXCI7XG4gICAgc3R5bGUudmVydGljYWxBbGlnbiA9IFwidG9wXCI7XG4gICAgc3R5bGUuYm94U2l6aW5nID0gXCJjb250ZW50LWJveFwiO1xuICAgIHN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgc3R5bGUucGFkZGluZ1JpZ2h0ID0gZXh0cmFQYWRSaWdodCArIFwicHhcIjsgLy9zb21lIGJyb3dzZXJzIG5lZ2xlY3QgdG8gZmFjdG9yIGluIHRoZSBib3R0b20gcGFkZGluZyB3aGVuIGNhbGN1bGF0aW5nIHRoZSBzY3JvbGxIZWlnaHQsIHNvIHdlIG5lZWQgdG8gYWRkIHRoYXQgcGFkZGluZyB0byB0aGUgY29udGVudCB3aGVuIHRoYXQgaGFwcGVucy4gQWxsb3cgYSAycHggbWFyZ2luIGZvciBlcnJvclxuXG4gICAgaWYgKF9hZGRQYWRkaW5nQlIpIHtcbiAgICAgIHN0eWxlLnBhZGRpbmdCb3R0b20gPSBjcy5wYWRkaW5nQm90dG9tO1xuICAgIH1cblxuICAgIGVsZW1lbnRXaWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgZWxlbWVudEhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIHNjcm9sbFdpZHRoID0gZWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICBzY3JvbGxIZWlnaHQgPSBlbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgICBtYXhMZWZ0ID0gZWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnRXaWR0aDtcbiAgICBtYXhUb3AgPSBlbGVtZW50LnNjcm9sbEhlaWdodCAtIGVsZW1lbnRIZWlnaHQ7XG4gICAgY29udGVudEhlaWdodCA9IGNvbnRlbnQub2Zmc2V0SGVpZ2h0O1xuICAgIHN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cbiAgICBpZiAoeCB8fCB5KSB7XG4gICAgICB0aGlzLmxlZnQoeCk7XG4gICAgICB0aGlzLnRvcCh5KTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgdGhpcy5fc2tpcCA9IGZhbHNlO1xuICB0aGlzLmVuYWJsZSgpO1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUocmVxdWlyZWQpIHtcbiAgaWYgKF93aW5kb3dFeGlzdHMoKSAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgdmFyIG5hdiA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xuICAgIF93aW4gPSB3aW5kb3c7XG4gICAgX2RvYyA9IGRvY3VtZW50O1xuICAgIF9kb2NFbGVtZW50ID0gX2RvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgX2JvZHkgPSBfZG9jLmJvZHk7XG4gICAgX3RlbXBEaXYgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBfc3VwcG9ydHNQb2ludGVyID0gISF3aW5kb3cuUG9pbnRlckV2ZW50O1xuICAgIF9wbGFjZWhvbGRlckRpdiA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIF9wbGFjZWhvbGRlckRpdi5zdHlsZS5jc3NUZXh0ID0gXCJ2aXNpYmlsaXR5OmhpZGRlbjtoZWlnaHQ6MXB4O3RvcDotMXB4O3BvaW50ZXItZXZlbnRzOm5vbmU7cG9zaXRpb246cmVsYXRpdmU7Y2xlYXI6Ym90aDtjdXJzb3I6Z3JhYlwiO1xuICAgIF9kZWZhdWx0Q3Vyc29yID0gX3BsYWNlaG9sZGVyRGl2LnN0eWxlLmN1cnNvciA9PT0gXCJncmFiXCIgPyBcImdyYWJcIiA6IFwibW92ZVwiO1xuICAgIF9pc0FuZHJvaWQgPSBuYXYgJiYgbmF2LnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJhbmRyb2lkXCIpICE9PSAtMTsgLy9BbmRyb2lkIGhhbmRsZXMgdG91Y2ggZXZlbnRzIGluIGFuIG9kZCB3YXkgYW5kIGl0J3MgdmlydHVhbGx5IGltcG9zc2libGUgdG8gXCJmZWF0dXJlIHRlc3RcIiBzbyB3ZSByZXNvcnQgdG8gVUEgc25pZmZpbmdcblxuICAgIF9pc1RvdWNoRGV2aWNlID0gXCJvbnRvdWNoc3RhcnRcIiBpbiBfZG9jRWxlbWVudCAmJiBcIm9yaWVudGF0aW9uXCIgaW4gX3dpbiB8fCBuYXYgJiYgKG5hdi5NYXhUb3VjaFBvaW50cyA+IDAgfHwgbmF2Lm1zTWF4VG91Y2hQb2ludHMgPiAwKTtcblxuICAgIF9hZGRQYWRkaW5nQlIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvL3RoaXMgZnVuY3Rpb24gaXMgaW4gY2hhcmdlIG9mIGFuYWx5emluZyBicm93c2VyIGJlaGF2aW9yIHJlbGF0ZWQgdG8gcGFkZGluZy4gSXQgc2V0cyB0aGUgX2FkZFBhZGRpbmdCUiB0byB0cnVlIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgbm9ybWFsbHkgZmFjdG9yIGluIHRoZSBib3R0b20gb3IgcmlnaHQgcGFkZGluZyBvbiB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIHNjcm9sbGluZyBhcmVhLCBhbmQgaXQgc2V0cyBfYWRkUGFkZGluZ0xlZnQgdG8gdHJ1ZSBpZiBpdCdzIGEgYnJvd3NlciB0aGF0IHJlcXVpcmVzIHRoZSBleHRyYSBvZmZzZXQgKG9mZnNldExlZnQpIHRvIGJlIGFkZGVkIHRvIHRoZSBwYWRkaW5nUmlnaHQgKGxpa2UgT3BlcmEpLlxuICAgICAgdmFyIGRpdiA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICAgIGNoaWxkID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgY2hpbGRTdHlsZSA9IGNoaWxkLnN0eWxlLFxuICAgICAgICAgIHBhcmVudCA9IF9ib2R5LFxuICAgICAgICAgIHZhbDtcblxuICAgICAgY2hpbGRTdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgIGNoaWxkU3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICBkaXYuc3R5bGUuY3NzVGV4dCA9IFwid2lkdGg6OTBweDtoZWlnaHQ6NDBweDtwYWRkaW5nOjEwcHg7b3ZlcmZsb3c6YXV0bzt2aXNpYmlsaXR5OmhpZGRlblwiO1xuICAgICAgZGl2LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgdmFsID0gY2hpbGQub2Zmc2V0SGVpZ2h0ICsgMTggPiBkaXYuc2Nyb2xsSGVpZ2h0OyAvL2Rpdi5zY3JvbGxIZWlnaHQgc2hvdWxkIGJlIGNoaWxkLm9mZnNldEhlaWdodCArIDIwIGJlY2F1c2Ugb2YgdGhlIDEwcHggb2YgcGFkZGluZyBvbiBlYWNoIHNpZGUsIGJ1dCBzb21lIGJyb3dzZXJzIGlnbm9yZSBvbmUgc2lkZS4gV2UgYWxsb3cgYSAycHggbWFyZ2luIG9mIGVycm9yLlxuXG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSgpO1xuXG4gICAgX3RvdWNoRXZlbnRMb29rdXAgPSBmdW5jdGlvbiAodHlwZXMpIHtcbiAgICAgIC8vd2UgY3JlYXRlIGFuIG9iamVjdCB0aGF0IG1ha2VzIGl0IGVhc3kgdG8gdHJhbnNsYXRlIHRvdWNoIGV2ZW50IHR5cGVzIGludG8gdGhlaXIgXCJwb2ludGVyXCIgY291bnRlcnBhcnRzIGlmIHdlJ3JlIGluIGEgYnJvd3NlciB0aGF0IHVzZXMgdGhvc2UgaW5zdGVhZC4gTGlrZSBJRTEwIHVzZXMgXCJNU1BvaW50ZXJEb3duXCIgaW5zdGVhZCBvZiBcInRvdWNoc3RhcnRcIiwgZm9yIGV4YW1wbGUuXG4gICAgICB2YXIgc3RhbmRhcmQgPSB0eXBlcy5zcGxpdChcIixcIiksXG4gICAgICAgICAgY29udmVydGVkID0gKFwib25wb2ludGVyZG93blwiIGluIF90ZW1wRGl2ID8gXCJwb2ludGVyZG93bixwb2ludGVybW92ZSxwb2ludGVydXAscG9pbnRlcmNhbmNlbFwiIDogXCJvbm1zcG9pbnRlcmRvd25cIiBpbiBfdGVtcERpdiA/IFwiTVNQb2ludGVyRG93bixNU1BvaW50ZXJNb3ZlLE1TUG9pbnRlclVwLE1TUG9pbnRlckNhbmNlbFwiIDogdHlwZXMpLnNwbGl0KFwiLFwiKSxcbiAgICAgICAgICBvYmogPSB7fSxcbiAgICAgICAgICBpID0gNDtcblxuICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICAgIG9ialtzdGFuZGFyZFtpXV0gPSBjb252ZXJ0ZWRbaV07XG4gICAgICAgIG9ialtjb252ZXJ0ZWRbaV1dID0gc3RhbmRhcmRbaV07XG4gICAgICB9IC8vdG8gYXZvaWQgcHJvYmxlbXMgaW4gaU9TIDksIHRlc3QgdG8gc2VlIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBcInBhc3NpdmVcIiBvcHRpb24gb24gYWRkRXZlbnRMaXN0ZW5lcigpLlxuXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIF9kb2NFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsIG51bGwsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJwYXNzaXZlXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIF9zdXBwb3J0c1Bhc3NpdmUgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9KFwidG91Y2hzdGFydCx0b3VjaG1vdmUsdG91Y2hlbmQsdG91Y2hjYW5jZWxcIik7XG5cbiAgICBfYWRkTGlzdGVuZXIoX2RvYywgXCJ0b3VjaGNhbmNlbFwiLCBfZW1wdHlGdW5jKTsgLy9zb21lIG9sZGVyIEFuZHJvaWQgZGV2aWNlcyBpbnRlcm1pdHRlbnRseSBzdG9wIGRpc3BhdGNoaW5nIFwidG91Y2htb3ZlXCIgZXZlbnRzIGlmIHdlIGRvbid0IGxpc3RlbiBmb3IgXCJ0b3VjaGNhbmNlbFwiIG9uIHRoZSBkb2N1bWVudC4gVmVyeSBzdHJhbmdlIGluZGVlZC5cblxuXG4gICAgX2FkZExpc3RlbmVyKF93aW4sIFwidG91Y2htb3ZlXCIsIF9lbXB0eUZ1bmMpOyAvL3dvcmtzIGFyb3VuZCBTYWZhcmkgYnVncyB0aGF0IHN0aWxsIGFsbG93IHRoZSBwYWdlIHRvIHNjcm9sbCBldmVuIHdoZW4gd2UgcHJldmVudERlZmF1bHQoKSBvbiB0aGUgdG91Y2htb3ZlIGV2ZW50LlxuXG5cbiAgICBfYm9keSAmJiBfYm9keS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBfZW1wdHlGdW5jKTsgLy93b3JrcyBhcm91bmQgU2FmYXJpIGJ1ZzogaHR0cHM6Ly9nc2FwLmNvbS9mb3J1bXMvdG9waWMvMjE0NTAtZHJhZ2dhYmxlLWluLWlmcmFtZS1vbi1tb2JpbGUtaXMtYnVnZ3kvXG5cbiAgICBfYWRkTGlzdGVuZXIoX2RvYywgXCJjb250ZXh0bWVudVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBwIGluIF9sb29rdXApIHtcbiAgICAgICAgaWYgKF9sb29rdXBbcF0uaXNQcmVzc2VkKSB7XG4gICAgICAgICAgX2xvb2t1cFtwXS5lbmREcmFnKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGdzYXAgPSBfY29yZUluaXR0ZWQgPSBfZ2V0R1NBUCgpO1xuICB9XG5cbiAgaWYgKGdzYXApIHtcbiAgICBJbmVydGlhUGx1Z2luID0gZ3NhcC5wbHVnaW5zLmluZXJ0aWE7XG5cbiAgICBfY29udGV4dCA9IGdzYXAuY29yZS5jb250ZXh0IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgX2NoZWNrUHJlZml4ID0gZ3NhcC51dGlscy5jaGVja1ByZWZpeDtcbiAgICBfdHJhbnNmb3JtUHJvcCA9IF9jaGVja1ByZWZpeChfdHJhbnNmb3JtUHJvcCk7XG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfY2hlY2tQcmVmaXgoX3RyYW5zZm9ybU9yaWdpblByb3ApO1xuICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgIF9nZXRTdHlsZVNhdmVyID0gZ3NhcC5jb3JlLmdldFN0eWxlU2F2ZXI7XG4gICAgX3N1cHBvcnRzM0QgPSAhIV9jaGVja1ByZWZpeChcInBlcnNwZWN0aXZlXCIpO1xuICB9IGVsc2UgaWYgKHJlcXVpcmVkKSB7XG4gICAgY29uc29sZS53YXJuKFwiUGxlYXNlIGdzYXAucmVnaXN0ZXJQbHVnaW4oRHJhZ2dhYmxlKVwiKTtcbiAgfVxufTtcblxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcih0YXJnZXQpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldCB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0gfHwgKHRoaXMuX2xpc3RlbmVyc1t0eXBlXSA9IFtdKTtcblxuICAgIGlmICghfmxpc3QuaW5kZXhPZihjYWxsYmFjaykpIHtcbiAgICAgIGxpc3QucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaykge1xuICAgIHZhciBsaXN0ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdLFxuICAgICAgICBpID0gbGlzdCAmJiBsaXN0LmluZGV4T2YoY2FsbGJhY2spO1xuICAgIGkgPj0gMCAmJiBsaXN0LnNwbGljZShpLCAxKTtcbiAgfTtcblxuICBfcHJvdG8uZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodHlwZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgcmVzdWx0O1xuICAgICh0aGlzLl9saXN0ZW5lcnNbdHlwZV0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChfdGhpcywge1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB0YXJnZXQ6IF90aGlzLnRhcmdldFxuICAgICAgfSkgPT09IGZhbHNlICYmIChyZXN1bHQgPSBmYWxzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDsgLy9pZiBhbnkgb2YgdGhlIGNhbGxiYWNrcyByZXR1cm4gZmFsc2UsIHBhc3MgdGhhdCBhbG9uZy5cbiAgfTtcblxuICByZXR1cm4gRXZlbnREaXNwYXRjaGVyO1xufSgpO1xuXG5leHBvcnQgdmFyIERyYWdnYWJsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50RGlzcGF0Y2hlcikge1xuICBfaW5oZXJpdHNMb29zZShEcmFnZ2FibGUsIF9FdmVudERpc3BhdGNoZXIpO1xuXG4gIGZ1bmN0aW9uIERyYWdnYWJsZSh0YXJnZXQsIHZhcnMpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgX3RoaXMyID0gX0V2ZW50RGlzcGF0Y2hlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX2NvcmVJbml0dGVkIHx8IF9pbml0Q29yZSgxKTtcbiAgICB0YXJnZXQgPSBfdG9BcnJheSh0YXJnZXQpWzBdOyAvL2luIGNhc2UgdGhlIHRhcmdldCBpcyBhIHNlbGVjdG9yIG9iamVjdCBvciBzZWxlY3RvciB0ZXh0XG5cbiAgICBfdGhpczIuc3R5bGVzID0gX2dldFN0eWxlU2F2ZXIgJiYgX2dldFN0eWxlU2F2ZXIodGFyZ2V0LCBcInRyYW5zZm9ybSxsZWZ0LHRvcFwiKTtcblxuICAgIGlmICghSW5lcnRpYVBsdWdpbikge1xuICAgICAgSW5lcnRpYVBsdWdpbiA9IGdzYXAucGx1Z2lucy5pbmVydGlhO1xuICAgIH1cblxuICAgIF90aGlzMi52YXJzID0gdmFycyA9IF9jb3B5KHZhcnMgfHwge30pO1xuICAgIF90aGlzMi50YXJnZXQgPSB0YXJnZXQ7XG4gICAgX3RoaXMyLnggPSBfdGhpczIueSA9IF90aGlzMi5yb3RhdGlvbiA9IDA7XG4gICAgX3RoaXMyLmRyYWdSZXNpc3RhbmNlID0gcGFyc2VGbG9hdCh2YXJzLmRyYWdSZXNpc3RhbmNlKSB8fCAwO1xuICAgIF90aGlzMi5lZGdlUmVzaXN0YW5jZSA9IGlzTmFOKHZhcnMuZWRnZVJlc2lzdGFuY2UpID8gMSA6IHBhcnNlRmxvYXQodmFycy5lZGdlUmVzaXN0YW5jZSkgfHwgMDtcbiAgICBfdGhpczIubG9ja0F4aXMgPSB2YXJzLmxvY2tBeGlzO1xuICAgIF90aGlzMi5hdXRvU2Nyb2xsID0gdmFycy5hdXRvU2Nyb2xsIHx8IDA7XG4gICAgX3RoaXMyLmxvY2tlZEF4aXMgPSBudWxsO1xuICAgIF90aGlzMi5hbGxvd0V2ZW50RGVmYXVsdCA9ICEhdmFycy5hbGxvd0V2ZW50RGVmYXVsdDtcbiAgICBnc2FwLmdldFByb3BlcnR5KHRhcmdldCwgXCJ4XCIpOyAvLyB0byBlbnN1cmUgdGhhdCB0cmFuc2Zvcm1zIGFyZSBpbnN0YW50aWF0ZWQuXG5cbiAgICB2YXIgdHlwZSA9ICh2YXJzLnR5cGUgfHwgXCJ4LHlcIikudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgeHlNb2RlID0gfnR5cGUuaW5kZXhPZihcInhcIikgfHwgfnR5cGUuaW5kZXhPZihcInlcIiksXG4gICAgICAgIHJvdGF0aW9uTW9kZSA9IHR5cGUuaW5kZXhPZihcInJvdGF0aW9uXCIpICE9PSAtMSxcbiAgICAgICAgeFByb3AgPSByb3RhdGlvbk1vZGUgPyBcInJvdGF0aW9uXCIgOiB4eU1vZGUgPyBcInhcIiA6IFwibGVmdFwiLFxuICAgICAgICB5UHJvcCA9IHh5TW9kZSA/IFwieVwiIDogXCJ0b3BcIixcbiAgICAgICAgYWxsb3dYID0gISEofnR5cGUuaW5kZXhPZihcInhcIikgfHwgfnR5cGUuaW5kZXhPZihcImxlZnRcIikgfHwgdHlwZSA9PT0gXCJzY3JvbGxcIiksXG4gICAgICAgIGFsbG93WSA9ICEhKH50eXBlLmluZGV4T2YoXCJ5XCIpIHx8IH50eXBlLmluZGV4T2YoXCJ0b3BcIikgfHwgdHlwZSA9PT0gXCJzY3JvbGxcIiksXG4gICAgICAgIG1pbmltdW1Nb3ZlbWVudCA9IHZhcnMubWluaW11bU1vdmVtZW50IHx8IDIsXG4gICAgICAgIHNlbGYgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMiksXG4gICAgICAgIHRyaWdnZXJzID0gX3RvQXJyYXkodmFycy50cmlnZ2VyIHx8IHZhcnMuaGFuZGxlIHx8IHRhcmdldCksXG4gICAgICAgIGtpbGxQcm9wcyA9IHt9LFxuICAgICAgICBkcmFnRW5kVGltZSA9IDAsXG4gICAgICAgIGNoZWNrQXV0b1Njcm9sbEJvdW5kcyA9IGZhbHNlLFxuICAgICAgICBhdXRvU2Nyb2xsTWFyZ2luVG9wID0gdmFycy5hdXRvU2Nyb2xsTWFyZ2luVG9wIHx8IDQwLFxuICAgICAgICBhdXRvU2Nyb2xsTWFyZ2luUmlnaHQgPSB2YXJzLmF1dG9TY3JvbGxNYXJnaW5SaWdodCB8fCA0MCxcbiAgICAgICAgYXV0b1Njcm9sbE1hcmdpbkJvdHRvbSA9IHZhcnMuYXV0b1Njcm9sbE1hcmdpbkJvdHRvbSB8fCA0MCxcbiAgICAgICAgYXV0b1Njcm9sbE1hcmdpbkxlZnQgPSB2YXJzLmF1dG9TY3JvbGxNYXJnaW5MZWZ0IHx8IDQwLFxuICAgICAgICBpc0NsaWNrYWJsZSA9IHZhcnMuY2xpY2thYmxlVGVzdCB8fCBfaXNDbGlja2FibGUsXG4gICAgICAgIGNsaWNrVGltZSA9IDAsXG4gICAgICAgIGdzQ2FjaGUgPSB0YXJnZXQuX2dzYXAgfHwgZ3NhcC5jb3JlLmdldENhY2hlKHRhcmdldCksXG4gICAgICAgIGlzRml4ZWQgPSBfaXNGaXhlZCh0YXJnZXQpLFxuICAgICAgICBnZXRQcm9wQXNOdW0gPSBmdW5jdGlvbiBnZXRQcm9wQXNOdW0ocHJvcGVydHksIHVuaXQpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KGdzQ2FjaGUuZ2V0KHRhcmdldCwgcHJvcGVydHksIHVuaXQpKTtcbiAgICB9LFxuICAgICAgICBvd25lckRvYyA9IHRhcmdldC5vd25lckRvY3VtZW50IHx8IF9kb2MsXG4gICAgICAgIGVuYWJsZWQsXG4gICAgICAgIHNjcm9sbFByb3h5LFxuICAgICAgICBzdGFydFBvaW50ZXJYLFxuICAgICAgICBzdGFydFBvaW50ZXJZLFxuICAgICAgICBzdGFydEVsZW1lbnRYLFxuICAgICAgICBzdGFydEVsZW1lbnRZLFxuICAgICAgICBoYXNCb3VuZHMsXG4gICAgICAgIGhhc0RyYWdDYWxsYmFjayxcbiAgICAgICAgaGFzTW92ZUNhbGxiYWNrLFxuICAgICAgICBtYXhYLFxuICAgICAgICBtaW5YLFxuICAgICAgICBtYXhZLFxuICAgICAgICBtaW5ZLFxuICAgICAgICB0b3VjaCxcbiAgICAgICAgdG91Y2hJRCxcbiAgICAgICAgcm90YXRpb25PcmlnaW4sXG4gICAgICAgIGRpcnR5LFxuICAgICAgICBvbGQsXG4gICAgICAgIHNuYXBYLFxuICAgICAgICBzbmFwWSxcbiAgICAgICAgc25hcFhZLFxuICAgICAgICBpc0NsaWNraW5nLFxuICAgICAgICB0b3VjaEV2ZW50VGFyZ2V0LFxuICAgICAgICBtYXRyaXgsXG4gICAgICAgIGludGVycnVwdGVkLFxuICAgICAgICBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nLFxuICAgICAgICB0b3VjaERyYWdBeGlzLFxuICAgICAgICBpc0Rpc3BhdGNoaW5nLFxuICAgICAgICBjbGlja0Rpc3BhdGNoLFxuICAgICAgICB0cnVzdGVkQ2xpY2tEaXNwYXRjaCxcbiAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCxcbiAgICAgICAgaW5uZXJNYXRyaXgsXG4gICAgICAgIGRyYWdnZWQsXG4gICAgICAgIG9uQ29udGV4dE1lbnUgPSBmdW5jdGlvbiBvbkNvbnRleHRNZW51KGUpIHtcbiAgICAgIC8vdXNlZCB0byBwcmV2ZW50IGxvbmctdG91Y2ggZnJvbSB0cmlnZ2VyaW5nIGEgY29udGV4dCBtZW51LlxuICAgICAgLy8gKHNlbGYuaXNQcmVzc2VkICYmIGUud2hpY2ggPCAyKSAmJiBzZWxmLmVuZERyYWcoKSAvLyBwcmV2aW91c2x5IGVuZGVkIGRyYWcgd2hlbiBjb250ZXh0IG1lbnUgd2FzIHRyaWdnZXJlZCwgYnV0IGluc3RlYWQgd2Ugc2hvdWxkIGp1c3Qgc3RvcCBwcm9wYWdhdGlvbiBhbmQgcHJldmVudCB0aGUgZGVmYXVsdCBldmVudCBiZWhhdmlvci5cbiAgICAgIF9wcmV2ZW50RGVmYXVsdChlKTtcblxuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gJiYgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgICAgICAvL3RoaXMgbWV0aG9kIGdldHMgY2FsbGVkIG9uIGV2ZXJ5IHRpY2sgb2YgVHdlZW5MaXRlLnRpY2tlciB3aGljaCBhbGxvd3MgdXMgdG8gc3luY2hyb25pemUgdGhlIHJlbmRlcnMgdG8gdGhlIGNvcmUgZW5naW5lICh3aGljaCBpcyB0eXBpY2FsbHkgc3luY2hyb25pemVkIHdpdGggdGhlIGRpc3BsYXkgcmVmcmVzaCB2aWEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKS4gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gLSBpdCdzIGJldHRlciB0aGFuIGFwcGx5aW5nIHRoZSB2YWx1ZXMgaW5zaWRlIHRoZSBcIm1vdXNlbW92ZVwiIG9yIFwidG91Y2htb3ZlXCIgZXZlbnQgaGFuZGxlciB3aGljaCBtYXkgZ2V0IGNhbGxlZCBtYW55IHRpbWVzIGluYmV0d2VlbiByZWZyZXNoZXMuXG4gICAgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHN1cHByZXNzRXZlbnRzKSB7XG4gICAgICBpZiAoc2VsZi5hdXRvU2Nyb2xsICYmIHNlbGYuaXNEcmFnZ2luZyAmJiAoY2hlY2tBdXRvU2Nyb2xsQm91bmRzIHx8IGRpcnR5KSkge1xuICAgICAgICB2YXIgZSA9IHRhcmdldCxcbiAgICAgICAgICAgIGF1dG9TY3JvbGxGYWN0b3IgPSBzZWxmLmF1dG9TY3JvbGwgKiAxNSxcbiAgICAgICAgICAgIC8vbXVsdGlwbHlpbmcgYnkgMTUganVzdCBnaXZlcyB1cyBhIGJldHRlciBcImZlZWxcIiBzcGVlZC13aXNlLlxuICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgICBpc1Jvb3QsXG4gICAgICAgICAgICByZWN0LFxuICAgICAgICAgICAgcG9pbnRlclgsXG4gICAgICAgICAgICBwb2ludGVyWSxcbiAgICAgICAgICAgIGNoYW5nZVgsXG4gICAgICAgICAgICBjaGFuZ2VZLFxuICAgICAgICAgICAgZ2FwO1xuICAgICAgICBjaGVja0F1dG9TY3JvbGxCb3VuZHMgPSBmYWxzZTtcbiAgICAgICAgX3dpbmRvd1Byb3h5LnNjcm9sbFRvcCA9IF93aW4ucGFnZVlPZmZzZXQgIT0gbnVsbCA/IF93aW4ucGFnZVlPZmZzZXQgOiBvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wICE9IG51bGwgPyBvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIDogb3duZXJEb2MuYm9keS5zY3JvbGxUb3A7XG4gICAgICAgIF93aW5kb3dQcm94eS5zY3JvbGxMZWZ0ID0gX3dpbi5wYWdlWE9mZnNldCAhPSBudWxsID8gX3dpbi5wYWdlWE9mZnNldCA6IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0ICE9IG51bGwgPyBvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCA6IG93bmVyRG9jLmJvZHkuc2Nyb2xsTGVmdDtcbiAgICAgICAgcG9pbnRlclggPSBzZWxmLnBvaW50ZXJYIC0gX3dpbmRvd1Byb3h5LnNjcm9sbExlZnQ7XG4gICAgICAgIHBvaW50ZXJZID0gc2VsZi5wb2ludGVyWSAtIF93aW5kb3dQcm94eS5zY3JvbGxUb3A7XG5cbiAgICAgICAgd2hpbGUgKGUgJiYgIWlzUm9vdCkge1xuICAgICAgICAgIC8vd2FsayB1cCB0aGUgY2hhaW4gYW5kIHNlbnNlIHdoZXJldmVyIHRoZSBwb2ludGVyIGlzIHdpdGhpbiA0MHB4IG9mIGFuIGVkZ2UgdGhhdCdzIHNjcm9sbGFibGUuXG4gICAgICAgICAgaXNSb290ID0gX2lzUm9vdChlLnBhcmVudE5vZGUpO1xuICAgICAgICAgIHBhcmVudCA9IGlzUm9vdCA/IF93aW5kb3dQcm94eSA6IGUucGFyZW50Tm9kZTtcbiAgICAgICAgICByZWN0ID0gaXNSb290ID8ge1xuICAgICAgICAgICAgYm90dG9tOiBNYXRoLm1heChfZG9jRWxlbWVudC5jbGllbnRIZWlnaHQsIF93aW4uaW5uZXJIZWlnaHQgfHwgMCksXG4gICAgICAgICAgICByaWdodDogTWF0aC5tYXgoX2RvY0VsZW1lbnQuY2xpZW50V2lkdGgsIF93aW4uaW5uZXJXaWR0aCB8fCAwKSxcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgICB9IDogcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIGNoYW5nZVggPSBjaGFuZ2VZID0gMDtcblxuICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgIGdhcCA9IHBhcmVudC5fZ3NNYXhTY3JvbGxZIC0gcGFyZW50LnNjcm9sbFRvcDtcblxuICAgICAgICAgICAgaWYgKGdhcCA8IDApIHtcbiAgICAgICAgICAgICAgY2hhbmdlWSA9IGdhcDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRlclkgPiByZWN0LmJvdHRvbSAtIGF1dG9TY3JvbGxNYXJnaW5Cb3R0b20gJiYgZ2FwKSB7XG4gICAgICAgICAgICAgIGNoZWNrQXV0b1Njcm9sbEJvdW5kcyA9IHRydWU7XG4gICAgICAgICAgICAgIGNoYW5nZVkgPSBNYXRoLm1pbihnYXAsIGF1dG9TY3JvbGxGYWN0b3IgKiAoMSAtIE1hdGgubWF4KDAsIHJlY3QuYm90dG9tIC0gcG9pbnRlclkpIC8gYXV0b1Njcm9sbE1hcmdpbkJvdHRvbSkgfCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRlclkgPCByZWN0LnRvcCArIGF1dG9TY3JvbGxNYXJnaW5Ub3AgJiYgcGFyZW50LnNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICBjaGVja0F1dG9TY3JvbGxCb3VuZHMgPSB0cnVlO1xuICAgICAgICAgICAgICBjaGFuZ2VZID0gLU1hdGgubWluKHBhcmVudC5zY3JvbGxUb3AsIGF1dG9TY3JvbGxGYWN0b3IgKiAoMSAtIE1hdGgubWF4KDAsIHBvaW50ZXJZIC0gcmVjdC50b3ApIC8gYXV0b1Njcm9sbE1hcmdpblRvcCkgfCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoYW5nZVkpIHtcbiAgICAgICAgICAgICAgcGFyZW50LnNjcm9sbFRvcCArPSBjaGFuZ2VZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAgICAgIGdhcCA9IHBhcmVudC5fZ3NNYXhTY3JvbGxYIC0gcGFyZW50LnNjcm9sbExlZnQ7XG5cbiAgICAgICAgICAgIGlmIChnYXAgPCAwKSB7XG4gICAgICAgICAgICAgIGNoYW5nZVggPSBnYXA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvaW50ZXJYID4gcmVjdC5yaWdodCAtIGF1dG9TY3JvbGxNYXJnaW5SaWdodCAmJiBnYXApIHtcbiAgICAgICAgICAgICAgY2hlY2tBdXRvU2Nyb2xsQm91bmRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY2hhbmdlWCA9IE1hdGgubWluKGdhcCwgYXV0b1Njcm9sbEZhY3RvciAqICgxIC0gTWF0aC5tYXgoMCwgcmVjdC5yaWdodCAtIHBvaW50ZXJYKSAvIGF1dG9TY3JvbGxNYXJnaW5SaWdodCkgfCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRlclggPCByZWN0LmxlZnQgKyBhdXRvU2Nyb2xsTWFyZ2luTGVmdCAmJiBwYXJlbnQuc2Nyb2xsTGVmdCkge1xuICAgICAgICAgICAgICBjaGVja0F1dG9TY3JvbGxCb3VuZHMgPSB0cnVlO1xuICAgICAgICAgICAgICBjaGFuZ2VYID0gLU1hdGgubWluKHBhcmVudC5zY3JvbGxMZWZ0LCBhdXRvU2Nyb2xsRmFjdG9yICogKDEgLSBNYXRoLm1heCgwLCBwb2ludGVyWCAtIHJlY3QubGVmdCkgLyBhdXRvU2Nyb2xsTWFyZ2luTGVmdCkgfCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoYW5nZVgpIHtcbiAgICAgICAgICAgICAgcGFyZW50LnNjcm9sbExlZnQgKz0gY2hhbmdlWDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNSb290ICYmIChjaGFuZ2VYIHx8IGNoYW5nZVkpKSB7XG4gICAgICAgICAgICBfd2luLnNjcm9sbFRvKHBhcmVudC5zY3JvbGxMZWZ0LCBwYXJlbnQuc2Nyb2xsVG9wKTtcblxuICAgICAgICAgICAgc2V0UG9pbnRlclBvc2l0aW9uKHNlbGYucG9pbnRlclggKyBjaGFuZ2VYLCBzZWxmLnBvaW50ZXJZICsgY2hhbmdlWSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgdmFyIHggPSBzZWxmLngsXG4gICAgICAgICAgICB5ID0gc2VsZi55O1xuXG4gICAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBzZWxmLmRlbHRhWCA9IHggLSBwYXJzZUZsb2F0KGdzQ2FjaGUucm90YXRpb24pO1xuICAgICAgICAgIHNlbGYucm90YXRpb24gPSB4O1xuICAgICAgICAgIGdzQ2FjaGUucm90YXRpb24gPSB4ICsgXCJkZWdcIjtcbiAgICAgICAgICBnc0NhY2hlLnJlbmRlclRyYW5zZm9ybSgxLCBnc0NhY2hlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2Nyb2xsUHJveHkpIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgICAgc2VsZi5kZWx0YVkgPSB5IC0gc2Nyb2xsUHJveHkudG9wKCk7XG4gICAgICAgICAgICAgIHNjcm9sbFByb3h5LnRvcCh5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgICBzZWxmLmRlbHRhWCA9IHggLSBzY3JvbGxQcm94eS5sZWZ0KCk7XG4gICAgICAgICAgICAgIHNjcm9sbFByb3h5LmxlZnQoeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh4eU1vZGUpIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgICAgc2VsZi5kZWx0YVkgPSB5IC0gcGFyc2VGbG9hdChnc0NhY2hlLnkpO1xuICAgICAgICAgICAgICBnc0NhY2hlLnkgPSB5ICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxsb3dYKSB7XG4gICAgICAgICAgICAgIHNlbGYuZGVsdGFYID0geCAtIHBhcnNlRmxvYXQoZ3NDYWNoZS54KTtcbiAgICAgICAgICAgICAgZ3NDYWNoZS54ID0geCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3NDYWNoZS5yZW5kZXJUcmFuc2Zvcm0oMSwgZ3NDYWNoZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgICAgc2VsZi5kZWx0YVkgPSB5IC0gcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUudG9wIHx8IDApO1xuICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUudG9wID0geSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgICBzZWxmLmRlbHRhWCA9IHggLSBwYXJzZUZsb2F0KHRhcmdldC5zdHlsZS5sZWZ0IHx8IDApO1xuICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUubGVmdCA9IHggKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0RyYWdDYWxsYmFjayAmJiAhc3VwcHJlc3NFdmVudHMgJiYgIWlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTsgLy9pbiBjYXNlIG9uRHJhZyBoYXMgYW4gdXBkYXRlKCkgY2FsbCAoYXZvaWQgZW5kbGVzcyBsb29wKVxuXG4gICAgICAgICAgaWYgKF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiZHJhZ1wiLCBcIm9uRHJhZ1wiKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAgICAgICAgc2VsZi54IC09IHNlbGYuZGVsdGFYO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxsb3dZKSB7XG4gICAgICAgICAgICAgIHNlbGYueSAtPSBzZWxmLmRlbHRhWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyKHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkaXJ0eSA9IGZhbHNlO1xuICAgIH0sXG4gICAgICAgIC8vY29waWVzIHRoZSB4L3kgZnJvbSB0aGUgZWxlbWVudCAod2hldGhlciB0aGF0IGJlIHRyYW5zZm9ybXMsIHRvcC9sZWZ0LCBvciBTY3JvbGxQcm94eSdzIHRvcC9sZWZ0KSB0byB0aGUgRHJhZ2dhYmxlJ3MgeCBhbmQgeSAoYW5kIHJvdGF0aW9uIGlmIG5lY2Vzc2FyeSkgcHJvcGVydGllcyBzbyB0aGF0IHRoZXkgcmVmbGVjdCByZWFsaXR5IGFuZCBpdCBhbHNvIChvcHRpb25hbGx5KSBhcHBsaWVzIGFueSBzbmFwcGluZyBuZWNlc3NhcnkuIFRoaXMgaXMgdXNlZCBieSB0aGUgSW5lcnRpYVBsdWdpbiB0d2VlbiBpbiBhbiBvblVwZGF0ZSB0byBlbnN1cmUgdGhpbmdzIGFyZSBzeW5jZWQgYW5kIHNuYXBwZWQuXG4gICAgc3luY1hZID0gZnVuY3Rpb24gc3luY1hZKHNraXBPblVwZGF0ZSwgc2tpcFNuYXApIHtcbiAgICAgIHZhciB4ID0gc2VsZi54LFxuICAgICAgICAgIHkgPSBzZWxmLnksXG4gICAgICAgICAgc25hcHBlZFZhbHVlLFxuICAgICAgICAgIGNzO1xuXG4gICAgICBpZiAoIXRhcmdldC5fZ3NhcCkge1xuICAgICAgICAvL2p1c3QgaW4gY2FzZSB0aGUgX2dzYXAgY2FjaGUgZ290IHdpcGVkLCBsaWtlIGlmIHRoZSB1c2VyIGNhbGxlZCBjbGVhclByb3BzIG9uIHRoZSB0cmFuc2Zvcm0gb3Igc29tZXRoaW5nICh2ZXJ5IHJhcmUpLlxuICAgICAgICBnc0NhY2hlID0gZ3NhcC5jb3JlLmdldENhY2hlKHRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIGdzQ2FjaGUudW5jYWNoZSAmJiBnc2FwLmdldFByb3BlcnR5KHRhcmdldCwgXCJ4XCIpOyAvLyB0cmlnZ2VyIGEgcmUtY2FjaGVcblxuICAgICAgaWYgKHh5TW9kZSkge1xuICAgICAgICBzZWxmLnggPSBwYXJzZUZsb2F0KGdzQ2FjaGUueCk7XG4gICAgICAgIHNlbGYueSA9IHBhcnNlRmxvYXQoZ3NDYWNoZS55KTtcbiAgICAgIH0gZWxzZSBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgIHNlbGYueCA9IHNlbGYucm90YXRpb24gPSBwYXJzZUZsb2F0KGdzQ2FjaGUucm90YXRpb24pO1xuICAgICAgfSBlbHNlIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICBzZWxmLnkgPSBzY3JvbGxQcm94eS50b3AoKTtcbiAgICAgICAgc2VsZi54ID0gc2Nyb2xsUHJveHkubGVmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi55ID0gcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUudG9wIHx8IChjcyA9IF9nZXRDb21wdXRlZFN0eWxlKHRhcmdldCkpICYmIGNzLnRvcCkgfHwgMDtcbiAgICAgICAgc2VsZi54ID0gcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUubGVmdCB8fCAoY3MgfHwge30pLmxlZnQpIHx8IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICgoc25hcFggfHwgc25hcFkgfHwgc25hcFhZKSAmJiAhc2tpcFNuYXAgJiYgKHNlbGYuaXNEcmFnZ2luZyB8fCBzZWxmLmlzVGhyb3dpbmcpKSB7XG4gICAgICAgIGlmIChzbmFwWFkpIHtcbiAgICAgICAgICBfdGVtcDEueCA9IHNlbGYueDtcbiAgICAgICAgICBfdGVtcDEueSA9IHNlbGYueTtcbiAgICAgICAgICBzbmFwcGVkVmFsdWUgPSBzbmFwWFkoX3RlbXAxKTtcblxuICAgICAgICAgIGlmIChzbmFwcGVkVmFsdWUueCAhPT0gc2VsZi54KSB7XG4gICAgICAgICAgICBzZWxmLnggPSBzbmFwcGVkVmFsdWUueDtcbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc25hcHBlZFZhbHVlLnkgIT09IHNlbGYueSkge1xuICAgICAgICAgICAgc2VsZi55ID0gc25hcHBlZFZhbHVlLnk7XG4gICAgICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNuYXBYKSB7XG4gICAgICAgICAgc25hcHBlZFZhbHVlID0gc25hcFgoc2VsZi54KTtcblxuICAgICAgICAgIGlmIChzbmFwcGVkVmFsdWUgIT09IHNlbGYueCkge1xuICAgICAgICAgICAgc2VsZi54ID0gc25hcHBlZFZhbHVlO1xuXG4gICAgICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgICAgIHNlbGYucm90YXRpb24gPSBzbmFwcGVkVmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc25hcFkpIHtcbiAgICAgICAgICBzbmFwcGVkVmFsdWUgPSBzbmFwWShzZWxmLnkpO1xuXG4gICAgICAgICAgaWYgKHNuYXBwZWRWYWx1ZSAhPT0gc2VsZi55KSB7XG4gICAgICAgICAgICBzZWxmLnkgPSBzbmFwcGVkVmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRpcnR5ICYmIHJlbmRlcih0cnVlKTtcblxuICAgICAgaWYgKCFza2lwT25VcGRhdGUpIHtcbiAgICAgICAgc2VsZi5kZWx0YVggPSBzZWxmLnggLSB4O1xuICAgICAgICBzZWxmLmRlbHRhWSA9IHNlbGYueSAtIHk7XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJ0aHJvd3VwZGF0ZVwiLCBcIm9uVGhyb3dVcGRhdGVcIik7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgYnVpbGRTbmFwRnVuYyA9IGZ1bmN0aW9uIGJ1aWxkU25hcEZ1bmMoc25hcCwgbWluLCBtYXgsIGZhY3Rvcikge1xuICAgICAgaWYgKG1pbiA9PSBudWxsKSB7XG4gICAgICAgIG1pbiA9IC1fYmlnTnVtO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgICAgbWF4ID0gX2JpZ051bTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9pc0Z1bmN0aW9uKHNuYXApKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobikge1xuICAgICAgICAgIHZhciBlZGdlVG9sZXJhbmNlID0gIXNlbGYuaXNQcmVzc2VkID8gMSA6IDEgLSBzZWxmLmVkZ2VSZXNpc3RhbmNlOyAvL2lmIHdlJ3JlIHR3ZWVuaW5nLCBkaXNhYmxlIHRoZSBlZGdlVG9sZXJhbmNlIGJlY2F1c2UgaXQncyBhbHJlYWR5IGZhY3RvcmVkIGludG8gdGhlIHR3ZWVuaW5nIHZhbHVlcyAod2UgZG9uJ3Qgd2FudCB0byBhcHBseSBpdCBtdWx0aXBsZSB0aW1lcylcblxuICAgICAgICAgIHJldHVybiBzbmFwLmNhbGwoc2VsZiwgKG4gPiBtYXggPyBtYXggKyAobiAtIG1heCkgKiBlZGdlVG9sZXJhbmNlIDogbiA8IG1pbiA/IG1pbiArIChuIC0gbWluKSAqIGVkZ2VUb2xlcmFuY2UgOiBuKSAqIGZhY3RvcikgKiBmYWN0b3I7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNBcnJheShzbmFwKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICB2YXIgaSA9IHNuYXAubGVuZ3RoLFxuICAgICAgICAgICAgICBjbG9zZXN0ID0gMCxcbiAgICAgICAgICAgICAgYWJzRGlmID0gX2JpZ051bSxcbiAgICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgICBkaWY7XG5cbiAgICAgICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgICAgIHZhbCA9IHNuYXBbaV07XG4gICAgICAgICAgICBkaWYgPSB2YWwgLSBuO1xuXG4gICAgICAgICAgICBpZiAoZGlmIDwgMCkge1xuICAgICAgICAgICAgICBkaWYgPSAtZGlmO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGlmIDwgYWJzRGlmICYmIHZhbCA+PSBtaW4gJiYgdmFsIDw9IG1heCkge1xuICAgICAgICAgICAgICBjbG9zZXN0ID0gaTtcbiAgICAgICAgICAgICAgYWJzRGlmID0gZGlmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzbmFwW2Nsb3Nlc3RdO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNOYU4oc25hcCkgPyBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzbmFwICogZmFjdG9yO1xuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBidWlsZFBvaW50U25hcEZ1bmMgPSBmdW5jdGlvbiBidWlsZFBvaW50U25hcEZ1bmMoc25hcCwgbWluWCwgbWF4WCwgbWluWSwgbWF4WSwgcmFkaXVzLCBmYWN0b3IpIHtcbiAgICAgIHJhZGl1cyA9IHJhZGl1cyAmJiByYWRpdXMgPCBfYmlnTnVtID8gcmFkaXVzICogcmFkaXVzIDogX2JpZ051bTsgLy9zbyB3ZSBkb24ndCBoYXZlIHRvIE1hdGguc3FydCgpIGluIHRoZSBmdW5jdGlvbnMuIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cblxuICAgICAgaWYgKF9pc0Z1bmN0aW9uKHNuYXApKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICB2YXIgZWRnZVRvbGVyYW5jZSA9ICFzZWxmLmlzUHJlc3NlZCA/IDEgOiAxIC0gc2VsZi5lZGdlUmVzaXN0YW5jZSxcbiAgICAgICAgICAgICAgeCA9IHBvaW50LngsXG4gICAgICAgICAgICAgIHkgPSBwb2ludC55LFxuICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgIGR4LFxuICAgICAgICAgICAgICBkeTsgLy9pZiB3ZSdyZSB0d2VlbmluZywgZGlzYWJsZSB0aGUgZWRnZVRvbGVyYW5jZSBiZWNhdXNlIGl0J3MgYWxyZWFkeSBmYWN0b3JlZCBpbnRvIHRoZSB0d2VlbmluZyB2YWx1ZXMgKHdlIGRvbid0IHdhbnQgdG8gYXBwbHkgaXQgbXVsdGlwbGUgdGltZXMpXG5cbiAgICAgICAgICBwb2ludC54ID0geCA9IHggPiBtYXhYID8gbWF4WCArICh4IC0gbWF4WCkgKiBlZGdlVG9sZXJhbmNlIDogeCA8IG1pblggPyBtaW5YICsgKHggLSBtaW5YKSAqIGVkZ2VUb2xlcmFuY2UgOiB4O1xuICAgICAgICAgIHBvaW50LnkgPSB5ID0geSA+IG1heFkgPyBtYXhZICsgKHkgLSBtYXhZKSAqIGVkZ2VUb2xlcmFuY2UgOiB5IDwgbWluWSA/IG1pblkgKyAoeSAtIG1pblkpICogZWRnZVRvbGVyYW5jZSA6IHk7XG4gICAgICAgICAgcmVzdWx0ID0gc25hcC5jYWxsKHNlbGYsIHBvaW50KTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgIT09IHBvaW50KSB7XG4gICAgICAgICAgICBwb2ludC54ID0gcmVzdWx0Lng7XG4gICAgICAgICAgICBwb2ludC55ID0gcmVzdWx0Lnk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZhY3RvciAhPT0gMSkge1xuICAgICAgICAgICAgcG9pbnQueCAqPSBmYWN0b3I7XG4gICAgICAgICAgICBwb2ludC55ICo9IGZhY3RvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmFkaXVzIDwgX2JpZ051bSkge1xuICAgICAgICAgICAgZHggPSBwb2ludC54IC0geDtcbiAgICAgICAgICAgIGR5ID0gcG9pbnQueSAtIHk7XG5cbiAgICAgICAgICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA+IHJhZGl1cykge1xuICAgICAgICAgICAgICBwb2ludC54ID0geDtcbiAgICAgICAgICAgICAgcG9pbnQueSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoX2lzQXJyYXkoc25hcCkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgdmFyIGkgPSBzbmFwLmxlbmd0aCxcbiAgICAgICAgICAgICAgY2xvc2VzdCA9IDAsXG4gICAgICAgICAgICAgIG1pbkRpc3QgPSBfYmlnTnVtLFxuICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgICAgZGlzdDtcblxuICAgICAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICAgICAgcG9pbnQgPSBzbmFwW2ldO1xuICAgICAgICAgICAgeCA9IHBvaW50LnggLSBwLng7XG4gICAgICAgICAgICB5ID0gcG9pbnQueSAtIHAueTtcbiAgICAgICAgICAgIGRpc3QgPSB4ICogeCArIHkgKiB5O1xuXG4gICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgICAgICAgY2xvc2VzdCA9IGk7XG4gICAgICAgICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBtaW5EaXN0IDw9IHJhZGl1cyA/IHNuYXBbY2xvc2VzdF0gOiBwO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9O1xuICAgIH0sXG4gICAgICAgIGNhbGN1bGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICAgIHZhciBib3VuZHMsIHRhcmdldEJvdW5kcywgc25hcCwgc25hcElzUmF3O1xuICAgICAgaGFzQm91bmRzID0gZmFsc2U7XG5cbiAgICAgIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICBzY3JvbGxQcm94eS5jYWxpYnJhdGUoKTtcbiAgICAgICAgc2VsZi5taW5YID0gbWluWCA9IC1zY3JvbGxQcm94eS5tYXhTY3JvbGxMZWZ0KCk7XG4gICAgICAgIHNlbGYubWluWSA9IG1pblkgPSAtc2Nyb2xsUHJveHkubWF4U2Nyb2xsVG9wKCk7XG4gICAgICAgIHNlbGYubWF4WCA9IG1heFggPSBzZWxmLm1heFkgPSBtYXhZID0gMDtcbiAgICAgICAgaGFzQm91bmRzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoISF2YXJzLmJvdW5kcykge1xuICAgICAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKHZhcnMuYm91bmRzLCB0YXJnZXQucGFyZW50Tm9kZSk7IC8vY291bGQgYmUgYSBzZWxlY3Rvci9qUXVlcnkgb2JqZWN0IG9yIGEgRE9NIGVsZW1lbnQgb3IgYSBnZW5lcmljIG9iamVjdCBsaWtlIHt0b3A6MCwgbGVmdDoxMDAsIHdpZHRoOjEwMDAsIGhlaWdodDo4MDB9IG9yIHttaW5YOjEwMCwgbWF4WDoxMTAwLCBtaW5ZOjAsIG1heFk6ODAwfVxuXG4gICAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBzZWxmLm1pblggPSBtaW5YID0gYm91bmRzLmxlZnQ7XG4gICAgICAgICAgc2VsZi5tYXhYID0gbWF4WCA9IGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoO1xuICAgICAgICAgIHNlbGYubWluWSA9IG1pblkgPSBzZWxmLm1heFkgPSBtYXhZID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICghX2lzVW5kZWZpbmVkKHZhcnMuYm91bmRzLm1heFgpIHx8ICFfaXNVbmRlZmluZWQodmFycy5ib3VuZHMubWF4WSkpIHtcbiAgICAgICAgICBib3VuZHMgPSB2YXJzLmJvdW5kcztcbiAgICAgICAgICBzZWxmLm1pblggPSBtaW5YID0gYm91bmRzLm1pblg7XG4gICAgICAgICAgc2VsZi5taW5ZID0gbWluWSA9IGJvdW5kcy5taW5ZO1xuICAgICAgICAgIHNlbGYubWF4WCA9IG1heFggPSBib3VuZHMubWF4WDtcbiAgICAgICAgICBzZWxmLm1heFkgPSBtYXhZID0gYm91bmRzLm1heFk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0Qm91bmRzID0gX2dldEJvdW5kcyh0YXJnZXQsIHRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgICAgICBzZWxmLm1pblggPSBtaW5YID0gTWF0aC5yb3VuZChnZXRQcm9wQXNOdW0oeFByb3AsIFwicHhcIikgKyBib3VuZHMubGVmdCAtIHRhcmdldEJvdW5kcy5sZWZ0KTtcbiAgICAgICAgICBzZWxmLm1pblkgPSBtaW5ZID0gTWF0aC5yb3VuZChnZXRQcm9wQXNOdW0oeVByb3AsIFwicHhcIikgKyBib3VuZHMudG9wIC0gdGFyZ2V0Qm91bmRzLnRvcCk7XG4gICAgICAgICAgc2VsZi5tYXhYID0gbWF4WCA9IE1hdGgucm91bmQobWluWCArIChib3VuZHMud2lkdGggLSB0YXJnZXRCb3VuZHMud2lkdGgpKTtcbiAgICAgICAgICBzZWxmLm1heFkgPSBtYXhZID0gTWF0aC5yb3VuZChtaW5ZICsgKGJvdW5kcy5oZWlnaHQgLSB0YXJnZXRCb3VuZHMuaGVpZ2h0KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWluWCA+IG1heFgpIHtcbiAgICAgICAgICBzZWxmLm1pblggPSBtYXhYO1xuICAgICAgICAgIHNlbGYubWF4WCA9IG1heFggPSBtaW5YO1xuICAgICAgICAgIG1pblggPSBzZWxmLm1pblg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWluWSA+IG1heFkpIHtcbiAgICAgICAgICBzZWxmLm1pblkgPSBtYXhZO1xuICAgICAgICAgIHNlbGYubWF4WSA9IG1heFkgPSBtaW5ZO1xuICAgICAgICAgIG1pblkgPSBzZWxmLm1pblk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgc2VsZi5taW5Sb3RhdGlvbiA9IG1pblg7XG4gICAgICAgICAgc2VsZi5tYXhSb3RhdGlvbiA9IG1heFg7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNCb3VuZHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFycy5saXZlU25hcCkge1xuICAgICAgICBzbmFwID0gdmFycy5saXZlU25hcCA9PT0gdHJ1ZSA/IHZhcnMuc25hcCB8fCB7fSA6IHZhcnMubGl2ZVNuYXA7XG4gICAgICAgIHNuYXBJc1JhdyA9IF9pc0FycmF5KHNuYXApIHx8IF9pc0Z1bmN0aW9uKHNuYXApO1xuXG4gICAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBzbmFwWCA9IGJ1aWxkU25hcEZ1bmMoc25hcElzUmF3ID8gc25hcCA6IHNuYXAucm90YXRpb24sIG1pblgsIG1heFgsIDEpO1xuICAgICAgICAgIHNuYXBZID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc25hcC5wb2ludHMpIHtcbiAgICAgICAgICAgIHNuYXBYWSA9IGJ1aWxkUG9pbnRTbmFwRnVuYyhzbmFwSXNSYXcgPyBzbmFwIDogc25hcC5wb2ludHMsIG1pblgsIG1heFgsIG1pblksIG1heFksIHNuYXAucmFkaXVzLCBzY3JvbGxQcm94eSA/IC0xIDogMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAgICAgICAgc25hcFggPSBidWlsZFNuYXBGdW5jKHNuYXBJc1JhdyA/IHNuYXAgOiBzbmFwLnggfHwgc25hcC5sZWZ0IHx8IHNuYXAuc2Nyb2xsTGVmdCwgbWluWCwgbWF4WCwgc2Nyb2xsUHJveHkgPyAtMSA6IDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxsb3dZKSB7XG4gICAgICAgICAgICAgIHNuYXBZID0gYnVpbGRTbmFwRnVuYyhzbmFwSXNSYXcgPyBzbmFwIDogc25hcC55IHx8IHNuYXAudG9wIHx8IHNuYXAuc2Nyb2xsVG9wLCBtaW5ZLCBtYXhZLCBzY3JvbGxQcm94eSA/IC0xIDogMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgb25UaHJvd0NvbXBsZXRlID0gZnVuY3Rpb24gb25UaHJvd0NvbXBsZXRlKCkge1xuICAgICAgc2VsZi5pc1Rocm93aW5nID0gZmFsc2U7XG5cbiAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwidGhyb3djb21wbGV0ZVwiLCBcIm9uVGhyb3dDb21wbGV0ZVwiKTtcbiAgICB9LFxuICAgICAgICBvblRocm93SW50ZXJydXB0ID0gZnVuY3Rpb24gb25UaHJvd0ludGVycnVwdCgpIHtcbiAgICAgIHNlbGYuaXNUaHJvd2luZyA9IGZhbHNlO1xuICAgIH0sXG4gICAgICAgIGFuaW1hdGUgPSBmdW5jdGlvbiBhbmltYXRlKGluZXJ0aWEsIGZvcmNlWmVyb1ZlbG9jaXR5KSB7XG4gICAgICB2YXIgc25hcCwgc25hcElzUmF3LCB0d2Vlbiwgb3ZlcnNob290VG9sZXJhbmNlO1xuXG4gICAgICBpZiAoaW5lcnRpYSAmJiBJbmVydGlhUGx1Z2luKSB7XG4gICAgICAgIGlmIChpbmVydGlhID09PSB0cnVlKSB7XG4gICAgICAgICAgc25hcCA9IHZhcnMuc25hcCB8fCB2YXJzLmxpdmVTbmFwIHx8IHt9O1xuICAgICAgICAgIHNuYXBJc1JhdyA9IF9pc0FycmF5KHNuYXApIHx8IF9pc0Z1bmN0aW9uKHNuYXApO1xuICAgICAgICAgIGluZXJ0aWEgPSB7XG4gICAgICAgICAgICByZXNpc3RhbmNlOiAodmFycy50aHJvd1Jlc2lzdGFuY2UgfHwgdmFycy5yZXNpc3RhbmNlIHx8IDEwMDApIC8gKHJvdGF0aW9uTW9kZSA/IDEwIDogMSlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICAgICAgaW5lcnRpYS5yb3RhdGlvbiA9IF9wYXJzZUluZXJ0aWEoc2VsZiwgc25hcElzUmF3ID8gc25hcCA6IHNuYXAucm90YXRpb24sIG1heFgsIG1pblgsIDEsIGZvcmNlWmVyb1ZlbG9jaXR5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgICBpbmVydGlhW3hQcm9wXSA9IF9wYXJzZUluZXJ0aWEoc2VsZiwgc25hcElzUmF3ID8gc25hcCA6IHNuYXAucG9pbnRzIHx8IHNuYXAueCB8fCBzbmFwLmxlZnQsIG1heFgsIG1pblgsIHNjcm9sbFByb3h5ID8gLTEgOiAxLCBmb3JjZVplcm9WZWxvY2l0eSB8fCBzZWxmLmxvY2tlZEF4aXMgPT09IFwieFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFsbG93WSkge1xuICAgICAgICAgICAgICBpbmVydGlhW3lQcm9wXSA9IF9wYXJzZUluZXJ0aWEoc2VsZiwgc25hcElzUmF3ID8gc25hcCA6IHNuYXAucG9pbnRzIHx8IHNuYXAueSB8fCBzbmFwLnRvcCwgbWF4WSwgbWluWSwgc2Nyb2xsUHJveHkgPyAtMSA6IDEsIGZvcmNlWmVyb1ZlbG9jaXR5IHx8IHNlbGYubG9ja2VkQXhpcyA9PT0gXCJ5XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc25hcC5wb2ludHMgfHwgX2lzQXJyYXkoc25hcCkgJiYgX2lzT2JqZWN0KHNuYXBbMF0pKSB7XG4gICAgICAgICAgICAgIGluZXJ0aWEubGlua2VkUHJvcHMgPSB4UHJvcCArIFwiLFwiICsgeVByb3A7XG4gICAgICAgICAgICAgIGluZXJ0aWEucmFkaXVzID0gc25hcC5yYWRpdXM7IC8vbm90ZTogd2UgYWxzbyBkaXNhYmxlIGxpdmVTbmFwcGluZyB3aGlsZSB0aHJvd2luZyBpZiB0aGVyZSdzIGEgXCJyYWRpdXNcIiBkZWZpbmVkLCBvdGhlcndpc2UgaXQgbG9va3Mgd2VpcmQgdG8gaGF2ZSB0aGUgaXRlbSB0aHJvd24gcGFzdCBhIHNuYXBwaW5nIHBvaW50IGJ1dCBsaXZlLXNuYXBwaW5nIG1pZC10d2Vlbi4gV2UgZG8gdGhpcyBieSBhbHRlcmluZyB0aGUgb25VcGRhdGVQYXJhbXMgc28gdGhhdCBcInNraXBTbmFwXCIgcGFyYW1ldGVyIGlzIHRydWUgZm9yIHN5bmNYWS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmlzVGhyb3dpbmcgPSB0cnVlO1xuICAgICAgICBvdmVyc2hvb3RUb2xlcmFuY2UgPSAhaXNOYU4odmFycy5vdmVyc2hvb3RUb2xlcmFuY2UpID8gdmFycy5vdmVyc2hvb3RUb2xlcmFuY2UgOiB2YXJzLmVkZ2VSZXNpc3RhbmNlID09PSAxID8gMCA6IDEgLSBzZWxmLmVkZ2VSZXNpc3RhbmNlICsgMC4yO1xuXG4gICAgICAgIGlmICghaW5lcnRpYS5kdXJhdGlvbikge1xuICAgICAgICAgIGluZXJ0aWEuZHVyYXRpb24gPSB7XG4gICAgICAgICAgICBtYXg6IE1hdGgubWF4KHZhcnMubWluRHVyYXRpb24gfHwgMCwgXCJtYXhEdXJhdGlvblwiIGluIHZhcnMgPyB2YXJzLm1heER1cmF0aW9uIDogMiksXG4gICAgICAgICAgICBtaW46ICFpc05hTih2YXJzLm1pbkR1cmF0aW9uKSA/IHZhcnMubWluRHVyYXRpb24gOiBvdmVyc2hvb3RUb2xlcmFuY2UgPT09IDAgfHwgX2lzT2JqZWN0KGluZXJ0aWEpICYmIGluZXJ0aWEucmVzaXN0YW5jZSA+IDEwMDAgPyAwIDogMC41LFxuICAgICAgICAgICAgb3ZlcnNob290OiBvdmVyc2hvb3RUb2xlcmFuY2VcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi50d2VlbiA9IHR3ZWVuID0gZ3NhcC50byhzY3JvbGxQcm94eSB8fCB0YXJnZXQsIHtcbiAgICAgICAgICBpbmVydGlhOiBpbmVydGlhLFxuICAgICAgICAgIGRhdGE6IFwiX2RyYWdnYWJsZVwiLFxuICAgICAgICAgIGluaGVyaXQ6IGZhbHNlLFxuICAgICAgICAgIG9uQ29tcGxldGU6IG9uVGhyb3dDb21wbGV0ZSxcbiAgICAgICAgICBvbkludGVycnVwdDogb25UaHJvd0ludGVycnVwdCxcbiAgICAgICAgICBvblVwZGF0ZTogdmFycy5mYXN0TW9kZSA/IF9kaXNwYXRjaEV2ZW50IDogc3luY1hZLFxuICAgICAgICAgIG9uVXBkYXRlUGFyYW1zOiB2YXJzLmZhc3RNb2RlID8gW3NlbGYsIFwib250aHJvd3VwZGF0ZVwiLCBcIm9uVGhyb3dVcGRhdGVcIl0gOiBzbmFwICYmIHNuYXAucmFkaXVzID8gW2ZhbHNlLCB0cnVlXSA6IFtdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghdmFycy5mYXN0TW9kZSkge1xuICAgICAgICAgIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICAgICAgc2Nyb2xsUHJveHkuX3NraXAgPSB0cnVlOyAvLyBNaWNyb3NvZnQgYnJvd3NlcnMgaGF2ZSBhIGJ1ZyB0aGF0IGNhdXNlcyB0aGVtIHRvIGJyaWVmbHkgcmVuZGVyIHRoZSBwb3NpdGlvbiBpbmNvcnJlY3RseSAoaXQgZmxhc2hlcyB0byB0aGUgZW5kIHN0YXRlIHdoZW4gd2Ugc2VlaygpIHRoZSB0d2VlbiBldmVuIHRob3VnaCB3ZSBqdW1wIHJpZ2h0IGJhY2sgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24sIGFuZCB0aGlzIG9ubHkgc2VlbXMgdG8gaGFwcGVuIHdoZW4gd2UncmUgYWZmZWN0aW5nIGJvdGggdG9wIGFuZCBsZWZ0KSwgc28gd2Ugc2V0IGEgX3N1c3BlbmRUcmFuc2Zvcm1zIGZsYWcgdG8gcHJldmVudCBpdCBmcm9tIGFjdHVhbGx5IGFwcGx5aW5nIHRoZSB2YWx1ZXMgaW4gdGhlIFNjcm9sbFByb3h5LlxuICAgICAgICAgIH1cblxuICAgICAgICAgIHR3ZWVuLnJlbmRlcigxZTksIHRydWUsIHRydWUpOyAvLyBmb3JjZSB0byB0aGUgZW5kLiBSZW1lbWJlciwgdGhlIGR1cmF0aW9uIHdpbGwgbGlrZWx5IGNoYW5nZSB1cG9uIGluaXR0aW5nIGJlY2F1c2UgdGhhdCdzIHdoZW4gSW5lcnRpYVBsdWdpbiBjYWxjdWxhdGVzIGl0LlxuXG4gICAgICAgICAgc3luY1hZKHRydWUsIHRydWUpO1xuICAgICAgICAgIHNlbGYuZW5kWCA9IHNlbGYueDtcbiAgICAgICAgICBzZWxmLmVuZFkgPSBzZWxmLnk7XG5cbiAgICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgICBzZWxmLmVuZFJvdGF0aW9uID0gc2VsZi54O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHR3ZWVuLnBsYXkoMCk7XG4gICAgICAgICAgc3luY1hZKHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKHNjcm9sbFByb3h5KSB7XG4gICAgICAgICAgICBzY3JvbGxQcm94eS5fc2tpcCA9IGZhbHNlOyAvL01pY3Jvc29mdCBicm93c2VycyBoYXZlIGEgYnVnIHRoYXQgY2F1c2VzIHRoZW0gdG8gYnJpZWZseSByZW5kZXIgdGhlIHBvc2l0aW9uIGluY29ycmVjdGx5IChpdCBmbGFzaGVzIHRvIHRoZSBlbmQgc3RhdGUgd2hlbiB3ZSBzZWVrKCkgdGhlIHR3ZWVuIGV2ZW4gdGhvdWdoIHdlIGp1bXAgcmlnaHQgYmFjayB0byB0aGUgY3VycmVudCBwb3NpdGlvbiwgYW5kIHRoaXMgb25seSBzZWVtcyB0byBoYXBwZW4gd2hlbiB3ZSdyZSBhZmZlY3RpbmcgYm90aCB0b3AgYW5kIGxlZnQpLCBzbyB3ZSBzZXQgYSBfc3VzcGVuZFRyYW5zZm9ybXMgZmxhZyB0byBwcmV2ZW50IGl0IGZyb20gYWN0dWFsbHkgYXBwbHlpbmcgdGhlIHZhbHVlcyBpbiB0aGUgU2Nyb2xsUHJveHkuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhhc0JvdW5kcykge1xuICAgICAgICBzZWxmLmFwcGx5Qm91bmRzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgdXBkYXRlTWF0cml4ID0gZnVuY3Rpb24gdXBkYXRlTWF0cml4KHNoaWZ0U3RhcnQpIHtcbiAgICAgIHZhciBzdGFydCA9IG1hdHJpeCxcbiAgICAgICAgICBwO1xuICAgICAgbWF0cml4ID0gZ2V0R2xvYmFsTWF0cml4KHRhcmdldC5wYXJlbnROb2RlLCB0cnVlKTtcblxuICAgICAgaWYgKHNoaWZ0U3RhcnQgJiYgc2VsZi5pc1ByZXNzZWQgJiYgIW1hdHJpeC5lcXVhbHMoc3RhcnQgfHwgbmV3IE1hdHJpeDJEKCkpKSB7XG4gICAgICAgIC8vaWYgdGhlIG1hdHJpeCBjaGFuZ2VzIFdISUxFIHRoZSBlbGVtZW50IGlzIHByZXNzZWQsIHdlIG11c3QgYWRqdXN0IHRoZSBzdGFydFBvaW50ZXJYIGFuZCBzdGFydFBvaW50ZXJZIGFjY29yZGluZ2x5LCBzbyB3ZSBpbnZlcnQgdGhlIG9yaWdpbmFsIG1hdHJpeCBhbmQgZmlndXJlIG91dCB3aGVyZSB0aGUgcG9pbnRlclggYW5kIHBvaW50ZXJZIHdlcmUgaW4gdGhlIGdsb2JhbCBzcGFjZSwgdGhlbiBhcHBseSB0aGUgbmV3IG1hdHJpeCB0byBnZXQgdGhlIHVwZGF0ZWQgY29vcmRpbmF0ZXMuXG4gICAgICAgIHAgPSBzdGFydC5pbnZlcnNlKCkuYXBwbHkoe1xuICAgICAgICAgIHg6IHN0YXJ0UG9pbnRlclgsXG4gICAgICAgICAgeTogc3RhcnRQb2ludGVyWVxuICAgICAgICB9KTtcbiAgICAgICAgbWF0cml4LmFwcGx5KHAsIHApO1xuICAgICAgICBzdGFydFBvaW50ZXJYID0gcC54O1xuICAgICAgICBzdGFydFBvaW50ZXJZID0gcC55O1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0cml4LmVxdWFscyhfaWRlbnRpdHlNYXRyaXgpKSB7XG4gICAgICAgIC8vaWYgdGhlcmUgYXJlIG5vIHRyYW5zZm9ybXMsIHdlIGNhbiBvcHRpbWl6ZSBwZXJmb3JtYW5jZSBieSBub3QgZmFjdG9yaW5nIGluIHRoZSBtYXRyaXhcbiAgICAgICAgbWF0cml4ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICByZWNvcmRTdGFydFBvc2l0aW9ucyA9IGZ1bmN0aW9uIHJlY29yZFN0YXJ0UG9zaXRpb25zKCkge1xuICAgICAgdmFyIGVkZ2VUb2xlcmFuY2UgPSAxIC0gc2VsZi5lZGdlUmVzaXN0YW5jZSxcbiAgICAgICAgICBvZmZzZXRYID0gaXNGaXhlZCA/IF9nZXREb2NTY3JvbGxMZWZ0KG93bmVyRG9jKSA6IDAsXG4gICAgICAgICAgb2Zmc2V0WSA9IGlzRml4ZWQgPyBfZ2V0RG9jU2Nyb2xsVG9wKG93bmVyRG9jKSA6IDAsXG4gICAgICAgICAgcGFyc2VkT3JpZ2luLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeTtcblxuICAgICAgaWYgKHh5TW9kZSkge1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSB1c2VyIHNldCBpdCBhcyBhIGRpZmZlcmVudCB1bml0LCBsaWtlIGFuaW1hdGluZyB0aGUgeCB0byBcIjEwMCVcIi4gV2UgbXVzdCBjb252ZXJ0IGl0IGJhY2sgdG8gcHghXG4gICAgICAgIGdzQ2FjaGUueCA9IGdldFByb3BBc051bSh4UHJvcCwgXCJweFwiKSArIFwicHhcIjtcbiAgICAgICAgZ3NDYWNoZS55ID0gZ2V0UHJvcEFzTnVtKHlQcm9wLCBcInB4XCIpICsgXCJweFwiO1xuICAgICAgICBnc0NhY2hlLnJlbmRlclRyYW5zZm9ybSgpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVNYXRyaXgoZmFsc2UpO1xuICAgICAgX3BvaW50MS54ID0gc2VsZi5wb2ludGVyWCAtIG9mZnNldFg7XG4gICAgICBfcG9pbnQxLnkgPSBzZWxmLnBvaW50ZXJZIC0gb2Zmc2V0WTtcbiAgICAgIG1hdHJpeCAmJiBtYXRyaXguYXBwbHkoX3BvaW50MSwgX3BvaW50MSk7XG4gICAgICBzdGFydFBvaW50ZXJYID0gX3BvaW50MS54OyAvL3RyYW5zbGF0ZSB0byBsb2NhbCBjb29yZGluYXRlIHN5c3RlbVxuXG4gICAgICBzdGFydFBvaW50ZXJZID0gX3BvaW50MS55O1xuXG4gICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgc2V0UG9pbnRlclBvc2l0aW9uKHNlbGYucG9pbnRlclgsIHNlbGYucG9pbnRlclkpO1xuICAgICAgICByZW5kZXIodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlubmVyTWF0cml4ID0gZ2V0R2xvYmFsTWF0cml4KHRhcmdldCk7XG5cbiAgICAgIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICBjYWxjdWxhdGVCb3VuZHMoKTtcbiAgICAgICAgc3RhcnRFbGVtZW50WSA9IHNjcm9sbFByb3h5LnRvcCgpO1xuICAgICAgICBzdGFydEVsZW1lbnRYID0gc2Nyb2xsUHJveHkubGVmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9pZiB0aGUgZWxlbWVudCBpcyBpbiB0aGUgcHJvY2VzcyBvZiB0d2VlbmluZywgZG9uJ3QgZm9yY2Ugc25hcHBpbmcgdG8gb2NjdXIgYmVjYXVzZSBpdCBjb3VsZCBtYWtlIGl0IGp1bXAuIEltYWdpbmUgdGhlIHVzZXIgdGhyb3dpbmcsIHRoZW4gYmVmb3JlIGl0J3MgZG9uZSwgY2xpY2tpbmcgb24gdGhlIGVsZW1lbnQgaW4gaXRzIGluYmV0d2VlbiBzdGF0ZS5cbiAgICAgICAgaWYgKGlzVHdlZW5pbmcoKSkge1xuICAgICAgICAgIHN5bmNYWSh0cnVlLCB0cnVlKTtcbiAgICAgICAgICBjYWxjdWxhdGVCb3VuZHMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLmFwcGx5Qm91bmRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgcGFyc2VkT3JpZ2luID0gdGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCA/IFtnc0NhY2hlLnhPcmlnaW4gLSB0YXJnZXQuZ2V0QkJveCgpLngsIGdzQ2FjaGUueU9yaWdpbiAtIHRhcmdldC5nZXRCQm94KCkueV0gOiAoX2dldENvbXB1dGVkU3R5bGUodGFyZ2V0KVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gfHwgXCIwIDBcIikuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgIHJvdGF0aW9uT3JpZ2luID0gc2VsZi5yb3RhdGlvbk9yaWdpbiA9IGdldEdsb2JhbE1hdHJpeCh0YXJnZXQpLmFwcGx5KHtcbiAgICAgICAgICAgIHg6IHBhcnNlRmxvYXQocGFyc2VkT3JpZ2luWzBdKSB8fCAwLFxuICAgICAgICAgICAgeTogcGFyc2VGbG9hdChwYXJzZWRPcmlnaW5bMV0pIHx8IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzeW5jWFkodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgeCA9IHNlbGYucG9pbnRlclggLSByb3RhdGlvbk9yaWdpbi54IC0gb2Zmc2V0WDtcbiAgICAgICAgICB5ID0gcm90YXRpb25PcmlnaW4ueSAtIHNlbGYucG9pbnRlclkgKyBvZmZzZXRZO1xuICAgICAgICAgIHN0YXJ0RWxlbWVudFggPSBzZWxmLng7IC8vc3RhcnRpbmcgcm90YXRpb24gKHggYWx3YXlzIHJlZmVycyB0byByb3RhdGlvbiBpbiB0eXBlOlwicm90YXRpb25cIiwgbWVhc3VyZWQgaW4gZGVncmVlcylcblxuICAgICAgICAgIHN0YXJ0RWxlbWVudFkgPSBzZWxmLnkgPSBNYXRoLmF0YW4yKHksIHgpICogX1JBRDJERUc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9wYXJlbnQgPSAhaXNGaXhlZCAmJiB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgICAvL3N0YXJ0U2Nyb2xsVG9wID0gcGFyZW50ID8gcGFyZW50LnNjcm9sbFRvcCB8fCAwIDogMDtcbiAgICAgICAgICAvL3N0YXJ0U2Nyb2xsTGVmdCA9IHBhcmVudCA/IHBhcmVudC5zY3JvbGxMZWZ0IHx8IDAgOiAwO1xuICAgICAgICAgIHN0YXJ0RWxlbWVudFkgPSBnZXRQcm9wQXNOdW0oeVByb3AsIFwicHhcIik7IC8vcmVjb3JkIHRoZSBzdGFydGluZyB0b3AgYW5kIGxlZnQgdmFsdWVzIHNvIHRoYXQgd2UgY2FuIGp1c3QgYWRkIHRoZSBtb3VzZSdzIG1vdmVtZW50IHRvIHRoZW0gbGF0ZXIuXG5cbiAgICAgICAgICBzdGFydEVsZW1lbnRYID0gZ2V0UHJvcEFzTnVtKHhQcm9wLCBcInB4XCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNCb3VuZHMgJiYgZWRnZVRvbGVyYW5jZSkge1xuICAgICAgICBpZiAoc3RhcnRFbGVtZW50WCA+IG1heFgpIHtcbiAgICAgICAgICBzdGFydEVsZW1lbnRYID0gbWF4WCArIChzdGFydEVsZW1lbnRYIC0gbWF4WCkgLyBlZGdlVG9sZXJhbmNlO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0RWxlbWVudFggPCBtaW5YKSB7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WCA9IG1pblggLSAobWluWCAtIHN0YXJ0RWxlbWVudFgpIC8gZWRnZVRvbGVyYW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0RWxlbWVudFkgPiBtYXhZKSB7XG4gICAgICAgICAgICBzdGFydEVsZW1lbnRZID0gbWF4WSArIChzdGFydEVsZW1lbnRZIC0gbWF4WSkgLyBlZGdlVG9sZXJhbmNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRFbGVtZW50WSA8IG1pblkpIHtcbiAgICAgICAgICAgIHN0YXJ0RWxlbWVudFkgPSBtaW5ZIC0gKG1pblkgLSBzdGFydEVsZW1lbnRZKSAvIGVkZ2VUb2xlcmFuY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuc3RhcnRYID0gc3RhcnRFbGVtZW50WCA9IF9yb3VuZChzdGFydEVsZW1lbnRYKTtcbiAgICAgIHNlbGYuc3RhcnRZID0gc3RhcnRFbGVtZW50WSA9IF9yb3VuZChzdGFydEVsZW1lbnRZKTtcbiAgICB9LFxuICAgICAgICBpc1R3ZWVuaW5nID0gZnVuY3Rpb24gaXNUd2VlbmluZygpIHtcbiAgICAgIHJldHVybiBzZWxmLnR3ZWVuICYmIHNlbGYudHdlZW4uaXNBY3RpdmUoKTtcbiAgICB9LFxuICAgICAgICByZW1vdmVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIHJlbW92ZVBsYWNlaG9sZGVyKCkge1xuICAgICAgaWYgKF9wbGFjZWhvbGRlckRpdi5wYXJlbnROb2RlICYmICFpc1R3ZWVuaW5nKCkgJiYgIXNlbGYuaXNEcmFnZ2luZykge1xuICAgICAgICAvL19wbGFjZWhvbGRlckRpdiBqdXN0IHByb3BzIG9wZW4gYXV0by1zY3JvbGxpbmcgY29udGFpbmVycyBzbyB0aGV5IGRvbid0IGNvbGxhcHNlIGFzIHRoZSB1c2VyIGRyYWdzIGxlZnQvdXAuIFdlIHJlbW92ZSBpdCBhZnRlciBkcmFnZ2luZyAoYW5kIHRocm93aW5nLCBpZiBuZWNlc3NhcnkpIGZpbmlzaGVzLlxuICAgICAgICBfcGxhY2Vob2xkZXJEaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfcGxhY2Vob2xkZXJEaXYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIC8vY2FsbGVkIHdoZW4gdGhlIG1vdXNlIGlzIHByZXNzZWQgKG9yIHRvdWNoIHN0YXJ0cylcbiAgICBvblByZXNzID0gZnVuY3Rpb24gb25QcmVzcyhlLCBmb3JjZSkge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGlmICghZW5hYmxlZCB8fCBzZWxmLmlzUHJlc3NlZCB8fCAhZSB8fCAoZS50eXBlID09PSBcIm1vdXNlZG93blwiIHx8IGUudHlwZSA9PT0gXCJwb2ludGVyZG93blwiKSAmJiAhZm9yY2UgJiYgX2dldFRpbWUoKSAtIGNsaWNrVGltZSA8IDMwICYmIF90b3VjaEV2ZW50TG9va3VwW3NlbGYucG9pbnRlckV2ZW50LnR5cGVdKSB7XG4gICAgICAgIC8vd2hlbiB3ZSBET04nVCBwcmV2ZW50RGVmYXVsdCgpIGluIG9yZGVyIHRvIGFjY29tbW9kYXRlIHRvdWNoLXNjcm9sbGluZyBhbmQgdGhlIHVzZXIganVzdCB0YXBzLCBtYW55IGJyb3dzZXJzIGFsc28gZmlyZSBhIG1vdXNlZG93bi9tb3VzZXVwIHNlcXVlbmNlIEFGVEVSIHRoZSB0b3VjaHN0YXJ0L3RvdWNoZW5kIHNlcXVlbmNlLCB0aHVzIGl0J2QgcmVzdWx0IGluIHR3byBxdWljayBcImNsaWNrXCIgZXZlbnRzIGJlaW5nIGRpc3BhdGNoZWQuIFRoaXMgbGluZSBzZW5zZXMgdGhhdCBjb25kaXRpb24gYW5kIGhhbHRzIGl0IG9uIHRoZSBzdWJzZXF1ZW50IG1vdXNlZG93bi5cbiAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCAmJiBlICYmIGVuYWJsZWQgJiYgX3ByZXZlbnREZWZhdWx0KGUpOyAvLyBpbiBzb21lIGJyb3dzZXJzLCB3ZSBtdXN0IGxpc3RlbiBmb3IgbXVsdGlwbGUgZXZlbnQgdHlwZXMgbGlrZSB0b3VjaHN0YXJ0LCBwb2ludGVyZG93biwgbW91c2Vkb3duLiBUaGUgZmlyc3QgdGltZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCwgd2UgcmVjb3JkIHdoZXRoZXIgb3Igbm90IHdlIF9wcmV2ZW50RGVmYXVsdCgpIHNvIHRoYXQgb24gZHVwbGljYXRlIGNhbGxzLCB3ZSBjYW4gZG8gdGhlIHNhbWUgaWYgbmVjZXNzYXJ5LlxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaW50ZXJydXB0ZWQgPSBpc1R3ZWVuaW5nKCk7XG4gICAgICBkcmFnZ2VkID0gZmFsc2U7IC8vIHdlIG5lZWQgdG8gdHJhY2sgd2hldGhlciBvciBub3QgaXQgd2FzIGRyYWdnZWQgaW4gdGhpcyBpbnRlcmFjdGlvbiBzbyB0aGF0IGlmLCBmb3IgZXhhbXBsZSwgdGhlIHVzZXIgY2FsbHMgLmVuZERyYWcoKSB0byBGT1JDRSBpdCB0byBzdG9wIGFuZCB0aGVuIHRoZXkga2VlcCB0aGUgbW91c2UgcHJlc3NlZCBkb3duIGFuZCBldmVudHVhbGx5IHJlbGVhc2UsIHRoYXQgd291bGQgbm9ybWFsbHkgY2F1c2UgYW4gb25DbGljayBidXQgd2UgaGF2ZSB0byBza2lwIGl0IGluIHRoYXQgY2FzZSBpZiB0aGVyZSB3YXMgZHJhZ2dpbmcgdGhhdCBvY2N1cnJlZC5cblxuICAgICAgc2VsZi5wb2ludGVyRXZlbnQgPSBlO1xuXG4gICAgICBpZiAoX3RvdWNoRXZlbnRMb29rdXBbZS50eXBlXSkge1xuICAgICAgICAvL25vdGU6IG9uIGlPUywgQk9USCB0b3VjaG1vdmUgYW5kIG1vdXNlbW92ZSBhcmUgZGlzcGF0Y2hlZCwgYnV0IHRoZSBtb3VzZW1vdmUgaGFzIHBhZ2VZIGFuZCBwYWdlWCBvZiAwIHdoaWNoIHdvdWxkIG1lc3MgdXAgdGhlIGNhbGN1bGF0aW9ucyBhbmQgbmVlZGxlc3NseSBodXJ0IHBlcmZvcm1hbmNlLlxuICAgICAgICB0b3VjaEV2ZW50VGFyZ2V0ID0gfmUudHlwZS5pbmRleE9mKFwidG91Y2hcIikgPyBlLmN1cnJlbnRUYXJnZXQgfHwgZS50YXJnZXQgOiBvd25lckRvYzsgLy9wb2ludGVyLWJhc2VkIHRvdWNoZXMgKGZvciBNaWNyb3NvZnQgYnJvd3NlcnMpIGRvbid0IHJlbWFpbiBsb2NrZWQgdG8gdGhlIG9yaWdpbmFsIHRhcmdldCBsaWtlIG90aGVyIGJyb3dzZXJzLCBzbyB3ZSBtdXN0IHVzZSB0aGUgZG9jdW1lbnQgaW5zdGVhZC4gVGhlIGV2ZW50IHR5cGUgd291bGQgYmUgXCJNU1BvaW50ZXJEb3duXCIgb3IgXCJwb2ludGVyZG93blwiLlxuXG4gICAgICAgIF9hZGRMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNoZW5kXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2htb3ZlXCIsIG9uTW92ZSk7IC8vIHBvc3NpYmxlIGZ1dHVyZSBjaGFuZ2UgaWYgUG9pbnRlckV2ZW50cyBhcmUgbW9yZSBzdGFuZGFyZGl6ZWQ6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L3NldFBvaW50ZXJDYXB0dXJlXG5cblxuICAgICAgICBfYWRkTGlzdGVuZXIodG91Y2hFdmVudFRhcmdldCwgXCJ0b3VjaGNhbmNlbFwiLCBvblJlbGVhc2UpO1xuXG4gICAgICAgIF9hZGRMaXN0ZW5lcihvd25lckRvYywgXCJ0b3VjaHN0YXJ0XCIsIF9vbk11bHRpVG91Y2hEb2N1bWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3VjaEV2ZW50VGFyZ2V0ID0gbnVsbDtcblxuICAgICAgICBfYWRkTGlzdGVuZXIob3duZXJEb2MsIFwibW91c2Vtb3ZlXCIsIG9uTW92ZSk7IC8vYXR0YWNoIHRoZXNlIHRvIHRoZSBkb2N1bWVudCBpbnN0ZWFkIG9mIHRoZSBib3ggaXRzZWxmIHNvIHRoYXQgaWYgdGhlIHVzZXIncyBtb3VzZSBtb3ZlcyB0b28gcXVpY2tseSAoYW5kIG9mZiBvZiB0aGUgYm94KSwgdGhpbmdzIHN0aWxsIHdvcmsuXG5cbiAgICAgIH1cblxuICAgICAgdG91Y2hEcmFnQXhpcyA9IG51bGw7XG5cbiAgICAgIGlmICghX3N1cHBvcnRzUG9pbnRlciB8fCAhdG91Y2hFdmVudFRhcmdldCkge1xuICAgICAgICBfYWRkTGlzdGVuZXIob3duZXJEb2MsIFwibW91c2V1cFwiLCBvblJlbGVhc2UpO1xuXG4gICAgICAgIGUgJiYgZS50YXJnZXQgJiYgX2FkZExpc3RlbmVyKGUudGFyZ2V0LCBcIm1vdXNldXBcIiwgb25SZWxlYXNlKTsgLy93ZSBhbHNvIGhhdmUgdG8gbGlzdGVuIGRpcmVjdGx5IG9uIHRoZSBlbGVtZW50IGJlY2F1c2Ugc29tZSBicm93c2VycyBkb24ndCBidWJibGUgdXAgdGhlIGV2ZW50IHRvIHRoZSBfZG9jIG9uIGVsZW1lbnRzIHdpdGggY29udGVudEVkaXRhYmxlPVwidHJ1ZVwiXG4gICAgICB9XG5cbiAgICAgIGlzQ2xpY2tpbmcgPSBpc0NsaWNrYWJsZS5jYWxsKHNlbGYsIGUudGFyZ2V0KSAmJiB2YXJzLmRyYWdDbGlja2FibGVzID09PSBmYWxzZSAmJiAhZm9yY2U7XG5cbiAgICAgIGlmIChpc0NsaWNraW5nKSB7XG4gICAgICAgIF9hZGRMaXN0ZW5lcihlLnRhcmdldCwgXCJjaGFuZ2VcIiwgb25SZWxlYXNlKTsgLy9pbiBzb21lIGJyb3dzZXJzLCB3aGVuIHlvdSBtb3VzZWRvd24gb24gYSA8c2VsZWN0PiBlbGVtZW50LCBubyBtb3VzZXVwIGdldHMgZGlzcGF0Y2hlZCEgU28gd2UgbGlzdGVuIGZvciBhIFwiY2hhbmdlXCIgZXZlbnQgaW5zdGVhZC5cblxuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwicHJlc3NJbml0XCIsIFwib25QcmVzc0luaXRcIik7XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJwcmVzc1wiLCBcIm9uUHJlc3NcIik7XG5cbiAgICAgICAgX3NldFNlbGVjdGFibGUodHJpZ2dlcnMsIHRydWUpOyAvL2FjY29tbW9kYXRlcyB0aGluZ3MgbGlrZSBpbnB1dHMgYW5kIGVsZW1lbnRzIHdpdGggY29udGVudEVkaXRhYmxlPVwidHJ1ZVwiIChvdGhlcndpc2UgdXNlciBjb3VsZG4ndCBkcmFnIHRvIHNlbGVjdCB0ZXh0KVxuXG5cbiAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgPSAhdG91Y2hFdmVudFRhcmdldCB8fCBhbGxvd1ggPT09IGFsbG93WSB8fCBzZWxmLnZhcnMuYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyA9PT0gZmFsc2UgfHwgc2VsZi52YXJzLmFsbG93Q29udGV4dE1lbnUgJiYgZSAmJiAoZS5jdHJsS2V5IHx8IGUud2hpY2ggPiAyKSA/IGZhbHNlIDogYWxsb3dYID8gXCJ5XCIgOiBcInhcIjsgLy9ub3RlOiBpbiBDaHJvbWUsIHJpZ2h0LWNsaWNraW5nIChmb3IgYSBjb250ZXh0IG1lbnUpIGZpcmVzIG9uUHJlc3MgYW5kIGl0IGRvZXNuJ3QgaGF2ZSB0aGUgZXZlbnQud2hpY2ggc2V0IHByb3Blcmx5LCBzbyB3ZSBtdXN0IGxvb2sgZm9yIGV2ZW50LmN0cmxLZXkuIElmIHRoZSB1c2VyIHdhbnRzIHRvIGFsbG93IGNvbnRleHQgbWVudXMgd2Ugc2hvdWxkIG9mIGNvdXJzZSBzZW5zZSBpdCBoZXJlIGFuZCBub3QgYWxsb3cgbmF0aXZlIHRvdWNoIHNjcm9sbGluZy5cblxuICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCA9ICFhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nICYmICFzZWxmLmFsbG93RXZlbnREZWZhdWx0O1xuXG4gICAgICBpZiAoaXNQcmV2ZW50aW5nRGVmYXVsdCkge1xuICAgICAgICBfcHJldmVudERlZmF1bHQoZSk7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKF93aW4sIFwidG91Y2hmb3JjZWNoYW5nZVwiLCBfcHJldmVudERlZmF1bHQpOyAvL3dvcmtzIGFyb3VuZCBzYWZhcmkgYnVnOiBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8yMTQ1MC1kcmFnZ2FibGUtaW4taWZyYW1lLW9uLW1vYmlsZS1pcy1idWdneS9cblxuICAgICAgfVxuXG4gICAgICBpZiAoZS5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgICAvL3RvdWNoIGV2ZW50cyBzdG9yZSB0aGUgZGF0YSBzbGlnaHRseSBkaWZmZXJlbnRseVxuICAgICAgICBlID0gdG91Y2ggPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICB0b3VjaElEID0gZS5pZGVudGlmaWVyO1xuICAgICAgfSBlbHNlIGlmIChlLnBvaW50ZXJJZCkge1xuICAgICAgICB0b3VjaElEID0gZS5wb2ludGVySWQ7IC8vZm9yIHNvbWUgTWljcm9zb2Z0IGJyb3dzZXJzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3VjaCA9IHRvdWNoSUQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBfZHJhZ0NvdW50Kys7XG5cbiAgICAgIF9hZGRUb1JlbmRlclF1ZXVlKHJlbmRlcik7IC8vY2F1c2VzIHRoZSBEcmFnZ2FibGUgdG8gcmVuZGVyIG9uIGVhY2ggXCJ0aWNrXCIgb2YgZ3NhcC50aWNrZXIgKHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiAtIHVwZGF0aW5nIHZhbHVlcyBpbiBhIG1vdXNlbW92ZSBjYW4gY2F1c2UgdGhlbSB0byBoYXBwZW4gdG9vIGZyZXF1ZW50bHksIGxpa2UgbXVsdGlwbGUgdGltZXMgYmV0d2VlbiBmcmFtZSByZWRyYXdzIHdoaWNoIGlzIHdhc3RlZnVsLCBhbmQgaXQgYWxzbyBwcmV2ZW50cyB2YWx1ZXMgZnJvbSB1cGRhdGluZyBwcm9wZXJseSBpbiBJRTgpXG5cblxuICAgICAgc3RhcnRQb2ludGVyWSA9IHNlbGYucG9pbnRlclkgPSBlLnBhZ2VZOyAvL3JlY29yZCB0aGUgc3RhcnRpbmcgeCBhbmQgeSBzbyB0aGF0IHdlIGNhbiBjYWxjdWxhdGUgdGhlIG1vdmVtZW50IGZyb20gdGhlIG9yaWdpbmFsIGluIF9vbk1vdXNlTW92ZVxuXG4gICAgICBzdGFydFBvaW50ZXJYID0gc2VsZi5wb2ludGVyWCA9IGUucGFnZVg7XG5cbiAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwicHJlc3NJbml0XCIsIFwib25QcmVzc0luaXRcIik7XG5cbiAgICAgIGlmIChhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nIHx8IHNlbGYuYXV0b1Njcm9sbCkge1xuICAgICAgICBfcmVjb3JkTWF4U2Nyb2xscyh0YXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXQucGFyZW50Tm9kZSAmJiBzZWxmLmF1dG9TY3JvbGwgJiYgIXNjcm9sbFByb3h5ICYmICFyb3RhdGlvbk1vZGUgJiYgdGFyZ2V0LnBhcmVudE5vZGUuX2dzTWF4U2Nyb2xsWCAmJiAhX3BsYWNlaG9sZGVyRGl2LnBhcmVudE5vZGUgJiYgIXRhcmdldC5nZXRCQm94KSB7XG4gICAgICAgIC8vYWRkIGEgcGxhY2Vob2xkZXIgZGl2IHRvIHByZXZlbnQgdGhlIHBhcmVudCBjb250YWluZXIgZnJvbSBjb2xsYXBzaW5nIHdoZW4gdGhlIHVzZXIgZHJhZ3MgdGhlIGVsZW1lbnQgbGVmdC5cbiAgICAgICAgX3BsYWNlaG9sZGVyRGl2LnN0eWxlLndpZHRoID0gdGFyZ2V0LnBhcmVudE5vZGUuc2Nyb2xsV2lkdGggKyBcInB4XCI7XG4gICAgICAgIHRhcmdldC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKF9wbGFjZWhvbGRlckRpdik7XG4gICAgICB9XG5cbiAgICAgIHJlY29yZFN0YXJ0UG9zaXRpb25zKCk7XG4gICAgICBzZWxmLnR3ZWVuICYmIHNlbGYudHdlZW4ua2lsbCgpO1xuICAgICAgc2VsZi5pc1Rocm93aW5nID0gZmFsc2U7XG4gICAgICBnc2FwLmtpbGxUd2VlbnNPZihzY3JvbGxQcm94eSB8fCB0YXJnZXQsIGtpbGxQcm9wcywgdHJ1ZSk7IC8vaW4gY2FzZSB0aGUgdXNlciB0cmllcyB0byBkcmFnIGl0IGJlZm9yZSB0aGUgbGFzdCB0d2VlbiBpcyBkb25lLlxuXG4gICAgICBzY3JvbGxQcm94eSAmJiBnc2FwLmtpbGxUd2VlbnNPZih0YXJnZXQsIHtcbiAgICAgICAgc2Nyb2xsVG86IDFcbiAgICAgIH0sIHRydWUpOyAvL2p1c3QgaW4gY2FzZSB0aGUgb3JpZ2luYWwgdGFyZ2V0J3Mgc2Nyb2xsIHBvc2l0aW9uIGlzIGJlaW5nIHR3ZWVuZWQgc29tZXdoZXJlIGVsc2UuXG5cbiAgICAgIHNlbGYudHdlZW4gPSBzZWxmLmxvY2tlZEF4aXMgPSBudWxsO1xuXG4gICAgICBpZiAodmFycy56SW5kZXhCb29zdCB8fCAhcm90YXRpb25Nb2RlICYmICFzY3JvbGxQcm94eSAmJiB2YXJzLnpJbmRleEJvb3N0ICE9PSBmYWxzZSkge1xuICAgICAgICB0YXJnZXQuc3R5bGUuekluZGV4ID0gRHJhZ2dhYmxlLnpJbmRleCsrO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmlzUHJlc3NlZCA9IHRydWU7XG4gICAgICBoYXNEcmFnQ2FsbGJhY2sgPSAhISh2YXJzLm9uRHJhZyB8fCBzZWxmLl9saXN0ZW5lcnMuZHJhZyk7XG4gICAgICBoYXNNb3ZlQ2FsbGJhY2sgPSAhISh2YXJzLm9uTW92ZSB8fCBzZWxmLl9saXN0ZW5lcnMubW92ZSk7XG5cbiAgICAgIGlmICh2YXJzLmN1cnNvciAhPT0gZmFsc2UgfHwgdmFycy5hY3RpdmVDdXJzb3IpIHtcbiAgICAgICAgaSA9IHRyaWdnZXJzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgICBnc2FwLnNldCh0cmlnZ2Vyc1tpXSwge1xuICAgICAgICAgICAgY3Vyc29yOiB2YXJzLmFjdGl2ZUN1cnNvciB8fCB2YXJzLmN1cnNvciB8fCAoX2RlZmF1bHRDdXJzb3IgPT09IFwiZ3JhYlwiID8gXCJncmFiYmluZ1wiIDogX2RlZmF1bHRDdXJzb3IpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJwcmVzc1wiLCBcIm9uUHJlc3NcIik7XG4gICAgfSxcbiAgICAgICAgLy9jYWxsZWQgZXZlcnkgdGltZSB0aGUgbW91c2UvdG91Y2ggbW92ZXNcbiAgICBvbk1vdmUgPSBmdW5jdGlvbiBvbk1vdmUoZSkge1xuICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBlLFxuICAgICAgICAgIHRvdWNoZXMsXG4gICAgICAgICAgcG9pbnRlclgsXG4gICAgICAgICAgcG9pbnRlclksXG4gICAgICAgICAgaSxcbiAgICAgICAgICBkeCxcbiAgICAgICAgICBkeTtcblxuICAgICAgaWYgKCFlbmFibGVkIHx8IF9pc011bHRpVG91Y2hpbmcgfHwgIXNlbGYuaXNQcmVzc2VkIHx8ICFlKSB7XG4gICAgICAgIGlzUHJldmVudGluZ0RlZmF1bHQgJiYgZSAmJiBlbmFibGVkICYmIF9wcmV2ZW50RGVmYXVsdChlKTsgLy8gaW4gc29tZSBicm93c2Vycywgd2UgbXVzdCBsaXN0ZW4gZm9yIG11bHRpcGxlIGV2ZW50IHR5cGVzIGxpa2UgdG91Y2htb3ZlLCBwb2ludGVybW92ZSwgbW91c2Vtb3ZlLiBUaGUgZmlyc3QgdGltZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCwgd2UgcmVjb3JkIHdoZXRoZXIgb3Igbm90IHdlIF9wcmV2ZW50RGVmYXVsdCgpIHNvIHRoYXQgb24gZHVwbGljYXRlIGNhbGxzLCB3ZSBjYW4gZG8gdGhlIHNhbWUgaWYgbmVjZXNzYXJ5LlxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5wb2ludGVyRXZlbnQgPSBlO1xuICAgICAgdG91Y2hlcyA9IGUuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICAgIGlmICh0b3VjaGVzKSB7XG4gICAgICAgIC8vdG91Y2ggZXZlbnRzIHN0b3JlIHRoZSBkYXRhIHNsaWdodGx5IGRpZmZlcmVudGx5XG4gICAgICAgIGUgPSB0b3VjaGVzWzBdO1xuXG4gICAgICAgIGlmIChlICE9PSB0b3VjaCAmJiBlLmlkZW50aWZpZXIgIT09IHRvdWNoSUQpIHtcbiAgICAgICAgICAvL1VzdWFsbHkgY2hhbmdlZFRvdWNoZXNbMF0gd2lsbCBiZSB3aGF0IHdlJ3JlIGxvb2tpbmcgZm9yLCBidXQgaW4gY2FzZSBpdCdzIG5vdCwgbG9vayB0aHJvdWdoIHRoZSByZXN0IG9mIHRoZSBhcnJheS4uLihhbmQgQW5kcm9pZCBicm93c2VycyBkb24ndCByZXVzZSB0aGUgZXZlbnQgbGlrZSBpT1MpXG4gICAgICAgICAgaSA9IHRvdWNoZXMubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKC0taSA+IC0xICYmIChlID0gdG91Y2hlc1tpXSkuaWRlbnRpZmllciAhPT0gdG91Y2hJRCAmJiBlLnRhcmdldCAhPT0gdGFyZ2V0KSB7fSAvLyBTb21lIEFuZHJvaWQgZGV2aWNlcyBkaXNwYXRjaCBhIHRvdWNoc3RhcnQgQU5EIHBvaW50ZXJkb3duIGluaXRpYWxseSwgYW5kIHRoZW4gb25seSBwb2ludGVybW92ZSB0aHVzIHRoZSB0b3VjaElEIG1heSBub3QgbWF0Y2ggYmVjYXVzZSBpdCB3YXMgZ3JhYmJlZCBmcm9tIHRoZSB0b3VjaHN0YXJ0IGV2ZW50IHdoZXJlYXMgdGhlIHBvaW50ZXIgZXZlbnQgaXMgdGhlIG9uZSB0aGF0IHRoZSBicm93c2VyIGRpc3BhdGNoZXMgZm9yIG1vdmUsIHNvIGlmIHRoZSBldmVudCB0YXJnZXQgbWF0Y2hlcyB0aGlzIERyYWdnYWJsZSdzIHRhcmdldCwgbGV0IGl0IHRocm91Z2guXG5cblxuICAgICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlLnBvaW50ZXJJZCAmJiB0b3VjaElEICYmIGUucG9pbnRlcklkICE9PSB0b3VjaElEKSB7XG4gICAgICAgIC8vZm9yIHNvbWUgTWljcm9zb2Z0IGJyb3dzZXJzLCB3ZSBtdXN0IGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8gdGhlIGRvYyByYXRoZXIgdGhhbiB0aGUgdHJpZ2dlciBzbyB0aGF0IHdoZW4gdGhlIGZpbmdlciBtb3ZlcyBvdXRzaWRlIHRoZSBib3VuZHMgb2YgdGhlIHRyaWdnZXIsIHRoaW5ncyBzdGlsbCB3b3JrLiBTbyBpZiB0aGUgZXZlbnQgd2UncmUgcmVjZWl2aW5nIGhhcyBhIHBvaW50ZXJJZCB0aGF0IGRvZXNuJ3QgbWF0Y2ggdGhlIHRvdWNoSUQsIGlnbm9yZSBpdCAoZm9yIG11bHRpLXRvdWNoKVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0b3VjaEV2ZW50VGFyZ2V0ICYmIGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgJiYgIXRvdWNoRHJhZ0F4aXMpIHtcbiAgICAgICAgLy9BbmRyb2lkIGJyb3dzZXJzIGZvcmNlIHVzIHRvIGRlY2lkZSBvbiB0aGUgZmlyc3QgXCJ0b3VjaG1vdmVcIiBldmVudCBpZiB3ZSBzaG91bGQgYWxsb3cgdGhlIGRlZmF1bHQgKHNjcm9sbGluZykgYmVoYXZpb3Igb3IgcHJldmVudERlZmF1bHQoKS4gT3RoZXJ3aXNlLCBhIFwidG91Y2hjYW5jZWxcIiB3aWxsIGJlIGZpcmVkIGFuZCB0aGVuIG5vIFwidG91Y2htb3ZlXCIgb3IgXCJ0b3VjaGVuZFwiIHdpbGwgZmlyZSBkdXJpbmcgdGhlIHNjcm9sbGluZyAobm8gZ29vZCkuXG4gICAgICAgIF9wb2ludDEueCA9IGUucGFnZVggLSAoaXNGaXhlZCA/IF9nZXREb2NTY3JvbGxMZWZ0KG93bmVyRG9jKSA6IDApO1xuICAgICAgICBfcG9pbnQxLnkgPSBlLnBhZ2VZIC0gKGlzRml4ZWQgPyBfZ2V0RG9jU2Nyb2xsVG9wKG93bmVyRG9jKSA6IDApO1xuICAgICAgICBtYXRyaXggJiYgbWF0cml4LmFwcGx5KF9wb2ludDEsIF9wb2ludDEpO1xuICAgICAgICBwb2ludGVyWCA9IF9wb2ludDEueDtcbiAgICAgICAgcG9pbnRlclkgPSBfcG9pbnQxLnk7XG4gICAgICAgIGR4ID0gTWF0aC5hYnMocG9pbnRlclggLSBzdGFydFBvaW50ZXJYKTtcbiAgICAgICAgZHkgPSBNYXRoLmFicyhwb2ludGVyWSAtIHN0YXJ0UG9pbnRlclkpO1xuXG4gICAgICAgIGlmIChkeCAhPT0gZHkgJiYgKGR4ID4gbWluaW11bU1vdmVtZW50IHx8IGR5ID4gbWluaW11bU1vdmVtZW50KSB8fCBfaXNBbmRyb2lkICYmIGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgPT09IHRvdWNoRHJhZ0F4aXMpIHtcbiAgICAgICAgICB0b3VjaERyYWdBeGlzID0gZHggPiBkeSAmJiBhbGxvd1ggPyBcInhcIiA6IFwieVwiO1xuXG4gICAgICAgICAgaWYgKGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgJiYgdG91Y2hEcmFnQXhpcyAhPT0gYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZykge1xuICAgICAgICAgICAgX2FkZExpc3RlbmVyKF93aW4sIFwidG91Y2hmb3JjZWNoYW5nZVwiLCBfcHJldmVudERlZmF1bHQpOyAvLyBwcmV2ZW50cyBuYXRpdmUgdG91Y2ggc2Nyb2xsaW5nIGZyb20gdGFraW5nIG92ZXIgaWYgdGhlIHVzZXIgc3RhcnRlZCBkcmFnZ2luZyBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uIGluIGlPUyBTYWZhcmlcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxmLnZhcnMubG9ja0F4aXNPblRvdWNoU2Nyb2xsICE9PSBmYWxzZSAmJiBhbGxvd1ggJiYgYWxsb3dZKSB7XG4gICAgICAgICAgICBzZWxmLmxvY2tlZEF4aXMgPSB0b3VjaERyYWdBeGlzID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCI7XG4gICAgICAgICAgICBfaXNGdW5jdGlvbihzZWxmLnZhcnMub25Mb2NrQXhpcykgJiYgc2VsZi52YXJzLm9uTG9ja0F4aXMuY2FsbChzZWxmLCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2lzQW5kcm9pZCAmJiBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nID09PSB0b3VjaERyYWdBeGlzKSB7XG4gICAgICAgICAgICBvblJlbGVhc2Uob3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi5hbGxvd0V2ZW50RGVmYXVsdCAmJiAoIWFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgfHwgdG91Y2hEcmFnQXhpcyAmJiBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nICE9PSB0b3VjaERyYWdBeGlzKSAmJiBvcmlnaW5hbEV2ZW50LmNhbmNlbGFibGUgIT09IGZhbHNlKSB7XG4gICAgICAgIF9wcmV2ZW50RGVmYXVsdChvcmlnaW5hbEV2ZW50KTtcblxuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNQcmV2ZW50aW5nRGVmYXVsdCkge1xuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLmF1dG9TY3JvbGwpIHtcbiAgICAgICAgY2hlY2tBdXRvU2Nyb2xsQm91bmRzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc2V0UG9pbnRlclBvc2l0aW9uKGUucGFnZVgsIGUucGFnZVksIGhhc01vdmVDYWxsYmFjayk7XG4gICAgfSxcbiAgICAgICAgc2V0UG9pbnRlclBvc2l0aW9uID0gZnVuY3Rpb24gc2V0UG9pbnRlclBvc2l0aW9uKHBvaW50ZXJYLCBwb2ludGVyWSwgaW52b2tlT25Nb3ZlKSB7XG4gICAgICB2YXIgZHJhZ1RvbGVyYW5jZSA9IDEgLSBzZWxmLmRyYWdSZXNpc3RhbmNlLFxuICAgICAgICAgIGVkZ2VUb2xlcmFuY2UgPSAxIC0gc2VsZi5lZGdlUmVzaXN0YW5jZSxcbiAgICAgICAgICBwcmV2UG9pbnRlclggPSBzZWxmLnBvaW50ZXJYLFxuICAgICAgICAgIHByZXZQb2ludGVyWSA9IHNlbGYucG9pbnRlclksXG4gICAgICAgICAgcHJldlN0YXJ0RWxlbWVudFkgPSBzdGFydEVsZW1lbnRZLFxuICAgICAgICAgIHByZXZYID0gc2VsZi54LFxuICAgICAgICAgIHByZXZZID0gc2VsZi55LFxuICAgICAgICAgIHByZXZFbmRYID0gc2VsZi5lbmRYLFxuICAgICAgICAgIHByZXZFbmRZID0gc2VsZi5lbmRZLFxuICAgICAgICAgIHByZXZFbmRSb3RhdGlvbiA9IHNlbGYuZW5kUm90YXRpb24sXG4gICAgICAgICAgcHJldkRpcnR5ID0gZGlydHksXG4gICAgICAgICAgeENoYW5nZSxcbiAgICAgICAgICB5Q2hhbmdlLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBkaWYsXG4gICAgICAgICAgdGVtcDtcbiAgICAgIHNlbGYucG9pbnRlclggPSBwb2ludGVyWDtcbiAgICAgIHNlbGYucG9pbnRlclkgPSBwb2ludGVyWTtcblxuICAgICAgaWYgKGlzRml4ZWQpIHtcbiAgICAgICAgcG9pbnRlclggLT0gX2dldERvY1Njcm9sbExlZnQob3duZXJEb2MpO1xuICAgICAgICBwb2ludGVyWSAtPSBfZ2V0RG9jU2Nyb2xsVG9wKG93bmVyRG9jKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICB5ID0gTWF0aC5hdGFuMihyb3RhdGlvbk9yaWdpbi55IC0gcG9pbnRlclksIHBvaW50ZXJYIC0gcm90YXRpb25PcmlnaW4ueCkgKiBfUkFEMkRFRztcbiAgICAgICAgZGlmID0gc2VsZi55IC0geTtcblxuICAgICAgICBpZiAoZGlmID4gMTgwKSB7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WSAtPSAzNjA7XG4gICAgICAgICAgc2VsZi55ID0geTtcbiAgICAgICAgfSBlbHNlIGlmIChkaWYgPCAtMTgwKSB7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WSArPSAzNjA7XG4gICAgICAgICAgc2VsZi55ID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnggIT09IHN0YXJ0RWxlbWVudFggfHwgTWF0aC5hYnMoc3RhcnRFbGVtZW50WSAtIHkpID4gbWluaW11bU1vdmVtZW50KSB7XG4gICAgICAgICAgc2VsZi55ID0geTtcbiAgICAgICAgICB4ID0gc3RhcnRFbGVtZW50WCArIChzdGFydEVsZW1lbnRZIC0geSkgKiBkcmFnVG9sZXJhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSBzdGFydEVsZW1lbnRYO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgdGVtcCA9IHBvaW50ZXJYICogbWF0cml4LmEgKyBwb2ludGVyWSAqIG1hdHJpeC5jICsgbWF0cml4LmU7XG4gICAgICAgICAgcG9pbnRlclkgPSBwb2ludGVyWCAqIG1hdHJpeC5iICsgcG9pbnRlclkgKiBtYXRyaXguZCArIG1hdHJpeC5mO1xuICAgICAgICAgIHBvaW50ZXJYID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHlDaGFuZ2UgPSBwb2ludGVyWSAtIHN0YXJ0UG9pbnRlclk7XG4gICAgICAgIHhDaGFuZ2UgPSBwb2ludGVyWCAtIHN0YXJ0UG9pbnRlclg7XG5cbiAgICAgICAgaWYgKHlDaGFuZ2UgPCBtaW5pbXVtTW92ZW1lbnQgJiYgeUNoYW5nZSA+IC1taW5pbXVtTW92ZW1lbnQpIHtcbiAgICAgICAgICB5Q2hhbmdlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4Q2hhbmdlIDwgbWluaW11bU1vdmVtZW50ICYmIHhDaGFuZ2UgPiAtbWluaW11bU1vdmVtZW50KSB7XG4gICAgICAgICAgeENoYW5nZSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHNlbGYubG9ja0F4aXMgfHwgc2VsZi5sb2NrZWRBeGlzKSAmJiAoeENoYW5nZSB8fCB5Q2hhbmdlKSkge1xuICAgICAgICAgIHRlbXAgPSBzZWxmLmxvY2tlZEF4aXM7XG5cbiAgICAgICAgICBpZiAoIXRlbXApIHtcbiAgICAgICAgICAgIHNlbGYubG9ja2VkQXhpcyA9IHRlbXAgPSBhbGxvd1ggJiYgTWF0aC5hYnMoeENoYW5nZSkgPiBNYXRoLmFicyh5Q2hhbmdlKSA/IFwieVwiIDogYWxsb3dZID8gXCJ4XCIgOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAodGVtcCAmJiBfaXNGdW5jdGlvbihzZWxmLnZhcnMub25Mb2NrQXhpcykpIHtcbiAgICAgICAgICAgICAgc2VsZi52YXJzLm9uTG9ja0F4aXMuY2FsbChzZWxmLCBzZWxmLnBvaW50ZXJFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRlbXAgPT09IFwieVwiKSB7XG4gICAgICAgICAgICB5Q2hhbmdlID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRlbXAgPT09IFwieFwiKSB7XG4gICAgICAgICAgICB4Q2hhbmdlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB4ID0gX3JvdW5kKHN0YXJ0RWxlbWVudFggKyB4Q2hhbmdlICogZHJhZ1RvbGVyYW5jZSk7XG4gICAgICAgIHkgPSBfcm91bmQoc3RhcnRFbGVtZW50WSArIHlDaGFuZ2UgKiBkcmFnVG9sZXJhbmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChzbmFwWCB8fCBzbmFwWSB8fCBzbmFwWFkpICYmIChzZWxmLnggIT09IHggfHwgc2VsZi55ICE9PSB5ICYmICFyb3RhdGlvbk1vZGUpKSB7XG4gICAgICAgIGlmIChzbmFwWFkpIHtcbiAgICAgICAgICBfdGVtcDEueCA9IHg7XG4gICAgICAgICAgX3RlbXAxLnkgPSB5O1xuICAgICAgICAgIHRlbXAgPSBzbmFwWFkoX3RlbXAxKTtcbiAgICAgICAgICB4ID0gX3JvdW5kKHRlbXAueCk7XG4gICAgICAgICAgeSA9IF9yb3VuZCh0ZW1wLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNuYXBYKSB7XG4gICAgICAgICAgeCA9IF9yb3VuZChzbmFwWCh4KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc25hcFkpIHtcbiAgICAgICAgICB5ID0gX3JvdW5kKHNuYXBZKHkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGFzQm91bmRzKSB7XG4gICAgICAgIGlmICh4ID4gbWF4WCkge1xuICAgICAgICAgIHggPSBtYXhYICsgTWF0aC5yb3VuZCgoeCAtIG1heFgpICogZWRnZVRvbGVyYW5jZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoeCA8IG1pblgpIHtcbiAgICAgICAgICB4ID0gbWluWCArIE1hdGgucm91bmQoKHggLSBtaW5YKSAqIGVkZ2VUb2xlcmFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgICAgIHkgPSBNYXRoLnJvdW5kKG1heFkgKyAoeSAtIG1heFkpICogZWRnZVRvbGVyYW5jZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh5IDwgbWluWSkge1xuICAgICAgICAgICAgeSA9IE1hdGgucm91bmQobWluWSArICh5IC0gbWluWSkgKiBlZGdlVG9sZXJhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYueCAhPT0geCB8fCBzZWxmLnkgIT09IHkgJiYgIXJvdGF0aW9uTW9kZSkge1xuICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgc2VsZi5lbmRSb3RhdGlvbiA9IHNlbGYueCA9IHNlbGYuZW5kWCA9IHg7XG4gICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgIHNlbGYueSA9IHNlbGYuZW5kWSA9IHk7XG4gICAgICAgICAgICBkaXJ0eSA9IHRydWU7IC8vYSBmbGFnIHRoYXQgaW5kaWNhdGVzIHdlIG5lZWQgdG8gcmVuZGVyIHRoZSB0YXJnZXQgbmV4dCB0aW1lIHRoZSBUd2VlbkxpdGUudGlja2VyIGRpc3BhdGNoZXMgYSBcInRpY2tcIiBldmVudCAodHlwaWNhbGx5IG9uIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSAtIHRoaXMgaXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gKHdlIHNob3VsZG4ndCByZW5kZXIgb24gZXZlcnkgbW92ZSBiZWNhdXNlIHNvbWV0aW1lcyBtYW55IG1vdmUgZXZlbnRzIGNhbiBnZXQgZGlzcGF0Y2hlZCBiZXR3ZWVuIHNjcmVlbiByZWZyZXNoZXMsIGFuZCB0aGF0J2QgYmUgd2FzdGVmdWwgdG8gcmVuZGVyIGV2ZXJ5IHRpbWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgc2VsZi54ID0gc2VsZi5lbmRYID0geDtcbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWludm9rZU9uTW92ZSB8fCBfZGlzcGF0Y2hFdmVudChzZWxmLCBcIm1vdmVcIiwgXCJvbk1vdmVcIikgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKCFzZWxmLmlzRHJhZ2dpbmcgJiYgc2VsZi5pc1ByZXNzZWQpIHtcbiAgICAgICAgICAgIHNlbGYuaXNEcmFnZ2luZyA9IGRyYWdnZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRyYWdzdGFydFwiLCBcIm9uRHJhZ1N0YXJ0XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL3JldmVydCBiZWNhdXNlIHRoZSBvbk1vdmUgcmV0dXJuZWQgZmFsc2UhXG4gICAgICAgICAgc2VsZi5wb2ludGVyWCA9IHByZXZQb2ludGVyWDtcbiAgICAgICAgICBzZWxmLnBvaW50ZXJZID0gcHJldlBvaW50ZXJZO1xuICAgICAgICAgIHN0YXJ0RWxlbWVudFkgPSBwcmV2U3RhcnRFbGVtZW50WTtcbiAgICAgICAgICBzZWxmLnggPSBwcmV2WDtcbiAgICAgICAgICBzZWxmLnkgPSBwcmV2WTtcbiAgICAgICAgICBzZWxmLmVuZFggPSBwcmV2RW5kWDtcbiAgICAgICAgICBzZWxmLmVuZFkgPSBwcmV2RW5kWTtcbiAgICAgICAgICBzZWxmLmVuZFJvdGF0aW9uID0gcHJldkVuZFJvdGF0aW9uO1xuICAgICAgICAgIGRpcnR5ID0gcHJldkRpcnR5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgLy9jYWxsZWQgd2hlbiB0aGUgbW91c2UvdG91Y2ggaXMgcmVsZWFzZWRcbiAgICBvblJlbGVhc2UgPSBmdW5jdGlvbiBvblJlbGVhc2UoZSwgZm9yY2UpIHtcbiAgICAgIGlmICghZW5hYmxlZCB8fCAhc2VsZi5pc1ByZXNzZWQgfHwgZSAmJiB0b3VjaElEICE9IG51bGwgJiYgIWZvcmNlICYmIChlLnBvaW50ZXJJZCAmJiBlLnBvaW50ZXJJZCAhPT0gdG91Y2hJRCAmJiBlLnRhcmdldCAhPT0gdGFyZ2V0IHx8IGUuY2hhbmdlZFRvdWNoZXMgJiYgIV9oYXNUb3VjaElEKGUuY2hhbmdlZFRvdWNoZXMsIHRvdWNoSUQpKSkge1xuICAgICAgICAvL2ZvciBzb21lIE1pY3Jvc29mdCBicm93c2Vycywgd2UgbXVzdCBhdHRhY2ggdGhlIGxpc3RlbmVyIHRvIHRoZSBkb2MgcmF0aGVyIHRoYW4gdGhlIHRyaWdnZXIgc28gdGhhdCB3aGVuIHRoZSBmaW5nZXIgbW92ZXMgb3V0c2lkZSB0aGUgYm91bmRzIG9mIHRoZSB0cmlnZ2VyLCB0aGluZ3Mgc3RpbGwgd29yay4gU28gaWYgdGhlIGV2ZW50IHdlJ3JlIHJlY2VpdmluZyBoYXMgYSBwb2ludGVySWQgdGhhdCBkb2Vzbid0IG1hdGNoIHRoZSB0b3VjaElELCBpZ25vcmUgaXQgKGZvciBtdWx0aS10b3VjaClcbiAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCAmJiBlICYmIGVuYWJsZWQgJiYgX3ByZXZlbnREZWZhdWx0KGUpOyAvLyBpbiBzb21lIGJyb3dzZXJzLCB3ZSBtdXN0IGxpc3RlbiBmb3IgbXVsdGlwbGUgZXZlbnQgdHlwZXMgbGlrZSB0b3VjaGVuZCwgcG9pbnRlcnVwLCBtb3VzZXVwLiBUaGUgZmlyc3QgdGltZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCwgd2UgcmVjb3JkIHdoZXRoZXIgb3Igbm90IHdlIF9wcmV2ZW50RGVmYXVsdCgpIHNvIHRoYXQgb24gZHVwbGljYXRlIGNhbGxzLCB3ZSBjYW4gZG8gdGhlIHNhbWUgaWYgbmVjZXNzYXJ5LlxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5pc1ByZXNzZWQgPSBmYWxzZTtcbiAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gZSxcbiAgICAgICAgICB3YXNEcmFnZ2luZyA9IHNlbGYuaXNEcmFnZ2luZyxcbiAgICAgICAgICBpc0NvbnRleHRNZW51UmVsZWFzZSA9IHNlbGYudmFycy5hbGxvd0NvbnRleHRNZW51ICYmIGUgJiYgKGUuY3RybEtleSB8fCBlLndoaWNoID4gMiksXG4gICAgICAgICAgcGxhY2Vob2xkZXJEZWxheWVkQ2FsbCA9IGdzYXAuZGVsYXllZENhbGwoMC4wMDEsIHJlbW92ZVBsYWNlaG9sZGVyKSxcbiAgICAgICAgICB0b3VjaGVzLFxuICAgICAgICAgIGksXG4gICAgICAgICAgc3ludGhldGljRXZlbnQsXG4gICAgICAgICAgZXZlbnRUYXJnZXQsXG4gICAgICAgICAgc3ludGhldGljQ2xpY2s7XG5cbiAgICAgIGlmICh0b3VjaEV2ZW50VGFyZ2V0KSB7XG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNoZW5kXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2htb3ZlXCIsIG9uTW92ZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2hjYW5jZWxcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIFwidG91Y2hzdGFydFwiLCBfb25NdWx0aVRvdWNoRG9jdW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBcIm1vdXNlbW92ZVwiLCBvbk1vdmUpO1xuICAgICAgfVxuXG4gICAgICBfcmVtb3ZlTGlzdGVuZXIoX3dpbiwgXCJ0b3VjaGZvcmNlY2hhbmdlXCIsIF9wcmV2ZW50RGVmYXVsdCk7XG5cbiAgICAgIGlmICghX3N1cHBvcnRzUG9pbnRlciB8fCAhdG91Y2hFdmVudFRhcmdldCkge1xuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIFwibW91c2V1cFwiLCBvblJlbGVhc2UpO1xuXG4gICAgICAgIGUgJiYgZS50YXJnZXQgJiYgX3JlbW92ZUxpc3RlbmVyKGUudGFyZ2V0LCBcIm1vdXNldXBcIiwgb25SZWxlYXNlKTtcbiAgICAgIH1cblxuICAgICAgZGlydHkgPSBmYWxzZTtcblxuICAgICAgaWYgKHdhc0RyYWdnaW5nKSB7XG4gICAgICAgIGRyYWdFbmRUaW1lID0gX2xhc3REcmFnVGltZSA9IF9nZXRUaW1lKCk7XG4gICAgICAgIHNlbGYuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBfcmVtb3ZlRnJvbVJlbmRlclF1ZXVlKHJlbmRlcik7XG5cbiAgICAgIGlmIChpc0NsaWNraW5nICYmICFpc0NvbnRleHRNZW51UmVsZWFzZSkge1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcihlLnRhcmdldCwgXCJjaGFuZ2VcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICAgIHNlbGYucG9pbnRlckV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zZXRTZWxlY3RhYmxlKHRyaWdnZXJzLCBmYWxzZSk7XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJyZWxlYXNlXCIsIFwib25SZWxlYXNlXCIpO1xuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiY2xpY2tcIiwgXCJvbkNsaWNrXCIpO1xuXG4gICAgICAgIGlzQ2xpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpID0gdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgX3NldFN0eWxlKHRyaWdnZXJzW2ldLCBcImN1cnNvclwiLCB2YXJzLmN1cnNvciB8fCAodmFycy5jdXJzb3IgIT09IGZhbHNlID8gX2RlZmF1bHRDdXJzb3IgOiBudWxsKSk7XG4gICAgICB9XG5cbiAgICAgIF9kcmFnQ291bnQtLTtcblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgdG91Y2hlcyA9IGUuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICAgICAgaWYgKHRvdWNoZXMpIHtcbiAgICAgICAgICAvL3RvdWNoIGV2ZW50cyBzdG9yZSB0aGUgZGF0YSBzbGlnaHRseSBkaWZmZXJlbnRseVxuICAgICAgICAgIGUgPSB0b3VjaGVzWzBdO1xuXG4gICAgICAgICAgaWYgKGUgIT09IHRvdWNoICYmIGUuaWRlbnRpZmllciAhPT0gdG91Y2hJRCkge1xuICAgICAgICAgICAgLy9Vc3VhbGx5IGNoYW5nZWRUb3VjaGVzWzBdIHdpbGwgYmUgd2hhdCB3ZSdyZSBsb29raW5nIGZvciwgYnV0IGluIGNhc2UgaXQncyBub3QsIGxvb2sgdGhyb3VnaCB0aGUgcmVzdCBvZiB0aGUgYXJyYXkuLi4oYW5kIEFuZHJvaWQgYnJvd3NlcnMgZG9uJ3QgcmV1c2UgdGhlIGV2ZW50IGxpa2UgaU9TKVxuICAgICAgICAgICAgaSA9IHRvdWNoZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICB3aGlsZSAoLS1pID4gLTEgJiYgKGUgPSB0b3VjaGVzW2ldKS5pZGVudGlmaWVyICE9PSB0b3VjaElEICYmIGUudGFyZ2V0ICE9PSB0YXJnZXQpIHt9XG5cbiAgICAgICAgICAgIGlmIChpIDwgMCAmJiAhZm9yY2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYucG9pbnRlckV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICAgICAgc2VsZi5wb2ludGVyWCA9IGUucGFnZVg7XG4gICAgICAgIHNlbGYucG9pbnRlclkgPSBlLnBhZ2VZO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNDb250ZXh0TWVudVJlbGVhc2UgJiYgb3JpZ2luYWxFdmVudCkge1xuICAgICAgICBfcHJldmVudERlZmF1bHQob3JpZ2luYWxFdmVudCk7XG5cbiAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCA9IHRydWU7XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJyZWxlYXNlXCIsIFwib25SZWxlYXNlXCIpO1xuICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbEV2ZW50ICYmICF3YXNEcmFnZ2luZykge1xuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGludGVycnVwdGVkICYmICh2YXJzLnNuYXAgfHwgdmFycy5ib3VuZHMpKSB7XG4gICAgICAgICAgLy9vdGhlcndpc2UsIGlmIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgb2JqZWN0IHdoaWxlIGl0J3MgYW5pbWF0aW5nIHRvIGEgc25hcHBlZCBwb3NpdGlvbiwgYW5kIHRoZW4gcmVsZWFzZXMgd2l0aG91dCBtb3ZpbmcgMyBwaXhlbHMsIGl0IHdpbGwganVzdCBzdGF5IHRoZXJlIChpdCBzaG91bGQgYW5pbWF0ZS9zbmFwKVxuICAgICAgICAgIGFuaW1hdGUodmFycy5pbmVydGlhIHx8IHZhcnMudGhyb3dQcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcInJlbGVhc2VcIiwgXCJvblJlbGVhc2VcIik7XG5cbiAgICAgICAgaWYgKCghX2lzQW5kcm9pZCB8fCBvcmlnaW5hbEV2ZW50LnR5cGUgIT09IFwidG91Y2htb3ZlXCIpICYmIG9yaWdpbmFsRXZlbnQudHlwZS5pbmRleE9mKFwiY2FuY2VsXCIpID09PSAtMSkge1xuICAgICAgICAgIC8vdG8gYWNjb21tb2RhdGUgbmF0aXZlIHNjcm9sbGluZyBvbiBBbmRyb2lkIGRldmljZXMsIHdlIGhhdmUgdG8gaW1tZWRpYXRlbHkgY2FsbCBvblJlbGVhc2UoKSBvbiB0aGUgZmlyc3QgdG91Y2htb3ZlIGV2ZW50LCBidXQgdGhhdCBzaG91bGRuJ3QgdHJpZ2dlciBhIFwiY2xpY2tcIi5cbiAgICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImNsaWNrXCIsIFwib25DbGlja1wiKTtcblxuICAgICAgICAgIGlmIChfZ2V0VGltZSgpIC0gY2xpY2tUaW1lIDwgMzAwKSB7XG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRvdWJsZWNsaWNrXCIsIFwib25Eb3VibGVDbGlja1wiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBldmVudFRhcmdldCA9IG9yaWdpbmFsRXZlbnQudGFyZ2V0IHx8IHRhcmdldDsgLy9vbGQgSUUgdXNlcyBzcmNFbGVtZW50XG5cbiAgICAgICAgICBjbGlja1RpbWUgPSBfZ2V0VGltZSgpO1xuXG4gICAgICAgICAgc3ludGhldGljQ2xpY2sgPSBmdW5jdGlvbiBzeW50aGV0aWNDbGljaygpIHtcbiAgICAgICAgICAgIC8vIHNvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgd29uJ3QgdHJ1c3Qgc2NyaXB0LWdlbmVyYXRlZCBjbGlja3MsIHNvIGlmIHRoZSB1c2VyIHRyaWVzIHRvIGNsaWNrIG9uIGEgdmlkZW8gdG8gcGxheSBpdCwgZm9yIGV4YW1wbGUsIGl0IHNpbXBseSB3b24ndCB3b3JrLiBTaW5jZSBhIHJlZ3VsYXIgXCJjbGlja1wiIGV2ZW50IHdpbGwgbW9zdCBsaWtlbHkgYmUgZ2VuZXJhdGVkIGFueXdheSAob25lIHRoYXQgaGFzIGl0cyBpc1RydXN0ZWQgZmxhZyBzZXQgdG8gdHJ1ZSksIHdlIG11c3Qgc2xpZ2h0bHkgZGVsYXkgb3VyIHNjcmlwdC1nZW5lcmF0ZWQgY2xpY2sgc28gdGhhdCB0aGUgXCJyZWFsXCIvdHJ1c3RlZCBvbmUgaXMgcHJpb3JpdGl6ZWQuIFJlbWVtYmVyLCB3aGVuIHRoZXJlIGFyZSBkdXBsaWNhdGUgZXZlbnRzIGluIHF1aWNrIHN1Y2Nlc3Npb24sIHdlIHN1cHByZXNzIGFsbCBidXQgdGhlIGZpcnN0IG9uZS4gU29tZSBicm93c2VycyBkb24ndCBldmVuIHRyaWdnZXIgdGhlIFwicmVhbFwiIG9uZSBhdCBhbGwsIHNvIG91ciBzeW50aGV0aWMgb25lIGlzIGEgc2FmZXR5IHZhbHZlIHRoYXQgZW5zdXJlcyB0aGF0IG5vIG1hdHRlciB3aGF0LCBhIGNsaWNrIGV2ZW50IGRvZXMgZ2V0IGRpc3BhdGNoZWQuXG4gICAgICAgICAgICBpZiAoY2xpY2tUaW1lICE9PSBjbGlja0Rpc3BhdGNoICYmIHNlbGYuZW5hYmxlZCgpICYmICFzZWxmLmlzUHJlc3NlZCAmJiAhb3JpZ2luYWxFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgIGlmIChldmVudFRhcmdldC5jbGljaykge1xuICAgICAgICAgICAgICAgIC8vc29tZSBicm93c2VycyAobGlrZSBtb2JpbGUgU2FmYXJpKSBkb24ndCBwcm9wZXJseSB0cmlnZ2VyIHRoZSBjbGljayBldmVudFxuICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmNsaWNrKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3duZXJEb2MuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBzeW50aGV0aWNFdmVudCA9IG93bmVyRG9jLmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7XG4gICAgICAgICAgICAgICAgc3ludGhldGljRXZlbnQuaW5pdE1vdXNlRXZlbnQoXCJjbGlja1wiLCB0cnVlLCB0cnVlLCBfd2luLCAxLCBzZWxmLnBvaW50ZXJFdmVudC5zY3JlZW5YLCBzZWxmLnBvaW50ZXJFdmVudC5zY3JlZW5ZLCBzZWxmLnBvaW50ZXJYLCBzZWxmLnBvaW50ZXJZLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgZXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudChzeW50aGV0aWNFdmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKCFfaXNBbmRyb2lkICYmICFvcmlnaW5hbEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIC8vaU9TIFNhZmFyaSByZXF1aXJlcyB0aGUgc3ludGhldGljIGNsaWNrIHRvIGhhcHBlbiBpbW1lZGlhdGVseSBvciBlbHNlIGl0IHNpbXBseSB3b24ndCB3b3JrLCBidXQgQW5kcm9pZCBkb2Vzbid0IHBsYXkgbmljZS5cbiAgICAgICAgICAgIGdzYXAuZGVsYXllZENhbGwoMC4wNSwgc3ludGhldGljQ2xpY2spOyAvL2luIGFkZGl0aW9uIHRvIHRoZSBpT1MgYnVnIHdvcmthcm91bmQsIHRoZXJlJ3MgYSBGaXJlZm94IGlzc3VlIHdpdGggY2xpY2tpbmcgb24gdGhpbmdzIGxpa2UgYSB2aWRlbyB0byBwbGF5LCBzbyB3ZSBtdXN0IGZha2UgYSBjbGljayBldmVudCBpbiBhIHNsaWdodGx5IGRlbGF5ZWQgZmFzaGlvbi4gUHJldmlvdXNseSwgd2UgbGlzdGVuZWQgZm9yIHRoZSBcImNsaWNrXCIgZXZlbnQgd2l0aCBcImNhcHR1cmVcIiBmYWxzZSB3aGljaCBzb2x2ZWQgdGhlIHZpZGVvLWNsaWNrLXRvLXBsYXkgaXNzdWUsIGJ1dCBpdCB3b3VsZCBhbGxvdyB0aGUgXCJjbGlja1wiIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQgdHdpY2UgbGlrZSBpZiB5b3Ugd2VyZSB1c2luZyBhIGpRdWVyeS5jbGljaygpIGJlY2F1c2UgdGhhdCB3YXMgaGFuZGxlZCBpbiB0aGUgY2FwdHVyZSBwaGFzZSwgdGh1cyB3ZSBoYWQgdG8gc3dpdGNoIHRvIHRoZSBjYXB0dXJlIHBoYXNlIHRvIGF2b2lkIHRoZSBkb3VibGUtZGlzcGF0Y2hpbmcsIGJ1dCBkbyB0aGUgZGVsYXllZCBzeW50aGV0aWMgY2xpY2suIERvbid0IGZpcmUgaXQgdG9vIGZhc3QgKGxpa2UgMC4wMDAwMSkgYmVjYXVzZSB3ZSB3YW50IHRvIGdpdmUgdGhlIG5hdGl2ZSBldmVudCBhIGNoYW5jZSB0byBmaXJlIGZpcnN0IGFzIGl0J3MgXCJ0cnVzdGVkXCIuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmltYXRlKHZhcnMuaW5lcnRpYSB8fCB2YXJzLnRocm93UHJvcHMpOyAvL3dpbGwgc2tpcCBpZiBpbmVydGlhL3Rocm93UHJvcHMgaXNuJ3QgZGVmaW5lZCBvciBJbmVydGlhUGx1Z2luIGlzbid0IGxvYWRlZC5cblxuICAgICAgICBpZiAoIXNlbGYuYWxsb3dFdmVudERlZmF1bHQgJiYgb3JpZ2luYWxFdmVudCAmJiAodmFycy5kcmFnQ2xpY2thYmxlcyAhPT0gZmFsc2UgfHwgIWlzQ2xpY2thYmxlLmNhbGwoc2VsZiwgb3JpZ2luYWxFdmVudC50YXJnZXQpKSAmJiB3YXNEcmFnZ2luZyAmJiAoIWFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgfHwgdG91Y2hEcmFnQXhpcyAmJiBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nID09PSB0b3VjaERyYWdBeGlzKSAmJiBvcmlnaW5hbEV2ZW50LmNhbmNlbGFibGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCA9IHRydWU7XG5cbiAgICAgICAgICBfcHJldmVudERlZmF1bHQob3JpZ2luYWxFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJyZWxlYXNlXCIsIFwib25SZWxlYXNlXCIpO1xuICAgICAgfVxuXG4gICAgICBpc1R3ZWVuaW5nKCkgJiYgcGxhY2Vob2xkZXJEZWxheWVkQ2FsbC5kdXJhdGlvbihzZWxmLnR3ZWVuLmR1cmF0aW9uKCkpOyAvL3N5bmMgdGhlIHRpbWluZyBzbyB0aGF0IHRoZSBwbGFjZWhvbGRlciBESVYgZ2V0c1xuXG4gICAgICB3YXNEcmFnZ2luZyAmJiBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRyYWdlbmRcIiwgXCJvbkRyYWdFbmRcIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgICAgICB1cGRhdGVTY3JvbGwgPSBmdW5jdGlvbiB1cGRhdGVTY3JvbGwoZSkge1xuICAgICAgaWYgKGUgJiYgc2VsZi5pc0RyYWdnaW5nICYmICFzY3JvbGxQcm94eSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gZS50YXJnZXQgfHwgdGFyZ2V0LnBhcmVudE5vZGUsXG4gICAgICAgICAgICBkZWx0YVggPSBwYXJlbnQuc2Nyb2xsTGVmdCAtIHBhcmVudC5fZ3NTY3JvbGxYLFxuICAgICAgICAgICAgZGVsdGFZID0gcGFyZW50LnNjcm9sbFRvcCAtIHBhcmVudC5fZ3NTY3JvbGxZO1xuXG4gICAgICAgIGlmIChkZWx0YVggfHwgZGVsdGFZKSB7XG4gICAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgc3RhcnRQb2ludGVyWCAtPSBkZWx0YVggKiBtYXRyaXguYSArIGRlbHRhWSAqIG1hdHJpeC5jO1xuICAgICAgICAgICAgc3RhcnRQb2ludGVyWSAtPSBkZWx0YVkgKiBtYXRyaXguZCArIGRlbHRhWCAqIG1hdHJpeC5iO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydFBvaW50ZXJYIC09IGRlbHRhWDtcbiAgICAgICAgICAgIHN0YXJ0UG9pbnRlclkgLT0gZGVsdGFZO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudC5fZ3NTY3JvbGxYICs9IGRlbHRhWDtcbiAgICAgICAgICBwYXJlbnQuX2dzU2Nyb2xsWSArPSBkZWx0YVk7XG4gICAgICAgICAgc2V0UG9pbnRlclBvc2l0aW9uKHNlbGYucG9pbnRlclgsIHNlbGYucG9pbnRlclkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgb25DbGljayA9IGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgLy90aGlzIHdhcyBhIGh1Z2UgcGFpbiBpbiB0aGUgbmVjayB0byBhbGlnbiBhbGwgdGhlIHZhcmlvdXMgYnJvd3NlcnMgYW5kIHRoZWlyIGJlaGF2aW9ycy4gQ2hyb21lLCBGaXJlZm94LCBTYWZhcmksIE9wZXJhLCBBbmRyb2lkLCBhbmQgTWljcm9zb2Z0IEVkZ2UgYWxsIGhhbmRsZSBldmVudHMgZGlmZmVyZW50bHkhIFNvbWUgd2lsbCBvbmx5IHRyaWdnZXIgbmF0aXZlIGJlaGF2aW9yIChsaWtlIGNoZWNrYm94IHRvZ2dsaW5nKSBmcm9tIHRydXN0ZWQgZXZlbnRzLiBPdGhlcnMgZG9uJ3QgZXZlbiBzdXBwb3J0IGlzVHJ1c3RlZCwgYnV0IHJlcXVpcmUgMiBldmVudHMgdG8gZmxvdyB0aHJvdWdoIGJlZm9yZSB0cmlnZ2VyaW5nIG5hdGl2ZSBiZWhhdmlvci4gRWRnZSB0cmVhdHMgZXZlcnl0aGluZyBhcyB0cnVzdGVkIGJ1dCBhbHNvIG1hbmRhdGVzIHRoYXQgMiBmbG93IHRocm91Z2ggdG8gdHJpZ2dlciB0aGUgY29ycmVjdCBuYXRpdmUgYmVoYXZpb3IuXG4gICAgICB2YXIgdGltZSA9IF9nZXRUaW1lKCksXG4gICAgICAgICAgcmVjZW50bHlDbGlja2VkID0gdGltZSAtIGNsaWNrVGltZSA8IDEwMCxcbiAgICAgICAgICByZWNlbnRseURyYWdnZWQgPSB0aW1lIC0gZHJhZ0VuZFRpbWUgPCA1MCxcbiAgICAgICAgICBhbHJlYWR5RGlzcGF0Y2hlZCA9IHJlY2VudGx5Q2xpY2tlZCAmJiBjbGlja0Rpc3BhdGNoID09PSBjbGlja1RpbWUsXG4gICAgICAgICAgZGVmYXVsdFByZXZlbnRlZCA9IHNlbGYucG9pbnRlckV2ZW50ICYmIHNlbGYucG9pbnRlckV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQsXG4gICAgICAgICAgYWxyZWFkeURpc3BhdGNoZWRUcnVzdGVkID0gcmVjZW50bHlDbGlja2VkICYmIHRydXN0ZWRDbGlja0Rpc3BhdGNoID09PSBjbGlja1RpbWUsXG4gICAgICAgICAgdHJ1c3RlZCA9IGUuaXNUcnVzdGVkIHx8IGUuaXNUcnVzdGVkID09IG51bGwgJiYgcmVjZW50bHlDbGlja2VkICYmIGFscmVhZHlEaXNwYXRjaGVkOyAvL25vdGU6IFNhZmFyaSBkb2Vzbid0IHN1cHBvcnQgaXNUcnVzdGVkLCBhbmQgaXQgd29uJ3QgcHJvcGVybHkgZXhlY3V0ZSBuYXRpdmUgYmVoYXZpb3IgKGxpa2UgdG9nZ2xpbmcgY2hlY2tib3hlcykgb24gdGhlIGZpcnN0IHN5bnRoZXRpYyBcImNsaWNrXCIgZXZlbnQgLSB3ZSBtdXN0IHdhaXQgZm9yIHRoZSAybmQgYW5kIHRyZWF0IGl0IGFzIHRydXN0ZWQgKGJ1dCBzdG9wIHByb3BhZ2F0aW9uIGF0IHRoYXQgcG9pbnQpLiBDb25mdXNpbmcsIEkga25vdy4gRG9uJ3QgeW91IGxvdmUgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmlsaXR5IGNoYWxsZW5nZXM/XG5cblxuICAgICAgaWYgKChhbHJlYWR5RGlzcGF0Y2hlZCB8fCByZWNlbnRseURyYWdnZWQgJiYgc2VsZi52YXJzLnN1cHByZXNzQ2xpY2tPbkRyYWcgIT09IGZhbHNlKSAmJiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjZW50bHlDbGlja2VkICYmICEoc2VsZi5wb2ludGVyRXZlbnQgJiYgc2VsZi5wb2ludGVyRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgJiYgKCFhbHJlYWR5RGlzcGF0Y2hlZCB8fCB0cnVzdGVkICYmICFhbHJlYWR5RGlzcGF0Y2hlZFRydXN0ZWQpKSB7XG4gICAgICAgIC8vbGV0IHRoZSBmaXJzdCBjbGljayBwYXNzIHRocm91Z2ggdW5oaW5kZXJlZC4gTGV0IHRoZSBuZXh0IG9uZSBvbmx5IGlmIGl0J3MgdHJ1c3RlZCwgdGhlbiBubyBtb3JlIChzdG9wIHF1aWNrLXN1Y2Nlc3Npb24gb25lcylcbiAgICAgICAgaWYgKHRydXN0ZWQgJiYgYWxyZWFkeURpc3BhdGNoZWQpIHtcbiAgICAgICAgICB0cnVzdGVkQ2xpY2tEaXNwYXRjaCA9IGNsaWNrVGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsaWNrRGlzcGF0Y2ggPSBjbGlja1RpbWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuaXNQcmVzc2VkIHx8IHJlY2VudGx5RHJhZ2dlZCB8fCByZWNlbnRseUNsaWNrZWQpIHtcbiAgICAgICAgaWYgKCF0cnVzdGVkIHx8ICFlLmRldGFpbCB8fCAhcmVjZW50bHlDbGlja2VkIHx8IGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICBfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFyZWNlbnRseUNsaWNrZWQgJiYgIXJlY2VudGx5RHJhZ2dlZCAmJiAhZHJhZ2dlZCkge1xuICAgICAgICAvLyBmb3Igc2NyaXB0LXRyaWdnZXJlZCBldmVudCBkaXNwYXRjaGVzLCBsaWtlIGVsZW1lbnQuY2xpY2soKVxuICAgICAgICBlICYmIGUudGFyZ2V0ICYmIChzZWxmLnBvaW50ZXJFdmVudCA9IGUpO1xuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiY2xpY2tcIiwgXCJvbkNsaWNrXCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIGxvY2FsaXplUG9pbnQgPSBmdW5jdGlvbiBsb2NhbGl6ZVBvaW50KHApIHtcbiAgICAgIHJldHVybiBtYXRyaXggPyB7XG4gICAgICAgIHg6IHAueCAqIG1hdHJpeC5hICsgcC55ICogbWF0cml4LmMgKyBtYXRyaXguZSxcbiAgICAgICAgeTogcC54ICogbWF0cml4LmIgKyBwLnkgKiBtYXRyaXguZCArIG1hdHJpeC5mXG4gICAgICB9IDoge1xuICAgICAgICB4OiBwLngsXG4gICAgICAgIHk6IHAueVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgb2xkID0gRHJhZ2dhYmxlLmdldCh0YXJnZXQpO1xuICAgIG9sZCAmJiBvbGQua2lsbCgpOyAvLyBhdm9pZHMgZHVwbGljYXRlcyAoYW4gZWxlbWVudCBjYW4gb25seSBiZSBjb250cm9sbGVkIGJ5IG9uZSBEcmFnZ2FibGUpXG4gICAgLy9naXZlIHRoZSB1c2VyIGFjY2VzcyB0byBzdGFydC9zdG9wIGRyYWdnaW5nLi4uXG5cbiAgICBfdGhpczIuc3RhcnREcmFnID0gZnVuY3Rpb24gKGV2ZW50LCBhbGlnbikge1xuICAgICAgdmFyIHIxLCByMiwgcDEsIHAyO1xuICAgICAgb25QcmVzcyhldmVudCB8fCBzZWxmLnBvaW50ZXJFdmVudCwgdHJ1ZSk7IC8vaWYgdGhlIHBvaW50ZXIgaXNuJ3Qgb24gdG9wIG9mIHRoZSBlbGVtZW50LCBhZGp1c3QgdGhpbmdzIGFjY29yZGluZ2x5XG5cbiAgICAgIGlmIChhbGlnbiAmJiAhc2VsZi5oaXRUZXN0KGV2ZW50IHx8IHNlbGYucG9pbnRlckV2ZW50KSkge1xuICAgICAgICByMSA9IF9wYXJzZVJlY3QoZXZlbnQgfHwgc2VsZi5wb2ludGVyRXZlbnQpO1xuICAgICAgICByMiA9IF9wYXJzZVJlY3QodGFyZ2V0KTtcbiAgICAgICAgcDEgPSBsb2NhbGl6ZVBvaW50KHtcbiAgICAgICAgICB4OiByMS5sZWZ0ICsgcjEud2lkdGggLyAyLFxuICAgICAgICAgIHk6IHIxLnRvcCArIHIxLmhlaWdodCAvIDJcbiAgICAgICAgfSk7XG4gICAgICAgIHAyID0gbG9jYWxpemVQb2ludCh7XG4gICAgICAgICAgeDogcjIubGVmdCArIHIyLndpZHRoIC8gMixcbiAgICAgICAgICB5OiByMi50b3AgKyByMi5oZWlnaHQgLyAyXG4gICAgICAgIH0pO1xuICAgICAgICBzdGFydFBvaW50ZXJYIC09IHAxLnggLSBwMi54O1xuICAgICAgICBzdGFydFBvaW50ZXJZIC09IHAxLnkgLSBwMi55O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGYuaXNEcmFnZ2luZykge1xuICAgICAgICBzZWxmLmlzRHJhZ2dpbmcgPSBkcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRyYWdzdGFydFwiLCBcIm9uRHJhZ1N0YXJ0XCIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpczIuZHJhZyA9IG9uTW92ZTtcblxuICAgIF90aGlzMi5lbmREcmFnID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBvblJlbGVhc2UoZSB8fCBzZWxmLnBvaW50ZXJFdmVudCwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIF90aGlzMi50aW1lU2luY2VEcmFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNlbGYuaXNEcmFnZ2luZyA/IDAgOiAoX2dldFRpbWUoKSAtIGRyYWdFbmRUaW1lKSAvIDEwMDA7XG4gICAgfTtcblxuICAgIF90aGlzMi50aW1lU2luY2VDbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX2dldFRpbWUoKSAtIGNsaWNrVGltZSkgLyAxMDAwO1xuICAgIH07XG5cbiAgICBfdGhpczIuaGl0VGVzdCA9IGZ1bmN0aW9uICh0YXJnZXQsIHRocmVzaG9sZCkge1xuICAgICAgcmV0dXJuIERyYWdnYWJsZS5oaXRUZXN0KHNlbGYudGFyZ2V0LCB0YXJnZXQsIHRocmVzaG9sZCk7XG4gICAgfTtcblxuICAgIF90aGlzMi5nZXREaXJlY3Rpb24gPSBmdW5jdGlvbiAoZnJvbSwgZGlhZ29uYWxUaHJlc2hvbGQpIHtcbiAgICAgIC8vZnJvbSBjYW4gYmUgXCJzdGFydFwiIChkZWZhdWx0KSwgXCJ2ZWxvY2l0eVwiLCBvciBhbiBlbGVtZW50XG4gICAgICB2YXIgbW9kZSA9IGZyb20gPT09IFwidmVsb2NpdHlcIiAmJiBJbmVydGlhUGx1Z2luID8gZnJvbSA6IF9pc09iamVjdChmcm9tKSAmJiAhcm90YXRpb25Nb2RlID8gXCJlbGVtZW50XCIgOiBcInN0YXJ0XCIsXG4gICAgICAgICAgeENoYW5nZSxcbiAgICAgICAgICB5Q2hhbmdlLFxuICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICByMSxcbiAgICAgICAgICByMjtcblxuICAgICAgaWYgKG1vZGUgPT09IFwiZWxlbWVudFwiKSB7XG4gICAgICAgIHIxID0gX3BhcnNlUmVjdChzZWxmLnRhcmdldCk7XG4gICAgICAgIHIyID0gX3BhcnNlUmVjdChmcm9tKTtcbiAgICAgIH1cblxuICAgICAgeENoYW5nZSA9IG1vZGUgPT09IFwic3RhcnRcIiA/IHNlbGYueCAtIHN0YXJ0RWxlbWVudFggOiBtb2RlID09PSBcInZlbG9jaXR5XCIgPyBJbmVydGlhUGx1Z2luLmdldFZlbG9jaXR5KHRhcmdldCwgeFByb3ApIDogcjEubGVmdCArIHIxLndpZHRoIC8gMiAtIChyMi5sZWZ0ICsgcjIud2lkdGggLyAyKTtcblxuICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICByZXR1cm4geENoYW5nZSA8IDAgPyBcImNvdW50ZXItY2xvY2t3aXNlXCIgOiBcImNsb2Nrd2lzZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlhZ29uYWxUaHJlc2hvbGQgPSBkaWFnb25hbFRocmVzaG9sZCB8fCAyO1xuICAgICAgICB5Q2hhbmdlID0gbW9kZSA9PT0gXCJzdGFydFwiID8gc2VsZi55IC0gc3RhcnRFbGVtZW50WSA6IG1vZGUgPT09IFwidmVsb2NpdHlcIiA/IEluZXJ0aWFQbHVnaW4uZ2V0VmVsb2NpdHkodGFyZ2V0LCB5UHJvcCkgOiByMS50b3AgKyByMS5oZWlnaHQgLyAyIC0gKHIyLnRvcCArIHIyLmhlaWdodCAvIDIpO1xuICAgICAgICByYXRpbyA9IE1hdGguYWJzKHhDaGFuZ2UgLyB5Q2hhbmdlKTtcbiAgICAgICAgZGlyZWN0aW9uID0gcmF0aW8gPCAxIC8gZGlhZ29uYWxUaHJlc2hvbGQgPyBcIlwiIDogeENoYW5nZSA8IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcblxuICAgICAgICBpZiAocmF0aW8gPCBkaWFnb25hbFRocmVzaG9sZCkge1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiArPSBcIi1cIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXJlY3Rpb24gKz0geUNoYW5nZSA8IDAgPyBcInVwXCIgOiBcImRvd25cIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlyZWN0aW9uO1xuICAgIH07XG5cbiAgICBfdGhpczIuYXBwbHlCb3VuZHMgPSBmdW5jdGlvbiAobmV3Qm91bmRzLCBzdGlja3kpIHtcbiAgICAgIHZhciB4LCB5LCBmb3JjZVplcm9WZWxvY2l0eSwgZSwgcGFyZW50LCBpc1Jvb3Q7XG5cbiAgICAgIGlmIChuZXdCb3VuZHMgJiYgdmFycy5ib3VuZHMgIT09IG5ld0JvdW5kcykge1xuICAgICAgICB2YXJzLmJvdW5kcyA9IG5ld0JvdW5kcztcbiAgICAgICAgcmV0dXJuIHNlbGYudXBkYXRlKHRydWUsIHN0aWNreSk7XG4gICAgICB9XG5cbiAgICAgIHN5bmNYWSh0cnVlKTtcbiAgICAgIGNhbGN1bGF0ZUJvdW5kcygpO1xuXG4gICAgICBpZiAoaGFzQm91bmRzICYmICFpc1R3ZWVuaW5nKCkpIHtcbiAgICAgICAgeCA9IHNlbGYueDtcbiAgICAgICAgeSA9IHNlbGYueTtcblxuICAgICAgICBpZiAoeCA+IG1heFgpIHtcbiAgICAgICAgICB4ID0gbWF4WDtcbiAgICAgICAgfSBlbHNlIGlmICh4IDwgbWluWCkge1xuICAgICAgICAgIHggPSBtaW5YO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgICAgeSA9IG1heFk7XG4gICAgICAgIH0gZWxzZSBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgICB5ID0gbWluWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnggIT09IHggfHwgc2VsZi55ICE9PSB5KSB7XG4gICAgICAgICAgZm9yY2VaZXJvVmVsb2NpdHkgPSB0cnVlO1xuICAgICAgICAgIHNlbGYueCA9IHNlbGYuZW5kWCA9IHg7XG5cbiAgICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgICBzZWxmLmVuZFJvdGF0aW9uID0geDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi55ID0gc2VsZi5lbmRZID0geTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgICAgcmVuZGVyKHRydWUpO1xuXG4gICAgICAgICAgaWYgKHNlbGYuYXV0b1Njcm9sbCAmJiAhc2VsZi5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICBfcmVjb3JkTWF4U2Nyb2xscyh0YXJnZXQucGFyZW50Tm9kZSk7XG5cbiAgICAgICAgICAgIGUgPSB0YXJnZXQ7XG4gICAgICAgICAgICBfd2luZG93UHJveHkuc2Nyb2xsVG9wID0gX3dpbi5wYWdlWU9mZnNldCAhPSBudWxsID8gX3dpbi5wYWdlWU9mZnNldCA6IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgIT0gbnVsbCA/IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgOiBvd25lckRvYy5ib2R5LnNjcm9sbFRvcDtcbiAgICAgICAgICAgIF93aW5kb3dQcm94eS5zY3JvbGxMZWZ0ID0gX3dpbi5wYWdlWE9mZnNldCAhPSBudWxsID8gX3dpbi5wYWdlWE9mZnNldCA6IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0ICE9IG51bGwgPyBvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCA6IG93bmVyRG9jLmJvZHkuc2Nyb2xsTGVmdDtcblxuICAgICAgICAgICAgd2hpbGUgKGUgJiYgIWlzUm9vdCkge1xuICAgICAgICAgICAgICAvL3dhbGsgdXAgdGhlIGNoYWluIGFuZCBzZW5zZSB3aGVyZXZlciB0aGUgc2Nyb2xsVG9wL3Njcm9sbExlZnQgZXhjZWVkcyB0aGUgbWF4aW11bS5cbiAgICAgICAgICAgICAgaXNSb290ID0gX2lzUm9vdChlLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICBwYXJlbnQgPSBpc1Jvb3QgPyBfd2luZG93UHJveHkgOiBlLnBhcmVudE5vZGU7XG5cbiAgICAgICAgICAgICAgaWYgKGFsbG93WSAmJiBwYXJlbnQuc2Nyb2xsVG9wID4gcGFyZW50Ll9nc01heFNjcm9sbFkpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc2Nyb2xsVG9wID0gcGFyZW50Ll9nc01heFNjcm9sbFk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYWxsb3dYICYmIHBhcmVudC5zY3JvbGxMZWZ0ID4gcGFyZW50Ll9nc01heFNjcm9sbFgpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc2Nyb2xsTGVmdCA9IHBhcmVudC5fZ3NNYXhTY3JvbGxYO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5pc1Rocm93aW5nICYmIChmb3JjZVplcm9WZWxvY2l0eSB8fCBzZWxmLmVuZFggPiBtYXhYIHx8IHNlbGYuZW5kWCA8IG1pblggfHwgc2VsZi5lbmRZID4gbWF4WSB8fCBzZWxmLmVuZFkgPCBtaW5ZKSkge1xuICAgICAgICAgIGFuaW1hdGUodmFycy5pbmVydGlhIHx8IHZhcnMudGhyb3dQcm9wcywgZm9yY2VaZXJvVmVsb2NpdHkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICBfdGhpczIudXBkYXRlID0gZnVuY3Rpb24gKGFwcGx5Qm91bmRzLCBzdGlja3ksIGlnbm9yZUV4dGVybmFsQ2hhbmdlcykge1xuICAgICAgaWYgKHN0aWNreSAmJiBzZWxmLmlzUHJlc3NlZCkge1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSBlbGVtZW50IHdhcyByZXBvc2l0aW9uZWQgaW4gdGhlIGRvY3VtZW50IGZsb3csIHRodXMgaXRzIHgveSBtYXkgYmUgaWRlbnRpY2FsIGJ1dCBpdHMgcG9zaXRpb24gaXMgYWN0dWFsbHkgcXVpdGUgZGlmZmVyZW50LlxuICAgICAgICB2YXIgbSA9IGdldEdsb2JhbE1hdHJpeCh0YXJnZXQpLFxuICAgICAgICAgICAgcCA9IGlubmVyTWF0cml4LmFwcGx5KHtcbiAgICAgICAgICB4OiBzZWxmLnggLSBzdGFydEVsZW1lbnRYLFxuICAgICAgICAgIHk6IHNlbGYueSAtIHN0YXJ0RWxlbWVudFlcbiAgICAgICAgfSksXG4gICAgICAgICAgICBtMiA9IGdldEdsb2JhbE1hdHJpeCh0YXJnZXQucGFyZW50Tm9kZSwgdHJ1ZSk7XG4gICAgICAgIG0yLmFwcGx5KHtcbiAgICAgICAgICB4OiBtLmUgLSBwLngsXG4gICAgICAgICAgeTogbS5mIC0gcC55XG4gICAgICAgIH0sIHApO1xuICAgICAgICBzZWxmLnggLT0gcC54IC0gbTIuZTtcbiAgICAgICAgc2VsZi55IC09IHAueSAtIG0yLmY7XG4gICAgICAgIHJlbmRlcih0cnVlKTtcbiAgICAgICAgcmVjb3JkU3RhcnRQb3NpdGlvbnMoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHggPSBzZWxmLngsXG4gICAgICAgICAgeSA9IHNlbGYueTtcbiAgICAgIHVwZGF0ZU1hdHJpeCghc3RpY2t5KTtcblxuICAgICAgaWYgKGFwcGx5Qm91bmRzKSB7XG4gICAgICAgIHNlbGYuYXBwbHlCb3VuZHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcnR5ICYmIGlnbm9yZUV4dGVybmFsQ2hhbmdlcyAmJiByZW5kZXIodHJ1ZSk7XG4gICAgICAgIHN5bmNYWSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0aWNreSkge1xuICAgICAgICBzZXRQb2ludGVyUG9zaXRpb24oc2VsZi5wb2ludGVyWCwgc2VsZi5wb2ludGVyWSk7XG4gICAgICAgIGRpcnR5ICYmIHJlbmRlcih0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuaXNQcmVzc2VkICYmICFzdGlja3kgJiYgKGFsbG93WCAmJiBNYXRoLmFicyh4IC0gc2VsZi54KSA+IDAuMDEgfHwgYWxsb3dZICYmIE1hdGguYWJzKHkgLSBzZWxmLnkpID4gMC4wMSAmJiAhcm90YXRpb25Nb2RlKSkge1xuICAgICAgICByZWNvcmRTdGFydFBvc2l0aW9ucygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5hdXRvU2Nyb2xsKSB7XG4gICAgICAgIF9yZWNvcmRNYXhTY3JvbGxzKHRhcmdldC5wYXJlbnROb2RlLCBzZWxmLmlzRHJhZ2dpbmcpO1xuXG4gICAgICAgIGNoZWNrQXV0b1Njcm9sbEJvdW5kcyA9IHNlbGYuaXNEcmFnZ2luZztcbiAgICAgICAgcmVuZGVyKHRydWUpOyAvL2luIGNhc2UgcmVwYXJlbnRpbmcgb2NjdXJyZWQuXG5cbiAgICAgICAgX3JlbW92ZVNjcm9sbExpc3RlbmVyKHRhcmdldCwgdXBkYXRlU2Nyb2xsKTtcblxuICAgICAgICBfYWRkU2Nyb2xsTGlzdGVuZXIodGFyZ2V0LCB1cGRhdGVTY3JvbGwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgX3RoaXMyLmVuYWJsZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgc2V0VmFycyA9IHtcbiAgICAgICAgbGF6eTogdHJ1ZVxuICAgICAgfSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHRyaWdnZXI7XG5cbiAgICAgIGlmICh2YXJzLmN1cnNvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgc2V0VmFycy5jdXJzb3IgPSB2YXJzLmN1cnNvciB8fCBfZGVmYXVsdEN1cnNvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGdzYXAudXRpbHMuY2hlY2tQcmVmaXgoXCJ0b3VjaENhbGxvdXRcIikpIHtcbiAgICAgICAgc2V0VmFycy50b3VjaENhbGxvdXQgPSBcIm5vbmVcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgIT09IFwic29mdFwiKSB7XG4gICAgICAgIF9zZXRUb3VjaEFjdGlvbkZvckFsbERlc2NlbmRhbnRzKHRyaWdnZXJzLCBhbGxvd1ggPT09IGFsbG93WSA/IFwibm9uZVwiIDogdmFycy5hbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nICYmIHRhcmdldC5zY3JvbGxIZWlnaHQgPT09IHRhcmdldC5jbGllbnRIZWlnaHQgPT09ICh0YXJnZXQuc2Nyb2xsV2lkdGggPT09IHRhcmdldC5jbGllbnRIZWlnaHQpIHx8IHZhcnMuYWxsb3dFdmVudERlZmF1bHQgPyBcIm1hbmlwdWxhdGlvblwiIDogYWxsb3dYID8gXCJwYW4teVwiIDogXCJwYW4teFwiKTsgLy8gU29tZSBicm93c2VycyBsaWtlIEludGVybmV0IEV4cGxvcmVyIHdpbGwgZmlyZSBhIHBvaW50ZXJjYW5jZWwgZXZlbnQgd2hlbiB0aGUgdXNlciBhdHRlbXB0cyB0byBkcmFnIHdoZW4gdG91Y2hBY3Rpb24gaXMgXCJtYW5pcHVsYXRlXCIgYmVjYXVzZSBpdCdzIHBlcmNlaXZlZCBhcyBhIHBhbi4gSWYgdGhlIGVsZW1lbnQgaGFzIHNjcm9sbGFibGUgY29udGVudCBpbiBvbmx5IG9uZSBkaXJlY3Rpb24sIHdlIHNob3VsZCB1c2UgcGFuLXggb3IgcGFuLXkgYWNjb3JkaW5nbHkgc28gdGhhdCB0aGUgcG9pbnRlcmNhbmNlbCBkb2Vzbid0IHByZXZlbnQgZHJhZ2dpbmcuXG5cblxuICAgICAgICBpID0gdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICAgIHRyaWdnZXIgPSB0cmlnZ2Vyc1tpXTtcbiAgICAgICAgICBfc3VwcG9ydHNQb2ludGVyIHx8IF9hZGRMaXN0ZW5lcih0cmlnZ2VyLCBcIm1vdXNlZG93blwiLCBvblByZXNzKTtcblxuICAgICAgICAgIF9hZGRMaXN0ZW5lcih0cmlnZ2VyLCBcInRvdWNoc3RhcnRcIiwgb25QcmVzcyk7XG5cbiAgICAgICAgICBfYWRkTGlzdGVuZXIodHJpZ2dlciwgXCJjbGlja1wiLCBvbkNsaWNrLCB0cnVlKTsgLy8gbm90ZTogdXNlZCB0byBwYXNzIHRydWUgZm9yIGNhcHR1cmUgYnV0IGl0IHByZXZlbnRlZCBjbGljay10by1wbGF5LXZpZGVvIGZ1bmN0aW9uYWxpdHkgaW4gRmlyZWZveC5cblxuXG4gICAgICAgICAgZ3NhcC5zZXQodHJpZ2dlciwgc2V0VmFycyk7XG5cbiAgICAgICAgICBpZiAodHJpZ2dlci5nZXRCQm94ICYmIHRyaWdnZXIub3duZXJTVkdFbGVtZW50ICYmIGFsbG93WCAhPT0gYWxsb3dZKSB7XG4gICAgICAgICAgICAvLyBhIGJ1ZyBpbiBjaHJvbWUgZG9lc24ndCByZXNwZWN0IHRvdWNoLWFjdGlvbiBvbiBTVkcgZWxlbWVudHMgLSBpdCBvbmx5IHdvcmtzIGlmIHdlIHNldCBpdCBvbiB0aGUgcGFyZW50IFNWRy5cbiAgICAgICAgICAgIGdzYXAuc2V0KHRyaWdnZXIub3duZXJTVkdFbGVtZW50LCB7XG4gICAgICAgICAgICAgIHRvdWNoQWN0aW9uOiB2YXJzLmFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgfHwgdmFycy5hbGxvd0V2ZW50RGVmYXVsdCA/IFwibWFuaXB1bGF0aW9uXCIgOiBhbGxvd1ggPyBcInBhbi15XCIgOiBcInBhbi14XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhcnMuYWxsb3dDb250ZXh0TWVudSB8fCBfYWRkTGlzdGVuZXIodHJpZ2dlciwgXCJjb250ZXh0bWVudVwiLCBvbkNvbnRleHRNZW51KTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zZXRTZWxlY3RhYmxlKHRyaWdnZXJzLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIF9hZGRTY3JvbGxMaXN0ZW5lcih0YXJnZXQsIHVwZGF0ZVNjcm9sbCk7XG5cbiAgICAgIGVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoSW5lcnRpYVBsdWdpbiAmJiB0eXBlICE9PSBcInNvZnRcIikge1xuICAgICAgICBJbmVydGlhUGx1Z2luLnRyYWNrKHNjcm9sbFByb3h5IHx8IHRhcmdldCwgeHlNb2RlID8gXCJ4LHlcIiA6IHJvdGF0aW9uTW9kZSA/IFwicm90YXRpb25cIiA6IFwidG9wLGxlZnRcIik7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5fZ3NEcmFnSUQgPSBpZCA9IFwiZFwiICsgX2xvb2t1cENvdW50Kys7XG4gICAgICBfbG9va3VwW2lkXSA9IHNlbGY7XG5cbiAgICAgIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICBzY3JvbGxQcm94eS5lbmFibGUoKTtcbiAgICAgICAgc2Nyb2xsUHJveHkuZWxlbWVudC5fZ3NEcmFnSUQgPSBpZDtcbiAgICAgIH1cblxuICAgICAgKHZhcnMuYm91bmRzIHx8IHJvdGF0aW9uTW9kZSkgJiYgcmVjb3JkU3RhcnRQb3NpdGlvbnMoKTtcbiAgICAgIHZhcnMuYm91bmRzICYmIHNlbGYuYXBwbHlCb3VuZHMoKTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICBfdGhpczIuZGlzYWJsZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgZHJhZ2dpbmcgPSBzZWxmLmlzRHJhZ2dpbmcsXG4gICAgICAgICAgaSA9IHRyaWdnZXJzLmxlbmd0aCxcbiAgICAgICAgICB0cmlnZ2VyO1xuXG4gICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgX3NldFN0eWxlKHRyaWdnZXJzW2ldLCBcImN1cnNvclwiLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgIT09IFwic29mdFwiKSB7XG4gICAgICAgIF9zZXRUb3VjaEFjdGlvbkZvckFsbERlc2NlbmRhbnRzKHRyaWdnZXJzLCBudWxsKTtcblxuICAgICAgICBpID0gdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICAgIHRyaWdnZXIgPSB0cmlnZ2Vyc1tpXTtcblxuICAgICAgICAgIF9zZXRTdHlsZSh0cmlnZ2VyLCBcInRvdWNoQ2FsbG91dFwiLCBudWxsKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0cmlnZ2VyLCBcIm1vdXNlZG93blwiLCBvblByZXNzKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0cmlnZ2VyLCBcInRvdWNoc3RhcnRcIiwgb25QcmVzcyk7XG5cbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodHJpZ2dlciwgXCJjbGlja1wiLCBvbkNsaWNrLCB0cnVlKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0cmlnZ2VyLCBcImNvbnRleHRtZW51XCIsIG9uQ29udGV4dE1lbnUpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3NldFNlbGVjdGFibGUodHJpZ2dlcnMsIHRydWUpO1xuXG4gICAgICAgIGlmICh0b3VjaEV2ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2hjYW5jZWxcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNoZW5kXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodG91Y2hFdmVudFRhcmdldCwgXCJ0b3VjaG1vdmVcIiwgb25Nb3ZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgXCJtb3VzZXVwXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBcIm1vdXNlbW92ZVwiLCBvbk1vdmUpO1xuICAgICAgfVxuXG4gICAgICBfcmVtb3ZlU2Nyb2xsTGlzdGVuZXIodGFyZ2V0LCB1cGRhdGVTY3JvbGwpO1xuXG4gICAgICBlbmFibGVkID0gZmFsc2U7XG5cbiAgICAgIGlmIChJbmVydGlhUGx1Z2luICYmIHR5cGUgIT09IFwic29mdFwiKSB7XG4gICAgICAgIEluZXJ0aWFQbHVnaW4udW50cmFjayhzY3JvbGxQcm94eSB8fCB0YXJnZXQsIHh5TW9kZSA/IFwieCx5XCIgOiByb3RhdGlvbk1vZGUgPyBcInJvdGF0aW9uXCIgOiBcInRvcCxsZWZ0XCIpO1xuICAgICAgICBzZWxmLnR3ZWVuICYmIHNlbGYudHdlZW4ua2lsbCgpO1xuICAgICAgfVxuXG4gICAgICBzY3JvbGxQcm94eSAmJiBzY3JvbGxQcm94eS5kaXNhYmxlKCk7XG5cbiAgICAgIF9yZW1vdmVGcm9tUmVuZGVyUXVldWUocmVuZGVyKTtcblxuICAgICAgc2VsZi5pc0RyYWdnaW5nID0gc2VsZi5pc1ByZXNzZWQgPSBpc0NsaWNraW5nID0gZmFsc2U7XG4gICAgICBkcmFnZ2luZyAmJiBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRyYWdlbmRcIiwgXCJvbkRyYWdFbmRcIik7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgX3RoaXMyLmVuYWJsZWQgPSBmdW5jdGlvbiAodmFsdWUsIHR5cGUpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdmFsdWUgPyBzZWxmLmVuYWJsZSh0eXBlKSA6IHNlbGYuZGlzYWJsZSh0eXBlKSA6IGVuYWJsZWQ7XG4gICAgfTtcblxuICAgIF90aGlzMi5raWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5pc1Rocm93aW5nID0gZmFsc2U7XG4gICAgICBzZWxmLnR3ZWVuICYmIHNlbGYudHdlZW4ua2lsbCgpO1xuICAgICAgc2VsZi5kaXNhYmxlKCk7XG4gICAgICBnc2FwLnNldCh0cmlnZ2Vycywge1xuICAgICAgICBjbGVhclByb3BzOiBcInVzZXJTZWxlY3RcIlxuICAgICAgfSk7XG4gICAgICBkZWxldGUgX2xvb2t1cFt0YXJnZXQuX2dzRHJhZ0lEXTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICBfdGhpczIucmV2ZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5raWxsKCk7XG4gICAgICB0aGlzLnN0eWxlcyAmJiB0aGlzLnN0eWxlcy5yZXZlcnQoKTtcbiAgICB9O1xuXG4gICAgaWYgKH50eXBlLmluZGV4T2YoXCJzY3JvbGxcIikpIHtcbiAgICAgIHNjcm9sbFByb3h5ID0gX3RoaXMyLnNjcm9sbFByb3h5ID0gbmV3IFNjcm9sbFByb3h5KHRhcmdldCwgX2V4dGVuZCh7XG4gICAgICAgIG9uS2lsbDogZnVuY3Rpb24gb25LaWxsKCkge1xuICAgICAgICAgIC8vU2Nyb2xsUHJveHkncyBvbktpbGwoKSBnZXRzIGNhbGxlZCBpZi93aGVuIHRoZSBTY3JvbGxQcm94eSBzZW5zZXMgdGhhdCB0aGUgdXNlciBpbnRlcmFjdGVkIHdpdGggdGhlIHNjcm9sbCBwb3NpdGlvbiBtYW51YWxseSAobGlrZSB1c2luZyB0aGUgc2Nyb2xsYmFyKS4gSUU5IGRvZXNuJ3QgZmlyZSB0aGUgXCJtb3VzZXVwXCIgcHJvcGVybHkgd2hlbiB1c2VycyBkcmFnIHRoZSBzY3JvbGxiYXIgb2YgYW4gZWxlbWVudCwgc28gdGhpcyB3b3JrcyBhcm91bmQgdGhhdCBpc3N1ZS5cbiAgICAgICAgICBzZWxmLmlzUHJlc3NlZCAmJiBvblJlbGVhc2UobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHZhcnMpKTsgLy9hIGJ1ZyBpbiBtYW55IEFuZHJvaWQgZGV2aWNlcycgc3RvY2sgYnJvd3NlciBjYXVzZXMgc2Nyb2xsVG9wIHRvIGdldCBmb3JjZWQgYmFjayB0byAwIGFmdGVyIGl0IGlzIGFsdGVyZWQgdmlhIEpTLCBzbyB3ZSBzZXQgb3ZlcmZsb3cgdG8gXCJoaWRkZW5cIiBvbiBtb2JpbGUvdG91Y2ggZGV2aWNlcyAodGhleSBoaWRlIHRoZSBzY3JvbGwgYmFyIGFueXdheSkuIFRoYXQgd29ya3MgYXJvdW5kIHRoZSBidWcuIChUaGlzIGJ1ZyBpcyBkaXNjdXNzZWQgYXQgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9hbmRyb2lkL2lzc3Vlcy9kZXRhaWw/aWQ9MTk2MjUpXG5cbiAgICAgIHRhcmdldC5zdHlsZS5vdmVyZmxvd1kgPSBhbGxvd1kgJiYgIV9pc1RvdWNoRGV2aWNlID8gXCJhdXRvXCIgOiBcImhpZGRlblwiO1xuICAgICAgdGFyZ2V0LnN0eWxlLm92ZXJmbG93WCA9IGFsbG93WCAmJiAhX2lzVG91Y2hEZXZpY2UgPyBcImF1dG9cIiA6IFwiaGlkZGVuXCI7XG4gICAgICB0YXJnZXQgPSBzY3JvbGxQcm94eS5jb250ZW50O1xuICAgIH1cblxuICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgIGtpbGxQcm9wcy5yb3RhdGlvbiA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAga2lsbFByb3BzW3hQcm9wXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAga2lsbFByb3BzW3lQcm9wXSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ3NDYWNoZS5mb3JjZTNEID0gXCJmb3JjZTNEXCIgaW4gdmFycyA/IHZhcnMuZm9yY2UzRCA6IHRydWU7IC8vb3RoZXJ3aXNlLCBub3JtYWwgZHJhZ2dpbmcgd291bGQgYmUgaW4gMkQgYW5kIHRoZW4gYXMgc29vbiBhcyBpdCdzIHJlbGVhc2VkIGFuZCB0aGVyZSdzIGFuIGluZXJ0aWEgdHdlZW4sIGl0J2QganVtcCB0byAzRCB3aGljaCBjYW4gY3JlYXRlIGFuIGluaXRpYWwganVtcCBkdWUgdG8gdGhlIHdvcmsgdGhlIGJyb3dzZXIgbXVzdCB0byBkbyBsYXllcml6ZSBpdC5cblxuICAgIF9jb250ZXh0KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMyKSk7XG5cbiAgICBfdGhpczIuZW5hYmxlKCk7XG5cbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgRHJhZ2dhYmxlLnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoY29yZSkge1xuICAgIGdzYXAgPSBjb3JlO1xuXG4gICAgX2luaXRDb3JlKCk7XG4gIH07XG5cbiAgRHJhZ2dhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSh0YXJnZXRzLCB2YXJzKSB7XG4gICAgX2NvcmVJbml0dGVkIHx8IF9pbml0Q29yZSh0cnVlKTtcbiAgICByZXR1cm4gX3RvQXJyYXkodGFyZ2V0cykubWFwKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBuZXcgRHJhZ2dhYmxlKHRhcmdldCwgdmFycyk7XG4gICAgfSk7XG4gIH07XG5cbiAgRHJhZ2dhYmxlLmdldCA9IGZ1bmN0aW9uIGdldCh0YXJnZXQpIHtcbiAgICByZXR1cm4gX2xvb2t1cFsoX3RvQXJyYXkodGFyZ2V0KVswXSB8fCB7fSkuX2dzRHJhZ0lEXTtcbiAgfTtcblxuICBEcmFnZ2FibGUudGltZVNpbmNlRHJhZyA9IGZ1bmN0aW9uIHRpbWVTaW5jZURyYWcoKSB7XG4gICAgcmV0dXJuIChfZ2V0VGltZSgpIC0gX2xhc3REcmFnVGltZSkgLyAxMDAwO1xuICB9O1xuXG4gIERyYWdnYWJsZS5oaXRUZXN0ID0gZnVuY3Rpb24gaGl0VGVzdChvYmoxLCBvYmoyLCB0aHJlc2hvbGQpIHtcbiAgICBpZiAob2JqMSA9PT0gb2JqMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciByMSA9IF9wYXJzZVJlY3Qob2JqMSksXG4gICAgICAgIHIyID0gX3BhcnNlUmVjdChvYmoyKSxcbiAgICAgICAgdG9wID0gcjEudG9wLFxuICAgICAgICBsZWZ0ID0gcjEubGVmdCxcbiAgICAgICAgcmlnaHQgPSByMS5yaWdodCxcbiAgICAgICAgYm90dG9tID0gcjEuYm90dG9tLFxuICAgICAgICB3aWR0aCA9IHIxLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSByMS5oZWlnaHQsXG4gICAgICAgIGlzT3V0c2lkZSA9IHIyLmxlZnQgPiByaWdodCB8fCByMi5yaWdodCA8IGxlZnQgfHwgcjIudG9wID4gYm90dG9tIHx8IHIyLmJvdHRvbSA8IHRvcCxcbiAgICAgICAgb3ZlcmxhcCxcbiAgICAgICAgYXJlYSxcbiAgICAgICAgaXNSYXRpbztcblxuICAgIGlmIChpc091dHNpZGUgfHwgIXRocmVzaG9sZCkge1xuICAgICAgcmV0dXJuICFpc091dHNpZGU7XG4gICAgfVxuXG4gICAgaXNSYXRpbyA9ICh0aHJlc2hvbGQgKyBcIlwiKS5pbmRleE9mKFwiJVwiKSAhPT0gLTE7XG4gICAgdGhyZXNob2xkID0gcGFyc2VGbG9hdCh0aHJlc2hvbGQpIHx8IDA7XG4gICAgb3ZlcmxhcCA9IHtcbiAgICAgIGxlZnQ6IE1hdGgubWF4KGxlZnQsIHIyLmxlZnQpLFxuICAgICAgdG9wOiBNYXRoLm1heCh0b3AsIHIyLnRvcClcbiAgICB9O1xuICAgIG92ZXJsYXAud2lkdGggPSBNYXRoLm1pbihyaWdodCwgcjIucmlnaHQpIC0gb3ZlcmxhcC5sZWZ0O1xuICAgIG92ZXJsYXAuaGVpZ2h0ID0gTWF0aC5taW4oYm90dG9tLCByMi5ib3R0b20pIC0gb3ZlcmxhcC50b3A7XG5cbiAgICBpZiAob3ZlcmxhcC53aWR0aCA8IDAgfHwgb3ZlcmxhcC5oZWlnaHQgPCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzUmF0aW8pIHtcbiAgICAgIHRocmVzaG9sZCAqPSAwLjAxO1xuICAgICAgYXJlYSA9IG92ZXJsYXAud2lkdGggKiBvdmVybGFwLmhlaWdodDtcbiAgICAgIHJldHVybiBhcmVhID49IHdpZHRoICogaGVpZ2h0ICogdGhyZXNob2xkIHx8IGFyZWEgPj0gcjIud2lkdGggKiByMi5oZWlnaHQgKiB0aHJlc2hvbGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG92ZXJsYXAud2lkdGggPiB0aHJlc2hvbGQgJiYgb3ZlcmxhcC5oZWlnaHQgPiB0aHJlc2hvbGQ7XG4gIH07XG5cbiAgcmV0dXJuIERyYWdnYWJsZTtcbn0oRXZlbnREaXNwYXRjaGVyKTtcblxuX3NldERlZmF1bHRzKERyYWdnYWJsZS5wcm90b3R5cGUsIHtcbiAgcG9pbnRlclg6IDAsXG4gIHBvaW50ZXJZOiAwLFxuICBzdGFydFg6IDAsXG4gIHN0YXJ0WTogMCxcbiAgZGVsdGFYOiAwLFxuICBkZWx0YVk6IDAsXG4gIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICBpc1ByZXNzZWQ6IGZhbHNlXG59KTtcblxuRHJhZ2dhYmxlLnpJbmRleCA9IDEwMDA7XG5EcmFnZ2FibGUudmVyc2lvbiA9IFwiMy4xMi41XCI7XG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oRHJhZ2dhYmxlKTtcbmV4cG9ydCB7IERyYWdnYWJsZSBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJfaW5oZXJpdHNMb29zZSIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiX19wcm90b19fIiwiZ2V0R2xvYmFsTWF0cml4IiwiTWF0cml4MkQiLCJnc2FwIiwiX3dpbiIsIl9kb2MiLCJfZG9jRWxlbWVudCIsIl9ib2R5IiwiX3RlbXBEaXYiLCJfcGxhY2Vob2xkZXJEaXYiLCJfY29yZUluaXR0ZWQiLCJfY2hlY2tQcmVmaXgiLCJfdG9BcnJheSIsIl9zdXBwb3J0c1Bhc3NpdmUiLCJfaXNUb3VjaERldmljZSIsIl90b3VjaEV2ZW50TG9va3VwIiwiX2lzTXVsdGlUb3VjaGluZyIsIl9pc0FuZHJvaWQiLCJJbmVydGlhUGx1Z2luIiwiX2RlZmF1bHRDdXJzb3IiLCJfc3VwcG9ydHNQb2ludGVyIiwiX2NvbnRleHQiLCJfZ2V0U3R5bGVTYXZlciIsIl9kcmFnQ291bnQiLCJfd2luZG93RXhpc3RzIiwid2luZG93IiwiX2dldEdTQVAiLCJyZWdpc3RlclBsdWdpbiIsIl9pc0Z1bmN0aW9uIiwidmFsdWUiLCJfaXNPYmplY3QiLCJfaXNVbmRlZmluZWQiLCJfZW1wdHlGdW5jIiwiX3RyYW5zZm9ybVByb3AiLCJfdHJhbnNmb3JtT3JpZ2luUHJvcCIsIl9yb3VuZCIsIk1hdGgiLCJyb3VuZCIsIl9pc0FycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiX2NyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwibnMiLCJlIiwiY3JlYXRlRWxlbWVudE5TIiwicmVwbGFjZSIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsIl9SQUQyREVHIiwiUEkiLCJfYmlnTnVtIiwiX2lkZW50aXR5TWF0cml4IiwiX2dldFRpbWUiLCJEYXRlIiwibm93IiwiZ2V0VGltZSIsIl9yZW5kZXJRdWV1ZSIsIl9sb29rdXAiLCJfbG9va3VwQ291bnQiLCJfY2xpY2thYmxlVGFnRXhwIiwiX2xhc3REcmFnVGltZSIsIl90ZW1wMSIsIl93aW5kb3dQcm94eSIsIl9jb3B5Iiwib2JqIiwiZmFjdG9yIiwiY29weSIsInAiLCJfZXh0ZW5kIiwiZGVmYXVsdHMiLCJfc2V0VG91Y2hBY3Rpb25Gb3JBbGxEZXNjZW5kYW50cyIsImVsZW1lbnRzIiwiaSIsImxlbmd0aCIsImNoaWxkcmVuIiwidG91Y2hBY3Rpb24iLCJyZW1vdmVQcm9wZXJ0eSIsIl9yZW5kZXJRdWV1ZVRpY2siLCJmb3JFYWNoIiwiZnVuYyIsIl9hZGRUb1JlbmRlclF1ZXVlIiwicHVzaCIsInRpY2tlciIsImFkZCIsIl9yZW5kZXJRdWV1ZVRpbWVvdXQiLCJyZW1vdmUiLCJfcmVtb3ZlRnJvbVJlbmRlclF1ZXVlIiwic3BsaWNlIiwidG8iLCJvdmVyd3JpdGUiLCJkZWxheSIsImR1cmF0aW9uIiwib25Db21wbGV0ZSIsImRhdGEiLCJfc2V0RGVmYXVsdHMiLCJfYWRkTGlzdGVuZXIiLCJlbGVtZW50IiwiY2FwdHVyZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJ0b3VjaFR5cGUiLCJwYXNzaXZlIiwiX3JlbW92ZUxpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIl9wcmV2ZW50RGVmYXVsdCIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJwcmV2ZW50TWFuaXB1bGF0aW9uIiwiX2hhc1RvdWNoSUQiLCJsaXN0IiwiSUQiLCJpZGVudGlmaWVyIiwiX29uTXVsdGlUb3VjaERvY3VtZW50RW5kIiwidG91Y2hlcyIsInRhcmdldCIsIl9vbk11bHRpVG91Y2hEb2N1bWVudCIsIl9nZXREb2NTY3JvbGxUb3AiLCJkb2MiLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsImRvY3VtZW50RWxlbWVudCIsImJvZHkiLCJfZ2V0RG9jU2Nyb2xsTGVmdCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsTGVmdCIsIl9hZGRTY3JvbGxMaXN0ZW5lciIsImNhbGxiYWNrIiwiX2lzUm9vdCIsInBhcmVudE5vZGUiLCJfcmVtb3ZlU2Nyb2xsTGlzdGVuZXIiLCJub2RlVHlwZSIsIl9nZXRNYXhTY3JvbGwiLCJheGlzIiwiZGltIiwic2Nyb2xsIiwiY2xpZW50IiwibWF4IiwiX3JlY29yZE1heFNjcm9sbHMiLCJza2lwQ3VycmVudCIsIngiLCJ5IiwiX2dzTWF4U2Nyb2xsWCIsIl9nc01heFNjcm9sbFkiLCJfZ3NTY3JvbGxYIiwiX2dzU2Nyb2xsWSIsIl9zZXRTdHlsZSIsInByb3BlcnR5IiwidG9Mb3dlckNhc2UiLCJfZ2V0Q29tcHV0ZWRTdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJFbGVtZW50IiwiaG9zdCIsIl90ZW1wUmVjdCIsIl9wYXJzZVJlY3QiLCJsZWZ0IiwidG9wIiwid2lkdGgiLCJyaWdodCIsImNsaWVudFdpZHRoIiwiaW5uZXJXaWR0aCIsImhlaWdodCIsImJvdHRvbSIsImlubmVySGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwib3duZXJEb2N1bWVudCIsInIiLCJwYWdlWCIsInBhZ2VZIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiX2Rpc3BhdGNoRXZlbnQiLCJjYWxsYmFja05hbWUiLCJ2YXJzIiwibGlzdGVuZXJzIiwiX2xpc3RlbmVycyIsInJlc3VsdCIsImFwcGx5IiwiY2FsbGJhY2tTY29wZSIsInBvaW50ZXJFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJfZ2V0Qm91bmRzIiwiY29udGV4dCIsIm9mZnNldCIsIm1pbiIsIm1pblgiLCJtaW5Sb3RhdGlvbiIsIm1pblkiLCJtYXhYIiwibWF4Um90YXRpb24iLCJtYXhZIiwiX2dldEVsZW1lbnRCb3VuZHMiLCJfcG9pbnQxIiwiaXNTVkciLCJnZXRCQm94Iiwib3duZXJTVkdFbGVtZW50IiwibWF0cml4IiwicDEiLCJwMiIsInAzIiwicDQiLCJiYm94IiwiY3MiLCJ2aWV3Qm94IiwiYmFzZVZhbCIsImJveFNpemluZyIsInBhcnNlRmxvYXQiLCJib3JkZXJMZWZ0V2lkdGgiLCJib3JkZXJSaWdodFdpZHRoIiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJCb3R0b21XaWR0aCIsIm11bHRpcGx5IiwiX3BhcnNlSW5lcnRpYSIsImRyYWdnYWJsZSIsInNuYXAiLCJmb3JjZVplcm9WZWxvY2l0eSIsImEiLCJsIiwiZW5kIiwiY2FsbCIsInZlbG9jaXR5IiwiX2lzQ2xpY2thYmxlIiwiZ2V0QXR0cmlidXRlIiwidGVzdCIsIm5vZGVOYW1lIiwiX3NldFNlbGVjdGFibGUiLCJzZWxlY3RhYmxlIiwib25kcmFnc3RhcnQiLCJvbnNlbGVjdHN0YXJ0Iiwic2V0IiwibGF6eSIsInVzZXJTZWxlY3QiLCJfaXNGaXhlZCIsInBvc2l0aW9uIiwiX3N1cHBvcnRzM0QiLCJfYWRkUGFkZGluZ0JSIiwiU2Nyb2xsUHJveHkiLCJ1dGlscyIsInRvQXJyYXkiLCJjb250ZW50IiwiZG9jdW1lbnQiLCJub2RlIiwiZmlyc3RDaGlsZCIsIm9mZnNldFRvcCIsIm9mZnNldExlZnQiLCJwcmV2VG9wIiwicHJldkxlZnQiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsImV4dHJhUGFkUmlnaHQiLCJtYXhMZWZ0IiwibWF4VG9wIiwiZWxlbWVudFdpZHRoIiwiZWxlbWVudEhlaWdodCIsImNvbnRlbnRIZWlnaHQiLCJuZXh0Tm9kZSIsInRyYW5zZm9ybVN0YXJ0IiwidHJhbnNmb3JtRW5kIiwiZm9yY2UzRCIsImZvcmNlIiwiYXJndW1lbnRzIiwiZGlmIiwib2xkT2Zmc2V0Iiwia2lsbFR3ZWVuc09mIiwib25LaWxsIiwiX3NraXAiLCJwYWRkaW5nUmlnaHQiLCJtYXhTY3JvbGxUb3AiLCJtYXhTY3JvbGxMZWZ0IiwiZGlzYWJsZSIsIm5leHRTaWJsaW5nIiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVDaGlsZCIsImVuYWJsZSIsImNhbGlicmF0ZSIsIndpZHRoTWF0Y2hlcyIsIm9mZnNldEhlaWdodCIsImRpc3BsYXkiLCJwYWRkaW5nTGVmdCIsIm92ZXJmbG93IiwidmVydGljYWxBbGlnbiIsInBhZGRpbmdCb3R0b20iLCJfaW5pdENvcmUiLCJyZXF1aXJlZCIsIm5hdiIsIm5hdmlnYXRvciIsIlBvaW50ZXJFdmVudCIsImNzc1RleHQiLCJjdXJzb3IiLCJ1c2VyQWdlbnQiLCJpbmRleE9mIiwiTWF4VG91Y2hQb2ludHMiLCJtc01heFRvdWNoUG9pbnRzIiwiZGl2IiwiY2hpbGQiLCJjaGlsZFN0eWxlIiwicGFyZW50IiwidmFsIiwidHlwZXMiLCJzdGFuZGFyZCIsInNwbGl0IiwiY29udmVydGVkIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJpc1ByZXNzZWQiLCJlbmREcmFnIiwicGx1Z2lucyIsImluZXJ0aWEiLCJjb3JlIiwiY2hlY2tQcmVmaXgiLCJnZXRTdHlsZVNhdmVyIiwiY29uc29sZSIsIndhcm4iLCJFdmVudERpc3BhdGNoZXIiLCJfcHJvdG8iLCJfdGhpcyIsIkRyYWdnYWJsZSIsIl9FdmVudERpc3BhdGNoZXIiLCJfdGhpczIiLCJzdHlsZXMiLCJyb3RhdGlvbiIsImRyYWdSZXNpc3RhbmNlIiwiZWRnZVJlc2lzdGFuY2UiLCJpc05hTiIsImxvY2tBeGlzIiwiYXV0b1Njcm9sbCIsImxvY2tlZEF4aXMiLCJhbGxvd0V2ZW50RGVmYXVsdCIsImdldFByb3BlcnR5IiwieHlNb2RlIiwicm90YXRpb25Nb2RlIiwieFByb3AiLCJ5UHJvcCIsImFsbG93WCIsImFsbG93WSIsIm1pbmltdW1Nb3ZlbWVudCIsInRyaWdnZXJzIiwidHJpZ2dlciIsImhhbmRsZSIsImtpbGxQcm9wcyIsImRyYWdFbmRUaW1lIiwiY2hlY2tBdXRvU2Nyb2xsQm91bmRzIiwiYXV0b1Njcm9sbE1hcmdpblRvcCIsImF1dG9TY3JvbGxNYXJnaW5SaWdodCIsImF1dG9TY3JvbGxNYXJnaW5Cb3R0b20iLCJhdXRvU2Nyb2xsTWFyZ2luTGVmdCIsImlzQ2xpY2thYmxlIiwiY2xpY2thYmxlVGVzdCIsImNsaWNrVGltZSIsImdzQ2FjaGUiLCJfZ3NhcCIsImdldENhY2hlIiwiaXNGaXhlZCIsImdldFByb3BBc051bSIsInVuaXQiLCJvd25lckRvYyIsImVuYWJsZWQiLCJzY3JvbGxQcm94eSIsInN0YXJ0UG9pbnRlclgiLCJzdGFydFBvaW50ZXJZIiwic3RhcnRFbGVtZW50WCIsInN0YXJ0RWxlbWVudFkiLCJoYXNCb3VuZHMiLCJoYXNEcmFnQ2FsbGJhY2siLCJoYXNNb3ZlQ2FsbGJhY2siLCJ0b3VjaCIsInRvdWNoSUQiLCJyb3RhdGlvbk9yaWdpbiIsImRpcnR5Iiwib2xkIiwic25hcFgiLCJzbmFwWSIsInNuYXBYWSIsImlzQ2xpY2tpbmciLCJ0b3VjaEV2ZW50VGFyZ2V0IiwiaW50ZXJydXB0ZWQiLCJhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nIiwidG91Y2hEcmFnQXhpcyIsImlzRGlzcGF0Y2hpbmciLCJjbGlja0Rpc3BhdGNoIiwidHJ1c3RlZENsaWNrRGlzcGF0Y2giLCJpc1ByZXZlbnRpbmdEZWZhdWx0IiwiaW5uZXJNYXRyaXgiLCJkcmFnZ2VkIiwib25Db250ZXh0TWVudSIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInJlbmRlciIsInN1cHByZXNzRXZlbnRzIiwiaXNEcmFnZ2luZyIsImF1dG9TY3JvbGxGYWN0b3IiLCJpc1Jvb3QiLCJyZWN0IiwicG9pbnRlclgiLCJwb2ludGVyWSIsImNoYW5nZVgiLCJjaGFuZ2VZIiwiZ2FwIiwic2Nyb2xsVG8iLCJzZXRQb2ludGVyUG9zaXRpb24iLCJkZWx0YVgiLCJyZW5kZXJUcmFuc2Zvcm0iLCJkZWx0YVkiLCJzeW5jWFkiLCJza2lwT25VcGRhdGUiLCJza2lwU25hcCIsInNuYXBwZWRWYWx1ZSIsInVuY2FjaGUiLCJpc1Rocm93aW5nIiwiYnVpbGRTbmFwRnVuYyIsIm4iLCJlZGdlVG9sZXJhbmNlIiwiY2xvc2VzdCIsImFic0RpZiIsImJ1aWxkUG9pbnRTbmFwRnVuYyIsInJhZGl1cyIsInBvaW50IiwiZHgiLCJkeSIsIm1pbkRpc3QiLCJkaXN0IiwiY2FsY3VsYXRlQm91bmRzIiwiYm91bmRzIiwidGFyZ2V0Qm91bmRzIiwic25hcElzUmF3IiwibGl2ZVNuYXAiLCJwb2ludHMiLCJvblRocm93Q29tcGxldGUiLCJvblRocm93SW50ZXJydXB0IiwiYW5pbWF0ZSIsInR3ZWVuIiwib3ZlcnNob290VG9sZXJhbmNlIiwicmVzaXN0YW5jZSIsInRocm93UmVzaXN0YW5jZSIsImxpbmtlZFByb3BzIiwibWluRHVyYXRpb24iLCJtYXhEdXJhdGlvbiIsIm92ZXJzaG9vdCIsImluaGVyaXQiLCJvbkludGVycnVwdCIsIm9uVXBkYXRlIiwiZmFzdE1vZGUiLCJvblVwZGF0ZVBhcmFtcyIsImVuZFgiLCJlbmRZIiwiZW5kUm90YXRpb24iLCJwbGF5IiwiYXBwbHlCb3VuZHMiLCJ1cGRhdGVNYXRyaXgiLCJzaGlmdFN0YXJ0Iiwic3RhcnQiLCJlcXVhbHMiLCJpbnZlcnNlIiwicmVjb3JkU3RhcnRQb3NpdGlvbnMiLCJvZmZzZXRYIiwib2Zmc2V0WSIsInBhcnNlZE9yaWdpbiIsImlzVHdlZW5pbmciLCJ4T3JpZ2luIiwieU9yaWdpbiIsImF0YW4yIiwic3RhcnRYIiwic3RhcnRZIiwiaXNBY3RpdmUiLCJyZW1vdmVQbGFjZWhvbGRlciIsIm9uUHJlc3MiLCJjdXJyZW50VGFyZ2V0Iiwib25SZWxlYXNlIiwib25Nb3ZlIiwiZHJhZ0NsaWNrYWJsZXMiLCJhbGxvd0NvbnRleHRNZW51IiwiY3RybEtleSIsIndoaWNoIiwiY2hhbmdlZFRvdWNoZXMiLCJwb2ludGVySWQiLCJraWxsIiwiekluZGV4Qm9vc3QiLCJ6SW5kZXgiLCJvbkRyYWciLCJkcmFnIiwibW92ZSIsImFjdGl2ZUN1cnNvciIsIm9yaWdpbmFsRXZlbnQiLCJhYnMiLCJsb2NrQXhpc09uVG91Y2hTY3JvbGwiLCJvbkxvY2tBeGlzIiwiY2FuY2VsYWJsZSIsImludm9rZU9uTW92ZSIsImRyYWdUb2xlcmFuY2UiLCJwcmV2UG9pbnRlclgiLCJwcmV2UG9pbnRlclkiLCJwcmV2U3RhcnRFbGVtZW50WSIsInByZXZYIiwicHJldlkiLCJwcmV2RW5kWCIsInByZXZFbmRZIiwicHJldkVuZFJvdGF0aW9uIiwicHJldkRpcnR5IiwieENoYW5nZSIsInlDaGFuZ2UiLCJ0ZW1wIiwiYyIsImIiLCJkIiwiZiIsIndhc0RyYWdnaW5nIiwiaXNDb250ZXh0TWVudVJlbGVhc2UiLCJwbGFjZWhvbGRlckRlbGF5ZWRDYWxsIiwiZGVsYXllZENhbGwiLCJzeW50aGV0aWNFdmVudCIsImV2ZW50VGFyZ2V0Iiwic3ludGhldGljQ2xpY2siLCJ0aHJvd1Byb3BzIiwiZGVmYXVsdFByZXZlbnRlZCIsImNsaWNrIiwiY3JlYXRlRXZlbnQiLCJpbml0TW91c2VFdmVudCIsInNjcmVlblgiLCJzY3JlZW5ZIiwidXBkYXRlU2Nyb2xsIiwib25DbGljayIsInRpbWUiLCJyZWNlbnRseUNsaWNrZWQiLCJyZWNlbnRseURyYWdnZWQiLCJhbHJlYWR5RGlzcGF0Y2hlZCIsImFscmVhZHlEaXNwYXRjaGVkVHJ1c3RlZCIsInRydXN0ZWQiLCJpc1RydXN0ZWQiLCJzdXBwcmVzc0NsaWNrT25EcmFnIiwiZGV0YWlsIiwibG9jYWxpemVQb2ludCIsInN0YXJ0RHJhZyIsImFsaWduIiwicjEiLCJyMiIsImhpdFRlc3QiLCJ0aW1lU2luY2VEcmFnIiwidGltZVNpbmNlQ2xpY2siLCJ0aHJlc2hvbGQiLCJnZXREaXJlY3Rpb24iLCJmcm9tIiwiZGlhZ29uYWxUaHJlc2hvbGQiLCJtb2RlIiwicmF0aW8iLCJkaXJlY3Rpb24iLCJnZXRWZWxvY2l0eSIsIm5ld0JvdW5kcyIsInN0aWNreSIsInVwZGF0ZSIsImlnbm9yZUV4dGVybmFsQ2hhbmdlcyIsIm0iLCJtMiIsInNldFZhcnMiLCJpZCIsInRvdWNoQ2FsbG91dCIsInRyYWNrIiwiX2dzRHJhZ0lEIiwiZHJhZ2dpbmciLCJ1bnRyYWNrIiwiY2xlYXJQcm9wcyIsInJldmVydCIsIm92ZXJmbG93WSIsIm92ZXJmbG93WCIsInJlZ2lzdGVyIiwidGFyZ2V0cyIsIm1hcCIsIm9iajEiLCJvYmoyIiwiaXNPdXRzaWRlIiwib3ZlcmxhcCIsImFyZWEiLCJpc1JhdGlvIiwidmVyc2lvbiIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Draggable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/EasePack.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/EasePack.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EasePack: function() { return /* binding */ EasePack; },\n/* harmony export */   ExpoScaleEase: function() { return /* binding */ ExpoScaleEase; },\n/* harmony export */   RoughEase: function() { return /* binding */ RoughEase; },\n/* harmony export */   SlowMo: function() { return /* binding */ SlowMo; },\n/* harmony export */   \"default\": function() { return /* binding */ EasePack; }\n/* harmony export */ });\n/*!\n * EasePack 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var gsap, _coreInitted, _registerEase, _getGSAP = function _getGSAP() {\n    return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _boolean = function _boolean(value, defaultValue) {\n    return !!(typeof value === \"undefined\" ? defaultValue : value && !~(value + \"\").indexOf(\"false\"));\n}, _initCore = function _initCore(core) {\n    gsap = core || _getGSAP();\n    if (gsap) {\n        _registerEase = gsap.registerEase; //add weighted ease capabilities to standard eases so users can do \"power2.inOut(0.8)\" for example to push everything toward the \"out\", or (-0.8) to push it toward the \"in\" (0 is neutral)\n        var eases = gsap.parseEase(), createConfig = function createConfig(ease) {\n            return function(ratio) {\n                var y = 0.5 + ratio / 2;\n                ease.config = function(p) {\n                    return ease(2 * (1 - p) * p * y + p * p);\n                };\n            };\n        }, p;\n        for(p in eases){\n            if (!eases[p].config) {\n                createConfig(eases[p]);\n            }\n        }\n        _registerEase(\"slow\", SlowMo);\n        _registerEase(\"expoScale\", ExpoScaleEase);\n        _registerEase(\"rough\", RoughEase);\n        for(p in EasePack){\n            p !== \"version\" && gsap.core.globals(p, EasePack[p]);\n        }\n        _coreInitted = 1;\n    }\n}, _createSlowMo = function _createSlowMo(linearRatio, power, yoyoMode) {\n    linearRatio = Math.min(1, linearRatio || 0.7);\n    var pow = linearRatio < 1 ? power || power === 0 ? power : 0.7 : 0, p1 = (1 - linearRatio) / 2, p3 = p1 + linearRatio, calcEnd = _boolean(yoyoMode);\n    return function(p) {\n        var r = p + (0.5 - p) * pow;\n        return p < p1 ? calcEnd ? 1 - (p = 1 - p / p1) * p : r - (p = 1 - p / p1) * p * p * p * r : p > p3 ? calcEnd ? p === 1 ? 0 : 1 - (p = (p - p3) / p1) * p : r + (p - r) * (p = (p - p3) / p1) * p * p * p : calcEnd ? 1 : r;\n    };\n}, _createExpoScale = function _createExpoScale(start, end, ease) {\n    var p1 = Math.log(end / start), p2 = end - start;\n    ease && (ease = gsap.parseEase(ease));\n    return function(p) {\n        return (start * Math.exp(p1 * (ease ? ease(p) : p)) - start) / p2;\n    };\n}, EasePoint = function EasePoint(time, value, next) {\n    this.t = time;\n    this.v = value;\n    if (next) {\n        this.next = next;\n        next.prev = this;\n        this.c = next.v - value;\n        this.gap = next.t - time;\n    }\n}, _createRoughEase = function _createRoughEase(vars) {\n    if (typeof vars !== \"object\") {\n        //users may pass in via a string, like \"rough(30)\"\n        vars = {\n            points: +vars || 20\n        };\n    }\n    var taper = vars.taper || \"none\", a = [], cnt = 0, points = (+vars.points || 20) | 0, i = points, randomize = _boolean(vars.randomize, true), clamp = _boolean(vars.clamp), template = gsap ? gsap.parseEase(vars.template) : 0, strength = (+vars.strength || 1) * 0.4, x, y, bump, invX, obj, pnt, recent;\n    while(--i > -1){\n        x = randomize ? Math.random() : 1 / points * i;\n        y = template ? template(x) : x;\n        if (taper === \"none\") {\n            bump = strength;\n        } else if (taper === \"out\") {\n            invX = 1 - x;\n            bump = invX * invX * strength;\n        } else if (taper === \"in\") {\n            bump = x * x * strength;\n        } else if (x < 0.5) {\n            //\"both\" (start)\n            invX = x * 2;\n            bump = invX * invX * 0.5 * strength;\n        } else {\n            //\"both\" (end)\n            invX = (1 - x) * 2;\n            bump = invX * invX * 0.5 * strength;\n        }\n        if (randomize) {\n            y += Math.random() * bump - bump * 0.5;\n        } else if (i % 2) {\n            y += bump * 0.5;\n        } else {\n            y -= bump * 0.5;\n        }\n        if (clamp) {\n            if (y > 1) {\n                y = 1;\n            } else if (y < 0) {\n                y = 0;\n            }\n        }\n        a[cnt++] = {\n            x: x,\n            y: y\n        };\n    }\n    a.sort(function(a, b) {\n        return a.x - b.x;\n    });\n    pnt = new EasePoint(1, 1, null);\n    i = points;\n    while(i--){\n        obj = a[i];\n        pnt = new EasePoint(obj.x, obj.y, pnt);\n    }\n    recent = new EasePoint(0, 0, pnt.t ? pnt : pnt.next);\n    return function(p) {\n        var pnt = recent;\n        if (p > pnt.t) {\n            while(pnt.next && p >= pnt.t){\n                pnt = pnt.next;\n            }\n            pnt = pnt.prev;\n        } else {\n            while(pnt.prev && p <= pnt.t){\n                pnt = pnt.prev;\n            }\n        }\n        recent = pnt;\n        return pnt.v + (p - pnt.t) / pnt.gap * pnt.c;\n    };\n};\nvar SlowMo = _createSlowMo(0.7);\nSlowMo.ease = SlowMo; //for backward compatibility\nSlowMo.config = _createSlowMo;\nvar ExpoScaleEase = _createExpoScale(1, 2);\nExpoScaleEase.config = _createExpoScale;\nvar RoughEase = _createRoughEase();\nRoughEase.ease = RoughEase; //for backward compatibility\nRoughEase.config = _createRoughEase;\nvar EasePack = {\n    SlowMo: SlowMo,\n    RoughEase: RoughEase,\n    ExpoScaleEase: ExpoScaleEase\n};\nfor(var p in EasePack){\n    EasePack[p].register = _initCore;\n    EasePack[p].version = \"3.12.5\";\n}\n_getGSAP() && gsap.registerPlugin(SlowMo);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9FYXNlUGFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCLEdBQ2xCLElBQUlBLE1BQ0FDLGNBQ0FDLGVBQ0FDLFdBQVcsU0FBU0E7SUFDdEIsT0FBT0gsUUFBUSxPQUFPSSxXQUFXLGVBQWdCSixDQUFBQSxPQUFPSSxPQUFPSixJQUFJLEtBQUtBLEtBQUtLLGNBQWMsSUFBSUw7QUFDakcsR0FDSU0sV0FBVyxTQUFTQSxTQUFTQyxLQUFLLEVBQUVDLFlBQVk7SUFDbEQsT0FBTyxDQUFDLENBQUUsUUFBT0QsVUFBVSxjQUFjQyxlQUFlRCxTQUFTLENBQUMsQ0FBQyxDQUFDQSxRQUFRLEVBQUMsRUFBR0UsT0FBTyxDQUFDLFFBQU87QUFDakcsR0FDSUMsWUFBWSxTQUFTQSxVQUFVQyxJQUFJO0lBQ3JDWCxPQUFPVyxRQUFRUjtJQUVmLElBQUlILE1BQU07UUFDUkUsZ0JBQWdCRixLQUFLWSxZQUFZLEVBQUUsMkxBQTJMO1FBRTlOLElBQUlDLFFBQVFiLEtBQUtjLFNBQVMsSUFDdEJDLGVBQWUsU0FBU0EsYUFBYUMsSUFBSTtZQUMzQyxPQUFPLFNBQVVDLEtBQUs7Z0JBQ3BCLElBQUlDLElBQUksTUFBTUQsUUFBUTtnQkFFdEJELEtBQUtHLE1BQU0sR0FBRyxTQUFVQyxDQUFDO29CQUN2QixPQUFPSixLQUFLLElBQUssS0FBSUksQ0FBQUEsSUFBS0EsSUFBSUYsSUFBSUUsSUFBSUE7Z0JBQ3hDO1lBQ0Y7UUFDRixHQUNJQTtRQUVKLElBQUtBLEtBQUtQLE1BQU87WUFDZixJQUFJLENBQUNBLEtBQUssQ0FBQ08sRUFBRSxDQUFDRCxNQUFNLEVBQUU7Z0JBQ3BCSixhQUFhRixLQUFLLENBQUNPLEVBQUU7WUFDdkI7UUFDRjtRQUVBbEIsY0FBYyxRQUFRbUI7UUFFdEJuQixjQUFjLGFBQWFvQjtR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QUtJLFNBQVU7SUFDdEJBLFFBQVEsQ0FBQ0osRUFBRSxDQUFDbUQsUUFBUSxHQUFHN0Q7SUFDdkJjLFFBQVEsQ0FBQ0osRUFBRSxDQUFDb0QsT0FBTyxHQUFHO0FBQ3hCO0FBRUFyRSxjQUFjSCxLQUFLSyxjQUFjLENBQUNnQjtBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9FYXNlUGFjay5qcz9kZTczIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRWFzZVBhY2sgMy4xMi41XG4gKiBodHRwczovL2dzYXAuY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyNCwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9nc2FwLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHU0FQIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIGdzYXAsXG4gICAgX2NvcmVJbml0dGVkLFxuICAgIF9yZWdpc3RlckVhc2UsXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9ib29sZWFuID0gZnVuY3Rpb24gX2Jvb2xlYW4odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gISEodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiID8gZGVmYXVsdFZhbHVlIDogdmFsdWUgJiYgIX4odmFsdWUgKyBcIlwiKS5pbmRleE9mKFwiZmFsc2VcIikpO1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoY29yZSkge1xuICBnc2FwID0gY29yZSB8fCBfZ2V0R1NBUCgpO1xuXG4gIGlmIChnc2FwKSB7XG4gICAgX3JlZ2lzdGVyRWFzZSA9IGdzYXAucmVnaXN0ZXJFYXNlOyAvL2FkZCB3ZWlnaHRlZCBlYXNlIGNhcGFiaWxpdGllcyB0byBzdGFuZGFyZCBlYXNlcyBzbyB1c2VycyBjYW4gZG8gXCJwb3dlcjIuaW5PdXQoMC44KVwiIGZvciBleGFtcGxlIHRvIHB1c2ggZXZlcnl0aGluZyB0b3dhcmQgdGhlIFwib3V0XCIsIG9yICgtMC44KSB0byBwdXNoIGl0IHRvd2FyZCB0aGUgXCJpblwiICgwIGlzIG5ldXRyYWwpXG5cbiAgICB2YXIgZWFzZXMgPSBnc2FwLnBhcnNlRWFzZSgpLFxuICAgICAgICBjcmVhdGVDb25maWcgPSBmdW5jdGlvbiBjcmVhdGVDb25maWcoZWFzZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyYXRpbykge1xuICAgICAgICB2YXIgeSA9IDAuNSArIHJhdGlvIC8gMjtcblxuICAgICAgICBlYXNlLmNvbmZpZyA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgcmV0dXJuIGVhc2UoMiAqICgxIC0gcCkgKiBwICogeSArIHAgKiBwKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgcDtcblxuICAgIGZvciAocCBpbiBlYXNlcykge1xuICAgICAgaWYgKCFlYXNlc1twXS5jb25maWcpIHtcbiAgICAgICAgY3JlYXRlQ29uZmlnKGVhc2VzW3BdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVnaXN0ZXJFYXNlKFwic2xvd1wiLCBTbG93TW8pO1xuXG4gICAgX3JlZ2lzdGVyRWFzZShcImV4cG9TY2FsZVwiLCBFeHBvU2NhbGVFYXNlKTtcblxuICAgIF9yZWdpc3RlckVhc2UoXCJyb3VnaFwiLCBSb3VnaEVhc2UpO1xuXG4gICAgZm9yIChwIGluIEVhc2VQYWNrKSB7XG4gICAgICBwICE9PSBcInZlcnNpb25cIiAmJiBnc2FwLmNvcmUuZ2xvYmFscyhwLCBFYXNlUGFja1twXSk7XG4gICAgfVxuXG4gICAgX2NvcmVJbml0dGVkID0gMTtcbiAgfVxufSxcbiAgICBfY3JlYXRlU2xvd01vID0gZnVuY3Rpb24gX2NyZWF0ZVNsb3dNbyhsaW5lYXJSYXRpbywgcG93ZXIsIHlveW9Nb2RlKSB7XG4gIGxpbmVhclJhdGlvID0gTWF0aC5taW4oMSwgbGluZWFyUmF0aW8gfHwgMC43KTtcblxuICB2YXIgcG93ID0gbGluZWFyUmF0aW8gPCAxID8gcG93ZXIgfHwgcG93ZXIgPT09IDAgPyBwb3dlciA6IDAuNyA6IDAsXG4gICAgICBwMSA9ICgxIC0gbGluZWFyUmF0aW8pIC8gMixcbiAgICAgIHAzID0gcDEgKyBsaW5lYXJSYXRpbyxcbiAgICAgIGNhbGNFbmQgPSBfYm9vbGVhbih5b3lvTW9kZSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgdmFyIHIgPSBwICsgKDAuNSAtIHApICogcG93O1xuICAgIHJldHVybiBwIDwgcDEgPyBjYWxjRW5kID8gMSAtIChwID0gMSAtIHAgLyBwMSkgKiBwIDogciAtIChwID0gMSAtIHAgLyBwMSkgKiBwICogcCAqIHAgKiByIDogcCA+IHAzID8gY2FsY0VuZCA/IHAgPT09IDEgPyAwIDogMSAtIChwID0gKHAgLSBwMykgLyBwMSkgKiBwIDogciArIChwIC0gcikgKiAocCA9IChwIC0gcDMpIC8gcDEpICogcCAqIHAgKiBwIDogY2FsY0VuZCA/IDEgOiByO1xuICB9O1xufSxcbiAgICBfY3JlYXRlRXhwb1NjYWxlID0gZnVuY3Rpb24gX2NyZWF0ZUV4cG9TY2FsZShzdGFydCwgZW5kLCBlYXNlKSB7XG4gIHZhciBwMSA9IE1hdGgubG9nKGVuZCAvIHN0YXJ0KSxcbiAgICAgIHAyID0gZW5kIC0gc3RhcnQ7XG4gIGVhc2UgJiYgKGVhc2UgPSBnc2FwLnBhcnNlRWFzZShlYXNlKSk7XG4gIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAoc3RhcnQgKiBNYXRoLmV4cChwMSAqIChlYXNlID8gZWFzZShwKSA6IHApKSAtIHN0YXJ0KSAvIHAyO1xuICB9O1xufSxcbiAgICBFYXNlUG9pbnQgPSBmdW5jdGlvbiBFYXNlUG9pbnQodGltZSwgdmFsdWUsIG5leHQpIHtcbiAgdGhpcy50ID0gdGltZTtcbiAgdGhpcy52ID0gdmFsdWU7XG5cbiAgaWYgKG5leHQpIHtcbiAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIG5leHQucHJldiA9IHRoaXM7XG4gICAgdGhpcy5jID0gbmV4dC52IC0gdmFsdWU7XG4gICAgdGhpcy5nYXAgPSBuZXh0LnQgLSB0aW1lO1xuICB9XG59LFxuICAgIF9jcmVhdGVSb3VnaEVhc2UgPSBmdW5jdGlvbiBfY3JlYXRlUm91Z2hFYXNlKHZhcnMpIHtcbiAgaWYgKHR5cGVvZiB2YXJzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgLy91c2VycyBtYXkgcGFzcyBpbiB2aWEgYSBzdHJpbmcsIGxpa2UgXCJyb3VnaCgzMClcIlxuICAgIHZhcnMgPSB7XG4gICAgICBwb2ludHM6ICt2YXJzIHx8IDIwXG4gICAgfTtcbiAgfVxuXG4gIHZhciB0YXBlciA9IHZhcnMudGFwZXIgfHwgXCJub25lXCIsXG4gICAgICBhID0gW10sXG4gICAgICBjbnQgPSAwLFxuICAgICAgcG9pbnRzID0gKCt2YXJzLnBvaW50cyB8fCAyMCkgfCAwLFxuICAgICAgaSA9IHBvaW50cyxcbiAgICAgIHJhbmRvbWl6ZSA9IF9ib29sZWFuKHZhcnMucmFuZG9taXplLCB0cnVlKSxcbiAgICAgIGNsYW1wID0gX2Jvb2xlYW4odmFycy5jbGFtcCksXG4gICAgICB0ZW1wbGF0ZSA9IGdzYXAgPyBnc2FwLnBhcnNlRWFzZSh2YXJzLnRlbXBsYXRlKSA6IDAsXG4gICAgICBzdHJlbmd0aCA9ICgrdmFycy5zdHJlbmd0aCB8fCAxKSAqIDAuNCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgYnVtcCxcbiAgICAgIGludlgsXG4gICAgICBvYmosXG4gICAgICBwbnQsXG4gICAgICByZWNlbnQ7XG5cbiAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgeCA9IHJhbmRvbWl6ZSA/IE1hdGgucmFuZG9tKCkgOiAxIC8gcG9pbnRzICogaTtcbiAgICB5ID0gdGVtcGxhdGUgPyB0ZW1wbGF0ZSh4KSA6IHg7XG5cbiAgICBpZiAodGFwZXIgPT09IFwibm9uZVwiKSB7XG4gICAgICBidW1wID0gc3RyZW5ndGg7XG4gICAgfSBlbHNlIGlmICh0YXBlciA9PT0gXCJvdXRcIikge1xuICAgICAgaW52WCA9IDEgLSB4O1xuICAgICAgYnVtcCA9IGludlggKiBpbnZYICogc3RyZW5ndGg7XG4gICAgfSBlbHNlIGlmICh0YXBlciA9PT0gXCJpblwiKSB7XG4gICAgICBidW1wID0geCAqIHggKiBzdHJlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHggPCAwLjUpIHtcbiAgICAgIC8vXCJib3RoXCIgKHN0YXJ0KVxuICAgICAgaW52WCA9IHggKiAyO1xuICAgICAgYnVtcCA9IGludlggKiBpbnZYICogMC41ICogc3RyZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXCJib3RoXCIgKGVuZClcbiAgICAgIGludlggPSAoMSAtIHgpICogMjtcbiAgICAgIGJ1bXAgPSBpbnZYICogaW52WCAqIDAuNSAqIHN0cmVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChyYW5kb21pemUpIHtcbiAgICAgIHkgKz0gTWF0aC5yYW5kb20oKSAqIGJ1bXAgLSBidW1wICogMC41O1xuICAgIH0gZWxzZSBpZiAoaSAlIDIpIHtcbiAgICAgIHkgKz0gYnVtcCAqIDAuNTtcbiAgICB9IGVsc2Uge1xuICAgICAgeSAtPSBidW1wICogMC41O1xuICAgIH1cblxuICAgIGlmIChjbGFtcCkge1xuICAgICAgaWYgKHkgPiAxKSB7XG4gICAgICAgIHkgPSAxO1xuICAgICAgfSBlbHNlIGlmICh5IDwgMCkge1xuICAgICAgICB5ID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhW2NudCsrXSA9IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcbiAgfVxuXG4gIGEuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLnggLSBiLng7XG4gIH0pO1xuICBwbnQgPSBuZXcgRWFzZVBvaW50KDEsIDEsIG51bGwpO1xuICBpID0gcG9pbnRzO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBvYmogPSBhW2ldO1xuICAgIHBudCA9IG5ldyBFYXNlUG9pbnQob2JqLngsIG9iai55LCBwbnQpO1xuICB9XG5cbiAgcmVjZW50ID0gbmV3IEVhc2VQb2ludCgwLCAwLCBwbnQudCA/IHBudCA6IHBudC5uZXh0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgdmFyIHBudCA9IHJlY2VudDtcblxuICAgIGlmIChwID4gcG50LnQpIHtcbiAgICAgIHdoaWxlIChwbnQubmV4dCAmJiBwID49IHBudC50KSB7XG4gICAgICAgIHBudCA9IHBudC5uZXh0O1xuICAgICAgfVxuXG4gICAgICBwbnQgPSBwbnQucHJldjtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKHBudC5wcmV2ICYmIHAgPD0gcG50LnQpIHtcbiAgICAgICAgcG50ID0gcG50LnByZXY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVjZW50ID0gcG50O1xuICAgIHJldHVybiBwbnQudiArIChwIC0gcG50LnQpIC8gcG50LmdhcCAqIHBudC5jO1xuICB9O1xufTtcblxuZXhwb3J0IHZhciBTbG93TW8gPSBfY3JlYXRlU2xvd01vKDAuNyk7XG5TbG93TW8uZWFzZSA9IFNsb3dNbzsgLy9mb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXG5TbG93TW8uY29uZmlnID0gX2NyZWF0ZVNsb3dNbztcbmV4cG9ydCB2YXIgRXhwb1NjYWxlRWFzZSA9IF9jcmVhdGVFeHBvU2NhbGUoMSwgMik7XG5FeHBvU2NhbGVFYXNlLmNvbmZpZyA9IF9jcmVhdGVFeHBvU2NhbGU7XG5leHBvcnQgdmFyIFJvdWdoRWFzZSA9IF9jcmVhdGVSb3VnaEVhc2UoKTtcblJvdWdoRWFzZS5lYXNlID0gUm91Z2hFYXNlOyAvL2ZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cblJvdWdoRWFzZS5jb25maWcgPSBfY3JlYXRlUm91Z2hFYXNlO1xuZXhwb3J0IHZhciBFYXNlUGFjayA9IHtcbiAgU2xvd01vOiBTbG93TW8sXG4gIFJvdWdoRWFzZTogUm91Z2hFYXNlLFxuICBFeHBvU2NhbGVFYXNlOiBFeHBvU2NhbGVFYXNlXG59O1xuXG5mb3IgKHZhciBwIGluIEVhc2VQYWNrKSB7XG4gIEVhc2VQYWNrW3BdLnJlZ2lzdGVyID0gX2luaXRDb3JlO1xuICBFYXNlUGFja1twXS52ZXJzaW9uID0gXCIzLjEyLjVcIjtcbn1cblxuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKFNsb3dNbyk7XG5leHBvcnQgeyBFYXNlUGFjayBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbImdzYXAiLCJfY29yZUluaXR0ZWQiLCJfcmVnaXN0ZXJFYXNlIiwiX2dldEdTQVAiLCJ3aW5kb3ciLCJyZWdpc3RlclBsdWdpbiIsIl9ib29sZWFuIiwidmFsdWUiLCJkZWZhdWx0VmFsdWUiLCJpbmRleE9mIiwiX2luaXRDb3JlIiwiY29yZSIsInJlZ2lzdGVyRWFzZSIsImVhc2VzIiwicGFyc2VFYXNlIiwiY3JlYXRlQ29uZmlnIiwiZWFzZSIsInJhdGlvIiwieSIsImNvbmZpZyIsInAiLCJTbG93TW8iLCJFeHBvU2NhbGVFYXNlIiwiUm91Z2hFYXNlIiwiRWFzZVBhY2siLCJnbG9iYWxzIiwiX2NyZWF0ZVNsb3dNbyIsImxpbmVhclJhdGlvIiwicG93ZXIiLCJ5b3lvTW9kZSIsIk1hdGgiLCJtaW4iLCJwb3ciLCJwMSIsInAzIiwiY2FsY0VuZCIsInIiLCJfY3JlYXRlRXhwb1NjYWxlIiwic3RhcnQiLCJlbmQiLCJsb2ciLCJwMiIsImV4cCIsIkVhc2VQb2ludCIsInRpbWUiLCJuZXh0IiwidCIsInYiLCJwcmV2IiwiYyIsImdhcCIsIl9jcmVhdGVSb3VnaEVhc2UiLCJ2YXJzIiwicG9pbnRzIiwidGFwZXIiLCJhIiwiY250IiwiaSIsInJhbmRvbWl6ZSIsImNsYW1wIiwidGVtcGxhdGUiLCJzdHJlbmd0aCIsIngiLCJidW1wIiwiaW52WCIsIm9iaiIsInBudCIsInJlY2VudCIsInJhbmRvbSIsInNvcnQiLCJiIiwicmVnaXN0ZXIiLCJ2ZXJzaW9uIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/EasePack.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/EaselPlugin.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/EaselPlugin.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EaselPlugin: function() { return /* binding */ EaselPlugin; },\n/* harmony export */   \"default\": function() { return /* binding */ EaselPlugin; }\n/* harmony export */ });\n/*!\n * EaselPlugin 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var gsap, _coreInitted, _win, _createJS, _ColorFilter, _ColorMatrixFilter, _colorProps = \"redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier,redOffset,greenOffset,blueOffset,alphaOffset\".split(\",\"), _windowExists = function _windowExists() {\n    return typeof window !== \"undefined\";\n}, _getGSAP = function _getGSAP() {\n    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _getCreateJS = function _getCreateJS() {\n    return _createJS || _win && _win.createjs || _win || {};\n}, _warn = function _warn(message) {\n    return console.warn(message);\n}, _cache = function _cache(target) {\n    var b = target.getBounds && target.getBounds();\n    if (!b) {\n        b = target.nominalBounds || {\n            x: 0,\n            y: 0,\n            width: 100,\n            height: 100\n        };\n        target.setBounds && target.setBounds(b.x, b.y, b.width, b.height);\n    }\n    target.cache && target.cache(b.x, b.y, b.width, b.height);\n    _warn(\"EaselPlugin: for filters to display in EaselJS, you must call the object's cache() method first. GSAP attempted to use the target's getBounds() for the cache but that may not be completely accurate. \" + target);\n}, _parseColorFilter = function _parseColorFilter(target, v, plugin) {\n    if (!_ColorFilter) {\n        _ColorFilter = _getCreateJS().ColorFilter;\n        if (!_ColorFilter) {\n            _warn(\"EaselPlugin error: The EaselJS ColorFilter JavaScript file wasn't loaded.\");\n        }\n    }\n    var filters = target.filters || [], i = filters.length, c, s, e, a, p, pt;\n    while(i--){\n        if (filters[i] instanceof _ColorFilter) {\n            s = filters[i];\n            break;\n        }\n    }\n    if (!s) {\n        s = new _ColorFilter();\n        filters.push(s);\n        target.filters = filters;\n    }\n    e = s.clone();\n    if (v.tint != null) {\n        c = gsap.utils.splitColor(v.tint);\n        a = v.tintAmount != null ? +v.tintAmount : 1;\n        e.redOffset = +c[0] * a;\n        e.greenOffset = +c[1] * a;\n        e.blueOffset = +c[2] * a;\n        e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1 - a;\n    } else {\n        for(p in v){\n            if (p !== \"exposure\") {\n                if (p !== \"brightness\") {\n                    e[p] = +v[p];\n                }\n            }\n        }\n    }\n    if (v.exposure != null) {\n        e.redOffset = e.greenOffset = e.blueOffset = 255 * (+v.exposure - 1);\n        e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1;\n    } else if (v.brightness != null) {\n        a = +v.brightness - 1;\n        e.redOffset = e.greenOffset = e.blueOffset = a > 0 ? a * 255 : 0;\n        e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1 - Math.abs(a);\n    }\n    i = 8;\n    while(i--){\n        p = _colorProps[i];\n        if (s[p] !== e[p]) {\n            pt = plugin.add(s, p, s[p], e[p], 0, 0, 0, 0, 0, 1);\n            if (pt) {\n                pt.op = \"easel_colorFilter\";\n            }\n        }\n    }\n    plugin._props.push(\"easel_colorFilter\");\n    if (!target.cacheID) {\n        _cache(target);\n    }\n}, _idMatrix = [\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0\n], _lumR = 0.212671, _lumG = 0.715160, _lumB = 0.072169, _applyMatrix = function _applyMatrix(m, m2) {\n    if (!(m instanceof Array) || !(m2 instanceof Array)) {\n        return m2;\n    }\n    var temp = [], i = 0, z = 0, y, x;\n    for(y = 0; y < 4; y++){\n        for(x = 0; x < 5; x++){\n            z = x === 4 ? m[i + 4] : 0;\n            temp[i + x] = m[i] * m2[x] + m[i + 1] * m2[x + 5] + m[i + 2] * m2[x + 10] + m[i + 3] * m2[x + 15] + z;\n        }\n        i += 5;\n    }\n    return temp;\n}, _setSaturation = function _setSaturation(m, n) {\n    if (isNaN(n)) {\n        return m;\n    }\n    var inv = 1 - n, r = inv * _lumR, g = inv * _lumG, b = inv * _lumB;\n    return _applyMatrix([\n        r + n,\n        g,\n        b,\n        0,\n        0,\n        r,\n        g + n,\n        b,\n        0,\n        0,\n        r,\n        g,\n        b + n,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n    ], m);\n}, _colorize = function _colorize(m, color, amount) {\n    if (isNaN(amount)) {\n        amount = 1;\n    }\n    var c = gsap.utils.splitColor(color), r = c[0] / 255, g = c[1] / 255, b = c[2] / 255, inv = 1 - amount;\n    return _applyMatrix([\n        inv + amount * r * _lumR,\n        amount * r * _lumG,\n        amount * r * _lumB,\n        0,\n        0,\n        amount * g * _lumR,\n        inv + amount * g * _lumG,\n        amount * g * _lumB,\n        0,\n        0,\n        amount * b * _lumR,\n        amount * b * _lumG,\n        inv + amount * b * _lumB,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n    ], m);\n}, _setHue = function _setHue(m, n) {\n    if (isNaN(n)) {\n        return m;\n    }\n    n *= Math.PI / 180;\n    var c = Math.cos(n), s = Math.sin(n);\n    return _applyMatrix([\n        _lumR + c * (1 - _lumR) + s * -_lumR,\n        _lumG + c * -_lumG + s * -_lumG,\n        _lumB + c * -_lumB + s * (1 - _lumB),\n        0,\n        0,\n        _lumR + c * -_lumR + s * 0.143,\n        _lumG + c * (1 - _lumG) + s * 0.14,\n        _lumB + c * -_lumB + s * -0.283,\n        0,\n        0,\n        _lumR + c * -_lumR + s * -(1 - _lumR),\n        _lumG + c * -_lumG + s * _lumG,\n        _lumB + c * (1 - _lumB) + s * _lumB,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1\n    ], m);\n}, _setContrast = function _setContrast(m, n) {\n    if (isNaN(n)) {\n        return m;\n    }\n    n += 0.01;\n    return _applyMatrix([\n        n,\n        0,\n        0,\n        0,\n        128 * (1 - n),\n        0,\n        n,\n        0,\n        0,\n        128 * (1 - n),\n        0,\n        0,\n        n,\n        0,\n        128 * (1 - n),\n        0,\n        0,\n        0,\n        1,\n        0\n    ], m);\n}, _parseColorMatrixFilter = function _parseColorMatrixFilter(target, v, plugin) {\n    if (!_ColorMatrixFilter) {\n        _ColorMatrixFilter = _getCreateJS().ColorMatrixFilter;\n        if (!_ColorMatrixFilter) {\n            _warn(\"EaselPlugin: The EaselJS ColorMatrixFilter JavaScript file wasn't loaded.\");\n        }\n    }\n    var filters = target.filters || [], i = filters.length, matrix, startMatrix, s, pg;\n    while(--i > -1){\n        if (filters[i] instanceof _ColorMatrixFilter) {\n            s = filters[i];\n            break;\n        }\n    }\n    if (!s) {\n        s = new _ColorMatrixFilter(_idMatrix.slice());\n        filters.push(s);\n        target.filters = filters;\n    }\n    startMatrix = s.matrix;\n    matrix = _idMatrix.slice();\n    if (v.colorize != null) {\n        matrix = _colorize(matrix, v.colorize, Number(v.colorizeAmount));\n    }\n    if (v.contrast != null) {\n        matrix = _setContrast(matrix, Number(v.contrast));\n    }\n    if (v.hue != null) {\n        matrix = _setHue(matrix, Number(v.hue));\n    }\n    if (v.saturation != null) {\n        matrix = _setSaturation(matrix, Number(v.saturation));\n    }\n    i = matrix.length;\n    while(--i > -1){\n        if (matrix[i] !== startMatrix[i]) {\n            pg = plugin.add(startMatrix, i, startMatrix[i], matrix[i], 0, 0, 0, 0, 0, 1);\n            if (pg) {\n                pg.op = \"easel_colorMatrixFilter\";\n            }\n        }\n    }\n    plugin._props.push(\"easel_colorMatrixFilter\");\n    if (!target.cacheID) {\n        _cache();\n    }\n    plugin._matrix = startMatrix;\n}, _initCore = function _initCore(core) {\n    gsap = core || _getGSAP();\n    if (_windowExists()) {\n        _win = window;\n    }\n    if (gsap) {\n        _coreInitted = 1;\n    }\n};\nvar EaselPlugin = {\n    version: \"3.12.5\",\n    name: \"easel\",\n    init: function init(target, value, tween, index, targets) {\n        if (!_coreInitted) {\n            _initCore();\n            if (!gsap) {\n                _warn(\"Please gsap.registerPlugin(EaselPlugin)\");\n            }\n        }\n        this.target = target;\n        var p, pt, tint, colorMatrix, end, labels, i;\n        for(p in value){\n            end = value[p];\n            if (p === \"colorFilter\" || p === \"tint\" || p === \"tintAmount\" || p === \"exposure\" || p === \"brightness\") {\n                if (!tint) {\n                    _parseColorFilter(target, value.colorFilter || value, this);\n                    tint = true;\n                }\n            } else if (p === \"saturation\" || p === \"contrast\" || p === \"hue\" || p === \"colorize\" || p === \"colorizeAmount\") {\n                if (!colorMatrix) {\n                    _parseColorMatrixFilter(target, value.colorMatrixFilter || value, this);\n                    colorMatrix = true;\n                }\n            } else if (p === \"frame\") {\n                if (typeof end === \"string\" && end.charAt(1) !== \"=\" && (labels = target.labels)) {\n                    for(i = 0; i < labels.length; i++){\n                        if (labels[i].label === end) {\n                            end = labels[i].position;\n                        }\n                    }\n                }\n                pt = this.add(target, \"gotoAndStop\", target.currentFrame, end, index, targets, Math.round, 0, 0, 1);\n                if (pt) {\n                    pt.op = p;\n                }\n            } else if (target[p] != null) {\n                this.add(target, p, \"get\", end);\n            }\n        }\n    },\n    render: function render(ratio, data) {\n        var pt = data._pt;\n        while(pt){\n            pt.r(ratio, pt.d);\n            pt = pt._next;\n        }\n        if (data.target.cacheID) {\n            data.target.updateCache();\n        }\n    },\n    register: _initCore\n};\nEaselPlugin.registerCreateJS = function(createjs) {\n    _createJS = createjs;\n};\n_getGSAP() && gsap.registerPlugin(EaselPlugin);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9FYXNlbFBsdWdpbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCLEdBQ2xCLElBQUlBLE1BQ0FDLGNBQ0FDLE1BQ0FDLFdBQ0FDLGNBQ0FDLG9CQUNBQyxjQUFjLDRHQUE0R0MsS0FBSyxDQUFDLE1BQ2hJQyxnQkFBZ0IsU0FBU0E7SUFDM0IsT0FBTyxPQUFPQyxXQUFXO0FBQzNCLEdBQ0lDLFdBQVcsU0FBU0E7SUFDdEIsT0FBT1YsUUFBUVEsbUJBQW9CUixDQUFBQSxPQUFPUyxPQUFPVCxJQUFJLEtBQUtBLEtBQUtXLGNBQWMsSUFBSVg7QUFDbkYsR0FDSVksZUFBZSxTQUFTQTtJQUMxQixPQUFPVCxhQUFhRCxRQUFRQSxLQUFLVyxRQUFRLElBQUlYLFFBQVEsQ0FBQztBQUN4RCxHQUNJWSxRQUFRLFNBQVNBLE1BQU1DLE9BQU87SUFDaEMsT0FBT0MsUUFBUUMsSUFBSSxDQUFDRjtBQUN0QixHQUNJRyxTQUFTLFNBQVNBLE9BQU9DLE1BQU07SUFDakMsSUFBSUMsSUFBSUQsT0FBT0UsU0FBUyxJQUFJRixPQUFPRSxTQUFTO0lBRTVDLElBQUksQ0FBQ0QsR0FBRztRQUNOQSxJQUFJRCxPQUFPRyxhQUFhLElBQUk7WUFDMUJDLEdBQUc7WUFDSEMsR0FBRztZQUNIQyxPQUFPO1lBQ1BDLFFBQVE7UUFDVjtRQUNBUCxPQUFPUSxTQUFTLElBQUlSLE9BQU9RLFNBQVMsQ0FBQ1AsRUFBRUcsQ0FBQyxFQUFFSCxFQUFFSSxDQUFDLEVBQUVKLEVBQUVLLEtBQUssRUFBRUwsRUFBRU0sTUFBTTtJQUNsRTtJQUVBUCxPQUFPUyxLQUFLLElBQUlULE9BQU9TLEtBQUssQ0FBQ1IsRUFBRUcsQ0FBQyxFQUFFSCxFQUFFSSxDQUFDLEVBQUVKLEVBQUVLLEtBQUssRUFBRUwsRUFBRU0sTUFBTTtJQUV4RFosTUFB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QyxPQUFPLEVBQUU7WUFDdkI0RCxLQUFLdEcsTUFBTSxDQUFDMEcsV0FBVztRQUN6QjtJQUNGO0lBQ0FDLFVBQVUzQjtBQUNaLEVBQUU7QUFFRkUsWUFBWTBCLGdCQUFnQixHQUFHLFNBQVVsSCxRQUFRO0lBQy9DVixZQUFZVTtBQUNkO0FBRUFILGNBQWNWLEtBQUtXLGNBQWMsQ0FBQzBGO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dzYXBAMy4xMi41L25vZGVfbW9kdWxlcy9nc2FwL0Vhc2VsUGx1Z2luLmpzP2U5YjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBFYXNlbFBsdWdpbiAzLjEyLjVcbiAqIGh0dHBzOi8vZ3NhcC5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDI0LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dzYXAuY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdTQVAgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgZ3NhcCxcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX3dpbixcbiAgICBfY3JlYXRlSlMsXG4gICAgX0NvbG9yRmlsdGVyLFxuICAgIF9Db2xvck1hdHJpeEZpbHRlcixcbiAgICBfY29sb3JQcm9wcyA9IFwicmVkTXVsdGlwbGllcixncmVlbk11bHRpcGxpZXIsYmx1ZU11bHRpcGxpZXIsYWxwaGFNdWx0aXBsaWVyLHJlZE9mZnNldCxncmVlbk9mZnNldCxibHVlT2Zmc2V0LGFscGhhT2Zmc2V0XCIuc3BsaXQoXCIsXCIpLFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgX3dpbmRvd0V4aXN0cygpICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX2dldENyZWF0ZUpTID0gZnVuY3Rpb24gX2dldENyZWF0ZUpTKCkge1xuICByZXR1cm4gX2NyZWF0ZUpTIHx8IF93aW4gJiYgX3dpbi5jcmVhdGVqcyB8fCBfd2luIHx8IHt9O1xufSxcbiAgICBfd2FybiA9IGZ1bmN0aW9uIF93YXJuKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbn0sXG4gICAgX2NhY2hlID0gZnVuY3Rpb24gX2NhY2hlKHRhcmdldCkge1xuICB2YXIgYiA9IHRhcmdldC5nZXRCb3VuZHMgJiYgdGFyZ2V0LmdldEJvdW5kcygpO1xuXG4gIGlmICghYikge1xuICAgIGIgPSB0YXJnZXQubm9taW5hbEJvdW5kcyB8fCB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiAxMDAsXG4gICAgICBoZWlnaHQ6IDEwMFxuICAgIH07XG4gICAgdGFyZ2V0LnNldEJvdW5kcyAmJiB0YXJnZXQuc2V0Qm91bmRzKGIueCwgYi55LCBiLndpZHRoLCBiLmhlaWdodCk7XG4gIH1cblxuICB0YXJnZXQuY2FjaGUgJiYgdGFyZ2V0LmNhY2hlKGIueCwgYi55LCBiLndpZHRoLCBiLmhlaWdodCk7XG5cbiAgX3dhcm4oXCJFYXNlbFBsdWdpbjogZm9yIGZpbHRlcnMgdG8gZGlzcGxheSBpbiBFYXNlbEpTLCB5b3UgbXVzdCBjYWxsIHRoZSBvYmplY3QncyBjYWNoZSgpIG1ldGhvZCBmaXJzdC4gR1NBUCBhdHRlbXB0ZWQgdG8gdXNlIHRoZSB0YXJnZXQncyBnZXRCb3VuZHMoKSBmb3IgdGhlIGNhY2hlIGJ1dCB0aGF0IG1heSBub3QgYmUgY29tcGxldGVseSBhY2N1cmF0ZS4gXCIgKyB0YXJnZXQpO1xufSxcbiAgICBfcGFyc2VDb2xvckZpbHRlciA9IGZ1bmN0aW9uIF9wYXJzZUNvbG9yRmlsdGVyKHRhcmdldCwgdiwgcGx1Z2luKSB7XG4gIGlmICghX0NvbG9yRmlsdGVyKSB7XG4gICAgX0NvbG9yRmlsdGVyID0gX2dldENyZWF0ZUpTKCkuQ29sb3JGaWx0ZXI7XG5cbiAgICBpZiAoIV9Db2xvckZpbHRlcikge1xuICAgICAgX3dhcm4oXCJFYXNlbFBsdWdpbiBlcnJvcjogVGhlIEVhc2VsSlMgQ29sb3JGaWx0ZXIgSmF2YVNjcmlwdCBmaWxlIHdhc24ndCBsb2FkZWQuXCIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWx0ZXJzID0gdGFyZ2V0LmZpbHRlcnMgfHwgW10sXG4gICAgICBpID0gZmlsdGVycy5sZW5ndGgsXG4gICAgICBjLFxuICAgICAgcyxcbiAgICAgIGUsXG4gICAgICBhLFxuICAgICAgcCxcbiAgICAgIHB0O1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoZmlsdGVyc1tpXSBpbnN0YW5jZW9mIF9Db2xvckZpbHRlcikge1xuICAgICAgcyA9IGZpbHRlcnNbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoIXMpIHtcbiAgICBzID0gbmV3IF9Db2xvckZpbHRlcigpO1xuICAgIGZpbHRlcnMucHVzaChzKTtcbiAgICB0YXJnZXQuZmlsdGVycyA9IGZpbHRlcnM7XG4gIH1cblxuICBlID0gcy5jbG9uZSgpO1xuXG4gIGlmICh2LnRpbnQgIT0gbnVsbCkge1xuICAgIGMgPSBnc2FwLnV0aWxzLnNwbGl0Q29sb3Iodi50aW50KTtcbiAgICBhID0gdi50aW50QW1vdW50ICE9IG51bGwgPyArdi50aW50QW1vdW50IDogMTtcbiAgICBlLnJlZE9mZnNldCA9ICtjWzBdICogYTtcbiAgICBlLmdyZWVuT2Zmc2V0ID0gK2NbMV0gKiBhO1xuICAgIGUuYmx1ZU9mZnNldCA9ICtjWzJdICogYTtcbiAgICBlLnJlZE11bHRpcGxpZXIgPSBlLmdyZWVuTXVsdGlwbGllciA9IGUuYmx1ZU11bHRpcGxpZXIgPSAxIC0gYTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHAgaW4gdikge1xuICAgICAgaWYgKHAgIT09IFwiZXhwb3N1cmVcIikgaWYgKHAgIT09IFwiYnJpZ2h0bmVzc1wiKSB7XG4gICAgICAgIGVbcF0gPSArdltwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodi5leHBvc3VyZSAhPSBudWxsKSB7XG4gICAgZS5yZWRPZmZzZXQgPSBlLmdyZWVuT2Zmc2V0ID0gZS5ibHVlT2Zmc2V0ID0gMjU1ICogKCt2LmV4cG9zdXJlIC0gMSk7XG4gICAgZS5yZWRNdWx0aXBsaWVyID0gZS5ncmVlbk11bHRpcGxpZXIgPSBlLmJsdWVNdWx0aXBsaWVyID0gMTtcbiAgfSBlbHNlIGlmICh2LmJyaWdodG5lc3MgIT0gbnVsbCkge1xuICAgIGEgPSArdi5icmlnaHRuZXNzIC0gMTtcbiAgICBlLnJlZE9mZnNldCA9IGUuZ3JlZW5PZmZzZXQgPSBlLmJsdWVPZmZzZXQgPSBhID4gMCA/IGEgKiAyNTUgOiAwO1xuICAgIGUucmVkTXVsdGlwbGllciA9IGUuZ3JlZW5NdWx0aXBsaWVyID0gZS5ibHVlTXVsdGlwbGllciA9IDEgLSBNYXRoLmFicyhhKTtcbiAgfVxuXG4gIGkgPSA4O1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBwID0gX2NvbG9yUHJvcHNbaV07XG5cbiAgICBpZiAoc1twXSAhPT0gZVtwXSkge1xuICAgICAgcHQgPSBwbHVnaW4uYWRkKHMsIHAsIHNbcF0sIGVbcF0sIDAsIDAsIDAsIDAsIDAsIDEpO1xuXG4gICAgICBpZiAocHQpIHtcbiAgICAgICAgcHQub3AgPSBcImVhc2VsX2NvbG9yRmlsdGVyXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcGx1Z2luLl9wcm9wcy5wdXNoKFwiZWFzZWxfY29sb3JGaWx0ZXJcIik7XG5cbiAgaWYgKCF0YXJnZXQuY2FjaGVJRCkge1xuICAgIF9jYWNoZSh0YXJnZXQpO1xuICB9XG59LFxuICAgIF9pZE1hdHJpeCA9IFsxLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxLCAwXSxcbiAgICBfbHVtUiA9IDAuMjEyNjcxLFxuICAgIF9sdW1HID0gMC43MTUxNjAsXG4gICAgX2x1bUIgPSAwLjA3MjE2OSxcbiAgICBfYXBwbHlNYXRyaXggPSBmdW5jdGlvbiBfYXBwbHlNYXRyaXgobSwgbTIpIHtcbiAgaWYgKCEobSBpbnN0YW5jZW9mIEFycmF5KSB8fCAhKG0yIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgcmV0dXJuIG0yO1xuICB9XG5cbiAgdmFyIHRlbXAgPSBbXSxcbiAgICAgIGkgPSAwLFxuICAgICAgeiA9IDAsXG4gICAgICB5LFxuICAgICAgeDtcblxuICBmb3IgKHkgPSAwOyB5IDwgNDsgeSsrKSB7XG4gICAgZm9yICh4ID0gMDsgeCA8IDU7IHgrKykge1xuICAgICAgeiA9IHggPT09IDQgPyBtW2kgKyA0XSA6IDA7XG4gICAgICB0ZW1wW2kgKyB4XSA9IG1baV0gKiBtMlt4XSArIG1baSArIDFdICogbTJbeCArIDVdICsgbVtpICsgMl0gKiBtMlt4ICsgMTBdICsgbVtpICsgM10gKiBtMlt4ICsgMTVdICsgejtcbiAgICB9XG5cbiAgICBpICs9IDU7XG4gIH1cblxuICByZXR1cm4gdGVtcDtcbn0sXG4gICAgX3NldFNhdHVyYXRpb24gPSBmdW5jdGlvbiBfc2V0U2F0dXJhdGlvbihtLCBuKSB7XG4gIGlmIChpc05hTihuKSkge1xuICAgIHJldHVybiBtO1xuICB9XG5cbiAgdmFyIGludiA9IDEgLSBuLFxuICAgICAgciA9IGludiAqIF9sdW1SLFxuICAgICAgZyA9IGludiAqIF9sdW1HLFxuICAgICAgYiA9IGludiAqIF9sdW1CO1xuICByZXR1cm4gX2FwcGx5TWF0cml4KFtyICsgbiwgZywgYiwgMCwgMCwgciwgZyArIG4sIGIsIDAsIDAsIHIsIGcsIGIgKyBuLCAwLCAwLCAwLCAwLCAwLCAxLCAwXSwgbSk7XG59LFxuICAgIF9jb2xvcml6ZSA9IGZ1bmN0aW9uIF9jb2xvcml6ZShtLCBjb2xvciwgYW1vdW50KSB7XG4gIGlmIChpc05hTihhbW91bnQpKSB7XG4gICAgYW1vdW50ID0gMTtcbiAgfVxuXG4gIHZhciBjID0gZ3NhcC51dGlscy5zcGxpdENvbG9yKGNvbG9yKSxcbiAgICAgIHIgPSBjWzBdIC8gMjU1LFxuICAgICAgZyA9IGNbMV0gLyAyNTUsXG4gICAgICBiID0gY1syXSAvIDI1NSxcbiAgICAgIGludiA9IDEgLSBhbW91bnQ7XG4gIHJldHVybiBfYXBwbHlNYXRyaXgoW2ludiArIGFtb3VudCAqIHIgKiBfbHVtUiwgYW1vdW50ICogciAqIF9sdW1HLCBhbW91bnQgKiByICogX2x1bUIsIDAsIDAsIGFtb3VudCAqIGcgKiBfbHVtUiwgaW52ICsgYW1vdW50ICogZyAqIF9sdW1HLCBhbW91bnQgKiBnICogX2x1bUIsIDAsIDAsIGFtb3VudCAqIGIgKiBfbHVtUiwgYW1vdW50ICogYiAqIF9sdW1HLCBpbnYgKyBhbW91bnQgKiBiICogX2x1bUIsIDAsIDAsIDAsIDAsIDAsIDEsIDBdLCBtKTtcbn0sXG4gICAgX3NldEh1ZSA9IGZ1bmN0aW9uIF9zZXRIdWUobSwgbikge1xuICBpZiAoaXNOYU4obikpIHtcbiAgICByZXR1cm4gbTtcbiAgfVxuXG4gIG4gKj0gTWF0aC5QSSAvIDE4MDtcbiAgdmFyIGMgPSBNYXRoLmNvcyhuKSxcbiAgICAgIHMgPSBNYXRoLnNpbihuKTtcbiAgcmV0dXJuIF9hcHBseU1hdHJpeChbX2x1bVIgKyBjICogKDEgLSBfbHVtUikgKyBzICogLV9sdW1SLCBfbHVtRyArIGMgKiAtX2x1bUcgKyBzICogLV9sdW1HLCBfbHVtQiArIGMgKiAtX2x1bUIgKyBzICogKDEgLSBfbHVtQiksIDAsIDAsIF9sdW1SICsgYyAqIC1fbHVtUiArIHMgKiAwLjE0MywgX2x1bUcgKyBjICogKDEgLSBfbHVtRykgKyBzICogMC4xNCwgX2x1bUIgKyBjICogLV9sdW1CICsgcyAqIC0wLjI4MywgMCwgMCwgX2x1bVIgKyBjICogLV9sdW1SICsgcyAqIC0oMSAtIF9sdW1SKSwgX2x1bUcgKyBjICogLV9sdW1HICsgcyAqIF9sdW1HLCBfbHVtQiArIGMgKiAoMSAtIF9sdW1CKSArIHMgKiBfbHVtQiwgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMV0sIG0pO1xufSxcbiAgICBfc2V0Q29udHJhc3QgPSBmdW5jdGlvbiBfc2V0Q29udHJhc3QobSwgbikge1xuICBpZiAoaXNOYU4obikpIHtcbiAgICByZXR1cm4gbTtcbiAgfVxuXG4gIG4gKz0gMC4wMTtcbiAgcmV0dXJuIF9hcHBseU1hdHJpeChbbiwgMCwgMCwgMCwgMTI4ICogKDEgLSBuKSwgMCwgbiwgMCwgMCwgMTI4ICogKDEgLSBuKSwgMCwgMCwgbiwgMCwgMTI4ICogKDEgLSBuKSwgMCwgMCwgMCwgMSwgMF0sIG0pO1xufSxcbiAgICBfcGFyc2VDb2xvck1hdHJpeEZpbHRlciA9IGZ1bmN0aW9uIF9wYXJzZUNvbG9yTWF0cml4RmlsdGVyKHRhcmdldCwgdiwgcGx1Z2luKSB7XG4gIGlmICghX0NvbG9yTWF0cml4RmlsdGVyKSB7XG4gICAgX0NvbG9yTWF0cml4RmlsdGVyID0gX2dldENyZWF0ZUpTKCkuQ29sb3JNYXRyaXhGaWx0ZXI7XG5cbiAgICBpZiAoIV9Db2xvck1hdHJpeEZpbHRlcikge1xuICAgICAgX3dhcm4oXCJFYXNlbFBsdWdpbjogVGhlIEVhc2VsSlMgQ29sb3JNYXRyaXhGaWx0ZXIgSmF2YVNjcmlwdCBmaWxlIHdhc24ndCBsb2FkZWQuXCIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWx0ZXJzID0gdGFyZ2V0LmZpbHRlcnMgfHwgW10sXG4gICAgICBpID0gZmlsdGVycy5sZW5ndGgsXG4gICAgICBtYXRyaXgsXG4gICAgICBzdGFydE1hdHJpeCxcbiAgICAgIHMsXG4gICAgICBwZztcblxuICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICBpZiAoZmlsdGVyc1tpXSBpbnN0YW5jZW9mIF9Db2xvck1hdHJpeEZpbHRlcikge1xuICAgICAgcyA9IGZpbHRlcnNbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoIXMpIHtcbiAgICBzID0gbmV3IF9Db2xvck1hdHJpeEZpbHRlcihfaWRNYXRyaXguc2xpY2UoKSk7XG4gICAgZmlsdGVycy5wdXNoKHMpO1xuICAgIHRhcmdldC5maWx0ZXJzID0gZmlsdGVycztcbiAgfVxuXG4gIHN0YXJ0TWF0cml4ID0gcy5tYXRyaXg7XG4gIG1hdHJpeCA9IF9pZE1hdHJpeC5zbGljZSgpO1xuXG4gIGlmICh2LmNvbG9yaXplICE9IG51bGwpIHtcbiAgICBtYXRyaXggPSBfY29sb3JpemUobWF0cml4LCB2LmNvbG9yaXplLCBOdW1iZXIodi5jb2xvcml6ZUFtb3VudCkpO1xuICB9XG5cbiAgaWYgKHYuY29udHJhc3QgIT0gbnVsbCkge1xuICAgIG1hdHJpeCA9IF9zZXRDb250cmFzdChtYXRyaXgsIE51bWJlcih2LmNvbnRyYXN0KSk7XG4gIH1cblxuICBpZiAodi5odWUgIT0gbnVsbCkge1xuICAgIG1hdHJpeCA9IF9zZXRIdWUobWF0cml4LCBOdW1iZXIodi5odWUpKTtcbiAgfVxuXG4gIGlmICh2LnNhdHVyYXRpb24gIT0gbnVsbCkge1xuICAgIG1hdHJpeCA9IF9zZXRTYXR1cmF0aW9uKG1hdHJpeCwgTnVtYmVyKHYuc2F0dXJhdGlvbikpO1xuICB9XG5cbiAgaSA9IG1hdHJpeC5sZW5ndGg7XG5cbiAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgaWYgKG1hdHJpeFtpXSAhPT0gc3RhcnRNYXRyaXhbaV0pIHtcbiAgICAgIHBnID0gcGx1Z2luLmFkZChzdGFydE1hdHJpeCwgaSwgc3RhcnRNYXRyaXhbaV0sIG1hdHJpeFtpXSwgMCwgMCwgMCwgMCwgMCwgMSk7XG5cbiAgICAgIGlmIChwZykge1xuICAgICAgICBwZy5vcCA9IFwiZWFzZWxfY29sb3JNYXRyaXhGaWx0ZXJcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwbHVnaW4uX3Byb3BzLnB1c2goXCJlYXNlbF9jb2xvck1hdHJpeEZpbHRlclwiKTtcblxuICBpZiAoIXRhcmdldC5jYWNoZUlEKSB7XG4gICAgX2NhY2hlKCk7XG4gIH1cblxuICBwbHVnaW4uX21hdHJpeCA9IHN0YXJ0TWF0cml4O1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoY29yZSkge1xuICBnc2FwID0gY29yZSB8fCBfZ2V0R1NBUCgpO1xuXG4gIGlmIChfd2luZG93RXhpc3RzKCkpIHtcbiAgICBfd2luID0gd2luZG93O1xuICB9XG5cbiAgaWYgKGdzYXApIHtcbiAgICBfY29yZUluaXR0ZWQgPSAxO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIEVhc2VsUGx1Z2luID0ge1xuICB2ZXJzaW9uOiBcIjMuMTIuNVwiLFxuICBuYW1lOiBcImVhc2VsXCIsXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YWx1ZSwgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgaWYgKCFfY29yZUluaXR0ZWQpIHtcbiAgICAgIF9pbml0Q29yZSgpO1xuXG4gICAgICBpZiAoIWdzYXApIHtcbiAgICAgICAgX3dhcm4oXCJQbGVhc2UgZ3NhcC5yZWdpc3RlclBsdWdpbihFYXNlbFBsdWdpbilcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdmFyIHAsIHB0LCB0aW50LCBjb2xvck1hdHJpeCwgZW5kLCBsYWJlbHMsIGk7XG5cbiAgICBmb3IgKHAgaW4gdmFsdWUpIHtcbiAgICAgIGVuZCA9IHZhbHVlW3BdO1xuXG4gICAgICBpZiAocCA9PT0gXCJjb2xvckZpbHRlclwiIHx8IHAgPT09IFwidGludFwiIHx8IHAgPT09IFwidGludEFtb3VudFwiIHx8IHAgPT09IFwiZXhwb3N1cmVcIiB8fCBwID09PSBcImJyaWdodG5lc3NcIikge1xuICAgICAgICBpZiAoIXRpbnQpIHtcbiAgICAgICAgICBfcGFyc2VDb2xvckZpbHRlcih0YXJnZXQsIHZhbHVlLmNvbG9yRmlsdGVyIHx8IHZhbHVlLCB0aGlzKTtcblxuICAgICAgICAgIHRpbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHAgPT09IFwic2F0dXJhdGlvblwiIHx8IHAgPT09IFwiY29udHJhc3RcIiB8fCBwID09PSBcImh1ZVwiIHx8IHAgPT09IFwiY29sb3JpemVcIiB8fCBwID09PSBcImNvbG9yaXplQW1vdW50XCIpIHtcbiAgICAgICAgaWYgKCFjb2xvck1hdHJpeCkge1xuICAgICAgICAgIF9wYXJzZUNvbG9yTWF0cml4RmlsdGVyKHRhcmdldCwgdmFsdWUuY29sb3JNYXRyaXhGaWx0ZXIgfHwgdmFsdWUsIHRoaXMpO1xuXG4gICAgICAgICAgY29sb3JNYXRyaXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHAgPT09IFwiZnJhbWVcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gXCJzdHJpbmdcIiAmJiBlbmQuY2hhckF0KDEpICE9PSBcIj1cIiAmJiAobGFiZWxzID0gdGFyZ2V0LmxhYmVscykpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobGFiZWxzW2ldLmxhYmVsID09PSBlbmQpIHtcbiAgICAgICAgICAgICAgZW5kID0gbGFiZWxzW2ldLnBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHB0ID0gdGhpcy5hZGQodGFyZ2V0LCBcImdvdG9BbmRTdG9wXCIsIHRhcmdldC5jdXJyZW50RnJhbWUsIGVuZCwgaW5kZXgsIHRhcmdldHMsIE1hdGgucm91bmQsIDAsIDAsIDEpO1xuXG4gICAgICAgIGlmIChwdCkge1xuICAgICAgICAgIHB0Lm9wID0gcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXRbcF0gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmFkZCh0YXJnZXQsIHAsIFwiZ2V0XCIsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyYXRpbywgZGF0YSkge1xuICAgIHZhciBwdCA9IGRhdGEuX3B0O1xuXG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEudGFyZ2V0LmNhY2hlSUQpIHtcbiAgICAgIGRhdGEudGFyZ2V0LnVwZGF0ZUNhY2hlKCk7XG4gICAgfVxuICB9LFxuICByZWdpc3RlcjogX2luaXRDb3JlXG59O1xuXG5FYXNlbFBsdWdpbi5yZWdpc3RlckNyZWF0ZUpTID0gZnVuY3Rpb24gKGNyZWF0ZWpzKSB7XG4gIF9jcmVhdGVKUyA9IGNyZWF0ZWpzO1xufTtcblxuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKEVhc2VsUGx1Z2luKTtcbmV4cG9ydCB7IEVhc2VsUGx1Z2luIGFzIGRlZmF1bHQgfTsiXSwibmFtZXMiOlsiZ3NhcCIsIl9jb3JlSW5pdHRlZCIsIl93aW4iLCJfY3JlYXRlSlMiLCJfQ29sb3JGaWx0ZXIiLCJfQ29sb3JNYXRyaXhGaWx0ZXIiLCJfY29sb3JQcm9wcyIsInNwbGl0IiwiX3dpbmRvd0V4aXN0cyIsIndpbmRvdyIsIl9nZXRHU0FQIiwicmVnaXN0ZXJQbHVnaW4iLCJfZ2V0Q3JlYXRlSlMiLCJjcmVhdGVqcyIsIl93YXJuIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwiX2NhY2hlIiwidGFyZ2V0IiwiYiIsImdldEJvdW5kcyIsIm5vbWluYWxCb3VuZHMiLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0Iiwic2V0Qm91bmRzIiwiY2FjaGUiLCJfcGFyc2VDb2xvckZpbHRlciIsInYiLCJwbHVnaW4iLCJDb2xvckZpbHRlciIsImZpbHRlcnMiLCJpIiwibGVuZ3RoIiwiYyIsInMiLCJlIiwiYSIsInAiLCJwdCIsInB1c2giLCJjbG9uZSIsInRpbnQiLCJ1dGlscyIsInNwbGl0Q29sb3IiLCJ0aW50QW1vdW50IiwicmVkT2Zmc2V0IiwiZ3JlZW5PZmZzZXQiLCJibHVlT2Zmc2V0IiwicmVkTXVsdGlwbGllciIsImdyZWVuTXVsdGlwbGllciIsImJsdWVNdWx0aXBsaWVyIiwiZXhwb3N1cmUiLCJicmlnaHRuZXNzIiwiTWF0aCIsImFicyIsImFkZCIsIm9wIiwiX3Byb3BzIiwiY2FjaGVJRCIsIl9pZE1hdHJpeCIsIl9sdW1SIiwiX2x1bUciLCJfbHVtQiIsIl9hcHBseU1hdHJpeCIsIm0iLCJtMiIsIkFycmF5IiwidGVtcCIsInoiLCJfc2V0U2F0dXJhdGlvbiIsIm4iLCJpc05hTiIsImludiIsInIiLCJnIiwiX2NvbG9yaXplIiwiY29sb3IiLCJhbW91bnQiLCJfc2V0SHVlIiwiUEkiLCJjb3MiLCJzaW4iLCJfc2V0Q29udHJhc3QiLCJfcGFyc2VDb2xvck1hdHJpeEZpbHRlciIsIkNvbG9yTWF0cml4RmlsdGVyIiwibWF0cml4Iiwic3RhcnRNYXRyaXgiLCJwZyIsInNsaWNlIiwiY29sb3JpemUiLCJOdW1iZXIiLCJjb2xvcml6ZUFtb3VudCIsImNvbnRyYXN0IiwiaHVlIiwic2F0dXJhdGlvbiIsIl9tYXRyaXgiLCJfaW5pdENvcmUiLCJjb3JlIiwiRWFzZWxQbHVnaW4iLCJ2ZXJzaW9uIiwibmFtZSIsImluaXQiLCJ2YWx1ZSIsInR3ZWVuIiwiaW5kZXgiLCJ0YXJnZXRzIiwiY29sb3JNYXRyaXgiLCJlbmQiLCJsYWJlbHMiLCJjb2xvckZpbHRlciIsImNvbG9yTWF0cml4RmlsdGVyIiwiY2hhckF0IiwibGFiZWwiLCJwb3NpdGlvbiIsImN1cnJlbnRGcmFtZSIsInJvdW5kIiwicmVuZGVyIiwicmF0aW8iLCJkYXRhIiwiX3B0IiwiZCIsIl9uZXh0IiwidXBkYXRlQ2FjaGUiLCJyZWdpc3RlciIsInJlZ2lzdGVyQ3JlYXRlSlMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/EaselPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Flip.js":
/*!******************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Flip.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Flip: function() { return /* binding */ Flip; },\n/* harmony export */   \"default\": function() { return /* binding */ Flip; }\n/* harmony export */ });\n/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/matrix.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/matrix.js\");\n/*!\n * Flip 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ \nvar _id = 1, _toArray, gsap, _batch, _batchAction, _body, _closestTenth, _getStyleSaver, _forEachBatch = function _forEachBatch(batch, name) {\n    return batch.actions.forEach(function(a) {\n        return a.vars[name] && a.vars[name](a);\n    });\n}, _batchLookup = {}, _RAD2DEG = 180 / Math.PI, _DEG2RAD = Math.PI / 180, _emptyObj = {}, _dashedNameLookup = {}, _memoizedRemoveProps = {}, _listToArray = function _listToArray(list) {\n    return typeof list === \"string\" ? list.split(\" \").join(\"\").split(\",\") : list;\n}, // removes extra spaces contaminating the names, returns an Array.\n_callbacks = _listToArray(\"onStart,onUpdate,onComplete,onReverseComplete,onInterrupt\"), _removeProps = _listToArray(\"transform,transformOrigin,width,height,position,top,left,opacity,zIndex,maxWidth,maxHeight,minWidth,minHeight\"), _getEl = function _getEl(target) {\n    return _toArray(target)[0] || console.warn(\"Element not found:\", target);\n}, _round = function _round(value) {\n    return Math.round(value * 10000) / 10000 || 0;\n}, _toggleClass = function _toggleClass(targets, className, action) {\n    return targets.forEach(function(el) {\n        return el.classList[action](className);\n    });\n}, _reserved = {\n    zIndex: 1,\n    kill: 1,\n    simple: 1,\n    spin: 1,\n    clearProps: 1,\n    targets: 1,\n    toggleClass: 1,\n    onComplete: 1,\n    onUpdate: 1,\n    onInterrupt: 1,\n    onStart: 1,\n    delay: 1,\n    repeat: 1,\n    repeatDelay: 1,\n    yoyo: 1,\n    scale: 1,\n    fade: 1,\n    absolute: 1,\n    props: 1,\n    onEnter: 1,\n    onLeave: 1,\n    custom: 1,\n    paused: 1,\n    nested: 1,\n    prune: 1,\n    absoluteOnLeave: 1\n}, _fitReserved = {\n    zIndex: 1,\n    simple: 1,\n    clearProps: 1,\n    scale: 1,\n    absolute: 1,\n    fitChild: 1,\n    getVars: 1,\n    props: 1\n}, _camelToDashed = function _camelToDashed(p) {\n    return p.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n}, _copy = function _copy(obj, exclude) {\n    var result = {}, p;\n    for(p in obj){\n        exclude[p] || (result[p] = obj[p]);\n    }\n    return result;\n}, _memoizedProps = {}, _memoizeProps = function _memoizeProps(props) {\n    var p = _memoizedProps[props] = _listToArray(props);\n    _memoizedRemoveProps[props] = p.concat(_removeProps);\n    return p;\n}, _getInverseGlobalMatrix = function _getInverseGlobalMatrix(el) {\n    // integrates caching for improved performance\n    var cache = el._gsap || gsap.core.getCache(el);\n    if (cache.gmCache === gsap.ticker.frame) {\n        return cache.gMatrix;\n    }\n    cache.gmCache = gsap.ticker.frame;\n    return cache.gMatrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(el, true, false, true);\n}, _getDOMDepth = function _getDOMDepth(el, invert, level) {\n    if (level === void 0) {\n        level = 0;\n    }\n    // In invert is true, the sibling depth is increments of 1, and parent/nesting depth is increments of 1000. This lets us order elements in an Array to reflect document flow.\n    var parent = el.parentNode, inc = 1000 * Math.pow(10, level) * (invert ? -1 : 1), l = invert ? -inc * 900 : 0;\n    while(el){\n        l += inc;\n        el = el.previousSibling;\n    }\n    return parent ? l + _getDOMDepth(parent, invert, level + 1) : l;\n}, _orderByDOMDepth = function _orderByDOMDepth(comps, invert, isElStates) {\n    comps.forEach(function(comp) {\n        return comp.d = _getDOMDepth(isElStates ? comp.element : comp.t, invert);\n    });\n    comps.sort(function(c1, c2) {\n        return c1.d - c2.d;\n    });\n    return comps;\n}, _recordInlineStyles = function _recordInlineStyles(elState, props) {\n    // records the current inline CSS properties into an Array in alternating name/value pairs that's stored in a \"css\" property on the state object so that we can revert later.\n    var style = elState.element.style, a = elState.css = elState.css || [], i = props.length, p, v;\n    while(i--){\n        p = props[i];\n        v = style[p] || style.getPropertyValue(p);\n        a.push(v ? p : _dashedNameLookup[p] || (_dashedNameLookup[p] = _camelToDashed(p)), v);\n    }\n    return style;\n}, _applyInlineStyles = function _applyInlineStyles(state) {\n    var css = state.css, style = state.element.style, i = 0;\n    state.cache.uncache = 1;\n    for(; i < css.length; i += 2){\n        css[i + 1] ? style[css[i]] = css[i + 1] : style.removeProperty(css[i]);\n    }\n    if (!css[css.indexOf(\"transform\") + 1] && style.translate) {\n        // CSSPlugin adds scale, translate, and rotate inline CSS as \"none\" in order to keep CSS rules from contaminating transforms.\n        style.removeProperty(\"translate\");\n        style.removeProperty(\"scale\");\n        style.removeProperty(\"rotate\");\n    }\n}, _setFinalStates = function _setFinalStates(comps, onlyTransforms) {\n    comps.forEach(function(c) {\n        return c.a.cache.uncache = 1;\n    });\n    onlyTransforms || comps.finalStates.forEach(_applyInlineStyles);\n}, _absoluteProps = \"paddingTop,paddingRight,paddingBottom,paddingLeft,gridArea,transition\".split(\",\"), // properties that we must record just\n_makeAbsolute = function _makeAbsolute(elState, fallbackNode, ignoreBatch) {\n    var element = elState.element, width = elState.width, height = elState.height, uncache = elState.uncache, getProp = elState.getProp, style = element.style, i = 4, result, displayIsNone, cs;\n    typeof fallbackNode !== \"object\" && (fallbackNode = elState);\n    if (_batch && ignoreBatch !== 1) {\n        _batch._abs.push({\n            t: element,\n            b: elState,\n            a: elState,\n            sd: 0\n        });\n        _batch._final.push(function() {\n            return (elState.cache.uncache = 1) && _applyInlineStyles(elState);\n        });\n        return element;\n    }\n    displayIsNone = getProp(\"display\") === \"none\";\n    if (!elState.isVisible || displayIsNone) {\n        displayIsNone && (_recordInlineStyles(elState, [\n            \"display\"\n        ]).display = fallbackNode.display);\n        elState.matrix = fallbackNode.matrix;\n        elState.width = width = elState.width || fallbackNode.width;\n        elState.height = height = elState.height || fallbackNode.height;\n    }\n    _recordInlineStyles(elState, _absoluteProps);\n    cs = window.getComputedStyle(element);\n    while(i--){\n        style[_absoluteProps[i]] = cs[_absoluteProps[i]]; // record paddings as px-based because if removed from grid, percentage-based ones could be altered.\n    }\n    style.gridArea = \"1 / 1 / 1 / 1\";\n    style.transition = \"none\";\n    style.position = \"absolute\";\n    style.width = width + \"px\";\n    style.height = height + \"px\";\n    style.top || (style.top = \"0px\");\n    style.left || (style.left = \"0px\");\n    if (uncache) {\n        result = new ElementState(element);\n    } else {\n        // better performance\n        result = _copy(elState, _emptyObj);\n        result.position = \"absolute\";\n        if (elState.simple) {\n            var bounds = element.getBoundingClientRect();\n            result.matrix = new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D(1, 0, 0, 1, bounds.left + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollLeft)(), bounds.top + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollTop)());\n        } else {\n            result.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(element, false, false, true);\n        }\n    }\n    result = _fit(result, elState, true);\n    elState.x = _closestTenth(result.x, 0.01);\n    elState.y = _closestTenth(result.y, 0.01);\n    return element;\n}, _filterComps = function _filterComps(comps, targets) {\n    if (targets !== true) {\n        targets = _toArray(targets);\n        comps = comps.filter(function(c) {\n            if (targets.indexOf((c.sd < 0 ? c.b : c.a).element) !== -1) {\n                return true;\n            } else {\n                c.t._gsap.renderTransform(1); // we must force transforms to render on anything that isn't being made position: absolute, otherwise the absolute position happens and then when animation begins it applies transforms which can create a new stacking context, throwing off positioning!\n                if (c.b.isVisible) {\n                    c.t.style.width = c.b.width + \"px\"; // otherwise things can collapse when contents are made position: absolute.\n                    c.t.style.height = c.b.height + \"px\";\n                }\n            }\n        });\n    }\n    return comps;\n}, _makeCompsAbsolute = function _makeCompsAbsolute(comps) {\n    return _orderByDOMDepth(comps, true).forEach(function(c) {\n        return (c.a.isVisible || c.b.isVisible) && _makeAbsolute(c.sd < 0 ? c.b : c.a, c.b, 1);\n    });\n}, _findElStateInState = function _findElStateInState(state, other) {\n    return other && state.idLookup[_parseElementState(other).id] || state.elementStates[0];\n}, _parseElementState = function _parseElementState(elOrNode, props, simple, other) {\n    return elOrNode instanceof ElementState ? elOrNode : elOrNode instanceof FlipState ? _findElStateInState(elOrNode, other) : new ElementState(typeof elOrNode === \"string\" ? _getEl(elOrNode) || console.warn(elOrNode + \" not found\") : elOrNode, props, simple);\n}, _recordProps = function _recordProps(elState, props) {\n    var getProp = gsap.getProperty(elState.element, null, \"native\"), obj = elState.props = {}, i = props.length;\n    while(i--){\n        obj[props[i]] = (getProp(props[i]) + \"\").trim();\n    }\n    obj.zIndex && (obj.zIndex = parseFloat(obj.zIndex) || 0);\n    return elState;\n}, _applyProps = function _applyProps(element, props) {\n    var style = element.style || element, // could pass in a vars object.\n    p;\n    for(p in props){\n        style[p] = props[p];\n    }\n}, _getID = function _getID(el) {\n    var id = el.getAttribute(\"data-flip-id\");\n    id || el.setAttribute(\"data-flip-id\", id = \"auto-\" + _id++);\n    return id;\n}, _elementsFromElementStates = function _elementsFromElementStates(elStates) {\n    return elStates.map(function(elState) {\n        return elState.element;\n    });\n}, _handleCallback = function _handleCallback(callback, elStates, tl) {\n    return callback && elStates.length && tl.add(callback(_elementsFromElementStates(elStates), tl, new FlipState(elStates, 0, true)), 0);\n}, _fit = function _fit(fromState, toState, scale, applyProps, fitChild, vars) {\n    var element = fromState.element, cache = fromState.cache, parent = fromState.parent, x = fromState.x, y = fromState.y, width = toState.width, height = toState.height, scaleX = toState.scaleX, scaleY = toState.scaleY, rotation = toState.rotation, bounds = toState.bounds, styles = vars && _getStyleSaver && _getStyleSaver(element, \"transform\"), dimensionState = fromState, _toState$matrix = toState.matrix, e = _toState$matrix.e, f = _toState$matrix.f, deep = fromState.bounds.width !== bounds.width || fromState.bounds.height !== bounds.height || fromState.scaleX !== scaleX || fromState.scaleY !== scaleY || fromState.rotation !== rotation, simple = !deep && fromState.simple && toState.simple && !fitChild, skewX, fromPoint, toPoint, getProp, parentMatrix, matrix, bbox;\n    if (simple || !parent) {\n        scaleX = scaleY = 1;\n        rotation = skewX = 0;\n    } else {\n        parentMatrix = _getInverseGlobalMatrix(parent);\n        matrix = parentMatrix.clone().multiply(toState.ctm ? toState.matrix.clone().multiply(toState.ctm) : toState.matrix); // root SVG elements have a ctm that we must factor out (for example, viewBox:\"0 0 94 94\" with a width of 200px would scale the internals by 2.127 but when we're matching the size of the root <svg> element itself, that scaling shouldn't factor in!)\n        rotation = _round(Math.atan2(matrix.b, matrix.a) * _RAD2DEG);\n        skewX = _round(Math.atan2(matrix.c, matrix.d) * _RAD2DEG + rotation) % 360; // in very rare cases, minor rounding might end up with 360 which should be 0.\n        scaleX = Math.sqrt(Math.pow(matrix.a, 2) + Math.pow(matrix.b, 2));\n        scaleY = Math.sqrt(Math.pow(matrix.c, 2) + Math.pow(matrix.d, 2)) * Math.cos(skewX * _DEG2RAD);\n        if (fitChild) {\n            fitChild = _toArray(fitChild)[0];\n            getProp = gsap.getProperty(fitChild);\n            bbox = fitChild.getBBox && typeof fitChild.getBBox === \"function\" && fitChild.getBBox();\n            dimensionState = {\n                scaleX: getProp(\"scaleX\"),\n                scaleY: getProp(\"scaleY\"),\n                width: bbox ? bbox.width : Math.ceil(parseFloat(getProp(\"width\", \"px\"))),\n                height: bbox ? bbox.height : parseFloat(getProp(\"height\", \"px\"))\n            };\n        }\n        cache.rotation = rotation + \"deg\";\n        cache.skewX = skewX + \"deg\";\n    }\n    if (scale) {\n        scaleX *= width === dimensionState.width || !dimensionState.width ? 1 : width / dimensionState.width; // note if widths are both 0, we should make scaleX 1 - some elements have box-sizing that incorporates padding, etc. and we don't want it to collapse in that case.\n        scaleY *= height === dimensionState.height || !dimensionState.height ? 1 : height / dimensionState.height;\n        cache.scaleX = scaleX;\n        cache.scaleY = scaleY;\n    } else {\n        width = _closestTenth(width * scaleX / dimensionState.scaleX, 0);\n        height = _closestTenth(height * scaleY / dimensionState.scaleY, 0);\n        element.style.width = width + \"px\";\n        element.style.height = height + \"px\";\n    } // if (fromState.isFixed) { // commented out because it's now taken care of in getGlobalMatrix() with a flag at the end.\n    // \te -= _getDocScrollLeft();\n    // \tf -= _getDocScrollTop();\n    // }\n    applyProps && _applyProps(element, toState.props);\n    if (simple || !parent) {\n        x += e - fromState.matrix.e;\n        y += f - fromState.matrix.f;\n    } else if (deep || parent !== toState.parent) {\n        cache.renderTransform(1, cache);\n        matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fitChild || element, false, false, true);\n        fromPoint = parentMatrix.apply({\n            x: matrix.e,\n            y: matrix.f\n        });\n        toPoint = parentMatrix.apply({\n            x: e,\n            y: f\n        });\n        x += toPoint.x - fromPoint.x;\n        y += toPoint.y - fromPoint.y;\n    } else {\n        // use a faster/cheaper algorithm if we're just moving x/y\n        parentMatrix.e = parentMatrix.f = 0;\n        toPoint = parentMatrix.apply({\n            x: e - fromState.matrix.e,\n            y: f - fromState.matrix.f\n        });\n        x += toPoint.x;\n        y += toPoint.y;\n    }\n    x = _closestTenth(x, 0.02);\n    y = _closestTenth(y, 0.02);\n    if (vars && !(vars instanceof ElementState)) {\n        // revert\n        styles && styles.revert();\n    } else {\n        // or apply the transform immediately\n        cache.x = x + \"px\";\n        cache.y = y + \"px\";\n        cache.renderTransform(1, cache);\n    }\n    if (vars) {\n        vars.x = x;\n        vars.y = y;\n        vars.rotation = rotation;\n        vars.skewX = skewX;\n        if (scale) {\n            vars.scaleX = scaleX;\n            vars.scaleY = scaleY;\n        } else {\n            vars.width = width;\n            vars.height = height;\n        }\n    }\n    return vars || cache;\n}, _parseState = function _parseState(targetsOrState, vars) {\n    return targetsOrState instanceof FlipState ? targetsOrState : new FlipState(targetsOrState, vars);\n}, _getChangingElState = function _getChangingElState(toState, fromState, id) {\n    var to1 = toState.idLookup[id], to2 = toState.alt[id];\n    return to2.isVisible && (!(fromState.getElementState(to2.element) || to2).isVisible || !to1.isVisible) ? to2 : to1;\n}, _bodyMetrics = [], _bodyProps = \"width,height,overflowX,overflowY\".split(\",\"), _bodyLocked, _lockBodyScroll = function _lockBodyScroll(lock) {\n    // if there's no scrollbar, we should lock that so that measurements don't get affected by temporary repositioning, like if something is centered in the window.\n    if (lock !== _bodyLocked) {\n        var s = _body.style, w = _body.clientWidth === window.outerWidth, h = _body.clientHeight === window.outerHeight, i = 4;\n        if (lock && (w || h)) {\n            while(i--){\n                _bodyMetrics[i] = s[_bodyProps[i]];\n            }\n            if (w) {\n                s.width = _body.clientWidth + \"px\";\n                s.overflowY = \"hidden\";\n            }\n            if (h) {\n                s.height = _body.clientHeight + \"px\";\n                s.overflowX = \"hidden\";\n            }\n            _bodyLocked = lock;\n        } else if (_bodyLocked) {\n            while(i--){\n                _bodyMetrics[i] ? s[_bodyProps[i]] = _bodyMetrics[i] : s.removeProperty(_camelToDashed(_bodyProps[i]));\n            }\n            _bodyLocked = lock;\n        }\n    }\n}, _fromTo = function _fromTo(fromState, toState, vars, relative) {\n    // relative is -1 if \"from()\", and 1 if \"to()\"\n    fromState instanceof FlipState && toState instanceof FlipState || console.warn(\"Not a valid state object.\");\n    vars = vars || {};\n    var _vars = vars, clearProps = _vars.clearProps, onEnter = _vars.onEnter, onLeave = _vars.onLeave, absolute = _vars.absolute, absoluteOnLeave = _vars.absoluteOnLeave, custom = _vars.custom, delay = _vars.delay, paused = _vars.paused, repeat = _vars.repeat, repeatDelay = _vars.repeatDelay, yoyo = _vars.yoyo, toggleClass = _vars.toggleClass, nested = _vars.nested, _zIndex = _vars.zIndex, scale = _vars.scale, fade = _vars.fade, stagger = _vars.stagger, spin = _vars.spin, prune = _vars.prune, props = (\"props\" in vars ? vars : fromState).props, tweenVars = _copy(vars, _reserved), animation = gsap.timeline({\n        delay: delay,\n        paused: paused,\n        repeat: repeat,\n        repeatDelay: repeatDelay,\n        yoyo: yoyo,\n        data: \"isFlip\"\n    }), remainingProps = tweenVars, entering = [], leaving = [], comps = [], swapOutTargets = [], spinNum = spin === true ? 1 : spin || 0, spinFunc = typeof spin === \"function\" ? spin : function spinFunc() {\n        return spinNum;\n    }, interrupted = fromState.interrupted || toState.interrupted, addFunc = animation[relative !== 1 ? \"to\" : \"from\"], v, p, endTime, i, el, comp, state, targets, finalStates, fromNode, toNode, run, a, b; //relative || (toState = (new FlipState(toState.targets, {props: props})).fit(toState, scale));\n    for(p in toState.idLookup){\n        toNode = !toState.alt[p] ? toState.idLookup[p] : _getChangingElState(toState, fromState, p);\n        el = toNode.element;\n        fromNode = fromState.idLookup[p];\n        fromState.alt[p] && el === fromNode.element && (fromState.alt[p].isVisible || !toNode.isVisible) && (fromNode = fromState.alt[p]);\n        if (fromNode) {\n            comp = {\n                t: el,\n                b: fromNode,\n                a: toNode,\n                sd: fromNode.element === el ? 0 : toNode.isVisible ? 1 : -1\n            };\n            comps.push(comp);\n            if (comp.sd) {\n                if (comp.sd < 0) {\n                    comp.b = toNode;\n                    comp.a = fromNode;\n                } // for swapping elements that got interrupted, we must re-record the inline styles to ensure they're not tainted. Remember, .batch() permits getState() not to force in-progress flips to their end state.\n                interrupted && _recordInlineStyles(comp.b, props ? _memoizedRemoveProps[props] : _removeProps);\n                fade && comps.push(comp.swap = {\n                    t: fromNode.element,\n                    b: comp.b,\n                    a: comp.a,\n                    sd: -comp.sd,\n                    swap: comp\n                });\n            }\n            el._flip = fromNode.element._flip = _batch ? _batch.timeline : animation;\n        } else if (toNode.isVisible) {\n            comps.push({\n                t: el,\n                b: _copy(toNode, {\n                    isVisible: 1\n                }),\n                a: toNode,\n                sd: 0,\n                entering: 1\n            }); // to include it in the \"entering\" Array and do absolute positioning if necessary\n            el._flip = _batch ? _batch.timeline : animation;\n        }\n    }\n    props && (_memoizedProps[props] || _memoizeProps(props)).forEach(function(p) {\n        return tweenVars[p] = function(i) {\n            return comps[i].a.props[p];\n        };\n    });\n    comps.finalStates = finalStates = [];\n    run = function run() {\n        _orderByDOMDepth(comps);\n        _lockBodyScroll(true); // otherwise, measurements may get thrown off when things get fit.\n        // TODO: cache the matrix, especially for parent because it'll probably get reused quite a bit, but lock it to a particular cycle(?).\n        for(i = 0; i < comps.length; i++){\n            comp = comps[i];\n            a = comp.a;\n            b = comp.b;\n            if (prune && !a.isDifferent(b) && !comp.entering) {\n                // only flip if things changed! Don't omit it from comps initially because that'd prevent the element from being positioned absolutely (if necessary)\n                comps.splice(i--, 1);\n            } else {\n                el = comp.t;\n                nested && !(comp.sd < 0) && i && (a.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(el, false, false, true)); // moving a parent affects the position of children\n                if (b.isVisible && a.isVisible) {\n                    if (comp.sd < 0) {\n                        // swapping OUT (swap direction of -1 is out)\n                        state = new ElementState(el, props, fromState.simple);\n                        _fit(state, a, scale, 0, 0, state);\n                        state.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(el, false, false, true);\n                        state.css = comp.b.css;\n                        comp.a = a = state;\n                        fade && (el.style.opacity = interrupted ? b.opacity : a.opacity);\n                        stagger && swapOutTargets.push(el);\n                    } else if (comp.sd > 0 && fade) {\n                        // swapping IN (swap direction of 1 is in)\n                        el.style.opacity = interrupted ? a.opacity - b.opacity : \"0\";\n                    }\n                    _fit(a, b, scale, props);\n                } else if (b.isVisible !== a.isVisible) {\n                    // either entering or leaving (one side is invisible)\n                    if (!b.isVisible) {\n                        // entering\n                        a.isVisible && entering.push(a);\n                        comps.splice(i--, 1);\n                    } else if (!a.isVisible) {\n                        // leaving\n                        b.css = a.css;\n                        leaving.push(b);\n                        comps.splice(i--, 1);\n                        absolute && nested && _fit(a, b, scale, props);\n                    }\n                }\n                if (!scale) {\n                    el.style.maxWidth = Math.max(a.width, b.width) + \"px\";\n                    el.style.maxHeight = Math.max(a.height, b.height) + \"px\";\n                    el.style.minWidth = Math.min(a.width, b.width) + \"px\";\n                    el.style.minHeight = Math.min(a.height, b.height) + \"px\";\n                }\n                nested && toggleClass && el.classList.add(toggleClass);\n            }\n            finalStates.push(a);\n        }\n        var classTargets;\n        if (toggleClass) {\n            classTargets = finalStates.map(function(s) {\n                return s.element;\n            });\n            nested && classTargets.forEach(function(e) {\n                return e.classList.remove(toggleClass);\n            }); // there could be a delay, so don't leave the classes applied (we'll do it in a timeline callback)\n        }\n        _lockBodyScroll(false);\n        if (scale) {\n            tweenVars.scaleX = function(i) {\n                return comps[i].a.scaleX;\n            };\n            tweenVars.scaleY = function(i) {\n                return comps[i].a.scaleY;\n            };\n        } else {\n            tweenVars.width = function(i) {\n                return comps[i].a.width + \"px\";\n            };\n            tweenVars.height = function(i) {\n                return comps[i].a.height + \"px\";\n            };\n            tweenVars.autoRound = vars.autoRound || false;\n        }\n        tweenVars.x = function(i) {\n            return comps[i].a.x + \"px\";\n        };\n        tweenVars.y = function(i) {\n            return comps[i].a.y + \"px\";\n        };\n        tweenVars.rotation = function(i) {\n            return comps[i].a.rotation + (spin ? spinFunc(i, targets[i], targets) * 360 : 0);\n        };\n        tweenVars.skewX = function(i) {\n            return comps[i].a.skewX;\n        };\n        targets = comps.map(function(c) {\n            return c.t;\n        });\n        if (_zIndex || _zIndex === 0) {\n            tweenVars.modifiers = {\n                zIndex: function zIndex() {\n                    return _zIndex;\n                }\n            };\n            tweenVars.zIndex = _zIndex;\n            tweenVars.immediateRender = vars.immediateRender !== false;\n        }\n        fade && (tweenVars.opacity = function(i) {\n            return comps[i].sd < 0 ? 0 : comps[i].sd > 0 ? comps[i].a.opacity : \"+=0\";\n        });\n        if (swapOutTargets.length) {\n            stagger = gsap.utils.distribute(stagger);\n            var dummyArray = targets.slice(swapOutTargets.length);\n            tweenVars.stagger = function(i, el) {\n                return stagger(~swapOutTargets.indexOf(el) ? targets.indexOf(comps[i].swap.t) : i, el, dummyArray);\n            };\n        } // // for testing...\n        // gsap.delayedCall(vars.data ? 50 : 1, function() {\n        // \tanimation.eventCallback(\"onComplete\", () => _setFinalStates(comps, !clearProps));\n        // \taddFunc.call(animation, targets, tweenVars, 0).play();\n        // });\n        // return;\n        _callbacks.forEach(function(name) {\n            return vars[name] && animation.eventCallback(name, vars[name], vars[name + \"Params\"]);\n        }); // apply callbacks to the timeline, not tweens (because \"custom\" timing can make multiple tweens)\n        if (custom && targets.length) {\n            // bust out the custom properties as their own tweens so they can use different eases, durations, etc.\n            remainingProps = _copy(tweenVars, _reserved);\n            if (\"scale\" in custom) {\n                custom.scaleX = custom.scaleY = custom.scale;\n                delete custom.scale;\n            }\n            for(p in custom){\n                v = _copy(custom[p], _fitReserved);\n                v[p] = tweenVars[p];\n                !(\"duration\" in v) && \"duration\" in tweenVars && (v.duration = tweenVars.duration);\n                v.stagger = tweenVars.stagger;\n                addFunc.call(animation, targets, v, 0);\n                delete remainingProps[p];\n            }\n        }\n        if (targets.length || leaving.length || entering.length) {\n            toggleClass && animation.add(function() {\n                return _toggleClass(classTargets, toggleClass, animation._zTime < 0 ? \"remove\" : \"add\");\n            }, 0) && !paused && _toggleClass(classTargets, toggleClass, \"add\");\n            targets.length && addFunc.call(animation, targets, remainingProps, 0);\n        }\n        _handleCallback(onEnter, entering, animation);\n        _handleCallback(onLeave, leaving, animation);\n        var batchTl = _batch && _batch.timeline;\n        if (batchTl) {\n            batchTl.add(animation, 0);\n            _batch._final.push(function() {\n                return _setFinalStates(comps, !clearProps);\n            });\n        }\n        endTime = animation.duration();\n        animation.call(function() {\n            var forward = animation.time() >= endTime;\n            forward && !batchTl && _setFinalStates(comps, !clearProps);\n            toggleClass && _toggleClass(classTargets, toggleClass, forward ? \"remove\" : \"add\");\n        });\n    };\n    absoluteOnLeave && (absolute = comps.filter(function(comp) {\n        return !comp.sd && !comp.a.isVisible && comp.b.isVisible;\n    }).map(function(comp) {\n        return comp.a.element;\n    }));\n    if (_batch) {\n        var _batch$_abs;\n        absolute && (_batch$_abs = _batch._abs).push.apply(_batch$_abs, _filterComps(comps, absolute));\n        _batch._run.push(run);\n    } else {\n        absolute && _makeCompsAbsolute(_filterComps(comps, absolute)); // when making absolute, we must go in a very particular order so that document flow changes don't affect things. Don't make it visible if both the before and after states are invisible! There's no point, and it could make things appear visible during the flip that shouldn't be.\n        run();\n    }\n    var anim = _batch ? _batch.timeline : animation;\n    anim.revert = function() {\n        return _killFlip(anim, 1, 1);\n    }; // a Flip timeline should behave very different when reverting - it should actually jump to the end so that styles get cleared out.\n    return anim;\n}, _interrupt = function _interrupt(tl) {\n    tl.vars.onInterrupt && tl.vars.onInterrupt.apply(tl, tl.vars.onInterruptParams || []);\n    tl.getChildren(true, false, true).forEach(_interrupt);\n}, _killFlip = function _killFlip(tl, action, force) {\n    // action: 0 = nothing, 1 = complete, 2 = only kill (don't complete)\n    if (tl && tl.progress() < 1 && (!tl.paused() || force)) {\n        if (action) {\n            _interrupt(tl);\n            action < 2 && tl.progress(1); // we should also kill it in case it was added to a parent timeline.\n            tl.kill();\n        }\n        return true;\n    }\n}, _createLookup = function _createLookup(state) {\n    var lookup = state.idLookup = {}, alt = state.alt = {}, elStates = state.elementStates, i = elStates.length, elState;\n    while(i--){\n        elState = elStates[i];\n        lookup[elState.id] ? alt[elState.id] = elState : lookup[elState.id] = elState;\n    }\n};\nvar FlipState = /*#__PURE__*/ function() {\n    function FlipState(targets, vars, targetsAreElementStates) {\n        this.props = vars && vars.props;\n        this.simple = !!(vars && vars.simple);\n        if (targetsAreElementStates) {\n            this.targets = _elementsFromElementStates(targets);\n            this.elementStates = targets;\n            _createLookup(this);\n        } else {\n            this.targets = _toArray(targets);\n            var soft = vars && (vars.kill === false || vars.batch && !vars.kill);\n            _batch && !soft && _batch._kill.push(this);\n            this.update(soft || !!_batch); // when batching, don't force in-progress flips to their end; we need to do that AFTER all getStates() are called.\n        }\n    }\n    var _proto = FlipState.prototype;\n    _proto.update = function update(soft) {\n        var _this = this;\n        this.elementStates = this.targets.map(function(el) {\n            return new ElementState(el, _this.props, _this.simple);\n        });\n        _createLookup(this);\n        this.interrupt(soft);\n        this.recordInlineStyles();\n        return this;\n    };\n    _proto.clear = function clear() {\n        this.targets.length = this.elementStates.length = 0;\n        _createLookup(this);\n        return this;\n    };\n    _proto.fit = function fit(state, scale, nested) {\n        var elStatesInOrder = _orderByDOMDepth(this.elementStates.slice(0), false, true), toElStates = (state || this).idLookup, i = 0, fromNode, toNode;\n        for(; i < elStatesInOrder.length; i++){\n            fromNode = elStatesInOrder[i];\n            nested && (fromNode.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fromNode.element, false, false, true)); // moving a parent affects the position of children\n            toNode = toElStates[fromNode.id];\n            toNode && _fit(fromNode, toNode, scale, true, 0, fromNode);\n            fromNode.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fromNode.element, false, false, true);\n        }\n        return this;\n    };\n    _proto.getProperty = function getProperty(element, property) {\n        var es = this.getElementState(element) || _emptyObj;\n        return (property in es ? es : es.props || _emptyObj)[property];\n    };\n    _proto.add = function add(state) {\n        var i = state.targets.length, lookup = this.idLookup, alt = this.alt, index, es, es2;\n        while(i--){\n            es = state.elementStates[i];\n            es2 = lookup[es.id];\n            if (es2 && (es.element === es2.element || alt[es.id] && alt[es.id].element === es.element)) {\n                // if the flip id is already in this FlipState, replace it!\n                index = this.elementStates.indexOf(es.element === es2.element ? es2 : alt[es.id]);\n                this.targets.splice(index, 1, state.targets[i]);\n                this.elementStates.splice(index, 1, es);\n            } else {\n                this.targets.push(state.targets[i]);\n                this.elementStates.push(es);\n            }\n        }\n        state.interrupted && (this.interrupted = true);\n        state.simple || (this.simple = false);\n        _createLookup(this);\n        return this;\n    };\n    _proto.compare = function compare(state) {\n        var l1 = state.idLookup, l2 = this.idLookup, unchanged = [], changed = [], enter = [], leave = [], targets = [], a1 = state.alt, a2 = this.alt, place = function place(s1, s2, el) {\n            return (s1.isVisible !== s2.isVisible ? s1.isVisible ? enter : leave : s1.isVisible ? changed : unchanged).push(el) && targets.push(el);\n        }, placeIfDoesNotExist = function placeIfDoesNotExist(s1, s2, el) {\n            return targets.indexOf(el) < 0 && place(s1, s2, el);\n        }, s1, s2, p, el, s1Alt, s2Alt, c1, c2;\n        for(p in l1){\n            s1Alt = a1[p];\n            s2Alt = a2[p];\n            s1 = !s1Alt ? l1[p] : _getChangingElState(state, this, p);\n            el = s1.element;\n            s2 = l2[p];\n            if (s2Alt) {\n                c2 = s2.isVisible || !s2Alt.isVisible && el === s2.element ? s2 : s2Alt;\n                c1 = s1Alt && !s1.isVisible && !s1Alt.isVisible && c2.element === s1Alt.element ? s1Alt : s1; //c1.element !== c2.element && c1.element === s2.element && (c2 = s2);\n                if (c1.isVisible && c2.isVisible && c1.element !== c2.element) {\n                    // swapping, so force into \"changed\" array\n                    (c1.isDifferent(c2) ? changed : unchanged).push(c1.element, c2.element);\n                    targets.push(c1.element, c2.element);\n                } else {\n                    place(c1, c2, c1.element);\n                }\n                s1Alt && c1.element === s1Alt.element && (s1Alt = l1[p]);\n                placeIfDoesNotExist(c1.element !== s2.element && s1Alt ? s1Alt : c1, s2, s2.element);\n                placeIfDoesNotExist(s1Alt && s1Alt.element === s2Alt.element ? s1Alt : c1, s2Alt, s2Alt.element);\n                s1Alt && placeIfDoesNotExist(s1Alt, s2Alt.element === s1Alt.element ? s2Alt : s2, s1Alt.element);\n            } else {\n                !s2 ? enter.push(el) : !s2.isDifferent(s1) ? unchanged.push(el) : place(s1, s2, el);\n                s1Alt && placeIfDoesNotExist(s1Alt, s2, s1Alt.element);\n            }\n        }\n        for(p in l2){\n            if (!l1[p]) {\n                leave.push(l2[p].element);\n                a2[p] && leave.push(a2[p].element);\n            }\n        }\n        return {\n            changed: changed,\n            unchanged: unchanged,\n            enter: enter,\n            leave: leave\n        };\n    };\n    _proto.recordInlineStyles = function recordInlineStyles() {\n        var props = _memoizedRemoveProps[this.props] || _removeProps, i = this.elementStates.length;\n        while(i--){\n            _recordInlineStyles(this.elementStates[i], props);\n        }\n    };\n    _proto.interrupt = function interrupt(soft) {\n        var _this2 = this;\n        // soft = DON'T force in-progress flip animations to completion (like when running a batch, we can't immediately kill flips when getting states because it could contaminate positioning and other .getState() calls that will run in the batch (we kill AFTER all the .getState() calls complete).\n        var timelines = [];\n        this.targets.forEach(function(t) {\n            var tl = t._flip, foundInProgress = _killFlip(tl, soft ? 0 : 1);\n            soft && foundInProgress && timelines.indexOf(tl) < 0 && tl.add(function() {\n                return _this2.updateVisibility();\n            });\n            foundInProgress && timelines.push(tl);\n        });\n        !soft && timelines.length && this.updateVisibility(); // if we found an in-progress Flip animation, we must record all the values in their current state at that point BUT we should update the isVisible value AFTER pushing that flip to completion so that elements that are entering or leaving will populate those Arrays properly.\n        this.interrupted || (this.interrupted = !!timelines.length);\n    };\n    _proto.updateVisibility = function updateVisibility() {\n        this.elementStates.forEach(function(es) {\n            var b = es.element.getBoundingClientRect();\n            es.isVisible = !!(b.width || b.height || b.top || b.left);\n            es.uncache = 1;\n        });\n    };\n    _proto.getElementState = function getElementState(element) {\n        return this.elementStates[this.targets.indexOf(_getEl(element))];\n    };\n    _proto.makeAbsolute = function makeAbsolute() {\n        return _orderByDOMDepth(this.elementStates.slice(0), true, true).map(_makeAbsolute);\n    };\n    return FlipState;\n}();\nvar ElementState = /*#__PURE__*/ function() {\n    function ElementState(element, props, simple) {\n        this.element = element;\n        this.update(props, simple);\n    }\n    var _proto2 = ElementState.prototype;\n    _proto2.isDifferent = function isDifferent(state) {\n        var b1 = this.bounds, b2 = state.bounds;\n        return b1.top !== b2.top || b1.left !== b2.left || b1.width !== b2.width || b1.height !== b2.height || !this.matrix.equals(state.matrix) || this.opacity !== state.opacity || this.props && state.props && JSON.stringify(this.props) !== JSON.stringify(state.props);\n    };\n    _proto2.update = function update(props, simple) {\n        var self = this, element = self.element, getProp = gsap.getProperty(element), cache = gsap.core.getCache(element), bounds = element.getBoundingClientRect(), bbox = element.getBBox && typeof element.getBBox === \"function\" && element.nodeName.toLowerCase() !== \"svg\" && element.getBBox(), m = simple ? new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D(1, 0, 0, 1, bounds.left + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollLeft)(), bounds.top + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollTop)()) : (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(element, false, false, true);\n        self.getProp = getProp;\n        self.element = element;\n        self.id = _getID(element);\n        self.matrix = m;\n        self.cache = cache;\n        self.bounds = bounds;\n        self.isVisible = !!(bounds.width || bounds.height || bounds.left || bounds.top);\n        self.display = getProp(\"display\");\n        self.position = getProp(\"position\");\n        self.parent = element.parentNode;\n        self.x = getProp(\"x\");\n        self.y = getProp(\"y\");\n        self.scaleX = cache.scaleX;\n        self.scaleY = cache.scaleY;\n        self.rotation = getProp(\"rotation\");\n        self.skewX = getProp(\"skewX\");\n        self.opacity = getProp(\"opacity\");\n        self.width = bbox ? bbox.width : _closestTenth(getProp(\"width\", \"px\"), 0.04); // round up to the closest 0.1 so that text doesn't wrap.\n        self.height = bbox ? bbox.height : _closestTenth(getProp(\"height\", \"px\"), 0.04);\n        props && _recordProps(self, _memoizedProps[props] || _memoizeProps(props));\n        self.ctm = element.getCTM && element.nodeName.toLowerCase() === \"svg\" && (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getCTM)(element).inverse();\n        self.simple = simple || _round(m.a) === 1 && !_round(m.b) && !_round(m.c) && _round(m.d) === 1; // allows us to speed through some other tasks if it's not scale/rotated\n        self.uncache = 0;\n    };\n    return ElementState;\n}();\nvar FlipAction = /*#__PURE__*/ function() {\n    function FlipAction(vars, batch) {\n        this.vars = vars;\n        this.batch = batch;\n        this.states = [];\n        this.timeline = batch.timeline;\n    }\n    var _proto3 = FlipAction.prototype;\n    _proto3.getStateById = function getStateById(id) {\n        var i = this.states.length;\n        while(i--){\n            if (this.states[i].idLookup[id]) {\n                return this.states[i];\n            }\n        }\n    };\n    _proto3.kill = function kill() {\n        this.batch.remove(this);\n    };\n    return FlipAction;\n}();\nvar FlipBatch = /*#__PURE__*/ function() {\n    function FlipBatch(id) {\n        this.id = id;\n        this.actions = [];\n        this._kill = [];\n        this._final = [];\n        this._abs = [];\n        this._run = [];\n        this.data = {};\n        this.state = new FlipState();\n        this.timeline = gsap.timeline();\n    }\n    var _proto4 = FlipBatch.prototype;\n    _proto4.add = function add(config) {\n        var result = this.actions.filter(function(action) {\n            return action.vars === config;\n        });\n        if (result.length) {\n            return result[0];\n        }\n        result = new FlipAction(typeof config === \"function\" ? {\n            animate: config\n        } : config, this);\n        this.actions.push(result);\n        return result;\n    };\n    _proto4.remove = function remove(action) {\n        var i = this.actions.indexOf(action);\n        i >= 0 && this.actions.splice(i, 1);\n        return this;\n    };\n    _proto4.getState = function getState(merge) {\n        var _this3 = this;\n        var prevBatch = _batch, prevAction = _batchAction;\n        _batch = this;\n        this.state.clear();\n        this._kill.length = 0;\n        this.actions.forEach(function(action) {\n            if (action.vars.getState) {\n                action.states.length = 0;\n                _batchAction = action;\n                action.state = action.vars.getState(action);\n            }\n            merge && action.states.forEach(function(s) {\n                return _this3.state.add(s);\n            });\n        });\n        _batchAction = prevAction;\n        _batch = prevBatch;\n        this.killConflicts();\n        return this;\n    };\n    _proto4.animate = function animate() {\n        var _this4 = this;\n        var prevBatch = _batch, tl = this.timeline, i = this.actions.length, finalStates, endTime;\n        _batch = this;\n        tl.clear();\n        this._abs.length = this._final.length = this._run.length = 0;\n        this.actions.forEach(function(a) {\n            a.vars.animate && a.vars.animate(a);\n            var onEnter = a.vars.onEnter, onLeave = a.vars.onLeave, targets = a.targets, s, result;\n            if (targets && targets.length && (onEnter || onLeave)) {\n                s = new FlipState();\n                a.states.forEach(function(state) {\n                    return s.add(state);\n                });\n                result = s.compare(Flip.getState(targets));\n                result.enter.length && onEnter && onEnter(result.enter);\n                result.leave.length && onLeave && onLeave(result.leave);\n            }\n        });\n        _makeCompsAbsolute(this._abs);\n        this._run.forEach(function(f) {\n            return f();\n        });\n        endTime = tl.duration();\n        finalStates = this._final.slice(0);\n        tl.add(function() {\n            if (endTime <= tl.time()) {\n                // only call if moving forward in the timeline (in case it's nested in a timeline that gets reversed)\n                finalStates.forEach(function(f) {\n                    return f();\n                });\n                _forEachBatch(_this4, \"onComplete\");\n            }\n        });\n        _batch = prevBatch;\n        while(i--){\n            this.actions[i].vars.once && this.actions[i].kill();\n        }\n        _forEachBatch(this, \"onStart\");\n        tl.restart();\n        return this;\n    };\n    _proto4.loadState = function loadState(done) {\n        done || (done = function done() {\n            return 0;\n        });\n        var queue = [];\n        this.actions.forEach(function(c) {\n            if (c.vars.loadState) {\n                var i, f = function f(targets) {\n                    targets && (c.targets = targets);\n                    i = queue.indexOf(f);\n                    if (~i) {\n                        queue.splice(i, 1);\n                        queue.length || done();\n                    }\n                };\n                queue.push(f);\n                c.vars.loadState(f);\n            }\n        });\n        queue.length || done();\n        return this;\n    };\n    _proto4.setState = function setState() {\n        this.actions.forEach(function(c) {\n            return c.targets = c.vars.setState && c.vars.setState(c);\n        });\n        return this;\n    };\n    _proto4.killConflicts = function killConflicts(soft) {\n        this.state.interrupt(soft);\n        this._kill.forEach(function(state) {\n            return state.interrupt(soft);\n        });\n        return this;\n    };\n    _proto4.run = function run(skipGetState, merge) {\n        var _this5 = this;\n        if (this !== _batch) {\n            skipGetState || this.getState(merge);\n            this.loadState(function() {\n                if (!_this5._killed) {\n                    _this5.setState();\n                    _this5.animate();\n                }\n            });\n        }\n        return this;\n    };\n    _proto4.clear = function clear(stateOnly) {\n        this.state.clear();\n        stateOnly || (this.actions.length = 0);\n    };\n    _proto4.getStateById = function getStateById(id) {\n        var i = this.actions.length, s;\n        while(i--){\n            s = this.actions[i].getStateById(id);\n            if (s) {\n                return s;\n            }\n        }\n        return this.state.idLookup[id] && this.state;\n    };\n    _proto4.kill = function kill() {\n        this._killed = 1;\n        this.clear();\n        delete _batchLookup[this.id];\n    };\n    return FlipBatch;\n}();\nvar Flip = /*#__PURE__*/ function() {\n    function Flip() {}\n    Flip.getState = function getState(targets, vars) {\n        var state = _parseState(targets, vars);\n        _batchAction && _batchAction.states.push(state);\n        vars && vars.batch && Flip.batch(vars.batch).state.add(state);\n        return state;\n    };\n    Flip.from = function from(state, vars) {\n        vars = vars || {};\n        \"clearProps\" in vars || (vars.clearProps = true);\n        return _fromTo(state, _parseState(vars.targets || state.targets, {\n            props: vars.props || state.props,\n            simple: vars.simple,\n            kill: !!vars.kill\n        }), vars, -1);\n    };\n    Flip.to = function to(state, vars) {\n        return _fromTo(state, _parseState(vars.targets || state.targets, {\n            props: vars.props || state.props,\n            simple: vars.simple,\n            kill: !!vars.kill\n        }), vars, 1);\n    };\n    Flip.fromTo = function fromTo(fromState, toState, vars) {\n        return _fromTo(fromState, toState, vars);\n    };\n    Flip.fit = function fit(fromEl, toEl, vars) {\n        var v = vars ? _copy(vars, _fitReserved) : {}, _ref = vars || v, absolute = _ref.absolute, scale = _ref.scale, getVars = _ref.getVars, props = _ref.props, runBackwards = _ref.runBackwards, onComplete = _ref.onComplete, simple = _ref.simple, fitChild = vars && vars.fitChild && _getEl(vars.fitChild), before = _parseElementState(toEl, props, simple, fromEl), after = _parseElementState(fromEl, 0, simple, before), inlineProps = props ? _memoizedRemoveProps[props] : _removeProps, ctx = gsap.context();\n        props && _applyProps(v, before.props);\n        _recordInlineStyles(after, inlineProps);\n        if (runBackwards) {\n            \"immediateRender\" in v || (v.immediateRender = true);\n            v.onComplete = function() {\n                _applyInlineStyles(after);\n                onComplete && onComplete.apply(this, arguments);\n            };\n        }\n        absolute && _makeAbsolute(after, before);\n        v = _fit(after, before, scale || fitChild, props, fitChild, v.duration || getVars ? v : 0);\n        ctx && !getVars && ctx.add(function() {\n            return function() {\n                return _applyInlineStyles(after);\n            };\n        });\n        return getVars ? v : v.duration ? gsap.to(after.element, v) : null;\n    };\n    Flip.makeAbsolute = function makeAbsolute(targetsOrStates, vars) {\n        return (targetsOrStates instanceof FlipState ? targetsOrStates : new FlipState(targetsOrStates, vars)).makeAbsolute();\n    };\n    Flip.batch = function batch(id) {\n        id || (id = \"default\");\n        return _batchLookup[id] || (_batchLookup[id] = new FlipBatch(id));\n    };\n    Flip.killFlipsOf = function killFlipsOf(targets, complete) {\n        (targets instanceof FlipState ? targets.targets : _toArray(targets)).forEach(function(t) {\n            return t && _killFlip(t._flip, complete !== false ? 1 : 2);\n        });\n    };\n    Flip.isFlipping = function isFlipping(target) {\n        var f = Flip.getByTarget(target);\n        return !!f && f.isActive();\n    };\n    Flip.getByTarget = function getByTarget(target) {\n        return (_getEl(target) || _emptyObj)._flip;\n    };\n    Flip.getElementState = function getElementState(target, props) {\n        return new ElementState(_getEl(target), props);\n    };\n    Flip.convertCoordinates = function convertCoordinates(fromElement, toElement, point) {\n        var m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(toElement, true, true).multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fromElement));\n        return point ? m.apply(point) : m;\n    };\n    Flip.register = function register(core) {\n        _body = typeof document !== \"undefined\" && document.body;\n        if (_body) {\n            gsap = core;\n            (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._setDoc)(_body);\n            _toArray = gsap.utils.toArray;\n            _getStyleSaver = gsap.core.getStyleSaver;\n            var snap = gsap.utils.snap(0.1);\n            _closestTenth = function _closestTenth(value, add) {\n                return snap(parseFloat(value) + add);\n            };\n        }\n    };\n    return Flip;\n}();\nFlip.version = \"3.12.5\"; // function whenImagesLoad(el, func) {\n// \tlet pending = [],\n// \t\tonLoad = e => {\n// \t\t\tpending.splice(pending.indexOf(e.target), 1);\n// \t\t\te.target.removeEventListener(\"load\", onLoad);\n// \t\t\tpending.length || func();\n// \t\t};\n// \tgsap.utils.toArray(el.tagName.toLowerCase() === \"img\" ? el : el.querySelectorAll(\"img\")).forEach(img => img.complete || img.addEventListener(\"load\", onLoad) || pending.push(img));\n// \tpending.length || func();\n// }\ntypeof window !== \"undefined\" && window.gsap && window.gsap.registerPlugin(Flip);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9GbGlwLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCLEdBQ21HO0FBRXJILElBQUlNLE1BQU0sR0FDTkMsVUFDQUMsTUFDQUMsUUFDQUMsY0FDQUMsT0FDQUMsZUFDQUMsZ0JBQ0FDLGdCQUFnQixTQUFTQSxjQUFjQyxLQUFLLEVBQUVDLElBQUk7SUFDcEQsT0FBT0QsTUFBTUUsT0FBTyxDQUFDQyxPQUFPLENBQUMsU0FBVUMsQ0FBQztRQUN0QyxPQUFPQSxFQUFFQyxJQUFJLENBQUNKLEtBQUssSUFBSUcsRUFBRUMsSUFBSSxDQUFDSixLQUFLLENBQUNHO0lBQ3RDO0FBQ0YsR0FDSUUsZUFBZSxDQUFDLEdBQ2hCQyxXQUFXLE1BQU1DLEtBQUtDLEVBQUUsRUFDeEJDLFdBQVdGLEtBQUtDLEVBQUUsR0FBRyxLQUNyQkUsWUFBWSxDQUFDLEdBQ2JDLG9CQUFvQixDQUFDLEdBQ3JCQyx1QkFBdUIsQ0FBQyxHQUN4QkMsZUFBZSxTQUFTQSxhQUFhQyxJQUFJO0lBQzNDLE9BQU8sT0FBT0EsU0FBUyxXQUFXQSxLQUFLQyxLQUFLLENBQUMsS0FBS0MsSUFBSSxDQUFDLElBQUlELEtBQUssQ0FBQyxPQUFPRDtBQUMxRSxHQUNJLGtFQUFrRTtBQUN0RUcsYUFBYUosYUFBYSw4REFDdEJLLGVBQWVMLGFBQWEsa0hBQzVCTSxTQUFTLFNBQVNBLE9BQU9DLE1BQU07SUFDakMsT0FBTzdCLFNBQVM2QixPQUFPLENBQUMsRUFBRSxJQUFJQyxRQUFRQyxJQUFJLENBQUMsc0JBQXNCRjtBQUNuRSxHQUNJRyxTQUFTLFNBQVNBLE9BQU9DLEtBQUs7SUFDaEMsT0FBT2pCLEtBQUtrQixLQUFLLENBQUNELFFBQVEsU0FBUyxTQUFTO0FBQzlDLEdBQ0lFLGVBQWUsU0FBU0EsYUFBYUMsT0FBTyxFQUFFQyxTQUFTLEVB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b0I7QUFDcEIsbURBQW1EO0FBQ25ELG1EQUFtRDtBQUNuRCwrQkFBK0I7QUFDL0IsT0FBTztBQUNQLHVMQUF1TDtBQUN2TCw2QkFBNkI7QUFDN0IsSUFBSTtBQUVKLE9BQU8xUCxXQUFXLGVBQWVBLE9BQU8vSSxJQUFJLElBQUkrSSxPQUFPL0ksSUFBSSxDQUFDMFksY0FBYyxDQUFDekM7QUFDaEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dzYXBAMy4xMi41L25vZGVfbW9kdWxlcy9nc2FwL0ZsaXAuanM/NTk5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEZsaXAgMy4xMi41XG4gKiBodHRwczovL2dzYXAuY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyNCwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9nc2FwLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHU0FQIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IHsgZ2V0R2xvYmFsTWF0cml4LCBfZ2V0RG9jU2Nyb2xsVG9wLCBfZ2V0RG9jU2Nyb2xsTGVmdCwgTWF0cml4MkQsIF9zZXREb2MsIF9nZXRDVE0gfSBmcm9tIFwiLi91dGlscy9tYXRyaXguanNcIjtcblxudmFyIF9pZCA9IDEsXG4gICAgX3RvQXJyYXksXG4gICAgZ3NhcCxcbiAgICBfYmF0Y2gsXG4gICAgX2JhdGNoQWN0aW9uLFxuICAgIF9ib2R5LFxuICAgIF9jbG9zZXN0VGVudGgsXG4gICAgX2dldFN0eWxlU2F2ZXIsXG4gICAgX2ZvckVhY2hCYXRjaCA9IGZ1bmN0aW9uIF9mb3JFYWNoQmF0Y2goYmF0Y2gsIG5hbWUpIHtcbiAgcmV0dXJuIGJhdGNoLmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBhLnZhcnNbbmFtZV0gJiYgYS52YXJzW25hbWVdKGEpO1xuICB9KTtcbn0sXG4gICAgX2JhdGNoTG9va3VwID0ge30sXG4gICAgX1JBRDJERUcgPSAxODAgLyBNYXRoLlBJLFxuICAgIF9ERUcyUkFEID0gTWF0aC5QSSAvIDE4MCxcbiAgICBfZW1wdHlPYmogPSB7fSxcbiAgICBfZGFzaGVkTmFtZUxvb2t1cCA9IHt9LFxuICAgIF9tZW1vaXplZFJlbW92ZVByb3BzID0ge30sXG4gICAgX2xpc3RUb0FycmF5ID0gZnVuY3Rpb24gX2xpc3RUb0FycmF5KGxpc3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBsaXN0ID09PSBcInN0cmluZ1wiID8gbGlzdC5zcGxpdChcIiBcIikuam9pbihcIlwiKS5zcGxpdChcIixcIikgOiBsaXN0O1xufSxcbiAgICAvLyByZW1vdmVzIGV4dHJhIHNwYWNlcyBjb250YW1pbmF0aW5nIHRoZSBuYW1lcywgcmV0dXJucyBhbiBBcnJheS5cbl9jYWxsYmFja3MgPSBfbGlzdFRvQXJyYXkoXCJvblN0YXJ0LG9uVXBkYXRlLG9uQ29tcGxldGUsb25SZXZlcnNlQ29tcGxldGUsb25JbnRlcnJ1cHRcIiksXG4gICAgX3JlbW92ZVByb3BzID0gX2xpc3RUb0FycmF5KFwidHJhbnNmb3JtLHRyYW5zZm9ybU9yaWdpbix3aWR0aCxoZWlnaHQscG9zaXRpb24sdG9wLGxlZnQsb3BhY2l0eSx6SW5kZXgsbWF4V2lkdGgsbWF4SGVpZ2h0LG1pbldpZHRoLG1pbkhlaWdodFwiKSxcbiAgICBfZ2V0RWwgPSBmdW5jdGlvbiBfZ2V0RWwodGFyZ2V0KSB7XG4gIHJldHVybiBfdG9BcnJheSh0YXJnZXQpWzBdIHx8IGNvbnNvbGUud2FybihcIkVsZW1lbnQgbm90IGZvdW5kOlwiLCB0YXJnZXQpO1xufSxcbiAgICBfcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMCkgLyAxMDAwMCB8fCAwO1xufSxcbiAgICBfdG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbiBfdG9nZ2xlQ2xhc3ModGFyZ2V0cywgY2xhc3NOYW1lLCBhY3Rpb24pIHtcbiAgcmV0dXJuIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWwuY2xhc3NMaXN0W2FjdGlvbl0oY2xhc3NOYW1lKTtcbiAgfSk7XG59LFxuICAgIF9yZXNlcnZlZCA9IHtcbiAgekluZGV4OiAxLFxuICBraWxsOiAxLFxuICBzaW1wbGU6IDEsXG4gIHNwaW46IDEsXG4gIGNsZWFyUHJvcHM6IDEsXG4gIHRhcmdldHM6IDEsXG4gIHRvZ2dsZUNsYXNzOiAxLFxuICBvbkNvbXBsZXRlOiAxLFxuICBvblVwZGF0ZTogMSxcbiAgb25JbnRlcnJ1cHQ6IDEsXG4gIG9uU3RhcnQ6IDEsXG4gIGRlbGF5OiAxLFxuICByZXBlYXQ6IDEsXG4gIHJlcGVhdERlbGF5OiAxLFxuICB5b3lvOiAxLFxuICBzY2FsZTogMSxcbiAgZmFkZTogMSxcbiAgYWJzb2x1dGU6IDEsXG4gIHByb3BzOiAxLFxuICBvbkVudGVyOiAxLFxuICBvbkxlYXZlOiAxLFxuICBjdXN0b206IDEsXG4gIHBhdXNlZDogMSxcbiAgbmVzdGVkOiAxLFxuICBwcnVuZTogMSxcbiAgYWJzb2x1dGVPbkxlYXZlOiAxXG59LFxuICAgIF9maXRSZXNlcnZlZCA9IHtcbiAgekluZGV4OiAxLFxuICBzaW1wbGU6IDEsXG4gIGNsZWFyUHJvcHM6IDEsXG4gIHNjYWxlOiAxLFxuICBhYnNvbHV0ZTogMSxcbiAgZml0Q2hpbGQ6IDEsXG4gIGdldFZhcnM6IDEsXG4gIHByb3BzOiAxXG59LFxuICAgIF9jYW1lbFRvRGFzaGVkID0gZnVuY3Rpb24gX2NhbWVsVG9EYXNoZWQocCkge1xuICByZXR1cm4gcC5yZXBsYWNlKC8oW0EtWl0pL2csIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCk7XG59LFxuICAgIF9jb3B5ID0gZnVuY3Rpb24gX2NvcHkob2JqLCBleGNsdWRlKSB7XG4gIHZhciByZXN1bHQgPSB7fSxcbiAgICAgIHA7XG5cbiAgZm9yIChwIGluIG9iaikge1xuICAgIGV4Y2x1ZGVbcF0gfHwgKHJlc3VsdFtwXSA9IG9ialtwXSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSxcbiAgICBfbWVtb2l6ZWRQcm9wcyA9IHt9LFxuICAgIF9tZW1vaXplUHJvcHMgPSBmdW5jdGlvbiBfbWVtb2l6ZVByb3BzKHByb3BzKSB7XG4gIHZhciBwID0gX21lbW9pemVkUHJvcHNbcHJvcHNdID0gX2xpc3RUb0FycmF5KHByb3BzKTtcblxuICBfbWVtb2l6ZWRSZW1vdmVQcm9wc1twcm9wc10gPSBwLmNvbmNhdChfcmVtb3ZlUHJvcHMpO1xuICByZXR1cm4gcDtcbn0sXG4gICAgX2dldEludmVyc2VHbG9iYWxNYXRyaXggPSBmdW5jdGlvbiBfZ2V0SW52ZXJzZUdsb2JhbE1hdHJpeChlbCkge1xuICAvLyBpbnRlZ3JhdGVzIGNhY2hpbmcgZm9yIGltcHJvdmVkIHBlcmZvcm1hbmNlXG4gIHZhciBjYWNoZSA9IGVsLl9nc2FwIHx8IGdzYXAuY29yZS5nZXRDYWNoZShlbCk7XG5cbiAgaWYgKGNhY2hlLmdtQ2FjaGUgPT09IGdzYXAudGlja2VyLmZyYW1lKSB7XG4gICAgcmV0dXJuIGNhY2hlLmdNYXRyaXg7XG4gIH1cblxuICBjYWNoZS5nbUNhY2hlID0gZ3NhcC50aWNrZXIuZnJhbWU7XG4gIHJldHVybiBjYWNoZS5nTWF0cml4ID0gZ2V0R2xvYmFsTWF0cml4KGVsLCB0cnVlLCBmYWxzZSwgdHJ1ZSk7XG59LFxuICAgIF9nZXRET01EZXB0aCA9IGZ1bmN0aW9uIF9nZXRET01EZXB0aChlbCwgaW52ZXJ0LCBsZXZlbCkge1xuICBpZiAobGV2ZWwgPT09IHZvaWQgMCkge1xuICAgIGxldmVsID0gMDtcbiAgfVxuXG4gIC8vIEluIGludmVydCBpcyB0cnVlLCB0aGUgc2libGluZyBkZXB0aCBpcyBpbmNyZW1lbnRzIG9mIDEsIGFuZCBwYXJlbnQvbmVzdGluZyBkZXB0aCBpcyBpbmNyZW1lbnRzIG9mIDEwMDAuIFRoaXMgbGV0cyB1cyBvcmRlciBlbGVtZW50cyBpbiBhbiBBcnJheSB0byByZWZsZWN0IGRvY3VtZW50IGZsb3cuXG4gIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlLFxuICAgICAgaW5jID0gMTAwMCAqIE1hdGgucG93KDEwLCBsZXZlbCkgKiAoaW52ZXJ0ID8gLTEgOiAxKSxcbiAgICAgIGwgPSBpbnZlcnQgPyAtaW5jICogOTAwIDogMDtcblxuICB3aGlsZSAoZWwpIHtcbiAgICBsICs9IGluYztcbiAgICBlbCA9IGVsLnByZXZpb3VzU2libGluZztcbiAgfVxuXG4gIHJldHVybiBwYXJlbnQgPyBsICsgX2dldERPTURlcHRoKHBhcmVudCwgaW52ZXJ0LCBsZXZlbCArIDEpIDogbDtcbn0sXG4gICAgX29yZGVyQnlET01EZXB0aCA9IGZ1bmN0aW9uIF9vcmRlckJ5RE9NRGVwdGgoY29tcHMsIGludmVydCwgaXNFbFN0YXRlcykge1xuICBjb21wcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wKSB7XG4gICAgcmV0dXJuIGNvbXAuZCA9IF9nZXRET01EZXB0aChpc0VsU3RhdGVzID8gY29tcC5lbGVtZW50IDogY29tcC50LCBpbnZlcnQpO1xuICB9KTtcbiAgY29tcHMuc29ydChmdW5jdGlvbiAoYzEsIGMyKSB7XG4gICAgcmV0dXJuIGMxLmQgLSBjMi5kO1xuICB9KTtcbiAgcmV0dXJuIGNvbXBzO1xufSxcbiAgICBfcmVjb3JkSW5saW5lU3R5bGVzID0gZnVuY3Rpb24gX3JlY29yZElubGluZVN0eWxlcyhlbFN0YXRlLCBwcm9wcykge1xuICAvLyByZWNvcmRzIHRoZSBjdXJyZW50IGlubGluZSBDU1MgcHJvcGVydGllcyBpbnRvIGFuIEFycmF5IGluIGFsdGVybmF0aW5nIG5hbWUvdmFsdWUgcGFpcnMgdGhhdCdzIHN0b3JlZCBpbiBhIFwiY3NzXCIgcHJvcGVydHkgb24gdGhlIHN0YXRlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiByZXZlcnQgbGF0ZXIuXG4gIHZhciBzdHlsZSA9IGVsU3RhdGUuZWxlbWVudC5zdHlsZSxcbiAgICAgIGEgPSBlbFN0YXRlLmNzcyA9IGVsU3RhdGUuY3NzIHx8IFtdLFxuICAgICAgaSA9IHByb3BzLmxlbmd0aCxcbiAgICAgIHAsXG4gICAgICB2O1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBwID0gcHJvcHNbaV07XG4gICAgdiA9IHN0eWxlW3BdIHx8IHN0eWxlLmdldFByb3BlcnR5VmFsdWUocCk7XG4gICAgYS5wdXNoKHYgPyBwIDogX2Rhc2hlZE5hbWVMb29rdXBbcF0gfHwgKF9kYXNoZWROYW1lTG9va3VwW3BdID0gX2NhbWVsVG9EYXNoZWQocCkpLCB2KTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn0sXG4gICAgX2FwcGx5SW5saW5lU3R5bGVzID0gZnVuY3Rpb24gX2FwcGx5SW5saW5lU3R5bGVzKHN0YXRlKSB7XG4gIHZhciBjc3MgPSBzdGF0ZS5jc3MsXG4gICAgICBzdHlsZSA9IHN0YXRlLmVsZW1lbnQuc3R5bGUsXG4gICAgICBpID0gMDtcbiAgc3RhdGUuY2FjaGUudW5jYWNoZSA9IDE7XG5cbiAgZm9yICg7IGkgPCBjc3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBjc3NbaSArIDFdID8gc3R5bGVbY3NzW2ldXSA9IGNzc1tpICsgMV0gOiBzdHlsZS5yZW1vdmVQcm9wZXJ0eShjc3NbaV0pO1xuICB9XG5cbiAgaWYgKCFjc3NbY3NzLmluZGV4T2YoXCJ0cmFuc2Zvcm1cIikgKyAxXSAmJiBzdHlsZS50cmFuc2xhdGUpIHtcbiAgICAvLyBDU1NQbHVnaW4gYWRkcyBzY2FsZSwgdHJhbnNsYXRlLCBhbmQgcm90YXRlIGlubGluZSBDU1MgYXMgXCJub25lXCIgaW4gb3JkZXIgdG8ga2VlcCBDU1MgcnVsZXMgZnJvbSBjb250YW1pbmF0aW5nIHRyYW5zZm9ybXMuXG4gICAgc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0cmFuc2xhdGVcIik7XG4gICAgc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJzY2FsZVwiKTtcbiAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eShcInJvdGF0ZVwiKTtcbiAgfVxufSxcbiAgICBfc2V0RmluYWxTdGF0ZXMgPSBmdW5jdGlvbiBfc2V0RmluYWxTdGF0ZXMoY29tcHMsIG9ubHlUcmFuc2Zvcm1zKSB7XG4gIGNvbXBzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gYy5hLmNhY2hlLnVuY2FjaGUgPSAxO1xuICB9KTtcbiAgb25seVRyYW5zZm9ybXMgfHwgY29tcHMuZmluYWxTdGF0ZXMuZm9yRWFjaChfYXBwbHlJbmxpbmVTdHlsZXMpO1xufSxcbiAgICBfYWJzb2x1dGVQcm9wcyA9IFwicGFkZGluZ1RvcCxwYWRkaW5nUmlnaHQscGFkZGluZ0JvdHRvbSxwYWRkaW5nTGVmdCxncmlkQXJlYSx0cmFuc2l0aW9uXCIuc3BsaXQoXCIsXCIpLFxuICAgIC8vIHByb3BlcnRpZXMgdGhhdCB3ZSBtdXN0IHJlY29yZCBqdXN0XG5fbWFrZUFic29sdXRlID0gZnVuY3Rpb24gX21ha2VBYnNvbHV0ZShlbFN0YXRlLCBmYWxsYmFja05vZGUsIGlnbm9yZUJhdGNoKSB7XG4gIHZhciBlbGVtZW50ID0gZWxTdGF0ZS5lbGVtZW50LFxuICAgICAgd2lkdGggPSBlbFN0YXRlLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gZWxTdGF0ZS5oZWlnaHQsXG4gICAgICB1bmNhY2hlID0gZWxTdGF0ZS51bmNhY2hlLFxuICAgICAgZ2V0UHJvcCA9IGVsU3RhdGUuZ2V0UHJvcCxcbiAgICAgIHN0eWxlID0gZWxlbWVudC5zdHlsZSxcbiAgICAgIGkgPSA0LFxuICAgICAgcmVzdWx0LFxuICAgICAgZGlzcGxheUlzTm9uZSxcbiAgICAgIGNzO1xuICB0eXBlb2YgZmFsbGJhY2tOb2RlICE9PSBcIm9iamVjdFwiICYmIChmYWxsYmFja05vZGUgPSBlbFN0YXRlKTtcblxuICBpZiAoX2JhdGNoICYmIGlnbm9yZUJhdGNoICE9PSAxKSB7XG4gICAgX2JhdGNoLl9hYnMucHVzaCh7XG4gICAgICB0OiBlbGVtZW50LFxuICAgICAgYjogZWxTdGF0ZSxcbiAgICAgIGE6IGVsU3RhdGUsXG4gICAgICBzZDogMFxuICAgIH0pO1xuXG4gICAgX2JhdGNoLl9maW5hbC5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoZWxTdGF0ZS5jYWNoZS51bmNhY2hlID0gMSkgJiYgX2FwcGx5SW5saW5lU3R5bGVzKGVsU3RhdGUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBkaXNwbGF5SXNOb25lID0gZ2V0UHJvcChcImRpc3BsYXlcIikgPT09IFwibm9uZVwiO1xuXG4gIGlmICghZWxTdGF0ZS5pc1Zpc2libGUgfHwgZGlzcGxheUlzTm9uZSkge1xuICAgIGRpc3BsYXlJc05vbmUgJiYgKF9yZWNvcmRJbmxpbmVTdHlsZXMoZWxTdGF0ZSwgW1wiZGlzcGxheVwiXSkuZGlzcGxheSA9IGZhbGxiYWNrTm9kZS5kaXNwbGF5KTtcbiAgICBlbFN0YXRlLm1hdHJpeCA9IGZhbGxiYWNrTm9kZS5tYXRyaXg7XG4gICAgZWxTdGF0ZS53aWR0aCA9IHdpZHRoID0gZWxTdGF0ZS53aWR0aCB8fCBmYWxsYmFja05vZGUud2lkdGg7XG4gICAgZWxTdGF0ZS5oZWlnaHQgPSBoZWlnaHQgPSBlbFN0YXRlLmhlaWdodCB8fCBmYWxsYmFja05vZGUuaGVpZ2h0O1xuICB9XG5cbiAgX3JlY29yZElubGluZVN0eWxlcyhlbFN0YXRlLCBfYWJzb2x1dGVQcm9wcyk7XG5cbiAgY3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgc3R5bGVbX2Fic29sdXRlUHJvcHNbaV1dID0gY3NbX2Fic29sdXRlUHJvcHNbaV1dOyAvLyByZWNvcmQgcGFkZGluZ3MgYXMgcHgtYmFzZWQgYmVjYXVzZSBpZiByZW1vdmVkIGZyb20gZ3JpZCwgcGVyY2VudGFnZS1iYXNlZCBvbmVzIGNvdWxkIGJlIGFsdGVyZWQuXG4gIH1cblxuICBzdHlsZS5ncmlkQXJlYSA9IFwiMSAvIDEgLyAxIC8gMVwiO1xuICBzdHlsZS50cmFuc2l0aW9uID0gXCJub25lXCI7XG4gIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICBzdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICBzdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gIHN0eWxlLnRvcCB8fCAoc3R5bGUudG9wID0gXCIwcHhcIik7XG4gIHN0eWxlLmxlZnQgfHwgKHN0eWxlLmxlZnQgPSBcIjBweFwiKTtcblxuICBpZiAodW5jYWNoZSkge1xuICAgIHJlc3VsdCA9IG5ldyBFbGVtZW50U3RhdGUoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYmV0dGVyIHBlcmZvcm1hbmNlXG4gICAgcmVzdWx0ID0gX2NvcHkoZWxTdGF0ZSwgX2VtcHR5T2JqKTtcbiAgICByZXN1bHQucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cbiAgICBpZiAoZWxTdGF0ZS5zaW1wbGUpIHtcbiAgICAgIHZhciBib3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmVzdWx0Lm1hdHJpeCA9IG5ldyBNYXRyaXgyRCgxLCAwLCAwLCAxLCBib3VuZHMubGVmdCArIF9nZXREb2NTY3JvbGxMZWZ0KCksIGJvdW5kcy50b3AgKyBfZ2V0RG9jU2Nyb2xsVG9wKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQubWF0cml4ID0gZ2V0R2xvYmFsTWF0cml4KGVsZW1lbnQsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmVzdWx0ID0gX2ZpdChyZXN1bHQsIGVsU3RhdGUsIHRydWUpO1xuICBlbFN0YXRlLnggPSBfY2xvc2VzdFRlbnRoKHJlc3VsdC54LCAwLjAxKTtcbiAgZWxTdGF0ZS55ID0gX2Nsb3Nlc3RUZW50aChyZXN1bHQueSwgMC4wMSk7XG4gIHJldHVybiBlbGVtZW50O1xufSxcbiAgICBfZmlsdGVyQ29tcHMgPSBmdW5jdGlvbiBfZmlsdGVyQ29tcHMoY29tcHMsIHRhcmdldHMpIHtcbiAgaWYgKHRhcmdldHMgIT09IHRydWUpIHtcbiAgICB0YXJnZXRzID0gX3RvQXJyYXkodGFyZ2V0cyk7XG4gICAgY29tcHMgPSBjb21wcy5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmICh0YXJnZXRzLmluZGV4T2YoKGMuc2QgPCAwID8gYy5iIDogYy5hKS5lbGVtZW50KSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjLnQuX2dzYXAucmVuZGVyVHJhbnNmb3JtKDEpOyAvLyB3ZSBtdXN0IGZvcmNlIHRyYW5zZm9ybXMgdG8gcmVuZGVyIG9uIGFueXRoaW5nIHRoYXQgaXNuJ3QgYmVpbmcgbWFkZSBwb3NpdGlvbjogYWJzb2x1dGUsIG90aGVyd2lzZSB0aGUgYWJzb2x1dGUgcG9zaXRpb24gaGFwcGVucyBhbmQgdGhlbiB3aGVuIGFuaW1hdGlvbiBiZWdpbnMgaXQgYXBwbGllcyB0cmFuc2Zvcm1zIHdoaWNoIGNhbiBjcmVhdGUgYSBuZXcgc3RhY2tpbmcgY29udGV4dCwgdGhyb3dpbmcgb2ZmIHBvc2l0aW9uaW5nIVxuXG5cbiAgICAgICAgaWYgKGMuYi5pc1Zpc2libGUpIHtcbiAgICAgICAgICBjLnQuc3R5bGUud2lkdGggPSBjLmIud2lkdGggKyBcInB4XCI7IC8vIG90aGVyd2lzZSB0aGluZ3MgY2FuIGNvbGxhcHNlIHdoZW4gY29udGVudHMgYXJlIG1hZGUgcG9zaXRpb246IGFic29sdXRlLlxuXG4gICAgICAgICAgYy50LnN0eWxlLmhlaWdodCA9IGMuYi5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjb21wcztcbn0sXG4gICAgX21ha2VDb21wc0Fic29sdXRlID0gZnVuY3Rpb24gX21ha2VDb21wc0Fic29sdXRlKGNvbXBzKSB7XG4gIHJldHVybiBfb3JkZXJCeURPTURlcHRoKGNvbXBzLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIChjLmEuaXNWaXNpYmxlIHx8IGMuYi5pc1Zpc2libGUpICYmIF9tYWtlQWJzb2x1dGUoYy5zZCA8IDAgPyBjLmIgOiBjLmEsIGMuYiwgMSk7XG4gIH0pO1xufSxcbiAgICBfZmluZEVsU3RhdGVJblN0YXRlID0gZnVuY3Rpb24gX2ZpbmRFbFN0YXRlSW5TdGF0ZShzdGF0ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIG90aGVyICYmIHN0YXRlLmlkTG9va3VwW19wYXJzZUVsZW1lbnRTdGF0ZShvdGhlcikuaWRdIHx8IHN0YXRlLmVsZW1lbnRTdGF0ZXNbMF07XG59LFxuICAgIF9wYXJzZUVsZW1lbnRTdGF0ZSA9IGZ1bmN0aW9uIF9wYXJzZUVsZW1lbnRTdGF0ZShlbE9yTm9kZSwgcHJvcHMsIHNpbXBsZSwgb3RoZXIpIHtcbiAgcmV0dXJuIGVsT3JOb2RlIGluc3RhbmNlb2YgRWxlbWVudFN0YXRlID8gZWxPck5vZGUgOiBlbE9yTm9kZSBpbnN0YW5jZW9mIEZsaXBTdGF0ZSA/IF9maW5kRWxTdGF0ZUluU3RhdGUoZWxPck5vZGUsIG90aGVyKSA6IG5ldyBFbGVtZW50U3RhdGUodHlwZW9mIGVsT3JOb2RlID09PSBcInN0cmluZ1wiID8gX2dldEVsKGVsT3JOb2RlKSB8fCBjb25zb2xlLndhcm4oZWxPck5vZGUgKyBcIiBub3QgZm91bmRcIikgOiBlbE9yTm9kZSwgcHJvcHMsIHNpbXBsZSk7XG59LFxuICAgIF9yZWNvcmRQcm9wcyA9IGZ1bmN0aW9uIF9yZWNvcmRQcm9wcyhlbFN0YXRlLCBwcm9wcykge1xuICB2YXIgZ2V0UHJvcCA9IGdzYXAuZ2V0UHJvcGVydHkoZWxTdGF0ZS5lbGVtZW50LCBudWxsLCBcIm5hdGl2ZVwiKSxcbiAgICAgIG9iaiA9IGVsU3RhdGUucHJvcHMgPSB7fSxcbiAgICAgIGkgPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIG9ialtwcm9wc1tpXV0gPSAoZ2V0UHJvcChwcm9wc1tpXSkgKyBcIlwiKS50cmltKCk7XG4gIH1cblxuICBvYmouekluZGV4ICYmIChvYmouekluZGV4ID0gcGFyc2VGbG9hdChvYmouekluZGV4KSB8fCAwKTtcbiAgcmV0dXJuIGVsU3RhdGU7XG59LFxuICAgIF9hcHBseVByb3BzID0gZnVuY3Rpb24gX2FwcGx5UHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZSB8fCBlbGVtZW50LFxuICAgICAgLy8gY291bGQgcGFzcyBpbiBhIHZhcnMgb2JqZWN0LlxuICBwO1xuXG4gIGZvciAocCBpbiBwcm9wcykge1xuICAgIHN0eWxlW3BdID0gcHJvcHNbcF07XG4gIH1cbn0sXG4gICAgX2dldElEID0gZnVuY3Rpb24gX2dldElEKGVsKSB7XG4gIHZhciBpZCA9IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtZmxpcC1pZFwiKTtcbiAgaWQgfHwgZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1mbGlwLWlkXCIsIGlkID0gXCJhdXRvLVwiICsgX2lkKyspO1xuICByZXR1cm4gaWQ7XG59LFxuICAgIF9lbGVtZW50c0Zyb21FbGVtZW50U3RhdGVzID0gZnVuY3Rpb24gX2VsZW1lbnRzRnJvbUVsZW1lbnRTdGF0ZXMoZWxTdGF0ZXMpIHtcbiAgcmV0dXJuIGVsU3RhdGVzLm1hcChmdW5jdGlvbiAoZWxTdGF0ZSkge1xuICAgIHJldHVybiBlbFN0YXRlLmVsZW1lbnQ7XG4gIH0pO1xufSxcbiAgICBfaGFuZGxlQ2FsbGJhY2sgPSBmdW5jdGlvbiBfaGFuZGxlQ2FsbGJhY2soY2FsbGJhY2ssIGVsU3RhdGVzLCB0bCkge1xuICByZXR1cm4gY2FsbGJhY2sgJiYgZWxTdGF0ZXMubGVuZ3RoICYmIHRsLmFkZChjYWxsYmFjayhfZWxlbWVudHNGcm9tRWxlbWVudFN0YXRlcyhlbFN0YXRlcyksIHRsLCBuZXcgRmxpcFN0YXRlKGVsU3RhdGVzLCAwLCB0cnVlKSksIDApO1xufSxcbiAgICBfZml0ID0gZnVuY3Rpb24gX2ZpdChmcm9tU3RhdGUsIHRvU3RhdGUsIHNjYWxlLCBhcHBseVByb3BzLCBmaXRDaGlsZCwgdmFycykge1xuICB2YXIgZWxlbWVudCA9IGZyb21TdGF0ZS5lbGVtZW50LFxuICAgICAgY2FjaGUgPSBmcm9tU3RhdGUuY2FjaGUsXG4gICAgICBwYXJlbnQgPSBmcm9tU3RhdGUucGFyZW50LFxuICAgICAgeCA9IGZyb21TdGF0ZS54LFxuICAgICAgeSA9IGZyb21TdGF0ZS55LFxuICAgICAgd2lkdGggPSB0b1N0YXRlLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gdG9TdGF0ZS5oZWlnaHQsXG4gICAgICBzY2FsZVggPSB0b1N0YXRlLnNjYWxlWCxcbiAgICAgIHNjYWxlWSA9IHRvU3RhdGUuc2NhbGVZLFxuICAgICAgcm90YXRpb24gPSB0b1N0YXRlLnJvdGF0aW9uLFxuICAgICAgYm91bmRzID0gdG9TdGF0ZS5ib3VuZHMsXG4gICAgICBzdHlsZXMgPSB2YXJzICYmIF9nZXRTdHlsZVNhdmVyICYmIF9nZXRTdHlsZVNhdmVyKGVsZW1lbnQsIFwidHJhbnNmb3JtXCIpLFxuICAgICAgZGltZW5zaW9uU3RhdGUgPSBmcm9tU3RhdGUsXG4gICAgICBfdG9TdGF0ZSRtYXRyaXggPSB0b1N0YXRlLm1hdHJpeCxcbiAgICAgIGUgPSBfdG9TdGF0ZSRtYXRyaXguZSxcbiAgICAgIGYgPSBfdG9TdGF0ZSRtYXRyaXguZixcbiAgICAgIGRlZXAgPSBmcm9tU3RhdGUuYm91bmRzLndpZHRoICE9PSBib3VuZHMud2lkdGggfHwgZnJvbVN0YXRlLmJvdW5kcy5oZWlnaHQgIT09IGJvdW5kcy5oZWlnaHQgfHwgZnJvbVN0YXRlLnNjYWxlWCAhPT0gc2NhbGVYIHx8IGZyb21TdGF0ZS5zY2FsZVkgIT09IHNjYWxlWSB8fCBmcm9tU3RhdGUucm90YXRpb24gIT09IHJvdGF0aW9uLFxuICAgICAgc2ltcGxlID0gIWRlZXAgJiYgZnJvbVN0YXRlLnNpbXBsZSAmJiB0b1N0YXRlLnNpbXBsZSAmJiAhZml0Q2hpbGQsXG4gICAgICBza2V3WCxcbiAgICAgIGZyb21Qb2ludCxcbiAgICAgIHRvUG9pbnQsXG4gICAgICBnZXRQcm9wLFxuICAgICAgcGFyZW50TWF0cml4LFxuICAgICAgbWF0cml4LFxuICAgICAgYmJveDtcblxuICBpZiAoc2ltcGxlIHx8ICFwYXJlbnQpIHtcbiAgICBzY2FsZVggPSBzY2FsZVkgPSAxO1xuICAgIHJvdGF0aW9uID0gc2tld1ggPSAwO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudE1hdHJpeCA9IF9nZXRJbnZlcnNlR2xvYmFsTWF0cml4KHBhcmVudCk7XG4gICAgbWF0cml4ID0gcGFyZW50TWF0cml4LmNsb25lKCkubXVsdGlwbHkodG9TdGF0ZS5jdG0gPyB0b1N0YXRlLm1hdHJpeC5jbG9uZSgpLm11bHRpcGx5KHRvU3RhdGUuY3RtKSA6IHRvU3RhdGUubWF0cml4KTsgLy8gcm9vdCBTVkcgZWxlbWVudHMgaGF2ZSBhIGN0bSB0aGF0IHdlIG11c3QgZmFjdG9yIG91dCAoZm9yIGV4YW1wbGUsIHZpZXdCb3g6XCIwIDAgOTQgOTRcIiB3aXRoIGEgd2lkdGggb2YgMjAwcHggd291bGQgc2NhbGUgdGhlIGludGVybmFscyBieSAyLjEyNyBidXQgd2hlbiB3ZSdyZSBtYXRjaGluZyB0aGUgc2l6ZSBvZiB0aGUgcm9vdCA8c3ZnPiBlbGVtZW50IGl0c2VsZiwgdGhhdCBzY2FsaW5nIHNob3VsZG4ndCBmYWN0b3IgaW4hKVxuXG4gICAgcm90YXRpb24gPSBfcm91bmQoTWF0aC5hdGFuMihtYXRyaXguYiwgbWF0cml4LmEpICogX1JBRDJERUcpO1xuICAgIHNrZXdYID0gX3JvdW5kKE1hdGguYXRhbjIobWF0cml4LmMsIG1hdHJpeC5kKSAqIF9SQUQyREVHICsgcm90YXRpb24pICUgMzYwOyAvLyBpbiB2ZXJ5IHJhcmUgY2FzZXMsIG1pbm9yIHJvdW5kaW5nIG1pZ2h0IGVuZCB1cCB3aXRoIDM2MCB3aGljaCBzaG91bGQgYmUgMC5cblxuICAgIHNjYWxlWCA9IE1hdGguc3FydChNYXRoLnBvdyhtYXRyaXguYSwgMikgKyBNYXRoLnBvdyhtYXRyaXguYiwgMikpO1xuICAgIHNjYWxlWSA9IE1hdGguc3FydChNYXRoLnBvdyhtYXRyaXguYywgMikgKyBNYXRoLnBvdyhtYXRyaXguZCwgMikpICogTWF0aC5jb3Moc2tld1ggKiBfREVHMlJBRCk7XG5cbiAgICBpZiAoZml0Q2hpbGQpIHtcbiAgICAgIGZpdENoaWxkID0gX3RvQXJyYXkoZml0Q2hpbGQpWzBdO1xuICAgICAgZ2V0UHJvcCA9IGdzYXAuZ2V0UHJvcGVydHkoZml0Q2hpbGQpO1xuICAgICAgYmJveCA9IGZpdENoaWxkLmdldEJCb3ggJiYgdHlwZW9mIGZpdENoaWxkLmdldEJCb3ggPT09IFwiZnVuY3Rpb25cIiAmJiBmaXRDaGlsZC5nZXRCQm94KCk7XG4gICAgICBkaW1lbnNpb25TdGF0ZSA9IHtcbiAgICAgICAgc2NhbGVYOiBnZXRQcm9wKFwic2NhbGVYXCIpLFxuICAgICAgICBzY2FsZVk6IGdldFByb3AoXCJzY2FsZVlcIiksXG4gICAgICAgIHdpZHRoOiBiYm94ID8gYmJveC53aWR0aCA6IE1hdGguY2VpbChwYXJzZUZsb2F0KGdldFByb3AoXCJ3aWR0aFwiLCBcInB4XCIpKSksXG4gICAgICAgIGhlaWdodDogYmJveCA/IGJib3guaGVpZ2h0IDogcGFyc2VGbG9hdChnZXRQcm9wKFwiaGVpZ2h0XCIsIFwicHhcIikpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNhY2hlLnJvdGF0aW9uID0gcm90YXRpb24gKyBcImRlZ1wiO1xuICAgIGNhY2hlLnNrZXdYID0gc2tld1ggKyBcImRlZ1wiO1xuICB9XG5cbiAgaWYgKHNjYWxlKSB7XG4gICAgc2NhbGVYICo9IHdpZHRoID09PSBkaW1lbnNpb25TdGF0ZS53aWR0aCB8fCAhZGltZW5zaW9uU3RhdGUud2lkdGggPyAxIDogd2lkdGggLyBkaW1lbnNpb25TdGF0ZS53aWR0aDsgLy8gbm90ZSBpZiB3aWR0aHMgYXJlIGJvdGggMCwgd2Ugc2hvdWxkIG1ha2Ugc2NhbGVYIDEgLSBzb21lIGVsZW1lbnRzIGhhdmUgYm94LXNpemluZyB0aGF0IGluY29ycG9yYXRlcyBwYWRkaW5nLCBldGMuIGFuZCB3ZSBkb24ndCB3YW50IGl0IHRvIGNvbGxhcHNlIGluIHRoYXQgY2FzZS5cblxuICAgIHNjYWxlWSAqPSBoZWlnaHQgPT09IGRpbWVuc2lvblN0YXRlLmhlaWdodCB8fCAhZGltZW5zaW9uU3RhdGUuaGVpZ2h0ID8gMSA6IGhlaWdodCAvIGRpbWVuc2lvblN0YXRlLmhlaWdodDtcbiAgICBjYWNoZS5zY2FsZVggPSBzY2FsZVg7XG4gICAgY2FjaGUuc2NhbGVZID0gc2NhbGVZO1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gX2Nsb3Nlc3RUZW50aCh3aWR0aCAqIHNjYWxlWCAvIGRpbWVuc2lvblN0YXRlLnNjYWxlWCwgMCk7XG4gICAgaGVpZ2h0ID0gX2Nsb3Nlc3RUZW50aChoZWlnaHQgKiBzY2FsZVkgLyBkaW1lbnNpb25TdGF0ZS5zY2FsZVksIDApO1xuICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgfSAvLyBpZiAoZnJvbVN0YXRlLmlzRml4ZWQpIHsgLy8gY29tbWVudGVkIG91dCBiZWNhdXNlIGl0J3Mgbm93IHRha2VuIGNhcmUgb2YgaW4gZ2V0R2xvYmFsTWF0cml4KCkgd2l0aCBhIGZsYWcgYXQgdGhlIGVuZC5cbiAgLy8gXHRlIC09IF9nZXREb2NTY3JvbGxMZWZ0KCk7XG4gIC8vIFx0ZiAtPSBfZ2V0RG9jU2Nyb2xsVG9wKCk7XG4gIC8vIH1cblxuXG4gIGFwcGx5UHJvcHMgJiYgX2FwcGx5UHJvcHMoZWxlbWVudCwgdG9TdGF0ZS5wcm9wcyk7XG5cbiAgaWYgKHNpbXBsZSB8fCAhcGFyZW50KSB7XG4gICAgeCArPSBlIC0gZnJvbVN0YXRlLm1hdHJpeC5lO1xuICAgIHkgKz0gZiAtIGZyb21TdGF0ZS5tYXRyaXguZjtcbiAgfSBlbHNlIGlmIChkZWVwIHx8IHBhcmVudCAhPT0gdG9TdGF0ZS5wYXJlbnQpIHtcbiAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0oMSwgY2FjaGUpO1xuICAgIG1hdHJpeCA9IGdldEdsb2JhbE1hdHJpeChmaXRDaGlsZCB8fCBlbGVtZW50LCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgIGZyb21Qb2ludCA9IHBhcmVudE1hdHJpeC5hcHBseSh7XG4gICAgICB4OiBtYXRyaXguZSxcbiAgICAgIHk6IG1hdHJpeC5mXG4gICAgfSk7XG4gICAgdG9Qb2ludCA9IHBhcmVudE1hdHJpeC5hcHBseSh7XG4gICAgICB4OiBlLFxuICAgICAgeTogZlxuICAgIH0pO1xuICAgIHggKz0gdG9Qb2ludC54IC0gZnJvbVBvaW50Lng7XG4gICAgeSArPSB0b1BvaW50LnkgLSBmcm9tUG9pbnQueTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgYSBmYXN0ZXIvY2hlYXBlciBhbGdvcml0aG0gaWYgd2UncmUganVzdCBtb3ZpbmcgeC95XG4gICAgcGFyZW50TWF0cml4LmUgPSBwYXJlbnRNYXRyaXguZiA9IDA7XG4gICAgdG9Qb2ludCA9IHBhcmVudE1hdHJpeC5hcHBseSh7XG4gICAgICB4OiBlIC0gZnJvbVN0YXRlLm1hdHJpeC5lLFxuICAgICAgeTogZiAtIGZyb21TdGF0ZS5tYXRyaXguZlxuICAgIH0pO1xuICAgIHggKz0gdG9Qb2ludC54O1xuICAgIHkgKz0gdG9Qb2ludC55O1xuICB9XG5cbiAgeCA9IF9jbG9zZXN0VGVudGgoeCwgMC4wMik7XG4gIHkgPSBfY2xvc2VzdFRlbnRoKHksIDAuMDIpO1xuXG4gIGlmICh2YXJzICYmICEodmFycyBpbnN0YW5jZW9mIEVsZW1lbnRTdGF0ZSkpIHtcbiAgICAvLyByZXZlcnRcbiAgICBzdHlsZXMgJiYgc3R5bGVzLnJldmVydCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIG9yIGFwcGx5IHRoZSB0cmFuc2Zvcm0gaW1tZWRpYXRlbHlcbiAgICBjYWNoZS54ID0geCArIFwicHhcIjtcbiAgICBjYWNoZS55ID0geSArIFwicHhcIjtcbiAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0oMSwgY2FjaGUpO1xuICB9XG5cbiAgaWYgKHZhcnMpIHtcbiAgICB2YXJzLnggPSB4O1xuICAgIHZhcnMueSA9IHk7XG4gICAgdmFycy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHZhcnMuc2tld1ggPSBza2V3WDtcblxuICAgIGlmIChzY2FsZSkge1xuICAgICAgdmFycy5zY2FsZVggPSBzY2FsZVg7XG4gICAgICB2YXJzLnNjYWxlWSA9IHNjYWxlWTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFycy53aWR0aCA9IHdpZHRoO1xuICAgICAgdmFycy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhcnMgfHwgY2FjaGU7XG59LFxuICAgIF9wYXJzZVN0YXRlID0gZnVuY3Rpb24gX3BhcnNlU3RhdGUodGFyZ2V0c09yU3RhdGUsIHZhcnMpIHtcbiAgcmV0dXJuIHRhcmdldHNPclN0YXRlIGluc3RhbmNlb2YgRmxpcFN0YXRlID8gdGFyZ2V0c09yU3RhdGUgOiBuZXcgRmxpcFN0YXRlKHRhcmdldHNPclN0YXRlLCB2YXJzKTtcbn0sXG4gICAgX2dldENoYW5naW5nRWxTdGF0ZSA9IGZ1bmN0aW9uIF9nZXRDaGFuZ2luZ0VsU3RhdGUodG9TdGF0ZSwgZnJvbVN0YXRlLCBpZCkge1xuICB2YXIgdG8xID0gdG9TdGF0ZS5pZExvb2t1cFtpZF0sXG4gICAgICB0bzIgPSB0b1N0YXRlLmFsdFtpZF07XG4gIHJldHVybiB0bzIuaXNWaXNpYmxlICYmICghKGZyb21TdGF0ZS5nZXRFbGVtZW50U3RhdGUodG8yLmVsZW1lbnQpIHx8IHRvMikuaXNWaXNpYmxlIHx8ICF0bzEuaXNWaXNpYmxlKSA/IHRvMiA6IHRvMTtcbn0sXG4gICAgX2JvZHlNZXRyaWNzID0gW10sXG4gICAgX2JvZHlQcm9wcyA9IFwid2lkdGgsaGVpZ2h0LG92ZXJmbG93WCxvdmVyZmxvd1lcIi5zcGxpdChcIixcIiksXG4gICAgX2JvZHlMb2NrZWQsXG4gICAgX2xvY2tCb2R5U2Nyb2xsID0gZnVuY3Rpb24gX2xvY2tCb2R5U2Nyb2xsKGxvY2spIHtcbiAgLy8gaWYgdGhlcmUncyBubyBzY3JvbGxiYXIsIHdlIHNob3VsZCBsb2NrIHRoYXQgc28gdGhhdCBtZWFzdXJlbWVudHMgZG9uJ3QgZ2V0IGFmZmVjdGVkIGJ5IHRlbXBvcmFyeSByZXBvc2l0aW9uaW5nLCBsaWtlIGlmIHNvbWV0aGluZyBpcyBjZW50ZXJlZCBpbiB0aGUgd2luZG93LlxuICBpZiAobG9jayAhPT0gX2JvZHlMb2NrZWQpIHtcbiAgICB2YXIgcyA9IF9ib2R5LnN0eWxlLFxuICAgICAgICB3ID0gX2JvZHkuY2xpZW50V2lkdGggPT09IHdpbmRvdy5vdXRlcldpZHRoLFxuICAgICAgICBoID0gX2JvZHkuY2xpZW50SGVpZ2h0ID09PSB3aW5kb3cub3V0ZXJIZWlnaHQsXG4gICAgICAgIGkgPSA0O1xuXG4gICAgaWYgKGxvY2sgJiYgKHcgfHwgaCkpIHtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgX2JvZHlNZXRyaWNzW2ldID0gc1tfYm9keVByb3BzW2ldXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcpIHtcbiAgICAgICAgcy53aWR0aCA9IF9ib2R5LmNsaWVudFdpZHRoICsgXCJweFwiO1xuICAgICAgICBzLm92ZXJmbG93WSA9IFwiaGlkZGVuXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChoKSB7XG4gICAgICAgIHMuaGVpZ2h0ID0gX2JvZHkuY2xpZW50SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICBzLm92ZXJmbG93WCA9IFwiaGlkZGVuXCI7XG4gICAgICB9XG5cbiAgICAgIF9ib2R5TG9ja2VkID0gbG9jaztcbiAgICB9IGVsc2UgaWYgKF9ib2R5TG9ja2VkKSB7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIF9ib2R5TWV0cmljc1tpXSA/IHNbX2JvZHlQcm9wc1tpXV0gPSBfYm9keU1ldHJpY3NbaV0gOiBzLnJlbW92ZVByb3BlcnR5KF9jYW1lbFRvRGFzaGVkKF9ib2R5UHJvcHNbaV0pKTtcbiAgICAgIH1cblxuICAgICAgX2JvZHlMb2NrZWQgPSBsb2NrO1xuICAgIH1cbiAgfVxufSxcbiAgICBfZnJvbVRvID0gZnVuY3Rpb24gX2Zyb21Ubyhmcm9tU3RhdGUsIHRvU3RhdGUsIHZhcnMsIHJlbGF0aXZlKSB7XG4gIC8vIHJlbGF0aXZlIGlzIC0xIGlmIFwiZnJvbSgpXCIsIGFuZCAxIGlmIFwidG8oKVwiXG4gIGZyb21TdGF0ZSBpbnN0YW5jZW9mIEZsaXBTdGF0ZSAmJiB0b1N0YXRlIGluc3RhbmNlb2YgRmxpcFN0YXRlIHx8IGNvbnNvbGUud2FybihcIk5vdCBhIHZhbGlkIHN0YXRlIG9iamVjdC5cIik7XG4gIHZhcnMgPSB2YXJzIHx8IHt9O1xuXG4gIHZhciBfdmFycyA9IHZhcnMsXG4gICAgICBjbGVhclByb3BzID0gX3ZhcnMuY2xlYXJQcm9wcyxcbiAgICAgIG9uRW50ZXIgPSBfdmFycy5vbkVudGVyLFxuICAgICAgb25MZWF2ZSA9IF92YXJzLm9uTGVhdmUsXG4gICAgICBhYnNvbHV0ZSA9IF92YXJzLmFic29sdXRlLFxuICAgICAgYWJzb2x1dGVPbkxlYXZlID0gX3ZhcnMuYWJzb2x1dGVPbkxlYXZlLFxuICAgICAgY3VzdG9tID0gX3ZhcnMuY3VzdG9tLFxuICAgICAgZGVsYXkgPSBfdmFycy5kZWxheSxcbiAgICAgIHBhdXNlZCA9IF92YXJzLnBhdXNlZCxcbiAgICAgIHJlcGVhdCA9IF92YXJzLnJlcGVhdCxcbiAgICAgIHJlcGVhdERlbGF5ID0gX3ZhcnMucmVwZWF0RGVsYXksXG4gICAgICB5b3lvID0gX3ZhcnMueW95byxcbiAgICAgIHRvZ2dsZUNsYXNzID0gX3ZhcnMudG9nZ2xlQ2xhc3MsXG4gICAgICBuZXN0ZWQgPSBfdmFycy5uZXN0ZWQsXG4gICAgICBfekluZGV4ID0gX3ZhcnMuekluZGV4LFxuICAgICAgc2NhbGUgPSBfdmFycy5zY2FsZSxcbiAgICAgIGZhZGUgPSBfdmFycy5mYWRlLFxuICAgICAgc3RhZ2dlciA9IF92YXJzLnN0YWdnZXIsXG4gICAgICBzcGluID0gX3ZhcnMuc3BpbixcbiAgICAgIHBydW5lID0gX3ZhcnMucHJ1bmUsXG4gICAgICBwcm9wcyA9IChcInByb3BzXCIgaW4gdmFycyA/IHZhcnMgOiBmcm9tU3RhdGUpLnByb3BzLFxuICAgICAgdHdlZW5WYXJzID0gX2NvcHkodmFycywgX3Jlc2VydmVkKSxcbiAgICAgIGFuaW1hdGlvbiA9IGdzYXAudGltZWxpbmUoe1xuICAgIGRlbGF5OiBkZWxheSxcbiAgICBwYXVzZWQ6IHBhdXNlZCxcbiAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICByZXBlYXREZWxheTogcmVwZWF0RGVsYXksXG4gICAgeW95bzogeW95byxcbiAgICBkYXRhOiBcImlzRmxpcFwiXG4gIH0pLFxuICAgICAgcmVtYWluaW5nUHJvcHMgPSB0d2VlblZhcnMsXG4gICAgICBlbnRlcmluZyA9IFtdLFxuICAgICAgbGVhdmluZyA9IFtdLFxuICAgICAgY29tcHMgPSBbXSxcbiAgICAgIHN3YXBPdXRUYXJnZXRzID0gW10sXG4gICAgICBzcGluTnVtID0gc3BpbiA9PT0gdHJ1ZSA/IDEgOiBzcGluIHx8IDAsXG4gICAgICBzcGluRnVuYyA9IHR5cGVvZiBzcGluID09PSBcImZ1bmN0aW9uXCIgPyBzcGluIDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzcGluTnVtO1xuICB9LFxuICAgICAgaW50ZXJydXB0ZWQgPSBmcm9tU3RhdGUuaW50ZXJydXB0ZWQgfHwgdG9TdGF0ZS5pbnRlcnJ1cHRlZCxcbiAgICAgIGFkZEZ1bmMgPSBhbmltYXRpb25bcmVsYXRpdmUgIT09IDEgPyBcInRvXCIgOiBcImZyb21cIl0sXG4gICAgICB2LFxuICAgICAgcCxcbiAgICAgIGVuZFRpbWUsXG4gICAgICBpLFxuICAgICAgZWwsXG4gICAgICBjb21wLFxuICAgICAgc3RhdGUsXG4gICAgICB0YXJnZXRzLFxuICAgICAgZmluYWxTdGF0ZXMsXG4gICAgICBmcm9tTm9kZSxcbiAgICAgIHRvTm9kZSxcbiAgICAgIHJ1bixcbiAgICAgIGEsXG4gICAgICBiOyAvL3JlbGF0aXZlIHx8ICh0b1N0YXRlID0gKG5ldyBGbGlwU3RhdGUodG9TdGF0ZS50YXJnZXRzLCB7cHJvcHM6IHByb3BzfSkpLmZpdCh0b1N0YXRlLCBzY2FsZSkpO1xuXG5cbiAgZm9yIChwIGluIHRvU3RhdGUuaWRMb29rdXApIHtcbiAgICB0b05vZGUgPSAhdG9TdGF0ZS5hbHRbcF0gPyB0b1N0YXRlLmlkTG9va3VwW3BdIDogX2dldENoYW5naW5nRWxTdGF0ZSh0b1N0YXRlLCBmcm9tU3RhdGUsIHApO1xuICAgIGVsID0gdG9Ob2RlLmVsZW1lbnQ7XG4gICAgZnJvbU5vZGUgPSBmcm9tU3RhdGUuaWRMb29rdXBbcF07XG4gICAgZnJvbVN0YXRlLmFsdFtwXSAmJiBlbCA9PT0gZnJvbU5vZGUuZWxlbWVudCAmJiAoZnJvbVN0YXRlLmFsdFtwXS5pc1Zpc2libGUgfHwgIXRvTm9kZS5pc1Zpc2libGUpICYmIChmcm9tTm9kZSA9IGZyb21TdGF0ZS5hbHRbcF0pO1xuXG4gICAgaWYgKGZyb21Ob2RlKSB7XG4gICAgICBjb21wID0ge1xuICAgICAgICB0OiBlbCxcbiAgICAgICAgYjogZnJvbU5vZGUsXG4gICAgICAgIGE6IHRvTm9kZSxcbiAgICAgICAgc2Q6IGZyb21Ob2RlLmVsZW1lbnQgPT09IGVsID8gMCA6IHRvTm9kZS5pc1Zpc2libGUgPyAxIDogLTFcbiAgICAgIH07XG4gICAgICBjb21wcy5wdXNoKGNvbXApO1xuXG4gICAgICBpZiAoY29tcC5zZCkge1xuICAgICAgICBpZiAoY29tcC5zZCA8IDApIHtcbiAgICAgICAgICBjb21wLmIgPSB0b05vZGU7XG4gICAgICAgICAgY29tcC5hID0gZnJvbU5vZGU7XG4gICAgICAgIH0gLy8gZm9yIHN3YXBwaW5nIGVsZW1lbnRzIHRoYXQgZ290IGludGVycnVwdGVkLCB3ZSBtdXN0IHJlLXJlY29yZCB0aGUgaW5saW5lIHN0eWxlcyB0byBlbnN1cmUgdGhleSdyZSBub3QgdGFpbnRlZC4gUmVtZW1iZXIsIC5iYXRjaCgpIHBlcm1pdHMgZ2V0U3RhdGUoKSBub3QgdG8gZm9yY2UgaW4tcHJvZ3Jlc3MgZmxpcHMgdG8gdGhlaXIgZW5kIHN0YXRlLlxuXG5cbiAgICAgICAgaW50ZXJydXB0ZWQgJiYgX3JlY29yZElubGluZVN0eWxlcyhjb21wLmIsIHByb3BzID8gX21lbW9pemVkUmVtb3ZlUHJvcHNbcHJvcHNdIDogX3JlbW92ZVByb3BzKTtcbiAgICAgICAgZmFkZSAmJiBjb21wcy5wdXNoKGNvbXAuc3dhcCA9IHtcbiAgICAgICAgICB0OiBmcm9tTm9kZS5lbGVtZW50LFxuICAgICAgICAgIGI6IGNvbXAuYixcbiAgICAgICAgICBhOiBjb21wLmEsXG4gICAgICAgICAgc2Q6IC1jb21wLnNkLFxuICAgICAgICAgIHN3YXA6IGNvbXBcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGVsLl9mbGlwID0gZnJvbU5vZGUuZWxlbWVudC5fZmxpcCA9IF9iYXRjaCA/IF9iYXRjaC50aW1lbGluZSA6IGFuaW1hdGlvbjtcbiAgICB9IGVsc2UgaWYgKHRvTm9kZS5pc1Zpc2libGUpIHtcbiAgICAgIGNvbXBzLnB1c2goe1xuICAgICAgICB0OiBlbCxcbiAgICAgICAgYjogX2NvcHkodG9Ob2RlLCB7XG4gICAgICAgICAgaXNWaXNpYmxlOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBhOiB0b05vZGUsXG4gICAgICAgIHNkOiAwLFxuICAgICAgICBlbnRlcmluZzogMVxuICAgICAgfSk7IC8vIHRvIGluY2x1ZGUgaXQgaW4gdGhlIFwiZW50ZXJpbmdcIiBBcnJheSBhbmQgZG8gYWJzb2x1dGUgcG9zaXRpb25pbmcgaWYgbmVjZXNzYXJ5XG5cbiAgICAgIGVsLl9mbGlwID0gX2JhdGNoID8gX2JhdGNoLnRpbWVsaW5lIDogYW5pbWF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHByb3BzICYmIChfbWVtb2l6ZWRQcm9wc1twcm9wc10gfHwgX21lbW9pemVQcm9wcyhwcm9wcykpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gdHdlZW5WYXJzW3BdID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBjb21wc1tpXS5hLnByb3BzW3BdO1xuICAgIH07XG4gIH0pO1xuICBjb21wcy5maW5hbFN0YXRlcyA9IGZpbmFsU3RhdGVzID0gW107XG5cbiAgcnVuID0gZnVuY3Rpb24gcnVuKCkge1xuICAgIF9vcmRlckJ5RE9NRGVwdGgoY29tcHMpO1xuXG4gICAgX2xvY2tCb2R5U2Nyb2xsKHRydWUpOyAvLyBvdGhlcndpc2UsIG1lYXN1cmVtZW50cyBtYXkgZ2V0IHRocm93biBvZmYgd2hlbiB0aGluZ3MgZ2V0IGZpdC5cbiAgICAvLyBUT0RPOiBjYWNoZSB0aGUgbWF0cml4LCBlc3BlY2lhbGx5IGZvciBwYXJlbnQgYmVjYXVzZSBpdCdsbCBwcm9iYWJseSBnZXQgcmV1c2VkIHF1aXRlIGEgYml0LCBidXQgbG9jayBpdCB0byBhIHBhcnRpY3VsYXIgY3ljbGUoPykuXG5cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb21wcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29tcCA9IGNvbXBzW2ldO1xuICAgICAgYSA9IGNvbXAuYTtcbiAgICAgIGIgPSBjb21wLmI7XG5cbiAgICAgIGlmIChwcnVuZSAmJiAhYS5pc0RpZmZlcmVudChiKSAmJiAhY29tcC5lbnRlcmluZykge1xuICAgICAgICAvLyBvbmx5IGZsaXAgaWYgdGhpbmdzIGNoYW5nZWQhIERvbid0IG9taXQgaXQgZnJvbSBjb21wcyBpbml0aWFsbHkgYmVjYXVzZSB0aGF0J2QgcHJldmVudCB0aGUgZWxlbWVudCBmcm9tIGJlaW5nIHBvc2l0aW9uZWQgYWJzb2x1dGVseSAoaWYgbmVjZXNzYXJ5KVxuICAgICAgICBjb21wcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gY29tcC50O1xuICAgICAgICBuZXN0ZWQgJiYgIShjb21wLnNkIDwgMCkgJiYgaSAmJiAoYS5tYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZWwsIGZhbHNlLCBmYWxzZSwgdHJ1ZSkpOyAvLyBtb3ZpbmcgYSBwYXJlbnQgYWZmZWN0cyB0aGUgcG9zaXRpb24gb2YgY2hpbGRyZW5cblxuICAgICAgICBpZiAoYi5pc1Zpc2libGUgJiYgYS5pc1Zpc2libGUpIHtcbiAgICAgICAgICBpZiAoY29tcC5zZCA8IDApIHtcbiAgICAgICAgICAgIC8vIHN3YXBwaW5nIE9VVCAoc3dhcCBkaXJlY3Rpb24gb2YgLTEgaXMgb3V0KVxuICAgICAgICAgICAgc3RhdGUgPSBuZXcgRWxlbWVudFN0YXRlKGVsLCBwcm9wcywgZnJvbVN0YXRlLnNpbXBsZSk7XG5cbiAgICAgICAgICAgIF9maXQoc3RhdGUsIGEsIHNjYWxlLCAwLCAwLCBzdGF0ZSk7XG5cbiAgICAgICAgICAgIHN0YXRlLm1hdHJpeCA9IGdldEdsb2JhbE1hdHJpeChlbCwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIHN0YXRlLmNzcyA9IGNvbXAuYi5jc3M7XG4gICAgICAgICAgICBjb21wLmEgPSBhID0gc3RhdGU7XG4gICAgICAgICAgICBmYWRlICYmIChlbC5zdHlsZS5vcGFjaXR5ID0gaW50ZXJydXB0ZWQgPyBiLm9wYWNpdHkgOiBhLm9wYWNpdHkpO1xuICAgICAgICAgICAgc3RhZ2dlciAmJiBzd2FwT3V0VGFyZ2V0cy5wdXNoKGVsKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbXAuc2QgPiAwICYmIGZhZGUpIHtcbiAgICAgICAgICAgIC8vIHN3YXBwaW5nIElOIChzd2FwIGRpcmVjdGlvbiBvZiAxIGlzIGluKVxuICAgICAgICAgICAgZWwuc3R5bGUub3BhY2l0eSA9IGludGVycnVwdGVkID8gYS5vcGFjaXR5IC0gYi5vcGFjaXR5IDogXCIwXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2ZpdChhLCBiLCBzY2FsZSwgcHJvcHMpO1xuICAgICAgICB9IGVsc2UgaWYgKGIuaXNWaXNpYmxlICE9PSBhLmlzVmlzaWJsZSkge1xuICAgICAgICAgIC8vIGVpdGhlciBlbnRlcmluZyBvciBsZWF2aW5nIChvbmUgc2lkZSBpcyBpbnZpc2libGUpXG4gICAgICAgICAgaWYgKCFiLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgLy8gZW50ZXJpbmdcbiAgICAgICAgICAgIGEuaXNWaXNpYmxlICYmIGVudGVyaW5nLnB1c2goYSk7XG4gICAgICAgICAgICBjb21wcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFhLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgLy8gbGVhdmluZ1xuICAgICAgICAgICAgYi5jc3MgPSBhLmNzcztcbiAgICAgICAgICAgIGxlYXZpbmcucHVzaChiKTtcbiAgICAgICAgICAgIGNvbXBzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgYWJzb2x1dGUgJiYgbmVzdGVkICYmIF9maXQoYSwgYiwgc2NhbGUsIHByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNjYWxlKSB7XG4gICAgICAgICAgZWwuc3R5bGUubWF4V2lkdGggPSBNYXRoLm1heChhLndpZHRoLCBiLndpZHRoKSArIFwicHhcIjtcbiAgICAgICAgICBlbC5zdHlsZS5tYXhIZWlnaHQgPSBNYXRoLm1heChhLmhlaWdodCwgYi5oZWlnaHQpICsgXCJweFwiO1xuICAgICAgICAgIGVsLnN0eWxlLm1pbldpZHRoID0gTWF0aC5taW4oYS53aWR0aCwgYi53aWR0aCkgKyBcInB4XCI7XG4gICAgICAgICAgZWwuc3R5bGUubWluSGVpZ2h0ID0gTWF0aC5taW4oYS5oZWlnaHQsIGIuaGVpZ2h0KSArIFwicHhcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5lc3RlZCAmJiB0b2dnbGVDbGFzcyAmJiBlbC5jbGFzc0xpc3QuYWRkKHRvZ2dsZUNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgZmluYWxTdGF0ZXMucHVzaChhKTtcbiAgICB9XG5cbiAgICB2YXIgY2xhc3NUYXJnZXRzO1xuXG4gICAgaWYgKHRvZ2dsZUNsYXNzKSB7XG4gICAgICBjbGFzc1RhcmdldHMgPSBmaW5hbFN0YXRlcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHMuZWxlbWVudDtcbiAgICAgIH0pO1xuICAgICAgbmVzdGVkICYmIGNsYXNzVGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLmNsYXNzTGlzdC5yZW1vdmUodG9nZ2xlQ2xhc3MpO1xuICAgICAgfSk7IC8vIHRoZXJlIGNvdWxkIGJlIGEgZGVsYXksIHNvIGRvbid0IGxlYXZlIHRoZSBjbGFzc2VzIGFwcGxpZWQgKHdlJ2xsIGRvIGl0IGluIGEgdGltZWxpbmUgY2FsbGJhY2spXG4gICAgfVxuXG4gICAgX2xvY2tCb2R5U2Nyb2xsKGZhbHNlKTtcblxuICAgIGlmIChzY2FsZSkge1xuICAgICAgdHdlZW5WYXJzLnNjYWxlWCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBjb21wc1tpXS5hLnNjYWxlWDtcbiAgICAgIH07XG5cbiAgICAgIHR3ZWVuVmFycy5zY2FsZVkgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gY29tcHNbaV0uYS5zY2FsZVk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0d2VlblZhcnMud2lkdGggPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gY29tcHNbaV0uYS53aWR0aCArIFwicHhcIjtcbiAgICAgIH07XG5cbiAgICAgIHR3ZWVuVmFycy5oZWlnaHQgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gY29tcHNbaV0uYS5oZWlnaHQgKyBcInB4XCI7XG4gICAgICB9O1xuXG4gICAgICB0d2VlblZhcnMuYXV0b1JvdW5kID0gdmFycy5hdXRvUm91bmQgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgdHdlZW5WYXJzLnggPSBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGNvbXBzW2ldLmEueCArIFwicHhcIjtcbiAgICB9O1xuXG4gICAgdHdlZW5WYXJzLnkgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGNvbXBzW2ldLmEueSArIFwicHhcIjtcbiAgICB9O1xuXG4gICAgdHdlZW5WYXJzLnJvdGF0aW9uID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBjb21wc1tpXS5hLnJvdGF0aW9uICsgKHNwaW4gPyBzcGluRnVuYyhpLCB0YXJnZXRzW2ldLCB0YXJnZXRzKSAqIDM2MCA6IDApO1xuICAgIH07XG5cbiAgICB0d2VlblZhcnMuc2tld1ggPSBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGNvbXBzW2ldLmEuc2tld1g7XG4gICAgfTtcblxuICAgIHRhcmdldHMgPSBjb21wcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjLnQ7XG4gICAgfSk7XG5cbiAgICBpZiAoX3pJbmRleCB8fCBfekluZGV4ID09PSAwKSB7XG4gICAgICB0d2VlblZhcnMubW9kaWZpZXJzID0ge1xuICAgICAgICB6SW5kZXg6IGZ1bmN0aW9uIHpJbmRleCgpIHtcbiAgICAgICAgICByZXR1cm4gX3pJbmRleDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHR3ZWVuVmFycy56SW5kZXggPSBfekluZGV4O1xuICAgICAgdHdlZW5WYXJzLmltbWVkaWF0ZVJlbmRlciA9IHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZTtcbiAgICB9XG5cbiAgICBmYWRlICYmICh0d2VlblZhcnMub3BhY2l0eSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gY29tcHNbaV0uc2QgPCAwID8gMCA6IGNvbXBzW2ldLnNkID4gMCA/IGNvbXBzW2ldLmEub3BhY2l0eSA6IFwiKz0wXCI7XG4gICAgfSk7XG5cbiAgICBpZiAoc3dhcE91dFRhcmdldHMubGVuZ3RoKSB7XG4gICAgICBzdGFnZ2VyID0gZ3NhcC51dGlscy5kaXN0cmlidXRlKHN0YWdnZXIpO1xuICAgICAgdmFyIGR1bW15QXJyYXkgPSB0YXJnZXRzLnNsaWNlKHN3YXBPdXRUYXJnZXRzLmxlbmd0aCk7XG5cbiAgICAgIHR3ZWVuVmFycy5zdGFnZ2VyID0gZnVuY3Rpb24gKGksIGVsKSB7XG4gICAgICAgIHJldHVybiBzdGFnZ2VyKH5zd2FwT3V0VGFyZ2V0cy5pbmRleE9mKGVsKSA/IHRhcmdldHMuaW5kZXhPZihjb21wc1tpXS5zd2FwLnQpIDogaSwgZWwsIGR1bW15QXJyYXkpO1xuICAgICAgfTtcbiAgICB9IC8vIC8vIGZvciB0ZXN0aW5nLi4uXG4gICAgLy8gZ3NhcC5kZWxheWVkQ2FsbCh2YXJzLmRhdGEgPyA1MCA6IDEsIGZ1bmN0aW9uKCkge1xuICAgIC8vIFx0YW5pbWF0aW9uLmV2ZW50Q2FsbGJhY2soXCJvbkNvbXBsZXRlXCIsICgpID0+IF9zZXRGaW5hbFN0YXRlcyhjb21wcywgIWNsZWFyUHJvcHMpKTtcbiAgICAvLyBcdGFkZEZ1bmMuY2FsbChhbmltYXRpb24sIHRhcmdldHMsIHR3ZWVuVmFycywgMCkucGxheSgpO1xuICAgIC8vIH0pO1xuICAgIC8vIHJldHVybjtcblxuXG4gICAgX2NhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gdmFyc1tuYW1lXSAmJiBhbmltYXRpb24uZXZlbnRDYWxsYmFjayhuYW1lLCB2YXJzW25hbWVdLCB2YXJzW25hbWUgKyBcIlBhcmFtc1wiXSk7XG4gICAgfSk7IC8vIGFwcGx5IGNhbGxiYWNrcyB0byB0aGUgdGltZWxpbmUsIG5vdCB0d2VlbnMgKGJlY2F1c2UgXCJjdXN0b21cIiB0aW1pbmcgY2FuIG1ha2UgbXVsdGlwbGUgdHdlZW5zKVxuXG5cbiAgICBpZiAoY3VzdG9tICYmIHRhcmdldHMubGVuZ3RoKSB7XG4gICAgICAvLyBidXN0IG91dCB0aGUgY3VzdG9tIHByb3BlcnRpZXMgYXMgdGhlaXIgb3duIHR3ZWVucyBzbyB0aGV5IGNhbiB1c2UgZGlmZmVyZW50IGVhc2VzLCBkdXJhdGlvbnMsIGV0Yy5cbiAgICAgIHJlbWFpbmluZ1Byb3BzID0gX2NvcHkodHdlZW5WYXJzLCBfcmVzZXJ2ZWQpO1xuXG4gICAgICBpZiAoXCJzY2FsZVwiIGluIGN1c3RvbSkge1xuICAgICAgICBjdXN0b20uc2NhbGVYID0gY3VzdG9tLnNjYWxlWSA9IGN1c3RvbS5zY2FsZTtcbiAgICAgICAgZGVsZXRlIGN1c3RvbS5zY2FsZTtcbiAgICAgIH1cblxuICAgICAgZm9yIChwIGluIGN1c3RvbSkge1xuICAgICAgICB2ID0gX2NvcHkoY3VzdG9tW3BdLCBfZml0UmVzZXJ2ZWQpO1xuICAgICAgICB2W3BdID0gdHdlZW5WYXJzW3BdO1xuICAgICAgICAhKFwiZHVyYXRpb25cIiBpbiB2KSAmJiBcImR1cmF0aW9uXCIgaW4gdHdlZW5WYXJzICYmICh2LmR1cmF0aW9uID0gdHdlZW5WYXJzLmR1cmF0aW9uKTtcbiAgICAgICAgdi5zdGFnZ2VyID0gdHdlZW5WYXJzLnN0YWdnZXI7XG4gICAgICAgIGFkZEZ1bmMuY2FsbChhbmltYXRpb24sIHRhcmdldHMsIHYsIDApO1xuICAgICAgICBkZWxldGUgcmVtYWluaW5nUHJvcHNbcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldHMubGVuZ3RoIHx8IGxlYXZpbmcubGVuZ3RoIHx8IGVudGVyaW5nLmxlbmd0aCkge1xuICAgICAgdG9nZ2xlQ2xhc3MgJiYgYW5pbWF0aW9uLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdG9nZ2xlQ2xhc3MoY2xhc3NUYXJnZXRzLCB0b2dnbGVDbGFzcywgYW5pbWF0aW9uLl96VGltZSA8IDAgPyBcInJlbW92ZVwiIDogXCJhZGRcIik7XG4gICAgICB9LCAwKSAmJiAhcGF1c2VkICYmIF90b2dnbGVDbGFzcyhjbGFzc1RhcmdldHMsIHRvZ2dsZUNsYXNzLCBcImFkZFwiKTtcbiAgICAgIHRhcmdldHMubGVuZ3RoICYmIGFkZEZ1bmMuY2FsbChhbmltYXRpb24sIHRhcmdldHMsIHJlbWFpbmluZ1Byb3BzLCAwKTtcbiAgICB9XG5cbiAgICBfaGFuZGxlQ2FsbGJhY2sob25FbnRlciwgZW50ZXJpbmcsIGFuaW1hdGlvbik7XG5cbiAgICBfaGFuZGxlQ2FsbGJhY2sob25MZWF2ZSwgbGVhdmluZywgYW5pbWF0aW9uKTtcblxuICAgIHZhciBiYXRjaFRsID0gX2JhdGNoICYmIF9iYXRjaC50aW1lbGluZTtcblxuICAgIGlmIChiYXRjaFRsKSB7XG4gICAgICBiYXRjaFRsLmFkZChhbmltYXRpb24sIDApO1xuXG4gICAgICBfYmF0Y2guX2ZpbmFsLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3NldEZpbmFsU3RhdGVzKGNvbXBzLCAhY2xlYXJQcm9wcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBlbmRUaW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uKCk7XG4gICAgYW5pbWF0aW9uLmNhbGwoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZvcndhcmQgPSBhbmltYXRpb24udGltZSgpID49IGVuZFRpbWU7XG4gICAgICBmb3J3YXJkICYmICFiYXRjaFRsICYmIF9zZXRGaW5hbFN0YXRlcyhjb21wcywgIWNsZWFyUHJvcHMpO1xuICAgICAgdG9nZ2xlQ2xhc3MgJiYgX3RvZ2dsZUNsYXNzKGNsYXNzVGFyZ2V0cywgdG9nZ2xlQ2xhc3MsIGZvcndhcmQgPyBcInJlbW92ZVwiIDogXCJhZGRcIik7XG4gICAgfSk7XG4gIH07XG5cbiAgYWJzb2x1dGVPbkxlYXZlICYmIChhYnNvbHV0ZSA9IGNvbXBzLmZpbHRlcihmdW5jdGlvbiAoY29tcCkge1xuICAgIHJldHVybiAhY29tcC5zZCAmJiAhY29tcC5hLmlzVmlzaWJsZSAmJiBjb21wLmIuaXNWaXNpYmxlO1xuICB9KS5tYXAoZnVuY3Rpb24gKGNvbXApIHtcbiAgICByZXR1cm4gY29tcC5hLmVsZW1lbnQ7XG4gIH0pKTtcblxuICBpZiAoX2JhdGNoKSB7XG4gICAgdmFyIF9iYXRjaCRfYWJzO1xuXG4gICAgYWJzb2x1dGUgJiYgKF9iYXRjaCRfYWJzID0gX2JhdGNoLl9hYnMpLnB1c2guYXBwbHkoX2JhdGNoJF9hYnMsIF9maWx0ZXJDb21wcyhjb21wcywgYWJzb2x1dGUpKTtcblxuICAgIF9iYXRjaC5fcnVuLnB1c2gocnVuKTtcbiAgfSBlbHNlIHtcbiAgICBhYnNvbHV0ZSAmJiBfbWFrZUNvbXBzQWJzb2x1dGUoX2ZpbHRlckNvbXBzKGNvbXBzLCBhYnNvbHV0ZSkpOyAvLyB3aGVuIG1ha2luZyBhYnNvbHV0ZSwgd2UgbXVzdCBnbyBpbiBhIHZlcnkgcGFydGljdWxhciBvcmRlciBzbyB0aGF0IGRvY3VtZW50IGZsb3cgY2hhbmdlcyBkb24ndCBhZmZlY3QgdGhpbmdzLiBEb24ndCBtYWtlIGl0IHZpc2libGUgaWYgYm90aCB0aGUgYmVmb3JlIGFuZCBhZnRlciBzdGF0ZXMgYXJlIGludmlzaWJsZSEgVGhlcmUncyBubyBwb2ludCwgYW5kIGl0IGNvdWxkIG1ha2UgdGhpbmdzIGFwcGVhciB2aXNpYmxlIGR1cmluZyB0aGUgZmxpcCB0aGF0IHNob3VsZG4ndCBiZS5cblxuICAgIHJ1bigpO1xuICB9XG5cbiAgdmFyIGFuaW0gPSBfYmF0Y2ggPyBfYmF0Y2gudGltZWxpbmUgOiBhbmltYXRpb247XG5cbiAgYW5pbS5yZXZlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9raWxsRmxpcChhbmltLCAxLCAxKTtcbiAgfTsgLy8gYSBGbGlwIHRpbWVsaW5lIHNob3VsZCBiZWhhdmUgdmVyeSBkaWZmZXJlbnQgd2hlbiByZXZlcnRpbmcgLSBpdCBzaG91bGQgYWN0dWFsbHkganVtcCB0byB0aGUgZW5kIHNvIHRoYXQgc3R5bGVzIGdldCBjbGVhcmVkIG91dC5cblxuXG4gIHJldHVybiBhbmltO1xufSxcbiAgICBfaW50ZXJydXB0ID0gZnVuY3Rpb24gX2ludGVycnVwdCh0bCkge1xuICB0bC52YXJzLm9uSW50ZXJydXB0ICYmIHRsLnZhcnMub25JbnRlcnJ1cHQuYXBwbHkodGwsIHRsLnZhcnMub25JbnRlcnJ1cHRQYXJhbXMgfHwgW10pO1xuICB0bC5nZXRDaGlsZHJlbih0cnVlLCBmYWxzZSwgdHJ1ZSkuZm9yRWFjaChfaW50ZXJydXB0KTtcbn0sXG4gICAgX2tpbGxGbGlwID0gZnVuY3Rpb24gX2tpbGxGbGlwKHRsLCBhY3Rpb24sIGZvcmNlKSB7XG4gIC8vIGFjdGlvbjogMCA9IG5vdGhpbmcsIDEgPSBjb21wbGV0ZSwgMiA9IG9ubHkga2lsbCAoZG9uJ3QgY29tcGxldGUpXG4gIGlmICh0bCAmJiB0bC5wcm9ncmVzcygpIDwgMSAmJiAoIXRsLnBhdXNlZCgpIHx8IGZvcmNlKSkge1xuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgIF9pbnRlcnJ1cHQodGwpO1xuXG4gICAgICBhY3Rpb24gPCAyICYmIHRsLnByb2dyZXNzKDEpOyAvLyB3ZSBzaG91bGQgYWxzbyBraWxsIGl0IGluIGNhc2UgaXQgd2FzIGFkZGVkIHRvIGEgcGFyZW50IHRpbWVsaW5lLlxuXG4gICAgICB0bC5raWxsKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0sXG4gICAgX2NyZWF0ZUxvb2t1cCA9IGZ1bmN0aW9uIF9jcmVhdGVMb29rdXAoc3RhdGUpIHtcbiAgdmFyIGxvb2t1cCA9IHN0YXRlLmlkTG9va3VwID0ge30sXG4gICAgICBhbHQgPSBzdGF0ZS5hbHQgPSB7fSxcbiAgICAgIGVsU3RhdGVzID0gc3RhdGUuZWxlbWVudFN0YXRlcyxcbiAgICAgIGkgPSBlbFN0YXRlcy5sZW5ndGgsXG4gICAgICBlbFN0YXRlO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBlbFN0YXRlID0gZWxTdGF0ZXNbaV07XG4gICAgbG9va3VwW2VsU3RhdGUuaWRdID8gYWx0W2VsU3RhdGUuaWRdID0gZWxTdGF0ZSA6IGxvb2t1cFtlbFN0YXRlLmlkXSA9IGVsU3RhdGU7XG4gIH1cbn07XG5cbnZhciBGbGlwU3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGbGlwU3RhdGUodGFyZ2V0cywgdmFycywgdGFyZ2V0c0FyZUVsZW1lbnRTdGF0ZXMpIHtcbiAgICB0aGlzLnByb3BzID0gdmFycyAmJiB2YXJzLnByb3BzO1xuICAgIHRoaXMuc2ltcGxlID0gISEodmFycyAmJiB2YXJzLnNpbXBsZSk7XG5cbiAgICBpZiAodGFyZ2V0c0FyZUVsZW1lbnRTdGF0ZXMpIHtcbiAgICAgIHRoaXMudGFyZ2V0cyA9IF9lbGVtZW50c0Zyb21FbGVtZW50U3RhdGVzKHRhcmdldHMpO1xuICAgICAgdGhpcy5lbGVtZW50U3RhdGVzID0gdGFyZ2V0cztcblxuICAgICAgX2NyZWF0ZUxvb2t1cCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YXJnZXRzID0gX3RvQXJyYXkodGFyZ2V0cyk7XG4gICAgICB2YXIgc29mdCA9IHZhcnMgJiYgKHZhcnMua2lsbCA9PT0gZmFsc2UgfHwgdmFycy5iYXRjaCAmJiAhdmFycy5raWxsKTtcbiAgICAgIF9iYXRjaCAmJiAhc29mdCAmJiBfYmF0Y2guX2tpbGwucHVzaCh0aGlzKTtcbiAgICAgIHRoaXMudXBkYXRlKHNvZnQgfHwgISFfYmF0Y2gpOyAvLyB3aGVuIGJhdGNoaW5nLCBkb24ndCBmb3JjZSBpbi1wcm9ncmVzcyBmbGlwcyB0byB0aGVpciBlbmQ7IHdlIG5lZWQgdG8gZG8gdGhhdCBBRlRFUiBhbGwgZ2V0U3RhdGVzKCkgYXJlIGNhbGxlZC5cbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRmxpcFN0YXRlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNvZnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5lbGVtZW50U3RhdGVzID0gdGhpcy50YXJnZXRzLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBuZXcgRWxlbWVudFN0YXRlKGVsLCBfdGhpcy5wcm9wcywgX3RoaXMuc2ltcGxlKTtcbiAgICB9KTtcblxuICAgIF9jcmVhdGVMb29rdXAodGhpcyk7XG5cbiAgICB0aGlzLmludGVycnVwdChzb2Z0KTtcbiAgICB0aGlzLnJlY29yZElubGluZVN0eWxlcygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMudGFyZ2V0cy5sZW5ndGggPSB0aGlzLmVsZW1lbnRTdGF0ZXMubGVuZ3RoID0gMDtcblxuICAgIF9jcmVhdGVMb29rdXAodGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZml0ID0gZnVuY3Rpb24gZml0KHN0YXRlLCBzY2FsZSwgbmVzdGVkKSB7XG4gICAgdmFyIGVsU3RhdGVzSW5PcmRlciA9IF9vcmRlckJ5RE9NRGVwdGgodGhpcy5lbGVtZW50U3RhdGVzLnNsaWNlKDApLCBmYWxzZSwgdHJ1ZSksXG4gICAgICAgIHRvRWxTdGF0ZXMgPSAoc3RhdGUgfHwgdGhpcykuaWRMb29rdXAsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBmcm9tTm9kZSxcbiAgICAgICAgdG9Ob2RlO1xuXG4gICAgZm9yICg7IGkgPCBlbFN0YXRlc0luT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZyb21Ob2RlID0gZWxTdGF0ZXNJbk9yZGVyW2ldO1xuICAgICAgbmVzdGVkICYmIChmcm9tTm9kZS5tYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZnJvbU5vZGUuZWxlbWVudCwgZmFsc2UsIGZhbHNlLCB0cnVlKSk7IC8vIG1vdmluZyBhIHBhcmVudCBhZmZlY3RzIHRoZSBwb3NpdGlvbiBvZiBjaGlsZHJlblxuXG4gICAgICB0b05vZGUgPSB0b0VsU3RhdGVzW2Zyb21Ob2RlLmlkXTtcbiAgICAgIHRvTm9kZSAmJiBfZml0KGZyb21Ob2RlLCB0b05vZGUsIHNjYWxlLCB0cnVlLCAwLCBmcm9tTm9kZSk7XG4gICAgICBmcm9tTm9kZS5tYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZnJvbU5vZGUuZWxlbWVudCwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICAgIHZhciBlcyA9IHRoaXMuZ2V0RWxlbWVudFN0YXRlKGVsZW1lbnQpIHx8IF9lbXB0eU9iajtcblxuICAgIHJldHVybiAocHJvcGVydHkgaW4gZXMgPyBlcyA6IGVzLnByb3BzIHx8IF9lbXB0eU9iailbcHJvcGVydHldO1xuICB9O1xuXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQoc3RhdGUpIHtcbiAgICB2YXIgaSA9IHN0YXRlLnRhcmdldHMubGVuZ3RoLFxuICAgICAgICBsb29rdXAgPSB0aGlzLmlkTG9va3VwLFxuICAgICAgICBhbHQgPSB0aGlzLmFsdCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGVzLFxuICAgICAgICBlczI7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBlcyA9IHN0YXRlLmVsZW1lbnRTdGF0ZXNbaV07XG4gICAgICBlczIgPSBsb29rdXBbZXMuaWRdO1xuXG4gICAgICBpZiAoZXMyICYmIChlcy5lbGVtZW50ID09PSBlczIuZWxlbWVudCB8fCBhbHRbZXMuaWRdICYmIGFsdFtlcy5pZF0uZWxlbWVudCA9PT0gZXMuZWxlbWVudCkpIHtcbiAgICAgICAgLy8gaWYgdGhlIGZsaXAgaWQgaXMgYWxyZWFkeSBpbiB0aGlzIEZsaXBTdGF0ZSwgcmVwbGFjZSBpdCFcbiAgICAgICAgaW5kZXggPSB0aGlzLmVsZW1lbnRTdGF0ZXMuaW5kZXhPZihlcy5lbGVtZW50ID09PSBlczIuZWxlbWVudCA/IGVzMiA6IGFsdFtlcy5pZF0pO1xuICAgICAgICB0aGlzLnRhcmdldHMuc3BsaWNlKGluZGV4LCAxLCBzdGF0ZS50YXJnZXRzW2ldKTtcbiAgICAgICAgdGhpcy5lbGVtZW50U3RhdGVzLnNwbGljZShpbmRleCwgMSwgZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50YXJnZXRzLnB1c2goc3RhdGUudGFyZ2V0c1tpXSk7XG4gICAgICAgIHRoaXMuZWxlbWVudFN0YXRlcy5wdXNoKGVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5pbnRlcnJ1cHRlZCAmJiAodGhpcy5pbnRlcnJ1cHRlZCA9IHRydWUpO1xuICAgIHN0YXRlLnNpbXBsZSB8fCAodGhpcy5zaW1wbGUgPSBmYWxzZSk7XG5cbiAgICBfY3JlYXRlTG9va3VwKHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKHN0YXRlKSB7XG4gICAgdmFyIGwxID0gc3RhdGUuaWRMb29rdXAsXG4gICAgICAgIGwyID0gdGhpcy5pZExvb2t1cCxcbiAgICAgICAgdW5jaGFuZ2VkID0gW10sXG4gICAgICAgIGNoYW5nZWQgPSBbXSxcbiAgICAgICAgZW50ZXIgPSBbXSxcbiAgICAgICAgbGVhdmUgPSBbXSxcbiAgICAgICAgdGFyZ2V0cyA9IFtdLFxuICAgICAgICBhMSA9IHN0YXRlLmFsdCxcbiAgICAgICAgYTIgPSB0aGlzLmFsdCxcbiAgICAgICAgcGxhY2UgPSBmdW5jdGlvbiBwbGFjZShzMSwgczIsIGVsKSB7XG4gICAgICByZXR1cm4gKHMxLmlzVmlzaWJsZSAhPT0gczIuaXNWaXNpYmxlID8gczEuaXNWaXNpYmxlID8gZW50ZXIgOiBsZWF2ZSA6IHMxLmlzVmlzaWJsZSA/IGNoYW5nZWQgOiB1bmNoYW5nZWQpLnB1c2goZWwpICYmIHRhcmdldHMucHVzaChlbCk7XG4gICAgfSxcbiAgICAgICAgcGxhY2VJZkRvZXNOb3RFeGlzdCA9IGZ1bmN0aW9uIHBsYWNlSWZEb2VzTm90RXhpc3QoczEsIHMyLCBlbCkge1xuICAgICAgcmV0dXJuIHRhcmdldHMuaW5kZXhPZihlbCkgPCAwICYmIHBsYWNlKHMxLCBzMiwgZWwpO1xuICAgIH0sXG4gICAgICAgIHMxLFxuICAgICAgICBzMixcbiAgICAgICAgcCxcbiAgICAgICAgZWwsXG4gICAgICAgIHMxQWx0LFxuICAgICAgICBzMkFsdCxcbiAgICAgICAgYzEsXG4gICAgICAgIGMyO1xuXG4gICAgZm9yIChwIGluIGwxKSB7XG4gICAgICBzMUFsdCA9IGExW3BdO1xuICAgICAgczJBbHQgPSBhMltwXTtcbiAgICAgIHMxID0gIXMxQWx0ID8gbDFbcF0gOiBfZ2V0Q2hhbmdpbmdFbFN0YXRlKHN0YXRlLCB0aGlzLCBwKTtcbiAgICAgIGVsID0gczEuZWxlbWVudDtcbiAgICAgIHMyID0gbDJbcF07XG5cbiAgICAgIGlmIChzMkFsdCkge1xuICAgICAgICBjMiA9IHMyLmlzVmlzaWJsZSB8fCAhczJBbHQuaXNWaXNpYmxlICYmIGVsID09PSBzMi5lbGVtZW50ID8gczIgOiBzMkFsdDtcbiAgICAgICAgYzEgPSBzMUFsdCAmJiAhczEuaXNWaXNpYmxlICYmICFzMUFsdC5pc1Zpc2libGUgJiYgYzIuZWxlbWVudCA9PT0gczFBbHQuZWxlbWVudCA/IHMxQWx0IDogczE7IC8vYzEuZWxlbWVudCAhPT0gYzIuZWxlbWVudCAmJiBjMS5lbGVtZW50ID09PSBzMi5lbGVtZW50ICYmIChjMiA9IHMyKTtcblxuICAgICAgICBpZiAoYzEuaXNWaXNpYmxlICYmIGMyLmlzVmlzaWJsZSAmJiBjMS5lbGVtZW50ICE9PSBjMi5lbGVtZW50KSB7XG4gICAgICAgICAgLy8gc3dhcHBpbmcsIHNvIGZvcmNlIGludG8gXCJjaGFuZ2VkXCIgYXJyYXlcbiAgICAgICAgICAoYzEuaXNEaWZmZXJlbnQoYzIpID8gY2hhbmdlZCA6IHVuY2hhbmdlZCkucHVzaChjMS5lbGVtZW50LCBjMi5lbGVtZW50KTtcbiAgICAgICAgICB0YXJnZXRzLnB1c2goYzEuZWxlbWVudCwgYzIuZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGxhY2UoYzEsIGMyLCBjMS5lbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHMxQWx0ICYmIGMxLmVsZW1lbnQgPT09IHMxQWx0LmVsZW1lbnQgJiYgKHMxQWx0ID0gbDFbcF0pO1xuICAgICAgICBwbGFjZUlmRG9lc05vdEV4aXN0KGMxLmVsZW1lbnQgIT09IHMyLmVsZW1lbnQgJiYgczFBbHQgPyBzMUFsdCA6IGMxLCBzMiwgczIuZWxlbWVudCk7XG4gICAgICAgIHBsYWNlSWZEb2VzTm90RXhpc3QoczFBbHQgJiYgczFBbHQuZWxlbWVudCA9PT0gczJBbHQuZWxlbWVudCA/IHMxQWx0IDogYzEsIHMyQWx0LCBzMkFsdC5lbGVtZW50KTtcbiAgICAgICAgczFBbHQgJiYgcGxhY2VJZkRvZXNOb3RFeGlzdChzMUFsdCwgczJBbHQuZWxlbWVudCA9PT0gczFBbHQuZWxlbWVudCA/IHMyQWx0IDogczIsIHMxQWx0LmVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIXMyID8gZW50ZXIucHVzaChlbCkgOiAhczIuaXNEaWZmZXJlbnQoczEpID8gdW5jaGFuZ2VkLnB1c2goZWwpIDogcGxhY2UoczEsIHMyLCBlbCk7XG4gICAgICAgIHMxQWx0ICYmIHBsYWNlSWZEb2VzTm90RXhpc3QoczFBbHQsIHMyLCBzMUFsdC5lbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHAgaW4gbDIpIHtcbiAgICAgIGlmICghbDFbcF0pIHtcbiAgICAgICAgbGVhdmUucHVzaChsMltwXS5lbGVtZW50KTtcbiAgICAgICAgYTJbcF0gJiYgbGVhdmUucHVzaChhMltwXS5lbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2hhbmdlZDogY2hhbmdlZCxcbiAgICAgIHVuY2hhbmdlZDogdW5jaGFuZ2VkLFxuICAgICAgZW50ZXI6IGVudGVyLFxuICAgICAgbGVhdmU6IGxlYXZlXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8ucmVjb3JkSW5saW5lU3R5bGVzID0gZnVuY3Rpb24gcmVjb3JkSW5saW5lU3R5bGVzKCkge1xuICAgIHZhciBwcm9wcyA9IF9tZW1vaXplZFJlbW92ZVByb3BzW3RoaXMucHJvcHNdIHx8IF9yZW1vdmVQcm9wcyxcbiAgICAgICAgaSA9IHRoaXMuZWxlbWVudFN0YXRlcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBfcmVjb3JkSW5saW5lU3R5bGVzKHRoaXMuZWxlbWVudFN0YXRlc1tpXSwgcHJvcHMpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaW50ZXJydXB0ID0gZnVuY3Rpb24gaW50ZXJydXB0KHNvZnQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIC8vIHNvZnQgPSBET04nVCBmb3JjZSBpbi1wcm9ncmVzcyBmbGlwIGFuaW1hdGlvbnMgdG8gY29tcGxldGlvbiAobGlrZSB3aGVuIHJ1bm5pbmcgYSBiYXRjaCwgd2UgY2FuJ3QgaW1tZWRpYXRlbHkga2lsbCBmbGlwcyB3aGVuIGdldHRpbmcgc3RhdGVzIGJlY2F1c2UgaXQgY291bGQgY29udGFtaW5hdGUgcG9zaXRpb25pbmcgYW5kIG90aGVyIC5nZXRTdGF0ZSgpIGNhbGxzIHRoYXQgd2lsbCBydW4gaW4gdGhlIGJhdGNoICh3ZSBraWxsIEFGVEVSIGFsbCB0aGUgLmdldFN0YXRlKCkgY2FsbHMgY29tcGxldGUpLlxuICAgIHZhciB0aW1lbGluZXMgPSBbXTtcbiAgICB0aGlzLnRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIHRsID0gdC5fZmxpcCxcbiAgICAgICAgICBmb3VuZEluUHJvZ3Jlc3MgPSBfa2lsbEZsaXAodGwsIHNvZnQgPyAwIDogMSk7XG5cbiAgICAgIHNvZnQgJiYgZm91bmRJblByb2dyZXNzICYmIHRpbWVsaW5lcy5pbmRleE9mKHRsKSA8IDAgJiYgdGwuYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgICB9KTtcbiAgICAgIGZvdW5kSW5Qcm9ncmVzcyAmJiB0aW1lbGluZXMucHVzaCh0bCk7XG4gICAgfSk7XG4gICAgIXNvZnQgJiYgdGltZWxpbmVzLmxlbmd0aCAmJiB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTsgLy8gaWYgd2UgZm91bmQgYW4gaW4tcHJvZ3Jlc3MgRmxpcCBhbmltYXRpb24sIHdlIG11c3QgcmVjb3JkIGFsbCB0aGUgdmFsdWVzIGluIHRoZWlyIGN1cnJlbnQgc3RhdGUgYXQgdGhhdCBwb2ludCBCVVQgd2Ugc2hvdWxkIHVwZGF0ZSB0aGUgaXNWaXNpYmxlIHZhbHVlIEFGVEVSIHB1c2hpbmcgdGhhdCBmbGlwIHRvIGNvbXBsZXRpb24gc28gdGhhdCBlbGVtZW50cyB0aGF0IGFyZSBlbnRlcmluZyBvciBsZWF2aW5nIHdpbGwgcG9wdWxhdGUgdGhvc2UgQXJyYXlzIHByb3Blcmx5LlxuXG4gICAgdGhpcy5pbnRlcnJ1cHRlZCB8fCAodGhpcy5pbnRlcnJ1cHRlZCA9ICEhdGltZWxpbmVzLmxlbmd0aCk7XG4gIH07XG5cbiAgX3Byb3RvLnVwZGF0ZVZpc2liaWxpdHkgPSBmdW5jdGlvbiB1cGRhdGVWaXNpYmlsaXR5KCkge1xuICAgIHRoaXMuZWxlbWVudFN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChlcykge1xuICAgICAgdmFyIGIgPSBlcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgZXMuaXNWaXNpYmxlID0gISEoYi53aWR0aCB8fCBiLmhlaWdodCB8fCBiLnRvcCB8fCBiLmxlZnQpO1xuICAgICAgZXMudW5jYWNoZSA9IDE7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldEVsZW1lbnRTdGF0ZSA9IGZ1bmN0aW9uIGdldEVsZW1lbnRTdGF0ZShlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudFN0YXRlc1t0aGlzLnRhcmdldHMuaW5kZXhPZihfZ2V0RWwoZWxlbWVudCkpXTtcbiAgfTtcblxuICBfcHJvdG8ubWFrZUFic29sdXRlID0gZnVuY3Rpb24gbWFrZUFic29sdXRlKCkge1xuICAgIHJldHVybiBfb3JkZXJCeURPTURlcHRoKHRoaXMuZWxlbWVudFN0YXRlcy5zbGljZSgwKSwgdHJ1ZSwgdHJ1ZSkubWFwKF9tYWtlQWJzb2x1dGUpO1xuICB9O1xuXG4gIHJldHVybiBGbGlwU3RhdGU7XG59KCk7XG5cbnZhciBFbGVtZW50U3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbGVtZW50U3RhdGUoZWxlbWVudCwgcHJvcHMsIHNpbXBsZSkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy51cGRhdGUocHJvcHMsIHNpbXBsZSk7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IEVsZW1lbnRTdGF0ZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5pc0RpZmZlcmVudCA9IGZ1bmN0aW9uIGlzRGlmZmVyZW50KHN0YXRlKSB7XG4gICAgdmFyIGIxID0gdGhpcy5ib3VuZHMsXG4gICAgICAgIGIyID0gc3RhdGUuYm91bmRzO1xuICAgIHJldHVybiBiMS50b3AgIT09IGIyLnRvcCB8fCBiMS5sZWZ0ICE9PSBiMi5sZWZ0IHx8IGIxLndpZHRoICE9PSBiMi53aWR0aCB8fCBiMS5oZWlnaHQgIT09IGIyLmhlaWdodCB8fCAhdGhpcy5tYXRyaXguZXF1YWxzKHN0YXRlLm1hdHJpeCkgfHwgdGhpcy5vcGFjaXR5ICE9PSBzdGF0ZS5vcGFjaXR5IHx8IHRoaXMucHJvcHMgJiYgc3RhdGUucHJvcHMgJiYgSlNPTi5zdHJpbmdpZnkodGhpcy5wcm9wcykgIT09IEpTT04uc3RyaW5naWZ5KHN0YXRlLnByb3BzKTtcbiAgfTtcblxuICBfcHJvdG8yLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShwcm9wcywgc2ltcGxlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBlbGVtZW50ID0gc2VsZi5lbGVtZW50LFxuICAgICAgICBnZXRQcm9wID0gZ3NhcC5nZXRQcm9wZXJ0eShlbGVtZW50KSxcbiAgICAgICAgY2FjaGUgPSBnc2FwLmNvcmUuZ2V0Q2FjaGUoZWxlbWVudCksXG4gICAgICAgIGJvdW5kcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGJib3ggPSBlbGVtZW50LmdldEJCb3ggJiYgdHlwZW9mIGVsZW1lbnQuZ2V0QkJveCA9PT0gXCJmdW5jdGlvblwiICYmIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJzdmdcIiAmJiBlbGVtZW50LmdldEJCb3goKSxcbiAgICAgICAgbSA9IHNpbXBsZSA/IG5ldyBNYXRyaXgyRCgxLCAwLCAwLCAxLCBib3VuZHMubGVmdCArIF9nZXREb2NTY3JvbGxMZWZ0KCksIGJvdW5kcy50b3AgKyBfZ2V0RG9jU2Nyb2xsVG9wKCkpIDogZ2V0R2xvYmFsTWF0cml4KGVsZW1lbnQsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgc2VsZi5nZXRQcm9wID0gZ2V0UHJvcDtcbiAgICBzZWxmLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHNlbGYuaWQgPSBfZ2V0SUQoZWxlbWVudCk7XG4gICAgc2VsZi5tYXRyaXggPSBtO1xuICAgIHNlbGYuY2FjaGUgPSBjYWNoZTtcbiAgICBzZWxmLmJvdW5kcyA9IGJvdW5kcztcbiAgICBzZWxmLmlzVmlzaWJsZSA9ICEhKGJvdW5kcy53aWR0aCB8fCBib3VuZHMuaGVpZ2h0IHx8IGJvdW5kcy5sZWZ0IHx8IGJvdW5kcy50b3ApO1xuICAgIHNlbGYuZGlzcGxheSA9IGdldFByb3AoXCJkaXNwbGF5XCIpO1xuICAgIHNlbGYucG9zaXRpb24gPSBnZXRQcm9wKFwicG9zaXRpb25cIik7XG4gICAgc2VsZi5wYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgc2VsZi54ID0gZ2V0UHJvcChcInhcIik7XG4gICAgc2VsZi55ID0gZ2V0UHJvcChcInlcIik7XG4gICAgc2VsZi5zY2FsZVggPSBjYWNoZS5zY2FsZVg7XG4gICAgc2VsZi5zY2FsZVkgPSBjYWNoZS5zY2FsZVk7XG4gICAgc2VsZi5yb3RhdGlvbiA9IGdldFByb3AoXCJyb3RhdGlvblwiKTtcbiAgICBzZWxmLnNrZXdYID0gZ2V0UHJvcChcInNrZXdYXCIpO1xuICAgIHNlbGYub3BhY2l0eSA9IGdldFByb3AoXCJvcGFjaXR5XCIpO1xuICAgIHNlbGYud2lkdGggPSBiYm94ID8gYmJveC53aWR0aCA6IF9jbG9zZXN0VGVudGgoZ2V0UHJvcChcIndpZHRoXCIsIFwicHhcIiksIDAuMDQpOyAvLyByb3VuZCB1cCB0byB0aGUgY2xvc2VzdCAwLjEgc28gdGhhdCB0ZXh0IGRvZXNuJ3Qgd3JhcC5cblxuICAgIHNlbGYuaGVpZ2h0ID0gYmJveCA/IGJib3guaGVpZ2h0IDogX2Nsb3Nlc3RUZW50aChnZXRQcm9wKFwiaGVpZ2h0XCIsIFwicHhcIiksIDAuMDQpO1xuICAgIHByb3BzICYmIF9yZWNvcmRQcm9wcyhzZWxmLCBfbWVtb2l6ZWRQcm9wc1twcm9wc10gfHwgX21lbW9pemVQcm9wcyhwcm9wcykpO1xuICAgIHNlbGYuY3RtID0gZWxlbWVudC5nZXRDVE0gJiYgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiICYmIF9nZXRDVE0oZWxlbWVudCkuaW52ZXJzZSgpO1xuICAgIHNlbGYuc2ltcGxlID0gc2ltcGxlIHx8IF9yb3VuZChtLmEpID09PSAxICYmICFfcm91bmQobS5iKSAmJiAhX3JvdW5kKG0uYykgJiYgX3JvdW5kKG0uZCkgPT09IDE7IC8vIGFsbG93cyB1cyB0byBzcGVlZCB0aHJvdWdoIHNvbWUgb3RoZXIgdGFza3MgaWYgaXQncyBub3Qgc2NhbGUvcm90YXRlZFxuXG4gICAgc2VsZi51bmNhY2hlID0gMDtcbiAgfTtcblxuICByZXR1cm4gRWxlbWVudFN0YXRlO1xufSgpO1xuXG52YXIgRmxpcEFjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZsaXBBY3Rpb24odmFycywgYmF0Y2gpIHtcbiAgICB0aGlzLnZhcnMgPSB2YXJzO1xuICAgIHRoaXMuYmF0Y2ggPSBiYXRjaDtcbiAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgIHRoaXMudGltZWxpbmUgPSBiYXRjaC50aW1lbGluZTtcbiAgfVxuXG4gIHZhciBfcHJvdG8zID0gRmxpcEFjdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMy5nZXRTdGF0ZUJ5SWQgPSBmdW5jdGlvbiBnZXRTdGF0ZUJ5SWQoaWQpIHtcbiAgICB2YXIgaSA9IHRoaXMuc3RhdGVzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlc1tpXS5pZExvb2t1cFtpZF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8zLmtpbGwgPSBmdW5jdGlvbiBraWxsKCkge1xuICAgIHRoaXMuYmF0Y2gucmVtb3ZlKHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBGbGlwQWN0aW9uO1xufSgpO1xuXG52YXIgRmxpcEJhdGNoID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmxpcEJhdGNoKGlkKSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgIHRoaXMuX2tpbGwgPSBbXTtcbiAgICB0aGlzLl9maW5hbCA9IFtdO1xuICAgIHRoaXMuX2FicyA9IFtdO1xuICAgIHRoaXMuX3J1biA9IFtdO1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIHRoaXMuc3RhdGUgPSBuZXcgRmxpcFN0YXRlKCk7XG4gICAgdGhpcy50aW1lbGluZSA9IGdzYXAudGltZWxpbmUoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG80ID0gRmxpcEJhdGNoLnByb3RvdHlwZTtcblxuICBfcHJvdG80LmFkZCA9IGZ1bmN0aW9uIGFkZChjb25maWcpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5hY3Rpb25zLmZpbHRlcihmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICByZXR1cm4gYWN0aW9uLnZhcnMgPT09IGNvbmZpZztcbiAgICB9KTtcblxuICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IG5ldyBGbGlwQWN0aW9uKHR5cGVvZiBjb25maWcgPT09IFwiZnVuY3Rpb25cIiA/IHtcbiAgICAgIGFuaW1hdGU6IGNvbmZpZ1xuICAgIH0gOiBjb25maWcsIHRoaXMpO1xuICAgIHRoaXMuYWN0aW9ucy5wdXNoKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG80LnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShhY3Rpb24pIHtcbiAgICB2YXIgaSA9IHRoaXMuYWN0aW9ucy5pbmRleE9mKGFjdGlvbik7XG4gICAgaSA+PSAwICYmIHRoaXMuYWN0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvNC5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlKG1lcmdlKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgcHJldkJhdGNoID0gX2JhdGNoLFxuICAgICAgICBwcmV2QWN0aW9uID0gX2JhdGNoQWN0aW9uO1xuICAgIF9iYXRjaCA9IHRoaXM7XG4gICAgdGhpcy5zdGF0ZS5jbGVhcigpO1xuICAgIHRoaXMuX2tpbGwubGVuZ3RoID0gMDtcbiAgICB0aGlzLmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBpZiAoYWN0aW9uLnZhcnMuZ2V0U3RhdGUpIHtcbiAgICAgICAgYWN0aW9uLnN0YXRlcy5sZW5ndGggPSAwO1xuICAgICAgICBfYmF0Y2hBY3Rpb24gPSBhY3Rpb247XG4gICAgICAgIGFjdGlvbi5zdGF0ZSA9IGFjdGlvbi52YXJzLmdldFN0YXRlKGFjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIG1lcmdlICYmIGFjdGlvbi5zdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gX3RoaXMzLnN0YXRlLmFkZChzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9iYXRjaEFjdGlvbiA9IHByZXZBY3Rpb247XG4gICAgX2JhdGNoID0gcHJldkJhdGNoO1xuICAgIHRoaXMua2lsbENvbmZsaWN0cygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzQuYW5pbWF0ZSA9IGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgcHJldkJhdGNoID0gX2JhdGNoLFxuICAgICAgICB0bCA9IHRoaXMudGltZWxpbmUsXG4gICAgICAgIGkgPSB0aGlzLmFjdGlvbnMubGVuZ3RoLFxuICAgICAgICBmaW5hbFN0YXRlcyxcbiAgICAgICAgZW5kVGltZTtcbiAgICBfYmF0Y2ggPSB0aGlzO1xuICAgIHRsLmNsZWFyKCk7XG4gICAgdGhpcy5fYWJzLmxlbmd0aCA9IHRoaXMuX2ZpbmFsLmxlbmd0aCA9IHRoaXMuX3J1bi5sZW5ndGggPSAwO1xuICAgIHRoaXMuYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICBhLnZhcnMuYW5pbWF0ZSAmJiBhLnZhcnMuYW5pbWF0ZShhKTtcbiAgICAgIHZhciBvbkVudGVyID0gYS52YXJzLm9uRW50ZXIsXG4gICAgICAgICAgb25MZWF2ZSA9IGEudmFycy5vbkxlYXZlLFxuICAgICAgICAgIHRhcmdldHMgPSBhLnRhcmdldHMsXG4gICAgICAgICAgcyxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGlmICh0YXJnZXRzICYmIHRhcmdldHMubGVuZ3RoICYmIChvbkVudGVyIHx8IG9uTGVhdmUpKSB7XG4gICAgICAgIHMgPSBuZXcgRmxpcFN0YXRlKCk7XG4gICAgICAgIGEuc3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHMuYWRkKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdCA9IHMuY29tcGFyZShGbGlwLmdldFN0YXRlKHRhcmdldHMpKTtcbiAgICAgICAgcmVzdWx0LmVudGVyLmxlbmd0aCAmJiBvbkVudGVyICYmIG9uRW50ZXIocmVzdWx0LmVudGVyKTtcbiAgICAgICAgcmVzdWx0LmxlYXZlLmxlbmd0aCAmJiBvbkxlYXZlICYmIG9uTGVhdmUocmVzdWx0LmxlYXZlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9tYWtlQ29tcHNBYnNvbHV0ZSh0aGlzLl9hYnMpO1xuXG4gICAgdGhpcy5fcnVuLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJldHVybiBmKCk7XG4gICAgfSk7XG5cbiAgICBlbmRUaW1lID0gdGwuZHVyYXRpb24oKTtcbiAgICBmaW5hbFN0YXRlcyA9IHRoaXMuX2ZpbmFsLnNsaWNlKDApO1xuICAgIHRsLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZW5kVGltZSA8PSB0bC50aW1lKCkpIHtcbiAgICAgICAgLy8gb25seSBjYWxsIGlmIG1vdmluZyBmb3J3YXJkIGluIHRoZSB0aW1lbGluZSAoaW4gY2FzZSBpdCdzIG5lc3RlZCBpbiBhIHRpbWVsaW5lIHRoYXQgZ2V0cyByZXZlcnNlZClcbiAgICAgICAgZmluYWxTdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9mb3JFYWNoQmF0Y2goX3RoaXM0LCBcIm9uQ29tcGxldGVcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2JhdGNoID0gcHJldkJhdGNoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5hY3Rpb25zW2ldLnZhcnMub25jZSAmJiB0aGlzLmFjdGlvbnNbaV0ua2lsbCgpO1xuICAgIH1cblxuICAgIF9mb3JFYWNoQmF0Y2godGhpcywgXCJvblN0YXJ0XCIpO1xuXG4gICAgdGwucmVzdGFydCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzQubG9hZFN0YXRlID0gZnVuY3Rpb24gbG9hZFN0YXRlKGRvbmUpIHtcbiAgICBkb25lIHx8IChkb25lID0gZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIHRoaXMuYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy52YXJzLmxvYWRTdGF0ZSkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGYgPSBmdW5jdGlvbiBmKHRhcmdldHMpIHtcbiAgICAgICAgICB0YXJnZXRzICYmIChjLnRhcmdldHMgPSB0YXJnZXRzKTtcbiAgICAgICAgICBpID0gcXVldWUuaW5kZXhPZihmKTtcblxuICAgICAgICAgIGlmICh+aSkge1xuICAgICAgICAgICAgcXVldWUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcXVldWUubGVuZ3RoIHx8IGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcXVldWUucHVzaChmKTtcbiAgICAgICAgYy52YXJzLmxvYWRTdGF0ZShmKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBxdWV1ZS5sZW5ndGggfHwgZG9uZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzQuc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZSgpIHtcbiAgICB0aGlzLmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMudGFyZ2V0cyA9IGMudmFycy5zZXRTdGF0ZSAmJiBjLnZhcnMuc2V0U3RhdGUoYyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvNC5raWxsQ29uZmxpY3RzID0gZnVuY3Rpb24ga2lsbENvbmZsaWN0cyhzb2Z0KSB7XG4gICAgdGhpcy5zdGF0ZS5pbnRlcnJ1cHQoc29mdCk7XG5cbiAgICB0aGlzLl9raWxsLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGUuaW50ZXJydXB0KHNvZnQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvNC5ydW4gPSBmdW5jdGlvbiBydW4oc2tpcEdldFN0YXRlLCBtZXJnZSkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMgIT09IF9iYXRjaCkge1xuICAgICAgc2tpcEdldFN0YXRlIHx8IHRoaXMuZ2V0U3RhdGUobWVyZ2UpO1xuICAgICAgdGhpcy5sb2FkU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIV90aGlzNS5fa2lsbGVkKSB7XG4gICAgICAgICAgX3RoaXM1LnNldFN0YXRlKCk7XG5cbiAgICAgICAgICBfdGhpczUuYW5pbWF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG80LmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoc3RhdGVPbmx5KSB7XG4gICAgdGhpcy5zdGF0ZS5jbGVhcigpO1xuICAgIHN0YXRlT25seSB8fCAodGhpcy5hY3Rpb25zLmxlbmd0aCA9IDApO1xuICB9O1xuXG4gIF9wcm90bzQuZ2V0U3RhdGVCeUlkID0gZnVuY3Rpb24gZ2V0U3RhdGVCeUlkKGlkKSB7XG4gICAgdmFyIGkgPSB0aGlzLmFjdGlvbnMubGVuZ3RoLFxuICAgICAgICBzO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcyA9IHRoaXMuYWN0aW9uc1tpXS5nZXRTdGF0ZUJ5SWQoaWQpO1xuXG4gICAgICBpZiAocykge1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5pZExvb2t1cFtpZF0gJiYgdGhpcy5zdGF0ZTtcbiAgfTtcblxuICBfcHJvdG80LmtpbGwgPSBmdW5jdGlvbiBraWxsKCkge1xuICAgIHRoaXMuX2tpbGxlZCA9IDE7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIGRlbGV0ZSBfYmF0Y2hMb29rdXBbdGhpcy5pZF07XG4gIH07XG5cbiAgcmV0dXJuIEZsaXBCYXRjaDtcbn0oKTtcblxuZXhwb3J0IHZhciBGbGlwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmxpcCgpIHt9XG5cbiAgRmxpcC5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlKHRhcmdldHMsIHZhcnMpIHtcbiAgICB2YXIgc3RhdGUgPSBfcGFyc2VTdGF0ZSh0YXJnZXRzLCB2YXJzKTtcblxuICAgIF9iYXRjaEFjdGlvbiAmJiBfYmF0Y2hBY3Rpb24uc3RhdGVzLnB1c2goc3RhdGUpO1xuICAgIHZhcnMgJiYgdmFycy5iYXRjaCAmJiBGbGlwLmJhdGNoKHZhcnMuYmF0Y2gpLnN0YXRlLmFkZChzdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9O1xuXG4gIEZsaXAuZnJvbSA9IGZ1bmN0aW9uIGZyb20oc3RhdGUsIHZhcnMpIHtcbiAgICB2YXJzID0gdmFycyB8fCB7fTtcbiAgICBcImNsZWFyUHJvcHNcIiBpbiB2YXJzIHx8ICh2YXJzLmNsZWFyUHJvcHMgPSB0cnVlKTtcbiAgICByZXR1cm4gX2Zyb21UbyhzdGF0ZSwgX3BhcnNlU3RhdGUodmFycy50YXJnZXRzIHx8IHN0YXRlLnRhcmdldHMsIHtcbiAgICAgIHByb3BzOiB2YXJzLnByb3BzIHx8IHN0YXRlLnByb3BzLFxuICAgICAgc2ltcGxlOiB2YXJzLnNpbXBsZSxcbiAgICAgIGtpbGw6ICEhdmFycy5raWxsXG4gICAgfSksIHZhcnMsIC0xKTtcbiAgfTtcblxuICBGbGlwLnRvID0gZnVuY3Rpb24gdG8oc3RhdGUsIHZhcnMpIHtcbiAgICByZXR1cm4gX2Zyb21UbyhzdGF0ZSwgX3BhcnNlU3RhdGUodmFycy50YXJnZXRzIHx8IHN0YXRlLnRhcmdldHMsIHtcbiAgICAgIHByb3BzOiB2YXJzLnByb3BzIHx8IHN0YXRlLnByb3BzLFxuICAgICAgc2ltcGxlOiB2YXJzLnNpbXBsZSxcbiAgICAgIGtpbGw6ICEhdmFycy5raWxsXG4gICAgfSksIHZhcnMsIDEpO1xuICB9O1xuXG4gIEZsaXAuZnJvbVRvID0gZnVuY3Rpb24gZnJvbVRvKGZyb21TdGF0ZSwgdG9TdGF0ZSwgdmFycykge1xuICAgIHJldHVybiBfZnJvbVRvKGZyb21TdGF0ZSwgdG9TdGF0ZSwgdmFycyk7XG4gIH07XG5cbiAgRmxpcC5maXQgPSBmdW5jdGlvbiBmaXQoZnJvbUVsLCB0b0VsLCB2YXJzKSB7XG4gICAgdmFyIHYgPSB2YXJzID8gX2NvcHkodmFycywgX2ZpdFJlc2VydmVkKSA6IHt9LFxuICAgICAgICBfcmVmID0gdmFycyB8fCB2LFxuICAgICAgICBhYnNvbHV0ZSA9IF9yZWYuYWJzb2x1dGUsXG4gICAgICAgIHNjYWxlID0gX3JlZi5zY2FsZSxcbiAgICAgICAgZ2V0VmFycyA9IF9yZWYuZ2V0VmFycyxcbiAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICBydW5CYWNrd2FyZHMgPSBfcmVmLnJ1bkJhY2t3YXJkcyxcbiAgICAgICAgb25Db21wbGV0ZSA9IF9yZWYub25Db21wbGV0ZSxcbiAgICAgICAgc2ltcGxlID0gX3JlZi5zaW1wbGUsXG4gICAgICAgIGZpdENoaWxkID0gdmFycyAmJiB2YXJzLmZpdENoaWxkICYmIF9nZXRFbCh2YXJzLmZpdENoaWxkKSxcbiAgICAgICAgYmVmb3JlID0gX3BhcnNlRWxlbWVudFN0YXRlKHRvRWwsIHByb3BzLCBzaW1wbGUsIGZyb21FbCksXG4gICAgICAgIGFmdGVyID0gX3BhcnNlRWxlbWVudFN0YXRlKGZyb21FbCwgMCwgc2ltcGxlLCBiZWZvcmUpLFxuICAgICAgICBpbmxpbmVQcm9wcyA9IHByb3BzID8gX21lbW9pemVkUmVtb3ZlUHJvcHNbcHJvcHNdIDogX3JlbW92ZVByb3BzLFxuICAgICAgICBjdHggPSBnc2FwLmNvbnRleHQoKTtcblxuICAgIHByb3BzICYmIF9hcHBseVByb3BzKHYsIGJlZm9yZS5wcm9wcyk7XG5cbiAgICBfcmVjb3JkSW5saW5lU3R5bGVzKGFmdGVyLCBpbmxpbmVQcm9wcyk7XG5cbiAgICBpZiAocnVuQmFja3dhcmRzKSB7XG4gICAgICBcImltbWVkaWF0ZVJlbmRlclwiIGluIHYgfHwgKHYuaW1tZWRpYXRlUmVuZGVyID0gdHJ1ZSk7XG5cbiAgICAgIHYub25Db21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX2FwcGx5SW5saW5lU3R5bGVzKGFmdGVyKTtcblxuICAgICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgYWJzb2x1dGUgJiYgX21ha2VBYnNvbHV0ZShhZnRlciwgYmVmb3JlKTtcbiAgICB2ID0gX2ZpdChhZnRlciwgYmVmb3JlLCBzY2FsZSB8fCBmaXRDaGlsZCwgcHJvcHMsIGZpdENoaWxkLCB2LmR1cmF0aW9uIHx8IGdldFZhcnMgPyB2IDogMCk7XG4gICAgY3R4ICYmICFnZXRWYXJzICYmIGN0eC5hZGQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9hcHBseUlubGluZVN0eWxlcyhhZnRlcik7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBnZXRWYXJzID8gdiA6IHYuZHVyYXRpb24gPyBnc2FwLnRvKGFmdGVyLmVsZW1lbnQsIHYpIDogbnVsbDtcbiAgfTtcblxuICBGbGlwLm1ha2VBYnNvbHV0ZSA9IGZ1bmN0aW9uIG1ha2VBYnNvbHV0ZSh0YXJnZXRzT3JTdGF0ZXMsIHZhcnMpIHtcbiAgICByZXR1cm4gKHRhcmdldHNPclN0YXRlcyBpbnN0YW5jZW9mIEZsaXBTdGF0ZSA/IHRhcmdldHNPclN0YXRlcyA6IG5ldyBGbGlwU3RhdGUodGFyZ2V0c09yU3RhdGVzLCB2YXJzKSkubWFrZUFic29sdXRlKCk7XG4gIH07XG5cbiAgRmxpcC5iYXRjaCA9IGZ1bmN0aW9uIGJhdGNoKGlkKSB7XG4gICAgaWQgfHwgKGlkID0gXCJkZWZhdWx0XCIpO1xuICAgIHJldHVybiBfYmF0Y2hMb29rdXBbaWRdIHx8IChfYmF0Y2hMb29rdXBbaWRdID0gbmV3IEZsaXBCYXRjaChpZCkpO1xuICB9O1xuXG4gIEZsaXAua2lsbEZsaXBzT2YgPSBmdW5jdGlvbiBraWxsRmxpcHNPZih0YXJnZXRzLCBjb21wbGV0ZSkge1xuICAgICh0YXJnZXRzIGluc3RhbmNlb2YgRmxpcFN0YXRlID8gdGFyZ2V0cy50YXJnZXRzIDogX3RvQXJyYXkodGFyZ2V0cykpLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0ICYmIF9raWxsRmxpcCh0Ll9mbGlwLCBjb21wbGV0ZSAhPT0gZmFsc2UgPyAxIDogMik7XG4gICAgfSk7XG4gIH07XG5cbiAgRmxpcC5pc0ZsaXBwaW5nID0gZnVuY3Rpb24gaXNGbGlwcGluZyh0YXJnZXQpIHtcbiAgICB2YXIgZiA9IEZsaXAuZ2V0QnlUYXJnZXQodGFyZ2V0KTtcbiAgICByZXR1cm4gISFmICYmIGYuaXNBY3RpdmUoKTtcbiAgfTtcblxuICBGbGlwLmdldEJ5VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0QnlUYXJnZXQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIChfZ2V0RWwodGFyZ2V0KSB8fCBfZW1wdHlPYmopLl9mbGlwO1xuICB9O1xuXG4gIEZsaXAuZ2V0RWxlbWVudFN0YXRlID0gZnVuY3Rpb24gZ2V0RWxlbWVudFN0YXRlKHRhcmdldCwgcHJvcHMpIHtcbiAgICByZXR1cm4gbmV3IEVsZW1lbnRTdGF0ZShfZ2V0RWwodGFyZ2V0KSwgcHJvcHMpO1xuICB9O1xuXG4gIEZsaXAuY29udmVydENvb3JkaW5hdGVzID0gZnVuY3Rpb24gY29udmVydENvb3JkaW5hdGVzKGZyb21FbGVtZW50LCB0b0VsZW1lbnQsIHBvaW50KSB7XG4gICAgdmFyIG0gPSBnZXRHbG9iYWxNYXRyaXgodG9FbGVtZW50LCB0cnVlLCB0cnVlKS5tdWx0aXBseShnZXRHbG9iYWxNYXRyaXgoZnJvbUVsZW1lbnQpKTtcbiAgICByZXR1cm4gcG9pbnQgPyBtLmFwcGx5KHBvaW50KSA6IG07XG4gIH07XG5cbiAgRmxpcC5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvcmUpIHtcbiAgICBfYm9keSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5ib2R5O1xuXG4gICAgaWYgKF9ib2R5KSB7XG4gICAgICBnc2FwID0gY29yZTtcblxuICAgICAgX3NldERvYyhfYm9keSk7XG5cbiAgICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgICAgX2dldFN0eWxlU2F2ZXIgPSBnc2FwLmNvcmUuZ2V0U3R5bGVTYXZlcjtcbiAgICAgIHZhciBzbmFwID0gZ3NhcC51dGlscy5zbmFwKDAuMSk7XG5cbiAgICAgIF9jbG9zZXN0VGVudGggPSBmdW5jdGlvbiBfY2xvc2VzdFRlbnRoKHZhbHVlLCBhZGQpIHtcbiAgICAgICAgcmV0dXJuIHNuYXAocGFyc2VGbG9hdCh2YWx1ZSkgKyBhZGQpO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEZsaXA7XG59KCk7XG5GbGlwLnZlcnNpb24gPSBcIjMuMTIuNVwiOyAvLyBmdW5jdGlvbiB3aGVuSW1hZ2VzTG9hZChlbCwgZnVuYykge1xuLy8gXHRsZXQgcGVuZGluZyA9IFtdLFxuLy8gXHRcdG9uTG9hZCA9IGUgPT4ge1xuLy8gXHRcdFx0cGVuZGluZy5zcGxpY2UocGVuZGluZy5pbmRleE9mKGUudGFyZ2V0KSwgMSk7XG4vLyBcdFx0XHRlLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBvbkxvYWQpO1xuLy8gXHRcdFx0cGVuZGluZy5sZW5ndGggfHwgZnVuYygpO1xuLy8gXHRcdH07XG4vLyBcdGdzYXAudXRpbHMudG9BcnJheShlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW1nXCIgPyBlbCA6IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbWdcIikpLmZvckVhY2goaW1nID0+IGltZy5jb21wbGV0ZSB8fCBpbWcuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgb25Mb2FkKSB8fCBwZW5kaW5nLnB1c2goaW1nKSk7XG4vLyBcdHBlbmRpbmcubGVuZ3RoIHx8IGZ1bmMoKTtcbi8vIH1cblxudHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZ3NhcCAmJiB3aW5kb3cuZ3NhcC5yZWdpc3RlclBsdWdpbihGbGlwKTtcbmV4cG9ydCB7IEZsaXAgYXMgZGVmYXVsdCB9OyJdLCJuYW1lcyI6WyJnZXRHbG9iYWxNYXRyaXgiLCJfZ2V0RG9jU2Nyb2xsVG9wIiwiX2dldERvY1Njcm9sbExlZnQiLCJNYXRyaXgyRCIsIl9zZXREb2MiLCJfZ2V0Q1RNIiwiX2lkIiwiX3RvQXJyYXkiLCJnc2FwIiwiX2JhdGNoIiwiX2JhdGNoQWN0aW9uIiwiX2JvZHkiLCJfY2xvc2VzdFRlbnRoIiwiX2dldFN0eWxlU2F2ZXIiLCJfZm9yRWFjaEJhdGNoIiwiYmF0Y2giLCJuYW1lIiwiYWN0aW9ucyIsImZvckVhY2giLCJhIiwidmFycyIsIl9iYXRjaExvb2t1cCIsIl9SQUQyREVHIiwiTWF0aCIsIlBJIiwiX0RFRzJSQUQiLCJfZW1wdHlPYmoiLCJfZGFzaGVkTmFtZUxvb2t1cCIsIl9tZW1vaXplZFJlbW92ZVByb3BzIiwiX2xpc3RUb0FycmF5IiwibGlzdCIsInNwbGl0Iiwiam9pbiIsIl9jYWxsYmFja3MiLCJfcmVtb3ZlUHJvcHMiLCJfZ2V0RWwiLCJ0YXJnZXQiLCJjb25zb2xlIiwid2FybiIsIl9yb3VuZCIsInZhbHVlIiwicm91bmQiLCJfdG9nZ2xlQ2xhc3MiLCJ0YXJnZXRzIiwiY2xhc3NOYW1lIiwiYWN0aW9uIiwiZWwiLCJjbGFzc0xpc3QiLCJfcmVzZXJ2ZWQiLCJ6SW5kZXgiLCJraWxsIiwic2ltcGxlIiwic3BpbiIsImNsZWFyUHJvcHMiLCJ0b2dnbGVDbGFzcyIsIm9uQ29tcGxldGUiLCJvblVwZGF0ZSIsIm9uSW50ZXJydXB0Iiwib25TdGFydCIsImRlbGF5IiwicmVwZWF0IiwicmVwZWF0RGVsYXkiLCJ5b3lvIiwic2NhbGUiLCJmYWRlIiwiYWJzb2x1dGUiLCJwcm9wcyIsIm9uRW50ZXIiLCJvbkxlYXZlIiwiY3VzdG9tIiwicGF1c2VkIiwibmVzdGVkIiwicHJ1bmUiLCJhYnNvbHV0ZU9uTGVhdmUiLCJfZml0UmVzZXJ2ZWQiLCJmaXRDaGlsZCIsImdldFZhcnMiLCJfY2FtZWxUb0Rhc2hlZCIsInAiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJfY29weSIsIm9iaiIsImV4Y2x1ZGUiLCJyZXN1bHQiLCJfbWVtb2l6ZWRQcm9wcyIsIl9tZW1vaXplUHJvcHMiLCJjb25jYXQiLCJfZ2V0SW52ZXJzZUdsb2JhbE1hdHJpeCIsImNhY2hlIiwiX2dzYXAiLCJjb3JlIiwiZ2V0Q2FjaGUiLCJnbUNhY2hlIiwidGlja2VyIiwiZnJhbWUiLCJnTWF0cml4IiwiX2dldERPTURlcHRoIiwiaW52ZXJ0IiwibGV2ZWwiLCJwYXJlbnQiLCJwYXJlbnROb2RlIiwiaW5jIiwicG93IiwibCIsInByZXZpb3VzU2libGluZyIsIl9vcmRlckJ5RE9NRGVwdGgiLCJjb21wcyIsImlzRWxTdGF0ZXMiLCJjb21wIiwiZCIsImVsZW1lbnQiLCJ0Iiwic29ydCIsImMxIiwiYzIiLCJfcmVjb3JkSW5saW5lU3R5bGVzIiwiZWxTdGF0ZSIsInN0eWxlIiwiY3NzIiwiaSIsImxlbmd0aCIsInYiLCJnZXRQcm9wZXJ0eVZhbHVlIiwicHVzaCIsIl9hcHBseUlubGluZVN0eWxlcyIsInN0YXRlIiwidW5jYWNoZSIsInJlbW92ZVByb3BlcnR5IiwiaW5kZXhPZiIsInRyYW5zbGF0ZSIsIl9zZXRGaW5hbFN0YXRlcyIsIm9ubHlUcmFuc2Zvcm1zIiwiYyIsImZpbmFsU3RhdGVzIiwiX2Fic29sdXRlUHJvcHMiLCJfbWFrZUFic29sdXRlIiwiZmFsbGJhY2tOb2RlIiwiaWdub3JlQmF0Y2giLCJ3aWR0aCIsImhlaWdodCIsImdldFByb3AiLCJkaXNwbGF5SXNOb25lIiwiY3MiLCJfYWJzIiwiYiIsInNkIiwiX2ZpbmFsIiwiaXNWaXNpYmxlIiwiZGlzcGxheSIsIm1hdHJpeCIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJncmlkQXJlYSIsInRyYW5zaXRpb24iLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJFbGVtZW50U3RhdGUiLCJib3VuZHMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJfZml0IiwieCIsInkiLCJfZmlsdGVyQ29tcHMiLCJmaWx0ZXIiLCJyZW5kZXJUcmFuc2Zvcm0iLCJfbWFrZUNvbXBzQWJzb2x1dGUiLCJfZmluZEVsU3RhdGVJblN0YXRlIiwib3RoZXIiLCJpZExvb2t1cCIsIl9wYXJzZUVsZW1lbnRTdGF0ZSIsImlkIiwiZWxlbWVudFN0YXRlcyIsImVsT3JOb2RlIiwiRmxpcFN0YXRlIiwiX3JlY29yZFByb3BzIiwiZ2V0UHJvcGVydHkiLCJ0cmltIiwicGFyc2VGbG9hdCIsIl9hcHBseVByb3BzIiwiX2dldElEIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiX2VsZW1lbnRzRnJvbUVsZW1lbnRTdGF0ZXMiLCJlbFN0YXRlcyIsIm1hcCIsIl9oYW5kbGVDYWxsYmFjayIsImNhbGxiYWNrIiwidGwiLCJhZGQiLCJmcm9tU3RhdGUiLCJ0b1N0YXRlIiwiYXBwbHlQcm9wcyIsInNjYWxlWCIsInNjYWxlWSIsInJvdGF0aW9uIiwic3R5bGVzIiwiZGltZW5zaW9uU3RhdGUiLCJfdG9TdGF0ZSRtYXRyaXgiLCJlIiwiZiIsImRlZXAiLCJza2V3WCIsImZyb21Qb2ludCIsInRvUG9pbnQiLCJwYXJlbnRNYXRyaXgiLCJiYm94IiwiY2xvbmUiLCJtdWx0aXBseSIsImN0bSIsImF0YW4yIiwic3FydCIsImNvcyIsImdldEJCb3giLCJjZWlsIiwiYXBwbHkiLCJyZXZlcnQiLCJfcGFyc2VTdGF0ZSIsInRhcmdldHNPclN0YXRlIiwiX2dldENoYW5naW5nRWxTdGF0ZSIsInRvMSIsInRvMiIsImFsdCIsImdldEVsZW1lbnRTdGF0ZSIsIl9ib2R5TWV0cmljcyIsIl9ib2R5UHJvcHMiLCJfYm9keUxvY2tlZCIsIl9sb2NrQm9keVNjcm9sbCIsImxvY2siLCJzIiwidyIsImNsaWVudFdpZHRoIiwib3V0ZXJXaWR0aCIsImgiLCJjbGllbnRIZWlnaHQiLCJvdXRlckhlaWdodCIsIm92ZXJmbG93WSIsIm92ZXJmbG93WCIsIl9mcm9tVG8iLCJyZWxhdGl2ZSIsIl92YXJzIiwiX3pJbmRleCIsInN0YWdnZXIiLCJ0d2VlblZhcnMiLCJhbmltYXRpb24iLCJ0aW1lbGluZSIsImRhdGEiLCJyZW1haW5pbmdQcm9wcyIsImVudGVyaW5nIiwibGVhdmluZyIsInN3YXBPdXRUYXJnZXRzIiwic3Bpbk51bSIsInNwaW5GdW5jIiwiaW50ZXJydXB0ZWQiLCJhZGRGdW5jIiwiZW5kVGltZSIsImZyb21Ob2RlIiwidG9Ob2RlIiwicnVuIiwic3dhcCIsIl9mbGlwIiwiaXNEaWZmZXJlbnQiLCJzcGxpY2UiLCJvcGFjaXR5IiwibWF4V2lkdGgiLCJtYXgiLCJtYXhIZWlnaHQiLCJtaW5XaWR0aCIsIm1pbiIsIm1pbkhlaWdodCIsImNsYXNzVGFyZ2V0cyIsInJlbW92ZSIsImF1dG9Sb3VuZCIsIm1vZGlmaWVycyIsImltbWVkaWF0ZVJlbmRlciIsInV0aWxzIiwiZGlzdHJpYnV0ZSIsImR1bW15QXJyYXkiLCJzbGljZSIsImV2ZW50Q2FsbGJhY2siLCJkdXJhdGlvbiIsImNhbGwiLCJfelRpbWUiLCJiYXRjaFRsIiwiZm9yd2FyZCIsInRpbWUiLCJfYmF0Y2gkX2FicyIsIl9ydW4iLCJhbmltIiwiX2tpbGxGbGlwIiwiX2ludGVycnVwdCIsIm9uSW50ZXJydXB0UGFyYW1zIiwiZ2V0Q2hpbGRyZW4iLCJmb3JjZSIsInByb2dyZXNzIiwiX2NyZWF0ZUxvb2t1cCIsImxvb2t1cCIsInRhcmdldHNBcmVFbGVtZW50U3RhdGVzIiwic29mdCIsIl9raWxsIiwidXBkYXRlIiwiX3Byb3RvIiwicHJvdG90eXBlIiwiX3RoaXMiLCJpbnRlcnJ1cHQiLCJyZWNvcmRJbmxpbmVTdHlsZXMiLCJjbGVhciIsImZpdCIsImVsU3RhdGVzSW5PcmRlciIsInRvRWxTdGF0ZXMiLCJwcm9wZXJ0eSIsImVzIiwiaW5kZXgiLCJlczIiLCJjb21wYXJlIiwibDEiLCJsMiIsInVuY2hhbmdlZCIsImNoYW5nZWQiLCJlbnRlciIsImxlYXZlIiwiYTEiLCJhMiIsInBsYWNlIiwiczEiLCJzMiIsInBsYWNlSWZEb2VzTm90RXhpc3QiLCJzMUFsdCIsInMyQWx0IiwiX3RoaXMyIiwidGltZWxpbmVzIiwiZm91bmRJblByb2dyZXNzIiwidXBkYXRlVmlzaWJpbGl0eSIsIm1ha2VBYnNvbHV0ZSIsIl9wcm90bzIiLCJiMSIsImIyIiwiZXF1YWxzIiwiSlNPTiIsInN0cmluZ2lmeSIsInNlbGYiLCJub2RlTmFtZSIsIm0iLCJnZXRDVE0iLCJpbnZlcnNlIiwiRmxpcEFjdGlvbiIsInN0YXRlcyIsIl9wcm90bzMiLCJnZXRTdGF0ZUJ5SWQiLCJGbGlwQmF0Y2giLCJfcHJvdG80IiwiY29uZmlnIiwiYW5pbWF0ZSIsImdldFN0YXRlIiwibWVyZ2UiLCJfdGhpczMiLCJwcmV2QmF0Y2giLCJwcmV2QWN0aW9uIiwia2lsbENvbmZsaWN0cyIsIl90aGlzNCIsIkZsaXAiLCJvbmNlIiwicmVzdGFydCIsImxvYWRTdGF0ZSIsImRvbmUiLCJxdWV1ZSIsInNldFN0YXRlIiwic2tpcEdldFN0YXRlIiwiX3RoaXM1IiwiX2tpbGxlZCIsInN0YXRlT25seSIsImZyb20iLCJ0byIsImZyb21UbyIsImZyb21FbCIsInRvRWwiLCJfcmVmIiwicnVuQmFja3dhcmRzIiwiYmVmb3JlIiwiYWZ0ZXIiLCJpbmxpbmVQcm9wcyIsImN0eCIsImNvbnRleHQiLCJhcmd1bWVudHMiLCJ0YXJnZXRzT3JTdGF0ZXMiLCJraWxsRmxpcHNPZiIsImNvbXBsZXRlIiwiaXNGbGlwcGluZyIsImdldEJ5VGFyZ2V0IiwiaXNBY3RpdmUiLCJjb252ZXJ0Q29vcmRpbmF0ZXMiLCJmcm9tRWxlbWVudCIsInRvRWxlbWVudCIsInBvaW50IiwicmVnaXN0ZXIiLCJkb2N1bWVudCIsImJvZHkiLCJ0b0FycmF5IiwiZ2V0U3R5bGVTYXZlciIsInNuYXAiLCJ2ZXJzaW9uIiwicmVnaXN0ZXJQbHVnaW4iLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Flip.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/MotionPathPlugin.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/MotionPathPlugin.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MotionPathPlugin: function() { return /* binding */ MotionPathPlugin; },\n/* harmony export */   \"default\": function() { return /* binding */ MotionPathPlugin; }\n/* harmony export */ });\n/* harmony import */ var _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/paths.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/paths.js\");\n/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/matrix.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/matrix.js\");\n/*!\n * MotionPathPlugin 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ \n\nvar _xProps = \"x,translateX,left,marginLeft,xPercent\".split(\",\"), _yProps = \"y,translateY,top,marginTop,yPercent\".split(\",\"), _DEG2RAD = Math.PI / 180, gsap, PropTween, _getUnit, _toArray, _getStyleSaver, _reverting, _getGSAP = function _getGSAP() {\n    return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _populateSegmentFromArray = function _populateSegmentFromArray(segment, values, property, mode) {\n    //mode: 0 = x but don't fill y yet, 1 = y, 2 = x and fill y with 0.\n    var l = values.length, si = mode === 2 ? 0 : mode, i = 0, v;\n    for(; i < l; i++){\n        segment[si] = v = parseFloat(values[i][property]);\n        mode === 2 && (segment[si + 1] = 0);\n        si += 2;\n    }\n    return segment;\n}, _getPropNum = function _getPropNum(target, prop, unit) {\n    return parseFloat(target._gsap.get(target, prop, unit || \"px\")) || 0;\n}, _relativize = function _relativize(segment) {\n    var x = segment[0], y = segment[1], i;\n    for(i = 2; i < segment.length; i += 2){\n        x = segment[i] += x;\n        y = segment[i + 1] += y;\n    }\n}, // feed in an array of quadratic bezier points like [{x: 0, y: 0}, ...] and it'll convert it to cubic bezier\n// _quadToCubic = points => {\n// \tlet cubic = [],\n// \t\tl = points.length - 1,\n// \t\ti = 1,\n// \t\ta, b, c;\n// \tfor (; i < l; i+=2) {\n// \t\ta = points[i-1];\n// \t\tb = points[i];\n// \t\tc = points[i+1];\n// \t\tcubic.push(a, {x: (2 * b.x + a.x) / 3, y: (2 * b.y + a.y) / 3}, {x: (2 * b.x + c.x) / 3, y: (2 * b.y + c.y) / 3});\n// \t}\n// \tcubic.push(points[l]);\n// \treturn cubic;\n// },\n_segmentToRawPath = function _segmentToRawPath(plugin, segment, target, x, y, slicer, vars, unitX, unitY) {\n    if (vars.type === \"cubic\") {\n        segment = [\n            segment\n        ];\n    } else {\n        vars.fromCurrent !== false && segment.unshift(_getPropNum(target, x, unitX), y ? _getPropNum(target, y, unitY) : 0);\n        vars.relative && _relativize(segment);\n        var pointFunc = y ? _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment : _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.flatPointsToSegment;\n        segment = [\n            pointFunc(segment, vars.curviness)\n        ];\n    }\n    segment = slicer(_align(segment, target, vars));\n    _addDimensionalPropTween(plugin, target, x, segment, \"x\", unitX);\n    y && _addDimensionalPropTween(plugin, target, y, segment, \"y\", unitY);\n    return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements)(segment, vars.resolution || (vars.curviness === 0 ? 20 : 12)); //when curviness is 0, it creates control points right on top of the anchors which makes it more sensitive to resolution, thus we change the default accordingly.\n}, _emptyFunc = function _emptyFunc(v) {\n    return v;\n}, _numExp = /[-+\\.]*\\d+\\.?(?:e-|e\\+)?\\d*/g, _originToPoint = function _originToPoint(element, origin, parentMatrix) {\n    // origin is an array of normalized values (0-1) in relation to the width/height, so [0.5, 0.5] would be the center. It can also be \"auto\" in which case it will be the top left unless it's a <path>, when it will start at the beginning of the path itself.\n    var m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(element), x = 0, y = 0, svg;\n    if ((element.tagName + \"\").toLowerCase() === \"svg\") {\n        svg = element.viewBox.baseVal;\n        svg.width || (svg = {\n            width: +element.getAttribute(\"width\"),\n            height: +element.getAttribute(\"height\")\n        });\n    } else {\n        svg = origin && element.getBBox && element.getBBox();\n    }\n    if (origin && origin !== \"auto\") {\n        x = origin.push ? origin[0] * (svg ? svg.width : element.offsetWidth || 0) : origin.x;\n        y = origin.push ? origin[1] * (svg ? svg.height : element.offsetHeight || 0) : origin.y;\n    }\n    return parentMatrix.apply(x || y ? m.apply({\n        x: x,\n        y: y\n    }) : {\n        x: m.e,\n        y: m.f\n    });\n}, _getAlignMatrix = function _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin) {\n    var parentMatrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(fromElement.parentNode, true, true), m = parentMatrix.clone().multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(toElement)), fromPoint = _originToPoint(fromElement, fromOrigin, parentMatrix), _originToPoint2 = _originToPoint(toElement, toOrigin, parentMatrix), x = _originToPoint2.x, y = _originToPoint2.y, p;\n    m.e = m.f = 0;\n    if (toOrigin === \"auto\" && toElement.getTotalLength && toElement.tagName.toLowerCase() === \"path\") {\n        p = toElement.getAttribute(\"d\").match(_numExp) || [];\n        p = m.apply({\n            x: +p[0],\n            y: +p[1]\n        });\n        x += p.x;\n        y += p.y;\n    } //if (p || (toElement.getBBox && fromElement.getBBox && toElement.ownerSVGElement === fromElement.ownerSVGElement)) {\n    if (p) {\n        p = m.apply(toElement.getBBox());\n        x -= p.x;\n        y -= p.y;\n    }\n    m.e = x - fromPoint.x;\n    m.f = y - fromPoint.y;\n    return m;\n}, _align = function _align(rawPath, target, _ref) {\n    var align = _ref.align, matrix = _ref.matrix, offsetX = _ref.offsetX, offsetY = _ref.offsetY, alignOrigin = _ref.alignOrigin;\n    var x = rawPath[0][0], y = rawPath[0][1], curX = _getPropNum(target, \"x\"), curY = _getPropNum(target, \"y\"), alignTarget, m, p;\n    if (!rawPath || !rawPath.length) {\n        return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath)(\"M0,0L0,0\");\n    }\n    if (align) {\n        if (align === \"self\" || (alignTarget = _toArray(align)[0] || target) === target) {\n            (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, 1, 0, 0, 1, curX - x, curY - y);\n        } else {\n            if (alignOrigin && alignOrigin[2] !== false) {\n                gsap.set(target, {\n                    transformOrigin: alignOrigin[0] * 100 + \"% \" + alignOrigin[1] * 100 + \"%\"\n                });\n            } else {\n                alignOrigin = [\n                    _getPropNum(target, \"xPercent\") / -100,\n                    _getPropNum(target, \"yPercent\") / -100\n                ];\n            }\n            m = _getAlignMatrix(target, alignTarget, alignOrigin, \"auto\");\n            p = m.apply({\n                x: x,\n                y: y\n            });\n            (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, m.a, m.b, m.c, m.d, curX + m.e - (p.x - m.e), curY + m.f - (p.y - m.f));\n        }\n    }\n    if (matrix) {\n        (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);\n    } else if (offsetX || offsetY) {\n        (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, 1, 0, 0, 1, offsetX || 0, offsetY || 0);\n    }\n    return rawPath;\n}, _addDimensionalPropTween = function _addDimensionalPropTween(plugin, target, property, rawPath, pathProperty, forceUnit) {\n    var cache = target._gsap, harness = cache.harness, alias = harness && harness.aliases && harness.aliases[property], prop = alias && alias.indexOf(\",\") < 0 ? alias : property, pt = plugin._pt = new PropTween(plugin._pt, target, prop, 0, 0, _emptyFunc, 0, cache.set(target, prop, plugin));\n    pt.u = _getUnit(cache.get(target, prop, forceUnit)) || 0;\n    pt.path = rawPath;\n    pt.pp = pathProperty;\n    plugin._props.push(prop);\n}, _sliceModifier = function _sliceModifier(start, end) {\n    return function(rawPath) {\n        return start || end !== 1 ? (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.sliceRawPath)(rawPath, start, end) : rawPath;\n    };\n};\nvar MotionPathPlugin = {\n    version: \"3.12.5\",\n    name: \"motionPath\",\n    register: function register(core, Plugin, propTween) {\n        gsap = core;\n        _getUnit = gsap.utils.getUnit;\n        _toArray = gsap.utils.toArray;\n        _getStyleSaver = gsap.core.getStyleSaver;\n        _reverting = gsap.core.reverting || function() {};\n        PropTween = propTween;\n    },\n    init: function init(target, vars, tween) {\n        if (!gsap) {\n            console.warn(\"Please gsap.registerPlugin(MotionPathPlugin)\");\n            return false;\n        }\n        if (!(typeof vars === \"object\" && !vars.style) || !vars.path) {\n            vars = {\n                path: vars\n            };\n        }\n        var rawPaths = [], _vars = vars, path = _vars.path, autoRotate = _vars.autoRotate, unitX = _vars.unitX, unitY = _vars.unitY, x = _vars.x, y = _vars.y, firstObj = path[0], slicer = _sliceModifier(vars.start, \"end\" in vars ? vars.end : 1), rawPath, p;\n        this.rawPaths = rawPaths;\n        this.target = target;\n        this.tween = tween;\n        this.styles = _getStyleSaver && _getStyleSaver(target, \"transform\");\n        if (this.rotate = autoRotate || autoRotate === 0) {\n            //get the rotational data FIRST so that the setTransform() method is called in the correct order in the render() loop - rotation gets set last.\n            this.rOffset = parseFloat(autoRotate) || 0;\n            this.radians = !!vars.useRadians;\n            this.rProp = vars.rotation || \"rotation\"; // rotation property\n            this.rSet = target._gsap.set(target, this.rProp, this); // rotation setter\n            this.ru = _getUnit(target._gsap.get(target, this.rProp)) || 0; // rotation units\n        }\n        if (Array.isArray(path) && !(\"closed\" in path) && typeof firstObj !== \"number\") {\n            for(p in firstObj){\n                if (!x && ~_xProps.indexOf(p)) {\n                    x = p;\n                } else if (!y && ~_yProps.indexOf(p)) {\n                    y = p;\n                }\n            }\n            if (x && y) {\n                //correlated values\n                rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray(_populateSegmentFromArray([], path, x, 0), path, y, 1), target, x, y, slicer, vars, unitX || _getUnit(path[0][x]), unitY || _getUnit(path[0][y])));\n            } else {\n                x = y = 0;\n            }\n            for(p in firstObj){\n                p !== x && p !== y && rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray([], path, p, 2), target, p, 0, slicer, vars, _getUnit(path[0][p])));\n            }\n        } else {\n            rawPath = slicer(_align((0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath)(vars.path), target, vars));\n            (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements)(rawPath, vars.resolution);\n            rawPaths.push(rawPath);\n            _addDimensionalPropTween(this, target, vars.x || \"x\", rawPath, \"x\", vars.unitX || \"px\");\n            _addDimensionalPropTween(this, target, vars.y || \"y\", rawPath, \"y\", vars.unitY || \"px\");\n        }\n    },\n    render: function render(ratio, data) {\n        var rawPaths = data.rawPaths, i = rawPaths.length, pt = data._pt;\n        if (data.tween._time || !_reverting()) {\n            if (ratio > 1) {\n                ratio = 1;\n            } else if (ratio < 0) {\n                ratio = 0;\n            }\n            while(i--){\n                (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getPositionOnPath)(rawPaths[i], ratio, !i && data.rotate, rawPaths[i]);\n            }\n            while(pt){\n                pt.set(pt.t, pt.p, pt.path[pt.pp] + pt.u, pt.d, ratio);\n                pt = pt._next;\n            }\n            data.rotate && data.rSet(data.target, data.rProp, rawPaths[0].angle * (data.radians ? _DEG2RAD : 1) + data.rOffset + data.ru, data, ratio);\n        } else {\n            data.styles.revert();\n        }\n    },\n    getLength: function getLength(path) {\n        return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements)((0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath)(path)).totalLength;\n    },\n    sliceRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.sliceRawPath,\n    getRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath,\n    pointsToSegment: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment,\n    stringToRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.stringToRawPath,\n    rawPathToString: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.rawPathToString,\n    transformRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath,\n    getGlobalMatrix: _utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix,\n    getPositionOnPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getPositionOnPath,\n    cacheRawPathMeasurements: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements,\n    convertToPath: function convertToPath(targets, swap) {\n        return _toArray(targets).map(function(target) {\n            return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.convertToPath)(target, swap !== false);\n        });\n    },\n    convertCoordinates: function convertCoordinates(fromElement, toElement, point) {\n        var m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(toElement, true, true).multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(fromElement));\n        return point ? m.apply(point) : m;\n    },\n    getAlignMatrix: _getAlignMatrix,\n    getRelativePosition: function getRelativePosition(fromElement, toElement, fromOrigin, toOrigin) {\n        var m = _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin);\n        return {\n            x: m.e,\n            y: m.f\n        };\n    },\n    arrayToRawPath: function arrayToRawPath(value, vars) {\n        vars = vars || {};\n        var segment = _populateSegmentFromArray(_populateSegmentFromArray([], value, vars.x || \"x\", 0), value, vars.y || \"y\", 1);\n        vars.relative && _relativize(segment);\n        return [\n            vars.type === \"cubic\" ? segment : (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment)(segment, vars.curviness)\n        ];\n    }\n};\n_getGSAP() && gsap.registerPlugin(MotionPathPlugin);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9Nb3Rpb25QYXRoUGx1Z2luLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFRQSxHQUVBLGtCQUFrQixHQUNrTjtBQUNoTDtBQUVwRCxJQUFJWSxVQUFVLHdDQUF3Q0MsS0FBSyxDQUFDLE1BQ3hEQyxVQUFVLHNDQUFzQ0QsS0FBSyxDQUFDLE1BQ3RERSxXQUFXQyxLQUFLQyxFQUFFLEdBQUcsS0FDckJDLE1BQ0FDLFdBQ0FDLFVBQ0FDLFVBQ0FDLGdCQUNBQyxZQUNBQyxXQUFXLFNBQVNBO0lBQ3RCLE9BQU9OLFFBQVEsT0FBT08sV0FBVyxlQUFnQlAsQ0FBQUEsT0FBT08sT0FBT1AsSUFBSSxLQUFLQSxLQUFLUSxjQUFjLElBQUlSO0FBQ2pHLEdBQ0lTLDRCQUE0QixTQUFTQSwwQkFBMEJDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLElBQUk7SUFDaEcsbUVBQW1FO0lBQ25FLElBQUlDLElBQUlILE9BQU9JLE1BQU0sRUFDakJDLEtBQUtILFNBQVMsSUFBSSxJQUFJQSxNQUN0QkksSUFBSSxHQUNKQztJQUVKLE1BQU9ELElBQUlILEdBQUdHLElBQUs7UUFDakJQLE9BQU8sQ0FBQ00sR0FBRyxHQUFHRSxJQUFJQyxXQUFXUixNQUFNLENBQUNNLEVBQUUsQ0FBQ0wsU0FBUztRQUNoREMsU0FBUyxLQUFNSCxDQUFBQSxPQUFPLENBQUNNLEtBQUssRUFBRSxHQUFHO1FBQ2pDQSxNQUFNO0lBQ1I7SUFFQSxPQUFPTjtBQUNULEdBQ0lVLGNBQWMsU0FBU0EsWUFBWUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLElBQUk7SUFDdkQsT0FBT0osV0FBV0UsT0FBT0csS0FBSyxDQUFDQyxHQUFHLENBQUNKLFFBQVFDLE1BQU1DLFFBQVEsVUFBVTtBQUNyRSxHQUNJRyxjQUFjLFNBQVNBLFlBQVloQixPQUFPO0lBQzVD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QUNSO0lBQ0Y7SUFDQStGLGdCQUFnQixTQUFTQSxlQUFlQyxLQUFLLEVBQUVqSSxJQUFJO1FBQ2pEQSxPQUFPQSxRQUFRLENBQUM7UUFFaEIsSUFBSXRCLFVBQVVELDBCQUEwQkEsMEJBQTBCLEVBQUUsRUFBRXdKLE9BQU9qSSxLQUFLTCxDQUFDLElBQUksS0FBSyxJQUFJc0ksT0FBT2pJLEtBQUtKLENBQUMsSUFBSSxLQUFLO1FBRXRISSxLQUFLTSxRQUFRLElBQUlaLFlBQVloQjtRQUM3QixPQUFPO1lBQUNzQixLQUFLRyxJQUFJLEtBQUssVUFBVXpCLFVBQVV6QixnRUFBZUEsQ0FBQ3lCLFNBQVNzQixLQUFLUSxTQUFTO1NBQUU7SUFDckY7QUFDRixFQUFFO0FBQ0ZsQyxjQUFjTixLQUFLUSxjQUFjLENBQUN1RztBQUNLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9Nb3Rpb25QYXRoUGx1Z2luLmpzP2I0MWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb3Rpb25QYXRoUGx1Z2luIDMuMTIuNVxuICogaHR0cHM6Ly9nc2FwLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjQsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3NhcC5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR1NBUCBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCB7IGdldFJhd1BhdGgsIGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cywgZ2V0UG9zaXRpb25PblBhdGgsIHBvaW50c1RvU2VnbWVudCwgZmxhdFBvaW50c1RvU2VnbWVudCwgc2xpY2VSYXdQYXRoLCBzdHJpbmdUb1Jhd1BhdGgsIHJhd1BhdGhUb1N0cmluZywgdHJhbnNmb3JtUmF3UGF0aCwgY29udmVydFRvUGF0aCBhcyBfY29udmVydFRvUGF0aCB9IGZyb20gXCIuL3V0aWxzL3BhdGhzLmpzXCI7XG5pbXBvcnQgeyBnZXRHbG9iYWxNYXRyaXggfSBmcm9tIFwiLi91dGlscy9tYXRyaXguanNcIjtcblxudmFyIF94UHJvcHMgPSBcIngsdHJhbnNsYXRlWCxsZWZ0LG1hcmdpbkxlZnQseFBlcmNlbnRcIi5zcGxpdChcIixcIiksXG4gICAgX3lQcm9wcyA9IFwieSx0cmFuc2xhdGVZLHRvcCxtYXJnaW5Ub3AseVBlcmNlbnRcIi5zcGxpdChcIixcIiksXG4gICAgX0RFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLFxuICAgIGdzYXAsXG4gICAgUHJvcFR3ZWVuLFxuICAgIF9nZXRVbml0LFxuICAgIF90b0FycmF5LFxuICAgIF9nZXRTdHlsZVNhdmVyLFxuICAgIF9yZXZlcnRpbmcsXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9wb3B1bGF0ZVNlZ21lbnRGcm9tQXJyYXkgPSBmdW5jdGlvbiBfcG9wdWxhdGVTZWdtZW50RnJvbUFycmF5KHNlZ21lbnQsIHZhbHVlcywgcHJvcGVydHksIG1vZGUpIHtcbiAgLy9tb2RlOiAwID0geCBidXQgZG9uJ3QgZmlsbCB5IHlldCwgMSA9IHksIDIgPSB4IGFuZCBmaWxsIHkgd2l0aCAwLlxuICB2YXIgbCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBzaSA9IG1vZGUgPT09IDIgPyAwIDogbW9kZSxcbiAgICAgIGkgPSAwLFxuICAgICAgdjtcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIHNlZ21lbnRbc2ldID0gdiA9IHBhcnNlRmxvYXQodmFsdWVzW2ldW3Byb3BlcnR5XSk7XG4gICAgbW9kZSA9PT0gMiAmJiAoc2VnbWVudFtzaSArIDFdID0gMCk7XG4gICAgc2kgKz0gMjtcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50O1xufSxcbiAgICBfZ2V0UHJvcE51bSA9IGZ1bmN0aW9uIF9nZXRQcm9wTnVtKHRhcmdldCwgcHJvcCwgdW5pdCkge1xuICByZXR1cm4gcGFyc2VGbG9hdCh0YXJnZXQuX2dzYXAuZ2V0KHRhcmdldCwgcHJvcCwgdW5pdCB8fCBcInB4XCIpKSB8fCAwO1xufSxcbiAgICBfcmVsYXRpdml6ZSA9IGZ1bmN0aW9uIF9yZWxhdGl2aXplKHNlZ21lbnQpIHtcbiAgdmFyIHggPSBzZWdtZW50WzBdLFxuICAgICAgeSA9IHNlZ21lbnRbMV0sXG4gICAgICBpO1xuXG4gIGZvciAoaSA9IDI7IGkgPCBzZWdtZW50Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgeCA9IHNlZ21lbnRbaV0gKz0geDtcbiAgICB5ID0gc2VnbWVudFtpICsgMV0gKz0geTtcbiAgfVxufSxcbiAgICAvLyBmZWVkIGluIGFuIGFycmF5IG9mIHF1YWRyYXRpYyBiZXppZXIgcG9pbnRzIGxpa2UgW3t4OiAwLCB5OiAwfSwgLi4uXSBhbmQgaXQnbGwgY29udmVydCBpdCB0byBjdWJpYyBiZXppZXJcbi8vIF9xdWFkVG9DdWJpYyA9IHBvaW50cyA9PiB7XG4vLyBcdGxldCBjdWJpYyA9IFtdLFxuLy8gXHRcdGwgPSBwb2ludHMubGVuZ3RoIC0gMSxcbi8vIFx0XHRpID0gMSxcbi8vIFx0XHRhLCBiLCBjO1xuLy8gXHRmb3IgKDsgaSA8IGw7IGkrPTIpIHtcbi8vIFx0XHRhID0gcG9pbnRzW2ktMV07XG4vLyBcdFx0YiA9IHBvaW50c1tpXTtcbi8vIFx0XHRjID0gcG9pbnRzW2krMV07XG4vLyBcdFx0Y3ViaWMucHVzaChhLCB7eDogKDIgKiBiLnggKyBhLngpIC8gMywgeTogKDIgKiBiLnkgKyBhLnkpIC8gM30sIHt4OiAoMiAqIGIueCArIGMueCkgLyAzLCB5OiAoMiAqIGIueSArIGMueSkgLyAzfSk7XG4vLyBcdH1cbi8vIFx0Y3ViaWMucHVzaChwb2ludHNbbF0pO1xuLy8gXHRyZXR1cm4gY3ViaWM7XG4vLyB9LFxuX3NlZ21lbnRUb1Jhd1BhdGggPSBmdW5jdGlvbiBfc2VnbWVudFRvUmF3UGF0aChwbHVnaW4sIHNlZ21lbnQsIHRhcmdldCwgeCwgeSwgc2xpY2VyLCB2YXJzLCB1bml0WCwgdW5pdFkpIHtcbiAgaWYgKHZhcnMudHlwZSA9PT0gXCJjdWJpY1wiKSB7XG4gICAgc2VnbWVudCA9IFtzZWdtZW50XTtcbiAgfSBlbHNlIHtcbiAgICB2YXJzLmZyb21DdXJyZW50ICE9PSBmYWxzZSAmJiBzZWdtZW50LnVuc2hpZnQoX2dldFByb3BOdW0odGFyZ2V0LCB4LCB1bml0WCksIHkgPyBfZ2V0UHJvcE51bSh0YXJnZXQsIHksIHVuaXRZKSA6IDApO1xuICAgIHZhcnMucmVsYXRpdmUgJiYgX3JlbGF0aXZpemUoc2VnbWVudCk7XG4gICAgdmFyIHBvaW50RnVuYyA9IHkgPyBwb2ludHNUb1NlZ21lbnQgOiBmbGF0UG9pbnRzVG9TZWdtZW50O1xuICAgIHNlZ21lbnQgPSBbcG9pbnRGdW5jKHNlZ21lbnQsIHZhcnMuY3VydmluZXNzKV07XG4gIH1cblxuICBzZWdtZW50ID0gc2xpY2VyKF9hbGlnbihzZWdtZW50LCB0YXJnZXQsIHZhcnMpKTtcblxuICBfYWRkRGltZW5zaW9uYWxQcm9wVHdlZW4ocGx1Z2luLCB0YXJnZXQsIHgsIHNlZ21lbnQsIFwieFwiLCB1bml0WCk7XG5cbiAgeSAmJiBfYWRkRGltZW5zaW9uYWxQcm9wVHdlZW4ocGx1Z2luLCB0YXJnZXQsIHksIHNlZ21lbnQsIFwieVwiLCB1bml0WSk7XG4gIHJldHVybiBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMoc2VnbWVudCwgdmFycy5yZXNvbHV0aW9uIHx8ICh2YXJzLmN1cnZpbmVzcyA9PT0gMCA/IDIwIDogMTIpKTsgLy93aGVuIGN1cnZpbmVzcyBpcyAwLCBpdCBjcmVhdGVzIGNvbnRyb2wgcG9pbnRzIHJpZ2h0IG9uIHRvcCBvZiB0aGUgYW5jaG9ycyB3aGljaCBtYWtlcyBpdCBtb3JlIHNlbnNpdGl2ZSB0byByZXNvbHV0aW9uLCB0aHVzIHdlIGNoYW5nZSB0aGUgZGVmYXVsdCBhY2NvcmRpbmdseS5cbn0sXG4gICAgX2VtcHR5RnVuYyA9IGZ1bmN0aW9uIF9lbXB0eUZ1bmModikge1xuICByZXR1cm4gdjtcbn0sXG4gICAgX251bUV4cCA9IC9bLStcXC5dKlxcZCtcXC4/KD86ZS18ZVxcKyk/XFxkKi9nLFxuICAgIF9vcmlnaW5Ub1BvaW50ID0gZnVuY3Rpb24gX29yaWdpblRvUG9pbnQoZWxlbWVudCwgb3JpZ2luLCBwYXJlbnRNYXRyaXgpIHtcbiAgLy8gb3JpZ2luIGlzIGFuIGFycmF5IG9mIG5vcm1hbGl6ZWQgdmFsdWVzICgwLTEpIGluIHJlbGF0aW9uIHRvIHRoZSB3aWR0aC9oZWlnaHQsIHNvIFswLjUsIDAuNV0gd291bGQgYmUgdGhlIGNlbnRlci4gSXQgY2FuIGFsc28gYmUgXCJhdXRvXCIgaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGJlIHRoZSB0b3AgbGVmdCB1bmxlc3MgaXQncyBhIDxwYXRoPiwgd2hlbiBpdCB3aWxsIHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHBhdGggaXRzZWxmLlxuICB2YXIgbSA9IGdldEdsb2JhbE1hdHJpeChlbGVtZW50KSxcbiAgICAgIHggPSAwLFxuICAgICAgeSA9IDAsXG4gICAgICBzdmc7XG5cbiAgaWYgKChlbGVtZW50LnRhZ05hbWUgKyBcIlwiKS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiKSB7XG4gICAgc3ZnID0gZWxlbWVudC52aWV3Qm94LmJhc2VWYWw7XG4gICAgc3ZnLndpZHRoIHx8IChzdmcgPSB7XG4gICAgICB3aWR0aDogK2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwid2lkdGhcIiksXG4gICAgICBoZWlnaHQ6ICtlbGVtZW50LmdldEF0dHJpYnV0ZShcImhlaWdodFwiKVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHN2ZyA9IG9yaWdpbiAmJiBlbGVtZW50LmdldEJCb3ggJiYgZWxlbWVudC5nZXRCQm94KCk7XG4gIH1cblxuICBpZiAob3JpZ2luICYmIG9yaWdpbiAhPT0gXCJhdXRvXCIpIHtcbiAgICB4ID0gb3JpZ2luLnB1c2ggPyBvcmlnaW5bMF0gKiAoc3ZnID8gc3ZnLndpZHRoIDogZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAwKSA6IG9yaWdpbi54O1xuICAgIHkgPSBvcmlnaW4ucHVzaCA/IG9yaWdpblsxXSAqIChzdmcgPyBzdmcuaGVpZ2h0IDogZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMCkgOiBvcmlnaW4ueTtcbiAgfVxuXG4gIHJldHVybiBwYXJlbnRNYXRyaXguYXBwbHkoeCB8fCB5ID8gbS5hcHBseSh7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0pIDoge1xuICAgIHg6IG0uZSxcbiAgICB5OiBtLmZcbiAgfSk7XG59LFxuICAgIF9nZXRBbGlnbk1hdHJpeCA9IGZ1bmN0aW9uIF9nZXRBbGlnbk1hdHJpeChmcm9tRWxlbWVudCwgdG9FbGVtZW50LCBmcm9tT3JpZ2luLCB0b09yaWdpbikge1xuICB2YXIgcGFyZW50TWF0cml4ID0gZ2V0R2xvYmFsTWF0cml4KGZyb21FbGVtZW50LnBhcmVudE5vZGUsIHRydWUsIHRydWUpLFxuICAgICAgbSA9IHBhcmVudE1hdHJpeC5jbG9uZSgpLm11bHRpcGx5KGdldEdsb2JhbE1hdHJpeCh0b0VsZW1lbnQpKSxcbiAgICAgIGZyb21Qb2ludCA9IF9vcmlnaW5Ub1BvaW50KGZyb21FbGVtZW50LCBmcm9tT3JpZ2luLCBwYXJlbnRNYXRyaXgpLFxuICAgICAgX29yaWdpblRvUG9pbnQyID0gX29yaWdpblRvUG9pbnQodG9FbGVtZW50LCB0b09yaWdpbiwgcGFyZW50TWF0cml4KSxcbiAgICAgIHggPSBfb3JpZ2luVG9Qb2ludDIueCxcbiAgICAgIHkgPSBfb3JpZ2luVG9Qb2ludDIueSxcbiAgICAgIHA7XG5cbiAgbS5lID0gbS5mID0gMDtcblxuICBpZiAodG9PcmlnaW4gPT09IFwiYXV0b1wiICYmIHRvRWxlbWVudC5nZXRUb3RhbExlbmd0aCAmJiB0b0VsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInBhdGhcIikge1xuICAgIHAgPSB0b0VsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZFwiKS5tYXRjaChfbnVtRXhwKSB8fCBbXTtcbiAgICBwID0gbS5hcHBseSh7XG4gICAgICB4OiArcFswXSxcbiAgICAgIHk6ICtwWzFdXG4gICAgfSk7XG4gICAgeCArPSBwLng7XG4gICAgeSArPSBwLnk7XG4gIH0gLy9pZiAocCB8fCAodG9FbGVtZW50LmdldEJCb3ggJiYgZnJvbUVsZW1lbnQuZ2V0QkJveCAmJiB0b0VsZW1lbnQub3duZXJTVkdFbGVtZW50ID09PSBmcm9tRWxlbWVudC5vd25lclNWR0VsZW1lbnQpKSB7XG5cblxuICBpZiAocCkge1xuICAgIHAgPSBtLmFwcGx5KHRvRWxlbWVudC5nZXRCQm94KCkpO1xuICAgIHggLT0gcC54O1xuICAgIHkgLT0gcC55O1xuICB9XG5cbiAgbS5lID0geCAtIGZyb21Qb2ludC54O1xuICBtLmYgPSB5IC0gZnJvbVBvaW50Lnk7XG4gIHJldHVybiBtO1xufSxcbiAgICBfYWxpZ24gPSBmdW5jdGlvbiBfYWxpZ24ocmF3UGF0aCwgdGFyZ2V0LCBfcmVmKSB7XG4gIHZhciBhbGlnbiA9IF9yZWYuYWxpZ24sXG4gICAgICBtYXRyaXggPSBfcmVmLm1hdHJpeCxcbiAgICAgIG9mZnNldFggPSBfcmVmLm9mZnNldFgsXG4gICAgICBvZmZzZXRZID0gX3JlZi5vZmZzZXRZLFxuICAgICAgYWxpZ25PcmlnaW4gPSBfcmVmLmFsaWduT3JpZ2luO1xuXG4gIHZhciB4ID0gcmF3UGF0aFswXVswXSxcbiAgICAgIHkgPSByYXdQYXRoWzBdWzFdLFxuICAgICAgY3VyWCA9IF9nZXRQcm9wTnVtKHRhcmdldCwgXCJ4XCIpLFxuICAgICAgY3VyWSA9IF9nZXRQcm9wTnVtKHRhcmdldCwgXCJ5XCIpLFxuICAgICAgYWxpZ25UYXJnZXQsXG4gICAgICBtLFxuICAgICAgcDtcblxuICBpZiAoIXJhd1BhdGggfHwgIXJhd1BhdGgubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGdldFJhd1BhdGgoXCJNMCwwTDAsMFwiKTtcbiAgfVxuXG4gIGlmIChhbGlnbikge1xuICAgIGlmIChhbGlnbiA9PT0gXCJzZWxmXCIgfHwgKGFsaWduVGFyZ2V0ID0gX3RvQXJyYXkoYWxpZ24pWzBdIHx8IHRhcmdldCkgPT09IHRhcmdldCkge1xuICAgICAgdHJhbnNmb3JtUmF3UGF0aChyYXdQYXRoLCAxLCAwLCAwLCAxLCBjdXJYIC0geCwgY3VyWSAtIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYWxpZ25PcmlnaW4gJiYgYWxpZ25PcmlnaW5bMl0gIT09IGZhbHNlKSB7XG4gICAgICAgIGdzYXAuc2V0KHRhcmdldCwge1xuICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogYWxpZ25PcmlnaW5bMF0gKiAxMDAgKyBcIiUgXCIgKyBhbGlnbk9yaWdpblsxXSAqIDEwMCArIFwiJVwiXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxpZ25PcmlnaW4gPSBbX2dldFByb3BOdW0odGFyZ2V0LCBcInhQZXJjZW50XCIpIC8gLTEwMCwgX2dldFByb3BOdW0odGFyZ2V0LCBcInlQZXJjZW50XCIpIC8gLTEwMF07XG4gICAgICB9XG5cbiAgICAgIG0gPSBfZ2V0QWxpZ25NYXRyaXgodGFyZ2V0LCBhbGlnblRhcmdldCwgYWxpZ25PcmlnaW4sIFwiYXV0b1wiKTtcbiAgICAgIHAgPSBtLmFwcGx5KHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfSk7XG4gICAgICB0cmFuc2Zvcm1SYXdQYXRoKHJhd1BhdGgsIG0uYSwgbS5iLCBtLmMsIG0uZCwgY3VyWCArIG0uZSAtIChwLnggLSBtLmUpLCBjdXJZICsgbS5mIC0gKHAueSAtIG0uZikpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtYXRyaXgpIHtcbiAgICB0cmFuc2Zvcm1SYXdQYXRoKHJhd1BhdGgsIG1hdHJpeC5hLCBtYXRyaXguYiwgbWF0cml4LmMsIG1hdHJpeC5kLCBtYXRyaXguZSwgbWF0cml4LmYpO1xuICB9IGVsc2UgaWYgKG9mZnNldFggfHwgb2Zmc2V0WSkge1xuICAgIHRyYW5zZm9ybVJhd1BhdGgocmF3UGF0aCwgMSwgMCwgMCwgMSwgb2Zmc2V0WCB8fCAwLCBvZmZzZXRZIHx8IDApO1xuICB9XG5cbiAgcmV0dXJuIHJhd1BhdGg7XG59LFxuICAgIF9hZGREaW1lbnNpb25hbFByb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGREaW1lbnNpb25hbFByb3BUd2VlbihwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIHJhd1BhdGgsIHBhdGhQcm9wZXJ0eSwgZm9yY2VVbml0KSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCxcbiAgICAgIGhhcm5lc3MgPSBjYWNoZS5oYXJuZXNzLFxuICAgICAgYWxpYXMgPSBoYXJuZXNzICYmIGhhcm5lc3MuYWxpYXNlcyAmJiBoYXJuZXNzLmFsaWFzZXNbcHJvcGVydHldLFxuICAgICAgcHJvcCA9IGFsaWFzICYmIGFsaWFzLmluZGV4T2YoXCIsXCIpIDwgMCA/IGFsaWFzIDogcHJvcGVydHksXG4gICAgICBwdCA9IHBsdWdpbi5fcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgcHJvcCwgMCwgMCwgX2VtcHR5RnVuYywgMCwgY2FjaGUuc2V0KHRhcmdldCwgcHJvcCwgcGx1Z2luKSk7XG4gIHB0LnUgPSBfZ2V0VW5pdChjYWNoZS5nZXQodGFyZ2V0LCBwcm9wLCBmb3JjZVVuaXQpKSB8fCAwO1xuICBwdC5wYXRoID0gcmF3UGF0aDtcbiAgcHQucHAgPSBwYXRoUHJvcGVydHk7XG5cbiAgcGx1Z2luLl9wcm9wcy5wdXNoKHByb3ApO1xufSxcbiAgICBfc2xpY2VNb2RpZmllciA9IGZ1bmN0aW9uIF9zbGljZU1vZGlmaWVyKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyYXdQYXRoKSB7XG4gICAgcmV0dXJuIHN0YXJ0IHx8IGVuZCAhPT0gMSA/IHNsaWNlUmF3UGF0aChyYXdQYXRoLCBzdGFydCwgZW5kKSA6IHJhd1BhdGg7XG4gIH07XG59O1xuXG5leHBvcnQgdmFyIE1vdGlvblBhdGhQbHVnaW4gPSB7XG4gIHZlcnNpb246IFwiMy4xMi41XCIsXG4gIG5hbWU6IFwibW90aW9uUGF0aFwiLFxuICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoY29yZSwgUGx1Z2luLCBwcm9wVHdlZW4pIHtcbiAgICBnc2FwID0gY29yZTtcbiAgICBfZ2V0VW5pdCA9IGdzYXAudXRpbHMuZ2V0VW5pdDtcbiAgICBfdG9BcnJheSA9IGdzYXAudXRpbHMudG9BcnJheTtcbiAgICBfZ2V0U3R5bGVTYXZlciA9IGdzYXAuY29yZS5nZXRTdHlsZVNhdmVyO1xuXG4gICAgX3JldmVydGluZyA9IGdzYXAuY29yZS5yZXZlcnRpbmcgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICBQcm9wVHdlZW4gPSBwcm9wVHdlZW47XG4gIH0sXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YXJzLCB0d2Vlbikge1xuICAgIGlmICghZ3NhcCkge1xuICAgICAgY29uc29sZS53YXJuKFwiUGxlYXNlIGdzYXAucmVnaXN0ZXJQbHVnaW4oTW90aW9uUGF0aFBsdWdpbilcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCEodHlwZW9mIHZhcnMgPT09IFwib2JqZWN0XCIgJiYgIXZhcnMuc3R5bGUpIHx8ICF2YXJzLnBhdGgpIHtcbiAgICAgIHZhcnMgPSB7XG4gICAgICAgIHBhdGg6IHZhcnNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHJhd1BhdGhzID0gW10sXG4gICAgICAgIF92YXJzID0gdmFycyxcbiAgICAgICAgcGF0aCA9IF92YXJzLnBhdGgsXG4gICAgICAgIGF1dG9Sb3RhdGUgPSBfdmFycy5hdXRvUm90YXRlLFxuICAgICAgICB1bml0WCA9IF92YXJzLnVuaXRYLFxuICAgICAgICB1bml0WSA9IF92YXJzLnVuaXRZLFxuICAgICAgICB4ID0gX3ZhcnMueCxcbiAgICAgICAgeSA9IF92YXJzLnksXG4gICAgICAgIGZpcnN0T2JqID0gcGF0aFswXSxcbiAgICAgICAgc2xpY2VyID0gX3NsaWNlTW9kaWZpZXIodmFycy5zdGFydCwgXCJlbmRcIiBpbiB2YXJzID8gdmFycy5lbmQgOiAxKSxcbiAgICAgICAgcmF3UGF0aCxcbiAgICAgICAgcDtcblxuICAgIHRoaXMucmF3UGF0aHMgPSByYXdQYXRocztcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLnR3ZWVuID0gdHdlZW47XG4gICAgdGhpcy5zdHlsZXMgPSBfZ2V0U3R5bGVTYXZlciAmJiBfZ2V0U3R5bGVTYXZlcih0YXJnZXQsIFwidHJhbnNmb3JtXCIpO1xuXG4gICAgaWYgKHRoaXMucm90YXRlID0gYXV0b1JvdGF0ZSB8fCBhdXRvUm90YXRlID09PSAwKSB7XG4gICAgICAvL2dldCB0aGUgcm90YXRpb25hbCBkYXRhIEZJUlNUIHNvIHRoYXQgdGhlIHNldFRyYW5zZm9ybSgpIG1ldGhvZCBpcyBjYWxsZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIgaW4gdGhlIHJlbmRlcigpIGxvb3AgLSByb3RhdGlvbiBnZXRzIHNldCBsYXN0LlxuICAgICAgdGhpcy5yT2Zmc2V0ID0gcGFyc2VGbG9hdChhdXRvUm90YXRlKSB8fCAwO1xuICAgICAgdGhpcy5yYWRpYW5zID0gISF2YXJzLnVzZVJhZGlhbnM7XG4gICAgICB0aGlzLnJQcm9wID0gdmFycy5yb3RhdGlvbiB8fCBcInJvdGF0aW9uXCI7IC8vIHJvdGF0aW9uIHByb3BlcnR5XG5cbiAgICAgIHRoaXMuclNldCA9IHRhcmdldC5fZ3NhcC5zZXQodGFyZ2V0LCB0aGlzLnJQcm9wLCB0aGlzKTsgLy8gcm90YXRpb24gc2V0dGVyXG5cbiAgICAgIHRoaXMucnUgPSBfZ2V0VW5pdCh0YXJnZXQuX2dzYXAuZ2V0KHRhcmdldCwgdGhpcy5yUHJvcCkpIHx8IDA7IC8vIHJvdGF0aW9uIHVuaXRzXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkgJiYgIShcImNsb3NlZFwiIGluIHBhdGgpICYmIHR5cGVvZiBmaXJzdE9iaiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgZm9yIChwIGluIGZpcnN0T2JqKSB7XG4gICAgICAgIGlmICgheCAmJiB+X3hQcm9wcy5pbmRleE9mKHApKSB7XG4gICAgICAgICAgeCA9IHA7XG4gICAgICAgIH0gZWxzZSBpZiAoIXkgJiYgfl95UHJvcHMuaW5kZXhPZihwKSkge1xuICAgICAgICAgIHkgPSBwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh4ICYmIHkpIHtcbiAgICAgICAgLy9jb3JyZWxhdGVkIHZhbHVlc1xuICAgICAgICByYXdQYXRocy5wdXNoKF9zZWdtZW50VG9SYXdQYXRoKHRoaXMsIF9wb3B1bGF0ZVNlZ21lbnRGcm9tQXJyYXkoX3BvcHVsYXRlU2VnbWVudEZyb21BcnJheShbXSwgcGF0aCwgeCwgMCksIHBhdGgsIHksIDEpLCB0YXJnZXQsIHgsIHksIHNsaWNlciwgdmFycywgdW5pdFggfHwgX2dldFVuaXQocGF0aFswXVt4XSksIHVuaXRZIHx8IF9nZXRVbml0KHBhdGhbMF1beV0pKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0geSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAocCBpbiBmaXJzdE9iaikge1xuICAgICAgICBwICE9PSB4ICYmIHAgIT09IHkgJiYgcmF3UGF0aHMucHVzaChfc2VnbWVudFRvUmF3UGF0aCh0aGlzLCBfcG9wdWxhdGVTZWdtZW50RnJvbUFycmF5KFtdLCBwYXRoLCBwLCAyKSwgdGFyZ2V0LCBwLCAwLCBzbGljZXIsIHZhcnMsIF9nZXRVbml0KHBhdGhbMF1bcF0pKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhd1BhdGggPSBzbGljZXIoX2FsaWduKGdldFJhd1BhdGgodmFycy5wYXRoKSwgdGFyZ2V0LCB2YXJzKSk7XG4gICAgICBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMocmF3UGF0aCwgdmFycy5yZXNvbHV0aW9uKTtcbiAgICAgIHJhd1BhdGhzLnB1c2gocmF3UGF0aCk7XG5cbiAgICAgIF9hZGREaW1lbnNpb25hbFByb3BUd2Vlbih0aGlzLCB0YXJnZXQsIHZhcnMueCB8fCBcInhcIiwgcmF3UGF0aCwgXCJ4XCIsIHZhcnMudW5pdFggfHwgXCJweFwiKTtcblxuICAgICAgX2FkZERpbWVuc2lvbmFsUHJvcFR3ZWVuKHRoaXMsIHRhcmdldCwgdmFycy55IHx8IFwieVwiLCByYXdQYXRoLCBcInlcIiwgdmFycy51bml0WSB8fCBcInB4XCIpO1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocmF0aW8sIGRhdGEpIHtcbiAgICB2YXIgcmF3UGF0aHMgPSBkYXRhLnJhd1BhdGhzLFxuICAgICAgICBpID0gcmF3UGF0aHMubGVuZ3RoLFxuICAgICAgICBwdCA9IGRhdGEuX3B0O1xuXG4gICAgaWYgKGRhdGEudHdlZW4uX3RpbWUgfHwgIV9yZXZlcnRpbmcoKSkge1xuICAgICAgaWYgKHJhdGlvID4gMSkge1xuICAgICAgICByYXRpbyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHJhdGlvIDwgMCkge1xuICAgICAgICByYXRpbyA9IDA7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgZ2V0UG9zaXRpb25PblBhdGgocmF3UGF0aHNbaV0sIHJhdGlvLCAhaSAmJiBkYXRhLnJvdGF0ZSwgcmF3UGF0aHNbaV0pO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAocHQpIHtcbiAgICAgICAgcHQuc2V0KHB0LnQsIHB0LnAsIHB0LnBhdGhbcHQucHBdICsgcHQudSwgcHQuZCwgcmF0aW8pO1xuICAgICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgICAgfVxuXG4gICAgICBkYXRhLnJvdGF0ZSAmJiBkYXRhLnJTZXQoZGF0YS50YXJnZXQsIGRhdGEuclByb3AsIHJhd1BhdGhzWzBdLmFuZ2xlICogKGRhdGEucmFkaWFucyA/IF9ERUcyUkFEIDogMSkgKyBkYXRhLnJPZmZzZXQgKyBkYXRhLnJ1LCBkYXRhLCByYXRpbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEuc3R5bGVzLnJldmVydCgpO1xuICAgIH1cbiAgfSxcbiAgZ2V0TGVuZ3RoOiBmdW5jdGlvbiBnZXRMZW5ndGgocGF0aCkge1xuICAgIHJldHVybiBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMoZ2V0UmF3UGF0aChwYXRoKSkudG90YWxMZW5ndGg7XG4gIH0sXG4gIHNsaWNlUmF3UGF0aDogc2xpY2VSYXdQYXRoLFxuICBnZXRSYXdQYXRoOiBnZXRSYXdQYXRoLFxuICBwb2ludHNUb1NlZ21lbnQ6IHBvaW50c1RvU2VnbWVudCxcbiAgc3RyaW5nVG9SYXdQYXRoOiBzdHJpbmdUb1Jhd1BhdGgsXG4gIHJhd1BhdGhUb1N0cmluZzogcmF3UGF0aFRvU3RyaW5nLFxuICB0cmFuc2Zvcm1SYXdQYXRoOiB0cmFuc2Zvcm1SYXdQYXRoLFxuICBnZXRHbG9iYWxNYXRyaXg6IGdldEdsb2JhbE1hdHJpeCxcbiAgZ2V0UG9zaXRpb25PblBhdGg6IGdldFBvc2l0aW9uT25QYXRoLFxuICBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHM6IGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyxcbiAgY29udmVydFRvUGF0aDogZnVuY3Rpb24gY29udmVydFRvUGF0aCh0YXJnZXRzLCBzd2FwKSB7XG4gICAgcmV0dXJuIF90b0FycmF5KHRhcmdldHMpLm1hcChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gX2NvbnZlcnRUb1BhdGgodGFyZ2V0LCBzd2FwICE9PSBmYWxzZSk7XG4gICAgfSk7XG4gIH0sXG4gIGNvbnZlcnRDb29yZGluYXRlczogZnVuY3Rpb24gY29udmVydENvb3JkaW5hdGVzKGZyb21FbGVtZW50LCB0b0VsZW1lbnQsIHBvaW50KSB7XG4gICAgdmFyIG0gPSBnZXRHbG9iYWxNYXRyaXgodG9FbGVtZW50LCB0cnVlLCB0cnVlKS5tdWx0aXBseShnZXRHbG9iYWxNYXRyaXgoZnJvbUVsZW1lbnQpKTtcbiAgICByZXR1cm4gcG9pbnQgPyBtLmFwcGx5KHBvaW50KSA6IG07XG4gIH0sXG4gIGdldEFsaWduTWF0cml4OiBfZ2V0QWxpZ25NYXRyaXgsXG4gIGdldFJlbGF0aXZlUG9zaXRpb246IGZ1bmN0aW9uIGdldFJlbGF0aXZlUG9zaXRpb24oZnJvbUVsZW1lbnQsIHRvRWxlbWVudCwgZnJvbU9yaWdpbiwgdG9PcmlnaW4pIHtcbiAgICB2YXIgbSA9IF9nZXRBbGlnbk1hdHJpeChmcm9tRWxlbWVudCwgdG9FbGVtZW50LCBmcm9tT3JpZ2luLCB0b09yaWdpbik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogbS5lLFxuICAgICAgeTogbS5mXG4gICAgfTtcbiAgfSxcbiAgYXJyYXlUb1Jhd1BhdGg6IGZ1bmN0aW9uIGFycmF5VG9SYXdQYXRoKHZhbHVlLCB2YXJzKSB7XG4gICAgdmFycyA9IHZhcnMgfHwge307XG5cbiAgICB2YXIgc2VnbWVudCA9IF9wb3B1bGF0ZVNlZ21lbnRGcm9tQXJyYXkoX3BvcHVsYXRlU2VnbWVudEZyb21BcnJheShbXSwgdmFsdWUsIHZhcnMueCB8fCBcInhcIiwgMCksIHZhbHVlLCB2YXJzLnkgfHwgXCJ5XCIsIDEpO1xuXG4gICAgdmFycy5yZWxhdGl2ZSAmJiBfcmVsYXRpdml6ZShzZWdtZW50KTtcbiAgICByZXR1cm4gW3ZhcnMudHlwZSA9PT0gXCJjdWJpY1wiID8gc2VnbWVudCA6IHBvaW50c1RvU2VnbWVudChzZWdtZW50LCB2YXJzLmN1cnZpbmVzcyldO1xuICB9XG59O1xuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKE1vdGlvblBhdGhQbHVnaW4pO1xuZXhwb3J0IHsgTW90aW9uUGF0aFBsdWdpbiBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbImdldFJhd1BhdGgiLCJjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMiLCJnZXRQb3NpdGlvbk9uUGF0aCIsInBvaW50c1RvU2VnbWVudCIsImZsYXRQb2ludHNUb1NlZ21lbnQiLCJzbGljZVJhd1BhdGgiLCJzdHJpbmdUb1Jhd1BhdGgiLCJyYXdQYXRoVG9TdHJpbmciLCJ0cmFuc2Zvcm1SYXdQYXRoIiwiY29udmVydFRvUGF0aCIsIl9jb252ZXJ0VG9QYXRoIiwiZ2V0R2xvYmFsTWF0cml4IiwiX3hQcm9wcyIsInNwbGl0IiwiX3lQcm9wcyIsIl9ERUcyUkFEIiwiTWF0aCIsIlBJIiwiZ3NhcCIsIlByb3BUd2VlbiIsIl9nZXRVbml0IiwiX3RvQXJyYXkiLCJfZ2V0U3R5bGVTYXZlciIsIl9yZXZlcnRpbmciLCJfZ2V0R1NBUCIsIndpbmRvdyIsInJlZ2lzdGVyUGx1Z2luIiwiX3BvcHVsYXRlU2VnbWVudEZyb21BcnJheSIsInNlZ21lbnQiLCJ2YWx1ZXMiLCJwcm9wZXJ0eSIsIm1vZGUiLCJsIiwibGVuZ3RoIiwic2kiLCJpIiwidiIsInBhcnNlRmxvYXQiLCJfZ2V0UHJvcE51bSIsInRhcmdldCIsInByb3AiLCJ1bml0IiwiX2dzYXAiLCJnZXQiLCJfcmVsYXRpdml6ZSIsIngiLCJ5IiwiX3NlZ21lbnRUb1Jhd1BhdGgiLCJwbHVnaW4iLCJzbGljZXIiLCJ2YXJzIiwidW5pdFgiLCJ1bml0WSIsInR5cGUiLCJmcm9tQ3VycmVudCIsInVuc2hpZnQiLCJyZWxhdGl2ZSIsInBvaW50RnVuYyIsImN1cnZpbmVzcyIsIl9hbGlnbiIsIl9hZGREaW1lbnNpb25hbFByb3BUd2VlbiIsInJlc29sdXRpb24iLCJfZW1wdHlGdW5jIiwiX251bUV4cCIsIl9vcmlnaW5Ub1BvaW50IiwiZWxlbWVudCIsIm9yaWdpbiIsInBhcmVudE1hdHJpeCIsIm0iLCJzdmciLCJ0YWdOYW1lIiwidG9Mb3dlckNhc2UiLCJ2aWV3Qm94IiwiYmFzZVZhbCIsIndpZHRoIiwiZ2V0QXR0cmlidXRlIiwiaGVpZ2h0IiwiZ2V0QkJveCIsInB1c2giLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImFwcGx5IiwiZSIsImYiLCJfZ2V0QWxpZ25NYXRyaXgiLCJmcm9tRWxlbWVudCIsInRvRWxlbWVudCIsImZyb21PcmlnaW4iLCJ0b09yaWdpbiIsInBhcmVudE5vZGUiLCJjbG9uZSIsIm11bHRpcGx5IiwiZnJvbVBvaW50IiwiX29yaWdpblRvUG9pbnQyIiwicCIsImdldFRvdGFsTGVuZ3RoIiwibWF0Y2giLCJyYXdQYXRoIiwiX3JlZiIsImFsaWduIiwibWF0cml4Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJhbGlnbk9yaWdpbiIsImN1clgiLCJjdXJZIiwiYWxpZ25UYXJnZXQiLCJzZXQiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJhIiwiYiIsImMiLCJkIiwicGF0aFByb3BlcnR5IiwiZm9yY2VVbml0IiwiY2FjaGUiLCJoYXJuZXNzIiwiYWxpYXMiLCJhbGlhc2VzIiwiaW5kZXhPZiIsInB0IiwiX3B0IiwidSIsInBhdGgiLCJwcCIsIl9wcm9wcyIsIl9zbGljZU1vZGlmaWVyIiwic3RhcnQiLCJlbmQiLCJNb3Rpb25QYXRoUGx1Z2luIiwidmVyc2lvbiIsIm5hbWUiLCJyZWdpc3RlciIsImNvcmUiLCJQbHVnaW4iLCJwcm9wVHdlZW4iLCJ1dGlscyIsImdldFVuaXQiLCJ0b0FycmF5IiwiZ2V0U3R5bGVTYXZlciIsInJldmVydGluZyIsImluaXQiLCJ0d2VlbiIsImNvbnNvbGUiLCJ3YXJuIiwic3R5bGUiLCJyYXdQYXRocyIsIl92YXJzIiwiYXV0b1JvdGF0ZSIsImZpcnN0T2JqIiwic3R5bGVzIiwicm90YXRlIiwick9mZnNldCIsInJhZGlhbnMiLCJ1c2VSYWRpYW5zIiwiclByb3AiLCJyb3RhdGlvbiIsInJTZXQiLCJydSIsIkFycmF5IiwiaXNBcnJheSIsInJlbmRlciIsInJhdGlvIiwiZGF0YSIsIl90aW1lIiwidCIsIl9uZXh0IiwiYW5nbGUiLCJyZXZlcnQiLCJnZXRMZW5ndGgiLCJ0b3RhbExlbmd0aCIsInRhcmdldHMiLCJzd2FwIiwibWFwIiwiY29udmVydENvb3JkaW5hdGVzIiwicG9pbnQiLCJnZXRBbGlnbk1hdHJpeCIsImdldFJlbGF0aXZlUG9zaXRpb24iLCJhcnJheVRvUmF3UGF0aCIsInZhbHVlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/MotionPathPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Observer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Observer.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Observer: function() { return /* binding */ Observer; },\n/* harmony export */   _getProxyProp: function() { return /* binding */ _getProxyProp; },\n/* harmony export */   _getScrollFunc: function() { return /* binding */ _getScrollFunc; },\n/* harmony export */   _getTarget: function() { return /* binding */ _getTarget; },\n/* harmony export */   _getVelocityProp: function() { return /* binding */ _getVelocityProp; },\n/* harmony export */   _horizontal: function() { return /* binding */ _horizontal; },\n/* harmony export */   _isViewport: function() { return /* binding */ _isViewport; },\n/* harmony export */   _proxies: function() { return /* binding */ _proxies; },\n/* harmony export */   _scrollers: function() { return /* binding */ _scrollers; },\n/* harmony export */   _vertical: function() { return /* binding */ _vertical; },\n/* harmony export */   \"default\": function() { return /* binding */ Observer; }\n/* harmony export */ });\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\n/*!\n * Observer 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var gsap, _coreInitted, _clamp, _win, _doc, _docEl, _body, _isTouch, _pointerType, ScrollTrigger, _root, _normalizer, _eventTypes, _context, _getGSAP = function _getGSAP() {\n    return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _startup = 1, _observers = [], _scrollers = [], _proxies = [], _getTime = Date.now, _bridge = function _bridge(name, value) {\n    return value;\n}, _integrate = function _integrate() {\n    var core = ScrollTrigger.core, data = core.bridge || {}, scrollers = core._scrollers, proxies = core._proxies;\n    scrollers.push.apply(scrollers, _scrollers);\n    proxies.push.apply(proxies, _proxies);\n    _scrollers = scrollers;\n    _proxies = proxies;\n    _bridge = function _bridge(name, value) {\n        return data[name](value);\n    };\n}, _getProxyProp = function _getProxyProp(element, property) {\n    return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];\n}, _isViewport = function _isViewport(el) {\n    return !!~_root.indexOf(el);\n}, _addListener = function _addListener(element, type, func, passive, capture) {\n    return element.addEventListener(type, func, {\n        passive: passive !== false,\n        capture: !!capture\n    });\n}, _removeListener = function _removeListener(element, type, func, capture) {\n    return element.removeEventListener(type, func, !!capture);\n}, _scrollLeft = \"scrollLeft\", _scrollTop = \"scrollTop\", _onScroll = function _onScroll() {\n    return _normalizer && _normalizer.isPressed || _scrollers.cache++;\n}, _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {\n    var cachingFunc = function cachingFunc(value) {\n        // since reading the scrollTop/scrollLeft/pageOffsetY/pageOffsetX can trigger a layout, this function allows us to cache the value so it only gets read fresh after a \"scroll\" event fires (or while we're refreshing because that can lengthen the page and alter the scroll position). when \"soft\" is true, that means don't actually set the scroll, but cache the new value instead (useful in ScrollSmoother)\n        if (value || value === 0) {\n            _startup && (_win.history.scrollRestoration = \"manual\"); // otherwise the new position will get overwritten by the browser onload.\n            var isNormalizing = _normalizer && _normalizer.isPressed;\n            value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0); //TODO: iOS Bug: if you allow it to go to 0, Safari can start to report super strange (wildly inaccurate) touch positions!\n            f(value);\n            cachingFunc.cacheID = _scrollers.cache;\n            isNormalizing && _bridge(\"ss\", value); // set scroll (notify ScrollTrigger so it can dispatch a \"scrollStart\" event if necessary\n        } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge(\"ref\")) {\n            cachingFunc.cacheID = _scrollers.cache;\n            cachingFunc.v = f();\n        }\n        return cachingFunc.v + cachingFunc.offset;\n    };\n    cachingFunc.offset = 0;\n    return f && cachingFunc;\n}, _horizontal = {\n    s: _scrollLeft,\n    p: \"left\",\n    p2: \"Left\",\n    os: \"right\",\n    os2: \"Right\",\n    d: \"width\",\n    d2: \"Width\",\n    a: \"x\",\n    sc: _scrollCacheFunc(function(value) {\n        return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;\n    })\n}, _vertical = {\n    s: _scrollTop,\n    p: \"top\",\n    p2: \"Top\",\n    os: \"bottom\",\n    os2: \"Bottom\",\n    d: \"height\",\n    d2: \"Height\",\n    a: \"y\",\n    op: _horizontal,\n    sc: _scrollCacheFunc(function(value) {\n        return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;\n    })\n}, _getTarget = function _getTarget(t, self) {\n    return (self && self._ctx && self._ctx.selector || gsap.utils.toArray)(t)[0] || (typeof t === \"string\" && gsap.config().nullTargetWarn !== false ? console.warn(\"Element not found:\", t) : null);\n}, _getScrollFunc = function _getScrollFunc(element, _ref) {\n    var s = _ref.s, sc = _ref.sc;\n    // we store the scroller functions in an alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a \".rec\" property in order to revert to that after refreshing to ensure things don't shift around.\n    _isViewport(element) && (element = _doc.scrollingElement || _docEl);\n    var i = _scrollers.indexOf(element), offset = sc === _vertical.sc ? 1 : 2;\n    !~i && (i = _scrollers.push(element) - 1);\n    _scrollers[i + offset] || _addListener(element, \"scroll\", _onScroll); // clear the cache when a scroll occurs\n    var prev = _scrollers[i + offset], func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function(value) {\n        return arguments.length ? element[s] = value : element[s];\n    })));\n    func.target = element;\n    prev || (func.smooth = gsap.getProperty(element, \"scrollBehavior\") === \"smooth\"); // only set it the first time (don't reset every time a scrollFunc is requested because perhaps it happens during a refresh() when it's disabled in ScrollTrigger.\n    return func;\n}, _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {\n    var v1 = value, v2 = value, t1 = _getTime(), t2 = t1, min = minTimeRefresh || 50, dropToZeroTime = Math.max(500, min * 3), update = function update(value, force) {\n        var t = _getTime();\n        if (force || t - t1 > min) {\n            v2 = v1;\n            v1 = value;\n            t2 = t1;\n            t1 = t;\n        } else if (useDelta) {\n            v1 += value;\n        } else {\n            // not totally necessary, but makes it a bit more accurate by adjusting the v1 value according to the new slope. This way we're not just ignoring the incoming data. Removing for now because it doesn't seem to make much practical difference and it's probably not worth the kb.\n            v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);\n        }\n    }, reset = function reset() {\n        v2 = v1 = useDelta ? 0 : v1;\n        t2 = t1 = 0;\n    }, getVelocity = function getVelocity(latestValue) {\n        var tOld = t2, vOld = v2, t = _getTime();\n        (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);\n        return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;\n    };\n    return {\n        update: update,\n        reset: reset,\n        getVelocity: getVelocity\n    };\n}, _getEvent = function _getEvent(e, preventDefault) {\n    preventDefault && !e._gsapAllow && e.preventDefault();\n    return e.changedTouches ? e.changedTouches[0] : e;\n}, _getAbsoluteMax = function _getAbsoluteMax(a) {\n    var max = Math.max.apply(Math, a), min = Math.min.apply(Math, a);\n    return Math.abs(max) >= Math.abs(min) ? max : min;\n}, _setScrollTrigger = function _setScrollTrigger() {\n    ScrollTrigger = gsap.core.globals().ScrollTrigger;\n    ScrollTrigger && ScrollTrigger.core && _integrate();\n}, _initCore = function _initCore(core) {\n    gsap = core || _getGSAP();\n    if (!_coreInitted && gsap && typeof document !== \"undefined\" && document.body) {\n        _win = window;\n        _doc = document;\n        _docEl = _doc.documentElement;\n        _body = _doc.body;\n        _root = [\n            _win,\n            _doc,\n            _docEl,\n            _body\n        ];\n        _clamp = gsap.utils.clamp;\n        _context = gsap.core.context || function() {};\n        _pointerType = \"onpointerenter\" in _body ? \"pointer\" : \"mouse\"; // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.\n        _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia(\"(hover: none), (pointer: coarse)\").matches ? 1 : \"ontouchstart\" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;\n        _eventTypes = Observer.eventTypes = (\"ontouchstart\" in _docEl ? \"touchstart,touchmove,touchcancel,touchend\" : !(\"onpointerdown\" in _docEl) ? \"mousedown,mousemove,mouseup,mouseup\" : \"pointerdown,pointermove,pointercancel,pointerup\").split(\",\");\n        setTimeout(function() {\n            return _startup = 0;\n        }, 500);\n        _setScrollTrigger();\n        _coreInitted = 1;\n    }\n    return _coreInitted;\n};\n_horizontal.op = _vertical;\n_scrollers.cache = 0;\nvar Observer = /*#__PURE__*/ function() {\n    function Observer(vars) {\n        this.init(vars);\n    }\n    var _proto = Observer.prototype;\n    _proto.init = function init(vars) {\n        _coreInitted || _initCore(gsap) || console.warn(\"Please gsap.registerPlugin(Observer)\");\n        ScrollTrigger || _setScrollTrigger();\n        var tolerance = vars.tolerance, dragMinimum = vars.dragMinimum, type = vars.type, target = vars.target, lineHeight = vars.lineHeight, debounce = vars.debounce, preventDefault = vars.preventDefault, onStop = vars.onStop, onStopDelay = vars.onStopDelay, ignore = vars.ignore, wheelSpeed = vars.wheelSpeed, event = vars.event, onDragStart = vars.onDragStart, onDragEnd = vars.onDragEnd, onDrag = vars.onDrag, onPress = vars.onPress, onRelease = vars.onRelease, onRight = vars.onRight, onLeft = vars.onLeft, onUp = vars.onUp, onDown = vars.onDown, onChangeX = vars.onChangeX, onChangeY = vars.onChangeY, onChange = vars.onChange, onToggleX = vars.onToggleX, onToggleY = vars.onToggleY, onHover = vars.onHover, onHoverEnd = vars.onHoverEnd, onMove = vars.onMove, ignoreCheck = vars.ignoreCheck, isNormalizer = vars.isNormalizer, onGestureStart = vars.onGestureStart, onGestureEnd = vars.onGestureEnd, onWheel = vars.onWheel, onEnable = vars.onEnable, onDisable = vars.onDisable, onClick = vars.onClick, scrollSpeed = vars.scrollSpeed, capture = vars.capture, allowClicks = vars.allowClicks, lockAxis = vars.lockAxis, onLockAxis = vars.onLockAxis;\n        this.target = target = _getTarget(target) || _docEl;\n        this.vars = vars;\n        ignore && (ignore = gsap.utils.toArray(ignore));\n        tolerance = tolerance || 1e-9;\n        dragMinimum = dragMinimum || 0;\n        wheelSpeed = wheelSpeed || 1;\n        scrollSpeed = scrollSpeed || 1;\n        type = type || \"wheel,touch,pointer\";\n        debounce = debounce !== false;\n        lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22); // note: browser may report \"normal\", so default to 22.\n        var id, onStopDelayedCall, dragged, moved, wheeled, locked, axis, self = this, prevDeltaX = 0, prevDeltaY = 0, passive = vars.passive || !preventDefault, scrollFuncX = _getScrollFunc(target, _horizontal), scrollFuncY = _getScrollFunc(target, _vertical), scrollX = scrollFuncX(), scrollY = scrollFuncY(), limitToTouch = ~type.indexOf(\"touch\") && !~type.indexOf(\"pointer\") && _eventTypes[0] === \"pointerdown\", // for devices that accommodate mouse events and touch events, we need to distinguish.\n        isViewport = _isViewport(target), ownerDoc = target.ownerDocument || _doc, deltaX = [\n            0,\n            0,\n            0\n        ], // wheel, scroll, pointer/touch\n        deltaY = [\n            0,\n            0,\n            0\n        ], onClickTime = 0, clickCapture = function clickCapture() {\n            return onClickTime = _getTime();\n        }, _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {\n            return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== \"touch\" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);\n        }, onStopFunc = function onStopFunc() {\n            self._vx.reset();\n            self._vy.reset();\n            onStopDelayedCall.pause();\n            onStop && onStop(self);\n        }, update = function update() {\n            var dx = self.deltaX = _getAbsoluteMax(deltaX), dy = self.deltaY = _getAbsoluteMax(deltaY), changedX = Math.abs(dx) >= tolerance, changedY = Math.abs(dy) >= tolerance;\n            onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY); // in ScrollTrigger.normalizeScroll(), we need to know if it was touch/pointer so we need access to the deltaX/deltaY Arrays before we clear them out.\n            if (changedX) {\n                onRight && self.deltaX > 0 && onRight(self);\n                onLeft && self.deltaX < 0 && onLeft(self);\n                onChangeX && onChangeX(self);\n                onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);\n                prevDeltaX = self.deltaX;\n                deltaX[0] = deltaX[1] = deltaX[2] = 0;\n            }\n            if (changedY) {\n                onDown && self.deltaY > 0 && onDown(self);\n                onUp && self.deltaY < 0 && onUp(self);\n                onChangeY && onChangeY(self);\n                onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);\n                prevDeltaY = self.deltaY;\n                deltaY[0] = deltaY[1] = deltaY[2] = 0;\n            }\n            if (moved || dragged) {\n                onMove && onMove(self);\n                if (dragged) {\n                    onDrag(self);\n                    dragged = false;\n                }\n                moved = false;\n            }\n            locked && !(locked = false) && onLockAxis && onLockAxis(self);\n            if (wheeled) {\n                onWheel(self);\n                wheeled = false;\n            }\n            id = 0;\n        }, onDelta = function onDelta(x, y, index) {\n            deltaX[index] += x;\n            deltaY[index] += y;\n            self._vx.update(x);\n            self._vy.update(y);\n            debounce ? id || (id = requestAnimationFrame(update)) : update();\n        }, onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {\n            if (lockAxis && !axis) {\n                self.axis = axis = Math.abs(x) > Math.abs(y) ? \"x\" : \"y\";\n                locked = true;\n            }\n            if (axis !== \"y\") {\n                deltaX[2] += x;\n                self._vx.update(x, true); // update the velocity as frequently as possible instead of in the debounced function so that very quick touch-scrolls (flicks) feel natural. If it's the mouse/touch/pointer, force it so that we get snappy/accurate momentum scroll.\n            }\n            if (axis !== \"x\") {\n                deltaY[2] += y;\n                self._vy.update(y, true);\n            }\n            debounce ? id || (id = requestAnimationFrame(update)) : update();\n        }, _onDrag = function _onDrag(e) {\n            if (_ignoreCheck(e, 1)) {\n                return;\n            }\n            e = _getEvent(e, preventDefault);\n            var x = e.clientX, y = e.clientY, dx = x - self.x, dy = y - self.y, isDragging = self.isDragging;\n            self.x = x;\n            self.y = y;\n            if (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) {\n                onDrag && (dragged = true);\n                isDragging || (self.isDragging = true);\n                onTouchOrPointerDelta(dx, dy);\n                isDragging || onDragStart && onDragStart(self);\n            }\n        }, _onPress = self.onPress = function _onPress(e) {\n            if (_ignoreCheck(e, 1) || e && e.button) {\n                return;\n            }\n            self.axis = axis = null;\n            onStopDelayedCall.pause();\n            self.isPressed = true;\n            e = _getEvent(e); // note: may need to preventDefault(?) Won't side-scroll on iOS Safari if we do, though.\n            prevDeltaX = prevDeltaY = 0;\n            self.startX = self.x = e.clientX;\n            self.startY = self.y = e.clientY;\n            self._vx.reset(); // otherwise the t2 may be stale if the user touches and flicks super fast and releases in less than 2 requestAnimationFrame ticks, causing velocity to be 0.\n            self._vy.reset();\n            _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, passive, true);\n            self.deltaX = self.deltaY = 0;\n            onPress && onPress(self);\n        }, _onRelease = self.onRelease = function _onRelease(e) {\n            if (_ignoreCheck(e, 1)) {\n                return;\n            }\n            _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n            var isTrackingDrag = !isNaN(self.y - self.startY), wasDragging = self.isDragging, isDragNotClick = wasDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3), // some touch devices need some wiggle room in terms of sensing clicks - the finger may move a few pixels.\n            eventData = _getEvent(e);\n            if (!isDragNotClick && isTrackingDrag) {\n                self._vx.reset();\n                self._vy.reset(); //if (preventDefault && allowClicks && self.isPressed) { // check isPressed because in a rare edge case, the inputObserver in ScrollTrigger may stopPropagation() on the press/drag, so the onRelease may get fired without the onPress/onDrag ever getting called, thus it could trigger a click to occur on a link after scroll-dragging it.\n                if (preventDefault && allowClicks) {\n                    gsap.delayedCall(0.08, function() {\n                        // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular \"click\" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the \"real\"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the \"real\" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.\n                        if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {\n                            if (e.target.click) {\n                                //some browsers (like mobile Safari) don't properly trigger the click event\n                                e.target.click();\n                            } else if (ownerDoc.createEvent) {\n                                var syntheticEvent = ownerDoc.createEvent(\"MouseEvents\");\n                                syntheticEvent.initMouseEvent(\"click\", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);\n                                e.target.dispatchEvent(syntheticEvent);\n                            }\n                        }\n                    });\n                }\n            }\n            self.isDragging = self.isGesturing = self.isPressed = false;\n            onStop && wasDragging && !isNormalizer && onStopDelayedCall.restart(true);\n            onDragEnd && wasDragging && onDragEnd(self);\n            onRelease && onRelease(self, isDragNotClick);\n        }, _onGestureStart = function _onGestureStart(e) {\n            return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);\n        }, _onGestureEnd = function _onGestureEnd() {\n            return (self.isGesturing = false) || onGestureEnd(self);\n        }, onScroll = function onScroll(e) {\n            if (_ignoreCheck(e)) {\n                return;\n            }\n            var x = scrollFuncX(), y = scrollFuncY();\n            onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);\n            scrollX = x;\n            scrollY = y;\n            onStop && onStopDelayedCall.restart(true);\n        }, _onWheel = function _onWheel(e) {\n            if (_ignoreCheck(e)) {\n                return;\n            }\n            e = _getEvent(e, preventDefault);\n            onWheel && (wheeled = true);\n            var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;\n            onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);\n            onStop && !isNormalizer && onStopDelayedCall.restart(true);\n        }, _onMove = function _onMove(e) {\n            if (_ignoreCheck(e)) {\n                return;\n            }\n            var x = e.clientX, y = e.clientY, dx = x - self.x, dy = y - self.y;\n            self.x = x;\n            self.y = y;\n            moved = true;\n            onStop && onStopDelayedCall.restart(true);\n            (dx || dy) && onTouchOrPointerDelta(dx, dy);\n        }, _onHover = function _onHover(e) {\n            self.event = e;\n            onHover(self);\n        }, _onHoverEnd = function _onHoverEnd(e) {\n            self.event = e;\n            onHoverEnd(self);\n        }, _onClick = function _onClick(e) {\n            return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);\n        };\n        onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();\n        self.deltaX = self.deltaY = 0;\n        self._vx = _getVelocityProp(0, 50, true);\n        self._vy = _getVelocityProp(0, 50, true);\n        self.scrollX = scrollFuncX;\n        self.scrollY = scrollFuncY;\n        self.isDragging = self.isGesturing = self.isPressed = false;\n        _context(this);\n        self.enable = function(e) {\n            if (!self.isEnabled) {\n                _addListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n                type.indexOf(\"scroll\") >= 0 && _addListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, passive, capture);\n                type.indexOf(\"wheel\") >= 0 && _addListener(target, \"wheel\", _onWheel, passive, capture);\n                if (type.indexOf(\"touch\") >= 0 && _isTouch || type.indexOf(\"pointer\") >= 0) {\n                    _addListener(target, _eventTypes[0], _onPress, passive, capture);\n                    _addListener(ownerDoc, _eventTypes[2], _onRelease);\n                    _addListener(ownerDoc, _eventTypes[3], _onRelease);\n                    allowClicks && _addListener(target, \"click\", clickCapture, true, true);\n                    onClick && _addListener(target, \"click\", _onClick);\n                    onGestureStart && _addListener(ownerDoc, \"gesturestart\", _onGestureStart);\n                    onGestureEnd && _addListener(ownerDoc, \"gestureend\", _onGestureEnd);\n                    onHover && _addListener(target, _pointerType + \"enter\", _onHover);\n                    onHoverEnd && _addListener(target, _pointerType + \"leave\", _onHoverEnd);\n                    onMove && _addListener(target, _pointerType + \"move\", _onMove);\n                }\n                self.isEnabled = true;\n                e && e.type && _onPress(e);\n                onEnable && onEnable(self);\n            }\n            return self;\n        };\n        self.disable = function() {\n            if (self.isEnabled) {\n                // only remove the _onScroll listener if there aren't any others that rely on the functionality.\n                _observers.filter(function(o) {\n                    return o !== self && _isViewport(o.target);\n                }).length || _removeListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n                if (self.isPressed) {\n                    self._vx.reset();\n                    self._vy.reset();\n                    _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n                }\n                _removeListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, capture);\n                _removeListener(target, \"wheel\", _onWheel, capture);\n                _removeListener(target, _eventTypes[0], _onPress, capture);\n                _removeListener(ownerDoc, _eventTypes[2], _onRelease);\n                _removeListener(ownerDoc, _eventTypes[3], _onRelease);\n                _removeListener(target, \"click\", clickCapture, true);\n                _removeListener(target, \"click\", _onClick);\n                _removeListener(ownerDoc, \"gesturestart\", _onGestureStart);\n                _removeListener(ownerDoc, \"gestureend\", _onGestureEnd);\n                _removeListener(target, _pointerType + \"enter\", _onHover);\n                _removeListener(target, _pointerType + \"leave\", _onHoverEnd);\n                _removeListener(target, _pointerType + \"move\", _onMove);\n                self.isEnabled = self.isPressed = self.isDragging = false;\n                onDisable && onDisable(self);\n            }\n        };\n        self.kill = self.revert = function() {\n            self.disable();\n            var i = _observers.indexOf(self);\n            i >= 0 && _observers.splice(i, 1);\n            _normalizer === self && (_normalizer = 0);\n        };\n        _observers.push(self);\n        isNormalizer && _isViewport(target) && (_normalizer = self);\n        self.enable(event);\n    };\n    _createClass(Observer, [\n        {\n            key: \"velocityX\",\n            get: function get() {\n                return this._vx.getVelocity();\n            }\n        },\n        {\n            key: \"velocityY\",\n            get: function get() {\n                return this._vy.getVelocity();\n            }\n        }\n    ]);\n    return Observer;\n}();\nObserver.version = \"3.12.5\";\nObserver.create = function(vars) {\n    return new Observer(vars);\n};\nObserver.register = _initCore;\nObserver.getAll = function() {\n    return _observers.slice();\n};\nObserver.getById = function(id) {\n    return _observers.filter(function(o) {\n        return o.vars.id === id;\n    })[0];\n};\n_getGSAP() && gsap.registerPlugin(Observer);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9PYnNlcnZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBLGtCQUFrQkMsTUFBTSxFQUFFQyxLQUFLO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELE1BQU1FLE1BQU0sRUFBRUQsSUFBSztRQUFFLElBQUlFLGFBQWFILEtBQUssQ0FBQ0MsRUFBRTtRQUFFRSxXQUFXQyxVQUFVLEdBQUdELFdBQVdDLFVBQVUsSUFBSTtRQUFPRCxXQUFXRSxZQUFZLEdBQUc7UUFBTSxJQUFJLFdBQVdGLFlBQVlBLFdBQVdHLFFBQVEsR0FBRztRQUFNQyxPQUFPQyxjQUFjLENBQUNULFFBQVFJLFdBQVdNLEdBQUcsRUFBRU47SUFBYTtBQUFFO0FBRTVULFNBQVNPLGFBQWFDLFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxXQUFXO0lBQUksSUFBSUQsWUFBWWQsa0JBQWtCYSxZQUFZRyxTQUFTLEVBQUVGO0lBQWEsSUFBSUMsYUFBYWYsa0JBQWtCYSxhQUFhRTtJQUFjLE9BQU9GO0FBQWE7QUFFdE47Ozs7Ozs7O0FBUUEsR0FFQSxrQkFBa0IsR0FDbEIsSUFBSUksTUFDQUMsY0FDQUMsUUFDQUMsTUFDQUMsTUFDQUMsUUFDQUMsT0FDQUMsVUFDQUMsY0FDQUMsZUFDQUMsT0FDQUMsYUFDQUMsYUFDQUMsVUFDQUMsV0FBVyxTQUFTQTtJQUN0QixPQUFPZCxRQUFRLE9BQU9lLFdBQVcsZUFBZ0JmLENBQUFBLE9BQU9lLE9BQU9mLElBQUksS0FBS0EsS0FBS2dCLGNBQWMsSUFBSWhCO0FBQ2pHLEdBQ0lpQixXQUFXLEdBQ1hDLGFBQWEsRUFBRSxFQUNmQyxhQUFhLEVBQUUsRUFDZkMsV0FBVyxFQUFFLEVBQ2JDLFdBQVdDLEtBQUtDLEdBQUcsRUFDbkJDLFVBQVUsU0FBU0EsUUFBUUMsSUFBSSxFQUFFQyxLQUFLO0lBQ3hDLE9B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LEtBQUs7QUFDekI7QUFFQTlJLFNBQVMrSSxPQUFPLEdBQUcsU0FBVTFGLEVBQUU7SUFDN0IsT0FBT3ZLLFdBQVdzUCxNQUFNLENBQUMsU0FBVUMsQ0FBQztRQUNsQyxPQUFPQSxFQUFFM0gsSUFBSSxDQUFDMkMsRUFBRSxLQUFLQTtJQUN2QixFQUFFLENBQUMsRUFBRTtBQUNQO0FBRUEzSyxjQUFjZCxLQUFLZ0IsY0FBYyxDQUFDb0g7QUFDcUgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dzYXBAMy4xMi41L25vZGVfbW9kdWxlcy9nc2FwL09ic2VydmVyLmpzPzQ0NGUiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKiFcbiAqIE9ic2VydmVyIDMuMTIuNVxuICogaHR0cHM6Ly9nc2FwLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjQsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3NhcC5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR1NBUCBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBnc2FwLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfY2xhbXAsXG4gICAgX3dpbixcbiAgICBfZG9jLFxuICAgIF9kb2NFbCxcbiAgICBfYm9keSxcbiAgICBfaXNUb3VjaCxcbiAgICBfcG9pbnRlclR5cGUsXG4gICAgU2Nyb2xsVHJpZ2dlcixcbiAgICBfcm9vdCxcbiAgICBfbm9ybWFsaXplcixcbiAgICBfZXZlbnRUeXBlcyxcbiAgICBfY29udGV4dCxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX3N0YXJ0dXAgPSAxLFxuICAgIF9vYnNlcnZlcnMgPSBbXSxcbiAgICBfc2Nyb2xsZXJzID0gW10sXG4gICAgX3Byb3hpZXMgPSBbXSxcbiAgICBfZ2V0VGltZSA9IERhdGUubm93LFxuICAgIF9icmlkZ2UgPSBmdW5jdGlvbiBfYnJpZGdlKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn0sXG4gICAgX2ludGVncmF0ZSA9IGZ1bmN0aW9uIF9pbnRlZ3JhdGUoKSB7XG4gIHZhciBjb3JlID0gU2Nyb2xsVHJpZ2dlci5jb3JlLFxuICAgICAgZGF0YSA9IGNvcmUuYnJpZGdlIHx8IHt9LFxuICAgICAgc2Nyb2xsZXJzID0gY29yZS5fc2Nyb2xsZXJzLFxuICAgICAgcHJveGllcyA9IGNvcmUuX3Byb3hpZXM7XG4gIHNjcm9sbGVycy5wdXNoLmFwcGx5KHNjcm9sbGVycywgX3Njcm9sbGVycyk7XG4gIHByb3hpZXMucHVzaC5hcHBseShwcm94aWVzLCBfcHJveGllcyk7XG4gIF9zY3JvbGxlcnMgPSBzY3JvbGxlcnM7XG4gIF9wcm94aWVzID0gcHJveGllcztcblxuICBfYnJpZGdlID0gZnVuY3Rpb24gX2JyaWRnZShuYW1lLCB2YWx1ZSkge1xuICAgIHJldHVybiBkYXRhW25hbWVdKHZhbHVlKTtcbiAgfTtcbn0sXG4gICAgX2dldFByb3h5UHJvcCA9IGZ1bmN0aW9uIF9nZXRQcm94eVByb3AoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIH5fcHJveGllcy5pbmRleE9mKGVsZW1lbnQpICYmIF9wcm94aWVzW19wcm94aWVzLmluZGV4T2YoZWxlbWVudCkgKyAxXVtwcm9wZXJ0eV07XG59LFxuICAgIF9pc1ZpZXdwb3J0ID0gZnVuY3Rpb24gX2lzVmlld3BvcnQoZWwpIHtcbiAgcmV0dXJuICEhfl9yb290LmluZGV4T2YoZWwpO1xufSxcbiAgICBfYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBfYWRkTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgZnVuYywgcGFzc2l2ZSwgY2FwdHVyZSkge1xuICByZXR1cm4gZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmMsIHtcbiAgICBwYXNzaXZlOiBwYXNzaXZlICE9PSBmYWxzZSxcbiAgICBjYXB0dXJlOiAhIWNhcHR1cmVcbiAgfSk7XG59LFxuICAgIF9yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIF9yZW1vdmVMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBmdW5jLCBjYXB0dXJlKSB7XG4gIHJldHVybiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZnVuYywgISFjYXB0dXJlKTtcbn0sXG4gICAgX3Njcm9sbExlZnQgPSBcInNjcm9sbExlZnRcIixcbiAgICBfc2Nyb2xsVG9wID0gXCJzY3JvbGxUb3BcIixcbiAgICBfb25TY3JvbGwgPSBmdW5jdGlvbiBfb25TY3JvbGwoKSB7XG4gIHJldHVybiBfbm9ybWFsaXplciAmJiBfbm9ybWFsaXplci5pc1ByZXNzZWQgfHwgX3Njcm9sbGVycy5jYWNoZSsrO1xufSxcbiAgICBfc2Nyb2xsQ2FjaGVGdW5jID0gZnVuY3Rpb24gX3Njcm9sbENhY2hlRnVuYyhmLCBkb05vdENhY2hlKSB7XG4gIHZhciBjYWNoaW5nRnVuYyA9IGZ1bmN0aW9uIGNhY2hpbmdGdW5jKHZhbHVlKSB7XG4gICAgLy8gc2luY2UgcmVhZGluZyB0aGUgc2Nyb2xsVG9wL3Njcm9sbExlZnQvcGFnZU9mZnNldFkvcGFnZU9mZnNldFggY2FuIHRyaWdnZXIgYSBsYXlvdXQsIHRoaXMgZnVuY3Rpb24gYWxsb3dzIHVzIHRvIGNhY2hlIHRoZSB2YWx1ZSBzbyBpdCBvbmx5IGdldHMgcmVhZCBmcmVzaCBhZnRlciBhIFwic2Nyb2xsXCIgZXZlbnQgZmlyZXMgKG9yIHdoaWxlIHdlJ3JlIHJlZnJlc2hpbmcgYmVjYXVzZSB0aGF0IGNhbiBsZW5ndGhlbiB0aGUgcGFnZSBhbmQgYWx0ZXIgdGhlIHNjcm9sbCBwb3NpdGlvbikuIHdoZW4gXCJzb2Z0XCIgaXMgdHJ1ZSwgdGhhdCBtZWFucyBkb24ndCBhY3R1YWxseSBzZXQgdGhlIHNjcm9sbCwgYnV0IGNhY2hlIHRoZSBuZXcgdmFsdWUgaW5zdGVhZCAodXNlZnVsIGluIFNjcm9sbFNtb290aGVyKVxuICAgIGlmICh2YWx1ZSB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgX3N0YXJ0dXAgJiYgKF93aW4uaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCIpOyAvLyBvdGhlcndpc2UgdGhlIG5ldyBwb3NpdGlvbiB3aWxsIGdldCBvdmVyd3JpdHRlbiBieSB0aGUgYnJvd3NlciBvbmxvYWQuXG5cbiAgICAgIHZhciBpc05vcm1hbGl6aW5nID0gX25vcm1hbGl6ZXIgJiYgX25vcm1hbGl6ZXIuaXNQcmVzc2VkO1xuICAgICAgdmFsdWUgPSBjYWNoaW5nRnVuYy52ID0gTWF0aC5yb3VuZCh2YWx1ZSkgfHwgKF9ub3JtYWxpemVyICYmIF9ub3JtYWxpemVyLmlPUyA/IDEgOiAwKTsgLy9UT0RPOiBpT1MgQnVnOiBpZiB5b3UgYWxsb3cgaXQgdG8gZ28gdG8gMCwgU2FmYXJpIGNhbiBzdGFydCB0byByZXBvcnQgc3VwZXIgc3RyYW5nZSAod2lsZGx5IGluYWNjdXJhdGUpIHRvdWNoIHBvc2l0aW9ucyFcblxuICAgICAgZih2YWx1ZSk7XG4gICAgICBjYWNoaW5nRnVuYy5jYWNoZUlEID0gX3Njcm9sbGVycy5jYWNoZTtcbiAgICAgIGlzTm9ybWFsaXppbmcgJiYgX2JyaWRnZShcInNzXCIsIHZhbHVlKTsgLy8gc2V0IHNjcm9sbCAobm90aWZ5IFNjcm9sbFRyaWdnZXIgc28gaXQgY2FuIGRpc3BhdGNoIGEgXCJzY3JvbGxTdGFydFwiIGV2ZW50IGlmIG5lY2Vzc2FyeVxuICAgIH0gZWxzZSBpZiAoZG9Ob3RDYWNoZSB8fCBfc2Nyb2xsZXJzLmNhY2hlICE9PSBjYWNoaW5nRnVuYy5jYWNoZUlEIHx8IF9icmlkZ2UoXCJyZWZcIikpIHtcbiAgICAgIGNhY2hpbmdGdW5jLmNhY2hlSUQgPSBfc2Nyb2xsZXJzLmNhY2hlO1xuICAgICAgY2FjaGluZ0Z1bmMudiA9IGYoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGluZ0Z1bmMudiArIGNhY2hpbmdGdW5jLm9mZnNldDtcbiAgfTtcblxuICBjYWNoaW5nRnVuYy5vZmZzZXQgPSAwO1xuICByZXR1cm4gZiAmJiBjYWNoaW5nRnVuYztcbn0sXG4gICAgX2hvcml6b250YWwgPSB7XG4gIHM6IF9zY3JvbGxMZWZ0LFxuICBwOiBcImxlZnRcIixcbiAgcDI6IFwiTGVmdFwiLFxuICBvczogXCJyaWdodFwiLFxuICBvczI6IFwiUmlnaHRcIixcbiAgZDogXCJ3aWR0aFwiLFxuICBkMjogXCJXaWR0aFwiLFxuICBhOiBcInhcIixcbiAgc2M6IF9zY3JvbGxDYWNoZUZ1bmMoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBfd2luLnNjcm9sbFRvKHZhbHVlLCBfdmVydGljYWwuc2MoKSkgOiBfd2luLnBhZ2VYT2Zmc2V0IHx8IF9kb2NbX3Njcm9sbExlZnRdIHx8IF9kb2NFbFtfc2Nyb2xsTGVmdF0gfHwgX2JvZHlbX3Njcm9sbExlZnRdIHx8IDA7XG4gIH0pXG59LFxuICAgIF92ZXJ0aWNhbCA9IHtcbiAgczogX3Njcm9sbFRvcCxcbiAgcDogXCJ0b3BcIixcbiAgcDI6IFwiVG9wXCIsXG4gIG9zOiBcImJvdHRvbVwiLFxuICBvczI6IFwiQm90dG9tXCIsXG4gIGQ6IFwiaGVpZ2h0XCIsXG4gIGQyOiBcIkhlaWdodFwiLFxuICBhOiBcInlcIixcbiAgb3A6IF9ob3Jpem9udGFsLFxuICBzYzogX3Njcm9sbENhY2hlRnVuYyhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IF93aW4uc2Nyb2xsVG8oX2hvcml6b250YWwuc2MoKSwgdmFsdWUpIDogX3dpbi5wYWdlWU9mZnNldCB8fCBfZG9jW19zY3JvbGxUb3BdIHx8IF9kb2NFbFtfc2Nyb2xsVG9wXSB8fCBfYm9keVtfc2Nyb2xsVG9wXSB8fCAwO1xuICB9KVxufSxcbiAgICBfZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gX2dldFRhcmdldCh0LCBzZWxmKSB7XG4gIHJldHVybiAoc2VsZiAmJiBzZWxmLl9jdHggJiYgc2VsZi5fY3R4LnNlbGVjdG9yIHx8IGdzYXAudXRpbHMudG9BcnJheSkodClbMF0gfHwgKHR5cGVvZiB0ID09PSBcInN0cmluZ1wiICYmIGdzYXAuY29uZmlnKCkubnVsbFRhcmdldFdhcm4gIT09IGZhbHNlID8gY29uc29sZS53YXJuKFwiRWxlbWVudCBub3QgZm91bmQ6XCIsIHQpIDogbnVsbCk7XG59LFxuICAgIF9nZXRTY3JvbGxGdW5jID0gZnVuY3Rpb24gX2dldFNjcm9sbEZ1bmMoZWxlbWVudCwgX3JlZikge1xuICB2YXIgcyA9IF9yZWYucyxcbiAgICAgIHNjID0gX3JlZi5zYztcbiAgLy8gd2Ugc3RvcmUgdGhlIHNjcm9sbGVyIGZ1bmN0aW9ucyBpbiBhbiBhbHRlcm5hdGluZyBzZXF1ZW5jZWQgQXJyYXkgbGlrZSBbZWxlbWVudCwgdmVydGljYWxTY3JvbGxGdW5jLCBob3Jpem9udGFsU2Nyb2xsRnVuYywgLi4uXSBzbyB0aGF0IHdlIGNhbiBtaW5pbWl6ZSBtZW1vcnksIG1heGltaXplIHBlcmZvcm1hbmNlLCBhbmQgd2UgYWxzbyByZWNvcmQgdGhlIGxhc3QgcG9zaXRpb24gYXMgYSBcIi5yZWNcIiBwcm9wZXJ0eSBpbiBvcmRlciB0byByZXZlcnQgdG8gdGhhdCBhZnRlciByZWZyZXNoaW5nIHRvIGVuc3VyZSB0aGluZ3MgZG9uJ3Qgc2hpZnQgYXJvdW5kLlxuICBfaXNWaWV3cG9ydChlbGVtZW50KSAmJiAoZWxlbWVudCA9IF9kb2Muc2Nyb2xsaW5nRWxlbWVudCB8fCBfZG9jRWwpO1xuXG4gIHZhciBpID0gX3Njcm9sbGVycy5pbmRleE9mKGVsZW1lbnQpLFxuICAgICAgb2Zmc2V0ID0gc2MgPT09IF92ZXJ0aWNhbC5zYyA/IDEgOiAyO1xuXG4gICF+aSAmJiAoaSA9IF9zY3JvbGxlcnMucHVzaChlbGVtZW50KSAtIDEpO1xuICBfc2Nyb2xsZXJzW2kgKyBvZmZzZXRdIHx8IF9hZGRMaXN0ZW5lcihlbGVtZW50LCBcInNjcm9sbFwiLCBfb25TY3JvbGwpOyAvLyBjbGVhciB0aGUgY2FjaGUgd2hlbiBhIHNjcm9sbCBvY2N1cnNcblxuICB2YXIgcHJldiA9IF9zY3JvbGxlcnNbaSArIG9mZnNldF0sXG4gICAgICBmdW5jID0gcHJldiB8fCAoX3Njcm9sbGVyc1tpICsgb2Zmc2V0XSA9IF9zY3JvbGxDYWNoZUZ1bmMoX2dldFByb3h5UHJvcChlbGVtZW50LCBzKSwgdHJ1ZSkgfHwgKF9pc1ZpZXdwb3J0KGVsZW1lbnQpID8gc2MgOiBfc2Nyb2xsQ2FjaGVGdW5jKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gZWxlbWVudFtzXSA9IHZhbHVlIDogZWxlbWVudFtzXTtcbiAgfSkpKTtcbiAgZnVuYy50YXJnZXQgPSBlbGVtZW50O1xuICBwcmV2IHx8IChmdW5jLnNtb290aCA9IGdzYXAuZ2V0UHJvcGVydHkoZWxlbWVudCwgXCJzY3JvbGxCZWhhdmlvclwiKSA9PT0gXCJzbW9vdGhcIik7IC8vIG9ubHkgc2V0IGl0IHRoZSBmaXJzdCB0aW1lIChkb24ndCByZXNldCBldmVyeSB0aW1lIGEgc2Nyb2xsRnVuYyBpcyByZXF1ZXN0ZWQgYmVjYXVzZSBwZXJoYXBzIGl0IGhhcHBlbnMgZHVyaW5nIGEgcmVmcmVzaCgpIHdoZW4gaXQncyBkaXNhYmxlZCBpbiBTY3JvbGxUcmlnZ2VyLlxuXG4gIHJldHVybiBmdW5jO1xufSxcbiAgICBfZ2V0VmVsb2NpdHlQcm9wID0gZnVuY3Rpb24gX2dldFZlbG9jaXR5UHJvcCh2YWx1ZSwgbWluVGltZVJlZnJlc2gsIHVzZURlbHRhKSB7XG4gIHZhciB2MSA9IHZhbHVlLFxuICAgICAgdjIgPSB2YWx1ZSxcbiAgICAgIHQxID0gX2dldFRpbWUoKSxcbiAgICAgIHQyID0gdDEsXG4gICAgICBtaW4gPSBtaW5UaW1lUmVmcmVzaCB8fCA1MCxcbiAgICAgIGRyb3BUb1plcm9UaW1lID0gTWF0aC5tYXgoNTAwLCBtaW4gKiAzKSxcbiAgICAgIHVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSwgZm9yY2UpIHtcbiAgICB2YXIgdCA9IF9nZXRUaW1lKCk7XG5cbiAgICBpZiAoZm9yY2UgfHwgdCAtIHQxID4gbWluKSB7XG4gICAgICB2MiA9IHYxO1xuICAgICAgdjEgPSB2YWx1ZTtcbiAgICAgIHQyID0gdDE7XG4gICAgICB0MSA9IHQ7XG4gICAgfSBlbHNlIGlmICh1c2VEZWx0YSkge1xuICAgICAgdjEgKz0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vdCB0b3RhbGx5IG5lY2Vzc2FyeSwgYnV0IG1ha2VzIGl0IGEgYml0IG1vcmUgYWNjdXJhdGUgYnkgYWRqdXN0aW5nIHRoZSB2MSB2YWx1ZSBhY2NvcmRpbmcgdG8gdGhlIG5ldyBzbG9wZS4gVGhpcyB3YXkgd2UncmUgbm90IGp1c3QgaWdub3JpbmcgdGhlIGluY29taW5nIGRhdGEuIFJlbW92aW5nIGZvciBub3cgYmVjYXVzZSBpdCBkb2Vzbid0IHNlZW0gdG8gbWFrZSBtdWNoIHByYWN0aWNhbCBkaWZmZXJlbmNlIGFuZCBpdCdzIHByb2JhYmx5IG5vdCB3b3J0aCB0aGUga2IuXG4gICAgICB2MSA9IHYyICsgKHZhbHVlIC0gdjIpIC8gKHQgLSB0MikgKiAodDEgLSB0Mik7XG4gICAgfVxuICB9LFxuICAgICAgcmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB2MiA9IHYxID0gdXNlRGVsdGEgPyAwIDogdjE7XG4gICAgdDIgPSB0MSA9IDA7XG4gIH0sXG4gICAgICBnZXRWZWxvY2l0eSA9IGZ1bmN0aW9uIGdldFZlbG9jaXR5KGxhdGVzdFZhbHVlKSB7XG4gICAgdmFyIHRPbGQgPSB0MixcbiAgICAgICAgdk9sZCA9IHYyLFxuICAgICAgICB0ID0gX2dldFRpbWUoKTtcblxuICAgIChsYXRlc3RWYWx1ZSB8fCBsYXRlc3RWYWx1ZSA9PT0gMCkgJiYgbGF0ZXN0VmFsdWUgIT09IHYxICYmIHVwZGF0ZShsYXRlc3RWYWx1ZSk7XG4gICAgcmV0dXJuIHQxID09PSB0MiB8fCB0IC0gdDIgPiBkcm9wVG9aZXJvVGltZSA/IDAgOiAodjEgKyAodXNlRGVsdGEgPyB2T2xkIDogLXZPbGQpKSAvICgodXNlRGVsdGEgPyB0IDogdDEpIC0gdE9sZCkgKiAxMDAwO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiB1cGRhdGUsXG4gICAgcmVzZXQ6IHJlc2V0LFxuICAgIGdldFZlbG9jaXR5OiBnZXRWZWxvY2l0eVxuICB9O1xufSxcbiAgICBfZ2V0RXZlbnQgPSBmdW5jdGlvbiBfZ2V0RXZlbnQoZSwgcHJldmVudERlZmF1bHQpIHtcbiAgcHJldmVudERlZmF1bHQgJiYgIWUuX2dzYXBBbGxvdyAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gIHJldHVybiBlLmNoYW5nZWRUb3VjaGVzID8gZS5jaGFuZ2VkVG91Y2hlc1swXSA6IGU7XG59LFxuICAgIF9nZXRBYnNvbHV0ZU1heCA9IGZ1bmN0aW9uIF9nZXRBYnNvbHV0ZU1heChhKSB7XG4gIHZhciBtYXggPSBNYXRoLm1heC5hcHBseShNYXRoLCBhKSxcbiAgICAgIG1pbiA9IE1hdGgubWluLmFwcGx5KE1hdGgsIGEpO1xuICByZXR1cm4gTWF0aC5hYnMobWF4KSA+PSBNYXRoLmFicyhtaW4pID8gbWF4IDogbWluO1xufSxcbiAgICBfc2V0U2Nyb2xsVHJpZ2dlciA9IGZ1bmN0aW9uIF9zZXRTY3JvbGxUcmlnZ2VyKCkge1xuICBTY3JvbGxUcmlnZ2VyID0gZ3NhcC5jb3JlLmdsb2JhbHMoKS5TY3JvbGxUcmlnZ2VyO1xuICBTY3JvbGxUcmlnZ2VyICYmIFNjcm9sbFRyaWdnZXIuY29yZSAmJiBfaW50ZWdyYXRlKCk7XG59LFxuICAgIF9pbml0Q29yZSA9IGZ1bmN0aW9uIF9pbml0Q29yZShjb3JlKSB7XG4gIGdzYXAgPSBjb3JlIHx8IF9nZXRHU0FQKCk7XG5cbiAgaWYgKCFfY29yZUluaXR0ZWQgJiYgZ3NhcCAmJiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgIF93aW4gPSB3aW5kb3c7XG4gICAgX2RvYyA9IGRvY3VtZW50O1xuICAgIF9kb2NFbCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIF9ib2R5ID0gX2RvYy5ib2R5O1xuICAgIF9yb290ID0gW193aW4sIF9kb2MsIF9kb2NFbCwgX2JvZHldO1xuICAgIF9jbGFtcCA9IGdzYXAudXRpbHMuY2xhbXA7XG5cbiAgICBfY29udGV4dCA9IGdzYXAuY29yZS5jb250ZXh0IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgX3BvaW50ZXJUeXBlID0gXCJvbnBvaW50ZXJlbnRlclwiIGluIF9ib2R5ID8gXCJwb2ludGVyXCIgOiBcIm1vdXNlXCI7IC8vIGlzVG91Y2ggaXMgMCBpZiBubyB0b3VjaCwgMSBpZiBPTkxZIHRvdWNoLCBhbmQgMiBpZiBpdCBjYW4gYWNjb21tb2RhdGUgdG91Y2ggYnV0IGFsc28gb3RoZXIgdHlwZXMgbGlrZSBtb3VzZS9wb2ludGVyLlxuXG4gICAgX2lzVG91Y2ggPSBPYnNlcnZlci5pc1RvdWNoID0gX3dpbi5tYXRjaE1lZGlhICYmIF93aW4ubWF0Y2hNZWRpYShcIihob3Zlcjogbm9uZSksIChwb2ludGVyOiBjb2Fyc2UpXCIpLm1hdGNoZXMgPyAxIDogXCJvbnRvdWNoc3RhcnRcIiBpbiBfd2luIHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDAgfHwgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgPiAwID8gMiA6IDA7XG4gICAgX2V2ZW50VHlwZXMgPSBPYnNlcnZlci5ldmVudFR5cGVzID0gKFwib250b3VjaHN0YXJ0XCIgaW4gX2RvY0VsID8gXCJ0b3VjaHN0YXJ0LHRvdWNobW92ZSx0b3VjaGNhbmNlbCx0b3VjaGVuZFwiIDogIShcIm9ucG9pbnRlcmRvd25cIiBpbiBfZG9jRWwpID8gXCJtb3VzZWRvd24sbW91c2Vtb3ZlLG1vdXNldXAsbW91c2V1cFwiIDogXCJwb2ludGVyZG93bixwb2ludGVybW92ZSxwb2ludGVyY2FuY2VsLHBvaW50ZXJ1cFwiKS5zcGxpdChcIixcIik7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3N0YXJ0dXAgPSAwO1xuICAgIH0sIDUwMCk7XG5cbiAgICBfc2V0U2Nyb2xsVHJpZ2dlcigpO1xuXG4gICAgX2NvcmVJbml0dGVkID0gMTtcbiAgfVxuXG4gIHJldHVybiBfY29yZUluaXR0ZWQ7XG59O1xuXG5faG9yaXpvbnRhbC5vcCA9IF92ZXJ0aWNhbDtcbl9zY3JvbGxlcnMuY2FjaGUgPSAwO1xuZXhwb3J0IHZhciBPYnNlcnZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmVyKHZhcnMpIHtcbiAgICB0aGlzLmluaXQodmFycyk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JzZXJ2ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCh2YXJzKSB7XG4gICAgX2NvcmVJbml0dGVkIHx8IF9pbml0Q29yZShnc2FwKSB8fCBjb25zb2xlLndhcm4oXCJQbGVhc2UgZ3NhcC5yZWdpc3RlclBsdWdpbihPYnNlcnZlcilcIik7XG4gICAgU2Nyb2xsVHJpZ2dlciB8fCBfc2V0U2Nyb2xsVHJpZ2dlcigpO1xuICAgIHZhciB0b2xlcmFuY2UgPSB2YXJzLnRvbGVyYW5jZSxcbiAgICAgICAgZHJhZ01pbmltdW0gPSB2YXJzLmRyYWdNaW5pbXVtLFxuICAgICAgICB0eXBlID0gdmFycy50eXBlLFxuICAgICAgICB0YXJnZXQgPSB2YXJzLnRhcmdldCxcbiAgICAgICAgbGluZUhlaWdodCA9IHZhcnMubGluZUhlaWdodCxcbiAgICAgICAgZGVib3VuY2UgPSB2YXJzLmRlYm91bmNlLFxuICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHZhcnMucHJldmVudERlZmF1bHQsXG4gICAgICAgIG9uU3RvcCA9IHZhcnMub25TdG9wLFxuICAgICAgICBvblN0b3BEZWxheSA9IHZhcnMub25TdG9wRGVsYXksXG4gICAgICAgIGlnbm9yZSA9IHZhcnMuaWdub3JlLFxuICAgICAgICB3aGVlbFNwZWVkID0gdmFycy53aGVlbFNwZWVkLFxuICAgICAgICBldmVudCA9IHZhcnMuZXZlbnQsXG4gICAgICAgIG9uRHJhZ1N0YXJ0ID0gdmFycy5vbkRyYWdTdGFydCxcbiAgICAgICAgb25EcmFnRW5kID0gdmFycy5vbkRyYWdFbmQsXG4gICAgICAgIG9uRHJhZyA9IHZhcnMub25EcmFnLFxuICAgICAgICBvblByZXNzID0gdmFycy5vblByZXNzLFxuICAgICAgICBvblJlbGVhc2UgPSB2YXJzLm9uUmVsZWFzZSxcbiAgICAgICAgb25SaWdodCA9IHZhcnMub25SaWdodCxcbiAgICAgICAgb25MZWZ0ID0gdmFycy5vbkxlZnQsXG4gICAgICAgIG9uVXAgPSB2YXJzLm9uVXAsXG4gICAgICAgIG9uRG93biA9IHZhcnMub25Eb3duLFxuICAgICAgICBvbkNoYW5nZVggPSB2YXJzLm9uQ2hhbmdlWCxcbiAgICAgICAgb25DaGFuZ2VZID0gdmFycy5vbkNoYW5nZVksXG4gICAgICAgIG9uQ2hhbmdlID0gdmFycy5vbkNoYW5nZSxcbiAgICAgICAgb25Ub2dnbGVYID0gdmFycy5vblRvZ2dsZVgsXG4gICAgICAgIG9uVG9nZ2xlWSA9IHZhcnMub25Ub2dnbGVZLFxuICAgICAgICBvbkhvdmVyID0gdmFycy5vbkhvdmVyLFxuICAgICAgICBvbkhvdmVyRW5kID0gdmFycy5vbkhvdmVyRW5kLFxuICAgICAgICBvbk1vdmUgPSB2YXJzLm9uTW92ZSxcbiAgICAgICAgaWdub3JlQ2hlY2sgPSB2YXJzLmlnbm9yZUNoZWNrLFxuICAgICAgICBpc05vcm1hbGl6ZXIgPSB2YXJzLmlzTm9ybWFsaXplcixcbiAgICAgICAgb25HZXN0dXJlU3RhcnQgPSB2YXJzLm9uR2VzdHVyZVN0YXJ0LFxuICAgICAgICBvbkdlc3R1cmVFbmQgPSB2YXJzLm9uR2VzdHVyZUVuZCxcbiAgICAgICAgb25XaGVlbCA9IHZhcnMub25XaGVlbCxcbiAgICAgICAgb25FbmFibGUgPSB2YXJzLm9uRW5hYmxlLFxuICAgICAgICBvbkRpc2FibGUgPSB2YXJzLm9uRGlzYWJsZSxcbiAgICAgICAgb25DbGljayA9IHZhcnMub25DbGljayxcbiAgICAgICAgc2Nyb2xsU3BlZWQgPSB2YXJzLnNjcm9sbFNwZWVkLFxuICAgICAgICBjYXB0dXJlID0gdmFycy5jYXB0dXJlLFxuICAgICAgICBhbGxvd0NsaWNrcyA9IHZhcnMuYWxsb3dDbGlja3MsXG4gICAgICAgIGxvY2tBeGlzID0gdmFycy5sb2NrQXhpcyxcbiAgICAgICAgb25Mb2NrQXhpcyA9IHZhcnMub25Mb2NrQXhpcztcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldCA9IF9nZXRUYXJnZXQodGFyZ2V0KSB8fCBfZG9jRWw7XG4gICAgdGhpcy52YXJzID0gdmFycztcbiAgICBpZ25vcmUgJiYgKGlnbm9yZSA9IGdzYXAudXRpbHMudG9BcnJheShpZ25vcmUpKTtcbiAgICB0b2xlcmFuY2UgPSB0b2xlcmFuY2UgfHwgMWUtOTtcbiAgICBkcmFnTWluaW11bSA9IGRyYWdNaW5pbXVtIHx8IDA7XG4gICAgd2hlZWxTcGVlZCA9IHdoZWVsU3BlZWQgfHwgMTtcbiAgICBzY3JvbGxTcGVlZCA9IHNjcm9sbFNwZWVkIHx8IDE7XG4gICAgdHlwZSA9IHR5cGUgfHwgXCJ3aGVlbCx0b3VjaCxwb2ludGVyXCI7XG4gICAgZGVib3VuY2UgPSBkZWJvdW5jZSAhPT0gZmFsc2U7XG4gICAgbGluZUhlaWdodCB8fCAobGluZUhlaWdodCA9IHBhcnNlRmxvYXQoX3dpbi5nZXRDb21wdXRlZFN0eWxlKF9ib2R5KS5saW5lSGVpZ2h0KSB8fCAyMik7IC8vIG5vdGU6IGJyb3dzZXIgbWF5IHJlcG9ydCBcIm5vcm1hbFwiLCBzbyBkZWZhdWx0IHRvIDIyLlxuXG4gICAgdmFyIGlkLFxuICAgICAgICBvblN0b3BEZWxheWVkQ2FsbCxcbiAgICAgICAgZHJhZ2dlZCxcbiAgICAgICAgbW92ZWQsXG4gICAgICAgIHdoZWVsZWQsXG4gICAgICAgIGxvY2tlZCxcbiAgICAgICAgYXhpcyxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIHByZXZEZWx0YVggPSAwLFxuICAgICAgICBwcmV2RGVsdGFZID0gMCxcbiAgICAgICAgcGFzc2l2ZSA9IHZhcnMucGFzc2l2ZSB8fCAhcHJldmVudERlZmF1bHQsXG4gICAgICAgIHNjcm9sbEZ1bmNYID0gX2dldFNjcm9sbEZ1bmModGFyZ2V0LCBfaG9yaXpvbnRhbCksXG4gICAgICAgIHNjcm9sbEZ1bmNZID0gX2dldFNjcm9sbEZ1bmModGFyZ2V0LCBfdmVydGljYWwpLFxuICAgICAgICBzY3JvbGxYID0gc2Nyb2xsRnVuY1goKSxcbiAgICAgICAgc2Nyb2xsWSA9IHNjcm9sbEZ1bmNZKCksXG4gICAgICAgIGxpbWl0VG9Ub3VjaCA9IH50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSAmJiAhfnR5cGUuaW5kZXhPZihcInBvaW50ZXJcIikgJiYgX2V2ZW50VHlwZXNbMF0gPT09IFwicG9pbnRlcmRvd25cIixcbiAgICAgICAgLy8gZm9yIGRldmljZXMgdGhhdCBhY2NvbW1vZGF0ZSBtb3VzZSBldmVudHMgYW5kIHRvdWNoIGV2ZW50cywgd2UgbmVlZCB0byBkaXN0aW5ndWlzaC5cbiAgICBpc1ZpZXdwb3J0ID0gX2lzVmlld3BvcnQodGFyZ2V0KSxcbiAgICAgICAgb3duZXJEb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudCB8fCBfZG9jLFxuICAgICAgICBkZWx0YVggPSBbMCwgMCwgMF0sXG4gICAgICAgIC8vIHdoZWVsLCBzY3JvbGwsIHBvaW50ZXIvdG91Y2hcbiAgICBkZWx0YVkgPSBbMCwgMCwgMF0sXG4gICAgICAgIG9uQ2xpY2tUaW1lID0gMCxcbiAgICAgICAgY2xpY2tDYXB0dXJlID0gZnVuY3Rpb24gY2xpY2tDYXB0dXJlKCkge1xuICAgICAgcmV0dXJuIG9uQ2xpY2tUaW1lID0gX2dldFRpbWUoKTtcbiAgICB9LFxuICAgICAgICBfaWdub3JlQ2hlY2sgPSBmdW5jdGlvbiBfaWdub3JlQ2hlY2soZSwgaXNQb2ludGVyT3JUb3VjaCkge1xuICAgICAgcmV0dXJuIChzZWxmLmV2ZW50ID0gZSkgJiYgaWdub3JlICYmIH5pZ25vcmUuaW5kZXhPZihlLnRhcmdldCkgfHwgaXNQb2ludGVyT3JUb3VjaCAmJiBsaW1pdFRvVG91Y2ggJiYgZS5wb2ludGVyVHlwZSAhPT0gXCJ0b3VjaFwiIHx8IGlnbm9yZUNoZWNrICYmIGlnbm9yZUNoZWNrKGUsIGlzUG9pbnRlck9yVG91Y2gpO1xuICAgIH0sXG4gICAgICAgIG9uU3RvcEZ1bmMgPSBmdW5jdGlvbiBvblN0b3BGdW5jKCkge1xuICAgICAgc2VsZi5fdngucmVzZXQoKTtcblxuICAgICAgc2VsZi5fdnkucmVzZXQoKTtcblxuICAgICAgb25TdG9wRGVsYXllZENhbGwucGF1c2UoKTtcbiAgICAgIG9uU3RvcCAmJiBvblN0b3Aoc2VsZik7XG4gICAgfSxcbiAgICAgICAgdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdmFyIGR4ID0gc2VsZi5kZWx0YVggPSBfZ2V0QWJzb2x1dGVNYXgoZGVsdGFYKSxcbiAgICAgICAgICBkeSA9IHNlbGYuZGVsdGFZID0gX2dldEFic29sdXRlTWF4KGRlbHRhWSksXG4gICAgICAgICAgY2hhbmdlZFggPSBNYXRoLmFicyhkeCkgPj0gdG9sZXJhbmNlLFxuICAgICAgICAgIGNoYW5nZWRZID0gTWF0aC5hYnMoZHkpID49IHRvbGVyYW5jZTtcblxuICAgICAgb25DaGFuZ2UgJiYgKGNoYW5nZWRYIHx8IGNoYW5nZWRZKSAmJiBvbkNoYW5nZShzZWxmLCBkeCwgZHksIGRlbHRhWCwgZGVsdGFZKTsgLy8gaW4gU2Nyb2xsVHJpZ2dlci5ub3JtYWxpemVTY3JvbGwoKSwgd2UgbmVlZCB0byBrbm93IGlmIGl0IHdhcyB0b3VjaC9wb2ludGVyIHNvIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBkZWx0YVgvZGVsdGFZIEFycmF5cyBiZWZvcmUgd2UgY2xlYXIgdGhlbSBvdXQuXG5cbiAgICAgIGlmIChjaGFuZ2VkWCkge1xuICAgICAgICBvblJpZ2h0ICYmIHNlbGYuZGVsdGFYID4gMCAmJiBvblJpZ2h0KHNlbGYpO1xuICAgICAgICBvbkxlZnQgJiYgc2VsZi5kZWx0YVggPCAwICYmIG9uTGVmdChzZWxmKTtcbiAgICAgICAgb25DaGFuZ2VYICYmIG9uQ2hhbmdlWChzZWxmKTtcbiAgICAgICAgb25Ub2dnbGVYICYmIHNlbGYuZGVsdGFYIDwgMCAhPT0gcHJldkRlbHRhWCA8IDAgJiYgb25Ub2dnbGVYKHNlbGYpO1xuICAgICAgICBwcmV2RGVsdGFYID0gc2VsZi5kZWx0YVg7XG4gICAgICAgIGRlbHRhWFswXSA9IGRlbHRhWFsxXSA9IGRlbHRhWFsyXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VkWSkge1xuICAgICAgICBvbkRvd24gJiYgc2VsZi5kZWx0YVkgPiAwICYmIG9uRG93bihzZWxmKTtcbiAgICAgICAgb25VcCAmJiBzZWxmLmRlbHRhWSA8IDAgJiYgb25VcChzZWxmKTtcbiAgICAgICAgb25DaGFuZ2VZICYmIG9uQ2hhbmdlWShzZWxmKTtcbiAgICAgICAgb25Ub2dnbGVZICYmIHNlbGYuZGVsdGFZIDwgMCAhPT0gcHJldkRlbHRhWSA8IDAgJiYgb25Ub2dnbGVZKHNlbGYpO1xuICAgICAgICBwcmV2RGVsdGFZID0gc2VsZi5kZWx0YVk7XG4gICAgICAgIGRlbHRhWVswXSA9IGRlbHRhWVsxXSA9IGRlbHRhWVsyXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb3ZlZCB8fCBkcmFnZ2VkKSB7XG4gICAgICAgIG9uTW92ZSAmJiBvbk1vdmUoc2VsZik7XG5cbiAgICAgICAgaWYgKGRyYWdnZWQpIHtcbiAgICAgICAgICBvbkRyYWcoc2VsZik7XG4gICAgICAgICAgZHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbW92ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbG9ja2VkICYmICEobG9ja2VkID0gZmFsc2UpICYmIG9uTG9ja0F4aXMgJiYgb25Mb2NrQXhpcyhzZWxmKTtcblxuICAgICAgaWYgKHdoZWVsZWQpIHtcbiAgICAgICAgb25XaGVlbChzZWxmKTtcbiAgICAgICAgd2hlZWxlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZCA9IDA7XG4gICAgfSxcbiAgICAgICAgb25EZWx0YSA9IGZ1bmN0aW9uIG9uRGVsdGEoeCwgeSwgaW5kZXgpIHtcbiAgICAgIGRlbHRhWFtpbmRleF0gKz0geDtcbiAgICAgIGRlbHRhWVtpbmRleF0gKz0geTtcblxuICAgICAgc2VsZi5fdngudXBkYXRlKHgpO1xuXG4gICAgICBzZWxmLl92eS51cGRhdGUoeSk7XG5cbiAgICAgIGRlYm91bmNlID8gaWQgfHwgKGlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZSkpIDogdXBkYXRlKCk7XG4gICAgfSxcbiAgICAgICAgb25Ub3VjaE9yUG9pbnRlckRlbHRhID0gZnVuY3Rpb24gb25Ub3VjaE9yUG9pbnRlckRlbHRhKHgsIHkpIHtcbiAgICAgIGlmIChsb2NrQXhpcyAmJiAhYXhpcykge1xuICAgICAgICBzZWxmLmF4aXMgPSBheGlzID0gTWF0aC5hYnMoeCkgPiBNYXRoLmFicyh5KSA/IFwieFwiIDogXCJ5XCI7XG4gICAgICAgIGxvY2tlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChheGlzICE9PSBcInlcIikge1xuICAgICAgICBkZWx0YVhbMl0gKz0geDtcblxuICAgICAgICBzZWxmLl92eC51cGRhdGUoeCwgdHJ1ZSk7IC8vIHVwZGF0ZSB0aGUgdmVsb2NpdHkgYXMgZnJlcXVlbnRseSBhcyBwb3NzaWJsZSBpbnN0ZWFkIG9mIGluIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gc28gdGhhdCB2ZXJ5IHF1aWNrIHRvdWNoLXNjcm9sbHMgKGZsaWNrcykgZmVlbCBuYXR1cmFsLiBJZiBpdCdzIHRoZSBtb3VzZS90b3VjaC9wb2ludGVyLCBmb3JjZSBpdCBzbyB0aGF0IHdlIGdldCBzbmFwcHkvYWNjdXJhdGUgbW9tZW50dW0gc2Nyb2xsLlxuXG4gICAgICB9XG5cbiAgICAgIGlmIChheGlzICE9PSBcInhcIikge1xuICAgICAgICBkZWx0YVlbMl0gKz0geTtcblxuICAgICAgICBzZWxmLl92eS51cGRhdGUoeSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGRlYm91bmNlID8gaWQgfHwgKGlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZSkpIDogdXBkYXRlKCk7XG4gICAgfSxcbiAgICAgICAgX29uRHJhZyA9IGZ1bmN0aW9uIF9vbkRyYWcoZSkge1xuICAgICAgaWYgKF9pZ25vcmVDaGVjayhlLCAxKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGUgPSBfZ2V0RXZlbnQoZSwgcHJldmVudERlZmF1bHQpO1xuICAgICAgdmFyIHggPSBlLmNsaWVudFgsXG4gICAgICAgICAgeSA9IGUuY2xpZW50WSxcbiAgICAgICAgICBkeCA9IHggLSBzZWxmLngsXG4gICAgICAgICAgZHkgPSB5IC0gc2VsZi55LFxuICAgICAgICAgIGlzRHJhZ2dpbmcgPSBzZWxmLmlzRHJhZ2dpbmc7XG4gICAgICBzZWxmLnggPSB4O1xuICAgICAgc2VsZi55ID0geTtcblxuICAgICAgaWYgKGlzRHJhZ2dpbmcgfHwgTWF0aC5hYnMoc2VsZi5zdGFydFggLSB4KSA+PSBkcmFnTWluaW11bSB8fCBNYXRoLmFicyhzZWxmLnN0YXJ0WSAtIHkpID49IGRyYWdNaW5pbXVtKSB7XG4gICAgICAgIG9uRHJhZyAmJiAoZHJhZ2dlZCA9IHRydWUpO1xuICAgICAgICBpc0RyYWdnaW5nIHx8IChzZWxmLmlzRHJhZ2dpbmcgPSB0cnVlKTtcbiAgICAgICAgb25Ub3VjaE9yUG9pbnRlckRlbHRhKGR4LCBkeSk7XG4gICAgICAgIGlzRHJhZ2dpbmcgfHwgb25EcmFnU3RhcnQgJiYgb25EcmFnU3RhcnQoc2VsZik7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgX29uUHJlc3MgPSBzZWxmLm9uUHJlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKF9pZ25vcmVDaGVjayhlLCAxKSB8fCBlICYmIGUuYnV0dG9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5heGlzID0gYXhpcyA9IG51bGw7XG4gICAgICBvblN0b3BEZWxheWVkQ2FsbC5wYXVzZSgpO1xuICAgICAgc2VsZi5pc1ByZXNzZWQgPSB0cnVlO1xuICAgICAgZSA9IF9nZXRFdmVudChlKTsgLy8gbm90ZTogbWF5IG5lZWQgdG8gcHJldmVudERlZmF1bHQoPykgV29uJ3Qgc2lkZS1zY3JvbGwgb24gaU9TIFNhZmFyaSBpZiB3ZSBkbywgdGhvdWdoLlxuXG4gICAgICBwcmV2RGVsdGFYID0gcHJldkRlbHRhWSA9IDA7XG4gICAgICBzZWxmLnN0YXJ0WCA9IHNlbGYueCA9IGUuY2xpZW50WDtcbiAgICAgIHNlbGYuc3RhcnRZID0gc2VsZi55ID0gZS5jbGllbnRZO1xuXG4gICAgICBzZWxmLl92eC5yZXNldCgpOyAvLyBvdGhlcndpc2UgdGhlIHQyIG1heSBiZSBzdGFsZSBpZiB0aGUgdXNlciB0b3VjaGVzIGFuZCBmbGlja3Mgc3VwZXIgZmFzdCBhbmQgcmVsZWFzZXMgaW4gbGVzcyB0aGFuIDIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRpY2tzLCBjYXVzaW5nIHZlbG9jaXR5IHRvIGJlIDAuXG5cblxuICAgICAgc2VsZi5fdnkucmVzZXQoKTtcblxuICAgICAgX2FkZExpc3RlbmVyKGlzTm9ybWFsaXplciA/IHRhcmdldCA6IG93bmVyRG9jLCBfZXZlbnRUeXBlc1sxXSwgX29uRHJhZywgcGFzc2l2ZSwgdHJ1ZSk7XG5cbiAgICAgIHNlbGYuZGVsdGFYID0gc2VsZi5kZWx0YVkgPSAwO1xuICAgICAgb25QcmVzcyAmJiBvblByZXNzKHNlbGYpO1xuICAgIH0sXG4gICAgICAgIF9vblJlbGVhc2UgPSBzZWxmLm9uUmVsZWFzZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoX2lnbm9yZUNoZWNrKGUsIDEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3JlbW92ZUxpc3RlbmVyKGlzTm9ybWFsaXplciA/IHRhcmdldCA6IG93bmVyRG9jLCBfZXZlbnRUeXBlc1sxXSwgX29uRHJhZywgdHJ1ZSk7XG5cbiAgICAgIHZhciBpc1RyYWNraW5nRHJhZyA9ICFpc05hTihzZWxmLnkgLSBzZWxmLnN0YXJ0WSksXG4gICAgICAgICAgd2FzRHJhZ2dpbmcgPSBzZWxmLmlzRHJhZ2dpbmcsXG4gICAgICAgICAgaXNEcmFnTm90Q2xpY2sgPSB3YXNEcmFnZ2luZyAmJiAoTWF0aC5hYnMoc2VsZi54IC0gc2VsZi5zdGFydFgpID4gMyB8fCBNYXRoLmFicyhzZWxmLnkgLSBzZWxmLnN0YXJ0WSkgPiAzKSxcbiAgICAgICAgICAvLyBzb21lIHRvdWNoIGRldmljZXMgbmVlZCBzb21lIHdpZ2dsZSByb29tIGluIHRlcm1zIG9mIHNlbnNpbmcgY2xpY2tzIC0gdGhlIGZpbmdlciBtYXkgbW92ZSBhIGZldyBwaXhlbHMuXG4gICAgICBldmVudERhdGEgPSBfZ2V0RXZlbnQoZSk7XG5cbiAgICAgIGlmICghaXNEcmFnTm90Q2xpY2sgJiYgaXNUcmFja2luZ0RyYWcpIHtcbiAgICAgICAgc2VsZi5fdngucmVzZXQoKTtcblxuICAgICAgICBzZWxmLl92eS5yZXNldCgpOyAvL2lmIChwcmV2ZW50RGVmYXVsdCAmJiBhbGxvd0NsaWNrcyAmJiBzZWxmLmlzUHJlc3NlZCkgeyAvLyBjaGVjayBpc1ByZXNzZWQgYmVjYXVzZSBpbiBhIHJhcmUgZWRnZSBjYXNlLCB0aGUgaW5wdXRPYnNlcnZlciBpbiBTY3JvbGxUcmlnZ2VyIG1heSBzdG9wUHJvcGFnYXRpb24oKSBvbiB0aGUgcHJlc3MvZHJhZywgc28gdGhlIG9uUmVsZWFzZSBtYXkgZ2V0IGZpcmVkIHdpdGhvdXQgdGhlIG9uUHJlc3Mvb25EcmFnIGV2ZXIgZ2V0dGluZyBjYWxsZWQsIHRodXMgaXQgY291bGQgdHJpZ2dlciBhIGNsaWNrIHRvIG9jY3VyIG9uIGEgbGluayBhZnRlciBzY3JvbGwtZHJhZ2dpbmcgaXQuXG5cblxuICAgICAgICBpZiAocHJldmVudERlZmF1bHQgJiYgYWxsb3dDbGlja3MpIHtcbiAgICAgICAgICBnc2FwLmRlbGF5ZWRDYWxsKDAuMDgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHNvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgd29uJ3QgdHJ1c3Qgc2NyaXB0LWdlbmVyYXRlZCBjbGlja3MsIHNvIGlmIHRoZSB1c2VyIHRyaWVzIHRvIGNsaWNrIG9uIGEgdmlkZW8gdG8gcGxheSBpdCwgZm9yIGV4YW1wbGUsIGl0IHNpbXBseSB3b24ndCB3b3JrLiBTaW5jZSBhIHJlZ3VsYXIgXCJjbGlja1wiIGV2ZW50IHdpbGwgbW9zdCBsaWtlbHkgYmUgZ2VuZXJhdGVkIGFueXdheSAob25lIHRoYXQgaGFzIGl0cyBpc1RydXN0ZWQgZmxhZyBzZXQgdG8gdHJ1ZSksIHdlIG11c3Qgc2xpZ2h0bHkgZGVsYXkgb3VyIHNjcmlwdC1nZW5lcmF0ZWQgY2xpY2sgc28gdGhhdCB0aGUgXCJyZWFsXCIvdHJ1c3RlZCBvbmUgaXMgcHJpb3JpdGl6ZWQuIFJlbWVtYmVyLCB3aGVuIHRoZXJlIGFyZSBkdXBsaWNhdGUgZXZlbnRzIGluIHF1aWNrIHN1Y2Nlc3Npb24sIHdlIHN1cHByZXNzIGFsbCBidXQgdGhlIGZpcnN0IG9uZS4gU29tZSBicm93c2VycyBkb24ndCBldmVuIHRyaWdnZXIgdGhlIFwicmVhbFwiIG9uZSBhdCBhbGwsIHNvIG91ciBzeW50aGV0aWMgb25lIGlzIGEgc2FmZXR5IHZhbHZlIHRoYXQgZW5zdXJlcyB0aGF0IG5vIG1hdHRlciB3aGF0LCBhIGNsaWNrIGV2ZW50IGRvZXMgZ2V0IGRpc3BhdGNoZWQuXG4gICAgICAgICAgICBpZiAoX2dldFRpbWUoKSAtIG9uQ2xpY2tUaW1lID4gMzAwICYmICFlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0LmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgLy9zb21lIGJyb3dzZXJzIChsaWtlIG1vYmlsZSBTYWZhcmkpIGRvbid0IHByb3Blcmx5IHRyaWdnZXIgdGhlIGNsaWNrIGV2ZW50XG4gICAgICAgICAgICAgICAgZS50YXJnZXQuY2xpY2soKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChvd25lckRvYy5jcmVhdGVFdmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBzeW50aGV0aWNFdmVudCA9IG93bmVyRG9jLmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7XG4gICAgICAgICAgICAgICAgc3ludGhldGljRXZlbnQuaW5pdE1vdXNlRXZlbnQoXCJjbGlja1wiLCB0cnVlLCB0cnVlLCBfd2luLCAxLCBldmVudERhdGEuc2NyZWVuWCwgZXZlbnREYXRhLnNjcmVlblksIGV2ZW50RGF0YS5jbGllbnRYLCBldmVudERhdGEuY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgICAgICAgIGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc3ludGhldGljRXZlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi5pc0RyYWdnaW5nID0gc2VsZi5pc0dlc3R1cmluZyA9IHNlbGYuaXNQcmVzc2VkID0gZmFsc2U7XG4gICAgICBvblN0b3AgJiYgd2FzRHJhZ2dpbmcgJiYgIWlzTm9ybWFsaXplciAmJiBvblN0b3BEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpO1xuICAgICAgb25EcmFnRW5kICYmIHdhc0RyYWdnaW5nICYmIG9uRHJhZ0VuZChzZWxmKTtcbiAgICAgIG9uUmVsZWFzZSAmJiBvblJlbGVhc2Uoc2VsZiwgaXNEcmFnTm90Q2xpY2spO1xuICAgIH0sXG4gICAgICAgIF9vbkdlc3R1cmVTdGFydCA9IGZ1bmN0aW9uIF9vbkdlc3R1cmVTdGFydChlKSB7XG4gICAgICByZXR1cm4gZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxICYmIChzZWxmLmlzR2VzdHVyaW5nID0gdHJ1ZSkgJiYgb25HZXN0dXJlU3RhcnQoZSwgc2VsZi5pc0RyYWdnaW5nKTtcbiAgICB9LFxuICAgICAgICBfb25HZXN0dXJlRW5kID0gZnVuY3Rpb24gX29uR2VzdHVyZUVuZCgpIHtcbiAgICAgIHJldHVybiAoc2VsZi5pc0dlc3R1cmluZyA9IGZhbHNlKSB8fCBvbkdlc3R1cmVFbmQoc2VsZik7XG4gICAgfSxcbiAgICAgICAgb25TY3JvbGwgPSBmdW5jdGlvbiBvblNjcm9sbChlKSB7XG4gICAgICBpZiAoX2lnbm9yZUNoZWNrKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHggPSBzY3JvbGxGdW5jWCgpLFxuICAgICAgICAgIHkgPSBzY3JvbGxGdW5jWSgpO1xuICAgICAgb25EZWx0YSgoeCAtIHNjcm9sbFgpICogc2Nyb2xsU3BlZWQsICh5IC0gc2Nyb2xsWSkgKiBzY3JvbGxTcGVlZCwgMSk7XG4gICAgICBzY3JvbGxYID0geDtcbiAgICAgIHNjcm9sbFkgPSB5O1xuICAgICAgb25TdG9wICYmIG9uU3RvcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgfSxcbiAgICAgICAgX29uV2hlZWwgPSBmdW5jdGlvbiBfb25XaGVlbChlKSB7XG4gICAgICBpZiAoX2lnbm9yZUNoZWNrKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZSA9IF9nZXRFdmVudChlLCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgICBvbldoZWVsICYmICh3aGVlbGVkID0gdHJ1ZSk7XG4gICAgICB2YXIgbXVsdGlwbGllciA9IChlLmRlbHRhTW9kZSA9PT0gMSA/IGxpbmVIZWlnaHQgOiBlLmRlbHRhTW9kZSA9PT0gMiA/IF93aW4uaW5uZXJIZWlnaHQgOiAxKSAqIHdoZWVsU3BlZWQ7XG4gICAgICBvbkRlbHRhKGUuZGVsdGFYICogbXVsdGlwbGllciwgZS5kZWx0YVkgKiBtdWx0aXBsaWVyLCAwKTtcbiAgICAgIG9uU3RvcCAmJiAhaXNOb3JtYWxpemVyICYmIG9uU3RvcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgfSxcbiAgICAgICAgX29uTW92ZSA9IGZ1bmN0aW9uIF9vbk1vdmUoZSkge1xuICAgICAgaWYgKF9pZ25vcmVDaGVjayhlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB4ID0gZS5jbGllbnRYLFxuICAgICAgICAgIHkgPSBlLmNsaWVudFksXG4gICAgICAgICAgZHggPSB4IC0gc2VsZi54LFxuICAgICAgICAgIGR5ID0geSAtIHNlbGYueTtcbiAgICAgIHNlbGYueCA9IHg7XG4gICAgICBzZWxmLnkgPSB5O1xuICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgb25TdG9wICYmIG9uU3RvcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgICAoZHggfHwgZHkpICYmIG9uVG91Y2hPclBvaW50ZXJEZWx0YShkeCwgZHkpO1xuICAgIH0sXG4gICAgICAgIF9vbkhvdmVyID0gZnVuY3Rpb24gX29uSG92ZXIoZSkge1xuICAgICAgc2VsZi5ldmVudCA9IGU7XG4gICAgICBvbkhvdmVyKHNlbGYpO1xuICAgIH0sXG4gICAgICAgIF9vbkhvdmVyRW5kID0gZnVuY3Rpb24gX29uSG92ZXJFbmQoZSkge1xuICAgICAgc2VsZi5ldmVudCA9IGU7XG4gICAgICBvbkhvdmVyRW5kKHNlbGYpO1xuICAgIH0sXG4gICAgICAgIF9vbkNsaWNrID0gZnVuY3Rpb24gX29uQ2xpY2soZSkge1xuICAgICAgcmV0dXJuIF9pZ25vcmVDaGVjayhlKSB8fCBfZ2V0RXZlbnQoZSwgcHJldmVudERlZmF1bHQpICYmIG9uQ2xpY2soc2VsZik7XG4gICAgfTtcblxuICAgIG9uU3RvcERlbGF5ZWRDYWxsID0gc2VsZi5fZGMgPSBnc2FwLmRlbGF5ZWRDYWxsKG9uU3RvcERlbGF5IHx8IDAuMjUsIG9uU3RvcEZ1bmMpLnBhdXNlKCk7XG4gICAgc2VsZi5kZWx0YVggPSBzZWxmLmRlbHRhWSA9IDA7XG4gICAgc2VsZi5fdnggPSBfZ2V0VmVsb2NpdHlQcm9wKDAsIDUwLCB0cnVlKTtcbiAgICBzZWxmLl92eSA9IF9nZXRWZWxvY2l0eVByb3AoMCwgNTAsIHRydWUpO1xuICAgIHNlbGYuc2Nyb2xsWCA9IHNjcm9sbEZ1bmNYO1xuICAgIHNlbGYuc2Nyb2xsWSA9IHNjcm9sbEZ1bmNZO1xuICAgIHNlbGYuaXNEcmFnZ2luZyA9IHNlbGYuaXNHZXN0dXJpbmcgPSBzZWxmLmlzUHJlc3NlZCA9IGZhbHNlO1xuXG4gICAgX2NvbnRleHQodGhpcyk7XG5cbiAgICBzZWxmLmVuYWJsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIXNlbGYuaXNFbmFibGVkKSB7XG4gICAgICAgIF9hZGRMaXN0ZW5lcihpc1ZpZXdwb3J0ID8gb3duZXJEb2MgOiB0YXJnZXQsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG5cbiAgICAgICAgdHlwZS5pbmRleE9mKFwic2Nyb2xsXCIpID49IDAgJiYgX2FkZExpc3RlbmVyKGlzVmlld3BvcnQgPyBvd25lckRvYyA6IHRhcmdldCwgXCJzY3JvbGxcIiwgb25TY3JvbGwsIHBhc3NpdmUsIGNhcHR1cmUpO1xuICAgICAgICB0eXBlLmluZGV4T2YoXCJ3aGVlbFwiKSA+PSAwICYmIF9hZGRMaXN0ZW5lcih0YXJnZXQsIFwid2hlZWxcIiwgX29uV2hlZWwsIHBhc3NpdmUsIGNhcHR1cmUpO1xuXG4gICAgICAgIGlmICh0eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSA+PSAwICYmIF9pc1RvdWNoIHx8IHR5cGUuaW5kZXhPZihcInBvaW50ZXJcIikgPj0gMCkge1xuICAgICAgICAgIF9hZGRMaXN0ZW5lcih0YXJnZXQsIF9ldmVudFR5cGVzWzBdLCBfb25QcmVzcywgcGFzc2l2ZSwgY2FwdHVyZSk7XG5cbiAgICAgICAgICBfYWRkTGlzdGVuZXIob3duZXJEb2MsIF9ldmVudFR5cGVzWzJdLCBfb25SZWxlYXNlKTtcblxuICAgICAgICAgIF9hZGRMaXN0ZW5lcihvd25lckRvYywgX2V2ZW50VHlwZXNbM10sIF9vblJlbGVhc2UpO1xuXG4gICAgICAgICAgYWxsb3dDbGlja3MgJiYgX2FkZExpc3RlbmVyKHRhcmdldCwgXCJjbGlja1wiLCBjbGlja0NhcHR1cmUsIHRydWUsIHRydWUpO1xuICAgICAgICAgIG9uQ2xpY2sgJiYgX2FkZExpc3RlbmVyKHRhcmdldCwgXCJjbGlja1wiLCBfb25DbGljayk7XG4gICAgICAgICAgb25HZXN0dXJlU3RhcnQgJiYgX2FkZExpc3RlbmVyKG93bmVyRG9jLCBcImdlc3R1cmVzdGFydFwiLCBfb25HZXN0dXJlU3RhcnQpO1xuICAgICAgICAgIG9uR2VzdHVyZUVuZCAmJiBfYWRkTGlzdGVuZXIob3duZXJEb2MsIFwiZ2VzdHVyZWVuZFwiLCBfb25HZXN0dXJlRW5kKTtcbiAgICAgICAgICBvbkhvdmVyICYmIF9hZGRMaXN0ZW5lcih0YXJnZXQsIF9wb2ludGVyVHlwZSArIFwiZW50ZXJcIiwgX29uSG92ZXIpO1xuICAgICAgICAgIG9uSG92ZXJFbmQgJiYgX2FkZExpc3RlbmVyKHRhcmdldCwgX3BvaW50ZXJUeXBlICsgXCJsZWF2ZVwiLCBfb25Ib3ZlckVuZCk7XG4gICAgICAgICAgb25Nb3ZlICYmIF9hZGRMaXN0ZW5lcih0YXJnZXQsIF9wb2ludGVyVHlwZSArIFwibW92ZVwiLCBfb25Nb3ZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgZSAmJiBlLnR5cGUgJiYgX29uUHJlc3MoZSk7XG4gICAgICAgIG9uRW5hYmxlICYmIG9uRW5hYmxlKHNlbGYpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgc2VsZi5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaXNFbmFibGVkKSB7XG4gICAgICAgIC8vIG9ubHkgcmVtb3ZlIHRoZSBfb25TY3JvbGwgbGlzdGVuZXIgaWYgdGhlcmUgYXJlbid0IGFueSBvdGhlcnMgdGhhdCByZWx5IG9uIHRoZSBmdW5jdGlvbmFsaXR5LlxuICAgICAgICBfb2JzZXJ2ZXJzLmZpbHRlcihmdW5jdGlvbiAobykge1xuICAgICAgICAgIHJldHVybiBvICE9PSBzZWxmICYmIF9pc1ZpZXdwb3J0KG8udGFyZ2V0KTtcbiAgICAgICAgfSkubGVuZ3RoIHx8IF9yZW1vdmVMaXN0ZW5lcihpc1ZpZXdwb3J0ID8gb3duZXJEb2MgOiB0YXJnZXQsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG5cbiAgICAgICAgaWYgKHNlbGYuaXNQcmVzc2VkKSB7XG4gICAgICAgICAgc2VsZi5fdngucmVzZXQoKTtcblxuICAgICAgICAgIHNlbGYuX3Z5LnJlc2V0KCk7XG5cbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIoaXNOb3JtYWxpemVyID8gdGFyZ2V0IDogb3duZXJEb2MsIF9ldmVudFR5cGVzWzFdLCBfb25EcmFnLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihpc1ZpZXdwb3J0ID8gb3duZXJEb2MgOiB0YXJnZXQsIFwic2Nyb2xsXCIsIG9uU2Nyb2xsLCBjYXB0dXJlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBcIndoZWVsXCIsIF9vbldoZWVsLCBjYXB0dXJlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBfZXZlbnRUeXBlc1swXSwgX29uUHJlc3MsIGNhcHR1cmUpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgX2V2ZW50VHlwZXNbMl0sIF9vblJlbGVhc2UpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgX2V2ZW50VHlwZXNbM10sIF9vblJlbGVhc2UpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0YXJnZXQsIFwiY2xpY2tcIiwgY2xpY2tDYXB0dXJlLCB0cnVlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBcImNsaWNrXCIsIF9vbkNsaWNrKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIFwiZ2VzdHVyZXN0YXJ0XCIsIF9vbkdlc3R1cmVTdGFydCk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBcImdlc3R1cmVlbmRcIiwgX29uR2VzdHVyZUVuZCk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRhcmdldCwgX3BvaW50ZXJUeXBlICsgXCJlbnRlclwiLCBfb25Ib3Zlcik7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRhcmdldCwgX3BvaW50ZXJUeXBlICsgXCJsZWF2ZVwiLCBfb25Ib3ZlckVuZCk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRhcmdldCwgX3BvaW50ZXJUeXBlICsgXCJtb3ZlXCIsIF9vbk1vdmUpO1xuXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gc2VsZi5pc1ByZXNzZWQgPSBzZWxmLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgb25EaXNhYmxlICYmIG9uRGlzYWJsZShzZWxmKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5raWxsID0gc2VsZi5yZXZlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmRpc2FibGUoKTtcblxuICAgICAgdmFyIGkgPSBfb2JzZXJ2ZXJzLmluZGV4T2Yoc2VsZik7XG5cbiAgICAgIGkgPj0gMCAmJiBfb2JzZXJ2ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIF9ub3JtYWxpemVyID09PSBzZWxmICYmIChfbm9ybWFsaXplciA9IDApO1xuICAgIH07XG5cbiAgICBfb2JzZXJ2ZXJzLnB1c2goc2VsZik7XG5cbiAgICBpc05vcm1hbGl6ZXIgJiYgX2lzVmlld3BvcnQodGFyZ2V0KSAmJiAoX25vcm1hbGl6ZXIgPSBzZWxmKTtcbiAgICBzZWxmLmVuYWJsZShldmVudCk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKE9ic2VydmVyLCBbe1xuICAgIGtleTogXCJ2ZWxvY2l0eVhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92eC5nZXRWZWxvY2l0eSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2ZWxvY2l0eVlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92eS5nZXRWZWxvY2l0eSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPYnNlcnZlcjtcbn0oKTtcbk9ic2VydmVyLnZlcnNpb24gPSBcIjMuMTIuNVwiO1xuXG5PYnNlcnZlci5jcmVhdGUgPSBmdW5jdGlvbiAodmFycykge1xuICByZXR1cm4gbmV3IE9ic2VydmVyKHZhcnMpO1xufTtcblxuT2JzZXJ2ZXIucmVnaXN0ZXIgPSBfaW5pdENvcmU7XG5cbk9ic2VydmVyLmdldEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9vYnNlcnZlcnMuc2xpY2UoKTtcbn07XG5cbk9ic2VydmVyLmdldEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIF9vYnNlcnZlcnMuZmlsdGVyKGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8udmFycy5pZCA9PT0gaWQ7XG4gIH0pWzBdO1xufTtcblxuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKE9ic2VydmVyKTtcbmV4cG9ydCB7IE9ic2VydmVyIGFzIGRlZmF1bHQsIF9pc1ZpZXdwb3J0LCBfc2Nyb2xsZXJzLCBfZ2V0U2Nyb2xsRnVuYywgX2dldFByb3h5UHJvcCwgX3Byb3hpZXMsIF9nZXRWZWxvY2l0eVByb3AsIF92ZXJ0aWNhbCwgX2hvcml6b250YWwsIF9nZXRUYXJnZXQgfTsiXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsImdzYXAiLCJfY29yZUluaXR0ZWQiLCJfY2xhbXAiLCJfd2luIiwiX2RvYyIsIl9kb2NFbCIsIl9ib2R5IiwiX2lzVG91Y2giLCJfcG9pbnRlclR5cGUiLCJTY3JvbGxUcmlnZ2VyIiwiX3Jvb3QiLCJfbm9ybWFsaXplciIsIl9ldmVudFR5cGVzIiwiX2NvbnRleHQiLCJfZ2V0R1NBUCIsIndpbmRvdyIsInJlZ2lzdGVyUGx1Z2luIiwiX3N0YXJ0dXAiLCJfb2JzZXJ2ZXJzIiwiX3Njcm9sbGVycyIsIl9wcm94aWVzIiwiX2dldFRpbWUiLCJEYXRlIiwibm93IiwiX2JyaWRnZSIsIm5hbWUiLCJ2YWx1ZSIsIl9pbnRlZ3JhdGUiLCJjb3JlIiwiZGF0YSIsImJyaWRnZSIsInNjcm9sbGVycyIsInByb3hpZXMiLCJwdXNoIiwiYXBwbHkiLCJfZ2V0UHJveHlQcm9wIiwiZWxlbWVudCIsInByb3BlcnR5IiwiaW5kZXhPZiIsIl9pc1ZpZXdwb3J0IiwiZWwiLCJfYWRkTGlzdGVuZXIiLCJ0eXBlIiwiZnVuYyIsInBhc3NpdmUiLCJjYXB0dXJlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9yZW1vdmVMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJfc2Nyb2xsTGVmdCIsIl9zY3JvbGxUb3AiLCJfb25TY3JvbGwiLCJpc1ByZXNzZWQiLCJjYWNoZSIsIl9zY3JvbGxDYWNoZUZ1bmMiLCJmIiwiZG9Ob3RDYWNoZSIsImNhY2hpbmdGdW5jIiwiaGlzdG9yeSIsInNjcm9sbFJlc3RvcmF0aW9uIiwiaXNOb3JtYWxpemluZyIsInYiLCJNYXRoIiwicm91bmQiLCJpT1MiLCJjYWNoZUlEIiwib2Zmc2V0IiwiX2hvcml6b250YWwiLCJzIiwicCIsInAyIiwib3MiLCJvczIiLCJkIiwiZDIiLCJhIiwic2MiLCJhcmd1bWVudHMiLCJzY3JvbGxUbyIsIl92ZXJ0aWNhbCIsInBhZ2VYT2Zmc2V0Iiwib3AiLCJwYWdlWU9mZnNldCIsIl9nZXRUYXJnZXQiLCJ0Iiwic2VsZiIsIl9jdHgiLCJzZWxlY3RvciIsInV0aWxzIiwidG9BcnJheSIsImNvbmZpZyIsIm51bGxUYXJnZXRXYXJuIiwiY29uc29sZSIsIndhcm4iLCJfZ2V0U2Nyb2xsRnVuYyIsIl9yZWYiLCJzY3JvbGxpbmdFbGVtZW50IiwicHJldiIsInNtb290aCIsImdldFByb3BlcnR5IiwiX2dldFZlbG9jaXR5UHJvcCIsIm1pblRpbWVSZWZyZXNoIiwidXNlRGVsdGEiLCJ2MSIsInYyIiwidDEiLCJ0MiIsIm1pbiIsImRyb3BUb1plcm9UaW1lIiwibWF4IiwidXBkYXRlIiwiZm9yY2UiLCJyZXNldCIsImdldFZlbG9jaXR5IiwibGF0ZXN0VmFsdWUiLCJ0T2xkIiwidk9sZCIsIl9nZXRFdmVudCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsIl9nc2FwQWxsb3ciLCJjaGFuZ2VkVG91Y2hlcyIsIl9nZXRBYnNvbHV0ZU1heCIsImFicyIsIl9zZXRTY3JvbGxUcmlnZ2VyIiwiZ2xvYmFscyIsIl9pbml0Q29yZSIsImRvY3VtZW50IiwiYm9keSIsImRvY3VtZW50RWxlbWVudCIsImNsYW1wIiwiY29udGV4dCIsIk9ic2VydmVyIiwiaXNUb3VjaCIsIm1hdGNoTWVkaWEiLCJtYXRjaGVzIiwibmF2aWdhdG9yIiwibWF4VG91Y2hQb2ludHMiLCJtc01heFRvdWNoUG9pbnRzIiwiZXZlbnRUeXBlcyIsInNwbGl0Iiwic2V0VGltZW91dCIsInZhcnMiLCJpbml0IiwiX3Byb3RvIiwidG9sZXJhbmNlIiwiZHJhZ01pbmltdW0iLCJsaW5lSGVpZ2h0IiwiZGVib3VuY2UiLCJvblN0b3AiLCJvblN0b3BEZWxheSIsImlnbm9yZSIsIndoZWVsU3BlZWQiLCJldmVudCIsIm9uRHJhZ1N0YXJ0Iiwib25EcmFnRW5kIiwib25EcmFnIiwib25QcmVzcyIsIm9uUmVsZWFzZSIsIm9uUmlnaHQiLCJvbkxlZnQiLCJvblVwIiwib25Eb3duIiwib25DaGFuZ2VYIiwib25DaGFuZ2VZIiwib25DaGFuZ2UiLCJvblRvZ2dsZVgiLCJvblRvZ2dsZVkiLCJvbkhvdmVyIiwib25Ib3ZlckVuZCIsIm9uTW92ZSIsImlnbm9yZUNoZWNrIiwiaXNOb3JtYWxpemVyIiwib25HZXN0dXJlU3RhcnQiLCJvbkdlc3R1cmVFbmQiLCJvbldoZWVsIiwib25FbmFibGUiLCJvbkRpc2FibGUiLCJvbkNsaWNrIiwic2Nyb2xsU3BlZWQiLCJhbGxvd0NsaWNrcyIsImxvY2tBeGlzIiwib25Mb2NrQXhpcyIsInBhcnNlRmxvYXQiLCJnZXRDb21wdXRlZFN0eWxlIiwiaWQiLCJvblN0b3BEZWxheWVkQ2FsbCIsImRyYWdnZWQiLCJtb3ZlZCIsIndoZWVsZWQiLCJsb2NrZWQiLCJheGlzIiwicHJldkRlbHRhWCIsInByZXZEZWx0YVkiLCJzY3JvbGxGdW5jWCIsInNjcm9sbEZ1bmNZIiwic2Nyb2xsWCIsInNjcm9sbFkiLCJsaW1pdFRvVG91Y2giLCJpc1ZpZXdwb3J0Iiwib3duZXJEb2MiLCJvd25lckRvY3VtZW50IiwiZGVsdGFYIiwiZGVsdGFZIiwib25DbGlja1RpbWUiLCJjbGlja0NhcHR1cmUiLCJfaWdub3JlQ2hlY2siLCJpc1BvaW50ZXJPclRvdWNoIiwicG9pbnRlclR5cGUiLCJvblN0b3BGdW5jIiwiX3Z4IiwiX3Z5IiwicGF1c2UiLCJkeCIsImR5IiwiY2hhbmdlZFgiLCJjaGFuZ2VkWSIsIm9uRGVsdGEiLCJ4IiwieSIsImluZGV4IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib25Ub3VjaE9yUG9pbnRlckRlbHRhIiwiX29uRHJhZyIsImNsaWVudFgiLCJjbGllbnRZIiwiaXNEcmFnZ2luZyIsInN0YXJ0WCIsInN0YXJ0WSIsIl9vblByZXNzIiwiYnV0dG9uIiwiX29uUmVsZWFzZSIsImlzVHJhY2tpbmdEcmFnIiwiaXNOYU4iLCJ3YXNEcmFnZ2luZyIsImlzRHJhZ05vdENsaWNrIiwiZXZlbnREYXRhIiwiZGVsYXllZENhbGwiLCJkZWZhdWx0UHJldmVudGVkIiwiY2xpY2siLCJjcmVhdGVFdmVudCIsInN5bnRoZXRpY0V2ZW50IiwiaW5pdE1vdXNlRXZlbnQiLCJzY3JlZW5YIiwic2NyZWVuWSIsImRpc3BhdGNoRXZlbnQiLCJpc0dlc3R1cmluZyIsInJlc3RhcnQiLCJfb25HZXN0dXJlU3RhcnQiLCJ0b3VjaGVzIiwiX29uR2VzdHVyZUVuZCIsIm9uU2Nyb2xsIiwiX29uV2hlZWwiLCJtdWx0aXBsaWVyIiwiZGVsdGFNb2RlIiwiaW5uZXJIZWlnaHQiLCJfb25Nb3ZlIiwiX29uSG92ZXIiLCJfb25Ib3ZlckVuZCIsIl9vbkNsaWNrIiwiX2RjIiwiZW5hYmxlIiwiaXNFbmFibGVkIiwiZGlzYWJsZSIsImZpbHRlciIsIm8iLCJraWxsIiwicmV2ZXJ0Iiwic3BsaWNlIiwiZ2V0IiwidmVyc2lvbiIsImNyZWF0ZSIsInJlZ2lzdGVyIiwiZ2V0QWxsIiwic2xpY2UiLCJnZXRCeUlkIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Observer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/PixiPlugin.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/PixiPlugin.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PixiPlugin: function() { return /* binding */ PixiPlugin; },\n/* harmony export */   \"default\": function() { return /* binding */ PixiPlugin; }\n/* harmony export */ });\n/*!\n * PixiPlugin 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var gsap, _splitColor, _coreInitted, _PIXI, PropTween, _getSetter, _isV4, _windowExists = function _windowExists() {\n    return typeof window !== \"undefined\";\n}, _getGSAP = function _getGSAP() {\n    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _isFunction = function _isFunction(value) {\n    return typeof value === \"function\";\n}, _warn = function _warn(message) {\n    return console.warn(message);\n}, _idMatrix = [\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0\n], _lumR = 0.212671, _lumG = 0.715160, _lumB = 0.072169, _filterClass = function _filterClass(name) {\n    return _isFunction(_PIXI[name]) ? _PIXI[name] : _PIXI.filters[name];\n}, // in PIXI 7.1, filters moved from PIXI.filters to just PIXI\n_applyMatrix = function _applyMatrix(m, m2) {\n    var temp = [], i = 0, z = 0, y, x;\n    for(y = 0; y < 4; y++){\n        for(x = 0; x < 5; x++){\n            z = x === 4 ? m[i + 4] : 0;\n            temp[i + x] = m[i] * m2[x] + m[i + 1] * m2[x + 5] + m[i + 2] * m2[x + 10] + m[i + 3] * m2[x + 15] + z;\n        }\n        i += 5;\n    }\n    return temp;\n}, _setSaturation = function _setSaturation(m, n) {\n    var inv = 1 - n, r = inv * _lumR, g = inv * _lumG, b = inv * _lumB;\n    return _applyMatrix([\n        r + n,\n        g,\n        b,\n        0,\n        0,\n        r,\n        g + n,\n        b,\n        0,\n        0,\n        r,\n        g,\n        b + n,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n    ], m);\n}, _colorize = function _colorize(m, color, amount) {\n    var c = _splitColor(color), r = c[0] / 255, g = c[1] / 255, b = c[2] / 255, inv = 1 - amount;\n    return _applyMatrix([\n        inv + amount * r * _lumR,\n        amount * r * _lumG,\n        amount * r * _lumB,\n        0,\n        0,\n        amount * g * _lumR,\n        inv + amount * g * _lumG,\n        amount * g * _lumB,\n        0,\n        0,\n        amount * b * _lumR,\n        amount * b * _lumG,\n        inv + amount * b * _lumB,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n    ], m);\n}, _setHue = function _setHue(m, n) {\n    n *= Math.PI / 180;\n    var c = Math.cos(n), s = Math.sin(n);\n    return _applyMatrix([\n        _lumR + c * (1 - _lumR) + s * -_lumR,\n        _lumG + c * -_lumG + s * -_lumG,\n        _lumB + c * -_lumB + s * (1 - _lumB),\n        0,\n        0,\n        _lumR + c * -_lumR + s * 0.143,\n        _lumG + c * (1 - _lumG) + s * 0.14,\n        _lumB + c * -_lumB + s * -0.283,\n        0,\n        0,\n        _lumR + c * -_lumR + s * -(1 - _lumR),\n        _lumG + c * -_lumG + s * _lumG,\n        _lumB + c * (1 - _lumB) + s * _lumB,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1\n    ], m);\n}, _setContrast = function _setContrast(m, n) {\n    return _applyMatrix([\n        n,\n        0,\n        0,\n        0,\n        0.5 * (1 - n),\n        0,\n        n,\n        0,\n        0,\n        0.5 * (1 - n),\n        0,\n        0,\n        n,\n        0,\n        0.5 * (1 - n),\n        0,\n        0,\n        0,\n        1,\n        0\n    ], m);\n}, _getFilter = function _getFilter(target, type) {\n    var filterClass = _filterClass(type), filters = target.filters || [], i = filters.length, filter;\n    filterClass || _warn(type + \" not found. PixiPlugin.registerPIXI(PIXI)\");\n    while(--i > -1){\n        if (filters[i] instanceof filterClass) {\n            return filters[i];\n        }\n    }\n    filter = new filterClass();\n    if (type === \"BlurFilter\") {\n        filter.blur = 0;\n    }\n    filters.push(filter);\n    target.filters = filters;\n    return filter;\n}, _addColorMatrixFilterCacheTween = function _addColorMatrixFilterCacheTween(p, plugin, cache, vars) {\n    //we cache the ColorMatrixFilter components in a _gsColorMatrixFilter object attached to the target object so that it's easy to grab the current value at any time.\n    plugin.add(cache, p, cache[p], vars[p]);\n    plugin._props.push(p);\n}, _applyBrightnessToMatrix = function _applyBrightnessToMatrix(brightness, matrix) {\n    var filterClass = _filterClass(\"ColorMatrixFilter\"), temp = new filterClass();\n    temp.matrix = matrix;\n    temp.brightness(brightness, true);\n    return temp.matrix;\n}, _copy = function _copy(obj) {\n    var copy = {}, p;\n    for(p in obj){\n        copy[p] = obj[p];\n    }\n    return copy;\n}, _CMFdefaults = {\n    contrast: 1,\n    saturation: 1,\n    colorizeAmount: 0,\n    colorize: \"rgb(255,255,255)\",\n    hue: 0,\n    brightness: 1\n}, _parseColorMatrixFilter = function _parseColorMatrixFilter(target, v, pg) {\n    var filter = _getFilter(target, \"ColorMatrixFilter\"), cache = target._gsColorMatrixFilter = target._gsColorMatrixFilter || _copy(_CMFdefaults), combine = v.combineCMF && !(\"colorMatrixFilter\" in v && !v.colorMatrixFilter), i, matrix, startMatrix;\n    startMatrix = filter.matrix;\n    if (v.resolution) {\n        filter.resolution = v.resolution;\n    }\n    if (v.matrix && v.matrix.length === startMatrix.length) {\n        matrix = v.matrix;\n        if (cache.contrast !== 1) {\n            _addColorMatrixFilterCacheTween(\"contrast\", pg, cache, _CMFdefaults);\n        }\n        if (cache.hue) {\n            _addColorMatrixFilterCacheTween(\"hue\", pg, cache, _CMFdefaults);\n        }\n        if (cache.brightness !== 1) {\n            _addColorMatrixFilterCacheTween(\"brightness\", pg, cache, _CMFdefaults);\n        }\n        if (cache.colorizeAmount) {\n            _addColorMatrixFilterCacheTween(\"colorize\", pg, cache, _CMFdefaults);\n            _addColorMatrixFilterCacheTween(\"colorizeAmount\", pg, cache, _CMFdefaults);\n        }\n        if (cache.saturation !== 1) {\n            _addColorMatrixFilterCacheTween(\"saturation\", pg, cache, _CMFdefaults);\n        }\n    } else {\n        matrix = _idMatrix.slice();\n        if (v.contrast != null) {\n            matrix = _setContrast(matrix, +v.contrast);\n            _addColorMatrixFilterCacheTween(\"contrast\", pg, cache, v);\n        } else if (cache.contrast !== 1) {\n            if (combine) {\n                matrix = _setContrast(matrix, cache.contrast);\n            } else {\n                _addColorMatrixFilterCacheTween(\"contrast\", pg, cache, _CMFdefaults);\n            }\n        }\n        if (v.hue != null) {\n            matrix = _setHue(matrix, +v.hue);\n            _addColorMatrixFilterCacheTween(\"hue\", pg, cache, v);\n        } else if (cache.hue) {\n            if (combine) {\n                matrix = _setHue(matrix, cache.hue);\n            } else {\n                _addColorMatrixFilterCacheTween(\"hue\", pg, cache, _CMFdefaults);\n            }\n        }\n        if (v.brightness != null) {\n            matrix = _applyBrightnessToMatrix(+v.brightness, matrix);\n            _addColorMatrixFilterCacheTween(\"brightness\", pg, cache, v);\n        } else if (cache.brightness !== 1) {\n            if (combine) {\n                matrix = _applyBrightnessToMatrix(cache.brightness, matrix);\n            } else {\n                _addColorMatrixFilterCacheTween(\"brightness\", pg, cache, _CMFdefaults);\n            }\n        }\n        if (v.colorize != null) {\n            v.colorizeAmount = \"colorizeAmount\" in v ? +v.colorizeAmount : 1;\n            matrix = _colorize(matrix, v.colorize, v.colorizeAmount);\n            _addColorMatrixFilterCacheTween(\"colorize\", pg, cache, v);\n            _addColorMatrixFilterCacheTween(\"colorizeAmount\", pg, cache, v);\n        } else if (cache.colorizeAmount) {\n            if (combine) {\n                matrix = _colorize(matrix, cache.colorize, cache.colorizeAmount);\n            } else {\n                _addColorMatrixFilterCacheTween(\"colorize\", pg, cache, _CMFdefaults);\n                _addColorMatrixFilterCacheTween(\"colorizeAmount\", pg, cache, _CMFdefaults);\n            }\n        }\n        if (v.saturation != null) {\n            matrix = _setSaturation(matrix, +v.saturation);\n            _addColorMatrixFilterCacheTween(\"saturation\", pg, cache, v);\n        } else if (cache.saturation !== 1) {\n            if (combine) {\n                matrix = _setSaturation(matrix, cache.saturation);\n            } else {\n                _addColorMatrixFilterCacheTween(\"saturation\", pg, cache, _CMFdefaults);\n            }\n        }\n    }\n    i = matrix.length;\n    while(--i > -1){\n        if (matrix[i] !== startMatrix[i]) {\n            pg.add(startMatrix, i, startMatrix[i], matrix[i], \"colorMatrixFilter\");\n        }\n    }\n    pg._props.push(\"colorMatrixFilter\");\n}, _renderColor = function _renderColor(ratio, _ref) {\n    var t = _ref.t, p = _ref.p, color = _ref.color, set = _ref.set;\n    set(t, p, color[0] << 16 | color[1] << 8 | color[2]);\n}, _renderDirtyCache = function _renderDirtyCache(ratio, _ref2) {\n    var g = _ref2.g;\n    if (g) {\n        //in order for PixiJS to actually redraw GraphicsData, we've gotta increment the \"dirty\" and \"clearDirty\" values. If we don't do this, the values will be tween properly, but not rendered.\n        g.dirty++;\n        g.clearDirty++;\n    }\n}, _renderAutoAlpha = function _renderAutoAlpha(ratio, data) {\n    data.t.visible = !!data.t.alpha;\n}, _addColorTween = function _addColorTween(target, p, value, plugin) {\n    var currentValue = target[p], startColor = _splitColor(_isFunction(currentValue) ? target[p.indexOf(\"set\") || !_isFunction(target[\"get\" + p.substr(3)]) ? p : \"get\" + p.substr(3)]() : currentValue), endColor = _splitColor(value);\n    plugin._pt = new PropTween(plugin._pt, target, p, 0, 0, _renderColor, {\n        t: target,\n        p: p,\n        color: startColor,\n        set: _getSetter(target, p)\n    });\n    plugin.add(startColor, 0, startColor[0], endColor[0]);\n    plugin.add(startColor, 1, startColor[1], endColor[1]);\n    plugin.add(startColor, 2, startColor[2], endColor[2]);\n}, _colorProps = {\n    tint: 1,\n    lineColor: 1,\n    fillColor: 1\n}, _xyContexts = \"position,scale,skew,pivot,anchor,tilePosition,tileScale\".split(\",\"), _contexts = {\n    x: \"position\",\n    y: \"position\",\n    tileX: \"tilePosition\",\n    tileY: \"tilePosition\"\n}, _colorMatrixFilterProps = {\n    colorMatrixFilter: 1,\n    saturation: 1,\n    contrast: 1,\n    hue: 1,\n    colorize: 1,\n    colorizeAmount: 1,\n    brightness: 1,\n    combineCMF: 1\n}, _DEG2RAD = Math.PI / 180, _isString = function _isString(value) {\n    return typeof value === \"string\";\n}, _degreesToRadians = function _degreesToRadians(value) {\n    return _isString(value) && value.charAt(1) === \"=\" ? value.substr(0, 2) + parseFloat(value.substr(2)) * _DEG2RAD : value * _DEG2RAD;\n}, _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {\n    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 100000) / 100000, data);\n}, _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue, radians) {\n    var cap = 360 * (radians ? _DEG2RAD : 1), isString = _isString(endValue), relative = isString && endValue.charAt(1) === \"=\" ? +(endValue.charAt(0) + \"1\") : 0, endNum = parseFloat(relative ? endValue.substr(2) : endValue) * (radians ? _DEG2RAD : 1), change = relative ? endNum * relative : endNum - startNum, finalValue = startNum + change, direction, pt;\n    if (isString) {\n        direction = endValue.split(\"_\")[1];\n        if (direction === \"short\") {\n            change %= cap;\n            if (change !== change % (cap / 2)) {\n                change += change < 0 ? cap : -cap;\n            }\n        }\n        if (direction === \"cw\" && change < 0) {\n            change = (change + cap * 1e10) % cap - ~~(change / cap) * cap;\n        } else if (direction === \"ccw\" && change > 0) {\n            change = (change - cap * 1e10) % cap - ~~(change / cap) * cap;\n        }\n    }\n    plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);\n    pt.e = finalValue;\n    return pt;\n}, _initCore = function _initCore() {\n    if (!_coreInitted) {\n        gsap = _getGSAP();\n        _PIXI = _coreInitted = _PIXI || _windowExists() && window.PIXI;\n        _isV4 = _PIXI && _PIXI.VERSION && _PIXI.VERSION.charAt(0) === \"4\";\n        _splitColor = function _splitColor(color) {\n            return gsap.utils.splitColor((color + \"\").substr(0, 2) === \"0x\" ? \"#\" + color.substr(2) : color);\n        }; // some colors in PIXI are reported as \"0xFF4421\" instead of \"#FF4421\".\n    }\n}, i, p; //context setup...\nfor(i = 0; i < _xyContexts.length; i++){\n    p = _xyContexts[i];\n    _contexts[p + \"X\"] = p;\n    _contexts[p + \"Y\"] = p;\n}\nvar PixiPlugin = {\n    version: \"3.12.5\",\n    name: \"pixi\",\n    register: function register(core, Plugin, propTween) {\n        gsap = core;\n        PropTween = propTween;\n        _getSetter = Plugin.getSetter;\n        _initCore();\n    },\n    headless: true,\n    // doesn't need window\n    registerPIXI: function registerPIXI(pixi) {\n        _PIXI = pixi;\n    },\n    init: function init(target, values, tween, index, targets) {\n        _PIXI || _initCore();\n        if (!_PIXI) {\n            _warn(\"PIXI was not found. PixiPlugin.registerPIXI(PIXI);\");\n            return false;\n        }\n        var context, axis, value, colorMatrix, filter, p, padding, i, data;\n        for(p in values){\n            context = _contexts[p];\n            value = values[p];\n            if (context) {\n                axis = ~p.charAt(p.length - 1).toLowerCase().indexOf(\"x\") ? \"x\" : \"y\";\n                this.add(target[context], axis, target[context][axis], context === \"skew\" ? _degreesToRadians(value) : value, 0, 0, 0, 0, 0, 1);\n            } else if (p === \"scale\" || p === \"anchor\" || p === \"pivot\" || p === \"tileScale\") {\n                this.add(target[p], \"x\", target[p].x, value);\n                this.add(target[p], \"y\", target[p].y, value);\n            } else if (p === \"rotation\" || p === \"angle\") {\n                //PIXI expects rotation in radians, but as a convenience we let folks define it in degrees and we do the conversion.\n                _addRotationalPropTween(this, target, p, target[p], value, p === \"rotation\");\n            } else if (_colorMatrixFilterProps[p]) {\n                if (!colorMatrix) {\n                    _parseColorMatrixFilter(target, values.colorMatrixFilter || values, this);\n                    colorMatrix = true;\n                }\n            } else if (p === \"blur\" || p === \"blurX\" || p === \"blurY\" || p === \"blurPadding\") {\n                filter = _getFilter(target, \"BlurFilter\");\n                this.add(filter, p, filter[p], value);\n                if (values.blurPadding !== 0) {\n                    padding = values.blurPadding || Math.max(filter[p], value) * 2;\n                    i = target.filters.length;\n                    while(--i > -1){\n                        target.filters[i].padding = Math.max(target.filters[i].padding, padding); //if we don't expand the padding on all the filters, it can look clipped.\n                    }\n                }\n            } else if (_colorProps[p]) {\n                if ((p === \"lineColor\" || p === \"fillColor\") && target instanceof _PIXI.Graphics) {\n                    data = (target.geometry || target).graphicsData; //\"geometry\" was introduced in PIXI version 5\n                    this._pt = new PropTween(this._pt, target, p, 0, 0, _renderDirtyCache, {\n                        g: target.geometry || target\n                    });\n                    i = data.length;\n                    while(--i > -1){\n                        _addColorTween(_isV4 ? data[i] : data[i][p.substr(0, 4) + \"Style\"], _isV4 ? p : \"color\", value, this);\n                    }\n                } else {\n                    _addColorTween(target, p, value, this);\n                }\n            } else if (p === \"autoAlpha\") {\n                this._pt = new PropTween(this._pt, target, \"visible\", 0, 0, _renderAutoAlpha);\n                this.add(target, \"alpha\", target.alpha, value);\n                this._props.push(\"alpha\", \"visible\");\n            } else if (p !== \"resolution\") {\n                this.add(target, p, \"get\", value);\n            }\n            this._props.push(p);\n        }\n    }\n};\n_getGSAP() && gsap.registerPlugin(PixiPlugin);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9QaXhpUGx1Z2luLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7O0FBUUEsR0FFQSxrQkFBa0IsR0FDbEIsSUFBSUEsTUFDQUMsYUFDQUMsY0FDQUMsT0FDQUMsV0FDQUMsWUFDQUMsT0FDQUMsZ0JBQWdCLFNBQVNBO0lBQzNCLE9BQU8sT0FBT0MsV0FBVztBQUMzQixHQUNJQyxXQUFXLFNBQVNBO0lBQ3RCLE9BQU9ULFFBQVFPLG1CQUFvQlAsQ0FBQUEsT0FBT1EsT0FBT1IsSUFBSSxLQUFLQSxLQUFLVSxjQUFjLElBQUlWO0FBQ25GLEdBQ0lXLGNBQWMsU0FBU0EsWUFBWUMsS0FBSztJQUMxQyxPQUFPLE9BQU9BLFVBQVU7QUFDMUIsR0FDSUMsUUFBUSxTQUFTQSxNQUFNQyxPQUFPO0lBQ2hDLE9BQU9DLFFBQVFDLElBQUksQ0FBQ0Y7QUFDdEIsR0FDSUcsWUFBWTtJQUFDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7Q0FBRSxFQUN4RUMsUUFBUSxVQUNSQyxRQUFRLFVBQ1JDLFFBQVEsVUFDUkMsZUFBZSxTQUFTQSxhQUFhQyxJQUFJO0lBQzNDLE9BQU9YLFlBQVlSLEtBQUssQ0FBQ21CLEtBQUssSUFBSW5CLEtBQUssQ0FBQ21CLEtBQUssR0FBR25CLE1BQU1vQixPQUFPLENBQUNELEtBQUs7QUFDckUsR0FDSSw0REFBNEQ7QUFDaEVFLGVBQWUsU0FBU0EsYUFBYUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3hDLElBQUlDLE9BQU8sRUFBRSxFQUNUQyxJQUFJLEdBQ0pDLElBQUksR0FDSkMsR0FDQUM7SUFFSixJQUFLRCxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBSztRQUN0QixJQUFLQyxJQUFJLEdB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Olsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vZ3NhcEAzLjEyLjUvbm9kZV9tb2R1bGVzL2dzYXAvUGl4aVBsdWdpbi5qcz9iMDZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogUGl4aVBsdWdpbiAzLjEyLjVcbiAqIGh0dHBzOi8vZ3NhcC5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDI0LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dzYXAuY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdTQVAgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgZ3NhcCxcbiAgICBfc3BsaXRDb2xvcixcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX1BJWEksXG4gICAgUHJvcFR3ZWVuLFxuICAgIF9nZXRTZXR0ZXIsXG4gICAgX2lzVjQsXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCBfd2luZG93RXhpc3RzKCkgJiYgKGdzYXAgPSB3aW5kb3cuZ3NhcCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbiAmJiBnc2FwO1xufSxcbiAgICBfaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIF9pc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn0sXG4gICAgX3dhcm4gPSBmdW5jdGlvbiBfd2FybihtZXNzYWdlKSB7XG4gIHJldHVybiBjb25zb2xlLndhcm4obWVzc2FnZSk7XG59LFxuICAgIF9pZE1hdHJpeCA9IFsxLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxLCAwXSxcbiAgICBfbHVtUiA9IDAuMjEyNjcxLFxuICAgIF9sdW1HID0gMC43MTUxNjAsXG4gICAgX2x1bUIgPSAwLjA3MjE2OSxcbiAgICBfZmlsdGVyQ2xhc3MgPSBmdW5jdGlvbiBfZmlsdGVyQ2xhc3MobmFtZSkge1xuICByZXR1cm4gX2lzRnVuY3Rpb24oX1BJWElbbmFtZV0pID8gX1BJWElbbmFtZV0gOiBfUElYSS5maWx0ZXJzW25hbWVdO1xufSxcbiAgICAvLyBpbiBQSVhJIDcuMSwgZmlsdGVycyBtb3ZlZCBmcm9tIFBJWEkuZmlsdGVycyB0byBqdXN0IFBJWElcbl9hcHBseU1hdHJpeCA9IGZ1bmN0aW9uIF9hcHBseU1hdHJpeChtLCBtMikge1xuICB2YXIgdGVtcCA9IFtdLFxuICAgICAgaSA9IDAsXG4gICAgICB6ID0gMCxcbiAgICAgIHksXG4gICAgICB4O1xuXG4gIGZvciAoeSA9IDA7IHkgPCA0OyB5KyspIHtcbiAgICBmb3IgKHggPSAwOyB4IDwgNTsgeCsrKSB7XG4gICAgICB6ID0geCA9PT0gNCA/IG1baSArIDRdIDogMDtcbiAgICAgIHRlbXBbaSArIHhdID0gbVtpXSAqIG0yW3hdICsgbVtpICsgMV0gKiBtMlt4ICsgNV0gKyBtW2kgKyAyXSAqIG0yW3ggKyAxMF0gKyBtW2kgKyAzXSAqIG0yW3ggKyAxNV0gKyB6O1xuICAgIH1cblxuICAgIGkgKz0gNTtcbiAgfVxuXG4gIHJldHVybiB0ZW1wO1xufSxcbiAgICBfc2V0U2F0dXJhdGlvbiA9IGZ1bmN0aW9uIF9zZXRTYXR1cmF0aW9uKG0sIG4pIHtcbiAgdmFyIGludiA9IDEgLSBuLFxuICAgICAgciA9IGludiAqIF9sdW1SLFxuICAgICAgZyA9IGludiAqIF9sdW1HLFxuICAgICAgYiA9IGludiAqIF9sdW1CO1xuICByZXR1cm4gX2FwcGx5TWF0cml4KFtyICsgbiwgZywgYiwgMCwgMCwgciwgZyArIG4sIGIsIDAsIDAsIHIsIGcsIGIgKyBuLCAwLCAwLCAwLCAwLCAwLCAxLCAwXSwgbSk7XG59LFxuICAgIF9jb2xvcml6ZSA9IGZ1bmN0aW9uIF9jb2xvcml6ZShtLCBjb2xvciwgYW1vdW50KSB7XG4gIHZhciBjID0gX3NwbGl0Q29sb3IoY29sb3IpLFxuICAgICAgciA9IGNbMF0gLyAyNTUsXG4gICAgICBnID0gY1sxXSAvIDI1NSxcbiAgICAgIGIgPSBjWzJdIC8gMjU1LFxuICAgICAgaW52ID0gMSAtIGFtb3VudDtcblxuICByZXR1cm4gX2FwcGx5TWF0cml4KFtpbnYgKyBhbW91bnQgKiByICogX2x1bVIsIGFtb3VudCAqIHIgKiBfbHVtRywgYW1vdW50ICogciAqIF9sdW1CLCAwLCAwLCBhbW91bnQgKiBnICogX2x1bVIsIGludiArIGFtb3VudCAqIGcgKiBfbHVtRywgYW1vdW50ICogZyAqIF9sdW1CLCAwLCAwLCBhbW91bnQgKiBiICogX2x1bVIsIGFtb3VudCAqIGIgKiBfbHVtRywgaW52ICsgYW1vdW50ICogYiAqIF9sdW1CLCAwLCAwLCAwLCAwLCAwLCAxLCAwXSwgbSk7XG59LFxuICAgIF9zZXRIdWUgPSBmdW5jdGlvbiBfc2V0SHVlKG0sIG4pIHtcbiAgbiAqPSBNYXRoLlBJIC8gMTgwO1xuICB2YXIgYyA9IE1hdGguY29zKG4pLFxuICAgICAgcyA9IE1hdGguc2luKG4pO1xuICByZXR1cm4gX2FwcGx5TWF0cml4KFtfbHVtUiArIGMgKiAoMSAtIF9sdW1SKSArIHMgKiAtX2x1bVIsIF9sdW1HICsgYyAqIC1fbHVtRyArIHMgKiAtX2x1bUcsIF9sdW1CICsgYyAqIC1fbHVtQiArIHMgKiAoMSAtIF9sdW1CKSwgMCwgMCwgX2x1bVIgKyBjICogLV9sdW1SICsgcyAqIDAuMTQzLCBfbHVtRyArIGMgKiAoMSAtIF9sdW1HKSArIHMgKiAwLjE0LCBfbHVtQiArIGMgKiAtX2x1bUIgKyBzICogLTAuMjgzLCAwLCAwLCBfbHVtUiArIGMgKiAtX2x1bVIgKyBzICogLSgxIC0gX2x1bVIpLCBfbHVtRyArIGMgKiAtX2x1bUcgKyBzICogX2x1bUcsIF9sdW1CICsgYyAqICgxIC0gX2x1bUIpICsgcyAqIF9sdW1CLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxXSwgbSk7XG59LFxuICAgIF9zZXRDb250cmFzdCA9IGZ1bmN0aW9uIF9zZXRDb250cmFzdChtLCBuKSB7XG4gIHJldHVybiBfYXBwbHlNYXRyaXgoW24sIDAsIDAsIDAsIDAuNSAqICgxIC0gbiksIDAsIG4sIDAsIDAsIDAuNSAqICgxIC0gbiksIDAsIDAsIG4sIDAsIDAuNSAqICgxIC0gbiksIDAsIDAsIDAsIDEsIDBdLCBtKTtcbn0sXG4gICAgX2dldEZpbHRlciA9IGZ1bmN0aW9uIF9nZXRGaWx0ZXIodGFyZ2V0LCB0eXBlKSB7XG4gIHZhciBmaWx0ZXJDbGFzcyA9IF9maWx0ZXJDbGFzcyh0eXBlKSxcbiAgICAgIGZpbHRlcnMgPSB0YXJnZXQuZmlsdGVycyB8fCBbXSxcbiAgICAgIGkgPSBmaWx0ZXJzLmxlbmd0aCxcbiAgICAgIGZpbHRlcjtcblxuICBmaWx0ZXJDbGFzcyB8fCBfd2Fybih0eXBlICsgXCIgbm90IGZvdW5kLiBQaXhpUGx1Z2luLnJlZ2lzdGVyUElYSShQSVhJKVwiKTtcblxuICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICBpZiAoZmlsdGVyc1tpXSBpbnN0YW5jZW9mIGZpbHRlckNsYXNzKSB7XG4gICAgICByZXR1cm4gZmlsdGVyc1tpXTtcbiAgICB9XG4gIH1cblxuICBmaWx0ZXIgPSBuZXcgZmlsdGVyQ2xhc3MoKTtcblxuICBpZiAodHlwZSA9PT0gXCJCbHVyRmlsdGVyXCIpIHtcbiAgICBmaWx0ZXIuYmx1ciA9IDA7XG4gIH1cblxuICBmaWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgdGFyZ2V0LmZpbHRlcnMgPSBmaWx0ZXJzO1xuICByZXR1cm4gZmlsdGVyO1xufSxcbiAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuID0gZnVuY3Rpb24gX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihwLCBwbHVnaW4sIGNhY2hlLCB2YXJzKSB7XG4gIC8vd2UgY2FjaGUgdGhlIENvbG9yTWF0cml4RmlsdGVyIGNvbXBvbmVudHMgaW4gYSBfZ3NDb2xvck1hdHJpeEZpbHRlciBvYmplY3QgYXR0YWNoZWQgdG8gdGhlIHRhcmdldCBvYmplY3Qgc28gdGhhdCBpdCdzIGVhc3kgdG8gZ3JhYiB0aGUgY3VycmVudCB2YWx1ZSBhdCBhbnkgdGltZS5cbiAgcGx1Z2luLmFkZChjYWNoZSwgcCwgY2FjaGVbcF0sIHZhcnNbcF0pO1xuXG4gIHBsdWdpbi5fcHJvcHMucHVzaChwKTtcbn0sXG4gICAgX2FwcGx5QnJpZ2h0bmVzc1RvTWF0cml4ID0gZnVuY3Rpb24gX2FwcGx5QnJpZ2h0bmVzc1RvTWF0cml4KGJyaWdodG5lc3MsIG1hdHJpeCkge1xuICB2YXIgZmlsdGVyQ2xhc3MgPSBfZmlsdGVyQ2xhc3MoXCJDb2xvck1hdHJpeEZpbHRlclwiKSxcbiAgICAgIHRlbXAgPSBuZXcgZmlsdGVyQ2xhc3MoKTtcblxuICB0ZW1wLm1hdHJpeCA9IG1hdHJpeDtcbiAgdGVtcC5icmlnaHRuZXNzKGJyaWdodG5lc3MsIHRydWUpO1xuICByZXR1cm4gdGVtcC5tYXRyaXg7XG59LFxuICAgIF9jb3B5ID0gZnVuY3Rpb24gX2NvcHkob2JqKSB7XG4gIHZhciBjb3B5ID0ge30sXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiBvYmopIHtcbiAgICBjb3B5W3BdID0gb2JqW3BdO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIF9DTUZkZWZhdWx0cyA9IHtcbiAgY29udHJhc3Q6IDEsXG4gIHNhdHVyYXRpb246IDEsXG4gIGNvbG9yaXplQW1vdW50OiAwLFxuICBjb2xvcml6ZTogXCJyZ2IoMjU1LDI1NSwyNTUpXCIsXG4gIGh1ZTogMCxcbiAgYnJpZ2h0bmVzczogMVxufSxcbiAgICBfcGFyc2VDb2xvck1hdHJpeEZpbHRlciA9IGZ1bmN0aW9uIF9wYXJzZUNvbG9yTWF0cml4RmlsdGVyKHRhcmdldCwgdiwgcGcpIHtcbiAgdmFyIGZpbHRlciA9IF9nZXRGaWx0ZXIodGFyZ2V0LCBcIkNvbG9yTWF0cml4RmlsdGVyXCIpLFxuICAgICAgY2FjaGUgPSB0YXJnZXQuX2dzQ29sb3JNYXRyaXhGaWx0ZXIgPSB0YXJnZXQuX2dzQ29sb3JNYXRyaXhGaWx0ZXIgfHwgX2NvcHkoX0NNRmRlZmF1bHRzKSxcbiAgICAgIGNvbWJpbmUgPSB2LmNvbWJpbmVDTUYgJiYgIShcImNvbG9yTWF0cml4RmlsdGVyXCIgaW4gdiAmJiAhdi5jb2xvck1hdHJpeEZpbHRlciksXG4gICAgICBpLFxuICAgICAgbWF0cml4LFxuICAgICAgc3RhcnRNYXRyaXg7XG5cbiAgc3RhcnRNYXRyaXggPSBmaWx0ZXIubWF0cml4O1xuXG4gIGlmICh2LnJlc29sdXRpb24pIHtcbiAgICBmaWx0ZXIucmVzb2x1dGlvbiA9IHYucmVzb2x1dGlvbjtcbiAgfVxuXG4gIGlmICh2Lm1hdHJpeCAmJiB2Lm1hdHJpeC5sZW5ndGggPT09IHN0YXJ0TWF0cml4Lmxlbmd0aCkge1xuICAgIG1hdHJpeCA9IHYubWF0cml4O1xuXG4gICAgaWYgKGNhY2hlLmNvbnRyYXN0ICE9PSAxKSB7XG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiY29udHJhc3RcIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5odWUpIHtcbiAgICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJodWVcIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5icmlnaHRuZXNzICE9PSAxKSB7XG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiYnJpZ2h0bmVzc1wiLCBwZywgY2FjaGUsIF9DTUZkZWZhdWx0cyk7XG4gICAgfVxuXG4gICAgaWYgKGNhY2hlLmNvbG9yaXplQW1vdW50KSB7XG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiY29sb3JpemVcIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuXG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiY29sb3JpemVBbW91bnRcIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5zYXR1cmF0aW9uICE9PSAxKSB7XG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwic2F0dXJhdGlvblwiLCBwZywgY2FjaGUsIF9DTUZkZWZhdWx0cyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hdHJpeCA9IF9pZE1hdHJpeC5zbGljZSgpO1xuXG4gICAgaWYgKHYuY29udHJhc3QgIT0gbnVsbCkge1xuICAgICAgbWF0cml4ID0gX3NldENvbnRyYXN0KG1hdHJpeCwgK3YuY29udHJhc3QpO1xuXG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiY29udHJhc3RcIiwgcGcsIGNhY2hlLCB2KTtcbiAgICB9IGVsc2UgaWYgKGNhY2hlLmNvbnRyYXN0ICE9PSAxKSB7XG4gICAgICBpZiAoY29tYmluZSkge1xuICAgICAgICBtYXRyaXggPSBfc2V0Q29udHJhc3QobWF0cml4LCBjYWNoZS5jb250cmFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiY29udHJhc3RcIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2Lmh1ZSAhPSBudWxsKSB7XG4gICAgICBtYXRyaXggPSBfc2V0SHVlKG1hdHJpeCwgK3YuaHVlKTtcblxuICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImh1ZVwiLCBwZywgY2FjaGUsIHYpO1xuICAgIH0gZWxzZSBpZiAoY2FjaGUuaHVlKSB7XG4gICAgICBpZiAoY29tYmluZSkge1xuICAgICAgICBtYXRyaXggPSBfc2V0SHVlKG1hdHJpeCwgY2FjaGUuaHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJodWVcIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2LmJyaWdodG5lc3MgIT0gbnVsbCkge1xuICAgICAgbWF0cml4ID0gX2FwcGx5QnJpZ2h0bmVzc1RvTWF0cml4KCt2LmJyaWdodG5lc3MsIG1hdHJpeCk7XG5cbiAgICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJicmlnaHRuZXNzXCIsIHBnLCBjYWNoZSwgdik7XG4gICAgfSBlbHNlIGlmIChjYWNoZS5icmlnaHRuZXNzICE9PSAxKSB7XG4gICAgICBpZiAoY29tYmluZSkge1xuICAgICAgICBtYXRyaXggPSBfYXBwbHlCcmlnaHRuZXNzVG9NYXRyaXgoY2FjaGUuYnJpZ2h0bmVzcywgbWF0cml4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJicmlnaHRuZXNzXCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodi5jb2xvcml6ZSAhPSBudWxsKSB7XG4gICAgICB2LmNvbG9yaXplQW1vdW50ID0gXCJjb2xvcml6ZUFtb3VudFwiIGluIHYgPyArdi5jb2xvcml6ZUFtb3VudCA6IDE7XG4gICAgICBtYXRyaXggPSBfY29sb3JpemUobWF0cml4LCB2LmNvbG9yaXplLCB2LmNvbG9yaXplQW1vdW50KTtcblxuICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImNvbG9yaXplXCIsIHBnLCBjYWNoZSwgdik7XG5cbiAgICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJjb2xvcml6ZUFtb3VudFwiLCBwZywgY2FjaGUsIHYpO1xuICAgIH0gZWxzZSBpZiAoY2FjaGUuY29sb3JpemVBbW91bnQpIHtcbiAgICAgIGlmIChjb21iaW5lKSB7XG4gICAgICAgIG1hdHJpeCA9IF9jb2xvcml6ZShtYXRyaXgsIGNhY2hlLmNvbG9yaXplLCBjYWNoZS5jb2xvcml6ZUFtb3VudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiY29sb3JpemVcIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuXG4gICAgICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJjb2xvcml6ZUFtb3VudFwiLCBwZywgY2FjaGUsIF9DTUZkZWZhdWx0cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHYuc2F0dXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICBtYXRyaXggPSBfc2V0U2F0dXJhdGlvbihtYXRyaXgsICt2LnNhdHVyYXRpb24pO1xuXG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwic2F0dXJhdGlvblwiLCBwZywgY2FjaGUsIHYpO1xuICAgIH0gZWxzZSBpZiAoY2FjaGUuc2F0dXJhdGlvbiAhPT0gMSkge1xuICAgICAgaWYgKGNvbWJpbmUpIHtcbiAgICAgICAgbWF0cml4ID0gX3NldFNhdHVyYXRpb24obWF0cml4LCBjYWNoZS5zYXR1cmF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJzYXR1cmF0aW9uXCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpID0gbWF0cml4Lmxlbmd0aDtcblxuICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICBpZiAobWF0cml4W2ldICE9PSBzdGFydE1hdHJpeFtpXSkge1xuICAgICAgcGcuYWRkKHN0YXJ0TWF0cml4LCBpLCBzdGFydE1hdHJpeFtpXSwgbWF0cml4W2ldLCBcImNvbG9yTWF0cml4RmlsdGVyXCIpO1xuICAgIH1cbiAgfVxuXG4gIHBnLl9wcm9wcy5wdXNoKFwiY29sb3JNYXRyaXhGaWx0ZXJcIik7XG59LFxuICAgIF9yZW5kZXJDb2xvciA9IGZ1bmN0aW9uIF9yZW5kZXJDb2xvcihyYXRpbywgX3JlZikge1xuICB2YXIgdCA9IF9yZWYudCxcbiAgICAgIHAgPSBfcmVmLnAsXG4gICAgICBjb2xvciA9IF9yZWYuY29sb3IsXG4gICAgICBzZXQgPSBfcmVmLnNldDtcbiAgc2V0KHQsIHAsIGNvbG9yWzBdIDw8IDE2IHwgY29sb3JbMV0gPDwgOCB8IGNvbG9yWzJdKTtcbn0sXG4gICAgX3JlbmRlckRpcnR5Q2FjaGUgPSBmdW5jdGlvbiBfcmVuZGVyRGlydHlDYWNoZShyYXRpbywgX3JlZjIpIHtcbiAgdmFyIGcgPSBfcmVmMi5nO1xuXG4gIGlmIChnKSB7XG4gICAgLy9pbiBvcmRlciBmb3IgUGl4aUpTIHRvIGFjdHVhbGx5IHJlZHJhdyBHcmFwaGljc0RhdGEsIHdlJ3ZlIGdvdHRhIGluY3JlbWVudCB0aGUgXCJkaXJ0eVwiIGFuZCBcImNsZWFyRGlydHlcIiB2YWx1ZXMuIElmIHdlIGRvbid0IGRvIHRoaXMsIHRoZSB2YWx1ZXMgd2lsbCBiZSB0d2VlbiBwcm9wZXJseSwgYnV0IG5vdCByZW5kZXJlZC5cbiAgICBnLmRpcnR5Kys7XG4gICAgZy5jbGVhckRpcnR5Kys7XG4gIH1cbn0sXG4gICAgX3JlbmRlckF1dG9BbHBoYSA9IGZ1bmN0aW9uIF9yZW5kZXJBdXRvQWxwaGEocmF0aW8sIGRhdGEpIHtcbiAgZGF0YS50LnZpc2libGUgPSAhIWRhdGEudC5hbHBoYTtcbn0sXG4gICAgX2FkZENvbG9yVHdlZW4gPSBmdW5jdGlvbiBfYWRkQ29sb3JUd2Vlbih0YXJnZXQsIHAsIHZhbHVlLCBwbHVnaW4pIHtcbiAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRhcmdldFtwXSxcbiAgICAgIHN0YXJ0Q29sb3IgPSBfc3BsaXRDb2xvcihfaXNGdW5jdGlvbihjdXJyZW50VmFsdWUpID8gdGFyZ2V0W3AuaW5kZXhPZihcInNldFwiKSB8fCAhX2lzRnVuY3Rpb24odGFyZ2V0W1wiZ2V0XCIgKyBwLnN1YnN0cigzKV0pID8gcCA6IFwiZ2V0XCIgKyBwLnN1YnN0cigzKV0oKSA6IGN1cnJlbnRWYWx1ZSksXG4gICAgICBlbmRDb2xvciA9IF9zcGxpdENvbG9yKHZhbHVlKTtcblxuICBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHAsIDAsIDAsIF9yZW5kZXJDb2xvciwge1xuICAgIHQ6IHRhcmdldCxcbiAgICBwOiBwLFxuICAgIGNvbG9yOiBzdGFydENvbG9yLFxuICAgIHNldDogX2dldFNldHRlcih0YXJnZXQsIHApXG4gIH0pO1xuICBwbHVnaW4uYWRkKHN0YXJ0Q29sb3IsIDAsIHN0YXJ0Q29sb3JbMF0sIGVuZENvbG9yWzBdKTtcbiAgcGx1Z2luLmFkZChzdGFydENvbG9yLCAxLCBzdGFydENvbG9yWzFdLCBlbmRDb2xvclsxXSk7XG4gIHBsdWdpbi5hZGQoc3RhcnRDb2xvciwgMiwgc3RhcnRDb2xvclsyXSwgZW5kQ29sb3JbMl0pO1xufSxcbiAgICBfY29sb3JQcm9wcyA9IHtcbiAgdGludDogMSxcbiAgbGluZUNvbG9yOiAxLFxuICBmaWxsQ29sb3I6IDFcbn0sXG4gICAgX3h5Q29udGV4dHMgPSBcInBvc2l0aW9uLHNjYWxlLHNrZXcscGl2b3QsYW5jaG9yLHRpbGVQb3NpdGlvbix0aWxlU2NhbGVcIi5zcGxpdChcIixcIiksXG4gICAgX2NvbnRleHRzID0ge1xuICB4OiBcInBvc2l0aW9uXCIsXG4gIHk6IFwicG9zaXRpb25cIixcbiAgdGlsZVg6IFwidGlsZVBvc2l0aW9uXCIsXG4gIHRpbGVZOiBcInRpbGVQb3NpdGlvblwiXG59LFxuICAgIF9jb2xvck1hdHJpeEZpbHRlclByb3BzID0ge1xuICBjb2xvck1hdHJpeEZpbHRlcjogMSxcbiAgc2F0dXJhdGlvbjogMSxcbiAgY29udHJhc3Q6IDEsXG4gIGh1ZTogMSxcbiAgY29sb3JpemU6IDEsXG4gIGNvbG9yaXplQW1vdW50OiAxLFxuICBicmlnaHRuZXNzOiAxLFxuICBjb21iaW5lQ01GOiAxXG59LFxuICAgIF9ERUcyUkFEID0gTWF0aC5QSSAvIDE4MCxcbiAgICBfaXNTdHJpbmcgPSBmdW5jdGlvbiBfaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbn0sXG4gICAgX2RlZ3JlZXNUb1JhZGlhbnMgPSBmdW5jdGlvbiBfZGVncmVlc1RvUmFkaWFucyh2YWx1ZSkge1xuICByZXR1cm4gX2lzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiID8gdmFsdWUuc3Vic3RyKDAsIDIpICsgcGFyc2VGbG9hdCh2YWx1ZS5zdWJzdHIoMikpICogX0RFRzJSQUQgOiB2YWx1ZSAqIF9ERUcyUkFEO1xufSxcbiAgICBfcmVuZGVyUHJvcFdpdGhFbmQgPSBmdW5jdGlvbiBfcmVuZGVyUHJvcFdpdGhFbmQocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA9PT0gMSA/IGRhdGEuZSA6IE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwMCkgLyAxMDAwMDAsIGRhdGEpO1xufSxcbiAgICBfYWRkUm90YXRpb25hbFByb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnROdW0sIGVuZFZhbHVlLCByYWRpYW5zKSB7XG4gIHZhciBjYXAgPSAzNjAgKiAocmFkaWFucyA/IF9ERUcyUkFEIDogMSksXG4gICAgICBpc1N0cmluZyA9IF9pc1N0cmluZyhlbmRWYWx1ZSksXG4gICAgICByZWxhdGl2ZSA9IGlzU3RyaW5nICYmIGVuZFZhbHVlLmNoYXJBdCgxKSA9PT0gXCI9XCIgPyArKGVuZFZhbHVlLmNoYXJBdCgwKSArIFwiMVwiKSA6IDAsXG4gICAgICBlbmROdW0gPSBwYXJzZUZsb2F0KHJlbGF0aXZlID8gZW5kVmFsdWUuc3Vic3RyKDIpIDogZW5kVmFsdWUpICogKHJhZGlhbnMgPyBfREVHMlJBRCA6IDEpLFxuICAgICAgY2hhbmdlID0gcmVsYXRpdmUgPyBlbmROdW0gKiByZWxhdGl2ZSA6IGVuZE51bSAtIHN0YXJ0TnVtLFxuICAgICAgZmluYWxWYWx1ZSA9IHN0YXJ0TnVtICsgY2hhbmdlLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgcHQ7XG5cbiAgaWYgKGlzU3RyaW5nKSB7XG4gICAgZGlyZWN0aW9uID0gZW5kVmFsdWUuc3BsaXQoXCJfXCIpWzFdO1xuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJzaG9ydFwiKSB7XG4gICAgICBjaGFuZ2UgJT0gY2FwO1xuXG4gICAgICBpZiAoY2hhbmdlICE9PSBjaGFuZ2UgJSAoY2FwIC8gMikpIHtcbiAgICAgICAgY2hhbmdlICs9IGNoYW5nZSA8IDAgPyBjYXAgOiAtY2FwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwiY3dcIiAmJiBjaGFuZ2UgPCAwKSB7XG4gICAgICBjaGFuZ2UgPSAoY2hhbmdlICsgY2FwICogMWUxMCkgJSBjYXAgLSB+fihjaGFuZ2UgLyBjYXApICogY2FwO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBcImNjd1wiICYmIGNoYW5nZSA+IDApIHtcbiAgICAgIGNoYW5nZSA9IChjaGFuZ2UgLSBjYXAgKiAxZTEwKSAlIGNhcCAtIH5+KGNoYW5nZSAvIGNhcCkgKiBjYXA7XG4gICAgfVxuICB9XG5cbiAgcGx1Z2luLl9wdCA9IHB0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCBzdGFydE51bSwgY2hhbmdlLCBfcmVuZGVyUHJvcFdpdGhFbmQpO1xuICBwdC5lID0gZmluYWxWYWx1ZTtcbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoKSB7XG4gIGlmICghX2NvcmVJbml0dGVkKSB7XG4gICAgZ3NhcCA9IF9nZXRHU0FQKCk7XG4gICAgX1BJWEkgPSBfY29yZUluaXR0ZWQgPSBfUElYSSB8fCBfd2luZG93RXhpc3RzKCkgJiYgd2luZG93LlBJWEk7XG4gICAgX2lzVjQgPSBfUElYSSAmJiBfUElYSS5WRVJTSU9OICYmIF9QSVhJLlZFUlNJT04uY2hhckF0KDApID09PSBcIjRcIjtcblxuICAgIF9zcGxpdENvbG9yID0gZnVuY3Rpb24gX3NwbGl0Q29sb3IoY29sb3IpIHtcbiAgICAgIHJldHVybiBnc2FwLnV0aWxzLnNwbGl0Q29sb3IoKGNvbG9yICsgXCJcIikuc3Vic3RyKDAsIDIpID09PSBcIjB4XCIgPyBcIiNcIiArIGNvbG9yLnN1YnN0cigyKSA6IGNvbG9yKTtcbiAgICB9OyAvLyBzb21lIGNvbG9ycyBpbiBQSVhJIGFyZSByZXBvcnRlZCBhcyBcIjB4RkY0NDIxXCIgaW5zdGVhZCBvZiBcIiNGRjQ0MjFcIi5cblxuICB9XG59LFxuICAgIGksXG4gICAgcDsgLy9jb250ZXh0IHNldHVwLi4uXG5cblxuZm9yIChpID0gMDsgaSA8IF94eUNvbnRleHRzLmxlbmd0aDsgaSsrKSB7XG4gIHAgPSBfeHlDb250ZXh0c1tpXTtcbiAgX2NvbnRleHRzW3AgKyBcIlhcIl0gPSBwO1xuICBfY29udGV4dHNbcCArIFwiWVwiXSA9IHA7XG59XG5cbmV4cG9ydCB2YXIgUGl4aVBsdWdpbiA9IHtcbiAgdmVyc2lvbjogXCIzLjEyLjVcIixcbiAgbmFtZTogXCJwaXhpXCIsXG4gIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3Rlcihjb3JlLCBQbHVnaW4sIHByb3BUd2Vlbikge1xuICAgIGdzYXAgPSBjb3JlO1xuICAgIFByb3BUd2VlbiA9IHByb3BUd2VlbjtcbiAgICBfZ2V0U2V0dGVyID0gUGx1Z2luLmdldFNldHRlcjtcblxuICAgIF9pbml0Q29yZSgpO1xuICB9LFxuICBoZWFkbGVzczogdHJ1ZSxcbiAgLy8gZG9lc24ndCBuZWVkIHdpbmRvd1xuICByZWdpc3RlclBJWEk6IGZ1bmN0aW9uIHJlZ2lzdGVyUElYSShwaXhpKSB7XG4gICAgX1BJWEkgPSBwaXhpO1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFsdWVzLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcbiAgICBfUElYSSB8fCBfaW5pdENvcmUoKTtcblxuICAgIGlmICghX1BJWEkpIHtcbiAgICAgIF93YXJuKFwiUElYSSB3YXMgbm90IGZvdW5kLiBQaXhpUGx1Z2luLnJlZ2lzdGVyUElYSShQSVhJKTtcIik7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY29udGV4dCwgYXhpcywgdmFsdWUsIGNvbG9yTWF0cml4LCBmaWx0ZXIsIHAsIHBhZGRpbmcsIGksIGRhdGE7XG5cbiAgICBmb3IgKHAgaW4gdmFsdWVzKSB7XG4gICAgICBjb250ZXh0ID0gX2NvbnRleHRzW3BdO1xuICAgICAgdmFsdWUgPSB2YWx1ZXNbcF07XG5cbiAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGF4aXMgPSB+cC5jaGFyQXQocC5sZW5ndGggLSAxKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJ4XCIpID8gXCJ4XCIgOiBcInlcIjtcbiAgICAgICAgdGhpcy5hZGQodGFyZ2V0W2NvbnRleHRdLCBheGlzLCB0YXJnZXRbY29udGV4dF1bYXhpc10sIGNvbnRleHQgPT09IFwic2tld1wiID8gX2RlZ3JlZXNUb1JhZGlhbnModmFsdWUpIDogdmFsdWUsIDAsIDAsIDAsIDAsIDAsIDEpO1xuICAgICAgfSBlbHNlIGlmIChwID09PSBcInNjYWxlXCIgfHwgcCA9PT0gXCJhbmNob3JcIiB8fCBwID09PSBcInBpdm90XCIgfHwgcCA9PT0gXCJ0aWxlU2NhbGVcIikge1xuICAgICAgICB0aGlzLmFkZCh0YXJnZXRbcF0sIFwieFwiLCB0YXJnZXRbcF0ueCwgdmFsdWUpO1xuICAgICAgICB0aGlzLmFkZCh0YXJnZXRbcF0sIFwieVwiLCB0YXJnZXRbcF0ueSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChwID09PSBcInJvdGF0aW9uXCIgfHwgcCA9PT0gXCJhbmdsZVwiKSB7XG4gICAgICAgIC8vUElYSSBleHBlY3RzIHJvdGF0aW9uIGluIHJhZGlhbnMsIGJ1dCBhcyBhIGNvbnZlbmllbmNlIHdlIGxldCBmb2xrcyBkZWZpbmUgaXQgaW4gZGVncmVlcyBhbmQgd2UgZG8gdGhlIGNvbnZlcnNpb24uXG4gICAgICAgIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuKHRoaXMsIHRhcmdldCwgcCwgdGFyZ2V0W3BdLCB2YWx1ZSwgcCA9PT0gXCJyb3RhdGlvblwiKTtcbiAgICAgIH0gZWxzZSBpZiAoX2NvbG9yTWF0cml4RmlsdGVyUHJvcHNbcF0pIHtcbiAgICAgICAgaWYgKCFjb2xvck1hdHJpeCkge1xuICAgICAgICAgIF9wYXJzZUNvbG9yTWF0cml4RmlsdGVyKHRhcmdldCwgdmFsdWVzLmNvbG9yTWF0cml4RmlsdGVyIHx8IHZhbHVlcywgdGhpcyk7XG5cbiAgICAgICAgICBjb2xvck1hdHJpeCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJibHVyXCIgfHwgcCA9PT0gXCJibHVyWFwiIHx8IHAgPT09IFwiYmx1cllcIiB8fCBwID09PSBcImJsdXJQYWRkaW5nXCIpIHtcbiAgICAgICAgZmlsdGVyID0gX2dldEZpbHRlcih0YXJnZXQsIFwiQmx1ckZpbHRlclwiKTtcbiAgICAgICAgdGhpcy5hZGQoZmlsdGVyLCBwLCBmaWx0ZXJbcF0sIHZhbHVlKTtcblxuICAgICAgICBpZiAodmFsdWVzLmJsdXJQYWRkaW5nICE9PSAwKSB7XG4gICAgICAgICAgcGFkZGluZyA9IHZhbHVlcy5ibHVyUGFkZGluZyB8fCBNYXRoLm1heChmaWx0ZXJbcF0sIHZhbHVlKSAqIDI7XG4gICAgICAgICAgaSA9IHRhcmdldC5maWx0ZXJzLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICAgICAgdGFyZ2V0LmZpbHRlcnNbaV0ucGFkZGluZyA9IE1hdGgubWF4KHRhcmdldC5maWx0ZXJzW2ldLnBhZGRpbmcsIHBhZGRpbmcpOyAvL2lmIHdlIGRvbid0IGV4cGFuZCB0aGUgcGFkZGluZyBvbiBhbGwgdGhlIGZpbHRlcnMsIGl0IGNhbiBsb29rIGNsaXBwZWQuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF9jb2xvclByb3BzW3BdKSB7XG4gICAgICAgIGlmICgocCA9PT0gXCJsaW5lQ29sb3JcIiB8fCBwID09PSBcImZpbGxDb2xvclwiKSAmJiB0YXJnZXQgaW5zdGFuY2VvZiBfUElYSS5HcmFwaGljcykge1xuICAgICAgICAgIGRhdGEgPSAodGFyZ2V0Lmdlb21ldHJ5IHx8IHRhcmdldCkuZ3JhcGhpY3NEYXRhOyAvL1wiZ2VvbWV0cnlcIiB3YXMgaW50cm9kdWNlZCBpbiBQSVhJIHZlcnNpb24gNVxuXG4gICAgICAgICAgdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCB0YXJnZXQsIHAsIDAsIDAsIF9yZW5kZXJEaXJ0eUNhY2hlLCB7XG4gICAgICAgICAgICBnOiB0YXJnZXQuZ2VvbWV0cnkgfHwgdGFyZ2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaSA9IGRhdGEubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICAgICAgICBfYWRkQ29sb3JUd2VlbihfaXNWNCA/IGRhdGFbaV0gOiBkYXRhW2ldW3Auc3Vic3RyKDAsIDQpICsgXCJTdHlsZVwiXSwgX2lzVjQgPyBwIDogXCJjb2xvclwiLCB2YWx1ZSwgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9hZGRDb2xvclR3ZWVuKHRhcmdldCwgcCwgdmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHAgPT09IFwiYXV0b0FscGhhXCIpIHtcbiAgICAgICAgdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCB0YXJnZXQsIFwidmlzaWJsZVwiLCAwLCAwLCBfcmVuZGVyQXV0b0FscGhhKTtcbiAgICAgICAgdGhpcy5hZGQodGFyZ2V0LCBcImFscGhhXCIsIHRhcmdldC5hbHBoYSwgdmFsdWUpO1xuXG4gICAgICAgIHRoaXMuX3Byb3BzLnB1c2goXCJhbHBoYVwiLCBcInZpc2libGVcIik7XG4gICAgICB9IGVsc2UgaWYgKHAgIT09IFwicmVzb2x1dGlvblwiKSB7XG4gICAgICAgIHRoaXMuYWRkKHRhcmdldCwgcCwgXCJnZXRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wcm9wcy5wdXNoKHApO1xuICAgIH1cbiAgfVxufTtcbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihQaXhpUGx1Z2luKTtcbmV4cG9ydCB7IFBpeGlQbHVnaW4gYXMgZGVmYXVsdCB9OyJdLCJuYW1lcyI6WyJnc2FwIiwiX3NwbGl0Q29sb3IiLCJfY29yZUluaXR0ZWQiLCJfUElYSSIsIlByb3BUd2VlbiIsIl9nZXRTZXR0ZXIiLCJfaXNWNCIsIl93aW5kb3dFeGlzdHMiLCJ3aW5kb3ciLCJfZ2V0R1NBUCIsInJlZ2lzdGVyUGx1Z2luIiwiX2lzRnVuY3Rpb24iLCJ2YWx1ZSIsIl93YXJuIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwiX2lkTWF0cml4IiwiX2x1bVIiLCJfbHVtRyIsIl9sdW1CIiwiX2ZpbHRlckNsYXNzIiwibmFtZSIsImZpbHRlcnMiLCJfYXBwbHlNYXRyaXgiLCJtIiwibTIiLCJ0ZW1wIiwiaSIsInoiLCJ5IiwieCIsIl9zZXRTYXR1cmF0aW9uIiwibiIsImludiIsInIiLCJnIiwiYiIsIl9jb2xvcml6ZSIsImNvbG9yIiwiYW1vdW50IiwiYyIsIl9zZXRIdWUiLCJNYXRoIiwiUEkiLCJjb3MiLCJzIiwic2luIiwiX3NldENvbnRyYXN0IiwiX2dldEZpbHRlciIsInRhcmdldCIsInR5cGUiLCJmaWx0ZXJDbGFzcyIsImxlbmd0aCIsImZpbHRlciIsImJsdXIiLCJwdXNoIiwiX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbiIsInAiLCJwbHVnaW4iLCJjYWNoZSIsInZhcnMiLCJhZGQiLCJfcHJvcHMiLCJfYXBwbHlCcmlnaHRuZXNzVG9NYXRyaXgiLCJicmlnaHRuZXNzIiwibWF0cml4IiwiX2NvcHkiLCJvYmoiLCJjb3B5IiwiX0NNRmRlZmF1bHRzIiwiY29udHJhc3QiLCJzYXR1cmF0aW9uIiwiY29sb3JpemVBbW91bnQiLCJjb2xvcml6ZSIsImh1ZSIsIl9wYXJzZUNvbG9yTWF0cml4RmlsdGVyIiwidiIsInBnIiwiX2dzQ29sb3JNYXRyaXhGaWx0ZXIiLCJjb21iaW5lIiwiY29tYmluZUNNRiIsImNvbG9yTWF0cml4RmlsdGVyIiwic3RhcnRNYXRyaXgiLCJyZXNvbHV0aW9uIiwic2xpY2UiLCJfcmVuZGVyQ29sb3IiLCJyYXRpbyIsIl9yZWYiLCJ0Iiwic2V0IiwiX3JlbmRlckRpcnR5Q2FjaGUiLCJfcmVmMiIsImRpcnR5IiwiY2xlYXJEaXJ0eSIsIl9yZW5kZXJBdXRvQWxwaGEiLCJkYXRhIiwidmlzaWJsZSIsImFscGhhIiwiX2FkZENvbG9yVHdlZW4iLCJjdXJyZW50VmFsdWUiLCJzdGFydENvbG9yIiwiaW5kZXhPZiIsInN1YnN0ciIsImVuZENvbG9yIiwiX3B0IiwiX2NvbG9yUHJvcHMiLCJ0aW50IiwibGluZUNvbG9yIiwiZmlsbENvbG9yIiwiX3h5Q29udGV4dHMiLCJzcGxpdCIsIl9jb250ZXh0cyIsInRpbGVYIiwidGlsZVkiLCJfY29sb3JNYXRyaXhGaWx0ZXJQcm9wcyIsIl9ERUcyUkFEIiwiX2lzU3RyaW5nIiwiX2RlZ3JlZXNUb1JhZGlhbnMiLCJjaGFyQXQiLCJwYXJzZUZsb2F0IiwiX3JlbmRlclByb3BXaXRoRW5kIiwiZSIsInJvdW5kIiwiX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4iLCJwcm9wZXJ0eSIsInN0YXJ0TnVtIiwiZW5kVmFsdWUiLCJyYWRpYW5zIiwiY2FwIiwiaXNTdHJpbmciLCJyZWxhdGl2ZSIsImVuZE51bSIsImNoYW5nZSIsImZpbmFsVmFsdWUiLCJkaXJlY3Rpb24iLCJwdCIsIl9pbml0Q29yZSIsIlBJWEkiLCJWRVJTSU9OIiwidXRpbHMiLCJzcGxpdENvbG9yIiwiUGl4aVBsdWdpbiIsInZlcnNpb24iLCJyZWdpc3RlciIsImNvcmUiLCJQbHVnaW4iLCJwcm9wVHdlZW4iLCJnZXRTZXR0ZXIiLCJoZWFkbGVzcyIsInJlZ2lzdGVyUElYSSIsInBpeGkiLCJpbml0IiwidmFsdWVzIiwidHdlZW4iLCJpbmRleCIsInRhcmdldHMiLCJjb250ZXh0IiwiYXhpcyIsImNvbG9yTWF0cml4IiwicGFkZGluZyIsInRvTG93ZXJDYXNlIiwiYmx1clBhZGRpbmciLCJtYXgiLCJHcmFwaGljcyIsImdlb21ldHJ5IiwiZ3JhcGhpY3NEYXRhIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/PixiPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollToPlugin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollToPlugin.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrollToPlugin: function() { return /* binding */ ScrollToPlugin; },\n/* harmony export */   \"default\": function() { return /* binding */ ScrollToPlugin; }\n/* harmony export */ });\n/*!\n * ScrollToPlugin 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var gsap, _coreInitted, _window, _docEl, _body, _toArray, _config, ScrollTrigger, _windowExists = function _windowExists() {\n    return typeof window !== \"undefined\";\n}, _getGSAP = function _getGSAP() {\n    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _isString = function _isString(value) {\n    return typeof value === \"string\";\n}, _isFunction = function _isFunction(value) {\n    return typeof value === \"function\";\n}, _max = function _max(element, axis) {\n    var dim = axis === \"x\" ? \"Width\" : \"Height\", scroll = \"scroll\" + dim, client = \"client\" + dim;\n    return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window[\"inner\" + dim] || _docEl[client] || _body[client]) : element[scroll] - element[\"offset\" + dim];\n}, _buildGetter = function _buildGetter(e, axis) {\n    //pass in an element and an axis (\"x\" or \"y\") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.\n    var p = \"scroll\" + (axis === \"x\" ? \"Left\" : \"Top\");\n    if (e === _window) {\n        if (e.pageXOffset != null) {\n            p = \"page\" + axis.toUpperCase() + \"Offset\";\n        } else {\n            e = _docEl[p] != null ? _docEl : _body;\n        }\n    }\n    return function() {\n        return e[p];\n    };\n}, _clean = function _clean(value, index, target, targets) {\n    _isFunction(value) && (value = value(index, target, targets));\n    if (typeof value !== \"object\") {\n        return _isString(value) && value !== \"max\" && value.charAt(1) !== \"=\" ? {\n            x: value,\n            y: value\n        } : {\n            y: value\n        }; //if we don't receive an object as the parameter, assume the user intends \"y\".\n    } else if (value.nodeType) {\n        return {\n            y: value,\n            x: value\n        };\n    } else {\n        var result = {}, p;\n        for(p in value){\n            result[p] = p !== \"onAutoKill\" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];\n        }\n        return result;\n    }\n}, _getOffset = function _getOffset(element, container) {\n    element = _toArray(element)[0];\n    if (!element || !element.getBoundingClientRect) {\n        return console.warn(\"scrollTo target doesn't exist. Using 0\") || {\n            x: 0,\n            y: 0\n        };\n    }\n    var rect = element.getBoundingClientRect(), isRoot = !container || container === _window || container === _body, cRect = isRoot ? {\n        top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),\n        left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)\n    } : container.getBoundingClientRect(), offsets = {\n        x: rect.left - cRect.left,\n        y: rect.top - cRect.top\n    };\n    if (!isRoot && container) {\n        //only add the current scroll position if it's not the window/body.\n        offsets.x += _buildGetter(container, \"x\")();\n        offsets.y += _buildGetter(container, \"y\")();\n    }\n    return offsets;\n}, _parseVal = function _parseVal(value, target, axis, currentVal, offset) {\n    return !isNaN(value) && typeof value !== \"object\" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === \"=\" ? parseFloat(value.substr(2)) * (value.charAt(0) === \"-\" ? -1 : 1) + currentVal - offset : value === \"max\" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);\n}, _initCore = function _initCore() {\n    gsap = _getGSAP();\n    if (_windowExists() && gsap && typeof document !== \"undefined\" && document.body) {\n        _window = window;\n        _body = document.body;\n        _docEl = document.documentElement;\n        _toArray = gsap.utils.toArray;\n        gsap.config({\n            autoKillThreshold: 7\n        });\n        _config = gsap.config();\n        _coreInitted = 1;\n    }\n};\nvar ScrollToPlugin = {\n    version: \"3.12.5\",\n    name: \"scrollTo\",\n    rawVars: 1,\n    register: function register(core) {\n        gsap = core;\n        _initCore();\n    },\n    init: function init(target, value, tween, index, targets) {\n        _coreInitted || _initCore();\n        var data = this, snapType = gsap.getProperty(target, \"scrollSnapType\");\n        data.isWin = target === _window;\n        data.target = target;\n        data.tween = tween;\n        value = _clean(value, index, target, targets);\n        data.vars = value;\n        data.autoKill = !!value.autoKill;\n        data.getX = _buildGetter(target, \"x\");\n        data.getY = _buildGetter(target, \"y\");\n        data.x = data.xPrev = data.getX();\n        data.y = data.yPrev = data.getY();\n        ScrollTrigger || (ScrollTrigger = gsap.core.globals().ScrollTrigger);\n        gsap.getProperty(target, \"scrollBehavior\") === \"smooth\" && gsap.set(target, {\n            scrollBehavior: \"auto\"\n        });\n        if (snapType && snapType !== \"none\") {\n            // disable scroll snapping to avoid strange behavior\n            data.snap = 1;\n            data.snapInline = target.style.scrollSnapType;\n            target.style.scrollSnapType = \"none\";\n        }\n        if (value.x != null) {\n            data.add(data, \"x\", data.x, _parseVal(value.x, target, \"x\", data.x, value.offsetX || 0), index, targets);\n            data._props.push(\"scrollTo_x\");\n        } else {\n            data.skipX = 1;\n        }\n        if (value.y != null) {\n            data.add(data, \"y\", data.y, _parseVal(value.y, target, \"y\", data.y, value.offsetY || 0), index, targets);\n            data._props.push(\"scrollTo_y\");\n        } else {\n            data.skipY = 1;\n        }\n    },\n    render: function render(ratio, data) {\n        var pt = data._pt, target = data.target, tween = data.tween, autoKill = data.autoKill, xPrev = data.xPrev, yPrev = data.yPrev, isWin = data.isWin, snap = data.snap, snapInline = data.snapInline, x, y, yDif, xDif, threshold;\n        while(pt){\n            pt.r(ratio, pt.d);\n            pt = pt._next;\n        }\n        x = isWin || !data.skipX ? data.getX() : xPrev;\n        y = isWin || !data.skipY ? data.getY() : yPrev;\n        yDif = y - yPrev;\n        xDif = x - xPrev;\n        threshold = _config.autoKillThreshold;\n        if (data.x < 0) {\n            //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)\n            data.x = 0;\n        }\n        if (data.y < 0) {\n            data.y = 0;\n        }\n        if (autoKill) {\n            //note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.\n            if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, \"x\")) {\n                data.skipX = 1; //if the user scrolls separately, we should stop tweening!\n            }\n            if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, \"y\")) {\n                data.skipY = 1; //if the user scrolls separately, we should stop tweening!\n            }\n            if (data.skipX && data.skipY) {\n                tween.kill();\n                data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);\n            }\n        }\n        if (isWin) {\n            _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);\n        } else {\n            data.skipY || (target.scrollTop = data.y);\n            data.skipX || (target.scrollLeft = data.x);\n        }\n        if (snap && (ratio === 1 || ratio === 0)) {\n            y = target.scrollTop;\n            x = target.scrollLeft;\n            snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty(\"scroll-snap-type\");\n            target.scrollTop = y + 1; // bug in Safari causes the element to totally reset its scroll position when scroll-snap-type changes, so we need to set it to a slightly different value and then back again to work around this bug.\n            target.scrollLeft = x + 1;\n            target.scrollTop = y;\n            target.scrollLeft = x;\n        }\n        data.xPrev = data.x;\n        data.yPrev = data.y;\n        ScrollTrigger && ScrollTrigger.update();\n    },\n    kill: function kill(property) {\n        var both = property === \"scrollTo\", i = this._props.indexOf(property);\n        if (both || property === \"scrollTo_x\") {\n            this.skipX = 1;\n        }\n        if (both || property === \"scrollTo_y\") {\n            this.skipY = 1;\n        }\n        i > -1 && this._props.splice(i, 1);\n        return !this._props.length;\n    }\n};\nScrollToPlugin.max = _max;\nScrollToPlugin.getOffset = _getOffset;\nScrollToPlugin.buildGetter = _buildGetter;\n_getGSAP() && gsap.registerPlugin(ScrollToPlugin);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9TY3JvbGxUb1BsdWdpbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCLEdBQ2xCLElBQUlBLE1BQ0FDLGNBQ0FDLFNBQ0FDLFFBQ0FDLE9BQ0FDLFVBQ0FDLFNBQ0FDLGVBQ0FDLGdCQUFnQixTQUFTQTtJQUMzQixPQUFPLE9BQU9DLFdBQVc7QUFDM0IsR0FDSUMsV0FBVyxTQUFTQTtJQUN0QixPQUFPVixRQUFRUSxtQkFBb0JSLENBQUFBLE9BQU9TLE9BQU9ULElBQUksS0FBS0EsS0FBS1csY0FBYyxJQUFJWDtBQUNuRixHQUNJWSxZQUFZLFNBQVNBLFVBQVVDLEtBQUs7SUFDdEMsT0FBTyxPQUFPQSxVQUFVO0FBQzFCLEdBQ0lDLGNBQWMsU0FBU0EsWUFBWUQsS0FBSztJQUMxQyxPQUFPLE9BQU9BLFVBQVU7QUFDMUIsR0FDSUUsT0FBTyxTQUFTQSxLQUFLQyxPQUFPLEVBQUVDLElBQUk7SUFDcEMsSUFBSUMsTUFBTUQsU0FBUyxNQUFNLFVBQVUsVUFDL0JFLFNBQVMsV0FBV0QsS0FDcEJFLFNBQVMsV0FBV0Y7SUFDeEIsT0FBT0YsWUFBWWQsV0FBV2MsWUFBWWIsVUFBVWEsWUFBWVosUUFBUWlCLEtBQUtDLEdBQUcsQ0FBQ25CLE1BQU0sQ0FBQ2dCLE9BQU8sRUFBRWYsS0FBSyxDQUFDZSxPQUFPLElBQUtqQixDQUFBQSxPQUFPLENBQUMsVUFBVWdCLElBQUksSUFBSWYsTUFBTSxDQUFDaUIsT0FBTyxJQUFJaEIsS0FBSyxDQUFDZ0IsT0FBTyxJQUFJSixPQUFPLENBQUNHLE9BQU8sR0FBR0gsT0FBTyxDQUFDLFdBQVdFLElBQUk7QUFDM04sR0FDSUssZUFBZSxTQUFTQSxhQUFhQyxDQUFDLEVBQUVQLElBQUk7SUFDOUMsc1hBQXNYO0lBQ3RYLElBQUlRLElBQUksV0FBWVIsQ0FBQUEsU0FB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QUFPcUIsVUFBVSxHQUFHbEIsSUFBSTtZQUN4QkgsT0FBT2tCLFNBQVMsR0FBR2Q7WUFDbkJKLE9BQU9xQixVQUFVLEdBQUdsQjtRQUN0QjtRQUVBMkMsS0FBS1EsS0FBSyxHQUFHUixLQUFLM0MsQ0FBQztRQUNuQjJDLEtBQUtTLEtBQUssR0FBR1QsS0FBSzFDLENBQUM7UUFDbkIzQixpQkFBaUJBLGNBQWM2RyxNQUFNO0lBQ3ZDO0lBQ0FOLE1BQU0sU0FBU0EsS0FBS08sUUFBUTtRQUMxQixJQUFJQyxPQUFPRCxhQUFhLFlBQ3BCRSxJQUFJLElBQUksQ0FBQ3hCLE1BQU0sQ0FBQ3lCLE9BQU8sQ0FBQ0g7UUFFNUIsSUFBSUMsUUFBUUQsYUFBYSxjQUFjO1lBQ3JDLElBQUksQ0FBQ3BCLEtBQUssR0FBRztRQUNmO1FBRUEsSUFBSXFCLFFBQVFELGFBQWEsY0FBYztZQUNyQyxJQUFJLENBQUNsQixLQUFLLEdBQUc7UUFDZjtRQUVBb0IsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDeEIsTUFBTSxDQUFDMEIsTUFBTSxDQUFDRixHQUFHO1FBQ2hDLE9BQU8sQ0FBQyxJQUFJLENBQUN4QixNQUFNLENBQUMyQixNQUFNO0lBQzVCO0FBQ0YsRUFBRTtBQUNGdEQsZUFBZTlDLEdBQUcsR0FBR1A7QUFDckJxRCxlQUFldUQsU0FBUyxHQUFHdEY7QUFDM0IrQixlQUFld0QsV0FBVyxHQUFHckc7QUFDN0JiLGNBQWNWLEtBQUtXLGNBQWMsQ0FBQ3lEO0FBQ0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dzYXBAMy4xMi41L25vZGVfbW9kdWxlcy9nc2FwL1Njcm9sbFRvUGx1Z2luLmpzPzhkMjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBTY3JvbGxUb1BsdWdpbiAzLjEyLjVcbiAqIGh0dHBzOi8vZ3NhcC5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDI0LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dzYXAuY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdTQVAgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgZ3NhcCxcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX3dpbmRvdyxcbiAgICBfZG9jRWwsXG4gICAgX2JvZHksXG4gICAgX3RvQXJyYXksXG4gICAgX2NvbmZpZyxcbiAgICBTY3JvbGxUcmlnZ2VyLFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgX3dpbmRvd0V4aXN0cygpICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX2lzU3RyaW5nID0gZnVuY3Rpb24gX2lzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59LFxuICAgIF9pc0Z1bmN0aW9uID0gZnVuY3Rpb24gX2lzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufSxcbiAgICBfbWF4ID0gZnVuY3Rpb24gX21heChlbGVtZW50LCBheGlzKSB7XG4gIHZhciBkaW0gPSBheGlzID09PSBcInhcIiA/IFwiV2lkdGhcIiA6IFwiSGVpZ2h0XCIsXG4gICAgICBzY3JvbGwgPSBcInNjcm9sbFwiICsgZGltLFxuICAgICAgY2xpZW50ID0gXCJjbGllbnRcIiArIGRpbTtcbiAgcmV0dXJuIGVsZW1lbnQgPT09IF93aW5kb3cgfHwgZWxlbWVudCA9PT0gX2RvY0VsIHx8IGVsZW1lbnQgPT09IF9ib2R5ID8gTWF0aC5tYXgoX2RvY0VsW3Njcm9sbF0sIF9ib2R5W3Njcm9sbF0pIC0gKF93aW5kb3dbXCJpbm5lclwiICsgZGltXSB8fCBfZG9jRWxbY2xpZW50XSB8fCBfYm9keVtjbGllbnRdKSA6IGVsZW1lbnRbc2Nyb2xsXSAtIGVsZW1lbnRbXCJvZmZzZXRcIiArIGRpbV07XG59LFxuICAgIF9idWlsZEdldHRlciA9IGZ1bmN0aW9uIF9idWlsZEdldHRlcihlLCBheGlzKSB7XG4gIC8vcGFzcyBpbiBhbiBlbGVtZW50IGFuZCBhbiBheGlzIChcInhcIiBvciBcInlcIikgYW5kIGl0J2xsIHJldHVybiBhIGdldHRlciBmdW5jdGlvbiBmb3IgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGF0IGVsZW1lbnQgKGxpa2Ugc2Nyb2xsVG9wIG9yIHNjcm9sbExlZnQsIGFsdGhvdWdoIGlmIHRoZSBlbGVtZW50IGlzIHRoZSB3aW5kb3csIGl0J2xsIHVzZSB0aGUgcGFnZVhPZmZzZXQvcGFnZVlPZmZzZXQgb3IgdGhlIGRvY3VtZW50RWxlbWVudCdzIHNjcm9sbFRvcC9zY3JvbGxMZWZ0IG9yIGRvY3VtZW50LmJvZHkncy4gQmFzaWNhbGx5IHRoaXMgc3RyZWFtbGluZXMgdGhpbmdzIGFuZCBtYWtlcyBhIHZlcnkgZmFzdCBnZXR0ZXIgYWNyb3NzIGJyb3dzZXJzLlxuICB2YXIgcCA9IFwic2Nyb2xsXCIgKyAoYXhpcyA9PT0gXCJ4XCIgPyBcIkxlZnRcIiA6IFwiVG9wXCIpO1xuXG4gIGlmIChlID09PSBfd2luZG93KSB7XG4gICAgaWYgKGUucGFnZVhPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgcCA9IFwicGFnZVwiICsgYXhpcy50b1VwcGVyQ2FzZSgpICsgXCJPZmZzZXRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZSA9IF9kb2NFbFtwXSAhPSBudWxsID8gX2RvY0VsIDogX2JvZHk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZVtwXTtcbiAgfTtcbn0sXG4gICAgX2NsZWFuID0gZnVuY3Rpb24gX2NsZWFuKHZhbHVlLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSB7XG4gIF9pc0Z1bmN0aW9uKHZhbHVlKSAmJiAodmFsdWUgPSB2YWx1ZShpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSk7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBfaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlICE9PSBcIm1heFwiICYmIHZhbHVlLmNoYXJBdCgxKSAhPT0gXCI9XCIgPyB7XG4gICAgICB4OiB2YWx1ZSxcbiAgICAgIHk6IHZhbHVlXG4gICAgfSA6IHtcbiAgICAgIHk6IHZhbHVlXG4gICAgfTsgLy9pZiB3ZSBkb24ndCByZWNlaXZlIGFuIG9iamVjdCBhcyB0aGUgcGFyYW1ldGVyLCBhc3N1bWUgdGhlIHVzZXIgaW50ZW5kcyBcInlcIi5cbiAgfSBlbHNlIGlmICh2YWx1ZS5ub2RlVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICB5OiB2YWx1ZSxcbiAgICAgIHg6IHZhbHVlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sXG4gICAgICAgIHA7XG5cbiAgICBmb3IgKHAgaW4gdmFsdWUpIHtcbiAgICAgIHJlc3VsdFtwXSA9IHAgIT09IFwib25BdXRvS2lsbFwiICYmIF9pc0Z1bmN0aW9uKHZhbHVlW3BdKSA/IHZhbHVlW3BdKGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIDogdmFsdWVbcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSxcbiAgICBfZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gX2dldE9mZnNldChlbGVtZW50LCBjb250YWluZXIpIHtcbiAgZWxlbWVudCA9IF90b0FycmF5KGVsZW1lbnQpWzBdO1xuXG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICByZXR1cm4gY29uc29sZS53YXJuKFwic2Nyb2xsVG8gdGFyZ2V0IGRvZXNuJ3QgZXhpc3QuIFVzaW5nIDBcIikgfHwge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgaXNSb290ID0gIWNvbnRhaW5lciB8fCBjb250YWluZXIgPT09IF93aW5kb3cgfHwgY29udGFpbmVyID09PSBfYm9keSxcbiAgICAgIGNSZWN0ID0gaXNSb290ID8ge1xuICAgIHRvcDogX2RvY0VsLmNsaWVudFRvcCAtIChfd2luZG93LnBhZ2VZT2Zmc2V0IHx8IF9kb2NFbC5zY3JvbGxUb3AgfHwgX2JvZHkuc2Nyb2xsVG9wIHx8IDApLFxuICAgIGxlZnQ6IF9kb2NFbC5jbGllbnRMZWZ0IC0gKF93aW5kb3cucGFnZVhPZmZzZXQgfHwgX2RvY0VsLnNjcm9sbExlZnQgfHwgX2JvZHkuc2Nyb2xsTGVmdCB8fCAwKVxuICB9IDogY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICB4OiByZWN0LmxlZnQgLSBjUmVjdC5sZWZ0LFxuICAgIHk6IHJlY3QudG9wIC0gY1JlY3QudG9wXG4gIH07XG5cbiAgaWYgKCFpc1Jvb3QgJiYgY29udGFpbmVyKSB7XG4gICAgLy9vbmx5IGFkZCB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gaWYgaXQncyBub3QgdGhlIHdpbmRvdy9ib2R5LlxuICAgIG9mZnNldHMueCArPSBfYnVpbGRHZXR0ZXIoY29udGFpbmVyLCBcInhcIikoKTtcbiAgICBvZmZzZXRzLnkgKz0gX2J1aWxkR2V0dGVyKGNvbnRhaW5lciwgXCJ5XCIpKCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn0sXG4gICAgX3BhcnNlVmFsID0gZnVuY3Rpb24gX3BhcnNlVmFsKHZhbHVlLCB0YXJnZXQsIGF4aXMsIGN1cnJlbnRWYWwsIG9mZnNldCkge1xuICByZXR1cm4gIWlzTmFOKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgPyBwYXJzZUZsb2F0KHZhbHVlKSAtIG9mZnNldCA6IF9pc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuY2hhckF0KDEpID09PSBcIj1cIiA/IHBhcnNlRmxvYXQodmFsdWUuc3Vic3RyKDIpKSAqICh2YWx1ZS5jaGFyQXQoMCkgPT09IFwiLVwiID8gLTEgOiAxKSArIGN1cnJlbnRWYWwgLSBvZmZzZXQgOiB2YWx1ZSA9PT0gXCJtYXhcIiA/IF9tYXgodGFyZ2V0LCBheGlzKSAtIG9mZnNldCA6IE1hdGgubWluKF9tYXgodGFyZ2V0LCBheGlzKSwgX2dldE9mZnNldCh2YWx1ZSwgdGFyZ2V0KVtheGlzXSAtIG9mZnNldCk7XG59LFxuICAgIF9pbml0Q29yZSA9IGZ1bmN0aW9uIF9pbml0Q29yZSgpIHtcbiAgZ3NhcCA9IF9nZXRHU0FQKCk7XG5cbiAgaWYgKF93aW5kb3dFeGlzdHMoKSAmJiBnc2FwICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgX3dpbmRvdyA9IHdpbmRvdztcbiAgICBfYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgX2RvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgIGdzYXAuY29uZmlnKHtcbiAgICAgIGF1dG9LaWxsVGhyZXNob2xkOiA3XG4gICAgfSk7XG4gICAgX2NvbmZpZyA9IGdzYXAuY29uZmlnKCk7XG4gICAgX2NvcmVJbml0dGVkID0gMTtcbiAgfVxufTtcblxuZXhwb3J0IHZhciBTY3JvbGxUb1BsdWdpbiA9IHtcbiAgdmVyc2lvbjogXCIzLjEyLjVcIixcbiAgbmFtZTogXCJzY3JvbGxUb1wiLFxuICByYXdWYXJzOiAxLFxuICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoY29yZSkge1xuICAgIGdzYXAgPSBjb3JlO1xuXG4gICAgX2luaXRDb3JlKCk7XG4gIH0sXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YWx1ZSwgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgX2NvcmVJbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuICAgIHZhciBkYXRhID0gdGhpcyxcbiAgICAgICAgc25hcFR5cGUgPSBnc2FwLmdldFByb3BlcnR5KHRhcmdldCwgXCJzY3JvbGxTbmFwVHlwZVwiKTtcbiAgICBkYXRhLmlzV2luID0gdGFyZ2V0ID09PSBfd2luZG93O1xuICAgIGRhdGEudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGRhdGEudHdlZW4gPSB0d2VlbjtcbiAgICB2YWx1ZSA9IF9jbGVhbih2YWx1ZSwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cyk7XG4gICAgZGF0YS52YXJzID0gdmFsdWU7XG4gICAgZGF0YS5hdXRvS2lsbCA9ICEhdmFsdWUuYXV0b0tpbGw7XG4gICAgZGF0YS5nZXRYID0gX2J1aWxkR2V0dGVyKHRhcmdldCwgXCJ4XCIpO1xuICAgIGRhdGEuZ2V0WSA9IF9idWlsZEdldHRlcih0YXJnZXQsIFwieVwiKTtcbiAgICBkYXRhLnggPSBkYXRhLnhQcmV2ID0gZGF0YS5nZXRYKCk7XG4gICAgZGF0YS55ID0gZGF0YS55UHJldiA9IGRhdGEuZ2V0WSgpO1xuICAgIFNjcm9sbFRyaWdnZXIgfHwgKFNjcm9sbFRyaWdnZXIgPSBnc2FwLmNvcmUuZ2xvYmFscygpLlNjcm9sbFRyaWdnZXIpO1xuICAgIGdzYXAuZ2V0UHJvcGVydHkodGFyZ2V0LCBcInNjcm9sbEJlaGF2aW9yXCIpID09PSBcInNtb290aFwiICYmIGdzYXAuc2V0KHRhcmdldCwge1xuICAgICAgc2Nyb2xsQmVoYXZpb3I6IFwiYXV0b1wiXG4gICAgfSk7XG5cbiAgICBpZiAoc25hcFR5cGUgJiYgc25hcFR5cGUgIT09IFwibm9uZVwiKSB7XG4gICAgICAvLyBkaXNhYmxlIHNjcm9sbCBzbmFwcGluZyB0byBhdm9pZCBzdHJhbmdlIGJlaGF2aW9yXG4gICAgICBkYXRhLnNuYXAgPSAxO1xuICAgICAgZGF0YS5zbmFwSW5saW5lID0gdGFyZ2V0LnN0eWxlLnNjcm9sbFNuYXBUeXBlO1xuICAgICAgdGFyZ2V0LnN0eWxlLnNjcm9sbFNuYXBUeXBlID0gXCJub25lXCI7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLnggIT0gbnVsbCkge1xuICAgICAgZGF0YS5hZGQoZGF0YSwgXCJ4XCIsIGRhdGEueCwgX3BhcnNlVmFsKHZhbHVlLngsIHRhcmdldCwgXCJ4XCIsIGRhdGEueCwgdmFsdWUub2Zmc2V0WCB8fCAwKSwgaW5kZXgsIHRhcmdldHMpO1xuXG4gICAgICBkYXRhLl9wcm9wcy5wdXNoKFwic2Nyb2xsVG9feFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5za2lwWCA9IDE7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLnkgIT0gbnVsbCkge1xuICAgICAgZGF0YS5hZGQoZGF0YSwgXCJ5XCIsIGRhdGEueSwgX3BhcnNlVmFsKHZhbHVlLnksIHRhcmdldCwgXCJ5XCIsIGRhdGEueSwgdmFsdWUub2Zmc2V0WSB8fCAwKSwgaW5kZXgsIHRhcmdldHMpO1xuXG4gICAgICBkYXRhLl9wcm9wcy5wdXNoKFwic2Nyb2xsVG9feVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5za2lwWSA9IDE7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyYXRpbywgZGF0YSkge1xuICAgIHZhciBwdCA9IGRhdGEuX3B0LFxuICAgICAgICB0YXJnZXQgPSBkYXRhLnRhcmdldCxcbiAgICAgICAgdHdlZW4gPSBkYXRhLnR3ZWVuLFxuICAgICAgICBhdXRvS2lsbCA9IGRhdGEuYXV0b0tpbGwsXG4gICAgICAgIHhQcmV2ID0gZGF0YS54UHJldixcbiAgICAgICAgeVByZXYgPSBkYXRhLnlQcmV2LFxuICAgICAgICBpc1dpbiA9IGRhdGEuaXNXaW4sXG4gICAgICAgIHNuYXAgPSBkYXRhLnNuYXAsXG4gICAgICAgIHNuYXBJbmxpbmUgPSBkYXRhLnNuYXBJbmxpbmUsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHlEaWYsXG4gICAgICAgIHhEaWYsXG4gICAgICAgIHRocmVzaG9sZDtcblxuICAgIHdoaWxlIChwdCkge1xuICAgICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cblxuICAgIHggPSBpc1dpbiB8fCAhZGF0YS5za2lwWCA/IGRhdGEuZ2V0WCgpIDogeFByZXY7XG4gICAgeSA9IGlzV2luIHx8ICFkYXRhLnNraXBZID8gZGF0YS5nZXRZKCkgOiB5UHJldjtcbiAgICB5RGlmID0geSAtIHlQcmV2O1xuICAgIHhEaWYgPSB4IC0geFByZXY7XG4gICAgdGhyZXNob2xkID0gX2NvbmZpZy5hdXRvS2lsbFRocmVzaG9sZDtcblxuICAgIGlmIChkYXRhLnggPCAwKSB7XG4gICAgICAvL2Nhbid0IHNjcm9sbCB0byBhIHBvc2l0aW9uIGxlc3MgdGhhbiAwISBNaWdodCBoYXBwZW4gaWYgc29tZW9uZSB1c2VzIGEgQmFjay5lYXNlT3V0IG9yIEVsYXN0aWMuZWFzZU91dCB3aGVuIHNjcm9sbGluZyBiYWNrIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UgKGZvciBleGFtcGxlKVxuICAgICAgZGF0YS54ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS55IDwgMCkge1xuICAgICAgZGF0YS55ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoYXV0b0tpbGwpIHtcbiAgICAgIC8vbm90ZTogaU9TIGhhcyBhIGJ1ZyB0aGF0IHRocm93cyBvZmYgdGhlIHNjcm9sbCBieSBzZXZlcmFsIHBpeGVscywgc28gd2UgbmVlZCB0byBjaGVjayBpZiBpdCdzIHdpdGhpbiA3IHBpeGVscyBvZiB0aGUgcHJldmlvdXMgb25lIHRoYXQgd2Ugc2V0IGluc3RlYWQgb2YganVzdCBsb29raW5nIGZvciBhbiBleGFjdCBtYXRjaC5cbiAgICAgIGlmICghZGF0YS5za2lwWCAmJiAoeERpZiA+IHRocmVzaG9sZCB8fCB4RGlmIDwgLXRocmVzaG9sZCkgJiYgeCA8IF9tYXgodGFyZ2V0LCBcInhcIikpIHtcbiAgICAgICAgZGF0YS5za2lwWCA9IDE7IC8vaWYgdGhlIHVzZXIgc2Nyb2xscyBzZXBhcmF0ZWx5LCB3ZSBzaG91bGQgc3RvcCB0d2VlbmluZyFcbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhLnNraXBZICYmICh5RGlmID4gdGhyZXNob2xkIHx8IHlEaWYgPCAtdGhyZXNob2xkKSAmJiB5IDwgX21heCh0YXJnZXQsIFwieVwiKSkge1xuICAgICAgICBkYXRhLnNraXBZID0gMTsgLy9pZiB0aGUgdXNlciBzY3JvbGxzIHNlcGFyYXRlbHksIHdlIHNob3VsZCBzdG9wIHR3ZWVuaW5nIVxuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5za2lwWCAmJiBkYXRhLnNraXBZKSB7XG4gICAgICAgIHR3ZWVuLmtpbGwoKTtcbiAgICAgICAgZGF0YS52YXJzLm9uQXV0b0tpbGwgJiYgZGF0YS52YXJzLm9uQXV0b0tpbGwuYXBwbHkodHdlZW4sIGRhdGEudmFycy5vbkF1dG9LaWxsUGFyYW1zIHx8IFtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNXaW4pIHtcbiAgICAgIF93aW5kb3cuc2Nyb2xsVG8oIWRhdGEuc2tpcFggPyBkYXRhLnggOiB4LCAhZGF0YS5za2lwWSA/IGRhdGEueSA6IHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLnNraXBZIHx8ICh0YXJnZXQuc2Nyb2xsVG9wID0gZGF0YS55KTtcbiAgICAgIGRhdGEuc2tpcFggfHwgKHRhcmdldC5zY3JvbGxMZWZ0ID0gZGF0YS54KTtcbiAgICB9XG5cbiAgICBpZiAoc25hcCAmJiAocmF0aW8gPT09IDEgfHwgcmF0aW8gPT09IDApKSB7XG4gICAgICB5ID0gdGFyZ2V0LnNjcm9sbFRvcDtcbiAgICAgIHggPSB0YXJnZXQuc2Nyb2xsTGVmdDtcbiAgICAgIHNuYXBJbmxpbmUgPyB0YXJnZXQuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSBzbmFwSW5saW5lIDogdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwic2Nyb2xsLXNuYXAtdHlwZVwiKTtcbiAgICAgIHRhcmdldC5zY3JvbGxUb3AgPSB5ICsgMTsgLy8gYnVnIGluIFNhZmFyaSBjYXVzZXMgdGhlIGVsZW1lbnQgdG8gdG90YWxseSByZXNldCBpdHMgc2Nyb2xsIHBvc2l0aW9uIHdoZW4gc2Nyb2xsLXNuYXAtdHlwZSBjaGFuZ2VzLCBzbyB3ZSBuZWVkIHRvIHNldCBpdCB0byBhIHNsaWdodGx5IGRpZmZlcmVudCB2YWx1ZSBhbmQgdGhlbiBiYWNrIGFnYWluIHRvIHdvcmsgYXJvdW5kIHRoaXMgYnVnLlxuXG4gICAgICB0YXJnZXQuc2Nyb2xsTGVmdCA9IHggKyAxO1xuICAgICAgdGFyZ2V0LnNjcm9sbFRvcCA9IHk7XG4gICAgICB0YXJnZXQuc2Nyb2xsTGVmdCA9IHg7XG4gICAgfVxuXG4gICAgZGF0YS54UHJldiA9IGRhdGEueDtcbiAgICBkYXRhLnlQcmV2ID0gZGF0YS55O1xuICAgIFNjcm9sbFRyaWdnZXIgJiYgU2Nyb2xsVHJpZ2dlci51cGRhdGUoKTtcbiAgfSxcbiAga2lsbDogZnVuY3Rpb24ga2lsbChwcm9wZXJ0eSkge1xuICAgIHZhciBib3RoID0gcHJvcGVydHkgPT09IFwic2Nyb2xsVG9cIixcbiAgICAgICAgaSA9IHRoaXMuX3Byb3BzLmluZGV4T2YocHJvcGVydHkpO1xuXG4gICAgaWYgKGJvdGggfHwgcHJvcGVydHkgPT09IFwic2Nyb2xsVG9feFwiKSB7XG4gICAgICB0aGlzLnNraXBYID0gMTtcbiAgICB9XG5cbiAgICBpZiAoYm90aCB8fCBwcm9wZXJ0eSA9PT0gXCJzY3JvbGxUb195XCIpIHtcbiAgICAgIHRoaXMuc2tpcFkgPSAxO1xuICAgIH1cblxuICAgIGkgPiAtMSAmJiB0aGlzLl9wcm9wcy5zcGxpY2UoaSwgMSk7XG4gICAgcmV0dXJuICF0aGlzLl9wcm9wcy5sZW5ndGg7XG4gIH1cbn07XG5TY3JvbGxUb1BsdWdpbi5tYXggPSBfbWF4O1xuU2Nyb2xsVG9QbHVnaW4uZ2V0T2Zmc2V0ID0gX2dldE9mZnNldDtcblNjcm9sbFRvUGx1Z2luLmJ1aWxkR2V0dGVyID0gX2J1aWxkR2V0dGVyO1xuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRvUGx1Z2luKTtcbmV4cG9ydCB7IFNjcm9sbFRvUGx1Z2luIGFzIGRlZmF1bHQgfTsiXSwibmFtZXMiOlsiZ3NhcCIsIl9jb3JlSW5pdHRlZCIsIl93aW5kb3ciLCJfZG9jRWwiLCJfYm9keSIsIl90b0FycmF5IiwiX2NvbmZpZyIsIlNjcm9sbFRyaWdnZXIiLCJfd2luZG93RXhpc3RzIiwid2luZG93IiwiX2dldEdTQVAiLCJyZWdpc3RlclBsdWdpbiIsIl9pc1N0cmluZyIsInZhbHVlIiwiX2lzRnVuY3Rpb24iLCJfbWF4IiwiZWxlbWVudCIsImF4aXMiLCJkaW0iLCJzY3JvbGwiLCJjbGllbnQiLCJNYXRoIiwibWF4IiwiX2J1aWxkR2V0dGVyIiwiZSIsInAiLCJwYWdlWE9mZnNldCIsInRvVXBwZXJDYXNlIiwiX2NsZWFuIiwiaW5kZXgiLCJ0YXJnZXQiLCJ0YXJnZXRzIiwiY2hhckF0IiwieCIsInkiLCJub2RlVHlwZSIsInJlc3VsdCIsIl9nZXRPZmZzZXQiLCJjb250YWluZXIiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjb25zb2xlIiwid2FybiIsInJlY3QiLCJpc1Jvb3QiLCJjUmVjdCIsInRvcCIsImNsaWVudFRvcCIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG9wIiwibGVmdCIsImNsaWVudExlZnQiLCJzY3JvbGxMZWZ0Iiwib2Zmc2V0cyIsIl9wYXJzZVZhbCIsImN1cnJlbnRWYWwiLCJvZmZzZXQiLCJpc05hTiIsInBhcnNlRmxvYXQiLCJzdWJzdHIiLCJtaW4iLCJfaW5pdENvcmUiLCJkb2N1bWVudCIsImJvZHkiLCJkb2N1bWVudEVsZW1lbnQiLCJ1dGlscyIsInRvQXJyYXkiLCJjb25maWciLCJhdXRvS2lsbFRocmVzaG9sZCIsIlNjcm9sbFRvUGx1Z2luIiwidmVyc2lvbiIsIm5hbWUiLCJyYXdWYXJzIiwicmVnaXN0ZXIiLCJjb3JlIiwiaW5pdCIsInR3ZWVuIiwiZGF0YSIsInNuYXBUeXBlIiwiZ2V0UHJvcGVydHkiLCJpc1dpbiIsInZhcnMiLCJhdXRvS2lsbCIsImdldFgiLCJnZXRZIiwieFByZXYiLCJ5UHJldiIsImdsb2JhbHMiLCJzZXQiLCJzY3JvbGxCZWhhdmlvciIsInNuYXAiLCJzbmFwSW5saW5lIiwic3R5bGUiLCJzY3JvbGxTbmFwVHlwZSIsImFkZCIsIm9mZnNldFgiLCJfcHJvcHMiLCJwdXNoIiwic2tpcFgiLCJvZmZzZXRZIiwic2tpcFkiLCJyZW5kZXIiLCJyYXRpbyIsInB0IiwiX3B0IiwieURpZiIsInhEaWYiLCJ0aHJlc2hvbGQiLCJyIiwiZCIsIl9uZXh0Iiwia2lsbCIsIm9uQXV0b0tpbGwiLCJhcHBseSIsIm9uQXV0b0tpbGxQYXJhbXMiLCJzY3JvbGxUbyIsInJlbW92ZVByb3BlcnR5IiwidXBkYXRlIiwicHJvcGVydHkiLCJib3RoIiwiaSIsImluZGV4T2YiLCJzcGxpY2UiLCJsZW5ndGgiLCJnZXRPZmZzZXQiLCJidWlsZEdldHRlciIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollToPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollTrigger.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollTrigger.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrollTrigger: function() { return /* binding */ ScrollTrigger; },\n/* harmony export */   \"default\": function() { return /* binding */ ScrollTrigger; }\n/* harmony export */ });\n/* harmony import */ var _Observer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Observer.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Observer.js\");\n/*!\n * ScrollTrigger 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ \nvar gsap, _coreInitted, _win, _doc, _docEl, _body, _root, _resizeDelay, _toArray, _clamp, _time2, _syncInterval, _refreshing, _pointerIsDown, _transformProp, _i, _prevWidth, _prevHeight, _autoRefresh, _sort, _suppressOverwrites, _ignoreResize, _normalizer, _ignoreMobileResize, _baseScreenHeight, _baseScreenWidth, _fixIOSBug, _context, _scrollRestoration, _div100vh, _100vh, _isReverted, _clampingMax, _limitCallbacks, // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.\n_startup = 1, _getTime = Date.now, _time1 = _getTime(), _lastScrollTime = 0, _enabled = 0, _parseClamp = function _parseClamp(value, type, self) {\n    var clamp = _isString(value) && (value.substr(0, 6) === \"clamp(\" || value.indexOf(\"max\") > -1);\n    self[\"_\" + type + \"Clamp\"] = clamp;\n    return clamp ? value.substr(6, value.length - 7) : value;\n}, _keepClamp = function _keepClamp(value, clamp) {\n    return clamp && (!_isString(value) || value.substr(0, 6) !== \"clamp(\") ? \"clamp(\" + value + \")\" : value;\n}, _rafBugFix = function _rafBugFix() {\n    return _enabled && requestAnimationFrame(_rafBugFix);\n}, // in some browsers (like Firefox), screen repaints weren't consistent unless we had SOMETHING queued up in requestAnimationFrame()! So this just creates a super simple loop to keep it alive and smooth out repaints.\n_pointerDownHandler = function _pointerDownHandler() {\n    return _pointerIsDown = 1;\n}, _pointerUpHandler = function _pointerUpHandler() {\n    return _pointerIsDown = 0;\n}, _passThrough = function _passThrough(v) {\n    return v;\n}, _round = function _round(value) {\n    return Math.round(value * 100000) / 100000 || 0;\n}, _windowExists = function _windowExists() {\n    return typeof window !== \"undefined\";\n}, _getGSAP = function _getGSAP() {\n    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n}, _isViewport = function _isViewport(e) {\n    return !!~_root.indexOf(e);\n}, _getViewportDimension = function _getViewportDimension(dimensionProperty) {\n    return (dimensionProperty === \"Height\" ? _100vh : _win[\"inner\" + dimensionProperty]) || _docEl[\"client\" + dimensionProperty] || _body[\"client\" + dimensionProperty];\n}, _getBoundsFunc = function _getBoundsFunc(element) {\n    return (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(element, \"getBoundingClientRect\") || (_isViewport(element) ? function() {\n        _winOffsets.width = _win.innerWidth;\n        _winOffsets.height = _100vh;\n        return _winOffsets;\n    } : function() {\n        return _getBounds(element);\n    });\n}, _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {\n    var d = _ref.d, d2 = _ref.d2, a = _ref.a;\n    return (a = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"getBoundingClientRect\")) ? function() {\n        return a()[d];\n    } : function() {\n        return (isViewport ? _getViewportDimension(d2) : scroller[\"client\" + d2]) || 0;\n    };\n}, _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {\n    return !isViewport || ~_Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.indexOf(element) ? _getBoundsFunc(element) : function() {\n        return _winOffsets;\n    };\n}, _maxScroll = function _maxScroll(element, _ref2) {\n    var s = _ref2.s, d2 = _ref2.d2, d = _ref2.d, a = _ref2.a;\n    return Math.max(0, (s = \"scroll\" + d2) && (a = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_docEl[s] || _body[s]) - _getViewportDimension(d2) : element[s] - element[\"offset\" + d2]);\n}, _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {\n    for(var i = 0; i < _autoRefresh.length; i += 3){\n        (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);\n    }\n}, _isString = function _isString(value) {\n    return typeof value === \"string\";\n}, _isFunction = function _isFunction(value) {\n    return typeof value === \"function\";\n}, _isNumber = function _isNumber(value) {\n    return typeof value === \"number\";\n}, _isObject = function _isObject(value) {\n    return typeof value === \"object\";\n}, _endAnimation = function _endAnimation(animation, reversed, pause) {\n    return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();\n}, _callback = function _callback(self, func) {\n    if (self.enabled) {\n        var result = self._ctx ? self._ctx.add(function() {\n            return func(self);\n        }) : func(self);\n        result && result.totalTime && (self.callbackAnimation = result);\n    }\n}, _abs = Math.abs, _left = \"left\", _top = \"top\", _right = \"right\", _bottom = \"bottom\", _width = \"width\", _height = \"height\", _Right = \"Right\", _Left = \"Left\", _Top = \"Top\", _Bottom = \"Bottom\", _padding = \"padding\", _margin = \"margin\", _Width = \"Width\", _Height = \"Height\", _px = \"px\", _getComputedStyle = function _getComputedStyle(element) {\n    return _win.getComputedStyle(element);\n}, _makePositionable = function _makePositionable(element) {\n    // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative\n    var position = _getComputedStyle(element).position;\n    element.style.position = position === \"absolute\" || position === \"fixed\" ? position : \"relative\";\n}, _setDefaults = function _setDefaults(obj, defaults) {\n    for(var p in defaults){\n        p in obj || (obj[p] = defaults[p]);\n    }\n    return obj;\n}, _getBounds = function _getBounds(element, withoutTransforms) {\n    var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== \"matrix(1, 0, 0, 1, 0, 0)\" && gsap.to(element, {\n        x: 0,\n        y: 0,\n        xPercent: 0,\n        yPercent: 0,\n        rotation: 0,\n        rotationX: 0,\n        rotationY: 0,\n        scale: 1,\n        skewX: 0,\n        skewY: 0\n    }).progress(1), bounds = element.getBoundingClientRect();\n    tween && tween.progress(0).kill();\n    return bounds;\n}, _getSize = function _getSize(element, _ref3) {\n    var d2 = _ref3.d2;\n    return element[\"offset\" + d2] || element[\"client\" + d2] || 0;\n}, _getLabelRatioArray = function _getLabelRatioArray(timeline) {\n    var a = [], labels = timeline.labels, duration = timeline.duration(), p;\n    for(p in labels){\n        a.push(labels[p] / duration);\n    }\n    return a;\n}, _getClosestLabel = function _getClosestLabel(animation) {\n    return function(value) {\n        return gsap.utils.snap(_getLabelRatioArray(animation), value);\n    };\n}, _snapDirectional = function _snapDirectional(snapIncrementOrArray) {\n    var snap = gsap.utils.snap(snapIncrementOrArray), a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function(a, b) {\n        return a - b;\n    });\n    return a ? function(value, direction, threshold) {\n        if (threshold === void 0) {\n            threshold = 1e-3;\n        }\n        var i;\n        if (!direction) {\n            return snap(value);\n        }\n        if (direction > 0) {\n            value -= threshold; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.\n            for(i = 0; i < a.length; i++){\n                if (a[i] >= value) {\n                    return a[i];\n                }\n            }\n            return a[i - 1];\n        } else {\n            i = a.length;\n            value += threshold;\n            while(i--){\n                if (a[i] <= value) {\n                    return a[i];\n                }\n            }\n        }\n        return a[0];\n    } : function(value, direction, threshold) {\n        if (threshold === void 0) {\n            threshold = 1e-3;\n        }\n        var snapped = snap(value);\n        return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);\n    };\n}, _getLabelAtDirection = function _getLabelAtDirection(timeline) {\n    return function(value, st) {\n        return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);\n    };\n}, _multiListener = function _multiListener(func, element, types, callback) {\n    return types.split(\",\").forEach(function(type) {\n        return func(element, type, callback);\n    });\n}, _addListener = function _addListener(element, type, func, nonPassive, capture) {\n    return element.addEventListener(type, func, {\n        passive: !nonPassive,\n        capture: !!capture\n    });\n}, _removeListener = function _removeListener(element, type, func, capture) {\n    return element.removeEventListener(type, func, !!capture);\n}, _wheelListener = function _wheelListener(func, el, scrollFunc) {\n    scrollFunc = scrollFunc && scrollFunc.wheelHandler;\n    if (scrollFunc) {\n        func(el, \"wheel\", scrollFunc);\n        func(el, \"touchmove\", scrollFunc);\n    }\n}, _markerDefaults = {\n    startColor: \"green\",\n    endColor: \"red\",\n    indent: 0,\n    fontSize: \"16px\",\n    fontWeight: \"normal\"\n}, _defaults = {\n    toggleActions: \"play\",\n    anticipatePin: 0\n}, _keywords = {\n    top: 0,\n    left: 0,\n    center: 0.5,\n    bottom: 1,\n    right: 1\n}, _offsetToPx = function _offsetToPx(value, size) {\n    if (_isString(value)) {\n        var eqIndex = value.indexOf(\"=\"), relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;\n        if (~eqIndex) {\n            value.indexOf(\"%\") > eqIndex && (relative *= size / 100);\n            value = value.substr(0, eqIndex - 1);\n        }\n        value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf(\"%\") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);\n    }\n    return value;\n}, _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {\n    var startColor = _ref4.startColor, endColor = _ref4.endColor, fontSize = _ref4.fontSize, indent = _ref4.indent, fontWeight = _ref4.fontWeight;\n    var e = _doc.createElement(\"div\"), useFixedPosition = _isViewport(container) || (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(container, \"pinType\") === \"fixed\", isScroller = type.indexOf(\"scroller\") !== -1, parent = useFixedPosition ? _body : container, isStart = type.indexOf(\"start\") !== -1, color = isStart ? startColor : endColor, css = \"border-color:\" + color + \";font-size:\" + fontSize + \";color:\" + color + \";font-weight:\" + fontWeight + \";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;\";\n    css += \"position:\" + ((isScroller || containerAnimation) && useFixedPosition ? \"fixed;\" : \"absolute;\");\n    (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? _right : _bottom) + \":\" + (offset + parseFloat(indent)) + \"px;\");\n    matchWidthEl && (css += \"box-sizing:border-box;text-align:left;width:\" + matchWidthEl.offsetWidth + \"px;\");\n    e._isStart = isStart;\n    e.setAttribute(\"class\", \"gsap-marker-\" + type + (name ? \" marker-\" + name : \"\"));\n    e.style.cssText = css;\n    e.innerText = name || name === 0 ? type + \"-\" + name : type;\n    parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);\n    e._offset = e[\"offset\" + direction.op.d2];\n    _positionMarker(e, 0, direction, isStart);\n    return e;\n}, _positionMarker = function _positionMarker(marker, start, direction, flipped) {\n    var vars = {\n        display: \"block\"\n    }, side = direction[flipped ? \"os2\" : \"p2\"], oppositeSide = direction[flipped ? \"p2\" : \"os2\"];\n    marker._isFlipped = flipped;\n    vars[direction.a + \"Percent\"] = flipped ? -100 : 0;\n    vars[direction.a] = flipped ? \"1px\" : 0;\n    vars[\"border\" + side + _Width] = 1;\n    vars[\"border\" + oppositeSide + _Width] = 0;\n    vars[direction.p] = start + \"px\";\n    gsap.set(marker, vars);\n}, _triggers = [], _ids = {}, _rafID, _sync = function _sync() {\n    return _getTime() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)));\n}, _onScroll = function _onScroll() {\n    // previously, we tried to optimize performance by batching/deferring to the next requestAnimationFrame(), but discovered that Safari has a few bugs that make this unworkable (especially on iOS). See https://codepen.io/GreenSock/pen/16c435b12ef09c38125204818e7b45fc?editors=0010 and https://codepen.io/GreenSock/pen/JjOxYpQ/3dd65ccec5a60f1d862c355d84d14562?editors=0010 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503?editors=0010\n    if (!_normalizer || !_normalizer.isPressed || _normalizer.startX > _body.clientWidth) {\n        // if the user is dragging the scrollbar, allow it.\n        _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\n        if (_normalizer) {\n            _rafID || (_rafID = requestAnimationFrame(_updateAll));\n        } else {\n            _updateAll(); // Safari in particular (on desktop) NEEDS the immediate update rather than waiting for a requestAnimationFrame() whereas iOS seems to benefit from waiting for the requestAnimationFrame() tick, at least when normalizing. See https://codepen.io/GreenSock/pen/qBYozqO?editors=0110\n        }\n        _lastScrollTime || _dispatch(\"scrollStart\");\n        _lastScrollTime = _getTime();\n    }\n}, _setBaseDimensions = function _setBaseDimensions() {\n    _baseScreenWidth = _win.innerWidth;\n    _baseScreenHeight = _win.innerHeight;\n}, _onResize = function _onResize() {\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\n    !_refreshing && !_ignoreResize && !_doc.fullscreenElement && !_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win.innerWidth || Math.abs(_win.innerHeight - _baseScreenHeight) > _win.innerHeight * 0.25) && _resizeDelay.restart(true);\n}, // ignore resizes triggered by refresh()\n_listeners = {}, _emptyArray = [], _softRefresh = function _softRefresh() {\n    return _removeListener(ScrollTrigger, \"scrollEnd\", _softRefresh) || _refreshAll(true);\n}, _dispatch = function _dispatch(type) {\n    return _listeners[type] && _listeners[type].map(function(f) {\n        return f();\n    }) || _emptyArray;\n}, _savedStyles = [], // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.\n_revertRecorded = function _revertRecorded(media) {\n    for(var i = 0; i < _savedStyles.length; i += 5){\n        if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {\n            _savedStyles[i].style.cssText = _savedStyles[i + 1];\n            _savedStyles[i].getBBox && _savedStyles[i].setAttribute(\"transform\", _savedStyles[i + 2] || \"\");\n            _savedStyles[i + 3].uncache = 1;\n        }\n    }\n}, _revertAll = function _revertAll(kill, media) {\n    var trigger;\n    for(_i = 0; _i < _triggers.length; _i++){\n        trigger = _triggers[_i];\n        if (trigger && (!media || trigger._ctx === media)) {\n            if (kill) {\n                trigger.kill(1);\n            } else {\n                trigger.revert(true, true);\n            }\n        }\n    }\n    _isReverted = true;\n    media && _revertRecorded(media);\n    media || _dispatch(\"revert\");\n}, _clearScrollMemory = function _clearScrollMemory(scrollRestoration, force) {\n    // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\n    (force || !_refreshingAll) && _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {\n        return _isFunction(obj) && obj.cacheID++ && (obj.rec = 0);\n    });\n    _isString(scrollRestoration) && (_win.history.scrollRestoration = _scrollRestoration = scrollRestoration);\n}, _refreshingAll, _refreshID = 0, _queueRefreshID, _queueRefreshAll = function _queueRefreshAll() {\n    // we don't want to call _refreshAll() every time we create a new ScrollTrigger (for performance reasons) - it's better to batch them. Some frameworks dynamically load content and we can't rely on the window's \"load\" or \"DOMContentLoaded\" events to trigger it.\n    if (_queueRefreshID !== _refreshID) {\n        var id = _queueRefreshID = _refreshID;\n        requestAnimationFrame(function() {\n            return id === _refreshID && _refreshAll(true);\n        });\n    }\n}, _refresh100vh = function _refresh100vh() {\n    _body.appendChild(_div100vh);\n    _100vh = !_normalizer && _div100vh.offsetHeight || _win.innerHeight;\n    _body.removeChild(_div100vh);\n}, _hideAllMarkers = function _hideAllMarkers(hide) {\n    return _toArray(\".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end\").forEach(function(el) {\n        return el.style.display = hide ? \"none\" : \"block\";\n    });\n}, _refreshAll = function _refreshAll(force, skipRevert) {\n    if (_lastScrollTime && !force && !_isReverted) {\n        _addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n        return;\n    }\n    _refresh100vh();\n    _refreshingAll = ScrollTrigger.isRefreshing = true;\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {\n        return _isFunction(obj) && ++obj.cacheID && (obj.rec = obj());\n    }); // force the clearing of the cache because some browsers take a little while to dispatch the \"scroll\" event and the user may have changed the scroll position and then called ScrollTrigger.refresh() right away\n    var refreshInits = _dispatch(\"refreshInit\");\n    _sort && ScrollTrigger.sort();\n    skipRevert || _revertAll();\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {\n        if (_isFunction(obj)) {\n            obj.smooth && (obj.target.style.scrollBehavior = \"auto\"); // smooth scrolling interferes\n            obj(0);\n        }\n    });\n    _triggers.slice(0).forEach(function(t) {\n        return t.refresh();\n    }); // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.\n    _isReverted = false;\n    _triggers.forEach(function(t) {\n        // nested pins (pinnedContainer) with pinSpacing may expand the container, so we must accommodate that here.\n        if (t._subPinOffset && t.pin) {\n            var prop = t.vars.horizontal ? \"offsetWidth\" : \"offsetHeight\", original = t.pin[prop];\n            t.revert(true, 1);\n            t.adjustPinSpacing(t.pin[prop] - original);\n            t.refresh();\n        }\n    });\n    _clampingMax = 1; // pinSpacing might be propping a page open, thus when we .setPositions() to clamp a ScrollTrigger's end we should leave the pinSpacing alone. That's what this flag is for.\n    _hideAllMarkers(true);\n    _triggers.forEach(function(t) {\n        // the scroller's max scroll position may change after all the ScrollTriggers refreshed (like pinning could push it down), so we need to loop back and correct any with end: \"max\". Same for anything with a clamped end\n        var max = _maxScroll(t.scroller, t._dir), endClamp = t.vars.end === \"max\" || t._endClamp && t.end > max, startClamp = t._startClamp && t.start >= max;\n        (endClamp || startClamp) && t.setPositions(startClamp ? max - 1 : t.start, endClamp ? Math.max(startClamp ? max : t.start + 1, max) : t.end, true);\n    });\n    _hideAllMarkers(false);\n    _clampingMax = 0;\n    refreshInits.forEach(function(result) {\n        return result && result.render && result.render(-1);\n    }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {\n        if (_isFunction(obj)) {\n            obj.smooth && requestAnimationFrame(function() {\n                return obj.target.style.scrollBehavior = \"smooth\";\n            });\n            obj.rec && obj(obj.rec);\n        }\n    });\n    _clearScrollMemory(_scrollRestoration, 1);\n    _resizeDelay.pause();\n    _refreshID++;\n    _refreshingAll = 2;\n    _updateAll(2);\n    _triggers.forEach(function(t) {\n        return _isFunction(t.vars.onRefresh) && t.vars.onRefresh(t);\n    });\n    _refreshingAll = ScrollTrigger.isRefreshing = false;\n    _dispatch(\"refresh\");\n}, _lastScroll = 0, _direction = 1, _primary, _updateAll = function _updateAll(force) {\n    if (force === 2 || !_refreshingAll && !_isReverted) {\n        // _isReverted could be true if, for example, a matchMedia() is in the process of executing. We don't want to update during the time everything is reverted.\n        ScrollTrigger.isUpdating = true;\n        _primary && _primary.update(0); // ScrollSmoother uses refreshPriority -9999 to become the primary that gets updated before all others because it affects the scroll position.\n        var l = _triggers.length, time = _getTime(), recordVelocity = time - _time1 >= 50, scroll = l && _triggers[0].scroll();\n        _direction = _lastScroll > scroll ? -1 : 1;\n        _refreshingAll || (_lastScroll = scroll);\n        if (recordVelocity) {\n            if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {\n                _lastScrollTime = 0;\n                _dispatch(\"scrollEnd\");\n            }\n            _time2 = _time1;\n            _time1 = time;\n        }\n        if (_direction < 0) {\n            _i = l;\n            while(_i-- > 0){\n                _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n            }\n            _direction = 1;\n        } else {\n            for(_i = 0; _i < l; _i++){\n                _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n            }\n        }\n        ScrollTrigger.isUpdating = false;\n    }\n    _rafID = 0;\n}, _propNamesToCopy = [\n    _left,\n    _top,\n    _bottom,\n    _right,\n    _margin + _Bottom,\n    _margin + _Right,\n    _margin + _Top,\n    _margin + _Left,\n    \"display\",\n    \"flexShrink\",\n    \"float\",\n    \"zIndex\",\n    \"gridColumnStart\",\n    \"gridColumnEnd\",\n    \"gridRowStart\",\n    \"gridRowEnd\",\n    \"gridArea\",\n    \"justifySelf\",\n    \"alignSelf\",\n    \"placeSelf\",\n    \"order\"\n], _stateProps = _propNamesToCopy.concat([\n    _width,\n    _height,\n    \"boxSizing\",\n    \"max\" + _Width,\n    \"max\" + _Height,\n    \"position\",\n    _margin,\n    _padding,\n    _padding + _Top,\n    _padding + _Right,\n    _padding + _Bottom,\n    _padding + _Left\n]), _swapPinOut = function _swapPinOut(pin, spacer, state) {\n    _setState(state);\n    var cache = pin._gsap;\n    if (cache.spacerIsNative) {\n        _setState(cache.spacerState);\n    } else if (pin._gsap.swappedIn) {\n        var parent = spacer.parentNode;\n        if (parent) {\n            parent.insertBefore(pin, spacer);\n            parent.removeChild(spacer);\n        }\n    }\n    pin._gsap.swappedIn = false;\n}, _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {\n    if (!pin._gsap.swappedIn) {\n        var i = _propNamesToCopy.length, spacerStyle = spacer.style, pinStyle = pin.style, p;\n        while(i--){\n            p = _propNamesToCopy[i];\n            spacerStyle[p] = cs[p];\n        }\n        spacerStyle.position = cs.position === \"absolute\" ? \"absolute\" : \"relative\";\n        cs.display === \"inline\" && (spacerStyle.display = \"inline-block\");\n        pinStyle[_bottom] = pinStyle[_right] = \"auto\";\n        spacerStyle.flexBasis = cs.flexBasis || \"auto\";\n        spacerStyle.overflow = \"visible\";\n        spacerStyle.boxSizing = \"border-box\";\n        spacerStyle[_width] = _getSize(pin, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal) + _px;\n        spacerStyle[_height] = _getSize(pin, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical) + _px;\n        spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = \"0\";\n        _setState(spacerState);\n        pinStyle[_width] = pinStyle[\"max\" + _Width] = cs[_width];\n        pinStyle[_height] = pinStyle[\"max\" + _Height] = cs[_height];\n        pinStyle[_padding] = cs[_padding];\n        if (pin.parentNode !== spacer) {\n            pin.parentNode.insertBefore(spacer, pin);\n            spacer.appendChild(pin);\n        }\n        pin._gsap.swappedIn = true;\n    }\n}, _capsExp = /([A-Z])/g, _setState = function _setState(state) {\n    if (state) {\n        var style = state.t.style, l = state.length, i = 0, p, value;\n        (state.t._gsap || gsap.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off\n        for(; i < l; i += 2){\n            value = state[i + 1];\n            p = state[i];\n            if (value) {\n                style[p] = value;\n            } else if (style[p]) {\n                style.removeProperty(p.replace(_capsExp, \"-$1\").toLowerCase());\n            }\n        }\n    }\n}, _getState = function _getState(element) {\n    // returns an Array with alternating values like [property, value, property, value] and a \"t\" property pointing to the target (element). Makes it fast and cheap.\n    var l = _stateProps.length, style = element.style, state = [], i = 0;\n    for(; i < l; i++){\n        state.push(_stateProps[i], style[_stateProps[i]]);\n    }\n    state.t = element;\n    return state;\n}, _copyState = function _copyState(state, override, omitOffsets) {\n    var result = [], l = state.length, i = omitOffsets ? 8 : 0, // skip top, left, right, bottom if omitOffsets is true\n    p;\n    for(; i < l; i += 2){\n        p = state[i];\n        result.push(p, p in override ? override[p] : state[i + 1]);\n    }\n    result.t = state.t;\n    return result;\n}, _winOffsets = {\n    left: 0,\n    top: 0\n}, // // potential future feature (?) Allow users to calculate where a trigger hits (scroll position) like getScrollPosition(\"#id\", \"top bottom\")\n// _getScrollPosition = (trigger, position, {scroller, containerAnimation, horizontal}) => {\n// \tscroller = _getTarget(scroller || _win);\n// \tlet direction = horizontal ? _horizontal : _vertical,\n// \t\tisViewport = _isViewport(scroller);\n// \t_getSizeFunc(scroller, isViewport, direction);\n// \treturn _parsePosition(position, _getTarget(trigger), _getSizeFunc(scroller, isViewport, direction)(), direction, _getScrollFunc(scroller, direction)(), 0, 0, 0, _getOffsetsFunc(scroller, isViewport)(), isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0, 0, containerAnimation ? containerAnimation.duration() : _maxScroll(scroller), containerAnimation);\n// },\n_parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation, clampZeroProp) {\n    _isFunction(value) && (value = value(self));\n    if (_isString(value) && value.substr(0, 3) === \"max\") {\n        value = scrollerMax + (value.charAt(4) === \"=\" ? _offsetToPx(\"0\" + value.substr(3), scrollerSize) : 0);\n    }\n    var time = containerAnimation ? containerAnimation.time() : 0, p1, p2, element;\n    containerAnimation && containerAnimation.seek(0);\n    isNaN(value) || (value = +value); // convert a string number like \"45\" to an actual number\n    if (!_isNumber(value)) {\n        _isFunction(trigger) && (trigger = trigger(self));\n        var offsets = (value || \"0\").split(\" \"), bounds, localOffset, globalOffset, display;\n        element = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(trigger, self) || _body;\n        bounds = _getBounds(element) || {};\n        if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === \"none\") {\n            // if display is \"none\", it won't report getBoundingClientRect() properly\n            display = element.style.display;\n            element.style.display = \"block\";\n            bounds = _getBounds(element);\n            display ? element.style.display = display : element.style.removeProperty(\"display\");\n        }\n        localOffset = _offsetToPx(offsets[0], bounds[direction.d]);\n        globalOffset = _offsetToPx(offsets[1] || \"0\", scrollerSize);\n        value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;\n        markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);\n        scrollerSize -= scrollerSize - globalOffset; // adjust for the marker\n    } else {\n        containerAnimation && (value = gsap.utils.mapRange(containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, 0, scrollerMax, value));\n        markerScroller && _positionMarker(markerScroller, scrollerSize, direction, true);\n    }\n    if (clampZeroProp) {\n        self[clampZeroProp] = value || -0.001;\n        value < 0 && (value = 0);\n    }\n    if (marker) {\n        var position = value + scrollerSize, isStart = marker._isStart;\n        p1 = \"scroll\" + direction.d2;\n        _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[p1], _docEl[p1]) : marker.parentNode[p1]) <= position + 1);\n        if (useFixedPosition) {\n            scrollerBounds = _getBounds(markerScroller);\n            useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);\n        }\n    }\n    if (containerAnimation && element) {\n        p1 = _getBounds(element);\n        containerAnimation.seek(scrollerMax);\n        p2 = _getBounds(element);\n        containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];\n        value = value / containerAnimation._caScrollDist * scrollerMax;\n    }\n    containerAnimation && containerAnimation.seek(time);\n    return containerAnimation ? value : Math.round(value);\n}, _prefixExp = /(webkit|moz|length|cssText|inset)/i, _reparent = function _reparent(element, parent, top, left) {\n    if (element.parentNode !== parent) {\n        var style = element.style, p, cs;\n        if (parent === _body) {\n            element._stOrig = style.cssText; // record original inline styles so we can revert them later\n            cs = _getComputedStyle(element);\n            for(p in cs){\n                // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.\n                if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === \"string\" && p !== \"0\") {\n                    style[p] = cs[p];\n                }\n            }\n            style.top = top;\n            style.left = left;\n        } else {\n            style.cssText = element._stOrig;\n        }\n        gsap.core.getCache(element).uncache = 1;\n        parent.appendChild(element);\n    }\n}, _interruptionTracker = function _interruptionTracker(getValueFunc, initialValue, onInterrupt) {\n    var last1 = initialValue, last2 = last1;\n    return function(value) {\n        var current = Math.round(getValueFunc()); // round because in some [very uncommon] Windows environments, scroll can get reported with decimals even though it was set without.\n        if (current !== last1 && current !== last2 && Math.abs(current - last1) > 3 && Math.abs(current - last2) > 3) {\n            // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.\n            value = current;\n            onInterrupt && onInterrupt();\n        }\n        last2 = last1;\n        last1 = value;\n        return value;\n    };\n}, _shiftMarker = function _shiftMarker(marker, direction, value) {\n    var vars = {};\n    vars[direction.p] = \"+=\" + value;\n    gsap.set(marker, vars);\n}, // _mergeAnimations = animations => {\n// \tlet tl = gsap.timeline({smoothChildTiming: true}).startTime(Math.min(...animations.map(a => a.globalTime(0))));\n// \tanimations.forEach(a => {let time = a.totalTime(); tl.add(a); a.totalTime(time); });\n// \ttl.smoothChildTiming = false;\n// \treturn tl;\n// },\n// returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)\n_getTweenCreator = function _getTweenCreator(scroller, direction) {\n    var getScroll = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, direction), prop = \"_scroll\" + direction.p2, // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.\n    getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {\n        var tween = getTween.tween, onComplete = vars.onComplete, modifiers = {};\n        initialValue = initialValue || getScroll();\n        var checkForInterruption = _interruptionTracker(getScroll, initialValue, function() {\n            tween.kill();\n            getTween.tween = 0;\n        });\n        change2 = change1 && change2 || 0; // if change1 is 0, we set that to the difference and ignore change2. Otherwise, there would be a compound effect.\n        change1 = change1 || scrollTo - initialValue;\n        tween && tween.kill();\n        vars[prop] = scrollTo;\n        vars.inherit = false;\n        vars.modifiers = modifiers;\n        modifiers[prop] = function() {\n            return checkForInterruption(initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio);\n        };\n        vars.onUpdate = function() {\n            _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\n            getTween.tween && _updateAll(); // if it was interrupted/killed, like in a context.revert(), don't force an updateAll()\n        };\n        vars.onComplete = function() {\n            getTween.tween = 0;\n            onComplete && onComplete.call(tween);\n        };\n        tween = getTween.tween = gsap.to(scroller, vars);\n        return tween;\n    };\n    scroller[prop] = getScroll;\n    getScroll.wheelHandler = function() {\n        return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);\n    };\n    _addListener(scroller, \"wheel\", getScroll.wheelHandler); // Windows machines handle mousewheel scrolling in chunks (like \"3 lines per scroll\") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.\n    ScrollTrigger.isTouch && _addListener(scroller, \"touchmove\", getScroll.wheelHandler);\n    return getTween;\n};\nvar ScrollTrigger = /*#__PURE__*/ function() {\n    function ScrollTrigger(vars, animation) {\n        _coreInitted || ScrollTrigger.register(gsap) || console.warn(\"Please gsap.registerPlugin(ScrollTrigger)\");\n        _context(this);\n        this.init(vars, animation);\n    }\n    var _proto = ScrollTrigger.prototype;\n    _proto.init = function init(vars, animation) {\n        this.progress = this.start = 0;\n        this.vars && this.kill(true, true); // in case it's being initted again\n        if (!_enabled) {\n            this.update = this.refresh = this.kill = _passThrough;\n            return;\n        }\n        vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {\n            trigger: vars\n        } : vars, _defaults);\n        var _vars = vars, onUpdate = _vars.onUpdate, toggleClass = _vars.toggleClass, id = _vars.id, onToggle = _vars.onToggle, onRefresh = _vars.onRefresh, scrub = _vars.scrub, trigger = _vars.trigger, pin = _vars.pin, pinSpacing = _vars.pinSpacing, invalidateOnRefresh = _vars.invalidateOnRefresh, anticipatePin = _vars.anticipatePin, onScrubComplete = _vars.onScrubComplete, onSnapComplete = _vars.onSnapComplete, once = _vars.once, snap = _vars.snap, pinReparent = _vars.pinReparent, pinSpacer = _vars.pinSpacer, containerAnimation = _vars.containerAnimation, fastScrollEnd = _vars.fastScrollEnd, preventOverlaps = _vars.preventOverlaps, direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical, isToggle = !scrub && scrub !== 0, scroller = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.scroller || _win), scrollerCache = gsap.core.getCache(scroller), isViewport = _isViewport(scroller), useFixedPosition = (\"pinType\" in vars ? vars.pinType : (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"pinType\") || isViewport && \"fixed\") === \"fixed\", callbacks = [\n            vars.onEnter,\n            vars.onLeave,\n            vars.onEnterBack,\n            vars.onLeaveBack\n        ], toggleActions = isToggle && vars.toggleActions.split(\" \"), markers = \"markers\" in vars ? vars.markers : _defaults.markers, borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0, self = this, onRefreshInit = vars.onRefreshInit && function() {\n            return vars.onRefreshInit(self);\n        }, getScrollerSize = _getSizeFunc(scroller, isViewport, direction), getScrollerOffsets = _getOffsetsFunc(scroller, isViewport), lastSnap = 0, lastRefresh = 0, prevProgress = 0, scrollFunc = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, direction), tweenTo, pinCache, snapFunc, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars, executingOnRefresh, change, pinOriginalState, pinActiveState, pinState, spacer, offset, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacerState, markerStartSetter, pinMoves, markerEndSetter, cs, snap1, snap2, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, prevScroll, prevAnimProgress, caMarkerSetter, customRevertReturn; // for the sake of efficiency, _startClamp/_endClamp serve like a truthy value indicating that clamping was enabled on the start/end, and ALSO store the actual pre-clamped numeric value. We tap into that in ScrollSmoother for speed effects. So for example, if start=\"clamp(top bottom)\" results in a start of -100 naturally, it would get clamped to 0 but -100 would be stored in _startClamp.\n        self._startClamp = self._endClamp = false;\n        self._dir = direction;\n        anticipatePin *= 45;\n        self.scroller = scroller;\n        self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;\n        scroll1 = scrollFunc();\n        self.vars = vars;\n        animation = animation || vars.animation;\n        if (\"refreshPriority\" in vars) {\n            _sort = 1;\n            vars.refreshPriority === -9999 && (_primary = self); // used by ScrollSmoother\n        }\n        scrollerCache.tweenScroll = scrollerCache.tweenScroll || {\n            top: _getTweenCreator(scroller, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical),\n            left: _getTweenCreator(scroller, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal)\n        };\n        self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];\n        self.scrubDuration = function(value) {\n            scrubSmooth = _isNumber(value) && value;\n            if (!scrubSmooth) {\n                scrubTween && scrubTween.progress(1).kill();\n                scrubTween = 0;\n            } else {\n                scrubTween ? scrubTween.duration(value) : scrubTween = gsap.to(animation, {\n                    ease: \"expo\",\n                    totalProgress: \"+=0\",\n                    inherit: false,\n                    duration: scrubSmooth,\n                    paused: true,\n                    onComplete: function onComplete() {\n                        return onScrubComplete && onScrubComplete(self);\n                    }\n                });\n            }\n        };\n        if (animation) {\n            animation.vars.lazy = false;\n            animation._initted && !self.isReverted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true); // special case: if this ScrollTrigger gets re-initted, a from() tween with a stagger could get initted initially and then reverted on the re-init which means it'll need to get rendered again here to properly display things. Otherwise, See https://gsap.com/forums/topic/36777-scrollsmoother-splittext-nextjs/ and https://codepen.io/GreenSock/pen/eYPyPpd?editors=0010\n            self.animation = animation.pause();\n            animation.scrollTrigger = self;\n            self.scrubDuration(scrub);\n            snap1 = 0;\n            id || (id = animation.vars.id);\n        }\n        if (snap) {\n            // TODO: potential idea: use legitimate CSS scroll snapping by pushing invisible elements into the DOM that serve as snap positions, and toggle the document.scrollingElement.style.scrollSnapType onToggle. See https://codepen.io/GreenSock/pen/JjLrgWM for a quick proof of concept.\n            if (!_isObject(snap) || snap.push) {\n                snap = {\n                    snapTo: snap\n                };\n            }\n            \"scrollBehavior\" in _body.style && gsap.set(isViewport ? [\n                _body,\n                _docEl\n            ] : scroller, {\n                scrollBehavior: \"auto\"\n            }); // smooth scrolling doesn't work with snap.\n            _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(o) {\n                return _isFunction(o) && o.target === (isViewport ? _doc.scrollingElement || _docEl : scroller) && (o.smooth = false);\n            }); // note: set smooth to false on both the vertical and horizontal scroll getters/setters\n            snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === \"labels\" ? _getClosestLabel(animation) : snap.snapTo === \"labelsDirectional\" ? _getLabelAtDirection(animation) : snap.directional !== false ? function snapFunc(value, st) {\n                return _snapDirectional(snap.snapTo)(value, _getTime() - lastRefresh < 500 ? 0 : st.direction);\n            } : gsap.utils.snap(snap.snapTo);\n            snapDurClamp = snap.duration || {\n                min: 0.1,\n                max: 2\n            };\n            snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);\n            snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function() {\n                var scroll = scrollFunc(), refreshedRecently = _getTime() - lastRefresh < 500, tween = tweenTo.tween;\n                if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {\n                    var progress = (scroll - start) / change, totalProgress = animation && !isToggle ? animation.totalProgress() : progress, velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0, change1 = gsap.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185), naturalEnd = progress + (snap.inertia === false ? 0 : change1), endValue, endScroll, _snap = snap, onStart = _snap.onStart, _onInterrupt = _snap.onInterrupt, _onComplete = _snap.onComplete;\n                    endValue = snapFunc(naturalEnd, self);\n                    _isNumber(endValue) || (endValue = naturalEnd); // in case the function didn't return a number, fall back to using the naturalEnd\n                    endScroll = Math.round(start + endValue * change);\n                    if (scroll <= end && scroll >= start && endScroll !== scroll) {\n                        if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {\n                            // there's an overlapping snap! So we must figure out which one is closer and let that tween live.\n                            return;\n                        }\n                        if (snap.inertia === false) {\n                            change1 = endValue - progress;\n                        }\n                        tweenTo(endScroll, {\n                            duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),\n                            ease: snap.ease || \"power3\",\n                            data: _abs(endScroll - scroll),\n                            // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.\n                            onInterrupt: function onInterrupt() {\n                                return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);\n                            },\n                            onComplete: function onComplete() {\n                                self.update();\n                                lastSnap = scrollFunc();\n                                if (animation) {\n                                    // the resolution of the scrollbar is limited, so we should correct the scrubbed animation's playhead at the end to match EXACTLY where it was supposed to snap\n                                    scrubTween ? scrubTween.resetTo(\"totalProgress\", endValue, animation._tTime / animation._tDur) : animation.progress(endValue);\n                                }\n                                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;\n                                onSnapComplete && onSnapComplete(self);\n                                _onComplete && _onComplete(self);\n                            }\n                        }, scroll, change1 * change, endScroll - scroll - change1 * change);\n                        onStart && onStart(self, tweenTo.tween);\n                    }\n                } else if (self.isActive && lastSnap !== scroll) {\n                    snapDelayedCall.restart(true);\n                }\n            }).pause();\n        }\n        id && (_ids[id] = self);\n        trigger = self.trigger = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(trigger || pin !== true && pin); // if a trigger has some kind of scroll-related effect applied that could contaminate the \"y\" or \"x\" position (like a ScrollSmoother effect), we needed a way to temporarily revert it, so we use the stRevert property of the gsCache. It can return another function that we'll call at the end so it can return to its normal state.\n        customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;\n        customRevertReturn && (customRevertReturn = customRevertReturn(self));\n        pin = pin === true ? trigger : (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(pin);\n        _isString(toggleClass) && (toggleClass = {\n            targets: trigger,\n            className: toggleClass\n        });\n        if (pin) {\n            pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === \"flex\" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default. We should check that pin.parentNode is an element (not shadow dom window)\n            self.pin = pin;\n            pinCache = gsap.core.getCache(pin);\n            if (!pinCache.spacer) {\n                // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the \"original\" pin state after it has already been affected by another ScrollTrigger.\n                if (pinSpacer) {\n                    pinSpacer = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(pinSpacer);\n                    pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement); // for React & Angular\n                    pinCache.spacerIsNative = !!pinSpacer;\n                    pinSpacer && (pinCache.spacerState = _getState(pinSpacer));\n                }\n                pinCache.spacer = spacer = pinSpacer || _doc.createElement(\"div\");\n                spacer.classList.add(\"pin-spacer\");\n                id && spacer.classList.add(\"pin-spacer-\" + id);\n                pinCache.pinState = pinOriginalState = _getState(pin);\n            } else {\n                pinOriginalState = pinCache.pinState;\n            }\n            vars.force3D !== false && gsap.set(pin, {\n                force3D: true\n            });\n            self.spacer = spacer = pinCache.spacer;\n            cs = _getComputedStyle(pin);\n            spacingStart = cs[pinSpacing + direction.os2];\n            pinGetter = gsap.getProperty(pin);\n            pinSetter = gsap.quickSetter(pin, direction.a, _px); // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = \"hidden\"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).\n            _swapPinIn(pin, spacer, cs);\n            pinState = _getState(pin);\n        }\n        if (markers) {\n            markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;\n            markerStartTrigger = _createMarker(\"scroller-start\", id, scroller, direction, markerVars, 0);\n            markerEndTrigger = _createMarker(\"scroller-end\", id, scroller, direction, markerVars, 0, markerStartTrigger);\n            offset = markerStartTrigger[\"offset\" + direction.op.d2];\n            var content = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)((0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"content\") || scroller);\n            markerStart = this.markerStart = _createMarker(\"start\", id, content, direction, markerVars, offset, 0, containerAnimation);\n            markerEnd = this.markerEnd = _createMarker(\"end\", id, content, direction, markerVars, offset, 0, containerAnimation);\n            containerAnimation && (caMarkerSetter = gsap.quickSetter([\n                markerStart,\n                markerEnd\n            ], direction.a, _px));\n            if (!useFixedPosition && !(_Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.length && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"fixedMarkers\") === true)) {\n                _makePositionable(isViewport ? _body : scroller);\n                gsap.set([\n                    markerStartTrigger,\n                    markerEndTrigger\n                ], {\n                    force3D: true\n                });\n                markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);\n                markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);\n            }\n        }\n        if (containerAnimation) {\n            var oldOnUpdate = containerAnimation.vars.onUpdate, oldParams = containerAnimation.vars.onUpdateParams;\n            containerAnimation.eventCallback(\"onUpdate\", function() {\n                self.update(0, 0, 1);\n                oldOnUpdate && oldOnUpdate.apply(containerAnimation, oldParams || []);\n            });\n        }\n        self.previous = function() {\n            return _triggers[_triggers.indexOf(self) - 1];\n        };\n        self.next = function() {\n            return _triggers[_triggers.indexOf(self) + 1];\n        };\n        self.revert = function(revert, temp) {\n            if (!temp) {\n                return self.kill(true);\n            } // for compatibility with gsap.context() and gsap.matchMedia() which call revert()\n            var r = revert !== false || !self.enabled, prevRefreshing = _refreshing;\n            if (r !== self.isReverted) {\n                if (r) {\n                    prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.\n                    prevProgress = self.progress;\n                    prevAnimProgress = animation && animation.progress();\n                }\n                markerStart && [\n                    markerStart,\n                    markerEnd,\n                    markerStartTrigger,\n                    markerEndTrigger\n                ].forEach(function(m) {\n                    return m.style.display = r ? \"none\" : \"block\";\n                });\n                if (r) {\n                    _refreshing = self;\n                    self.update(r); // make sure the pin is back in its original position so that all the measurements are correct. do this BEFORE swapping the pin out\n                }\n                if (pin && (!pinReparent || !self.isActive)) {\n                    if (r) {\n                        _swapPinOut(pin, spacer, pinOriginalState);\n                    } else {\n                        _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState);\n                    }\n                }\n                r || self.update(r); // when we're restoring, the update should run AFTER swapping the pin into its pin-spacer.\n                _refreshing = prevRefreshing; // restore. We set it to true during the update() so that things fire properly in there.\n                self.isReverted = r;\n            }\n        };\n        self.refresh = function(soft, force, position, pinOffset) {\n            // position is typically only defined if it's coming from setPositions() - it's a way to skip the normal parsing. pinOffset is also only from setPositions() and is mostly related to fancy stuff we need to do in ScrollSmoother with effects\n            if ((_refreshing || !self.enabled) && !force) {\n                return;\n            }\n            if (pin && soft && _lastScrollTime) {\n                _addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n                return;\n            }\n            !_refreshingAll && onRefreshInit && onRefreshInit(self);\n            _refreshing = self;\n            if (tweenTo.tween && !position) {\n                // we skip this if a position is passed in because typically that's from .setPositions() and it's best to allow in-progress snapping to continue.\n                tweenTo.tween.kill();\n                tweenTo.tween = 0;\n            }\n            scrubTween && scrubTween.pause();\n            invalidateOnRefresh && animation && animation.revert({\n                kill: false\n            }).invalidate();\n            self.isReverted || self.revert(true, true);\n            self._subPinOffset = false; // we'll set this to true in the sub-pins if we find any\n            var size = getScrollerSize(), scrollerBounds = getScrollerOffsets(), max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction), isFirstRefresh = change <= 0.01, offset = 0, otherPinOffset = pinOffset || 0, parsedEnd = _isObject(position) ? position.end : vars.end, parsedEndTrigger = vars.endTrigger || trigger, parsedStart = _isObject(position) ? position.start : vars.start || (vars.start === 0 || !trigger ? 0 : pin ? \"0 0\" : \"0 100%\"), pinnedContainer = self.pinnedContainer = vars.pinnedContainer && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.pinnedContainer, self), triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0, i = triggerIndex, cs, bounds, scroll, isVertical, override, curTrigger, curPin, oppositeScroll, initted, revertedPins, forcedOverflow, markerStartOffset, markerEndOffset;\n            if (markers && _isObject(position)) {\n                // if we alter the start/end positions with .setPositions(), it generally feeds in absolute NUMBERS which don't convey information about where to line up the markers, so to keep it intuitive, we record how far the trigger positions shift after applying the new numbers and then offset by that much in the opposite direction. We do the same to the associated trigger markers too of course.\n                markerStartOffset = gsap.getProperty(markerStartTrigger, direction.p);\n                markerEndOffset = gsap.getProperty(markerEndTrigger, direction.p);\n            }\n            while(i--){\n                // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things \"rewind\" properly.\n                curTrigger = _triggers[i];\n                curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = self); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.\n                curPin = curTrigger.pin;\n                if (curPin && (curPin === trigger || curPin === pin || curPin === pinnedContainer) && !curTrigger.isReverted) {\n                    revertedPins || (revertedPins = []);\n                    revertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly\n                    curTrigger.revert(true, true);\n                }\n                if (curTrigger !== _triggers[i]) {\n                    // in case it got removed.\n                    triggerIndex--;\n                    i--;\n                }\n            }\n            _isFunction(parsedStart) && (parsedStart = parsedStart(self));\n            parsedStart = _parseClamp(parsedStart, \"start\", self);\n            start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._startClamp && \"_startClamp\") || (pin ? -0.001 : 0);\n            _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));\n            if (_isString(parsedEnd) && !parsedEnd.indexOf(\"+=\")) {\n                if (~parsedEnd.indexOf(\" \")) {\n                    parsedEnd = (_isString(parsedStart) ? parsedStart.split(\" \")[0] : \"\") + parsedEnd;\n                } else {\n                    offset = _offsetToPx(parsedEnd.substr(2), size);\n                    parsedEnd = _isString(parsedStart) ? parsedStart : (containerAnimation ? gsap.utils.mapRange(0, containerAnimation.duration(), containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, start) : start) + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.\n                    parsedEndTrigger = trigger;\n                }\n            }\n            parsedEnd = _parseClamp(parsedEnd, \"end\", self);\n            end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? \"100% 0\" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._endClamp && \"_endClamp\")) || -0.001;\n            offset = 0;\n            i = triggerIndex;\n            while(i--){\n                curTrigger = _triggers[i];\n                curPin = curTrigger.pin;\n                if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {\n                    cs = curTrigger.end - (self._startClamp ? Math.max(0, curTrigger.start) : curTrigger.start);\n                    if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && isNaN(parsedStart)) {\n                        // numeric start values shouldn't be offset at all - treat them as absolute\n                        offset += cs * (1 - curTrigger.progress);\n                    }\n                    curPin === pin && (otherPinOffset += cs);\n                }\n            }\n            start += offset;\n            end += offset;\n            self._startClamp && (self._startClamp += offset);\n            if (self._endClamp && !_refreshingAll) {\n                self._endClamp = end || -0.001;\n                end = Math.min(end, _maxScroll(scroller, direction));\n            }\n            change = end - start || (start -= 0.01) && 0.001;\n            if (isFirstRefresh) {\n                // on the very first refresh(), the prevProgress couldn't have been accurate yet because the start/end were never calculated, so we set it here. Before 3.11.5, it could lead to an inaccurate scroll position restoration with snapping.\n                prevProgress = gsap.utils.clamp(0, 1, gsap.utils.normalize(start, end, prevScroll));\n            }\n            self._pinPush = otherPinOffset;\n            if (markerStart && offset) {\n                // offset the markers if necessary\n                cs = {};\n                cs[direction.a] = \"+=\" + offset;\n                pinnedContainer && (cs[direction.p] = \"-=\" + scrollFunc());\n                gsap.set([\n                    markerStart,\n                    markerEnd\n                ], cs);\n            }\n            if (pin && !(_clampingMax && self.end >= _maxScroll(scroller, direction))) {\n                cs = _getComputedStyle(pin);\n                isVertical = direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical;\n                scroll = scrollFunc(); // recalculate because the triggers can affect the scroll\n                pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;\n                if (!max && end > 1) {\n                    // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://gsap.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/\n                    forcedOverflow = (isViewport ? _doc.scrollingElement || _docEl : scroller).style;\n                    forcedOverflow = {\n                        style: forcedOverflow,\n                        value: forcedOverflow[\"overflow\" + direction.a.toUpperCase()]\n                    };\n                    if (isViewport && _getComputedStyle(_body)[\"overflow\" + direction.a.toUpperCase()] !== \"scroll\") {\n                        // avoid an extra scrollbar if BOTH <html> and <body> have overflow set to \"scroll\"\n                        forcedOverflow.style[\"overflow\" + direction.a.toUpperCase()] = \"scroll\";\n                    }\n                }\n                _swapPinIn(pin, spacer, cs);\n                pinState = _getState(pin); // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.\n                bounds = _getBounds(pin, true);\n                oppositeScroll = useFixedPosition && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, isVertical ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical)();\n                if (pinSpacing) {\n                    spacerState = [\n                        pinSpacing + direction.os2,\n                        change + otherPinOffset + _px\n                    ];\n                    spacerState.t = spacer;\n                    i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;\n                    if (i) {\n                        spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).\n                        spacer.style.flexBasis !== \"auto\" && (spacer.style.flexBasis = i + _px);\n                    }\n                    _setState(spacerState);\n                    if (pinnedContainer) {\n                        // in ScrollTrigger.refresh(), we need to re-evaluate the pinContainer's size because this pinSpacing may stretch it out, but we can't just add the exact distance because depending on layout, it may not push things down or it may only do so partially.\n                        _triggers.forEach(function(t) {\n                            if (t.pin === pinnedContainer && t.vars.pinSpacing !== false) {\n                                t._subPinOffset = true;\n                            }\n                        });\n                    }\n                    useFixedPosition && scrollFunc(prevScroll);\n                } else {\n                    i = _getSize(pin, direction);\n                    i && spacer.style.flexBasis !== \"auto\" && (spacer.style.flexBasis = i + _px);\n                }\n                if (useFixedPosition) {\n                    override = {\n                        top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,\n                        left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,\n                        boxSizing: \"border-box\",\n                        position: \"fixed\"\n                    };\n                    override[_width] = override[\"max\" + _Width] = Math.ceil(bounds.width) + _px;\n                    override[_height] = override[\"max\" + _Height] = Math.ceil(bounds.height) + _px;\n                    override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = \"0\";\n                    override[_padding] = cs[_padding];\n                    override[_padding + _Top] = cs[_padding + _Top];\n                    override[_padding + _Right] = cs[_padding + _Right];\n                    override[_padding + _Bottom] = cs[_padding + _Bottom];\n                    override[_padding + _Left] = cs[_padding + _Left];\n                    pinActiveState = _copyState(pinOriginalState, override, pinReparent);\n                    _refreshingAll && scrollFunc(0);\n                }\n                if (animation) {\n                    // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.\n                    initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.\n                    _suppressOverwrites(1);\n                    animation.render(animation.duration(), true, true);\n                    pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;\n                    pinMoves = Math.abs(change - pinChange) > 1;\n                    useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.\n                    animation.render(0, true, true);\n                    initted || animation.invalidate(true);\n                    animation.parent || animation.totalTime(animation.totalTime()); // if, for example, a toggleAction called play() and then refresh() happens and when we render(1) above, it would cause the animation to complete and get removed from its parent, so this makes sure it gets put back in.\n                    _suppressOverwrites(0);\n                } else {\n                    pinChange = change;\n                }\n                forcedOverflow && (forcedOverflow.value ? forcedOverflow.style[\"overflow\" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty(\"overflow-\" + direction.a));\n            } else if (trigger && scrollFunc() && !containerAnimation) {\n                // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()\n                bounds = trigger.parentNode;\n                while(bounds && bounds !== _body){\n                    if (bounds._pinOffset) {\n                        start -= bounds._pinOffset;\n                        end -= bounds._pinOffset;\n                    }\n                    bounds = bounds.parentNode;\n                }\n            }\n            revertedPins && revertedPins.forEach(function(t) {\n                return t.revert(false, true);\n            });\n            self.start = start;\n            self.end = end;\n            scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc(); // reset velocity\n            if (!containerAnimation && !_refreshingAll) {\n                scroll1 < prevScroll && scrollFunc(prevScroll);\n                self.scroll.rec = 0;\n            }\n            self.revert(false, true);\n            lastRefresh = _getTime();\n            if (snapDelayedCall) {\n                lastSnap = -1; // just so snapping gets re-enabled, clear out any recorded last value\n                // self.isActive && scrollFunc(start + change * prevProgress); // previously this line was here to ensure that when snapping kicks in, it's from the previous progress but in some cases that's not desirable, like an all-page ScrollTrigger when new content gets added to the page, that'd totally change the progress.\n                snapDelayedCall.restart(true);\n            }\n            _refreshing = 0;\n            animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress || 0, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().\n            if (isFirstRefresh || prevProgress !== self.progress || containerAnimation || invalidateOnRefresh) {\n                // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.\n                animation && !isToggle && animation.totalProgress(containerAnimation && start < -0.001 && !prevProgress ? gsap.utils.normalize(start, end, 0) : prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.\n                self.progress = isFirstRefresh || (scroll1 - start) / change === prevProgress ? 0 : prevProgress;\n            }\n            pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));\n            scrubTween && scrubTween.invalidate();\n            if (!isNaN(markerStartOffset)) {\n                // numbers were passed in for the position which are absolute, so instead of just putting the markers at the very bottom of the viewport, we figure out how far they shifted down (it's safe to assume they were originally positioned in closer relation to the trigger element with values like \"top\", \"center\", a percentage or whatever, so we offset that much in the opposite direction to basically revert them to the relative position thy were at previously.\n                markerStartOffset -= gsap.getProperty(markerStartTrigger, direction.p);\n                markerEndOffset -= gsap.getProperty(markerEndTrigger, direction.p);\n                _shiftMarker(markerStartTrigger, direction, markerStartOffset);\n                _shiftMarker(markerStart, direction, markerStartOffset - (pinOffset || 0));\n                _shiftMarker(markerEndTrigger, direction, markerEndOffset);\n                _shiftMarker(markerEnd, direction, markerEndOffset - (pinOffset || 0));\n            }\n            isFirstRefresh && !_refreshingAll && self.update(); // edge case - when you reload a page when it's already scrolled down, some browsers fire a \"scroll\" event before DOMContentLoaded, triggering an updateAll(). If we don't update the self.progress as part of refresh(), then when it happens next, it may record prevProgress as 0 when it really shouldn't, potentially causing a callback in an animation to fire again.\n            if (onRefresh && !_refreshingAll && !executingOnRefresh) {\n                // when refreshing all, we do extra work to correct pinnedContainer sizes and ensure things don't exceed the maxScroll, so we should do all the refreshes at the end after all that work so that the start/end values are corrected.\n                executingOnRefresh = true;\n                onRefresh(self);\n                executingOnRefresh = false;\n            }\n        };\n        self.getVelocity = function() {\n            return (scrollFunc() - scroll2) / (_getTime() - _time2) * 1000 || 0;\n        };\n        self.endAnimation = function() {\n            _endAnimation(self.callbackAnimation);\n            if (animation) {\n                scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);\n            }\n        };\n        self.labelToScroll = function(label) {\n            return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;\n        };\n        self.getTrailing = function(name) {\n            var i = _triggers.indexOf(self), a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);\n            return (_isString(name) ? a.filter(function(t) {\n                return t.vars.preventOverlaps === name;\n            }) : a).filter(function(t) {\n                return self.direction > 0 ? t.end <= start : t.start >= end;\n            });\n        };\n        self.update = function(reset, recordVelocity, forceFake) {\n            if (containerAnimation && !forceFake && !reset) {\n                return;\n            }\n            var scroll = _refreshingAll === true ? prevScroll : self.scroll(), p = reset ? 0 : (scroll - start) / change, clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0, prevProgress = self.progress, isActive, wasActive, toggleState, action, stateChanged, toggled, isAtMax, isTakingAction;\n            if (recordVelocity) {\n                scroll2 = scroll1;\n                scroll1 = containerAnimation ? scrollFunc() : scroll;\n                if (snap) {\n                    snap2 = snap1;\n                    snap1 = animation && !isToggle ? animation.totalProgress() : clipped;\n                }\n            } // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).\n            if (anticipatePin && pin && !_refreshing && !_startup && _lastScrollTime) {\n                if (!clipped && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {\n                    clipped = 0.0001;\n                } else if (clipped === 1 && end > scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {\n                    clipped = 0.9999;\n                }\n            }\n            if (clipped !== prevProgress && self.enabled) {\n                isActive = self.isActive = !!clipped && clipped < 1;\n                wasActive = !!prevProgress && prevProgress < 1;\n                toggled = isActive !== wasActive;\n                stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)\n                self.direction = clipped > prevProgress ? 1 : -1;\n                self.progress = clipped;\n                if (stateChanged && !_refreshing) {\n                    toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.\n                    if (isToggle) {\n                        action = !toggled && toggleActions[toggleState + 1] !== \"none\" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the \"enter\" action, we should switch to the \"leave\" in this case (but only if one is defined)\n                        isTakingAction = animation && (action === \"complete\" || action === \"reset\" || action in animation);\n                    }\n                }\n                preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function(t) {\n                    return t.endAnimation();\n                }));\n                if (!isToggle) {\n                    if (scrubTween && !_refreshing && !_startup) {\n                        scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start); // if there's a scrub on both the container animation and this one (or a ScrollSmoother), the update order would cause this one not to have rendered yet, so it wouldn't make any progress before we .restart() it heading toward the new progress so it'd appear stuck thus we force a render here.\n                        if (scrubTween.resetTo) {\n                            scrubTween.resetTo(\"totalProgress\", clipped, animation._tTime / animation._tDur);\n                        } else {\n                            // legacy support (courtesy), before 3.10.0\n                            scrubTween.vars.totalProgress = clipped;\n                            scrubTween.invalidate().restart();\n                        }\n                    } else if (animation) {\n                        animation.totalProgress(clipped, !!(_refreshing && (lastRefresh || reset)));\n                    }\n                }\n                if (pin) {\n                    reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);\n                    if (!useFixedPosition) {\n                        pinSetter(_round(pinStart + pinChange * clipped));\n                    } else if (stateChanged) {\n                        isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)\n                        if (pinReparent) {\n                            if (!reset && (isActive || isAtMax)) {\n                                var bounds = _getBounds(pin, true), _offset = scroll - start;\n                                _reparent(pin, _body, bounds.top + (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? _offset : 0) + _px, bounds.left + (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? 0 : _offset) + _px);\n                            } else {\n                                _reparent(pin, spacer);\n                            }\n                        }\n                        _setState(isActive || isAtMax ? pinActiveState : pinState);\n                        pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));\n                    }\n                }\n                snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);\n                toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function(el) {\n                    return el.classList[isActive || once ? \"add\" : \"remove\"](toggleClass.className);\n                }); // classes could affect positioning, so do it even if reset or refreshing is true.\n                onUpdate && !isToggle && !reset && onUpdate(self);\n                if (stateChanged && !_refreshing) {\n                    if (isToggle) {\n                        if (isTakingAction) {\n                            if (action === \"complete\") {\n                                animation.pause().totalProgress(1);\n                            } else if (action === \"reset\") {\n                                animation.restart(true).pause();\n                            } else if (action === \"restart\") {\n                                animation.restart(true);\n                            } else {\n                                animation[action]();\n                            }\n                        }\n                        onUpdate && onUpdate(self);\n                    }\n                    if (toggled || !_limitCallbacks) {\n                        // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.\n                        onToggle && toggled && _callback(self, onToggle);\n                        callbacks[toggleState] && _callback(self, callbacks[toggleState]);\n                        once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn't be called again if once is true.\n                        if (!toggled) {\n                            // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order\n                            toggleState = clipped === 1 ? 1 : 3;\n                            callbacks[toggleState] && _callback(self, callbacks[toggleState]);\n                        }\n                    }\n                    if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {\n                        _endAnimation(self.callbackAnimation);\n                        scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === \"reverse\" ? 1 : !clipped, 1);\n                    }\n                } else if (isToggle && onUpdate && !_refreshing) {\n                    onUpdate(self);\n                }\n            } // update absolutely-positioned markers (only if the scroller isn't the viewport)\n            if (markerEndSetter) {\n                var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;\n                markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));\n                markerEndSetter(n);\n            }\n            caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));\n        };\n        self.enable = function(reset, refresh) {\n            if (!self.enabled) {\n                self.enabled = true;\n                _addListener(scroller, \"resize\", _onResize);\n                isViewport || _addListener(scroller, \"scroll\", _onScroll);\n                onRefreshInit && _addListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n                if (reset !== false) {\n                    self.progress = prevProgress = 0;\n                    scroll1 = scroll2 = lastSnap = scrollFunc();\n                }\n                refresh !== false && self.refresh();\n            }\n        };\n        self.getTween = function(snap) {\n            return snap && tweenTo ? tweenTo.tween : scrubTween;\n        };\n        self.setPositions = function(newStart, newEnd, keepClamp, pinOffset) {\n            // doesn't persist after refresh()! Intended to be a way to override values that were set during refresh(), like you could set it in onRefresh()\n            if (containerAnimation) {\n                // convert ratios into scroll positions. Remember, start/end values on ScrollTriggers that have a containerAnimation refer to the time (in seconds), NOT scroll positions.\n                var st = containerAnimation.scrollTrigger, duration = containerAnimation.duration(), _change = st.end - st.start;\n                newStart = st.start + _change * newStart / duration;\n                newEnd = st.start + _change * newEnd / duration;\n            }\n            self.refresh(false, false, {\n                start: _keepClamp(newStart, keepClamp && !!self._startClamp),\n                end: _keepClamp(newEnd, keepClamp && !!self._endClamp)\n            }, pinOffset);\n            self.update();\n        };\n        self.adjustPinSpacing = function(amount) {\n            if (spacerState && amount) {\n                var i = spacerState.indexOf(direction.d) + 1;\n                spacerState[i] = parseFloat(spacerState[i]) + amount + _px;\n                spacerState[1] = parseFloat(spacerState[1]) + amount + _px;\n                _setState(spacerState);\n            }\n        };\n        self.disable = function(reset, allowAnimation) {\n            if (self.enabled) {\n                reset !== false && self.revert(true, true);\n                self.enabled = self.isActive = false;\n                allowAnimation || scrubTween && scrubTween.pause();\n                prevScroll = 0;\n                pinCache && (pinCache.uncache = 1);\n                onRefreshInit && _removeListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n                if (snapDelayedCall) {\n                    snapDelayedCall.pause();\n                    tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);\n                }\n                if (!isViewport) {\n                    var i = _triggers.length;\n                    while(i--){\n                        if (_triggers[i].scroller === scroller && _triggers[i] !== self) {\n                            return; //don't remove the listeners if there are still other triggers referencing it.\n                        }\n                    }\n                    _removeListener(scroller, \"resize\", _onResize);\n                    isViewport || _removeListener(scroller, \"scroll\", _onScroll);\n                }\n            }\n        };\n        self.kill = function(revert, allowAnimation) {\n            self.disable(revert, allowAnimation);\n            scrubTween && !allowAnimation && scrubTween.kill();\n            id && delete _ids[id];\n            var i = _triggers.indexOf(self);\n            i >= 0 && _triggers.splice(i, 1);\n            i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...\n            // if no other ScrollTrigger instances of the same scroller are found, wipe out any recorded scroll position. Otherwise, in a single page application, for example, it could maintain scroll position when it really shouldn't.\n            i = 0;\n            _triggers.forEach(function(t) {\n                return t.scroller === self.scroller && (i = 1);\n            });\n            i || _refreshingAll || (self.scroll.rec = 0);\n            if (animation) {\n                animation.scrollTrigger = null;\n                revert && animation.revert({\n                    kill: false\n                });\n                allowAnimation || animation.kill();\n            }\n            markerStart && [\n                markerStart,\n                markerEnd,\n                markerStartTrigger,\n                markerEndTrigger\n            ].forEach(function(m) {\n                return m.parentNode && m.parentNode.removeChild(m);\n            });\n            _primary === self && (_primary = 0);\n            if (pin) {\n                pinCache && (pinCache.uncache = 1);\n                i = 0;\n                _triggers.forEach(function(t) {\n                    return t.pin === pin && i++;\n                });\n                i || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.\n            }\n            vars.onKill && vars.onKill(self);\n        };\n        _triggers.push(self);\n        self.enable(false, false);\n        customRevertReturn && customRevertReturn(self);\n        if (animation && animation.add && !change) {\n            // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If \"change\" is defined, we know it must be re-enabling, thus we can refresh() right away.\n            var updateFunc = self.update; // some browsers may fire a scroll event BEFORE a tick elapses and/or the DOMContentLoaded fires. So there's a chance update() will be called BEFORE a refresh() has happened on a Timeline-attached ScrollTrigger which means the start/end won't be calculated yet. We don't want to add conditional logic inside the update() method (like check to see if end is defined and if not, force a refresh()) because that's a function that gets hit a LOT (performance). So we swap out the real update() method for this one that'll re-attach it the first time it gets called and of course forces a refresh().\n            self.update = function() {\n                self.update = updateFunc;\n                start || end || self.refresh();\n            };\n            gsap.delayedCall(0.01, self.update);\n            change = 0.01;\n            start = end = 0;\n        } else {\n            self.refresh();\n        }\n        pin && _queueRefreshAll(); // pinning could affect the positions of other things, so make sure we queue a full refresh()\n    };\n    ScrollTrigger.register = function register(core) {\n        if (!_coreInitted) {\n            gsap = core || _getGSAP();\n            _windowExists() && window.document && ScrollTrigger.enable();\n            _coreInitted = _enabled;\n        }\n        return _coreInitted;\n    };\n    ScrollTrigger.defaults = function defaults(config) {\n        if (config) {\n            for(var p in config){\n                _defaults[p] = config[p];\n            }\n        }\n        return _defaults;\n    };\n    ScrollTrigger.disable = function disable(reset, kill) {\n        _enabled = 0;\n        _triggers.forEach(function(trigger) {\n            return trigger[kill ? \"kill\" : \"disable\"](reset);\n        });\n        _removeListener(_win, \"wheel\", _onScroll);\n        _removeListener(_doc, \"scroll\", _onScroll);\n        clearInterval(_syncInterval);\n        _removeListener(_doc, \"touchcancel\", _passThrough);\n        _removeListener(_body, \"touchstart\", _passThrough);\n        _multiListener(_removeListener, _doc, \"pointerdown,touchstart,mousedown\", _pointerDownHandler);\n        _multiListener(_removeListener, _doc, \"pointerup,touchend,mouseup\", _pointerUpHandler);\n        _resizeDelay.kill();\n        _iterateAutoRefresh(_removeListener);\n        for(var i = 0; i < _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.length; i += 3){\n            _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 1]);\n            _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 2]);\n        }\n    };\n    ScrollTrigger.enable = function enable() {\n        _win = window;\n        _doc = document;\n        _docEl = _doc.documentElement;\n        _body = _doc.body;\n        if (gsap) {\n            _toArray = gsap.utils.toArray;\n            _clamp = gsap.utils.clamp;\n            _context = gsap.core.context || _passThrough;\n            _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;\n            _scrollRestoration = _win.history.scrollRestoration || \"auto\";\n            _lastScroll = _win.pageYOffset;\n            gsap.core.globals(\"ScrollTrigger\", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a \"name\" property.\n            if (_body) {\n                _enabled = 1;\n                _div100vh = document.createElement(\"div\"); // to solve mobile browser address bar show/hide resizing, we shouldn't rely on window.innerHeight. Instead, use a <div> with its height set to 100vh and measure that since that's what the scrolling is based on anyway and it's not affected by address bar showing/hiding.\n                _div100vh.style.height = \"100vh\";\n                _div100vh.style.position = \"absolute\";\n                _refresh100vh();\n                _rafBugFix();\n                _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.register(gsap); // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.\n                ScrollTrigger.isTouch = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch;\n                _fixIOSBug = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent); // since 2017, iOS has had a bug that causes event.clientX/Y to be inaccurate when a scroll occurs, thus we must alternate ignoring every other touchmove event to work around it. See https://bugs.webkit.org/show_bug.cgi?id=181954 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503\n                _ignoreMobileResize = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch === 1;\n                _addListener(_win, \"wheel\", _onScroll); // mostly for 3rd party smooth scrolling libraries.\n                _root = [\n                    _win,\n                    _doc,\n                    _docEl,\n                    _body\n                ];\n                if (gsap.matchMedia) {\n                    ScrollTrigger.matchMedia = function(vars) {\n                        var mm = gsap.matchMedia(), p;\n                        for(p in vars){\n                            mm.add(p, vars[p]);\n                        }\n                        return mm;\n                    };\n                    gsap.addEventListener(\"matchMediaInit\", function() {\n                        return _revertAll();\n                    });\n                    gsap.addEventListener(\"matchMediaRevert\", function() {\n                        return _revertRecorded();\n                    });\n                    gsap.addEventListener(\"matchMedia\", function() {\n                        _refreshAll(0, 1);\n                        _dispatch(\"matchMedia\");\n                    });\n                    gsap.matchMedia(\"(orientation: portrait)\", function() {\n                        // when orientation changes, we should take new base measurements for the ignoreMobileResize feature.\n                        _setBaseDimensions();\n                        return _setBaseDimensions;\n                    });\n                } else {\n                    console.warn(\"Requires GSAP 3.11.0 or later\");\n                }\n                _setBaseDimensions();\n                _addListener(_doc, \"scroll\", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!\n                var bodyStyle = _body.style, border = bodyStyle.borderTopStyle, AnimationProto = gsap.core.Animation.prototype, bounds, i;\n                AnimationProto.revert || Object.defineProperty(AnimationProto, \"revert\", {\n                    value: function value() {\n                        return this.time(-0.01, true);\n                    }\n                }); // only for backwards compatibility (Animation.revert() was added after 3.10.4)\n                bodyStyle.borderTopStyle = \"solid\"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.\n                bounds = _getBounds(_body);\n                _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical.m = Math.round(bounds.top + _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding\n                _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal.m = Math.round(bounds.left + _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal.sc()) || 0;\n                border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty(\"border-top-style\"); // TODO: (?) maybe move to leveraging the velocity mechanism in Observer and skip intervals.\n                _syncInterval = setInterval(_sync, 250);\n                gsap.delayedCall(0.5, function() {\n                    return _startup = 0;\n                });\n                _addListener(_doc, \"touchcancel\", _passThrough); // some older Android devices intermittently stop dispatching \"touchmove\" events if we don't listen for \"touchcancel\" on the document.\n                _addListener(_body, \"touchstart\", _passThrough); //works around Safari bug: https://gsap.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n                _multiListener(_addListener, _doc, \"pointerdown,touchstart,mousedown\", _pointerDownHandler);\n                _multiListener(_addListener, _doc, \"pointerup,touchend,mouseup\", _pointerUpHandler);\n                _transformProp = gsap.utils.checkPrefix(\"transform\");\n                _stateProps.push(_transformProp);\n                _coreInitted = _getTime();\n                _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();\n                _autoRefresh = [\n                    _doc,\n                    \"visibilitychange\",\n                    function() {\n                        var w = _win.innerWidth, h = _win.innerHeight;\n                        if (_doc.hidden) {\n                            _prevWidth = w;\n                            _prevHeight = h;\n                        } else if (_prevWidth !== w || _prevHeight !== h) {\n                            _onResize();\n                        }\n                    },\n                    _doc,\n                    \"DOMContentLoaded\",\n                    _refreshAll,\n                    _win,\n                    \"load\",\n                    _refreshAll,\n                    _win,\n                    \"resize\",\n                    _onResize\n                ];\n                _iterateAutoRefresh(_addListener);\n                _triggers.forEach(function(trigger) {\n                    return trigger.enable(0, 1);\n                });\n                for(i = 0; i < _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.length; i += 3){\n                    _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 1]);\n                    _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 2]);\n                }\n            }\n        }\n    };\n    ScrollTrigger.config = function config(vars) {\n        \"limitCallbacks\" in vars && (_limitCallbacks = !!vars.limitCallbacks);\n        var ms = vars.syncInterval;\n        ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);\n        \"ignoreMobileResize\" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);\n        if (\"autoRefreshEvents\" in vars) {\n            _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || \"none\");\n            _ignoreResize = (vars.autoRefreshEvents + \"\").indexOf(\"resize\") === -1;\n        }\n    };\n    ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {\n        var t = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(target), i = _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.indexOf(t), isViewport = _isViewport(t);\n        if (~i) {\n            _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.splice(i, isViewport ? 6 : 2);\n        }\n        if (vars) {\n            isViewport ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.unshift(t, vars);\n        }\n    };\n    ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {\n        _triggers.forEach(function(t) {\n            return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);\n        });\n    };\n    ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {\n        var bounds = (_isString(element) ? (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element) : element).getBoundingClientRect(), offset = bounds[horizontal ? _width : _height] * ratio || 0;\n        return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win.innerHeight;\n    };\n    ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {\n        _isString(element) && (element = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element));\n        var bounds = element.getBoundingClientRect(), size = bounds[horizontal ? _width : _height], offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf(\"%\") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;\n        return horizontal ? (bounds.left + offset) / _win.innerWidth : (bounds.top + offset) / _win.innerHeight;\n    };\n    ScrollTrigger.killAll = function killAll(allowListeners) {\n        _triggers.slice(0).forEach(function(t) {\n            return t.vars.id !== \"ScrollSmoother\" && t.kill();\n        });\n        if (allowListeners !== true) {\n            var listeners = _listeners.killAll || [];\n            _listeners = {};\n            listeners.forEach(function(f) {\n                return f();\n            });\n        }\n    };\n    return ScrollTrigger;\n}();\nScrollTrigger.version = \"3.12.5\";\nScrollTrigger.saveStyles = function(targets) {\n    return targets ? _toArray(targets).forEach(function(target) {\n        // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]\n        if (target && target.style) {\n            var i = _savedStyles.indexOf(target);\n            i >= 0 && _savedStyles.splice(i, 5);\n            _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute(\"transform\"), gsap.core.getCache(target), _context());\n        }\n    }) : _savedStyles;\n};\nScrollTrigger.revert = function(soft, media) {\n    return _revertAll(!soft, media);\n};\nScrollTrigger.create = function(vars, animation) {\n    return new ScrollTrigger(vars, animation);\n};\nScrollTrigger.refresh = function(safe) {\n    return safe ? _onResize() : (_coreInitted || ScrollTrigger.register()) && _refreshAll(true);\n};\nScrollTrigger.update = function(force) {\n    return ++_Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache && _updateAll(force === true ? 2 : 0);\n};\nScrollTrigger.clearScrollMemory = _clearScrollMemory;\nScrollTrigger.maxScroll = function(element, horizontal) {\n    return _maxScroll(element, horizontal ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\n};\nScrollTrigger.getScrollFunc = function(element, horizontal) {\n    return (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)((0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element), horizontal ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\n};\nScrollTrigger.getById = function(id) {\n    return _ids[id];\n};\nScrollTrigger.getAll = function() {\n    return _triggers.filter(function(t) {\n        return t.vars.id !== \"ScrollSmoother\";\n    });\n}; // it's common for people to ScrollTrigger.getAll(t => t.kill()) on page routes, for example, and we don't want it to ruin smooth scrolling by killing the main ScrollSmoother one.\nScrollTrigger.isScrolling = function() {\n    return !!_lastScrollTime;\n};\nScrollTrigger.snapDirectional = _snapDirectional;\nScrollTrigger.addEventListener = function(type, callback) {\n    var a = _listeners[type] || (_listeners[type] = []);\n    ~a.indexOf(callback) || a.push(callback);\n};\nScrollTrigger.removeEventListener = function(type, callback) {\n    var a = _listeners[type], i = a && a.indexOf(callback);\n    i >= 0 && a.splice(i, 1);\n};\nScrollTrigger.batch = function(targets, vars) {\n    var result = [], varsCopy = {}, interval = vars.interval || 0.016, batchMax = vars.batchMax || 1e9, proxyCallback = function proxyCallback(type, callback) {\n        var elements = [], triggers = [], delay = gsap.delayedCall(interval, function() {\n            callback(elements, triggers);\n            elements = [];\n            triggers = [];\n        }).pause();\n        return function(self) {\n            elements.length || delay.restart(true);\n            elements.push(self.trigger);\n            triggers.push(self);\n            batchMax <= elements.length && delay.progress(1);\n        };\n    }, p;\n    for(p in vars){\n        varsCopy[p] = p.substr(0, 2) === \"on\" && _isFunction(vars[p]) && p !== \"onRefreshInit\" ? proxyCallback(p, vars[p]) : vars[p];\n    }\n    if (_isFunction(batchMax)) {\n        batchMax = batchMax();\n        _addListener(ScrollTrigger, \"refresh\", function() {\n            return batchMax = vars.batchMax();\n        });\n    }\n    _toArray(targets).forEach(function(target) {\n        var config = {};\n        for(p in varsCopy){\n            config[p] = varsCopy[p];\n        }\n        config.trigger = target;\n        result.push(ScrollTrigger.create(config));\n    });\n    return result;\n}; // to reduce file size. clamps the scroll and also returns a duration multiplier so that if the scroll gets chopped shorter, the duration gets curtailed as well (otherwise if you're very close to the top of the page, for example, and swipe up really fast, it'll suddenly slow down and take a long time to reach the top).\nvar _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {\n    current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);\n    return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;\n}, _allowNativePanning = function _allowNativePanning(target, direction) {\n    if (direction === true) {\n        target.style.removeProperty(\"touch-action\");\n    } else {\n        target.style.touchAction = direction === true ? \"auto\" : direction ? \"pan-\" + direction + (_Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch ? \" pinch-zoom\" : \"\") : \"none\"; // note: Firefox doesn't support it pinch-zoom properly, at least in addition to a pan-x or pan-y.\n    }\n    target === _docEl && _allowNativePanning(_body, direction);\n}, _overflow = {\n    auto: 1,\n    scroll: 1\n}, _nestedScroll = function _nestedScroll(_ref5) {\n    var event = _ref5.event, target = _ref5.target, axis = _ref5.axis;\n    var node = (event.changedTouches ? event.changedTouches[0] : event).target, cache = node._gsap || gsap.core.getCache(node), time = _getTime(), cs;\n    if (!cache._isScrollT || time - cache._isScrollT > 2000) {\n        // cache for 2 seconds to improve performance.\n        while(node && node !== _body && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))){\n            node = node.parentNode;\n        }\n        cache._isScroll = node && node !== target && !_isViewport(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);\n        cache._isScrollT = time;\n    }\n    if (cache._isScroll || axis === \"x\") {\n        event.stopPropagation();\n        event._gsapAllow = true;\n    }\n}, // capture events on scrollable elements INSIDE the <body> and allow those by calling stopPropagation() when we find a scrollable ancestor\n_inputObserver = function _inputObserver(target, type, inputs, nested) {\n    return _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.create({\n        target: target,\n        capture: true,\n        debounce: false,\n        lockAxis: true,\n        type: type,\n        onWheel: nested = nested && _nestedScroll,\n        onPress: nested,\n        onDrag: nested,\n        onScroll: nested,\n        onEnable: function onEnable() {\n            return inputs && _addListener(_doc, _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.eventTypes[0], _captureInputs, false, true);\n        },\n        onDisable: function onDisable() {\n            return _removeListener(_doc, _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.eventTypes[0], _captureInputs, true);\n        }\n    });\n}, _inputExp = /(input|label|select|textarea)/i, _inputIsFocused, _captureInputs = function _captureInputs(e) {\n    var isInput = _inputExp.test(e.target.tagName);\n    if (isInput || _inputIsFocused) {\n        e._gsapAllow = true;\n        _inputIsFocused = isInput;\n    }\n}, _getScrollNormalizer = function _getScrollNormalizer(vars) {\n    _isObject(vars) || (vars = {});\n    vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;\n    vars.type || (vars.type = \"wheel,touch\");\n    vars.debounce = !!vars.debounce;\n    vars.id = vars.id || \"normalizer\";\n    var _vars2 = vars, normalizeScrollX = _vars2.normalizeScrollX, momentum = _vars2.momentum, allowNestedScroll = _vars2.allowNestedScroll, onRelease = _vars2.onRelease, self, maxY, target = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.target) || _docEl, smoother = gsap.core.globals().ScrollSmoother, smootherInstance = smoother && smoother.get(), content = _fixIOSBug && (vars.content && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()), scrollFuncY = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical), scrollFuncX = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal), scale = 1, initialScale = (_Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch && _win.visualViewport ? _win.visualViewport.scale * _win.visualViewport.width : _win.outerWidth) / _win.innerWidth, wheelRefresh = 0, resolveMomentumDuration = _isFunction(momentum) ? function resolveMomentumDuration() {\n        return momentum(self);\n    } : function() {\n        return momentum || 2.8;\n    }, lastRefreshID, skipTouchMove, inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll), resumeTouchMove = function resumeTouchMove() {\n        return skipTouchMove = false;\n    }, scrollClampX = _passThrough, scrollClampY = _passThrough, updateClamps = function updateClamps() {\n        maxY = _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\n        scrollClampY = _clamp(_fixIOSBug ? 1 : 0, maxY);\n        normalizeScrollX && (scrollClampX = _clamp(0, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal)));\n        lastRefreshID = _refreshID;\n    }, removeContentOffset = function removeContentOffset() {\n        content._gsap.y = _round(parseFloat(content._gsap.y) + scrollFuncY.offset) + \"px\";\n        content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + parseFloat(content._gsap.y) + \", 0, 1)\";\n        scrollFuncY.offset = scrollFuncY.cacheID = 0;\n    }, ignoreDrag = function ignoreDrag() {\n        if (skipTouchMove) {\n            requestAnimationFrame(resumeTouchMove);\n            var offset = _round(self.deltaY / 2), scroll = scrollClampY(scrollFuncY.v - offset);\n            if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {\n                scrollFuncY.offset = scroll - scrollFuncY.v;\n                var y = _round((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);\n                content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + y + \", 0, 1)\";\n                content._gsap.y = y + \"px\";\n                scrollFuncY.cacheID = _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache;\n                _updateAll();\n            }\n            return true;\n        }\n        scrollFuncY.offset && removeContentOffset();\n        skipTouchMove = true;\n    }, tween, startScrollX, startScrollY, onStopDelayedCall, onResize = function onResize() {\n        // if the window resizes, like on an iPhone which Apple FORCES the address bar to show/hide even if we event.preventDefault(), it may be scrolling too far now that the address bar is showing, so we must dynamically adjust the momentum tween.\n        updateClamps();\n        if (tween.isActive() && tween.vars.scrollY > maxY) {\n            scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo(\"scrollY\", maxY);\n        }\n    };\n    content && gsap.set(content, {\n        y: \"+=0\"\n    }); // to ensure there's a cache (element._gsap)\n    vars.ignoreCheck = function(e) {\n        return _fixIOSBug && e.type === \"touchmove\" && ignoreDrag(e) || scale > 1.05 && e.type !== \"touchstart\" || self.isGesturing || e.touches && e.touches.length > 1;\n    };\n    vars.onPress = function() {\n        skipTouchMove = false;\n        var prevScale = scale;\n        scale = _round((_win.visualViewport && _win.visualViewport.scale || 1) / initialScale);\n        tween.pause();\n        prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : \"x\");\n        startScrollX = scrollFuncX();\n        startScrollY = scrollFuncY();\n        updateClamps();\n        lastRefreshID = _refreshID;\n    };\n    vars.onRelease = vars.onGestureStart = function(self, wasDragging) {\n        scrollFuncY.offset && removeContentOffset();\n        if (!wasDragging) {\n            onStopDelayedCall.restart(true);\n        } else {\n            _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++; // make sure we're pulling the non-cached value\n            // alternate algorithm: durX = Math.min(6, Math.abs(self.velocityX / 800)),\tdur = Math.max(durX, Math.min(6, Math.abs(self.velocityY / 800))); dur = dur * (0.4 + (1 - _power4In(dur / 6)) * 0.6)) * (momentumSpeed || 1)\n            var dur = resolveMomentumDuration(), currentScroll, endScroll;\n            if (normalizeScrollX) {\n                currentScroll = scrollFuncX();\n                endScroll = currentScroll + dur * 0.05 * -self.velocityX / 0.227; // the constant .227 is from power4(0.05). velocity is inverted because scrolling goes in the opposite direction.\n                dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal));\n                tween.vars.scrollX = scrollClampX(endScroll);\n            }\n            currentScroll = scrollFuncY();\n            endScroll = currentScroll + dur * 0.05 * -self.velocityY / 0.227; // the constant .227 is from power4(0.05)\n            dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical));\n            tween.vars.scrollY = scrollClampY(endScroll);\n            tween.invalidate().duration(dur).play(0.01);\n            if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {\n                // iOS bug: it'll show the address bar but NOT fire the window \"resize\" event until the animation is done but we must protect against overshoot so we leverage an onUpdate to do so.\n                gsap.to({}, {\n                    onUpdate: onResize,\n                    duration: dur\n                });\n            }\n        }\n        onRelease && onRelease(self);\n    };\n    vars.onWheel = function() {\n        tween._ts && tween.pause();\n        if (_getTime() - wheelRefresh > 1000) {\n            // after 1 second, refresh the clamps otherwise that'll only happen when ScrollTrigger.refresh() is called or for touch-scrolling.\n            lastRefreshID = 0;\n            wheelRefresh = _getTime();\n        }\n    };\n    vars.onChange = function(self, dx, dy, xArray, yArray) {\n        _refreshID !== lastRefreshID && updateClamps();\n        dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1])); // for more precision, we track pointer/touch movement from the start, otherwise it'll drift.\n        if (dy) {\n            scrollFuncY.offset && removeContentOffset();\n            var isTouch = yArray[2] === dy, y = isTouch ? startScrollY + self.startY - self.y : scrollFuncY() + dy - yArray[1], yClamped = scrollClampY(y);\n            isTouch && y !== yClamped && (startScrollY += yClamped - y);\n            scrollFuncY(yClamped);\n        }\n        (dy || dx) && _updateAll();\n    };\n    vars.onEnable = function() {\n        _allowNativePanning(target, normalizeScrollX ? false : \"x\");\n        ScrollTrigger.addEventListener(\"refresh\", onResize);\n        _addListener(_win, \"resize\", onResize);\n        if (scrollFuncY.smooth) {\n            scrollFuncY.target.style.scrollBehavior = \"auto\";\n            scrollFuncY.smooth = scrollFuncX.smooth = false;\n        }\n        inputObserver.enable();\n    };\n    vars.onDisable = function() {\n        _allowNativePanning(target, true);\n        _removeListener(_win, \"resize\", onResize);\n        ScrollTrigger.removeEventListener(\"refresh\", onResize);\n        inputObserver.kill();\n    };\n    vars.lockAxis = vars.lockAxis !== false;\n    self = new _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer(vars);\n    self.iOS = _fixIOSBug; // used in the Observer getCachedScroll() function to work around an iOS bug that wreaks havoc with TouchEvent.clientY if we allow scroll to go all the way back to 0.\n    _fixIOSBug && !scrollFuncY() && scrollFuncY(1); // iOS bug causes event.clientY values to freak out (wildly inaccurate) if the scroll position is exactly 0.\n    _fixIOSBug && gsap.ticker.add(_passThrough); // prevent the ticker from sleeping\n    onStopDelayedCall = self._dc;\n    tween = gsap.to(self, {\n        ease: \"power4\",\n        paused: true,\n        inherit: false,\n        scrollX: normalizeScrollX ? \"+=0.1\" : \"+=0\",\n        scrollY: \"+=0.1\",\n        modifiers: {\n            scrollY: _interruptionTracker(scrollFuncY, scrollFuncY(), function() {\n                return tween.pause();\n            })\n        },\n        onUpdate: _updateAll,\n        onComplete: onStopDelayedCall.vars.onComplete\n    }); // we need the modifier to sense if the scroll position is altered outside of the momentum tween (like with a scrollTo tween) so we can pause() it to prevent conflicts.\n    return self;\n};\nScrollTrigger.sort = function(func) {\n    return _triggers.sort(func || function(a, b) {\n        return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);\n    });\n};\nScrollTrigger.observe = function(vars) {\n    return new _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer(vars);\n};\nScrollTrigger.normalizeScroll = function(vars) {\n    if (typeof vars === \"undefined\") {\n        return _normalizer;\n    }\n    if (vars === true && _normalizer) {\n        return _normalizer.enable();\n    }\n    if (vars === false) {\n        _normalizer && _normalizer.kill();\n        _normalizer = vars;\n        return;\n    }\n    var normalizer = vars instanceof _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer ? vars : _getScrollNormalizer(vars);\n    _normalizer && _normalizer.target === normalizer.target && _normalizer.kill();\n    _isViewport(normalizer.target) && (_normalizer = normalizer);\n    return normalizer;\n};\nScrollTrigger.core = {\n    // smaller file size way to leverage in ScrollSmoother and Observer\n    _getVelocityProp: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getVelocityProp,\n    _inputObserver: _inputObserver,\n    _scrollers: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers,\n    _proxies: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies,\n    bridge: {\n        // when normalizeScroll sets the scroll position (ss = setScroll)\n        ss: function ss() {\n            _lastScrollTime || _dispatch(\"scrollStart\");\n            _lastScrollTime = _getTime();\n        },\n        // a way to get the _refreshing value in Observer\n        ref: function ref() {\n            return _refreshing;\n        }\n    }\n};\n_getGSAP() && gsap.registerPlugin(ScrollTrigger);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9TY3JvbGxUcmlnZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCLEdBQ2tJO0FBRXBKLElBQUlTLE1BQ0FDLGNBQ0FDLE1BQ0FDLE1BQ0FDLFFBQ0FDLE9BQ0FDLE9BQ0FDLGNBQ0FDLFVBQ0FDLFFBQ0FDLFFBQ0FDLGVBQ0FDLGFBQ0FDLGdCQUNBQyxnQkFDQUMsSUFDQUMsWUFDQUMsYUFDQUMsY0FDQUMsT0FDQUMscUJBQ0FDLGVBQ0FDLGFBQ0FDLHFCQUNBQyxtQkFDQUMsa0JBQ0FDLFlBQ0FDLFVBQ0FDLG9CQUNBQyxXQUNBQyxRQUNBQyxhQUNBQyxjQUNBQyxpQkFDQSx1UUFBdVE7QUFDM1FDLFdBQVcsR0FDUEMsV0FBV0MsS0FBS0MsR0FBRyxFQUNuQkMsU0FBU0gsWUFDVEksa0JBQWtCLEdBQ2xCQyxXQUFXLEdBQ1hDLGNBQWMsU0FBU0EsWUFBWUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLElBQUk7SUFDdEQsSUFBSUMsUUFBUUMsVUFBVUosVUFBV0EsQ0FBQUEsTUFBTUssTUFBTSxDQUFDLEdBQUcsT0FBTyxZQUFZTCxNQUFNTSxPQUFPLENBQUMsU0FBUyxDQUFDO0lBQzVGSixJQUFJLENBQUMsTUFBTUQsT0FBTyxRQUFRLEdBQUdFO0lBQzdCLE9BQU9BLFFBQVFILE1BQU1LLE1BQU0sQ0FBQyxHQUFHTCxNQUFNTyxNQUFNLEdBQUcsS0FBS1A7QUFDckQsR0FDSVEsYUFBYSxTQUFTQSxXQUFXUixLQUFLLEVBQUVHLEtBQUs7SUFDL0MsT0FBT0EsU0FBVSxFQUFDQyxVQUFVSixVQUFVQSxNQUFNSyxNQUFNLENBQUMsR0FBRyxPQUFPLFFBQU8sSUFBSyxXQUFXTCxRQUFRLE1BQU1BO0FBQ3BHLEdBQ0lTLGFBQWEsU0FBU0E7SUFDeEIsT0FBT1gsWUFBWVksc0JBQXNCRDtBQUMzQyxHQUNJLHVOQUF1TjtBQUMzTkUsc0JBQXNCLFNBQVNBO0lBQzdCLE9BQU94QyxpQkFBaUI7QUFDMUIsR0FDSXlDLG9CQUFvQixTQUFTQTtJQUMvQixPQUFPekMsaUJBQWlCO0FBQzFCLEdBQ0kwQyxlQUFlLFNBQVNBLGFBQWFDLENBQUM7SUFDeEMsT0FBT0E7QUFDVCxHQUNJQyxTQUFTLFNBQVNBLE9BQU9mLEtBQUs7SUFDaEMsT0FBT2dCLEtBQUtDLEtBQUssQ0FBQ2pCLFFBQVEsVUFBVSxVQUFVO0FBQ2hELEdBQ0lrQixnQkFBZ0IsU0FBU0E7SUFDM0IsT0FBTyxPQUFPQyxXQUFXO0FBQzNCLEdBQ0lDLFdBQVcsU0FBU0E7SUFDdEIsT0FBTzlELFFBQVE0RCxtQkFBb0I1RCxDQUFBQSxPQUFPNkQsT0FBTzdELElBQUksS0FBS0EsS0FBSytELGNBQWMsSUFBSS9EO0FBQ25GLEdBQ0lnRSxjQUFjLFNBQVNBLFlBQVlDLENBQUM7SUFDdEMsT0FBTyxDQUFDLENBQUMsQ0FBQzNELE1BQU0wQyxPQUFPLENBQUNpQjtBQUMxQixHQUNJQyx3QkFBd0IsU0FBU0Esc0JBQXNCQyxpQkFBaUI7SUFDMUUsT0FBTyxDQUFDQSxzQkFBc0IsV0FBV3JDLFNBQVM1QixJQUFJLENBQUMsVUFBVWlFLGtCQUFrQixLQUFLL0QsTUFBTSxDQUFDLFdBQVcrRCxrQkFBa0IsSUFBSTlELEtBQUssQ0FBQyxXQUFXOEQsa0JBQWtCO0FBQ3JLLEdBQ0lDLGlCQUFpQixTQUFTQSxlQUFlQyxPQUFPO0lBQ2xELE9BQU92RSwyREFBYUEsQ0FBQ3VFLFNBQVMsNEJBQTZCTCxDQUFBQSxZQUFZSyxXQUFXO1FBQ2hGQyxZQUFZQyxLQUFLLEdBQUdyRSxLQUFLc0UsVUFBVTtRQUNuQ0YsWUFBWUcsTUFBTSxHQUFHM0M7UUFDckIsT0FBT3dDO0lBQ1QsSUFBSTtRQUNGLE9BQU9JLFdBQVdMO0lBQ3BCO0FBQ0YsR0FDSU0sZUFBZSxTQUFTQSxhQUFhQyxRQUFRLEVBQUVDLFVBQVUsRUFBRUMsSUFBSTtJQUNqRSxJQUFJQyxJQUFJRCxLQUFLQyxDQUFDLEVBQ1ZDLEtBQUtGLEtBQUtFLEVBQUUsRUFDWkMsSUFBSUgsS0FBS0csQ0FBQztJQUNkLE9BQU8sQ0FBQ0EsSUFBSW5GLDJEQUFhQSxDQUFDOEUsVUFBVSx3QkFBdUIsSUFBSztRQUM5RCxPQUFPSyxHQUFHLENBQUNGLEVBQUU7SUFDZixJQUFJO1FBQ0YsT0FBTyxDQUFDRixhQUFhWCxzQkFBc0JjLE1BQU1KLFFBQVEsQ0FBQyxXQUFXSSxHQUFHLEtBQUs7SUFDL0U7QUFDRixHQUNJRSxrQkFBa0IsU0FBU0EsZ0JBQWdCYixPQUFPLEVBQUVRLFVBQVU7SUFDaEUsT0FBTyxDQUFDQSxjQUFjLENBQUNqRixrREFBUUEsQ0FBQ29ELE9BQU8sQ0FBQ3FCLFdBQVdELGVBQWVDLFdBQVc7UUFDM0UsT0FBT0M7SUFDVDtBQUNGLEdBQ0lhLGFBQWEsU0FBU0EsV0FBV2QsT0FBTyxFQUFFZSxLQUFLO0lBQ2pELElBQUlDLElBQUlELE1BQU1DLENBQUMsRUFDWEwsS0FBS0ksTUFBTUosRUFBRSxFQUNiRCxJQUFJSyxNQUFNTCxDQUFDLEVBQ1hFLElBQUlHLE1BQU1ILENBQUM7SUFDZixPQUFPdkIsS0FBSzRCLEdBQUcsQ0FBQyxHQUFHLENBQUNELElBQUksV0FBV0wsRUFBQyxLQUFPQyxDQUFBQSxJQUFJbkYsMkRBQWFBLENBQUN1RSxTQUFTZ0IsRUFBQyxJQUFLSixNQUFNYixlQUFlQyxVQUFVLENBQUNVLEVBQUUsR0FBR2YsWUFBWUssV0FBVyxDQUFDakUsTUFBTSxDQUFDaUYsRUFBRSxJQUFJaEYsS0FBSyxDQUFDZ0YsRUFBRSxJQUFJbkIsc0JBQXNCYyxNQUFNWCxPQUFPLENBQUNnQixFQUFFLEdBQUdoQixPQUFPLENBQUMsV0FBV1csR0FBRztBQUNuTyxHQUNJTyxzQkFBc0IsU0FBU0Esb0JBQW9CQyxJQUFJLEVBQUVDLE1BQU07SUFDakUsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUl4RSxhQUFhK0IsTUFBTSxFQUFFeUMsS0FBSyxFQUFHO1FBQzlDLEVBQUNELFVBQVUsQ0FBQ0EsT0FBT3pDLE9BQU8sQ0FBQzlCLFlBQVksQ0FBQ3dFLElBQUksRUFBRSxNQUFNRixLQUFLdEUsWUFBWSxDQUFDd0UsRUFBRSxFQUFFeEUsWUFBWSxDQUFDd0UsSUFBSSxFQUFFLEVBQUV4RSxZQUFZLENBQUN3RSxJQUFJLEVBQUU7SUFDckg7QUFDRixHQUNJNUMsWUFBWSxTQUFTQSxVQUFVSixLQUFLO0lBQ3RDLE9BQU8sT0FBT0EsVUFBVTtBQUMxQixHQUNJaUQsY0FBYyxTQUFTQSxZQUFZakQsS0FBSztJQUMxQyxPQUFPLE9BQU9BLFVBQVU7QUFDMUIsR0FDSWtELFlBQVksU0FBU0EsVUFBVWxELEtBQUs7SUFDdEMsT0FBTyxPQUFPQSxVQUFVO0FBQzFCLEdBQ0ltRCxZQUFZLFNBQVNBLFVBQVVuRCxLQUFLO0lBQ3RDLE9BQU8sT0FBT0EsVUFBVTtBQUMxQixHQUNJb0QsZ0JBQWdCLFNBQVNBLGNBQWNDLFNBQVMsRUFBRUMsUUFBUSxFQUFFQyxLQUFLO0lBQ25FLE9BQU9GLGFBQWFBLFVBQVVHLFFBQVEsQ0FBQ0YsV0FBVyxJQUFJLE1BQU1DLFNBQVNGLFVBQVVFLEtBQUs7QUFDdEYsR0FDSUUsWUFBWSxTQUFTQSxVQUFVdkQsSUFBSSxFQUFFNEMsSUFBSTtJQUMzQyxJQUFJNUMsS0FBS3dELE9BQU8sRUFBRTtRQUNoQixJQUFJQyxTQUFTekQsS0FBSzBELElBQUksR0FBRzFELEtBQUswRCxJQUFJLENBQUNDLEdBQUcsQ0FBQztZQUNyQyxPQUFPZixLQUFLNUM7UUFDZCxLQUFLNEMsS0FBSzVDO1FBQ1Z5RCxVQUFVQSxPQUFPRyxTQUFTLElBQUs1RCxDQUFBQSxLQUFLNkQsaUJBQWlCLEdBQUdKLE1BQUs7SUFDL0Q7QUFDRixHQUNJSyxPQUFPaEQsS0FBS2lELEdBQUcsRUFDZkMsUUFBUSxRQUNSQyxPQUFPLE9BQ1BDLFNBQVMsU0FDVEMsVUFBVSxVQUNWQyxTQUFTLFNBQ1RDLFVBQVUsVUFDVkMsU0FBUyxTQUNUQyxRQUFRLFFBQ1JDLE9BQU8sT0FDUEMsVUFBVSxVQUNWQyxXQUFXLFdBQ1hDLFVBQVUsVUFDVkMsU0FBUyxTQUNUQyxVQUFVLFVBQ1ZDLE1BQU0sTUFDTkMsb0JBQW9CLFNBQVNBLGtCQUFrQnRELE9BQU87SUFDeEQsT0FBT25FLEtBQUswSCxnQkFBZ0IsQ0FBQ3ZEO0FBQy9CLEdBQ0l3RCxvQkFBb0IsU0FBU0Esa0JBQWtCeEQsT0FBTztJQUN4RCwyR0FBMkc7SUFDM0csSUFBSXlELFdBQVdILGtCQUFrQnRELFNBQVN5RCxRQUFRO0lBRWxEekQsUUFBUTBELEtBQUssQ0FBQ0QsUUFBUSxHQUFHQSxhQUFhLGNBQWNBLGFBQWEsVUFBVUEsV0FBVztBQUN4RixHQUNJRSxlQUFlLFNBQVNBLGFBQWFDLEdBQUcsRUFBRUMsUUFBUTtJQUNwRCxJQUFLLElBQUlDLEtBQUtELFNBQVU7UUFDdEJDLEtBQUtGLE9BQVFBLENBQUFBLEdBQUcsQ0FBQ0UsRUFBRSxHQUFHRCxRQUFRLENBQUNDLEVBQUU7SUFDbkM7SUFFQSxPQUFPRjtBQUNULEdBQ0l2RCxhQUFhLFNBQVNBLFdBQVdMLE9BQU8sRUFBRStELGlCQUFpQjtJQUM3RCxJQUFJQyxRQUFRRCxxQkFBcUJULGtCQUFrQnRELFFBQVEsQ0FBQ3ZELGVBQWUsS0FBSyw4QkFBOEJkLEtBQUtzSSxFQUFFLENBQUNqRSxTQUFTO1FBQzdIa0UsR0FBRztRQUNIQyxHQUFHO1FBQ0hDLFVBQVU7UUFDVkMsVUFBVTtRQUNWQyxVQUFVO1FBQ1ZDLFdBQVc7UUFDWEMsV0FBVztRQUNYQyxPQUFPO1FBQ1BDLE9BQU87UUFDUEMsT0FBTztJQUNULEdBQUc5QyxRQUFRLENBQUMsSUFDUitDLFNBQVM1RSxRQUFRNkUscUJBQXFCO0lBQzFDYixTQUFTQSxNQUFNbkMsUUFBUSxDQUFDLEdBQUdpRCxJQUFJO0lBQy9CLE9BQU9GO0FBQ1QsR0FDSUcsV0FBVyxTQUFTQSxTQUFTL0UsT0FBTyxFQUFFZ0YsS0FBSztJQUM3QyxJQUFJckUsS0FBS3FFLE1BQU1yRSxFQUFFO0lBQ2pCLE9BQU9YLE9BQU8sQ0FBQyxXQUFXVyxHQUFHLElBQUlYLE9BQU8sQ0FBQyxXQUFXVyxHQUFHLElBQUk7QUFDN0QsR0FDSXNFLHNCQUFzQixTQUFTQSxvQkFBb0JDLFFBQVE7SUFDN0QsSUFBSXRFLElBQUksRUFBRSxFQUNOdUUsU0FBU0QsU0FBU0MsTUFBTSxFQUN4QkMsV0FBV0YsU0FBU0UsUUFBUSxJQUM1QnRCO0lBRUosSUFBS0EsS0FBS3FCLE9BQVE7UUFDaEJ2RSxFQUFFeUUsSUFBSSxDQUFDRixNQUFNLENBQUNyQixFQUFFLEdBQUdzQjtJQUNyQjtJQUVBLE9BQU94RTtBQUNULEdBQ0kwRSxtQkFBbUIsU0FBU0EsaUJBQWlCNUQsU0FBUztJQUN4RCxPQUFPLFNBQVVyRCxLQUFLO1FBQ3BCLE9BQU8xQyxLQUFLNEosS0FBSyxDQUFDQyxJQUFJLENBQUNQLG9CQUFvQnZELFlBQVlyRDtJQUN6RDtBQUNGLEdBQ0lvSCxtQkFBbUIsU0FBU0EsaUJBQWlCQyxvQkFBb0I7SUFDbkUsSUFBSUYsT0FBTzdKLEtBQUs0SixLQUFLLENBQUNDLElBQUksQ0FBQ0UsdUJBQ3ZCOUUsSUFBSStFLE1BQU1DLE9BQU8sQ0FBQ0YseUJBQXlCQSxxQkFBcUJHLEtBQUssQ0FBQyxHQUFHQyxJQUFJLENBQUMsU0FBVWxGLENBQUMsRUFBRW1GLENBQUM7UUFDOUYsT0FBT25GLElBQUltRjtJQUNiO0lBQ0EsT0FBT25GLElBQUksU0FBVXZDLEtBQUssRUFBRTJILFNBQVMsRUFBRUMsU0FBUztRQUM5QyxJQUFJQSxjQUFjLEtBQUssR0FBRztZQUN4QkEsWUFBWTtRQUNkO1FBRUEsSUFBSTVFO1FBRUosSUFBSSxDQUFDMkUsV0FBVztZQUNkLE9BQU9SLEtBQUtuSDtRQUNkO1FBRUEsSUFBSTJILFlBQVksR0FBRztZQUNqQjNILFNBQVM0SCxXQUFXLDJHQUEyRztZQUUvSCxJQUFLNUUsSUFBSSxHQUFHQSxJQUFJVCxFQUFFaEMsTUFBTSxFQUFFeUMsSUFBSztnQkFDN0IsSUFBSVQsQ0FBQyxDQUFDUyxFQUFFLElBQUloRCxPQUFPO29CQUNqQixPQUFPdUMsQ0FBQyxDQUFDUyxFQUFFO2dCQUNiO1lBQ0Y7WUFFQSxPQUFPVCxDQUFDLENBQUNTLElBQUksRUFBRTtRQUNqQixPQUFPO1lBQ0xBLElBQUlULEVBQUVoQyxNQUFNO1lBQ1pQLFNBQVM0SDtZQUVULE1BQU81RSxJQUFLO2dCQUNWLElBQUlULENBQUMsQ0FBQ1MsRUFBRSxJQUFJaEQsT0FBTztvQkFDakIsT0FBT3VDLENBQUMsQ0FBQ1MsRUFBRTtnQkFDYjtZQUNGO1FBQ0Y7UUFFQSxPQUFPVCxDQUFDLENBQUMsRUFBRTtJQUNiLElBQUksU0FBVXZDLEtBQUssRUFBRTJILFNBQVMsRUFBRUMsU0FBUztRQUN2QyxJQUFJQSxjQUFjLEtBQUssR0FBRztZQUN4QkEsWUFBWTtRQUNkO1FBRUEsSUFBSUMsVUFBVVYsS0FBS25IO1FBQ25CLE9BQU8sQ0FBQzJILGFBQWEzRyxLQUFLaUQsR0FBRyxDQUFDNEQsVUFBVTdILFNBQVM0SCxhQUFhQyxVQUFVN0gsUUFBUSxNQUFNMkgsWUFBWSxJQUFJRSxVQUFVVixLQUFLUSxZQUFZLElBQUkzSCxRQUFRcUgsdUJBQXVCckgsUUFBUXFIO0lBQzlLO0FBQ0YsR0FDSVMsdUJBQXVCLFNBQVNBLHFCQUFxQmpCLFFBQVE7SUFDL0QsT0FBTyxTQUFVN0csS0FBSyxFQUFFK0gsRUFBRTtRQUN4QixPQUFPWCxpQkFBaUJSLG9CQUFvQkMsV0FBVzdHLE9BQU8rSCxHQUFHSixTQUFTO0lBQzVFO0FBQ0YsR0FDSUssaUJBQWlCLFNBQVNBLGVBQWVsRixJQUFJLEVBQUVuQixPQUFPLEVBQUVzRyxLQUFLLEVBQUVDLFFBQVE7SUFDekUsT0FBT0QsTUFBTUUsS0FBSyxDQUFDLEtBQUtDLE9BQU8sQ0FBQyxTQUFVbkksSUFBSTtRQUM1QyxPQUFPNkMsS0FBS25CLFNBQVMxQixNQUFNaUk7SUFDN0I7QUFDRixHQUNJRyxlQUFlLFNBQVNBLGFBQWExRyxPQUFPLEVBQUUxQixJQUFJLEVBQUU2QyxJQUFJLEVBQUV3RixVQUFVLEVBQUVDLE9BQU87SUFDL0UsT0FBTzVHLFFBQVE2RyxnQkFBZ0IsQ0FBQ3ZJLE1BQU02QyxNQUFNO1FBQzFDMkYsU0FBUyxDQUFDSDtRQUNWQyxTQUFTLENBQUMsQ0FBQ0E7SUFDYjtBQUNGLEdBQ0lHLGtCQUFrQixTQUFTQSxnQkFBZ0IvRyxPQUFPLEVBQUUxQixJQUFJLEVBQUU2QyxJQUFJLEVBQUV5RixPQUFPO0lBQ3pFLE9BQU81RyxRQUFRZ0gsbUJBQW1CLENBQUMxSSxNQUFNNkMsTUFBTSxDQUFDLENBQUN5RjtBQUNuRCxHQUNJSyxpQkFBaUIsU0FBU0EsZUFBZTlGLElBQUksRUFBRStGLEVBQUUsRUFBRUMsVUFBVTtJQUMvREEsYUFBYUEsY0FBY0EsV0FBV0MsWUFBWTtJQUVsRCxJQUFJRCxZQUFZO1FBQ2RoRyxLQUFLK0YsSUFBSSxTQUFTQztRQUNsQmhHLEtBQUsrRixJQUFJLGFBQWFDO0lBQ3hCO0FBQ0YsR0FDSUUsa0JBQWtCO0lBQ3BCQyxZQUFZO0lBQ1pDLFVBQVU7SUFDVkMsUUFBUTtJQUNSQyxVQUFVO0lBQ1ZDLFlBQVk7QUFDZCxHQUNJQyxZQUFZO0lBQ2RDLGVBQWU7SUFDZkMsZUFBZTtBQUNqQixHQUNJQyxZQUFZO0lBQ2RDLEtBQUs7SUFDTEMsTUFBTTtJQUNOQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsT0FBTztBQUNULEdBQ0lDLGNBQWMsU0FBU0EsWUFBWS9KLEtBQUssRUFBRWdLLElBQUk7SUFDaEQsSUFBSTVKLFVBQVVKLFFBQVE7UUFDcEIsSUFBSWlLLFVBQVVqSyxNQUFNTSxPQUFPLENBQUMsTUFDeEI0SixXQUFXLENBQUNELFVBQVUsQ0FBRWpLLENBQUFBLE1BQU1tSyxNQUFNLENBQUNGLFVBQVUsS0FBSyxLQUFLRyxXQUFXcEssTUFBTUssTUFBTSxDQUFDNEosVUFBVSxNQUFNO1FBRXJHLElBQUksQ0FBQ0EsU0FBUztZQUNaakssTUFBTU0sT0FBTyxDQUFDLE9BQU8ySixXQUFZQyxDQUFBQSxZQUFZRixPQUFPLEdBQUU7WUFDdERoSyxRQUFRQSxNQUFNSyxNQUFNLENBQUMsR0FBRzRKLFVBQVU7UUFDcEM7UUFFQWpLLFFBQVFrSyxXQUFZbEssQ0FBQUEsU0FBU3lKLFlBQVlBLFNBQVMsQ0FBQ3pKLE1BQU0sR0FBR2dLLE9BQU8sQ0FBQ2hLLE1BQU1NLE9BQU8sQ0FBQyxPQUFPOEosV0FBV3BLLFNBQVNnSyxPQUFPLE1BQU1JLFdBQVdwSyxVQUFVO0lBQ2pKO0lBRUEsT0FBT0E7QUFDVCxHQUNJcUssZ0JBQWdCLFNBQVNBLGNBQWNwSyxJQUFJLEVBQUVxSyxJQUFJLEVBQUVDLFNBQVMsRUFBRTVDLFNBQVMsRUFBRTZDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxZQUFZLEVBQUVDLGtCQUFrQjtJQUMxSCxJQUFJMUIsYUFBYXVCLE1BQU12QixVQUFVLEVBQzdCQyxXQUFXc0IsTUFBTXRCLFFBQVEsRUFDekJFLFdBQVdvQixNQUFNcEIsUUFBUSxFQUN6QkQsU0FBU3FCLE1BQU1yQixNQUFNLEVBQ3JCRSxhQUFhbUIsTUFBTW5CLFVBQVU7SUFFakMsSUFBSTlILElBQUk5RCxLQUFLbU4sYUFBYSxDQUFDLFFBQ3ZCQyxtQkFBbUJ2SixZQUFZaUosY0FBY25OLDJEQUFhQSxDQUFDbU4sV0FBVyxlQUFlLFNBQ3JGTyxhQUFhN0ssS0FBS0ssT0FBTyxDQUFDLGdCQUFnQixDQUFDLEdBQzNDeUssU0FBU0YsbUJBQW1CbE4sUUFBUTRNLFdBQ3BDUyxVQUFVL0ssS0FBS0ssT0FBTyxDQUFDLGFBQWEsQ0FBQyxHQUNyQzJLLFFBQVFELFVBQVUvQixhQUFhQyxVQUMvQmdDLE1BQU0sa0JBQWtCRCxRQUFRLGdCQUFnQjdCLFdBQVcsWUFBWTZCLFFBQVEsa0JBQWtCNUIsYUFBYTtJQUVsSDZCLE9BQU8sY0FBZSxFQUFDSixjQUFjSCxrQkFBaUIsS0FBTUUsbUJBQW1CLFdBQVcsV0FBVTtJQUNuR0MsQ0FBQUEsY0FBY0gsc0JBQXNCLENBQUNFLGdCQUFlLEtBQU9LLENBQUFBLE9BQU8sQ0FBQ3ZELGNBQWM1SyxtREFBU0EsR0FBR3FILFNBQVNDLE9BQU0sSUFBSyxNQUFPb0csQ0FBQUEsU0FBU0wsV0FBV2pCLE9BQU0sSUFBSyxLQUFJO0lBQzVKdUIsZ0JBQWlCUSxDQUFBQSxPQUFPLGlEQUFpRFIsYUFBYVMsV0FBVyxHQUFHLEtBQUk7SUFDeEc1SixFQUFFNkosUUFBUSxHQUFHSjtJQUNiekosRUFBRThKLFlBQVksQ0FBQyxTQUFTLGlCQUFpQnBMLE9BQVFxSyxDQUFBQSxPQUFPLGFBQWFBLE9BQU8sRUFBQztJQUM3RS9JLEVBQUU4RCxLQUFLLENBQUNpRyxPQUFPLEdBQUdKO0lBQ2xCM0osRUFBRWdLLFNBQVMsR0FBR2pCLFFBQVFBLFNBQVMsSUFBSXJLLE9BQU8sTUFBTXFLLE9BQU9ySztJQUN2RDhLLE9BQU9TLFFBQVEsQ0FBQyxFQUFFLEdBQUdULE9BQU9VLFlBQVksQ0FBQ2xLLEdBQUd3SixPQUFPUyxRQUFRLENBQUMsRUFBRSxJQUFJVCxPQUFPVyxXQUFXLENBQUNuSztJQUNyRkEsRUFBRW9LLE9BQU8sR0FBR3BLLENBQUMsQ0FBQyxXQUFXb0csVUFBVWlFLEVBQUUsQ0FBQ3RKLEVBQUUsQ0FBQztJQUV6Q3VKLGdCQUFnQnRLLEdBQUcsR0FBR29HLFdBQVdxRDtJQUVqQyxPQUFPeko7QUFDVCxHQUNJc0ssa0JBQWtCLFNBQVNBLGdCQUFnQkMsTUFBTSxFQUFFQyxLQUFLLEVBQUVwRSxTQUFTLEVBQUVxRSxPQUFPO0lBQzlFLElBQUlDLE9BQU87UUFDVEMsU0FBUztJQUNYLEdBQ0lDLE9BQU94RSxTQUFTLENBQUNxRSxVQUFVLFFBQVEsS0FBSyxFQUN4Q0ksZUFBZXpFLFNBQVMsQ0FBQ3FFLFVBQVUsT0FBTyxNQUFNO0lBQ3BERixPQUFPTyxVQUFVLEdBQUdMO0lBQ3BCQyxJQUFJLENBQUN0RSxVQUFVcEYsQ0FBQyxHQUFHLFVBQVUsR0FBR3lKLFVBQVUsQ0FBQyxNQUFNO0lBQ2pEQyxJQUFJLENBQUN0RSxVQUFVcEYsQ0FBQyxDQUFDLEdBQUd5SixVQUFVLFFBQVE7SUFDdENDLElBQUksQ0FBQyxXQUFXRSxPQUFPckgsT0FBTyxHQUFHO0lBQ2pDbUgsSUFBSSxDQUFDLFdBQVdHLGVBQWV0SCxPQUFPLEdBQUc7SUFDekNtSCxJQUFJLENBQUN0RSxVQUFVbEMsQ0FBQyxDQUFDLEdBQUdzRyxRQUFRO0lBQzVCek8sS0FBS2dQLEdBQUcsQ0FBQ1IsUUFBUUc7QUFDbkIsR0FDSU0sWUFBWSxFQUFFLEVBQ2RDLE9BQU8sQ0FBQyxHQUNSQyxRQUNBQyxRQUFRLFNBQVNBO0lBQ25CLE9BQU9qTixhQUFhSSxrQkFBa0IsTUFBTzRNLENBQUFBLFVBQVdBLENBQUFBLFNBQVMvTCxzQkFBc0JpTSxXQUFVLENBQUM7QUFDcEcsR0FDSUMsWUFBWSxTQUFTQTtJQUN2Qiw0Y0FBNGM7SUFDNWMsSUFBSSxDQUFDaE8sZUFBZSxDQUFDQSxZQUFZaU8sU0FBUyxJQUFJak8sWUFBWWtPLE1BQU0sR0FBR25QLE1BQU1vUCxXQUFXLEVBQUU7UUFDcEYsbURBQW1EO1FBQ25EOVAsb0RBQVVBLENBQUMrUCxLQUFLO1FBRWhCLElBQUlwTyxhQUFhO1lBQ2Y2TixVQUFXQSxDQUFBQSxTQUFTL0wsc0JBQXNCaU0sV0FBVTtRQUN0RCxPQUFPO1lBQ0xBLGNBQWMsc1JBQXNSO1FBRXRTO1FBRUE5TSxtQkFBbUJvTixVQUFVO1FBQzdCcE4sa0JBQWtCSjtJQUNwQjtBQUNGLEdBQ0l5TixxQkFBcUIsU0FBU0E7SUFDaENuTyxtQkFBbUJ2QixLQUFLc0UsVUFBVTtJQUNsQ2hELG9CQUFvQnRCLEtBQUsyUCxXQUFXO0FBQ3RDLEdBQ0lDLFlBQVksU0FBU0E7SUFDdkJuUSxvREFBVUEsQ0FBQytQLEtBQUs7SUFDaEIsQ0FBQzlPLGVBQWUsQ0FBQ1MsaUJBQWlCLENBQUNsQixLQUFLNFAsaUJBQWlCLElBQUksQ0FBQzVQLEtBQUs2UCx1QkFBdUIsSUFBSyxFQUFDek8sdUJBQXVCRSxxQkFBcUJ2QixLQUFLc0UsVUFBVSxJQUFJZCxLQUFLaUQsR0FBRyxDQUFDekcsS0FBSzJQLFdBQVcsR0FBR3JPLHFCQUFxQnRCLEtBQUsyUCxXQUFXLEdBQUcsSUFBRyxLQUFNdFAsYUFBYTBQLE9BQU8sQ0FBQztBQUNuUSxHQUNJLHdDQUF3QztBQUM1Q0MsYUFBYSxDQUFDLEdBQ1ZDLGNBQWMsRUFBRSxFQUNoQkMsZUFBZSxTQUFTQTtJQUMxQixPQUFPaEYsZ0JBQWdCaUYsZUFBZSxhQUFhRCxpQkFBaUJFLFlBQVk7QUFDbEYsR0FDSVgsWUFBWSxTQUFTQSxVQUFVaE4sSUFBSTtJQUNyQyxPQUFPdU4sVUFBVSxDQUFDdk4sS0FBSyxJQUFJdU4sVUFBVSxDQUFDdk4sS0FBSyxDQUFDNE4sR0FBRyxDQUFDLFNBQVVDLENBQUM7UUFDekQsT0FBT0E7SUFDVCxNQUFNTDtBQUNSLEdBQ0lNLGVBQWUsRUFBRSxFQUNqQiwyTkFBMk47QUFDL05DLGtCQUFrQixTQUFTQSxnQkFBZ0JDLEtBQUs7SUFDOUMsSUFBSyxJQUFJakwsSUFBSSxHQUFHQSxJQUFJK0ssYUFBYXhOLE1BQU0sRUFBRXlDLEtBQUssRUFBRztRQUMvQyxJQUFJLENBQUNpTCxTQUFTRixZQUFZLENBQUMvSyxJQUFJLEVBQUUsSUFBSStLLFlBQVksQ0FBQy9LLElBQUksRUFBRSxDQUFDa0wsS0FBSyxLQUFLRCxPQUFPO1lBQ3hFRixZQUFZLENBQUMvSyxFQUFFLENBQUNxQyxLQUFLLENBQUNpRyxPQUFPLEdBQUd5QyxZQUFZLENBQUMvSyxJQUFJLEVBQUU7WUFDbkQrSyxZQUFZLENBQUMvSyxFQUFFLENBQUNtTCxPQUFPLElBQUlKLFlBQVksQ0FBQy9LLEVBQUUsQ0FBQ3FJLFlBQVksQ0FBQyxhQUFhMEMsWUFBWSxDQUFDL0ssSUFBSSxFQUFFLElBQUk7WUFDNUYrSyxZQUFZLENBQUMvSyxJQUFJLEVBQUUsQ0FBQ29MLE9BQU8sR0FBRztRQUNoQztJQUNGO0FBQ0YsR0FDSUMsYUFBYSxTQUFTQSxXQUFXNUgsSUFBSSxFQUFFd0gsS0FBSztJQUM5QyxJQUFJSztJQUVKLElBQUtqUSxLQUFLLEdBQUdBLEtBQUtrTyxVQUFVaE0sTUFBTSxFQUFFbEMsS0FBTTtRQUN4Q2lRLFVBQVUvQixTQUFTLENBQUNsTyxHQUFHO1FBRXZCLElBQUlpUSxXQUFZLEVBQUNMLFNBQVNLLFFBQVExSyxJQUFJLEtBQUtxSyxLQUFJLEdBQUk7WUFDakQsSUFBSXhILE1BQU07Z0JBQ1I2SCxRQUFRN0gsSUFBSSxDQUFDO1lBQ2YsT0FBTztnQkFDTDZILFFBQVFDLE1BQU0sQ0FBQyxNQUFNO1lBQ3ZCO1FBQ0Y7SUFDRjtJQUVBbFAsY0FBYztJQUNkNE8sU0FBU0QsZ0JBQWdCQztJQUN6QkEsU0FBU2hCLFVBQVU7QUFDckIsR0FDSXVCLHFCQUFxQixTQUFTQSxtQkFBbUJDLGlCQUFpQixFQUFFQyxLQUFLO0lBQzNFLHdVQUF3VTtJQUN4VXpSLG9EQUFVQSxDQUFDK1AsS0FBSztJQUNmMEIsQ0FBQUEsU0FBUyxDQUFDQyxjQUFhLEtBQU0xUixvREFBVUEsQ0FBQ21MLE9BQU8sQ0FBQyxTQUFVN0MsR0FBRztRQUM1RCxPQUFPdEMsWUFBWXNDLFFBQVFBLElBQUlxSixPQUFPLE1BQU9ySixDQUFBQSxJQUFJc0osR0FBRyxHQUFHO0lBQ3pEO0lBQ0F6TyxVQUFVcU8sc0JBQXVCalIsQ0FBQUEsS0FBS3NSLE9BQU8sQ0FBQ0wsaUJBQWlCLEdBQUd2UCxxQkFBcUJ1UCxpQkFBZ0I7QUFDekcsR0FDSUUsZ0JBQ0FJLGFBQWEsR0FDYkMsaUJBQ0FDLG1CQUFtQixTQUFTQTtJQUM5QixvUUFBb1E7SUFDcFEsSUFBSUQsb0JBQW9CRCxZQUFZO1FBQ2xDLElBQUlHLEtBQUtGLGtCQUFrQkQ7UUFDM0JyTyxzQkFBc0I7WUFDcEIsT0FBT3dPLE9BQU9ILGNBQWNuQixZQUFZO1FBQzFDO0lBQ0Y7QUFDRixHQUNJdUIsZ0JBQWdCLFNBQVNBO0lBQzNCeFIsTUFBTStOLFdBQVcsQ0FBQ3ZNO0lBRWxCQyxTQUFTLENBQUNSLGVBQWVPLFVBQVVpUSxZQUFZLElBQUk1UixLQUFLMlAsV0FBVztJQUVuRXhQLE1BQU0wUixXQUFXLENBQUNsUTtBQUNwQixHQUNJbVEsa0JBQWtCLFNBQVNBLGdCQUFnQkMsSUFBSTtJQUNqRCxPQUFPelIsU0FBUyxnR0FBZ0dzSyxPQUFPLENBQUMsU0FBVVMsRUFBRTtRQUNsSSxPQUFPQSxHQUFHeEQsS0FBSyxDQUFDNkcsT0FBTyxHQUFHcUQsT0FBTyxTQUFTO0lBQzVDO0FBQ0YsR0FDSTNCLGNBQWMsU0FBU0EsWUFBWWMsS0FBSyxFQUFFYyxVQUFVO0lBQ3RELElBQUkzUCxtQkFBbUIsQ0FBQzZPLFNBQVMsQ0FBQ3JQLGFBQWE7UUFDN0NnSixhQUFhc0YsZUFBZSxhQUFhRDtRQUV6QztJQUNGO0lBRUF5QjtJQUVBUixpQkFBaUJoQixjQUFjOEIsWUFBWSxHQUFHO0lBRTlDeFMsb0RBQVVBLENBQUNtTCxPQUFPLENBQUMsU0FBVTdDLEdBQUc7UUFDOUIsT0FBT3RDLFlBQVlzQyxRQUFRLEVBQUVBLElBQUlxSixPQUFPLElBQUtySixDQUFBQSxJQUFJc0osR0FBRyxHQUFHdEosS0FBSTtJQUM3RCxJQUFJLGdOQUFnTjtJQUdwTixJQUFJbUssZUFBZXpDLFVBQVU7SUFFN0J4TyxTQUFTa1AsY0FBY2xHLElBQUk7SUFDM0IrSCxjQUFjbkI7SUFFZHBSLG9EQUFVQSxDQUFDbUwsT0FBTyxDQUFDLFNBQVU3QyxHQUFHO1FBQzlCLElBQUl0QyxZQUFZc0MsTUFBTTtZQUNwQkEsSUFBSW9LLE1BQU0sSUFBS3BLLENBQUFBLElBQUlxSyxNQUFNLENBQUN2SyxLQUFLLENBQUN3SyxjQUFjLEdBQUcsTUFBSyxHQUFJLDhCQUE4QjtZQUV4RnRLLElBQUk7UUFDTjtJQUNGO0lBRUFnSCxVQUFVL0UsS0FBSyxDQUFDLEdBQUdZLE9BQU8sQ0FBQyxTQUFVMEgsQ0FBQztRQUNwQyxPQUFPQSxFQUFFQyxPQUFPO0lBQ2xCLElBQUksOElBQThJO0lBR2xKMVEsY0FBYztJQUVka04sVUFBVW5FLE9BQU8sQ0FBQyxTQUFVMEgsQ0FBQztRQUMzQiw0R0FBNEc7UUFDNUcsSUFBSUEsRUFBRUUsYUFBYSxJQUFJRixFQUFFRyxHQUFHLEVBQUU7WUFDNUIsSUFBSUMsT0FBT0osRUFBRTdELElBQUksQ0FBQ2tFLFVBQVUsR0FBRyxnQkFBZ0IsZ0JBQzNDQyxXQUFXTixFQUFFRyxHQUFHLENBQUNDLEtBQUs7WUFDMUJKLEVBQUV2QixNQUFNLENBQUMsTUFBTTtZQUNmdUIsRUFBRU8sZ0JBQWdCLENBQUNQLEVBQUVHLEdBQUcsQ0FBQ0MsS0FBSyxHQUFHRTtZQUNqQ04sRUFBRUMsT0FBTztRQUNYO0lBQ0Y7SUFFQXpRLGVBQWUsR0FBRyw0S0FBNEs7SUFFOUxnUSxnQkFBZ0I7SUFFaEIvQyxVQUFVbkUsT0FBTyxDQUFDLFNBQVUwSCxDQUFDO1FBQzNCLHdOQUF3TjtRQUN4TixJQUFJbE4sTUFBTUgsV0FBV3FOLEVBQUU1TixRQUFRLEVBQUU0TixFQUFFUSxJQUFJLEdBQ25DQyxXQUFXVCxFQUFFN0QsSUFBSSxDQUFDdUUsR0FBRyxLQUFLLFNBQVNWLEVBQUVXLFNBQVMsSUFBSVgsRUFBRVUsR0FBRyxHQUFHNU4sS0FDMUQ4TixhQUFhWixFQUFFYSxXQUFXLElBQUliLEVBQUUvRCxLQUFLLElBQUluSjtRQUU1QzJOLENBQUFBLFlBQVlHLFVBQVMsS0FBTVosRUFBRWMsWUFBWSxDQUFDRixhQUFhOU4sTUFBTSxJQUFJa04sRUFBRS9ELEtBQUssRUFBRXdFLFdBQVd2UCxLQUFLNEIsR0FBRyxDQUFDOE4sYUFBYTlOLE1BQU1rTixFQUFFL0QsS0FBSyxHQUFHLEdBQUduSixPQUFPa04sRUFBRVUsR0FBRyxFQUFFO0lBQy9JO0lBRUFsQixnQkFBZ0I7SUFFaEJoUSxlQUFlO0lBQ2ZvUSxhQUFhdEgsT0FBTyxDQUFDLFNBQVV6RSxNQUFNO1FBQ25DLE9BQU9BLFVBQVVBLE9BQU9rTixNQUFNLElBQUlsTixPQUFPa04sTUFBTSxDQUFDLENBQUM7SUFDbkQsSUFBSSw0TUFBNE07SUFFaE41VCxvREFBVUEsQ0FBQ21MLE9BQU8sQ0FBQyxTQUFVN0MsR0FBRztRQUM5QixJQUFJdEMsWUFBWXNDLE1BQU07WUFDcEJBLElBQUlvSyxNQUFNLElBQUlqUCxzQkFBc0I7Z0JBQ2xDLE9BQU82RSxJQUFJcUssTUFBTSxDQUFDdkssS0FBSyxDQUFDd0ssY0FBYyxHQUFHO1lBQzNDO1lBQ0F0SyxJQUFJc0osR0FBRyxJQUFJdEosSUFBSUEsSUFBSXNKLEdBQUc7UUFDeEI7SUFDRjtJQUVBTCxtQkFBbUJ0UCxvQkFBb0I7SUFFdkNyQixhQUFhMEYsS0FBSztJQUVsQndMO0lBQ0FKLGlCQUFpQjtJQUVqQmhDLFdBQVc7SUFFWEosVUFBVW5FLE9BQU8sQ0FBQyxTQUFVMEgsQ0FBQztRQUMzQixPQUFPN00sWUFBWTZNLEVBQUU3RCxJQUFJLENBQUM2RSxTQUFTLEtBQUtoQixFQUFFN0QsSUFBSSxDQUFDNkUsU0FBUyxDQUFDaEI7SUFDM0Q7SUFFQW5CLGlCQUFpQmhCLGNBQWM4QixZQUFZLEdBQUc7SUFFOUN4QyxVQUFVO0FBQ1osR0FDSThELGNBQWMsR0FDZEMsYUFBYSxHQUNiQyxVQUNBdEUsYUFBYSxTQUFTQSxXQUFXK0IsS0FBSztJQUN4QyxJQUFJQSxVQUFVLEtBQUssQ0FBQ0Msa0JBQWtCLENBQUN0UCxhQUFhO1FBQ2xELDRKQUE0SjtRQUM1SnNPLGNBQWN1RCxVQUFVLEdBQUc7UUFDM0JELFlBQVlBLFNBQVNFLE1BQU0sQ0FBQyxJQUFJLDhJQUE4STtRQUU5SyxJQUFJQyxJQUFJN0UsVUFBVWhNLE1BQU0sRUFDcEI4USxPQUFPNVIsWUFDUDZSLGlCQUFpQkQsT0FBT3pSLFVBQVUsSUFDbEMyUixTQUFTSCxLQUFLN0UsU0FBUyxDQUFDLEVBQUUsQ0FBQ2dGLE1BQU07UUFFckNQLGFBQWFELGNBQWNRLFNBQVMsQ0FBQyxJQUFJO1FBQ3pDNUMsa0JBQW1Cb0MsQ0FBQUEsY0FBY1EsTUFBSztRQUV0QyxJQUFJRCxnQkFBZ0I7WUFDbEIsSUFBSXpSLG1CQUFtQixDQUFDMUIsa0JBQWtCa1QsT0FBT3hSLGtCQUFrQixLQUFLO2dCQUN0RUEsa0JBQWtCO2dCQUVsQm9OLFVBQVU7WUFDWjtZQUVBalAsU0FBUzRCO1lBQ1RBLFNBQVN5UjtRQUNYO1FBRUEsSUFBSUwsYUFBYSxHQUFHO1lBQ2xCM1MsS0FBSytTO1lBRUwsTUFBTy9TLE9BQU8sRUFBRztnQkFDZmtPLFNBQVMsQ0FBQ2xPLEdBQUcsSUFBSWtPLFNBQVMsQ0FBQ2xPLEdBQUcsQ0FBQzhTLE1BQU0sQ0FBQyxHQUFHRztZQUMzQztZQUVBTixhQUFhO1FBQ2YsT0FBTztZQUNMLElBQUszUyxLQUFLLEdBQUdBLEtBQUsrUyxHQUFHL1MsS0FBTTtnQkFDekJrTyxTQUFTLENBQUNsTyxHQUFHLElBQUlrTyxTQUFTLENBQUNsTyxHQUFHLENBQUM4UyxNQUFNLENBQUMsR0FBR0c7WUFDM0M7UUFDRjtRQUVBM0QsY0FBY3VELFVBQVUsR0FBRztJQUM3QjtJQUVBekUsU0FBUztBQUNYLEdBQ0krRSxtQkFBbUI7SUFBQ3ROO0lBQU9DO0lBQU1FO0lBQVNEO0lBQVFTLFVBQVVGO0lBQVNFLFVBQVVMO0lBQVFLLFVBQVVIO0lBQU1HLFVBQVVKO0lBQU87SUFBVztJQUFjO0lBQVM7SUFBVTtJQUFtQjtJQUFpQjtJQUFnQjtJQUFjO0lBQVk7SUFBZTtJQUFhO0lBQWE7Q0FBUSxFQUNuU2dOLGNBQWNELGlCQUFpQkUsTUFBTSxDQUFDO0lBQUNwTjtJQUFRQztJQUFTO0lBQWEsUUFBUU87SUFBUSxRQUFRQztJQUFTO0lBQVlGO0lBQVNEO0lBQVVBLFdBQVdGO0lBQU1FLFdBQVdKO0lBQVFJLFdBQVdEO0lBQVNDLFdBQVdIO0NBQU0sR0FDOU1rTixjQUFjLFNBQVNBLFlBQVkxQixHQUFHLEVBQUUyQixNQUFNLEVBQUVDLEtBQUs7SUFDdkRDLFVBQVVEO0lBRVYsSUFBSTdFLFFBQVFpRCxJQUFJOEIsS0FBSztJQUVyQixJQUFJL0UsTUFBTWdGLGNBQWMsRUFBRTtRQUN4QkYsVUFBVTlFLE1BQU1pRixXQUFXO0lBQzdCLE9BQU8sSUFBSWhDLElBQUk4QixLQUFLLENBQUNHLFNBQVMsRUFBRTtRQUM5QixJQUFJbkgsU0FBUzZHLE9BQU9PLFVBQVU7UUFFOUIsSUFBSXBILFFBQVE7WUFDVkEsT0FBT1UsWUFBWSxDQUFDd0UsS0FBSzJCO1lBQ3pCN0csT0FBT3NFLFdBQVcsQ0FBQ3VDO1FBQ3JCO0lBQ0Y7SUFFQTNCLElBQUk4QixLQUFLLENBQUNHLFNBQVMsR0FBRztBQUN4QixHQUNJRSxhQUFhLFNBQVNBLFdBQVduQyxHQUFHLEVBQUUyQixNQUFNLEVBQUVTLEVBQUUsRUFBRUosV0FBVztJQUMvRCxJQUFJLENBQUNoQyxJQUFJOEIsS0FBSyxDQUFDRyxTQUFTLEVBQUU7UUFDeEIsSUFBSWxQLElBQUl3TyxpQkFBaUJqUixNQUFNLEVBQzNCK1IsY0FBY1YsT0FBT3ZNLEtBQUssRUFDMUJrTixXQUFXdEMsSUFBSTVLLEtBQUssRUFDcEJJO1FBRUosTUFBT3pDLElBQUs7WUFDVnlDLElBQUkrTCxnQkFBZ0IsQ0FBQ3hPLEVBQUU7WUFDdkJzUCxXQUFXLENBQUM3TSxFQUFFLEdBQUc0TSxFQUFFLENBQUM1TSxFQUFFO1FBQ3hCO1FBRUE2TSxZQUFZbE4sUUFBUSxHQUFHaU4sR0FBR2pOLFFBQVEsS0FBSyxhQUFhLGFBQWE7UUFDakVpTixHQUFHbkcsT0FBTyxLQUFLLFlBQWFvRyxDQUFBQSxZQUFZcEcsT0FBTyxHQUFHLGNBQWE7UUFDL0RxRyxRQUFRLENBQUNsTyxRQUFRLEdBQUdrTyxRQUFRLENBQUNuTyxPQUFPLEdBQUc7UUFDdkNrTyxZQUFZRSxTQUFTLEdBQUdILEdBQUdHLFNBQVMsSUFBSTtRQUN4Q0YsWUFBWUcsUUFBUSxHQUFHO1FBQ3ZCSCxZQUFZSSxTQUFTLEdBQUc7UUFDeEJKLFdBQVcsQ0FBQ2hPLE9BQU8sR0FBR29DLFNBQVN1SixLQUFLalQscURBQVdBLElBQUlnSTtRQUNuRHNOLFdBQVcsQ0FBQy9OLFFBQVEsR0FBR21DLFNBQVN1SixLQUFLbFQsbURBQVNBLElBQUlpSTtRQUNsRHNOLFdBQVcsQ0FBQzFOLFNBQVMsR0FBRzJOLFFBQVEsQ0FBQzFOLFFBQVEsR0FBRzBOLFFBQVEsQ0FBQ3BPLEtBQUssR0FBR29PLFFBQVEsQ0FBQ3JPLE1BQU0sR0FBRztRQUUvRTROLFVBQVVHO1FBRVZNLFFBQVEsQ0FBQ2pPLE9BQU8sR0FBR2lPLFFBQVEsQ0FBQyxRQUFRek4sT0FBTyxHQUFHdU4sRUFBRSxDQUFDL04sT0FBTztRQUN4RGlPLFFBQVEsQ0FBQ2hPLFFBQVEsR0FBR2dPLFFBQVEsQ0FBQyxRQUFReE4sUUFBUSxHQUFHc04sRUFBRSxDQUFDOU4sUUFBUTtRQUMzRGdPLFFBQVEsQ0FBQzNOLFNBQVMsR0FBR3lOLEVBQUUsQ0FBQ3pOLFNBQVM7UUFFakMsSUFBSXFMLElBQUlrQyxVQUFVLEtBQUtQLFFBQVE7WUFDN0IzQixJQUFJa0MsVUFBVSxDQUFDMUcsWUFBWSxDQUFDbUcsUUFBUTNCO1lBQ3BDMkIsT0FBT2xHLFdBQVcsQ0FBQ3VFO1FBQ3JCO1FBRUFBLElBQUk4QixLQUFLLENBQUNHLFNBQVMsR0FBRztJQUN4QjtBQUNGLEdBQ0lTLFdBQVcsWUFDWGIsWUFBWSxTQUFTQSxVQUFVRCxLQUFLO0lBQ3RDLElBQUlBLE9BQU87UUFDVCxJQUFJeE0sUUFBUXdNLE1BQU0vQixDQUFDLENBQUN6SyxLQUFLLEVBQ3JCK0wsSUFBSVMsTUFBTXRSLE1BQU0sRUFDaEJ5QyxJQUFJLEdBQ0p5QyxHQUNBekY7UUFDSDZSLENBQUFBLE1BQU0vQixDQUFDLENBQUNpQyxLQUFLLElBQUl6VSxLQUFLc1YsSUFBSSxDQUFDQyxRQUFRLENBQUNoQixNQUFNL0IsQ0FBQyxHQUFHMUIsT0FBTyxHQUFHLEdBQUcsa0NBQWtDO1FBRTlGLE1BQU9wTCxJQUFJb08sR0FBR3BPLEtBQUssRUFBRztZQUNwQmhELFFBQVE2UixLQUFLLENBQUM3TyxJQUFJLEVBQUU7WUFDcEJ5QyxJQUFJb00sS0FBSyxDQUFDN08sRUFBRTtZQUVaLElBQUloRCxPQUFPO2dCQUNUcUYsS0FBSyxDQUFDSSxFQUFFLEdBQUd6RjtZQUNiLE9BQU8sSUFBSXFGLEtBQUssQ0FBQ0ksRUFBRSxFQUFFO2dCQUNuQkosTUFBTXlOLGNBQWMsQ0FBQ3JOLEVBQUVzTixPQUFPLENBQUNKLFVBQVUsT0FBT0ssV0FBVztZQUM3RDtRQUNGO0lBQ0Y7QUFDRixHQUNJQyxZQUFZLFNBQVNBLFVBQVV0UixPQUFPO0lBQ3hDLGlLQUFpSztJQUNqSyxJQUFJeVAsSUFBSUssWUFBWWxSLE1BQU0sRUFDdEI4RSxRQUFRMUQsUUFBUTBELEtBQUssRUFDckJ3TSxRQUFRLEVBQUUsRUFDVjdPLElBQUk7SUFFUixNQUFPQSxJQUFJb08sR0FBR3BPLElBQUs7UUFDakI2TyxNQUFNN0ssSUFBSSxDQUFDeUssV0FBVyxDQUFDek8sRUFBRSxFQUFFcUMsS0FBSyxDQUFDb00sV0FBVyxDQUFDek8sRUFBRSxDQUFDO0lBQ2xEO0lBRUE2TyxNQUFNL0IsQ0FBQyxHQUFHbk87SUFDVixPQUFPa1E7QUFDVCxHQUNJcUIsYUFBYSxTQUFTQSxXQUFXckIsS0FBSyxFQUFFc0IsUUFBUSxFQUFFQyxXQUFXO0lBQy9ELElBQUl6UCxTQUFTLEVBQUUsRUFDWHlOLElBQUlTLE1BQU10UixNQUFNLEVBQ2hCeUMsSUFBSW9RLGNBQWMsSUFBSSxHQUN0Qix1REFBdUQ7SUFDM0QzTjtJQUVBLE1BQU96QyxJQUFJb08sR0FBR3BPLEtBQUssRUFBRztRQUNwQnlDLElBQUlvTSxLQUFLLENBQUM3TyxFQUFFO1FBQ1pXLE9BQU9xRCxJQUFJLENBQUN2QixHQUFHQSxLQUFLME4sV0FBV0EsUUFBUSxDQUFDMU4sRUFBRSxHQUFHb00sS0FBSyxDQUFDN08sSUFBSSxFQUFFO0lBQzNEO0lBRUFXLE9BQU9tTSxDQUFDLEdBQUcrQixNQUFNL0IsQ0FBQztJQUNsQixPQUFPbk07QUFDVCxHQUNJL0IsY0FBYztJQUNoQitILE1BQU07SUFDTkQsS0FBSztBQUNQLEdBQ0ksOElBQThJO0FBQ2xKLDRGQUE0RjtBQUM1Riw0Q0FBNEM7QUFDNUMseURBQXlEO0FBQ3pELHdDQUF3QztBQUN4QyxrREFBa0Q7QUFDbEQsaVpBQWlaO0FBQ2paLEtBQUs7QUFDTDJKLGlCQUFpQixTQUFTQSxlQUFlclQsS0FBSyxFQUFFc08sT0FBTyxFQUFFZ0YsWUFBWSxFQUFFM0wsU0FBUyxFQUFFNEosTUFBTSxFQUFFekYsTUFBTSxFQUFFeUgsY0FBYyxFQUFFclQsSUFBSSxFQUFFc1QsY0FBYyxFQUFFQyxXQUFXLEVBQUU1SSxnQkFBZ0IsRUFBRTZJLFdBQVcsRUFBRS9JLGtCQUFrQixFQUFFZ0osYUFBYTtJQUNuTjFRLFlBQVlqRCxVQUFXQSxDQUFBQSxRQUFRQSxNQUFNRSxLQUFJO0lBRXpDLElBQUlFLFVBQVVKLFVBQVVBLE1BQU1LLE1BQU0sQ0FBQyxHQUFHLE9BQU8sT0FBTztRQUNwREwsUUFBUTBULGNBQWUxVCxDQUFBQSxNQUFNbUssTUFBTSxDQUFDLE9BQU8sTUFBTUosWUFBWSxNQUFNL0osTUFBTUssTUFBTSxDQUFDLElBQUlpVCxnQkFBZ0I7SUFDdEc7SUFFQSxJQUFJakMsT0FBTzFHLHFCQUFxQkEsbUJBQW1CMEcsSUFBSSxLQUFLLEdBQ3hEdUMsSUFDQUMsSUFDQWxTO0lBQ0pnSixzQkFBc0JBLG1CQUFtQm1KLElBQUksQ0FBQztJQUM5Q0MsTUFBTS9ULFVBQVdBLENBQUFBLFFBQVEsQ0FBQ0EsS0FBSSxHQUFJLHdEQUF3RDtJQUUxRixJQUFJLENBQUNrRCxVQUFVbEQsUUFBUTtRQUNyQmlELFlBQVlxTCxZQUFhQSxDQUFBQSxVQUFVQSxRQUFRcE8sS0FBSTtRQUMvQyxJQUFJOFQsVUFBVSxDQUFDaFUsU0FBUyxHQUFFLEVBQUdtSSxLQUFLLENBQUMsTUFDL0I1QixRQUNBME4sYUFDQUMsY0FDQWhJO1FBQ0p2SyxVQUFVN0Usd0RBQVVBLENBQUN3UixTQUFTcE8sU0FBU3ZDO1FBQ3ZDNEksU0FBU3ZFLFdBQVdMLFlBQVksQ0FBQztRQUVqQyxJQUFJLENBQUMsQ0FBQzRFLFVBQVUsQ0FBQ0EsT0FBT29ELElBQUksSUFBSSxDQUFDcEQsT0FBT21ELEdBQUcsS0FBS3pFLGtCQUFrQnRELFNBQVN1SyxPQUFPLEtBQUssUUFBUTtZQUM3Rix5RUFBeUU7WUFDekVBLFVBQVV2SyxRQUFRMEQsS0FBSyxDQUFDNkcsT0FBTztZQUMvQnZLLFFBQVEwRCxLQUFLLENBQUM2RyxPQUFPLEdBQUc7WUFDeEIzRixTQUFTdkUsV0FBV0w7WUFDcEJ1SyxVQUFVdkssUUFBUTBELEtBQUssQ0FBQzZHLE9BQU8sR0FBR0EsVUFBVXZLLFFBQVEwRCxLQUFLLENBQUN5TixjQUFjLENBQUM7UUFDM0U7UUFFQW1CLGNBQWNsSyxZQUFZaUssT0FBTyxDQUFDLEVBQUUsRUFBRXpOLE1BQU0sQ0FBQ29CLFVBQVV0RixDQUFDLENBQUM7UUFDekQ2UixlQUFlbkssWUFBWWlLLE9BQU8sQ0FBQyxFQUFFLElBQUksS0FBS1Y7UUFDOUN0VCxRQUFRdUcsTUFBTSxDQUFDb0IsVUFBVWxDLENBQUMsQ0FBQyxHQUFHK04sY0FBYyxDQUFDN0wsVUFBVWxDLENBQUMsQ0FBQyxHQUFHZ08sY0FBY1EsY0FBYzFDLFNBQVMyQztRQUNqR1gsa0JBQWtCMUgsZ0JBQWdCMEgsZ0JBQWdCVyxjQUFjdk0sV0FBVzJMLGVBQWVZLGVBQWUsTUFBTVgsZUFBZW5JLFFBQVEsSUFBSThJLGVBQWU7UUFDekpaLGdCQUFnQkEsZUFBZVksY0FBYyx3QkFBd0I7SUFDdkUsT0FBTztRQUNMdkosc0JBQXVCM0ssQ0FBQUEsUUFBUTFDLEtBQUs0SixLQUFLLENBQUNpTixRQUFRLENBQUN4SixtQkFBbUJ5SixhQUFhLENBQUNySSxLQUFLLEVBQUVwQixtQkFBbUJ5SixhQUFhLENBQUM1RCxHQUFHLEVBQUUsR0FBR2tELGFBQWExVCxNQUFLO1FBQ3RKdVQsa0JBQWtCMUgsZ0JBQWdCMEgsZ0JBQWdCRCxjQUFjM0wsV0FBVztJQUM3RTtJQUVBLElBQUlnTSxlQUFlO1FBQ2pCelQsSUFBSSxDQUFDeVQsY0FBYyxHQUFHM1QsU0FBUyxDQUFDO1FBQ2hDQSxRQUFRLEtBQU1BLENBQUFBLFFBQVE7SUFDeEI7SUFFQSxJQUFJOEwsUUFBUTtRQUNWLElBQUkxRyxXQUFXcEYsUUFBUXNULGNBQ25CdEksVUFBVWMsT0FBT1YsUUFBUTtRQUM3QndJLEtBQUssV0FBV2pNLFVBQVVyRixFQUFFO1FBRTVCdUosZ0JBQWdCQyxRQUFRMUcsVUFBVXVDLFdBQVdxRCxXQUFXNUYsV0FBVyxNQUFNLENBQUM0RixXQUFXLENBQUNILG1CQUFtQjdKLEtBQUs0QixHQUFHLENBQUNqRixLQUFLLENBQUNpVyxHQUFHLEVBQUVsVyxNQUFNLENBQUNrVyxHQUFHLElBQUk5SCxPQUFPcUcsVUFBVSxDQUFDeUIsR0FBRyxLQUFLeE8sV0FBVztRQUVoTCxJQUFJeUYsa0JBQWtCO1lBQ3BCMkksaUJBQWlCeFIsV0FBV3VSO1lBQzVCMUksb0JBQXFCaUIsQ0FBQUEsT0FBT3pHLEtBQUssQ0FBQ3NDLFVBQVVpRSxFQUFFLENBQUNuRyxDQUFDLENBQUMsR0FBRytOLGNBQWMsQ0FBQzdMLFVBQVVpRSxFQUFFLENBQUNuRyxDQUFDLENBQUMsR0FBR2tDLFVBQVVpRSxFQUFFLENBQUN5SSxDQUFDLEdBQUd2SSxPQUFPSCxPQUFPLEdBQUczRyxHQUFFO1FBQzNIO0lBQ0Y7SUFFQSxJQUFJMkYsc0JBQXNCaEosU0FBUztRQUNqQ2lTLEtBQUs1UixXQUFXTDtRQUNoQmdKLG1CQUFtQm1KLElBQUksQ0FBQ0o7UUFDeEJHLEtBQUs3UixXQUFXTDtRQUNoQmdKLG1CQUFtQjJKLGFBQWEsR0FBR1YsRUFBRSxDQUFDak0sVUFBVWxDLENBQUMsQ0FBQyxHQUFHb08sRUFBRSxDQUFDbE0sVUFBVWxDLENBQUMsQ0FBQztRQUNwRXpGLFFBQVFBLFFBQVEySyxtQkFBbUIySixhQUFhLEdBQUdaO0lBQ3JEO0lBRUEvSSxzQkFBc0JBLG1CQUFtQm1KLElBQUksQ0FBQ3pDO0lBQzlDLE9BQU8xRyxxQkFBcUIzSyxRQUFRZ0IsS0FBS0MsS0FBSyxDQUFDakI7QUFDakQsR0FDSXVVLGFBQWEsc0NBQ2JDLFlBQVksU0FBU0EsVUFBVTdTLE9BQU8sRUFBRW9KLE1BQU0sRUFBRXJCLEdBQUcsRUFBRUMsSUFBSTtJQUMzRCxJQUFJaEksUUFBUXdRLFVBQVUsS0FBS3BILFFBQVE7UUFDakMsSUFBSTFGLFFBQVExRCxRQUFRMEQsS0FBSyxFQUNyQkksR0FDQTRNO1FBRUosSUFBSXRILFdBQVdwTixPQUFPO1lBQ3BCZ0UsUUFBUThTLE9BQU8sR0FBR3BQLE1BQU1pRyxPQUFPLEVBQUUsNERBQTREO1lBRTdGK0csS0FBS3BOLGtCQUFrQnREO1lBRXZCLElBQUs4RCxLQUFLNE0sR0FBSTtnQkFDWix1SUFBdUk7Z0JBQ3ZJLElBQUksQ0FBQyxDQUFDNU0sS0FBSyxDQUFDOE8sV0FBV0csSUFBSSxDQUFDalAsTUFBTTRNLEVBQUUsQ0FBQzVNLEVBQUUsSUFBSSxPQUFPSixLQUFLLENBQUNJLEVBQUUsS0FBSyxZQUFZQSxNQUFNLEtBQUs7b0JBQ3BGSixLQUFLLENBQUNJLEVBQUUsR0FBRzRNLEVBQUUsQ0FBQzVNLEVBQUU7Z0JBQ2xCO1lBQ0Y7WUFFQUosTUFBTXFFLEdBQUcsR0FBR0E7WUFDWnJFLE1BQU1zRSxJQUFJLEdBQUdBO1FBQ2YsT0FBTztZQUNMdEUsTUFBTWlHLE9BQU8sR0FBRzNKLFFBQVE4UyxPQUFPO1FBQ2pDO1FBRUFuWCxLQUFLc1YsSUFBSSxDQUFDQyxRQUFRLENBQUNsUixTQUFTeU0sT0FBTyxHQUFHO1FBQ3RDckQsT0FBT1csV0FBVyxDQUFDL0o7SUFDckI7QUFDRixHQUNJZ1QsdUJBQXVCLFNBQVNBLHFCQUFxQkMsWUFBWSxFQUFFQyxZQUFZLEVBQUVDLFdBQVc7SUFDOUYsSUFBSUMsUUFBUUYsY0FDUkcsUUFBUUQ7SUFDWixPQUFPLFNBQVUvVSxLQUFLO1FBQ3BCLElBQUlpVixVQUFValUsS0FBS0MsS0FBSyxDQUFDMlQsaUJBQWlCLG9JQUFvSTtRQUU5SyxJQUFJSyxZQUFZRixTQUFTRSxZQUFZRCxTQUFTaFUsS0FBS2lELEdBQUcsQ0FBQ2dSLFVBQVVGLFNBQVMsS0FBSy9ULEtBQUtpRCxHQUFHLENBQUNnUixVQUFVRCxTQUFTLEdBQUc7WUFDNUcsMlRBQTJUO1lBQzNUaFYsUUFBUWlWO1lBQ1JILGVBQWVBO1FBQ2pCO1FBRUFFLFFBQVFEO1FBQ1JBLFFBQVEvVTtRQUNSLE9BQU9BO0lBQ1Q7QUFDRixHQUNJa1YsZUFBZSxTQUFTQSxhQUFhcEosTUFBTSxFQUFFbkUsU0FBUyxFQUFFM0gsS0FBSztJQUMvRCxJQUFJaU0sT0FBTyxDQUFDO0lBQ1pBLElBQUksQ0FBQ3RFLFVBQVVsQyxDQUFDLENBQUMsR0FBRyxPQUFPekY7SUFDM0IxQyxLQUFLZ1AsR0FBRyxDQUFDUixRQUFRRztBQUNuQixHQUNJLHFDQUFxQztBQUN6QyxtSEFBbUg7QUFDbkgsd0ZBQXdGO0FBQ3hGLGlDQUFpQztBQUNqQyxjQUFjO0FBQ2QsS0FBSztBQUNMLHNaQUFzWjtBQUN0WmtKLG1CQUFtQixTQUFTQSxpQkFBaUJqVCxRQUFRLEVBQUV5RixTQUFTO0lBQzlELElBQUl5TixZQUFZalksNERBQWNBLENBQUMrRSxVQUFVeUYsWUFDckN1SSxPQUFPLFlBQVl2SSxVQUFVa00sRUFBRSxFQUMvQiwrTEFBK0w7SUFDbk13QixXQUFXLFNBQVNBLFNBQVNDLFFBQVEsRUFBRXJKLElBQUksRUFBRTRJLFlBQVksRUFBRVUsT0FBTyxFQUFFQyxPQUFPO1FBQ3pFLElBQUk3UCxRQUFRMFAsU0FBUzFQLEtBQUssRUFDdEI4UCxhQUFheEosS0FBS3dKLFVBQVUsRUFDNUJDLFlBQVksQ0FBQztRQUNqQmIsZUFBZUEsZ0JBQWdCTztRQUUvQixJQUFJTyx1QkFBdUJoQixxQkFBcUJTLFdBQVdQLGNBQWM7WUFDdkVsUCxNQUFNYyxJQUFJO1lBQ1Y0TyxTQUFTMVAsS0FBSyxHQUFHO1FBQ25CO1FBRUE2UCxVQUFVRCxXQUFXQyxXQUFXLEdBQUcsa0hBQWtIO1FBRXJKRCxVQUFVQSxXQUFXRCxXQUFXVDtRQUNoQ2xQLFNBQVNBLE1BQU1jLElBQUk7UUFDbkJ3RixJQUFJLENBQUNpRSxLQUFLLEdBQUdvRjtRQUNickosS0FBSzJKLE9BQU8sR0FBRztRQUNmM0osS0FBS3lKLFNBQVMsR0FBR0E7UUFFakJBLFNBQVMsQ0FBQ3hGLEtBQUssR0FBRztZQUNoQixPQUFPeUYscUJBQXFCZCxlQUFlVSxVQUFVNVAsTUFBTWtRLEtBQUssR0FBR0wsVUFBVTdQLE1BQU1rUSxLQUFLLEdBQUdsUSxNQUFNa1EsS0FBSztRQUN4RztRQUVBNUosS0FBSzZKLFFBQVEsR0FBRztZQUNkN1ksb0RBQVVBLENBQUMrUCxLQUFLO1lBQ2hCcUksU0FBUzFQLEtBQUssSUFBSWdILGNBQWMsdUZBQXVGO1FBQ3pIO1FBRUFWLEtBQUt3SixVQUFVLEdBQUc7WUFDaEJKLFNBQVMxUCxLQUFLLEdBQUc7WUFDakI4UCxjQUFjQSxXQUFXTSxJQUFJLENBQUNwUTtRQUNoQztRQUVBQSxRQUFRMFAsU0FBUzFQLEtBQUssR0FBR3JJLEtBQUtzSSxFQUFFLENBQUMxRCxVQUFVK0o7UUFDM0MsT0FBT3RHO0lBQ1Q7SUFFQXpELFFBQVEsQ0FBQ2dPLEtBQUssR0FBR2tGO0lBRWpCQSxVQUFVck0sWUFBWSxHQUFHO1FBQ3ZCLE9BQU9zTSxTQUFTMVAsS0FBSyxJQUFJMFAsU0FBUzFQLEtBQUssQ0FBQ2MsSUFBSSxNQUFPNE8sQ0FBQUEsU0FBUzFQLEtBQUssR0FBRztJQUN0RTtJQUVBMEMsYUFBYW5HLFVBQVUsU0FBU2tULFVBQVVyTSxZQUFZLEdBQUcsdVNBQXVTO0lBR2hXNEUsY0FBY3FJLE9BQU8sSUFBSTNOLGFBQWFuRyxVQUFVLGFBQWFrVCxVQUFVck0sWUFBWTtJQUNuRixPQUFPc007QUFDVDtBQUVPLElBQUkxSCxnQkFBZ0IsV0FBVyxHQUFFO0lBQ3RDLFNBQVNBLGNBQWMxQixJQUFJLEVBQUU1SSxTQUFTO1FBQ3BDOUYsZ0JBQWdCb1EsY0FBY3NJLFFBQVEsQ0FBQzNZLFNBQVM0WSxRQUFRQyxJQUFJLENBQUM7UUFFN0RsWCxTQUFTLElBQUk7UUFFYixJQUFJLENBQUNtWCxJQUFJLENBQUNuSyxNQUFNNUk7SUFDbEI7SUFFQSxJQUFJZ1QsU0FBUzFJLGNBQWMySSxTQUFTO0lBRXBDRCxPQUFPRCxJQUFJLEdBQUcsU0FBU0EsS0FBS25LLElBQUksRUFBRTVJLFNBQVM7UUFDekMsSUFBSSxDQUFDRyxRQUFRLEdBQUcsSUFBSSxDQUFDdUksS0FBSyxHQUFHO1FBQzdCLElBQUksQ0FBQ0UsSUFBSSxJQUFJLElBQUksQ0FBQ3hGLElBQUksQ0FBQyxNQUFNLE9BQU8sbUNBQW1DO1FBRXZFLElBQUksQ0FBQzNHLFVBQVU7WUFDYixJQUFJLENBQUNxUixNQUFNLEdBQUcsSUFBSSxDQUFDcEIsT0FBTyxHQUFHLElBQUksQ0FBQ3RKLElBQUksR0FBRzVGO1lBQ3pDO1FBQ0Y7UUFFQW9MLE9BQU8zRyxhQUFhbEYsVUFBVTZMLFNBQVMvSSxVQUFVK0ksU0FBU0EsS0FBS3NLLFFBQVEsR0FBRztZQUN4RWpJLFNBQVNyQztRQUNYLElBQUlBLE1BQU0zQztRQUVWLElBQUlrTixRQUFRdkssTUFDUjZKLFdBQVdVLE1BQU1WLFFBQVEsRUFDekJXLGNBQWNELE1BQU1DLFdBQVcsRUFDL0J2SCxLQUFLc0gsTUFBTXRILEVBQUUsRUFDYndILFdBQVdGLE1BQU1FLFFBQVEsRUFDekI1RixZQUFZMEYsTUFBTTFGLFNBQVMsRUFDM0I2RixRQUFRSCxNQUFNRyxLQUFLLEVBQ25CckksVUFBVWtJLE1BQU1sSSxPQUFPLEVBQ3ZCMkIsTUFBTXVHLE1BQU12RyxHQUFHLEVBQ2YyRyxhQUFhSixNQUFNSSxVQUFVLEVBQzdCQyxzQkFBc0JMLE1BQU1LLG1CQUFtQixFQUMvQ3JOLGdCQUFnQmdOLE1BQU1oTixhQUFhLEVBQ25Dc04sa0JBQWtCTixNQUFNTSxlQUFlLEVBQ3ZDQyxpQkFBaUJQLE1BQU1PLGNBQWMsRUFDckNDLE9BQU9SLE1BQU1RLElBQUksRUFDakI3UCxPQUFPcVAsTUFBTXJQLElBQUksRUFDakI4UCxjQUFjVCxNQUFNUyxXQUFXLEVBQy9CQyxZQUFZVixNQUFNVSxTQUFTLEVBQzNCdk0scUJBQXFCNkwsTUFBTTdMLGtCQUFrQixFQUM3Q3dNLGdCQUFnQlgsTUFBTVcsYUFBYSxFQUNuQ0Msa0JBQWtCWixNQUFNWSxlQUFlLEVBQ3ZDelAsWUFBWXNFLEtBQUtrRSxVQUFVLElBQUlsRSxLQUFLdEIsa0JBQWtCLElBQUlzQixLQUFLa0UsVUFBVSxLQUFLLFFBQVFuVCxxREFBV0EsR0FBR0QsbURBQVNBLEVBQzdHc2EsV0FBVyxDQUFDVixTQUFTQSxVQUFVLEdBQy9CelUsV0FBV3BGLHdEQUFVQSxDQUFDbVAsS0FBSy9KLFFBQVEsSUFBSTFFLE9BQ3ZDOFosZ0JBQWdCaGEsS0FBS3NWLElBQUksQ0FBQ0MsUUFBUSxDQUFDM1EsV0FDbkNDLGFBQWFiLFlBQVlZLFdBQ3pCMkksbUJBQW1CLENBQUMsYUFBYW9CLE9BQU9BLEtBQUtzTCxPQUFPLEdBQUduYSwyREFBYUEsQ0FBQzhFLFVBQVUsY0FBY0MsY0FBYyxPQUFNLE1BQU8sU0FDeEhxVixZQUFZO1lBQUN2TCxLQUFLd0wsT0FBTztZQUFFeEwsS0FBS3lMLE9BQU87WUFBRXpMLEtBQUswTCxXQUFXO1lBQUUxTCxLQUFLMkwsV0FBVztTQUFDLEVBQzVFck8sZ0JBQWdCOE4sWUFBWXBMLEtBQUsxQyxhQUFhLENBQUNwQixLQUFLLENBQUMsTUFDckQwUCxVQUFVLGFBQWE1TCxPQUFPQSxLQUFLNEwsT0FBTyxHQUFHdk8sVUFBVXVPLE9BQU8sRUFDOURwRSxjQUFjdFIsYUFBYSxJQUFJaUksV0FBV25GLGtCQUFrQi9DLFNBQVMsQ0FBQyxXQUFXeUYsVUFBVWtNLEVBQUUsR0FBRy9PLE9BQU8sS0FBSyxHQUM1RzVFLE9BQU8sSUFBSSxFQUNYNFgsZ0JBQWdCN0wsS0FBSzZMLGFBQWEsSUFBSTtZQUN4QyxPQUFPN0wsS0FBSzZMLGFBQWEsQ0FBQzVYO1FBQzVCLEdBQ0k2WCxrQkFBa0I5VixhQUFhQyxVQUFVQyxZQUFZd0YsWUFDckRxUSxxQkFBcUJ4VixnQkFBZ0JOLFVBQVVDLGFBQy9DOFYsV0FBVyxHQUNYQyxjQUFjLEdBQ2RDLGVBQWUsR0FDZnJQLGFBQWEzTCw0REFBY0EsQ0FBQytFLFVBQVV5RixZQUN0Q3lRLFNBQ0FDLFVBQ0FDLFVBQ0FDLFNBQ0FDLFNBQ0F6TSxPQUNBeUUsS0FDQWlJLGFBQ0FDLFdBQ0FDLG9CQUNBQyxrQkFDQUMsWUFDQUMsb0JBQ0FDLFFBQ0FDLGtCQUNBQyxnQkFDQUMsVUFDQXRILFFBQ0FuSCxRQUNBME8sV0FDQUMsV0FDQUMsVUFDQUMsV0FDQUMsY0FDQXRILGFBQ0F1SCxtQkFDQUMsVUFDQUMsaUJBQ0FySCxJQUNBc0gsT0FDQUMsT0FDQUMsWUFDQUMsYUFDQUMsY0FDQUMsaUJBQ0FDLFlBQ0FDLGtCQUNBQyxnQkFDQUMsb0JBQW9CLHNZQUFzWTtRQUc5WmxhLEtBQUt5USxXQUFXLEdBQUd6USxLQUFLdVEsU0FBUyxHQUFHO1FBQ3BDdlEsS0FBS29RLElBQUksR0FBRzNJO1FBQ1o2QixpQkFBaUI7UUFDakJ0SixLQUFLZ0MsUUFBUSxHQUFHQTtRQUNoQmhDLEtBQUtxUixNQUFNLEdBQUc1RyxxQkFBcUJBLG1CQUFtQjBHLElBQUksQ0FBQ2dKLElBQUksQ0FBQzFQLHNCQUFzQjdCO1FBQ3RGeVAsVUFBVXpQO1FBQ1Y1SSxLQUFLK0wsSUFBSSxHQUFHQTtRQUNaNUksWUFBWUEsYUFBYTRJLEtBQUs1SSxTQUFTO1FBRXZDLElBQUkscUJBQXFCNEksTUFBTTtZQUM3QnhOLFFBQVE7WUFDUndOLEtBQUtxTyxlQUFlLEtBQUssQ0FBQyxRQUFTckosQ0FBQUEsV0FBVy9RLElBQUcsR0FBSSx5QkFBeUI7UUFDaEY7UUFFQW9YLGNBQWNpRCxXQUFXLEdBQUdqRCxjQUFjaUQsV0FBVyxJQUFJO1lBQ3ZEN1EsS0FBS3lMLGlCQUFpQmpULFVBQVVuRixtREFBU0E7WUFDekM0TSxNQUFNd0wsaUJBQWlCalQsVUFBVWxGLHFEQUFXQTtRQUM5QztRQUNBa0QsS0FBS2tZLE9BQU8sR0FBR0EsVUFBVWQsY0FBY2lELFdBQVcsQ0FBQzVTLFVBQVVsQyxDQUFDLENBQUM7UUFFL0R2RixLQUFLc2EsYUFBYSxHQUFHLFNBQVV4YSxLQUFLO1lBQ2xDOFosY0FBYzVXLFVBQVVsRCxVQUFVQTtZQUVsQyxJQUFJLENBQUM4WixhQUFhO2dCQUNoQkQsY0FBY0EsV0FBV3JXLFFBQVEsQ0FBQyxHQUFHaUQsSUFBSTtnQkFDekNvVCxhQUFhO1lBQ2YsT0FBTztnQkFDTEEsYUFBYUEsV0FBVzlTLFFBQVEsQ0FBQy9HLFNBQVM2WixhQUFhdmMsS0FBS3NJLEVBQUUsQ0FBQ3ZDLFdBQVc7b0JBQ3hFb1gsTUFBTTtvQkFDTkMsZUFBZTtvQkFDZjlFLFNBQVM7b0JBQ1Q3TyxVQUFVK1M7b0JBQ1ZhLFFBQVE7b0JBQ1JsRixZQUFZLFNBQVNBO3dCQUNuQixPQUFPcUIsbUJBQW1CQSxnQkFBZ0I1VztvQkFDNUM7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsSUFBSW1ELFdBQVc7WUFDYkEsVUFBVTRJLElBQUksQ0FBQzJPLElBQUksR0FBRztZQUN0QnZYLFVBQVV3WCxRQUFRLElBQUksQ0FBQzNhLEtBQUs0YSxVQUFVLElBQUl6WCxVQUFVNEksSUFBSSxDQUFDOE8sZUFBZSxLQUFLLFNBQVM5TyxLQUFLOE8sZUFBZSxLQUFLLFNBQVMxWCxVQUFVMEQsUUFBUSxNQUFNMUQsVUFBVXdOLE1BQU0sQ0FBQyxHQUFHLE1BQU0sT0FBTyw4V0FBOFc7WUFFL2hCM1EsS0FBS21ELFNBQVMsR0FBR0EsVUFBVUUsS0FBSztZQUNoQ0YsVUFBVStRLGFBQWEsR0FBR2xVO1lBQzFCQSxLQUFLc2EsYUFBYSxDQUFDN0Q7WUFDbkJnRCxRQUFRO1lBQ1J6SyxNQUFPQSxDQUFBQSxLQUFLN0wsVUFBVTRJLElBQUksQ0FBQ2lELEVBQUU7UUFDL0I7UUFFQSxJQUFJL0gsTUFBTTtZQUNSLHVSQUF1UjtZQUN2UixJQUFJLENBQUNoRSxVQUFVZ0UsU0FBU0EsS0FBS0gsSUFBSSxFQUFFO2dCQUNqQ0csT0FBTztvQkFDTDZULFFBQVE3VDtnQkFDVjtZQUNGO1lBRUEsb0JBQW9CeEosTUFBTTBILEtBQUssSUFBSS9ILEtBQUtnUCxHQUFHLENBQUNuSyxhQUFhO2dCQUFDeEU7Z0JBQU9EO2FBQU8sR0FBR3dFLFVBQVU7Z0JBQ25GMk4sZ0JBQWdCO1lBQ2xCLElBQUksMkNBQTJDO1lBRS9DNVMsb0RBQVVBLENBQUNtTCxPQUFPLENBQUMsU0FBVTZTLENBQUM7Z0JBQzVCLE9BQU9oWSxZQUFZZ1ksTUFBTUEsRUFBRXJMLE1BQU0sS0FBTXpOLENBQUFBLGFBQWExRSxLQUFLeWQsZ0JBQWdCLElBQUl4ZCxTQUFTd0UsUUFBTyxLQUFPK1ksQ0FBQUEsRUFBRXRMLE1BQU0sR0FBRyxLQUFJO1lBQ3JILElBQUksdUZBQXVGO1lBRzNGMkksV0FBV3JWLFlBQVlrRSxLQUFLNlQsTUFBTSxJQUFJN1QsS0FBSzZULE1BQU0sR0FBRzdULEtBQUs2VCxNQUFNLEtBQUssV0FBVy9ULGlCQUFpQjVELGFBQWE4RCxLQUFLNlQsTUFBTSxLQUFLLHNCQUFzQmxULHFCQUFxQnpFLGFBQWE4RCxLQUFLZ1UsV0FBVyxLQUFLLFFBQVEsa0JBQVVuYixLQUFLLEVBQUUrSCxFQUFFO2dCQUNuTyxPQUFPWCxpQkFBaUJELEtBQUs2VCxNQUFNLEVBQUVoYixPQUFPUCxhQUFheVksY0FBYyxNQUFNLElBQUluUSxHQUFHSixTQUFTO1lBQy9GLElBQUlySyxLQUFLNEosS0FBSyxDQUFDQyxJQUFJLENBQUNBLEtBQUs2VCxNQUFNO1lBQy9CakIsZUFBZTVTLEtBQUtKLFFBQVEsSUFBSTtnQkFDOUJxVSxLQUFLO2dCQUNMeFksS0FBSztZQUNQO1lBQ0FtWCxlQUFlNVcsVUFBVTRXLGdCQUFnQmhjLE9BQU9nYyxhQUFhcUIsR0FBRyxFQUFFckIsYUFBYW5YLEdBQUcsSUFBSTdFLE9BQU9nYyxjQUFjQTtZQUMzR0Msa0JBQWtCMWMsS0FBSytkLFdBQVcsQ0FBQ2xVLEtBQUttVSxLQUFLLElBQUl4QixjQUFjLEtBQUssS0FBSztnQkFDdkUsSUFBSXZJLFNBQVN6SSxjQUNUeVMsb0JBQW9COWIsYUFBYXlZLGNBQWMsS0FDL0N2UyxRQUFReVMsUUFBUXpTLEtBQUs7Z0JBRXpCLElBQUksQ0FBQzRWLHFCQUFxQnZhLEtBQUtpRCxHQUFHLENBQUMvRCxLQUFLc2IsV0FBVyxNQUFNLEVBQUMsS0FBTSxDQUFDN1YsU0FBUyxDQUFDeEgsa0JBQWtCOFosYUFBYTFHLFFBQVE7b0JBQ2hILElBQUkvTixXQUFXLENBQUMrTixTQUFTeEYsS0FBSSxJQUFLZ04sUUFDOUIyQixnQkFBZ0JyWCxhQUFhLENBQUNnVSxXQUFXaFUsVUFBVXFYLGFBQWEsS0FBS2xYLFVBQ3JFaVksV0FBV0Ysb0JBQW9CLElBQUksQ0FBQ2IsZ0JBQWdCZCxLQUFJLElBQU1uYSxDQUFBQSxhQUFhekIsTUFBSyxJQUFLLFFBQVEsR0FDN0Z1WCxVQUFValksS0FBSzRKLEtBQUssQ0FBQy9HLEtBQUssQ0FBQyxDQUFDcUQsVUFBVSxJQUFJQSxVQUFVUSxLQUFLeVgsV0FBVyxLQUFLQSxXQUFXLFFBQ3BGQyxhQUFhbFksV0FBWTJELENBQUFBLEtBQUt3VSxPQUFPLEtBQUssUUFBUSxJQUFJcEcsT0FBTSxHQUM1RHFHLFVBQ0FDLFdBQ0FDLFFBQVEzVSxNQUNSNFUsVUFBVUQsTUFBTUMsT0FBTyxFQUN2QkMsZUFBZUYsTUFBTWhILFdBQVcsRUFDaENtSCxjQUFjSCxNQUFNckcsVUFBVTtvQkFDbENtRyxXQUFXdEQsU0FBU29ELFlBQVl4YjtvQkFDaENnRCxVQUFVMFksYUFBY0EsQ0FBQUEsV0FBV0YsVUFBUyxHQUFJLGlGQUFpRjtvQkFFaklHLFlBQVk3YSxLQUFLQyxLQUFLLENBQUM4SyxRQUFRNlAsV0FBVzdDO29CQUUxQyxJQUFJeEgsVUFBVWYsT0FBT2UsVUFBVXhGLFNBQVM4UCxjQUFjdEssUUFBUTt3QkFDNUQsSUFBSTVMLFNBQVMsQ0FBQ0EsTUFBTWtWLFFBQVEsSUFBSWxWLE1BQU11VyxJQUFJLElBQUlsWSxLQUFLNlgsWUFBWXRLLFNBQVM7NEJBQ3RFLGtHQUFrRzs0QkFDbEc7d0JBQ0Y7d0JBRUEsSUFBSXBLLEtBQUt3VSxPQUFPLEtBQUssT0FBTzs0QkFDMUJwRyxVQUFVcUcsV0FBV3BZO3dCQUN2Qjt3QkFFQTRVLFFBQVF5RCxXQUFXOzRCQUNqQjlVLFVBQVVnVCxhQUFhL1YsS0FBS2hELEtBQUs0QixHQUFHLENBQUNvQixLQUFLMFgsYUFBYWhCLGdCQUFnQjFXLEtBQUs0WCxXQUFXbEIsa0JBQWtCLFFBQVFlLFdBQVcsUUFBUTs0QkFDcEloQixNQUFNdFQsS0FBS3NULElBQUksSUFBSTs0QkFDbkJ5QixNQUFNbFksS0FBSzZYLFlBQVl0Szs0QkFDdkIsMEdBQTBHOzRCQUMxR3VELGFBQWEsU0FBU0E7Z0NBQ3BCLE9BQU9rRixnQkFBZ0J6TSxPQUFPLENBQUMsU0FBU3lPLGdCQUFnQkEsYUFBYTliOzRCQUN2RTs0QkFDQXVWLFlBQVksU0FBU0E7Z0NBQ25CdlYsS0FBS2lSLE1BQU07Z0NBQ1g4RyxXQUFXblA7Z0NBRVgsSUFBSXpGLFdBQVc7b0NBQ2IsK0pBQStKO29DQUMvSndXLGFBQWFBLFdBQVdzQyxPQUFPLENBQUMsaUJBQWlCUCxVQUFVdlksVUFBVStZLE1BQU0sR0FBRy9ZLFVBQVVnWixLQUFLLElBQUloWixVQUFVRyxRQUFRLENBQUNvWTtnQ0FDdEg7Z0NBRUFqQyxRQUFRQyxRQUFRdlcsYUFBYSxDQUFDZ1UsV0FBV2hVLFVBQVVxWCxhQUFhLEtBQUt4YSxLQUFLc0QsUUFBUTtnQ0FDbEZ1VCxrQkFBa0JBLGVBQWU3VztnQ0FDakMrYixlQUFlQSxZQUFZL2I7NEJBQzdCO3dCQUNGLEdBQUdxUixRQUFRZ0UsVUFBVXdELFFBQVE4QyxZQUFZdEssU0FBU2dFLFVBQVV3RDt3QkFDNURnRCxXQUFXQSxRQUFRN2IsTUFBTWtZLFFBQVF6UyxLQUFLO29CQUN4QztnQkFDRixPQUFPLElBQUl6RixLQUFLb2MsUUFBUSxJQUFJckUsYUFBYTFHLFFBQVE7b0JBQy9DeUksZ0JBQWdCek0sT0FBTyxDQUFDO2dCQUMxQjtZQUNGLEdBQUdoSyxLQUFLO1FBQ1Y7UUFFQTJMLE1BQU8xQyxDQUFBQSxJQUFJLENBQUMwQyxHQUFHLEdBQUdoUCxJQUFHO1FBQ3JCb08sVUFBVXBPLEtBQUtvTyxPQUFPLEdBQUd4Uix3REFBVUEsQ0FBQ3dSLFdBQVcyQixRQUFRLFFBQVFBLE1BQU0sdVVBQXVVO1FBRTVZbUsscUJBQXFCOUwsV0FBV0EsUUFBUXlELEtBQUssSUFBSXpELFFBQVF5RCxLQUFLLENBQUN3SyxRQUFRO1FBQ3ZFbkMsc0JBQXVCQSxDQUFBQSxxQkFBcUJBLG1CQUFtQmxhLEtBQUk7UUFDbkUrUCxNQUFNQSxRQUFRLE9BQU8zQixVQUFVeFIsd0RBQVVBLENBQUNtVDtRQUMxQzdQLFVBQVVxVyxnQkFBaUJBLENBQUFBLGNBQWM7WUFDdkMrRixTQUFTbE87WUFDVG1PLFdBQVdoRztRQUNiO1FBRUEsSUFBSXhHLEtBQUs7WUFDUDJHLGVBQWUsU0FBU0EsZUFBZS9SLFdBQVkrUixDQUFBQSxhQUFhLENBQUNBLGNBQWMzRyxJQUFJa0MsVUFBVSxJQUFJbEMsSUFBSWtDLFVBQVUsQ0FBQzlNLEtBQUssSUFBSUosa0JBQWtCZ0wsSUFBSWtDLFVBQVUsRUFBRWpHLE9BQU8sS0FBSyxTQUFTLFFBQVF0SCxRQUFPLEdBQUksK0lBQStJO1lBRWxWMUUsS0FBSytQLEdBQUcsR0FBR0E7WUFDWG9JLFdBQVcvYSxLQUFLc1YsSUFBSSxDQUFDQyxRQUFRLENBQUM1QztZQUU5QixJQUFJLENBQUNvSSxTQUFTekcsTUFBTSxFQUFFO2dCQUNwQiwyUUFBMlE7Z0JBQzNRLElBQUlzRixXQUFXO29CQUNiQSxZQUFZcGEsd0RBQVVBLENBQUNvYTtvQkFDdkJBLGFBQWEsQ0FBQ0EsVUFBVVgsUUFBUSxJQUFLVyxDQUFBQSxZQUFZQSxVQUFVakMsT0FBTyxJQUFJaUMsVUFBVXdGLGFBQWEsR0FBRyxzQkFBc0I7b0JBRXRIckUsU0FBU3JHLGNBQWMsR0FBRyxDQUFDLENBQUNrRjtvQkFDNUJBLGFBQWNtQixDQUFBQSxTQUFTcEcsV0FBVyxHQUFHZ0IsVUFBVWlFLFVBQVM7Z0JBQzFEO2dCQUVBbUIsU0FBU3pHLE1BQU0sR0FBR0EsU0FBU3NGLGFBQWF6WixLQUFLbU4sYUFBYSxDQUFDO2dCQUMzRGdILE9BQU8rSyxTQUFTLENBQUM5WSxHQUFHLENBQUM7Z0JBQ3JCcUwsTUFBTTBDLE9BQU8rSyxTQUFTLENBQUM5WSxHQUFHLENBQUMsZ0JBQWdCcUw7Z0JBQzNDbUosU0FBU2EsUUFBUSxHQUFHRixtQkFBbUIvRixVQUFVaEQ7WUFDbkQsT0FBTztnQkFDTCtJLG1CQUFtQlgsU0FBU2EsUUFBUTtZQUN0QztZQUVBak4sS0FBSzJRLE9BQU8sS0FBSyxTQUFTdGYsS0FBS2dQLEdBQUcsQ0FBQzJELEtBQUs7Z0JBQ3RDMk0sU0FBUztZQUNYO1lBQ0ExYyxLQUFLMFIsTUFBTSxHQUFHQSxTQUFTeUcsU0FBU3pHLE1BQU07WUFDdENTLEtBQUtwTixrQkFBa0JnTDtZQUN2QnNKLGVBQWVsSCxFQUFFLENBQUN1RSxhQUFhalAsVUFBVWtWLEdBQUcsQ0FBQztZQUM3QzFELFlBQVk3YixLQUFLd2YsV0FBVyxDQUFDN007WUFDN0JtSixZQUFZOWIsS0FBS3lmLFdBQVcsQ0FBQzlNLEtBQUt0SSxVQUFVcEYsQ0FBQyxFQUFFeUMsTUFBTSx3YkFBd2I7WUFFN2VvTixXQUFXbkMsS0FBSzJCLFFBQVFTO1lBRXhCNkcsV0FBV2pHLFVBQVVoRDtRQUN2QjtRQUVBLElBQUk0SCxTQUFTO1lBQ1hnQixhQUFhMVYsVUFBVTBVLFdBQVd2UyxhQUFhdVMsU0FBUzdPLG1CQUFtQkE7WUFDM0UyUCxxQkFBcUJ0TyxjQUFjLGtCQUFrQjZFLElBQUloTixVQUFVeUYsV0FBV2tSLFlBQVk7WUFDMUZELG1CQUFtQnZPLGNBQWMsZ0JBQWdCNkUsSUFBSWhOLFVBQVV5RixXQUFXa1IsWUFBWSxHQUFHRjtZQUN6RmxPLFNBQVNrTyxrQkFBa0IsQ0FBQyxXQUFXaFIsVUFBVWlFLEVBQUUsQ0FBQ3RKLEVBQUUsQ0FBQztZQUV2RCxJQUFJMGEsVUFBVWxnQix3REFBVUEsQ0FBQ00sMkRBQWFBLENBQUM4RSxVQUFVLGNBQWNBO1lBRS9EdVcsY0FBYyxJQUFJLENBQUNBLFdBQVcsR0FBR3BPLGNBQWMsU0FBUzZFLElBQUk4TixTQUFTclYsV0FBV2tSLFlBQVlwTyxRQUFRLEdBQUdFO1lBQ3ZHK04sWUFBWSxJQUFJLENBQUNBLFNBQVMsR0FBR3JPLGNBQWMsT0FBTzZFLElBQUk4TixTQUFTclYsV0FBV2tSLFlBQVlwTyxRQUFRLEdBQUdFO1lBQ2pHQSxzQkFBdUJ3UCxDQUFBQSxpQkFBaUI3YyxLQUFLeWYsV0FBVyxDQUFDO2dCQUFDdEU7Z0JBQWFDO2FBQVUsRUFBRS9RLFVBQVVwRixDQUFDLEVBQUV5QyxJQUFHO1lBRW5HLElBQUksQ0FBQzZGLG9CQUFvQixDQUFFM04sQ0FBQUEsa0RBQVFBLENBQUNxRCxNQUFNLElBQUluRCwyREFBYUEsQ0FBQzhFLFVBQVUsb0JBQW9CLElBQUcsR0FBSTtnQkFDL0ZpRCxrQkFBa0JoRCxhQUFheEUsUUFBUXVFO2dCQUV2QzVFLEtBQUtnUCxHQUFHLENBQUM7b0JBQUNxTTtvQkFBb0JDO2lCQUFpQixFQUFFO29CQUMvQ2dFLFNBQVM7Z0JBQ1g7Z0JBQ0FwRCxvQkFBb0JsYyxLQUFLeWYsV0FBVyxDQUFDcEUsb0JBQW9CaFIsVUFBVXBGLENBQUMsRUFBRXlDO2dCQUN0RTBVLGtCQUFrQnBjLEtBQUt5ZixXQUFXLENBQUNuRSxrQkFBa0JqUixVQUFVcEYsQ0FBQyxFQUFFeUM7WUFDcEU7UUFDRjtRQUVBLElBQUkyRixvQkFBb0I7WUFDdEIsSUFBSXNTLGNBQWN0UyxtQkFBbUJzQixJQUFJLENBQUM2SixRQUFRLEVBQzlDb0gsWUFBWXZTLG1CQUFtQnNCLElBQUksQ0FBQ2tSLGNBQWM7WUFDdER4UyxtQkFBbUJ5UyxhQUFhLENBQUMsWUFBWTtnQkFDM0NsZCxLQUFLaVIsTUFBTSxDQUFDLEdBQUcsR0FBRztnQkFDbEI4TCxlQUFlQSxZQUFZSSxLQUFLLENBQUMxUyxvQkFBb0J1UyxhQUFhLEVBQUU7WUFDdEU7UUFDRjtRQUVBaGQsS0FBS29kLFFBQVEsR0FBRztZQUNkLE9BQU8vUSxTQUFTLENBQUNBLFVBQVVqTSxPQUFPLENBQUNKLFFBQVEsRUFBRTtRQUMvQztRQUVBQSxLQUFLcWQsSUFBSSxHQUFHO1lBQ1YsT0FBT2hSLFNBQVMsQ0FBQ0EsVUFBVWpNLE9BQU8sQ0FBQ0osUUFBUSxFQUFFO1FBQy9DO1FBRUFBLEtBQUtxTyxNQUFNLEdBQUcsU0FBVUEsTUFBTSxFQUFFaVAsSUFBSTtZQUNsQyxJQUFJLENBQUNBLE1BQU07Z0JBQ1QsT0FBT3RkLEtBQUt1RyxJQUFJLENBQUM7WUFDbkIsRUFBRSxrRkFBa0Y7WUFHcEYsSUFBSWdYLElBQUlsUCxXQUFXLFNBQVMsQ0FBQ3JPLEtBQUt3RCxPQUFPLEVBQ3JDZ2EsaUJBQWlCeGY7WUFFckIsSUFBSXVmLE1BQU12ZCxLQUFLNGEsVUFBVSxFQUFFO2dCQUN6QixJQUFJMkMsR0FBRztvQkFDTHhELGFBQWFqWixLQUFLNEIsR0FBRyxDQUFDa0csY0FBYzVJLEtBQUtxUixNQUFNLENBQUMxQyxHQUFHLElBQUksSUFBSSwrTEFBK0w7b0JBRTFQc0osZUFBZWpZLEtBQUtzRCxRQUFRO29CQUM1QjBXLG1CQUFtQjdXLGFBQWFBLFVBQVVHLFFBQVE7Z0JBQ3BEO2dCQUVBaVYsZUFBZTtvQkFBQ0E7b0JBQWFDO29CQUFXQztvQkFBb0JDO2lCQUFpQixDQUFDeFEsT0FBTyxDQUFDLFNBQVVpTSxDQUFDO29CQUMvRixPQUFPQSxFQUFFaFAsS0FBSyxDQUFDNkcsT0FBTyxHQUFHdVIsSUFBSSxTQUFTO2dCQUN4QztnQkFFQSxJQUFJQSxHQUFHO29CQUNMdmYsY0FBY2dDO29CQUNkQSxLQUFLaVIsTUFBTSxDQUFDc00sSUFBSSxtSUFBbUk7Z0JBQ3JKO2dCQUVBLElBQUl4TixPQUFRLEVBQUNnSCxlQUFlLENBQUMvVyxLQUFLb2MsUUFBUSxHQUFHO29CQUMzQyxJQUFJbUIsR0FBRzt3QkFDTDlMLFlBQVkxQixLQUFLMkIsUUFBUW9IO29CQUMzQixPQUFPO3dCQUNMNUcsV0FBV25DLEtBQUsyQixRQUFRM00sa0JBQWtCZ0wsTUFBTWdDO29CQUNsRDtnQkFDRjtnQkFFQXdMLEtBQUt2ZCxLQUFLaVIsTUFBTSxDQUFDc00sSUFBSSwwRkFBMEY7Z0JBRS9HdmYsY0FBY3dmLGdCQUFnQix3RkFBd0Y7Z0JBRXRIeGQsS0FBSzRhLFVBQVUsR0FBRzJDO1lBQ3BCO1FBQ0Y7UUFFQXZkLEtBQUs2UCxPQUFPLEdBQUcsU0FBVTROLElBQUksRUFBRWpQLEtBQUssRUFBRXRKLFFBQVEsRUFBRXdZLFNBQVM7WUFDdkQsOE9BQThPO1lBQzlPLElBQUksQ0FBQzFmLGVBQWUsQ0FBQ2dDLEtBQUt3RCxPQUFPLEtBQUssQ0FBQ2dMLE9BQU87Z0JBQzVDO1lBQ0Y7WUFFQSxJQUFJdUIsT0FBTzBOLFFBQVE5ZCxpQkFBaUI7Z0JBQ2xDd0ksYUFBYXNGLGVBQWUsYUFBYUQ7Z0JBRXpDO1lBQ0Y7WUFFQSxDQUFDaUIsa0JBQWtCbUosaUJBQWlCQSxjQUFjNVg7WUFDbERoQyxjQUFjZ0M7WUFFZCxJQUFJa1ksUUFBUXpTLEtBQUssSUFBSSxDQUFDUCxVQUFVO2dCQUM5QixpSkFBaUo7Z0JBQ2pKZ1QsUUFBUXpTLEtBQUssQ0FBQ2MsSUFBSTtnQkFDbEIyUixRQUFRelMsS0FBSyxHQUFHO1lBQ2xCO1lBRUFrVSxjQUFjQSxXQUFXdFcsS0FBSztZQUM5QnNULHVCQUF1QnhULGFBQWFBLFVBQVVrTCxNQUFNLENBQUM7Z0JBQ25EOUgsTUFBTTtZQUNSLEdBQUdvWCxVQUFVO1lBQ2IzZCxLQUFLNGEsVUFBVSxJQUFJNWEsS0FBS3FPLE1BQU0sQ0FBQyxNQUFNO1lBQ3JDck8sS0FBSzhQLGFBQWEsR0FBRyxPQUFPLHdEQUF3RDtZQUVwRixJQUFJaEcsT0FBTytOLG1CQUNQdkUsaUJBQWlCd0Usc0JBQ2pCcFYsTUFBTStILHFCQUFxQkEsbUJBQW1CNUQsUUFBUSxLQUFLdEUsV0FBV1AsVUFBVXlGLFlBQ2hGbVcsaUJBQWlCL0UsVUFBVSxNQUMzQnRPLFNBQVMsR0FDVHNULGlCQUFpQkgsYUFBYSxHQUM5QkksWUFBWTdhLFVBQVVpQyxZQUFZQSxTQUFTb0wsR0FBRyxHQUFHdkUsS0FBS3VFLEdBQUcsRUFDekR5TixtQkFBbUJoUyxLQUFLaVMsVUFBVSxJQUFJNVAsU0FDdEM2UCxjQUFjaGIsVUFBVWlDLFlBQVlBLFNBQVMyRyxLQUFLLEdBQUdFLEtBQUtGLEtBQUssSUFBS0UsQ0FBQUEsS0FBS0YsS0FBSyxLQUFLLEtBQUssQ0FBQ3VDLFVBQVUsSUFBSTJCLE1BQU0sUUFBUSxRQUFPLEdBQzVIbU8sa0JBQWtCbGUsS0FBS2tlLGVBQWUsR0FBR25TLEtBQUttUyxlQUFlLElBQUl0aEIsd0RBQVVBLENBQUNtUCxLQUFLbVMsZUFBZSxFQUFFbGUsT0FDbEdtZSxlQUFlL1AsV0FBV3ROLEtBQUs0QixHQUFHLENBQUMsR0FBRzJKLFVBQVVqTSxPQUFPLENBQUNKLFVBQVUsR0FDbEU4QyxJQUFJcWIsY0FDSmhNLElBQ0E5TCxRQUNBZ0wsUUFDQStNLFlBQ0FuTCxVQUNBb0wsWUFDQUMsUUFDQUMsZ0JBQ0FDLFNBQ0FDLGNBQ0FDLGdCQUNBQyxtQkFDQUM7WUFFSixJQUFJakgsV0FBVzFVLFVBQVVpQyxXQUFXO2dCQUNsQyxvWUFBb1k7Z0JBQ3BZeVosb0JBQW9CdmhCLEtBQUt3ZixXQUFXLENBQUNuRSxvQkFBb0JoUixVQUFVbEMsQ0FBQztnQkFDcEVxWixrQkFBa0J4aEIsS0FBS3dmLFdBQVcsQ0FBQ2xFLGtCQUFrQmpSLFVBQVVsQyxDQUFDO1lBQ2xFO1lBRUEsTUFBT3pDLElBQUs7Z0JBQ1Ysd1JBQXdSO2dCQUN4UnViLGFBQWFoUyxTQUFTLENBQUN2SixFQUFFO2dCQUN6QnViLFdBQVcvTixHQUFHLElBQUkrTixXQUFXeE8sT0FBTyxDQUFDLEdBQUcsTUFBTzdSLENBQUFBLGNBQWNnQyxJQUFHLEdBQUksZ1JBQWdSO2dCQUVwVnNlLFNBQVNELFdBQVd0TyxHQUFHO2dCQUV2QixJQUFJdU8sVUFBV0EsQ0FBQUEsV0FBV2xRLFdBQVdrUSxXQUFXdk8sT0FBT3VPLFdBQVdKLGVBQWMsS0FBTSxDQUFDRyxXQUFXekQsVUFBVSxFQUFFO29CQUM1RzZELGdCQUFpQkEsQ0FBQUEsZUFBZSxFQUFFO29CQUNsQ0EsYUFBYUksT0FBTyxDQUFDUixhQUFhLHFGQUFxRjtvQkFFdkhBLFdBQVdoUSxNQUFNLENBQUMsTUFBTTtnQkFDMUI7Z0JBRUEsSUFBSWdRLGVBQWVoUyxTQUFTLENBQUN2SixFQUFFLEVBQUU7b0JBQy9CLDBCQUEwQjtvQkFDMUJxYjtvQkFDQXJiO2dCQUNGO1lBQ0Y7WUFFQUMsWUFBWWtiLGdCQUFpQkEsQ0FBQUEsY0FBY0EsWUFBWWplLEtBQUk7WUFDM0RpZSxjQUFjcGUsWUFBWW9lLGFBQWEsU0FBU2plO1lBQ2hENkwsUUFBUXNILGVBQWU4SyxhQUFhN1AsU0FBU3RFLE1BQU1yQyxXQUFXbUIsY0FBYzJQLGFBQWFFLG9CQUFvQnpZLE1BQU1zVCxnQkFBZ0JDLGFBQWE1SSxrQkFBa0JqSSxLQUFLK0gsb0JBQW9CekssS0FBS3lRLFdBQVcsSUFBSSxrQkFBbUJWLENBQUFBLE1BQU0sQ0FBQyxRQUFRO1lBQ2pQaE4sWUFBWSthLGNBQWVBLENBQUFBLFlBQVlBLFVBQVU5ZCxLQUFJO1lBRXJELElBQUlFLFVBQVU0ZCxjQUFjLENBQUNBLFVBQVUxZCxPQUFPLENBQUMsT0FBTztnQkFDcEQsSUFBSSxDQUFDMGQsVUFBVTFkLE9BQU8sQ0FBQyxNQUFNO29CQUMzQjBkLFlBQVksQ0FBQzVkLFVBQVUrZCxlQUFlQSxZQUFZaFcsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBQyxJQUFLNlY7Z0JBQzFFLE9BQU87b0JBQ0x2VCxTQUFTVixZQUFZaVUsVUFBVTNkLE1BQU0sQ0FBQyxJQUFJMko7b0JBQzFDZ1UsWUFBWTVkLFVBQVUrZCxlQUFlQSxjQUFjLENBQUN4VCxxQkFBcUJyTixLQUFLNEosS0FBSyxDQUFDaU4sUUFBUSxDQUFDLEdBQUd4SixtQkFBbUI1RCxRQUFRLElBQUk0RCxtQkFBbUJ5SixhQUFhLENBQUNySSxLQUFLLEVBQUVwQixtQkFBbUJ5SixhQUFhLENBQUM1RCxHQUFHLEVBQUV6RSxTQUFTQSxLQUFJLElBQUt0QixRQUFRLHFGQUFxRjtvQkFFNVR3VCxtQkFBbUIzUDtnQkFDckI7WUFDRjtZQUVBMFAsWUFBWWplLFlBQVlpZSxXQUFXLE9BQU85ZDtZQUMxQ3NRLE1BQU14UCxLQUFLNEIsR0FBRyxDQUFDbUosT0FBT3NILGVBQWUySyxhQUFjQyxDQUFBQSxtQkFBbUIsV0FBV3JiLEdBQUUsR0FBSXFiLGtCQUFrQmpVLE1BQU1yQyxXQUFXbUIsZUFBZTJCLFFBQVFpTyxXQUFXRSxrQkFBa0IxWSxNQUFNc1QsZ0JBQWdCQyxhQUFhNUksa0JBQWtCakksS0FBSytILG9CQUFvQnpLLEtBQUt1USxTQUFTLElBQUksaUJBQWlCLENBQUM7WUFDaFNoRyxTQUFTO1lBQ1R6SCxJQUFJcWI7WUFFSixNQUFPcmIsSUFBSztnQkFDVnViLGFBQWFoUyxTQUFTLENBQUN2SixFQUFFO2dCQUN6QndiLFNBQVNELFdBQVd0TyxHQUFHO2dCQUV2QixJQUFJdU8sVUFBVUQsV0FBV3hTLEtBQUssR0FBR3dTLFdBQVdTLFFBQVEsSUFBSWpULFNBQVMsQ0FBQ3BCLHNCQUFzQjRULFdBQVcvTixHQUFHLEdBQUcsR0FBRztvQkFDMUc2QixLQUFLa00sV0FBVy9OLEdBQUcsR0FBSXRRLENBQUFBLEtBQUt5USxXQUFXLEdBQUczUCxLQUFLNEIsR0FBRyxDQUFDLEdBQUcyYixXQUFXeFMsS0FBSyxJQUFJd1MsV0FBV3hTLEtBQUs7b0JBRTFGLElBQUksQ0FBQ3lTLFdBQVdsUSxXQUFXaVEsV0FBV3hTLEtBQUssR0FBR3dTLFdBQVdTLFFBQVEsR0FBR2pULFNBQVN5UyxXQUFXSixlQUFjLEtBQU1ySyxNQUFNb0ssY0FBYzt3QkFDOUgsMkVBQTJFO3dCQUMzRTFULFVBQVU0SCxLQUFNLEtBQUlrTSxXQUFXL2EsUUFBUTtvQkFDekM7b0JBRUFnYixXQUFXdk8sT0FBUThOLENBQUFBLGtCQUFrQjFMLEVBQUM7Z0JBQ3hDO1lBQ0Y7WUFFQXRHLFNBQVN0QjtZQUNUK0YsT0FBTy9GO1lBQ1B2SyxLQUFLeVEsV0FBVyxJQUFLelEsQ0FBQUEsS0FBS3lRLFdBQVcsSUFBSWxHLE1BQUs7WUFFOUMsSUFBSXZLLEtBQUt1USxTQUFTLElBQUksQ0FBQzlCLGdCQUFnQjtnQkFDckN6TyxLQUFLdVEsU0FBUyxHQUFHRCxPQUFPLENBQUM7Z0JBQ3pCQSxNQUFNeFAsS0FBS29hLEdBQUcsQ0FBQzVLLEtBQUsvTixXQUFXUCxVQUFVeUY7WUFDM0M7WUFFQW9SLFNBQVN2SSxNQUFNekUsU0FBUyxDQUFDQSxTQUFTLElBQUcsS0FBTTtZQUUzQyxJQUFJK1IsZ0JBQWdCO2dCQUNsQix5T0FBeU87Z0JBQ3pPM0YsZUFBZTdhLEtBQUs0SixLQUFLLENBQUMvRyxLQUFLLENBQUMsR0FBRyxHQUFHN0MsS0FBSzRKLEtBQUssQ0FBQytYLFNBQVMsQ0FBQ2xULE9BQU95RSxLQUFLeUo7WUFDekU7WUFFQS9aLEtBQUs4ZSxRQUFRLEdBQUdqQjtZQUVoQixJQUFJdEYsZUFBZWhPLFFBQVE7Z0JBQ3pCLGtDQUFrQztnQkFDbEM0SCxLQUFLLENBQUM7Z0JBQ05BLEVBQUUsQ0FBQzFLLFVBQVVwRixDQUFDLENBQUMsR0FBRyxPQUFPa0k7Z0JBQ3pCMlQsbUJBQW9CL0wsQ0FBQUEsRUFBRSxDQUFDMUssVUFBVWxDLENBQUMsQ0FBQyxHQUFHLE9BQU9xRCxZQUFXO2dCQUN4RHhMLEtBQUtnUCxHQUFHLENBQUM7b0JBQUNtTTtvQkFBYUM7aUJBQVUsRUFBRXJHO1lBQ3JDO1lBRUEsSUFBSXBDLE9BQU8sQ0FBRTNRLENBQUFBLGdCQUFnQlksS0FBS3NRLEdBQUcsSUFBSS9OLFdBQVdQLFVBQVV5RixVQUFTLEdBQUk7Z0JBQ3pFMEssS0FBS3BOLGtCQUFrQmdMO2dCQUN2QnFPLGFBQWEzVyxjQUFjNUssbURBQVNBO2dCQUNwQ3dVLFNBQVN6SSxjQUFjLHlEQUF5RDtnQkFFaEZ1USxXQUFXalAsV0FBVytPLFVBQVV4UixVQUFVcEYsQ0FBQyxLQUFLd2I7Z0JBRWhELElBQUksQ0FBQ25iLE9BQU80TixNQUFNLEdBQUc7b0JBQ25CLDBQQUEwUDtvQkFDMVBvTyxpQkFBaUIsQ0FBQ3pjLGFBQWExRSxLQUFLeWQsZ0JBQWdCLElBQUl4ZCxTQUFTd0UsUUFBTyxFQUFHbUQsS0FBSztvQkFDaEZ1WixpQkFBaUI7d0JBQ2Z2WixPQUFPdVo7d0JBQ1A1ZSxPQUFPNGUsY0FBYyxDQUFDLGFBQWFqWCxVQUFVcEYsQ0FBQyxDQUFDMmMsV0FBVyxHQUFHO29CQUMvRDtvQkFFQSxJQUFJL2MsY0FBYzhDLGtCQUFrQnRILE1BQU0sQ0FBQyxhQUFhZ0ssVUFBVXBGLENBQUMsQ0FBQzJjLFdBQVcsR0FBRyxLQUFLLFVBQVU7d0JBQy9GLG1GQUFtRjt3QkFDbkZOLGVBQWV2WixLQUFLLENBQUMsYUFBYXNDLFVBQVVwRixDQUFDLENBQUMyYyxXQUFXLEdBQUcsR0FBRztvQkFDakU7Z0JBQ0Y7Z0JBRUE5TSxXQUFXbkMsS0FBSzJCLFFBQVFTO2dCQUV4QjZHLFdBQVdqRyxVQUFVaEQsTUFBTSxpSkFBaUo7Z0JBRTVLMUosU0FBU3ZFLFdBQVdpTyxLQUFLO2dCQUN6QndPLGlCQUFpQjVULG9CQUFvQjFOLDREQUFjQSxDQUFDK0UsVUFBVW9jLGFBQWF0aEIscURBQVdBLEdBQUdELG1EQUFTQTtnQkFFbEcsSUFBSTZaLFlBQVk7b0JBQ2QzRSxjQUFjO3dCQUFDMkUsYUFBYWpQLFVBQVVrVixHQUFHO3dCQUFFOUQsU0FBU2dGLGlCQUFpQi9ZO3FCQUFJO29CQUN6RWlOLFlBQVluQyxDQUFDLEdBQUc4QjtvQkFDaEI1TyxJQUFJNFQsZUFBZWhTLFdBQVc4QixTQUFTdUosS0FBS3RJLGFBQWFvUixTQUFTZ0YsaUJBQWlCO29CQUVuRixJQUFJL2EsR0FBRzt3QkFDTGlQLFlBQVlqTCxJQUFJLENBQUNXLFVBQVV0RixDQUFDLEVBQUVXLElBQUlnQyxNQUFNLHFEQUFxRDt3QkFFN0Y0TSxPQUFPdk0sS0FBSyxDQUFDbU4sU0FBUyxLQUFLLFVBQVdaLENBQUFBLE9BQU92TSxLQUFLLENBQUNtTixTQUFTLEdBQUd4UCxJQUFJZ0MsR0FBRTtvQkFDdkU7b0JBRUE4TSxVQUFVRztvQkFFVixJQUFJbU0saUJBQWlCO3dCQUNuQiwyUEFBMlA7d0JBQzNQN1IsVUFBVW5FLE9BQU8sQ0FBQyxTQUFVMEgsQ0FBQzs0QkFDM0IsSUFBSUEsRUFBRUcsR0FBRyxLQUFLbU8sbUJBQW1CdE8sRUFBRTdELElBQUksQ0FBQzJLLFVBQVUsS0FBSyxPQUFPO2dDQUM1RDlHLEVBQUVFLGFBQWEsR0FBRzs0QkFDcEI7d0JBQ0Y7b0JBQ0Y7b0JBRUFuRixvQkFBb0IvQixXQUFXbVI7Z0JBQ2pDLE9BQU87b0JBQ0xqWCxJQUFJMEQsU0FBU3VKLEtBQUt0STtvQkFDbEIzRSxLQUFLNE8sT0FBT3ZNLEtBQUssQ0FBQ21OLFNBQVMsS0FBSyxVQUFXWixDQUFBQSxPQUFPdk0sS0FBSyxDQUFDbU4sU0FBUyxHQUFHeFAsSUFBSWdDLEdBQUU7Z0JBQzVFO2dCQUVBLElBQUk2RixrQkFBa0I7b0JBQ3BCc0ksV0FBVzt3QkFDVHpKLEtBQUtuRCxPQUFPbUQsR0FBRyxHQUFJNFUsQ0FBQUEsYUFBYS9NLFNBQVN4RixRQUFRMFMsY0FBYSxJQUFLelo7d0JBQ25FMkUsTUFBTXBELE9BQU9vRCxJQUFJLEdBQUkyVSxDQUFBQSxhQUFhRyxpQkFBaUJsTixTQUFTeEYsS0FBSSxJQUFLL0c7d0JBQ3JFME4sV0FBVzt3QkFDWHROLFVBQVU7b0JBQ1o7b0JBQ0ErTixRQUFRLENBQUM3TyxPQUFPLEdBQUc2TyxRQUFRLENBQUMsUUFBUXJPLE9BQU8sR0FBRzlELEtBQUttZSxJQUFJLENBQUM1WSxPQUFPMUUsS0FBSyxJQUFJbUQ7b0JBQ3hFbU8sUUFBUSxDQUFDNU8sUUFBUSxHQUFHNE8sUUFBUSxDQUFDLFFBQVFwTyxRQUFRLEdBQUcvRCxLQUFLbWUsSUFBSSxDQUFDNVksT0FBT3hFLE1BQU0sSUFBSWlEO29CQUMzRW1PLFFBQVEsQ0FBQ3RPLFFBQVEsR0FBR3NPLFFBQVEsQ0FBQ3RPLFVBQVVILEtBQUssR0FBR3lPLFFBQVEsQ0FBQ3RPLFVBQVVMLE9BQU8sR0FBRzJPLFFBQVEsQ0FBQ3RPLFVBQVVGLFFBQVEsR0FBR3dPLFFBQVEsQ0FBQ3RPLFVBQVVKLE1BQU0sR0FBRztvQkFDdEkwTyxRQUFRLENBQUN2TyxTQUFTLEdBQUd5TixFQUFFLENBQUN6TixTQUFTO29CQUNqQ3VPLFFBQVEsQ0FBQ3ZPLFdBQVdGLEtBQUssR0FBRzJOLEVBQUUsQ0FBQ3pOLFdBQVdGLEtBQUs7b0JBQy9DeU8sUUFBUSxDQUFDdk8sV0FBV0osT0FBTyxHQUFHNk4sRUFBRSxDQUFDek4sV0FBV0osT0FBTztvQkFDbkQyTyxRQUFRLENBQUN2TyxXQUFXRCxRQUFRLEdBQUcwTixFQUFFLENBQUN6TixXQUFXRCxRQUFRO29CQUNyRHdPLFFBQVEsQ0FBQ3ZPLFdBQVdILE1BQU0sR0FBRzROLEVBQUUsQ0FBQ3pOLFdBQVdILE1BQU07b0JBQ2pEd1UsaUJBQWlCL0YsV0FBVzhGLGtCQUFrQjdGLFVBQVU4RDtvQkFDeER0SSxrQkFBa0I3RixXQUFXO2dCQUMvQjtnQkFFQSxJQUFJekYsV0FBVztvQkFDYix5UEFBeVA7b0JBQ3pQcWIsVUFBVXJiLFVBQVV3WCxRQUFRLEVBQUUsd0dBQXdHO29CQUV0SW5jLG9CQUFvQjtvQkFFcEIyRSxVQUFVd04sTUFBTSxDQUFDeE4sVUFBVTBELFFBQVEsSUFBSSxNQUFNO29CQUM3Q3VTLFlBQVlILFVBQVV4UixVQUFVcEYsQ0FBQyxJQUFJOFcsV0FBV04sU0FBU2dGO29CQUN6RHRFLFdBQVd6WSxLQUFLaUQsR0FBRyxDQUFDOFUsU0FBU08sYUFBYTtvQkFDMUN6TyxvQkFBb0I0TyxZQUFZUixlQUFlbUcsTUFBTSxDQUFDbkcsZUFBZTFZLE1BQU0sR0FBRyxHQUFHLElBQUksMkhBQTJIO29CQUVoTjhDLFVBQVV3TixNQUFNLENBQUMsR0FBRyxNQUFNO29CQUMxQjZOLFdBQVdyYixVQUFVd2EsVUFBVSxDQUFDO29CQUNoQ3hhLFVBQVUwSCxNQUFNLElBQUkxSCxVQUFVUyxTQUFTLENBQUNULFVBQVVTLFNBQVMsS0FBSywwTkFBME47b0JBRTFScEYsb0JBQW9CO2dCQUN0QixPQUFPO29CQUNMNGEsWUFBWVA7Z0JBQ2Q7Z0JBRUE2RixrQkFBbUJBLENBQUFBLGVBQWU1ZSxLQUFLLEdBQUc0ZSxlQUFldlosS0FBSyxDQUFDLGFBQWFzQyxVQUFVcEYsQ0FBQyxDQUFDMmMsV0FBVyxHQUFHLEdBQUdOLGVBQWU1ZSxLQUFLLEdBQUc0ZSxlQUFldlosS0FBSyxDQUFDeU4sY0FBYyxDQUFDLGNBQWNuTCxVQUFVcEYsQ0FBQztZQUMvTCxPQUFPLElBQUkrTCxXQUFXeEYsZ0JBQWdCLENBQUM2QixvQkFBb0I7Z0JBQ3pELHNPQUFzTztnQkFDdE9wRSxTQUFTK0gsUUFBUTZELFVBQVU7Z0JBRTNCLE1BQU81TCxVQUFVQSxXQUFXNUksTUFBTztvQkFDakMsSUFBSTRJLE9BQU84WSxVQUFVLEVBQUU7d0JBQ3JCdFQsU0FBU3hGLE9BQU84WSxVQUFVO3dCQUMxQjdPLE9BQU9qSyxPQUFPOFksVUFBVTtvQkFDMUI7b0JBRUE5WSxTQUFTQSxPQUFPNEwsVUFBVTtnQkFDNUI7WUFDRjtZQUVBd00sZ0JBQWdCQSxhQUFhdlcsT0FBTyxDQUFDLFNBQVUwSCxDQUFDO2dCQUM5QyxPQUFPQSxFQUFFdkIsTUFBTSxDQUFDLE9BQU87WUFDekI7WUFDQXJPLEtBQUs2TCxLQUFLLEdBQUdBO1lBQ2I3TCxLQUFLc1EsR0FBRyxHQUFHQTtZQUNYK0gsVUFBVUMsVUFBVTdKLGlCQUFpQnNMLGFBQWFuUixjQUFjLGlCQUFpQjtZQUVqRixJQUFJLENBQUM2QixzQkFBc0IsQ0FBQ2dFLGdCQUFnQjtnQkFDMUM0SixVQUFVMEIsY0FBY25SLFdBQVdtUjtnQkFDbkMvWixLQUFLcVIsTUFBTSxDQUFDMUMsR0FBRyxHQUFHO1lBQ3BCO1lBRUEzTyxLQUFLcU8sTUFBTSxDQUFDLE9BQU87WUFDbkIySixjQUFjelk7WUFFZCxJQUFJdWEsaUJBQWlCO2dCQUNuQi9CLFdBQVcsQ0FBQyxHQUFHLHNFQUFzRTtnQkFDckYsMFRBQTBUO2dCQUUxVCtCLGdCQUFnQnpNLE9BQU8sQ0FBQztZQUMxQjtZQUVBclAsY0FBYztZQUNkbUYsYUFBYWdVLFlBQWFoVSxDQUFBQSxVQUFVd1gsUUFBUSxJQUFJWCxnQkFBZSxLQUFNN1csVUFBVUcsUUFBUSxPQUFPMFcsb0JBQW9CN1csVUFBVUcsUUFBUSxDQUFDMFcsb0JBQW9CLEdBQUcsTUFBTXJKLE1BQU0sQ0FBQ3hOLFVBQVVnTyxJQUFJLElBQUksTUFBTSxPQUFPLHVJQUF1STtZQUUvVSxJQUFJeU0sa0JBQWtCM0YsaUJBQWlCalksS0FBS3NELFFBQVEsSUFBSW1ILHNCQUFzQmtNLHFCQUFxQjtnQkFDakcsa0xBQWtMO2dCQUNsTHhULGFBQWEsQ0FBQ2dVLFlBQVloVSxVQUFVcVgsYUFBYSxDQUFDL1Asc0JBQXNCb0IsUUFBUSxDQUFDLFNBQVMsQ0FBQ29NLGVBQWU3YSxLQUFLNEosS0FBSyxDQUFDK1gsU0FBUyxDQUFDbFQsT0FBT3lFLEtBQUssS0FBSzJILGNBQWMsT0FBTywyRUFBMkU7Z0JBRWhQalksS0FBS3NELFFBQVEsR0FBR3NhLGtCQUFrQixDQUFDdkYsVUFBVXhNLEtBQUksSUFBS2dOLFdBQVdaLGVBQWUsSUFBSUE7WUFDdEY7WUFFQWxJLE9BQU8yRyxjQUFlaEYsQ0FBQUEsT0FBT3lOLFVBQVUsR0FBR3JlLEtBQUtDLEtBQUssQ0FBQ2YsS0FBS3NELFFBQVEsR0FBRzhWLFVBQVM7WUFDOUVPLGNBQWNBLFdBQVdnRSxVQUFVO1lBRW5DLElBQUksQ0FBQzlKLE1BQU04SyxvQkFBb0I7Z0JBQzdCLHVjQUF1YztnQkFDdmNBLHFCQUFxQnZoQixLQUFLd2YsV0FBVyxDQUFDbkUsb0JBQW9CaFIsVUFBVWxDLENBQUM7Z0JBQ3JFcVosbUJBQW1CeGhCLEtBQUt3ZixXQUFXLENBQUNsRSxrQkFBa0JqUixVQUFVbEMsQ0FBQztnQkFFakV5UCxhQUFheUQsb0JBQW9CaFIsV0FBV2tYO2dCQUU1QzNKLGFBQWF1RCxhQUFhOVEsV0FBV2tYLG9CQUFxQmpCLENBQUFBLGFBQWE7Z0JBRXZFMUksYUFBYTBELGtCQUFrQmpSLFdBQVdtWDtnQkFFMUM1SixhQUFhd0QsV0FBVy9RLFdBQVdtWCxrQkFBbUJsQixDQUFBQSxhQUFhO1lBQ3JFO1lBRUFFLGtCQUFrQixDQUFDblAsa0JBQWtCek8sS0FBS2lSLE1BQU0sSUFBSSw0V0FBNFc7WUFFaGEsSUFBSUwsYUFBYSxDQUFDbkMsa0JBQWtCLENBQUNtSyxvQkFBb0I7Z0JBQ3ZELG9PQUFvTztnQkFDcE9BLHFCQUFxQjtnQkFDckJoSSxVQUFVNVE7Z0JBQ1Y0WSxxQkFBcUI7WUFDdkI7UUFDRjtRQUVBNVksS0FBS3NiLFdBQVcsR0FBRztZQUNqQixPQUFPLENBQUMxUyxlQUFlMFAsT0FBTSxJQUFNL1ksQ0FBQUEsYUFBYXpCLE1BQUssSUFBSyxRQUFRO1FBQ3BFO1FBRUFrQyxLQUFLb2YsWUFBWSxHQUFHO1lBQ2xCbGMsY0FBY2xELEtBQUs2RCxpQkFBaUI7WUFFcEMsSUFBSVYsV0FBVztnQkFDYndXLGFBQWFBLFdBQVdyVyxRQUFRLENBQUMsS0FBSyxDQUFDSCxVQUFVc1gsTUFBTSxLQUFLdlgsY0FBY0MsV0FBV0EsVUFBVUMsUUFBUSxNQUFNK1QsWUFBWWpVLGNBQWNDLFdBQVduRCxLQUFLeUgsU0FBUyxHQUFHLEdBQUc7WUFDeEs7UUFDRjtRQUVBekgsS0FBS3FmLGFBQWEsR0FBRyxTQUFVQyxLQUFLO1lBQ2xDLE9BQU9uYyxhQUFhQSxVQUFVeUQsTUFBTSxJQUFJLENBQUNpRixTQUFTN0wsS0FBSzZQLE9BQU8sTUFBTWhFLEtBQUksSUFBSzFJLFVBQVV5RCxNQUFNLENBQUMwWSxNQUFNLEdBQUduYyxVQUFVMEQsUUFBUSxLQUFLZ1MsVUFBVTtRQUMxSTtRQUVBN1ksS0FBS3VmLFdBQVcsR0FBRyxTQUFVblYsSUFBSTtZQUMvQixJQUFJdEgsSUFBSXVKLFVBQVVqTSxPQUFPLENBQUNKLE9BQ3RCcUMsSUFBSXJDLEtBQUt5SCxTQUFTLEdBQUcsSUFBSTRFLFVBQVUvRSxLQUFLLENBQUMsR0FBR3hFLEdBQUcwYyxPQUFPLEtBQUtuVCxVQUFVL0UsS0FBSyxDQUFDeEUsSUFBSTtZQUVuRixPQUFPLENBQUM1QyxVQUFVa0ssUUFBUS9ILEVBQUVvZCxNQUFNLENBQUMsU0FBVTdQLENBQUM7Z0JBQzVDLE9BQU9BLEVBQUU3RCxJQUFJLENBQUNtTCxlQUFlLEtBQUs5TTtZQUNwQyxLQUFLL0gsQ0FBQUEsRUFBR29kLE1BQU0sQ0FBQyxTQUFVN1AsQ0FBQztnQkFDeEIsT0FBTzVQLEtBQUt5SCxTQUFTLEdBQUcsSUFBSW1JLEVBQUVVLEdBQUcsSUFBSXpFLFFBQVErRCxFQUFFL0QsS0FBSyxJQUFJeUU7WUFDMUQ7UUFDRjtRQUVBdFEsS0FBS2lSLE1BQU0sR0FBRyxTQUFVeU8sS0FBSyxFQUFFdE8sY0FBYyxFQUFFdU8sU0FBUztZQUN0RCxJQUFJbFYsc0JBQXNCLENBQUNrVixhQUFhLENBQUNELE9BQU87Z0JBQzlDO1lBQ0Y7WUFFQSxJQUFJck8sU0FBUzVDLG1CQUFtQixPQUFPc0wsYUFBYS9aLEtBQUtxUixNQUFNLElBQzNEOUwsSUFBSW1hLFFBQVEsSUFBSSxDQUFDck8sU0FBU3hGLEtBQUksSUFBS2dOLFFBQ25DK0csVUFBVXJhLElBQUksSUFBSSxJQUFJQSxJQUFJLElBQUksSUFBSUEsS0FBSyxHQUN2QzBTLGVBQWVqWSxLQUFLc0QsUUFBUSxFQUM1QjhZLFVBQ0F5RCxXQUNBQyxhQUNBQyxRQUNBQyxjQUNBQyxTQUNBQyxTQUNBQztZQUVKLElBQUkvTyxnQkFBZ0I7Z0JBQ2xCa0gsVUFBVUQ7Z0JBQ1ZBLFVBQVU1TixxQkFBcUI3QixlQUFleUk7Z0JBRTlDLElBQUlwSyxNQUFNO29CQUNSeVMsUUFBUUQ7b0JBQ1JBLFFBQVF0VyxhQUFhLENBQUNnVSxXQUFXaFUsVUFBVXFYLGFBQWEsS0FBS29GO2dCQUMvRDtZQUNGLEVBQUUsNE1BQTRNO1lBRzlNLElBQUl0VyxpQkFBaUJ5RyxPQUFPLENBQUMvUixlQUFlLENBQUNzQixZQUFZSyxpQkFBaUI7Z0JBQ3hFLElBQUksQ0FBQ2lnQixXQUFXL1QsUUFBUXdGLFNBQVMsQ0FBQ0EsU0FBU2lILE9BQU0sSUFBTS9ZLENBQUFBLGFBQWF6QixNQUFLLElBQUt3TCxlQUFlO29CQUMzRnNXLFVBQVU7Z0JBQ1osT0FBTyxJQUFJQSxZQUFZLEtBQUt0UCxNQUFNZSxTQUFTLENBQUNBLFNBQVNpSCxPQUFNLElBQU0vWSxDQUFBQSxhQUFhekIsTUFBSyxJQUFLd0wsZUFBZTtvQkFDckdzVyxVQUFVO2dCQUNaO1lBQ0Y7WUFFQSxJQUFJQSxZQUFZM0gsZ0JBQWdCalksS0FBS3dELE9BQU8sRUFBRTtnQkFDNUM0WSxXQUFXcGMsS0FBS29jLFFBQVEsR0FBRyxDQUFDLENBQUN3RCxXQUFXQSxVQUFVO2dCQUNsREMsWUFBWSxDQUFDLENBQUM1SCxnQkFBZ0JBLGVBQWU7Z0JBQzdDZ0ksVUFBVTdELGFBQWF5RDtnQkFDdkJHLGVBQWVDLFdBQVcsQ0FBQyxDQUFDTCxZQUFZLENBQUMsQ0FBQzNILGNBQWMsaUlBQWlJO2dCQUV6TGpZLEtBQUt5SCxTQUFTLEdBQUdtWSxVQUFVM0gsZUFBZSxJQUFJLENBQUM7Z0JBQy9DalksS0FBS3NELFFBQVEsR0FBR3NjO2dCQUVoQixJQUFJSSxnQkFBZ0IsQ0FBQ2hpQixhQUFhO29CQUNoQzhoQixjQUFjRixXQUFXLENBQUMzSCxlQUFlLElBQUkySCxZQUFZLElBQUksSUFBSTNILGlCQUFpQixJQUFJLElBQUksR0FBRywyTEFBMkw7b0JBRXhSLElBQUlkLFVBQVU7d0JBQ1o0SSxTQUFTLENBQUNFLFdBQVc1VyxhQUFhLENBQUN5VyxjQUFjLEVBQUUsS0FBSyxVQUFVelcsYUFBYSxDQUFDeVcsY0FBYyxFQUFFLElBQUl6VyxhQUFhLENBQUN5VyxZQUFZLEVBQUUsMktBQTJLO3dCQUUzU0ssaUJBQWlCaGQsYUFBYzRjLENBQUFBLFdBQVcsY0FBY0EsV0FBVyxXQUFXQSxVQUFVNWMsU0FBUTtvQkFDbEc7Z0JBQ0Y7Z0JBRUErVCxtQkFBb0IrSSxDQUFBQSxXQUFXRSxjQUFhLEtBQU9BLENBQUFBLGtCQUFrQjFKLFNBQVMsQ0FBQ3RULFNBQVEsS0FBT0osQ0FBQUEsWUFBWW1VLG1CQUFtQkEsZ0JBQWdCbFgsUUFBUUEsS0FBS3VmLFdBQVcsQ0FBQ3JJLGlCQUFpQmhQLE9BQU8sQ0FBQyxTQUFVMEgsQ0FBQztvQkFDeE0sT0FBT0EsRUFBRXdQLFlBQVk7Z0JBQ3ZCLEVBQUM7Z0JBRUQsSUFBSSxDQUFDakksVUFBVTtvQkFDYixJQUFJd0MsY0FBYyxDQUFDM2IsZUFBZSxDQUFDc0IsVUFBVTt3QkFDM0NxYSxXQUFXeUcsR0FBRyxDQUFDQyxLQUFLLEdBQUcxRyxXQUFXMkcsTUFBTSxLQUFLM0csV0FBVzBHLEtBQUssSUFBSTFHLFdBQVdoSixNQUFNLENBQUNnSixXQUFXeUcsR0FBRyxDQUFDQyxLQUFLLEdBQUcxRyxXQUFXMkcsTUFBTSxHQUFHLG9TQUFvUzt3QkFFbGEsSUFBSTNHLFdBQVdzQyxPQUFPLEVBQUU7NEJBQ3RCdEMsV0FBV3NDLE9BQU8sQ0FBQyxpQkFBaUIyRCxTQUFTemMsVUFBVStZLE1BQU0sR0FBRy9ZLFVBQVVnWixLQUFLO3dCQUNqRixPQUFPOzRCQUNMLDJDQUEyQzs0QkFDM0N4QyxXQUFXNU4sSUFBSSxDQUFDeU8sYUFBYSxHQUFHb0Y7NEJBQ2hDakcsV0FBV2dFLFVBQVUsR0FBR3RRLE9BQU87d0JBQ2pDO29CQUNGLE9BQU8sSUFBSWxLLFdBQVc7d0JBQ3BCQSxVQUFVcVgsYUFBYSxDQUFDb0YsU0FBUyxDQUFDLENBQUU1aEIsQ0FBQUEsZUFBZ0JnYSxDQUFBQSxlQUFlMEgsS0FBSSxDQUFDO29CQUMxRTtnQkFDRjtnQkFFQSxJQUFJM1AsS0FBSztvQkFDUDJQLFNBQVNoSixjQUFlaEYsQ0FBQUEsT0FBT3ZNLEtBQUssQ0FBQ3VSLGFBQWFqUCxVQUFVa1YsR0FBRyxDQUFDLEdBQUd0RCxZQUFXO29CQUU5RSxJQUFJLENBQUMxTyxrQkFBa0I7d0JBQ3JCdU8sVUFBVXJZLE9BQU9zWSxXQUFXQyxZQUFZd0c7b0JBQzFDLE9BQU8sSUFBSUksY0FBYzt3QkFDdkJFLFVBQVUsQ0FBQ1IsU0FBU0UsVUFBVTNILGdCQUFnQjNILE1BQU0sSUFBSWUsVUFBVUEsU0FBUyxLQUFLOU8sV0FBV1AsVUFBVXlGLFlBQVksZ01BQWdNO3dCQUVqVCxJQUFJc1AsYUFBYTs0QkFDZixJQUFJLENBQUMySSxTQUFVdEQsQ0FBQUEsWUFBWThELE9BQU0sR0FBSTtnQ0FDbkMsSUFBSTdaLFNBQVN2RSxXQUFXaU8sS0FBSyxPQUN6QnRFLFVBQVU0RixTQUFTeEY7Z0NBRXZCeUksVUFBVXZFLEtBQUt0UyxPQUFPNEksT0FBT21ELEdBQUcsR0FBSS9CLENBQUFBLGNBQWM1SyxtREFBU0EsR0FBRzRPLFVBQVUsS0FBSzNHLEtBQUt1QixPQUFPb0QsSUFBSSxHQUFJaEMsQ0FBQUEsY0FBYzVLLG1EQUFTQSxHQUFHLElBQUk0TyxPQUFNLElBQUszRzs0QkFDNUksT0FBTztnQ0FDTHdQLFVBQVV2RSxLQUFLMkI7NEJBQ2pCO3dCQUNGO3dCQUVBRSxVQUFVd0ssWUFBWThELFVBQVVuSCxpQkFBaUJDO3dCQUVqRE8sWUFBWXFHLFVBQVUsS0FBS3hELFlBQVlsRCxVQUFVQyxXQUFZeUcsQ0FBQUEsWUFBWSxLQUFLLENBQUNNLFVBQVU5RyxZQUFZO29CQUN2RztnQkFDRjtnQkFFQW5TLFFBQVEsQ0FBQ2lSLFFBQVF6UyxLQUFLLElBQUksQ0FBQ3pILGVBQWUsQ0FBQ3NCLFlBQVl3YSxnQkFBZ0J6TSxPQUFPLENBQUM7Z0JBQy9Fa0osZUFBZ0IwSixDQUFBQSxXQUFXbkosUUFBUThJLFdBQVlBLENBQUFBLFVBQVUsS0FBSyxDQUFDdmdCLGVBQWMsQ0FBQyxLQUFNekIsU0FBUzJZLFlBQVkrRixPQUFPLEVBQUVwVSxPQUFPLENBQUMsU0FBVVMsRUFBRTtvQkFDcEksT0FBT0EsR0FBRzhULFNBQVMsQ0FBQ0wsWUFBWXRGLE9BQU8sUUFBUSxTQUFTLENBQUNQLFlBQVlnRyxTQUFTO2dCQUNoRixJQUFJLGtGQUFrRjtnQkFFdEYzRyxZQUFZLENBQUN1QixZQUFZLENBQUN1SSxTQUFTOUosU0FBUzVWO2dCQUU1QyxJQUFJZ2dCLGdCQUFnQixDQUFDaGlCLGFBQWE7b0JBQ2hDLElBQUltWixVQUFVO3dCQUNaLElBQUlnSixnQkFBZ0I7NEJBQ2xCLElBQUlKLFdBQVcsWUFBWTtnQ0FDekI1YyxVQUFVRSxLQUFLLEdBQUdtWCxhQUFhLENBQUM7NEJBQ2xDLE9BQU8sSUFBSXVGLFdBQVcsU0FBUztnQ0FDN0I1YyxVQUFVa0ssT0FBTyxDQUFDLE1BQU1oSyxLQUFLOzRCQUMvQixPQUFPLElBQUkwYyxXQUFXLFdBQVc7Z0NBQy9CNWMsVUFBVWtLLE9BQU8sQ0FBQzs0QkFDcEIsT0FBTztnQ0FDTGxLLFNBQVMsQ0FBQzRjLE9BQU87NEJBQ25CO3dCQUNGO3dCQUVBbkssWUFBWUEsU0FBUzVWO29CQUN2QjtvQkFFQSxJQUFJaWdCLFdBQVcsQ0FBQzVnQixpQkFBaUI7d0JBQy9CLGlMQUFpTDt3QkFDakxtWCxZQUFZeUosV0FBVzFjLFVBQVV2RCxNQUFNd1c7d0JBQ3ZDYyxTQUFTLENBQUN3SSxZQUFZLElBQUl2YyxVQUFVdkQsTUFBTXNYLFNBQVMsQ0FBQ3dJLFlBQVk7d0JBQ2hFaEosUUFBUzhJLENBQUFBLFlBQVksSUFBSTVmLEtBQUt1RyxJQUFJLENBQUMsT0FBTyxLQUFLK1EsU0FBUyxDQUFDd0ksWUFBWSxHQUFHLElBQUksd0RBQXdEO3dCQUVwSSxJQUFJLENBQUNHLFNBQVM7NEJBQ1osOEpBQThKOzRCQUM5SkgsY0FBY0YsWUFBWSxJQUFJLElBQUk7NEJBQ2xDdEksU0FBUyxDQUFDd0ksWUFBWSxJQUFJdmMsVUFBVXZELE1BQU1zWCxTQUFTLENBQUN3SSxZQUFZO3dCQUNsRTtvQkFDRjtvQkFFQSxJQUFJN0ksaUJBQWlCLENBQUNtRixZQUFZdGIsS0FBS2lELEdBQUcsQ0FBQy9ELEtBQUtzYixXQUFXLE1BQU90WSxDQUFBQSxVQUFVaVUsaUJBQWlCQSxnQkFBZ0IsSUFBRyxHQUFJO3dCQUNsSC9ULGNBQWNsRCxLQUFLNkQsaUJBQWlCO3dCQUVwQzhWLGFBQWFBLFdBQVdyVyxRQUFRLENBQUMsS0FBS0osY0FBY0MsV0FBVzRjLFdBQVcsWUFBWSxJQUFJLENBQUNILFNBQVM7b0JBQ3RHO2dCQUNGLE9BQU8sSUFBSXpJLFlBQVl2QixZQUFZLENBQUM1WCxhQUFhO29CQUMvQzRYLFNBQVM1VjtnQkFDWDtZQUNGLEVBQUUsaUZBQWlGO1lBR25GLElBQUl3WixpQkFBaUI7Z0JBQ25CLElBQUkrRyxJQUFJOVYscUJBQXFCNEcsU0FBUzVHLG1CQUFtQjVELFFBQVEsS0FBTTRELENBQUFBLG1CQUFtQjJKLGFBQWEsSUFBSSxLQUFLL0M7Z0JBQ2hIaUksa0JBQWtCaUgsSUFBSzlILENBQUFBLG1CQUFtQnRNLFVBQVUsR0FBRyxJQUFJO2dCQUMzRHFOLGdCQUFnQitHO1lBQ2xCO1lBRUF0RyxrQkFBa0JBLGVBQWUsQ0FBQzVJLFNBQVM1RyxtQkFBbUI1RCxRQUFRLEtBQU00RCxDQUFBQSxtQkFBbUIySixhQUFhLElBQUk7UUFDbEg7UUFFQXBVLEtBQUt3Z0IsTUFBTSxHQUFHLFNBQVVkLEtBQUssRUFBRTdQLE9BQU87WUFDcEMsSUFBSSxDQUFDN1AsS0FBS3dELE9BQU8sRUFBRTtnQkFDakJ4RCxLQUFLd0QsT0FBTyxHQUFHO2dCQUVmMkUsYUFBYW5HLFVBQVUsVUFBVWtMO2dCQUVqQ2pMLGNBQWNrRyxhQUFhbkcsVUFBVSxVQUFVMEs7Z0JBQy9Da0wsaUJBQWlCelAsYUFBYXNGLGVBQWUsZUFBZW1LO2dCQUU1RCxJQUFJOEgsVUFBVSxPQUFPO29CQUNuQjFmLEtBQUtzRCxRQUFRLEdBQUcyVSxlQUFlO29CQUMvQkksVUFBVUMsVUFBVVAsV0FBV25QO2dCQUNqQztnQkFFQWlILFlBQVksU0FBUzdQLEtBQUs2UCxPQUFPO1lBQ25DO1FBQ0Y7UUFFQTdQLEtBQUttVixRQUFRLEdBQUcsU0FBVWxPLElBQUk7WUFDNUIsT0FBT0EsUUFBUWlSLFVBQVVBLFFBQVF6UyxLQUFLLEdBQUdrVTtRQUMzQztRQUVBM1osS0FBSzBRLFlBQVksR0FBRyxTQUFVK1AsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLFNBQVMsRUFBRWpELFNBQVM7WUFDbEUsZ0pBQWdKO1lBQ2hKLElBQUlqVCxvQkFBb0I7Z0JBQ3RCLDBLQUEwSztnQkFDMUssSUFBSTVDLEtBQUs0QyxtQkFBbUJ5SixhQUFhLEVBQ3JDck4sV0FBVzRELG1CQUFtQjVELFFBQVEsSUFDdEMrWixVQUFVL1ksR0FBR3lJLEdBQUcsR0FBR3pJLEdBQUdnRSxLQUFLO2dCQUUvQjRVLFdBQVc1WSxHQUFHZ0UsS0FBSyxHQUFHK1UsVUFBVUgsV0FBVzVaO2dCQUMzQzZaLFNBQVM3WSxHQUFHZ0UsS0FBSyxHQUFHK1UsVUFBVUYsU0FBUzdaO1lBQ3pDO1lBRUE3RyxLQUFLNlAsT0FBTyxDQUFDLE9BQU8sT0FBTztnQkFDekJoRSxPQUFPdkwsV0FBV21nQixVQUFVRSxhQUFhLENBQUMsQ0FBQzNnQixLQUFLeVEsV0FBVztnQkFDM0RILEtBQUtoUSxXQUFXb2dCLFFBQVFDLGFBQWEsQ0FBQyxDQUFDM2dCLEtBQUt1USxTQUFTO1lBQ3ZELEdBQUdtTjtZQUNIMWQsS0FBS2lSLE1BQU07UUFDYjtRQUVBalIsS0FBS21RLGdCQUFnQixHQUFHLFNBQVUwUSxNQUFNO1lBQ3RDLElBQUk5TyxlQUFlOE8sUUFBUTtnQkFDekIsSUFBSS9kLElBQUlpUCxZQUFZM1IsT0FBTyxDQUFDcUgsVUFBVXRGLENBQUMsSUFBSTtnQkFDM0M0UCxXQUFXLENBQUNqUCxFQUFFLEdBQUdvSCxXQUFXNkgsV0FBVyxDQUFDalAsRUFBRSxJQUFJK2QsU0FBUy9iO2dCQUN2RGlOLFdBQVcsQ0FBQyxFQUFFLEdBQUc3SCxXQUFXNkgsV0FBVyxDQUFDLEVBQUUsSUFBSThPLFNBQVMvYjtnQkFFdkQ4TSxVQUFVRztZQUNaO1FBQ0Y7UUFFQS9SLEtBQUs4Z0IsT0FBTyxHQUFHLFNBQVVwQixLQUFLLEVBQUVxQixjQUFjO1lBQzVDLElBQUkvZ0IsS0FBS3dELE9BQU8sRUFBRTtnQkFDaEJrYyxVQUFVLFNBQVMxZixLQUFLcU8sTUFBTSxDQUFDLE1BQU07Z0JBQ3JDck8sS0FBS3dELE9BQU8sR0FBR3hELEtBQUtvYyxRQUFRLEdBQUc7Z0JBQy9CMkUsa0JBQWtCcEgsY0FBY0EsV0FBV3RXLEtBQUs7Z0JBQ2hEMFcsYUFBYTtnQkFDYjVCLFlBQWFBLENBQUFBLFNBQVNqSyxPQUFPLEdBQUc7Z0JBQ2hDMEosaUJBQWlCcFAsZ0JBQWdCaUYsZUFBZSxlQUFlbUs7Z0JBRS9ELElBQUlrQyxpQkFBaUI7b0JBQ25CQSxnQkFBZ0J6VyxLQUFLO29CQUNyQjZVLFFBQVF6UyxLQUFLLElBQUl5UyxRQUFRelMsS0FBSyxDQUFDYyxJQUFJLE1BQU8yUixDQUFBQSxRQUFRelMsS0FBSyxHQUFHO2dCQUM1RDtnQkFFQSxJQUFJLENBQUN4RCxZQUFZO29CQUNmLElBQUlhLElBQUl1SixVQUFVaE0sTUFBTTtvQkFFeEIsTUFBT3lDLElBQUs7d0JBQ1YsSUFBSXVKLFNBQVMsQ0FBQ3ZKLEVBQUUsQ0FBQ2QsUUFBUSxLQUFLQSxZQUFZcUssU0FBUyxDQUFDdkosRUFBRSxLQUFLOUMsTUFBTTs0QkFDL0QsUUFBUSw4RUFBOEU7d0JBQ3hGO29CQUNGO29CQUVBd0ksZ0JBQWdCeEcsVUFBVSxVQUFVa0w7b0JBRXBDakwsY0FBY3VHLGdCQUFnQnhHLFVBQVUsVUFBVTBLO2dCQUNwRDtZQUNGO1FBQ0Y7UUFFQTFNLEtBQUt1RyxJQUFJLEdBQUcsU0FBVThILE1BQU0sRUFBRTBTLGNBQWM7WUFDMUMvZ0IsS0FBSzhnQixPQUFPLENBQUN6UyxRQUFRMFM7WUFDckJwSCxjQUFjLENBQUNvSCxrQkFBa0JwSCxXQUFXcFQsSUFBSTtZQUNoRHlJLE1BQU0sT0FBTzFDLElBQUksQ0FBQzBDLEdBQUc7WUFFckIsSUFBSWxNLElBQUl1SixVQUFVak0sT0FBTyxDQUFDSjtZQUUxQjhDLEtBQUssS0FBS3VKLFVBQVU2UyxNQUFNLENBQUNwYyxHQUFHO1lBQzlCQSxNQUFNM0UsTUFBTTJTLGFBQWEsS0FBSzNTLE1BQU0sMkdBQTJHO1lBQy9JLCtOQUErTjtZQUUvTjJFLElBQUk7WUFFSnVKLFVBQVVuRSxPQUFPLENBQUMsU0FBVTBILENBQUM7Z0JBQzNCLE9BQU9BLEVBQUU1TixRQUFRLEtBQUtoQyxLQUFLZ0MsUUFBUSxJQUFLYyxDQUFBQSxJQUFJO1lBQzlDO1lBRUFBLEtBQUsyTCxrQkFBbUJ6TyxDQUFBQSxLQUFLcVIsTUFBTSxDQUFDMUMsR0FBRyxHQUFHO1lBRTFDLElBQUl4TCxXQUFXO2dCQUNiQSxVQUFVK1EsYUFBYSxHQUFHO2dCQUMxQjdGLFVBQVVsTCxVQUFVa0wsTUFBTSxDQUFDO29CQUN6QjlILE1BQU07Z0JBQ1I7Z0JBQ0F3YSxrQkFBa0I1ZCxVQUFVb0QsSUFBSTtZQUNsQztZQUVBZ1MsZUFBZTtnQkFBQ0E7Z0JBQWFDO2dCQUFXQztnQkFBb0JDO2FBQWlCLENBQUN4USxPQUFPLENBQUMsU0FBVWlNLENBQUM7Z0JBQy9GLE9BQU9BLEVBQUVsQyxVQUFVLElBQUlrQyxFQUFFbEMsVUFBVSxDQUFDOUMsV0FBVyxDQUFDZ0Y7WUFDbEQ7WUFDQXBELGFBQWEvUSxRQUFTK1EsQ0FBQUEsV0FBVztZQUVqQyxJQUFJaEIsS0FBSztnQkFDUG9JLFlBQWFBLENBQUFBLFNBQVNqSyxPQUFPLEdBQUc7Z0JBQ2hDcEwsSUFBSTtnQkFFSnVKLFVBQVVuRSxPQUFPLENBQUMsU0FBVTBILENBQUM7b0JBQzNCLE9BQU9BLEVBQUVHLEdBQUcsS0FBS0EsT0FBT2pOO2dCQUMxQjtnQkFFQUEsS0FBTXFWLENBQUFBLFNBQVN6RyxNQUFNLEdBQUcsSUFBSSxzTUFBc007WUFDcE87WUFFQTNGLEtBQUtpVixNQUFNLElBQUlqVixLQUFLaVYsTUFBTSxDQUFDaGhCO1FBQzdCO1FBRUFxTSxVQUFVdkYsSUFBSSxDQUFDOUc7UUFFZkEsS0FBS3dnQixNQUFNLENBQUMsT0FBTztRQUNuQnRHLHNCQUFzQkEsbUJBQW1CbGE7UUFFekMsSUFBSW1ELGFBQWFBLFVBQVVRLEdBQUcsSUFBSSxDQUFDa1YsUUFBUTtZQUN6QyxpUkFBaVI7WUFDalIsSUFBSW9JLGFBQWFqaEIsS0FBS2lSLE1BQU0sRUFBRSxrbEJBQWtsQjtZQUVobkJqUixLQUFLaVIsTUFBTSxHQUFHO2dCQUNaalIsS0FBS2lSLE1BQU0sR0FBR2dRO2dCQUNkcFYsU0FBU3lFLE9BQU90USxLQUFLNlAsT0FBTztZQUM5QjtZQUVBelMsS0FBSytkLFdBQVcsQ0FBQyxNQUFNbmIsS0FBS2lSLE1BQU07WUFDbEM0SCxTQUFTO1lBQ1RoTixRQUFReUUsTUFBTTtRQUNoQixPQUFPO1lBQ0x0USxLQUFLNlAsT0FBTztRQUNkO1FBRUFFLE9BQU9oQixvQkFBb0IsNkZBQTZGO0lBQzFIO0lBRUF0QixjQUFjc0ksUUFBUSxHQUFHLFNBQVNBLFNBQVNyRCxJQUFJO1FBQzdDLElBQUksQ0FBQ3JWLGNBQWM7WUFDakJELE9BQU9zVixRQUFReFI7WUFDZkYsbUJBQW1CQyxPQUFPaWdCLFFBQVEsSUFBSXpULGNBQWMrUyxNQUFNO1lBQzFEbmpCLGVBQWV1QztRQUNqQjtRQUVBLE9BQU92QztJQUNUO0lBRUFvUSxjQUFjbkksUUFBUSxHQUFHLFNBQVNBLFNBQVM2YixNQUFNO1FBQy9DLElBQUlBLFFBQVE7WUFDVixJQUFLLElBQUk1YixLQUFLNGIsT0FBUTtnQkFDcEIvWCxTQUFTLENBQUM3RCxFQUFFLEdBQUc0YixNQUFNLENBQUM1YixFQUFFO1lBQzFCO1FBQ0Y7UUFFQSxPQUFPNkQ7SUFDVDtJQUVBcUUsY0FBY3FULE9BQU8sR0FBRyxTQUFTQSxRQUFRcEIsS0FBSyxFQUFFblosSUFBSTtRQUNsRDNHLFdBQVc7UUFFWHlNLFVBQVVuRSxPQUFPLENBQUMsU0FBVWtHLE9BQU87WUFDakMsT0FBT0EsT0FBTyxDQUFDN0gsT0FBTyxTQUFTLFVBQVUsQ0FBQ21aO1FBQzVDO1FBRUFsWCxnQkFBZ0JsTCxNQUFNLFNBQVNvUDtRQUUvQmxFLGdCQUFnQmpMLE1BQU0sVUFBVW1QO1FBRWhDMFUsY0FBY3JqQjtRQUVkeUssZ0JBQWdCakwsTUFBTSxlQUFlb0Q7UUFFckM2SCxnQkFBZ0IvSyxPQUFPLGNBQWNrRDtRQUVyQ21ILGVBQWVVLGlCQUFpQmpMLE1BQU0sb0NBQW9Da0Q7UUFFMUVxSCxlQUFlVSxpQkFBaUJqTCxNQUFNLDhCQUE4Qm1EO1FBRXBFL0MsYUFBYTRJLElBQUk7UUFFakI1RCxvQkFBb0I2RjtRQUVwQixJQUFLLElBQUkxRixJQUFJLEdBQUdBLElBQUkvRixvREFBVUEsQ0FBQ3NELE1BQU0sRUFBRXlDLEtBQUssRUFBRztZQUM3QzRGLGVBQWVGLGlCQUFpQnpMLG9EQUFVLENBQUMrRixFQUFFLEVBQUUvRixvREFBVSxDQUFDK0YsSUFBSSxFQUFFO1lBRWhFNEYsZUFBZUYsaUJBQWlCekwsb0RBQVUsQ0FBQytGLEVBQUUsRUFBRS9GLG9EQUFVLENBQUMrRixJQUFJLEVBQUU7UUFDbEU7SUFDRjtJQUVBMkssY0FBYytTLE1BQU0sR0FBRyxTQUFTQTtRQUM5QmxqQixPQUFPMkQ7UUFDUDFELE9BQU8yakI7UUFDUDFqQixTQUFTRCxLQUFLOGpCLGVBQWU7UUFDN0I1akIsUUFBUUYsS0FBSytqQixJQUFJO1FBRWpCLElBQUlsa0IsTUFBTTtZQUNSUSxXQUFXUixLQUFLNEosS0FBSyxDQUFDdWEsT0FBTztZQUM3QjFqQixTQUFTVCxLQUFLNEosS0FBSyxDQUFDL0csS0FBSztZQUN6QmxCLFdBQVczQixLQUFLc1YsSUFBSSxDQUFDOE8sT0FBTyxJQUFJN2dCO1lBQ2hDbkMsc0JBQXNCcEIsS0FBS3NWLElBQUksQ0FBQytPLGtCQUFrQixJQUFJOWdCO1lBQ3REM0IscUJBQXFCMUIsS0FBS3NSLE9BQU8sQ0FBQ0wsaUJBQWlCLElBQUk7WUFDdkRzQyxjQUFjdlQsS0FBS29rQixXQUFXO1lBQzlCdGtCLEtBQUtzVixJQUFJLENBQUNpUCxPQUFPLENBQUMsaUJBQWlCbFUsZ0JBQWdCLG9IQUFvSDtZQUV2SyxJQUFJaFEsT0FBTztnQkFDVG1DLFdBQVc7Z0JBQ1hYLFlBQVlpaUIsU0FBU3hXLGFBQWEsQ0FBQyxRQUFRLDhRQUE4UTtnQkFFelR6TCxVQUFVa0csS0FBSyxDQUFDdEQsTUFBTSxHQUFHO2dCQUN6QjVDLFVBQVVrRyxLQUFLLENBQUNELFFBQVEsR0FBRztnQkFFM0IrSjtnQkFFQTFPO2dCQUVBNUQsa0RBQVFBLENBQUNvWixRQUFRLENBQUMzWSxPQUFPLHdIQUF3SDtnQkFFakpxUSxjQUFjcUksT0FBTyxHQUFHblosa0RBQVFBLENBQUNtWixPQUFPO2dCQUN4Q2hYLGFBQWFuQyxrREFBUUEsQ0FBQ21aLE9BQU8sSUFBSSwwQkFBMEJ0QixJQUFJLENBQUNvTixVQUFVQyxTQUFTLEdBQUcsbVRBQW1UO2dCQUV6WWxqQixzQkFBc0JoQyxrREFBUUEsQ0FBQ21aLE9BQU8sS0FBSztnQkFFM0MzTixhQUFhN0ssTUFBTSxTQUFTb1AsWUFBWSxtREFBbUQ7Z0JBRzNGaFAsUUFBUTtvQkFBQ0o7b0JBQU1DO29CQUFNQztvQkFBUUM7aUJBQU07Z0JBRW5DLElBQUlMLEtBQUswa0IsVUFBVSxFQUFFO29CQUNuQnJVLGNBQWNxVSxVQUFVLEdBQUcsU0FBVS9WLElBQUk7d0JBQ3ZDLElBQUlnVyxLQUFLM2tCLEtBQUswa0IsVUFBVSxJQUNwQnZjO3dCQUVKLElBQUtBLEtBQUt3RyxLQUFNOzRCQUNkZ1csR0FBR3BlLEdBQUcsQ0FBQzRCLEdBQUd3RyxJQUFJLENBQUN4RyxFQUFFO3dCQUNuQjt3QkFFQSxPQUFPd2M7b0JBQ1Q7b0JBRUEza0IsS0FBS2tMLGdCQUFnQixDQUFDLGtCQUFrQjt3QkFDdEMsT0FBTzZGO29CQUNUO29CQUNBL1EsS0FBS2tMLGdCQUFnQixDQUFDLG9CQUFvQjt3QkFDeEMsT0FBT3dGO29CQUNUO29CQUNBMVEsS0FBS2tMLGdCQUFnQixDQUFDLGNBQWM7d0JBQ2xDb0YsWUFBWSxHQUFHO3dCQUVmWCxVQUFVO29CQUNaO29CQUNBM1AsS0FBSzBrQixVQUFVLENBQUMsMkJBQTJCO3dCQUN6QyxxR0FBcUc7d0JBQ3JHOVU7d0JBRUEsT0FBT0E7b0JBQ1Q7Z0JBQ0YsT0FBTztvQkFDTGdKLFFBQVFDLElBQUksQ0FBQztnQkFDZjtnQkFFQWpKO2dCQUVBN0UsYUFBYTVLLE1BQU0sVUFBVW1QLFlBQVksd0pBQXdKO2dCQUdqTSxJQUFJc1YsWUFBWXZrQixNQUFNMEgsS0FBSyxFQUN2QjhjLFNBQVNELFVBQVVFLGNBQWMsRUFDakNDLGlCQUFpQi9rQixLQUFLc1YsSUFBSSxDQUFDMFAsU0FBUyxDQUFDaE0sU0FBUyxFQUM5Qy9QLFFBQ0F2RDtnQkFDSnFmLGVBQWU5VCxNQUFNLElBQUlnVSxPQUFPQyxjQUFjLENBQUNILGdCQUFnQixVQUFVO29CQUN2RXJpQixPQUFPLFNBQVNBO3dCQUNkLE9BQU8sSUFBSSxDQUFDcVIsSUFBSSxDQUFDLENBQUMsTUFBTTtvQkFDMUI7Z0JBQ0YsSUFBSSwrRUFBK0U7Z0JBRW5GNlEsVUFBVUUsY0FBYyxHQUFHLFNBQVMsb05BQW9OO2dCQUV4UDdiLFNBQVN2RSxXQUFXckU7Z0JBQ3BCWixtREFBU0EsQ0FBQ3NYLENBQUMsR0FBR3JULEtBQUtDLEtBQUssQ0FBQ3NGLE9BQU9tRCxHQUFHLEdBQUczTSxtREFBU0EsQ0FBQzBsQixFQUFFLE9BQU8sR0FBRyx3RUFBd0U7Z0JBRXBJemxCLHFEQUFXQSxDQUFDcVgsQ0FBQyxHQUFHclQsS0FBS0MsS0FBSyxDQUFDc0YsT0FBT29ELElBQUksR0FBRzNNLHFEQUFXQSxDQUFDeWxCLEVBQUUsT0FBTztnQkFDOUROLFNBQVNELFVBQVVFLGNBQWMsR0FBR0QsU0FBU0QsVUFBVXBQLGNBQWMsQ0FBQyxxQkFBcUIsNEZBQTRGO2dCQUV2TDdVLGdCQUFnQnlrQixZQUFZaFcsT0FBTztnQkFDbkNwUCxLQUFLK2QsV0FBVyxDQUFDLEtBQUs7b0JBQ3BCLE9BQU83YixXQUFXO2dCQUNwQjtnQkFFQTZJLGFBQWE1SyxNQUFNLGVBQWVvRCxlQUFlLHNJQUFzSTtnQkFHdkx3SCxhQUFhMUssT0FBTyxjQUFja0QsZUFBZSxzR0FBc0c7Z0JBR3ZKbUgsZUFBZUssY0FBYzVLLE1BQU0sb0NBQW9Da0Q7Z0JBRXZFcUgsZUFBZUssY0FBYzVLLE1BQU0sOEJBQThCbUQ7Z0JBRWpFeEMsaUJBQWlCZCxLQUFLNEosS0FBSyxDQUFDeWIsV0FBVyxDQUFDO2dCQUV4Q2xSLFlBQVl6SyxJQUFJLENBQUM1STtnQkFFakJiLGVBQWVrQztnQkFDZjVCLGVBQWVQLEtBQUsrZCxXQUFXLENBQUMsS0FBS3pOLGFBQWFySyxLQUFLO2dCQUN2RC9FLGVBQWU7b0JBQUNmO29CQUFNO29CQUFvQjt3QkFDeEMsSUFBSW1sQixJQUFJcGxCLEtBQUtzRSxVQUFVLEVBQ25CK2dCLElBQUlybEIsS0FBSzJQLFdBQVc7d0JBRXhCLElBQUkxUCxLQUFLcWxCLE1BQU0sRUFBRTs0QkFDZnhrQixhQUFhc2tCOzRCQUNicmtCLGNBQWNza0I7d0JBQ2hCLE9BQU8sSUFBSXZrQixlQUFlc2tCLEtBQUtya0IsZ0JBQWdCc2tCLEdBQUc7NEJBQ2hEelY7d0JBQ0Y7b0JBQ0Y7b0JBQUczUDtvQkFBTTtvQkFBb0JtUTtvQkFBYXBRO29CQUFNO29CQUFRb1E7b0JBQWFwUTtvQkFBTTtvQkFBVTRQO2lCQUFVO2dCQUUvRnZLLG9CQUFvQndGO2dCQUVwQmtFLFVBQVVuRSxPQUFPLENBQUMsU0FBVWtHLE9BQU87b0JBQ2pDLE9BQU9BLFFBQVFvUyxNQUFNLENBQUMsR0FBRztnQkFDM0I7Z0JBRUEsSUFBSzFkLElBQUksR0FBR0EsSUFBSS9GLG9EQUFVQSxDQUFDc0QsTUFBTSxFQUFFeUMsS0FBSyxFQUFHO29CQUN6QzRGLGVBQWVGLGlCQUFpQnpMLG9EQUFVLENBQUMrRixFQUFFLEVBQUUvRixvREFBVSxDQUFDK0YsSUFBSSxFQUFFO29CQUVoRTRGLGVBQWVGLGlCQUFpQnpMLG9EQUFVLENBQUMrRixFQUFFLEVBQUUvRixvREFBVSxDQUFDK0YsSUFBSSxFQUFFO2dCQUNsRTtZQUNGO1FBQ0Y7SUFDRjtJQUVBMkssY0FBYzBULE1BQU0sR0FBRyxTQUFTQSxPQUFPcFYsSUFBSTtRQUN6QyxvQkFBb0JBLFFBQVMxTSxDQUFBQSxrQkFBa0IsQ0FBQyxDQUFDME0sS0FBSzhXLGNBQWM7UUFDcEUsSUFBSUMsS0FBSy9XLEtBQUtnWCxZQUFZO1FBQzFCRCxNQUFNMUIsY0FBY3JqQixrQkFBa0IsQ0FBQ0EsZ0JBQWdCK2tCLEVBQUMsS0FBTU4sWUFBWWhXLE9BQU9zVztRQUNqRix3QkFBd0IvVyxRQUFTcE4sQ0FBQUEsc0JBQXNCOE8sY0FBY3FJLE9BQU8sS0FBSyxLQUFLL0osS0FBS2lYLGtCQUFrQjtRQUU3RyxJQUFJLHVCQUF1QmpYLE1BQU07WUFDL0JwSixvQkFBb0I2RixvQkFBb0I3RixvQkFBb0J3RixjQUFjNEQsS0FBS2tYLGlCQUFpQixJQUFJO1lBQ3BHeGtCLGdCQUFnQixDQUFDc04sS0FBS2tYLGlCQUFpQixHQUFHLEVBQUMsRUFBRzdpQixPQUFPLENBQUMsY0FBYyxDQUFDO1FBQ3ZFO0lBQ0Y7SUFFQXFOLGNBQWN5VixhQUFhLEdBQUcsU0FBU0EsY0FBY3hULE1BQU0sRUFBRTNELElBQUk7UUFDL0QsSUFBSTZELElBQUloVCx3REFBVUEsQ0FBQzhTLFNBQ2Y1TSxJQUFJL0Ysb0RBQVVBLENBQUNxRCxPQUFPLENBQUN3UCxJQUN2QjNOLGFBQWFiLFlBQVl3TztRQUU3QixJQUFJLENBQUM5TSxHQUFHO1lBQ04vRixvREFBVUEsQ0FBQ21pQixNQUFNLENBQUNwYyxHQUFHYixhQUFhLElBQUk7UUFDeEM7UUFFQSxJQUFJOEosTUFBTTtZQUNSOUosYUFBYWpGLGtEQUFRQSxDQUFDNmhCLE9BQU8sQ0FBQ3ZoQixNQUFNeU8sTUFBTXRPLE9BQU9zTyxNQUFNdk8sUUFBUXVPLFFBQVEvTyxrREFBUUEsQ0FBQzZoQixPQUFPLENBQUNqUCxHQUFHN0Q7UUFDN0Y7SUFDRjtJQUVBMEIsY0FBYzBWLGVBQWUsR0FBRyxTQUFTQSxnQkFBZ0JuVixLQUFLO1FBQzVEM0IsVUFBVW5FLE9BQU8sQ0FBQyxTQUFVMEgsQ0FBQztZQUMzQixPQUFPQSxFQUFFbE0sSUFBSSxJQUFJa00sRUFBRWxNLElBQUksQ0FBQ3NLLEtBQUssS0FBS0EsU0FBUzRCLEVBQUVsTSxJQUFJLENBQUM2QyxJQUFJLENBQUMsTUFBTTtRQUMvRDtJQUNGO0lBRUFrSCxjQUFjMlYsWUFBWSxHQUFHLFNBQVNBLGFBQWEzaEIsT0FBTyxFQUFFa1UsS0FBSyxFQUFFMUYsVUFBVTtRQUMzRSxJQUFJNUosU0FBUyxDQUFDbkcsVUFBVXVCLFdBQVc3RSx3REFBVUEsQ0FBQzZFLFdBQVdBLE9BQU0sRUFBRzZFLHFCQUFxQixJQUNuRmlFLFNBQVNsRSxNQUFNLENBQUM0SixhQUFhN0wsU0FBU0MsUUFBUSxHQUFHc1IsU0FBUztRQUM5RCxPQUFPMUYsYUFBYTVKLE9BQU91RCxLQUFLLEdBQUdXLFNBQVMsS0FBS2xFLE9BQU9vRCxJQUFJLEdBQUdjLFNBQVNqTixLQUFLc0UsVUFBVSxHQUFHeUUsT0FBT3NELE1BQU0sR0FBR1ksU0FBUyxLQUFLbEUsT0FBT21ELEdBQUcsR0FBR2UsU0FBU2pOLEtBQUsyUCxXQUFXO0lBQ2hLO0lBRUFRLGNBQWM0VixrQkFBa0IsR0FBRyxTQUFTQSxtQkFBbUI1aEIsT0FBTyxFQUFFNmhCLGNBQWMsRUFBRXJULFVBQVU7UUFDaEcvUCxVQUFVdUIsWUFBYUEsQ0FBQUEsVUFBVTdFLHdEQUFVQSxDQUFDNkUsUUFBTztRQUNuRCxJQUFJNEUsU0FBUzVFLFFBQVE2RSxxQkFBcUIsSUFDdEN3RCxPQUFPekQsTUFBTSxDQUFDNEosYUFBYTdMLFNBQVNDLFFBQVEsRUFDNUNrRyxTQUFTK1ksa0JBQWtCLE9BQU94WixPQUFPLElBQUl3WixrQkFBa0IvWixZQUFZQSxTQUFTLENBQUMrWixlQUFlLEdBQUd4WixPQUFPLENBQUN3WixlQUFlbGpCLE9BQU8sQ0FBQyxPQUFPOEosV0FBV29aLGtCQUFrQnhaLE9BQU8sTUFBTUksV0FBV29aLG1CQUFtQjtRQUN6TixPQUFPclQsYUFBYSxDQUFDNUosT0FBT29ELElBQUksR0FBR2MsTUFBSyxJQUFLak4sS0FBS3NFLFVBQVUsR0FBRyxDQUFDeUUsT0FBT21ELEdBQUcsR0FBR2UsTUFBSyxJQUFLak4sS0FBSzJQLFdBQVc7SUFDekc7SUFFQVEsY0FBYzhWLE9BQU8sR0FBRyxTQUFTQSxRQUFRQyxjQUFjO1FBQ3JEblgsVUFBVS9FLEtBQUssQ0FBQyxHQUFHWSxPQUFPLENBQUMsU0FBVTBILENBQUM7WUFDcEMsT0FBT0EsRUFBRTdELElBQUksQ0FBQ2lELEVBQUUsS0FBSyxvQkFBb0JZLEVBQUVySixJQUFJO1FBQ2pEO1FBRUEsSUFBSWlkLG1CQUFtQixNQUFNO1lBQzNCLElBQUlDLFlBQVluVyxXQUFXaVcsT0FBTyxJQUFJLEVBQUU7WUFDeENqVyxhQUFhLENBQUM7WUFDZG1XLFVBQVV2YixPQUFPLENBQUMsU0FBVTBGLENBQUM7Z0JBQzNCLE9BQU9BO1lBQ1Q7UUFDRjtJQUNGO0lBRUEsT0FBT0g7QUFDVCxJQUFJO0FBQ0pBLGNBQWNpVyxPQUFPLEdBQUc7QUFFeEJqVyxjQUFja1csVUFBVSxHQUFHLFNBQVVySCxPQUFPO0lBQzFDLE9BQU9BLFVBQVUxZSxTQUFTMGUsU0FBU3BVLE9BQU8sQ0FBQyxTQUFVd0gsTUFBTTtRQUN6RCxxSUFBcUk7UUFDckksSUFBSUEsVUFBVUEsT0FBT3ZLLEtBQUssRUFBRTtZQUMxQixJQUFJckMsSUFBSStLLGFBQWF6TixPQUFPLENBQUNzUDtZQUU3QjVNLEtBQUssS0FBSytLLGFBQWFxUixNQUFNLENBQUNwYyxHQUFHO1lBRWpDK0ssYUFBYS9HLElBQUksQ0FBQzRJLFFBQVFBLE9BQU92SyxLQUFLLENBQUNpRyxPQUFPLEVBQUVzRSxPQUFPekIsT0FBTyxJQUFJeUIsT0FBT2tVLFlBQVksQ0FBQyxjQUFjeG1CLEtBQUtzVixJQUFJLENBQUNDLFFBQVEsQ0FBQ2pELFNBQVMzUTtRQUNsSTtJQUNGLEtBQUs4TztBQUNQO0FBRUFKLGNBQWNZLE1BQU0sR0FBRyxTQUFVb1AsSUFBSSxFQUFFMVAsS0FBSztJQUMxQyxPQUFPSSxXQUFXLENBQUNzUCxNQUFNMVA7QUFDM0I7QUFFQU4sY0FBY29XLE1BQU0sR0FBRyxTQUFVOVgsSUFBSSxFQUFFNUksU0FBUztJQUM5QyxPQUFPLElBQUlzSyxjQUFjMUIsTUFBTTVJO0FBQ2pDO0FBRUFzSyxjQUFjb0MsT0FBTyxHQUFHLFNBQVVpVSxJQUFJO0lBQ3BDLE9BQU9BLE9BQU81VyxjQUFjLENBQUM3UCxnQkFBZ0JvUSxjQUFjc0ksUUFBUSxFQUFDLEtBQU1ySSxZQUFZO0FBQ3hGO0FBRUFELGNBQWN3RCxNQUFNLEdBQUcsU0FBVXpDLEtBQUs7SUFDcEMsT0FBTyxFQUFFelIsb0RBQVVBLENBQUMrUCxLQUFLLElBQUlMLFdBQVcrQixVQUFVLE9BQU8sSUFBSTtBQUMvRDtBQUVBZixjQUFjc1csaUJBQWlCLEdBQUd6VjtBQUVsQ2IsY0FBY3VXLFNBQVMsR0FBRyxTQUFVdmlCLE9BQU8sRUFBRXdPLFVBQVU7SUFDckQsT0FBTzFOLFdBQVdkLFNBQVN3TyxhQUFhblQscURBQVdBLEdBQUdELG1EQUFTQTtBQUNqRTtBQUVBNFEsY0FBY3dXLGFBQWEsR0FBRyxTQUFVeGlCLE9BQU8sRUFBRXdPLFVBQVU7SUFDekQsT0FBT2hULDREQUFjQSxDQUFDTCx3REFBVUEsQ0FBQzZFLFVBQVV3TyxhQUFhblQscURBQVdBLEdBQUdELG1EQUFTQTtBQUNqRjtBQUVBNFEsY0FBY3lXLE9BQU8sR0FBRyxTQUFVbFYsRUFBRTtJQUNsQyxPQUFPMUMsSUFBSSxDQUFDMEMsR0FBRztBQUNqQjtBQUVBdkIsY0FBYzBXLE1BQU0sR0FBRztJQUNyQixPQUFPOVgsVUFBVW9ULE1BQU0sQ0FBQyxTQUFVN1AsQ0FBQztRQUNqQyxPQUFPQSxFQUFFN0QsSUFBSSxDQUFDaUQsRUFBRSxLQUFLO0lBQ3ZCO0FBQ0YsR0FBRyxtTEFBbUw7QUFHdEx2QixjQUFjMlcsV0FBVyxHQUFHO0lBQzFCLE9BQU8sQ0FBQyxDQUFDemtCO0FBQ1g7QUFFQThOLGNBQWM0VyxlQUFlLEdBQUduZDtBQUVoQ3VHLGNBQWNuRixnQkFBZ0IsR0FBRyxTQUFVdkksSUFBSSxFQUFFaUksUUFBUTtJQUN2RCxJQUFJM0YsSUFBSWlMLFVBQVUsQ0FBQ3ZOLEtBQUssSUFBS3VOLENBQUFBLFVBQVUsQ0FBQ3ZOLEtBQUssR0FBRyxFQUFFO0lBQ2xELENBQUNzQyxFQUFFakMsT0FBTyxDQUFDNEgsYUFBYTNGLEVBQUV5RSxJQUFJLENBQUNrQjtBQUNqQztBQUVBeUYsY0FBY2hGLG1CQUFtQixHQUFHLFNBQVUxSSxJQUFJLEVBQUVpSSxRQUFRO0lBQzFELElBQUkzRixJQUFJaUwsVUFBVSxDQUFDdk4sS0FBSyxFQUNwQitDLElBQUlULEtBQUtBLEVBQUVqQyxPQUFPLENBQUM0SDtJQUN2QmxGLEtBQUssS0FBS1QsRUFBRTZjLE1BQU0sQ0FBQ3BjLEdBQUc7QUFDeEI7QUFFQTJLLGNBQWM2VyxLQUFLLEdBQUcsU0FBVWhJLE9BQU8sRUFBRXZRLElBQUk7SUFDM0MsSUFBSXRJLFNBQVMsRUFBRSxFQUNYOGdCLFdBQVcsQ0FBQyxHQUNaQyxXQUFXelksS0FBS3lZLFFBQVEsSUFBSSxPQUM1QkMsV0FBVzFZLEtBQUswWSxRQUFRLElBQUksS0FDNUJDLGdCQUFnQixTQUFTQSxjQUFjM2tCLElBQUksRUFBRWlJLFFBQVE7UUFDdkQsSUFBSTJjLFdBQVcsRUFBRSxFQUNiQyxXQUFXLEVBQUUsRUFDYnhKLFFBQVFoZSxLQUFLK2QsV0FBVyxDQUFDcUosVUFBVTtZQUNyQ3hjLFNBQVMyYyxVQUFVQztZQUNuQkQsV0FBVyxFQUFFO1lBQ2JDLFdBQVcsRUFBRTtRQUNmLEdBQUd2aEIsS0FBSztRQUNSLE9BQU8sU0FBVXJELElBQUk7WUFDbkIya0IsU0FBU3RrQixNQUFNLElBQUkrYSxNQUFNL04sT0FBTyxDQUFDO1lBQ2pDc1gsU0FBUzdkLElBQUksQ0FBQzlHLEtBQUtvTyxPQUFPO1lBQzFCd1csU0FBUzlkLElBQUksQ0FBQzlHO1lBQ2R5a0IsWUFBWUUsU0FBU3RrQixNQUFNLElBQUkrYSxNQUFNOVgsUUFBUSxDQUFDO1FBQ2hEO0lBQ0YsR0FDSWlDO0lBRUosSUFBS0EsS0FBS3dHLEtBQU07UUFDZHdZLFFBQVEsQ0FBQ2hmLEVBQUUsR0FBR0EsRUFBRXBGLE1BQU0sQ0FBQyxHQUFHLE9BQU8sUUFBUTRDLFlBQVlnSixJQUFJLENBQUN4RyxFQUFFLEtBQUtBLE1BQU0sa0JBQWtCbWYsY0FBY25mLEdBQUd3RyxJQUFJLENBQUN4RyxFQUFFLElBQUl3RyxJQUFJLENBQUN4RyxFQUFFO0lBQzlIO0lBRUEsSUFBSXhDLFlBQVkwaEIsV0FBVztRQUN6QkEsV0FBV0E7UUFFWHRjLGFBQWFzRixlQUFlLFdBQVc7WUFDckMsT0FBT2dYLFdBQVcxWSxLQUFLMFksUUFBUTtRQUNqQztJQUNGO0lBRUE3bUIsU0FBUzBlLFNBQVNwVSxPQUFPLENBQUMsU0FBVXdILE1BQU07UUFDeEMsSUFBSXlSLFNBQVMsQ0FBQztRQUVkLElBQUs1YixLQUFLZ2YsU0FBVTtZQUNsQnBELE1BQU0sQ0FBQzViLEVBQUUsR0FBR2dmLFFBQVEsQ0FBQ2hmLEVBQUU7UUFDekI7UUFFQTRiLE9BQU8vUyxPQUFPLEdBQUdzQjtRQUNqQmpNLE9BQU9xRCxJQUFJLENBQUMyRyxjQUFjb1csTUFBTSxDQUFDMUM7SUFDbkM7SUFFQSxPQUFPMWQ7QUFDVCxHQUFHLGdVQUFnVTtBQUduVSxJQUFJb2hCLHVDQUF1QyxTQUFTQSxxQ0FBcUNqYyxVQUFVLEVBQUVtTSxPQUFPLEVBQUV6RSxHQUFHLEVBQUU1TixHQUFHO0lBQ3BIcVMsVUFBVXJTLE1BQU1rRyxXQUFXbEcsT0FBT3FTLFVBQVUsS0FBS25NLFdBQVc7SUFDNUQsT0FBTzBILE1BQU01TixNQUFNLENBQUNBLE1BQU1xUyxPQUFNLElBQU16RSxDQUFBQSxNQUFNeUUsT0FBTSxJQUFLekUsTUFBTSxJQUFJeUUsVUFBV0EsQ0FBQUEsVUFBVXpFLEdBQUUsSUFBSztBQUMvRixHQUNJd1Usc0JBQXNCLFNBQVNBLG9CQUFvQnBWLE1BQU0sRUFBRWpJLFNBQVM7SUFDdEUsSUFBSUEsY0FBYyxNQUFNO1FBQ3RCaUksT0FBT3ZLLEtBQUssQ0FBQ3lOLGNBQWMsQ0FBQztJQUM5QixPQUFPO1FBQ0xsRCxPQUFPdkssS0FBSyxDQUFDNGYsV0FBVyxHQUFHdGQsY0FBYyxPQUFPLFNBQVNBLFlBQVksU0FBU0EsWUFBYTlLLENBQUFBLGtEQUFRQSxDQUFDbVosT0FBTyxHQUFHLGdCQUFnQixFQUFDLElBQUssUUFBUSxrR0FBa0c7SUFDaFA7SUFFQXBHLFdBQVdsUyxVQUFVc25CLG9CQUFvQnJuQixPQUFPZ0s7QUFDbEQsR0FDSXVkLFlBQVk7SUFDZEMsTUFBTTtJQUNONVQsUUFBUTtBQUNWLEdBQ0k2VCxnQkFBZ0IsU0FBU0EsY0FBY0MsS0FBSztJQUM5QyxJQUFJQyxRQUFRRCxNQUFNQyxLQUFLLEVBQ25CMVYsU0FBU3lWLE1BQU16VixNQUFNLEVBQ3JCMlYsT0FBT0YsTUFBTUUsSUFBSTtJQUVyQixJQUFJQyxPQUFPLENBQUNGLE1BQU1HLGNBQWMsR0FBR0gsTUFBTUcsY0FBYyxDQUFDLEVBQUUsR0FBR0gsS0FBSSxFQUFHMVYsTUFBTSxFQUN0RTVDLFFBQVF3WSxLQUFLelQsS0FBSyxJQUFJelUsS0FBS3NWLElBQUksQ0FBQ0MsUUFBUSxDQUFDMlMsT0FDekNuVSxPQUFPNVIsWUFDUDRTO0lBRUosSUFBSSxDQUFDckYsTUFBTTBZLFVBQVUsSUFBSXJVLE9BQU9yRSxNQUFNMFksVUFBVSxHQUFHLE1BQU07UUFDdkQsOENBQThDO1FBQzlDLE1BQU9GLFFBQVFBLFNBQVM3bkIsU0FBVTZuQixDQUFBQSxLQUFLRyxZQUFZLElBQUlILEtBQUtJLFlBQVksSUFBSUosS0FBS0ssV0FBVyxJQUFJTCxLQUFLelksV0FBVyxJQUFJLENBQUVtWSxDQUFBQSxTQUFTLENBQUMsQ0FBQzdTLEtBQUtwTixrQkFBa0J1Z0IsS0FBSSxFQUFHTSxTQUFTLENBQUMsSUFBSVosU0FBUyxDQUFDN1MsR0FBRzBULFNBQVMsQ0FBQyxHQUFJO1lBQ3RNUCxPQUFPQSxLQUFLclQsVUFBVTtRQUN4QjtRQUVBbkYsTUFBTWdaLFNBQVMsR0FBR1IsUUFBUUEsU0FBUzVWLFVBQVUsQ0FBQ3RPLFlBQVlra0IsU0FBVU4sQ0FBQUEsU0FBUyxDQUFDLENBQUM3UyxLQUFLcE4sa0JBQWtCdWdCLEtBQUksRUFBR00sU0FBUyxDQUFDLElBQUlaLFNBQVMsQ0FBQzdTLEdBQUcwVCxTQUFTLENBQUM7UUFDbEovWSxNQUFNMFksVUFBVSxHQUFHclU7SUFDckI7SUFFQSxJQUFJckUsTUFBTWdaLFNBQVMsSUFBSVQsU0FBUyxLQUFLO1FBQ25DRCxNQUFNVyxlQUFlO1FBQ3JCWCxNQUFNWSxVQUFVLEdBQUc7SUFDckI7QUFDRixHQUNJLDBJQUEwSTtBQUM5SUMsaUJBQWlCLFNBQVNBLGVBQWV2VyxNQUFNLEVBQUUzUCxJQUFJLEVBQUVtbUIsTUFBTSxFQUFFQyxNQUFNO0lBQ25FLE9BQU94cEIsa0RBQVFBLENBQUNrbkIsTUFBTSxDQUFDO1FBQ3JCblUsUUFBUUE7UUFDUnJILFNBQVM7UUFDVCtkLFVBQVU7UUFDVkMsVUFBVTtRQUNWdG1CLE1BQU1BO1FBQ051bUIsU0FBU0gsU0FBU0EsVUFBVWpCO1FBQzVCcUIsU0FBU0o7UUFDVEssUUFBUUw7UUFDUk0sVUFBVU47UUFDVk8sVUFBVSxTQUFTQTtZQUNqQixPQUFPUixVQUFVL2QsYUFBYTVLLE1BQU1aLGtEQUFRQSxDQUFDZ3FCLFVBQVUsQ0FBQyxFQUFFLEVBQUVDLGdCQUFnQixPQUFPO1FBQ3JGO1FBQ0FDLFdBQVcsU0FBU0E7WUFDbEIsT0FBT3JlLGdCQUFnQmpMLE1BQU1aLGtEQUFRQSxDQUFDZ3FCLFVBQVUsQ0FBQyxFQUFFLEVBQUVDLGdCQUFnQjtRQUN2RTtJQUNGO0FBQ0YsR0FDSUUsWUFBWSxrQ0FDWkMsaUJBQ0FILGlCQUFpQixTQUFTQSxlQUFldmxCLENBQUM7SUFDNUMsSUFBSTJsQixVQUFVRixVQUFVdFMsSUFBSSxDQUFDblQsRUFBRXFPLE1BQU0sQ0FBQ3VYLE9BQU87SUFFN0MsSUFBSUQsV0FBV0QsaUJBQWlCO1FBQzlCMWxCLEVBQUUya0IsVUFBVSxHQUFHO1FBQ2ZlLGtCQUFrQkM7SUFDcEI7QUFDRixHQUNJRSx1QkFBdUIsU0FBU0EscUJBQXFCbmIsSUFBSTtJQUMzRDlJLFVBQVU4SSxTQUFVQSxDQUFBQSxPQUFPLENBQUM7SUFDNUJBLEtBQUtvYixjQUFjLEdBQUdwYixLQUFLcWIsWUFBWSxHQUFHcmIsS0FBS3NiLFdBQVcsR0FBRztJQUM3RHRiLEtBQUtoTSxJQUFJLElBQUtnTSxDQUFBQSxLQUFLaE0sSUFBSSxHQUFHLGFBQVk7SUFDdENnTSxLQUFLcWEsUUFBUSxHQUFHLENBQUMsQ0FBQ3JhLEtBQUtxYSxRQUFRO0lBQy9CcmEsS0FBS2lELEVBQUUsR0FBR2pELEtBQUtpRCxFQUFFLElBQUk7SUFFckIsSUFBSXNZLFNBQVN2YixNQUNUd2IsbUJBQW1CRCxPQUFPQyxnQkFBZ0IsRUFDMUNDLFdBQVdGLE9BQU9FLFFBQVEsRUFDMUJDLG9CQUFvQkgsT0FBT0csaUJBQWlCLEVBQzVDQyxZQUFZSixPQUFPSSxTQUFTLEVBQzVCMW5CLE1BQ0EybkIsTUFDQWpZLFNBQVM5Uyx3REFBVUEsQ0FBQ21QLEtBQUsyRCxNQUFNLEtBQUtsUyxRQUNwQ29xQixXQUFXeHFCLEtBQUtzVixJQUFJLENBQUNpUCxPQUFPLEdBQUdrRyxjQUFjLEVBQzdDQyxtQkFBbUJGLFlBQVlBLFNBQVNHLEdBQUcsSUFDM0NqTCxVQUFVaGUsY0FBZWlOLENBQUFBLEtBQUsrUSxPQUFPLElBQUlsZ0Isd0RBQVVBLENBQUNtUCxLQUFLK1EsT0FBTyxLQUFLZ0wsb0JBQW9CL2IsS0FBSytRLE9BQU8sS0FBSyxTQUFTLENBQUNnTCxpQkFBaUJyWSxNQUFNLE1BQU1xWSxpQkFBaUJoTCxPQUFPLEVBQUMsR0FDMUtrTCxjQUFjL3FCLDREQUFjQSxDQUFDeVMsUUFBUTdTLG1EQUFTQSxHQUM5Q29yQixjQUFjaHJCLDREQUFjQSxDQUFDeVMsUUFBUTVTLHFEQUFXQSxHQUNoRG9KLFFBQVEsR0FDUmdpQixlQUFlLENBQUN2ckIsa0RBQVFBLENBQUNtWixPQUFPLElBQUl4WSxLQUFLNnFCLGNBQWMsR0FBRzdxQixLQUFLNnFCLGNBQWMsQ0FBQ2ppQixLQUFLLEdBQUc1SSxLQUFLNnFCLGNBQWMsQ0FBQ3htQixLQUFLLEdBQUdyRSxLQUFLOHFCLFVBQVUsSUFBSTlxQixLQUFLc0UsVUFBVSxFQUNwSnltQixlQUFlLEdBQ2ZDLDBCQUEwQnZsQixZQUFZeWtCLFlBQVk7UUFDcEQsT0FBT0EsU0FBU3huQjtJQUNsQixJQUFJO1FBQ0YsT0FBT3duQixZQUFZO0lBQ3JCLEdBQ0llLGVBQ0FDLGVBQ0FDLGdCQUFnQnhDLGVBQWV2VyxRQUFRM0QsS0FBS2hNLElBQUksRUFBRSxNQUFNMG5CLG9CQUN4RGlCLGtCQUFrQixTQUFTQTtRQUM3QixPQUFPRixnQkFBZ0I7SUFDekIsR0FDSUcsZUFBZWhvQixjQUNmaW9CLGVBQWVqb0IsY0FDZmtvQixlQUFlLFNBQVNBO1FBQzFCbEIsT0FBT3BsQixXQUFXbU4sUUFBUTdTLG1EQUFTQTtRQUNuQytyQixlQUFlL3FCLE9BQU9pQixhQUFhLElBQUksR0FBRzZvQjtRQUMxQ0osb0JBQXFCb0IsQ0FBQUEsZUFBZTlxQixPQUFPLEdBQUcwRSxXQUFXbU4sUUFBUTVTLHFEQUFXQSxFQUFDO1FBQzdFeXJCLGdCQUFnQjFaO0lBQ2xCLEdBQ0lpYSxzQkFBc0IsU0FBU0E7UUFDakNoTSxRQUFRakwsS0FBSyxDQUFDak0sQ0FBQyxHQUFHL0UsT0FBT3FKLFdBQVc0UyxRQUFRakwsS0FBSyxDQUFDak0sQ0FBQyxJQUFJb2lCLFlBQVl6ZCxNQUFNLElBQUk7UUFDN0V1UyxRQUFRM1gsS0FBSyxDQUFDNGpCLFNBQVMsR0FBRyxxREFBcUQ3ZSxXQUFXNFMsUUFBUWpMLEtBQUssQ0FBQ2pNLENBQUMsSUFBSTtRQUM3R29pQixZQUFZemQsTUFBTSxHQUFHeWQsWUFBWXRaLE9BQU8sR0FBRztJQUM3QyxHQUNJc2EsYUFBYSxTQUFTQTtRQUN4QixJQUFJUixlQUFlO1lBQ2pCaG9CLHNCQUFzQmtvQjtZQUV0QixJQUFJbmUsU0FBUzFKLE9BQU9iLEtBQUtpcEIsTUFBTSxHQUFHLElBQzlCNVgsU0FBU3VYLGFBQWFaLFlBQVlwbkIsQ0FBQyxHQUFHMko7WUFFMUMsSUFBSXVTLFdBQVd6TCxXQUFXMlcsWUFBWXBuQixDQUFDLEdBQUdvbkIsWUFBWXpkLE1BQU0sRUFBRTtnQkFDNUR5ZCxZQUFZemQsTUFBTSxHQUFHOEcsU0FBUzJXLFlBQVlwbkIsQ0FBQztnQkFFM0MsSUFBSWdGLElBQUkvRSxPQUFPLENBQUNxSixXQUFXNFMsV0FBV0EsUUFBUWpMLEtBQUssQ0FBQ2pNLENBQUMsS0FBSyxLQUFLb2lCLFlBQVl6ZCxNQUFNO2dCQUVqRnVTLFFBQVEzWCxLQUFLLENBQUM0akIsU0FBUyxHQUFHLHFEQUFxRG5qQixJQUFJO2dCQUNuRmtYLFFBQVFqTCxLQUFLLENBQUNqTSxDQUFDLEdBQUdBLElBQUk7Z0JBQ3RCb2lCLFlBQVl0WixPQUFPLEdBQUczUixvREFBVUEsQ0FBQytQLEtBQUs7Z0JBRXRDTDtZQUNGO1lBRUEsT0FBTztRQUNUO1FBRUF1YixZQUFZemQsTUFBTSxJQUFJdWU7UUFDdEJOLGdCQUFnQjtJQUNsQixHQUNJL2lCLE9BQ0F5akIsY0FDQUMsY0FDQUMsbUJBQ0FDLFdBQVcsU0FBU0E7UUFDdEIsaVBBQWlQO1FBQ2pQUjtRQUVBLElBQUlwakIsTUFBTTJXLFFBQVEsTUFBTTNXLE1BQU1zRyxJQUFJLENBQUN1ZCxPQUFPLEdBQUczQixNQUFNO1lBQ2pESyxnQkFBZ0JMLE9BQU9saUIsTUFBTW5DLFFBQVEsQ0FBQyxNQUFNMGtCLFlBQVlMLFFBQVFsaUIsTUFBTXdXLE9BQU8sQ0FBQyxXQUFXMEw7UUFDM0Y7SUFDRjtJQUVBN0ssV0FBVzFmLEtBQUtnUCxHQUFHLENBQUMwUSxTQUFTO1FBQzNCbFgsR0FBRztJQUNMLElBQUksNENBQTRDO0lBRWhEbUcsS0FBS3dkLFdBQVcsR0FBRyxTQUFVbG9CLENBQUM7UUFDNUIsT0FBT3ZDLGNBQWN1QyxFQUFFdEIsSUFBSSxLQUFLLGVBQWVpcEIsV0FBVzNuQixNQUFNNkUsUUFBUSxRQUFRN0UsRUFBRXRCLElBQUksS0FBSyxnQkFBZ0JDLEtBQUt3cEIsV0FBVyxJQUFJbm9CLEVBQUVvb0IsT0FBTyxJQUFJcG9CLEVBQUVvb0IsT0FBTyxDQUFDcHBCLE1BQU0sR0FBRztJQUNqSztJQUVBMEwsS0FBS3dhLE9BQU8sR0FBRztRQUNiaUMsZ0JBQWdCO1FBQ2hCLElBQUlrQixZQUFZeGpCO1FBQ2hCQSxRQUFRckYsT0FBTyxDQUFDdkQsS0FBSzZxQixjQUFjLElBQUk3cUIsS0FBSzZxQixjQUFjLENBQUNqaUIsS0FBSyxJQUFJLEtBQUtnaUI7UUFDekV6aUIsTUFBTXBDLEtBQUs7UUFDWHFtQixjQUFjeGpCLFNBQVM0ZSxvQkFBb0JwVixRQUFReEosUUFBUSxPQUFPLE9BQU9xaEIsbUJBQW1CLFFBQVE7UUFDcEcyQixlQUFlakI7UUFDZmtCLGVBQWVuQjtRQUNmYTtRQUNBTixnQkFBZ0IxWjtJQUNsQjtJQUVBOUMsS0FBSzJiLFNBQVMsR0FBRzNiLEtBQUs0ZCxjQUFjLEdBQUcsU0FBVTNwQixJQUFJLEVBQUU0cEIsV0FBVztRQUNoRTVCLFlBQVl6ZCxNQUFNLElBQUl1ZTtRQUV0QixJQUFJLENBQUNjLGFBQWE7WUFDaEJSLGtCQUFrQi9iLE9BQU8sQ0FBQztRQUM1QixPQUFPO1lBQ0x0USxvREFBVUEsQ0FBQytQLEtBQUssSUFBSSwrQ0FBK0M7WUFDbkUseU5BQXlOO1lBRXpOLElBQUkrYyxNQUFNdkIsMkJBQ053QixlQUNBbk87WUFFSixJQUFJNEwsa0JBQWtCO2dCQUNwQnVDLGdCQUFnQjdCO2dCQUNoQnRNLFlBQVltTyxnQkFBZ0JELE1BQU0sT0FBTyxDQUFDN3BCLEtBQUsrcEIsU0FBUyxHQUFHLE9BQU8saUhBQWlIO2dCQUVuTEYsT0FBT2hGLHFDQUFxQ29ELGFBQWE2QixlQUFlbk8sV0FBV3BaLFdBQVdtTixRQUFRNVMscURBQVdBO2dCQUNqSDJJLE1BQU1zRyxJQUFJLENBQUNpZSxPQUFPLEdBQUdyQixhQUFhaE47WUFDcEM7WUFFQW1PLGdCQUFnQjlCO1lBQ2hCck0sWUFBWW1PLGdCQUFnQkQsTUFBTSxPQUFPLENBQUM3cEIsS0FBS2lxQixTQUFTLEdBQUcsT0FBTyx5Q0FBeUM7WUFFM0dKLE9BQU9oRixxQ0FBcUNtRCxhQUFhOEIsZUFBZW5PLFdBQVdwWixXQUFXbU4sUUFBUTdTLG1EQUFTQTtZQUMvRzRJLE1BQU1zRyxJQUFJLENBQUN1ZCxPQUFPLEdBQUdWLGFBQWFqTjtZQUNsQ2xXLE1BQU1rWSxVQUFVLEdBQUc5VyxRQUFRLENBQUNnakIsS0FBS0ssSUFBSSxDQUFDO1lBRXRDLElBQUlwckIsY0FBYzJHLE1BQU1zRyxJQUFJLENBQUN1ZCxPQUFPLElBQUkzQixRQUFRbUMsaUJBQWlCbkMsT0FBTyxHQUFHO2dCQUN6RSxvTEFBb0w7Z0JBQ3BMdnFCLEtBQUtzSSxFQUFFLENBQUMsQ0FBQyxHQUFHO29CQUNWa1EsVUFBVXlUO29CQUNWeGlCLFVBQVVnakI7Z0JBQ1o7WUFDRjtRQUNGO1FBRUFuQyxhQUFhQSxVQUFVMW5CO0lBQ3pCO0lBRUErTCxLQUFLdWEsT0FBTyxHQUFHO1FBQ2I3Z0IsTUFBTTBrQixHQUFHLElBQUkxa0IsTUFBTXBDLEtBQUs7UUFFeEIsSUFBSTlELGFBQWE4b0IsZUFBZSxNQUFNO1lBQ3BDLGtJQUFrSTtZQUNsSUUsZ0JBQWdCO1lBQ2hCRixlQUFlOW9CO1FBQ2pCO0lBQ0Y7SUFFQXdNLEtBQUtxZSxRQUFRLEdBQUcsU0FBVXBxQixJQUFJLEVBQUVxcUIsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLE1BQU0sRUFBRUMsTUFBTTtRQUNwRDNiLGVBQWUwWixpQkFBaUJNO1FBQ2hDd0IsTUFBTTlDLG9CQUFvQlUsWUFBWVUsYUFBYTRCLE1BQU0sQ0FBQyxFQUFFLEtBQUtGLEtBQUtuQixlQUFnQmxwQixDQUFBQSxLQUFLNE0sTUFBTSxHQUFHNU0sS0FBSzJGLENBQUMsSUFBSXNpQixnQkFBZ0JvQyxLQUFLRSxNQUFNLENBQUMsRUFBRSxJQUFJLDZGQUE2RjtRQUU3TyxJQUFJRCxJQUFJO1lBQ050QyxZQUFZemQsTUFBTSxJQUFJdWU7WUFDdEIsSUFBSWhULFVBQVUwVSxNQUFNLENBQUMsRUFBRSxLQUFLRixJQUN4QjFrQixJQUFJa1EsVUFBVXFULGVBQWVucEIsS0FBS3lxQixNQUFNLEdBQUd6cUIsS0FBSzRGLENBQUMsR0FBR29pQixnQkFBZ0JzQyxLQUFLRSxNQUFNLENBQUMsRUFBRSxFQUNsRkUsV0FBVzlCLGFBQWFoakI7WUFDNUJrUSxXQUFXbFEsTUFBTThrQixZQUFhdkIsQ0FBQUEsZ0JBQWdCdUIsV0FBVzlrQixDQUFBQTtZQUN6RG9pQixZQUFZMEM7UUFDZDtRQUVDSixDQUFBQSxNQUFNRCxFQUFDLEtBQU01ZDtJQUNoQjtJQUVBVixLQUFLMmEsUUFBUSxHQUFHO1FBQ2Q1QixvQkFBb0JwVixRQUFRNlgsbUJBQW1CLFFBQVE7UUFFdkQ5WixjQUFjbkYsZ0JBQWdCLENBQUMsV0FBVytnQjtRQUUxQ2xoQixhQUFhN0ssTUFBTSxVQUFVK3JCO1FBRTdCLElBQUlyQixZQUFZdlksTUFBTSxFQUFFO1lBQ3RCdVksWUFBWXRZLE1BQU0sQ0FBQ3ZLLEtBQUssQ0FBQ3dLLGNBQWMsR0FBRztZQUMxQ3FZLFlBQVl2WSxNQUFNLEdBQUd3WSxZQUFZeFksTUFBTSxHQUFHO1FBQzVDO1FBRUFnWixjQUFjakksTUFBTTtJQUN0QjtJQUVBelUsS0FBSzhhLFNBQVMsR0FBRztRQUNmL0Isb0JBQW9CcFYsUUFBUTtRQUU1QmxILGdCQUFnQmxMLE1BQU0sVUFBVStyQjtRQUVoQzViLGNBQWNoRixtQkFBbUIsQ0FBQyxXQUFXNGdCO1FBQzdDWixjQUFjbGlCLElBQUk7SUFDcEI7SUFFQXdGLEtBQUtzYSxRQUFRLEdBQUd0YSxLQUFLc2EsUUFBUSxLQUFLO0lBQ2xDcm1CLE9BQU8sSUFBSXJELGtEQUFRQSxDQUFDb1A7SUFDcEIvTCxLQUFLMnFCLEdBQUcsR0FBRzdyQixZQUFZLHNLQUFzSztJQUU3TEEsY0FBYyxDQUFDa3BCLGlCQUFpQkEsWUFBWSxJQUFJLDRHQUE0RztJQUU1SmxwQixjQUFjMUIsS0FBS3d0QixNQUFNLENBQUNqbkIsR0FBRyxDQUFDaEQsZUFBZSxtQ0FBbUM7SUFFaEZ5b0Isb0JBQW9CcHBCLEtBQUs2cUIsR0FBRztJQUM1QnBsQixRQUFRckksS0FBS3NJLEVBQUUsQ0FBQzFGLE1BQU07UUFDcEJ1YSxNQUFNO1FBQ05FLFFBQVE7UUFDUi9FLFNBQVM7UUFDVHNVLFNBQVN6QyxtQkFBbUIsVUFBVTtRQUN0QytCLFNBQVM7UUFDVDlULFdBQVc7WUFDVDhULFNBQVM3VSxxQkFBcUJ1VCxhQUFhQSxlQUFlO2dCQUN4RCxPQUFPdmlCLE1BQU1wQyxLQUFLO1lBQ3BCO1FBQ0Y7UUFDQXVTLFVBQVVuSjtRQUNWOEksWUFBWTZULGtCQUFrQnJkLElBQUksQ0FBQ3dKLFVBQVU7SUFDL0MsSUFBSSx3S0FBd0s7SUFFNUssT0FBT3ZWO0FBQ1Q7QUFFQXlOLGNBQWNsRyxJQUFJLEdBQUcsU0FBVTNFLElBQUk7SUFDakMsT0FBT3lKLFVBQVU5RSxJQUFJLENBQUMzRSxRQUFRLFNBQVVQLENBQUMsRUFBRW1GLENBQUM7UUFDMUMsT0FBTyxDQUFDbkYsRUFBRTBKLElBQUksQ0FBQ3FPLGVBQWUsSUFBSSxLQUFLLENBQUMsTUFBTS9YLEVBQUV3SixLQUFLLEdBQUlyRSxDQUFBQSxFQUFFcUUsS0FBSyxHQUFHLENBQUNyRSxFQUFFdUUsSUFBSSxDQUFDcU8sZUFBZSxJQUFJLEtBQUssQ0FBQyxHQUFFO0lBQ3hHO0FBQ0Y7QUFFQTNNLGNBQWNxZCxPQUFPLEdBQUcsU0FBVS9lLElBQUk7SUFDcEMsT0FBTyxJQUFJcFAsa0RBQVFBLENBQUNvUDtBQUN0QjtBQUVBMEIsY0FBY3NkLGVBQWUsR0FBRyxTQUFVaGYsSUFBSTtJQUM1QyxJQUFJLE9BQU9BLFNBQVMsYUFBYTtRQUMvQixPQUFPck47SUFDVDtJQUVBLElBQUlxTixTQUFTLFFBQVFyTixhQUFhO1FBQ2hDLE9BQU9BLFlBQVk4aEIsTUFBTTtJQUMzQjtJQUVBLElBQUl6VSxTQUFTLE9BQU87UUFDbEJyTixlQUFlQSxZQUFZNkgsSUFBSTtRQUMvQjdILGNBQWNxTjtRQUNkO0lBQ0Y7SUFFQSxJQUFJaWYsYUFBYWpmLGdCQUFnQnBQLGtEQUFRQSxHQUFHb1AsT0FBT21iLHFCQUFxQm5iO0lBQ3hFck4sZUFBZUEsWUFBWWdSLE1BQU0sS0FBS3NiLFdBQVd0YixNQUFNLElBQUloUixZQUFZNkgsSUFBSTtJQUMzRW5GLFlBQVk0cEIsV0FBV3RiLE1BQU0sS0FBTWhSLENBQUFBLGNBQWNzc0IsVUFBUztJQUMxRCxPQUFPQTtBQUNUO0FBRUF2ZCxjQUFjaUYsSUFBSSxHQUFHO0lBQ25CLG1FQUFtRTtJQUNuRXZWLGtCQUFrQkEsMERBQWdCQTtJQUNsQzhvQixnQkFBZ0JBO0lBQ2hCbHBCLFlBQVlBLG9EQUFVQTtJQUN0QkMsVUFBVUEsa0RBQVFBO0lBQ2xCaXVCLFFBQVE7UUFDTixpRUFBaUU7UUFDakVDLElBQUksU0FBU0E7WUFDWHZyQixtQkFBbUJvTixVQUFVO1lBQzdCcE4sa0JBQWtCSjtRQUNwQjtRQUNBLGlEQUFpRDtRQUNqRDRyQixLQUFLLFNBQVNBO1lBQ1osT0FBT250QjtRQUNUO0lBQ0Y7QUFDRjtBQUNBa0QsY0FBYzlELEtBQUsrRCxjQUFjLENBQUNzTTtBQUNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9TY3JvbGxUcmlnZ2VyLmpzPzYyYTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBTY3JvbGxUcmlnZ2VyIDMuMTIuNVxuICogaHR0cHM6Ly9nc2FwLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjQsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3NhcC5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR1NBUCBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCB7IE9ic2VydmVyLCBfZ2V0VGFyZ2V0LCBfdmVydGljYWwsIF9ob3Jpem9udGFsLCBfc2Nyb2xsZXJzLCBfcHJveGllcywgX2dldFNjcm9sbEZ1bmMsIF9nZXRQcm94eVByb3AsIF9nZXRWZWxvY2l0eVByb3AgfSBmcm9tIFwiLi9PYnNlcnZlci5qc1wiO1xuXG52YXIgZ3NhcCxcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX3dpbixcbiAgICBfZG9jLFxuICAgIF9kb2NFbCxcbiAgICBfYm9keSxcbiAgICBfcm9vdCxcbiAgICBfcmVzaXplRGVsYXksXG4gICAgX3RvQXJyYXksXG4gICAgX2NsYW1wLFxuICAgIF90aW1lMixcbiAgICBfc3luY0ludGVydmFsLFxuICAgIF9yZWZyZXNoaW5nLFxuICAgIF9wb2ludGVySXNEb3duLFxuICAgIF90cmFuc2Zvcm1Qcm9wLFxuICAgIF9pLFxuICAgIF9wcmV2V2lkdGgsXG4gICAgX3ByZXZIZWlnaHQsXG4gICAgX2F1dG9SZWZyZXNoLFxuICAgIF9zb3J0LFxuICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMsXG4gICAgX2lnbm9yZVJlc2l6ZSxcbiAgICBfbm9ybWFsaXplcixcbiAgICBfaWdub3JlTW9iaWxlUmVzaXplLFxuICAgIF9iYXNlU2NyZWVuSGVpZ2h0LFxuICAgIF9iYXNlU2NyZWVuV2lkdGgsXG4gICAgX2ZpeElPU0J1ZyxcbiAgICBfY29udGV4dCxcbiAgICBfc2Nyb2xsUmVzdG9yYXRpb24sXG4gICAgX2RpdjEwMHZoLFxuICAgIF8xMDB2aCxcbiAgICBfaXNSZXZlcnRlZCxcbiAgICBfY2xhbXBpbmdNYXgsXG4gICAgX2xpbWl0Q2FsbGJhY2tzLFxuICAgIC8vIGlmIHRydWUsIHdlJ2xsIG9ubHkgdHJpZ2dlciBjYWxsYmFja3MgaWYgdGhlIGFjdGl2ZSBzdGF0ZSB0b2dnbGVzLCBzbyBpZiB5b3Ugc2Nyb2xsIGltbWVkaWF0ZWx5IHBhc3QgYm90aCB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgb2YgYSBTY3JvbGxUcmlnZ2VyICh0aHVzIGluYWN0aXZlIHRvIGluYWN0aXZlKSwgbmVpdGhlciBpdHMgb25FbnRlciBub3Igb25MZWF2ZSB3aWxsIGJlIGNhbGxlZC4gVGhpcyBpcyB1c2VmdWwgZHVyaW5nIHN0YXJ0dXAuXG5fc3RhcnR1cCA9IDEsXG4gICAgX2dldFRpbWUgPSBEYXRlLm5vdyxcbiAgICBfdGltZTEgPSBfZ2V0VGltZSgpLFxuICAgIF9sYXN0U2Nyb2xsVGltZSA9IDAsXG4gICAgX2VuYWJsZWQgPSAwLFxuICAgIF9wYXJzZUNsYW1wID0gZnVuY3Rpb24gX3BhcnNlQ2xhbXAodmFsdWUsIHR5cGUsIHNlbGYpIHtcbiAgdmFyIGNsYW1wID0gX2lzU3RyaW5nKHZhbHVlKSAmJiAodmFsdWUuc3Vic3RyKDAsIDYpID09PSBcImNsYW1wKFwiIHx8IHZhbHVlLmluZGV4T2YoXCJtYXhcIikgPiAtMSk7XG4gIHNlbGZbXCJfXCIgKyB0eXBlICsgXCJDbGFtcFwiXSA9IGNsYW1wO1xuICByZXR1cm4gY2xhbXAgPyB2YWx1ZS5zdWJzdHIoNiwgdmFsdWUubGVuZ3RoIC0gNykgOiB2YWx1ZTtcbn0sXG4gICAgX2tlZXBDbGFtcCA9IGZ1bmN0aW9uIF9rZWVwQ2xhbXAodmFsdWUsIGNsYW1wKSB7XG4gIHJldHVybiBjbGFtcCAmJiAoIV9pc1N0cmluZyh2YWx1ZSkgfHwgdmFsdWUuc3Vic3RyKDAsIDYpICE9PSBcImNsYW1wKFwiKSA/IFwiY2xhbXAoXCIgKyB2YWx1ZSArIFwiKVwiIDogdmFsdWU7XG59LFxuICAgIF9yYWZCdWdGaXggPSBmdW5jdGlvbiBfcmFmQnVnRml4KCkge1xuICByZXR1cm4gX2VuYWJsZWQgJiYgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF9yYWZCdWdGaXgpO1xufSxcbiAgICAvLyBpbiBzb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpLCBzY3JlZW4gcmVwYWludHMgd2VyZW4ndCBjb25zaXN0ZW50IHVubGVzcyB3ZSBoYWQgU09NRVRISU5HIHF1ZXVlZCB1cCBpbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSEgU28gdGhpcyBqdXN0IGNyZWF0ZXMgYSBzdXBlciBzaW1wbGUgbG9vcCB0byBrZWVwIGl0IGFsaXZlIGFuZCBzbW9vdGggb3V0IHJlcGFpbnRzLlxuX3BvaW50ZXJEb3duSGFuZGxlciA9IGZ1bmN0aW9uIF9wb2ludGVyRG93bkhhbmRsZXIoKSB7XG4gIHJldHVybiBfcG9pbnRlcklzRG93biA9IDE7XG59LFxuICAgIF9wb2ludGVyVXBIYW5kbGVyID0gZnVuY3Rpb24gX3BvaW50ZXJVcEhhbmRsZXIoKSB7XG4gIHJldHVybiBfcG9pbnRlcklzRG93biA9IDA7XG59LFxuICAgIF9wYXNzVGhyb3VnaCA9IGZ1bmN0aW9uIF9wYXNzVGhyb3VnaCh2KSB7XG4gIHJldHVybiB2O1xufSxcbiAgICBfcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMDApIC8gMTAwMDAwIHx8IDA7XG59LFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgX3dpbmRvd0V4aXN0cygpICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX2lzVmlld3BvcnQgPSBmdW5jdGlvbiBfaXNWaWV3cG9ydChlKSB7XG4gIHJldHVybiAhIX5fcm9vdC5pbmRleE9mKGUpO1xufSxcbiAgICBfZ2V0Vmlld3BvcnREaW1lbnNpb24gPSBmdW5jdGlvbiBfZ2V0Vmlld3BvcnREaW1lbnNpb24oZGltZW5zaW9uUHJvcGVydHkpIHtcbiAgcmV0dXJuIChkaW1lbnNpb25Qcm9wZXJ0eSA9PT0gXCJIZWlnaHRcIiA/IF8xMDB2aCA6IF93aW5bXCJpbm5lclwiICsgZGltZW5zaW9uUHJvcGVydHldKSB8fCBfZG9jRWxbXCJjbGllbnRcIiArIGRpbWVuc2lvblByb3BlcnR5XSB8fCBfYm9keVtcImNsaWVudFwiICsgZGltZW5zaW9uUHJvcGVydHldO1xufSxcbiAgICBfZ2V0Qm91bmRzRnVuYyA9IGZ1bmN0aW9uIF9nZXRCb3VuZHNGdW5jKGVsZW1lbnQpIHtcbiAgcmV0dXJuIF9nZXRQcm94eVByb3AoZWxlbWVudCwgXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcIikgfHwgKF9pc1ZpZXdwb3J0KGVsZW1lbnQpID8gZnVuY3Rpb24gKCkge1xuICAgIF93aW5PZmZzZXRzLndpZHRoID0gX3dpbi5pbm5lcldpZHRoO1xuICAgIF93aW5PZmZzZXRzLmhlaWdodCA9IF8xMDB2aDtcbiAgICByZXR1cm4gX3dpbk9mZnNldHM7XG4gIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9nZXRCb3VuZHMoZWxlbWVudCk7XG4gIH0pO1xufSxcbiAgICBfZ2V0U2l6ZUZ1bmMgPSBmdW5jdGlvbiBfZ2V0U2l6ZUZ1bmMoc2Nyb2xsZXIsIGlzVmlld3BvcnQsIF9yZWYpIHtcbiAgdmFyIGQgPSBfcmVmLmQsXG4gICAgICBkMiA9IF9yZWYuZDIsXG4gICAgICBhID0gX3JlZi5hO1xuICByZXR1cm4gKGEgPSBfZ2V0UHJveHlQcm9wKHNjcm9sbGVyLCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiKSkgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGEoKVtkXTtcbiAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKGlzVmlld3BvcnQgPyBfZ2V0Vmlld3BvcnREaW1lbnNpb24oZDIpIDogc2Nyb2xsZXJbXCJjbGllbnRcIiArIGQyXSkgfHwgMDtcbiAgfTtcbn0sXG4gICAgX2dldE9mZnNldHNGdW5jID0gZnVuY3Rpb24gX2dldE9mZnNldHNGdW5jKGVsZW1lbnQsIGlzVmlld3BvcnQpIHtcbiAgcmV0dXJuICFpc1ZpZXdwb3J0IHx8IH5fcHJveGllcy5pbmRleE9mKGVsZW1lbnQpID8gX2dldEJvdW5kc0Z1bmMoZWxlbWVudCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF93aW5PZmZzZXRzO1xuICB9O1xufSxcbiAgICBfbWF4U2Nyb2xsID0gZnVuY3Rpb24gX21heFNjcm9sbChlbGVtZW50LCBfcmVmMikge1xuICB2YXIgcyA9IF9yZWYyLnMsXG4gICAgICBkMiA9IF9yZWYyLmQyLFxuICAgICAgZCA9IF9yZWYyLmQsXG4gICAgICBhID0gX3JlZjIuYTtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIChzID0gXCJzY3JvbGxcIiArIGQyKSAmJiAoYSA9IF9nZXRQcm94eVByb3AoZWxlbWVudCwgcykpID8gYSgpIC0gX2dldEJvdW5kc0Z1bmMoZWxlbWVudCkoKVtkXSA6IF9pc1ZpZXdwb3J0KGVsZW1lbnQpID8gKF9kb2NFbFtzXSB8fCBfYm9keVtzXSkgLSBfZ2V0Vmlld3BvcnREaW1lbnNpb24oZDIpIDogZWxlbWVudFtzXSAtIGVsZW1lbnRbXCJvZmZzZXRcIiArIGQyXSk7XG59LFxuICAgIF9pdGVyYXRlQXV0b1JlZnJlc2ggPSBmdW5jdGlvbiBfaXRlcmF0ZUF1dG9SZWZyZXNoKGZ1bmMsIGV2ZW50cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IF9hdXRvUmVmcmVzaC5sZW5ndGg7IGkgKz0gMykge1xuICAgICghZXZlbnRzIHx8IH5ldmVudHMuaW5kZXhPZihfYXV0b1JlZnJlc2hbaSArIDFdKSkgJiYgZnVuYyhfYXV0b1JlZnJlc2hbaV0sIF9hdXRvUmVmcmVzaFtpICsgMV0sIF9hdXRvUmVmcmVzaFtpICsgMl0pO1xuICB9XG59LFxuICAgIF9pc1N0cmluZyA9IGZ1bmN0aW9uIF9pc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufSxcbiAgICBfaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIF9pc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn0sXG4gICAgX2lzTnVtYmVyID0gZnVuY3Rpb24gX2lzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG59LFxuICAgIF9pc09iamVjdCA9IGZ1bmN0aW9uIF9pc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufSxcbiAgICBfZW5kQW5pbWF0aW9uID0gZnVuY3Rpb24gX2VuZEFuaW1hdGlvbihhbmltYXRpb24sIHJldmVyc2VkLCBwYXVzZSkge1xuICByZXR1cm4gYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5wcm9ncmVzcyhyZXZlcnNlZCA/IDAgOiAxKSAmJiBwYXVzZSAmJiBhbmltYXRpb24ucGF1c2UoKTtcbn0sXG4gICAgX2NhbGxiYWNrID0gZnVuY3Rpb24gX2NhbGxiYWNrKHNlbGYsIGZ1bmMpIHtcbiAgaWYgKHNlbGYuZW5hYmxlZCkge1xuICAgIHZhciByZXN1bHQgPSBzZWxmLl9jdHggPyBzZWxmLl9jdHguYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jKHNlbGYpO1xuICAgIH0pIDogZnVuYyhzZWxmKTtcbiAgICByZXN1bHQgJiYgcmVzdWx0LnRvdGFsVGltZSAmJiAoc2VsZi5jYWxsYmFja0FuaW1hdGlvbiA9IHJlc3VsdCk7XG4gIH1cbn0sXG4gICAgX2FicyA9IE1hdGguYWJzLFxuICAgIF9sZWZ0ID0gXCJsZWZ0XCIsXG4gICAgX3RvcCA9IFwidG9wXCIsXG4gICAgX3JpZ2h0ID0gXCJyaWdodFwiLFxuICAgIF9ib3R0b20gPSBcImJvdHRvbVwiLFxuICAgIF93aWR0aCA9IFwid2lkdGhcIixcbiAgICBfaGVpZ2h0ID0gXCJoZWlnaHRcIixcbiAgICBfUmlnaHQgPSBcIlJpZ2h0XCIsXG4gICAgX0xlZnQgPSBcIkxlZnRcIixcbiAgICBfVG9wID0gXCJUb3BcIixcbiAgICBfQm90dG9tID0gXCJCb3R0b21cIixcbiAgICBfcGFkZGluZyA9IFwicGFkZGluZ1wiLFxuICAgIF9tYXJnaW4gPSBcIm1hcmdpblwiLFxuICAgIF9XaWR0aCA9IFwiV2lkdGhcIixcbiAgICBfSGVpZ2h0ID0gXCJIZWlnaHRcIixcbiAgICBfcHggPSBcInB4XCIsXG4gICAgX2dldENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbiBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBfd2luLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59LFxuICAgIF9tYWtlUG9zaXRpb25hYmxlID0gZnVuY3Rpb24gX21ha2VQb3NpdGlvbmFibGUoZWxlbWVudCkge1xuICAvLyBpZiB0aGUgZWxlbWVudCBhbHJlYWR5IGhhcyBwb3NpdGlvbjogYWJzb2x1dGUgb3IgZml4ZWQsIGxlYXZlIHRoYXQsIG90aGVyd2lzZSBtYWtlIGl0IHBvc2l0aW9uOiByZWxhdGl2ZVxuICB2YXIgcG9zaXRpb24gPSBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbjtcblxuICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gcG9zaXRpb24gOiBcInJlbGF0aXZlXCI7XG59LFxuICAgIF9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIF9zZXREZWZhdWx0cyhvYmosIGRlZmF1bHRzKSB7XG4gIGZvciAodmFyIHAgaW4gZGVmYXVsdHMpIHtcbiAgICBwIGluIG9iaiB8fCAob2JqW3BdID0gZGVmYXVsdHNbcF0pO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0sXG4gICAgX2dldEJvdW5kcyA9IGZ1bmN0aW9uIF9nZXRCb3VuZHMoZWxlbWVudCwgd2l0aG91dFRyYW5zZm9ybXMpIHtcbiAgdmFyIHR3ZWVuID0gd2l0aG91dFRyYW5zZm9ybXMgJiYgX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudClbX3RyYW5zZm9ybVByb3BdICE9PSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiICYmIGdzYXAudG8oZWxlbWVudCwge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB4UGVyY2VudDogMCxcbiAgICB5UGVyY2VudDogMCxcbiAgICByb3RhdGlvbjogMCxcbiAgICByb3RhdGlvblg6IDAsXG4gICAgcm90YXRpb25ZOiAwLFxuICAgIHNjYWxlOiAxLFxuICAgIHNrZXdYOiAwLFxuICAgIHNrZXdZOiAwXG4gIH0pLnByb2dyZXNzKDEpLFxuICAgICAgYm91bmRzID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdHdlZW4gJiYgdHdlZW4ucHJvZ3Jlc3MoMCkua2lsbCgpO1xuICByZXR1cm4gYm91bmRzO1xufSxcbiAgICBfZ2V0U2l6ZSA9IGZ1bmN0aW9uIF9nZXRTaXplKGVsZW1lbnQsIF9yZWYzKSB7XG4gIHZhciBkMiA9IF9yZWYzLmQyO1xuICByZXR1cm4gZWxlbWVudFtcIm9mZnNldFwiICsgZDJdIHx8IGVsZW1lbnRbXCJjbGllbnRcIiArIGQyXSB8fCAwO1xufSxcbiAgICBfZ2V0TGFiZWxSYXRpb0FycmF5ID0gZnVuY3Rpb24gX2dldExhYmVsUmF0aW9BcnJheSh0aW1lbGluZSkge1xuICB2YXIgYSA9IFtdLFxuICAgICAgbGFiZWxzID0gdGltZWxpbmUubGFiZWxzLFxuICAgICAgZHVyYXRpb24gPSB0aW1lbGluZS5kdXJhdGlvbigpLFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gbGFiZWxzKSB7XG4gICAgYS5wdXNoKGxhYmVsc1twXSAvIGR1cmF0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBhO1xufSxcbiAgICBfZ2V0Q2xvc2VzdExhYmVsID0gZnVuY3Rpb24gX2dldENsb3Nlc3RMYWJlbChhbmltYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBnc2FwLnV0aWxzLnNuYXAoX2dldExhYmVsUmF0aW9BcnJheShhbmltYXRpb24pLCB2YWx1ZSk7XG4gIH07XG59LFxuICAgIF9zbmFwRGlyZWN0aW9uYWwgPSBmdW5jdGlvbiBfc25hcERpcmVjdGlvbmFsKHNuYXBJbmNyZW1lbnRPckFycmF5KSB7XG4gIHZhciBzbmFwID0gZ3NhcC51dGlscy5zbmFwKHNuYXBJbmNyZW1lbnRPckFycmF5KSxcbiAgICAgIGEgPSBBcnJheS5pc0FycmF5KHNuYXBJbmNyZW1lbnRPckFycmF5KSAmJiBzbmFwSW5jcmVtZW50T3JBcnJheS5zbGljZSgwKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xuICB9KTtcbiAgcmV0dXJuIGEgPyBmdW5jdGlvbiAodmFsdWUsIGRpcmVjdGlvbiwgdGhyZXNob2xkKSB7XG4gICAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJlc2hvbGQgPSAxZS0zO1xuICAgIH1cblxuICAgIHZhciBpO1xuXG4gICAgaWYgKCFkaXJlY3Rpb24pIHtcbiAgICAgIHJldHVybiBzbmFwKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xuICAgICAgdmFsdWUgLT0gdGhyZXNob2xkOyAvLyB0byBhdm9pZCByb3VuZGluZyBlcnJvcnMuIElmIHdlJ3JlIHRvbyBzdHJpY3QsIGl0IG1pZ2h0IHNuYXAgZm9yd2FyZCwgdGhlbiBpbW1lZGlhdGVseSBhZ2FpbiwgYW5kIGFnYWluLlxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSA+PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBhW2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhW2kgLSAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaSA9IGEubGVuZ3RoO1xuICAgICAgdmFsdWUgKz0gdGhyZXNob2xkO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmIChhW2ldIDw9IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGFbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYVswXTtcbiAgfSA6IGZ1bmN0aW9uICh2YWx1ZSwgZGlyZWN0aW9uLCB0aHJlc2hvbGQpIHtcbiAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICAgIHRocmVzaG9sZCA9IDFlLTM7XG4gICAgfVxuXG4gICAgdmFyIHNuYXBwZWQgPSBzbmFwKHZhbHVlKTtcbiAgICByZXR1cm4gIWRpcmVjdGlvbiB8fCBNYXRoLmFicyhzbmFwcGVkIC0gdmFsdWUpIDwgdGhyZXNob2xkIHx8IHNuYXBwZWQgLSB2YWx1ZSA8IDAgPT09IGRpcmVjdGlvbiA8IDAgPyBzbmFwcGVkIDogc25hcChkaXJlY3Rpb24gPCAwID8gdmFsdWUgLSBzbmFwSW5jcmVtZW50T3JBcnJheSA6IHZhbHVlICsgc25hcEluY3JlbWVudE9yQXJyYXkpO1xuICB9O1xufSxcbiAgICBfZ2V0TGFiZWxBdERpcmVjdGlvbiA9IGZ1bmN0aW9uIF9nZXRMYWJlbEF0RGlyZWN0aW9uKHRpbWVsaW5lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIHN0KSB7XG4gICAgcmV0dXJuIF9zbmFwRGlyZWN0aW9uYWwoX2dldExhYmVsUmF0aW9BcnJheSh0aW1lbGluZSkpKHZhbHVlLCBzdC5kaXJlY3Rpb24pO1xuICB9O1xufSxcbiAgICBfbXVsdGlMaXN0ZW5lciA9IGZ1bmN0aW9uIF9tdWx0aUxpc3RlbmVyKGZ1bmMsIGVsZW1lbnQsIHR5cGVzLCBjYWxsYmFjaykge1xuICByZXR1cm4gdHlwZXMuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICByZXR1cm4gZnVuYyhlbGVtZW50LCB0eXBlLCBjYWxsYmFjayk7XG4gIH0pO1xufSxcbiAgICBfYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBfYWRkTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgZnVuYywgbm9uUGFzc2l2ZSwgY2FwdHVyZSkge1xuICByZXR1cm4gZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmMsIHtcbiAgICBwYXNzaXZlOiAhbm9uUGFzc2l2ZSxcbiAgICBjYXB0dXJlOiAhIWNhcHR1cmVcbiAgfSk7XG59LFxuICAgIF9yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIF9yZW1vdmVMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBmdW5jLCBjYXB0dXJlKSB7XG4gIHJldHVybiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZnVuYywgISFjYXB0dXJlKTtcbn0sXG4gICAgX3doZWVsTGlzdGVuZXIgPSBmdW5jdGlvbiBfd2hlZWxMaXN0ZW5lcihmdW5jLCBlbCwgc2Nyb2xsRnVuYykge1xuICBzY3JvbGxGdW5jID0gc2Nyb2xsRnVuYyAmJiBzY3JvbGxGdW5jLndoZWVsSGFuZGxlcjtcblxuICBpZiAoc2Nyb2xsRnVuYykge1xuICAgIGZ1bmMoZWwsIFwid2hlZWxcIiwgc2Nyb2xsRnVuYyk7XG4gICAgZnVuYyhlbCwgXCJ0b3VjaG1vdmVcIiwgc2Nyb2xsRnVuYyk7XG4gIH1cbn0sXG4gICAgX21hcmtlckRlZmF1bHRzID0ge1xuICBzdGFydENvbG9yOiBcImdyZWVuXCIsXG4gIGVuZENvbG9yOiBcInJlZFwiLFxuICBpbmRlbnQ6IDAsXG4gIGZvbnRTaXplOiBcIjE2cHhcIixcbiAgZm9udFdlaWdodDogXCJub3JtYWxcIlxufSxcbiAgICBfZGVmYXVsdHMgPSB7XG4gIHRvZ2dsZUFjdGlvbnM6IFwicGxheVwiLFxuICBhbnRpY2lwYXRlUGluOiAwXG59LFxuICAgIF9rZXl3b3JkcyA9IHtcbiAgdG9wOiAwLFxuICBsZWZ0OiAwLFxuICBjZW50ZXI6IDAuNSxcbiAgYm90dG9tOiAxLFxuICByaWdodDogMVxufSxcbiAgICBfb2Zmc2V0VG9QeCA9IGZ1bmN0aW9uIF9vZmZzZXRUb1B4KHZhbHVlLCBzaXplKSB7XG4gIGlmIChfaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIGVxSW5kZXggPSB2YWx1ZS5pbmRleE9mKFwiPVwiKSxcbiAgICAgICAgcmVsYXRpdmUgPSB+ZXFJbmRleCA/ICsodmFsdWUuY2hhckF0KGVxSW5kZXggLSAxKSArIDEpICogcGFyc2VGbG9hdCh2YWx1ZS5zdWJzdHIoZXFJbmRleCArIDEpKSA6IDA7XG5cbiAgICBpZiAofmVxSW5kZXgpIHtcbiAgICAgIHZhbHVlLmluZGV4T2YoXCIlXCIpID4gZXFJbmRleCAmJiAocmVsYXRpdmUgKj0gc2l6ZSAvIDEwMCk7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCBlcUluZGV4IC0gMSk7XG4gICAgfVxuXG4gICAgdmFsdWUgPSByZWxhdGl2ZSArICh2YWx1ZSBpbiBfa2V5d29yZHMgPyBfa2V5d29yZHNbdmFsdWVdICogc2l6ZSA6IH52YWx1ZS5pbmRleE9mKFwiJVwiKSA/IHBhcnNlRmxvYXQodmFsdWUpICogc2l6ZSAvIDEwMCA6IHBhcnNlRmxvYXQodmFsdWUpIHx8IDApO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufSxcbiAgICBfY3JlYXRlTWFya2VyID0gZnVuY3Rpb24gX2NyZWF0ZU1hcmtlcih0eXBlLCBuYW1lLCBjb250YWluZXIsIGRpcmVjdGlvbiwgX3JlZjQsIG9mZnNldCwgbWF0Y2hXaWR0aEVsLCBjb250YWluZXJBbmltYXRpb24pIHtcbiAgdmFyIHN0YXJ0Q29sb3IgPSBfcmVmNC5zdGFydENvbG9yLFxuICAgICAgZW5kQ29sb3IgPSBfcmVmNC5lbmRDb2xvcixcbiAgICAgIGZvbnRTaXplID0gX3JlZjQuZm9udFNpemUsXG4gICAgICBpbmRlbnQgPSBfcmVmNC5pbmRlbnQsXG4gICAgICBmb250V2VpZ2h0ID0gX3JlZjQuZm9udFdlaWdodDtcblxuICB2YXIgZSA9IF9kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgIHVzZUZpeGVkUG9zaXRpb24gPSBfaXNWaWV3cG9ydChjb250YWluZXIpIHx8IF9nZXRQcm94eVByb3AoY29udGFpbmVyLCBcInBpblR5cGVcIikgPT09IFwiZml4ZWRcIixcbiAgICAgIGlzU2Nyb2xsZXIgPSB0eXBlLmluZGV4T2YoXCJzY3JvbGxlclwiKSAhPT0gLTEsXG4gICAgICBwYXJlbnQgPSB1c2VGaXhlZFBvc2l0aW9uID8gX2JvZHkgOiBjb250YWluZXIsXG4gICAgICBpc1N0YXJ0ID0gdHlwZS5pbmRleE9mKFwic3RhcnRcIikgIT09IC0xLFxuICAgICAgY29sb3IgPSBpc1N0YXJ0ID8gc3RhcnRDb2xvciA6IGVuZENvbG9yLFxuICAgICAgY3NzID0gXCJib3JkZXItY29sb3I6XCIgKyBjb2xvciArIFwiO2ZvbnQtc2l6ZTpcIiArIGZvbnRTaXplICsgXCI7Y29sb3I6XCIgKyBjb2xvciArIFwiO2ZvbnQtd2VpZ2h0OlwiICsgZm9udFdlaWdodCArIFwiO3BvaW50ZXItZXZlbnRzOm5vbmU7d2hpdGUtc3BhY2U6bm93cmFwO2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWYsQXJpYWw7ei1pbmRleDoxMDAwO3BhZGRpbmc6NHB4IDhweDtib3JkZXItd2lkdGg6MDtib3JkZXItc3R5bGU6c29saWQ7XCI7XG5cbiAgY3NzICs9IFwicG9zaXRpb246XCIgKyAoKGlzU2Nyb2xsZXIgfHwgY29udGFpbmVyQW5pbWF0aW9uKSAmJiB1c2VGaXhlZFBvc2l0aW9uID8gXCJmaXhlZDtcIiA6IFwiYWJzb2x1dGU7XCIpO1xuICAoaXNTY3JvbGxlciB8fCBjb250YWluZXJBbmltYXRpb24gfHwgIXVzZUZpeGVkUG9zaXRpb24pICYmIChjc3MgKz0gKGRpcmVjdGlvbiA9PT0gX3ZlcnRpY2FsID8gX3JpZ2h0IDogX2JvdHRvbSkgKyBcIjpcIiArIChvZmZzZXQgKyBwYXJzZUZsb2F0KGluZGVudCkpICsgXCJweDtcIik7XG4gIG1hdGNoV2lkdGhFbCAmJiAoY3NzICs9IFwiYm94LXNpemluZzpib3JkZXItYm94O3RleHQtYWxpZ246bGVmdDt3aWR0aDpcIiArIG1hdGNoV2lkdGhFbC5vZmZzZXRXaWR0aCArIFwicHg7XCIpO1xuICBlLl9pc1N0YXJ0ID0gaXNTdGFydDtcbiAgZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImdzYXAtbWFya2VyLVwiICsgdHlwZSArIChuYW1lID8gXCIgbWFya2VyLVwiICsgbmFtZSA6IFwiXCIpKTtcbiAgZS5zdHlsZS5jc3NUZXh0ID0gY3NzO1xuICBlLmlubmVyVGV4dCA9IG5hbWUgfHwgbmFtZSA9PT0gMCA/IHR5cGUgKyBcIi1cIiArIG5hbWUgOiB0eXBlO1xuICBwYXJlbnQuY2hpbGRyZW5bMF0gPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKGUsIHBhcmVudC5jaGlsZHJlblswXSkgOiBwYXJlbnQuYXBwZW5kQ2hpbGQoZSk7XG4gIGUuX29mZnNldCA9IGVbXCJvZmZzZXRcIiArIGRpcmVjdGlvbi5vcC5kMl07XG5cbiAgX3Bvc2l0aW9uTWFya2VyKGUsIDAsIGRpcmVjdGlvbiwgaXNTdGFydCk7XG5cbiAgcmV0dXJuIGU7XG59LFxuICAgIF9wb3NpdGlvbk1hcmtlciA9IGZ1bmN0aW9uIF9wb3NpdGlvbk1hcmtlcihtYXJrZXIsIHN0YXJ0LCBkaXJlY3Rpb24sIGZsaXBwZWQpIHtcbiAgdmFyIHZhcnMgPSB7XG4gICAgZGlzcGxheTogXCJibG9ja1wiXG4gIH0sXG4gICAgICBzaWRlID0gZGlyZWN0aW9uW2ZsaXBwZWQgPyBcIm9zMlwiIDogXCJwMlwiXSxcbiAgICAgIG9wcG9zaXRlU2lkZSA9IGRpcmVjdGlvbltmbGlwcGVkID8gXCJwMlwiIDogXCJvczJcIl07XG4gIG1hcmtlci5faXNGbGlwcGVkID0gZmxpcHBlZDtcbiAgdmFyc1tkaXJlY3Rpb24uYSArIFwiUGVyY2VudFwiXSA9IGZsaXBwZWQgPyAtMTAwIDogMDtcbiAgdmFyc1tkaXJlY3Rpb24uYV0gPSBmbGlwcGVkID8gXCIxcHhcIiA6IDA7XG4gIHZhcnNbXCJib3JkZXJcIiArIHNpZGUgKyBfV2lkdGhdID0gMTtcbiAgdmFyc1tcImJvcmRlclwiICsgb3Bwb3NpdGVTaWRlICsgX1dpZHRoXSA9IDA7XG4gIHZhcnNbZGlyZWN0aW9uLnBdID0gc3RhcnQgKyBcInB4XCI7XG4gIGdzYXAuc2V0KG1hcmtlciwgdmFycyk7XG59LFxuICAgIF90cmlnZ2VycyA9IFtdLFxuICAgIF9pZHMgPSB7fSxcbiAgICBfcmFmSUQsXG4gICAgX3N5bmMgPSBmdW5jdGlvbiBfc3luYygpIHtcbiAgcmV0dXJuIF9nZXRUaW1lKCkgLSBfbGFzdFNjcm9sbFRpbWUgPiAzNCAmJiAoX3JhZklEIHx8IChfcmFmSUQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3VwZGF0ZUFsbCkpKTtcbn0sXG4gICAgX29uU2Nyb2xsID0gZnVuY3Rpb24gX29uU2Nyb2xsKCkge1xuICAvLyBwcmV2aW91c2x5LCB3ZSB0cmllZCB0byBvcHRpbWl6ZSBwZXJmb3JtYW5jZSBieSBiYXRjaGluZy9kZWZlcnJpbmcgdG8gdGhlIG5leHQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCksIGJ1dCBkaXNjb3ZlcmVkIHRoYXQgU2FmYXJpIGhhcyBhIGZldyBidWdzIHRoYXQgbWFrZSB0aGlzIHVud29ya2FibGUgKGVzcGVjaWFsbHkgb24gaU9TKS4gU2VlIGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuLzE2YzQzNWIxMmVmMDljMzgxMjUyMDQ4MThlN2I0NWZjP2VkaXRvcnM9MDAxMCBhbmQgaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vSmpPeFlwUS8zZGQ2NWNjZWM1YTYwZjFkODYyYzM1NWQ4NGQxNDU2Mj9lZGl0b3JzPTAwMTAgYW5kIGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuL0V4YnJQTmEvMDg3Y2VmMTk3ZGMzNTQ0NWEwOTUxZTg5MzVjNDE1MDM/ZWRpdG9ycz0wMDEwXG4gIGlmICghX25vcm1hbGl6ZXIgfHwgIV9ub3JtYWxpemVyLmlzUHJlc3NlZCB8fCBfbm9ybWFsaXplci5zdGFydFggPiBfYm9keS5jbGllbnRXaWR0aCkge1xuICAgIC8vIGlmIHRoZSB1c2VyIGlzIGRyYWdnaW5nIHRoZSBzY3JvbGxiYXIsIGFsbG93IGl0LlxuICAgIF9zY3JvbGxlcnMuY2FjaGUrKztcblxuICAgIGlmIChfbm9ybWFsaXplcikge1xuICAgICAgX3JhZklEIHx8IChfcmFmSUQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3VwZGF0ZUFsbCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdXBkYXRlQWxsKCk7IC8vIFNhZmFyaSBpbiBwYXJ0aWN1bGFyIChvbiBkZXNrdG9wKSBORUVEUyB0aGUgaW1tZWRpYXRlIHVwZGF0ZSByYXRoZXIgdGhhbiB3YWl0aW5nIGZvciBhIHJlcXVlc3RBbmltYXRpb25GcmFtZSgpIHdoZXJlYXMgaU9TIHNlZW1zIHRvIGJlbmVmaXQgZnJvbSB3YWl0aW5nIGZvciB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkgdGljaywgYXQgbGVhc3Qgd2hlbiBub3JtYWxpemluZy4gU2VlIGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuL3FCWW96cU8/ZWRpdG9ycz0wMTEwXG5cbiAgICB9XG5cbiAgICBfbGFzdFNjcm9sbFRpbWUgfHwgX2Rpc3BhdGNoKFwic2Nyb2xsU3RhcnRcIik7XG4gICAgX2xhc3RTY3JvbGxUaW1lID0gX2dldFRpbWUoKTtcbiAgfVxufSxcbiAgICBfc2V0QmFzZURpbWVuc2lvbnMgPSBmdW5jdGlvbiBfc2V0QmFzZURpbWVuc2lvbnMoKSB7XG4gIF9iYXNlU2NyZWVuV2lkdGggPSBfd2luLmlubmVyV2lkdGg7XG4gIF9iYXNlU2NyZWVuSGVpZ2h0ID0gX3dpbi5pbm5lckhlaWdodDtcbn0sXG4gICAgX29uUmVzaXplID0gZnVuY3Rpb24gX29uUmVzaXplKCkge1xuICBfc2Nyb2xsZXJzLmNhY2hlKys7XG4gICFfcmVmcmVzaGluZyAmJiAhX2lnbm9yZVJlc2l6ZSAmJiAhX2RvYy5mdWxsc2NyZWVuRWxlbWVudCAmJiAhX2RvYy53ZWJraXRGdWxsc2NyZWVuRWxlbWVudCAmJiAoIV9pZ25vcmVNb2JpbGVSZXNpemUgfHwgX2Jhc2VTY3JlZW5XaWR0aCAhPT0gX3dpbi5pbm5lcldpZHRoIHx8IE1hdGguYWJzKF93aW4uaW5uZXJIZWlnaHQgLSBfYmFzZVNjcmVlbkhlaWdodCkgPiBfd2luLmlubmVySGVpZ2h0ICogMC4yNSkgJiYgX3Jlc2l6ZURlbGF5LnJlc3RhcnQodHJ1ZSk7XG59LFxuICAgIC8vIGlnbm9yZSByZXNpemVzIHRyaWdnZXJlZCBieSByZWZyZXNoKClcbl9saXN0ZW5lcnMgPSB7fSxcbiAgICBfZW1wdHlBcnJheSA9IFtdLFxuICAgIF9zb2Z0UmVmcmVzaCA9IGZ1bmN0aW9uIF9zb2Z0UmVmcmVzaCgpIHtcbiAgcmV0dXJuIF9yZW1vdmVMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInNjcm9sbEVuZFwiLCBfc29mdFJlZnJlc2gpIHx8IF9yZWZyZXNoQWxsKHRydWUpO1xufSxcbiAgICBfZGlzcGF0Y2ggPSBmdW5jdGlvbiBfZGlzcGF0Y2godHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVyc1t0eXBlXSAmJiBfbGlzdGVuZXJzW3R5cGVdLm1hcChmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmKCk7XG4gIH0pIHx8IF9lbXB0eUFycmF5O1xufSxcbiAgICBfc2F2ZWRTdHlsZXMgPSBbXSxcbiAgICAvLyB3aGVuIFNjcm9sbFRyaWdnZXIuc2F2ZVN0eWxlcygpIGlzIGNhbGxlZCwgdGhlIGlubGluZSBzdHlsZXMgYXJlIHJlY29yZGVkIGluIHRoaXMgQXJyYXkgaW4gYSBzZXF1ZW50aWFsIGZvcm1hdCBsaWtlIFtlbGVtZW50LCBjc3NUZXh0LCBnc0NhY2hlLCBtZWRpYV0uIFRoaXMga2VlcHMgaXQgdmVyeSBtZW1vcnktZWZmaWNpZW50IGFuZCBmYXN0IHRvIGl0ZXJhdGUgdGhyb3VnaC5cbl9yZXZlcnRSZWNvcmRlZCA9IGZ1bmN0aW9uIF9yZXZlcnRSZWNvcmRlZChtZWRpYSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IF9zYXZlZFN0eWxlcy5sZW5ndGg7IGkgKz0gNSkge1xuICAgIGlmICghbWVkaWEgfHwgX3NhdmVkU3R5bGVzW2kgKyA0XSAmJiBfc2F2ZWRTdHlsZXNbaSArIDRdLnF1ZXJ5ID09PSBtZWRpYSkge1xuICAgICAgX3NhdmVkU3R5bGVzW2ldLnN0eWxlLmNzc1RleHQgPSBfc2F2ZWRTdHlsZXNbaSArIDFdO1xuICAgICAgX3NhdmVkU3R5bGVzW2ldLmdldEJCb3ggJiYgX3NhdmVkU3R5bGVzW2ldLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBfc2F2ZWRTdHlsZXNbaSArIDJdIHx8IFwiXCIpO1xuICAgICAgX3NhdmVkU3R5bGVzW2kgKyAzXS51bmNhY2hlID0gMTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX3JldmVydEFsbCA9IGZ1bmN0aW9uIF9yZXZlcnRBbGwoa2lsbCwgbWVkaWEpIHtcbiAgdmFyIHRyaWdnZXI7XG5cbiAgZm9yIChfaSA9IDA7IF9pIDwgX3RyaWdnZXJzLmxlbmd0aDsgX2krKykge1xuICAgIHRyaWdnZXIgPSBfdHJpZ2dlcnNbX2ldO1xuXG4gICAgaWYgKHRyaWdnZXIgJiYgKCFtZWRpYSB8fCB0cmlnZ2VyLl9jdHggPT09IG1lZGlhKSkge1xuICAgICAgaWYgKGtpbGwpIHtcbiAgICAgICAgdHJpZ2dlci5raWxsKDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJpZ2dlci5yZXZlcnQodHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2lzUmV2ZXJ0ZWQgPSB0cnVlO1xuICBtZWRpYSAmJiBfcmV2ZXJ0UmVjb3JkZWQobWVkaWEpO1xuICBtZWRpYSB8fCBfZGlzcGF0Y2goXCJyZXZlcnRcIik7XG59LFxuICAgIF9jbGVhclNjcm9sbE1lbW9yeSA9IGZ1bmN0aW9uIF9jbGVhclNjcm9sbE1lbW9yeShzY3JvbGxSZXN0b3JhdGlvbiwgZm9yY2UpIHtcbiAgLy8gemVyby1vdXQgYWxsIHRoZSByZWNvcmRlZCBzY3JvbGwgcG9zaXRpb25zLiBEb24ndCB1c2UgX3RyaWdnZXJzIGJlY2F1c2UgaWYsIGZvciBleGFtcGxlLCAubWF0Y2hNZWRpYSgpIGlzIHVzZWQgdG8gY3JlYXRlIHNvbWUgU2Nyb2xsVHJpZ2dlcnMgYW5kIHRoZW4gdGhlIHVzZXIgcmVzaXplcyBhbmQgaXQgcmVtb3ZlcyBBTEwgU2Nyb2xsVHJpZ2dlcnMsIGFuZCB0aGVuIGdvIGJhY2sgdG8gYSBzaXplIHdoZXJlIHRoZXJlIGFyZSBTY3JvbGxUcmlnZ2VycywgaXQgd291bGQgaGF2ZSBrZXB0IHRoZSBwb3NpdGlvbihzKSBzYXZlZCBmcm9tIHRoZSBpbml0aWFsIHN0YXRlLlxuICBfc2Nyb2xsZXJzLmNhY2hlKys7XG4gIChmb3JjZSB8fCAhX3JlZnJlc2hpbmdBbGwpICYmIF9zY3JvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIF9pc0Z1bmN0aW9uKG9iaikgJiYgb2JqLmNhY2hlSUQrKyAmJiAob2JqLnJlYyA9IDApO1xuICB9KTtcbiAgX2lzU3RyaW5nKHNjcm9sbFJlc3RvcmF0aW9uKSAmJiAoX3dpbi5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gX3Njcm9sbFJlc3RvcmF0aW9uID0gc2Nyb2xsUmVzdG9yYXRpb24pO1xufSxcbiAgICBfcmVmcmVzaGluZ0FsbCxcbiAgICBfcmVmcmVzaElEID0gMCxcbiAgICBfcXVldWVSZWZyZXNoSUQsXG4gICAgX3F1ZXVlUmVmcmVzaEFsbCA9IGZ1bmN0aW9uIF9xdWV1ZVJlZnJlc2hBbGwoKSB7XG4gIC8vIHdlIGRvbid0IHdhbnQgdG8gY2FsbCBfcmVmcmVzaEFsbCgpIGV2ZXJ5IHRpbWUgd2UgY3JlYXRlIGEgbmV3IFNjcm9sbFRyaWdnZXIgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKSAtIGl0J3MgYmV0dGVyIHRvIGJhdGNoIHRoZW0uIFNvbWUgZnJhbWV3b3JrcyBkeW5hbWljYWxseSBsb2FkIGNvbnRlbnQgYW5kIHdlIGNhbid0IHJlbHkgb24gdGhlIHdpbmRvdydzIFwibG9hZFwiIG9yIFwiRE9NQ29udGVudExvYWRlZFwiIGV2ZW50cyB0byB0cmlnZ2VyIGl0LlxuICBpZiAoX3F1ZXVlUmVmcmVzaElEICE9PSBfcmVmcmVzaElEKSB7XG4gICAgdmFyIGlkID0gX3F1ZXVlUmVmcmVzaElEID0gX3JlZnJlc2hJRDtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGlkID09PSBfcmVmcmVzaElEICYmIF9yZWZyZXNoQWxsKHRydWUpO1xuICAgIH0pO1xuICB9XG59LFxuICAgIF9yZWZyZXNoMTAwdmggPSBmdW5jdGlvbiBfcmVmcmVzaDEwMHZoKCkge1xuICBfYm9keS5hcHBlbmRDaGlsZChfZGl2MTAwdmgpO1xuXG4gIF8xMDB2aCA9ICFfbm9ybWFsaXplciAmJiBfZGl2MTAwdmgub2Zmc2V0SGVpZ2h0IHx8IF93aW4uaW5uZXJIZWlnaHQ7XG5cbiAgX2JvZHkucmVtb3ZlQ2hpbGQoX2RpdjEwMHZoKTtcbn0sXG4gICAgX2hpZGVBbGxNYXJrZXJzID0gZnVuY3Rpb24gX2hpZGVBbGxNYXJrZXJzKGhpZGUpIHtcbiAgcmV0dXJuIF90b0FycmF5KFwiLmdzYXAtbWFya2VyLXN0YXJ0LCAuZ3NhcC1tYXJrZXItZW5kLCAuZ3NhcC1tYXJrZXItc2Nyb2xsZXItc3RhcnQsIC5nc2FwLW1hcmtlci1zY3JvbGxlci1lbmRcIikuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWwuc3R5bGUuZGlzcGxheSA9IGhpZGUgPyBcIm5vbmVcIiA6IFwiYmxvY2tcIjtcbiAgfSk7XG59LFxuICAgIF9yZWZyZXNoQWxsID0gZnVuY3Rpb24gX3JlZnJlc2hBbGwoZm9yY2UsIHNraXBSZXZlcnQpIHtcbiAgaWYgKF9sYXN0U2Nyb2xsVGltZSAmJiAhZm9yY2UgJiYgIV9pc1JldmVydGVkKSB7XG4gICAgX2FkZExpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwic2Nyb2xsRW5kXCIsIF9zb2Z0UmVmcmVzaCk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBfcmVmcmVzaDEwMHZoKCk7XG5cbiAgX3JlZnJlc2hpbmdBbGwgPSBTY3JvbGxUcmlnZ2VyLmlzUmVmcmVzaGluZyA9IHRydWU7XG5cbiAgX3Njcm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gX2lzRnVuY3Rpb24ob2JqKSAmJiArK29iai5jYWNoZUlEICYmIChvYmoucmVjID0gb2JqKCkpO1xuICB9KTsgLy8gZm9yY2UgdGhlIGNsZWFyaW5nIG9mIHRoZSBjYWNoZSBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgdGFrZSBhIGxpdHRsZSB3aGlsZSB0byBkaXNwYXRjaCB0aGUgXCJzY3JvbGxcIiBldmVudCBhbmQgdGhlIHVzZXIgbWF5IGhhdmUgY2hhbmdlZCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGFuZCB0aGVuIGNhbGxlZCBTY3JvbGxUcmlnZ2VyLnJlZnJlc2goKSByaWdodCBhd2F5XG5cblxuICB2YXIgcmVmcmVzaEluaXRzID0gX2Rpc3BhdGNoKFwicmVmcmVzaEluaXRcIik7XG5cbiAgX3NvcnQgJiYgU2Nyb2xsVHJpZ2dlci5zb3J0KCk7XG4gIHNraXBSZXZlcnQgfHwgX3JldmVydEFsbCgpO1xuXG4gIF9zY3JvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKF9pc0Z1bmN0aW9uKG9iaikpIHtcbiAgICAgIG9iai5zbW9vdGggJiYgKG9iai50YXJnZXQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSBcImF1dG9cIik7IC8vIHNtb290aCBzY3JvbGxpbmcgaW50ZXJmZXJlc1xuXG4gICAgICBvYmooMCk7XG4gICAgfVxuICB9KTtcblxuICBfdHJpZ2dlcnMuc2xpY2UoMCkuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0LnJlZnJlc2goKTtcbiAgfSk7IC8vIGRvbid0IGxvb3Agd2l0aCBfaSBiZWNhdXNlIGR1cmluZyBhIHJlZnJlc2goKSBzb21lb25lIGNvdWxkIGNhbGwgU2Nyb2xsVHJpZ2dlci51cGRhdGUoKSB3aGljaCB3b3VsZCBpdGVyYXRlIHRocm91Z2ggX2kgcmVzdWx0aW5nIGluIGEgc2tpcC5cblxuXG4gIF9pc1JldmVydGVkID0gZmFsc2U7XG5cbiAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAvLyBuZXN0ZWQgcGlucyAocGlubmVkQ29udGFpbmVyKSB3aXRoIHBpblNwYWNpbmcgbWF5IGV4cGFuZCB0aGUgY29udGFpbmVyLCBzbyB3ZSBtdXN0IGFjY29tbW9kYXRlIHRoYXQgaGVyZS5cbiAgICBpZiAodC5fc3ViUGluT2Zmc2V0ICYmIHQucGluKSB7XG4gICAgICB2YXIgcHJvcCA9IHQudmFycy5ob3Jpem9udGFsID8gXCJvZmZzZXRXaWR0aFwiIDogXCJvZmZzZXRIZWlnaHRcIixcbiAgICAgICAgICBvcmlnaW5hbCA9IHQucGluW3Byb3BdO1xuICAgICAgdC5yZXZlcnQodHJ1ZSwgMSk7XG4gICAgICB0LmFkanVzdFBpblNwYWNpbmcodC5waW5bcHJvcF0gLSBvcmlnaW5hbCk7XG4gICAgICB0LnJlZnJlc2goKTtcbiAgICB9XG4gIH0pO1xuXG4gIF9jbGFtcGluZ01heCA9IDE7IC8vIHBpblNwYWNpbmcgbWlnaHQgYmUgcHJvcHBpbmcgYSBwYWdlIG9wZW4sIHRodXMgd2hlbiB3ZSAuc2V0UG9zaXRpb25zKCkgdG8gY2xhbXAgYSBTY3JvbGxUcmlnZ2VyJ3MgZW5kIHdlIHNob3VsZCBsZWF2ZSB0aGUgcGluU3BhY2luZyBhbG9uZS4gVGhhdCdzIHdoYXQgdGhpcyBmbGFnIGlzIGZvci5cblxuICBfaGlkZUFsbE1hcmtlcnModHJ1ZSk7XG5cbiAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAvLyB0aGUgc2Nyb2xsZXIncyBtYXggc2Nyb2xsIHBvc2l0aW9uIG1heSBjaGFuZ2UgYWZ0ZXIgYWxsIHRoZSBTY3JvbGxUcmlnZ2VycyByZWZyZXNoZWQgKGxpa2UgcGlubmluZyBjb3VsZCBwdXNoIGl0IGRvd24pLCBzbyB3ZSBuZWVkIHRvIGxvb3AgYmFjayBhbmQgY29ycmVjdCBhbnkgd2l0aCBlbmQ6IFwibWF4XCIuIFNhbWUgZm9yIGFueXRoaW5nIHdpdGggYSBjbGFtcGVkIGVuZFxuICAgIHZhciBtYXggPSBfbWF4U2Nyb2xsKHQuc2Nyb2xsZXIsIHQuX2RpciksXG4gICAgICAgIGVuZENsYW1wID0gdC52YXJzLmVuZCA9PT0gXCJtYXhcIiB8fCB0Ll9lbmRDbGFtcCAmJiB0LmVuZCA+IG1heCxcbiAgICAgICAgc3RhcnRDbGFtcCA9IHQuX3N0YXJ0Q2xhbXAgJiYgdC5zdGFydCA+PSBtYXg7XG5cbiAgICAoZW5kQ2xhbXAgfHwgc3RhcnRDbGFtcCkgJiYgdC5zZXRQb3NpdGlvbnMoc3RhcnRDbGFtcCA/IG1heCAtIDEgOiB0LnN0YXJ0LCBlbmRDbGFtcCA/IE1hdGgubWF4KHN0YXJ0Q2xhbXAgPyBtYXggOiB0LnN0YXJ0ICsgMSwgbWF4KSA6IHQuZW5kLCB0cnVlKTtcbiAgfSk7XG5cbiAgX2hpZGVBbGxNYXJrZXJzKGZhbHNlKTtcblxuICBfY2xhbXBpbmdNYXggPSAwO1xuICByZWZyZXNoSW5pdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdCAmJiByZXN1bHQucmVuZGVyICYmIHJlc3VsdC5yZW5kZXIoLTEpO1xuICB9KTsgLy8gaWYgdGhlIG9uUmVmcmVzaEluaXQoKSByZXR1cm5zIGFuIGFuaW1hdGlvbiAodHlwaWNhbGx5IGEgZ3NhcC5zZXQoKSksIHJldmVydCBpdC4gVGhpcyBtYWtlcyBpdCBlYXN5IHRvIHB1dCB0aGluZ3MgaW4gYSBjZXJ0YWluIHNwb3QgYmVmb3JlIHJlZnJlc2hpbmcgZm9yIG1lYXN1cmVtZW50IHB1cnBvc2VzLCBhbmQgdGhlbiBwdXQgdGhpbmdzIGJhY2suXG5cbiAgX3Njcm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoX2lzRnVuY3Rpb24ob2JqKSkge1xuICAgICAgb2JqLnNtb290aCAmJiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb2JqLnRhcmdldC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IFwic21vb3RoXCI7XG4gICAgICB9KTtcbiAgICAgIG9iai5yZWMgJiYgb2JqKG9iai5yZWMpO1xuICAgIH1cbiAgfSk7XG5cbiAgX2NsZWFyU2Nyb2xsTWVtb3J5KF9zY3JvbGxSZXN0b3JhdGlvbiwgMSk7XG5cbiAgX3Jlc2l6ZURlbGF5LnBhdXNlKCk7XG5cbiAgX3JlZnJlc2hJRCsrO1xuICBfcmVmcmVzaGluZ0FsbCA9IDI7XG5cbiAgX3VwZGF0ZUFsbCgyKTtcblxuICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBfaXNGdW5jdGlvbih0LnZhcnMub25SZWZyZXNoKSAmJiB0LnZhcnMub25SZWZyZXNoKHQpO1xuICB9KTtcblxuICBfcmVmcmVzaGluZ0FsbCA9IFNjcm9sbFRyaWdnZXIuaXNSZWZyZXNoaW5nID0gZmFsc2U7XG5cbiAgX2Rpc3BhdGNoKFwicmVmcmVzaFwiKTtcbn0sXG4gICAgX2xhc3RTY3JvbGwgPSAwLFxuICAgIF9kaXJlY3Rpb24gPSAxLFxuICAgIF9wcmltYXJ5LFxuICAgIF91cGRhdGVBbGwgPSBmdW5jdGlvbiBfdXBkYXRlQWxsKGZvcmNlKSB7XG4gIGlmIChmb3JjZSA9PT0gMiB8fCAhX3JlZnJlc2hpbmdBbGwgJiYgIV9pc1JldmVydGVkKSB7XG4gICAgLy8gX2lzUmV2ZXJ0ZWQgY291bGQgYmUgdHJ1ZSBpZiwgZm9yIGV4YW1wbGUsIGEgbWF0Y2hNZWRpYSgpIGlzIGluIHRoZSBwcm9jZXNzIG9mIGV4ZWN1dGluZy4gV2UgZG9uJ3Qgd2FudCB0byB1cGRhdGUgZHVyaW5nIHRoZSB0aW1lIGV2ZXJ5dGhpbmcgaXMgcmV2ZXJ0ZWQuXG4gICAgU2Nyb2xsVHJpZ2dlci5pc1VwZGF0aW5nID0gdHJ1ZTtcbiAgICBfcHJpbWFyeSAmJiBfcHJpbWFyeS51cGRhdGUoMCk7IC8vIFNjcm9sbFNtb290aGVyIHVzZXMgcmVmcmVzaFByaW9yaXR5IC05OTk5IHRvIGJlY29tZSB0aGUgcHJpbWFyeSB0aGF0IGdldHMgdXBkYXRlZCBiZWZvcmUgYWxsIG90aGVycyBiZWNhdXNlIGl0IGFmZmVjdHMgdGhlIHNjcm9sbCBwb3NpdGlvbi5cblxuICAgIHZhciBsID0gX3RyaWdnZXJzLmxlbmd0aCxcbiAgICAgICAgdGltZSA9IF9nZXRUaW1lKCksXG4gICAgICAgIHJlY29yZFZlbG9jaXR5ID0gdGltZSAtIF90aW1lMSA+PSA1MCxcbiAgICAgICAgc2Nyb2xsID0gbCAmJiBfdHJpZ2dlcnNbMF0uc2Nyb2xsKCk7XG5cbiAgICBfZGlyZWN0aW9uID0gX2xhc3RTY3JvbGwgPiBzY3JvbGwgPyAtMSA6IDE7XG4gICAgX3JlZnJlc2hpbmdBbGwgfHwgKF9sYXN0U2Nyb2xsID0gc2Nyb2xsKTtcblxuICAgIGlmIChyZWNvcmRWZWxvY2l0eSkge1xuICAgICAgaWYgKF9sYXN0U2Nyb2xsVGltZSAmJiAhX3BvaW50ZXJJc0Rvd24gJiYgdGltZSAtIF9sYXN0U2Nyb2xsVGltZSA+IDIwMCkge1xuICAgICAgICBfbGFzdFNjcm9sbFRpbWUgPSAwO1xuXG4gICAgICAgIF9kaXNwYXRjaChcInNjcm9sbEVuZFwiKTtcbiAgICAgIH1cblxuICAgICAgX3RpbWUyID0gX3RpbWUxO1xuICAgICAgX3RpbWUxID0gdGltZTtcbiAgICB9XG5cbiAgICBpZiAoX2RpcmVjdGlvbiA8IDApIHtcbiAgICAgIF9pID0gbDtcblxuICAgICAgd2hpbGUgKF9pLS0gPiAwKSB7XG4gICAgICAgIF90cmlnZ2Vyc1tfaV0gJiYgX3RyaWdnZXJzW19pXS51cGRhdGUoMCwgcmVjb3JkVmVsb2NpdHkpO1xuICAgICAgfVxuXG4gICAgICBfZGlyZWN0aW9uID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChfaSA9IDA7IF9pIDwgbDsgX2krKykge1xuICAgICAgICBfdHJpZ2dlcnNbX2ldICYmIF90cmlnZ2Vyc1tfaV0udXBkYXRlKDAsIHJlY29yZFZlbG9jaXR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBTY3JvbGxUcmlnZ2VyLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIF9yYWZJRCA9IDA7XG59LFxuICAgIF9wcm9wTmFtZXNUb0NvcHkgPSBbX2xlZnQsIF90b3AsIF9ib3R0b20sIF9yaWdodCwgX21hcmdpbiArIF9Cb3R0b20sIF9tYXJnaW4gKyBfUmlnaHQsIF9tYXJnaW4gKyBfVG9wLCBfbWFyZ2luICsgX0xlZnQsIFwiZGlzcGxheVwiLCBcImZsZXhTaHJpbmtcIiwgXCJmbG9hdFwiLCBcInpJbmRleFwiLCBcImdyaWRDb2x1bW5TdGFydFwiLCBcImdyaWRDb2x1bW5FbmRcIiwgXCJncmlkUm93U3RhcnRcIiwgXCJncmlkUm93RW5kXCIsIFwiZ3JpZEFyZWFcIiwgXCJqdXN0aWZ5U2VsZlwiLCBcImFsaWduU2VsZlwiLCBcInBsYWNlU2VsZlwiLCBcIm9yZGVyXCJdLFxuICAgIF9zdGF0ZVByb3BzID0gX3Byb3BOYW1lc1RvQ29weS5jb25jYXQoW193aWR0aCwgX2hlaWdodCwgXCJib3hTaXppbmdcIiwgXCJtYXhcIiArIF9XaWR0aCwgXCJtYXhcIiArIF9IZWlnaHQsIFwicG9zaXRpb25cIiwgX21hcmdpbiwgX3BhZGRpbmcsIF9wYWRkaW5nICsgX1RvcCwgX3BhZGRpbmcgKyBfUmlnaHQsIF9wYWRkaW5nICsgX0JvdHRvbSwgX3BhZGRpbmcgKyBfTGVmdF0pLFxuICAgIF9zd2FwUGluT3V0ID0gZnVuY3Rpb24gX3N3YXBQaW5PdXQocGluLCBzcGFjZXIsIHN0YXRlKSB7XG4gIF9zZXRTdGF0ZShzdGF0ZSk7XG5cbiAgdmFyIGNhY2hlID0gcGluLl9nc2FwO1xuXG4gIGlmIChjYWNoZS5zcGFjZXJJc05hdGl2ZSkge1xuICAgIF9zZXRTdGF0ZShjYWNoZS5zcGFjZXJTdGF0ZSk7XG4gIH0gZWxzZSBpZiAocGluLl9nc2FwLnN3YXBwZWRJbikge1xuICAgIHZhciBwYXJlbnQgPSBzcGFjZXIucGFyZW50Tm9kZTtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUocGluLCBzcGFjZXIpO1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHNwYWNlcik7XG4gICAgfVxuICB9XG5cbiAgcGluLl9nc2FwLnN3YXBwZWRJbiA9IGZhbHNlO1xufSxcbiAgICBfc3dhcFBpbkluID0gZnVuY3Rpb24gX3N3YXBQaW5JbihwaW4sIHNwYWNlciwgY3MsIHNwYWNlclN0YXRlKSB7XG4gIGlmICghcGluLl9nc2FwLnN3YXBwZWRJbikge1xuICAgIHZhciBpID0gX3Byb3BOYW1lc1RvQ29weS5sZW5ndGgsXG4gICAgICAgIHNwYWNlclN0eWxlID0gc3BhY2VyLnN0eWxlLFxuICAgICAgICBwaW5TdHlsZSA9IHBpbi5zdHlsZSxcbiAgICAgICAgcDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHAgPSBfcHJvcE5hbWVzVG9Db3B5W2ldO1xuICAgICAgc3BhY2VyU3R5bGVbcF0gPSBjc1twXTtcbiAgICB9XG5cbiAgICBzcGFjZXJTdHlsZS5wb3NpdGlvbiA9IGNzLnBvc2l0aW9uID09PSBcImFic29sdXRlXCIgPyBcImFic29sdXRlXCIgOiBcInJlbGF0aXZlXCI7XG4gICAgY3MuZGlzcGxheSA9PT0gXCJpbmxpbmVcIiAmJiAoc3BhY2VyU3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCIpO1xuICAgIHBpblN0eWxlW19ib3R0b21dID0gcGluU3R5bGVbX3JpZ2h0XSA9IFwiYXV0b1wiO1xuICAgIHNwYWNlclN0eWxlLmZsZXhCYXNpcyA9IGNzLmZsZXhCYXNpcyB8fCBcImF1dG9cIjtcbiAgICBzcGFjZXJTdHlsZS5vdmVyZmxvdyA9IFwidmlzaWJsZVwiO1xuICAgIHNwYWNlclN0eWxlLmJveFNpemluZyA9IFwiYm9yZGVyLWJveFwiO1xuICAgIHNwYWNlclN0eWxlW193aWR0aF0gPSBfZ2V0U2l6ZShwaW4sIF9ob3Jpem9udGFsKSArIF9weDtcbiAgICBzcGFjZXJTdHlsZVtfaGVpZ2h0XSA9IF9nZXRTaXplKHBpbiwgX3ZlcnRpY2FsKSArIF9weDtcbiAgICBzcGFjZXJTdHlsZVtfcGFkZGluZ10gPSBwaW5TdHlsZVtfbWFyZ2luXSA9IHBpblN0eWxlW190b3BdID0gcGluU3R5bGVbX2xlZnRdID0gXCIwXCI7XG5cbiAgICBfc2V0U3RhdGUoc3BhY2VyU3RhdGUpO1xuXG4gICAgcGluU3R5bGVbX3dpZHRoXSA9IHBpblN0eWxlW1wibWF4XCIgKyBfV2lkdGhdID0gY3NbX3dpZHRoXTtcbiAgICBwaW5TdHlsZVtfaGVpZ2h0XSA9IHBpblN0eWxlW1wibWF4XCIgKyBfSGVpZ2h0XSA9IGNzW19oZWlnaHRdO1xuICAgIHBpblN0eWxlW19wYWRkaW5nXSA9IGNzW19wYWRkaW5nXTtcblxuICAgIGlmIChwaW4ucGFyZW50Tm9kZSAhPT0gc3BhY2VyKSB7XG4gICAgICBwaW4ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3BhY2VyLCBwaW4pO1xuICAgICAgc3BhY2VyLmFwcGVuZENoaWxkKHBpbik7XG4gICAgfVxuXG4gICAgcGluLl9nc2FwLnN3YXBwZWRJbiA9IHRydWU7XG4gIH1cbn0sXG4gICAgX2NhcHNFeHAgPSAvKFtBLVpdKS9nLFxuICAgIF9zZXRTdGF0ZSA9IGZ1bmN0aW9uIF9zZXRTdGF0ZShzdGF0ZSkge1xuICBpZiAoc3RhdGUpIHtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS50LnN0eWxlLFxuICAgICAgICBsID0gc3RhdGUubGVuZ3RoLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgcCxcbiAgICAgICAgdmFsdWU7XG4gICAgKHN0YXRlLnQuX2dzYXAgfHwgZ3NhcC5jb3JlLmdldENhY2hlKHN0YXRlLnQpKS51bmNhY2hlID0gMTsgLy8gb3RoZXJ3aXNlIHRyYW5zZm9ybXMgbWF5IGJlIG9mZlxuXG4gICAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgIHZhbHVlID0gc3RhdGVbaSArIDFdO1xuICAgICAgcCA9IHN0YXRlW2ldO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgc3R5bGVbcF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGVbcF0pIHtcbiAgICAgICAgc3R5bGUucmVtb3ZlUHJvcGVydHkocC5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG4gICAgX2dldFN0YXRlID0gZnVuY3Rpb24gX2dldFN0YXRlKGVsZW1lbnQpIHtcbiAgLy8gcmV0dXJucyBhbiBBcnJheSB3aXRoIGFsdGVybmF0aW5nIHZhbHVlcyBsaWtlIFtwcm9wZXJ0eSwgdmFsdWUsIHByb3BlcnR5LCB2YWx1ZV0gYW5kIGEgXCJ0XCIgcHJvcGVydHkgcG9pbnRpbmcgdG8gdGhlIHRhcmdldCAoZWxlbWVudCkuIE1ha2VzIGl0IGZhc3QgYW5kIGNoZWFwLlxuICB2YXIgbCA9IF9zdGF0ZVByb3BzLmxlbmd0aCxcbiAgICAgIHN0eWxlID0gZWxlbWVudC5zdHlsZSxcbiAgICAgIHN0YXRlID0gW10sXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIHN0YXRlLnB1c2goX3N0YXRlUHJvcHNbaV0sIHN0eWxlW19zdGF0ZVByb3BzW2ldXSk7XG4gIH1cblxuICBzdGF0ZS50ID0gZWxlbWVudDtcbiAgcmV0dXJuIHN0YXRlO1xufSxcbiAgICBfY29weVN0YXRlID0gZnVuY3Rpb24gX2NvcHlTdGF0ZShzdGF0ZSwgb3ZlcnJpZGUsIG9taXRPZmZzZXRzKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIGwgPSBzdGF0ZS5sZW5ndGgsXG4gICAgICBpID0gb21pdE9mZnNldHMgPyA4IDogMCxcbiAgICAgIC8vIHNraXAgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tIGlmIG9taXRPZmZzZXRzIGlzIHRydWVcbiAgcDtcblxuICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHAgPSBzdGF0ZVtpXTtcbiAgICByZXN1bHQucHVzaChwLCBwIGluIG92ZXJyaWRlID8gb3ZlcnJpZGVbcF0gOiBzdGF0ZVtpICsgMV0pO1xuICB9XG5cbiAgcmVzdWx0LnQgPSBzdGF0ZS50O1xuICByZXR1cm4gcmVzdWx0O1xufSxcbiAgICBfd2luT2Zmc2V0cyA9IHtcbiAgbGVmdDogMCxcbiAgdG9wOiAwXG59LFxuICAgIC8vIC8vIHBvdGVudGlhbCBmdXR1cmUgZmVhdHVyZSAoPykgQWxsb3cgdXNlcnMgdG8gY2FsY3VsYXRlIHdoZXJlIGEgdHJpZ2dlciBoaXRzIChzY3JvbGwgcG9zaXRpb24pIGxpa2UgZ2V0U2Nyb2xsUG9zaXRpb24oXCIjaWRcIiwgXCJ0b3AgYm90dG9tXCIpXG4vLyBfZ2V0U2Nyb2xsUG9zaXRpb24gPSAodHJpZ2dlciwgcG9zaXRpb24sIHtzY3JvbGxlciwgY29udGFpbmVyQW5pbWF0aW9uLCBob3Jpem9udGFsfSkgPT4ge1xuLy8gXHRzY3JvbGxlciA9IF9nZXRUYXJnZXQoc2Nyb2xsZXIgfHwgX3dpbik7XG4vLyBcdGxldCBkaXJlY3Rpb24gPSBob3Jpem9udGFsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwsXG4vLyBcdFx0aXNWaWV3cG9ydCA9IF9pc1ZpZXdwb3J0KHNjcm9sbGVyKTtcbi8vIFx0X2dldFNpemVGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0LCBkaXJlY3Rpb24pO1xuLy8gXHRyZXR1cm4gX3BhcnNlUG9zaXRpb24ocG9zaXRpb24sIF9nZXRUYXJnZXQodHJpZ2dlciksIF9nZXRTaXplRnVuYyhzY3JvbGxlciwgaXNWaWV3cG9ydCwgZGlyZWN0aW9uKSgpLCBkaXJlY3Rpb24sIF9nZXRTY3JvbGxGdW5jKHNjcm9sbGVyLCBkaXJlY3Rpb24pKCksIDAsIDAsIDAsIF9nZXRPZmZzZXRzRnVuYyhzY3JvbGxlciwgaXNWaWV3cG9ydCkoKSwgaXNWaWV3cG9ydCA/IDAgOiBwYXJzZUZsb2F0KF9nZXRDb21wdXRlZFN0eWxlKHNjcm9sbGVyKVtcImJvcmRlclwiICsgZGlyZWN0aW9uLnAyICsgX1dpZHRoXSkgfHwgMCwgMCwgY29udGFpbmVyQW5pbWF0aW9uID8gY29udGFpbmVyQW5pbWF0aW9uLmR1cmF0aW9uKCkgOiBfbWF4U2Nyb2xsKHNjcm9sbGVyKSwgY29udGFpbmVyQW5pbWF0aW9uKTtcbi8vIH0sXG5fcGFyc2VQb3NpdGlvbiA9IGZ1bmN0aW9uIF9wYXJzZVBvc2l0aW9uKHZhbHVlLCB0cmlnZ2VyLCBzY3JvbGxlclNpemUsIGRpcmVjdGlvbiwgc2Nyb2xsLCBtYXJrZXIsIG1hcmtlclNjcm9sbGVyLCBzZWxmLCBzY3JvbGxlckJvdW5kcywgYm9yZGVyV2lkdGgsIHVzZUZpeGVkUG9zaXRpb24sIHNjcm9sbGVyTWF4LCBjb250YWluZXJBbmltYXRpb24sIGNsYW1wWmVyb1Byb3ApIHtcbiAgX2lzRnVuY3Rpb24odmFsdWUpICYmICh2YWx1ZSA9IHZhbHVlKHNlbGYpKTtcblxuICBpZiAoX2lzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5zdWJzdHIoMCwgMykgPT09IFwibWF4XCIpIHtcbiAgICB2YWx1ZSA9IHNjcm9sbGVyTWF4ICsgKHZhbHVlLmNoYXJBdCg0KSA9PT0gXCI9XCIgPyBfb2Zmc2V0VG9QeChcIjBcIiArIHZhbHVlLnN1YnN0cigzKSwgc2Nyb2xsZXJTaXplKSA6IDApO1xuICB9XG5cbiAgdmFyIHRpbWUgPSBjb250YWluZXJBbmltYXRpb24gPyBjb250YWluZXJBbmltYXRpb24udGltZSgpIDogMCxcbiAgICAgIHAxLFxuICAgICAgcDIsXG4gICAgICBlbGVtZW50O1xuICBjb250YWluZXJBbmltYXRpb24gJiYgY29udGFpbmVyQW5pbWF0aW9uLnNlZWsoMCk7XG4gIGlzTmFOKHZhbHVlKSB8fCAodmFsdWUgPSArdmFsdWUpOyAvLyBjb252ZXJ0IGEgc3RyaW5nIG51bWJlciBsaWtlIFwiNDVcIiB0byBhbiBhY3R1YWwgbnVtYmVyXG5cbiAgaWYgKCFfaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgX2lzRnVuY3Rpb24odHJpZ2dlcikgJiYgKHRyaWdnZXIgPSB0cmlnZ2VyKHNlbGYpKTtcbiAgICB2YXIgb2Zmc2V0cyA9ICh2YWx1ZSB8fCBcIjBcIikuc3BsaXQoXCIgXCIpLFxuICAgICAgICBib3VuZHMsXG4gICAgICAgIGxvY2FsT2Zmc2V0LFxuICAgICAgICBnbG9iYWxPZmZzZXQsXG4gICAgICAgIGRpc3BsYXk7XG4gICAgZWxlbWVudCA9IF9nZXRUYXJnZXQodHJpZ2dlciwgc2VsZikgfHwgX2JvZHk7XG4gICAgYm91bmRzID0gX2dldEJvdW5kcyhlbGVtZW50KSB8fCB7fTtcblxuICAgIGlmICgoIWJvdW5kcyB8fCAhYm91bmRzLmxlZnQgJiYgIWJvdW5kcy50b3ApICYmIF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgICAvLyBpZiBkaXNwbGF5IGlzIFwibm9uZVwiLCBpdCB3b24ndCByZXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgcHJvcGVybHlcbiAgICAgIGRpc3BsYXkgPSBlbGVtZW50LnN0eWxlLmRpc3BsYXk7XG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKGVsZW1lbnQpO1xuICAgICAgZGlzcGxheSA/IGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXkgOiBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZGlzcGxheVwiKTtcbiAgICB9XG5cbiAgICBsb2NhbE9mZnNldCA9IF9vZmZzZXRUb1B4KG9mZnNldHNbMF0sIGJvdW5kc1tkaXJlY3Rpb24uZF0pO1xuICAgIGdsb2JhbE9mZnNldCA9IF9vZmZzZXRUb1B4KG9mZnNldHNbMV0gfHwgXCIwXCIsIHNjcm9sbGVyU2l6ZSk7XG4gICAgdmFsdWUgPSBib3VuZHNbZGlyZWN0aW9uLnBdIC0gc2Nyb2xsZXJCb3VuZHNbZGlyZWN0aW9uLnBdIC0gYm9yZGVyV2lkdGggKyBsb2NhbE9mZnNldCArIHNjcm9sbCAtIGdsb2JhbE9mZnNldDtcbiAgICBtYXJrZXJTY3JvbGxlciAmJiBfcG9zaXRpb25NYXJrZXIobWFya2VyU2Nyb2xsZXIsIGdsb2JhbE9mZnNldCwgZGlyZWN0aW9uLCBzY3JvbGxlclNpemUgLSBnbG9iYWxPZmZzZXQgPCAyMCB8fCBtYXJrZXJTY3JvbGxlci5faXNTdGFydCAmJiBnbG9iYWxPZmZzZXQgPiAyMCk7XG4gICAgc2Nyb2xsZXJTaXplIC09IHNjcm9sbGVyU2l6ZSAtIGdsb2JhbE9mZnNldDsgLy8gYWRqdXN0IGZvciB0aGUgbWFya2VyXG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyQW5pbWF0aW9uICYmICh2YWx1ZSA9IGdzYXAudXRpbHMubWFwUmFuZ2UoY29udGFpbmVyQW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIuc3RhcnQsIGNvbnRhaW5lckFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyLmVuZCwgMCwgc2Nyb2xsZXJNYXgsIHZhbHVlKSk7XG4gICAgbWFya2VyU2Nyb2xsZXIgJiYgX3Bvc2l0aW9uTWFya2VyKG1hcmtlclNjcm9sbGVyLCBzY3JvbGxlclNpemUsIGRpcmVjdGlvbiwgdHJ1ZSk7XG4gIH1cblxuICBpZiAoY2xhbXBaZXJvUHJvcCkge1xuICAgIHNlbGZbY2xhbXBaZXJvUHJvcF0gPSB2YWx1ZSB8fCAtMC4wMDE7XG4gICAgdmFsdWUgPCAwICYmICh2YWx1ZSA9IDApO1xuICB9XG5cbiAgaWYgKG1hcmtlcikge1xuICAgIHZhciBwb3NpdGlvbiA9IHZhbHVlICsgc2Nyb2xsZXJTaXplLFxuICAgICAgICBpc1N0YXJ0ID0gbWFya2VyLl9pc1N0YXJ0O1xuICAgIHAxID0gXCJzY3JvbGxcIiArIGRpcmVjdGlvbi5kMjtcblxuICAgIF9wb3NpdGlvbk1hcmtlcihtYXJrZXIsIHBvc2l0aW9uLCBkaXJlY3Rpb24sIGlzU3RhcnQgJiYgcG9zaXRpb24gPiAyMCB8fCAhaXNTdGFydCAmJiAodXNlRml4ZWRQb3NpdGlvbiA/IE1hdGgubWF4KF9ib2R5W3AxXSwgX2RvY0VsW3AxXSkgOiBtYXJrZXIucGFyZW50Tm9kZVtwMV0pIDw9IHBvc2l0aW9uICsgMSk7XG5cbiAgICBpZiAodXNlRml4ZWRQb3NpdGlvbikge1xuICAgICAgc2Nyb2xsZXJCb3VuZHMgPSBfZ2V0Qm91bmRzKG1hcmtlclNjcm9sbGVyKTtcbiAgICAgIHVzZUZpeGVkUG9zaXRpb24gJiYgKG1hcmtlci5zdHlsZVtkaXJlY3Rpb24ub3AucF0gPSBzY3JvbGxlckJvdW5kc1tkaXJlY3Rpb24ub3AucF0gLSBkaXJlY3Rpb24ub3AubSAtIG1hcmtlci5fb2Zmc2V0ICsgX3B4KTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29udGFpbmVyQW5pbWF0aW9uICYmIGVsZW1lbnQpIHtcbiAgICBwMSA9IF9nZXRCb3VuZHMoZWxlbWVudCk7XG4gICAgY29udGFpbmVyQW5pbWF0aW9uLnNlZWsoc2Nyb2xsZXJNYXgpO1xuICAgIHAyID0gX2dldEJvdW5kcyhlbGVtZW50KTtcbiAgICBjb250YWluZXJBbmltYXRpb24uX2NhU2Nyb2xsRGlzdCA9IHAxW2RpcmVjdGlvbi5wXSAtIHAyW2RpcmVjdGlvbi5wXTtcbiAgICB2YWx1ZSA9IHZhbHVlIC8gY29udGFpbmVyQW5pbWF0aW9uLl9jYVNjcm9sbERpc3QgKiBzY3JvbGxlck1heDtcbiAgfVxuXG4gIGNvbnRhaW5lckFuaW1hdGlvbiAmJiBjb250YWluZXJBbmltYXRpb24uc2Vlayh0aW1lKTtcbiAgcmV0dXJuIGNvbnRhaW5lckFuaW1hdGlvbiA/IHZhbHVlIDogTWF0aC5yb3VuZCh2YWx1ZSk7XG59LFxuICAgIF9wcmVmaXhFeHAgPSAvKHdlYmtpdHxtb3p8bGVuZ3RofGNzc1RleHR8aW5zZXQpL2ksXG4gICAgX3JlcGFyZW50ID0gZnVuY3Rpb24gX3JlcGFyZW50KGVsZW1lbnQsIHBhcmVudCwgdG9wLCBsZWZ0KSB7XG4gIGlmIChlbGVtZW50LnBhcmVudE5vZGUgIT09IHBhcmVudCkge1xuICAgIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGUsXG4gICAgICAgIHAsXG4gICAgICAgIGNzO1xuXG4gICAgaWYgKHBhcmVudCA9PT0gX2JvZHkpIHtcbiAgICAgIGVsZW1lbnQuX3N0T3JpZyA9IHN0eWxlLmNzc1RleHQ7IC8vIHJlY29yZCBvcmlnaW5hbCBpbmxpbmUgc3R5bGVzIHNvIHdlIGNhbiByZXZlcnQgdGhlbSBsYXRlclxuXG4gICAgICBjcyA9IF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgICBmb3IgKHAgaW4gY3MpIHtcbiAgICAgICAgLy8gbXVzdCBjb3B5IGFsbCByZWxldmFudCBzdHlsZXMgdG8gZW5zdXJlIHRoYXQgbm90aGluZyBjaGFuZ2VzIHZpc3VhbGx5IHdoZW4gd2UgcmVwYXJlbnQgdG8gdGhlIDxib2R5Pi4gU2tpcCB0aGUgdmVuZG9yIHByZWZpeGVkIG9uZXMuXG4gICAgICAgIGlmICghK3AgJiYgIV9wcmVmaXhFeHAudGVzdChwKSAmJiBjc1twXSAmJiB0eXBlb2Ygc3R5bGVbcF0gPT09IFwic3RyaW5nXCIgJiYgcCAhPT0gXCIwXCIpIHtcbiAgICAgICAgICBzdHlsZVtwXSA9IGNzW3BdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0eWxlLnRvcCA9IHRvcDtcbiAgICAgIHN0eWxlLmxlZnQgPSBsZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5jc3NUZXh0ID0gZWxlbWVudC5fc3RPcmlnO1xuICAgIH1cblxuICAgIGdzYXAuY29yZS5nZXRDYWNoZShlbGVtZW50KS51bmNhY2hlID0gMTtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gIH1cbn0sXG4gICAgX2ludGVycnVwdGlvblRyYWNrZXIgPSBmdW5jdGlvbiBfaW50ZXJydXB0aW9uVHJhY2tlcihnZXRWYWx1ZUZ1bmMsIGluaXRpYWxWYWx1ZSwgb25JbnRlcnJ1cHQpIHtcbiAgdmFyIGxhc3QxID0gaW5pdGlhbFZhbHVlLFxuICAgICAgbGFzdDIgPSBsYXN0MTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBjdXJyZW50ID0gTWF0aC5yb3VuZChnZXRWYWx1ZUZ1bmMoKSk7IC8vIHJvdW5kIGJlY2F1c2UgaW4gc29tZSBbdmVyeSB1bmNvbW1vbl0gV2luZG93cyBlbnZpcm9ubWVudHMsIHNjcm9sbCBjYW4gZ2V0IHJlcG9ydGVkIHdpdGggZGVjaW1hbHMgZXZlbiB0aG91Z2ggaXQgd2FzIHNldCB3aXRob3V0LlxuXG4gICAgaWYgKGN1cnJlbnQgIT09IGxhc3QxICYmIGN1cnJlbnQgIT09IGxhc3QyICYmIE1hdGguYWJzKGN1cnJlbnQgLSBsYXN0MSkgPiAzICYmIE1hdGguYWJzKGN1cnJlbnQgLSBsYXN0MikgPiAzKSB7XG4gICAgICAvLyBpZiB0aGUgdXNlciBzY3JvbGxzLCBraWxsIHRoZSB0d2Vlbi4gaU9TIFNhZmFyaSBpbnRlcm1pdHRlbnRseSBtaXNyZXBvcnRzIHRoZSBzY3JvbGwgcG9zaXRpb24sIGl0IG1heSBiZSB0aGUgbW9zdCByZWNlbnRseS1zZXQgb25lIG9yIHRoZSBvbmUgYmVmb3JlIHRoYXQhIFdoZW4gU2FmYXJpIGlzIHpvb21lZCAoQ01ELSspLCBpdCBvZnRlbiBtaXNyZXBvcnRzIGFzIDEgcGl4ZWwgb2ZmIHRvbyEgU28gaWYgd2Ugc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gdG8gMTI1LCBmb3IgZXhhbXBsZSwgaXQnbGwgYWN0dWFsbHkgcmVwb3J0IGl0IGFzIDEyNC5cbiAgICAgIHZhbHVlID0gY3VycmVudDtcbiAgICAgIG9uSW50ZXJydXB0ICYmIG9uSW50ZXJydXB0KCk7XG4gICAgfVxuXG4gICAgbGFzdDIgPSBsYXN0MTtcbiAgICBsYXN0MSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn0sXG4gICAgX3NoaWZ0TWFya2VyID0gZnVuY3Rpb24gX3NoaWZ0TWFya2VyKG1hcmtlciwgZGlyZWN0aW9uLCB2YWx1ZSkge1xuICB2YXIgdmFycyA9IHt9O1xuICB2YXJzW2RpcmVjdGlvbi5wXSA9IFwiKz1cIiArIHZhbHVlO1xuICBnc2FwLnNldChtYXJrZXIsIHZhcnMpO1xufSxcbiAgICAvLyBfbWVyZ2VBbmltYXRpb25zID0gYW5pbWF0aW9ucyA9PiB7XG4vLyBcdGxldCB0bCA9IGdzYXAudGltZWxpbmUoe3Ntb290aENoaWxkVGltaW5nOiB0cnVlfSkuc3RhcnRUaW1lKE1hdGgubWluKC4uLmFuaW1hdGlvbnMubWFwKGEgPT4gYS5nbG9iYWxUaW1lKDApKSkpO1xuLy8gXHRhbmltYXRpb25zLmZvckVhY2goYSA9PiB7bGV0IHRpbWUgPSBhLnRvdGFsVGltZSgpOyB0bC5hZGQoYSk7IGEudG90YWxUaW1lKHRpbWUpOyB9KTtcbi8vIFx0dGwuc21vb3RoQ2hpbGRUaW1pbmcgPSBmYWxzZTtcbi8vIFx0cmV0dXJuIHRsO1xuLy8gfSxcbi8vIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHR3ZWVuIHRoZSBzY3JvbGwgcG9zaXRpb24gaW4gdGhlIGRpcmVjdGlvbiBwcm92aWRlZCwgYW5kIHdoZW4gZG9pbmcgc28gaXQnbGwgYWRkIGEgLnR3ZWVuIHByb3BlcnR5IHRvIHRoZSBGVU5DVElPTiBpdHNlbGYsIGFuZCByZW1vdmUgaXQgd2hlbiB0aGUgdHdlZW4gY29tcGxldGVzIG9yIGdldHMga2lsbGVkLiBUaGlzIGdpdmVzIHVzIGEgd2F5IHRvIGhhdmUgbXVsdGlwbGUgU2Nyb2xsVHJpZ2dlcnMgdXNlIGEgY2VudHJhbCBmdW5jdGlvbiBmb3IgYW55IGdpdmVuIHNjcm9sbGVyIGFuZCBzZWUgaWYgdGhlcmUncyBhIHNjcm9sbCB0d2VlbiBydW5uaW5nICh3aGljaCB3b3VsZCBhZmZlY3QgaWYvaG93IHRoaW5ncyBnZXQgdXBkYXRlZClcbl9nZXRUd2VlbkNyZWF0b3IgPSBmdW5jdGlvbiBfZ2V0VHdlZW5DcmVhdG9yKHNjcm9sbGVyLCBkaXJlY3Rpb24pIHtcbiAgdmFyIGdldFNjcm9sbCA9IF9nZXRTY3JvbGxGdW5jKHNjcm9sbGVyLCBkaXJlY3Rpb24pLFxuICAgICAgcHJvcCA9IFwiX3Njcm9sbFwiICsgZGlyZWN0aW9uLnAyLFxuICAgICAgLy8gYWRkIGEgdHdlZW5hYmxlIHByb3BlcnR5IHRvIHRoZSBzY3JvbGxlciB0aGF0J3MgYSBnZXR0ZXIvc2V0dGVyIGZ1bmN0aW9uLCBsaWtlIF9zY3JvbGxUb3Agb3IgX3Njcm9sbExlZnQuIFRoaXMgd2F5LCBpZiBzb21lb25lIGRvZXMgZ3NhcC5raWxsVHdlZW5zT2Yoc2Nyb2xsZXIpIGl0J2xsIGtpbGwgdGhlIHNjcm9sbCB0d2Vlbi5cbiAgZ2V0VHdlZW4gPSBmdW5jdGlvbiBnZXRUd2VlbihzY3JvbGxUbywgdmFycywgaW5pdGlhbFZhbHVlLCBjaGFuZ2UxLCBjaGFuZ2UyKSB7XG4gICAgdmFyIHR3ZWVuID0gZ2V0VHdlZW4udHdlZW4sXG4gICAgICAgIG9uQ29tcGxldGUgPSB2YXJzLm9uQ29tcGxldGUsXG4gICAgICAgIG1vZGlmaWVycyA9IHt9O1xuICAgIGluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZSB8fCBnZXRTY3JvbGwoKTtcblxuICAgIHZhciBjaGVja0ZvckludGVycnVwdGlvbiA9IF9pbnRlcnJ1cHRpb25UcmFja2VyKGdldFNjcm9sbCwgaW5pdGlhbFZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0d2Vlbi5raWxsKCk7XG4gICAgICBnZXRUd2Vlbi50d2VlbiA9IDA7XG4gICAgfSk7XG5cbiAgICBjaGFuZ2UyID0gY2hhbmdlMSAmJiBjaGFuZ2UyIHx8IDA7IC8vIGlmIGNoYW5nZTEgaXMgMCwgd2Ugc2V0IHRoYXQgdG8gdGhlIGRpZmZlcmVuY2UgYW5kIGlnbm9yZSBjaGFuZ2UyLiBPdGhlcndpc2UsIHRoZXJlIHdvdWxkIGJlIGEgY29tcG91bmQgZWZmZWN0LlxuXG4gICAgY2hhbmdlMSA9IGNoYW5nZTEgfHwgc2Nyb2xsVG8gLSBpbml0aWFsVmFsdWU7XG4gICAgdHdlZW4gJiYgdHdlZW4ua2lsbCgpO1xuICAgIHZhcnNbcHJvcF0gPSBzY3JvbGxUbztcbiAgICB2YXJzLmluaGVyaXQgPSBmYWxzZTtcbiAgICB2YXJzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcblxuICAgIG1vZGlmaWVyc1twcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjaGVja0ZvckludGVycnVwdGlvbihpbml0aWFsVmFsdWUgKyBjaGFuZ2UxICogdHdlZW4ucmF0aW8gKyBjaGFuZ2UyICogdHdlZW4ucmF0aW8gKiB0d2Vlbi5yYXRpbyk7XG4gICAgfTtcblxuICAgIHZhcnMub25VcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfc2Nyb2xsZXJzLmNhY2hlKys7XG4gICAgICBnZXRUd2Vlbi50d2VlbiAmJiBfdXBkYXRlQWxsKCk7IC8vIGlmIGl0IHdhcyBpbnRlcnJ1cHRlZC9raWxsZWQsIGxpa2UgaW4gYSBjb250ZXh0LnJldmVydCgpLCBkb24ndCBmb3JjZSBhbiB1cGRhdGVBbGwoKVxuICAgIH07XG5cbiAgICB2YXJzLm9uQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBnZXRUd2Vlbi50d2VlbiA9IDA7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUuY2FsbCh0d2Vlbik7XG4gICAgfTtcblxuICAgIHR3ZWVuID0gZ2V0VHdlZW4udHdlZW4gPSBnc2FwLnRvKHNjcm9sbGVyLCB2YXJzKTtcbiAgICByZXR1cm4gdHdlZW47XG4gIH07XG5cbiAgc2Nyb2xsZXJbcHJvcF0gPSBnZXRTY3JvbGw7XG5cbiAgZ2V0U2Nyb2xsLndoZWVsSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0VHdlZW4udHdlZW4gJiYgZ2V0VHdlZW4udHdlZW4ua2lsbCgpICYmIChnZXRUd2Vlbi50d2VlbiA9IDApO1xuICB9O1xuXG4gIF9hZGRMaXN0ZW5lcihzY3JvbGxlciwgXCJ3aGVlbFwiLCBnZXRTY3JvbGwud2hlZWxIYW5kbGVyKTsgLy8gV2luZG93cyBtYWNoaW5lcyBoYW5kbGUgbW91c2V3aGVlbCBzY3JvbGxpbmcgaW4gY2h1bmtzIChsaWtlIFwiMyBsaW5lcyBwZXIgc2Nyb2xsXCIpIG1lYW5pbmcgdGhlIHR5cGljYWwgc3RyYXRlZ3kgZm9yIGNhbmNlbGxpbmcgdGhlIHNjcm9sbCBpc24ndCBhcyBzZW5zaXRpdmUuIEl0J3MgbXVjaCBtb3JlIGxpa2VseSB0byBtYXRjaCBvbmUgb2YgdGhlIHByZXZpb3VzIDIgc2Nyb2xsIGV2ZW50IHBvc2l0aW9ucy4gU28gd2Uga2lsbCBhbnkgc25hcHBpbmcgYXMgc29vbiBhcyB0aGVyZSdzIGEgd2hlZWwgZXZlbnQuXG5cblxuICBTY3JvbGxUcmlnZ2VyLmlzVG91Y2ggJiYgX2FkZExpc3RlbmVyKHNjcm9sbGVyLCBcInRvdWNobW92ZVwiLCBnZXRTY3JvbGwud2hlZWxIYW5kbGVyKTtcbiAgcmV0dXJuIGdldFR3ZWVuO1xufTtcblxuZXhwb3J0IHZhciBTY3JvbGxUcmlnZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2Nyb2xsVHJpZ2dlcih2YXJzLCBhbmltYXRpb24pIHtcbiAgICBfY29yZUluaXR0ZWQgfHwgU2Nyb2xsVHJpZ2dlci5yZWdpc3Rlcihnc2FwKSB8fCBjb25zb2xlLndhcm4oXCJQbGVhc2UgZ3NhcC5yZWdpc3RlclBsdWdpbihTY3JvbGxUcmlnZ2VyKVwiKTtcblxuICAgIF9jb250ZXh0KHRoaXMpO1xuXG4gICAgdGhpcy5pbml0KHZhcnMsIGFuaW1hdGlvbik7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2Nyb2xsVHJpZ2dlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KHZhcnMsIGFuaW1hdGlvbikge1xuICAgIHRoaXMucHJvZ3Jlc3MgPSB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLnZhcnMgJiYgdGhpcy5raWxsKHRydWUsIHRydWUpOyAvLyBpbiBjYXNlIGl0J3MgYmVpbmcgaW5pdHRlZCBhZ2FpblxuXG4gICAgaWYgKCFfZW5hYmxlZCkge1xuICAgICAgdGhpcy51cGRhdGUgPSB0aGlzLnJlZnJlc2ggPSB0aGlzLmtpbGwgPSBfcGFzc1Rocm91Z2g7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFycyA9IF9zZXREZWZhdWx0cyhfaXNTdHJpbmcodmFycykgfHwgX2lzTnVtYmVyKHZhcnMpIHx8IHZhcnMubm9kZVR5cGUgPyB7XG4gICAgICB0cmlnZ2VyOiB2YXJzXG4gICAgfSA6IHZhcnMsIF9kZWZhdWx0cyk7XG5cbiAgICB2YXIgX3ZhcnMgPSB2YXJzLFxuICAgICAgICBvblVwZGF0ZSA9IF92YXJzLm9uVXBkYXRlLFxuICAgICAgICB0b2dnbGVDbGFzcyA9IF92YXJzLnRvZ2dsZUNsYXNzLFxuICAgICAgICBpZCA9IF92YXJzLmlkLFxuICAgICAgICBvblRvZ2dsZSA9IF92YXJzLm9uVG9nZ2xlLFxuICAgICAgICBvblJlZnJlc2ggPSBfdmFycy5vblJlZnJlc2gsXG4gICAgICAgIHNjcnViID0gX3ZhcnMuc2NydWIsXG4gICAgICAgIHRyaWdnZXIgPSBfdmFycy50cmlnZ2VyLFxuICAgICAgICBwaW4gPSBfdmFycy5waW4sXG4gICAgICAgIHBpblNwYWNpbmcgPSBfdmFycy5waW5TcGFjaW5nLFxuICAgICAgICBpbnZhbGlkYXRlT25SZWZyZXNoID0gX3ZhcnMuaW52YWxpZGF0ZU9uUmVmcmVzaCxcbiAgICAgICAgYW50aWNpcGF0ZVBpbiA9IF92YXJzLmFudGljaXBhdGVQaW4sXG4gICAgICAgIG9uU2NydWJDb21wbGV0ZSA9IF92YXJzLm9uU2NydWJDb21wbGV0ZSxcbiAgICAgICAgb25TbmFwQ29tcGxldGUgPSBfdmFycy5vblNuYXBDb21wbGV0ZSxcbiAgICAgICAgb25jZSA9IF92YXJzLm9uY2UsXG4gICAgICAgIHNuYXAgPSBfdmFycy5zbmFwLFxuICAgICAgICBwaW5SZXBhcmVudCA9IF92YXJzLnBpblJlcGFyZW50LFxuICAgICAgICBwaW5TcGFjZXIgPSBfdmFycy5waW5TcGFjZXIsXG4gICAgICAgIGNvbnRhaW5lckFuaW1hdGlvbiA9IF92YXJzLmNvbnRhaW5lckFuaW1hdGlvbixcbiAgICAgICAgZmFzdFNjcm9sbEVuZCA9IF92YXJzLmZhc3RTY3JvbGxFbmQsXG4gICAgICAgIHByZXZlbnRPdmVybGFwcyA9IF92YXJzLnByZXZlbnRPdmVybGFwcyxcbiAgICAgICAgZGlyZWN0aW9uID0gdmFycy5ob3Jpem9udGFsIHx8IHZhcnMuY29udGFpbmVyQW5pbWF0aW9uICYmIHZhcnMuaG9yaXpvbnRhbCAhPT0gZmFsc2UgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCxcbiAgICAgICAgaXNUb2dnbGUgPSAhc2NydWIgJiYgc2NydWIgIT09IDAsXG4gICAgICAgIHNjcm9sbGVyID0gX2dldFRhcmdldCh2YXJzLnNjcm9sbGVyIHx8IF93aW4pLFxuICAgICAgICBzY3JvbGxlckNhY2hlID0gZ3NhcC5jb3JlLmdldENhY2hlKHNjcm9sbGVyKSxcbiAgICAgICAgaXNWaWV3cG9ydCA9IF9pc1ZpZXdwb3J0KHNjcm9sbGVyKSxcbiAgICAgICAgdXNlRml4ZWRQb3NpdGlvbiA9IChcInBpblR5cGVcIiBpbiB2YXJzID8gdmFycy5waW5UeXBlIDogX2dldFByb3h5UHJvcChzY3JvbGxlciwgXCJwaW5UeXBlXCIpIHx8IGlzVmlld3BvcnQgJiYgXCJmaXhlZFwiKSA9PT0gXCJmaXhlZFwiLFxuICAgICAgICBjYWxsYmFja3MgPSBbdmFycy5vbkVudGVyLCB2YXJzLm9uTGVhdmUsIHZhcnMub25FbnRlckJhY2ssIHZhcnMub25MZWF2ZUJhY2tdLFxuICAgICAgICB0b2dnbGVBY3Rpb25zID0gaXNUb2dnbGUgJiYgdmFycy50b2dnbGVBY3Rpb25zLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgbWFya2VycyA9IFwibWFya2Vyc1wiIGluIHZhcnMgPyB2YXJzLm1hcmtlcnMgOiBfZGVmYXVsdHMubWFya2VycyxcbiAgICAgICAgYm9yZGVyV2lkdGggPSBpc1ZpZXdwb3J0ID8gMCA6IHBhcnNlRmxvYXQoX2dldENvbXB1dGVkU3R5bGUoc2Nyb2xsZXIpW1wiYm9yZGVyXCIgKyBkaXJlY3Rpb24ucDIgKyBfV2lkdGhdKSB8fCAwLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgb25SZWZyZXNoSW5pdCA9IHZhcnMub25SZWZyZXNoSW5pdCAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdmFycy5vblJlZnJlc2hJbml0KHNlbGYpO1xuICAgIH0sXG4gICAgICAgIGdldFNjcm9sbGVyU2l6ZSA9IF9nZXRTaXplRnVuYyhzY3JvbGxlciwgaXNWaWV3cG9ydCwgZGlyZWN0aW9uKSxcbiAgICAgICAgZ2V0U2Nyb2xsZXJPZmZzZXRzID0gX2dldE9mZnNldHNGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0KSxcbiAgICAgICAgbGFzdFNuYXAgPSAwLFxuICAgICAgICBsYXN0UmVmcmVzaCA9IDAsXG4gICAgICAgIHByZXZQcm9ncmVzcyA9IDAsXG4gICAgICAgIHNjcm9sbEZ1bmMgPSBfZ2V0U2Nyb2xsRnVuYyhzY3JvbGxlciwgZGlyZWN0aW9uKSxcbiAgICAgICAgdHdlZW5UbyxcbiAgICAgICAgcGluQ2FjaGUsXG4gICAgICAgIHNuYXBGdW5jLFxuICAgICAgICBzY3JvbGwxLFxuICAgICAgICBzY3JvbGwyLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kLFxuICAgICAgICBtYXJrZXJTdGFydCxcbiAgICAgICAgbWFya2VyRW5kLFxuICAgICAgICBtYXJrZXJTdGFydFRyaWdnZXIsXG4gICAgICAgIG1hcmtlckVuZFRyaWdnZXIsXG4gICAgICAgIG1hcmtlclZhcnMsXG4gICAgICAgIGV4ZWN1dGluZ09uUmVmcmVzaCxcbiAgICAgICAgY2hhbmdlLFxuICAgICAgICBwaW5PcmlnaW5hbFN0YXRlLFxuICAgICAgICBwaW5BY3RpdmVTdGF0ZSxcbiAgICAgICAgcGluU3RhdGUsXG4gICAgICAgIHNwYWNlcixcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBwaW5HZXR0ZXIsXG4gICAgICAgIHBpblNldHRlcixcbiAgICAgICAgcGluU3RhcnQsXG4gICAgICAgIHBpbkNoYW5nZSxcbiAgICAgICAgc3BhY2luZ1N0YXJ0LFxuICAgICAgICBzcGFjZXJTdGF0ZSxcbiAgICAgICAgbWFya2VyU3RhcnRTZXR0ZXIsXG4gICAgICAgIHBpbk1vdmVzLFxuICAgICAgICBtYXJrZXJFbmRTZXR0ZXIsXG4gICAgICAgIGNzLFxuICAgICAgICBzbmFwMSxcbiAgICAgICAgc25hcDIsXG4gICAgICAgIHNjcnViVHdlZW4sXG4gICAgICAgIHNjcnViU21vb3RoLFxuICAgICAgICBzbmFwRHVyQ2xhbXAsXG4gICAgICAgIHNuYXBEZWxheWVkQ2FsbCxcbiAgICAgICAgcHJldlNjcm9sbCxcbiAgICAgICAgcHJldkFuaW1Qcm9ncmVzcyxcbiAgICAgICAgY2FNYXJrZXJTZXR0ZXIsXG4gICAgICAgIGN1c3RvbVJldmVydFJldHVybjsgLy8gZm9yIHRoZSBzYWtlIG9mIGVmZmljaWVuY3ksIF9zdGFydENsYW1wL19lbmRDbGFtcCBzZXJ2ZSBsaWtlIGEgdHJ1dGh5IHZhbHVlIGluZGljYXRpbmcgdGhhdCBjbGFtcGluZyB3YXMgZW5hYmxlZCBvbiB0aGUgc3RhcnQvZW5kLCBhbmQgQUxTTyBzdG9yZSB0aGUgYWN0dWFsIHByZS1jbGFtcGVkIG51bWVyaWMgdmFsdWUuIFdlIHRhcCBpbnRvIHRoYXQgaW4gU2Nyb2xsU21vb3RoZXIgZm9yIHNwZWVkIGVmZmVjdHMuIFNvIGZvciBleGFtcGxlLCBpZiBzdGFydD1cImNsYW1wKHRvcCBib3R0b20pXCIgcmVzdWx0cyBpbiBhIHN0YXJ0IG9mIC0xMDAgbmF0dXJhbGx5LCBpdCB3b3VsZCBnZXQgY2xhbXBlZCB0byAwIGJ1dCAtMTAwIHdvdWxkIGJlIHN0b3JlZCBpbiBfc3RhcnRDbGFtcC5cblxuXG4gICAgc2VsZi5fc3RhcnRDbGFtcCA9IHNlbGYuX2VuZENsYW1wID0gZmFsc2U7XG4gICAgc2VsZi5fZGlyID0gZGlyZWN0aW9uO1xuICAgIGFudGljaXBhdGVQaW4gKj0gNDU7XG4gICAgc2VsZi5zY3JvbGxlciA9IHNjcm9sbGVyO1xuICAgIHNlbGYuc2Nyb2xsID0gY29udGFpbmVyQW5pbWF0aW9uID8gY29udGFpbmVyQW5pbWF0aW9uLnRpbWUuYmluZChjb250YWluZXJBbmltYXRpb24pIDogc2Nyb2xsRnVuYztcbiAgICBzY3JvbGwxID0gc2Nyb2xsRnVuYygpO1xuICAgIHNlbGYudmFycyA9IHZhcnM7XG4gICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uIHx8IHZhcnMuYW5pbWF0aW9uO1xuXG4gICAgaWYgKFwicmVmcmVzaFByaW9yaXR5XCIgaW4gdmFycykge1xuICAgICAgX3NvcnQgPSAxO1xuICAgICAgdmFycy5yZWZyZXNoUHJpb3JpdHkgPT09IC05OTk5ICYmIChfcHJpbWFyeSA9IHNlbGYpOyAvLyB1c2VkIGJ5IFNjcm9sbFNtb290aGVyXG4gICAgfVxuXG4gICAgc2Nyb2xsZXJDYWNoZS50d2VlblNjcm9sbCA9IHNjcm9sbGVyQ2FjaGUudHdlZW5TY3JvbGwgfHwge1xuICAgICAgdG9wOiBfZ2V0VHdlZW5DcmVhdG9yKHNjcm9sbGVyLCBfdmVydGljYWwpLFxuICAgICAgbGVmdDogX2dldFR3ZWVuQ3JlYXRvcihzY3JvbGxlciwgX2hvcml6b250YWwpXG4gICAgfTtcbiAgICBzZWxmLnR3ZWVuVG8gPSB0d2VlblRvID0gc2Nyb2xsZXJDYWNoZS50d2VlblNjcm9sbFtkaXJlY3Rpb24ucF07XG5cbiAgICBzZWxmLnNjcnViRHVyYXRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHNjcnViU21vb3RoID0gX2lzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZTtcblxuICAgICAgaWYgKCFzY3J1YlNtb290aCkge1xuICAgICAgICBzY3J1YlR3ZWVuICYmIHNjcnViVHdlZW4ucHJvZ3Jlc3MoMSkua2lsbCgpO1xuICAgICAgICBzY3J1YlR3ZWVuID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcnViVHdlZW4gPyBzY3J1YlR3ZWVuLmR1cmF0aW9uKHZhbHVlKSA6IHNjcnViVHdlZW4gPSBnc2FwLnRvKGFuaW1hdGlvbiwge1xuICAgICAgICAgIGVhc2U6IFwiZXhwb1wiLFxuICAgICAgICAgIHRvdGFsUHJvZ3Jlc3M6IFwiKz0wXCIsXG4gICAgICAgICAgaW5oZXJpdDogZmFsc2UsXG4gICAgICAgICAgZHVyYXRpb246IHNjcnViU21vb3RoLFxuICAgICAgICAgIHBhdXNlZDogdHJ1ZSxcbiAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9uU2NydWJDb21wbGV0ZSAmJiBvblNjcnViQ29tcGxldGUoc2VsZik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgYW5pbWF0aW9uLnZhcnMubGF6eSA9IGZhbHNlO1xuICAgICAgYW5pbWF0aW9uLl9pbml0dGVkICYmICFzZWxmLmlzUmV2ZXJ0ZWQgfHwgYW5pbWF0aW9uLnZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZSAmJiB2YXJzLmltbWVkaWF0ZVJlbmRlciAhPT0gZmFsc2UgJiYgYW5pbWF0aW9uLmR1cmF0aW9uKCkgJiYgYW5pbWF0aW9uLnJlbmRlcigwLCB0cnVlLCB0cnVlKTsgLy8gc3BlY2lhbCBjYXNlOiBpZiB0aGlzIFNjcm9sbFRyaWdnZXIgZ2V0cyByZS1pbml0dGVkLCBhIGZyb20oKSB0d2VlbiB3aXRoIGEgc3RhZ2dlciBjb3VsZCBnZXQgaW5pdHRlZCBpbml0aWFsbHkgYW5kIHRoZW4gcmV2ZXJ0ZWQgb24gdGhlIHJlLWluaXQgd2hpY2ggbWVhbnMgaXQnbGwgbmVlZCB0byBnZXQgcmVuZGVyZWQgYWdhaW4gaGVyZSB0byBwcm9wZXJseSBkaXNwbGF5IHRoaW5ncy4gT3RoZXJ3aXNlLCBTZWUgaHR0cHM6Ly9nc2FwLmNvbS9mb3J1bXMvdG9waWMvMzY3Nzctc2Nyb2xsc21vb3RoZXItc3BsaXR0ZXh0LW5leHRqcy8gYW5kIGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuL2VZUHlQcGQ/ZWRpdG9ycz0wMDEwXG5cbiAgICAgIHNlbGYuYW5pbWF0aW9uID0gYW5pbWF0aW9uLnBhdXNlKCk7XG4gICAgICBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlciA9IHNlbGY7XG4gICAgICBzZWxmLnNjcnViRHVyYXRpb24oc2NydWIpO1xuICAgICAgc25hcDEgPSAwO1xuICAgICAgaWQgfHwgKGlkID0gYW5pbWF0aW9uLnZhcnMuaWQpO1xuICAgIH1cblxuICAgIGlmIChzbmFwKSB7XG4gICAgICAvLyBUT0RPOiBwb3RlbnRpYWwgaWRlYTogdXNlIGxlZ2l0aW1hdGUgQ1NTIHNjcm9sbCBzbmFwcGluZyBieSBwdXNoaW5nIGludmlzaWJsZSBlbGVtZW50cyBpbnRvIHRoZSBET00gdGhhdCBzZXJ2ZSBhcyBzbmFwIHBvc2l0aW9ucywgYW5kIHRvZ2dsZSB0aGUgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudC5zdHlsZS5zY3JvbGxTbmFwVHlwZSBvblRvZ2dsZS4gU2VlIGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuL0pqTHJnV00gZm9yIGEgcXVpY2sgcHJvb2Ygb2YgY29uY2VwdC5cbiAgICAgIGlmICghX2lzT2JqZWN0KHNuYXApIHx8IHNuYXAucHVzaCkge1xuICAgICAgICBzbmFwID0ge1xuICAgICAgICAgIHNuYXBUbzogc25hcFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBcInNjcm9sbEJlaGF2aW9yXCIgaW4gX2JvZHkuc3R5bGUgJiYgZ3NhcC5zZXQoaXNWaWV3cG9ydCA/IFtfYm9keSwgX2RvY0VsXSA6IHNjcm9sbGVyLCB7XG4gICAgICAgIHNjcm9sbEJlaGF2aW9yOiBcImF1dG9cIlxuICAgICAgfSk7IC8vIHNtb290aCBzY3JvbGxpbmcgZG9lc24ndCB3b3JrIHdpdGggc25hcC5cblxuICAgICAgX3Njcm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBfaXNGdW5jdGlvbihvKSAmJiBvLnRhcmdldCA9PT0gKGlzVmlld3BvcnQgPyBfZG9jLnNjcm9sbGluZ0VsZW1lbnQgfHwgX2RvY0VsIDogc2Nyb2xsZXIpICYmIChvLnNtb290aCA9IGZhbHNlKTtcbiAgICAgIH0pOyAvLyBub3RlOiBzZXQgc21vb3RoIHRvIGZhbHNlIG9uIGJvdGggdGhlIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIHNjcm9sbCBnZXR0ZXJzL3NldHRlcnNcblxuXG4gICAgICBzbmFwRnVuYyA9IF9pc0Z1bmN0aW9uKHNuYXAuc25hcFRvKSA/IHNuYXAuc25hcFRvIDogc25hcC5zbmFwVG8gPT09IFwibGFiZWxzXCIgPyBfZ2V0Q2xvc2VzdExhYmVsKGFuaW1hdGlvbikgOiBzbmFwLnNuYXBUbyA9PT0gXCJsYWJlbHNEaXJlY3Rpb25hbFwiID8gX2dldExhYmVsQXREaXJlY3Rpb24oYW5pbWF0aW9uKSA6IHNuYXAuZGlyZWN0aW9uYWwgIT09IGZhbHNlID8gZnVuY3Rpb24gKHZhbHVlLCBzdCkge1xuICAgICAgICByZXR1cm4gX3NuYXBEaXJlY3Rpb25hbChzbmFwLnNuYXBUbykodmFsdWUsIF9nZXRUaW1lKCkgLSBsYXN0UmVmcmVzaCA8IDUwMCA/IDAgOiBzdC5kaXJlY3Rpb24pO1xuICAgICAgfSA6IGdzYXAudXRpbHMuc25hcChzbmFwLnNuYXBUbyk7XG4gICAgICBzbmFwRHVyQ2xhbXAgPSBzbmFwLmR1cmF0aW9uIHx8IHtcbiAgICAgICAgbWluOiAwLjEsXG4gICAgICAgIG1heDogMlxuICAgICAgfTtcbiAgICAgIHNuYXBEdXJDbGFtcCA9IF9pc09iamVjdChzbmFwRHVyQ2xhbXApID8gX2NsYW1wKHNuYXBEdXJDbGFtcC5taW4sIHNuYXBEdXJDbGFtcC5tYXgpIDogX2NsYW1wKHNuYXBEdXJDbGFtcCwgc25hcER1ckNsYW1wKTtcbiAgICAgIHNuYXBEZWxheWVkQ2FsbCA9IGdzYXAuZGVsYXllZENhbGwoc25hcC5kZWxheSB8fCBzY3J1YlNtb290aCAvIDIgfHwgMC4xLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY3JvbGwgPSBzY3JvbGxGdW5jKCksXG4gICAgICAgICAgICByZWZyZXNoZWRSZWNlbnRseSA9IF9nZXRUaW1lKCkgLSBsYXN0UmVmcmVzaCA8IDUwMCxcbiAgICAgICAgICAgIHR3ZWVuID0gdHdlZW5Uby50d2VlbjtcblxuICAgICAgICBpZiAoKHJlZnJlc2hlZFJlY2VudGx5IHx8IE1hdGguYWJzKHNlbGYuZ2V0VmVsb2NpdHkoKSkgPCAxMCkgJiYgIXR3ZWVuICYmICFfcG9pbnRlcklzRG93biAmJiBsYXN0U25hcCAhPT0gc2Nyb2xsKSB7XG4gICAgICAgICAgdmFyIHByb2dyZXNzID0gKHNjcm9sbCAtIHN0YXJ0KSAvIGNoYW5nZSxcbiAgICAgICAgICAgICAgdG90YWxQcm9ncmVzcyA9IGFuaW1hdGlvbiAmJiAhaXNUb2dnbGUgPyBhbmltYXRpb24udG90YWxQcm9ncmVzcygpIDogcHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHZlbG9jaXR5ID0gcmVmcmVzaGVkUmVjZW50bHkgPyAwIDogKHRvdGFsUHJvZ3Jlc3MgLSBzbmFwMikgLyAoX2dldFRpbWUoKSAtIF90aW1lMikgKiAxMDAwIHx8IDAsXG4gICAgICAgICAgICAgIGNoYW5nZTEgPSBnc2FwLnV0aWxzLmNsYW1wKC1wcm9ncmVzcywgMSAtIHByb2dyZXNzLCBfYWJzKHZlbG9jaXR5IC8gMikgKiB2ZWxvY2l0eSAvIDAuMTg1KSxcbiAgICAgICAgICAgICAgbmF0dXJhbEVuZCA9IHByb2dyZXNzICsgKHNuYXAuaW5lcnRpYSA9PT0gZmFsc2UgPyAwIDogY2hhbmdlMSksXG4gICAgICAgICAgICAgIGVuZFZhbHVlLFxuICAgICAgICAgICAgICBlbmRTY3JvbGwsXG4gICAgICAgICAgICAgIF9zbmFwID0gc25hcCxcbiAgICAgICAgICAgICAgb25TdGFydCA9IF9zbmFwLm9uU3RhcnQsXG4gICAgICAgICAgICAgIF9vbkludGVycnVwdCA9IF9zbmFwLm9uSW50ZXJydXB0LFxuICAgICAgICAgICAgICBfb25Db21wbGV0ZSA9IF9zbmFwLm9uQ29tcGxldGU7XG4gICAgICAgICAgZW5kVmFsdWUgPSBzbmFwRnVuYyhuYXR1cmFsRW5kLCBzZWxmKTtcbiAgICAgICAgICBfaXNOdW1iZXIoZW5kVmFsdWUpIHx8IChlbmRWYWx1ZSA9IG5hdHVyYWxFbmQpOyAvLyBpbiBjYXNlIHRoZSBmdW5jdGlvbiBkaWRuJ3QgcmV0dXJuIGEgbnVtYmVyLCBmYWxsIGJhY2sgdG8gdXNpbmcgdGhlIG5hdHVyYWxFbmRcblxuICAgICAgICAgIGVuZFNjcm9sbCA9IE1hdGgucm91bmQoc3RhcnQgKyBlbmRWYWx1ZSAqIGNoYW5nZSk7XG5cbiAgICAgICAgICBpZiAoc2Nyb2xsIDw9IGVuZCAmJiBzY3JvbGwgPj0gc3RhcnQgJiYgZW5kU2Nyb2xsICE9PSBzY3JvbGwpIHtcbiAgICAgICAgICAgIGlmICh0d2VlbiAmJiAhdHdlZW4uX2luaXR0ZWQgJiYgdHdlZW4uZGF0YSA8PSBfYWJzKGVuZFNjcm9sbCAtIHNjcm9sbCkpIHtcbiAgICAgICAgICAgICAgLy8gdGhlcmUncyBhbiBvdmVybGFwcGluZyBzbmFwISBTbyB3ZSBtdXN0IGZpZ3VyZSBvdXQgd2hpY2ggb25lIGlzIGNsb3NlciBhbmQgbGV0IHRoYXQgdHdlZW4gbGl2ZS5cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc25hcC5pbmVydGlhID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBjaGFuZ2UxID0gZW5kVmFsdWUgLSBwcm9ncmVzcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHdlZW5UbyhlbmRTY3JvbGwsIHtcbiAgICAgICAgICAgICAgZHVyYXRpb246IHNuYXBEdXJDbGFtcChfYWJzKE1hdGgubWF4KF9hYnMobmF0dXJhbEVuZCAtIHRvdGFsUHJvZ3Jlc3MpLCBfYWJzKGVuZFZhbHVlIC0gdG90YWxQcm9ncmVzcykpICogMC4xODUgLyB2ZWxvY2l0eSAvIDAuMDUgfHwgMCkpLFxuICAgICAgICAgICAgICBlYXNlOiBzbmFwLmVhc2UgfHwgXCJwb3dlcjNcIixcbiAgICAgICAgICAgICAgZGF0YTogX2FicyhlbmRTY3JvbGwgLSBzY3JvbGwpLFxuICAgICAgICAgICAgICAvLyByZWNvcmQgdGhlIGRpc3RhbmNlIHNvIHRoYXQgaWYgYW5vdGhlciBzbmFwIHR3ZWVuIG9jY3VycyAoY29uZmxpY3QpIHdlIGNhbiBwcmlvcml0aXplIHRoZSBjbG9zZXN0IHNuYXAuXG4gICAgICAgICAgICAgIG9uSW50ZXJydXB0OiBmdW5jdGlvbiBvbkludGVycnVwdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc25hcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSkgJiYgX29uSW50ZXJydXB0ICYmIF9vbkludGVycnVwdChzZWxmKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIGxhc3RTbmFwID0gc2Nyb2xsRnVuYygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlc29sdXRpb24gb2YgdGhlIHNjcm9sbGJhciBpcyBsaW1pdGVkLCBzbyB3ZSBzaG91bGQgY29ycmVjdCB0aGUgc2NydWJiZWQgYW5pbWF0aW9uJ3MgcGxheWhlYWQgYXQgdGhlIGVuZCB0byBtYXRjaCBFWEFDVExZIHdoZXJlIGl0IHdhcyBzdXBwb3NlZCB0byBzbmFwXG4gICAgICAgICAgICAgICAgICBzY3J1YlR3ZWVuID8gc2NydWJUd2Vlbi5yZXNldFRvKFwidG90YWxQcm9ncmVzc1wiLCBlbmRWYWx1ZSwgYW5pbWF0aW9uLl90VGltZSAvIGFuaW1hdGlvbi5fdER1cikgOiBhbmltYXRpb24ucHJvZ3Jlc3MoZW5kVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNuYXAxID0gc25hcDIgPSBhbmltYXRpb24gJiYgIWlzVG9nZ2xlID8gYW5pbWF0aW9uLnRvdGFsUHJvZ3Jlc3MoKSA6IHNlbGYucHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgb25TbmFwQ29tcGxldGUgJiYgb25TbmFwQ29tcGxldGUoc2VsZik7XG4gICAgICAgICAgICAgICAgX29uQ29tcGxldGUgJiYgX29uQ29tcGxldGUoc2VsZik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHNjcm9sbCwgY2hhbmdlMSAqIGNoYW5nZSwgZW5kU2Nyb2xsIC0gc2Nyb2xsIC0gY2hhbmdlMSAqIGNoYW5nZSk7XG4gICAgICAgICAgICBvblN0YXJ0ICYmIG9uU3RhcnQoc2VsZiwgdHdlZW5Uby50d2Vlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNlbGYuaXNBY3RpdmUgJiYgbGFzdFNuYXAgIT09IHNjcm9sbCkge1xuICAgICAgICAgIHNuYXBEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KS5wYXVzZSgpO1xuICAgIH1cblxuICAgIGlkICYmIChfaWRzW2lkXSA9IHNlbGYpO1xuICAgIHRyaWdnZXIgPSBzZWxmLnRyaWdnZXIgPSBfZ2V0VGFyZ2V0KHRyaWdnZXIgfHwgcGluICE9PSB0cnVlICYmIHBpbik7IC8vIGlmIGEgdHJpZ2dlciBoYXMgc29tZSBraW5kIG9mIHNjcm9sbC1yZWxhdGVkIGVmZmVjdCBhcHBsaWVkIHRoYXQgY291bGQgY29udGFtaW5hdGUgdGhlIFwieVwiIG9yIFwieFwiIHBvc2l0aW9uIChsaWtlIGEgU2Nyb2xsU21vb3RoZXIgZWZmZWN0KSwgd2UgbmVlZGVkIGEgd2F5IHRvIHRlbXBvcmFyaWx5IHJldmVydCBpdCwgc28gd2UgdXNlIHRoZSBzdFJldmVydCBwcm9wZXJ0eSBvZiB0aGUgZ3NDYWNoZS4gSXQgY2FuIHJldHVybiBhbm90aGVyIGZ1bmN0aW9uIHRoYXQgd2UnbGwgY2FsbCBhdCB0aGUgZW5kIHNvIGl0IGNhbiByZXR1cm4gdG8gaXRzIG5vcm1hbCBzdGF0ZS5cblxuICAgIGN1c3RvbVJldmVydFJldHVybiA9IHRyaWdnZXIgJiYgdHJpZ2dlci5fZ3NhcCAmJiB0cmlnZ2VyLl9nc2FwLnN0UmV2ZXJ0O1xuICAgIGN1c3RvbVJldmVydFJldHVybiAmJiAoY3VzdG9tUmV2ZXJ0UmV0dXJuID0gY3VzdG9tUmV2ZXJ0UmV0dXJuKHNlbGYpKTtcbiAgICBwaW4gPSBwaW4gPT09IHRydWUgPyB0cmlnZ2VyIDogX2dldFRhcmdldChwaW4pO1xuICAgIF9pc1N0cmluZyh0b2dnbGVDbGFzcykgJiYgKHRvZ2dsZUNsYXNzID0ge1xuICAgICAgdGFyZ2V0czogdHJpZ2dlcixcbiAgICAgIGNsYXNzTmFtZTogdG9nZ2xlQ2xhc3NcbiAgICB9KTtcblxuICAgIGlmIChwaW4pIHtcbiAgICAgIHBpblNwYWNpbmcgPT09IGZhbHNlIHx8IHBpblNwYWNpbmcgPT09IF9tYXJnaW4gfHwgKHBpblNwYWNpbmcgPSAhcGluU3BhY2luZyAmJiBwaW4ucGFyZW50Tm9kZSAmJiBwaW4ucGFyZW50Tm9kZS5zdHlsZSAmJiBfZ2V0Q29tcHV0ZWRTdHlsZShwaW4ucGFyZW50Tm9kZSkuZGlzcGxheSA9PT0gXCJmbGV4XCIgPyBmYWxzZSA6IF9wYWRkaW5nKTsgLy8gaWYgdGhlIHBhcmVudCBpcyBkaXNwbGF5OiBmbGV4LCBkb24ndCBhcHBseSBwaW5TcGFjaW5nIGJ5IGRlZmF1bHQuIFdlIHNob3VsZCBjaGVjayB0aGF0IHBpbi5wYXJlbnROb2RlIGlzIGFuIGVsZW1lbnQgKG5vdCBzaGFkb3cgZG9tIHdpbmRvdylcblxuICAgICAgc2VsZi5waW4gPSBwaW47XG4gICAgICBwaW5DYWNoZSA9IGdzYXAuY29yZS5nZXRDYWNoZShwaW4pO1xuXG4gICAgICBpZiAoIXBpbkNhY2hlLnNwYWNlcikge1xuICAgICAgICAvLyByZWNvcmQgdGhlIHNwYWNlciBhbmQgcGluT3JpZ2luYWxTdGF0ZSBvbiB0aGUgY2FjaGUgaW4gY2FzZSBzb21lb25lIHRyaWVzIHBpbm5pbmcgdGhlIHNhbWUgZWxlbWVudCB3aXRoIE1VTFRJUExFIFNjcm9sbFRyaWdnZXJzIC0gd2UgZG9uJ3Qgd2FudCB0byBoYXZlIG11bHRpcGxlIHNwYWNlcnMgb3IgcmVjb3JkIHRoZSBcIm9yaWdpbmFsXCIgcGluIHN0YXRlIGFmdGVyIGl0IGhhcyBhbHJlYWR5IGJlZW4gYWZmZWN0ZWQgYnkgYW5vdGhlciBTY3JvbGxUcmlnZ2VyLlxuICAgICAgICBpZiAocGluU3BhY2VyKSB7XG4gICAgICAgICAgcGluU3BhY2VyID0gX2dldFRhcmdldChwaW5TcGFjZXIpO1xuICAgICAgICAgIHBpblNwYWNlciAmJiAhcGluU3BhY2VyLm5vZGVUeXBlICYmIChwaW5TcGFjZXIgPSBwaW5TcGFjZXIuY3VycmVudCB8fCBwaW5TcGFjZXIubmF0aXZlRWxlbWVudCk7IC8vIGZvciBSZWFjdCAmIEFuZ3VsYXJcblxuICAgICAgICAgIHBpbkNhY2hlLnNwYWNlcklzTmF0aXZlID0gISFwaW5TcGFjZXI7XG4gICAgICAgICAgcGluU3BhY2VyICYmIChwaW5DYWNoZS5zcGFjZXJTdGF0ZSA9IF9nZXRTdGF0ZShwaW5TcGFjZXIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBpbkNhY2hlLnNwYWNlciA9IHNwYWNlciA9IHBpblNwYWNlciB8fCBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHNwYWNlci5jbGFzc0xpc3QuYWRkKFwicGluLXNwYWNlclwiKTtcbiAgICAgICAgaWQgJiYgc3BhY2VyLmNsYXNzTGlzdC5hZGQoXCJwaW4tc3BhY2VyLVwiICsgaWQpO1xuICAgICAgICBwaW5DYWNoZS5waW5TdGF0ZSA9IHBpbk9yaWdpbmFsU3RhdGUgPSBfZ2V0U3RhdGUocGluKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBpbk9yaWdpbmFsU3RhdGUgPSBwaW5DYWNoZS5waW5TdGF0ZTtcbiAgICAgIH1cblxuICAgICAgdmFycy5mb3JjZTNEICE9PSBmYWxzZSAmJiBnc2FwLnNldChwaW4sIHtcbiAgICAgICAgZm9yY2UzRDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBzZWxmLnNwYWNlciA9IHNwYWNlciA9IHBpbkNhY2hlLnNwYWNlcjtcbiAgICAgIGNzID0gX2dldENvbXB1dGVkU3R5bGUocGluKTtcbiAgICAgIHNwYWNpbmdTdGFydCA9IGNzW3BpblNwYWNpbmcgKyBkaXJlY3Rpb24ub3MyXTtcbiAgICAgIHBpbkdldHRlciA9IGdzYXAuZ2V0UHJvcGVydHkocGluKTtcbiAgICAgIHBpblNldHRlciA9IGdzYXAucXVpY2tTZXR0ZXIocGluLCBkaXJlY3Rpb24uYSwgX3B4KTsgLy8gcGluLmZpcnN0Q2hpbGQgJiYgIV9tYXhTY3JvbGwocGluLCBkaXJlY3Rpb24pICYmIChwaW4uc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiKTsgLy8gcHJvdGVjdHMgZnJvbSBjb2xsYXBzaW5nIG1hcmdpbnMsIGJ1dCBjYW4gaGF2ZSB1bmludGVuZGVkIGNvbnNlcXVlbmNlcyBhcyBkZW1vbnN0cmF0ZWQgaGVyZTogaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vMWU0MmM3YTczYmZhNDA5ZDJjZjFlMTg0ZTdhNDI0OGQgc28gaXQgd2FzIHJlbW92ZWQgaW4gZmF2b3Igb2YganVzdCB0ZWxsaW5nIHBlb3BsZSB0byBzZXQgdXAgdGhlaXIgQ1NTIHRvIGF2b2lkIHRoZSBjb2xsYXBzaW5nIG1hcmdpbnMgKG92ZXJmbG93OiBoaWRkZW4gfCBhdXRvIGlzIGp1c3Qgb25lIG9wdGlvbi4gQW5vdGhlciBpcyBib3JkZXItdG9wOiAxcHggc29saWQgdHJhbnNwYXJlbnQpLlxuXG4gICAgICBfc3dhcFBpbkluKHBpbiwgc3BhY2VyLCBjcyk7XG5cbiAgICAgIHBpblN0YXRlID0gX2dldFN0YXRlKHBpbik7XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlcnMpIHtcbiAgICAgIG1hcmtlclZhcnMgPSBfaXNPYmplY3QobWFya2VycykgPyBfc2V0RGVmYXVsdHMobWFya2VycywgX21hcmtlckRlZmF1bHRzKSA6IF9tYXJrZXJEZWZhdWx0cztcbiAgICAgIG1hcmtlclN0YXJ0VHJpZ2dlciA9IF9jcmVhdGVNYXJrZXIoXCJzY3JvbGxlci1zdGFydFwiLCBpZCwgc2Nyb2xsZXIsIGRpcmVjdGlvbiwgbWFya2VyVmFycywgMCk7XG4gICAgICBtYXJrZXJFbmRUcmlnZ2VyID0gX2NyZWF0ZU1hcmtlcihcInNjcm9sbGVyLWVuZFwiLCBpZCwgc2Nyb2xsZXIsIGRpcmVjdGlvbiwgbWFya2VyVmFycywgMCwgbWFya2VyU3RhcnRUcmlnZ2VyKTtcbiAgICAgIG9mZnNldCA9IG1hcmtlclN0YXJ0VHJpZ2dlcltcIm9mZnNldFwiICsgZGlyZWN0aW9uLm9wLmQyXTtcblxuICAgICAgdmFyIGNvbnRlbnQgPSBfZ2V0VGFyZ2V0KF9nZXRQcm94eVByb3Aoc2Nyb2xsZXIsIFwiY29udGVudFwiKSB8fCBzY3JvbGxlcik7XG5cbiAgICAgIG1hcmtlclN0YXJ0ID0gdGhpcy5tYXJrZXJTdGFydCA9IF9jcmVhdGVNYXJrZXIoXCJzdGFydFwiLCBpZCwgY29udGVudCwgZGlyZWN0aW9uLCBtYXJrZXJWYXJzLCBvZmZzZXQsIDAsIGNvbnRhaW5lckFuaW1hdGlvbik7XG4gICAgICBtYXJrZXJFbmQgPSB0aGlzLm1hcmtlckVuZCA9IF9jcmVhdGVNYXJrZXIoXCJlbmRcIiwgaWQsIGNvbnRlbnQsIGRpcmVjdGlvbiwgbWFya2VyVmFycywgb2Zmc2V0LCAwLCBjb250YWluZXJBbmltYXRpb24pO1xuICAgICAgY29udGFpbmVyQW5pbWF0aW9uICYmIChjYU1hcmtlclNldHRlciA9IGdzYXAucXVpY2tTZXR0ZXIoW21hcmtlclN0YXJ0LCBtYXJrZXJFbmRdLCBkaXJlY3Rpb24uYSwgX3B4KSk7XG5cbiAgICAgIGlmICghdXNlRml4ZWRQb3NpdGlvbiAmJiAhKF9wcm94aWVzLmxlbmd0aCAmJiBfZ2V0UHJveHlQcm9wKHNjcm9sbGVyLCBcImZpeGVkTWFya2Vyc1wiKSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgX21ha2VQb3NpdGlvbmFibGUoaXNWaWV3cG9ydCA/IF9ib2R5IDogc2Nyb2xsZXIpO1xuXG4gICAgICAgIGdzYXAuc2V0KFttYXJrZXJTdGFydFRyaWdnZXIsIG1hcmtlckVuZFRyaWdnZXJdLCB7XG4gICAgICAgICAgZm9yY2UzRDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgbWFya2VyU3RhcnRTZXR0ZXIgPSBnc2FwLnF1aWNrU2V0dGVyKG1hcmtlclN0YXJ0VHJpZ2dlciwgZGlyZWN0aW9uLmEsIF9weCk7XG4gICAgICAgIG1hcmtlckVuZFNldHRlciA9IGdzYXAucXVpY2tTZXR0ZXIobWFya2VyRW5kVHJpZ2dlciwgZGlyZWN0aW9uLmEsIF9weCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5lckFuaW1hdGlvbikge1xuICAgICAgdmFyIG9sZE9uVXBkYXRlID0gY29udGFpbmVyQW5pbWF0aW9uLnZhcnMub25VcGRhdGUsXG4gICAgICAgICAgb2xkUGFyYW1zID0gY29udGFpbmVyQW5pbWF0aW9uLnZhcnMub25VcGRhdGVQYXJhbXM7XG4gICAgICBjb250YWluZXJBbmltYXRpb24uZXZlbnRDYWxsYmFjayhcIm9uVXBkYXRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi51cGRhdGUoMCwgMCwgMSk7XG4gICAgICAgIG9sZE9uVXBkYXRlICYmIG9sZE9uVXBkYXRlLmFwcGx5KGNvbnRhaW5lckFuaW1hdGlvbiwgb2xkUGFyYW1zIHx8IFtdKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNlbGYucHJldmlvdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RyaWdnZXJzW190cmlnZ2Vycy5pbmRleE9mKHNlbGYpIC0gMV07XG4gICAgfTtcblxuICAgIHNlbGYubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdHJpZ2dlcnNbX3RyaWdnZXJzLmluZGV4T2Yoc2VsZikgKyAxXTtcbiAgICB9O1xuXG4gICAgc2VsZi5yZXZlcnQgPSBmdW5jdGlvbiAocmV2ZXJ0LCB0ZW1wKSB7XG4gICAgICBpZiAoIXRlbXApIHtcbiAgICAgICAgcmV0dXJuIHNlbGYua2lsbCh0cnVlKTtcbiAgICAgIH0gLy8gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBnc2FwLmNvbnRleHQoKSBhbmQgZ3NhcC5tYXRjaE1lZGlhKCkgd2hpY2ggY2FsbCByZXZlcnQoKVxuXG5cbiAgICAgIHZhciByID0gcmV2ZXJ0ICE9PSBmYWxzZSB8fCAhc2VsZi5lbmFibGVkLFxuICAgICAgICAgIHByZXZSZWZyZXNoaW5nID0gX3JlZnJlc2hpbmc7XG5cbiAgICAgIGlmIChyICE9PSBzZWxmLmlzUmV2ZXJ0ZWQpIHtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICBwcmV2U2Nyb2xsID0gTWF0aC5tYXgoc2Nyb2xsRnVuYygpLCBzZWxmLnNjcm9sbC5yZWMgfHwgMCk7IC8vIHJlY29yZCB0aGUgc2Nyb2xsIHNvIHdlIGNhbiByZXZlcnQgbGF0ZXIgKHJlcG9zaXRpb25pbmcvcGlubmluZyB0aGluZ3MgY2FuIGFmZmVjdCBzY3JvbGwgcG9zaXRpb24pLiBJbiB0aGUgc3RhdGljIHJlZnJlc2goKSBtZXRob2QsIHdlIGZpcnN0IHJlY29yZCBhbGwgdGhlIHNjcm9sbCBwb3NpdGlvbnMgYXMgYSByZWZlcmVuY2UuXG5cbiAgICAgICAgICBwcmV2UHJvZ3Jlc3MgPSBzZWxmLnByb2dyZXNzO1xuICAgICAgICAgIHByZXZBbmltUHJvZ3Jlc3MgPSBhbmltYXRpb24gJiYgYW5pbWF0aW9uLnByb2dyZXNzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXJrZXJTdGFydCAmJiBbbWFya2VyU3RhcnQsIG1hcmtlckVuZCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG0uc3R5bGUuZGlzcGxheSA9IHIgPyBcIm5vbmVcIiA6IFwiYmxvY2tcIjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICBfcmVmcmVzaGluZyA9IHNlbGY7XG4gICAgICAgICAgc2VsZi51cGRhdGUocik7IC8vIG1ha2Ugc3VyZSB0aGUgcGluIGlzIGJhY2sgaW4gaXRzIG9yaWdpbmFsIHBvc2l0aW9uIHNvIHRoYXQgYWxsIHRoZSBtZWFzdXJlbWVudHMgYXJlIGNvcnJlY3QuIGRvIHRoaXMgQkVGT1JFIHN3YXBwaW5nIHRoZSBwaW4gb3V0XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGluICYmICghcGluUmVwYXJlbnQgfHwgIXNlbGYuaXNBY3RpdmUpKSB7XG4gICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIF9zd2FwUGluT3V0KHBpbiwgc3BhY2VyLCBwaW5PcmlnaW5hbFN0YXRlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3N3YXBQaW5JbihwaW4sIHNwYWNlciwgX2dldENvbXB1dGVkU3R5bGUocGluKSwgc3BhY2VyU3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHIgfHwgc2VsZi51cGRhdGUocik7IC8vIHdoZW4gd2UncmUgcmVzdG9yaW5nLCB0aGUgdXBkYXRlIHNob3VsZCBydW4gQUZURVIgc3dhcHBpbmcgdGhlIHBpbiBpbnRvIGl0cyBwaW4tc3BhY2VyLlxuXG4gICAgICAgIF9yZWZyZXNoaW5nID0gcHJldlJlZnJlc2hpbmc7IC8vIHJlc3RvcmUuIFdlIHNldCBpdCB0byB0cnVlIGR1cmluZyB0aGUgdXBkYXRlKCkgc28gdGhhdCB0aGluZ3MgZmlyZSBwcm9wZXJseSBpbiB0aGVyZS5cblxuICAgICAgICBzZWxmLmlzUmV2ZXJ0ZWQgPSByO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLnJlZnJlc2ggPSBmdW5jdGlvbiAoc29mdCwgZm9yY2UsIHBvc2l0aW9uLCBwaW5PZmZzZXQpIHtcbiAgICAgIC8vIHBvc2l0aW9uIGlzIHR5cGljYWxseSBvbmx5IGRlZmluZWQgaWYgaXQncyBjb21pbmcgZnJvbSBzZXRQb3NpdGlvbnMoKSAtIGl0J3MgYSB3YXkgdG8gc2tpcCB0aGUgbm9ybWFsIHBhcnNpbmcuIHBpbk9mZnNldCBpcyBhbHNvIG9ubHkgZnJvbSBzZXRQb3NpdGlvbnMoKSBhbmQgaXMgbW9zdGx5IHJlbGF0ZWQgdG8gZmFuY3kgc3R1ZmYgd2UgbmVlZCB0byBkbyBpbiBTY3JvbGxTbW9vdGhlciB3aXRoIGVmZmVjdHNcbiAgICAgIGlmICgoX3JlZnJlc2hpbmcgfHwgIXNlbGYuZW5hYmxlZCkgJiYgIWZvcmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBpbiAmJiBzb2Z0ICYmIF9sYXN0U2Nyb2xsVGltZSkge1xuICAgICAgICBfYWRkTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJzY3JvbGxFbmRcIiwgX3NvZnRSZWZyZXNoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgICFfcmVmcmVzaGluZ0FsbCAmJiBvblJlZnJlc2hJbml0ICYmIG9uUmVmcmVzaEluaXQoc2VsZik7XG4gICAgICBfcmVmcmVzaGluZyA9IHNlbGY7XG5cbiAgICAgIGlmICh0d2VlblRvLnR3ZWVuICYmICFwb3NpdGlvbikge1xuICAgICAgICAvLyB3ZSBza2lwIHRoaXMgaWYgYSBwb3NpdGlvbiBpcyBwYXNzZWQgaW4gYmVjYXVzZSB0eXBpY2FsbHkgdGhhdCdzIGZyb20gLnNldFBvc2l0aW9ucygpIGFuZCBpdCdzIGJlc3QgdG8gYWxsb3cgaW4tcHJvZ3Jlc3Mgc25hcHBpbmcgdG8gY29udGludWUuXG4gICAgICAgIHR3ZWVuVG8udHdlZW4ua2lsbCgpO1xuICAgICAgICB0d2VlblRvLnR3ZWVuID0gMDtcbiAgICAgIH1cblxuICAgICAgc2NydWJUd2VlbiAmJiBzY3J1YlR3ZWVuLnBhdXNlKCk7XG4gICAgICBpbnZhbGlkYXRlT25SZWZyZXNoICYmIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucmV2ZXJ0KHtcbiAgICAgICAga2lsbDogZmFsc2VcbiAgICAgIH0pLmludmFsaWRhdGUoKTtcbiAgICAgIHNlbGYuaXNSZXZlcnRlZCB8fCBzZWxmLnJldmVydCh0cnVlLCB0cnVlKTtcbiAgICAgIHNlbGYuX3N1YlBpbk9mZnNldCA9IGZhbHNlOyAvLyB3ZSdsbCBzZXQgdGhpcyB0byB0cnVlIGluIHRoZSBzdWItcGlucyBpZiB3ZSBmaW5kIGFueVxuXG4gICAgICB2YXIgc2l6ZSA9IGdldFNjcm9sbGVyU2l6ZSgpLFxuICAgICAgICAgIHNjcm9sbGVyQm91bmRzID0gZ2V0U2Nyb2xsZXJPZmZzZXRzKCksXG4gICAgICAgICAgbWF4ID0gY29udGFpbmVyQW5pbWF0aW9uID8gY29udGFpbmVyQW5pbWF0aW9uLmR1cmF0aW9uKCkgOiBfbWF4U2Nyb2xsKHNjcm9sbGVyLCBkaXJlY3Rpb24pLFxuICAgICAgICAgIGlzRmlyc3RSZWZyZXNoID0gY2hhbmdlIDw9IDAuMDEsXG4gICAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgICBvdGhlclBpbk9mZnNldCA9IHBpbk9mZnNldCB8fCAwLFxuICAgICAgICAgIHBhcnNlZEVuZCA9IF9pc09iamVjdChwb3NpdGlvbikgPyBwb3NpdGlvbi5lbmQgOiB2YXJzLmVuZCxcbiAgICAgICAgICBwYXJzZWRFbmRUcmlnZ2VyID0gdmFycy5lbmRUcmlnZ2VyIHx8IHRyaWdnZXIsXG4gICAgICAgICAgcGFyc2VkU3RhcnQgPSBfaXNPYmplY3QocG9zaXRpb24pID8gcG9zaXRpb24uc3RhcnQgOiB2YXJzLnN0YXJ0IHx8ICh2YXJzLnN0YXJ0ID09PSAwIHx8ICF0cmlnZ2VyID8gMCA6IHBpbiA/IFwiMCAwXCIgOiBcIjAgMTAwJVwiKSxcbiAgICAgICAgICBwaW5uZWRDb250YWluZXIgPSBzZWxmLnBpbm5lZENvbnRhaW5lciA9IHZhcnMucGlubmVkQ29udGFpbmVyICYmIF9nZXRUYXJnZXQodmFycy5waW5uZWRDb250YWluZXIsIHNlbGYpLFxuICAgICAgICAgIHRyaWdnZXJJbmRleCA9IHRyaWdnZXIgJiYgTWF0aC5tYXgoMCwgX3RyaWdnZXJzLmluZGV4T2Yoc2VsZikpIHx8IDAsXG4gICAgICAgICAgaSA9IHRyaWdnZXJJbmRleCxcbiAgICAgICAgICBjcyxcbiAgICAgICAgICBib3VuZHMsXG4gICAgICAgICAgc2Nyb2xsLFxuICAgICAgICAgIGlzVmVydGljYWwsXG4gICAgICAgICAgb3ZlcnJpZGUsXG4gICAgICAgICAgY3VyVHJpZ2dlcixcbiAgICAgICAgICBjdXJQaW4sXG4gICAgICAgICAgb3Bwb3NpdGVTY3JvbGwsXG4gICAgICAgICAgaW5pdHRlZCxcbiAgICAgICAgICByZXZlcnRlZFBpbnMsXG4gICAgICAgICAgZm9yY2VkT3ZlcmZsb3csXG4gICAgICAgICAgbWFya2VyU3RhcnRPZmZzZXQsXG4gICAgICAgICAgbWFya2VyRW5kT2Zmc2V0O1xuXG4gICAgICBpZiAobWFya2VycyAmJiBfaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIC8vIGlmIHdlIGFsdGVyIHRoZSBzdGFydC9lbmQgcG9zaXRpb25zIHdpdGggLnNldFBvc2l0aW9ucygpLCBpdCBnZW5lcmFsbHkgZmVlZHMgaW4gYWJzb2x1dGUgTlVNQkVSUyB3aGljaCBkb24ndCBjb252ZXkgaW5mb3JtYXRpb24gYWJvdXQgd2hlcmUgdG8gbGluZSB1cCB0aGUgbWFya2Vycywgc28gdG8ga2VlcCBpdCBpbnR1aXRpdmUsIHdlIHJlY29yZCBob3cgZmFyIHRoZSB0cmlnZ2VyIHBvc2l0aW9ucyBzaGlmdCBhZnRlciBhcHBseWluZyB0aGUgbmV3IG51bWJlcnMgYW5kIHRoZW4gb2Zmc2V0IGJ5IHRoYXQgbXVjaCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLiBXZSBkbyB0aGUgc2FtZSB0byB0aGUgYXNzb2NpYXRlZCB0cmlnZ2VyIG1hcmtlcnMgdG9vIG9mIGNvdXJzZS5cbiAgICAgICAgbWFya2VyU3RhcnRPZmZzZXQgPSBnc2FwLmdldFByb3BlcnR5KG1hcmtlclN0YXJ0VHJpZ2dlciwgZGlyZWN0aW9uLnApO1xuICAgICAgICBtYXJrZXJFbmRPZmZzZXQgPSBnc2FwLmdldFByb3BlcnR5KG1hcmtlckVuZFRyaWdnZXIsIGRpcmVjdGlvbi5wKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAvLyB1c2VyIG1pZ2h0IHRyeSB0byBwaW4gdGhlIHNhbWUgZWxlbWVudCBtb3JlIHRoYW4gb25jZSwgc28gd2UgbXVzdCBmaW5kIGFueSBwcmlvciB0cmlnZ2VycyB3aXRoIHRoZSBzYW1lIHBpbiwgcmV2ZXJ0IHRoZW0sIGFuZCBkZXRlcm1pbmUgaG93IGxvbmcgdGhleSdyZSBwaW5uaW5nIHNvIHRoYXQgd2UgY2FuIG9mZnNldCB0aGluZ3MgYXBwcm9wcmlhdGVseS4gTWFrZSBzdXJlIHdlIHJldmVydCBmcm9tIGxhc3QgdG8gZmlyc3Qgc28gdGhhdCB0aGluZ3MgXCJyZXdpbmRcIiBwcm9wZXJseS5cbiAgICAgICAgY3VyVHJpZ2dlciA9IF90cmlnZ2Vyc1tpXTtcbiAgICAgICAgY3VyVHJpZ2dlci5lbmQgfHwgY3VyVHJpZ2dlci5yZWZyZXNoKDAsIDEpIHx8IChfcmVmcmVzaGluZyA9IHNlbGYpOyAvLyBpZiBpdCdzIGEgdGltZWxpbmUtYmFzZWQgdHJpZ2dlciB0aGF0IGhhc24ndCBiZWVuIGZ1bGx5IGluaXRpYWxpemVkIHlldCBiZWNhdXNlIGl0J3Mgd2FpdGluZyBmb3IgMSB0aWNrLCBqdXN0IGZvcmNlIHRoZSByZWZyZXNoKCkgaGVyZSwgb3RoZXJ3aXNlIGlmIGl0IGNvbnRhaW5zIGEgcGluIHRoYXQncyBzdXBwb3NlZCB0byBhZmZlY3Qgb3RoZXIgU2Nyb2xsVHJpZ2dlcnMgZnVydGhlciBkb3duIHRoZSBwYWdlLCB0aGV5IHdvbid0IGJlIGFkanVzdGVkIHByb3Blcmx5LlxuXG4gICAgICAgIGN1clBpbiA9IGN1clRyaWdnZXIucGluO1xuXG4gICAgICAgIGlmIChjdXJQaW4gJiYgKGN1clBpbiA9PT0gdHJpZ2dlciB8fCBjdXJQaW4gPT09IHBpbiB8fCBjdXJQaW4gPT09IHBpbm5lZENvbnRhaW5lcikgJiYgIWN1clRyaWdnZXIuaXNSZXZlcnRlZCkge1xuICAgICAgICAgIHJldmVydGVkUGlucyB8fCAocmV2ZXJ0ZWRQaW5zID0gW10pO1xuICAgICAgICAgIHJldmVydGVkUGlucy51bnNoaWZ0KGN1clRyaWdnZXIpOyAvLyB3ZSdsbCByZXZlcnQgZnJvbSBmaXJzdCB0byBsYXN0IHRvIG1ha2Ugc3VyZSB0aGluZ3MgcmVhY2ggdGhlaXIgZW5kIHN0YXRlIHByb3Blcmx5XG5cbiAgICAgICAgICBjdXJUcmlnZ2VyLnJldmVydCh0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJUcmlnZ2VyICE9PSBfdHJpZ2dlcnNbaV0pIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIGl0IGdvdCByZW1vdmVkLlxuICAgICAgICAgIHRyaWdnZXJJbmRleC0tO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfaXNGdW5jdGlvbihwYXJzZWRTdGFydCkgJiYgKHBhcnNlZFN0YXJ0ID0gcGFyc2VkU3RhcnQoc2VsZikpO1xuICAgICAgcGFyc2VkU3RhcnQgPSBfcGFyc2VDbGFtcChwYXJzZWRTdGFydCwgXCJzdGFydFwiLCBzZWxmKTtcbiAgICAgIHN0YXJ0ID0gX3BhcnNlUG9zaXRpb24ocGFyc2VkU3RhcnQsIHRyaWdnZXIsIHNpemUsIGRpcmVjdGlvbiwgc2Nyb2xsRnVuYygpLCBtYXJrZXJTdGFydCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBzZWxmLCBzY3JvbGxlckJvdW5kcywgYm9yZGVyV2lkdGgsIHVzZUZpeGVkUG9zaXRpb24sIG1heCwgY29udGFpbmVyQW5pbWF0aW9uLCBzZWxmLl9zdGFydENsYW1wICYmIFwiX3N0YXJ0Q2xhbXBcIikgfHwgKHBpbiA/IC0wLjAwMSA6IDApO1xuICAgICAgX2lzRnVuY3Rpb24ocGFyc2VkRW5kKSAmJiAocGFyc2VkRW5kID0gcGFyc2VkRW5kKHNlbGYpKTtcblxuICAgICAgaWYgKF9pc1N0cmluZyhwYXJzZWRFbmQpICYmICFwYXJzZWRFbmQuaW5kZXhPZihcIis9XCIpKSB7XG4gICAgICAgIGlmICh+cGFyc2VkRW5kLmluZGV4T2YoXCIgXCIpKSB7XG4gICAgICAgICAgcGFyc2VkRW5kID0gKF9pc1N0cmluZyhwYXJzZWRTdGFydCkgPyBwYXJzZWRTdGFydC5zcGxpdChcIiBcIilbMF0gOiBcIlwiKSArIHBhcnNlZEVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSBfb2Zmc2V0VG9QeChwYXJzZWRFbmQuc3Vic3RyKDIpLCBzaXplKTtcbiAgICAgICAgICBwYXJzZWRFbmQgPSBfaXNTdHJpbmcocGFyc2VkU3RhcnQpID8gcGFyc2VkU3RhcnQgOiAoY29udGFpbmVyQW5pbWF0aW9uID8gZ3NhcC51dGlscy5tYXBSYW5nZSgwLCBjb250YWluZXJBbmltYXRpb24uZHVyYXRpb24oKSwgY29udGFpbmVyQW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIuc3RhcnQsIGNvbnRhaW5lckFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyLmVuZCwgc3RhcnQpIDogc3RhcnQpICsgb2Zmc2V0OyAvLyBfcGFyc2VQb3NpdGlvbiB3b24ndCBmYWN0b3IgaW4gdGhlIG9mZnNldCBpZiB0aGUgc3RhcnQgaXMgYSBudW1iZXIsIHNvIGRvIGl0IGhlcmUuXG5cbiAgICAgICAgICBwYXJzZWRFbmRUcmlnZ2VyID0gdHJpZ2dlcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwYXJzZWRFbmQgPSBfcGFyc2VDbGFtcChwYXJzZWRFbmQsIFwiZW5kXCIsIHNlbGYpO1xuICAgICAgZW5kID0gTWF0aC5tYXgoc3RhcnQsIF9wYXJzZVBvc2l0aW9uKHBhcnNlZEVuZCB8fCAocGFyc2VkRW5kVHJpZ2dlciA/IFwiMTAwJSAwXCIgOiBtYXgpLCBwYXJzZWRFbmRUcmlnZ2VyLCBzaXplLCBkaXJlY3Rpb24sIHNjcm9sbEZ1bmMoKSArIG9mZnNldCwgbWFya2VyRW5kLCBtYXJrZXJFbmRUcmlnZ2VyLCBzZWxmLCBzY3JvbGxlckJvdW5kcywgYm9yZGVyV2lkdGgsIHVzZUZpeGVkUG9zaXRpb24sIG1heCwgY29udGFpbmVyQW5pbWF0aW9uLCBzZWxmLl9lbmRDbGFtcCAmJiBcIl9lbmRDbGFtcFwiKSkgfHwgLTAuMDAxO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIGkgPSB0cmlnZ2VySW5kZXg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY3VyVHJpZ2dlciA9IF90cmlnZ2Vyc1tpXTtcbiAgICAgICAgY3VyUGluID0gY3VyVHJpZ2dlci5waW47XG5cbiAgICAgICAgaWYgKGN1clBpbiAmJiBjdXJUcmlnZ2VyLnN0YXJ0IC0gY3VyVHJpZ2dlci5fcGluUHVzaCA8PSBzdGFydCAmJiAhY29udGFpbmVyQW5pbWF0aW9uICYmIGN1clRyaWdnZXIuZW5kID4gMCkge1xuICAgICAgICAgIGNzID0gY3VyVHJpZ2dlci5lbmQgLSAoc2VsZi5fc3RhcnRDbGFtcCA/IE1hdGgubWF4KDAsIGN1clRyaWdnZXIuc3RhcnQpIDogY3VyVHJpZ2dlci5zdGFydCk7XG5cbiAgICAgICAgICBpZiAoKGN1clBpbiA9PT0gdHJpZ2dlciAmJiBjdXJUcmlnZ2VyLnN0YXJ0IC0gY3VyVHJpZ2dlci5fcGluUHVzaCA8IHN0YXJ0IHx8IGN1clBpbiA9PT0gcGlubmVkQ29udGFpbmVyKSAmJiBpc05hTihwYXJzZWRTdGFydCkpIHtcbiAgICAgICAgICAgIC8vIG51bWVyaWMgc3RhcnQgdmFsdWVzIHNob3VsZG4ndCBiZSBvZmZzZXQgYXQgYWxsIC0gdHJlYXQgdGhlbSBhcyBhYnNvbHV0ZVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGNzICogKDEgLSBjdXJUcmlnZ2VyLnByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJQaW4gPT09IHBpbiAmJiAob3RoZXJQaW5PZmZzZXQgKz0gY3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0ICs9IG9mZnNldDtcbiAgICAgIGVuZCArPSBvZmZzZXQ7XG4gICAgICBzZWxmLl9zdGFydENsYW1wICYmIChzZWxmLl9zdGFydENsYW1wICs9IG9mZnNldCk7XG5cbiAgICAgIGlmIChzZWxmLl9lbmRDbGFtcCAmJiAhX3JlZnJlc2hpbmdBbGwpIHtcbiAgICAgICAgc2VsZi5fZW5kQ2xhbXAgPSBlbmQgfHwgLTAuMDAxO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbihlbmQsIF9tYXhTY3JvbGwoc2Nyb2xsZXIsIGRpcmVjdGlvbikpO1xuICAgICAgfVxuXG4gICAgICBjaGFuZ2UgPSBlbmQgLSBzdGFydCB8fCAoc3RhcnQgLT0gMC4wMSkgJiYgMC4wMDE7XG5cbiAgICAgIGlmIChpc0ZpcnN0UmVmcmVzaCkge1xuICAgICAgICAvLyBvbiB0aGUgdmVyeSBmaXJzdCByZWZyZXNoKCksIHRoZSBwcmV2UHJvZ3Jlc3MgY291bGRuJ3QgaGF2ZSBiZWVuIGFjY3VyYXRlIHlldCBiZWNhdXNlIHRoZSBzdGFydC9lbmQgd2VyZSBuZXZlciBjYWxjdWxhdGVkLCBzbyB3ZSBzZXQgaXQgaGVyZS4gQmVmb3JlIDMuMTEuNSwgaXQgY291bGQgbGVhZCB0byBhbiBpbmFjY3VyYXRlIHNjcm9sbCBwb3NpdGlvbiByZXN0b3JhdGlvbiB3aXRoIHNuYXBwaW5nLlxuICAgICAgICBwcmV2UHJvZ3Jlc3MgPSBnc2FwLnV0aWxzLmNsYW1wKDAsIDEsIGdzYXAudXRpbHMubm9ybWFsaXplKHN0YXJ0LCBlbmQsIHByZXZTY3JvbGwpKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5fcGluUHVzaCA9IG90aGVyUGluT2Zmc2V0O1xuXG4gICAgICBpZiAobWFya2VyU3RhcnQgJiYgb2Zmc2V0KSB7XG4gICAgICAgIC8vIG9mZnNldCB0aGUgbWFya2VycyBpZiBuZWNlc3NhcnlcbiAgICAgICAgY3MgPSB7fTtcbiAgICAgICAgY3NbZGlyZWN0aW9uLmFdID0gXCIrPVwiICsgb2Zmc2V0O1xuICAgICAgICBwaW5uZWRDb250YWluZXIgJiYgKGNzW2RpcmVjdGlvbi5wXSA9IFwiLT1cIiArIHNjcm9sbEZ1bmMoKSk7XG4gICAgICAgIGdzYXAuc2V0KFttYXJrZXJTdGFydCwgbWFya2VyRW5kXSwgY3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGluICYmICEoX2NsYW1waW5nTWF4ICYmIHNlbGYuZW5kID49IF9tYXhTY3JvbGwoc2Nyb2xsZXIsIGRpcmVjdGlvbikpKSB7XG4gICAgICAgIGNzID0gX2dldENvbXB1dGVkU3R5bGUocGluKTtcbiAgICAgICAgaXNWZXJ0aWNhbCA9IGRpcmVjdGlvbiA9PT0gX3ZlcnRpY2FsO1xuICAgICAgICBzY3JvbGwgPSBzY3JvbGxGdW5jKCk7IC8vIHJlY2FsY3VsYXRlIGJlY2F1c2UgdGhlIHRyaWdnZXJzIGNhbiBhZmZlY3QgdGhlIHNjcm9sbFxuXG4gICAgICAgIHBpblN0YXJ0ID0gcGFyc2VGbG9hdChwaW5HZXR0ZXIoZGlyZWN0aW9uLmEpKSArIG90aGVyUGluT2Zmc2V0O1xuXG4gICAgICAgIGlmICghbWF4ICYmIGVuZCA+IDEpIHtcbiAgICAgICAgICAvLyBtYWtlcyBzdXJlIHRoZSBzY3JvbGxlciBoYXMgYSBzY3JvbGxiYXIsIG90aGVyd2lzZSBpZiBzb21ldGhpbmcgaGFzIHdpZHRoOiAxMDAlLCBmb3IgZXhhbXBsZSwgaXQgd291bGQgYmUgdG9vIGJpZyAoZXhjbHVkZSB0aGUgc2Nyb2xsYmFyKS4gU2VlIGh0dHBzOi8vZ3NhcC5jb20vZm9ydW1zL3RvcGljLzI1MTgyLXNjcm9sbHRyaWdnZXItd2lkdGgtb2YtcGFnZS1pbmNyZWFzZS13aGVyZS1tYXJrZXJzLWFyZS1zZXQtdG8tZmFsc2UvXG4gICAgICAgICAgZm9yY2VkT3ZlcmZsb3cgPSAoaXNWaWV3cG9ydCA/IF9kb2Muc2Nyb2xsaW5nRWxlbWVudCB8fCBfZG9jRWwgOiBzY3JvbGxlcikuc3R5bGU7XG4gICAgICAgICAgZm9yY2VkT3ZlcmZsb3cgPSB7XG4gICAgICAgICAgICBzdHlsZTogZm9yY2VkT3ZlcmZsb3csXG4gICAgICAgICAgICB2YWx1ZTogZm9yY2VkT3ZlcmZsb3dbXCJvdmVyZmxvd1wiICsgZGlyZWN0aW9uLmEudG9VcHBlckNhc2UoKV1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGlzVmlld3BvcnQgJiYgX2dldENvbXB1dGVkU3R5bGUoX2JvZHkpW1wib3ZlcmZsb3dcIiArIGRpcmVjdGlvbi5hLnRvVXBwZXJDYXNlKCldICE9PSBcInNjcm9sbFwiKSB7XG4gICAgICAgICAgICAvLyBhdm9pZCBhbiBleHRyYSBzY3JvbGxiYXIgaWYgQk9USCA8aHRtbD4gYW5kIDxib2R5PiBoYXZlIG92ZXJmbG93IHNldCB0byBcInNjcm9sbFwiXG4gICAgICAgICAgICBmb3JjZWRPdmVyZmxvdy5zdHlsZVtcIm92ZXJmbG93XCIgKyBkaXJlY3Rpb24uYS50b1VwcGVyQ2FzZSgpXSA9IFwic2Nyb2xsXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3N3YXBQaW5JbihwaW4sIHNwYWNlciwgY3MpO1xuXG4gICAgICAgIHBpblN0YXRlID0gX2dldFN0YXRlKHBpbik7IC8vIHRyYW5zZm9ybXMgd2lsbCBpbnRlcmZlcmUgd2l0aCB0aGUgdG9wL2xlZnQvcmlnaHQvYm90dG9tIHBsYWNlbWVudCwgc28gcmVtb3ZlIHRoZW0gdGVtcG9yYXJpbHkuIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGZhY3RvcnMgaW4gdHJhbnNmb3Jtcy5cblxuICAgICAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKHBpbiwgdHJ1ZSk7XG4gICAgICAgIG9wcG9zaXRlU2Nyb2xsID0gdXNlRml4ZWRQb3NpdGlvbiAmJiBfZ2V0U2Nyb2xsRnVuYyhzY3JvbGxlciwgaXNWZXJ0aWNhbCA/IF9ob3Jpem9udGFsIDogX3ZlcnRpY2FsKSgpO1xuXG4gICAgICAgIGlmIChwaW5TcGFjaW5nKSB7XG4gICAgICAgICAgc3BhY2VyU3RhdGUgPSBbcGluU3BhY2luZyArIGRpcmVjdGlvbi5vczIsIGNoYW5nZSArIG90aGVyUGluT2Zmc2V0ICsgX3B4XTtcbiAgICAgICAgICBzcGFjZXJTdGF0ZS50ID0gc3BhY2VyO1xuICAgICAgICAgIGkgPSBwaW5TcGFjaW5nID09PSBfcGFkZGluZyA/IF9nZXRTaXplKHBpbiwgZGlyZWN0aW9uKSArIGNoYW5nZSArIG90aGVyUGluT2Zmc2V0IDogMDtcblxuICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICBzcGFjZXJTdGF0ZS5wdXNoKGRpcmVjdGlvbi5kLCBpICsgX3B4KTsgLy8gZm9yIGJveC1zaXppbmc6IGJvcmRlci1ib3ggKG11c3QgaW5jbHVkZSBwYWRkaW5nKS5cblxuICAgICAgICAgICAgc3BhY2VyLnN0eWxlLmZsZXhCYXNpcyAhPT0gXCJhdXRvXCIgJiYgKHNwYWNlci5zdHlsZS5mbGV4QmFzaXMgPSBpICsgX3B4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfc2V0U3RhdGUoc3BhY2VyU3RhdGUpO1xuXG4gICAgICAgICAgaWYgKHBpbm5lZENvbnRhaW5lcikge1xuICAgICAgICAgICAgLy8gaW4gU2Nyb2xsVHJpZ2dlci5yZWZyZXNoKCksIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgdGhlIHBpbkNvbnRhaW5lcidzIHNpemUgYmVjYXVzZSB0aGlzIHBpblNwYWNpbmcgbWF5IHN0cmV0Y2ggaXQgb3V0LCBidXQgd2UgY2FuJ3QganVzdCBhZGQgdGhlIGV4YWN0IGRpc3RhbmNlIGJlY2F1c2UgZGVwZW5kaW5nIG9uIGxheW91dCwgaXQgbWF5IG5vdCBwdXNoIHRoaW5ncyBkb3duIG9yIGl0IG1heSBvbmx5IGRvIHNvIHBhcnRpYWxseS5cbiAgICAgICAgICAgIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIGlmICh0LnBpbiA9PT0gcGlubmVkQ29udGFpbmVyICYmIHQudmFycy5waW5TcGFjaW5nICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHQuX3N1YlBpbk9mZnNldCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVzZUZpeGVkUG9zaXRpb24gJiYgc2Nyb2xsRnVuYyhwcmV2U2Nyb2xsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpID0gX2dldFNpemUocGluLCBkaXJlY3Rpb24pO1xuICAgICAgICAgIGkgJiYgc3BhY2VyLnN0eWxlLmZsZXhCYXNpcyAhPT0gXCJhdXRvXCIgJiYgKHNwYWNlci5zdHlsZS5mbGV4QmFzaXMgPSBpICsgX3B4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1c2VGaXhlZFBvc2l0aW9uKSB7XG4gICAgICAgICAgb3ZlcnJpZGUgPSB7XG4gICAgICAgICAgICB0b3A6IGJvdW5kcy50b3AgKyAoaXNWZXJ0aWNhbCA/IHNjcm9sbCAtIHN0YXJ0IDogb3Bwb3NpdGVTY3JvbGwpICsgX3B4LFxuICAgICAgICAgICAgbGVmdDogYm91bmRzLmxlZnQgKyAoaXNWZXJ0aWNhbCA/IG9wcG9zaXRlU2Nyb2xsIDogc2Nyb2xsIC0gc3RhcnQpICsgX3B4LFxuICAgICAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImZpeGVkXCJcbiAgICAgICAgICB9O1xuICAgICAgICAgIG92ZXJyaWRlW193aWR0aF0gPSBvdmVycmlkZVtcIm1heFwiICsgX1dpZHRoXSA9IE1hdGguY2VpbChib3VuZHMud2lkdGgpICsgX3B4O1xuICAgICAgICAgIG92ZXJyaWRlW19oZWlnaHRdID0gb3ZlcnJpZGVbXCJtYXhcIiArIF9IZWlnaHRdID0gTWF0aC5jZWlsKGJvdW5kcy5oZWlnaHQpICsgX3B4O1xuICAgICAgICAgIG92ZXJyaWRlW19tYXJnaW5dID0gb3ZlcnJpZGVbX21hcmdpbiArIF9Ub3BdID0gb3ZlcnJpZGVbX21hcmdpbiArIF9SaWdodF0gPSBvdmVycmlkZVtfbWFyZ2luICsgX0JvdHRvbV0gPSBvdmVycmlkZVtfbWFyZ2luICsgX0xlZnRdID0gXCIwXCI7XG4gICAgICAgICAgb3ZlcnJpZGVbX3BhZGRpbmddID0gY3NbX3BhZGRpbmddO1xuICAgICAgICAgIG92ZXJyaWRlW19wYWRkaW5nICsgX1RvcF0gPSBjc1tfcGFkZGluZyArIF9Ub3BdO1xuICAgICAgICAgIG92ZXJyaWRlW19wYWRkaW5nICsgX1JpZ2h0XSA9IGNzW19wYWRkaW5nICsgX1JpZ2h0XTtcbiAgICAgICAgICBvdmVycmlkZVtfcGFkZGluZyArIF9Cb3R0b21dID0gY3NbX3BhZGRpbmcgKyBfQm90dG9tXTtcbiAgICAgICAgICBvdmVycmlkZVtfcGFkZGluZyArIF9MZWZ0XSA9IGNzW19wYWRkaW5nICsgX0xlZnRdO1xuICAgICAgICAgIHBpbkFjdGl2ZVN0YXRlID0gX2NvcHlTdGF0ZShwaW5PcmlnaW5hbFN0YXRlLCBvdmVycmlkZSwgcGluUmVwYXJlbnQpO1xuICAgICAgICAgIF9yZWZyZXNoaW5nQWxsICYmIHNjcm9sbEZ1bmMoMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgICAgLy8gdGhlIGFuaW1hdGlvbiBtaWdodCBiZSBhZmZlY3RpbmcgdGhlIHRyYW5zZm9ybSwgc28gd2UgbXVzdCBqdW1wIHRvIHRoZSBlbmQsIGNoZWNrIHRoZSB2YWx1ZSwgYW5kIGNvbXBlbnNhdGUgYWNjb3JkaW5nbHkuIE90aGVyd2lzZSwgd2hlbiBpdCBiZWNvbWVzIHVucGlubmVkLCB0aGUgcGluU2V0dGVyKCkgd2lsbCBnZXQgc2V0IHRvIGEgdmFsdWUgdGhhdCBkb2Vzbid0IGluY2x1ZGUgd2hhdGV2ZXIgdGhlIGFuaW1hdGlvbiBkaWQuXG4gICAgICAgICAgaW5pdHRlZCA9IGFuaW1hdGlvbi5faW5pdHRlZDsgLy8gaWYgbm90LCB3ZSBtdXN0IGludmFsaWRhdGUoKSBhZnRlciB0aGlzIHN0ZXAsIG90aGVyd2lzZSBpdCBjb3VsZCBsb2NrIGluIHN0YXJ0aW5nIHZhbHVlcyBwcmVtYXR1cmVseS5cblxuICAgICAgICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMoMSk7XG5cbiAgICAgICAgICBhbmltYXRpb24ucmVuZGVyKGFuaW1hdGlvbi5kdXJhdGlvbigpLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBwaW5DaGFuZ2UgPSBwaW5HZXR0ZXIoZGlyZWN0aW9uLmEpIC0gcGluU3RhcnQgKyBjaGFuZ2UgKyBvdGhlclBpbk9mZnNldDtcbiAgICAgICAgICBwaW5Nb3ZlcyA9IE1hdGguYWJzKGNoYW5nZSAtIHBpbkNoYW5nZSkgPiAxO1xuICAgICAgICAgIHVzZUZpeGVkUG9zaXRpb24gJiYgcGluTW92ZXMgJiYgcGluQWN0aXZlU3RhdGUuc3BsaWNlKHBpbkFjdGl2ZVN0YXRlLmxlbmd0aCAtIDIsIDIpOyAvLyB0cmFuc2Zvcm0gaXMgdGhlIGxhc3QgcHJvcGVydHkvdmFsdWUgc2V0IGluIHRoZSBzdGF0ZSBBcnJheS4gU2luY2UgdGhlIGFuaW1hdGlvbiBpcyBjb250cm9sbGluZyB0aGF0LCB3ZSBzaG91bGQgb21pdCBpdC5cblxuICAgICAgICAgIGFuaW1hdGlvbi5yZW5kZXIoMCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgaW5pdHRlZCB8fCBhbmltYXRpb24uaW52YWxpZGF0ZSh0cnVlKTtcbiAgICAgICAgICBhbmltYXRpb24ucGFyZW50IHx8IGFuaW1hdGlvbi50b3RhbFRpbWUoYW5pbWF0aW9uLnRvdGFsVGltZSgpKTsgLy8gaWYsIGZvciBleGFtcGxlLCBhIHRvZ2dsZUFjdGlvbiBjYWxsZWQgcGxheSgpIGFuZCB0aGVuIHJlZnJlc2goKSBoYXBwZW5zIGFuZCB3aGVuIHdlIHJlbmRlcigxKSBhYm92ZSwgaXQgd291bGQgY2F1c2UgdGhlIGFuaW1hdGlvbiB0byBjb21wbGV0ZSBhbmQgZ2V0IHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50LCBzbyB0aGlzIG1ha2VzIHN1cmUgaXQgZ2V0cyBwdXQgYmFjayBpbi5cblxuICAgICAgICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGluQ2hhbmdlID0gY2hhbmdlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yY2VkT3ZlcmZsb3cgJiYgKGZvcmNlZE92ZXJmbG93LnZhbHVlID8gZm9yY2VkT3ZlcmZsb3cuc3R5bGVbXCJvdmVyZmxvd1wiICsgZGlyZWN0aW9uLmEudG9VcHBlckNhc2UoKV0gPSBmb3JjZWRPdmVyZmxvdy52YWx1ZSA6IGZvcmNlZE92ZXJmbG93LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwib3ZlcmZsb3ctXCIgKyBkaXJlY3Rpb24uYSkpO1xuICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICYmIHNjcm9sbEZ1bmMoKSAmJiAhY29udGFpbmVyQW5pbWF0aW9uKSB7XG4gICAgICAgIC8vIGl0IG1heSBiZSBJTlNJREUgYSBwaW5uZWQgZWxlbWVudCwgc28gd2FsayB1cCB0aGUgdHJlZSBhbmQgbG9vayBmb3IgYW55IGVsZW1lbnRzIHdpdGggX3Bpbk9mZnNldCB0byBjb21wZW5zYXRlIGJlY2F1c2UgYW55dGhpbmcgd2l0aCBwaW5TcGFjaW5nIHRoYXQncyBhbHJlYWR5IHNjcm9sbGVkIHdvdWxkIHRocm93IG9mZiB0aGUgbWVhc3VyZW1lbnRzIGluIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIGJvdW5kcyA9IHRyaWdnZXIucGFyZW50Tm9kZTtcblxuICAgICAgICB3aGlsZSAoYm91bmRzICYmIGJvdW5kcyAhPT0gX2JvZHkpIHtcbiAgICAgICAgICBpZiAoYm91bmRzLl9waW5PZmZzZXQpIHtcbiAgICAgICAgICAgIHN0YXJ0IC09IGJvdW5kcy5fcGluT2Zmc2V0O1xuICAgICAgICAgICAgZW5kIC09IGJvdW5kcy5fcGluT2Zmc2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJvdW5kcyA9IGJvdW5kcy5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldmVydGVkUGlucyAmJiByZXZlcnRlZFBpbnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5yZXZlcnQoZmFsc2UsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICBzZWxmLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICBzZWxmLmVuZCA9IGVuZDtcbiAgICAgIHNjcm9sbDEgPSBzY3JvbGwyID0gX3JlZnJlc2hpbmdBbGwgPyBwcmV2U2Nyb2xsIDogc2Nyb2xsRnVuYygpOyAvLyByZXNldCB2ZWxvY2l0eVxuXG4gICAgICBpZiAoIWNvbnRhaW5lckFuaW1hdGlvbiAmJiAhX3JlZnJlc2hpbmdBbGwpIHtcbiAgICAgICAgc2Nyb2xsMSA8IHByZXZTY3JvbGwgJiYgc2Nyb2xsRnVuYyhwcmV2U2Nyb2xsKTtcbiAgICAgICAgc2VsZi5zY3JvbGwucmVjID0gMDtcbiAgICAgIH1cblxuICAgICAgc2VsZi5yZXZlcnQoZmFsc2UsIHRydWUpO1xuICAgICAgbGFzdFJlZnJlc2ggPSBfZ2V0VGltZSgpO1xuXG4gICAgICBpZiAoc25hcERlbGF5ZWRDYWxsKSB7XG4gICAgICAgIGxhc3RTbmFwID0gLTE7IC8vIGp1c3Qgc28gc25hcHBpbmcgZ2V0cyByZS1lbmFibGVkLCBjbGVhciBvdXQgYW55IHJlY29yZGVkIGxhc3QgdmFsdWVcbiAgICAgICAgLy8gc2VsZi5pc0FjdGl2ZSAmJiBzY3JvbGxGdW5jKHN0YXJ0ICsgY2hhbmdlICogcHJldlByb2dyZXNzKTsgLy8gcHJldmlvdXNseSB0aGlzIGxpbmUgd2FzIGhlcmUgdG8gZW5zdXJlIHRoYXQgd2hlbiBzbmFwcGluZyBraWNrcyBpbiwgaXQncyBmcm9tIHRoZSBwcmV2aW91cyBwcm9ncmVzcyBidXQgaW4gc29tZSBjYXNlcyB0aGF0J3Mgbm90IGRlc2lyYWJsZSwgbGlrZSBhbiBhbGwtcGFnZSBTY3JvbGxUcmlnZ2VyIHdoZW4gbmV3IGNvbnRlbnQgZ2V0cyBhZGRlZCB0byB0aGUgcGFnZSwgdGhhdCdkIHRvdGFsbHkgY2hhbmdlIHRoZSBwcm9ncmVzcy5cblxuICAgICAgICBzbmFwRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgX3JlZnJlc2hpbmcgPSAwO1xuICAgICAgYW5pbWF0aW9uICYmIGlzVG9nZ2xlICYmIChhbmltYXRpb24uX2luaXR0ZWQgfHwgcHJldkFuaW1Qcm9ncmVzcykgJiYgYW5pbWF0aW9uLnByb2dyZXNzKCkgIT09IHByZXZBbmltUHJvZ3Jlc3MgJiYgYW5pbWF0aW9uLnByb2dyZXNzKHByZXZBbmltUHJvZ3Jlc3MgfHwgMCwgdHJ1ZSkucmVuZGVyKGFuaW1hdGlvbi50aW1lKCksIHRydWUsIHRydWUpOyAvLyBtdXN0IGZvcmNlIGEgcmUtcmVuZGVyIGJlY2F1c2UgaWYgc2F2ZVN0eWxlcygpIHdhcyB1c2VkIG9uIHRoZSB0YXJnZXQocyksIHRoZSBzdHlsZXMgY291bGQgaGF2ZSBiZWVuIHdpcGVkIG91dCBkdXJpbmcgdGhlIHJlZnJlc2goKS5cblxuICAgICAgaWYgKGlzRmlyc3RSZWZyZXNoIHx8IHByZXZQcm9ncmVzcyAhPT0gc2VsZi5wcm9ncmVzcyB8fCBjb250YWluZXJBbmltYXRpb24gfHwgaW52YWxpZGF0ZU9uUmVmcmVzaCkge1xuICAgICAgICAvLyBlbnN1cmVzIHRoYXQgdGhlIGRpcmVjdGlvbiBpcyBzZXQgcHJvcGVybHkgKHdoZW4gcmVmcmVzaGluZywgcHJvZ3Jlc3MgaXMgc2V0IGJhY2sgdG8gMCBpbml0aWFsbHksIHRoZW4gYmFjayBhZ2FpbiB0byB3aGVyZXZlciBpdCBuZWVkcyB0byBiZSkgYW5kIHRoYXQgY2FsbGJhY2tzIGFyZSB0cmlnZ2VyZWQuXG4gICAgICAgIGFuaW1hdGlvbiAmJiAhaXNUb2dnbGUgJiYgYW5pbWF0aW9uLnRvdGFsUHJvZ3Jlc3MoY29udGFpbmVyQW5pbWF0aW9uICYmIHN0YXJ0IDwgLTAuMDAxICYmICFwcmV2UHJvZ3Jlc3MgPyBnc2FwLnV0aWxzLm5vcm1hbGl6ZShzdGFydCwgZW5kLCAwKSA6IHByZXZQcm9ncmVzcywgdHJ1ZSk7IC8vIHRvIGF2b2lkIGlzc3VlcyB3aGVyZSBhbmltYXRpb24gY2FsbGJhY2tzIGxpa2Ugb25TdGFydCBhcmVuJ3QgdHJpZ2dlcmVkLlxuXG4gICAgICAgIHNlbGYucHJvZ3Jlc3MgPSBpc0ZpcnN0UmVmcmVzaCB8fCAoc2Nyb2xsMSAtIHN0YXJ0KSAvIGNoYW5nZSA9PT0gcHJldlByb2dyZXNzID8gMCA6IHByZXZQcm9ncmVzcztcbiAgICAgIH1cblxuICAgICAgcGluICYmIHBpblNwYWNpbmcgJiYgKHNwYWNlci5fcGluT2Zmc2V0ID0gTWF0aC5yb3VuZChzZWxmLnByb2dyZXNzICogcGluQ2hhbmdlKSk7XG4gICAgICBzY3J1YlR3ZWVuICYmIHNjcnViVHdlZW4uaW52YWxpZGF0ZSgpO1xuXG4gICAgICBpZiAoIWlzTmFOKG1hcmtlclN0YXJ0T2Zmc2V0KSkge1xuICAgICAgICAvLyBudW1iZXJzIHdlcmUgcGFzc2VkIGluIGZvciB0aGUgcG9zaXRpb24gd2hpY2ggYXJlIGFic29sdXRlLCBzbyBpbnN0ZWFkIG9mIGp1c3QgcHV0dGluZyB0aGUgbWFya2VycyBhdCB0aGUgdmVyeSBib3R0b20gb2YgdGhlIHZpZXdwb3J0LCB3ZSBmaWd1cmUgb3V0IGhvdyBmYXIgdGhleSBzaGlmdGVkIGRvd24gKGl0J3Mgc2FmZSB0byBhc3N1bWUgdGhleSB3ZXJlIG9yaWdpbmFsbHkgcG9zaXRpb25lZCBpbiBjbG9zZXIgcmVsYXRpb24gdG8gdGhlIHRyaWdnZXIgZWxlbWVudCB3aXRoIHZhbHVlcyBsaWtlIFwidG9wXCIsIFwiY2VudGVyXCIsIGEgcGVyY2VudGFnZSBvciB3aGF0ZXZlciwgc28gd2Ugb2Zmc2V0IHRoYXQgbXVjaCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIHRvIGJhc2ljYWxseSByZXZlcnQgdGhlbSB0byB0aGUgcmVsYXRpdmUgcG9zaXRpb24gdGh5IHdlcmUgYXQgcHJldmlvdXNseS5cbiAgICAgICAgbWFya2VyU3RhcnRPZmZzZXQgLT0gZ3NhcC5nZXRQcm9wZXJ0eShtYXJrZXJTdGFydFRyaWdnZXIsIGRpcmVjdGlvbi5wKTtcbiAgICAgICAgbWFya2VyRW5kT2Zmc2V0IC09IGdzYXAuZ2V0UHJvcGVydHkobWFya2VyRW5kVHJpZ2dlciwgZGlyZWN0aW9uLnApO1xuXG4gICAgICAgIF9zaGlmdE1hcmtlcihtYXJrZXJTdGFydFRyaWdnZXIsIGRpcmVjdGlvbiwgbWFya2VyU3RhcnRPZmZzZXQpO1xuXG4gICAgICAgIF9zaGlmdE1hcmtlcihtYXJrZXJTdGFydCwgZGlyZWN0aW9uLCBtYXJrZXJTdGFydE9mZnNldCAtIChwaW5PZmZzZXQgfHwgMCkpO1xuXG4gICAgICAgIF9zaGlmdE1hcmtlcihtYXJrZXJFbmRUcmlnZ2VyLCBkaXJlY3Rpb24sIG1hcmtlckVuZE9mZnNldCk7XG5cbiAgICAgICAgX3NoaWZ0TWFya2VyKG1hcmtlckVuZCwgZGlyZWN0aW9uLCBtYXJrZXJFbmRPZmZzZXQgLSAocGluT2Zmc2V0IHx8IDApKTtcbiAgICAgIH1cblxuICAgICAgaXNGaXJzdFJlZnJlc2ggJiYgIV9yZWZyZXNoaW5nQWxsICYmIHNlbGYudXBkYXRlKCk7IC8vIGVkZ2UgY2FzZSAtIHdoZW4geW91IHJlbG9hZCBhIHBhZ2Ugd2hlbiBpdCdzIGFscmVhZHkgc2Nyb2xsZWQgZG93biwgc29tZSBicm93c2VycyBmaXJlIGEgXCJzY3JvbGxcIiBldmVudCBiZWZvcmUgRE9NQ29udGVudExvYWRlZCwgdHJpZ2dlcmluZyBhbiB1cGRhdGVBbGwoKS4gSWYgd2UgZG9uJ3QgdXBkYXRlIHRoZSBzZWxmLnByb2dyZXNzIGFzIHBhcnQgb2YgcmVmcmVzaCgpLCB0aGVuIHdoZW4gaXQgaGFwcGVucyBuZXh0LCBpdCBtYXkgcmVjb3JkIHByZXZQcm9ncmVzcyBhcyAwIHdoZW4gaXQgcmVhbGx5IHNob3VsZG4ndCwgcG90ZW50aWFsbHkgY2F1c2luZyBhIGNhbGxiYWNrIGluIGFuIGFuaW1hdGlvbiB0byBmaXJlIGFnYWluLlxuXG4gICAgICBpZiAob25SZWZyZXNoICYmICFfcmVmcmVzaGluZ0FsbCAmJiAhZXhlY3V0aW5nT25SZWZyZXNoKSB7XG4gICAgICAgIC8vIHdoZW4gcmVmcmVzaGluZyBhbGwsIHdlIGRvIGV4dHJhIHdvcmsgdG8gY29ycmVjdCBwaW5uZWRDb250YWluZXIgc2l6ZXMgYW5kIGVuc3VyZSB0aGluZ3MgZG9uJ3QgZXhjZWVkIHRoZSBtYXhTY3JvbGwsIHNvIHdlIHNob3VsZCBkbyBhbGwgdGhlIHJlZnJlc2hlcyBhdCB0aGUgZW5kIGFmdGVyIGFsbCB0aGF0IHdvcmsgc28gdGhhdCB0aGUgc3RhcnQvZW5kIHZhbHVlcyBhcmUgY29ycmVjdGVkLlxuICAgICAgICBleGVjdXRpbmdPblJlZnJlc2ggPSB0cnVlO1xuICAgICAgICBvblJlZnJlc2goc2VsZik7XG4gICAgICAgIGV4ZWN1dGluZ09uUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmdldFZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChzY3JvbGxGdW5jKCkgLSBzY3JvbGwyKSAvIChfZ2V0VGltZSgpIC0gX3RpbWUyKSAqIDEwMDAgfHwgMDtcbiAgICB9O1xuXG4gICAgc2VsZi5lbmRBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfZW5kQW5pbWF0aW9uKHNlbGYuY2FsbGJhY2tBbmltYXRpb24pO1xuXG4gICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIHNjcnViVHdlZW4gPyBzY3J1YlR3ZWVuLnByb2dyZXNzKDEpIDogIWFuaW1hdGlvbi5wYXVzZWQoKSA/IF9lbmRBbmltYXRpb24oYW5pbWF0aW9uLCBhbmltYXRpb24ucmV2ZXJzZWQoKSkgOiBpc1RvZ2dsZSB8fCBfZW5kQW5pbWF0aW9uKGFuaW1hdGlvbiwgc2VsZi5kaXJlY3Rpb24gPCAwLCAxKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5sYWJlbFRvU2Nyb2xsID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICByZXR1cm4gYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5sYWJlbHMgJiYgKHN0YXJ0IHx8IHNlbGYucmVmcmVzaCgpIHx8IHN0YXJ0KSArIGFuaW1hdGlvbi5sYWJlbHNbbGFiZWxdIC8gYW5pbWF0aW9uLmR1cmF0aW9uKCkgKiBjaGFuZ2UgfHwgMDtcbiAgICB9O1xuXG4gICAgc2VsZi5nZXRUcmFpbGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgaSA9IF90cmlnZ2Vycy5pbmRleE9mKHNlbGYpLFxuICAgICAgICAgIGEgPSBzZWxmLmRpcmVjdGlvbiA+IDAgPyBfdHJpZ2dlcnMuc2xpY2UoMCwgaSkucmV2ZXJzZSgpIDogX3RyaWdnZXJzLnNsaWNlKGkgKyAxKTtcblxuICAgICAgcmV0dXJuIChfaXNTdHJpbmcobmFtZSkgPyBhLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC52YXJzLnByZXZlbnRPdmVybGFwcyA9PT0gbmFtZTtcbiAgICAgIH0pIDogYSkuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBzZWxmLmRpcmVjdGlvbiA+IDAgPyB0LmVuZCA8PSBzdGFydCA6IHQuc3RhcnQgPj0gZW5kO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHNlbGYudXBkYXRlID0gZnVuY3Rpb24gKHJlc2V0LCByZWNvcmRWZWxvY2l0eSwgZm9yY2VGYWtlKSB7XG4gICAgICBpZiAoY29udGFpbmVyQW5pbWF0aW9uICYmICFmb3JjZUZha2UgJiYgIXJlc2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNjcm9sbCA9IF9yZWZyZXNoaW5nQWxsID09PSB0cnVlID8gcHJldlNjcm9sbCA6IHNlbGYuc2Nyb2xsKCksXG4gICAgICAgICAgcCA9IHJlc2V0ID8gMCA6IChzY3JvbGwgLSBzdGFydCkgLyBjaGFuZ2UsXG4gICAgICAgICAgY2xpcHBlZCA9IHAgPCAwID8gMCA6IHAgPiAxID8gMSA6IHAgfHwgMCxcbiAgICAgICAgICBwcmV2UHJvZ3Jlc3MgPSBzZWxmLnByb2dyZXNzLFxuICAgICAgICAgIGlzQWN0aXZlLFxuICAgICAgICAgIHdhc0FjdGl2ZSxcbiAgICAgICAgICB0b2dnbGVTdGF0ZSxcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgc3RhdGVDaGFuZ2VkLFxuICAgICAgICAgIHRvZ2dsZWQsXG4gICAgICAgICAgaXNBdE1heCxcbiAgICAgICAgICBpc1Rha2luZ0FjdGlvbjtcblxuICAgICAgaWYgKHJlY29yZFZlbG9jaXR5KSB7XG4gICAgICAgIHNjcm9sbDIgPSBzY3JvbGwxO1xuICAgICAgICBzY3JvbGwxID0gY29udGFpbmVyQW5pbWF0aW9uID8gc2Nyb2xsRnVuYygpIDogc2Nyb2xsO1xuXG4gICAgICAgIGlmIChzbmFwKSB7XG4gICAgICAgICAgc25hcDIgPSBzbmFwMTtcbiAgICAgICAgICBzbmFwMSA9IGFuaW1hdGlvbiAmJiAhaXNUb2dnbGUgPyBhbmltYXRpb24udG90YWxQcm9ncmVzcygpIDogY2xpcHBlZDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBhbnRpY2lwYXRlIHRoZSBwaW5uaW5nIGEgZmV3IHRpY2tzIGFoZWFkIG9mIHRpbWUgYmFzZWQgb24gdmVsb2NpdHkgdG8gYXZvaWQgYSB2aXN1YWwgZ2xpdGNoIGR1ZSB0byB0aGUgZmFjdCB0aGF0IG1vc3QgYnJvd3NlcnMgZG8gc2Nyb2xsaW5nIG9uIGEgc2VwYXJhdGUgdGhyZWFkIChub3Qgc3luY2VkIHdpdGggcmVxdWVzdEFuaW1hdGlvbkZyYW1lKS5cblxuXG4gICAgICBpZiAoYW50aWNpcGF0ZVBpbiAmJiBwaW4gJiYgIV9yZWZyZXNoaW5nICYmICFfc3RhcnR1cCAmJiBfbGFzdFNjcm9sbFRpbWUpIHtcbiAgICAgICAgaWYgKCFjbGlwcGVkICYmIHN0YXJ0IDwgc2Nyb2xsICsgKHNjcm9sbCAtIHNjcm9sbDIpIC8gKF9nZXRUaW1lKCkgLSBfdGltZTIpICogYW50aWNpcGF0ZVBpbikge1xuICAgICAgICAgIGNsaXBwZWQgPSAwLjAwMDE7XG4gICAgICAgIH0gZWxzZSBpZiAoY2xpcHBlZCA9PT0gMSAmJiBlbmQgPiBzY3JvbGwgKyAoc2Nyb2xsIC0gc2Nyb2xsMikgLyAoX2dldFRpbWUoKSAtIF90aW1lMikgKiBhbnRpY2lwYXRlUGluKSB7XG4gICAgICAgICAgY2xpcHBlZCA9IDAuOTk5OTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2xpcHBlZCAhPT0gcHJldlByb2dyZXNzICYmIHNlbGYuZW5hYmxlZCkge1xuICAgICAgICBpc0FjdGl2ZSA9IHNlbGYuaXNBY3RpdmUgPSAhIWNsaXBwZWQgJiYgY2xpcHBlZCA8IDE7XG4gICAgICAgIHdhc0FjdGl2ZSA9ICEhcHJldlByb2dyZXNzICYmIHByZXZQcm9ncmVzcyA8IDE7XG4gICAgICAgIHRvZ2dsZWQgPSBpc0FjdGl2ZSAhPT0gd2FzQWN0aXZlO1xuICAgICAgICBzdGF0ZUNoYW5nZWQgPSB0b2dnbGVkIHx8ICEhY2xpcHBlZCAhPT0gISFwcmV2UHJvZ3Jlc3M7IC8vIGNvdWxkIGdvIGZyb20gc3RhcnQgYWxsIHRoZSB3YXkgdG8gZW5kLCB0aHVzIGl0IGRpZG4ndCB0b2dnbGUgYnV0IGl0IGRpZCBjaGFuZ2Ugc3RhdGUgaW4gYSBzZW5zZSAobWF5IG5lZWQgdG8gZmlyZSBhIGNhbGxiYWNrKVxuXG4gICAgICAgIHNlbGYuZGlyZWN0aW9uID0gY2xpcHBlZCA+IHByZXZQcm9ncmVzcyA/IDEgOiAtMTtcbiAgICAgICAgc2VsZi5wcm9ncmVzcyA9IGNsaXBwZWQ7XG5cbiAgICAgICAgaWYgKHN0YXRlQ2hhbmdlZCAmJiAhX3JlZnJlc2hpbmcpIHtcbiAgICAgICAgICB0b2dnbGVTdGF0ZSA9IGNsaXBwZWQgJiYgIXByZXZQcm9ncmVzcyA/IDAgOiBjbGlwcGVkID09PSAxID8gMSA6IHByZXZQcm9ncmVzcyA9PT0gMSA/IDIgOiAzOyAvLyAwID0gZW50ZXIsIDEgPSBsZWF2ZSwgMiA9IGVudGVyQmFjaywgMyA9IGxlYXZlQmFjayAod2UgcHJpb3JpdGl6ZSB0aGUgRklSU1QgZW5jb3VudGVyLCB0aHVzIGlmIHlvdSBzY3JvbGwgcmVhbGx5IGZhc3QgcGFzdCB0aGUgb25FbnRlciBhbmQgb25MZWF2ZSBpbiBvbmUgdGljaywgaXQnZCBwcmlvcml0aXplIG9uRW50ZXIuXG5cbiAgICAgICAgICBpZiAoaXNUb2dnbGUpIHtcbiAgICAgICAgICAgIGFjdGlvbiA9ICF0b2dnbGVkICYmIHRvZ2dsZUFjdGlvbnNbdG9nZ2xlU3RhdGUgKyAxXSAhPT0gXCJub25lXCIgJiYgdG9nZ2xlQWN0aW9uc1t0b2dnbGVTdGF0ZSArIDFdIHx8IHRvZ2dsZUFjdGlvbnNbdG9nZ2xlU3RhdGVdOyAvLyBpZiBpdCBkaWRuJ3QgdG9nZ2xlLCB0aGF0IG1lYW5zIGl0IHNob3QgcmlnaHQgcGFzdCBhbmQgc2luY2Ugd2UgcHJpb3JpdGl6ZSB0aGUgXCJlbnRlclwiIGFjdGlvbiwgd2Ugc2hvdWxkIHN3aXRjaCB0byB0aGUgXCJsZWF2ZVwiIGluIHRoaXMgY2FzZSAoYnV0IG9ubHkgaWYgb25lIGlzIGRlZmluZWQpXG5cbiAgICAgICAgICAgIGlzVGFraW5nQWN0aW9uID0gYW5pbWF0aW9uICYmIChhY3Rpb24gPT09IFwiY29tcGxldGVcIiB8fCBhY3Rpb24gPT09IFwicmVzZXRcIiB8fCBhY3Rpb24gaW4gYW5pbWF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2ZW50T3ZlcmxhcHMgJiYgKHRvZ2dsZWQgfHwgaXNUYWtpbmdBY3Rpb24pICYmIChpc1Rha2luZ0FjdGlvbiB8fCBzY3J1YiB8fCAhYW5pbWF0aW9uKSAmJiAoX2lzRnVuY3Rpb24ocHJldmVudE92ZXJsYXBzKSA/IHByZXZlbnRPdmVybGFwcyhzZWxmKSA6IHNlbGYuZ2V0VHJhaWxpbmcocHJldmVudE92ZXJsYXBzKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQuZW5kQW5pbWF0aW9uKCk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBpZiAoIWlzVG9nZ2xlKSB7XG4gICAgICAgICAgaWYgKHNjcnViVHdlZW4gJiYgIV9yZWZyZXNoaW5nICYmICFfc3RhcnR1cCkge1xuICAgICAgICAgICAgc2NydWJUd2Vlbi5fZHAuX3RpbWUgLSBzY3J1YlR3ZWVuLl9zdGFydCAhPT0gc2NydWJUd2Vlbi5fdGltZSAmJiBzY3J1YlR3ZWVuLnJlbmRlcihzY3J1YlR3ZWVuLl9kcC5fdGltZSAtIHNjcnViVHdlZW4uX3N0YXJ0KTsgLy8gaWYgdGhlcmUncyBhIHNjcnViIG9uIGJvdGggdGhlIGNvbnRhaW5lciBhbmltYXRpb24gYW5kIHRoaXMgb25lIChvciBhIFNjcm9sbFNtb290aGVyKSwgdGhlIHVwZGF0ZSBvcmRlciB3b3VsZCBjYXVzZSB0aGlzIG9uZSBub3QgdG8gaGF2ZSByZW5kZXJlZCB5ZXQsIHNvIGl0IHdvdWxkbid0IG1ha2UgYW55IHByb2dyZXNzIGJlZm9yZSB3ZSAucmVzdGFydCgpIGl0IGhlYWRpbmcgdG93YXJkIHRoZSBuZXcgcHJvZ3Jlc3Mgc28gaXQnZCBhcHBlYXIgc3R1Y2sgdGh1cyB3ZSBmb3JjZSBhIHJlbmRlciBoZXJlLlxuXG4gICAgICAgICAgICBpZiAoc2NydWJUd2Vlbi5yZXNldFRvKSB7XG4gICAgICAgICAgICAgIHNjcnViVHdlZW4ucmVzZXRUbyhcInRvdGFsUHJvZ3Jlc3NcIiwgY2xpcHBlZCwgYW5pbWF0aW9uLl90VGltZSAvIGFuaW1hdGlvbi5fdER1cik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBsZWdhY3kgc3VwcG9ydCAoY291cnRlc3kpLCBiZWZvcmUgMy4xMC4wXG4gICAgICAgICAgICAgIHNjcnViVHdlZW4udmFycy50b3RhbFByb2dyZXNzID0gY2xpcHBlZDtcbiAgICAgICAgICAgICAgc2NydWJUd2Vlbi5pbnZhbGlkYXRlKCkucmVzdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBhbmltYXRpb24udG90YWxQcm9ncmVzcyhjbGlwcGVkLCAhIShfcmVmcmVzaGluZyAmJiAobGFzdFJlZnJlc2ggfHwgcmVzZXQpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBpbikge1xuICAgICAgICAgIHJlc2V0ICYmIHBpblNwYWNpbmcgJiYgKHNwYWNlci5zdHlsZVtwaW5TcGFjaW5nICsgZGlyZWN0aW9uLm9zMl0gPSBzcGFjaW5nU3RhcnQpO1xuXG4gICAgICAgICAgaWYgKCF1c2VGaXhlZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBwaW5TZXR0ZXIoX3JvdW5kKHBpblN0YXJ0ICsgcGluQ2hhbmdlICogY2xpcHBlZCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpc0F0TWF4ID0gIXJlc2V0ICYmIGNsaXBwZWQgPiBwcmV2UHJvZ3Jlc3MgJiYgZW5kICsgMSA+IHNjcm9sbCAmJiBzY3JvbGwgKyAxID49IF9tYXhTY3JvbGwoc2Nyb2xsZXIsIGRpcmVjdGlvbik7IC8vIGlmIGl0J3MgYXQgdGhlIFZFUlkgZW5kIG9mIHRoZSBwYWdlLCBkb24ndCBzd2l0Y2ggYXdheSBmcm9tIHBvc2l0aW9uOiBmaXhlZCBiZWNhdXNlIGl0J3MgcG9pbnRsZXNzIGFuZCBpdCBjb3VsZCBjYXVzZSBhIGJyaWVmIGZsYXNoIHdoZW4gdGhlIHVzZXIgc2Nyb2xscyBiYWNrIHVwICh3aGVuIGl0IGdldHMgcGlubmVkIGFnYWluKVxuXG4gICAgICAgICAgICBpZiAocGluUmVwYXJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKCFyZXNldCAmJiAoaXNBY3RpdmUgfHwgaXNBdE1heCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRzID0gX2dldEJvdW5kcyhwaW4sIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICBfb2Zmc2V0ID0gc2Nyb2xsIC0gc3RhcnQ7XG5cbiAgICAgICAgICAgICAgICBfcmVwYXJlbnQocGluLCBfYm9keSwgYm91bmRzLnRvcCArIChkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbCA/IF9vZmZzZXQgOiAwKSArIF9weCwgYm91bmRzLmxlZnQgKyAoZGlyZWN0aW9uID09PSBfdmVydGljYWwgPyAwIDogX29mZnNldCkgKyBfcHgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9yZXBhcmVudChwaW4sIHNwYWNlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3NldFN0YXRlKGlzQWN0aXZlIHx8IGlzQXRNYXggPyBwaW5BY3RpdmVTdGF0ZSA6IHBpblN0YXRlKTtcblxuICAgICAgICAgICAgcGluTW92ZXMgJiYgY2xpcHBlZCA8IDEgJiYgaXNBY3RpdmUgfHwgcGluU2V0dGVyKHBpblN0YXJ0ICsgKGNsaXBwZWQgPT09IDEgJiYgIWlzQXRNYXggPyBwaW5DaGFuZ2UgOiAwKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc25hcCAmJiAhdHdlZW5Uby50d2VlbiAmJiAhX3JlZnJlc2hpbmcgJiYgIV9zdGFydHVwICYmIHNuYXBEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpO1xuICAgICAgICB0b2dnbGVDbGFzcyAmJiAodG9nZ2xlZCB8fCBvbmNlICYmIGNsaXBwZWQgJiYgKGNsaXBwZWQgPCAxIHx8ICFfbGltaXRDYWxsYmFja3MpKSAmJiBfdG9BcnJheSh0b2dnbGVDbGFzcy50YXJnZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIHJldHVybiBlbC5jbGFzc0xpc3RbaXNBY3RpdmUgfHwgb25jZSA/IFwiYWRkXCIgOiBcInJlbW92ZVwiXSh0b2dnbGVDbGFzcy5jbGFzc05hbWUpO1xuICAgICAgICB9KTsgLy8gY2xhc3NlcyBjb3VsZCBhZmZlY3QgcG9zaXRpb25pbmcsIHNvIGRvIGl0IGV2ZW4gaWYgcmVzZXQgb3IgcmVmcmVzaGluZyBpcyB0cnVlLlxuXG4gICAgICAgIG9uVXBkYXRlICYmICFpc1RvZ2dsZSAmJiAhcmVzZXQgJiYgb25VcGRhdGUoc2VsZik7XG5cbiAgICAgICAgaWYgKHN0YXRlQ2hhbmdlZCAmJiAhX3JlZnJlc2hpbmcpIHtcbiAgICAgICAgICBpZiAoaXNUb2dnbGUpIHtcbiAgICAgICAgICAgIGlmIChpc1Rha2luZ0FjdGlvbikge1xuICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24ucGF1c2UoKS50b3RhbFByb2dyZXNzKDEpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJyZXNldFwiKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLnJlc3RhcnQodHJ1ZSkucGF1c2UoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT09IFwicmVzdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLnJlc3RhcnQodHJ1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uW2FjdGlvbl0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvblVwZGF0ZSAmJiBvblVwZGF0ZShzZWxmKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodG9nZ2xlZCB8fCAhX2xpbWl0Q2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAvLyBvbiBzdGFydHVwLCB0aGUgcGFnZSBjb3VsZCBiZSBzY3JvbGxlZCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBmaXJlIGNhbGxiYWNrcyB0aGF0IGRpZG4ndCB0b2dnbGUuIEZvciBleGFtcGxlIG9uRW50ZXIgc2hvdWxkbid0IGZpcmUgaWYgdGhlIFNjcm9sbFRyaWdnZXIgaXNuJ3QgYWN0dWFsbHkgZW50ZXJlZC5cbiAgICAgICAgICAgIG9uVG9nZ2xlICYmIHRvZ2dsZWQgJiYgX2NhbGxiYWNrKHNlbGYsIG9uVG9nZ2xlKTtcbiAgICAgICAgICAgIGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0gJiYgX2NhbGxiYWNrKHNlbGYsIGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0pO1xuICAgICAgICAgICAgb25jZSAmJiAoY2xpcHBlZCA9PT0gMSA/IHNlbGYua2lsbChmYWxzZSwgMSkgOiBjYWxsYmFja3NbdG9nZ2xlU3RhdGVdID0gMCk7IC8vIGEgY2FsbGJhY2sgc2hvdWxkbid0IGJlIGNhbGxlZCBhZ2FpbiBpZiBvbmNlIGlzIHRydWUuXG5cbiAgICAgICAgICAgIGlmICghdG9nZ2xlZCkge1xuICAgICAgICAgICAgICAvLyBpdCdzIHBvc3NpYmxlIHRvIGdvIGNvbXBsZXRlbHkgcGFzdCwgbGlrZSBmcm9tIGJlZm9yZSB0aGUgc3RhcnQgdG8gYWZ0ZXIgdGhlIGVuZCAob3IgdmljZS12ZXJzYSkgaW4gd2hpY2ggY2FzZSBCT1RIIGNhbGxiYWNrcyBzaG91bGQgYmUgZmlyZWQgaW4gdGhhdCBvcmRlclxuICAgICAgICAgICAgICB0b2dnbGVTdGF0ZSA9IGNsaXBwZWQgPT09IDEgPyAxIDogMztcbiAgICAgICAgICAgICAgY2FsbGJhY2tzW3RvZ2dsZVN0YXRlXSAmJiBfY2FsbGJhY2soc2VsZiwgY2FsbGJhY2tzW3RvZ2dsZVN0YXRlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZhc3RTY3JvbGxFbmQgJiYgIWlzQWN0aXZlICYmIE1hdGguYWJzKHNlbGYuZ2V0VmVsb2NpdHkoKSkgPiAoX2lzTnVtYmVyKGZhc3RTY3JvbGxFbmQpID8gZmFzdFNjcm9sbEVuZCA6IDI1MDApKSB7XG4gICAgICAgICAgICBfZW5kQW5pbWF0aW9uKHNlbGYuY2FsbGJhY2tBbmltYXRpb24pO1xuXG4gICAgICAgICAgICBzY3J1YlR3ZWVuID8gc2NydWJUd2Vlbi5wcm9ncmVzcygxKSA6IF9lbmRBbmltYXRpb24oYW5pbWF0aW9uLCBhY3Rpb24gPT09IFwicmV2ZXJzZVwiID8gMSA6ICFjbGlwcGVkLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNUb2dnbGUgJiYgb25VcGRhdGUgJiYgIV9yZWZyZXNoaW5nKSB7XG4gICAgICAgICAgb25VcGRhdGUoc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gdXBkYXRlIGFic29sdXRlbHktcG9zaXRpb25lZCBtYXJrZXJzIChvbmx5IGlmIHRoZSBzY3JvbGxlciBpc24ndCB0aGUgdmlld3BvcnQpXG5cblxuICAgICAgaWYgKG1hcmtlckVuZFNldHRlcikge1xuICAgICAgICB2YXIgbiA9IGNvbnRhaW5lckFuaW1hdGlvbiA/IHNjcm9sbCAvIGNvbnRhaW5lckFuaW1hdGlvbi5kdXJhdGlvbigpICogKGNvbnRhaW5lckFuaW1hdGlvbi5fY2FTY3JvbGxEaXN0IHx8IDApIDogc2Nyb2xsO1xuICAgICAgICBtYXJrZXJTdGFydFNldHRlcihuICsgKG1hcmtlclN0YXJ0VHJpZ2dlci5faXNGbGlwcGVkID8gMSA6IDApKTtcbiAgICAgICAgbWFya2VyRW5kU2V0dGVyKG4pO1xuICAgICAgfVxuXG4gICAgICBjYU1hcmtlclNldHRlciAmJiBjYU1hcmtlclNldHRlcigtc2Nyb2xsIC8gY29udGFpbmVyQW5pbWF0aW9uLmR1cmF0aW9uKCkgKiAoY29udGFpbmVyQW5pbWF0aW9uLl9jYVNjcm9sbERpc3QgfHwgMCkpO1xuICAgIH07XG5cbiAgICBzZWxmLmVuYWJsZSA9IGZ1bmN0aW9uIChyZXNldCwgcmVmcmVzaCkge1xuICAgICAgaWYgKCFzZWxmLmVuYWJsZWQpIHtcbiAgICAgICAgc2VsZi5lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICBfYWRkTGlzdGVuZXIoc2Nyb2xsZXIsIFwicmVzaXplXCIsIF9vblJlc2l6ZSk7XG5cbiAgICAgICAgaXNWaWV3cG9ydCB8fCBfYWRkTGlzdGVuZXIoc2Nyb2xsZXIsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG4gICAgICAgIG9uUmVmcmVzaEluaXQgJiYgX2FkZExpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwicmVmcmVzaEluaXRcIiwgb25SZWZyZXNoSW5pdCk7XG5cbiAgICAgICAgaWYgKHJlc2V0ICE9PSBmYWxzZSkge1xuICAgICAgICAgIHNlbGYucHJvZ3Jlc3MgPSBwcmV2UHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgIHNjcm9sbDEgPSBzY3JvbGwyID0gbGFzdFNuYXAgPSBzY3JvbGxGdW5jKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZWZyZXNoICE9PSBmYWxzZSAmJiBzZWxmLnJlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5nZXRUd2VlbiA9IGZ1bmN0aW9uIChzbmFwKSB7XG4gICAgICByZXR1cm4gc25hcCAmJiB0d2VlblRvID8gdHdlZW5Uby50d2VlbiA6IHNjcnViVHdlZW47XG4gICAgfTtcblxuICAgIHNlbGYuc2V0UG9zaXRpb25zID0gZnVuY3Rpb24gKG5ld1N0YXJ0LCBuZXdFbmQsIGtlZXBDbGFtcCwgcGluT2Zmc2V0KSB7XG4gICAgICAvLyBkb2Vzbid0IHBlcnNpc3QgYWZ0ZXIgcmVmcmVzaCgpISBJbnRlbmRlZCB0byBiZSBhIHdheSB0byBvdmVycmlkZSB2YWx1ZXMgdGhhdCB3ZXJlIHNldCBkdXJpbmcgcmVmcmVzaCgpLCBsaWtlIHlvdSBjb3VsZCBzZXQgaXQgaW4gb25SZWZyZXNoKClcbiAgICAgIGlmIChjb250YWluZXJBbmltYXRpb24pIHtcbiAgICAgICAgLy8gY29udmVydCByYXRpb3MgaW50byBzY3JvbGwgcG9zaXRpb25zLiBSZW1lbWJlciwgc3RhcnQvZW5kIHZhbHVlcyBvbiBTY3JvbGxUcmlnZ2VycyB0aGF0IGhhdmUgYSBjb250YWluZXJBbmltYXRpb24gcmVmZXIgdG8gdGhlIHRpbWUgKGluIHNlY29uZHMpLCBOT1Qgc2Nyb2xsIHBvc2l0aW9ucy5cbiAgICAgICAgdmFyIHN0ID0gY29udGFpbmVyQW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIsXG4gICAgICAgICAgICBkdXJhdGlvbiA9IGNvbnRhaW5lckFuaW1hdGlvbi5kdXJhdGlvbigpLFxuICAgICAgICAgICAgX2NoYW5nZSA9IHN0LmVuZCAtIHN0LnN0YXJ0O1xuXG4gICAgICAgIG5ld1N0YXJ0ID0gc3Quc3RhcnQgKyBfY2hhbmdlICogbmV3U3RhcnQgLyBkdXJhdGlvbjtcbiAgICAgICAgbmV3RW5kID0gc3Quc3RhcnQgKyBfY2hhbmdlICogbmV3RW5kIC8gZHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIHNlbGYucmVmcmVzaChmYWxzZSwgZmFsc2UsIHtcbiAgICAgICAgc3RhcnQ6IF9rZWVwQ2xhbXAobmV3U3RhcnQsIGtlZXBDbGFtcCAmJiAhIXNlbGYuX3N0YXJ0Q2xhbXApLFxuICAgICAgICBlbmQ6IF9rZWVwQ2xhbXAobmV3RW5kLCBrZWVwQ2xhbXAgJiYgISFzZWxmLl9lbmRDbGFtcClcbiAgICAgIH0sIHBpbk9mZnNldCk7XG4gICAgICBzZWxmLnVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICBzZWxmLmFkanVzdFBpblNwYWNpbmcgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICBpZiAoc3BhY2VyU3RhdGUgJiYgYW1vdW50KSB7XG4gICAgICAgIHZhciBpID0gc3BhY2VyU3RhdGUuaW5kZXhPZihkaXJlY3Rpb24uZCkgKyAxO1xuICAgICAgICBzcGFjZXJTdGF0ZVtpXSA9IHBhcnNlRmxvYXQoc3BhY2VyU3RhdGVbaV0pICsgYW1vdW50ICsgX3B4O1xuICAgICAgICBzcGFjZXJTdGF0ZVsxXSA9IHBhcnNlRmxvYXQoc3BhY2VyU3RhdGVbMV0pICsgYW1vdW50ICsgX3B4O1xuXG4gICAgICAgIF9zZXRTdGF0ZShzcGFjZXJTdGF0ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbGYuZGlzYWJsZSA9IGZ1bmN0aW9uIChyZXNldCwgYWxsb3dBbmltYXRpb24pIHtcbiAgICAgIGlmIChzZWxmLmVuYWJsZWQpIHtcbiAgICAgICAgcmVzZXQgIT09IGZhbHNlICYmIHNlbGYucmV2ZXJ0KHRydWUsIHRydWUpO1xuICAgICAgICBzZWxmLmVuYWJsZWQgPSBzZWxmLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGFsbG93QW5pbWF0aW9uIHx8IHNjcnViVHdlZW4gJiYgc2NydWJUd2Vlbi5wYXVzZSgpO1xuICAgICAgICBwcmV2U2Nyb2xsID0gMDtcbiAgICAgICAgcGluQ2FjaGUgJiYgKHBpbkNhY2hlLnVuY2FjaGUgPSAxKTtcbiAgICAgICAgb25SZWZyZXNoSW5pdCAmJiBfcmVtb3ZlTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJyZWZyZXNoSW5pdFwiLCBvblJlZnJlc2hJbml0KTtcblxuICAgICAgICBpZiAoc25hcERlbGF5ZWRDYWxsKSB7XG4gICAgICAgICAgc25hcERlbGF5ZWRDYWxsLnBhdXNlKCk7XG4gICAgICAgICAgdHdlZW5Uby50d2VlbiAmJiB0d2VlblRvLnR3ZWVuLmtpbGwoKSAmJiAodHdlZW5Uby50d2VlbiA9IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1ZpZXdwb3J0KSB7XG4gICAgICAgICAgdmFyIGkgPSBfdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgaWYgKF90cmlnZ2Vyc1tpXS5zY3JvbGxlciA9PT0gc2Nyb2xsZXIgJiYgX3RyaWdnZXJzW2ldICE9PSBzZWxmKSB7XG4gICAgICAgICAgICAgIHJldHVybjsgLy9kb24ndCByZW1vdmUgdGhlIGxpc3RlbmVycyBpZiB0aGVyZSBhcmUgc3RpbGwgb3RoZXIgdHJpZ2dlcnMgcmVmZXJlbmNpbmcgaXQuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHNjcm9sbGVyLCBcInJlc2l6ZVwiLCBfb25SZXNpemUpO1xuXG4gICAgICAgICAgaXNWaWV3cG9ydCB8fCBfcmVtb3ZlTGlzdGVuZXIoc2Nyb2xsZXIsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5raWxsID0gZnVuY3Rpb24gKHJldmVydCwgYWxsb3dBbmltYXRpb24pIHtcbiAgICAgIHNlbGYuZGlzYWJsZShyZXZlcnQsIGFsbG93QW5pbWF0aW9uKTtcbiAgICAgIHNjcnViVHdlZW4gJiYgIWFsbG93QW5pbWF0aW9uICYmIHNjcnViVHdlZW4ua2lsbCgpO1xuICAgICAgaWQgJiYgZGVsZXRlIF9pZHNbaWRdO1xuXG4gICAgICB2YXIgaSA9IF90cmlnZ2Vycy5pbmRleE9mKHNlbGYpO1xuXG4gICAgICBpID49IDAgJiYgX3RyaWdnZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIGkgPT09IF9pICYmIF9kaXJlY3Rpb24gPiAwICYmIF9pLS07IC8vIGlmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSByZWZyZXNoKCkgb3IgdXBkYXRlKCksIHNwbGljaW5nIHdvdWxkIGNhdXNlIHNraXBzIGluIHRoZSBpbmRleCwgc28gYWRqdXN0Li4uXG4gICAgICAvLyBpZiBubyBvdGhlciBTY3JvbGxUcmlnZ2VyIGluc3RhbmNlcyBvZiB0aGUgc2FtZSBzY3JvbGxlciBhcmUgZm91bmQsIHdpcGUgb3V0IGFueSByZWNvcmRlZCBzY3JvbGwgcG9zaXRpb24uIE90aGVyd2lzZSwgaW4gYSBzaW5nbGUgcGFnZSBhcHBsaWNhdGlvbiwgZm9yIGV4YW1wbGUsIGl0IGNvdWxkIG1haW50YWluIHNjcm9sbCBwb3NpdGlvbiB3aGVuIGl0IHJlYWxseSBzaG91bGRuJ3QuXG5cbiAgICAgIGkgPSAwO1xuXG4gICAgICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5zY3JvbGxlciA9PT0gc2VsZi5zY3JvbGxlciAmJiAoaSA9IDEpO1xuICAgICAgfSk7XG5cbiAgICAgIGkgfHwgX3JlZnJlc2hpbmdBbGwgfHwgKHNlbGYuc2Nyb2xsLnJlYyA9IDApO1xuXG4gICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIGFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyID0gbnVsbDtcbiAgICAgICAgcmV2ZXJ0ICYmIGFuaW1hdGlvbi5yZXZlcnQoe1xuICAgICAgICAgIGtpbGw6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBhbGxvd0FuaW1hdGlvbiB8fCBhbmltYXRpb24ua2lsbCgpO1xuICAgICAgfVxuXG4gICAgICBtYXJrZXJTdGFydCAmJiBbbWFya2VyU3RhcnQsIG1hcmtlckVuZCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiBtLnBhcmVudE5vZGUgJiYgbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG0pO1xuICAgICAgfSk7XG4gICAgICBfcHJpbWFyeSA9PT0gc2VsZiAmJiAoX3ByaW1hcnkgPSAwKTtcblxuICAgICAgaWYgKHBpbikge1xuICAgICAgICBwaW5DYWNoZSAmJiAocGluQ2FjaGUudW5jYWNoZSA9IDEpO1xuICAgICAgICBpID0gMDtcblxuICAgICAgICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0LnBpbiA9PT0gcGluICYmIGkrKztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaSB8fCAocGluQ2FjaGUuc3BhY2VyID0gMCk7IC8vIGlmIHRoZXJlIGFyZW4ndCBhbnkgbW9yZSBTY3JvbGxUcmlnZ2VycyB3aXRoIHRoZSBzYW1lIHBpbiwgcmVtb3ZlIHRoZSBzcGFjZXIsIG90aGVyd2lzZSBpdCBjb3VsZCBiZSBjb250YW1pbmF0ZWQgd2l0aCBvbGQvc3RhbGUgdmFsdWVzIGlmIHRoZSB1c2VyIHJlLWNyZWF0ZXMgYSBTY3JvbGxUcmlnZ2VyIGZvciB0aGUgc2FtZSBlbGVtZW50LlxuICAgICAgfVxuXG4gICAgICB2YXJzLm9uS2lsbCAmJiB2YXJzLm9uS2lsbChzZWxmKTtcbiAgICB9O1xuXG4gICAgX3RyaWdnZXJzLnB1c2goc2VsZik7XG5cbiAgICBzZWxmLmVuYWJsZShmYWxzZSwgZmFsc2UpO1xuICAgIGN1c3RvbVJldmVydFJldHVybiAmJiBjdXN0b21SZXZlcnRSZXR1cm4oc2VsZik7XG5cbiAgICBpZiAoYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5hZGQgJiYgIWNoYW5nZSkge1xuICAgICAgLy8gaWYgdGhlIGFuaW1hdGlvbiBpcyBhIHRpbWVsaW5lLCBpdCBtYXkgbm90IGhhdmUgYmVlbiBwb3B1bGF0ZWQgeWV0LCBzbyBpdCB3b3VsZG4ndCByZW5kZXIgYXQgdGhlIHByb3BlciBwbGFjZSBvbiB0aGUgZmlyc3QgcmVmcmVzaCgpLCB0aHVzIHdlIHNob3VsZCBzY2hlZHVsZSBvbmUgZm9yIHRoZSBuZXh0IHRpY2suIElmIFwiY2hhbmdlXCIgaXMgZGVmaW5lZCwgd2Uga25vdyBpdCBtdXN0IGJlIHJlLWVuYWJsaW5nLCB0aHVzIHdlIGNhbiByZWZyZXNoKCkgcmlnaHQgYXdheS5cbiAgICAgIHZhciB1cGRhdGVGdW5jID0gc2VsZi51cGRhdGU7IC8vIHNvbWUgYnJvd3NlcnMgbWF5IGZpcmUgYSBzY3JvbGwgZXZlbnQgQkVGT1JFIGEgdGljayBlbGFwc2VzIGFuZC9vciB0aGUgRE9NQ29udGVudExvYWRlZCBmaXJlcy4gU28gdGhlcmUncyBhIGNoYW5jZSB1cGRhdGUoKSB3aWxsIGJlIGNhbGxlZCBCRUZPUkUgYSByZWZyZXNoKCkgaGFzIGhhcHBlbmVkIG9uIGEgVGltZWxpbmUtYXR0YWNoZWQgU2Nyb2xsVHJpZ2dlciB3aGljaCBtZWFucyB0aGUgc3RhcnQvZW5kIHdvbid0IGJlIGNhbGN1bGF0ZWQgeWV0LiBXZSBkb24ndCB3YW50IHRvIGFkZCBjb25kaXRpb25hbCBsb2dpYyBpbnNpZGUgdGhlIHVwZGF0ZSgpIG1ldGhvZCAobGlrZSBjaGVjayB0byBzZWUgaWYgZW5kIGlzIGRlZmluZWQgYW5kIGlmIG5vdCwgZm9yY2UgYSByZWZyZXNoKCkpIGJlY2F1c2UgdGhhdCdzIGEgZnVuY3Rpb24gdGhhdCBnZXRzIGhpdCBhIExPVCAocGVyZm9ybWFuY2UpLiBTbyB3ZSBzd2FwIG91dCB0aGUgcmVhbCB1cGRhdGUoKSBtZXRob2QgZm9yIHRoaXMgb25lIHRoYXQnbGwgcmUtYXR0YWNoIGl0IHRoZSBmaXJzdCB0aW1lIGl0IGdldHMgY2FsbGVkIGFuZCBvZiBjb3Vyc2UgZm9yY2VzIGEgcmVmcmVzaCgpLlxuXG4gICAgICBzZWxmLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi51cGRhdGUgPSB1cGRhdGVGdW5jO1xuICAgICAgICBzdGFydCB8fCBlbmQgfHwgc2VsZi5yZWZyZXNoKCk7XG4gICAgICB9O1xuXG4gICAgICBnc2FwLmRlbGF5ZWRDYWxsKDAuMDEsIHNlbGYudXBkYXRlKTtcbiAgICAgIGNoYW5nZSA9IDAuMDE7XG4gICAgICBzdGFydCA9IGVuZCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYucmVmcmVzaCgpO1xuICAgIH1cblxuICAgIHBpbiAmJiBfcXVldWVSZWZyZXNoQWxsKCk7IC8vIHBpbm5pbmcgY291bGQgYWZmZWN0IHRoZSBwb3NpdGlvbnMgb2Ygb3RoZXIgdGhpbmdzLCBzbyBtYWtlIHN1cmUgd2UgcXVldWUgYSBmdWxsIHJlZnJlc2goKVxuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3Rlcihjb3JlKSB7XG4gICAgaWYgKCFfY29yZUluaXR0ZWQpIHtcbiAgICAgIGdzYXAgPSBjb3JlIHx8IF9nZXRHU0FQKCk7XG4gICAgICBfd2luZG93RXhpc3RzKCkgJiYgd2luZG93LmRvY3VtZW50ICYmIFNjcm9sbFRyaWdnZXIuZW5hYmxlKCk7XG4gICAgICBfY29yZUluaXR0ZWQgPSBfZW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gX2NvcmVJbml0dGVkO1xuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuZGVmYXVsdHMgPSBmdW5jdGlvbiBkZWZhdWx0cyhjb25maWcpIHtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGNvbmZpZykge1xuICAgICAgICBfZGVmYXVsdHNbcF0gPSBjb25maWdbcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9kZWZhdWx0cztcbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKHJlc2V0LCBraWxsKSB7XG4gICAgX2VuYWJsZWQgPSAwO1xuXG4gICAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyaWdnZXIpIHtcbiAgICAgIHJldHVybiB0cmlnZ2VyW2tpbGwgPyBcImtpbGxcIiA6IFwiZGlzYWJsZVwiXShyZXNldCk7XG4gICAgfSk7XG5cbiAgICBfcmVtb3ZlTGlzdGVuZXIoX3dpbiwgXCJ3aGVlbFwiLCBfb25TY3JvbGwpO1xuXG4gICAgX3JlbW92ZUxpc3RlbmVyKF9kb2MsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG5cbiAgICBjbGVhckludGVydmFsKF9zeW5jSW50ZXJ2YWwpO1xuXG4gICAgX3JlbW92ZUxpc3RlbmVyKF9kb2MsIFwidG91Y2hjYW5jZWxcIiwgX3Bhc3NUaHJvdWdoKTtcblxuICAgIF9yZW1vdmVMaXN0ZW5lcihfYm9keSwgXCJ0b3VjaHN0YXJ0XCIsIF9wYXNzVGhyb3VnaCk7XG5cbiAgICBfbXVsdGlMaXN0ZW5lcihfcmVtb3ZlTGlzdGVuZXIsIF9kb2MsIFwicG9pbnRlcmRvd24sdG91Y2hzdGFydCxtb3VzZWRvd25cIiwgX3BvaW50ZXJEb3duSGFuZGxlcik7XG5cbiAgICBfbXVsdGlMaXN0ZW5lcihfcmVtb3ZlTGlzdGVuZXIsIF9kb2MsIFwicG9pbnRlcnVwLHRvdWNoZW5kLG1vdXNldXBcIiwgX3BvaW50ZXJVcEhhbmRsZXIpO1xuXG4gICAgX3Jlc2l6ZURlbGF5LmtpbGwoKTtcblxuICAgIF9pdGVyYXRlQXV0b1JlZnJlc2goX3JlbW92ZUxpc3RlbmVyKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3Njcm9sbGVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgX3doZWVsTGlzdGVuZXIoX3JlbW92ZUxpc3RlbmVyLCBfc2Nyb2xsZXJzW2ldLCBfc2Nyb2xsZXJzW2kgKyAxXSk7XG5cbiAgICAgIF93aGVlbExpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX3Njcm9sbGVyc1tpXSwgX3Njcm9sbGVyc1tpICsgMl0pO1xuICAgIH1cbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICBfd2luID0gd2luZG93O1xuICAgIF9kb2MgPSBkb2N1bWVudDtcbiAgICBfZG9jRWwgPSBfZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICBfYm9keSA9IF9kb2MuYm9keTtcblxuICAgIGlmIChnc2FwKSB7XG4gICAgICBfdG9BcnJheSA9IGdzYXAudXRpbHMudG9BcnJheTtcbiAgICAgIF9jbGFtcCA9IGdzYXAudXRpbHMuY2xhbXA7XG4gICAgICBfY29udGV4dCA9IGdzYXAuY29yZS5jb250ZXh0IHx8IF9wYXNzVGhyb3VnaDtcbiAgICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMgPSBnc2FwLmNvcmUuc3VwcHJlc3NPdmVyd3JpdGVzIHx8IF9wYXNzVGhyb3VnaDtcbiAgICAgIF9zY3JvbGxSZXN0b3JhdGlvbiA9IF93aW4uaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiB8fCBcImF1dG9cIjtcbiAgICAgIF9sYXN0U2Nyb2xsID0gX3dpbi5wYWdlWU9mZnNldDtcbiAgICAgIGdzYXAuY29yZS5nbG9iYWxzKFwiU2Nyb2xsVHJpZ2dlclwiLCBTY3JvbGxUcmlnZ2VyKTsgLy8gbXVzdCByZWdpc3RlciB0aGUgZ2xvYmFsIG1hbnVhbGx5IGJlY2F1c2UgaW4gSW50ZXJuZXQgRXhwbG9yZXIsIGZ1bmN0aW9ucyAoY2xhc3NlcykgZG9uJ3QgaGF2ZSBhIFwibmFtZVwiIHByb3BlcnR5LlxuXG4gICAgICBpZiAoX2JvZHkpIHtcbiAgICAgICAgX2VuYWJsZWQgPSAxO1xuICAgICAgICBfZGl2MTAwdmggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpOyAvLyB0byBzb2x2ZSBtb2JpbGUgYnJvd3NlciBhZGRyZXNzIGJhciBzaG93L2hpZGUgcmVzaXppbmcsIHdlIHNob3VsZG4ndCByZWx5IG9uIHdpbmRvdy5pbm5lckhlaWdodC4gSW5zdGVhZCwgdXNlIGEgPGRpdj4gd2l0aCBpdHMgaGVpZ2h0IHNldCB0byAxMDB2aCBhbmQgbWVhc3VyZSB0aGF0IHNpbmNlIHRoYXQncyB3aGF0IHRoZSBzY3JvbGxpbmcgaXMgYmFzZWQgb24gYW55d2F5IGFuZCBpdCdzIG5vdCBhZmZlY3RlZCBieSBhZGRyZXNzIGJhciBzaG93aW5nL2hpZGluZy5cblxuICAgICAgICBfZGl2MTAwdmguc3R5bGUuaGVpZ2h0ID0gXCIxMDB2aFwiO1xuICAgICAgICBfZGl2MTAwdmguc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cbiAgICAgICAgX3JlZnJlc2gxMDB2aCgpO1xuXG4gICAgICAgIF9yYWZCdWdGaXgoKTtcblxuICAgICAgICBPYnNlcnZlci5yZWdpc3Rlcihnc2FwKTsgLy8gaXNUb3VjaCBpcyAwIGlmIG5vIHRvdWNoLCAxIGlmIE9OTFkgdG91Y2gsIGFuZCAyIGlmIGl0IGNhbiBhY2NvbW1vZGF0ZSB0b3VjaCBidXQgYWxzbyBvdGhlciB0eXBlcyBsaWtlIG1vdXNlL3BvaW50ZXIuXG5cbiAgICAgICAgU2Nyb2xsVHJpZ2dlci5pc1RvdWNoID0gT2JzZXJ2ZXIuaXNUb3VjaDtcbiAgICAgICAgX2ZpeElPU0J1ZyA9IE9ic2VydmVyLmlzVG91Y2ggJiYgLyhpUGFkfGlQaG9uZXxpUG9kfE1hYykvZy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyBzaW5jZSAyMDE3LCBpT1MgaGFzIGhhZCBhIGJ1ZyB0aGF0IGNhdXNlcyBldmVudC5jbGllbnRYL1kgdG8gYmUgaW5hY2N1cmF0ZSB3aGVuIGEgc2Nyb2xsIG9jY3VycywgdGh1cyB3ZSBtdXN0IGFsdGVybmF0ZSBpZ25vcmluZyBldmVyeSBvdGhlciB0b3VjaG1vdmUgZXZlbnQgdG8gd29yayBhcm91bmQgaXQuIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTgxOTU0IGFuZCBodHRwczovL2NvZGVwZW4uaW8vR3JlZW5Tb2NrL3Blbi9FeGJyUE5hLzA4N2NlZjE5N2RjMzU0NDVhMDk1MWU4OTM1YzQxNTAzXG5cbiAgICAgICAgX2lnbm9yZU1vYmlsZVJlc2l6ZSA9IE9ic2VydmVyLmlzVG91Y2ggPT09IDE7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKF93aW4sIFwid2hlZWxcIiwgX29uU2Nyb2xsKTsgLy8gbW9zdGx5IGZvciAzcmQgcGFydHkgc21vb3RoIHNjcm9sbGluZyBsaWJyYXJpZXMuXG5cblxuICAgICAgICBfcm9vdCA9IFtfd2luLCBfZG9jLCBfZG9jRWwsIF9ib2R5XTtcblxuICAgICAgICBpZiAoZ3NhcC5tYXRjaE1lZGlhKSB7XG4gICAgICAgICAgU2Nyb2xsVHJpZ2dlci5tYXRjaE1lZGlhID0gZnVuY3Rpb24gKHZhcnMpIHtcbiAgICAgICAgICAgIHZhciBtbSA9IGdzYXAubWF0Y2hNZWRpYSgpLFxuICAgICAgICAgICAgICAgIHA7XG5cbiAgICAgICAgICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICAgICAgICAgIG1tLmFkZChwLCB2YXJzW3BdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1tO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBnc2FwLmFkZEV2ZW50TGlzdGVuZXIoXCJtYXRjaE1lZGlhSW5pdFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JldmVydEFsbCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGdzYXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1hdGNoTWVkaWFSZXZlcnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZXZlcnRSZWNvcmRlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGdzYXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1hdGNoTWVkaWFcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3JlZnJlc2hBbGwoMCwgMSk7XG5cbiAgICAgICAgICAgIF9kaXNwYXRjaChcIm1hdGNoTWVkaWFcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZ3NhcC5tYXRjaE1lZGlhKFwiKG9yaWVudGF0aW9uOiBwb3J0cmFpdClcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gd2hlbiBvcmllbnRhdGlvbiBjaGFuZ2VzLCB3ZSBzaG91bGQgdGFrZSBuZXcgYmFzZSBtZWFzdXJlbWVudHMgZm9yIHRoZSBpZ25vcmVNb2JpbGVSZXNpemUgZmVhdHVyZS5cbiAgICAgICAgICAgIF9zZXRCYXNlRGltZW5zaW9ucygpO1xuXG4gICAgICAgICAgICByZXR1cm4gX3NldEJhc2VEaW1lbnNpb25zO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlJlcXVpcmVzIEdTQVAgMy4xMS4wIG9yIGxhdGVyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3NldEJhc2VEaW1lbnNpb25zKCk7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKF9kb2MsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7IC8vIHNvbWUgYnJvd3NlcnMgKGxpa2UgQ2hyb21lKSwgdGhlIHdpbmRvdyBzdG9wcyBkaXNwYXRjaGluZyBzY3JvbGwgZXZlbnRzIG9uIHRoZSB3aW5kb3cgaWYgeW91IHNjcm9sbCByZWFsbHkgZmFzdCwgYnV0IGl0J3MgY29uc2lzdGVudCBvbiB0aGUgZG9jdW1lbnQhXG5cblxuICAgICAgICB2YXIgYm9keVN0eWxlID0gX2JvZHkuc3R5bGUsXG4gICAgICAgICAgICBib3JkZXIgPSBib2R5U3R5bGUuYm9yZGVyVG9wU3R5bGUsXG4gICAgICAgICAgICBBbmltYXRpb25Qcm90byA9IGdzYXAuY29yZS5BbmltYXRpb24ucHJvdG90eXBlLFxuICAgICAgICAgICAgYm91bmRzLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgQW5pbWF0aW9uUHJvdG8ucmV2ZXJ0IHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRpb25Qcm90bywgXCJyZXZlcnRcIiwge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbWUoLTAuMDEsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IChBbmltYXRpb24ucmV2ZXJ0KCkgd2FzIGFkZGVkIGFmdGVyIDMuMTAuNClcblxuICAgICAgICBib2R5U3R5bGUuYm9yZGVyVG9wU3R5bGUgPSBcInNvbGlkXCI7IC8vIHdvcmtzIGFyb3VuZCBhbiBpc3N1ZSB3aGVyZSBhIG1hcmdpbiBvZiBhIGNoaWxkIGVsZW1lbnQgY291bGQgdGhyb3cgb2ZmIHRoZSBib3VuZHMgb2YgdGhlIF9ib2R5LCBtYWtpbmcgaXQgc2VlbSBsaWtlIHRoZXJlJ3MgYSBtYXJnaW4gd2hlbiB0aGVyZSBhY3R1YWxseSBpc24ndC4gVGhlIGJvcmRlciBlbnN1cmVzIHRoYXQgdGhlIGJvdW5kcyBhcmUgYWNjdXJhdGUuXG5cbiAgICAgICAgYm91bmRzID0gX2dldEJvdW5kcyhfYm9keSk7XG4gICAgICAgIF92ZXJ0aWNhbC5tID0gTWF0aC5yb3VuZChib3VuZHMudG9wICsgX3ZlcnRpY2FsLnNjKCkpIHx8IDA7IC8vIGFjY29tbW9kYXRlIHRoZSBvZmZzZXQgb2YgdGhlIDxib2R5PiBjYXVzZWQgYnkgbWFyZ2lucyBhbmQvb3IgcGFkZGluZ1xuXG4gICAgICAgIF9ob3Jpem9udGFsLm0gPSBNYXRoLnJvdW5kKGJvdW5kcy5sZWZ0ICsgX2hvcml6b250YWwuc2MoKSkgfHwgMDtcbiAgICAgICAgYm9yZGVyID8gYm9keVN0eWxlLmJvcmRlclRvcFN0eWxlID0gYm9yZGVyIDogYm9keVN0eWxlLnJlbW92ZVByb3BlcnR5KFwiYm9yZGVyLXRvcC1zdHlsZVwiKTsgLy8gVE9ETzogKD8pIG1heWJlIG1vdmUgdG8gbGV2ZXJhZ2luZyB0aGUgdmVsb2NpdHkgbWVjaGFuaXNtIGluIE9ic2VydmVyIGFuZCBza2lwIGludGVydmFscy5cblxuICAgICAgICBfc3luY0ludGVydmFsID0gc2V0SW50ZXJ2YWwoX3N5bmMsIDI1MCk7XG4gICAgICAgIGdzYXAuZGVsYXllZENhbGwoMC41LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF9zdGFydHVwID0gMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKF9kb2MsIFwidG91Y2hjYW5jZWxcIiwgX3Bhc3NUaHJvdWdoKTsgLy8gc29tZSBvbGRlciBBbmRyb2lkIGRldmljZXMgaW50ZXJtaXR0ZW50bHkgc3RvcCBkaXNwYXRjaGluZyBcInRvdWNobW92ZVwiIGV2ZW50cyBpZiB3ZSBkb24ndCBsaXN0ZW4gZm9yIFwidG91Y2hjYW5jZWxcIiBvbiB0aGUgZG9jdW1lbnQuXG5cblxuICAgICAgICBfYWRkTGlzdGVuZXIoX2JvZHksIFwidG91Y2hzdGFydFwiLCBfcGFzc1Rocm91Z2gpOyAvL3dvcmtzIGFyb3VuZCBTYWZhcmkgYnVnOiBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8yMTQ1MC1kcmFnZ2FibGUtaW4taWZyYW1lLW9uLW1vYmlsZS1pcy1idWdneS9cblxuXG4gICAgICAgIF9tdWx0aUxpc3RlbmVyKF9hZGRMaXN0ZW5lciwgX2RvYywgXCJwb2ludGVyZG93bix0b3VjaHN0YXJ0LG1vdXNlZG93blwiLCBfcG9pbnRlckRvd25IYW5kbGVyKTtcblxuICAgICAgICBfbXVsdGlMaXN0ZW5lcihfYWRkTGlzdGVuZXIsIF9kb2MsIFwicG9pbnRlcnVwLHRvdWNoZW5kLG1vdXNldXBcIiwgX3BvaW50ZXJVcEhhbmRsZXIpO1xuXG4gICAgICAgIF90cmFuc2Zvcm1Qcm9wID0gZ3NhcC51dGlscy5jaGVja1ByZWZpeChcInRyYW5zZm9ybVwiKTtcblxuICAgICAgICBfc3RhdGVQcm9wcy5wdXNoKF90cmFuc2Zvcm1Qcm9wKTtcblxuICAgICAgICBfY29yZUluaXR0ZWQgPSBfZ2V0VGltZSgpO1xuICAgICAgICBfcmVzaXplRGVsYXkgPSBnc2FwLmRlbGF5ZWRDYWxsKDAuMiwgX3JlZnJlc2hBbGwpLnBhdXNlKCk7XG4gICAgICAgIF9hdXRvUmVmcmVzaCA9IFtfZG9jLCBcInZpc2liaWxpdHljaGFuZ2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB3ID0gX3dpbi5pbm5lcldpZHRoLFxuICAgICAgICAgICAgICBoID0gX3dpbi5pbm5lckhlaWdodDtcblxuICAgICAgICAgIGlmIChfZG9jLmhpZGRlbikge1xuICAgICAgICAgICAgX3ByZXZXaWR0aCA9IHc7XG4gICAgICAgICAgICBfcHJldkhlaWdodCA9IGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChfcHJldldpZHRoICE9PSB3IHx8IF9wcmV2SGVpZ2h0ICE9PSBoKSB7XG4gICAgICAgICAgICBfb25SZXNpemUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9kb2MsIFwiRE9NQ29udGVudExvYWRlZFwiLCBfcmVmcmVzaEFsbCwgX3dpbiwgXCJsb2FkXCIsIF9yZWZyZXNoQWxsLCBfd2luLCBcInJlc2l6ZVwiLCBfb25SZXNpemVdO1xuXG4gICAgICAgIF9pdGVyYXRlQXV0b1JlZnJlc2goX2FkZExpc3RlbmVyKTtcblxuICAgICAgICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJpZ2dlcikge1xuICAgICAgICAgIHJldHVybiB0cmlnZ2VyLmVuYWJsZSgwLCAxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IF9zY3JvbGxlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICBfd2hlZWxMaXN0ZW5lcihfcmVtb3ZlTGlzdGVuZXIsIF9zY3JvbGxlcnNbaV0sIF9zY3JvbGxlcnNbaSArIDFdKTtcblxuICAgICAgICAgIF93aGVlbExpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX3Njcm9sbGVyc1tpXSwgX3Njcm9sbGVyc1tpICsgMl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuY29uZmlnID0gZnVuY3Rpb24gY29uZmlnKHZhcnMpIHtcbiAgICBcImxpbWl0Q2FsbGJhY2tzXCIgaW4gdmFycyAmJiAoX2xpbWl0Q2FsbGJhY2tzID0gISF2YXJzLmxpbWl0Q2FsbGJhY2tzKTtcbiAgICB2YXIgbXMgPSB2YXJzLnN5bmNJbnRlcnZhbDtcbiAgICBtcyAmJiBjbGVhckludGVydmFsKF9zeW5jSW50ZXJ2YWwpIHx8IChfc3luY0ludGVydmFsID0gbXMpICYmIHNldEludGVydmFsKF9zeW5jLCBtcyk7XG4gICAgXCJpZ25vcmVNb2JpbGVSZXNpemVcIiBpbiB2YXJzICYmIChfaWdub3JlTW9iaWxlUmVzaXplID0gU2Nyb2xsVHJpZ2dlci5pc1RvdWNoID09PSAxICYmIHZhcnMuaWdub3JlTW9iaWxlUmVzaXplKTtcblxuICAgIGlmIChcImF1dG9SZWZyZXNoRXZlbnRzXCIgaW4gdmFycykge1xuICAgICAgX2l0ZXJhdGVBdXRvUmVmcmVzaChfcmVtb3ZlTGlzdGVuZXIpIHx8IF9pdGVyYXRlQXV0b1JlZnJlc2goX2FkZExpc3RlbmVyLCB2YXJzLmF1dG9SZWZyZXNoRXZlbnRzIHx8IFwibm9uZVwiKTtcbiAgICAgIF9pZ25vcmVSZXNpemUgPSAodmFycy5hdXRvUmVmcmVzaEV2ZW50cyArIFwiXCIpLmluZGV4T2YoXCJyZXNpemVcIikgPT09IC0xO1xuICAgIH1cbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLnNjcm9sbGVyUHJveHkgPSBmdW5jdGlvbiBzY3JvbGxlclByb3h5KHRhcmdldCwgdmFycykge1xuICAgIHZhciB0ID0gX2dldFRhcmdldCh0YXJnZXQpLFxuICAgICAgICBpID0gX3Njcm9sbGVycy5pbmRleE9mKHQpLFxuICAgICAgICBpc1ZpZXdwb3J0ID0gX2lzVmlld3BvcnQodCk7XG5cbiAgICBpZiAofmkpIHtcbiAgICAgIF9zY3JvbGxlcnMuc3BsaWNlKGksIGlzVmlld3BvcnQgPyA2IDogMik7XG4gICAgfVxuXG4gICAgaWYgKHZhcnMpIHtcbiAgICAgIGlzVmlld3BvcnQgPyBfcHJveGllcy51bnNoaWZ0KF93aW4sIHZhcnMsIF9ib2R5LCB2YXJzLCBfZG9jRWwsIHZhcnMpIDogX3Byb3hpZXMudW5zaGlmdCh0LCB2YXJzKTtcbiAgICB9XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5jbGVhck1hdGNoTWVkaWEgPSBmdW5jdGlvbiBjbGVhck1hdGNoTWVkaWEocXVlcnkpIHtcbiAgICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQuX2N0eCAmJiB0Ll9jdHgucXVlcnkgPT09IHF1ZXJ5ICYmIHQuX2N0eC5raWxsKHRydWUsIHRydWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuaXNJblZpZXdwb3J0ID0gZnVuY3Rpb24gaXNJblZpZXdwb3J0KGVsZW1lbnQsIHJhdGlvLCBob3Jpem9udGFsKSB7XG4gICAgdmFyIGJvdW5kcyA9IChfaXNTdHJpbmcoZWxlbWVudCkgPyBfZ2V0VGFyZ2V0KGVsZW1lbnQpIDogZWxlbWVudCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIG9mZnNldCA9IGJvdW5kc1tob3Jpem9udGFsID8gX3dpZHRoIDogX2hlaWdodF0gKiByYXRpbyB8fCAwO1xuICAgIHJldHVybiBob3Jpem9udGFsID8gYm91bmRzLnJpZ2h0IC0gb2Zmc2V0ID4gMCAmJiBib3VuZHMubGVmdCArIG9mZnNldCA8IF93aW4uaW5uZXJXaWR0aCA6IGJvdW5kcy5ib3R0b20gLSBvZmZzZXQgPiAwICYmIGJvdW5kcy50b3AgKyBvZmZzZXQgPCBfd2luLmlubmVySGVpZ2h0O1xuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIucG9zaXRpb25JblZpZXdwb3J0ID0gZnVuY3Rpb24gcG9zaXRpb25JblZpZXdwb3J0KGVsZW1lbnQsIHJlZmVyZW5jZVBvaW50LCBob3Jpem9udGFsKSB7XG4gICAgX2lzU3RyaW5nKGVsZW1lbnQpICYmIChlbGVtZW50ID0gX2dldFRhcmdldChlbGVtZW50KSk7XG4gICAgdmFyIGJvdW5kcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIHNpemUgPSBib3VuZHNbaG9yaXpvbnRhbCA/IF93aWR0aCA6IF9oZWlnaHRdLFxuICAgICAgICBvZmZzZXQgPSByZWZlcmVuY2VQb2ludCA9PSBudWxsID8gc2l6ZSAvIDIgOiByZWZlcmVuY2VQb2ludCBpbiBfa2V5d29yZHMgPyBfa2V5d29yZHNbcmVmZXJlbmNlUG9pbnRdICogc2l6ZSA6IH5yZWZlcmVuY2VQb2ludC5pbmRleE9mKFwiJVwiKSA/IHBhcnNlRmxvYXQocmVmZXJlbmNlUG9pbnQpICogc2l6ZSAvIDEwMCA6IHBhcnNlRmxvYXQocmVmZXJlbmNlUG9pbnQpIHx8IDA7XG4gICAgcmV0dXJuIGhvcml6b250YWwgPyAoYm91bmRzLmxlZnQgKyBvZmZzZXQpIC8gX3dpbi5pbm5lcldpZHRoIDogKGJvdW5kcy50b3AgKyBvZmZzZXQpIC8gX3dpbi5pbm5lckhlaWdodDtcbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLmtpbGxBbGwgPSBmdW5jdGlvbiBraWxsQWxsKGFsbG93TGlzdGVuZXJzKSB7XG4gICAgX3RyaWdnZXJzLnNsaWNlKDApLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0LnZhcnMuaWQgIT09IFwiU2Nyb2xsU21vb3RoZXJcIiAmJiB0LmtpbGwoKTtcbiAgICB9KTtcblxuICAgIGlmIChhbGxvd0xpc3RlbmVycyAhPT0gdHJ1ZSkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IF9saXN0ZW5lcnMua2lsbEFsbCB8fCBbXTtcbiAgICAgIF9saXN0ZW5lcnMgPSB7fTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNjcm9sbFRyaWdnZXI7XG59KCk7XG5TY3JvbGxUcmlnZ2VyLnZlcnNpb24gPSBcIjMuMTIuNVwiO1xuXG5TY3JvbGxUcmlnZ2VyLnNhdmVTdHlsZXMgPSBmdW5jdGlvbiAodGFyZ2V0cykge1xuICByZXR1cm4gdGFyZ2V0cyA/IF90b0FycmF5KHRhcmdldHMpLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIC8vIHNhdmVkIHN0eWxlcyBhcmUgcmVjb3JkZWQgaW4gYSBjb25zZWN1dGl2ZSBhbHRlcm5hdGluZyBBcnJheSwgbGlrZSBbZWxlbWVudCwgY3NzVGV4dCwgdHJhbnNmb3JtIGF0dHJpYnV0ZSwgY2FjaGUsIG1hdGNoTWVkaWEsIC4uLl1cbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5zdHlsZSkge1xuICAgICAgdmFyIGkgPSBfc2F2ZWRTdHlsZXMuaW5kZXhPZih0YXJnZXQpO1xuXG4gICAgICBpID49IDAgJiYgX3NhdmVkU3R5bGVzLnNwbGljZShpLCA1KTtcblxuICAgICAgX3NhdmVkU3R5bGVzLnB1c2godGFyZ2V0LCB0YXJnZXQuc3R5bGUuY3NzVGV4dCwgdGFyZ2V0LmdldEJCb3ggJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKSwgZ3NhcC5jb3JlLmdldENhY2hlKHRhcmdldCksIF9jb250ZXh0KCkpO1xuICAgIH1cbiAgfSkgOiBfc2F2ZWRTdHlsZXM7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLnJldmVydCA9IGZ1bmN0aW9uIChzb2Z0LCBtZWRpYSkge1xuICByZXR1cm4gX3JldmVydEFsbCghc29mdCwgbWVkaWEpO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5jcmVhdGUgPSBmdW5jdGlvbiAodmFycywgYW5pbWF0aW9uKSB7XG4gIHJldHVybiBuZXcgU2Nyb2xsVHJpZ2dlcih2YXJzLCBhbmltYXRpb24pO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5yZWZyZXNoID0gZnVuY3Rpb24gKHNhZmUpIHtcbiAgcmV0dXJuIHNhZmUgPyBfb25SZXNpemUoKSA6IChfY29yZUluaXR0ZWQgfHwgU2Nyb2xsVHJpZ2dlci5yZWdpc3RlcigpKSAmJiBfcmVmcmVzaEFsbCh0cnVlKTtcbn07XG5cblNjcm9sbFRyaWdnZXIudXBkYXRlID0gZnVuY3Rpb24gKGZvcmNlKSB7XG4gIHJldHVybiArK19zY3JvbGxlcnMuY2FjaGUgJiYgX3VwZGF0ZUFsbChmb3JjZSA9PT0gdHJ1ZSA/IDIgOiAwKTtcbn07XG5cblNjcm9sbFRyaWdnZXIuY2xlYXJTY3JvbGxNZW1vcnkgPSBfY2xlYXJTY3JvbGxNZW1vcnk7XG5cblNjcm9sbFRyaWdnZXIubWF4U2Nyb2xsID0gZnVuY3Rpb24gKGVsZW1lbnQsIGhvcml6b250YWwpIHtcbiAgcmV0dXJuIF9tYXhTY3JvbGwoZWxlbWVudCwgaG9yaXpvbnRhbCA/IF9ob3Jpem9udGFsIDogX3ZlcnRpY2FsKTtcbn07XG5cblNjcm9sbFRyaWdnZXIuZ2V0U2Nyb2xsRnVuYyA9IGZ1bmN0aW9uIChlbGVtZW50LCBob3Jpem9udGFsKSB7XG4gIHJldHVybiBfZ2V0U2Nyb2xsRnVuYyhfZ2V0VGFyZ2V0KGVsZW1lbnQpLCBob3Jpem9udGFsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwpO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5nZXRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiBfaWRzW2lkXTtcbn07XG5cblNjcm9sbFRyaWdnZXIuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX3RyaWdnZXJzLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0LnZhcnMuaWQgIT09IFwiU2Nyb2xsU21vb3RoZXJcIjtcbiAgfSk7XG59OyAvLyBpdCdzIGNvbW1vbiBmb3IgcGVvcGxlIHRvIFNjcm9sbFRyaWdnZXIuZ2V0QWxsKHQgPT4gdC5raWxsKCkpIG9uIHBhZ2Ugcm91dGVzLCBmb3IgZXhhbXBsZSwgYW5kIHdlIGRvbid0IHdhbnQgaXQgdG8gcnVpbiBzbW9vdGggc2Nyb2xsaW5nIGJ5IGtpbGxpbmcgdGhlIG1haW4gU2Nyb2xsU21vb3RoZXIgb25lLlxuXG5cblNjcm9sbFRyaWdnZXIuaXNTY3JvbGxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIV9sYXN0U2Nyb2xsVGltZTtcbn07XG5cblNjcm9sbFRyaWdnZXIuc25hcERpcmVjdGlvbmFsID0gX3NuYXBEaXJlY3Rpb25hbDtcblxuU2Nyb2xsVHJpZ2dlci5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XG4gIHZhciBhID0gX2xpc3RlbmVyc1t0eXBlXSB8fCAoX2xpc3RlbmVyc1t0eXBlXSA9IFtdKTtcbiAgfmEuaW5kZXhPZihjYWxsYmFjaykgfHwgYS5wdXNoKGNhbGxiYWNrKTtcbn07XG5cblNjcm9sbFRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xuICB2YXIgYSA9IF9saXN0ZW5lcnNbdHlwZV0sXG4gICAgICBpID0gYSAmJiBhLmluZGV4T2YoY2FsbGJhY2spO1xuICBpID49IDAgJiYgYS5zcGxpY2UoaSwgMSk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLmJhdGNoID0gZnVuY3Rpb24gKHRhcmdldHMsIHZhcnMpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgdmFyc0NvcHkgPSB7fSxcbiAgICAgIGludGVydmFsID0gdmFycy5pbnRlcnZhbCB8fCAwLjAxNixcbiAgICAgIGJhdGNoTWF4ID0gdmFycy5iYXRjaE1heCB8fCAxZTksXG4gICAgICBwcm94eUNhbGxiYWNrID0gZnVuY3Rpb24gcHJveHlDYWxsYmFjayh0eXBlLCBjYWxsYmFjaykge1xuICAgIHZhciBlbGVtZW50cyA9IFtdLFxuICAgICAgICB0cmlnZ2VycyA9IFtdLFxuICAgICAgICBkZWxheSA9IGdzYXAuZGVsYXllZENhbGwoaW50ZXJ2YWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKGVsZW1lbnRzLCB0cmlnZ2Vycyk7XG4gICAgICBlbGVtZW50cyA9IFtdO1xuICAgICAgdHJpZ2dlcnMgPSBbXTtcbiAgICB9KS5wYXVzZSgpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc2VsZikge1xuICAgICAgZWxlbWVudHMubGVuZ3RoIHx8IGRlbGF5LnJlc3RhcnQodHJ1ZSk7XG4gICAgICBlbGVtZW50cy5wdXNoKHNlbGYudHJpZ2dlcik7XG4gICAgICB0cmlnZ2Vycy5wdXNoKHNlbGYpO1xuICAgICAgYmF0Y2hNYXggPD0gZWxlbWVudHMubGVuZ3RoICYmIGRlbGF5LnByb2dyZXNzKDEpO1xuICAgIH07XG4gIH0sXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiB2YXJzKSB7XG4gICAgdmFyc0NvcHlbcF0gPSBwLnN1YnN0cigwLCAyKSA9PT0gXCJvblwiICYmIF9pc0Z1bmN0aW9uKHZhcnNbcF0pICYmIHAgIT09IFwib25SZWZyZXNoSW5pdFwiID8gcHJveHlDYWxsYmFjayhwLCB2YXJzW3BdKSA6IHZhcnNbcF07XG4gIH1cblxuICBpZiAoX2lzRnVuY3Rpb24oYmF0Y2hNYXgpKSB7XG4gICAgYmF0Y2hNYXggPSBiYXRjaE1heCgpO1xuXG4gICAgX2FkZExpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwicmVmcmVzaFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYmF0Y2hNYXggPSB2YXJzLmJhdGNoTWF4KCk7XG4gICAgfSk7XG4gIH1cblxuICBfdG9BcnJheSh0YXJnZXRzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB2YXIgY29uZmlnID0ge307XG5cbiAgICBmb3IgKHAgaW4gdmFyc0NvcHkpIHtcbiAgICAgIGNvbmZpZ1twXSA9IHZhcnNDb3B5W3BdO1xuICAgIH1cblxuICAgIGNvbmZpZy50cmlnZ2VyID0gdGFyZ2V0O1xuICAgIHJlc3VsdC5wdXNoKFNjcm9sbFRyaWdnZXIuY3JlYXRlKGNvbmZpZykpO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTsgLy8gdG8gcmVkdWNlIGZpbGUgc2l6ZS4gY2xhbXBzIHRoZSBzY3JvbGwgYW5kIGFsc28gcmV0dXJucyBhIGR1cmF0aW9uIG11bHRpcGxpZXIgc28gdGhhdCBpZiB0aGUgc2Nyb2xsIGdldHMgY2hvcHBlZCBzaG9ydGVyLCB0aGUgZHVyYXRpb24gZ2V0cyBjdXJ0YWlsZWQgYXMgd2VsbCAob3RoZXJ3aXNlIGlmIHlvdSdyZSB2ZXJ5IGNsb3NlIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UsIGZvciBleGFtcGxlLCBhbmQgc3dpcGUgdXAgcmVhbGx5IGZhc3QsIGl0J2xsIHN1ZGRlbmx5IHNsb3cgZG93biBhbmQgdGFrZSBhIGxvbmcgdGltZSB0byByZWFjaCB0aGUgdG9wKS5cblxuXG52YXIgX2NsYW1wU2Nyb2xsQW5kR2V0RHVyYXRpb25NdWx0aXBsaWVyID0gZnVuY3Rpb24gX2NsYW1wU2Nyb2xsQW5kR2V0RHVyYXRpb25NdWx0aXBsaWVyKHNjcm9sbEZ1bmMsIGN1cnJlbnQsIGVuZCwgbWF4KSB7XG4gIGN1cnJlbnQgPiBtYXggPyBzY3JvbGxGdW5jKG1heCkgOiBjdXJyZW50IDwgMCAmJiBzY3JvbGxGdW5jKDApO1xuICByZXR1cm4gZW5kID4gbWF4ID8gKG1heCAtIGN1cnJlbnQpIC8gKGVuZCAtIGN1cnJlbnQpIDogZW5kIDwgMCA/IGN1cnJlbnQgLyAoY3VycmVudCAtIGVuZCkgOiAxO1xufSxcbiAgICBfYWxsb3dOYXRpdmVQYW5uaW5nID0gZnVuY3Rpb24gX2FsbG93TmF0aXZlUGFubmluZyh0YXJnZXQsIGRpcmVjdGlvbikge1xuICBpZiAoZGlyZWN0aW9uID09PSB0cnVlKSB7XG4gICAgdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwidG91Y2gtYWN0aW9uXCIpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC5zdHlsZS50b3VjaEFjdGlvbiA9IGRpcmVjdGlvbiA9PT0gdHJ1ZSA/IFwiYXV0b1wiIDogZGlyZWN0aW9uID8gXCJwYW4tXCIgKyBkaXJlY3Rpb24gKyAoT2JzZXJ2ZXIuaXNUb3VjaCA/IFwiIHBpbmNoLXpvb21cIiA6IFwiXCIpIDogXCJub25lXCI7IC8vIG5vdGU6IEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IGl0IHBpbmNoLXpvb20gcHJvcGVybHksIGF0IGxlYXN0IGluIGFkZGl0aW9uIHRvIGEgcGFuLXggb3IgcGFuLXkuXG4gIH1cblxuICB0YXJnZXQgPT09IF9kb2NFbCAmJiBfYWxsb3dOYXRpdmVQYW5uaW5nKF9ib2R5LCBkaXJlY3Rpb24pO1xufSxcbiAgICBfb3ZlcmZsb3cgPSB7XG4gIGF1dG86IDEsXG4gIHNjcm9sbDogMVxufSxcbiAgICBfbmVzdGVkU2Nyb2xsID0gZnVuY3Rpb24gX25lc3RlZFNjcm9sbChfcmVmNSkge1xuICB2YXIgZXZlbnQgPSBfcmVmNS5ldmVudCxcbiAgICAgIHRhcmdldCA9IF9yZWY1LnRhcmdldCxcbiAgICAgIGF4aXMgPSBfcmVmNS5heGlzO1xuXG4gIHZhciBub2RlID0gKGV2ZW50LmNoYW5nZWRUb3VjaGVzID8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldmVudCkudGFyZ2V0LFxuICAgICAgY2FjaGUgPSBub2RlLl9nc2FwIHx8IGdzYXAuY29yZS5nZXRDYWNoZShub2RlKSxcbiAgICAgIHRpbWUgPSBfZ2V0VGltZSgpLFxuICAgICAgY3M7XG5cbiAgaWYgKCFjYWNoZS5faXNTY3JvbGxUIHx8IHRpbWUgLSBjYWNoZS5faXNTY3JvbGxUID4gMjAwMCkge1xuICAgIC8vIGNhY2hlIGZvciAyIHNlY29uZHMgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSBfYm9keSAmJiAobm9kZS5zY3JvbGxIZWlnaHQgPD0gbm9kZS5jbGllbnRIZWlnaHQgJiYgbm9kZS5zY3JvbGxXaWR0aCA8PSBub2RlLmNsaWVudFdpZHRoIHx8ICEoX292ZXJmbG93WyhjcyA9IF9nZXRDb21wdXRlZFN0eWxlKG5vZGUpKS5vdmVyZmxvd1ldIHx8IF9vdmVyZmxvd1tjcy5vdmVyZmxvd1hdKSkpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgY2FjaGUuX2lzU2Nyb2xsID0gbm9kZSAmJiBub2RlICE9PSB0YXJnZXQgJiYgIV9pc1ZpZXdwb3J0KG5vZGUpICYmIChfb3ZlcmZsb3dbKGNzID0gX2dldENvbXB1dGVkU3R5bGUobm9kZSkpLm92ZXJmbG93WV0gfHwgX292ZXJmbG93W2NzLm92ZXJmbG93WF0pO1xuICAgIGNhY2hlLl9pc1Njcm9sbFQgPSB0aW1lO1xuICB9XG5cbiAgaWYgKGNhY2hlLl9pc1Njcm9sbCB8fCBheGlzID09PSBcInhcIikge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50Ll9nc2FwQWxsb3cgPSB0cnVlO1xuICB9XG59LFxuICAgIC8vIGNhcHR1cmUgZXZlbnRzIG9uIHNjcm9sbGFibGUgZWxlbWVudHMgSU5TSURFIHRoZSA8Ym9keT4gYW5kIGFsbG93IHRob3NlIGJ5IGNhbGxpbmcgc3RvcFByb3BhZ2F0aW9uKCkgd2hlbiB3ZSBmaW5kIGEgc2Nyb2xsYWJsZSBhbmNlc3RvclxuX2lucHV0T2JzZXJ2ZXIgPSBmdW5jdGlvbiBfaW5wdXRPYnNlcnZlcih0YXJnZXQsIHR5cGUsIGlucHV0cywgbmVzdGVkKSB7XG4gIHJldHVybiBPYnNlcnZlci5jcmVhdGUoe1xuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIGNhcHR1cmU6IHRydWUsXG4gICAgZGVib3VuY2U6IGZhbHNlLFxuICAgIGxvY2tBeGlzOiB0cnVlLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgb25XaGVlbDogbmVzdGVkID0gbmVzdGVkICYmIF9uZXN0ZWRTY3JvbGwsXG4gICAgb25QcmVzczogbmVzdGVkLFxuICAgIG9uRHJhZzogbmVzdGVkLFxuICAgIG9uU2Nyb2xsOiBuZXN0ZWQsXG4gICAgb25FbmFibGU6IGZ1bmN0aW9uIG9uRW5hYmxlKCkge1xuICAgICAgcmV0dXJuIGlucHV0cyAmJiBfYWRkTGlzdGVuZXIoX2RvYywgT2JzZXJ2ZXIuZXZlbnRUeXBlc1swXSwgX2NhcHR1cmVJbnB1dHMsIGZhbHNlLCB0cnVlKTtcbiAgICB9LFxuICAgIG9uRGlzYWJsZTogZnVuY3Rpb24gb25EaXNhYmxlKCkge1xuICAgICAgcmV0dXJuIF9yZW1vdmVMaXN0ZW5lcihfZG9jLCBPYnNlcnZlci5ldmVudFR5cGVzWzBdLCBfY2FwdHVyZUlucHV0cywgdHJ1ZSk7XG4gICAgfVxuICB9KTtcbn0sXG4gICAgX2lucHV0RXhwID0gLyhpbnB1dHxsYWJlbHxzZWxlY3R8dGV4dGFyZWEpL2ksXG4gICAgX2lucHV0SXNGb2N1c2VkLFxuICAgIF9jYXB0dXJlSW5wdXRzID0gZnVuY3Rpb24gX2NhcHR1cmVJbnB1dHMoZSkge1xuICB2YXIgaXNJbnB1dCA9IF9pbnB1dEV4cC50ZXN0KGUudGFyZ2V0LnRhZ05hbWUpO1xuXG4gIGlmIChpc0lucHV0IHx8IF9pbnB1dElzRm9jdXNlZCkge1xuICAgIGUuX2dzYXBBbGxvdyA9IHRydWU7XG4gICAgX2lucHV0SXNGb2N1c2VkID0gaXNJbnB1dDtcbiAgfVxufSxcbiAgICBfZ2V0U2Nyb2xsTm9ybWFsaXplciA9IGZ1bmN0aW9uIF9nZXRTY3JvbGxOb3JtYWxpemVyKHZhcnMpIHtcbiAgX2lzT2JqZWN0KHZhcnMpIHx8ICh2YXJzID0ge30pO1xuICB2YXJzLnByZXZlbnREZWZhdWx0ID0gdmFycy5pc05vcm1hbGl6ZXIgPSB2YXJzLmFsbG93Q2xpY2tzID0gdHJ1ZTtcbiAgdmFycy50eXBlIHx8ICh2YXJzLnR5cGUgPSBcIndoZWVsLHRvdWNoXCIpO1xuICB2YXJzLmRlYm91bmNlID0gISF2YXJzLmRlYm91bmNlO1xuICB2YXJzLmlkID0gdmFycy5pZCB8fCBcIm5vcm1hbGl6ZXJcIjtcblxuICB2YXIgX3ZhcnMyID0gdmFycyxcbiAgICAgIG5vcm1hbGl6ZVNjcm9sbFggPSBfdmFyczIubm9ybWFsaXplU2Nyb2xsWCxcbiAgICAgIG1vbWVudHVtID0gX3ZhcnMyLm1vbWVudHVtLFxuICAgICAgYWxsb3dOZXN0ZWRTY3JvbGwgPSBfdmFyczIuYWxsb3dOZXN0ZWRTY3JvbGwsXG4gICAgICBvblJlbGVhc2UgPSBfdmFyczIub25SZWxlYXNlLFxuICAgICAgc2VsZixcbiAgICAgIG1heFksXG4gICAgICB0YXJnZXQgPSBfZ2V0VGFyZ2V0KHZhcnMudGFyZ2V0KSB8fCBfZG9jRWwsXG4gICAgICBzbW9vdGhlciA9IGdzYXAuY29yZS5nbG9iYWxzKCkuU2Nyb2xsU21vb3RoZXIsXG4gICAgICBzbW9vdGhlckluc3RhbmNlID0gc21vb3RoZXIgJiYgc21vb3RoZXIuZ2V0KCksXG4gICAgICBjb250ZW50ID0gX2ZpeElPU0J1ZyAmJiAodmFycy5jb250ZW50ICYmIF9nZXRUYXJnZXQodmFycy5jb250ZW50KSB8fCBzbW9vdGhlckluc3RhbmNlICYmIHZhcnMuY29udGVudCAhPT0gZmFsc2UgJiYgIXNtb290aGVySW5zdGFuY2Uuc21vb3RoKCkgJiYgc21vb3RoZXJJbnN0YW5jZS5jb250ZW50KCkpLFxuICAgICAgc2Nyb2xsRnVuY1kgPSBfZ2V0U2Nyb2xsRnVuYyh0YXJnZXQsIF92ZXJ0aWNhbCksXG4gICAgICBzY3JvbGxGdW5jWCA9IF9nZXRTY3JvbGxGdW5jKHRhcmdldCwgX2hvcml6b250YWwpLFxuICAgICAgc2NhbGUgPSAxLFxuICAgICAgaW5pdGlhbFNjYWxlID0gKE9ic2VydmVyLmlzVG91Y2ggJiYgX3dpbi52aXN1YWxWaWV3cG9ydCA/IF93aW4udmlzdWFsVmlld3BvcnQuc2NhbGUgKiBfd2luLnZpc3VhbFZpZXdwb3J0LndpZHRoIDogX3dpbi5vdXRlcldpZHRoKSAvIF93aW4uaW5uZXJXaWR0aCxcbiAgICAgIHdoZWVsUmVmcmVzaCA9IDAsXG4gICAgICByZXNvbHZlTW9tZW50dW1EdXJhdGlvbiA9IF9pc0Z1bmN0aW9uKG1vbWVudHVtKSA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbW9tZW50dW0oc2VsZik7XG4gIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG1vbWVudHVtIHx8IDIuODtcbiAgfSxcbiAgICAgIGxhc3RSZWZyZXNoSUQsXG4gICAgICBza2lwVG91Y2hNb3ZlLFxuICAgICAgaW5wdXRPYnNlcnZlciA9IF9pbnB1dE9ic2VydmVyKHRhcmdldCwgdmFycy50eXBlLCB0cnVlLCBhbGxvd05lc3RlZFNjcm9sbCksXG4gICAgICByZXN1bWVUb3VjaE1vdmUgPSBmdW5jdGlvbiByZXN1bWVUb3VjaE1vdmUoKSB7XG4gICAgcmV0dXJuIHNraXBUb3VjaE1vdmUgPSBmYWxzZTtcbiAgfSxcbiAgICAgIHNjcm9sbENsYW1wWCA9IF9wYXNzVGhyb3VnaCxcbiAgICAgIHNjcm9sbENsYW1wWSA9IF9wYXNzVGhyb3VnaCxcbiAgICAgIHVwZGF0ZUNsYW1wcyA9IGZ1bmN0aW9uIHVwZGF0ZUNsYW1wcygpIHtcbiAgICBtYXhZID0gX21heFNjcm9sbCh0YXJnZXQsIF92ZXJ0aWNhbCk7XG4gICAgc2Nyb2xsQ2xhbXBZID0gX2NsYW1wKF9maXhJT1NCdWcgPyAxIDogMCwgbWF4WSk7XG4gICAgbm9ybWFsaXplU2Nyb2xsWCAmJiAoc2Nyb2xsQ2xhbXBYID0gX2NsYW1wKDAsIF9tYXhTY3JvbGwodGFyZ2V0LCBfaG9yaXpvbnRhbCkpKTtcbiAgICBsYXN0UmVmcmVzaElEID0gX3JlZnJlc2hJRDtcbiAgfSxcbiAgICAgIHJlbW92ZUNvbnRlbnRPZmZzZXQgPSBmdW5jdGlvbiByZW1vdmVDb250ZW50T2Zmc2V0KCkge1xuICAgIGNvbnRlbnQuX2dzYXAueSA9IF9yb3VuZChwYXJzZUZsb2F0KGNvbnRlbnQuX2dzYXAueSkgKyBzY3JvbGxGdW5jWS5vZmZzZXQpICsgXCJweFwiO1xuICAgIGNvbnRlbnQuc3R5bGUudHJhbnNmb3JtID0gXCJtYXRyaXgzZCgxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCBcIiArIHBhcnNlRmxvYXQoY29udGVudC5fZ3NhcC55KSArIFwiLCAwLCAxKVwiO1xuICAgIHNjcm9sbEZ1bmNZLm9mZnNldCA9IHNjcm9sbEZ1bmNZLmNhY2hlSUQgPSAwO1xuICB9LFxuICAgICAgaWdub3JlRHJhZyA9IGZ1bmN0aW9uIGlnbm9yZURyYWcoKSB7XG4gICAgaWYgKHNraXBUb3VjaE1vdmUpIHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZXN1bWVUb3VjaE1vdmUpO1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gX3JvdW5kKHNlbGYuZGVsdGFZIC8gMiksXG4gICAgICAgICAgc2Nyb2xsID0gc2Nyb2xsQ2xhbXBZKHNjcm9sbEZ1bmNZLnYgLSBvZmZzZXQpO1xuXG4gICAgICBpZiAoY29udGVudCAmJiBzY3JvbGwgIT09IHNjcm9sbEZ1bmNZLnYgKyBzY3JvbGxGdW5jWS5vZmZzZXQpIHtcbiAgICAgICAgc2Nyb2xsRnVuY1kub2Zmc2V0ID0gc2Nyb2xsIC0gc2Nyb2xsRnVuY1kudjtcblxuICAgICAgICB2YXIgeSA9IF9yb3VuZCgocGFyc2VGbG9hdChjb250ZW50ICYmIGNvbnRlbnQuX2dzYXAueSkgfHwgMCkgLSBzY3JvbGxGdW5jWS5vZmZzZXQpO1xuXG4gICAgICAgIGNvbnRlbnQuc3R5bGUudHJhbnNmb3JtID0gXCJtYXRyaXgzZCgxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCBcIiArIHkgKyBcIiwgMCwgMSlcIjtcbiAgICAgICAgY29udGVudC5fZ3NhcC55ID0geSArIFwicHhcIjtcbiAgICAgICAgc2Nyb2xsRnVuY1kuY2FjaGVJRCA9IF9zY3JvbGxlcnMuY2FjaGU7XG5cbiAgICAgICAgX3VwZGF0ZUFsbCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzY3JvbGxGdW5jWS5vZmZzZXQgJiYgcmVtb3ZlQ29udGVudE9mZnNldCgpO1xuICAgIHNraXBUb3VjaE1vdmUgPSB0cnVlO1xuICB9LFxuICAgICAgdHdlZW4sXG4gICAgICBzdGFydFNjcm9sbFgsXG4gICAgICBzdGFydFNjcm9sbFksXG4gICAgICBvblN0b3BEZWxheWVkQ2FsbCxcbiAgICAgIG9uUmVzaXplID0gZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gICAgLy8gaWYgdGhlIHdpbmRvdyByZXNpemVzLCBsaWtlIG9uIGFuIGlQaG9uZSB3aGljaCBBcHBsZSBGT1JDRVMgdGhlIGFkZHJlc3MgYmFyIHRvIHNob3cvaGlkZSBldmVuIGlmIHdlIGV2ZW50LnByZXZlbnREZWZhdWx0KCksIGl0IG1heSBiZSBzY3JvbGxpbmcgdG9vIGZhciBub3cgdGhhdCB0aGUgYWRkcmVzcyBiYXIgaXMgc2hvd2luZywgc28gd2UgbXVzdCBkeW5hbWljYWxseSBhZGp1c3QgdGhlIG1vbWVudHVtIHR3ZWVuLlxuICAgIHVwZGF0ZUNsYW1wcygpO1xuXG4gICAgaWYgKHR3ZWVuLmlzQWN0aXZlKCkgJiYgdHdlZW4udmFycy5zY3JvbGxZID4gbWF4WSkge1xuICAgICAgc2Nyb2xsRnVuY1koKSA+IG1heFkgPyB0d2Vlbi5wcm9ncmVzcygxKSAmJiBzY3JvbGxGdW5jWShtYXhZKSA6IHR3ZWVuLnJlc2V0VG8oXCJzY3JvbGxZXCIsIG1heFkpO1xuICAgIH1cbiAgfTtcblxuICBjb250ZW50ICYmIGdzYXAuc2V0KGNvbnRlbnQsIHtcbiAgICB5OiBcIis9MFwiXG4gIH0pOyAvLyB0byBlbnN1cmUgdGhlcmUncyBhIGNhY2hlIChlbGVtZW50Ll9nc2FwKVxuXG4gIHZhcnMuaWdub3JlQ2hlY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBfZml4SU9TQnVnICYmIGUudHlwZSA9PT0gXCJ0b3VjaG1vdmVcIiAmJiBpZ25vcmVEcmFnKGUpIHx8IHNjYWxlID4gMS4wNSAmJiBlLnR5cGUgIT09IFwidG91Y2hzdGFydFwiIHx8IHNlbGYuaXNHZXN0dXJpbmcgfHwgZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxO1xuICB9O1xuXG4gIHZhcnMub25QcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBza2lwVG91Y2hNb3ZlID0gZmFsc2U7XG4gICAgdmFyIHByZXZTY2FsZSA9IHNjYWxlO1xuICAgIHNjYWxlID0gX3JvdW5kKChfd2luLnZpc3VhbFZpZXdwb3J0ICYmIF93aW4udmlzdWFsVmlld3BvcnQuc2NhbGUgfHwgMSkgLyBpbml0aWFsU2NhbGUpO1xuICAgIHR3ZWVuLnBhdXNlKCk7XG4gICAgcHJldlNjYWxlICE9PSBzY2FsZSAmJiBfYWxsb3dOYXRpdmVQYW5uaW5nKHRhcmdldCwgc2NhbGUgPiAxLjAxID8gdHJ1ZSA6IG5vcm1hbGl6ZVNjcm9sbFggPyBmYWxzZSA6IFwieFwiKTtcbiAgICBzdGFydFNjcm9sbFggPSBzY3JvbGxGdW5jWCgpO1xuICAgIHN0YXJ0U2Nyb2xsWSA9IHNjcm9sbEZ1bmNZKCk7XG4gICAgdXBkYXRlQ2xhbXBzKCk7XG4gICAgbGFzdFJlZnJlc2hJRCA9IF9yZWZyZXNoSUQ7XG4gIH07XG5cbiAgdmFycy5vblJlbGVhc2UgPSB2YXJzLm9uR2VzdHVyZVN0YXJ0ID0gZnVuY3Rpb24gKHNlbGYsIHdhc0RyYWdnaW5nKSB7XG4gICAgc2Nyb2xsRnVuY1kub2Zmc2V0ICYmIHJlbW92ZUNvbnRlbnRPZmZzZXQoKTtcblxuICAgIGlmICghd2FzRHJhZ2dpbmcpIHtcbiAgICAgIG9uU3RvcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9zY3JvbGxlcnMuY2FjaGUrKzsgLy8gbWFrZSBzdXJlIHdlJ3JlIHB1bGxpbmcgdGhlIG5vbi1jYWNoZWQgdmFsdWVcbiAgICAgIC8vIGFsdGVybmF0ZSBhbGdvcml0aG06IGR1clggPSBNYXRoLm1pbig2LCBNYXRoLmFicyhzZWxmLnZlbG9jaXR5WCAvIDgwMCkpLFx0ZHVyID0gTWF0aC5tYXgoZHVyWCwgTWF0aC5taW4oNiwgTWF0aC5hYnMoc2VsZi52ZWxvY2l0eVkgLyA4MDApKSk7IGR1ciA9IGR1ciAqICgwLjQgKyAoMSAtIF9wb3dlcjRJbihkdXIgLyA2KSkgKiAwLjYpKSAqIChtb21lbnR1bVNwZWVkIHx8IDEpXG5cbiAgICAgIHZhciBkdXIgPSByZXNvbHZlTW9tZW50dW1EdXJhdGlvbigpLFxuICAgICAgICAgIGN1cnJlbnRTY3JvbGwsXG4gICAgICAgICAgZW5kU2Nyb2xsO1xuXG4gICAgICBpZiAobm9ybWFsaXplU2Nyb2xsWCkge1xuICAgICAgICBjdXJyZW50U2Nyb2xsID0gc2Nyb2xsRnVuY1goKTtcbiAgICAgICAgZW5kU2Nyb2xsID0gY3VycmVudFNjcm9sbCArIGR1ciAqIDAuMDUgKiAtc2VsZi52ZWxvY2l0eVggLyAwLjIyNzsgLy8gdGhlIGNvbnN0YW50IC4yMjcgaXMgZnJvbSBwb3dlcjQoMC4wNSkuIHZlbG9jaXR5IGlzIGludmVydGVkIGJlY2F1c2Ugc2Nyb2xsaW5nIGdvZXMgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbi5cblxuICAgICAgICBkdXIgKj0gX2NsYW1wU2Nyb2xsQW5kR2V0RHVyYXRpb25NdWx0aXBsaWVyKHNjcm9sbEZ1bmNYLCBjdXJyZW50U2Nyb2xsLCBlbmRTY3JvbGwsIF9tYXhTY3JvbGwodGFyZ2V0LCBfaG9yaXpvbnRhbCkpO1xuICAgICAgICB0d2Vlbi52YXJzLnNjcm9sbFggPSBzY3JvbGxDbGFtcFgoZW5kU2Nyb2xsKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudFNjcm9sbCA9IHNjcm9sbEZ1bmNZKCk7XG4gICAgICBlbmRTY3JvbGwgPSBjdXJyZW50U2Nyb2xsICsgZHVyICogMC4wNSAqIC1zZWxmLnZlbG9jaXR5WSAvIDAuMjI3OyAvLyB0aGUgY29uc3RhbnQgLjIyNyBpcyBmcm9tIHBvd2VyNCgwLjA1KVxuXG4gICAgICBkdXIgKj0gX2NsYW1wU2Nyb2xsQW5kR2V0RHVyYXRpb25NdWx0aXBsaWVyKHNjcm9sbEZ1bmNZLCBjdXJyZW50U2Nyb2xsLCBlbmRTY3JvbGwsIF9tYXhTY3JvbGwodGFyZ2V0LCBfdmVydGljYWwpKTtcbiAgICAgIHR3ZWVuLnZhcnMuc2Nyb2xsWSA9IHNjcm9sbENsYW1wWShlbmRTY3JvbGwpO1xuICAgICAgdHdlZW4uaW52YWxpZGF0ZSgpLmR1cmF0aW9uKGR1cikucGxheSgwLjAxKTtcblxuICAgICAgaWYgKF9maXhJT1NCdWcgJiYgdHdlZW4udmFycy5zY3JvbGxZID49IG1heFkgfHwgY3VycmVudFNjcm9sbCA+PSBtYXhZIC0gMSkge1xuICAgICAgICAvLyBpT1MgYnVnOiBpdCdsbCBzaG93IHRoZSBhZGRyZXNzIGJhciBidXQgTk9UIGZpcmUgdGhlIHdpbmRvdyBcInJlc2l6ZVwiIGV2ZW50IHVudGlsIHRoZSBhbmltYXRpb24gaXMgZG9uZSBidXQgd2UgbXVzdCBwcm90ZWN0IGFnYWluc3Qgb3ZlcnNob290IHNvIHdlIGxldmVyYWdlIGFuIG9uVXBkYXRlIHRvIGRvIHNvLlxuICAgICAgICBnc2FwLnRvKHt9LCB7XG4gICAgICAgICAgb25VcGRhdGU6IG9uUmVzaXplLFxuICAgICAgICAgIGR1cmF0aW9uOiBkdXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb25SZWxlYXNlICYmIG9uUmVsZWFzZShzZWxmKTtcbiAgfTtcblxuICB2YXJzLm9uV2hlZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdHdlZW4uX3RzICYmIHR3ZWVuLnBhdXNlKCk7XG5cbiAgICBpZiAoX2dldFRpbWUoKSAtIHdoZWVsUmVmcmVzaCA+IDEwMDApIHtcbiAgICAgIC8vIGFmdGVyIDEgc2Vjb25kLCByZWZyZXNoIHRoZSBjbGFtcHMgb3RoZXJ3aXNlIHRoYXQnbGwgb25seSBoYXBwZW4gd2hlbiBTY3JvbGxUcmlnZ2VyLnJlZnJlc2goKSBpcyBjYWxsZWQgb3IgZm9yIHRvdWNoLXNjcm9sbGluZy5cbiAgICAgIGxhc3RSZWZyZXNoSUQgPSAwO1xuICAgICAgd2hlZWxSZWZyZXNoID0gX2dldFRpbWUoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFycy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChzZWxmLCBkeCwgZHksIHhBcnJheSwgeUFycmF5KSB7XG4gICAgX3JlZnJlc2hJRCAhPT0gbGFzdFJlZnJlc2hJRCAmJiB1cGRhdGVDbGFtcHMoKTtcbiAgICBkeCAmJiBub3JtYWxpemVTY3JvbGxYICYmIHNjcm9sbEZ1bmNYKHNjcm9sbENsYW1wWCh4QXJyYXlbMl0gPT09IGR4ID8gc3RhcnRTY3JvbGxYICsgKHNlbGYuc3RhcnRYIC0gc2VsZi54KSA6IHNjcm9sbEZ1bmNYKCkgKyBkeCAtIHhBcnJheVsxXSkpOyAvLyBmb3IgbW9yZSBwcmVjaXNpb24sIHdlIHRyYWNrIHBvaW50ZXIvdG91Y2ggbW92ZW1lbnQgZnJvbSB0aGUgc3RhcnQsIG90aGVyd2lzZSBpdCdsbCBkcmlmdC5cblxuICAgIGlmIChkeSkge1xuICAgICAgc2Nyb2xsRnVuY1kub2Zmc2V0ICYmIHJlbW92ZUNvbnRlbnRPZmZzZXQoKTtcbiAgICAgIHZhciBpc1RvdWNoID0geUFycmF5WzJdID09PSBkeSxcbiAgICAgICAgICB5ID0gaXNUb3VjaCA/IHN0YXJ0U2Nyb2xsWSArIHNlbGYuc3RhcnRZIC0gc2VsZi55IDogc2Nyb2xsRnVuY1koKSArIGR5IC0geUFycmF5WzFdLFxuICAgICAgICAgIHlDbGFtcGVkID0gc2Nyb2xsQ2xhbXBZKHkpO1xuICAgICAgaXNUb3VjaCAmJiB5ICE9PSB5Q2xhbXBlZCAmJiAoc3RhcnRTY3JvbGxZICs9IHlDbGFtcGVkIC0geSk7XG4gICAgICBzY3JvbGxGdW5jWSh5Q2xhbXBlZCk7XG4gICAgfVxuXG4gICAgKGR5IHx8IGR4KSAmJiBfdXBkYXRlQWxsKCk7XG4gIH07XG5cbiAgdmFycy5vbkVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfYWxsb3dOYXRpdmVQYW5uaW5nKHRhcmdldCwgbm9ybWFsaXplU2Nyb2xsWCA/IGZhbHNlIDogXCJ4XCIpO1xuXG4gICAgU2Nyb2xsVHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKFwicmVmcmVzaFwiLCBvblJlc2l6ZSk7XG5cbiAgICBfYWRkTGlzdGVuZXIoX3dpbiwgXCJyZXNpemVcIiwgb25SZXNpemUpO1xuXG4gICAgaWYgKHNjcm9sbEZ1bmNZLnNtb290aCkge1xuICAgICAgc2Nyb2xsRnVuY1kudGFyZ2V0LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gXCJhdXRvXCI7XG4gICAgICBzY3JvbGxGdW5jWS5zbW9vdGggPSBzY3JvbGxGdW5jWC5zbW9vdGggPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpbnB1dE9ic2VydmVyLmVuYWJsZSgpO1xuICB9O1xuXG4gIHZhcnMub25EaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIF9hbGxvd05hdGl2ZVBhbm5pbmcodGFyZ2V0LCB0cnVlKTtcblxuICAgIF9yZW1vdmVMaXN0ZW5lcihfd2luLCBcInJlc2l6ZVwiLCBvblJlc2l6ZSk7XG5cbiAgICBTY3JvbGxUcmlnZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZWZyZXNoXCIsIG9uUmVzaXplKTtcbiAgICBpbnB1dE9ic2VydmVyLmtpbGwoKTtcbiAgfTtcblxuICB2YXJzLmxvY2tBeGlzID0gdmFycy5sb2NrQXhpcyAhPT0gZmFsc2U7XG4gIHNlbGYgPSBuZXcgT2JzZXJ2ZXIodmFycyk7XG4gIHNlbGYuaU9TID0gX2ZpeElPU0J1ZzsgLy8gdXNlZCBpbiB0aGUgT2JzZXJ2ZXIgZ2V0Q2FjaGVkU2Nyb2xsKCkgZnVuY3Rpb24gdG8gd29yayBhcm91bmQgYW4gaU9TIGJ1ZyB0aGF0IHdyZWFrcyBoYXZvYyB3aXRoIFRvdWNoRXZlbnQuY2xpZW50WSBpZiB3ZSBhbGxvdyBzY3JvbGwgdG8gZ28gYWxsIHRoZSB3YXkgYmFjayB0byAwLlxuXG4gIF9maXhJT1NCdWcgJiYgIXNjcm9sbEZ1bmNZKCkgJiYgc2Nyb2xsRnVuY1koMSk7IC8vIGlPUyBidWcgY2F1c2VzIGV2ZW50LmNsaWVudFkgdmFsdWVzIHRvIGZyZWFrIG91dCAod2lsZGx5IGluYWNjdXJhdGUpIGlmIHRoZSBzY3JvbGwgcG9zaXRpb24gaXMgZXhhY3RseSAwLlxuXG4gIF9maXhJT1NCdWcgJiYgZ3NhcC50aWNrZXIuYWRkKF9wYXNzVGhyb3VnaCk7IC8vIHByZXZlbnQgdGhlIHRpY2tlciBmcm9tIHNsZWVwaW5nXG5cbiAgb25TdG9wRGVsYXllZENhbGwgPSBzZWxmLl9kYztcbiAgdHdlZW4gPSBnc2FwLnRvKHNlbGYsIHtcbiAgICBlYXNlOiBcInBvd2VyNFwiLFxuICAgIHBhdXNlZDogdHJ1ZSxcbiAgICBpbmhlcml0OiBmYWxzZSxcbiAgICBzY3JvbGxYOiBub3JtYWxpemVTY3JvbGxYID8gXCIrPTAuMVwiIDogXCIrPTBcIixcbiAgICBzY3JvbGxZOiBcIis9MC4xXCIsXG4gICAgbW9kaWZpZXJzOiB7XG4gICAgICBzY3JvbGxZOiBfaW50ZXJydXB0aW9uVHJhY2tlcihzY3JvbGxGdW5jWSwgc2Nyb2xsRnVuY1koKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHdlZW4ucGF1c2UoKTtcbiAgICAgIH0pXG4gICAgfSxcbiAgICBvblVwZGF0ZTogX3VwZGF0ZUFsbCxcbiAgICBvbkNvbXBsZXRlOiBvblN0b3BEZWxheWVkQ2FsbC52YXJzLm9uQ29tcGxldGVcbiAgfSk7IC8vIHdlIG5lZWQgdGhlIG1vZGlmaWVyIHRvIHNlbnNlIGlmIHRoZSBzY3JvbGwgcG9zaXRpb24gaXMgYWx0ZXJlZCBvdXRzaWRlIG9mIHRoZSBtb21lbnR1bSB0d2VlbiAobGlrZSB3aXRoIGEgc2Nyb2xsVG8gdHdlZW4pIHNvIHdlIGNhbiBwYXVzZSgpIGl0IHRvIHByZXZlbnQgY29uZmxpY3RzLlxuXG4gIHJldHVybiBzZWxmO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5zb3J0ID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgcmV0dXJuIF90cmlnZ2Vycy5zb3J0KGZ1bmMgfHwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gKGEudmFycy5yZWZyZXNoUHJpb3JpdHkgfHwgMCkgKiAtMWU2ICsgYS5zdGFydCAtIChiLnN0YXJ0ICsgKGIudmFycy5yZWZyZXNoUHJpb3JpdHkgfHwgMCkgKiAtMWU2KTtcbiAgfSk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLm9ic2VydmUgPSBmdW5jdGlvbiAodmFycykge1xuICByZXR1cm4gbmV3IE9ic2VydmVyKHZhcnMpO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5ub3JtYWxpemVTY3JvbGwgPSBmdW5jdGlvbiAodmFycykge1xuICBpZiAodHlwZW9mIHZhcnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gX25vcm1hbGl6ZXI7XG4gIH1cblxuICBpZiAodmFycyA9PT0gdHJ1ZSAmJiBfbm9ybWFsaXplcikge1xuICAgIHJldHVybiBfbm9ybWFsaXplci5lbmFibGUoKTtcbiAgfVxuXG4gIGlmICh2YXJzID09PSBmYWxzZSkge1xuICAgIF9ub3JtYWxpemVyICYmIF9ub3JtYWxpemVyLmtpbGwoKTtcbiAgICBfbm9ybWFsaXplciA9IHZhcnM7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5vcm1hbGl6ZXIgPSB2YXJzIGluc3RhbmNlb2YgT2JzZXJ2ZXIgPyB2YXJzIDogX2dldFNjcm9sbE5vcm1hbGl6ZXIodmFycyk7XG4gIF9ub3JtYWxpemVyICYmIF9ub3JtYWxpemVyLnRhcmdldCA9PT0gbm9ybWFsaXplci50YXJnZXQgJiYgX25vcm1hbGl6ZXIua2lsbCgpO1xuICBfaXNWaWV3cG9ydChub3JtYWxpemVyLnRhcmdldCkgJiYgKF9ub3JtYWxpemVyID0gbm9ybWFsaXplcik7XG4gIHJldHVybiBub3JtYWxpemVyO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5jb3JlID0ge1xuICAvLyBzbWFsbGVyIGZpbGUgc2l6ZSB3YXkgdG8gbGV2ZXJhZ2UgaW4gU2Nyb2xsU21vb3RoZXIgYW5kIE9ic2VydmVyXG4gIF9nZXRWZWxvY2l0eVByb3A6IF9nZXRWZWxvY2l0eVByb3AsXG4gIF9pbnB1dE9ic2VydmVyOiBfaW5wdXRPYnNlcnZlcixcbiAgX3Njcm9sbGVyczogX3Njcm9sbGVycyxcbiAgX3Byb3hpZXM6IF9wcm94aWVzLFxuICBicmlkZ2U6IHtcbiAgICAvLyB3aGVuIG5vcm1hbGl6ZVNjcm9sbCBzZXRzIHRoZSBzY3JvbGwgcG9zaXRpb24gKHNzID0gc2V0U2Nyb2xsKVxuICAgIHNzOiBmdW5jdGlvbiBzcygpIHtcbiAgICAgIF9sYXN0U2Nyb2xsVGltZSB8fCBfZGlzcGF0Y2goXCJzY3JvbGxTdGFydFwiKTtcbiAgICAgIF9sYXN0U2Nyb2xsVGltZSA9IF9nZXRUaW1lKCk7XG4gICAgfSxcbiAgICAvLyBhIHdheSB0byBnZXQgdGhlIF9yZWZyZXNoaW5nIHZhbHVlIGluIE9ic2VydmVyXG4gICAgcmVmOiBmdW5jdGlvbiByZWYoKSB7XG4gICAgICByZXR1cm4gX3JlZnJlc2hpbmc7XG4gICAgfVxuICB9XG59O1xuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRyaWdnZXIpO1xuZXhwb3J0IHsgU2Nyb2xsVHJpZ2dlciBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbIk9ic2VydmVyIiwiX2dldFRhcmdldCIsIl92ZXJ0aWNhbCIsIl9ob3Jpem9udGFsIiwiX3Njcm9sbGVycyIsIl9wcm94aWVzIiwiX2dldFNjcm9sbEZ1bmMiLCJfZ2V0UHJveHlQcm9wIiwiX2dldFZlbG9jaXR5UHJvcCIsImdzYXAiLCJfY29yZUluaXR0ZWQiLCJfd2luIiwiX2RvYyIsIl9kb2NFbCIsIl9ib2R5IiwiX3Jvb3QiLCJfcmVzaXplRGVsYXkiLCJfdG9BcnJheSIsIl9jbGFtcCIsIl90aW1lMiIsIl9zeW5jSW50ZXJ2YWwiLCJfcmVmcmVzaGluZyIsIl9wb2ludGVySXNEb3duIiwiX3RyYW5zZm9ybVByb3AiLCJfaSIsIl9wcmV2V2lkdGgiLCJfcHJldkhlaWdodCIsIl9hdXRvUmVmcmVzaCIsIl9zb3J0IiwiX3N1cHByZXNzT3ZlcndyaXRlcyIsIl9pZ25vcmVSZXNpemUiLCJfbm9ybWFsaXplciIsIl9pZ25vcmVNb2JpbGVSZXNpemUiLCJfYmFzZVNjcmVlbkhlaWdodCIsIl9iYXNlU2NyZWVuV2lkdGgiLCJfZml4SU9TQnVnIiwiX2NvbnRleHQiLCJfc2Nyb2xsUmVzdG9yYXRpb24iLCJfZGl2MTAwdmgiLCJfMTAwdmgiLCJfaXNSZXZlcnRlZCIsIl9jbGFtcGluZ01heCIsIl9saW1pdENhbGxiYWNrcyIsIl9zdGFydHVwIiwiX2dldFRpbWUiLCJEYXRlIiwibm93IiwiX3RpbWUxIiwiX2xhc3RTY3JvbGxUaW1lIiwiX2VuYWJsZWQiLCJfcGFyc2VDbGFtcCIsInZhbHVlIiwidHlwZSIsInNlbGYiLCJjbGFtcCIsIl9pc1N0cmluZyIsInN1YnN0ciIsImluZGV4T2YiLCJsZW5ndGgiLCJfa2VlcENsYW1wIiwiX3JhZkJ1Z0ZpeCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIl9wb2ludGVyRG93bkhhbmRsZXIiLCJfcG9pbnRlclVwSGFuZGxlciIsIl9wYXNzVGhyb3VnaCIsInYiLCJfcm91bmQiLCJNYXRoIiwicm91bmQiLCJfd2luZG93RXhpc3RzIiwid2luZG93IiwiX2dldEdTQVAiLCJyZWdpc3RlclBsdWdpbiIsIl9pc1ZpZXdwb3J0IiwiZSIsIl9nZXRWaWV3cG9ydERpbWVuc2lvbiIsImRpbWVuc2lvblByb3BlcnR5IiwiX2dldEJvdW5kc0Z1bmMiLCJlbGVtZW50IiwiX3dpbk9mZnNldHMiLCJ3aWR0aCIsImlubmVyV2lkdGgiLCJoZWlnaHQiLCJfZ2V0Qm91bmRzIiwiX2dldFNpemVGdW5jIiwic2Nyb2xsZXIiLCJpc1ZpZXdwb3J0IiwiX3JlZiIsImQiLCJkMiIsImEiLCJfZ2V0T2Zmc2V0c0Z1bmMiLCJfbWF4U2Nyb2xsIiwiX3JlZjIiLCJzIiwibWF4IiwiX2l0ZXJhdGVBdXRvUmVmcmVzaCIsImZ1bmMiLCJldmVudHMiLCJpIiwiX2lzRnVuY3Rpb24iLCJfaXNOdW1iZXIiLCJfaXNPYmplY3QiLCJfZW5kQW5pbWF0aW9uIiwiYW5pbWF0aW9uIiwicmV2ZXJzZWQiLCJwYXVzZSIsInByb2dyZXNzIiwiX2NhbGxiYWNrIiwiZW5hYmxlZCIsInJlc3VsdCIsIl9jdHgiLCJhZGQiLCJ0b3RhbFRpbWUiLCJjYWxsYmFja0FuaW1hdGlvbiIsIl9hYnMiLCJhYnMiLCJfbGVmdCIsIl90b3AiLCJfcmlnaHQiLCJfYm90dG9tIiwiX3dpZHRoIiwiX2hlaWdodCIsIl9SaWdodCIsIl9MZWZ0IiwiX1RvcCIsIl9Cb3R0b20iLCJfcGFkZGluZyIsIl9tYXJnaW4iLCJfV2lkdGgiLCJfSGVpZ2h0IiwiX3B4IiwiX2dldENvbXB1dGVkU3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiX21ha2VQb3NpdGlvbmFibGUiLCJwb3NpdGlvbiIsInN0eWxlIiwiX3NldERlZmF1bHRzIiwib2JqIiwiZGVmYXVsdHMiLCJwIiwid2l0aG91dFRyYW5zZm9ybXMiLCJ0d2VlbiIsInRvIiwieCIsInkiLCJ4UGVyY2VudCIsInlQZXJjZW50Iiwicm90YXRpb24iLCJyb3RhdGlvblgiLCJyb3RhdGlvblkiLCJzY2FsZSIsInNrZXdYIiwic2tld1kiLCJib3VuZHMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJraWxsIiwiX2dldFNpemUiLCJfcmVmMyIsIl9nZXRMYWJlbFJhdGlvQXJyYXkiLCJ0aW1lbGluZSIsImxhYmVscyIsImR1cmF0aW9uIiwicHVzaCIsIl9nZXRDbG9zZXN0TGFiZWwiLCJ1dGlscyIsInNuYXAiLCJfc25hcERpcmVjdGlvbmFsIiwic25hcEluY3JlbWVudE9yQXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJzbGljZSIsInNvcnQiLCJiIiwiZGlyZWN0aW9uIiwidGhyZXNob2xkIiwic25hcHBlZCIsIl9nZXRMYWJlbEF0RGlyZWN0aW9uIiwic3QiLCJfbXVsdGlMaXN0ZW5lciIsInR5cGVzIiwiY2FsbGJhY2siLCJzcGxpdCIsImZvckVhY2giLCJfYWRkTGlzdGVuZXIiLCJub25QYXNzaXZlIiwiY2FwdHVyZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwiX3JlbW92ZUxpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIl93aGVlbExpc3RlbmVyIiwiZWwiLCJzY3JvbGxGdW5jIiwid2hlZWxIYW5kbGVyIiwiX21hcmtlckRlZmF1bHRzIiwic3RhcnRDb2xvciIsImVuZENvbG9yIiwiaW5kZW50IiwiZm9udFNpemUiLCJmb250V2VpZ2h0IiwiX2RlZmF1bHRzIiwidG9nZ2xlQWN0aW9ucyIsImFudGljaXBhdGVQaW4iLCJfa2V5d29yZHMiLCJ0b3AiLCJsZWZ0IiwiY2VudGVyIiwiYm90dG9tIiwicmlnaHQiLCJfb2Zmc2V0VG9QeCIsInNpemUiLCJlcUluZGV4IiwicmVsYXRpdmUiLCJjaGFyQXQiLCJwYXJzZUZsb2F0IiwiX2NyZWF0ZU1hcmtlciIsIm5hbWUiLCJjb250YWluZXIiLCJfcmVmNCIsIm9mZnNldCIsIm1hdGNoV2lkdGhFbCIsImNvbnRhaW5lckFuaW1hdGlvbiIsImNyZWF0ZUVsZW1lbnQiLCJ1c2VGaXhlZFBvc2l0aW9uIiwiaXNTY3JvbGxlciIsInBhcmVudCIsImlzU3RhcnQiLCJjb2xvciIsImNzcyIsIm9mZnNldFdpZHRoIiwiX2lzU3RhcnQiLCJzZXRBdHRyaWJ1dGUiLCJjc3NUZXh0IiwiaW5uZXJUZXh0IiwiY2hpbGRyZW4iLCJpbnNlcnRCZWZvcmUiLCJhcHBlbmRDaGlsZCIsIl9vZmZzZXQiLCJvcCIsIl9wb3NpdGlvbk1hcmtlciIsIm1hcmtlciIsInN0YXJ0IiwiZmxpcHBlZCIsInZhcnMiLCJkaXNwbGF5Iiwic2lkZSIsIm9wcG9zaXRlU2lkZSIsIl9pc0ZsaXBwZWQiLCJzZXQiLCJfdHJpZ2dlcnMiLCJfaWRzIiwiX3JhZklEIiwiX3N5bmMiLCJfdXBkYXRlQWxsIiwiX29uU2Nyb2xsIiwiaXNQcmVzc2VkIiwic3RhcnRYIiwiY2xpZW50V2lkdGgiLCJjYWNoZSIsIl9kaXNwYXRjaCIsIl9zZXRCYXNlRGltZW5zaW9ucyIsImlubmVySGVpZ2h0IiwiX29uUmVzaXplIiwiZnVsbHNjcmVlbkVsZW1lbnQiLCJ3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCIsInJlc3RhcnQiLCJfbGlzdGVuZXJzIiwiX2VtcHR5QXJyYXkiLCJfc29mdFJlZnJlc2giLCJTY3JvbGxUcmlnZ2VyIiwiX3JlZnJlc2hBbGwiLCJtYXAiLCJmIiwiX3NhdmVkU3R5bGVzIiwiX3JldmVydFJlY29yZGVkIiwibWVkaWEiLCJxdWVyeSIsImdldEJCb3giLCJ1bmNhY2hlIiwiX3JldmVydEFsbCIsInRyaWdnZXIiLCJyZXZlcnQiLCJfY2xlYXJTY3JvbGxNZW1vcnkiLCJzY3JvbGxSZXN0b3JhdGlvbiIsImZvcmNlIiwiX3JlZnJlc2hpbmdBbGwiLCJjYWNoZUlEIiwicmVjIiwiaGlzdG9yeSIsIl9yZWZyZXNoSUQiLCJfcXVldWVSZWZyZXNoSUQiLCJfcXVldWVSZWZyZXNoQWxsIiwiaWQiLCJfcmVmcmVzaDEwMHZoIiwib2Zmc2V0SGVpZ2h0IiwicmVtb3ZlQ2hpbGQiLCJfaGlkZUFsbE1hcmtlcnMiLCJoaWRlIiwic2tpcFJldmVydCIsImlzUmVmcmVzaGluZyIsInJlZnJlc2hJbml0cyIsInNtb290aCIsInRhcmdldCIsInNjcm9sbEJlaGF2aW9yIiwidCIsInJlZnJlc2giLCJfc3ViUGluT2Zmc2V0IiwicGluIiwicHJvcCIsImhvcml6b250YWwiLCJvcmlnaW5hbCIsImFkanVzdFBpblNwYWNpbmciLCJfZGlyIiwiZW5kQ2xhbXAiLCJlbmQiLCJfZW5kQ2xhbXAiLCJzdGFydENsYW1wIiwiX3N0YXJ0Q2xhbXAiLCJzZXRQb3NpdGlvbnMiLCJyZW5kZXIiLCJvblJlZnJlc2giLCJfbGFzdFNjcm9sbCIsIl9kaXJlY3Rpb24iLCJfcHJpbWFyeSIsImlzVXBkYXRpbmciLCJ1cGRhdGUiLCJsIiwidGltZSIsInJlY29yZFZlbG9jaXR5Iiwic2Nyb2xsIiwiX3Byb3BOYW1lc1RvQ29weSIsIl9zdGF0ZVByb3BzIiwiY29uY2F0IiwiX3N3YXBQaW5PdXQiLCJzcGFjZXIiLCJzdGF0ZSIsIl9zZXRTdGF0ZSIsIl9nc2FwIiwic3BhY2VySXNOYXRpdmUiLCJzcGFjZXJTdGF0ZSIsInN3YXBwZWRJbiIsInBhcmVudE5vZGUiLCJfc3dhcFBpbkluIiwiY3MiLCJzcGFjZXJTdHlsZSIsInBpblN0eWxlIiwiZmxleEJhc2lzIiwib3ZlcmZsb3ciLCJib3hTaXppbmciLCJfY2Fwc0V4cCIsImNvcmUiLCJnZXRDYWNoZSIsInJlbW92ZVByb3BlcnR5IiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwiX2dldFN0YXRlIiwiX2NvcHlTdGF0ZSIsIm92ZXJyaWRlIiwib21pdE9mZnNldHMiLCJfcGFyc2VQb3NpdGlvbiIsInNjcm9sbGVyU2l6ZSIsIm1hcmtlclNjcm9sbGVyIiwic2Nyb2xsZXJCb3VuZHMiLCJib3JkZXJXaWR0aCIsInNjcm9sbGVyTWF4IiwiY2xhbXBaZXJvUHJvcCIsInAxIiwicDIiLCJzZWVrIiwiaXNOYU4iLCJvZmZzZXRzIiwibG9jYWxPZmZzZXQiLCJnbG9iYWxPZmZzZXQiLCJtYXBSYW5nZSIsInNjcm9sbFRyaWdnZXIiLCJtIiwiX2NhU2Nyb2xsRGlzdCIsIl9wcmVmaXhFeHAiLCJfcmVwYXJlbnQiLCJfc3RPcmlnIiwidGVzdCIsIl9pbnRlcnJ1cHRpb25UcmFja2VyIiwiZ2V0VmFsdWVGdW5jIiwiaW5pdGlhbFZhbHVlIiwib25JbnRlcnJ1cHQiLCJsYXN0MSIsImxhc3QyIiwiY3VycmVudCIsIl9zaGlmdE1hcmtlciIsIl9nZXRUd2VlbkNyZWF0b3IiLCJnZXRTY3JvbGwiLCJnZXRUd2VlbiIsInNjcm9sbFRvIiwiY2hhbmdlMSIsImNoYW5nZTIiLCJvbkNvbXBsZXRlIiwibW9kaWZpZXJzIiwiY2hlY2tGb3JJbnRlcnJ1cHRpb24iLCJpbmhlcml0IiwicmF0aW8iLCJvblVwZGF0ZSIsImNhbGwiLCJpc1RvdWNoIiwicmVnaXN0ZXIiLCJjb25zb2xlIiwid2FybiIsImluaXQiLCJfcHJvdG8iLCJwcm90b3R5cGUiLCJub2RlVHlwZSIsIl92YXJzIiwidG9nZ2xlQ2xhc3MiLCJvblRvZ2dsZSIsInNjcnViIiwicGluU3BhY2luZyIsImludmFsaWRhdGVPblJlZnJlc2giLCJvblNjcnViQ29tcGxldGUiLCJvblNuYXBDb21wbGV0ZSIsIm9uY2UiLCJwaW5SZXBhcmVudCIsInBpblNwYWNlciIsImZhc3RTY3JvbGxFbmQiLCJwcmV2ZW50T3ZlcmxhcHMiLCJpc1RvZ2dsZSIsInNjcm9sbGVyQ2FjaGUiLCJwaW5UeXBlIiwiY2FsbGJhY2tzIiwib25FbnRlciIsIm9uTGVhdmUiLCJvbkVudGVyQmFjayIsIm9uTGVhdmVCYWNrIiwibWFya2VycyIsIm9uUmVmcmVzaEluaXQiLCJnZXRTY3JvbGxlclNpemUiLCJnZXRTY3JvbGxlck9mZnNldHMiLCJsYXN0U25hcCIsImxhc3RSZWZyZXNoIiwicHJldlByb2dyZXNzIiwidHdlZW5UbyIsInBpbkNhY2hlIiwic25hcEZ1bmMiLCJzY3JvbGwxIiwic2Nyb2xsMiIsIm1hcmtlclN0YXJ0IiwibWFya2VyRW5kIiwibWFya2VyU3RhcnRUcmlnZ2VyIiwibWFya2VyRW5kVHJpZ2dlciIsIm1hcmtlclZhcnMiLCJleGVjdXRpbmdPblJlZnJlc2giLCJjaGFuZ2UiLCJwaW5PcmlnaW5hbFN0YXRlIiwicGluQWN0aXZlU3RhdGUiLCJwaW5TdGF0ZSIsInBpbkdldHRlciIsInBpblNldHRlciIsInBpblN0YXJ0IiwicGluQ2hhbmdlIiwic3BhY2luZ1N0YXJ0IiwibWFya2VyU3RhcnRTZXR0ZXIiLCJwaW5Nb3ZlcyIsIm1hcmtlckVuZFNldHRlciIsInNuYXAxIiwic25hcDIiLCJzY3J1YlR3ZWVuIiwic2NydWJTbW9vdGgiLCJzbmFwRHVyQ2xhbXAiLCJzbmFwRGVsYXllZENhbGwiLCJwcmV2U2Nyb2xsIiwicHJldkFuaW1Qcm9ncmVzcyIsImNhTWFya2VyU2V0dGVyIiwiY3VzdG9tUmV2ZXJ0UmV0dXJuIiwiYmluZCIsInJlZnJlc2hQcmlvcml0eSIsInR3ZWVuU2Nyb2xsIiwic2NydWJEdXJhdGlvbiIsImVhc2UiLCJ0b3RhbFByb2dyZXNzIiwicGF1c2VkIiwibGF6eSIsIl9pbml0dGVkIiwiaXNSZXZlcnRlZCIsImltbWVkaWF0ZVJlbmRlciIsInNuYXBUbyIsIm8iLCJzY3JvbGxpbmdFbGVtZW50IiwiZGlyZWN0aW9uYWwiLCJtaW4iLCJkZWxheWVkQ2FsbCIsImRlbGF5IiwicmVmcmVzaGVkUmVjZW50bHkiLCJnZXRWZWxvY2l0eSIsInZlbG9jaXR5IiwibmF0dXJhbEVuZCIsImluZXJ0aWEiLCJlbmRWYWx1ZSIsImVuZFNjcm9sbCIsIl9zbmFwIiwib25TdGFydCIsIl9vbkludGVycnVwdCIsIl9vbkNvbXBsZXRlIiwiZGF0YSIsInJlc2V0VG8iLCJfdFRpbWUiLCJfdER1ciIsImlzQWN0aXZlIiwic3RSZXZlcnQiLCJ0YXJnZXRzIiwiY2xhc3NOYW1lIiwibmF0aXZlRWxlbWVudCIsImNsYXNzTGlzdCIsImZvcmNlM0QiLCJvczIiLCJnZXRQcm9wZXJ0eSIsInF1aWNrU2V0dGVyIiwiY29udGVudCIsIm9sZE9uVXBkYXRlIiwib2xkUGFyYW1zIiwib25VcGRhdGVQYXJhbXMiLCJldmVudENhbGxiYWNrIiwiYXBwbHkiLCJwcmV2aW91cyIsIm5leHQiLCJ0ZW1wIiwiciIsInByZXZSZWZyZXNoaW5nIiwic29mdCIsInBpbk9mZnNldCIsImludmFsaWRhdGUiLCJpc0ZpcnN0UmVmcmVzaCIsIm90aGVyUGluT2Zmc2V0IiwicGFyc2VkRW5kIiwicGFyc2VkRW5kVHJpZ2dlciIsImVuZFRyaWdnZXIiLCJwYXJzZWRTdGFydCIsInBpbm5lZENvbnRhaW5lciIsInRyaWdnZXJJbmRleCIsImlzVmVydGljYWwiLCJjdXJUcmlnZ2VyIiwiY3VyUGluIiwib3Bwb3NpdGVTY3JvbGwiLCJpbml0dGVkIiwicmV2ZXJ0ZWRQaW5zIiwiZm9yY2VkT3ZlcmZsb3ciLCJtYXJrZXJTdGFydE9mZnNldCIsIm1hcmtlckVuZE9mZnNldCIsInVuc2hpZnQiLCJfcGluUHVzaCIsIm5vcm1hbGl6ZSIsInRvVXBwZXJDYXNlIiwiY2VpbCIsInNwbGljZSIsIl9waW5PZmZzZXQiLCJlbmRBbmltYXRpb24iLCJsYWJlbFRvU2Nyb2xsIiwibGFiZWwiLCJnZXRUcmFpbGluZyIsInJldmVyc2UiLCJmaWx0ZXIiLCJyZXNldCIsImZvcmNlRmFrZSIsImNsaXBwZWQiLCJ3YXNBY3RpdmUiLCJ0b2dnbGVTdGF0ZSIsImFjdGlvbiIsInN0YXRlQ2hhbmdlZCIsInRvZ2dsZWQiLCJpc0F0TWF4IiwiaXNUYWtpbmdBY3Rpb24iLCJfZHAiLCJfdGltZSIsIl9zdGFydCIsIm4iLCJlbmFibGUiLCJuZXdTdGFydCIsIm5ld0VuZCIsImtlZXBDbGFtcCIsIl9jaGFuZ2UiLCJhbW91bnQiLCJkaXNhYmxlIiwiYWxsb3dBbmltYXRpb24iLCJvbktpbGwiLCJ1cGRhdGVGdW5jIiwiZG9jdW1lbnQiLCJjb25maWciLCJjbGVhckludGVydmFsIiwiZG9jdW1lbnRFbGVtZW50IiwiYm9keSIsInRvQXJyYXkiLCJjb250ZXh0Iiwic3VwcHJlc3NPdmVyd3JpdGVzIiwicGFnZVlPZmZzZXQiLCJnbG9iYWxzIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwibWF0Y2hNZWRpYSIsIm1tIiwiYm9keVN0eWxlIiwiYm9yZGVyIiwiYm9yZGVyVG9wU3R5bGUiLCJBbmltYXRpb25Qcm90byIsIkFuaW1hdGlvbiIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwic2MiLCJzZXRJbnRlcnZhbCIsImNoZWNrUHJlZml4IiwidyIsImgiLCJoaWRkZW4iLCJsaW1pdENhbGxiYWNrcyIsIm1zIiwic3luY0ludGVydmFsIiwiaWdub3JlTW9iaWxlUmVzaXplIiwiYXV0b1JlZnJlc2hFdmVudHMiLCJzY3JvbGxlclByb3h5IiwiY2xlYXJNYXRjaE1lZGlhIiwiaXNJblZpZXdwb3J0IiwicG9zaXRpb25JblZpZXdwb3J0IiwicmVmZXJlbmNlUG9pbnQiLCJraWxsQWxsIiwiYWxsb3dMaXN0ZW5lcnMiLCJsaXN0ZW5lcnMiLCJ2ZXJzaW9uIiwic2F2ZVN0eWxlcyIsImdldEF0dHJpYnV0ZSIsImNyZWF0ZSIsInNhZmUiLCJjbGVhclNjcm9sbE1lbW9yeSIsIm1heFNjcm9sbCIsImdldFNjcm9sbEZ1bmMiLCJnZXRCeUlkIiwiZ2V0QWxsIiwiaXNTY3JvbGxpbmciLCJzbmFwRGlyZWN0aW9uYWwiLCJiYXRjaCIsInZhcnNDb3B5IiwiaW50ZXJ2YWwiLCJiYXRjaE1heCIsInByb3h5Q2FsbGJhY2siLCJlbGVtZW50cyIsInRyaWdnZXJzIiwiX2NsYW1wU2Nyb2xsQW5kR2V0RHVyYXRpb25NdWx0aXBsaWVyIiwiX2FsbG93TmF0aXZlUGFubmluZyIsInRvdWNoQWN0aW9uIiwiX292ZXJmbG93IiwiYXV0byIsIl9uZXN0ZWRTY3JvbGwiLCJfcmVmNSIsImV2ZW50IiwiYXhpcyIsIm5vZGUiLCJjaGFuZ2VkVG91Y2hlcyIsIl9pc1Njcm9sbFQiLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxXaWR0aCIsIm92ZXJmbG93WSIsIm92ZXJmbG93WCIsIl9pc1Njcm9sbCIsInN0b3BQcm9wYWdhdGlvbiIsIl9nc2FwQWxsb3ciLCJfaW5wdXRPYnNlcnZlciIsImlucHV0cyIsIm5lc3RlZCIsImRlYm91bmNlIiwibG9ja0F4aXMiLCJvbldoZWVsIiwib25QcmVzcyIsIm9uRHJhZyIsIm9uU2Nyb2xsIiwib25FbmFibGUiLCJldmVudFR5cGVzIiwiX2NhcHR1cmVJbnB1dHMiLCJvbkRpc2FibGUiLCJfaW5wdXRFeHAiLCJfaW5wdXRJc0ZvY3VzZWQiLCJpc0lucHV0IiwidGFnTmFtZSIsIl9nZXRTY3JvbGxOb3JtYWxpemVyIiwicHJldmVudERlZmF1bHQiLCJpc05vcm1hbGl6ZXIiLCJhbGxvd0NsaWNrcyIsIl92YXJzMiIsIm5vcm1hbGl6ZVNjcm9sbFgiLCJtb21lbnR1bSIsImFsbG93TmVzdGVkU2Nyb2xsIiwib25SZWxlYXNlIiwibWF4WSIsInNtb290aGVyIiwiU2Nyb2xsU21vb3RoZXIiLCJzbW9vdGhlckluc3RhbmNlIiwiZ2V0Iiwic2Nyb2xsRnVuY1kiLCJzY3JvbGxGdW5jWCIsImluaXRpYWxTY2FsZSIsInZpc3VhbFZpZXdwb3J0Iiwib3V0ZXJXaWR0aCIsIndoZWVsUmVmcmVzaCIsInJlc29sdmVNb21lbnR1bUR1cmF0aW9uIiwibGFzdFJlZnJlc2hJRCIsInNraXBUb3VjaE1vdmUiLCJpbnB1dE9ic2VydmVyIiwicmVzdW1lVG91Y2hNb3ZlIiwic2Nyb2xsQ2xhbXBYIiwic2Nyb2xsQ2xhbXBZIiwidXBkYXRlQ2xhbXBzIiwicmVtb3ZlQ29udGVudE9mZnNldCIsInRyYW5zZm9ybSIsImlnbm9yZURyYWciLCJkZWx0YVkiLCJzdGFydFNjcm9sbFgiLCJzdGFydFNjcm9sbFkiLCJvblN0b3BEZWxheWVkQ2FsbCIsIm9uUmVzaXplIiwic2Nyb2xsWSIsImlnbm9yZUNoZWNrIiwiaXNHZXN0dXJpbmciLCJ0b3VjaGVzIiwicHJldlNjYWxlIiwib25HZXN0dXJlU3RhcnQiLCJ3YXNEcmFnZ2luZyIsImR1ciIsImN1cnJlbnRTY3JvbGwiLCJ2ZWxvY2l0eVgiLCJzY3JvbGxYIiwidmVsb2NpdHlZIiwicGxheSIsIl90cyIsIm9uQ2hhbmdlIiwiZHgiLCJkeSIsInhBcnJheSIsInlBcnJheSIsInN0YXJ0WSIsInlDbGFtcGVkIiwiaU9TIiwidGlja2VyIiwiX2RjIiwib2JzZXJ2ZSIsIm5vcm1hbGl6ZVNjcm9sbCIsIm5vcm1hbGl6ZXIiLCJicmlkZ2UiLCJzcyIsInJlZiIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollTrigger.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/TextPlugin.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/TextPlugin.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextPlugin: function() { return /* binding */ TextPlugin; },\n/* harmony export */   \"default\": function() { return /* binding */ TextPlugin; }\n/* harmony export */ });\n/* harmony import */ var _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/strings.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/strings.js\");\n/*!\n * TextPlugin 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ \nvar gsap, _tempDiv, _getGSAP = function _getGSAP() {\n    return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n};\nvar TextPlugin = {\n    version: \"3.12.5\",\n    name: \"text\",\n    init: function init(target, value, tween) {\n        typeof value !== \"object\" && (value = {\n            value: value\n        });\n        var i = target.nodeName.toUpperCase(), data = this, _value = value, newClass = _value.newClass, oldClass = _value.oldClass, preserveSpaces = _value.preserveSpaces, rtl = _value.rtl, delimiter = data.delimiter = value.delimiter || \"\", fillChar = data.fillChar = value.fillChar || (value.padSpace ? \"&nbsp;\" : \"\"), _short, text, original, j, condensedText, condensedOriginal, aggregate, s;\n        data.svg = target.getBBox && (i === \"TEXT\" || i === \"TSPAN\");\n        if (!(\"innerHTML\" in target) && !data.svg) {\n            return false;\n        }\n        data.target = target;\n        if (!(\"value\" in value)) {\n            data.text = data.original = [\n                \"\"\n            ];\n            return;\n        }\n        original = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitInnerHTML)(target, delimiter, false, preserveSpaces);\n        _tempDiv || (_tempDiv = document.createElement(\"div\"));\n        _tempDiv.innerHTML = value.value;\n        text = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitInnerHTML)(_tempDiv, delimiter, false, preserveSpaces);\n        data.from = tween._from;\n        if ((data.from || rtl) && !(rtl && data.from)) {\n            // right-to-left or \"from()\" tweens should invert things (but if it's BOTH .from() and rtl, inverting twice equals not inverting at all :)\n            i = original;\n            original = text;\n            text = i;\n        }\n        data.hasClass = !!(newClass || oldClass);\n        data.newClass = rtl ? oldClass : newClass;\n        data.oldClass = rtl ? newClass : oldClass;\n        i = original.length - text.length;\n        _short = i < 0 ? original : text;\n        if (i < 0) {\n            i = -i;\n        }\n        while(--i > -1){\n            _short.push(fillChar);\n        }\n        if (value.type === \"diff\") {\n            j = 0;\n            condensedText = [];\n            condensedOriginal = [];\n            aggregate = \"\";\n            for(i = 0; i < text.length; i++){\n                s = text[i];\n                if (s === original[i]) {\n                    aggregate += s;\n                } else {\n                    condensedText[j] = aggregate + s;\n                    condensedOriginal[j++] = aggregate + original[i];\n                    aggregate = \"\";\n                }\n            }\n            text = condensedText;\n            original = condensedOriginal;\n            if (aggregate) {\n                text.push(aggregate);\n                original.push(aggregate);\n            }\n        }\n        value.speed && tween.duration(Math.min(0.05 / value.speed * _short.length, value.maxDuration || 9999));\n        data.rtl = rtl;\n        data.original = original;\n        data.text = text;\n        data._props.push(\"text\");\n    },\n    render: function render(ratio, data) {\n        if (ratio > 1) {\n            ratio = 1;\n        } else if (ratio < 0) {\n            ratio = 0;\n        }\n        if (data.from) {\n            ratio = 1 - ratio;\n        }\n        var text = data.text, hasClass = data.hasClass, newClass = data.newClass, oldClass = data.oldClass, delimiter = data.delimiter, target = data.target, fillChar = data.fillChar, original = data.original, rtl = data.rtl, l = text.length, i = (rtl ? 1 - ratio : ratio) * l + 0.5 | 0, applyNew, applyOld, str;\n        if (hasClass && ratio) {\n            applyNew = newClass && i;\n            applyOld = oldClass && i !== l;\n            str = (applyNew ? \"<span class='\" + newClass + \"'>\" : \"\") + text.slice(0, i).join(delimiter) + (applyNew ? \"</span>\" : \"\") + (applyOld ? \"<span class='\" + oldClass + \"'>\" : \"\") + delimiter + original.slice(i).join(delimiter) + (applyOld ? \"</span>\" : \"\");\n        } else {\n            str = text.slice(0, i).join(delimiter) + delimiter + original.slice(i).join(delimiter);\n        }\n        if (data.svg) {\n            //SVG text elements don't have an \"innerHTML\" in Microsoft browsers.\n            target.textContent = str;\n        } else {\n            target.innerHTML = fillChar === \"&nbsp;\" && ~str.indexOf(\"  \") ? str.split(\"  \").join(\"&nbsp;&nbsp;\") : str;\n        }\n    }\n};\nTextPlugin.splitInnerHTML = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitInnerHTML;\nTextPlugin.emojiSafeSplit = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit;\nTextPlugin.getText = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.getText;\n_getGSAP() && gsap.registerPlugin(TextPlugin);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9UZXh0UGx1Z2luLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCLEdBQzJEO0FBRTdFLElBQUlHLE1BQ0FDLFVBQ0FDLFdBQVcsU0FBU0E7SUFDdEIsT0FBT0YsUUFBUSxPQUFPRyxXQUFXLGVBQWdCSCxDQUFBQSxPQUFPRyxPQUFPSCxJQUFJLEtBQUtBLEtBQUtJLGNBQWMsSUFBSUo7QUFDakc7QUFFTyxJQUFJSyxhQUFhO0lBQ3RCQyxTQUFTO0lBQ1RDLE1BQU07SUFDTkMsTUFBTSxTQUFTQSxLQUFLQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsS0FBSztRQUN0QyxPQUFPRCxVQUFVLFlBQWFBLENBQUFBLFFBQVE7WUFDcENBLE9BQU9BO1FBQ1Q7UUFFQSxJQUFJRSxJQUFJSCxPQUFPSSxRQUFRLENBQUNDLFdBQVcsSUFDL0JDLE9BQU8sSUFBSSxFQUNYQyxTQUFTTixPQUNUTyxXQUFXRCxPQUFPQyxRQUFRLEVBQzFCQyxXQUFXRixPQUFPRSxRQUFRLEVBQzFCQyxpQkFBaUJILE9BQU9HLGNBQWMsRUFDdENDLE1BQU1KLE9BQU9JLEdBQUcsRUFDaEJDLFlBQVlOLEtBQUtNLFNBQVMsR0FBR1gsTUFBTVcsU0FBUyxJQUFJLElBQ2hEQyxXQUFXUCxLQUFLTyxRQUFRLEdBQUdaLE1BQU1ZLFFBQVEsSUFBS1osQ0FBQUEsTUFBTWEsUUFBUSxHQUFHLFdBQVcsRUFBQyxHQUMzRUMsUUFDQUMsTUFDQUMsVUFDQUMsR0FDQUMsZUFDQUMsbUJBQ0FDLFdBQ0FDO1FBRUpoQixLQUFLaUIsR0FBRyxHQUFHdkIsT0FBT3dCLE9BQU8sSUFBS3JCLENBQUFBLE1BQU0sVUFBVUEsTUFBTSxPQUFNO1FBRTFELElBQUksQ0FBRSxnQkFBZUgsTUFBSyxLQUFNLENBQUNNLEtBQUtpQixHQUFHLEVBQUU7WUFDekMsT0FB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Y0YsS0FBS0ksY0FBYyxDQUFDQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9UZXh0UGx1Z2luLmpzPzk3M2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUZXh0UGx1Z2luIDMuMTIuNVxuICogaHR0cHM6Ly9nc2FwLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjQsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3NhcC5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR1NBUCBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCB7IGVtb2ppU2FmZVNwbGl0LCBnZXRUZXh0LCBzcGxpdElubmVySFRNTCB9IGZyb20gXCIuL3V0aWxzL3N0cmluZ3MuanNcIjtcblxudmFyIGdzYXAsXG4gICAgX3RlbXBEaXYsXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59O1xuXG5leHBvcnQgdmFyIFRleHRQbHVnaW4gPSB7XG4gIHZlcnNpb246IFwiMy4xMi41XCIsXG4gIG5hbWU6IFwidGV4dFwiLFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFsdWUsIHR3ZWVuKSB7XG4gICAgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiICYmICh2YWx1ZSA9IHtcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuXG4gICAgdmFyIGkgPSB0YXJnZXQubm9kZU5hbWUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgZGF0YSA9IHRoaXMsXG4gICAgICAgIF92YWx1ZSA9IHZhbHVlLFxuICAgICAgICBuZXdDbGFzcyA9IF92YWx1ZS5uZXdDbGFzcyxcbiAgICAgICAgb2xkQ2xhc3MgPSBfdmFsdWUub2xkQ2xhc3MsXG4gICAgICAgIHByZXNlcnZlU3BhY2VzID0gX3ZhbHVlLnByZXNlcnZlU3BhY2VzLFxuICAgICAgICBydGwgPSBfdmFsdWUucnRsLFxuICAgICAgICBkZWxpbWl0ZXIgPSBkYXRhLmRlbGltaXRlciA9IHZhbHVlLmRlbGltaXRlciB8fCBcIlwiLFxuICAgICAgICBmaWxsQ2hhciA9IGRhdGEuZmlsbENoYXIgPSB2YWx1ZS5maWxsQ2hhciB8fCAodmFsdWUucGFkU3BhY2UgPyBcIiZuYnNwO1wiIDogXCJcIiksXG4gICAgICAgIF9zaG9ydCxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgb3JpZ2luYWwsXG4gICAgICAgIGosXG4gICAgICAgIGNvbmRlbnNlZFRleHQsXG4gICAgICAgIGNvbmRlbnNlZE9yaWdpbmFsLFxuICAgICAgICBhZ2dyZWdhdGUsXG4gICAgICAgIHM7XG5cbiAgICBkYXRhLnN2ZyA9IHRhcmdldC5nZXRCQm94ICYmIChpID09PSBcIlRFWFRcIiB8fCBpID09PSBcIlRTUEFOXCIpO1xuXG4gICAgaWYgKCEoXCJpbm5lckhUTUxcIiBpbiB0YXJnZXQpICYmICFkYXRhLnN2Zykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGRhdGEudGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgaWYgKCEoXCJ2YWx1ZVwiIGluIHZhbHVlKSkge1xuICAgICAgZGF0YS50ZXh0ID0gZGF0YS5vcmlnaW5hbCA9IFtcIlwiXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvcmlnaW5hbCA9IHNwbGl0SW5uZXJIVE1MKHRhcmdldCwgZGVsaW1pdGVyLCBmYWxzZSwgcHJlc2VydmVTcGFjZXMpO1xuICAgIF90ZW1wRGl2IHx8IChfdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgIF90ZW1wRGl2LmlubmVySFRNTCA9IHZhbHVlLnZhbHVlO1xuICAgIHRleHQgPSBzcGxpdElubmVySFRNTChfdGVtcERpdiwgZGVsaW1pdGVyLCBmYWxzZSwgcHJlc2VydmVTcGFjZXMpO1xuICAgIGRhdGEuZnJvbSA9IHR3ZWVuLl9mcm9tO1xuXG4gICAgaWYgKChkYXRhLmZyb20gfHwgcnRsKSAmJiAhKHJ0bCAmJiBkYXRhLmZyb20pKSB7XG4gICAgICAvLyByaWdodC10by1sZWZ0IG9yIFwiZnJvbSgpXCIgdHdlZW5zIHNob3VsZCBpbnZlcnQgdGhpbmdzIChidXQgaWYgaXQncyBCT1RIIC5mcm9tKCkgYW5kIHJ0bCwgaW52ZXJ0aW5nIHR3aWNlIGVxdWFscyBub3QgaW52ZXJ0aW5nIGF0IGFsbCA6KVxuICAgICAgaSA9IG9yaWdpbmFsO1xuICAgICAgb3JpZ2luYWwgPSB0ZXh0O1xuICAgICAgdGV4dCA9IGk7XG4gICAgfVxuXG4gICAgZGF0YS5oYXNDbGFzcyA9ICEhKG5ld0NsYXNzIHx8IG9sZENsYXNzKTtcbiAgICBkYXRhLm5ld0NsYXNzID0gcnRsID8gb2xkQ2xhc3MgOiBuZXdDbGFzcztcbiAgICBkYXRhLm9sZENsYXNzID0gcnRsID8gbmV3Q2xhc3MgOiBvbGRDbGFzcztcbiAgICBpID0gb3JpZ2luYWwubGVuZ3RoIC0gdGV4dC5sZW5ndGg7XG4gICAgX3Nob3J0ID0gaSA8IDAgPyBvcmlnaW5hbCA6IHRleHQ7XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIGkgPSAtaTtcbiAgICB9XG5cbiAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgIF9zaG9ydC5wdXNoKGZpbGxDaGFyKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJkaWZmXCIpIHtcbiAgICAgIGogPSAwO1xuICAgICAgY29uZGVuc2VkVGV4dCA9IFtdO1xuICAgICAgY29uZGVuc2VkT3JpZ2luYWwgPSBbXTtcbiAgICAgIGFnZ3JlZ2F0ZSA9IFwiXCI7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHMgPSB0ZXh0W2ldO1xuXG4gICAgICAgIGlmIChzID09PSBvcmlnaW5hbFtpXSkge1xuICAgICAgICAgIGFnZ3JlZ2F0ZSArPSBzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbmRlbnNlZFRleHRbal0gPSBhZ2dyZWdhdGUgKyBzO1xuICAgICAgICAgIGNvbmRlbnNlZE9yaWdpbmFsW2orK10gPSBhZ2dyZWdhdGUgKyBvcmlnaW5hbFtpXTtcbiAgICAgICAgICBhZ2dyZWdhdGUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRleHQgPSBjb25kZW5zZWRUZXh0O1xuICAgICAgb3JpZ2luYWwgPSBjb25kZW5zZWRPcmlnaW5hbDtcblxuICAgICAgaWYgKGFnZ3JlZ2F0ZSkge1xuICAgICAgICB0ZXh0LnB1c2goYWdncmVnYXRlKTtcbiAgICAgICAgb3JpZ2luYWwucHVzaChhZ2dyZWdhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbHVlLnNwZWVkICYmIHR3ZWVuLmR1cmF0aW9uKE1hdGgubWluKDAuMDUgLyB2YWx1ZS5zcGVlZCAqIF9zaG9ydC5sZW5ndGgsIHZhbHVlLm1heER1cmF0aW9uIHx8IDk5OTkpKTtcbiAgICBkYXRhLnJ0bCA9IHJ0bDtcbiAgICBkYXRhLm9yaWdpbmFsID0gb3JpZ2luYWw7XG4gICAgZGF0YS50ZXh0ID0gdGV4dDtcblxuICAgIGRhdGEuX3Byb3BzLnB1c2goXCJ0ZXh0XCIpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyYXRpbywgZGF0YSkge1xuICAgIGlmIChyYXRpbyA+IDEpIHtcbiAgICAgIHJhdGlvID0gMTtcbiAgICB9IGVsc2UgaWYgKHJhdGlvIDwgMCkge1xuICAgICAgcmF0aW8gPSAwO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmZyb20pIHtcbiAgICAgIHJhdGlvID0gMSAtIHJhdGlvO1xuICAgIH1cblxuICAgIHZhciB0ZXh0ID0gZGF0YS50ZXh0LFxuICAgICAgICBoYXNDbGFzcyA9IGRhdGEuaGFzQ2xhc3MsXG4gICAgICAgIG5ld0NsYXNzID0gZGF0YS5uZXdDbGFzcyxcbiAgICAgICAgb2xkQ2xhc3MgPSBkYXRhLm9sZENsYXNzLFxuICAgICAgICBkZWxpbWl0ZXIgPSBkYXRhLmRlbGltaXRlcixcbiAgICAgICAgdGFyZ2V0ID0gZGF0YS50YXJnZXQsXG4gICAgICAgIGZpbGxDaGFyID0gZGF0YS5maWxsQ2hhcixcbiAgICAgICAgb3JpZ2luYWwgPSBkYXRhLm9yaWdpbmFsLFxuICAgICAgICBydGwgPSBkYXRhLnJ0bCxcbiAgICAgICAgbCA9IHRleHQubGVuZ3RoLFxuICAgICAgICBpID0gKHJ0bCA/IDEgLSByYXRpbyA6IHJhdGlvKSAqIGwgKyAwLjUgfCAwLFxuICAgICAgICBhcHBseU5ldyxcbiAgICAgICAgYXBwbHlPbGQsXG4gICAgICAgIHN0cjtcblxuICAgIGlmIChoYXNDbGFzcyAmJiByYXRpbykge1xuICAgICAgYXBwbHlOZXcgPSBuZXdDbGFzcyAmJiBpO1xuICAgICAgYXBwbHlPbGQgPSBvbGRDbGFzcyAmJiBpICE9PSBsO1xuICAgICAgc3RyID0gKGFwcGx5TmV3ID8gXCI8c3BhbiBjbGFzcz0nXCIgKyBuZXdDbGFzcyArIFwiJz5cIiA6IFwiXCIpICsgdGV4dC5zbGljZSgwLCBpKS5qb2luKGRlbGltaXRlcikgKyAoYXBwbHlOZXcgPyBcIjwvc3Bhbj5cIiA6IFwiXCIpICsgKGFwcGx5T2xkID8gXCI8c3BhbiBjbGFzcz0nXCIgKyBvbGRDbGFzcyArIFwiJz5cIiA6IFwiXCIpICsgZGVsaW1pdGVyICsgb3JpZ2luYWwuc2xpY2UoaSkuam9pbihkZWxpbWl0ZXIpICsgKGFwcGx5T2xkID8gXCI8L3NwYW4+XCIgOiBcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gdGV4dC5zbGljZSgwLCBpKS5qb2luKGRlbGltaXRlcikgKyBkZWxpbWl0ZXIgKyBvcmlnaW5hbC5zbGljZShpKS5qb2luKGRlbGltaXRlcik7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuc3ZnKSB7XG4gICAgICAvL1NWRyB0ZXh0IGVsZW1lbnRzIGRvbid0IGhhdmUgYW4gXCJpbm5lckhUTUxcIiBpbiBNaWNyb3NvZnQgYnJvd3NlcnMuXG4gICAgICB0YXJnZXQudGV4dENvbnRlbnQgPSBzdHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5pbm5lckhUTUwgPSBmaWxsQ2hhciA9PT0gXCImbmJzcDtcIiAmJiB+c3RyLmluZGV4T2YoXCIgIFwiKSA/IHN0ci5zcGxpdChcIiAgXCIpLmpvaW4oXCImbmJzcDsmbmJzcDtcIikgOiBzdHI7XG4gICAgfVxuICB9XG59O1xuVGV4dFBsdWdpbi5zcGxpdElubmVySFRNTCA9IHNwbGl0SW5uZXJIVE1MO1xuVGV4dFBsdWdpbi5lbW9qaVNhZmVTcGxpdCA9IGVtb2ppU2FmZVNwbGl0O1xuVGV4dFBsdWdpbi5nZXRUZXh0ID0gZ2V0VGV4dDtcbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihUZXh0UGx1Z2luKTtcbmV4cG9ydCB7IFRleHRQbHVnaW4gYXMgZGVmYXVsdCB9OyJdLCJuYW1lcyI6WyJlbW9qaVNhZmVTcGxpdCIsImdldFRleHQiLCJzcGxpdElubmVySFRNTCIsImdzYXAiLCJfdGVtcERpdiIsIl9nZXRHU0FQIiwid2luZG93IiwicmVnaXN0ZXJQbHVnaW4iLCJUZXh0UGx1Z2luIiwidmVyc2lvbiIsIm5hbWUiLCJpbml0IiwidGFyZ2V0IiwidmFsdWUiLCJ0d2VlbiIsImkiLCJub2RlTmFtZSIsInRvVXBwZXJDYXNlIiwiZGF0YSIsIl92YWx1ZSIsIm5ld0NsYXNzIiwib2xkQ2xhc3MiLCJwcmVzZXJ2ZVNwYWNlcyIsInJ0bCIsImRlbGltaXRlciIsImZpbGxDaGFyIiwicGFkU3BhY2UiLCJfc2hvcnQiLCJ0ZXh0Iiwib3JpZ2luYWwiLCJqIiwiY29uZGVuc2VkVGV4dCIsImNvbmRlbnNlZE9yaWdpbmFsIiwiYWdncmVnYXRlIiwicyIsInN2ZyIsImdldEJCb3giLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbm5lckhUTUwiLCJmcm9tIiwiX2Zyb20iLCJoYXNDbGFzcyIsImxlbmd0aCIsInB1c2giLCJ0eXBlIiwic3BlZWQiLCJkdXJhdGlvbiIsIk1hdGgiLCJtaW4iLCJtYXhEdXJhdGlvbiIsIl9wcm9wcyIsInJlbmRlciIsInJhdGlvIiwibCIsImFwcGx5TmV3IiwiYXBwbHlPbGQiLCJzdHIiLCJzbGljZSIsImpvaW4iLCJ0ZXh0Q29udGVudCIsImluZGV4T2YiLCJzcGxpdCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/TextPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/all.js":
/*!*****************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/all.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Back: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Back; },\n/* harmony export */   Bounce: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Bounce; },\n/* harmony export */   CSSPlugin: function() { return /* reexport safe */ _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   CSSRulePlugin: function() { return /* reexport safe */ _CSSRulePlugin_js__WEBPACK_IMPORTED_MODULE_4__.CSSRulePlugin; },\n/* harmony export */   Circ: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Circ; },\n/* harmony export */   Cubic: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Cubic; },\n/* harmony export */   CustomEase: function() { return /* reexport safe */ _CustomEase_js__WEBPACK_IMPORTED_MODULE_2__.CustomEase; },\n/* harmony export */   Draggable: function() { return /* reexport safe */ _Draggable_js__WEBPACK_IMPORTED_MODULE_3__.Draggable; },\n/* harmony export */   EasePack: function() { return /* reexport safe */ _EasePack_js__WEBPACK_IMPORTED_MODULE_6__.EasePack; },\n/* harmony export */   EaselPlugin: function() { return /* reexport safe */ _EaselPlugin_js__WEBPACK_IMPORTED_MODULE_5__.EaselPlugin; },\n/* harmony export */   Elastic: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Elastic; },\n/* harmony export */   Expo: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Expo; },\n/* harmony export */   ExpoScaleEase: function() { return /* reexport safe */ _EasePack_js__WEBPACK_IMPORTED_MODULE_6__.ExpoScaleEase; },\n/* harmony export */   Flip: function() { return /* reexport safe */ _Flip_js__WEBPACK_IMPORTED_MODULE_7__.Flip; },\n/* harmony export */   Linear: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Linear; },\n/* harmony export */   MotionPathPlugin: function() { return /* reexport safe */ _MotionPathPlugin_js__WEBPACK_IMPORTED_MODULE_8__.MotionPathPlugin; },\n/* harmony export */   Observer: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__.Observer; },\n/* harmony export */   PixiPlugin: function() { return /* reexport safe */ _PixiPlugin_js__WEBPACK_IMPORTED_MODULE_10__.PixiPlugin; },\n/* harmony export */   Power0: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power0; },\n/* harmony export */   Power1: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power1; },\n/* harmony export */   Power2: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power2; },\n/* harmony export */   Power3: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power3; },\n/* harmony export */   Power4: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power4; },\n/* harmony export */   Quad: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quad; },\n/* harmony export */   Quart: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quart; },\n/* harmony export */   Quint: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quint; },\n/* harmony export */   RoughEase: function() { return /* reexport safe */ _EasePack_js__WEBPACK_IMPORTED_MODULE_6__.RoughEase; },\n/* harmony export */   ScrollToPlugin: function() { return /* reexport safe */ _ScrollToPlugin_js__WEBPACK_IMPORTED_MODULE_11__.ScrollToPlugin; },\n/* harmony export */   ScrollTrigger: function() { return /* reexport safe */ _ScrollTrigger_js__WEBPACK_IMPORTED_MODULE_12__.ScrollTrigger; },\n/* harmony export */   Sine: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Sine; },\n/* harmony export */   SlowMo: function() { return /* reexport safe */ _EasePack_js__WEBPACK_IMPORTED_MODULE_6__.SlowMo; },\n/* harmony export */   SteppedEase: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.SteppedEase; },\n/* harmony export */   Strong: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Strong; },\n/* harmony export */   TextPlugin: function() { return /* reexport safe */ _TextPlugin_js__WEBPACK_IMPORTED_MODULE_13__.TextPlugin; },\n/* harmony export */   TimelineLite: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineLite; },\n/* harmony export */   TimelineMax: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineMax; },\n/* harmony export */   TweenLite: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TweenLite; },\n/* harmony export */   TweenMax: function() { return /* binding */ TweenMaxWithCSS; },\n/* harmony export */   _getProxyProp: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__._getProxyProp; },\n/* harmony export */   _getScrollFunc: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__._getScrollFunc; },\n/* harmony export */   _getTarget: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__._getTarget; },\n/* harmony export */   _getVelocityProp: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__._getVelocityProp; },\n/* harmony export */   _horizontal: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__._horizontal; },\n/* harmony export */   _isViewport: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__._isViewport; },\n/* harmony export */   _proxies: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__._proxies; },\n/* harmony export */   _scrollers: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__._scrollers; },\n/* harmony export */   _vertical: function() { return /* reexport safe */ _Observer_js__WEBPACK_IMPORTED_MODULE_9__._vertical; },\n/* harmony export */   clamp: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.clamp; },\n/* harmony export */   \"default\": function() { return /* binding */ gsapWithCSS; },\n/* harmony export */   distribute: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.distribute; },\n/* harmony export */   getUnit: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit; },\n/* harmony export */   gsap: function() { return /* binding */ gsapWithCSS; },\n/* harmony export */   interpolate: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.interpolate; },\n/* harmony export */   mapRange: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.mapRange; },\n/* harmony export */   normalize: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.normalize; },\n/* harmony export */   pipe: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.pipe; },\n/* harmony export */   random: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.random; },\n/* harmony export */   selector: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.selector; },\n/* harmony export */   shuffle: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.shuffle; },\n/* harmony export */   snap: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.snap; },\n/* harmony export */   splitColor: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.splitColor; },\n/* harmony export */   toArray: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.toArray; },\n/* harmony export */   unitize: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.unitize; },\n/* harmony export */   wrap: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.wrap; },\n/* harmony export */   wrapYoyo: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.wrapYoyo; }\n/* harmony export */ });\n/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/gsap-core.js\");\n/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSPlugin.js\");\n/* harmony import */ var _CustomEase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CustomEase.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CustomEase.js\");\n/* harmony import */ var _Draggable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Draggable.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Draggable.js\");\n/* harmony import */ var _CSSRulePlugin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CSSRulePlugin.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSRulePlugin.js\");\n/* harmony import */ var _EaselPlugin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EaselPlugin.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/EaselPlugin.js\");\n/* harmony import */ var _EasePack_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./EasePack.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/EasePack.js\");\n/* harmony import */ var _Flip_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Flip.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Flip.js\");\n/* harmony import */ var _MotionPathPlugin_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./MotionPathPlugin.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/MotionPathPlugin.js\");\n/* harmony import */ var _Observer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Observer.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Observer.js\");\n/* harmony import */ var _PixiPlugin_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./PixiPlugin.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/PixiPlugin.js\");\n/* harmony import */ var _ScrollToPlugin_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ScrollToPlugin.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollToPlugin.js\");\n/* harmony import */ var _ScrollTrigger_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ScrollTrigger.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollTrigger.js\");\n/* harmony import */ var _TextPlugin_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./TextPlugin.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/TextPlugin.js\");\n\n\nvar gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"], // to protect from tree shaking\nTweenMaxWithCSS = gsapWithCSS.core.Tween;\n\n\n\n\n\n\n\n\n\n\n\n\n\n //BONUS EXPORTS\n // export * from \"./DrawSVGPlugin.js\";\n // export * from \"./Physics2DPlugin.js\";\n // export * from \"./PhysicsPropsPlugin.js\";\n // export * from \"./ScrambleTextPlugin.js\";\n // export * from \"./CustomBounce.js\";\n // export * from \"./CustomWiggle.js\";\n // export * from \"./GSDevTools.js\";\n // export * from \"./InertiaPlugin.js\";\n // export * from \"./MorphSVGPlugin.js\";\n // export * from \"./MotionPathHelper.js\";\n // export * from \"./ScrollSmoother.js\";\n // export * from \"./SplitText.js\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9hbGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrQztBQUNLO0FBQ3ZDLElBQUlFLGNBQWNGLHFEQUFJQSxDQUFDRyxjQUFjLENBQUNGLHFEQUFTQSxLQUFLRCxxREFBSUEsRUFDcEQsK0JBQStCO0FBQ25DSSxrQkFBa0JGLFlBQVlHLElBQUksQ0FBQ0MsS0FBSztBQUN1RDtBQUNtUTtBQUNsVTtBQUNEO0FBQ0k7QUFDRjtBQUNIO0FBQ0o7QUFDWTtBQUNSO0FBQ0U7QUFDSTtBQUNEO0FBQ0gsQ0FBQyxlQUFlO0NBQ2hELHNDQUFzQztDQUN0Qyx3Q0FBd0M7Q0FDeEMsMkNBQTJDO0NBQzNDLDJDQUEyQztDQUMzQyxxQ0FBcUM7Q0FDckMscUNBQXFDO0NBQ3JDLG1DQUFtQztDQUNuQyxzQ0FBc0M7Q0FDdEMsdUNBQXVDO0NBQ3ZDLHlDQUF5QztDQUN6Qyx1Q0FBdUM7Q0FDdkMsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9hbGwuanM/MDFhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ3NhcCBmcm9tIFwiLi9nc2FwLWNvcmUuanNcIjtcbmltcG9ydCBDU1NQbHVnaW4gZnJvbSBcIi4vQ1NTUGx1Z2luLmpzXCI7XG52YXIgZ3NhcFdpdGhDU1MgPSBnc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1BsdWdpbikgfHwgZ3NhcCxcbiAgICAvLyB0byBwcm90ZWN0IGZyb20gdHJlZSBzaGFraW5nXG5Ud2Vlbk1heFdpdGhDU1MgPSBnc2FwV2l0aENTUy5jb3JlLlR3ZWVuO1xuZXhwb3J0IHsgZ3NhcFdpdGhDU1MgYXMgZ3NhcCwgZ3NhcFdpdGhDU1MgYXMgZGVmYXVsdCwgVHdlZW5NYXhXaXRoQ1NTIGFzIFR3ZWVuTWF4LCBDU1NQbHVnaW4gfTtcbmV4cG9ydCB7IFR3ZWVuTGl0ZSwgVGltZWxpbmVNYXgsIFRpbWVsaW5lTGl0ZSwgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjLCB3cmFwLCB3cmFwWW95bywgZGlzdHJpYnV0ZSwgcmFuZG9tLCBzbmFwLCBub3JtYWxpemUsIGdldFVuaXQsIGNsYW1wLCBzcGxpdENvbG9yLCB0b0FycmF5LCBtYXBSYW5nZSwgcGlwZSwgdW5pdGl6ZSwgaW50ZXJwb2xhdGUsIHNodWZmbGUsIHNlbGVjdG9yIH0gZnJvbSBcIi4vZ3NhcC1jb3JlLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9DdXN0b21FYXNlLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9EcmFnZ2FibGUuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0NTU1J1bGVQbHVnaW4uanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0Vhc2VsUGx1Z2luLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9FYXNlUGFjay5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vRmxpcC5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vTW90aW9uUGF0aFBsdWdpbi5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vT2JzZXJ2ZXIuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1BpeGlQbHVnaW4uanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1Njcm9sbFRvUGx1Z2luLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9TY3JvbGxUcmlnZ2VyLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9UZXh0UGx1Z2luLmpzXCI7IC8vQk9OVVMgRVhQT1JUU1xuLy8gZXhwb3J0ICogZnJvbSBcIi4vRHJhd1NWR1BsdWdpbi5qc1wiO1xuLy8gZXhwb3J0ICogZnJvbSBcIi4vUGh5c2ljczJEUGx1Z2luLmpzXCI7XG4vLyBleHBvcnQgKiBmcm9tIFwiLi9QaHlzaWNzUHJvcHNQbHVnaW4uanNcIjtcbi8vIGV4cG9ydCAqIGZyb20gXCIuL1NjcmFtYmxlVGV4dFBsdWdpbi5qc1wiO1xuLy8gZXhwb3J0ICogZnJvbSBcIi4vQ3VzdG9tQm91bmNlLmpzXCI7XG4vLyBleHBvcnQgKiBmcm9tIFwiLi9DdXN0b21XaWdnbGUuanNcIjtcbi8vIGV4cG9ydCAqIGZyb20gXCIuL0dTRGV2VG9vbHMuanNcIjtcbi8vIGV4cG9ydCAqIGZyb20gXCIuL0luZXJ0aWFQbHVnaW4uanNcIjtcbi8vIGV4cG9ydCAqIGZyb20gXCIuL01vcnBoU1ZHUGx1Z2luLmpzXCI7XG4vLyBleHBvcnQgKiBmcm9tIFwiLi9Nb3Rpb25QYXRoSGVscGVyLmpzXCI7XG4vLyBleHBvcnQgKiBmcm9tIFwiLi9TY3JvbGxTbW9vdGhlci5qc1wiO1xuLy8gZXhwb3J0ICogZnJvbSBcIi4vU3BsaXRUZXh0LmpzXCI7Il0sIm5hbWVzIjpbImdzYXAiLCJDU1NQbHVnaW4iLCJnc2FwV2l0aENTUyIsInJlZ2lzdGVyUGx1Z2luIiwiVHdlZW5NYXhXaXRoQ1NTIiwiY29yZSIsIlR3ZWVuIiwiZGVmYXVsdCIsIlR3ZWVuTWF4IiwiVHdlZW5MaXRlIiwiVGltZWxpbmVNYXgiLCJUaW1lbGluZUxpdGUiLCJQb3dlcjAiLCJQb3dlcjEiLCJQb3dlcjIiLCJQb3dlcjMiLCJQb3dlcjQiLCJMaW5lYXIiLCJRdWFkIiwiQ3ViaWMiLCJRdWFydCIsIlF1aW50IiwiU3Ryb25nIiwiRWxhc3RpYyIsIkJhY2siLCJTdGVwcGVkRWFzZSIsIkJvdW5jZSIsIlNpbmUiLCJFeHBvIiwiQ2lyYyIsIndyYXAiLCJ3cmFwWW95byIsImRpc3RyaWJ1dGUiLCJyYW5kb20iLCJzbmFwIiwibm9ybWFsaXplIiwiZ2V0VW5pdCIsImNsYW1wIiwic3BsaXRDb2xvciIsInRvQXJyYXkiLCJtYXBSYW5nZSIsInBpcGUiLCJ1bml0aXplIiwiaW50ZXJwb2xhdGUiLCJzaHVmZmxlIiwic2VsZWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/all.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/gsap-core.js":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/gsap-core.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animation: function() { return /* binding */ Animation; },\n/* harmony export */   Back: function() { return /* binding */ Back; },\n/* harmony export */   Bounce: function() { return /* binding */ Bounce; },\n/* harmony export */   Circ: function() { return /* binding */ Circ; },\n/* harmony export */   Cubic: function() { return /* binding */ Cubic; },\n/* harmony export */   Elastic: function() { return /* binding */ Elastic; },\n/* harmony export */   Expo: function() { return /* binding */ Expo; },\n/* harmony export */   GSCache: function() { return /* binding */ GSCache; },\n/* harmony export */   Linear: function() { return /* binding */ Linear; },\n/* harmony export */   Power0: function() { return /* binding */ Power0; },\n/* harmony export */   Power1: function() { return /* binding */ Power1; },\n/* harmony export */   Power2: function() { return /* binding */ Power2; },\n/* harmony export */   Power3: function() { return /* binding */ Power3; },\n/* harmony export */   Power4: function() { return /* binding */ Power4; },\n/* harmony export */   PropTween: function() { return /* binding */ PropTween; },\n/* harmony export */   Quad: function() { return /* binding */ Quad; },\n/* harmony export */   Quart: function() { return /* binding */ Quart; },\n/* harmony export */   Quint: function() { return /* binding */ Quint; },\n/* harmony export */   Sine: function() { return /* binding */ Sine; },\n/* harmony export */   SteppedEase: function() { return /* binding */ SteppedEase; },\n/* harmony export */   Strong: function() { return /* binding */ Strong; },\n/* harmony export */   Timeline: function() { return /* binding */ Timeline; },\n/* harmony export */   TimelineLite: function() { return /* binding */ Timeline; },\n/* harmony export */   TimelineMax: function() { return /* binding */ Timeline; },\n/* harmony export */   Tween: function() { return /* binding */ Tween; },\n/* harmony export */   TweenLite: function() { return /* binding */ Tween; },\n/* harmony export */   TweenMax: function() { return /* binding */ Tween; },\n/* harmony export */   _checkPlugin: function() { return /* binding */ _checkPlugin; },\n/* harmony export */   _colorExp: function() { return /* binding */ _colorExp; },\n/* harmony export */   _colorStringFilter: function() { return /* binding */ _colorStringFilter; },\n/* harmony export */   _config: function() { return /* binding */ _config; },\n/* harmony export */   _forEachName: function() { return /* binding */ _forEachName; },\n/* harmony export */   _getCache: function() { return /* binding */ _getCache; },\n/* harmony export */   _getProperty: function() { return /* binding */ _getProperty; },\n/* harmony export */   _getSetter: function() { return /* binding */ _getSetter; },\n/* harmony export */   _isString: function() { return /* binding */ _isString; },\n/* harmony export */   _isUndefined: function() { return /* binding */ _isUndefined; },\n/* harmony export */   _missingPlugin: function() { return /* binding */ _missingPlugin; },\n/* harmony export */   _numExp: function() { return /* binding */ _numExp; },\n/* harmony export */   _numWithUnitExp: function() { return /* binding */ _numWithUnitExp; },\n/* harmony export */   _parseRelative: function() { return /* binding */ _parseRelative; },\n/* harmony export */   _plugins: function() { return /* binding */ _plugins; },\n/* harmony export */   _relExp: function() { return /* binding */ _relExp; },\n/* harmony export */   _removeLinkedListItem: function() { return /* binding */ _removeLinkedListItem; },\n/* harmony export */   _renderComplexString: function() { return /* binding */ _renderComplexString; },\n/* harmony export */   _replaceRandom: function() { return /* binding */ _replaceRandom; },\n/* harmony export */   _round: function() { return /* binding */ _round; },\n/* harmony export */   _roundModifier: function() { return /* binding */ _roundModifier; },\n/* harmony export */   _setDefaults: function() { return /* binding */ _setDefaults; },\n/* harmony export */   _sortPropTweensByPriority: function() { return /* binding */ _sortPropTweensByPriority; },\n/* harmony export */   _ticker: function() { return /* binding */ _ticker; },\n/* harmony export */   clamp: function() { return /* binding */ clamp; },\n/* harmony export */   \"default\": function() { return /* binding */ gsap; },\n/* harmony export */   distribute: function() { return /* binding */ distribute; },\n/* harmony export */   getUnit: function() { return /* binding */ getUnit; },\n/* harmony export */   gsap: function() { return /* binding */ gsap; },\n/* harmony export */   interpolate: function() { return /* binding */ interpolate; },\n/* harmony export */   mapRange: function() { return /* binding */ mapRange; },\n/* harmony export */   normalize: function() { return /* binding */ normalize; },\n/* harmony export */   pipe: function() { return /* binding */ pipe; },\n/* harmony export */   random: function() { return /* binding */ random; },\n/* harmony export */   selector: function() { return /* binding */ selector; },\n/* harmony export */   shuffle: function() { return /* binding */ shuffle; },\n/* harmony export */   snap: function() { return /* binding */ snap; },\n/* harmony export */   splitColor: function() { return /* binding */ splitColor; },\n/* harmony export */   toArray: function() { return /* binding */ toArray; },\n/* harmony export */   unitize: function() { return /* binding */ unitize; },\n/* harmony export */   wrap: function() { return /* binding */ wrap; },\n/* harmony export */   wrapYoyo: function() { return /* binding */ wrapYoyo; }\n/* harmony export */ });\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n}\n/*!\n * GSAP 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var _config = {\n    autoSleep: 120,\n    force3D: \"auto\",\n    nullTargetWarn: 1,\n    units: {\n        lineHeight: \"\"\n    }\n}, _defaults = {\n    duration: .5,\n    overwrite: false,\n    delay: 0\n}, _suppressOverwrites, _reverting, _context, _bigNum = 1e8, _tinyNum = 1 / _bigNum, _2PI = Math.PI * 2, _HALF_PI = _2PI / 4, _gsID = 0, _sqrt = Math.sqrt, _cos = Math.cos, _sin = Math.sin, _isString = function _isString(value) {\n    return typeof value === \"string\";\n}, _isFunction = function _isFunction(value) {\n    return typeof value === \"function\";\n}, _isNumber = function _isNumber(value) {\n    return typeof value === \"number\";\n}, _isUndefined = function _isUndefined(value) {\n    return typeof value === \"undefined\";\n}, _isObject = function _isObject(value) {\n    return typeof value === \"object\";\n}, _isNotFalse = function _isNotFalse(value) {\n    return value !== false;\n}, _windowExists = function _windowExists() {\n    return typeof window !== \"undefined\";\n}, _isFuncOrString = function _isFuncOrString(value) {\n    return _isFunction(value) || _isString(value);\n}, _isTypedArray = typeof ArrayBuffer === \"function\" && ArrayBuffer.isView || function() {}, // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().\n_isArray = Array.isArray, _strictNumExp = /(?:-?\\.?\\d|\\.)+/gi, //only numbers (including negatives and decimals) but NOT relative values.\n_numExp = /[-+=.]*\\d+[.e\\-+]*\\d*[e\\-+]*\\d*/g, //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\n_numWithUnitExp = /[-+=.]*\\d+[.e-]*\\d*[a-z%]*/g, _complexStringNumExp = /[-+=.]*\\d+\\.?\\d*(?:e-|e\\+)?\\d*/gi, //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.\n_relExp = /[+-]=-?[.\\d]+/, _delimitedValueExp = /[^,'\"\\[\\]\\s]+/gi, // previously /[#\\-+.]*\\b[a-z\\d\\-=+%.]+/gi but didn't catch special characters.\n_unitExp = /^[+\\-=e\\s\\d]*\\d+[.\\d]*([a-z]*|%)\\s*$/i, _globalTimeline, _win, _coreInitted, _doc, _globals = {}, _installScope = {}, _coreReady, _install = function _install(scope) {\n    return (_installScope = _merge(scope, _globals)) && gsap;\n}, _missingPlugin = function _missingPlugin(property, value) {\n    return console.warn(\"Invalid property\", property, \"set to\", value, \"Missing plugin? gsap.registerPlugin()\");\n}, _warn = function _warn(message, suppress) {\n    return !suppress && console.warn(message);\n}, _addGlobal = function _addGlobal(name, obj) {\n    return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;\n}, _emptyFunc = function _emptyFunc() {\n    return 0;\n}, _startAtRevertConfig = {\n    suppressEvents: true,\n    isStart: true,\n    kill: false\n}, _revertConfigNoKill = {\n    suppressEvents: true,\n    kill: false\n}, _revertConfig = {\n    suppressEvents: true\n}, _reservedProps = {}, _lazyTweens = [], _lazyLookup = {}, _lastRenderedFrame, _plugins = {}, _effects = {}, _nextGCFrame = 30, _harnessPlugins = [], _callbackNames = \"\", _harness = function _harness(targets) {\n    var target = targets[0], harnessPlugin, i;\n    _isObject(target) || _isFunction(target) || (targets = [\n        targets\n    ]);\n    if (!(harnessPlugin = (target._gsap || {}).harness)) {\n        // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)\n        i = _harnessPlugins.length;\n        while(i-- && !_harnessPlugins[i].targetTest(target)){}\n        harnessPlugin = _harnessPlugins[i];\n    }\n    i = targets.length;\n    while(i--){\n        targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);\n    }\n    return targets;\n}, _getCache = function _getCache(target) {\n    return target._gsap || _harness(toArray(target))[0]._gsap;\n}, _getProperty = function _getProperty(target, property, v) {\n    return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;\n}, _forEachName = function _forEachName(names, func) {\n    return (names = names.split(\",\")).forEach(func) || names;\n}, //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).\n_round = function _round(value) {\n    return Math.round(value * 100000) / 100000 || 0;\n}, _roundPrecise = function _roundPrecise(value) {\n    return Math.round(value * 10000000) / 10000000 || 0;\n}, // increased precision mostly for timing values.\n_parseRelative = function _parseRelative(start, value) {\n    var operator = value.charAt(0), end = parseFloat(value.substr(2));\n    start = parseFloat(start);\n    return operator === \"+\" ? start + end : operator === \"-\" ? start - end : operator === \"*\" ? start * end : start / end;\n}, _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {\n    //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.\n    var l = toFind.length, i = 0;\n    for(; toSearch.indexOf(toFind[i]) < 0 && ++i < l;){}\n    return i < l;\n}, _lazyRender = function _lazyRender() {\n    var l = _lazyTweens.length, a = _lazyTweens.slice(0), i, tween;\n    _lazyLookup = {};\n    _lazyTweens.length = 0;\n    for(i = 0; i < l; i++){\n        tween = a[i];\n        tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);\n    }\n}, _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {\n    _lazyTweens.length && !_reverting && _lazyRender();\n    animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));\n    _lazyTweens.length && !_reverting && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.\n}, _numericIfPossible = function _numericIfPossible(value) {\n    var n = parseFloat(value);\n    return (n || n === 0) && (value + \"\").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;\n}, _passThrough = function _passThrough(p) {\n    return p;\n}, _setDefaults = function _setDefaults(obj, defaults) {\n    for(var p in defaults){\n        p in obj || (obj[p] = defaults[p]);\n    }\n    return obj;\n}, _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {\n    return function(obj, defaults) {\n        for(var p in defaults){\n            p in obj || p === \"duration\" && excludeDuration || p === \"ease\" || (obj[p] = defaults[p]);\n        }\n    };\n}, _merge = function _merge(base, toMerge) {\n    for(var p in toMerge){\n        base[p] = toMerge[p];\n    }\n    return base;\n}, _mergeDeep = function _mergeDeep(base, toMerge) {\n    for(var p in toMerge){\n        p !== \"__proto__\" && p !== \"constructor\" && p !== \"prototype\" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);\n    }\n    return base;\n}, _copyExcluding = function _copyExcluding(obj, excluding) {\n    var copy = {}, p;\n    for(p in obj){\n        p in excluding || (copy[p] = obj[p]);\n    }\n    return copy;\n}, _inheritDefaults = function _inheritDefaults(vars) {\n    var parent = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;\n    if (_isNotFalse(vars.inherit)) {\n        while(parent){\n            func(vars, parent.vars.defaults);\n            parent = parent.parent || parent._dp;\n        }\n    }\n    return vars;\n}, _arraysMatch = function _arraysMatch(a1, a2) {\n    var i = a1.length, match = i === a2.length;\n    while(match && i-- && a1[i] === a2[i]){}\n    return i < 0;\n}, _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {\n    if (firstProp === void 0) {\n        firstProp = \"_first\";\n    }\n    if (lastProp === void 0) {\n        lastProp = \"_last\";\n    }\n    var prev = parent[lastProp], t;\n    if (sortBy) {\n        t = child[sortBy];\n        while(prev && prev[sortBy] > t){\n            prev = prev._prev;\n        }\n    }\n    if (prev) {\n        child._next = prev._next;\n        prev._next = child;\n    } else {\n        child._next = parent[firstProp];\n        parent[firstProp] = child;\n    }\n    if (child._next) {\n        child._next._prev = child;\n    } else {\n        parent[lastProp] = child;\n    }\n    child._prev = prev;\n    child.parent = child._dp = parent;\n    return child;\n}, _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {\n    if (firstProp === void 0) {\n        firstProp = \"_first\";\n    }\n    if (lastProp === void 0) {\n        lastProp = \"_last\";\n    }\n    var prev = child._prev, next = child._next;\n    if (prev) {\n        prev._next = next;\n    } else if (parent[firstProp] === child) {\n        parent[firstProp] = next;\n    }\n    if (next) {\n        next._prev = prev;\n    } else if (parent[lastProp] === child) {\n        parent[lastProp] = prev;\n    }\n    child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.\n}, _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {\n    child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);\n    child._act = 0;\n}, _uncache = function _uncache(animation, child) {\n    if (animation && (!child || child._end > animation._dur || child._start < 0)) {\n        // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)\n        var a = animation;\n        while(a){\n            a._dirty = 1;\n            a = a.parent;\n        }\n    }\n    return animation;\n}, _recacheAncestors = function _recacheAncestors(animation) {\n    var parent = animation.parent;\n    while(parent && parent.parent){\n        //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.\n        parent._dirty = 1;\n        parent.totalDuration();\n        parent = parent.parent;\n    }\n    return animation;\n}, _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {\n    return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));\n}, _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {\n    return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);\n}, _elapsedCycleDuration = function _elapsedCycleDuration(animation) {\n    return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;\n}, // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.\n_animationCycle = function _animationCycle(tTime, cycleDuration) {\n    var whole = Math.floor(tTime /= cycleDuration);\n    return tTime && whole === tTime ? whole - 1 : whole;\n}, _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {\n    return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);\n}, _setEnd = function _setEnd(animation) {\n    return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));\n}, _alignPlayhead = function _alignPlayhead(animation, totalTime) {\n    // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.\n    var parent = animation._dp;\n    if (parent && parent.smoothChildTiming && animation._ts) {\n        animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));\n        _setEnd(animation);\n        parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.\n    }\n    return animation;\n}, /*\n_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {\n\tlet cycleDuration = duration + repeatDelay,\n\t\ttime = _round(clampedTotalTime % cycleDuration);\n\tif (time > duration) {\n\t\ttime = duration;\n\t}\n\treturn (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;\n},\n*/ _postAddChecks = function _postAddChecks(timeline, child) {\n    var t;\n    if (child._time || !child._dur && child._initted || child._start < timeline._time && (child._dur || !child.add)) {\n        // in case, for example, the _start is moved on a tween that has already rendered, or if it's being inserted into a timeline BEFORE where the playhead is currently. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning. Special case: if it's a timeline (has .add() method) and no duration, we can skip rendering because the user may be populating it AFTER adding it to a parent timeline (unconventional, but possible, and we wouldn't want it to get removed if the parent's autoRemoveChildren is true).\n        t = _parentToChildTotalTime(timeline.rawTime(), child);\n        if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {\n            child.render(t, true);\n        }\n    } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.\n    if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {\n        //in case any of the ancestors had completed but should now be enabled...\n        if (timeline._dur < timeline.duration()) {\n            t = timeline;\n            while(t._dp){\n                t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.\n                t = t._dp;\n            }\n        }\n        timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.\n    }\n}, _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {\n    child.parent && _removeFromParent(child);\n    child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);\n    child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));\n    _addLinkedListItem(timeline, child, \"_first\", \"_last\", timeline._sort ? \"_start\" : 0);\n    _isFromOrFromStart(child) || (timeline._recent = child);\n    skipChecks || _postAddChecks(timeline, child);\n    timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime); // if the timeline is reversed and the new child makes it longer, we may need to adjust the parent's _start (push it back)\n    return timeline;\n}, _scrollTrigger = function _scrollTrigger(animation, trigger) {\n    return (_globals.ScrollTrigger || _missingPlugin(\"scrollTrigger\", trigger)) && _globals.ScrollTrigger.create(trigger, animation);\n}, _attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {\n    _initTween(tween, time, tTime);\n    if (!tween._initted) {\n        return 1;\n    }\n    if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {\n        _lazyTweens.push(tween);\n        tween._lazy = [\n            tTime,\n            suppressEvents\n        ];\n        return 1;\n    }\n}, _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {\n    var parent = _ref.parent;\n    return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));\n}, // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0\n_isFromOrFromStart = function _isFromOrFromStart(_ref2) {\n    var data = _ref2.data;\n    return data === \"isFromStart\" || data === \"isStart\";\n}, _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {\n    var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the \"startAt\" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any \"from\" and \"fromTo\" startAt tweens are rendered the first time at a ratio of 1.\n    repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;\n    if (repeatDelay && tween._repeat) {\n        // in case there's a zero-duration tween that has a repeat with a repeatDelay\n        tTime = _clamp(0, tween._tDur, totalTime);\n        iteration = _animationCycle(tTime, repeatDelay);\n        tween._yoyo && iteration & 1 && (ratio = 1 - ratio);\n        if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {\n            // if iteration changed\n            prevRatio = 1 - ratio;\n            tween.vars.repeatRefresh && tween._initted && tween.invalidate();\n        }\n    }\n    if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {\n        if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {\n            // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.\n            return;\n        }\n        prevIteration = tween._zTime;\n        tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\n        suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.\n        tween.ratio = ratio;\n        tween._from && (ratio = 1 - ratio);\n        tween._time = 0;\n        tween._tTime = tTime;\n        pt = tween._pt;\n        while(pt){\n            pt.r(ratio, pt.d);\n            pt = pt._next;\n        }\n        totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);\n        tween._onUpdate && !suppressEvents && _callback(tween, \"onUpdate\");\n        tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, \"onRepeat\");\n        if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {\n            ratio && _removeFromParent(tween, 1);\n            if (!suppressEvents && !_reverting) {\n                _callback(tween, ratio ? \"onComplete\" : \"onReverseComplete\", true);\n                tween._prom && tween._prom();\n            }\n        }\n    } else if (!tween._zTime) {\n        tween._zTime = totalTime;\n    }\n}, _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {\n    var child;\n    if (time > prevTime) {\n        child = animation._first;\n        while(child && child._start <= time){\n            if (child.data === \"isPause\" && child._start > prevTime) {\n                return child;\n            }\n            child = child._next;\n        }\n    } else {\n        child = animation._last;\n        while(child && child._start >= time){\n            if (child.data === \"isPause\" && child._start < prevTime) {\n                return child;\n            }\n            child = child._prev;\n        }\n    }\n}, _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {\n    var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;\n    totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);\n    animation._dur = dur;\n    animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);\n    totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);\n    animation.parent && _setEnd(animation);\n    skipUncache || _uncache(animation.parent, animation);\n    return animation;\n}, _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {\n    return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);\n}, _zeroPosition = {\n    _start: 0,\n    endTime: _emptyFunc,\n    totalDuration: _emptyFunc\n}, _parsePosition = function _parsePosition(animation, position, percentAnimation) {\n    var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.\n    i, offset, isPercent;\n    if (_isString(position) && (isNaN(position) || position in labels)) {\n        //if the string is a number like \"1\", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).\n        offset = position.charAt(0);\n        isPercent = position.substr(-1) === \"%\";\n        i = position.indexOf(\"=\");\n        if (offset === \"<\" || offset === \">\") {\n            i >= 0 && (position = position.replace(/=/, \"\"));\n            return (offset === \"<\" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);\n        }\n        if (i < 0) {\n            position in labels || (labels[position] = clippedDuration);\n            return labels[position];\n        }\n        offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));\n        if (isPercent && percentAnimation) {\n            offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();\n        }\n        return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;\n    }\n    return position == null ? clippedDuration : +position;\n}, _createTweenType = function _createTweenType(type, params, timeline) {\n    var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent;\n    isLegacy && (vars.duration = params[1]);\n    vars.parent = timeline;\n    if (type) {\n        irVars = vars;\n        parent = timeline;\n        while(parent && !(\"immediateRender\" in irVars)){\n            // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.\n            irVars = parent.vars.defaults || {};\n            parent = _isNotFalse(parent.vars.inherit) && parent.parent;\n        }\n        vars.immediateRender = _isNotFalse(irVars.immediateRender);\n        type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // \"from\" vars\n    }\n    return new Tween(params[0], vars, params[varsIndex + 1]);\n}, _conditionalReturn = function _conditionalReturn(value, func) {\n    return value || value === 0 ? func(value) : func;\n}, _clamp = function _clamp(min, max, value) {\n    return value < min ? min : value > max ? max : value;\n}, getUnit = function getUnit(value, v) {\n    return !_isString(value) || !(v = _unitExp.exec(value)) ? \"\" : v[1];\n}, // note: protect against padded numbers as strings, like \"100.100\". That shouldn't return \"00\" as the unit. If it's numeric, return no unit.\nclamp = function clamp(min, max, value) {\n    return _conditionalReturn(value, function(v) {\n        return _clamp(min, max, v);\n    });\n}, _slice = [].slice, _isArrayLike = function _isArrayLike(value, nonEmpty) {\n    return value && _isObject(value) && \"length\" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;\n}, _flatten = function _flatten(ar, leaveStrings, accumulator) {\n    if (accumulator === void 0) {\n        accumulator = [];\n    }\n    return ar.forEach(function(value) {\n        var _accumulator;\n        return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);\n    }) || accumulator;\n}, //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.\ntoArray = function toArray(value, scope, leaveStrings) {\n    return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [\n        value\n    ] : [];\n}, selector = function selector(value) {\n    value = toArray(value)[0] || _warn(\"Invalid scope\") || {};\n    return function(v) {\n        var el = value.current || value.nativeElement || value;\n        return toArray(v, el.querySelectorAll ? el : el === value ? _warn(\"Invalid scope\") || _doc.createElement(\"div\") : value);\n    };\n}, shuffle = function shuffle(a) {\n    return a.sort(function() {\n        return .5 - Math.random();\n    });\n}, // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;\n//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following\ndistribute = function distribute(v) {\n    if (_isFunction(v)) {\n        return v;\n    }\n    var vars = _isObject(v) ? v : {\n        each: v\n    }, //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total \"amount\" that's chunked out among them all.\n    ease = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;\n    if (_isString(from)) {\n        ratioX = ratioY = ({\n            center: .5,\n            edges: .5,\n            end: 1\n        })[from] || 0;\n    } else if (!isDecimal && ratios) {\n        ratioX = from[0];\n        ratioY = from[1];\n    }\n    return function(i, target, a) {\n        var l = (a || vars).length, distances = cache[l], originX, originY, x, y, d, j, max, min, wrapAt;\n        if (!distances) {\n            wrapAt = vars.grid === \"auto\" ? 0 : (vars.grid || [\n                1,\n                _bigNum\n            ])[1];\n            if (!wrapAt) {\n                max = -_bigNum;\n                while(max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l){}\n                wrapAt < l && wrapAt--;\n            }\n            distances = cache[l] = [];\n            originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;\n            originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;\n            max = 0;\n            min = _bigNum;\n            for(j = 0; j < l; j++){\n                x = j % wrapAt - originX;\n                y = originY - (j / wrapAt | 0);\n                distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === \"y\" ? y : x);\n                d > max && (max = d);\n                d < min && (min = d);\n            }\n            from === \"random\" && shuffle(distances);\n            distances.max = max - min;\n            distances.min = min;\n            distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === \"y\" ? l / wrapAt : wrapAt) || 0) * (from === \"edges\" ? -1 : 1);\n            distances.b = l < 0 ? base - l : base;\n            distances.u = getUnit(vars.amount || vars.each) || 0; //unit\n            ease = ease && l < 0 ? _invertEase(ease) : ease;\n        }\n        l = (distances[i] - distances.min) / distances.max || 0;\n        return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors\n    };\n}, _roundModifier = function _roundModifier(v) {\n    //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.\n    var p = Math.pow(10, ((v + \"\").split(\".\")[1] || \"\").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())\n    return function(raw) {\n        var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);\n        return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!\n    };\n}, snap = function snap(snapTo, value) {\n    var isArray = _isArray(snapTo), radius, is2D;\n    if (!isArray && _isObject(snapTo)) {\n        radius = isArray = snapTo.radius || _bigNum;\n        if (snapTo.values) {\n            snapTo = toArray(snapTo.values);\n            if (is2D = !_isNumber(snapTo[0])) {\n                radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.\n            }\n        } else {\n            snapTo = _roundModifier(snapTo.increment);\n        }\n    }\n    return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {\n        is2D = snapTo(raw);\n        return Math.abs(is2D - raw) <= radius ? is2D : raw;\n    } : function(raw) {\n        var x = parseFloat(is2D ? raw.x : raw), y = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest = 0, i = snapTo.length, dx, dy;\n        while(i--){\n            if (is2D) {\n                dx = snapTo[i].x - x;\n                dy = snapTo[i].y - y;\n                dx = dx * dx + dy * dy;\n            } else {\n                dx = Math.abs(snapTo[i] - x);\n            }\n            if (dx < min) {\n                min = dx;\n                closest = i;\n            }\n        }\n        closest = !radius || min <= radius ? snapTo[closest] : raw;\n        return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);\n    });\n}, random = function random(min, max, roundingIncrement, returnFunction) {\n    return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {\n        return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + \"\").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;\n    });\n}, pipe = function pipe() {\n    for(var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++){\n        functions[_key] = arguments[_key];\n    }\n    return function(value) {\n        return functions.reduce(function(v, f) {\n            return f(v);\n        }, value);\n    };\n}, unitize = function unitize(func, unit) {\n    return function(value) {\n        return func(parseFloat(value)) + (unit || getUnit(value));\n    };\n}, normalize = function normalize(min, max, value) {\n    return mapRange(min, max, 0, 1, value);\n}, _wrapArray = function _wrapArray(a, wrapper, value) {\n    return _conditionalReturn(value, function(index) {\n        return a[~~wrapper(index)];\n    });\n}, wrap = function wrap(min, max, value) {\n    // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).\n    var range = max - min;\n    return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function(value) {\n        return (range + (value - min) % range) % range + min;\n    });\n}, wrapYoyo = function wrapYoyo(min, max, value) {\n    var range = max - min, total = range * 2;\n    return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function(value) {\n        value = (total + (value - min) % total) % total || 0;\n        return min + (value > range ? total - value : value);\n    });\n}, _replaceRandom = function _replaceRandom(value) {\n    //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])\n    var prev = 0, s = \"\", i, nums, end, isArray;\n    while(~(i = value.indexOf(\"random(\", prev))){\n        end = value.indexOf(\")\", i);\n        isArray = value.charAt(i + 7) === \"[\";\n        nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);\n        s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);\n        prev = end + 1;\n    }\n    return s + value.substr(prev, value.length - prev);\n}, mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {\n    var inRange = inMax - inMin, outRange = outMax - outMin;\n    return _conditionalReturn(value, function(value) {\n        return outMin + ((value - inMin) / inRange * outRange || 0);\n    });\n}, interpolate = function interpolate(start, end, progress, mutate) {\n    var func = isNaN(start + end) ? 0 : function func(p) {\n        return (1 - p) * start + p * end;\n    };\n    if (!func) {\n        var isString = _isString(start), master = {}, p, i, interpolators, l, il;\n        progress === true && (mutate = 1) && (progress = null);\n        if (isString) {\n            start = {\n                p: start\n            };\n            end = {\n                p: end\n            };\n        } else if (_isArray(start) && !_isArray(end)) {\n            interpolators = [];\n            l = start.length;\n            il = l - 2;\n            for(i = 1; i < l; i++){\n                interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.\n            }\n            l--;\n            func = function func(p) {\n                p *= l;\n                var i = Math.min(il, ~~p);\n                return interpolators[i](p - i);\n            };\n            progress = end;\n        } else if (!mutate) {\n            start = _merge(_isArray(start) ? [] : {}, start);\n        }\n        if (!interpolators) {\n            for(p in end){\n                _addPropTween.call(master, start, p, \"get\", end[p]);\n            }\n            func = function func(p) {\n                return _renderPropTweens(p, master) || (isString ? start.p : start);\n            };\n        }\n    }\n    return _conditionalReturn(progress, func);\n}, _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {\n    //used for nextLabel() and previousLabel()\n    var labels = timeline.labels, min = _bigNum, p, distance, label;\n    for(p in labels){\n        distance = labels[p] - fromTime;\n        if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {\n            label = p;\n            min = distance;\n        }\n    }\n    return label;\n}, _callback = function _callback(animation, type, executeLazyFirst) {\n    var v = animation.vars, callback = v[type], prevContext = _context, context = animation._ctx, params, scope, result;\n    if (!callback) {\n        return;\n    }\n    params = v[type + \"Params\"];\n    scope = v.callbackScope || animation;\n    executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.\n    context && (_context = context);\n    result = params ? callback.apply(scope, params) : callback.call(scope);\n    _context = prevContext;\n    return result;\n}, _interrupt = function _interrupt(animation) {\n    _removeFromParent(animation);\n    animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);\n    animation.progress() < 1 && _callback(animation, \"onInterrupt\");\n    return animation;\n}, _quickTween, _registerPluginQueue = [], _createPlugin = function _createPlugin(config) {\n    if (!config) return;\n    config = !config.name && config[\"default\"] || config; // UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.\n    if (_windowExists() || config.headless) {\n        // edge case: some build tools may pass in a null/undefined value\n        var name = config.name, isFunc = _isFunction(config), Plugin = name && !isFunc && config.init ? function Plugin() {\n            this._props = [];\n        } : config, //in case someone passes in an object that's not a plugin, like CustomEase\n        instanceDefaults = {\n            init: _emptyFunc,\n            render: _renderPropTweens,\n            add: _addPropTween,\n            kill: _killPropTweensOf,\n            modifier: _addPluginModifier,\n            rawVars: 0\n        }, statics = {\n            targetTest: 0,\n            get: 0,\n            getSetter: _getSetter,\n            aliases: {},\n            register: 0\n        };\n        _wake();\n        if (config !== Plugin) {\n            if (_plugins[name]) {\n                return;\n            }\n            _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods\n            _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods\n            _plugins[Plugin.prop = name] = Plugin;\n            if (config.targetTest) {\n                _harnessPlugins.push(Plugin);\n                _reservedProps[name] = 1;\n            }\n            name = (name === \"css\" ? \"CSS\" : name.charAt(0).toUpperCase() + name.substr(1)) + \"Plugin\"; //for the global name. \"motionPath\" should become MotionPathPlugin\n        }\n        _addGlobal(name, Plugin);\n        config.register && config.register(gsap, Plugin, PropTween);\n    } else {\n        _registerPluginQueue.push(config);\n    }\n}, /*\n * --------------------------------------------------------------------------------------\n * COLORS\n * --------------------------------------------------------------------------------------\n */ _255 = 255, _colorLookup = {\n    aqua: [\n        0,\n        _255,\n        _255\n    ],\n    lime: [\n        0,\n        _255,\n        0\n    ],\n    silver: [\n        192,\n        192,\n        192\n    ],\n    black: [\n        0,\n        0,\n        0\n    ],\n    maroon: [\n        128,\n        0,\n        0\n    ],\n    teal: [\n        0,\n        128,\n        128\n    ],\n    blue: [\n        0,\n        0,\n        _255\n    ],\n    navy: [\n        0,\n        0,\n        128\n    ],\n    white: [\n        _255,\n        _255,\n        _255\n    ],\n    olive: [\n        128,\n        128,\n        0\n    ],\n    yellow: [\n        _255,\n        _255,\n        0\n    ],\n    orange: [\n        _255,\n        165,\n        0\n    ],\n    gray: [\n        128,\n        128,\n        128\n    ],\n    purple: [\n        128,\n        0,\n        128\n    ],\n    green: [\n        0,\n        128,\n        0\n    ],\n    red: [\n        _255,\n        0,\n        0\n    ],\n    pink: [\n        _255,\n        192,\n        203\n    ],\n    cyan: [\n        0,\n        _255,\n        _255\n    ],\n    transparent: [\n        _255,\n        _255,\n        _255,\n        0\n    ]\n}, // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:\n// let ctx = _doc.createElement(\"canvas\").getContext(\"2d\");\n// _forEachName(\"aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan\", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});\n_hue = function _hue(h, m1, m2) {\n    h += h < 0 ? 1 : h > 1 ? -1 : 0;\n    return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;\n}, splitColor = function splitColor(v, toHSL, forceAlpha) {\n    var a = !v ? _colorLookup.black : _isNumber(v) ? [\n        v >> 16,\n        v >> 8 & _255,\n        v & _255\n    ] : 0, r, g, b, h, s, l, max, min, d, wasHSL;\n    if (!a) {\n        if (v.substr(-1) === \",\") {\n            //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:\"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)\" - in this example \"blue,\" has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.\n            v = v.substr(0, v.length - 1);\n        }\n        if (_colorLookup[v]) {\n            a = _colorLookup[v];\n        } else if (v.charAt(0) === \"#\") {\n            if (v.length < 6) {\n                //for shorthand like #9F0 or #9F0F (could have alpha)\n                r = v.charAt(1);\n                g = v.charAt(2);\n                b = v.charAt(3);\n                v = \"#\" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : \"\");\n            }\n            if (v.length === 9) {\n                // hex with alpha, like #fd5e53ff\n                a = parseInt(v.substr(1, 6), 16);\n                return [\n                    a >> 16,\n                    a >> 8 & _255,\n                    a & _255,\n                    parseInt(v.substr(7), 16) / 255\n                ];\n            }\n            v = parseInt(v.substr(1), 16);\n            a = [\n                v >> 16,\n                v >> 8 & _255,\n                v & _255\n            ];\n        } else if (v.substr(0, 3) === \"hsl\") {\n            a = wasHSL = v.match(_strictNumExp);\n            if (!toHSL) {\n                h = +a[0] % 360 / 360;\n                s = +a[1] / 100;\n                l = +a[2] / 100;\n                g = l <= .5 ? l * (s + 1) : l + s - l * s;\n                r = l * 2 - g;\n                a.length > 3 && (a[3] *= 1); //cast as number\n                a[0] = _hue(h + 1 / 3, r, g);\n                a[1] = _hue(h, r, g);\n                a[2] = _hue(h - 1 / 3, r, g);\n            } else if (~v.indexOf(\"=\")) {\n                //if relative values are found, just return the raw strings with the relative prefixes in place.\n                a = v.match(_numExp);\n                forceAlpha && a.length < 4 && (a[3] = 1);\n                return a;\n            }\n        } else {\n            a = v.match(_strictNumExp) || _colorLookup.transparent;\n        }\n        a = a.map(Number);\n    }\n    if (toHSL && !wasHSL) {\n        r = a[0] / _255;\n        g = a[1] / _255;\n        b = a[2] / _255;\n        max = Math.max(r, g, b);\n        min = Math.min(r, g, b);\n        l = (max + min) / 2;\n        if (max === min) {\n            h = s = 0;\n        } else {\n            d = max - min;\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n            h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;\n            h *= 60;\n        }\n        a[0] = ~~(h + .5);\n        a[1] = ~~(s * 100 + .5);\n        a[2] = ~~(l * 100 + .5);\n    }\n    forceAlpha && a.length < 4 && (a[3] = 1);\n    return a;\n}, _colorOrderData = function _colorOrderData(v) {\n    // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a \"c\" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()\n    var values = [], c = [], i = -1;\n    v.split(_colorExp).forEach(function(v) {\n        var a = v.match(_numWithUnitExp) || [];\n        values.push.apply(values, a);\n        c.push(i += a.length + 1);\n    });\n    values.c = c;\n    return values;\n}, _formatColors = function _formatColors(s, toHSL, orderMatchData) {\n    var result = \"\", colors = (s + result).match(_colorExp), type = toHSL ? \"hsla(\" : \"rgba(\", i = 0, c, shell, d, l;\n    if (!colors) {\n        return s;\n    }\n    colors = colors.map(function(color) {\n        return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + \",\" + color[1] + \"%,\" + color[2] + \"%,\" + color[3] : color.join(\",\")) + \")\";\n    });\n    if (orderMatchData) {\n        d = _colorOrderData(s);\n        c = orderMatchData.c;\n        if (c.join(result) !== d.c.join(result)) {\n            shell = s.replace(_colorExp, \"1\").split(_numWithUnitExp);\n            l = shell.length - 1;\n            for(; i < l; i++){\n                result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + \"0,0,0,0)\" : (d.length ? d : colors.length ? colors : orderMatchData).shift());\n            }\n        }\n    }\n    if (!shell) {\n        shell = s.split(_colorExp);\n        l = shell.length - 1;\n        for(; i < l; i++){\n            result += shell[i] + colors[i];\n        }\n    }\n    return result + shell[l];\n}, _colorExp = function() {\n    var s = \"(?:\\\\b(?:(?:rgb|rgba|hsl|hsla)\\\\(.+?\\\\))|\\\\B#(?:[0-9a-f]{3,4}){1,2}\\\\b\", //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,\n    p;\n    for(p in _colorLookup){\n        s += \"|\" + p + \"\\\\b\";\n    }\n    return new RegExp(s + \")\", \"gi\");\n}(), _hslExp = /hsl[a]?\\(/, _colorStringFilter = function _colorStringFilter(a) {\n    var combined = a.join(\" \"), toHSL;\n    _colorExp.lastIndex = 0;\n    if (_colorExp.test(combined)) {\n        toHSL = _hslExp.test(combined);\n        a[1] = _formatColors(a[1], toHSL);\n        a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.\n        return true;\n    }\n}, /*\n * --------------------------------------------------------------------------------------\n * TICKER\n * --------------------------------------------------------------------------------------\n */ _tickerActive, _ticker = function() {\n    var _getTime = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime(), _lastUpdate = _startTime, _gap = 1000 / 240, _nextTime = _gap, _listeners = [], _id, _req, _raf, _self, _delta, _i, _tick = function _tick(v) {\n        var elapsed = _getTime() - _lastUpdate, manual = v === true, overlap, dispatch, time, frame;\n        (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);\n        _lastUpdate += elapsed;\n        time = _lastUpdate - _startTime;\n        overlap = time - _nextTime;\n        if (overlap > 0 || manual) {\n            frame = ++_self.frame;\n            _delta = time - _self.time * 1000;\n            _self.time = time = time / 1000;\n            _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);\n            dispatch = 1;\n        }\n        manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the \"tick\" event so that timing is maintained. Otherwise, if processing the \"tick\" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.\n        if (dispatch) {\n            for(_i = 0; _i < _listeners.length; _i++){\n                // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.\n                _listeners[_i](time, _delta, frame, v);\n            }\n        }\n    };\n    _self = {\n        time: 0,\n        frame: 0,\n        tick: function tick() {\n            _tick(true);\n        },\n        deltaRatio: function deltaRatio(fps) {\n            return _delta / (1000 / (fps || 60));\n        },\n        wake: function wake() {\n            if (_coreReady) {\n                if (!_coreInitted && _windowExists()) {\n                    _win = _coreInitted = window;\n                    _doc = _win.document || {};\n                    _globals.gsap = gsap;\n                    (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);\n                    _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});\n                    _registerPluginQueue.forEach(_createPlugin);\n                }\n                _raf = typeof requestAnimationFrame !== \"undefined\" && requestAnimationFrame;\n                _id && _self.sleep();\n                _req = _raf || function(f) {\n                    return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);\n                };\n                _tickerActive = 1;\n                _tick(2);\n            }\n        },\n        sleep: function sleep() {\n            (_raf ? cancelAnimationFrame : clearTimeout)(_id);\n            _tickerActive = 0;\n            _req = _emptyFunc;\n        },\n        lagSmoothing: function lagSmoothing(threshold, adjustedLag) {\n            _lagThreshold = threshold || Infinity; // zero should be interpreted as basically unlimited\n            _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);\n        },\n        fps: function fps(_fps) {\n            _gap = 1000 / (_fps || 240);\n            _nextTime = _self.time * 1000 + _gap;\n        },\n        add: function add(callback, once, prioritize) {\n            var func = once ? function func1(t, d, f, v) {\n                callback(t, d, f, v);\n                _self.remove(func);\n            } : callback;\n            _self.remove(callback);\n            _listeners[prioritize ? \"unshift\" : \"push\"](func);\n            _wake();\n            return func;\n        },\n        remove: function remove(callback, i) {\n            ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;\n        },\n        _listeners: _listeners\n    };\n    return _self;\n}(), _wake = function _wake() {\n    return !_tickerActive && _ticker.wake();\n}, //also ensures the core classes are initialized.\n/*\n* -------------------------------------------------\n* EASING\n* -------------------------------------------------\n*/ _easeMap = {}, _customEaseExp = /^[\\d.\\-M][\\d.\\-,\\s]/, _quotesExp = /[\"']/g, _parseObjectInString = function _parseObjectInString(value) {\n    //takes a string like \"{wiggles:10, type:anticipate})\" and turns it into a real object. Notice it ends in \")\" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.\n    var obj = {}, split = value.substr(1, value.length - 3).split(\":\"), key = split[0], i = 1, l = split.length, index, val, parsedVal;\n    for(; i < l; i++){\n        val = split[i];\n        index = i !== l - 1 ? val.lastIndexOf(\",\") : val.length;\n        parsedVal = val.substr(0, index);\n        obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, \"\").trim() : +parsedVal;\n        key = val.substr(index + 1).trim();\n    }\n    return obj;\n}, _valueInParentheses = function _valueInParentheses(value) {\n    var open = value.indexOf(\"(\") + 1, close = value.indexOf(\")\"), nested = value.indexOf(\"(\", open);\n    return value.substring(open, ~nested && nested < close ? value.indexOf(\")\", close + 1) : close);\n}, _configEaseFromString = function _configEaseFromString(name) {\n    //name can be a string like \"elastic.out(1,0.5)\", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).\n    var split = (name + \"\").split(\"(\"), ease = _easeMap[split[0]];\n    return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf(\"{\") ? [\n        _parseObjectInString(split[1])\n    ] : _valueInParentheses(name).split(\",\").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE(\"\", name) : ease;\n}, _invertEase = function _invertEase(ease) {\n    return function(p) {\n        return 1 - ease(1 - p);\n    };\n}, // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.\n_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {\n    var child = timeline._first, ease;\n    while(child){\n        if (child instanceof Timeline) {\n            _propagateYoyoEase(child, isYoyo);\n        } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {\n            if (child.timeline) {\n                _propagateYoyoEase(child.timeline, isYoyo);\n            } else {\n                ease = child._ease;\n                child._ease = child._yEase;\n                child._yEase = ease;\n                child._yoyo = isYoyo;\n            }\n        }\n        child = child._next;\n    }\n}, _parseEase = function _parseEase(ease, defaultEase) {\n    return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;\n}, _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {\n    if (easeOut === void 0) {\n        easeOut = function easeOut(p) {\n            return 1 - easeIn(1 - p);\n        };\n    }\n    if (easeInOut === void 0) {\n        easeInOut = function easeInOut(p) {\n            return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;\n        };\n    }\n    var ease = {\n        easeIn: easeIn,\n        easeOut: easeOut,\n        easeInOut: easeInOut\n    }, lowercaseName;\n    _forEachName(names, function(name) {\n        _easeMap[name] = _globals[name] = ease;\n        _easeMap[lowercaseName = name.toLowerCase()] = easeOut;\n        for(var p in ease){\n            _easeMap[lowercaseName + (p === \"easeIn\" ? \".in\" : p === \"easeOut\" ? \".out\" : \".inOut\")] = _easeMap[name + \".\" + p] = ease[p];\n        }\n    });\n    return ease;\n}, _easeInOutFromOut = function _easeInOutFromOut(easeOut) {\n    return function(p) {\n        return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;\n    };\n}, _configElastic = function _configElastic(type, amplitude, period) {\n    var p1 = amplitude >= 1 ? amplitude : 1, //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.\n    p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut(p) {\n        return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;\n    }, ease = type === \"out\" ? easeOut : type === \"in\" ? function ease(p) {\n        return 1 - easeOut(1 - p);\n    } : _easeInOutFromOut(easeOut);\n    p2 = _2PI / p2; //precalculate to optimize\n    ease.config = function(amplitude, period) {\n        return _configElastic(type, amplitude, period);\n    };\n    return ease;\n}, _configBack = function _configBack(type, overshoot) {\n    if (overshoot === void 0) {\n        overshoot = 1.70158;\n    }\n    var easeOut = function easeOut(p) {\n        return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;\n    }, ease = type === \"out\" ? easeOut : type === \"in\" ? function ease(p) {\n        return 1 - easeOut(1 - p);\n    } : _easeInOutFromOut(easeOut);\n    ease.config = function(overshoot) {\n        return _configBack(type, overshoot);\n    };\n    return ease;\n}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\n// _weightedEase = ratio => {\n// \tlet y = 0.5 + ratio / 2;\n// \treturn p => (2 * (1 - p) * p * y + p * p);\n// },\n// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\n// _weightedEaseStrong = ratio => {\n// \tratio = .5 + ratio / 2;\n// \tlet o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),\n// \t\tb = ratio - o,\n// \t\tc = ratio + o;\n// \treturn p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;\n// };\n_forEachName(\"Linear,Quad,Cubic,Quart,Quint,Strong\", function(name, i) {\n    var power = i < 5 ? i + 1 : i;\n    _insertEase(name + \",Power\" + (power - 1), i ? function(p) {\n        return Math.pow(p, power);\n    } : function(p) {\n        return p;\n    }, function(p) {\n        return 1 - Math.pow(1 - p, power);\n    }, function(p) {\n        return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;\n    });\n});\n_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;\n_insertEase(\"Elastic\", _configElastic(\"in\"), _configElastic(\"out\"), _configElastic());\n(function(n, c) {\n    var n1 = 1 / c, n2 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut(p) {\n        return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;\n    };\n    _insertEase(\"Bounce\", function(p) {\n        return 1 - easeOut(1 - p);\n    }, easeOut);\n})(7.5625, 2.75);\n_insertEase(\"Expo\", function(p) {\n    return p ? Math.pow(2, 10 * (p - 1)) : 0;\n});\n_insertEase(\"Circ\", function(p) {\n    return -(_sqrt(1 - p * p) - 1);\n});\n_insertEase(\"Sine\", function(p) {\n    return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;\n});\n_insertEase(\"Back\", _configBack(\"in\"), _configBack(\"out\"), _configBack());\n_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {\n    config: function config(steps, immediateStart) {\n        if (steps === void 0) {\n            steps = 1;\n        }\n        var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;\n        return function(p) {\n            return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;\n        };\n    }\n};\n_defaults.ease = _easeMap[\"quad.out\"];\n_forEachName(\"onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt\", function(name) {\n    return _callbackNames += name + \",\" + name + \"Params,\";\n});\n/*\n * --------------------------------------------------------------------------------------\n * CACHE\n * --------------------------------------------------------------------------------------\n */ var GSCache = function GSCache(target, harness) {\n    this.id = _gsID++;\n    target._gsap = this;\n    this.target = target;\n    this.harness = harness;\n    this.get = harness ? harness.get : _getProperty;\n    this.set = harness ? harness.getSetter : _getSetter;\n};\n_c = GSCache;\n/*\n * --------------------------------------------------------------------------------------\n * ANIMATION\n * --------------------------------------------------------------------------------------\n */ var Animation = /*#__PURE__*/ function() {\n    function Animation(vars) {\n        this.vars = vars;\n        this._delay = +vars.delay || 0;\n        if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {\n            // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.\n            this._rDelay = vars.repeatDelay || 0;\n            this._yoyo = !!vars.yoyo || !!vars.yoyoEase;\n        }\n        this._ts = 1;\n        _setDuration(this, +vars.duration, 1, 1);\n        this.data = vars.data;\n        if (_context) {\n            this._ctx = _context;\n            _context.data.push(this);\n        }\n        _tickerActive || _ticker.wake();\n    }\n    var _proto = Animation.prototype;\n    _proto.delay = function delay(value) {\n        if (value || value === 0) {\n            this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);\n            this._delay = value;\n            return this;\n        }\n        return this._delay;\n    };\n    _proto.duration = function duration(value) {\n        return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;\n    };\n    _proto.totalDuration = function totalDuration(value) {\n        if (!arguments.length) {\n            return this._tDur;\n        }\n        this._dirty = 0;\n        return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));\n    };\n    _proto.totalTime = function totalTime(_totalTime, suppressEvents) {\n        _wake();\n        if (!arguments.length) {\n            return this._tTime;\n        }\n        var parent = this._dp;\n        if (parent && parent.smoothChildTiming && this._ts) {\n            _alignPlayhead(this, _totalTime);\n            !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.\n            //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.\n            while(parent && parent.parent){\n                if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {\n                    parent.totalTime(parent._tTime, true);\n                }\n                parent = parent.parent;\n            }\n            if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {\n                //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.\n                _addToTimeline(this._dp, this, this._start - this._delay);\n            }\n        }\n        if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {\n            // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)\n            this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause\n            //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)\n            //   this._lock = 1;\n            _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;\n        //}\n        }\n        return this;\n    };\n    _proto.time = function time(value, suppressEvents) {\n        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!\n    };\n    _proto.totalProgress = function totalProgress(value, suppressEvents) {\n        return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;\n    };\n    _proto.progress = function progress(value, suppressEvents) {\n        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;\n    };\n    _proto.iteration = function iteration(value, suppressEvents) {\n        var cycleDuration = this.duration() + this._rDelay;\n        return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;\n    } // potential future addition:\n    ;\n    _proto.timeScale = function timeScale(value, suppressEvents) {\n        if (!arguments.length) {\n            return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.\n        }\n        if (this._rts === value) {\n            return this;\n        }\n        var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.\n        // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.\n        //(+value < 0 && this._rts >= 0) && _callback(this, \"onReverse\", true);\n        // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.\n        this._rts = +value || 0;\n        this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.\n        this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), suppressEvents !== false);\n        _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.\n        return _recacheAncestors(this);\n    };\n    _proto.paused = function paused(value) {\n        if (!arguments.length) {\n            return this._ps;\n        }\n        if (this._ps !== value) {\n            this._ps = value;\n            if (value) {\n                this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.\n                this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the \"real\" timeScale as _rts (recorded time scale)\n            } else {\n                _wake();\n                this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.\n                this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.\n            }\n        }\n        return this;\n    };\n    _proto.startTime = function startTime(value) {\n        if (arguments.length) {\n            this._start = value;\n            var parent = this.parent || this._dp;\n            parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);\n            return this;\n        }\n        return this._start;\n    };\n    _proto.endTime = function endTime(includeRepeats) {\n        return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);\n    };\n    _proto.rawTime = function rawTime(wrapRepeats) {\n        var parent = this.parent || this._dp; // _dp = detached parent\n        return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);\n    };\n    _proto.revert = function revert(config) {\n        if (config === void 0) {\n            config = _revertConfig;\n        }\n        var prevIsReverting = _reverting;\n        _reverting = config;\n        if (this._initted || this._startAt) {\n            this.timeline && this.timeline.revert(config);\n            this.totalTime(-0.01, config.suppressEvents);\n        }\n        this.data !== \"nested\" && config.kill !== false && this.kill();\n        _reverting = prevIsReverting;\n        return this;\n    };\n    _proto.globalTime = function globalTime(rawTime) {\n        var animation = this, time = arguments.length ? rawTime : animation.rawTime();\n        while(animation){\n            time = animation._start + time / (Math.abs(animation._ts) || 1);\n            animation = animation._dp;\n        }\n        return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time; // the _startAt tweens for .fromTo() and .from() that have immediateRender should always be FIRST in the timeline (important for context.revert()). \"_sat\" stands for _startAtTween, referring to the parent tween that created the _startAt. We must discern if that tween had immediateRender so that we can know whether or not to prioritize it in revert().\n    };\n    _proto.repeat = function repeat(value) {\n        if (arguments.length) {\n            this._repeat = value === Infinity ? -2 : value;\n            return _onUpdateTotalDuration(this);\n        }\n        return this._repeat === -2 ? Infinity : this._repeat;\n    };\n    _proto.repeatDelay = function repeatDelay(value) {\n        if (arguments.length) {\n            var time = this._time;\n            this._rDelay = value;\n            _onUpdateTotalDuration(this);\n            return time ? this.time(time) : this;\n        }\n        return this._rDelay;\n    };\n    _proto.yoyo = function yoyo(value) {\n        if (arguments.length) {\n            this._yoyo = value;\n            return this;\n        }\n        return this._yoyo;\n    };\n    _proto.seek = function seek(position, suppressEvents) {\n        return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));\n    };\n    _proto.restart = function restart(includeDelay, suppressEvents) {\n        return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));\n    };\n    _proto.play = function play(from, suppressEvents) {\n        from != null && this.seek(from, suppressEvents);\n        return this.reversed(false).paused(false);\n    };\n    _proto.reverse = function reverse(from, suppressEvents) {\n        from != null && this.seek(from || this.totalDuration(), suppressEvents);\n        return this.reversed(true).paused(false);\n    };\n    _proto.pause = function pause(atTime, suppressEvents) {\n        atTime != null && this.seek(atTime, suppressEvents);\n        return this.paused(true);\n    };\n    _proto.resume = function resume() {\n        return this.paused(false);\n    };\n    _proto.reversed = function reversed(value) {\n        if (arguments.length) {\n            !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.\n            return this;\n        }\n        return this._rts < 0;\n    };\n    _proto.invalidate = function invalidate() {\n        this._initted = this._act = 0;\n        this._zTime = -_tinyNum;\n        return this;\n    };\n    _proto.isActive = function isActive() {\n        var parent = this.parent || this._dp, start = this._start, rawTime;\n        return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);\n    };\n    _proto.eventCallback = function eventCallback(type, callback, params) {\n        var vars = this.vars;\n        if (arguments.length > 1) {\n            if (!callback) {\n                delete vars[type];\n            } else {\n                vars[type] = callback;\n                params && (vars[type + \"Params\"] = params);\n                type === \"onUpdate\" && (this._onUpdate = callback);\n            }\n            return this;\n        }\n        return vars[type];\n    };\n    _proto.then = function then(onFulfilled) {\n        var self = this;\n        return new Promise(function(resolve) {\n            var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve() {\n                var _then = self.then;\n                self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)\n                _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);\n                resolve(f);\n                self.then = _then;\n            };\n            if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {\n                _resolve();\n            } else {\n                self._prom = _resolve;\n            }\n        });\n    };\n    _proto.kill = function kill() {\n        _interrupt(this);\n    };\n    return Animation;\n}();\n_setDefaults(Animation.prototype, {\n    _time: 0,\n    _start: 0,\n    _end: 0,\n    _tTime: 0,\n    _tDur: 0,\n    _dirty: 0,\n    _repeat: 0,\n    _yoyo: false,\n    parent: null,\n    _initted: false,\n    _rDelay: 0,\n    _ts: 1,\n    _dp: 0,\n    ratio: 0,\n    _zTime: -_tinyNum,\n    _prom: 0,\n    _ps: false,\n    _rts: 1\n});\n/*\n * -------------------------------------------------\n * TIMELINE\n * -------------------------------------------------\n */ var Timeline = /*#__PURE__*/ function(_Animation) {\n    _inheritsLoose(Timeline, _Animation);\n    function Timeline(vars, position) {\n        var _this;\n        if (vars === void 0) {\n            vars = {};\n        }\n        _this = _Animation.call(this, vars) || this;\n        _this.labels = {};\n        _this.smoothChildTiming = !!vars.smoothChildTiming;\n        _this.autoRemoveChildren = !!vars.autoRemoveChildren;\n        _this._sort = _isNotFalse(vars.sortChildren);\n        _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);\n        vars.reversed && _this.reverse();\n        vars.paused && _this.paused(true);\n        vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);\n        return _this;\n    }\n    var _proto2 = Timeline.prototype;\n    _proto2.to = function to(targets, vars, position) {\n        _createTweenType(0, arguments, this);\n        return this;\n    };\n    _proto2.from = function from(targets, vars, position) {\n        _createTweenType(1, arguments, this);\n        return this;\n    };\n    _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {\n        _createTweenType(2, arguments, this);\n        return this;\n    };\n    _proto2.set = function set(targets, vars, position) {\n        vars.duration = 0;\n        vars.parent = this;\n        _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);\n        vars.immediateRender = !!vars.immediateRender;\n        new Tween(targets, vars, _parsePosition(this, position), 1);\n        return this;\n    };\n    _proto2.call = function call(callback, params, position) {\n        return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);\n    } //ONLY for backward compatibility! Maybe delete?\n    ;\n    _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n        vars.duration = duration;\n        vars.stagger = vars.stagger || stagger;\n        vars.onComplete = onCompleteAll;\n        vars.onCompleteParams = onCompleteAllParams;\n        vars.parent = this;\n        new Tween(targets, vars, _parsePosition(this, position));\n        return this;\n    };\n    _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n        vars.runBackwards = 1;\n        _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);\n        return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);\n    };\n    _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {\n        toVars.startAt = fromVars;\n        _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);\n        return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);\n    };\n    _proto2.render = function render(totalTime, suppressEvents, force) {\n        var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.\n        crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;\n        this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);\n        if (tTime !== this._tTime || force || crossingStart) {\n            if (prevTime !== this._time && dur) {\n                //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).\n                tTime += this._time - prevTime;\n                totalTime += this._time - prevTime;\n            }\n            time = tTime;\n            prevStart = this._start;\n            timeScale = this._ts;\n            prevPaused = !timeScale;\n            if (crossingStart) {\n                dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\n                (totalTime || !suppressEvents) && (this._zTime = totalTime);\n            }\n            if (this._repeat) {\n                //adjust the time for repeats and yoyos\n                yoyo = this._yoyo;\n                cycleDuration = dur + this._rDelay;\n                if (this._repeat < -1 && totalTime < 0) {\n                    return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n                }\n                time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\n                if (tTime === tDur) {\n                    // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)\n                    iteration = this._repeat;\n                    time = dur;\n                } else {\n                    iteration = ~~(tTime / cycleDuration);\n                    if (iteration && iteration === tTime / cycleDuration) {\n                        time = dur;\n                        iteration--;\n                    }\n                    time > dur && (time = dur);\n                }\n                prevIteration = _animationCycle(this._tTime, cycleDuration);\n                !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://gsap.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005 also, this._tTime - prevIteration * cycleDuration - this._dur <= 0 just checks to make sure it wasn't previously in the \"repeatDelay\" portion\n                if (yoyo && iteration & 1) {\n                    time = dur - time;\n                    isYoyo = 1;\n                }\n                /*\n        make sure children at the end/beginning of the timeline are rendered properly. If, for example,\n        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which\n        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there\n        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So\n        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must\n        ensure that zero-duration tweens at the very beginning or end of the Timeline work.\n        */ if (iteration !== prevIteration && !this._lock) {\n                    var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);\n                    iteration < prevIteration && (rewinding = !rewinding);\n                    prevTime = rewinding ? 0 : tTime % dur ? dur : tTime; // if the playhead is landing exactly at the end of an iteration, use that totalTime rather than only the duration, otherwise it'll skip the 2nd render since it's effectively at the same time.\n                    this._lock = 1;\n                    this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;\n                    this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.\n                    !suppressEvents && this.parent && _callback(this, \"onRepeat\");\n                    this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);\n                    if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {\n                        // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.\n                        return this;\n                    }\n                    dur = this._dur; // in case the duration changed in the onRepeat\n                    tDur = this._tDur;\n                    if (doesWrap) {\n                        this._lock = 2;\n                        prevTime = rewinding ? dur : -0.0001;\n                        this.render(prevTime, true);\n                        this.vars.repeatRefresh && !isYoyo && this.invalidate();\n                    }\n                    this._lock = 0;\n                    if (!this._ts && !prevPaused) {\n                        return this;\n                    } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.\n                    _propagateYoyoEase(this, isYoyo);\n                }\n            }\n            if (this._hasPause && !this._forcing && this._lock < 2) {\n                pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));\n                if (pauseTween) {\n                    tTime -= time - (time = pauseTween._start);\n                }\n            }\n            this._tTime = tTime;\n            this._time = time;\n            this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.\n            if (!this._initted) {\n                this._onUpdate = this.vars.onUpdate;\n                this._initted = 1;\n                this._zTime = totalTime;\n                prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).\n            }\n            if (!prevTime && time && !suppressEvents && !iteration) {\n                _callback(this, \"onStart\");\n                if (this._tTime !== tTime) {\n                    // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.\n                    return this;\n                }\n            }\n            if (time >= prevTime && totalTime >= 0) {\n                child = this._first;\n                while(child){\n                    next = child._next;\n                    if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {\n                        if (child.parent !== this) {\n                            // an extreme edge case - the child's render could do something like kill() the \"next\" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\n                            return this.render(totalTime, suppressEvents, force);\n                        }\n                        child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);\n                        if (time !== this._time || !this._ts && !prevPaused) {\n                            //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\n                            pauseTween = 0;\n                            next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)\n                            break;\n                        }\n                    }\n                    child = next;\n                }\n            } else {\n                child = this._last;\n                var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.\n                while(child){\n                    next = child._prev;\n                    if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {\n                        if (child.parent !== this) {\n                            // an extreme edge case - the child's render could do something like kill() the \"next\" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\n                            return this.render(totalTime, suppressEvents, force);\n                        }\n                        child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt)); // if reverting, we should always force renders of initted tweens (but remember that .fromTo() or .from() may have a _startAt but not _initted yet). If, for example, a .fromTo() tween with a stagger (which creates an internal timeline) gets reverted BEFORE some of its child tweens render for the first time, it may not properly trigger them to revert.\n                        if (time !== this._time || !this._ts && !prevPaused) {\n                            //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\n                            pauseTween = 0;\n                            next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)\n                            break;\n                        }\n                    }\n                    child = next;\n                }\n            }\n            if (pauseTween && !suppressEvents) {\n                this.pause();\n                pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;\n                if (this._ts) {\n                    //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).\n                    this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.\n                    _setEnd(this);\n                    return this.render(totalTime, suppressEvents, force);\n                }\n            }\n            this._onUpdate && !suppressEvents && _callback(this, \"onUpdate\", true);\n            if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {\n                if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {\n                    if (!this._lock) {\n                        // remember, a child's callback may alter this timeline's playhead or timeScale which is why we need to add some of these checks.\n                        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\n                        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {\n                            _callback(this, tTime === tDur && totalTime >= 0 ? \"onComplete\" : \"onReverseComplete\", true);\n                            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n                        }\n                    }\n                }\n            }\n        }\n        return this;\n    };\n    _proto2.add = function add(child, position) {\n        var _this2 = this;\n        _isNumber(position) || (position = _parsePosition(this, position, child));\n        if (!(child instanceof Animation)) {\n            if (_isArray(child)) {\n                child.forEach(function(obj) {\n                    return _this2.add(obj, position);\n                });\n                return this;\n            }\n            if (_isString(child)) {\n                return this.addLabel(child, position);\n            }\n            if (_isFunction(child)) {\n                child = Tween.delayedCall(0, child);\n            } else {\n                return this;\n            }\n        }\n        return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!\n    };\n    _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {\n        if (nested === void 0) {\n            nested = true;\n        }\n        if (tweens === void 0) {\n            tweens = true;\n        }\n        if (timelines === void 0) {\n            timelines = true;\n        }\n        if (ignoreBeforeTime === void 0) {\n            ignoreBeforeTime = -_bigNum;\n        }\n        var a = [], child = this._first;\n        while(child){\n            if (child._start >= ignoreBeforeTime) {\n                if (child instanceof Tween) {\n                    tweens && a.push(child);\n                } else {\n                    timelines && a.push(child);\n                    nested && a.push.apply(a, child.getChildren(true, tweens, timelines));\n                }\n            }\n            child = child._next;\n        }\n        return a;\n    };\n    _proto2.getById = function getById(id) {\n        var animations = this.getChildren(1, 1, 1), i = animations.length;\n        while(i--){\n            if (animations[i].vars.id === id) {\n                return animations[i];\n            }\n        }\n    };\n    _proto2.remove = function remove(child) {\n        if (_isString(child)) {\n            return this.removeLabel(child);\n        }\n        if (_isFunction(child)) {\n            return this.killTweensOf(child);\n        }\n        _removeLinkedListItem(this, child);\n        if (child === this._recent) {\n            this._recent = this._last;\n        }\n        return _uncache(this);\n    };\n    _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {\n        if (!arguments.length) {\n            return this._tTime;\n        }\n        this._forcing = 1;\n        if (!this._dp && this._ts) {\n            //special case for the global timeline (or any other that has no parent or detached parent).\n            this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));\n        }\n        _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);\n        this._forcing = 0;\n        return this;\n    };\n    _proto2.addLabel = function addLabel(label, position) {\n        this.labels[label] = _parsePosition(this, position);\n        return this;\n    };\n    _proto2.removeLabel = function removeLabel(label) {\n        delete this.labels[label];\n        return this;\n    };\n    _proto2.addPause = function addPause(position, callback, params) {\n        var t = Tween.delayedCall(0, callback || _emptyFunc, params);\n        t.data = \"isPause\";\n        this._hasPause = 1;\n        return _addToTimeline(this, t, _parsePosition(this, position));\n    };\n    _proto2.removePause = function removePause(position) {\n        var child = this._first;\n        position = _parsePosition(this, position);\n        while(child){\n            if (child._start === position && child.data === \"isPause\") {\n                _removeFromParent(child);\n            }\n            child = child._next;\n        }\n    };\n    _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n        var tweens = this.getTweensOf(targets, onlyActive), i = tweens.length;\n        while(i--){\n            _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);\n        }\n        return this;\n    };\n    _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {\n        var a = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), // a number is interpreted as a global time. If the animation spans\n        children;\n        while(child){\n            if (child instanceof Tween) {\n                if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {\n                    // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.\n                    a.push(child);\n                }\n            } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {\n                a.push.apply(a, children);\n            }\n            child = child._next;\n        }\n        return a;\n    } // potential future feature - targets() on timelines\n    ;\n    _proto2.tweenTo = function tweenTo(position, vars) {\n        vars = vars || {};\n        var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({\n            ease: vars.ease || \"none\",\n            lazy: false,\n            immediateRender: false,\n            time: endTime,\n            overwrite: \"auto\",\n            duration: vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,\n            onStart: function onStart() {\n                tl.pause();\n                if (!initted) {\n                    var duration = vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale());\n                    tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);\n                    initted = 1;\n                }\n                _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.\n            }\n        }, vars));\n        return immediateRender ? tween.render(0) : tween;\n    };\n    _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {\n        return this.tweenTo(toPosition, _setDefaults({\n            startAt: {\n                time: _parsePosition(this, fromPosition)\n            }\n        }, vars));\n    };\n    _proto2.recent = function recent() {\n        return this._recent;\n    };\n    _proto2.nextLabel = function nextLabel(afterTime) {\n        if (afterTime === void 0) {\n            afterTime = this._time;\n        }\n        return _getLabelInDirection(this, _parsePosition(this, afterTime));\n    };\n    _proto2.previousLabel = function previousLabel(beforeTime) {\n        if (beforeTime === void 0) {\n            beforeTime = this._time;\n        }\n        return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);\n    };\n    _proto2.currentLabel = function currentLabel(value) {\n        return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);\n    };\n    _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {\n        if (ignoreBeforeTime === void 0) {\n            ignoreBeforeTime = 0;\n        }\n        var child = this._first, labels = this.labels, p;\n        while(child){\n            if (child._start >= ignoreBeforeTime) {\n                child._start += amount;\n                child._end += amount;\n            }\n            child = child._next;\n        }\n        if (adjustLabels) {\n            for(p in labels){\n                if (labels[p] >= ignoreBeforeTime) {\n                    labels[p] += amount;\n                }\n            }\n        }\n        return _uncache(this);\n    };\n    _proto2.invalidate = function invalidate(soft) {\n        var child = this._first;\n        this._lock = 0;\n        while(child){\n            child.invalidate(soft);\n            child = child._next;\n        }\n        return _Animation.prototype.invalidate.call(this, soft);\n    };\n    _proto2.clear = function clear(includeLabels) {\n        if (includeLabels === void 0) {\n            includeLabels = true;\n        }\n        var child = this._first, next;\n        while(child){\n            next = child._next;\n            this.remove(child);\n            child = next;\n        }\n        this._dp && (this._time = this._tTime = this._pTime = 0);\n        includeLabels && (this.labels = {});\n        return _uncache(this);\n    };\n    _proto2.totalDuration = function totalDuration(value) {\n        var max = 0, self = this, child = self._last, prevStart = _bigNum, prev, start, parent;\n        if (arguments.length) {\n            return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));\n        }\n        if (self._dirty) {\n            parent = self.parent;\n            while(child){\n                prev = child._prev; //record it here in case the tween changes position in the sequence...\n                child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.\n                start = child._start;\n                if (start > prevStart && self._sort && child._ts && !self._lock) {\n                    //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence\n                    self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().\n                    _addToTimeline(self, child, start - child._delay, 1)._lock = 0;\n                } else {\n                    prevStart = start;\n                }\n                if (start < 0 && child._ts) {\n                    //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.\n                    max -= start;\n                    if (!parent && !self._dp || parent && parent.smoothChildTiming) {\n                        self._start += start / self._ts;\n                        self._time -= start;\n                        self._tTime -= start;\n                    }\n                    self.shiftChildren(-start, false, -Infinity);\n                    prevStart = 0;\n                }\n                child._end > max && child._ts && (max = child._end);\n                child = prev;\n            }\n            _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);\n            self._dirty = 0;\n        }\n        return self._tDur;\n    };\n    Timeline.updateRoot = function updateRoot(time) {\n        if (_globalTimeline._ts) {\n            _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));\n            _lastRenderedFrame = _ticker.frame;\n        }\n        if (_ticker.frame >= _nextGCFrame) {\n            _nextGCFrame += _config.autoSleep || 120;\n            var child = _globalTimeline._first;\n            if (!child || !child._ts) {\n                if (_config.autoSleep && _ticker._listeners.length < 2) {\n                    while(child && !child._ts){\n                        child = child._next;\n                    }\n                    child || _ticker.sleep();\n                }\n            }\n        }\n    };\n    return Timeline;\n}(Animation);\n_setDefaults(Timeline.prototype, {\n    _lock: 0,\n    _hasPause: 0,\n    _forcing: 0\n});\nvar _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {\n    //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\n    var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a;\n    pt.b = start;\n    pt.e = end;\n    start += \"\"; //ensure values are strings\n    end += \"\";\n    if (hasRandom = ~end.indexOf(\"random(\")) {\n        end = _replaceRandom(end);\n    }\n    if (stringFilter) {\n        a = [\n            start,\n            end\n        ];\n        stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.\n        start = a[0];\n        end = a[1];\n    }\n    startNums = start.match(_complexStringNumExp) || [];\n    while(result = _complexStringNumExp.exec(end)){\n        endNum = result[0];\n        chunk = end.substring(index, result.index);\n        if (color) {\n            color = (color + 1) % 5;\n        } else if (chunk.substr(-5) === \"rgba(\") {\n            color = 1;\n        }\n        if (endNum !== startNums[matchIndex++]) {\n            startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.\n            pt._pt = {\n                _next: pt._pt,\n                p: chunk || matchIndex === 1 ? chunk : \",\",\n                //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n                s: startNum,\n                c: endNum.charAt(1) === \"=\" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,\n                m: color && color < 4 ? Math.round : 0\n            };\n            index = _complexStringNumExp.lastIndex;\n        }\n    }\n    pt.c = index < end.length ? end.substring(index, end.length) : \"\"; //we use the \"c\" of the PropTween to store the final part of the string (after the last number)\n    pt.fp = funcParam;\n    if (_relExp.test(end) || hasRandom) {\n        pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).\n    }\n    this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\n    return pt;\n}, _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {\n    _isFunction(end) && (end = end(index || 0, target, targets));\n    var currentValue = target[prop], parsedStart = start !== \"get\" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf(\"set\") || !_isFunction(target[\"get\" + prop.substr(3)]) ? prop : \"get\" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;\n    if (_isString(end)) {\n        if (~end.indexOf(\"random(\")) {\n            end = _replaceRandom(end);\n        }\n        if (end.charAt(1) === \"=\") {\n            pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);\n            if (pt || pt === 0) {\n                // to avoid isNaN, like if someone passes in a value like \"!= whatever\"\n                end = pt;\n            }\n        }\n    }\n    if (!optional || parsedStart !== end || _forceAllPropTweens) {\n        if (!isNaN(parsedStart * end) && end !== \"\") {\n            // fun fact: any number multiplied by \"\" is evaluated as the number 0!\n            pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === \"boolean\" ? _renderBoolean : _renderPlain, 0, setter);\n            funcParam && (pt.fp = funcParam);\n            modifier && pt.modifier(modifier, this, target);\n            return this._pt = pt;\n        }\n        !currentValue && !(prop in target) && _missingPlugin(prop, end);\n        return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);\n    }\n}, //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with \"random()\" in them. It does NOT process relative values.\n_processVars = function _processVars(vars, index, target, targets, tween) {\n    _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));\n    if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {\n        return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;\n    }\n    var copy = {}, p;\n    for(p in vars){\n        copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);\n    }\n    return copy;\n}, _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {\n    var plugin, pt, ptLookup, i;\n    if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {\n        tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);\n        if (tween !== _quickTween) {\n            ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.\n            i = plugin._props.length;\n            while(i--){\n                ptLookup[plugin._props[i]] = pt;\n            }\n        }\n    }\n    return plugin;\n}, _overwritingTween, //store a reference temporarily so we can avoid overwriting itself.\n_forceAllPropTweens, _initTween = function _initTween(tween, time, tTime) {\n    var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent = tween.parent, fullTargets = parent && parent.data === \"nested\" ? parent.vars.targets : targets, autoOverwrite = tween._overwrite === \"auto\" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;\n    tl && (!keyframes || !ease) && (ease = \"none\");\n    tween._ease = _parseEase(ease, _defaults.ease);\n    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;\n    if (yoyoEase && tween._yoyo && !tween._repeat) {\n        //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.\n        yoyoEase = tween._yEase;\n        tween._yEase = tween._ease;\n        tween._ease = yoyoEase;\n    }\n    tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.\n    if (!tl || keyframes && !vars.stagger) {\n        //if there's an internal timeline, skip all the parsing because we passed that task down the chain.\n        harness = targets[0] ? _getCache(targets[0]).harness : 0;\n        harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an \"x\" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.\n        cleanVars = _copyExcluding(vars, _reservedProps);\n        if (prevStartAt) {\n            prevStartAt._zTime < 0 && prevStartAt.progress(1); // in case it's a lazy startAt that hasn't rendered yet.\n            time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig); // if it's a \"startAt\" (not \"from()\" or runBackwards: true), we only need to do a shallow revert (keep transforms cached in CSSPlugin)\n            // don't just _removeFromParent(prevStartAt.render(-1, true)) because that'll leave inline styles. We're creating a new _startAt for \"startAt\" tweens that re-capture things to ensure that if the pre-tween values changed since the tween was created, they're recorded.\n            prevStartAt._lazy = 0;\n        }\n        if (startAt) {\n            _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({\n                data: \"isStart\",\n                overwrite: false,\n                parent: parent,\n                immediateRender: true,\n                lazy: !prevStartAt && _isNotFalse(lazy),\n                startAt: null,\n                delay: 0,\n                onUpdate: onUpdate && function() {\n                    return _callback(tween, \"onUpdate\");\n                },\n                stagger: 0\n            }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);\n            tween._startAt._dp = 0; // don't allow it to get put back into root timeline! Like when revert() is called and totalTime() gets set.\n            tween._startAt._sat = tween; // used in globalTime(). _sat stands for _startAtTween\n            time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.\n            if (immediateRender) {\n                if (dur && time <= 0 && tTime <= 0) {\n                    // check tTime here because in the case of a yoyo tween whose playhead gets pushed to the end like tween.progress(1), we should allow it through so that the onComplete gets fired properly.\n                    time && (tween._zTime = time);\n                    return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.\n                }\n            }\n        } else if (runBackwards && dur) {\n            //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)\n            if (!prevStartAt) {\n                time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0\n                p = _setDefaults({\n                    overwrite: false,\n                    data: \"isFromStart\",\n                    //we tag the tween with as \"isFromStart\" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a \"from()\" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:\"height\", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.\n                    lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),\n                    immediateRender: immediateRender,\n                    //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)\n                    stagger: 0,\n                    parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(\".class\", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})\n                }, cleanVars);\n                harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})\n                _removeFromParent(tween._startAt = Tween.set(targets, p));\n                tween._startAt._dp = 0; // don't allow it to get put back into root timeline!\n                tween._startAt._sat = tween; // used in globalTime()\n                time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));\n                tween._zTime = time;\n                if (!immediateRender) {\n                    _initTween(tween._startAt, _tinyNum, _tinyNum); //ensures that the initial values are recorded\n                } else if (!time) {\n                    return;\n                }\n            }\n        }\n        tween._pt = tween._ptCache = 0;\n        lazy = dur && _isNotFalse(lazy) || lazy && !dur;\n        for(i = 0; i < targets.length; i++){\n            target = targets[i];\n            gsData = target._gsap || _harness(targets)[i]._gsap;\n            tween._ptLookup[i] = ptLookup = {};\n            _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)\n            index = fullTargets === targets ? i : fullTargets.indexOf(target);\n            if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {\n                tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);\n                plugin._props.forEach(function(name) {\n                    ptLookup[name] = pt;\n                });\n                plugin.priority && (hasPriority = 1);\n            }\n            if (!harness || harnessVars) {\n                for(p in cleanVars){\n                    if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {\n                        plugin.priority && (hasPriority = 1);\n                    } else {\n                        ptLookup[p] = pt = _addPropTween.call(tween, target, p, \"get\", cleanVars[p], index, fullTargets, 0, vars.stringFilter);\n                    }\n                }\n            }\n            tween._op && tween._op[i] && tween.kill(target, tween._op[i]);\n            if (autoOverwrite && tween._pt) {\n                _overwritingTween = tween;\n                _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!\n                overwritten = !tween.parent;\n                _overwritingTween = 0;\n            }\n            tween._pt && lazy && (_lazyLookup[gsData.id] = 1);\n        }\n        hasPriority && _sortPropTweensByPriority(tween);\n        tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.\n    }\n    tween._onUpdate = onUpdate;\n    tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.\n    keyframes && time <= 0 && tl.render(_bigNum, true, true); // if there's a 0% keyframe, it'll render in the \"before\" state for any staggered/delayed animations thus when the following tween initializes, it'll use the \"before\" state instead of the \"after\" state as the initial values.\n}, _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {\n    var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property], pt, rootPT, lookup, i;\n    if (!ptCache) {\n        ptCache = tween._ptCache[property] = [];\n        lookup = tween._ptLookup;\n        i = tween._targets.length;\n        while(i--){\n            pt = lookup[i][property];\n            if (pt && pt.d && pt.d._pt) {\n                // it's a plugin, so find the nested PropTween\n                pt = pt.d._pt;\n                while(pt && pt.p !== property && pt.fp !== property){\n                    // \"fp\" is functionParam for things like setting CSS variables which require .setProperty(\"--var-name\", value)\n                    pt = pt._next;\n                }\n            }\n            if (!pt) {\n                // there is no PropTween associated with that property, so we must FORCE one to be created and ditch out of this\n                // if the tween has other properties that already rendered at new positions, we'd normally have to rewind to put them back like tween.render(0, true) before forcing an _initTween(), but that can create another edge case like tweening a timeline's progress would trigger onUpdates to fire which could move other things around. It's better to just inform users that .resetTo() should ONLY be used for tweens that already have that property. For example, you can't gsap.to(...{ y: 0 }) and then tween.restTo(\"x\", 200) for example.\n                _forceAllPropTweens = 1; // otherwise, when we _addPropTween() and it finds no change between the start and end values, it skips creating a PropTween (for efficiency...why tween when there's no difference?) but in this case we NEED that PropTween created so we can edit it.\n                tween.vars[property] = \"+=0\";\n                _initTween(tween, time);\n                _forceAllPropTweens = 0;\n                return skipRecursion ? _warn(property + \" not eligible for reset\") : 1; // if someone tries to do a quickTo() on a special property like borderRadius which must get split into 4 different properties, that's not eligible for .resetTo().\n            }\n            ptCache.push(pt);\n        }\n    }\n    i = ptCache.length;\n    while(i--){\n        rootPT = ptCache[i];\n        pt = rootPT._pt || rootPT; // complex values may have nested PropTweens. We only accommodate the FIRST value.\n        pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;\n        pt.c = value - pt.s;\n        rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e)); // mainly for CSSPlugin (end value)\n        rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b)); // (beginning value)\n    }\n}, _addAliasesToVars = function _addAliasesToVars(targets, vars) {\n    var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p, i, aliases;\n    if (!propertyAliases) {\n        return vars;\n    }\n    copy = _merge({}, vars);\n    for(p in propertyAliases){\n        if (p in copy) {\n            aliases = propertyAliases[p].split(\",\");\n            i = aliases.length;\n            while(i--){\n                copy[aliases[i]] = copy[p];\n            }\n        }\n    }\n    return copy;\n}, // parses multiple formats, like {\"0%\": {x: 100}, {\"50%\": {x: -20}} and { x: {\"0%\": 100, \"50%\": -20} }, and an \"ease\" can be set on any object. We populate an \"allProps\" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a \"t\" (time), \"v\", (value), and \"e\" (ease) property. This allows us to piece together a timeline later.\n_parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {\n    var ease = obj.ease || easeEach || \"power1.inOut\", p, a;\n    if (_isArray(obj)) {\n        a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease\n        obj.forEach(function(value, i) {\n            return a.push({\n                t: i / (obj.length - 1) * 100,\n                v: value,\n                e: ease\n            });\n        });\n    } else {\n        for(p in obj){\n            a = allProps[p] || (allProps[p] = []);\n            p === \"ease\" || a.push({\n                t: parseFloat(prop),\n                v: obj[p],\n                e: ease\n            });\n        }\n    }\n}, _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {\n    return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf(\"random(\") ? _replaceRandom(value) : value;\n}, _staggerTweenProps = _callbackNames + \"repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert\", _staggerPropsToSkip = {};\n_forEachName(_staggerTweenProps + \",id,stagger,delay,duration,paused,scrollTrigger\", function(name) {\n    return _staggerPropsToSkip[name] = 1;\n});\n/*\n * --------------------------------------------------------------------------------------\n * TWEEN\n * --------------------------------------------------------------------------------------\n */ var Tween = /*#__PURE__*/ function(_Animation2) {\n    _inheritsLoose(Tween, _Animation2);\n    function Tween(targets, vars, position, skipInherit) {\n        var _this3;\n        if (typeof vars === \"number\") {\n            position.duration = vars;\n            vars = position;\n            position = null;\n        }\n        _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;\n        var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : \"length\" in vars) ? [\n            targets\n        ] : toArray(targets), tl, i, copy, l, p, curTarget, staggerFunc, staggerVarsToMerge;\n        _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn(\"GSAP target \" + targets + \" not found. https://gsap.com\", !_config.nullTargetWarn) || [];\n        _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property\n        _this3._overwrite = overwrite;\n        if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n            vars = _this3.vars;\n            tl = _this3.timeline = new Timeline({\n                data: \"nested\",\n                defaults: defaults || {},\n                targets: parent && parent.data === \"nested\" ? parent.vars.targets : parsedTargets\n            }); // we need to store the targets because for staggers and keyframes, we end up creating an individual tween for each but function-based values need to know the index and the whole Array of targets.\n            tl.kill();\n            tl.parent = tl._dp = _assertThisInitialized(_this3);\n            tl._start = 0;\n            if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n                l = parsedTargets.length;\n                staggerFunc = stagger && distribute(stagger);\n                if (_isObject(stagger)) {\n                    //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.\n                    for(p in stagger){\n                        if (~_staggerTweenProps.indexOf(p)) {\n                            staggerVarsToMerge || (staggerVarsToMerge = {});\n                            staggerVarsToMerge[p] = stagger[p];\n                        }\n                    }\n                }\n                for(i = 0; i < l; i++){\n                    copy = _copyExcluding(vars, _staggerPropsToSkip);\n                    copy.stagger = 0;\n                    yoyoEase && (copy.yoyoEase = yoyoEase);\n                    staggerVarsToMerge && _merge(copy, staggerVarsToMerge);\n                    curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.\n                    copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);\n                    copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;\n                    if (!stagger && l === 1 && copy.delay) {\n                        // if someone does delay:\"random(1, 5)\", repeat:-1, for example, the delay shouldn't be inside the repeat.\n                        _this3._delay = delay = copy.delay;\n                        _this3._start += delay;\n                        copy.delay = 0;\n                    }\n                    tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);\n                    tl._ease = _easeMap.none;\n                }\n                tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!\n            } else if (keyframes) {\n                _inheritDefaults(_setDefaults(tl.vars.defaults, {\n                    ease: \"none\"\n                }));\n                tl._ease = _parseEase(keyframes.ease || vars.ease || \"none\");\n                var time = 0, a, kf, v;\n                if (_isArray(keyframes)) {\n                    keyframes.forEach(function(frame) {\n                        return tl.to(parsedTargets, frame, \">\");\n                    });\n                    tl.duration(); // to ensure tl._dur is cached because we tap into it for performance purposes in the render() method.\n                } else {\n                    copy = {};\n                    for(p in keyframes){\n                        p === \"ease\" || p === \"easeEach\" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);\n                    }\n                    for(p in copy){\n                        a = copy[p].sort(function(a, b) {\n                            return a.t - b.t;\n                        });\n                        time = 0;\n                        for(i = 0; i < a.length; i++){\n                            kf = a[i];\n                            v = {\n                                ease: kf.e,\n                                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration\n                            };\n                            v[p] = kf.v;\n                            tl.to(parsedTargets, v, time);\n                            time += v.duration;\n                        }\n                    }\n                    tl.duration() < duration && tl.to({}, {\n                        duration: duration - tl.duration()\n                    }); // in case keyframes didn't go to 100%\n                }\n            }\n            duration || _this3.duration(duration = tl.duration());\n        } else {\n            _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)\n        }\n        if (overwrite === true && !_suppressOverwrites) {\n            _overwritingTween = _assertThisInitialized(_this3);\n            _globalTimeline.killTweensOf(parsedTargets);\n            _overwritingTween = 0;\n        }\n        _addToTimeline(parent, _assertThisInitialized(_this3), position);\n        vars.reversed && _this3.reverse();\n        vars.paused && _this3.paused(true);\n        if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== \"nested\") {\n            _this3._tTime = -_tinyNum; //forces a render without having to set the render() \"force\" parameter to true because we want to allow lazying by default (using the \"force\" parameter always forces an immediate full render)\n            _this3.render(Math.max(0, -delay) || 0); //in case delay is negative\n        }\n        scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);\n        return _this3;\n    }\n    var _proto3 = Tween.prototype;\n    _proto3.render = function render(totalTime, suppressEvents, force) {\n        var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline, yoyoEase;\n        if (!dur) {\n            _renderZeroDurationTween(this, totalTime, suppressEvents, force);\n        } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {\n            //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)\n            time = tTime;\n            timeline = this.timeline;\n            if (this._repeat) {\n                //adjust the time for repeats and yoyos\n                cycleDuration = dur + this._rDelay;\n                if (this._repeat < -1 && isNegative) {\n                    return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n                }\n                time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\n                if (tTime === tDur) {\n                    // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)\n                    iteration = this._repeat;\n                    time = dur;\n                } else {\n                    iteration = ~~(tTime / cycleDuration);\n                    if (iteration && iteration === _roundPrecise(tTime / cycleDuration)) {\n                        time = dur;\n                        iteration--;\n                    }\n                    time > dur && (time = dur);\n                }\n                isYoyo = this._yoyo && iteration & 1;\n                if (isYoyo) {\n                    yoyoEase = this._yEase;\n                    time = dur - time;\n                }\n                prevIteration = _animationCycle(this._tTime, cycleDuration);\n                if (time === prevTime && !force && this._initted && iteration === prevIteration) {\n                    //could be during the repeatDelay part. No need to render and fire callbacks.\n                    this._tTime = tTime;\n                    return this;\n                }\n                if (iteration !== prevIteration) {\n                    timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality\n                    if (this.vars.repeatRefresh && !isYoyo && !this._lock && this._time !== cycleDuration && this._initted) {\n                        // this._time will === cycleDuration when we render at EXACTLY the end of an iteration. Without this condition, it'd often do the repeatRefresh render TWICE (again on the very next tick).\n                        this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.\n                        this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;\n                    }\n                }\n            }\n            if (!this._initted) {\n                if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {\n                    this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.\n                    return this;\n                }\n                if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {\n                    // rare edge case - during initialization, an onUpdate in the _startAt (.fromTo()) might force this tween to render at a different spot in which case we should ditch this render() call so that it doesn't revert the values. But we also don't want to dump if we're doing a repeatRefresh render!\n                    return this;\n                }\n                if (dur !== this._dur) {\n                    // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.\n                    return this.render(totalTime, suppressEvents, force);\n                }\n            }\n            this._tTime = tTime;\n            this._time = time;\n            if (!this._act && this._ts) {\n                this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.\n                this._lazy = 0;\n            }\n            this.ratio = ratio = (yoyoEase || this._ease)(time / dur);\n            if (this._from) {\n                this.ratio = ratio = 1 - ratio;\n            }\n            if (time && !prevTime && !suppressEvents && !iteration) {\n                _callback(this, \"onStart\");\n                if (this._tTime !== tTime) {\n                    // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.\n                    return this;\n                }\n            }\n            pt = this._pt;\n            while(pt){\n                pt.r(ratio, pt.d);\n                pt = pt._next;\n            }\n            timeline && timeline.render(totalTime < 0 ? totalTime : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);\n            if (this._onUpdate && !suppressEvents) {\n                isNegative && _rewindStartAt(this, totalTime, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.\n                _callback(this, \"onUpdate\");\n            }\n            this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, \"onRepeat\");\n            if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {\n                isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);\n                (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\n                if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {\n                    // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();\n                    _callback(this, tTime === tDur ? \"onComplete\" : \"onReverseComplete\", true);\n                    this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n                }\n            }\n        }\n        return this;\n    };\n    _proto3.targets = function targets() {\n        return this._targets;\n    };\n    _proto3.invalidate = function invalidate(soft) {\n        // \"soft\" gives us a way to clear out everything EXCEPT the recorded pre-\"from\" portion of from() tweens. Otherwise, for example, if you tween.progress(1).render(0, true true).invalidate(), the \"from\" values would persist and then on the next render, the from() tweens would initialize and the current value would match the \"from\" values, thus animate from the same value to the same value (no animation). We tap into this in ScrollTrigger's refresh() where we must push a tween to completion and then back again but honor its init state in case the tween is dependent on another tween further up on the page.\n        (!soft || !this.vars.runBackwards) && (this._startAt = 0);\n        this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;\n        this._ptLookup = [];\n        this.timeline && this.timeline.invalidate(soft);\n        return _Animation2.prototype.invalidate.call(this, soft);\n    };\n    _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {\n        _tickerActive || _ticker.wake();\n        this._ts || this.play();\n        var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;\n        this._initted || _initTween(this, time);\n        ratio = this._ease(time / this._dur); // don't just get tween.ratio because it may not have rendered yet.\n        // possible future addition to allow an object with multiple values to update, like tween.resetTo({x: 100, y: 200}); At this point, it doesn't seem worth the added kb given the fact that most users will likely opt for the convenient gsap.quickTo() way of interacting with this method.\n        // if (_isObject(property)) { // performance optimization\n        // \tfor (p in property) {\n        // \t\tif (_updatePropTweens(this, p, property[p], value ? value[p] : null, start, ratio, time)) {\n        // \t\t\treturn this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.\n        // \t\t}\n        // \t}\n        // } else {\n        if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {\n            return this.resetTo(property, value, start, startIsRelative, 1); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.\n        } //}\n        _alignPlayhead(this, 0);\n        this.parent || _addLinkedListItem(this._dp, this, \"_first\", \"_last\", this._dp._sort ? \"_start\" : 0);\n        return this.render(0);\n    };\n    _proto3.kill = function kill(targets, vars) {\n        if (vars === void 0) {\n            vars = \"all\";\n        }\n        if (!targets && (!vars || vars === \"all\")) {\n            this._lazy = this._pt = 0;\n            return this.parent ? _interrupt(this) : this;\n        }\n        if (this.timeline) {\n            var tDur = this.timeline.totalDuration();\n            this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.\n            this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.\n            return this;\n        }\n        var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i;\n        if ((!vars || vars === \"all\") && _arraysMatch(parsedTargets, killingTargets)) {\n            vars === \"all\" && (this._pt = 0);\n            return _interrupt(this);\n        }\n        overwrittenProps = this._op = this._op || [];\n        if (vars !== \"all\") {\n            //so people can pass in a comma-delimited list of property names\n            if (_isString(vars)) {\n                p = {};\n                _forEachName(vars, function(name) {\n                    return p[name] = 1;\n                });\n                vars = p;\n            }\n            vars = _addAliasesToVars(parsedTargets, vars);\n        }\n        i = parsedTargets.length;\n        while(i--){\n            if (~killingTargets.indexOf(parsedTargets[i])) {\n                curLookup = propTweenLookup[i];\n                if (vars === \"all\") {\n                    overwrittenProps[i] = vars;\n                    props = curLookup;\n                    curOverwriteProps = {};\n                } else {\n                    curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};\n                    props = vars;\n                }\n                for(p in props){\n                    pt = curLookup && curLookup[p];\n                    if (pt) {\n                        if (!(\"kill\" in pt.d) || pt.d.kill(p) === true) {\n                            _removeLinkedListItem(this, pt, \"_pt\");\n                        }\n                        delete curLookup[p];\n                    }\n                    if (curOverwriteProps !== \"all\") {\n                        curOverwriteProps[p] = 1;\n                    }\n                }\n            }\n        }\n        this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.\n        return this;\n    };\n    Tween.to = function to(targets, vars) {\n        return new Tween(targets, vars, arguments[2]);\n    };\n    Tween.from = function from(targets, vars) {\n        return _createTweenType(1, arguments);\n    };\n    Tween.delayedCall = function delayedCall(delay, callback, params, scope) {\n        return new Tween(callback, 0, {\n            immediateRender: false,\n            lazy: false,\n            overwrite: false,\n            delay: delay,\n            onComplete: callback,\n            onReverseComplete: callback,\n            onCompleteParams: params,\n            onReverseCompleteParams: params,\n            callbackScope: scope\n        }); // we must use onReverseComplete too for things like timeline.add(() => {...}) which should be triggered in BOTH directions (forward and reverse)\n    };\n    Tween.fromTo = function fromTo(targets, fromVars, toVars) {\n        return _createTweenType(2, arguments);\n    };\n    Tween.set = function set(targets, vars) {\n        vars.duration = 0;\n        vars.repeatDelay || (vars.repeat = 0);\n        return new Tween(targets, vars);\n    };\n    Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n        return _globalTimeline.killTweensOf(targets, props, onlyActive);\n    };\n    return Tween;\n}(Animation);\n_setDefaults(Tween.prototype, {\n    _targets: [],\n    _lazy: 0,\n    _startAt: 0,\n    _op: 0,\n    _onInit: 0\n}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)\n// _forEachName(\"to,from,fromTo,set,call,add,addLabel,addPause\", name => {\n// \tTween.prototype[name] = function() {\n// \t\tlet tl = new Timeline();\n// \t\treturn _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));\n// \t}\n// });\n//for backward compatibility. Leverage the timeline calls.\n_forEachName(\"staggerTo,staggerFrom,staggerFromTo\", function(name) {\n    Tween[name] = function() {\n        var tl = new Timeline(), params = _slice.call(arguments, 0);\n        params.splice(name === \"staggerFromTo\" ? 5 : 4, 0, 0);\n        return tl[name].apply(tl, params);\n    };\n});\n/*\n * --------------------------------------------------------------------------------------\n * PROPTWEEN\n * --------------------------------------------------------------------------------------\n */ var _setterPlain = function _setterPlain(target, property, value) {\n    return target[property] = value;\n}, _setterFunc = function _setterFunc(target, property, value) {\n    return target[property](value);\n}, _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {\n    return target[property](data.fp, value);\n}, _setterAttribute = function _setterAttribute(target, property, value) {\n    return target.setAttribute(property, value);\n}, _getSetter = function _getSetter(target, property) {\n    return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;\n}, _renderPlain = function _renderPlain(ratio, data) {\n    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);\n}, _renderBoolean = function _renderBoolean(ratio, data) {\n    return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);\n}, _renderComplexString = function _renderComplexString(ratio, data) {\n    var pt = data._pt, s = \"\";\n    if (!ratio && data.b) {\n        //b = beginning string\n        s = data.b;\n    } else if (ratio === 1 && data.e) {\n        //e = ending string\n        s = data.e;\n    } else {\n        while(pt){\n            s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the \"p\" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.\n            pt = pt._next;\n        }\n        s += data.c; //we use the \"c\" of the PropTween to store the final chunk of non-numeric text.\n    }\n    data.set(data.t, data.p, s, data);\n}, _renderPropTweens = function _renderPropTweens(ratio, data) {\n    var pt = data._pt;\n    while(pt){\n        pt.r(ratio, pt.d);\n        pt = pt._next;\n    }\n}, _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {\n    var pt = this._pt, next;\n    while(pt){\n        next = pt._next;\n        pt.p === property && pt.modifier(modifier, tween, target);\n        pt = next;\n    }\n}, _killPropTweensOf = function _killPropTweensOf(property) {\n    var pt = this._pt, hasNonDependentRemaining, next;\n    while(pt){\n        next = pt._next;\n        if (pt.p === property && !pt.op || pt.op === property) {\n            _removeLinkedListItem(this, pt, \"_pt\");\n        } else if (!pt.dep) {\n            hasNonDependentRemaining = 1;\n        }\n        pt = next;\n    }\n    return !hasNonDependentRemaining;\n}, _setterWithModifier = function _setterWithModifier(target, property, value, data) {\n    data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);\n}, _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {\n    var pt = parent._pt, next, pt2, first, last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)\n    while(pt){\n        next = pt._next;\n        pt2 = first;\n        while(pt2 && pt2.pr > pt.pr){\n            pt2 = pt2._next;\n        }\n        if (pt._prev = pt2 ? pt2._prev : last) {\n            pt._prev._next = pt;\n        } else {\n            first = pt;\n        }\n        if (pt._next = pt2) {\n            pt2._prev = pt;\n        } else {\n            last = pt;\n        }\n        pt = next;\n    }\n    parent._pt = first;\n}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)\nvar PropTween = /*#__PURE__*/ function() {\n    function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {\n        this.t = target;\n        this.s = start;\n        this.c = change;\n        this.p = prop;\n        this.r = renderer || _renderPlain;\n        this.d = data || this;\n        this.set = setter || _setterPlain;\n        this.pr = priority || 0;\n        this._next = next;\n        if (next) {\n            next._prev = this;\n        }\n    }\n    var _proto4 = PropTween.prototype;\n    _proto4.modifier = function modifier(func, tween, target) {\n        this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)\n        this.set = _setterWithModifier;\n        this.m = func;\n        this.mt = target; //modifier target\n        this.tween = tween;\n    };\n    return PropTween;\n}(); //Initialization tasks\n_forEachName(_callbackNames + \"parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger\", function(name) {\n    return _reservedProps[name] = 1;\n});\n_globals.TweenMax = _globals.TweenLite = Tween;\n_globals.TimelineLite = _globals.TimelineMax = Timeline;\n_globalTimeline = new Timeline({\n    sortChildren: false,\n    defaults: _defaults,\n    autoRemoveChildren: true,\n    id: \"root\",\n    smoothChildTiming: true\n});\n_config.stringFilter = _colorStringFilter;\nvar _media = [], _listeners = {}, _emptyArray = [], _lastMediaTime = 0, _contextID = 0, _dispatch = function _dispatch(type) {\n    return (_listeners[type] || _emptyArray).map(function(f) {\n        return f();\n    });\n}, _onMediaChange = function _onMediaChange() {\n    var time = Date.now(), matches = [];\n    if (time - _lastMediaTime > 2) {\n        _dispatch(\"matchMediaInit\");\n        _media.forEach(function(c) {\n            var queries = c.queries, conditions = c.conditions, match, p, anyMatch, toggled;\n            for(p in queries){\n                match = _win.matchMedia(queries[p]).matches; // Firefox doesn't update the \"matches\" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.\n                match && (anyMatch = 1);\n                if (match !== conditions[p]) {\n                    conditions[p] = match;\n                    toggled = 1;\n                }\n            }\n            if (toggled) {\n                c.revert();\n                anyMatch && matches.push(c);\n            }\n        });\n        _dispatch(\"matchMediaRevert\");\n        matches.forEach(function(c) {\n            return c.onMatch(c, function(func) {\n                return c.add(null, func);\n            });\n        });\n        _lastMediaTime = time;\n        _dispatch(\"matchMedia\");\n    }\n};\nvar Context = /*#__PURE__*/ function() {\n    function Context(func, scope) {\n        this.selector = scope && selector(scope);\n        this.data = [];\n        this._r = []; // returned/cleanup functions\n        this.isReverted = false;\n        this.id = _contextID++; // to work around issues that frameworks like Vue cause by making things into Proxies which make it impossible to do something like _media.indexOf(this) because \"this\" would no longer refer to the Context instance itself - it'd refer to a Proxy! We needed a way to identify the context uniquely\n        func && this.add(func);\n    }\n    var _proto5 = Context.prototype;\n    _proto5.add = function add(name, func, scope) {\n        // possible future addition if we need the ability to add() an animation to a context and for whatever reason cannot create that animation inside of a context.add(() => {...}) function.\n        // if (name && _isFunction(name.revert)) {\n        // \tthis.data.push(name);\n        // \treturn (name._ctx = this);\n        // }\n        if (_isFunction(name)) {\n            scope = func;\n            func = name;\n            name = _isFunction;\n        }\n        var self = this, f = function f() {\n            var prev = _context, prevSelector = self.selector, result;\n            prev && prev !== self && prev.data.push(self);\n            scope && (self.selector = selector(scope));\n            _context = self;\n            result = func.apply(self, arguments);\n            _isFunction(result) && self._r.push(result);\n            _context = prev;\n            self.selector = prevSelector;\n            self.isReverted = false;\n            return result;\n        };\n        self.last = f;\n        return name === _isFunction ? f(self, function(func) {\n            return self.add(null, func);\n        }) : name ? self[name] = f : f;\n    };\n    _proto5.ignore = function ignore(func) {\n        var prev = _context;\n        _context = null;\n        func(this);\n        _context = prev;\n    };\n    _proto5.getTweens = function getTweens() {\n        var a = [];\n        this.data.forEach(function(e) {\n            return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === \"nested\") && a.push(e);\n        });\n        return a;\n    };\n    _proto5.clear = function clear() {\n        this._r.length = this.data.length = 0;\n    };\n    _proto5.kill = function kill(revert, matchMedia) {\n        var _this4 = this;\n        if (revert) {\n            (function() {\n                var tweens = _this4.getTweens(), i = _this4.data.length, t;\n                while(i--){\n                    // Flip plugin tweens are very different in that they should actually be pushed to their end. The plugin replaces the timeline's .revert() method to do exactly that. But we also need to remove any of those nested tweens inside the flip timeline so that they don't get individually reverted.\n                    t = _this4.data[i];\n                    if (t.data === \"isFlip\") {\n                        t.revert();\n                        t.getChildren(true, true, false).forEach(function(tween) {\n                            return tweens.splice(tweens.indexOf(tween), 1);\n                        });\n                    }\n                } // save as an object so that we can cache the globalTime for each tween to optimize performance during the sort\n                tweens.map(function(t) {\n                    return {\n                        g: t._dur || t._delay || t._sat && !t._sat.vars.immediateRender ? t.globalTime(0) : -Infinity,\n                        t: t\n                    };\n                }).sort(function(a, b) {\n                    return b.g - a.g || -Infinity;\n                }).forEach(function(o) {\n                    return o.t.revert(revert);\n                }); // note: all of the _startAt tweens should be reverted in reverse order that they were created, and they'll all have the same globalTime (-1) so the \" || -1\" in the sort keeps the order properly.\n                i = _this4.data.length;\n                while(i--){\n                    // make sure we loop backwards so that, for example, SplitTexts that were created later on the same element get reverted first\n                    t = _this4.data[i];\n                    if (t instanceof Timeline) {\n                        if (t.data !== \"nested\") {\n                            t.scrollTrigger && t.scrollTrigger.revert();\n                            t.kill(); // don't revert() the timeline because that's duplicating efforts since we already reverted all the tweens\n                        }\n                    } else {\n                        !(t instanceof Tween) && t.revert && t.revert(revert);\n                    }\n                }\n                _this4._r.forEach(function(f) {\n                    return f(revert, _this4);\n                });\n                _this4.isReverted = true;\n            })();\n        } else {\n            this.data.forEach(function(e) {\n                return e.kill && e.kill();\n            });\n        }\n        this.clear();\n        if (matchMedia) {\n            var i = _media.length;\n            while(i--){\n                // previously, we checked _media.indexOf(this), but some frameworks like Vue enforce Proxy objects that make it impossible to get the proper result that way, so we must use a unique ID number instead.\n                _media[i].id === this.id && _media.splice(i, 1);\n            }\n        }\n    };\n    _proto5.revert = function revert(config) {\n        this.kill(config || {});\n    };\n    return Context;\n}();\nvar MatchMedia = /*#__PURE__*/ function() {\n    function MatchMedia(scope) {\n        this.contexts = [];\n        this.scope = scope;\n        _context && _context.data.push(this);\n    }\n    var _proto6 = MatchMedia.prototype;\n    _proto6.add = function add(conditions, func, scope) {\n        _isObject(conditions) || (conditions = {\n            matches: conditions\n        });\n        var context = new Context(0, scope || this.scope), cond = context.conditions = {}, mq, p, active;\n        _context && !context.selector && (context.selector = _context.selector); // in case a context is created inside a context. Like a gsap.matchMedia() that's inside a scoped gsap.context()\n        this.contexts.push(context);\n        func = context.add(\"onMatch\", func);\n        context.queries = conditions;\n        for(p in conditions){\n            if (p === \"all\") {\n                active = 1;\n            } else {\n                mq = _win.matchMedia(conditions[p]);\n                if (mq) {\n                    _media.indexOf(context) < 0 && _media.push(context);\n                    (cond[p] = mq.matches) && (active = 1);\n                    mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener(\"change\", _onMediaChange);\n                }\n            }\n        }\n        active && func(context, function(f) {\n            return context.add(null, f);\n        });\n        return this;\n    } // refresh() {\n    ;\n    _proto6.revert = function revert(config) {\n        this.kill(config || {});\n    };\n    _proto6.kill = function kill(revert) {\n        this.contexts.forEach(function(c) {\n            return c.kill(revert, true);\n        });\n    };\n    return MatchMedia;\n}();\n/*\n * --------------------------------------------------------------------------------------\n * GSAP\n * --------------------------------------------------------------------------------------\n */ var _gsap = {\n    registerPlugin: function registerPlugin() {\n        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            args[_key2] = arguments[_key2];\n        }\n        args.forEach(function(config) {\n            return _createPlugin(config);\n        });\n    },\n    timeline: function timeline(vars) {\n        return new Timeline(vars);\n    },\n    getTweensOf: function getTweensOf(targets, onlyActive) {\n        return _globalTimeline.getTweensOf(targets, onlyActive);\n    },\n    getProperty: function getProperty(target, property, unit, uncache) {\n        _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in\n        var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;\n        unit === \"native\" && (unit = \"\");\n        return !target ? target : !property ? function(property, unit, uncache) {\n            return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n        } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n    },\n    quickSetter: function quickSetter(target, property, unit) {\n        target = toArray(target);\n        if (target.length > 1) {\n            var setters = target.map(function(t) {\n                return gsap.quickSetter(t, property, unit);\n            }), l = setters.length;\n            return function(value) {\n                var i = l;\n                while(i--){\n                    setters[i](value);\n                }\n            };\n        }\n        target = target[0] || {};\n        var Plugin = _plugins[property], cache = _getCache(target), p = cache.harness && (cache.harness.aliases || {})[property] || property, // in case it's an alias, like \"rotate\" for \"rotation\".\n        setter = Plugin ? function setter(value) {\n            var p = new Plugin();\n            _quickTween._pt = 0;\n            p.init(target, unit ? value + unit : value, _quickTween, 0, [\n                target\n            ]);\n            p.render(1, p);\n            _quickTween._pt && _renderPropTweens(1, _quickTween);\n        } : cache.set(target, p);\n        return Plugin ? setter : function(value) {\n            return setter(target, p, unit ? value + unit : value, cache, 1);\n        };\n    },\n    quickTo: function quickTo(target, property, vars) {\n        var _merge2;\n        var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = \"+=0.1\", _merge2.paused = true, _merge2), vars || {})), func = function func(value, start, startIsRelative) {\n            return tween.resetTo(property, value, start, startIsRelative);\n        };\n        func.tween = tween;\n        return func;\n    },\n    isTweening: function isTweening(targets) {\n        return _globalTimeline.getTweensOf(targets, true).length > 0;\n    },\n    defaults: function defaults(value) {\n        value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));\n        return _mergeDeep(_defaults, value || {});\n    },\n    config: function config(value) {\n        return _mergeDeep(_config, value || {});\n    },\n    registerEffect: function registerEffect(_ref3) {\n        var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults = _ref3.defaults, extendTimeline = _ref3.extendTimeline;\n        (plugins || \"\").split(\",\").forEach(function(pluginName) {\n            return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + \" effect requires \" + pluginName + \" plugin.\");\n        });\n        _effects[name] = function(targets, vars, tl) {\n            return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);\n        };\n        if (extendTimeline) {\n            Timeline.prototype[name] = function(targets, vars, position) {\n                return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);\n            };\n        }\n    },\n    registerEase: function registerEase(name, ease) {\n        _easeMap[name] = _parseEase(ease);\n    },\n    parseEase: function parseEase(ease, defaultEase) {\n        return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;\n    },\n    getById: function getById(id) {\n        return _globalTimeline.getById(id);\n    },\n    exportRoot: function exportRoot(vars, includeDelayedCalls) {\n        if (vars === void 0) {\n            vars = {};\n        }\n        var tl = new Timeline(vars), child, next;\n        tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);\n        _globalTimeline.remove(tl);\n        tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).\n        tl._time = tl._tTime = _globalTimeline._time;\n        child = _globalTimeline._first;\n        while(child){\n            next = child._next;\n            if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {\n                _addToTimeline(tl, child, child._start - child._delay);\n            }\n            child = next;\n        }\n        _addToTimeline(_globalTimeline, tl, 0);\n        return tl;\n    },\n    context: function context(func, scope) {\n        return func ? new Context(func, scope) : _context;\n    },\n    matchMedia: function matchMedia(scope) {\n        return new MatchMedia(scope);\n    },\n    matchMediaRefresh: function matchMediaRefresh() {\n        return _media.forEach(function(c) {\n            var cond = c.conditions, found, p;\n            for(p in cond){\n                if (cond[p]) {\n                    cond[p] = false;\n                    found = 1;\n                }\n            }\n            found && c.revert();\n        }) || _onMediaChange();\n    },\n    addEventListener: function addEventListener(type, callback) {\n        var a = _listeners[type] || (_listeners[type] = []);\n        ~a.indexOf(callback) || a.push(callback);\n    },\n    removeEventListener: function removeEventListener(type, callback) {\n        var a = _listeners[type], i = a && a.indexOf(callback);\n        i >= 0 && a.splice(i, 1);\n    },\n    utils: {\n        wrap: wrap,\n        wrapYoyo: wrapYoyo,\n        distribute: distribute,\n        random: random,\n        snap: snap,\n        normalize: normalize,\n        getUnit: getUnit,\n        clamp: clamp,\n        splitColor: splitColor,\n        toArray: toArray,\n        selector: selector,\n        mapRange: mapRange,\n        pipe: pipe,\n        unitize: unitize,\n        interpolate: interpolate,\n        shuffle: shuffle\n    },\n    install: _install,\n    effects: _effects,\n    ticker: _ticker,\n    updateRoot: Timeline.updateRoot,\n    plugins: _plugins,\n    globalTimeline: _globalTimeline,\n    core: {\n        PropTween: PropTween,\n        globals: _addGlobal,\n        Tween: Tween,\n        Timeline: Timeline,\n        Animation: Animation,\n        getCache: _getCache,\n        _removeLinkedListItem: _removeLinkedListItem,\n        reverting: function reverting() {\n            return _reverting;\n        },\n        context: function context(toAdd) {\n            if (toAdd && _context) {\n                _context.data.push(toAdd);\n                toAdd._ctx = _context;\n            }\n            return _context;\n        },\n        suppressOverwrites: function suppressOverwrites(value) {\n            return _suppressOverwrites = value;\n        }\n    }\n};\n_forEachName(\"to,from,fromTo,delayedCall,set,killTweensOf\", function(name) {\n    return _gsap[name] = Tween[name];\n});\n_ticker.add(Timeline.updateRoot);\n_quickTween = _gsap.to({}, {\n    duration: 0\n}); // ---- EXTRA PLUGINS --------------------------------------------------------\nvar _getPluginPropTween = function _getPluginPropTween(plugin, prop) {\n    var pt = plugin._pt;\n    while(pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop){\n        pt = pt._next;\n    }\n    return pt;\n}, _addModifiers = function _addModifiers(tween, modifiers) {\n    var targets = tween._targets, p, i, pt;\n    for(p in modifiers){\n        i = targets.length;\n        while(i--){\n            pt = tween._ptLookup[i][p];\n            if (pt && (pt = pt.d)) {\n                if (pt._pt) {\n                    // is a plugin\n                    pt = _getPluginPropTween(pt, p);\n                }\n                pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);\n            }\n        }\n    }\n}, _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {\n    return {\n        name: name,\n        rawVars: 1,\n        //don't pre-process function-based values or \"random()\" strings.\n        init: function init(target, vars, tween) {\n            tween._onInit = function(tween) {\n                var temp, p;\n                if (_isString(vars)) {\n                    temp = {};\n                    _forEachName(vars, function(name) {\n                        return temp[name] = 1;\n                    }); //if the user passes in a comma-delimited list of property names to roundProps, like \"x,y\", we round to whole numbers.\n                    vars = temp;\n                }\n                if (modifier) {\n                    temp = {};\n                    for(p in vars){\n                        temp[p] = modifier(vars[p]);\n                    }\n                    vars = temp;\n                }\n                _addModifiers(tween, vars);\n            };\n        }\n    };\n}; //register core plugins\nvar gsap = _gsap.registerPlugin({\n    name: \"attr\",\n    init: function init(target, vars, tween, index, targets) {\n        var p, pt, v;\n        this.tween = tween;\n        for(p in vars){\n            v = target.getAttribute(p) || \"\";\n            pt = this.add(target, \"setAttribute\", (v || 0) + \"\", vars[p], index, targets, 0, 0, p);\n            pt.op = p;\n            pt.b = v; // record the beginning value so we can revert()\n            this._props.push(p);\n        }\n    },\n    render: function render(ratio, data) {\n        var pt = data._pt;\n        while(pt){\n            _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d); // if reverting, go back to the original (pt.b)\n            pt = pt._next;\n        }\n    }\n}, {\n    name: \"endArray\",\n    init: function init(target, value) {\n        var i = value.length;\n        while(i--){\n            this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);\n        }\n    }\n}, _buildModifierPlugin(\"roundProps\", _roundModifier), _buildModifierPlugin(\"modifiers\"), _buildModifierPlugin(\"snap\", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.\nTween.version = Timeline.version = gsap.version = \"3.12.5\";\n_coreReady = 1;\n_windowExists() && _wake();\nvar Power0 = _easeMap.Power0, Power1 = _easeMap.Power1, Power2 = _easeMap.Power2, Power3 = _easeMap.Power3, Power4 = _easeMap.Power4, Linear = _easeMap.Linear, Quad = _easeMap.Quad, Cubic = _easeMap.Cubic, Quart = _easeMap.Quart, Quint = _easeMap.Quint, Strong = _easeMap.Strong, Elastic = _easeMap.Elastic, Back = _easeMap.Back, SteppedEase = _easeMap.SteppedEase, Bounce = _easeMap.Bounce, Sine = _easeMap.Sine, Expo = _easeMap.Expo, Circ = _easeMap.Circ;\n\n //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.\n\nvar _c;\n$RefreshReg$(_c, \"GSCache\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9nc2FwLWNvcmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsU0FBU0EsdUJBQXVCQyxJQUFJO0lBQUksSUFBSUEsU0FBUyxLQUFLLEdBQUc7UUFBRSxNQUFNLElBQUlDLGVBQWU7SUFBOEQ7SUFBRSxPQUFPRDtBQUFNO0FBRXJLLFNBQVNFLGVBQWVDLFFBQVEsRUFBRUMsVUFBVTtJQUFJRCxTQUFTRSxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0gsV0FBV0MsU0FBUztJQUFHRixTQUFTRSxTQUFTLENBQUNHLFdBQVcsR0FBR0w7SUFBVUEsU0FBU00sU0FBUyxHQUFHTDtBQUFZO0FBRXRMOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCLEdBQ2xCLElBQUlNLFVBQVU7SUFDWkMsV0FBVztJQUNYQyxTQUFTO0lBQ1RDLGdCQUFnQjtJQUNoQkMsT0FBTztRQUNMQyxZQUFZO0lBQ2Q7QUFDRixHQUNJQyxZQUFZO0lBQ2RDLFVBQVU7SUFDVkMsV0FBVztJQUNYQyxPQUFPO0FBQ1QsR0FDSUMscUJBQ0FDLFlBQ0FDLFVBQ0FDLFVBQVUsS0FDVkMsV0FBVyxJQUFJRCxTQUNmRSxPQUFPQyxLQUFLQyxFQUFFLEdBQUcsR0FDakJDLFdBQVdILE9BQU8sR0FDbEJJLFFBQVEsR0FDUkMsUUFBUUosS0FBS0ssSUFBSSxFQUNqQkMsT0FBT04sS0FBS08sR0FBRyxFQUNmQyxPQUFPUixLQUFLUyxHQUFHLEVBQ2ZDLFlBQVksU0FBU0EsVUFBVUMsS0FBSztJQUN0QyxPQUFPLE9BQU9BLFVBQVU7QUFDMUIsR0FDSUMsY0FBYyxTQUFTQSxZQUFZRCxLQUFLO0lBQzFDLE9BQU8sT0FBT0EsVUFBVTtBQUMxQixHQUNJRSxZQUFZLFNBQVNBLFVB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QUcvRCxLQUFLLENBQUMrRCxFQUFFLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO1FBQy9EO0lBQ0Y7QUFDRixHQUFHcXVCLHFCQUFxQixjQUFjN2UsaUJBQWlCNmUscUJBQXFCLGNBQWNBLHFCQUFxQixRQUFRMWUsVUFBVTFQLE1BQU0sQ0FBQywySUFBMkk7QUFFblJnTSxNQUFNMk4sT0FBTyxHQUFHOU8sU0FBUzhPLE9BQU8sR0FBRzNiLEtBQUsyYixPQUFPLEdBQUc7QUFDbEQvYixhQUFhO0FBQ2J0QixtQkFBbUI0UTtBQUNuQixJQUFJb2hCLFNBQVM3VCxTQUFTNlQsTUFBTSxFQUN4QkMsU0FBUzlULFNBQVM4VCxNQUFNLEVBQ3hCQyxTQUFTL1QsU0FBUytULE1BQU0sRUFDeEJDLFNBQVNoVSxTQUFTZ1UsTUFBTSxFQUN4QkMsU0FBU2pVLFNBQVNpVSxNQUFNLEVBQ3hCM1IsU0FBU3RDLFNBQVNzQyxNQUFNLEVBQ3hCNFIsT0FBT2xVLFNBQVNrVSxJQUFJLEVBQ3BCQyxRQUFRblUsU0FBU21VLEtBQUssRUFDdEJDLFFBQVFwVSxTQUFTb1UsS0FBSyxFQUN0QkMsUUFBUXJVLFNBQVNxVSxLQUFLLEVBQ3RCQyxTQUFTdFUsU0FBU3NVLE1BQU0sRUFDeEJDLFVBQVV2VSxTQUFTdVUsT0FBTyxFQUMxQkMsT0FBT3hVLFNBQVN3VSxJQUFJLEVBQ3BCNVIsY0FBYzVDLFNBQVM0QyxXQUFXLEVBQ2xDNlIsU0FBU3pVLFNBQVN5VSxNQUFNLEVBQ3hCQyxPQUFPMVUsU0FBUzBVLElBQUksRUFDcEJDLE9BQU8zVSxTQUFTMlUsSUFBSSxFQUNwQkMsT0FBTzVVLFNBQVM0VSxJQUFJO0FBQzJIO0FBQ3FILENBQUMsMElBQTBJO0FBRW5EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9nc2FwLWNvcmUuanM/NWQyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qIVxuICogR1NBUCAzLjEyLjVcbiAqIGh0dHBzOi8vZ3NhcC5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDI0LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dzYXAuY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdTQVAgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgX2NvbmZpZyA9IHtcbiAgYXV0b1NsZWVwOiAxMjAsXG4gIGZvcmNlM0Q6IFwiYXV0b1wiLFxuICBudWxsVGFyZ2V0V2FybjogMSxcbiAgdW5pdHM6IHtcbiAgICBsaW5lSGVpZ2h0OiBcIlwiXG4gIH1cbn0sXG4gICAgX2RlZmF1bHRzID0ge1xuICBkdXJhdGlvbjogLjUsXG4gIG92ZXJ3cml0ZTogZmFsc2UsXG4gIGRlbGF5OiAwXG59LFxuICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMsXG4gICAgX3JldmVydGluZyxcbiAgICBfY29udGV4dCxcbiAgICBfYmlnTnVtID0gMWU4LFxuICAgIF90aW55TnVtID0gMSAvIF9iaWdOdW0sXG4gICAgXzJQSSA9IE1hdGguUEkgKiAyLFxuICAgIF9IQUxGX1BJID0gXzJQSSAvIDQsXG4gICAgX2dzSUQgPSAwLFxuICAgIF9zcXJ0ID0gTWF0aC5zcXJ0LFxuICAgIF9jb3MgPSBNYXRoLmNvcyxcbiAgICBfc2luID0gTWF0aC5zaW4sXG4gICAgX2lzU3RyaW5nID0gZnVuY3Rpb24gX2lzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59LFxuICAgIF9pc0Z1bmN0aW9uID0gZnVuY3Rpb24gX2lzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufSxcbiAgICBfaXNOdW1iZXIgPSBmdW5jdGlvbiBfaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn0sXG4gICAgX2lzVW5kZWZpbmVkID0gZnVuY3Rpb24gX2lzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9pc09iamVjdCA9IGZ1bmN0aW9uIF9pc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufSxcbiAgICBfaXNOb3RGYWxzZSA9IGZ1bmN0aW9uIF9pc05vdEZhbHNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gZmFsc2U7XG59LFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2lzRnVuY09yU3RyaW5nID0gZnVuY3Rpb24gX2lzRnVuY09yU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBfaXNGdW5jdGlvbih2YWx1ZSkgfHwgX2lzU3RyaW5nKHZhbHVlKTtcbn0sXG4gICAgX2lzVHlwZWRBcnJheSA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiICYmIEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbiAoKSB7fSxcbiAgICAvLyBub3RlOiBJRTEwIGhhcyBBcnJheUJ1ZmZlciwgYnV0IE5PVCBBcnJheUJ1ZmZlci5pc1ZpZXcoKS5cbl9pc0FycmF5ID0gQXJyYXkuaXNBcnJheSxcbiAgICBfc3RyaWN0TnVtRXhwID0gLyg/Oi0/XFwuP1xcZHxcXC4pKy9naSxcbiAgICAvL29ubHkgbnVtYmVycyAoaW5jbHVkaW5nIG5lZ2F0aXZlcyBhbmQgZGVjaW1hbHMpIGJ1dCBOT1QgcmVsYXRpdmUgdmFsdWVzLlxuX251bUV4cCA9IC9bLSs9Ll0qXFxkK1suZVxcLStdKlxcZCpbZVxcLStdKlxcZCovZyxcbiAgICAvL2ZpbmRzIGFueSBudW1iZXJzLCBpbmNsdWRpbmcgb25lcyB0aGF0IHN0YXJ0IHdpdGggKz0gb3IgLT0sIG5lZ2F0aXZlIG51bWJlcnMsIGFuZCBvbmVzIGluIHNjaWVudGlmaWMgbm90YXRpb24gbGlrZSAxZS04LlxuX251bVdpdGhVbml0RXhwID0gL1stKz0uXSpcXGQrWy5lLV0qXFxkKlthLXolXSovZyxcbiAgICBfY29tcGxleFN0cmluZ051bUV4cCA9IC9bLSs9Ll0qXFxkK1xcLj9cXGQqKD86ZS18ZVxcKyk/XFxkKi9naSxcbiAgICAvL2R1cGxpY2F0ZSBzbyB0aGF0IHdoaWxlIHdlJ3JlIGxvb3BpbmcgdGhyb3VnaCBtYXRjaGVzIGZyb20gZXhlYygpLCBpdCBkb2Vzbid0IGNvbnRhbWluYXRlIHRoZSBsYXN0SW5kZXggb2YgX251bUV4cCB3aGljaCB3ZSB1c2UgdG8gc2VhcmNoIGZvciBjb2xvcnMgdG9vLlxuX3JlbEV4cCA9IC9bKy1dPS0/Wy5cXGRdKy8sXG4gICAgX2RlbGltaXRlZFZhbHVlRXhwID0gL1teLCdcIlxcW1xcXVxcc10rL2dpLFxuICAgIC8vIHByZXZpb3VzbHkgL1sjXFwtKy5dKlxcYlthLXpcXGRcXC09KyUuXSsvZ2kgYnV0IGRpZG4ndCBjYXRjaCBzcGVjaWFsIGNoYXJhY3RlcnMuXG5fdW5pdEV4cCA9IC9eWytcXC09ZVxcc1xcZF0qXFxkK1suXFxkXSooW2Etel0qfCUpXFxzKiQvaSxcbiAgICBfZ2xvYmFsVGltZWxpbmUsXG4gICAgX3dpbixcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX2RvYyxcbiAgICBfZ2xvYmFscyA9IHt9LFxuICAgIF9pbnN0YWxsU2NvcGUgPSB7fSxcbiAgICBfY29yZVJlYWR5LFxuICAgIF9pbnN0YWxsID0gZnVuY3Rpb24gX2luc3RhbGwoc2NvcGUpIHtcbiAgcmV0dXJuIChfaW5zdGFsbFNjb3BlID0gX21lcmdlKHNjb3BlLCBfZ2xvYmFscykpICYmIGdzYXA7XG59LFxuICAgIF9taXNzaW5nUGx1Z2luID0gZnVuY3Rpb24gX21pc3NpbmdQbHVnaW4ocHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHByb3BlcnR5XCIsIHByb3BlcnR5LCBcInNldCB0b1wiLCB2YWx1ZSwgXCJNaXNzaW5nIHBsdWdpbj8gZ3NhcC5yZWdpc3RlclBsdWdpbigpXCIpO1xufSxcbiAgICBfd2FybiA9IGZ1bmN0aW9uIF93YXJuKG1lc3NhZ2UsIHN1cHByZXNzKSB7XG4gIHJldHVybiAhc3VwcHJlc3MgJiYgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xufSxcbiAgICBfYWRkR2xvYmFsID0gZnVuY3Rpb24gX2FkZEdsb2JhbChuYW1lLCBvYmopIHtcbiAgcmV0dXJuIG5hbWUgJiYgKF9nbG9iYWxzW25hbWVdID0gb2JqKSAmJiBfaW5zdGFsbFNjb3BlICYmIChfaW5zdGFsbFNjb3BlW25hbWVdID0gb2JqKSB8fCBfZ2xvYmFscztcbn0sXG4gICAgX2VtcHR5RnVuYyA9IGZ1bmN0aW9uIF9lbXB0eUZ1bmMoKSB7XG4gIHJldHVybiAwO1xufSxcbiAgICBfc3RhcnRBdFJldmVydENvbmZpZyA9IHtcbiAgc3VwcHJlc3NFdmVudHM6IHRydWUsXG4gIGlzU3RhcnQ6IHRydWUsXG4gIGtpbGw6IGZhbHNlXG59LFxuICAgIF9yZXZlcnRDb25maWdOb0tpbGwgPSB7XG4gIHN1cHByZXNzRXZlbnRzOiB0cnVlLFxuICBraWxsOiBmYWxzZVxufSxcbiAgICBfcmV2ZXJ0Q29uZmlnID0ge1xuICBzdXBwcmVzc0V2ZW50czogdHJ1ZVxufSxcbiAgICBfcmVzZXJ2ZWRQcm9wcyA9IHt9LFxuICAgIF9sYXp5VHdlZW5zID0gW10sXG4gICAgX2xhenlMb29rdXAgPSB7fSxcbiAgICBfbGFzdFJlbmRlcmVkRnJhbWUsXG4gICAgX3BsdWdpbnMgPSB7fSxcbiAgICBfZWZmZWN0cyA9IHt9LFxuICAgIF9uZXh0R0NGcmFtZSA9IDMwLFxuICAgIF9oYXJuZXNzUGx1Z2lucyA9IFtdLFxuICAgIF9jYWxsYmFja05hbWVzID0gXCJcIixcbiAgICBfaGFybmVzcyA9IGZ1bmN0aW9uIF9oYXJuZXNzKHRhcmdldHMpIHtcbiAgdmFyIHRhcmdldCA9IHRhcmdldHNbMF0sXG4gICAgICBoYXJuZXNzUGx1Z2luLFxuICAgICAgaTtcbiAgX2lzT2JqZWN0KHRhcmdldCkgfHwgX2lzRnVuY3Rpb24odGFyZ2V0KSB8fCAodGFyZ2V0cyA9IFt0YXJnZXRzXSk7XG5cbiAgaWYgKCEoaGFybmVzc1BsdWdpbiA9ICh0YXJnZXQuX2dzYXAgfHwge30pLmhhcm5lc3MpKSB7XG4gICAgLy8gZmluZCB0aGUgZmlyc3QgdGFyZ2V0IHdpdGggYSBoYXJuZXNzLiBXZSBhc3N1bWUgdGFyZ2V0cyBwYXNzZWQgaW50byBhbiBhbmltYXRpb24gd2lsbCBiZSBvZiBzaW1pbGFyIHR5cGUsIG1lYW5pbmcgdGhlIHNhbWUga2luZCBvZiBoYXJuZXNzIGNhbiBiZSB1c2VkIGZvciB0aGVtIGFsbCAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uKVxuICAgIGkgPSBfaGFybmVzc1BsdWdpbnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSAmJiAhX2hhcm5lc3NQbHVnaW5zW2ldLnRhcmdldFRlc3QodGFyZ2V0KSkge31cblxuICAgIGhhcm5lc3NQbHVnaW4gPSBfaGFybmVzc1BsdWdpbnNbaV07XG4gIH1cblxuICBpID0gdGFyZ2V0cy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHRhcmdldHNbaV0gJiYgKHRhcmdldHNbaV0uX2dzYXAgfHwgKHRhcmdldHNbaV0uX2dzYXAgPSBuZXcgR1NDYWNoZSh0YXJnZXRzW2ldLCBoYXJuZXNzUGx1Z2luKSkpIHx8IHRhcmdldHMuc3BsaWNlKGksIDEpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldHM7XG59LFxuICAgIF9nZXRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRDYWNoZSh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldC5fZ3NhcCB8fCBfaGFybmVzcyh0b0FycmF5KHRhcmdldCkpWzBdLl9nc2FwO1xufSxcbiAgICBfZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiBfZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgdikge1xuICByZXR1cm4gKHYgPSB0YXJnZXRbcHJvcGVydHldKSAmJiBfaXNGdW5jdGlvbih2KSA/IHRhcmdldFtwcm9wZXJ0eV0oKSA6IF9pc1VuZGVmaW5lZCh2KSAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUocHJvcGVydHkpIHx8IHY7XG59LFxuICAgIF9mb3JFYWNoTmFtZSA9IGZ1bmN0aW9uIF9mb3JFYWNoTmFtZShuYW1lcywgZnVuYykge1xuICByZXR1cm4gKG5hbWVzID0gbmFtZXMuc3BsaXQoXCIsXCIpKS5mb3JFYWNoKGZ1bmMpIHx8IG5hbWVzO1xufSxcbiAgICAvL3NwbGl0IGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgbmFtZXMgaW50byBhbiBhcnJheSwgdGhlbiBydW4gYSBmb3JFYWNoKCkgZnVuY3Rpb24gYW5kIHJldHVybiB0aGUgc3BsaXQgYXJyYXkgKHRoaXMgaXMganVzdCBhIHdheSB0byBjb25zb2xpZGF0ZS9zaG9ydGVuIHNvbWUgY29kZSkuXG5fcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMDApIC8gMTAwMDAwIHx8IDA7XG59LFxuICAgIF9yb3VuZFByZWNpc2UgPSBmdW5jdGlvbiBfcm91bmRQcmVjaXNlKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwMDApIC8gMTAwMDAwMDAgfHwgMDtcbn0sXG4gICAgLy8gaW5jcmVhc2VkIHByZWNpc2lvbiBtb3N0bHkgZm9yIHRpbWluZyB2YWx1ZXMuXG5fcGFyc2VSZWxhdGl2ZSA9IGZ1bmN0aW9uIF9wYXJzZVJlbGF0aXZlKHN0YXJ0LCB2YWx1ZSkge1xuICB2YXIgb3BlcmF0b3IgPSB2YWx1ZS5jaGFyQXQoMCksXG4gICAgICBlbmQgPSBwYXJzZUZsb2F0KHZhbHVlLnN1YnN0cigyKSk7XG4gIHN0YXJ0ID0gcGFyc2VGbG9hdChzdGFydCk7XG4gIHJldHVybiBvcGVyYXRvciA9PT0gXCIrXCIgPyBzdGFydCArIGVuZCA6IG9wZXJhdG9yID09PSBcIi1cIiA/IHN0YXJ0IC0gZW5kIDogb3BlcmF0b3IgPT09IFwiKlwiID8gc3RhcnQgKiBlbmQgOiBzdGFydCAvIGVuZDtcbn0sXG4gICAgX2FycmF5Q29udGFpbnNBbnkgPSBmdW5jdGlvbiBfYXJyYXlDb250YWluc0FueSh0b1NlYXJjaCwgdG9GaW5kKSB7XG4gIC8vc2VhcmNoZXMgb25lIGFycmF5IHRvIGZpbmQgbWF0Y2hlcyBmb3IgYW55IG9mIHRoZSBpdGVtcyBpbiB0aGUgdG9GaW5kIGFycmF5LiBBcyBzb29uIGFzIG9uZSBpcyBmb3VuZCwgaXQgcmV0dXJucyB0cnVlLiBJdCBkb2VzIE5PVCByZXR1cm4gYWxsIHRoZSBtYXRjaGVzOyBpdCdzIHNpbXBseSBhIGJvb2xlYW4gc2VhcmNoLlxuICB2YXIgbCA9IHRvRmluZC5sZW5ndGgsXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgdG9TZWFyY2guaW5kZXhPZih0b0ZpbmRbaV0pIDwgMCAmJiArK2kgPCBsOykge31cblxuICByZXR1cm4gaSA8IGw7XG59LFxuICAgIF9sYXp5UmVuZGVyID0gZnVuY3Rpb24gX2xhenlSZW5kZXIoKSB7XG4gIHZhciBsID0gX2xhenlUd2VlbnMubGVuZ3RoLFxuICAgICAgYSA9IF9sYXp5VHdlZW5zLnNsaWNlKDApLFxuICAgICAgaSxcbiAgICAgIHR3ZWVuO1xuXG4gIF9sYXp5TG9va3VwID0ge307XG4gIF9sYXp5VHdlZW5zLmxlbmd0aCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHR3ZWVuID0gYVtpXTtcbiAgICB0d2VlbiAmJiB0d2Vlbi5fbGF6eSAmJiAodHdlZW4ucmVuZGVyKHR3ZWVuLl9sYXp5WzBdLCB0d2Vlbi5fbGF6eVsxXSwgdHJ1ZSkuX2xhenkgPSAwKTtcbiAgfVxufSxcbiAgICBfbGF6eVNhZmVSZW5kZXIgPSBmdW5jdGlvbiBfbGF6eVNhZmVSZW5kZXIoYW5pbWF0aW9uLCB0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgX2xhenlUd2VlbnMubGVuZ3RoICYmICFfcmV2ZXJ0aW5nICYmIF9sYXp5UmVuZGVyKCk7XG4gIGFuaW1hdGlvbi5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlIHx8IF9yZXZlcnRpbmcgJiYgdGltZSA8IDAgJiYgKGFuaW1hdGlvbi5faW5pdHRlZCB8fCBhbmltYXRpb24uX3N0YXJ0QXQpKTtcbiAgX2xhenlUd2VlbnMubGVuZ3RoICYmICFfcmV2ZXJ0aW5nICYmIF9sYXp5UmVuZGVyKCk7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBzb21lb25lIGNhbGxzIHNlZWsoKSBvciB0aW1lKCkgb3IgcHJvZ3Jlc3MoKSwgdGhleSBleHBlY3QgYW4gaW1tZWRpYXRlIHJlbmRlci5cbn0sXG4gICAgX251bWVyaWNJZlBvc3NpYmxlID0gZnVuY3Rpb24gX251bWVyaWNJZlBvc3NpYmxlKHZhbHVlKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIHJldHVybiAobiB8fCBuID09PSAwKSAmJiAodmFsdWUgKyBcIlwiKS5tYXRjaChfZGVsaW1pdGVkVmFsdWVFeHApLmxlbmd0aCA8IDIgPyBuIDogX2lzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xufSxcbiAgICBfcGFzc1Rocm91Z2ggPSBmdW5jdGlvbiBfcGFzc1Rocm91Z2gocCkge1xuICByZXR1cm4gcDtcbn0sXG4gICAgX3NldERlZmF1bHRzID0gZnVuY3Rpb24gX3NldERlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIHAgaW4gb2JqIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfc2V0S2V5ZnJhbWVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9zZXRLZXlmcmFtZURlZmF1bHRzKGV4Y2x1ZGVEdXJhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgZGVmYXVsdHMpIHtcbiAgICBmb3IgKHZhciBwIGluIGRlZmF1bHRzKSB7XG4gICAgICBwIGluIG9iaiB8fCBwID09PSBcImR1cmF0aW9uXCIgJiYgZXhjbHVkZUR1cmF0aW9uIHx8IHAgPT09IFwiZWFzZVwiIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gICAgfVxuICB9O1xufSxcbiAgICBfbWVyZ2UgPSBmdW5jdGlvbiBfbWVyZ2UoYmFzZSwgdG9NZXJnZSkge1xuICBmb3IgKHZhciBwIGluIHRvTWVyZ2UpIHtcbiAgICBiYXNlW3BdID0gdG9NZXJnZVtwXTtcbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufSxcbiAgICBfbWVyZ2VEZWVwID0gZnVuY3Rpb24gX21lcmdlRGVlcChiYXNlLCB0b01lcmdlKSB7XG4gIGZvciAodmFyIHAgaW4gdG9NZXJnZSkge1xuICAgIHAgIT09IFwiX19wcm90b19fXCIgJiYgcCAhPT0gXCJjb25zdHJ1Y3RvclwiICYmIHAgIT09IFwicHJvdG90eXBlXCIgJiYgKGJhc2VbcF0gPSBfaXNPYmplY3QodG9NZXJnZVtwXSkgPyBfbWVyZ2VEZWVwKGJhc2VbcF0gfHwgKGJhc2VbcF0gPSB7fSksIHRvTWVyZ2VbcF0pIDogdG9NZXJnZVtwXSk7XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn0sXG4gICAgX2NvcHlFeGNsdWRpbmcgPSBmdW5jdGlvbiBfY29weUV4Y2x1ZGluZyhvYmosIGV4Y2x1ZGluZykge1xuICB2YXIgY29weSA9IHt9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gb2JqKSB7XG4gICAgcCBpbiBleGNsdWRpbmcgfHwgKGNvcHlbcF0gPSBvYmpbcF0pO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIF9pbmhlcml0RGVmYXVsdHMgPSBmdW5jdGlvbiBfaW5oZXJpdERlZmF1bHRzKHZhcnMpIHtcbiAgdmFyIHBhcmVudCA9IHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZSxcbiAgICAgIGZ1bmMgPSB2YXJzLmtleWZyYW1lcyA/IF9zZXRLZXlmcmFtZURlZmF1bHRzKF9pc0FycmF5KHZhcnMua2V5ZnJhbWVzKSkgOiBfc2V0RGVmYXVsdHM7XG5cbiAgaWYgKF9pc05vdEZhbHNlKHZhcnMuaW5oZXJpdCkpIHtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBmdW5jKHZhcnMsIHBhcmVudC52YXJzLmRlZmF1bHRzKTtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQgfHwgcGFyZW50Ll9kcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFycztcbn0sXG4gICAgX2FycmF5c01hdGNoID0gZnVuY3Rpb24gX2FycmF5c01hdGNoKGExLCBhMikge1xuICB2YXIgaSA9IGExLmxlbmd0aCxcbiAgICAgIG1hdGNoID0gaSA9PT0gYTIubGVuZ3RoO1xuXG4gIHdoaWxlIChtYXRjaCAmJiBpLS0gJiYgYTFbaV0gPT09IGEyW2ldKSB7fVxuXG4gIHJldHVybiBpIDwgMDtcbn0sXG4gICAgX2FkZExpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX2FkZExpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3AsIHNvcnRCeSkge1xuICBpZiAoZmlyc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBmaXJzdFByb3AgPSBcIl9maXJzdFwiO1xuICB9XG5cbiAgaWYgKGxhc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBsYXN0UHJvcCA9IFwiX2xhc3RcIjtcbiAgfVxuXG4gIHZhciBwcmV2ID0gcGFyZW50W2xhc3RQcm9wXSxcbiAgICAgIHQ7XG5cbiAgaWYgKHNvcnRCeSkge1xuICAgIHQgPSBjaGlsZFtzb3J0QnldO1xuXG4gICAgd2hpbGUgKHByZXYgJiYgcHJldltzb3J0QnldID4gdCkge1xuICAgICAgcHJldiA9IHByZXYuX3ByZXY7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXYpIHtcbiAgICBjaGlsZC5fbmV4dCA9IHByZXYuX25leHQ7XG4gICAgcHJldi5fbmV4dCA9IGNoaWxkO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkLl9uZXh0ID0gcGFyZW50W2ZpcnN0UHJvcF07XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBjaGlsZDtcbiAgfVxuXG4gIGlmIChjaGlsZC5fbmV4dCkge1xuICAgIGNoaWxkLl9uZXh0Ll9wcmV2ID0gY2hpbGQ7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50W2xhc3RQcm9wXSA9IGNoaWxkO1xuICB9XG5cbiAgY2hpbGQuX3ByZXYgPSBwcmV2O1xuICBjaGlsZC5wYXJlbnQgPSBjaGlsZC5fZHAgPSBwYXJlbnQ7XG4gIHJldHVybiBjaGlsZDtcbn0sXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX3JlbW92ZUxpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3ApIHtcbiAgaWYgKGZpcnN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgZmlyc3RQcm9wID0gXCJfZmlyc3RcIjtcbiAgfVxuXG4gIGlmIChsYXN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgbGFzdFByb3AgPSBcIl9sYXN0XCI7XG4gIH1cblxuICB2YXIgcHJldiA9IGNoaWxkLl9wcmV2LFxuICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5fbmV4dCA9IG5leHQ7XG4gIH0gZWxzZSBpZiAocGFyZW50W2ZpcnN0UHJvcF0gPT09IGNoaWxkKSB7XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0Ll9wcmV2ID0gcHJldjtcbiAgfSBlbHNlIGlmIChwYXJlbnRbbGFzdFByb3BdID09PSBjaGlsZCkge1xuICAgIHBhcmVudFtsYXN0UHJvcF0gPSBwcmV2O1xuICB9XG5cbiAgY2hpbGQuX25leHQgPSBjaGlsZC5fcHJldiA9IGNoaWxkLnBhcmVudCA9IG51bGw7IC8vIGRvbid0IGRlbGV0ZSB0aGUgX2RwIGp1c3Qgc28gd2UgY2FuIHJldmVydCBpZiBuZWNlc3NhcnkuIEJ1dCBwYXJlbnQgc2hvdWxkIGJlIG51bGwgdG8gaW5kaWNhdGUgdGhlIGl0ZW0gaXNuJ3QgaW4gYSBsaW5rZWQgbGlzdC5cbn0sXG4gICAgX3JlbW92ZUZyb21QYXJlbnQgPSBmdW5jdGlvbiBfcmVtb3ZlRnJvbVBhcmVudChjaGlsZCwgb25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSkge1xuICBjaGlsZC5wYXJlbnQgJiYgKCFvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlIHx8IGNoaWxkLnBhcmVudC5hdXRvUmVtb3ZlQ2hpbGRyZW4pICYmIGNoaWxkLnBhcmVudC5yZW1vdmUgJiYgY2hpbGQucGFyZW50LnJlbW92ZShjaGlsZCk7XG4gIGNoaWxkLl9hY3QgPSAwO1xufSxcbiAgICBfdW5jYWNoZSA9IGZ1bmN0aW9uIF91bmNhY2hlKGFuaW1hdGlvbiwgY2hpbGQpIHtcbiAgaWYgKGFuaW1hdGlvbiAmJiAoIWNoaWxkIHx8IGNoaWxkLl9lbmQgPiBhbmltYXRpb24uX2R1ciB8fCBjaGlsZC5fc3RhcnQgPCAwKSkge1xuICAgIC8vIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogaWYgYSBjaGlsZCBhbmltYXRpb24gaXMgcGFzc2VkIGluIHdlIHNob3VsZCBvbmx5IHVuY2FjaGUgaWYgdGhhdCBjaGlsZCBFWFRFTkRTIHRoZSBhbmltYXRpb24gKGl0cyBlbmQgdGltZSBpcyBiZXlvbmQgdGhlIGVuZClcbiAgICB2YXIgYSA9IGFuaW1hdGlvbjtcblxuICAgIHdoaWxlIChhKSB7XG4gICAgICBhLl9kaXJ0eSA9IDE7XG4gICAgICBhID0gYS5wYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG4gICAgX3JlY2FjaGVBbmNlc3RvcnMgPSBmdW5jdGlvbiBfcmVjYWNoZUFuY2VzdG9ycyhhbmltYXRpb24pIHtcbiAgdmFyIHBhcmVudCA9IGFuaW1hdGlvbi5wYXJlbnQ7XG5cbiAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQucGFyZW50KSB7XG4gICAgLy9zb21ldGltZXMgd2UgbXVzdCBmb3JjZSBhIHJlLXNvcnQgb2YgYWxsIGNoaWxkcmVuIGFuZCB1cGRhdGUgdGhlIGR1cmF0aW9uL3RvdGFsRHVyYXRpb24gb2YgYWxsIGFuY2VzdG9yIHRpbWVsaW5lcyBpbW1lZGlhdGVseSBpbiBjYXNlLCBmb3IgZXhhbXBsZSwgaW4gdGhlIG1pZGRsZSBvZiBhIHJlbmRlciBsb29wLCBvbmUgdHdlZW4gYWx0ZXJzIGFub3RoZXIgdHdlZW4ncyB0aW1lU2NhbGUgd2hpY2ggc2hvdmVzIGl0cyBzdGFydFRpbWUgYmVmb3JlIDAsIGZvcmNpbmcgdGhlIHBhcmVudCB0aW1lbGluZSB0byBzaGlmdCBhcm91bmQgYW5kIHNoaWZ0Q2hpbGRyZW4oKSB3aGljaCBjb3VsZCBhZmZlY3QgdGhhdCBuZXh0IHR3ZWVuJ3MgcmVuZGVyIChzdGFydFRpbWUpLiBEb2Vzbid0IG1hdHRlciBmb3IgdGhlIHJvb3QgdGltZWxpbmUgdGhvdWdoLlxuICAgIHBhcmVudC5fZGlydHkgPSAxO1xuICAgIHBhcmVudC50b3RhbER1cmF0aW9uKCk7XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuXG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9yZXdpbmRTdGFydEF0ID0gZnVuY3Rpb24gX3Jld2luZFN0YXJ0QXQodHdlZW4sIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG4gIHJldHVybiB0d2Vlbi5fc3RhcnRBdCAmJiAoX3JldmVydGluZyA/IHR3ZWVuLl9zdGFydEF0LnJldmVydChfcmV2ZXJ0Q29uZmlnTm9LaWxsKSA6IHR3ZWVuLnZhcnMuaW1tZWRpYXRlUmVuZGVyICYmICF0d2Vlbi52YXJzLmF1dG9SZXZlcnQgfHwgdHdlZW4uX3N0YXJ0QXQucmVuZGVyKHRvdGFsVGltZSwgdHJ1ZSwgZm9yY2UpKTtcbn0sXG4gICAgX2hhc05vUGF1c2VkQW5jZXN0b3JzID0gZnVuY3Rpb24gX2hhc05vUGF1c2VkQW5jZXN0b3JzKGFuaW1hdGlvbikge1xuICByZXR1cm4gIWFuaW1hdGlvbiB8fCBhbmltYXRpb24uX3RzICYmIF9oYXNOb1BhdXNlZEFuY2VzdG9ycyhhbmltYXRpb24ucGFyZW50KTtcbn0sXG4gICAgX2VsYXBzZWRDeWNsZUR1cmF0aW9uID0gZnVuY3Rpb24gX2VsYXBzZWRDeWNsZUR1cmF0aW9uKGFuaW1hdGlvbikge1xuICByZXR1cm4gYW5pbWF0aW9uLl9yZXBlYXQgPyBfYW5pbWF0aW9uQ3ljbGUoYW5pbWF0aW9uLl90VGltZSwgYW5pbWF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uKCkgKyBhbmltYXRpb24uX3JEZWxheSkgKiBhbmltYXRpb24gOiAwO1xufSxcbiAgICAvLyBmZWVkIGluIHRoZSB0b3RhbFRpbWUgYW5kIGN5Y2xlRHVyYXRpb24gYW5kIGl0J2xsIHJldHVybiB0aGUgY3ljbGUgKGl0ZXJhdGlvbiBtaW51cyAxKSBhbmQgaWYgdGhlIHBsYXloZWFkIGlzIGV4YWN0bHkgYXQgdGhlIHZlcnkgRU5ELCBpdCB3aWxsIE5PVCBidW1wIHVwIHRvIHRoZSBuZXh0IGN5Y2xlLlxuX2FuaW1hdGlvbkN5Y2xlID0gZnVuY3Rpb24gX2FuaW1hdGlvbkN5Y2xlKHRUaW1lLCBjeWNsZUR1cmF0aW9uKSB7XG4gIHZhciB3aG9sZSA9IE1hdGguZmxvb3IodFRpbWUgLz0gY3ljbGVEdXJhdGlvbik7XG4gIHJldHVybiB0VGltZSAmJiB3aG9sZSA9PT0gdFRpbWUgPyB3aG9sZSAtIDEgOiB3aG9sZTtcbn0sXG4gICAgX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUgPSBmdW5jdGlvbiBfcGFyZW50VG9DaGlsZFRvdGFsVGltZShwYXJlbnRUaW1lLCBjaGlsZCkge1xuICByZXR1cm4gKHBhcmVudFRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzICsgKGNoaWxkLl90cyA+PSAwID8gMCA6IGNoaWxkLl9kaXJ0eSA/IGNoaWxkLnRvdGFsRHVyYXRpb24oKSA6IGNoaWxkLl90RHVyKTtcbn0sXG4gICAgX3NldEVuZCA9IGZ1bmN0aW9uIF9zZXRFbmQoYW5pbWF0aW9uKSB7XG4gIHJldHVybiBhbmltYXRpb24uX2VuZCA9IF9yb3VuZFByZWNpc2UoYW5pbWF0aW9uLl9zdGFydCArIChhbmltYXRpb24uX3REdXIgLyBNYXRoLmFicyhhbmltYXRpb24uX3RzIHx8IGFuaW1hdGlvbi5fcnRzIHx8IF90aW55TnVtKSB8fCAwKSk7XG59LFxuICAgIF9hbGlnblBsYXloZWFkID0gZnVuY3Rpb24gX2FsaWduUGxheWhlYWQoYW5pbWF0aW9uLCB0b3RhbFRpbWUpIHtcbiAgLy8gYWRqdXN0cyB0aGUgYW5pbWF0aW9uJ3MgX3N0YXJ0IGFuZCBfZW5kIGFjY29yZGluZyB0byB0aGUgcHJvdmlkZWQgdG90YWxUaW1lIChvbmx5IGlmIHRoZSBwYXJlbnQncyBzbW9vdGhDaGlsZFRpbWluZyBpcyB0cnVlIGFuZCB0aGUgYW5pbWF0aW9uIGlzbid0IHBhdXNlZCkuIEl0IGRvZXNuJ3QgZG8gYW55IHJlbmRlcmluZyBvciBmb3JjaW5nIHRoaW5ncyBiYWNrIGludG8gcGFyZW50IHRpbWVsaW5lcywgZXRjLiAtIHRoYXQncyB3aGF0IHRvdGFsVGltZSgpIGlzIGZvci5cbiAgdmFyIHBhcmVudCA9IGFuaW1hdGlvbi5fZHA7XG5cbiAgaWYgKHBhcmVudCAmJiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgJiYgYW5pbWF0aW9uLl90cykge1xuICAgIGFuaW1hdGlvbi5fc3RhcnQgPSBfcm91bmRQcmVjaXNlKHBhcmVudC5fdGltZSAtIChhbmltYXRpb24uX3RzID4gMCA/IHRvdGFsVGltZSAvIGFuaW1hdGlvbi5fdHMgOiAoKGFuaW1hdGlvbi5fZGlydHkgPyBhbmltYXRpb24udG90YWxEdXJhdGlvbigpIDogYW5pbWF0aW9uLl90RHVyKSAtIHRvdGFsVGltZSkgLyAtYW5pbWF0aW9uLl90cykpO1xuXG4gICAgX3NldEVuZChhbmltYXRpb24pO1xuXG4gICAgcGFyZW50Ll9kaXJ0eSB8fCBfdW5jYWNoZShwYXJlbnQsIGFuaW1hdGlvbik7IC8vZm9yIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50LiBJZiB0aGUgcGFyZW50J3MgY2FjaGUgaXMgYWxyZWFkeSBkaXJ0eSwgaXQgYWxyZWFkeSB0b29rIGNhcmUgb2YgbWFya2luZyB0aGUgYW5jZXN0b3JzIGFzIGRpcnR5IHRvbywgc28gc2tpcCB0aGUgZnVuY3Rpb24gY2FsbCBoZXJlLlxuICB9XG5cbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG5cbi8qXG5fdG90YWxUaW1lVG9UaW1lID0gKGNsYW1wZWRUb3RhbFRpbWUsIGR1cmF0aW9uLCByZXBlYXQsIHJlcGVhdERlbGF5LCB5b3lvKSA9PiB7XG5cdGxldCBjeWNsZUR1cmF0aW9uID0gZHVyYXRpb24gKyByZXBlYXREZWxheSxcblx0XHR0aW1lID0gX3JvdW5kKGNsYW1wZWRUb3RhbFRpbWUgJSBjeWNsZUR1cmF0aW9uKTtcblx0aWYgKHRpbWUgPiBkdXJhdGlvbikge1xuXHRcdHRpbWUgPSBkdXJhdGlvbjtcblx0fVxuXHRyZXR1cm4gKHlveW8gJiYgKH5+KGNsYW1wZWRUb3RhbFRpbWUgLyBjeWNsZUR1cmF0aW9uKSAmIDEpKSA/IGR1cmF0aW9uIC0gdGltZSA6IHRpbWU7XG59LFxuKi9cbl9wb3N0QWRkQ2hlY2tzID0gZnVuY3Rpb24gX3Bvc3RBZGRDaGVja3ModGltZWxpbmUsIGNoaWxkKSB7XG4gIHZhciB0O1xuXG4gIGlmIChjaGlsZC5fdGltZSB8fCAhY2hpbGQuX2R1ciAmJiBjaGlsZC5faW5pdHRlZCB8fCBjaGlsZC5fc3RhcnQgPCB0aW1lbGluZS5fdGltZSAmJiAoY2hpbGQuX2R1ciB8fCAhY2hpbGQuYWRkKSkge1xuICAgIC8vIGluIGNhc2UsIGZvciBleGFtcGxlLCB0aGUgX3N0YXJ0IGlzIG1vdmVkIG9uIGEgdHdlZW4gdGhhdCBoYXMgYWxyZWFkeSByZW5kZXJlZCwgb3IgaWYgaXQncyBiZWluZyBpbnNlcnRlZCBpbnRvIGEgdGltZWxpbmUgQkVGT1JFIHdoZXJlIHRoZSBwbGF5aGVhZCBpcyBjdXJyZW50bHkuIEltYWdpbmUgaXQncyBhdCBpdHMgZW5kIHN0YXRlLCB0aGVuIHRoZSBzdGFydFRpbWUgaXMgbW92ZWQgV0FZIGxhdGVyIChhZnRlciB0aGUgZW5kIG9mIHRoaXMgdGltZWxpbmUpLCBpdCBzaG91bGQgcmVuZGVyIGF0IGl0cyBiZWdpbm5pbmcuIFNwZWNpYWwgY2FzZTogaWYgaXQncyBhIHRpbWVsaW5lIChoYXMgLmFkZCgpIG1ldGhvZCkgYW5kIG5vIGR1cmF0aW9uLCB3ZSBjYW4gc2tpcCByZW5kZXJpbmcgYmVjYXVzZSB0aGUgdXNlciBtYXkgYmUgcG9wdWxhdGluZyBpdCBBRlRFUiBhZGRpbmcgaXQgdG8gYSBwYXJlbnQgdGltZWxpbmUgKHVuY29udmVudGlvbmFsLCBidXQgcG9zc2libGUsIGFuZCB3ZSB3b3VsZG4ndCB3YW50IGl0IHRvIGdldCByZW1vdmVkIGlmIHRoZSBwYXJlbnQncyBhdXRvUmVtb3ZlQ2hpbGRyZW4gaXMgdHJ1ZSkuXG4gICAgdCA9IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRpbWVsaW5lLnJhd1RpbWUoKSwgY2hpbGQpO1xuXG4gICAgaWYgKCFjaGlsZC5fZHVyIHx8IF9jbGFtcCgwLCBjaGlsZC50b3RhbER1cmF0aW9uKCksIHQpIC0gY2hpbGQuX3RUaW1lID4gX3RpbnlOdW0pIHtcbiAgICAgIGNoaWxkLnJlbmRlcih0LCB0cnVlKTtcbiAgICB9XG4gIH0gLy9pZiB0aGUgdGltZWxpbmUgaGFzIGFscmVhZHkgZW5kZWQgYnV0IHRoZSBpbnNlcnRlZCB0d2Vlbi90aW1lbGluZSBleHRlbmRzIHRoZSBkdXJhdGlvbiwgd2Ugc2hvdWxkIGVuYWJsZSB0aGlzIHRpbWVsaW5lIGFnYWluIHNvIHRoYXQgaXQgcmVuZGVycyBwcm9wZXJseS4gV2Ugc2hvdWxkIGFsc28gYWxpZ24gdGhlIHBsYXloZWFkIHdpdGggdGhlIHBhcmVudCB0aW1lbGluZSdzIHdoZW4gYXBwcm9wcmlhdGUuXG5cblxuICBpZiAoX3VuY2FjaGUodGltZWxpbmUsIGNoaWxkKS5fZHAgJiYgdGltZWxpbmUuX2luaXR0ZWQgJiYgdGltZWxpbmUuX3RpbWUgPj0gdGltZWxpbmUuX2R1ciAmJiB0aW1lbGluZS5fdHMpIHtcbiAgICAvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvcnMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLi4uXG4gICAgaWYgKHRpbWVsaW5lLl9kdXIgPCB0aW1lbGluZS5kdXJhdGlvbigpKSB7XG4gICAgICB0ID0gdGltZWxpbmU7XG5cbiAgICAgIHdoaWxlICh0Ll9kcCkge1xuICAgICAgICB0LnJhd1RpbWUoKSA+PSAwICYmIHQudG90YWxUaW1lKHQuX3RUaW1lKTsgLy9tb3ZlcyB0aGUgdGltZWxpbmUgKHNoaWZ0cyBpdHMgc3RhcnRUaW1lKSBpZiBuZWNlc3NhcnksIGFuZCBhbHNvIGVuYWJsZXMgaXQuIElmIGl0J3MgY3VycmVudGx5IHplcm8sIHRob3VnaCwgaXQgbWF5IG5vdCBiZSBzY2hlZHVsZWQgdG8gcmVuZGVyIHVudGlsIGxhdGVyIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSBpdCB0byBhbGlnbiB3aXRoIHRoZSBjdXJyZW50IHBsYXloZWFkIHBvc2l0aW9uLiBPbmx5IG1vdmUgdG8gY2F0Y2ggdXAgd2l0aCB0aGUgcGxheWhlYWQuXG5cbiAgICAgICAgdCA9IHQuX2RwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRpbWVsaW5lLl96VGltZSA9IC1fdGlueU51bTsgLy8gaGVscHMgZW5zdXJlIHRoYXQgdGhlIG5leHQgcmVuZGVyKCkgd2lsbCBiZSBmb3JjZWQgKGNyb3NzaW5nU3RhcnQgPSB0cnVlIGluIHJlbmRlcigpKSwgZXZlbiBpZiB0aGUgZHVyYXRpb24gaGFzbid0IGNoYW5nZWQgKHdlJ3JlIGFkZGluZyBhIGNoaWxkIHdoaWNoIHdvdWxkIG5lZWQgdG8gZ2V0IHJlbmRlcmVkKS4gRGVmaW5pdGVseSBhbiBlZGdlIGNhc2UuIE5vdGU6IHdlIE1VU1QgZG8gdGhpcyBBRlRFUiB0aGUgbG9vcCBhYm92ZSB3aGVyZSB0aGUgdG90YWxUaW1lKCkgbWlnaHQgdHJpZ2dlciBhIHJlbmRlcigpIGJlY2F1c2UgdGhpcyBfYWRkVG9UaW1lbGluZSgpIG1ldGhvZCBnZXRzIGNhbGxlZCBmcm9tIHRoZSBBbmltYXRpb24gY29uc3RydWN0b3IsIEJFRk9SRSB0d2VlbnMgZXZlbiByZWNvcmQgdGhlaXIgdGFyZ2V0cywgZXRjLiBzbyB3ZSB3b3VsZG4ndCB3YW50IHRoaW5ncyB0byBnZXQgdHJpZ2dlcmVkIGluIHRoZSB3cm9uZyBvcmRlci5cbiAgfVxufSxcbiAgICBfYWRkVG9UaW1lbGluZSA9IGZ1bmN0aW9uIF9hZGRUb1RpbWVsaW5lKHRpbWVsaW5lLCBjaGlsZCwgcG9zaXRpb24sIHNraXBDaGVja3MpIHtcbiAgY2hpbGQucGFyZW50ICYmIF9yZW1vdmVGcm9tUGFyZW50KGNoaWxkKTtcbiAgY2hpbGQuX3N0YXJ0ID0gX3JvdW5kUHJlY2lzZSgoX2lzTnVtYmVyKHBvc2l0aW9uKSA/IHBvc2l0aW9uIDogcG9zaXRpb24gfHwgdGltZWxpbmUgIT09IF9nbG9iYWxUaW1lbGluZSA/IF9wYXJzZVBvc2l0aW9uKHRpbWVsaW5lLCBwb3NpdGlvbiwgY2hpbGQpIDogdGltZWxpbmUuX3RpbWUpICsgY2hpbGQuX2RlbGF5KTtcbiAgY2hpbGQuX2VuZCA9IF9yb3VuZFByZWNpc2UoY2hpbGQuX3N0YXJ0ICsgKGNoaWxkLnRvdGFsRHVyYXRpb24oKSAvIE1hdGguYWJzKGNoaWxkLnRpbWVTY2FsZSgpKSB8fCAwKSk7XG5cbiAgX2FkZExpbmtlZExpc3RJdGVtKHRpbWVsaW5lLCBjaGlsZCwgXCJfZmlyc3RcIiwgXCJfbGFzdFwiLCB0aW1lbGluZS5fc29ydCA/IFwiX3N0YXJ0XCIgOiAwKTtcblxuICBfaXNGcm9tT3JGcm9tU3RhcnQoY2hpbGQpIHx8ICh0aW1lbGluZS5fcmVjZW50ID0gY2hpbGQpO1xuICBza2lwQ2hlY2tzIHx8IF9wb3N0QWRkQ2hlY2tzKHRpbWVsaW5lLCBjaGlsZCk7XG4gIHRpbWVsaW5lLl90cyA8IDAgJiYgX2FsaWduUGxheWhlYWQodGltZWxpbmUsIHRpbWVsaW5lLl90VGltZSk7IC8vIGlmIHRoZSB0aW1lbGluZSBpcyByZXZlcnNlZCBhbmQgdGhlIG5ldyBjaGlsZCBtYWtlcyBpdCBsb25nZXIsIHdlIG1heSBuZWVkIHRvIGFkanVzdCB0aGUgcGFyZW50J3MgX3N0YXJ0IChwdXNoIGl0IGJhY2spXG5cbiAgcmV0dXJuIHRpbWVsaW5lO1xufSxcbiAgICBfc2Nyb2xsVHJpZ2dlciA9IGZ1bmN0aW9uIF9zY3JvbGxUcmlnZ2VyKGFuaW1hdGlvbiwgdHJpZ2dlcikge1xuICByZXR1cm4gKF9nbG9iYWxzLlNjcm9sbFRyaWdnZXIgfHwgX21pc3NpbmdQbHVnaW4oXCJzY3JvbGxUcmlnZ2VyXCIsIHRyaWdnZXIpKSAmJiBfZ2xvYmFscy5TY3JvbGxUcmlnZ2VyLmNyZWF0ZSh0cmlnZ2VyLCBhbmltYXRpb24pO1xufSxcbiAgICBfYXR0ZW1wdEluaXRUd2VlbiA9IGZ1bmN0aW9uIF9hdHRlbXB0SW5pdFR3ZWVuKHR3ZWVuLCB0aW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMsIHRUaW1lKSB7XG4gIF9pbml0VHdlZW4odHdlZW4sIHRpbWUsIHRUaW1lKTtcblxuICBpZiAoIXR3ZWVuLl9pbml0dGVkKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBpZiAoIWZvcmNlICYmIHR3ZWVuLl9wdCAmJiAhX3JldmVydGluZyAmJiAodHdlZW4uX2R1ciAmJiB0d2Vlbi52YXJzLmxhenkgIT09IGZhbHNlIHx8ICF0d2Vlbi5fZHVyICYmIHR3ZWVuLnZhcnMubGF6eSkgJiYgX2xhc3RSZW5kZXJlZEZyYW1lICE9PSBfdGlja2VyLmZyYW1lKSB7XG4gICAgX2xhenlUd2VlbnMucHVzaCh0d2Vlbik7XG5cbiAgICB0d2Vlbi5fbGF6eSA9IFt0VGltZSwgc3VwcHJlc3NFdmVudHNdO1xuICAgIHJldHVybiAxO1xuICB9XG59LFxuICAgIF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQgPSBmdW5jdGlvbiBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KF9yZWYpIHtcbiAgdmFyIHBhcmVudCA9IF9yZWYucGFyZW50O1xuICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC5fdHMgJiYgcGFyZW50Ll9pbml0dGVkICYmICFwYXJlbnQuX2xvY2sgJiYgKHBhcmVudC5yYXdUaW1lKCkgPCAwIHx8IF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQocGFyZW50KSk7XG59LFxuICAgIC8vIGNoZWNrIHBhcmVudCdzIF9sb2NrIGJlY2F1c2Ugd2hlbiBhIHRpbWVsaW5lIHJlcGVhdHMveW95b3MgYW5kIGRvZXMgaXRzIGFydGlmaWNpYWwgd3JhcHBpbmcsIHdlIHNob3VsZG4ndCBmb3JjZSB0aGUgcmF0aW8gYmFjayB0byAwXG5faXNGcm9tT3JGcm9tU3RhcnQgPSBmdW5jdGlvbiBfaXNGcm9tT3JGcm9tU3RhcnQoX3JlZjIpIHtcbiAgdmFyIGRhdGEgPSBfcmVmMi5kYXRhO1xuICByZXR1cm4gZGF0YSA9PT0gXCJpc0Zyb21TdGFydFwiIHx8IGRhdGEgPT09IFwiaXNTdGFydFwiO1xufSxcbiAgICBfcmVuZGVyWmVyb0R1cmF0aW9uVHdlZW4gPSBmdW5jdGlvbiBfcmVuZGVyWmVyb0R1cmF0aW9uVHdlZW4odHdlZW4sIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG4gIHZhciBwcmV2UmF0aW8gPSB0d2Vlbi5yYXRpbyxcbiAgICAgIHJhdGlvID0gdG90YWxUaW1lIDwgMCB8fCAhdG90YWxUaW1lICYmICghdHdlZW4uX3N0YXJ0ICYmIF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQodHdlZW4pICYmICEoIXR3ZWVuLl9pbml0dGVkICYmIF9pc0Zyb21PckZyb21TdGFydCh0d2VlbikpIHx8ICh0d2Vlbi5fdHMgPCAwIHx8IHR3ZWVuLl9kcC5fdHMgPCAwKSAmJiAhX2lzRnJvbU9yRnJvbVN0YXJ0KHR3ZWVuKSkgPyAwIDogMSxcbiAgICAgIC8vIGlmIHRoZSB0d2VlbiBvciBpdHMgcGFyZW50IGlzIHJldmVyc2VkIGFuZCB0aGUgdG90YWxUaW1lIGlzIDAsIHdlIHNob3VsZCBnbyB0byBhIHJhdGlvIG9mIDAuIEVkZ2UgY2FzZTogaWYgYSBmcm9tKCkgb3IgZnJvbVRvKCkgc3RhZ2dlciB0d2VlbiBpcyBwbGFjZWQgbGF0ZXIgaW4gYSB0aW1lbGluZSwgdGhlIFwic3RhcnRBdFwiIHplcm8tZHVyYXRpb24gdHdlZW4gY291bGQgaW5pdGlhbGx5IHJlbmRlciBhdCBhIHRpbWUgd2hlbiB0aGUgcGFyZW50IHRpbWVsaW5lJ3MgcGxheWhlYWQgaXMgdGVjaG5pY2FsbHkgQkVGT1JFIHdoZXJlIHRoaXMgdHdlZW4gaXMsIHNvIG1ha2Ugc3VyZSB0aGF0IGFueSBcImZyb21cIiBhbmQgXCJmcm9tVG9cIiBzdGFydEF0IHR3ZWVucyBhcmUgcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUgYXQgYSByYXRpbyBvZiAxLlxuICByZXBlYXREZWxheSA9IHR3ZWVuLl9yRGVsYXksXG4gICAgICB0VGltZSA9IDAsXG4gICAgICBwdCxcbiAgICAgIGl0ZXJhdGlvbixcbiAgICAgIHByZXZJdGVyYXRpb247XG5cbiAgaWYgKHJlcGVhdERlbGF5ICYmIHR3ZWVuLl9yZXBlYXQpIHtcbiAgICAvLyBpbiBjYXNlIHRoZXJlJ3MgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIHRoYXQgaGFzIGEgcmVwZWF0IHdpdGggYSByZXBlYXREZWxheVxuICAgIHRUaW1lID0gX2NsYW1wKDAsIHR3ZWVuLl90RHVyLCB0b3RhbFRpbWUpO1xuICAgIGl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0VGltZSwgcmVwZWF0RGVsYXkpO1xuICAgIHR3ZWVuLl95b3lvICYmIGl0ZXJhdGlvbiAmIDEgJiYgKHJhdGlvID0gMSAtIHJhdGlvKTtcblxuICAgIGlmIChpdGVyYXRpb24gIT09IF9hbmltYXRpb25DeWNsZSh0d2Vlbi5fdFRpbWUsIHJlcGVhdERlbGF5KSkge1xuICAgICAgLy8gaWYgaXRlcmF0aW9uIGNoYW5nZWRcbiAgICAgIHByZXZSYXRpbyA9IDEgLSByYXRpbztcbiAgICAgIHR3ZWVuLnZhcnMucmVwZWF0UmVmcmVzaCAmJiB0d2Vlbi5faW5pdHRlZCAmJiB0d2Vlbi5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJhdGlvICE9PSBwcmV2UmF0aW8gfHwgX3JldmVydGluZyB8fCBmb3JjZSB8fCB0d2Vlbi5felRpbWUgPT09IF90aW55TnVtIHx8ICF0b3RhbFRpbWUgJiYgdHdlZW4uX3pUaW1lKSB7XG4gICAgaWYgKCF0d2Vlbi5faW5pdHRlZCAmJiBfYXR0ZW1wdEluaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMsIHRUaW1lKSkge1xuICAgICAgLy8gaWYgd2UgcmVuZGVyIHRoZSB2ZXJ5IGJlZ2lubmluZyAodGltZSA9PSAwKSBvZiBhIGZyb21UbygpLCB3ZSBtdXN0IGZvcmNlIHRoZSByZW5kZXIgKG5vcm1hbCB0d2VlbnMgd291bGRuJ3QgbmVlZCB0byByZW5kZXIgYXQgYSB0aW1lIG9mIDAgd2hlbiB0aGUgcHJldlRpbWUgd2FzIGFsc28gMCkuIFRoaXMgaXMgYWxzbyBtYW5kYXRvcnkgdG8gbWFrZSBzdXJlIG92ZXJ3cml0aW5nIGtpY2tzIGluIGltbWVkaWF0ZWx5LlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByZXZJdGVyYXRpb24gPSB0d2Vlbi5felRpbWU7XG4gICAgdHdlZW4uX3pUaW1lID0gdG90YWxUaW1lIHx8IChzdXBwcmVzc0V2ZW50cyA/IF90aW55TnVtIDogMCk7IC8vIHdoZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LlxuXG4gICAgc3VwcHJlc3NFdmVudHMgfHwgKHN1cHByZXNzRXZlbnRzID0gdG90YWxUaW1lICYmICFwcmV2SXRlcmF0aW9uKTsgLy8gaWYgaXQgd2FzIHJlbmRlcmVkIHByZXZpb3VzbHkgYXQgZXhhY3RseSAwIChfelRpbWUpIGFuZCBub3cgdGhlIHBsYXloZWFkIGlzIG1vdmluZyBhd2F5LCBET04nVCBmaXJlIGNhbGxiYWNrcyBvdGhlcndpc2UgdGhleSdsbCBzZWVtIGxpa2UgZHVwbGljYXRlcy5cblxuICAgIHR3ZWVuLnJhdGlvID0gcmF0aW87XG4gICAgdHdlZW4uX2Zyb20gJiYgKHJhdGlvID0gMSAtIHJhdGlvKTtcbiAgICB0d2Vlbi5fdGltZSA9IDA7XG4gICAgdHdlZW4uX3RUaW1lID0gdFRpbWU7XG4gICAgcHQgPSB0d2Vlbi5fcHQ7XG5cbiAgICB3aGlsZSAocHQpIHtcbiAgICAgIHB0LnIocmF0aW8sIHB0LmQpO1xuICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICB9XG5cbiAgICB0b3RhbFRpbWUgPCAwICYmIF9yZXdpbmRTdGFydEF0KHR3ZWVuLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCB0cnVlKTtcbiAgICB0d2Vlbi5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzICYmIF9jYWxsYmFjayh0d2VlbiwgXCJvblVwZGF0ZVwiKTtcbiAgICB0VGltZSAmJiB0d2Vlbi5fcmVwZWF0ICYmICFzdXBwcmVzc0V2ZW50cyAmJiB0d2Vlbi5wYXJlbnQgJiYgX2NhbGxiYWNrKHR3ZWVuLCBcIm9uUmVwZWF0XCIpO1xuXG4gICAgaWYgKCh0b3RhbFRpbWUgPj0gdHdlZW4uX3REdXIgfHwgdG90YWxUaW1lIDwgMCkgJiYgdHdlZW4ucmF0aW8gPT09IHJhdGlvKSB7XG4gICAgICByYXRpbyAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0d2VlbiwgMSk7XG5cbiAgICAgIGlmICghc3VwcHJlc3NFdmVudHMgJiYgIV9yZXZlcnRpbmcpIHtcbiAgICAgICAgX2NhbGxiYWNrKHR3ZWVuLCByYXRpbyA/IFwib25Db21wbGV0ZVwiIDogXCJvblJldmVyc2VDb21wbGV0ZVwiLCB0cnVlKTtcblxuICAgICAgICB0d2Vlbi5fcHJvbSAmJiB0d2Vlbi5fcHJvbSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICghdHdlZW4uX3pUaW1lKSB7XG4gICAgdHdlZW4uX3pUaW1lID0gdG90YWxUaW1lO1xuICB9XG59LFxuICAgIF9maW5kTmV4dFBhdXNlVHdlZW4gPSBmdW5jdGlvbiBfZmluZE5leHRQYXVzZVR3ZWVuKGFuaW1hdGlvbiwgcHJldlRpbWUsIHRpbWUpIHtcbiAgdmFyIGNoaWxkO1xuXG4gIGlmICh0aW1lID4gcHJldlRpbWUpIHtcbiAgICBjaGlsZCA9IGFuaW1hdGlvbi5fZmlyc3Q7XG5cbiAgICB3aGlsZSAoY2hpbGQgJiYgY2hpbGQuX3N0YXJ0IDw9IHRpbWUpIHtcbiAgICAgIGlmIChjaGlsZC5kYXRhID09PSBcImlzUGF1c2VcIiAmJiBjaGlsZC5fc3RhcnQgPiBwcmV2VGltZSkge1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNoaWxkID0gYW5pbWF0aW9uLl9sYXN0O1xuXG4gICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLl9zdGFydCA+PSB0aW1lKSB7XG4gICAgICBpZiAoY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgY2hpbGQuX3N0YXJ0IDwgcHJldlRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9wcmV2O1xuICAgIH1cbiAgfVxufSxcbiAgICBfc2V0RHVyYXRpb24gPSBmdW5jdGlvbiBfc2V0RHVyYXRpb24oYW5pbWF0aW9uLCBkdXJhdGlvbiwgc2tpcFVuY2FjaGUsIGxlYXZlUGxheWhlYWQpIHtcbiAgdmFyIHJlcGVhdCA9IGFuaW1hdGlvbi5fcmVwZWF0LFxuICAgICAgZHVyID0gX3JvdW5kUHJlY2lzZShkdXJhdGlvbikgfHwgMCxcbiAgICAgIHRvdGFsUHJvZ3Jlc3MgPSBhbmltYXRpb24uX3RUaW1lIC8gYW5pbWF0aW9uLl90RHVyO1xuICB0b3RhbFByb2dyZXNzICYmICFsZWF2ZVBsYXloZWFkICYmIChhbmltYXRpb24uX3RpbWUgKj0gZHVyIC8gYW5pbWF0aW9uLl9kdXIpO1xuICBhbmltYXRpb24uX2R1ciA9IGR1cjtcbiAgYW5pbWF0aW9uLl90RHVyID0gIXJlcGVhdCA/IGR1ciA6IHJlcGVhdCA8IDAgPyAxZTEwIDogX3JvdW5kUHJlY2lzZShkdXIgKiAocmVwZWF0ICsgMSkgKyBhbmltYXRpb24uX3JEZWxheSAqIHJlcGVhdCk7XG4gIHRvdGFsUHJvZ3Jlc3MgPiAwICYmICFsZWF2ZVBsYXloZWFkICYmIF9hbGlnblBsYXloZWFkKGFuaW1hdGlvbiwgYW5pbWF0aW9uLl90VGltZSA9IGFuaW1hdGlvbi5fdER1ciAqIHRvdGFsUHJvZ3Jlc3MpO1xuICBhbmltYXRpb24ucGFyZW50ICYmIF9zZXRFbmQoYW5pbWF0aW9uKTtcbiAgc2tpcFVuY2FjaGUgfHwgX3VuY2FjaGUoYW5pbWF0aW9uLnBhcmVudCwgYW5pbWF0aW9uKTtcbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG4gICAgX29uVXBkYXRlVG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24oYW5pbWF0aW9uKSB7XG4gIHJldHVybiBhbmltYXRpb24gaW5zdGFuY2VvZiBUaW1lbGluZSA/IF91bmNhY2hlKGFuaW1hdGlvbikgOiBfc2V0RHVyYXRpb24oYW5pbWF0aW9uLCBhbmltYXRpb24uX2R1cik7XG59LFxuICAgIF96ZXJvUG9zaXRpb24gPSB7XG4gIF9zdGFydDogMCxcbiAgZW5kVGltZTogX2VtcHR5RnVuYyxcbiAgdG90YWxEdXJhdGlvbjogX2VtcHR5RnVuY1xufSxcbiAgICBfcGFyc2VQb3NpdGlvbiA9IGZ1bmN0aW9uIF9wYXJzZVBvc2l0aW9uKGFuaW1hdGlvbiwgcG9zaXRpb24sIHBlcmNlbnRBbmltYXRpb24pIHtcbiAgdmFyIGxhYmVscyA9IGFuaW1hdGlvbi5sYWJlbHMsXG4gICAgICByZWNlbnQgPSBhbmltYXRpb24uX3JlY2VudCB8fCBfemVyb1Bvc2l0aW9uLFxuICAgICAgY2xpcHBlZER1cmF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uKCkgPj0gX2JpZ051bSA/IHJlY2VudC5lbmRUaW1lKGZhbHNlKSA6IGFuaW1hdGlvbi5fZHVyLFxuICAgICAgLy9pbiBjYXNlIHRoZXJlJ3MgYSBjaGlsZCB0aGF0IGluZmluaXRlbHkgcmVwZWF0cywgdXNlcnMgYWxtb3N0IG5ldmVyIGludGVuZCBmb3IgdGhlIGluc2VydGlvbiBwb2ludCBvZiBhIG5ldyBjaGlsZCB0byBiZSBiYXNlZCBvbiBhIFNVUEVSIGxvbmcgdmFsdWUgbGlrZSB0aGF0IHNvIHdlIGNsaXAgaXQgYW5kIGFzc3VtZSB0aGUgbW9zdCByZWNlbnRseS1hZGRlZCBjaGlsZCdzIGVuZFRpbWUgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgaSxcbiAgICAgIG9mZnNldCxcbiAgICAgIGlzUGVyY2VudDtcblxuICBpZiAoX2lzU3RyaW5nKHBvc2l0aW9uKSAmJiAoaXNOYU4ocG9zaXRpb24pIHx8IHBvc2l0aW9uIGluIGxhYmVscykpIHtcbiAgICAvL2lmIHRoZSBzdHJpbmcgaXMgYSBudW1iZXIgbGlrZSBcIjFcIiwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlJ3MgYSBsYWJlbCB3aXRoIHRoYXQgbmFtZSwgb3RoZXJ3aXNlIGludGVycHJldCBpdCBhcyBhIG51bWJlciAoYWJzb2x1dGUgdmFsdWUpLlxuICAgIG9mZnNldCA9IHBvc2l0aW9uLmNoYXJBdCgwKTtcbiAgICBpc1BlcmNlbnQgPSBwb3NpdGlvbi5zdWJzdHIoLTEpID09PSBcIiVcIjtcbiAgICBpID0gcG9zaXRpb24uaW5kZXhPZihcIj1cIik7XG5cbiAgICBpZiAob2Zmc2V0ID09PSBcIjxcIiB8fCBvZmZzZXQgPT09IFwiPlwiKSB7XG4gICAgICBpID49IDAgJiYgKHBvc2l0aW9uID0gcG9zaXRpb24ucmVwbGFjZSgvPS8sIFwiXCIpKTtcbiAgICAgIHJldHVybiAob2Zmc2V0ID09PSBcIjxcIiA/IHJlY2VudC5fc3RhcnQgOiByZWNlbnQuZW5kVGltZShyZWNlbnQuX3JlcGVhdCA+PSAwKSkgKyAocGFyc2VGbG9hdChwb3NpdGlvbi5zdWJzdHIoMSkpIHx8IDApICogKGlzUGVyY2VudCA/IChpIDwgMCA/IHJlY2VudCA6IHBlcmNlbnRBbmltYXRpb24pLnRvdGFsRHVyYXRpb24oKSAvIDEwMCA6IDEpO1xuICAgIH1cblxuICAgIGlmIChpIDwgMCkge1xuICAgICAgcG9zaXRpb24gaW4gbGFiZWxzIHx8IChsYWJlbHNbcG9zaXRpb25dID0gY2xpcHBlZER1cmF0aW9uKTtcbiAgICAgIHJldHVybiBsYWJlbHNbcG9zaXRpb25dO1xuICAgIH1cblxuICAgIG9mZnNldCA9IHBhcnNlRmxvYXQocG9zaXRpb24uY2hhckF0KGkgLSAxKSArIHBvc2l0aW9uLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGlzUGVyY2VudCAmJiBwZXJjZW50QW5pbWF0aW9uKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgLyAxMDAgKiAoX2lzQXJyYXkocGVyY2VudEFuaW1hdGlvbikgPyBwZXJjZW50QW5pbWF0aW9uWzBdIDogcGVyY2VudEFuaW1hdGlvbikudG90YWxEdXJhdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiBpID4gMSA/IF9wYXJzZVBvc2l0aW9uKGFuaW1hdGlvbiwgcG9zaXRpb24uc3Vic3RyKDAsIGkgLSAxKSwgcGVyY2VudEFuaW1hdGlvbikgKyBvZmZzZXQgOiBjbGlwcGVkRHVyYXRpb24gKyBvZmZzZXQ7XG4gIH1cblxuICByZXR1cm4gcG9zaXRpb24gPT0gbnVsbCA/IGNsaXBwZWREdXJhdGlvbiA6ICtwb3NpdGlvbjtcbn0sXG4gICAgX2NyZWF0ZVR3ZWVuVHlwZSA9IGZ1bmN0aW9uIF9jcmVhdGVUd2VlblR5cGUodHlwZSwgcGFyYW1zLCB0aW1lbGluZSkge1xuICB2YXIgaXNMZWdhY3kgPSBfaXNOdW1iZXIocGFyYW1zWzFdKSxcbiAgICAgIHZhcnNJbmRleCA9IChpc0xlZ2FjeSA/IDIgOiAxKSArICh0eXBlIDwgMiA/IDAgOiAxKSxcbiAgICAgIHZhcnMgPSBwYXJhbXNbdmFyc0luZGV4XSxcbiAgICAgIGlyVmFycyxcbiAgICAgIHBhcmVudDtcblxuICBpc0xlZ2FjeSAmJiAodmFycy5kdXJhdGlvbiA9IHBhcmFtc1sxXSk7XG4gIHZhcnMucGFyZW50ID0gdGltZWxpbmU7XG5cbiAgaWYgKHR5cGUpIHtcbiAgICBpclZhcnMgPSB2YXJzO1xuICAgIHBhcmVudCA9IHRpbWVsaW5lO1xuXG4gICAgd2hpbGUgKHBhcmVudCAmJiAhKFwiaW1tZWRpYXRlUmVuZGVyXCIgaW4gaXJWYXJzKSkge1xuICAgICAgLy8gaW5oZXJpdGFuY2UgaGFzbid0IGhhcHBlbmVkIHlldCwgYnV0IHNvbWVvbmUgbWF5IGhhdmUgc2V0IGEgZGVmYXVsdCBpbiBhbiBhbmNlc3RvciB0aW1lbGluZS4gV2UgY291bGQgZG8gdmFycy5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZShfaW5oZXJpdERlZmF1bHRzKHZhcnMpLmltbWVkaWF0ZVJlbmRlcikgYnV0IHRoYXQnZCBleGFjdCBhIHNsaWdodCBwZXJmb3JtYW5jZSBwZW5hbHR5IGJlY2F1c2UgX2luaGVyaXREZWZhdWx0cygpIGFsc28gcnVucyBpbiB0aGUgVHdlZW4gY29uc3RydWN0b3IuIFdlJ3JlIHBheWluZyBhIHNtYWxsIGtiIHByaWNlIGhlcmUgdG8gZ2FpbiBzcGVlZC5cbiAgICAgIGlyVmFycyA9IHBhcmVudC52YXJzLmRlZmF1bHRzIHx8IHt9O1xuICAgICAgcGFyZW50ID0gX2lzTm90RmFsc2UocGFyZW50LnZhcnMuaW5oZXJpdCkgJiYgcGFyZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICB2YXJzLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKGlyVmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuICAgIHR5cGUgPCAyID8gdmFycy5ydW5CYWNrd2FyZHMgPSAxIDogdmFycy5zdGFydEF0ID0gcGFyYW1zW3ZhcnNJbmRleCAtIDFdOyAvLyBcImZyb21cIiB2YXJzXG4gIH1cblxuICByZXR1cm4gbmV3IFR3ZWVuKHBhcmFtc1swXSwgdmFycywgcGFyYW1zW3ZhcnNJbmRleCArIDFdKTtcbn0sXG4gICAgX2NvbmRpdGlvbmFsUmV0dXJuID0gZnVuY3Rpb24gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jKSB7XG4gIHJldHVybiB2YWx1ZSB8fCB2YWx1ZSA9PT0gMCA/IGZ1bmModmFsdWUpIDogZnVuYztcbn0sXG4gICAgX2NsYW1wID0gZnVuY3Rpb24gX2NsYW1wKG1pbiwgbWF4LCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPCBtaW4gPyBtaW4gOiB2YWx1ZSA+IG1heCA/IG1heCA6IHZhbHVlO1xufSxcbiAgICBnZXRVbml0ID0gZnVuY3Rpb24gZ2V0VW5pdCh2YWx1ZSwgdikge1xuICByZXR1cm4gIV9pc1N0cmluZyh2YWx1ZSkgfHwgISh2ID0gX3VuaXRFeHAuZXhlYyh2YWx1ZSkpID8gXCJcIiA6IHZbMV07XG59LFxuICAgIC8vIG5vdGU6IHByb3RlY3QgYWdhaW5zdCBwYWRkZWQgbnVtYmVycyBhcyBzdHJpbmdzLCBsaWtlIFwiMTAwLjEwMFwiLiBUaGF0IHNob3VsZG4ndCByZXR1cm4gXCIwMFwiIGFzIHRoZSB1bml0LiBJZiBpdCdzIG51bWVyaWMsIHJldHVybiBubyB1bml0LlxuY2xhbXAgPSBmdW5jdGlvbiBjbGFtcChtaW4sIG1heCwgdmFsdWUpIHtcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gX2NsYW1wKG1pbiwgbWF4LCB2KTtcbiAgfSk7XG59LFxuICAgIF9zbGljZSA9IFtdLnNsaWNlLFxuICAgIF9pc0FycmF5TGlrZSA9IGZ1bmN0aW9uIF9pc0FycmF5TGlrZSh2YWx1ZSwgbm9uRW1wdHkpIHtcbiAgcmV0dXJuIHZhbHVlICYmIF9pc09iamVjdCh2YWx1ZSkgJiYgXCJsZW5ndGhcIiBpbiB2YWx1ZSAmJiAoIW5vbkVtcHR5ICYmICF2YWx1ZS5sZW5ndGggfHwgdmFsdWUubGVuZ3RoIC0gMSBpbiB2YWx1ZSAmJiBfaXNPYmplY3QodmFsdWVbMF0pKSAmJiAhdmFsdWUubm9kZVR5cGUgJiYgdmFsdWUgIT09IF93aW47XG59LFxuICAgIF9mbGF0dGVuID0gZnVuY3Rpb24gX2ZsYXR0ZW4oYXIsIGxlYXZlU3RyaW5ncywgYWNjdW11bGF0b3IpIHtcbiAgaWYgKGFjY3VtdWxhdG9yID09PSB2b2lkIDApIHtcbiAgICBhY2N1bXVsYXRvciA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGFyLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIF9hY2N1bXVsYXRvcjtcblxuICAgIHJldHVybiBfaXNTdHJpbmcodmFsdWUpICYmICFsZWF2ZVN0cmluZ3MgfHwgX2lzQXJyYXlMaWtlKHZhbHVlLCAxKSA/IChfYWNjdW11bGF0b3IgPSBhY2N1bXVsYXRvcikucHVzaC5hcHBseShfYWNjdW11bGF0b3IsIHRvQXJyYXkodmFsdWUpKSA6IGFjY3VtdWxhdG9yLnB1c2godmFsdWUpO1xuICB9KSB8fCBhY2N1bXVsYXRvcjtcbn0sXG4gICAgLy90YWtlcyBhbnkgdmFsdWUgYW5kIHJldHVybnMgYW4gYXJyYXkuIElmIGl0J3MgYSBzdHJpbmcgKGFuZCBsZWF2ZVN0cmluZ3MgaXNuJ3QgdHJ1ZSksIGl0J2xsIHVzZSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCkgYW5kIGNvbnZlcnQgdGhhdCB0byBhbiBhcnJheS4gSXQnbGwgYWxzbyBhY2NlcHQgaXRlcmFibGVzIGxpa2UgalF1ZXJ5IG9iamVjdHMuXG50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSwgc2NvcGUsIGxlYXZlU3RyaW5ncykge1xuICByZXR1cm4gX2NvbnRleHQgJiYgIXNjb3BlICYmIF9jb250ZXh0LnNlbGVjdG9yID8gX2NvbnRleHQuc2VsZWN0b3IodmFsdWUpIDogX2lzU3RyaW5nKHZhbHVlKSAmJiAhbGVhdmVTdHJpbmdzICYmIChfY29yZUluaXR0ZWQgfHwgIV93YWtlKCkpID8gX3NsaWNlLmNhbGwoKHNjb3BlIHx8IF9kb2MpLnF1ZXJ5U2VsZWN0b3JBbGwodmFsdWUpLCAwKSA6IF9pc0FycmF5KHZhbHVlKSA/IF9mbGF0dGVuKHZhbHVlLCBsZWF2ZVN0cmluZ3MpIDogX2lzQXJyYXlMaWtlKHZhbHVlKSA/IF9zbGljZS5jYWxsKHZhbHVlLCAwKSA6IHZhbHVlID8gW3ZhbHVlXSA6IFtdO1xufSxcbiAgICBzZWxlY3RvciA9IGZ1bmN0aW9uIHNlbGVjdG9yKHZhbHVlKSB7XG4gIHZhbHVlID0gdG9BcnJheSh2YWx1ZSlbMF0gfHwgX3dhcm4oXCJJbnZhbGlkIHNjb3BlXCIpIHx8IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgZWwgPSB2YWx1ZS5jdXJyZW50IHx8IHZhbHVlLm5hdGl2ZUVsZW1lbnQgfHwgdmFsdWU7XG4gICAgcmV0dXJuIHRvQXJyYXkodiwgZWwucXVlcnlTZWxlY3RvckFsbCA/IGVsIDogZWwgPT09IHZhbHVlID8gX3dhcm4oXCJJbnZhbGlkIHNjb3BlXCIpIHx8IF9kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSA6IHZhbHVlKTtcbiAgfTtcbn0sXG4gICAgc2h1ZmZsZSA9IGZ1bmN0aW9uIHNodWZmbGUoYSkge1xuICByZXR1cm4gYS5zb3J0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gLjUgLSBNYXRoLnJhbmRvbSgpO1xuICB9KTtcbn0sXG4gICAgLy8gYWx0ZXJuYXRpdmUgdGhhdCdzIGEgYml0IGZhc3RlciBhbmQgbW9yZSByZWxpYWJseSBkaXZlcnNlIGJ1dCBiaWdnZXI6ICAgZm9yIChsZXQgaiwgdiwgaSA9IGEubGVuZ3RoOyBpOyBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogaSksIHYgPSBhWy0taV0sIGFbaV0gPSBhW2pdLCBhW2pdID0gdik7IHJldHVybiBhO1xuLy9mb3IgZGlzdHJpYnV0aW5nIHZhbHVlcyBhY3Jvc3MgYW4gYXJyYXkuIENhbiBhY2NlcHQgYSBudW1iZXIsIGEgZnVuY3Rpb24gb3IgKG1vc3QgY29tbW9ubHkpIGEgZnVuY3Rpb24gd2hpY2ggY2FuIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOiB7YmFzZSwgYW1vdW50LCBmcm9tLCBlYXNlLCBncmlkLCBheGlzLCBsZW5ndGgsIGVhY2h9LiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBleHBlY3RzIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczogaW5kZXgsIHRhcmdldCwgYXJyYXkuIFJlY29nbml6ZXMgdGhlIGZvbGxvd2luZ1xuZGlzdHJpYnV0ZSA9IGZ1bmN0aW9uIGRpc3RyaWJ1dGUodikge1xuICBpZiAoX2lzRnVuY3Rpb24odikpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuXG4gIHZhciB2YXJzID0gX2lzT2JqZWN0KHYpID8gdiA6IHtcbiAgICBlYWNoOiB2XG4gIH0sXG4gICAgICAvL246MSBpcyBqdXN0IHRvIGluZGljYXRlIHYgd2FzIGEgbnVtYmVyOyB3ZSBsZXZlcmFnZSB0aGF0IGxhdGVyIHRvIHNldCB2IGFjY29yZGluZyB0byB0aGUgbGVuZ3RoIHdlIGdldC4gSWYgYSBudW1iZXIgaXMgcGFzc2VkIGluLCB3ZSB0cmVhdCBpdCBsaWtlIHRoZSBvbGQgc3RhZ2dlciB2YWx1ZSB3aGVyZSAwLjEsIGZvciBleGFtcGxlLCB3b3VsZCBtZWFuIHRoYXQgdGhpbmdzIHdvdWxkIGJlIGRpc3RyaWJ1dGVkIHdpdGggMC4xIGJldHdlZW4gZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSByYXRoZXIgdGhhbiBhIHRvdGFsIFwiYW1vdW50XCIgdGhhdCdzIGNodW5rZWQgb3V0IGFtb25nIHRoZW0gYWxsLlxuICBlYXNlID0gX3BhcnNlRWFzZSh2YXJzLmVhc2UpLFxuICAgICAgZnJvbSA9IHZhcnMuZnJvbSB8fCAwLFxuICAgICAgYmFzZSA9IHBhcnNlRmxvYXQodmFycy5iYXNlKSB8fCAwLFxuICAgICAgY2FjaGUgPSB7fSxcbiAgICAgIGlzRGVjaW1hbCA9IGZyb20gPiAwICYmIGZyb20gPCAxLFxuICAgICAgcmF0aW9zID0gaXNOYU4oZnJvbSkgfHwgaXNEZWNpbWFsLFxuICAgICAgYXhpcyA9IHZhcnMuYXhpcyxcbiAgICAgIHJhdGlvWCA9IGZyb20sXG4gICAgICByYXRpb1kgPSBmcm9tO1xuXG4gIGlmIChfaXNTdHJpbmcoZnJvbSkpIHtcbiAgICByYXRpb1ggPSByYXRpb1kgPSB7XG4gICAgICBjZW50ZXI6IC41LFxuICAgICAgZWRnZXM6IC41LFxuICAgICAgZW5kOiAxXG4gICAgfVtmcm9tXSB8fCAwO1xuICB9IGVsc2UgaWYgKCFpc0RlY2ltYWwgJiYgcmF0aW9zKSB7XG4gICAgcmF0aW9YID0gZnJvbVswXTtcbiAgICByYXRpb1kgPSBmcm9tWzFdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpLCB0YXJnZXQsIGEpIHtcbiAgICB2YXIgbCA9IChhIHx8IHZhcnMpLmxlbmd0aCxcbiAgICAgICAgZGlzdGFuY2VzID0gY2FjaGVbbF0sXG4gICAgICAgIG9yaWdpblgsXG4gICAgICAgIG9yaWdpblksXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGQsXG4gICAgICAgIGosXG4gICAgICAgIG1heCxcbiAgICAgICAgbWluLFxuICAgICAgICB3cmFwQXQ7XG5cbiAgICBpZiAoIWRpc3RhbmNlcykge1xuICAgICAgd3JhcEF0ID0gdmFycy5ncmlkID09PSBcImF1dG9cIiA/IDAgOiAodmFycy5ncmlkIHx8IFsxLCBfYmlnTnVtXSlbMV07XG5cbiAgICAgIGlmICghd3JhcEF0KSB7XG4gICAgICAgIG1heCA9IC1fYmlnTnVtO1xuXG4gICAgICAgIHdoaWxlIChtYXggPCAobWF4ID0gYVt3cmFwQXQrK10uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCkgJiYgd3JhcEF0IDwgbCkge31cblxuICAgICAgICB3cmFwQXQgPCBsICYmIHdyYXBBdC0tO1xuICAgICAgfVxuXG4gICAgICBkaXN0YW5jZXMgPSBjYWNoZVtsXSA9IFtdO1xuICAgICAgb3JpZ2luWCA9IHJhdGlvcyA/IE1hdGgubWluKHdyYXBBdCwgbCkgKiByYXRpb1ggLSAuNSA6IGZyb20gJSB3cmFwQXQ7XG4gICAgICBvcmlnaW5ZID0gd3JhcEF0ID09PSBfYmlnTnVtID8gMCA6IHJhdGlvcyA/IGwgKiByYXRpb1kgLyB3cmFwQXQgLSAuNSA6IGZyb20gLyB3cmFwQXQgfCAwO1xuICAgICAgbWF4ID0gMDtcbiAgICAgIG1pbiA9IF9iaWdOdW07XG5cbiAgICAgIGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICAgICAgeCA9IGogJSB3cmFwQXQgLSBvcmlnaW5YO1xuICAgICAgICB5ID0gb3JpZ2luWSAtIChqIC8gd3JhcEF0IHwgMCk7XG4gICAgICAgIGRpc3RhbmNlc1tqXSA9IGQgPSAhYXhpcyA/IF9zcXJ0KHggKiB4ICsgeSAqIHkpIDogTWF0aC5hYnMoYXhpcyA9PT0gXCJ5XCIgPyB5IDogeCk7XG4gICAgICAgIGQgPiBtYXggJiYgKG1heCA9IGQpO1xuICAgICAgICBkIDwgbWluICYmIChtaW4gPSBkKTtcbiAgICAgIH1cblxuICAgICAgZnJvbSA9PT0gXCJyYW5kb21cIiAmJiBzaHVmZmxlKGRpc3RhbmNlcyk7XG4gICAgICBkaXN0YW5jZXMubWF4ID0gbWF4IC0gbWluO1xuICAgICAgZGlzdGFuY2VzLm1pbiA9IG1pbjtcbiAgICAgIGRpc3RhbmNlcy52ID0gbCA9IChwYXJzZUZsb2F0KHZhcnMuYW1vdW50KSB8fCBwYXJzZUZsb2F0KHZhcnMuZWFjaCkgKiAod3JhcEF0ID4gbCA/IGwgLSAxIDogIWF4aXMgPyBNYXRoLm1heCh3cmFwQXQsIGwgLyB3cmFwQXQpIDogYXhpcyA9PT0gXCJ5XCIgPyBsIC8gd3JhcEF0IDogd3JhcEF0KSB8fCAwKSAqIChmcm9tID09PSBcImVkZ2VzXCIgPyAtMSA6IDEpO1xuICAgICAgZGlzdGFuY2VzLmIgPSBsIDwgMCA/IGJhc2UgLSBsIDogYmFzZTtcbiAgICAgIGRpc3RhbmNlcy51ID0gZ2V0VW5pdCh2YXJzLmFtb3VudCB8fCB2YXJzLmVhY2gpIHx8IDA7IC8vdW5pdFxuXG4gICAgICBlYXNlID0gZWFzZSAmJiBsIDwgMCA/IF9pbnZlcnRFYXNlKGVhc2UpIDogZWFzZTtcbiAgICB9XG5cbiAgICBsID0gKGRpc3RhbmNlc1tpXSAtIGRpc3RhbmNlcy5taW4pIC8gZGlzdGFuY2VzLm1heCB8fCAwO1xuICAgIHJldHVybiBfcm91bmRQcmVjaXNlKGRpc3RhbmNlcy5iICsgKGVhc2UgPyBlYXNlKGwpIDogbCkgKiBkaXN0YW5jZXMudikgKyBkaXN0YW5jZXMudTsgLy9yb3VuZCBpbiBvcmRlciB0byB3b3JrIGFyb3VuZCBmbG9hdGluZyBwb2ludCBlcnJvcnNcbiAgfTtcbn0sXG4gICAgX3JvdW5kTW9kaWZpZXIgPSBmdW5jdGlvbiBfcm91bmRNb2RpZmllcih2KSB7XG4gIC8vcGFzcyBpbiAwLjEgZ2V0IGEgZnVuY3Rpb24gdGhhdCdsbCByb3VuZCB0byB0aGUgbmVhcmVzdCB0ZW50aCwgb3IgNSB0byByb3VuZCB0byB0aGUgY2xvc2VzdCA1LCBvciAwLjAwMSB0byB0aGUgY2xvc2VzdCAxMDAwdGgsIGV0Yy5cbiAgdmFyIHAgPSBNYXRoLnBvdygxMCwgKCh2ICsgXCJcIikuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aCk7IC8vdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGxpa2UgMjQgKiAwLjEgPT0gMi40MDAwMDAwMDAwMDAwMDA0KSwgd2UgY2hvcCBvZmYgYXQgYSBzcGVjaWZpYyBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgKG11Y2ggZmFzdGVyIHRoYW4gdG9GaXhlZCgpKVxuXG4gIHJldHVybiBmdW5jdGlvbiAocmF3KSB7XG4gICAgdmFyIG4gPSBfcm91bmRQcmVjaXNlKE1hdGgucm91bmQocGFyc2VGbG9hdChyYXcpIC8gdikgKiB2ICogcCk7XG5cbiAgICByZXR1cm4gKG4gLSBuICUgMSkgLyBwICsgKF9pc051bWJlcihyYXcpID8gMCA6IGdldFVuaXQocmF3KSk7IC8vIG4gLSBuICUgMSByZXBsYWNlcyBNYXRoLmZsb29yKCkgaW4gb3JkZXIgdG8gaGFuZGxlIG5lZ2F0aXZlIHZhbHVlcyBwcm9wZXJseS4gRm9yIGV4YW1wbGUsIE1hdGguZmxvb3IoLTE1MC4wMDAwMDAwMDAwMDAwMykgaXMgMTUxIVxuICB9O1xufSxcbiAgICBzbmFwID0gZnVuY3Rpb24gc25hcChzbmFwVG8sIHZhbHVlKSB7XG4gIHZhciBpc0FycmF5ID0gX2lzQXJyYXkoc25hcFRvKSxcbiAgICAgIHJhZGl1cyxcbiAgICAgIGlzMkQ7XG5cbiAgaWYgKCFpc0FycmF5ICYmIF9pc09iamVjdChzbmFwVG8pKSB7XG4gICAgcmFkaXVzID0gaXNBcnJheSA9IHNuYXBUby5yYWRpdXMgfHwgX2JpZ051bTtcblxuICAgIGlmIChzbmFwVG8udmFsdWVzKSB7XG4gICAgICBzbmFwVG8gPSB0b0FycmF5KHNuYXBUby52YWx1ZXMpO1xuXG4gICAgICBpZiAoaXMyRCA9ICFfaXNOdW1iZXIoc25hcFRvWzBdKSkge1xuICAgICAgICByYWRpdXMgKj0gcmFkaXVzOyAvL3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBzbyB3ZSBkb24ndCBoYXZlIHRvIE1hdGguc3FydCgpIGluIHRoZSBsb29wLlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzbmFwVG8gPSBfcm91bmRNb2RpZmllcihzbmFwVG8uaW5jcmVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCAhaXNBcnJheSA/IF9yb3VuZE1vZGlmaWVyKHNuYXBUbykgOiBfaXNGdW5jdGlvbihzbmFwVG8pID8gZnVuY3Rpb24gKHJhdykge1xuICAgIGlzMkQgPSBzbmFwVG8ocmF3KTtcbiAgICByZXR1cm4gTWF0aC5hYnMoaXMyRCAtIHJhdykgPD0gcmFkaXVzID8gaXMyRCA6IHJhdztcbiAgfSA6IGZ1bmN0aW9uIChyYXcpIHtcbiAgICB2YXIgeCA9IHBhcnNlRmxvYXQoaXMyRCA/IHJhdy54IDogcmF3KSxcbiAgICAgICAgeSA9IHBhcnNlRmxvYXQoaXMyRCA/IHJhdy55IDogMCksXG4gICAgICAgIG1pbiA9IF9iaWdOdW0sXG4gICAgICAgIGNsb3Nlc3QgPSAwLFxuICAgICAgICBpID0gc25hcFRvLmxlbmd0aCxcbiAgICAgICAgZHgsXG4gICAgICAgIGR5O1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGlzMkQpIHtcbiAgICAgICAgZHggPSBzbmFwVG9baV0ueCAtIHg7XG4gICAgICAgIGR5ID0gc25hcFRvW2ldLnkgLSB5O1xuICAgICAgICBkeCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHggPSBNYXRoLmFicyhzbmFwVG9baV0gLSB4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGR4IDwgbWluKSB7XG4gICAgICAgIG1pbiA9IGR4O1xuICAgICAgICBjbG9zZXN0ID0gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbG9zZXN0ID0gIXJhZGl1cyB8fCBtaW4gPD0gcmFkaXVzID8gc25hcFRvW2Nsb3Nlc3RdIDogcmF3O1xuICAgIHJldHVybiBpczJEIHx8IGNsb3Nlc3QgPT09IHJhdyB8fCBfaXNOdW1iZXIocmF3KSA/IGNsb3Nlc3QgOiBjbG9zZXN0ICsgZ2V0VW5pdChyYXcpO1xuICB9KTtcbn0sXG4gICAgcmFuZG9tID0gZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4LCByb3VuZGluZ0luY3JlbWVudCwgcmV0dXJuRnVuY3Rpb24pIHtcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybihfaXNBcnJheShtaW4pID8gIW1heCA6IHJvdW5kaW5nSW5jcmVtZW50ID09PSB0cnVlID8gISEocm91bmRpbmdJbmNyZW1lbnQgPSAwKSA6ICFyZXR1cm5GdW5jdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNBcnJheShtaW4pID8gbWluW35+KE1hdGgucmFuZG9tKCkgKiBtaW4ubGVuZ3RoKV0gOiAocm91bmRpbmdJbmNyZW1lbnQgPSByb3VuZGluZ0luY3JlbWVudCB8fCAxZS01KSAmJiAocmV0dXJuRnVuY3Rpb24gPSByb3VuZGluZ0luY3JlbWVudCA8IDEgPyBNYXRoLnBvdygxMCwgKHJvdW5kaW5nSW5jcmVtZW50ICsgXCJcIikubGVuZ3RoIC0gMikgOiAxKSAmJiBNYXRoLmZsb29yKE1hdGgucm91bmQoKG1pbiAtIHJvdW5kaW5nSW5jcmVtZW50IC8gMiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgcm91bmRpbmdJbmNyZW1lbnQgKiAuOTkpKSAvIHJvdW5kaW5nSW5jcmVtZW50KSAqIHJvdW5kaW5nSW5jcmVtZW50ICogcmV0dXJuRnVuY3Rpb24pIC8gcmV0dXJuRnVuY3Rpb247XG4gIH0pO1xufSxcbiAgICBwaXBlID0gZnVuY3Rpb24gcGlwZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmN0aW9ucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jdGlvbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHYsIGYpIHtcbiAgICAgIHJldHVybiBmKHYpO1xuICAgIH0sIHZhbHVlKTtcbiAgfTtcbn0sXG4gICAgdW5pdGl6ZSA9IGZ1bmN0aW9uIHVuaXRpemUoZnVuYywgdW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmMocGFyc2VGbG9hdCh2YWx1ZSkpICsgKHVuaXQgfHwgZ2V0VW5pdCh2YWx1ZSkpO1xuICB9O1xufSxcbiAgICBub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUobWluLCBtYXgsIHZhbHVlKSB7XG4gIHJldHVybiBtYXBSYW5nZShtaW4sIG1heCwgMCwgMSwgdmFsdWUpO1xufSxcbiAgICBfd3JhcEFycmF5ID0gZnVuY3Rpb24gX3dyYXBBcnJheShhLCB3cmFwcGVyLCB2YWx1ZSkge1xuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gYVt+fndyYXBwZXIoaW5kZXgpXTtcbiAgfSk7XG59LFxuICAgIHdyYXAgPSBmdW5jdGlvbiB3cmFwKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAvLyBOT1RFOiB3cmFwKCkgQ0FOTk9UIGJlIGFuIGFycm93IGZ1bmN0aW9uISBBIHZlcnkgb2RkIGNvbXBpbGluZyBidWcgY2F1c2VzIHByb2JsZW1zICh1bnJlbGF0ZWQgdG8gR1NBUCkuXG4gIHZhciByYW5nZSA9IG1heCAtIG1pbjtcbiAgcmV0dXJuIF9pc0FycmF5KG1pbikgPyBfd3JhcEFycmF5KG1pbiwgd3JhcCgwLCBtaW4ubGVuZ3RoKSwgbWF4KSA6IF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIChyYW5nZSArICh2YWx1ZSAtIG1pbikgJSByYW5nZSkgJSByYW5nZSArIG1pbjtcbiAgfSk7XG59LFxuICAgIHdyYXBZb3lvID0gZnVuY3Rpb24gd3JhcFlveW8obWluLCBtYXgsIHZhbHVlKSB7XG4gIHZhciByYW5nZSA9IG1heCAtIG1pbixcbiAgICAgIHRvdGFsID0gcmFuZ2UgKiAyO1xuICByZXR1cm4gX2lzQXJyYXkobWluKSA/IF93cmFwQXJyYXkobWluLCB3cmFwWW95bygwLCBtaW4ubGVuZ3RoIC0gMSksIG1heCkgOiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhbHVlID0gKHRvdGFsICsgKHZhbHVlIC0gbWluKSAlIHRvdGFsKSAlIHRvdGFsIHx8IDA7XG4gICAgcmV0dXJuIG1pbiArICh2YWx1ZSA+IHJhbmdlID8gdG90YWwgLSB2YWx1ZSA6IHZhbHVlKTtcbiAgfSk7XG59LFxuICAgIF9yZXBsYWNlUmFuZG9tID0gZnVuY3Rpb24gX3JlcGxhY2VSYW5kb20odmFsdWUpIHtcbiAgLy9yZXBsYWNlcyBhbGwgb2NjdXJyZW5jZXMgb2YgcmFuZG9tKC4uLikgaW4gYSBzdHJpbmcgd2l0aCB0aGUgY2FsY3VsYXRlZCByYW5kb20gdmFsdWUuIGNhbiBiZSBhIHJhbmdlIGxpa2UgcmFuZG9tKC0xMDAsIDEwMCwgNSkgb3IgYW4gYXJyYXkgbGlrZSByYW5kb20oWzAsIDEwMCwgNTAwXSlcbiAgdmFyIHByZXYgPSAwLFxuICAgICAgcyA9IFwiXCIsXG4gICAgICBpLFxuICAgICAgbnVtcyxcbiAgICAgIGVuZCxcbiAgICAgIGlzQXJyYXk7XG5cbiAgd2hpbGUgKH4oaSA9IHZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIsIHByZXYpKSkge1xuICAgIGVuZCA9IHZhbHVlLmluZGV4T2YoXCIpXCIsIGkpO1xuICAgIGlzQXJyYXkgPSB2YWx1ZS5jaGFyQXQoaSArIDcpID09PSBcIltcIjtcbiAgICBudW1zID0gdmFsdWUuc3Vic3RyKGkgKyA3LCBlbmQgLSBpIC0gNykubWF0Y2goaXNBcnJheSA/IF9kZWxpbWl0ZWRWYWx1ZUV4cCA6IF9zdHJpY3ROdW1FeHApO1xuICAgIHMgKz0gdmFsdWUuc3Vic3RyKHByZXYsIGkgLSBwcmV2KSArIHJhbmRvbShpc0FycmF5ID8gbnVtcyA6ICtudW1zWzBdLCBpc0FycmF5ID8gMCA6ICtudW1zWzFdLCArbnVtc1syXSB8fCAxZS01KTtcbiAgICBwcmV2ID0gZW5kICsgMTtcbiAgfVxuXG4gIHJldHVybiBzICsgdmFsdWUuc3Vic3RyKHByZXYsIHZhbHVlLmxlbmd0aCAtIHByZXYpO1xufSxcbiAgICBtYXBSYW5nZSA9IGZ1bmN0aW9uIG1hcFJhbmdlKGluTWluLCBpbk1heCwgb3V0TWluLCBvdXRNYXgsIHZhbHVlKSB7XG4gIHZhciBpblJhbmdlID0gaW5NYXggLSBpbk1pbixcbiAgICAgIG91dFJhbmdlID0gb3V0TWF4IC0gb3V0TWluO1xuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gb3V0TWluICsgKCh2YWx1ZSAtIGluTWluKSAvIGluUmFuZ2UgKiBvdXRSYW5nZSB8fCAwKTtcbiAgfSk7XG59LFxuICAgIGludGVycG9sYXRlID0gZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3RhcnQsIGVuZCwgcHJvZ3Jlc3MsIG11dGF0ZSkge1xuICB2YXIgZnVuYyA9IGlzTmFOKHN0YXJ0ICsgZW5kKSA/IDAgOiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAoMSAtIHApICogc3RhcnQgKyBwICogZW5kO1xuICB9O1xuXG4gIGlmICghZnVuYykge1xuICAgIHZhciBpc1N0cmluZyA9IF9pc1N0cmluZyhzdGFydCksXG4gICAgICAgIG1hc3RlciA9IHt9LFxuICAgICAgICBwLFxuICAgICAgICBpLFxuICAgICAgICBpbnRlcnBvbGF0b3JzLFxuICAgICAgICBsLFxuICAgICAgICBpbDtcblxuICAgIHByb2dyZXNzID09PSB0cnVlICYmIChtdXRhdGUgPSAxKSAmJiAocHJvZ3Jlc3MgPSBudWxsKTtcblxuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgc3RhcnQgPSB7XG4gICAgICAgIHA6IHN0YXJ0XG4gICAgICB9O1xuICAgICAgZW5kID0ge1xuICAgICAgICBwOiBlbmRcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChfaXNBcnJheShzdGFydCkgJiYgIV9pc0FycmF5KGVuZCkpIHtcbiAgICAgIGludGVycG9sYXRvcnMgPSBbXTtcbiAgICAgIGwgPSBzdGFydC5sZW5ndGg7XG4gICAgICBpbCA9IGwgLSAyO1xuXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGludGVycG9sYXRvcnMucHVzaChpbnRlcnBvbGF0ZShzdGFydFtpIC0gMV0sIHN0YXJ0W2ldKSk7IC8vYnVpbGQgdGhlIGludGVycG9sYXRvcnMgdXAgZnJvbnQgYXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gc28gdGhhdCB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgbWFueSB0aW1lcywgaXQgY2FuIGp1c3QgcmV1c2UgdGhlbS5cbiAgICAgIH1cblxuICAgICAgbC0tO1xuXG4gICAgICBmdW5jID0gZnVuY3Rpb24gZnVuYyhwKSB7XG4gICAgICAgIHAgKj0gbDtcbiAgICAgICAgdmFyIGkgPSBNYXRoLm1pbihpbCwgfn5wKTtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRvcnNbaV0ocCAtIGkpO1xuICAgICAgfTtcblxuICAgICAgcHJvZ3Jlc3MgPSBlbmQ7XG4gICAgfSBlbHNlIGlmICghbXV0YXRlKSB7XG4gICAgICBzdGFydCA9IF9tZXJnZShfaXNBcnJheShzdGFydCkgPyBbXSA6IHt9LCBzdGFydCk7XG4gICAgfVxuXG4gICAgaWYgKCFpbnRlcnBvbGF0b3JzKSB7XG4gICAgICBmb3IgKHAgaW4gZW5kKSB7XG4gICAgICAgIF9hZGRQcm9wVHdlZW4uY2FsbChtYXN0ZXIsIHN0YXJ0LCBwLCBcImdldFwiLCBlbmRbcF0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jID0gZnVuY3Rpb24gZnVuYyhwKSB7XG4gICAgICAgIHJldHVybiBfcmVuZGVyUHJvcFR3ZWVucyhwLCBtYXN0ZXIpIHx8IChpc1N0cmluZyA/IHN0YXJ0LnAgOiBzdGFydCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4ocHJvZ3Jlc3MsIGZ1bmMpO1xufSxcbiAgICBfZ2V0TGFiZWxJbkRpcmVjdGlvbiA9IGZ1bmN0aW9uIF9nZXRMYWJlbEluRGlyZWN0aW9uKHRpbWVsaW5lLCBmcm9tVGltZSwgYmFja3dhcmQpIHtcbiAgLy91c2VkIGZvciBuZXh0TGFiZWwoKSBhbmQgcHJldmlvdXNMYWJlbCgpXG4gIHZhciBsYWJlbHMgPSB0aW1lbGluZS5sYWJlbHMsXG4gICAgICBtaW4gPSBfYmlnTnVtLFxuICAgICAgcCxcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgbGFiZWw7XG5cbiAgZm9yIChwIGluIGxhYmVscykge1xuICAgIGRpc3RhbmNlID0gbGFiZWxzW3BdIC0gZnJvbVRpbWU7XG5cbiAgICBpZiAoZGlzdGFuY2UgPCAwID09PSAhIWJhY2t3YXJkICYmIGRpc3RhbmNlICYmIG1pbiA+IChkaXN0YW5jZSA9IE1hdGguYWJzKGRpc3RhbmNlKSkpIHtcbiAgICAgIGxhYmVsID0gcDtcbiAgICAgIG1pbiA9IGRpc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsYWJlbDtcbn0sXG4gICAgX2NhbGxiYWNrID0gZnVuY3Rpb24gX2NhbGxiYWNrKGFuaW1hdGlvbiwgdHlwZSwgZXhlY3V0ZUxhenlGaXJzdCkge1xuICB2YXIgdiA9IGFuaW1hdGlvbi52YXJzLFxuICAgICAgY2FsbGJhY2sgPSB2W3R5cGVdLFxuICAgICAgcHJldkNvbnRleHQgPSBfY29udGV4dCxcbiAgICAgIGNvbnRleHQgPSBhbmltYXRpb24uX2N0eCxcbiAgICAgIHBhcmFtcyxcbiAgICAgIHNjb3BlLFxuICAgICAgcmVzdWx0O1xuXG4gIGlmICghY2FsbGJhY2spIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwYXJhbXMgPSB2W3R5cGUgKyBcIlBhcmFtc1wiXTtcbiAgc2NvcGUgPSB2LmNhbGxiYWNrU2NvcGUgfHwgYW5pbWF0aW9uO1xuICBleGVjdXRlTGF6eUZpcnN0ICYmIF9sYXp5VHdlZW5zLmxlbmd0aCAmJiBfbGF6eVJlbmRlcigpOyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gYSB0aW1lbGluZSBmaW5pc2hlcywgdXNlcnMgZXhwZWN0IHRoaW5ncyB0byBoYXZlIHJlbmRlcmVkIGZ1bGx5LiBJbWFnaW5lIGFuIG9uVXBkYXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblxuICBjb250ZXh0ICYmIChfY29udGV4dCA9IGNvbnRleHQpO1xuICByZXN1bHQgPSBwYXJhbXMgPyBjYWxsYmFjay5hcHBseShzY29wZSwgcGFyYW1zKSA6IGNhbGxiYWNrLmNhbGwoc2NvcGUpO1xuICBfY29udGV4dCA9IHByZXZDb250ZXh0O1xuICByZXR1cm4gcmVzdWx0O1xufSxcbiAgICBfaW50ZXJydXB0ID0gZnVuY3Rpb24gX2ludGVycnVwdChhbmltYXRpb24pIHtcbiAgX3JlbW92ZUZyb21QYXJlbnQoYW5pbWF0aW9uKTtcblxuICBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlciAmJiBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlci5raWxsKCEhX3JldmVydGluZyk7XG4gIGFuaW1hdGlvbi5wcm9ncmVzcygpIDwgMSAmJiBfY2FsbGJhY2soYW5pbWF0aW9uLCBcIm9uSW50ZXJydXB0XCIpO1xuICByZXR1cm4gYW5pbWF0aW9uO1xufSxcbiAgICBfcXVpY2tUd2VlbixcbiAgICBfcmVnaXN0ZXJQbHVnaW5RdWV1ZSA9IFtdLFxuICAgIF9jcmVhdGVQbHVnaW4gPSBmdW5jdGlvbiBfY3JlYXRlUGx1Z2luKGNvbmZpZykge1xuICBpZiAoIWNvbmZpZykgcmV0dXJuO1xuICBjb25maWcgPSAhY29uZmlnLm5hbWUgJiYgY29uZmlnW1wiZGVmYXVsdFwiXSB8fCBjb25maWc7IC8vIFVNRCBwYWNrYWdpbmcgd3JhcHMgdGhpbmdzIG9kZGx5LCBzbyBmb3IgZXhhbXBsZSBNb3Rpb25QYXRoSGVscGVyIGJlY29tZXMge01vdGlvblBhdGhIZWxwZXI6TW90aW9uUGF0aEhlbHBlciwgZGVmYXVsdDpNb3Rpb25QYXRoSGVscGVyfS5cblxuICBpZiAoX3dpbmRvd0V4aXN0cygpIHx8IGNvbmZpZy5oZWFkbGVzcykge1xuICAgIC8vIGVkZ2UgY2FzZTogc29tZSBidWlsZCB0b29scyBtYXkgcGFzcyBpbiBhIG51bGwvdW5kZWZpbmVkIHZhbHVlXG4gICAgdmFyIG5hbWUgPSBjb25maWcubmFtZSxcbiAgICAgICAgaXNGdW5jID0gX2lzRnVuY3Rpb24oY29uZmlnKSxcbiAgICAgICAgUGx1Z2luID0gbmFtZSAmJiAhaXNGdW5jICYmIGNvbmZpZy5pbml0ID8gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcHJvcHMgPSBbXTtcbiAgICB9IDogY29uZmlnLFxuICAgICAgICAvL2luIGNhc2Ugc29tZW9uZSBwYXNzZXMgaW4gYW4gb2JqZWN0IHRoYXQncyBub3QgYSBwbHVnaW4sIGxpa2UgQ3VzdG9tRWFzZVxuICAgIGluc3RhbmNlRGVmYXVsdHMgPSB7XG4gICAgICBpbml0OiBfZW1wdHlGdW5jLFxuICAgICAgcmVuZGVyOiBfcmVuZGVyUHJvcFR3ZWVucyxcbiAgICAgIGFkZDogX2FkZFByb3BUd2VlbixcbiAgICAgIGtpbGw6IF9raWxsUHJvcFR3ZWVuc09mLFxuICAgICAgbW9kaWZpZXI6IF9hZGRQbHVnaW5Nb2RpZmllcixcbiAgICAgIHJhd1ZhcnM6IDBcbiAgICB9LFxuICAgICAgICBzdGF0aWNzID0ge1xuICAgICAgdGFyZ2V0VGVzdDogMCxcbiAgICAgIGdldDogMCxcbiAgICAgIGdldFNldHRlcjogX2dldFNldHRlcixcbiAgICAgIGFsaWFzZXM6IHt9LFxuICAgICAgcmVnaXN0ZXI6IDBcbiAgICB9O1xuXG4gICAgX3dha2UoKTtcblxuICAgIGlmIChjb25maWcgIT09IFBsdWdpbikge1xuICAgICAgaWYgKF9wbHVnaW5zW25hbWVdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3NldERlZmF1bHRzKFBsdWdpbiwgX3NldERlZmF1bHRzKF9jb3B5RXhjbHVkaW5nKGNvbmZpZywgaW5zdGFuY2VEZWZhdWx0cyksIHN0YXRpY3MpKTsgLy9zdGF0aWMgbWV0aG9kc1xuXG5cbiAgICAgIF9tZXJnZShQbHVnaW4ucHJvdG90eXBlLCBfbWVyZ2UoaW5zdGFuY2VEZWZhdWx0cywgX2NvcHlFeGNsdWRpbmcoY29uZmlnLCBzdGF0aWNzKSkpOyAvL2luc3RhbmNlIG1ldGhvZHNcblxuXG4gICAgICBfcGx1Z2luc1tQbHVnaW4ucHJvcCA9IG5hbWVdID0gUGx1Z2luO1xuXG4gICAgICBpZiAoY29uZmlnLnRhcmdldFRlc3QpIHtcbiAgICAgICAgX2hhcm5lc3NQbHVnaW5zLnB1c2goUGx1Z2luKTtcblxuICAgICAgICBfcmVzZXJ2ZWRQcm9wc1tuYW1lXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIG5hbWUgPSAobmFtZSA9PT0gXCJjc3NcIiA/IFwiQ1NTXCIgOiBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSkpICsgXCJQbHVnaW5cIjsgLy9mb3IgdGhlIGdsb2JhbCBuYW1lLiBcIm1vdGlvblBhdGhcIiBzaG91bGQgYmVjb21lIE1vdGlvblBhdGhQbHVnaW5cbiAgICB9XG5cbiAgICBfYWRkR2xvYmFsKG5hbWUsIFBsdWdpbik7XG5cbiAgICBjb25maWcucmVnaXN0ZXIgJiYgY29uZmlnLnJlZ2lzdGVyKGdzYXAsIFBsdWdpbiwgUHJvcFR3ZWVuKTtcbiAgfSBlbHNlIHtcbiAgICBfcmVnaXN0ZXJQbHVnaW5RdWV1ZS5wdXNoKGNvbmZpZyk7XG4gIH1cbn0sXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ09MT1JTXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5fMjU1ID0gMjU1LFxuICAgIF9jb2xvckxvb2t1cCA9IHtcbiAgYXF1YTogWzAsIF8yNTUsIF8yNTVdLFxuICBsaW1lOiBbMCwgXzI1NSwgMF0sXG4gIHNpbHZlcjogWzE5MiwgMTkyLCAxOTJdLFxuICBibGFjazogWzAsIDAsIDBdLFxuICBtYXJvb246IFsxMjgsIDAsIDBdLFxuICB0ZWFsOiBbMCwgMTI4LCAxMjhdLFxuICBibHVlOiBbMCwgMCwgXzI1NV0sXG4gIG5hdnk6IFswLCAwLCAxMjhdLFxuICB3aGl0ZTogW18yNTUsIF8yNTUsIF8yNTVdLFxuICBvbGl2ZTogWzEyOCwgMTI4LCAwXSxcbiAgeWVsbG93OiBbXzI1NSwgXzI1NSwgMF0sXG4gIG9yYW5nZTogW18yNTUsIDE2NSwgMF0sXG4gIGdyYXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgcHVycGxlOiBbMTI4LCAwLCAxMjhdLFxuICBncmVlbjogWzAsIDEyOCwgMF0sXG4gIHJlZDogW18yNTUsIDAsIDBdLFxuICBwaW5rOiBbXzI1NSwgMTkyLCAyMDNdLFxuICBjeWFuOiBbMCwgXzI1NSwgXzI1NV0sXG4gIHRyYW5zcGFyZW50OiBbXzI1NSwgXzI1NSwgXzI1NSwgMF1cbn0sXG4gICAgLy8gcG9zc2libGUgZnV0dXJlIGlkZWEgdG8gcmVwbGFjZSB0aGUgaGFyZC1jb2RlZCBjb2xvciBuYW1lIHZhbHVlcyAtIHB1dCB0aGlzIGluIHRoZSB0aWNrZXIud2FrZSgpIHdoZXJlIHdlIHNldCB0aGUgX2RvYzpcbi8vIGxldCBjdHggPSBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpO1xuLy8gX2ZvckVhY2hOYW1lKFwiYXF1YSxsaW1lLHNpbHZlcixibGFjayxtYXJvb24sdGVhbCxibHVlLG5hdnksd2hpdGUsb2xpdmUseWVsbG93LG9yYW5nZSxncmF5LHB1cnBsZSxncmVlbixyZWQscGluayxjeWFuXCIsIGNvbG9yID0+IHtjdHguZmlsbFN0eWxlID0gY29sb3I7IF9jb2xvckxvb2t1cFtjb2xvcl0gPSBzcGxpdENvbG9yKGN0eC5maWxsU3R5bGUpfSk7XG5faHVlID0gZnVuY3Rpb24gX2h1ZShoLCBtMSwgbTIpIHtcbiAgaCArPSBoIDwgMCA/IDEgOiBoID4gMSA/IC0xIDogMDtcbiAgcmV0dXJuIChoICogNiA8IDEgPyBtMSArIChtMiAtIG0xKSAqIGggKiA2IDogaCA8IC41ID8gbTIgOiBoICogMyA8IDIgPyBtMSArIChtMiAtIG0xKSAqICgyIC8gMyAtIGgpICogNiA6IG0xKSAqIF8yNTUgKyAuNSB8IDA7XG59LFxuICAgIHNwbGl0Q29sb3IgPSBmdW5jdGlvbiBzcGxpdENvbG9yKHYsIHRvSFNMLCBmb3JjZUFscGhhKSB7XG4gIHZhciBhID0gIXYgPyBfY29sb3JMb29rdXAuYmxhY2sgOiBfaXNOdW1iZXIodikgPyBbdiA+PiAxNiwgdiA+PiA4ICYgXzI1NSwgdiAmIF8yNTVdIDogMCxcbiAgICAgIHIsXG4gICAgICBnLFxuICAgICAgYixcbiAgICAgIGgsXG4gICAgICBzLFxuICAgICAgbCxcbiAgICAgIG1heCxcbiAgICAgIG1pbixcbiAgICAgIGQsXG4gICAgICB3YXNIU0w7XG5cbiAgaWYgKCFhKSB7XG4gICAgaWYgKHYuc3Vic3RyKC0xKSA9PT0gXCIsXCIpIHtcbiAgICAgIC8vc29tZXRpbWVzIGEgdHJhaWxpbmcgY29tbWEgaXMgaW5jbHVkZWQgYW5kIHdlIHNob3VsZCBjaG9wIGl0IG9mZiAodHlwaWNhbGx5IGZyb20gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiB2YWx1ZXMgbGlrZSBhIHRleHRTaGFkb3c6XCIycHggMnB4IDJweCBibHVlLCA1cHggNXB4IDVweCByZ2IoMjU1LDAsMClcIiAtIGluIHRoaXMgZXhhbXBsZSBcImJsdWUsXCIgaGFzIGEgdHJhaWxpbmcgY29tbWEuIFdlIGNvdWxkIHN0cmlwIGl0IG91dCBpbnNpZGUgcGFyc2VDb21wbGV4KCkgYnV0IHdlJ2QgbmVlZCB0byBkbyBpdCB0byB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIHBsdXMgaXQgd291bGRuJ3QgcHJvdmlkZSBwcm90ZWN0aW9uIGZyb20gb3RoZXIgcG90ZW50aWFsIHNjZW5hcmlvcyBsaWtlIGlmIHRoZSB1c2VyIHBhc3NlcyBpbiBhIHNpbWlsYXIgdmFsdWUuXG4gICAgICB2ID0gdi5zdWJzdHIoMCwgdi5sZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICBpZiAoX2NvbG9yTG9va3VwW3ZdKSB7XG4gICAgICBhID0gX2NvbG9yTG9va3VwW3ZdO1xuICAgIH0gZWxzZSBpZiAodi5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICBpZiAodi5sZW5ndGggPCA2KSB7XG4gICAgICAgIC8vZm9yIHNob3J0aGFuZCBsaWtlICM5RjAgb3IgIzlGMEYgKGNvdWxkIGhhdmUgYWxwaGEpXG4gICAgICAgIHIgPSB2LmNoYXJBdCgxKTtcbiAgICAgICAgZyA9IHYuY2hhckF0KDIpO1xuICAgICAgICBiID0gdi5jaGFyQXQoMyk7XG4gICAgICAgIHYgPSBcIiNcIiArIHIgKyByICsgZyArIGcgKyBiICsgYiArICh2Lmxlbmd0aCA9PT0gNSA/IHYuY2hhckF0KDQpICsgdi5jaGFyQXQoNCkgOiBcIlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHYubGVuZ3RoID09PSA5KSB7XG4gICAgICAgIC8vIGhleCB3aXRoIGFscGhhLCBsaWtlICNmZDVlNTNmZlxuICAgICAgICBhID0gcGFyc2VJbnQodi5zdWJzdHIoMSwgNiksIDE2KTtcbiAgICAgICAgcmV0dXJuIFthID4+IDE2LCBhID4+IDggJiBfMjU1LCBhICYgXzI1NSwgcGFyc2VJbnQodi5zdWJzdHIoNyksIDE2KSAvIDI1NV07XG4gICAgICB9XG5cbiAgICAgIHYgPSBwYXJzZUludCh2LnN1YnN0cigxKSwgMTYpO1xuICAgICAgYSA9IFt2ID4+IDE2LCB2ID4+IDggJiBfMjU1LCB2ICYgXzI1NV07XG4gICAgfSBlbHNlIGlmICh2LnN1YnN0cigwLCAzKSA9PT0gXCJoc2xcIikge1xuICAgICAgYSA9IHdhc0hTTCA9IHYubWF0Y2goX3N0cmljdE51bUV4cCk7XG5cbiAgICAgIGlmICghdG9IU0wpIHtcbiAgICAgICAgaCA9ICthWzBdICUgMzYwIC8gMzYwO1xuICAgICAgICBzID0gK2FbMV0gLyAxMDA7XG4gICAgICAgIGwgPSArYVsyXSAvIDEwMDtcbiAgICAgICAgZyA9IGwgPD0gLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHIgPSBsICogMiAtIGc7XG4gICAgICAgIGEubGVuZ3RoID4gMyAmJiAoYVszXSAqPSAxKTsgLy9jYXN0IGFzIG51bWJlclxuXG4gICAgICAgIGFbMF0gPSBfaHVlKGggKyAxIC8gMywgciwgZyk7XG4gICAgICAgIGFbMV0gPSBfaHVlKGgsIHIsIGcpO1xuICAgICAgICBhWzJdID0gX2h1ZShoIC0gMSAvIDMsIHIsIGcpO1xuICAgICAgfSBlbHNlIGlmICh+di5pbmRleE9mKFwiPVwiKSkge1xuICAgICAgICAvL2lmIHJlbGF0aXZlIHZhbHVlcyBhcmUgZm91bmQsIGp1c3QgcmV0dXJuIHRoZSByYXcgc3RyaW5ncyB3aXRoIHRoZSByZWxhdGl2ZSBwcmVmaXhlcyBpbiBwbGFjZS5cbiAgICAgICAgYSA9IHYubWF0Y2goX251bUV4cCk7XG4gICAgICAgIGZvcmNlQWxwaGEgJiYgYS5sZW5ndGggPCA0ICYmIChhWzNdID0gMSk7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhID0gdi5tYXRjaChfc3RyaWN0TnVtRXhwKSB8fCBfY29sb3JMb29rdXAudHJhbnNwYXJlbnQ7XG4gICAgfVxuXG4gICAgYSA9IGEubWFwKE51bWJlcik7XG4gIH1cblxuICBpZiAodG9IU0wgJiYgIXdhc0hTTCkge1xuICAgIHIgPSBhWzBdIC8gXzI1NTtcbiAgICBnID0gYVsxXSAvIF8yNTU7XG4gICAgYiA9IGFbMl0gLyBfMjU1O1xuICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIGwgPSAobWF4ICsgbWluKSAvIDI7XG5cbiAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgIGggPSBzID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZCA9IG1heCAtIG1pbjtcbiAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICAgIGggPSBtYXggPT09IHIgPyAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKSA6IG1heCA9PT0gZyA/IChiIC0gcikgLyBkICsgMiA6IChyIC0gZykgLyBkICsgNDtcbiAgICAgIGggKj0gNjA7XG4gICAgfVxuXG4gICAgYVswXSA9IH5+KGggKyAuNSk7XG4gICAgYVsxXSA9IH5+KHMgKiAxMDAgKyAuNSk7XG4gICAgYVsyXSA9IH5+KGwgKiAxMDAgKyAuNSk7XG4gIH1cblxuICBmb3JjZUFscGhhICYmIGEubGVuZ3RoIDwgNCAmJiAoYVszXSA9IDEpO1xuICByZXR1cm4gYTtcbn0sXG4gICAgX2NvbG9yT3JkZXJEYXRhID0gZnVuY3Rpb24gX2NvbG9yT3JkZXJEYXRhKHYpIHtcbiAgLy8gc3RyaXBzIG91dCB0aGUgY29sb3JzIGZyb20gdGhlIHN0cmluZywgZmluZHMgYWxsIHRoZSBudW1lcmljIHNsb3RzICh3aXRoIHVuaXRzKSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aG9zZS4gVGhlIEFycmF5IGFsc28gaGFzIGEgXCJjXCIgcHJvcGVydHkgd2hpY2ggaXMgYW4gQXJyYXkgb2YgdGhlIGluZGV4IHZhbHVlcyB3aGVyZSB0aGUgY29sb3JzIGJlbG9uZy4gVGhpcyBpcyB0byBoZWxwIHdvcmsgYXJvdW5kIGlzc3VlcyB3aGVyZSB0aGVyZSdzIGEgbWlzLW1hdGNoZWQgb3JkZXIgb2YgY29sb3IvbnVtZXJpYyBkYXRhIGxpa2UgZHJvcC1zaGFkb3coI2YwMCAwcHggMXB4IDJweCkgYW5kIGRyb3Atc2hhZG93KDB4IDFweCAycHggI2YwMCkuIFRoaXMgaXMgYmFzaWNhbGx5IGEgaGVscGVyIGZ1bmN0aW9uIHVzZWQgaW4gX2Zvcm1hdENvbG9ycygpXG4gIHZhciB2YWx1ZXMgPSBbXSxcbiAgICAgIGMgPSBbXSxcbiAgICAgIGkgPSAtMTtcbiAgdi5zcGxpdChfY29sb3JFeHApLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgYSA9IHYubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcbiAgICB2YWx1ZXMucHVzaC5hcHBseSh2YWx1ZXMsIGEpO1xuICAgIGMucHVzaChpICs9IGEubGVuZ3RoICsgMSk7XG4gIH0pO1xuICB2YWx1ZXMuYyA9IGM7XG4gIHJldHVybiB2YWx1ZXM7XG59LFxuICAgIF9mb3JtYXRDb2xvcnMgPSBmdW5jdGlvbiBfZm9ybWF0Q29sb3JzKHMsIHRvSFNMLCBvcmRlck1hdGNoRGF0YSkge1xuICB2YXIgcmVzdWx0ID0gXCJcIixcbiAgICAgIGNvbG9ycyA9IChzICsgcmVzdWx0KS5tYXRjaChfY29sb3JFeHApLFxuICAgICAgdHlwZSA9IHRvSFNMID8gXCJoc2xhKFwiIDogXCJyZ2JhKFwiLFxuICAgICAgaSA9IDAsXG4gICAgICBjLFxuICAgICAgc2hlbGwsXG4gICAgICBkLFxuICAgICAgbDtcblxuICBpZiAoIWNvbG9ycykge1xuICAgIHJldHVybiBzO1xuICB9XG5cbiAgY29sb3JzID0gY29sb3JzLm1hcChmdW5jdGlvbiAoY29sb3IpIHtcbiAgICByZXR1cm4gKGNvbG9yID0gc3BsaXRDb2xvcihjb2xvciwgdG9IU0wsIDEpKSAmJiB0eXBlICsgKHRvSFNMID8gY29sb3JbMF0gKyBcIixcIiArIGNvbG9yWzFdICsgXCIlLFwiICsgY29sb3JbMl0gKyBcIiUsXCIgKyBjb2xvclszXSA6IGNvbG9yLmpvaW4oXCIsXCIpKSArIFwiKVwiO1xuICB9KTtcblxuICBpZiAob3JkZXJNYXRjaERhdGEpIHtcbiAgICBkID0gX2NvbG9yT3JkZXJEYXRhKHMpO1xuICAgIGMgPSBvcmRlck1hdGNoRGF0YS5jO1xuXG4gICAgaWYgKGMuam9pbihyZXN1bHQpICE9PSBkLmMuam9pbihyZXN1bHQpKSB7XG4gICAgICBzaGVsbCA9IHMucmVwbGFjZShfY29sb3JFeHAsIFwiMVwiKS5zcGxpdChfbnVtV2l0aFVuaXRFeHApO1xuICAgICAgbCA9IHNoZWxsLmxlbmd0aCAtIDE7XG5cbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCArPSBzaGVsbFtpXSArICh+Yy5pbmRleE9mKGkpID8gY29sb3JzLnNoaWZ0KCkgfHwgdHlwZSArIFwiMCwwLDAsMClcIiA6IChkLmxlbmd0aCA/IGQgOiBjb2xvcnMubGVuZ3RoID8gY29sb3JzIDogb3JkZXJNYXRjaERhdGEpLnNoaWZ0KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghc2hlbGwpIHtcbiAgICBzaGVsbCA9IHMuc3BsaXQoX2NvbG9yRXhwKTtcbiAgICBsID0gc2hlbGwubGVuZ3RoIC0gMTtcblxuICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXN1bHQgKz0gc2hlbGxbaV0gKyBjb2xvcnNbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdCArIHNoZWxsW2xdO1xufSxcbiAgICBfY29sb3JFeHAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzID0gXCIoPzpcXFxcYig/Oig/OnJnYnxyZ2JhfGhzbHxoc2xhKVxcXFwoLis/XFxcXCkpfFxcXFxCIyg/OlswLTlhLWZdezMsNH0pezEsMn1cXFxcYlwiLFxuICAgICAgLy93ZSdsbCBkeW5hbWljYWxseSBidWlsZCB0aGlzIFJlZ3VsYXIgRXhwcmVzc2lvbiB0byBjb25zZXJ2ZSBmaWxlIHNpemUuIEFmdGVyIGJ1aWxkaW5nIGl0LCBpdCB3aWxsIGJlIGFibGUgdG8gZmluZCByZ2IoKSwgcmdiYSgpLCAjIChoZXhhZGVjaW1hbCksIGFuZCBuYW1lZCBjb2xvciB2YWx1ZXMgbGlrZSByZWQsIGJsdWUsIHB1cnBsZSwgZXRjLixcbiAgcDtcblxuICBmb3IgKHAgaW4gX2NvbG9yTG9va3VwKSB7XG4gICAgcyArPSBcInxcIiArIHAgKyBcIlxcXFxiXCI7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlZ0V4cChzICsgXCIpXCIsIFwiZ2lcIik7XG59KCksXG4gICAgX2hzbEV4cCA9IC9oc2xbYV0/XFwoLyxcbiAgICBfY29sb3JTdHJpbmdGaWx0ZXIgPSBmdW5jdGlvbiBfY29sb3JTdHJpbmdGaWx0ZXIoYSkge1xuICB2YXIgY29tYmluZWQgPSBhLmpvaW4oXCIgXCIpLFxuICAgICAgdG9IU0w7XG4gIF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xuXG4gIGlmIChfY29sb3JFeHAudGVzdChjb21iaW5lZCkpIHtcbiAgICB0b0hTTCA9IF9oc2xFeHAudGVzdChjb21iaW5lZCk7XG4gICAgYVsxXSA9IF9mb3JtYXRDb2xvcnMoYVsxXSwgdG9IU0wpO1xuICAgIGFbMF0gPSBfZm9ybWF0Q29sb3JzKGFbMF0sIHRvSFNMLCBfY29sb3JPcmRlckRhdGEoYVsxXSkpOyAvLyBtYWtlIHN1cmUgdGhlIG9yZGVyIG9mIG51bWJlcnMvY29sb3JzIG1hdGNoIHdpdGggdGhlIEVORCB2YWx1ZS5cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59LFxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRJQ0tFUlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuX3RpY2tlckFjdGl2ZSxcbiAgICBfdGlja2VyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX2dldFRpbWUgPSBEYXRlLm5vdyxcbiAgICAgIF9sYWdUaHJlc2hvbGQgPSA1MDAsXG4gICAgICBfYWRqdXN0ZWRMYWcgPSAzMyxcbiAgICAgIF9zdGFydFRpbWUgPSBfZ2V0VGltZSgpLFxuICAgICAgX2xhc3RVcGRhdGUgPSBfc3RhcnRUaW1lLFxuICAgICAgX2dhcCA9IDEwMDAgLyAyNDAsXG4gICAgICBfbmV4dFRpbWUgPSBfZ2FwLFxuICAgICAgX2xpc3RlbmVycyA9IFtdLFxuICAgICAgX2lkLFxuICAgICAgX3JlcSxcbiAgICAgIF9yYWYsXG4gICAgICBfc2VsZixcbiAgICAgIF9kZWx0YSxcbiAgICAgIF9pLFxuICAgICAgX3RpY2sgPSBmdW5jdGlvbiBfdGljayh2KSB7XG4gICAgdmFyIGVsYXBzZWQgPSBfZ2V0VGltZSgpIC0gX2xhc3RVcGRhdGUsXG4gICAgICAgIG1hbnVhbCA9IHYgPT09IHRydWUsXG4gICAgICAgIG92ZXJsYXAsXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICB0aW1lLFxuICAgICAgICBmcmFtZTtcblxuICAgIChlbGFwc2VkID4gX2xhZ1RocmVzaG9sZCB8fCBlbGFwc2VkIDwgMCkgJiYgKF9zdGFydFRpbWUgKz0gZWxhcHNlZCAtIF9hZGp1c3RlZExhZyk7XG4gICAgX2xhc3RVcGRhdGUgKz0gZWxhcHNlZDtcbiAgICB0aW1lID0gX2xhc3RVcGRhdGUgLSBfc3RhcnRUaW1lO1xuICAgIG92ZXJsYXAgPSB0aW1lIC0gX25leHRUaW1lO1xuXG4gICAgaWYgKG92ZXJsYXAgPiAwIHx8IG1hbnVhbCkge1xuICAgICAgZnJhbWUgPSArK19zZWxmLmZyYW1lO1xuICAgICAgX2RlbHRhID0gdGltZSAtIF9zZWxmLnRpbWUgKiAxMDAwO1xuICAgICAgX3NlbGYudGltZSA9IHRpbWUgPSB0aW1lIC8gMTAwMDtcbiAgICAgIF9uZXh0VGltZSArPSBvdmVybGFwICsgKG92ZXJsYXAgPj0gX2dhcCA/IDQgOiBfZ2FwIC0gb3ZlcmxhcCk7XG4gICAgICBkaXNwYXRjaCA9IDE7XG4gICAgfVxuXG4gICAgbWFudWFsIHx8IChfaWQgPSBfcmVxKF90aWNrKSk7IC8vbWFrZSBzdXJlIHRoZSByZXF1ZXN0IGlzIG1hZGUgYmVmb3JlIHdlIGRpc3BhdGNoIHRoZSBcInRpY2tcIiBldmVudCBzbyB0aGF0IHRpbWluZyBpcyBtYWludGFpbmVkLiBPdGhlcndpc2UsIGlmIHByb2Nlc3NpbmcgdGhlIFwidGlja1wiIHJlcXVpcmVzIGEgYnVuY2ggb2YgdGltZSAobGlrZSAxNW1zKSBhbmQgd2UncmUgdXNpbmcgYSBzZXRUaW1lb3V0KCkgdGhhdCdzIGJhc2VkIG9uIDE2LjdtcywgaXQnZCB0ZWNobmljYWxseSB0YWtlIDMxLjdtcyBiZXR3ZWVuIGZyYW1lcyBvdGhlcndpc2UuXG5cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGZvciAoX2kgPSAwOyBfaSA8IF9saXN0ZW5lcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIC8vIHVzZSBfaSBhbmQgY2hlY2sgX2xpc3RlbmVycy5sZW5ndGggaW5zdGVhZCBvZiBhIHZhcmlhYmxlIGJlY2F1c2UgYSBsaXN0ZW5lciBjb3VsZCBnZXQgcmVtb3ZlZCBkdXJpbmcgdGhlIGxvb3AsIGFuZCBpZiB0aGF0IGhhcHBlbnMgdG8gYW4gZWxlbWVudCBsZXNzIHRoYW4gdGhlIGN1cnJlbnQgaW5kZXgsIGl0J2QgdGhyb3cgdGhpbmdzIG9mZiBpbiB0aGUgbG9vcC5cbiAgICAgICAgX2xpc3RlbmVyc1tfaV0odGltZSwgX2RlbHRhLCBmcmFtZSwgdik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9zZWxmID0ge1xuICAgIHRpbWU6IDAsXG4gICAgZnJhbWU6IDAsXG4gICAgdGljazogZnVuY3Rpb24gdGljaygpIHtcbiAgICAgIF90aWNrKHRydWUpO1xuICAgIH0sXG4gICAgZGVsdGFSYXRpbzogZnVuY3Rpb24gZGVsdGFSYXRpbyhmcHMpIHtcbiAgICAgIHJldHVybiBfZGVsdGEgLyAoMTAwMCAvIChmcHMgfHwgNjApKTtcbiAgICB9LFxuICAgIHdha2U6IGZ1bmN0aW9uIHdha2UoKSB7XG4gICAgICBpZiAoX2NvcmVSZWFkeSkge1xuICAgICAgICBpZiAoIV9jb3JlSW5pdHRlZCAmJiBfd2luZG93RXhpc3RzKCkpIHtcbiAgICAgICAgICBfd2luID0gX2NvcmVJbml0dGVkID0gd2luZG93O1xuICAgICAgICAgIF9kb2MgPSBfd2luLmRvY3VtZW50IHx8IHt9O1xuICAgICAgICAgIF9nbG9iYWxzLmdzYXAgPSBnc2FwO1xuICAgICAgICAgIChfd2luLmdzYXBWZXJzaW9ucyB8fCAoX3dpbi5nc2FwVmVyc2lvbnMgPSBbXSkpLnB1c2goZ3NhcC52ZXJzaW9uKTtcblxuICAgICAgICAgIF9pbnN0YWxsKF9pbnN0YWxsU2NvcGUgfHwgX3dpbi5HcmVlblNvY2tHbG9iYWxzIHx8ICFfd2luLmdzYXAgJiYgX3dpbiB8fCB7fSk7XG5cbiAgICAgICAgICBfcmVnaXN0ZXJQbHVnaW5RdWV1ZS5mb3JFYWNoKF9jcmVhdGVQbHVnaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgX3JhZiA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgICAgICBfaWQgJiYgX3NlbGYuc2xlZXAoKTtcblxuICAgICAgICBfcmVxID0gX3JhZiB8fCBmdW5jdGlvbiAoZikge1xuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGYsIF9uZXh0VGltZSAtIF9zZWxmLnRpbWUgKiAxMDAwICsgMSB8IDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aWNrZXJBY3RpdmUgPSAxO1xuXG4gICAgICAgIF90aWNrKDIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2xlZXA6IGZ1bmN0aW9uIHNsZWVwKCkge1xuICAgICAgKF9yYWYgPyBjYW5jZWxBbmltYXRpb25GcmFtZSA6IGNsZWFyVGltZW91dCkoX2lkKTtcbiAgICAgIF90aWNrZXJBY3RpdmUgPSAwO1xuICAgICAgX3JlcSA9IF9lbXB0eUZ1bmM7XG4gICAgfSxcbiAgICBsYWdTbW9vdGhpbmc6IGZ1bmN0aW9uIGxhZ1Ntb290aGluZyh0aHJlc2hvbGQsIGFkanVzdGVkTGFnKSB7XG4gICAgICBfbGFnVGhyZXNob2xkID0gdGhyZXNob2xkIHx8IEluZmluaXR5OyAvLyB6ZXJvIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBiYXNpY2FsbHkgdW5saW1pdGVkXG5cbiAgICAgIF9hZGp1c3RlZExhZyA9IE1hdGgubWluKGFkanVzdGVkTGFnIHx8IDMzLCBfbGFnVGhyZXNob2xkKTtcbiAgICB9LFxuICAgIGZwczogZnVuY3Rpb24gZnBzKF9mcHMpIHtcbiAgICAgIF9nYXAgPSAxMDAwIC8gKF9mcHMgfHwgMjQwKTtcbiAgICAgIF9uZXh0VGltZSA9IF9zZWxmLnRpbWUgKiAxMDAwICsgX2dhcDtcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24gYWRkKGNhbGxiYWNrLCBvbmNlLCBwcmlvcml0aXplKSB7XG4gICAgICB2YXIgZnVuYyA9IG9uY2UgPyBmdW5jdGlvbiAodCwgZCwgZiwgdikge1xuICAgICAgICBjYWxsYmFjayh0LCBkLCBmLCB2KTtcblxuICAgICAgICBfc2VsZi5yZW1vdmUoZnVuYyk7XG4gICAgICB9IDogY2FsbGJhY2s7XG5cbiAgICAgIF9zZWxmLnJlbW92ZShjYWxsYmFjayk7XG5cbiAgICAgIF9saXN0ZW5lcnNbcHJpb3JpdGl6ZSA/IFwidW5zaGlmdFwiIDogXCJwdXNoXCJdKGZ1bmMpO1xuXG4gICAgICBfd2FrZSgpO1xuXG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGNhbGxiYWNrLCBpKSB7XG4gICAgICB+KGkgPSBfbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spKSAmJiBfbGlzdGVuZXJzLnNwbGljZShpLCAxKSAmJiBfaSA+PSBpICYmIF9pLS07XG4gICAgfSxcbiAgICBfbGlzdGVuZXJzOiBfbGlzdGVuZXJzXG4gIH07XG4gIHJldHVybiBfc2VsZjtcbn0oKSxcbiAgICBfd2FrZSA9IGZ1bmN0aW9uIF93YWtlKCkge1xuICByZXR1cm4gIV90aWNrZXJBY3RpdmUgJiYgX3RpY2tlci53YWtlKCk7XG59LFxuICAgIC8vYWxzbyBlbnN1cmVzIHRoZSBjb3JlIGNsYXNzZXMgYXJlIGluaXRpYWxpemVkLlxuXG4vKlxuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIEVBU0lOR1xuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qL1xuX2Vhc2VNYXAgPSB7fSxcbiAgICBfY3VzdG9tRWFzZUV4cCA9IC9eW1xcZC5cXC1NXVtcXGQuXFwtLFxcc10vLFxuICAgIF9xdW90ZXNFeHAgPSAvW1wiJ10vZyxcbiAgICBfcGFyc2VPYmplY3RJblN0cmluZyA9IGZ1bmN0aW9uIF9wYXJzZU9iamVjdEluU3RyaW5nKHZhbHVlKSB7XG4gIC8vdGFrZXMgYSBzdHJpbmcgbGlrZSBcInt3aWdnbGVzOjEwLCB0eXBlOmFudGljaXBhdGV9KVwiIGFuZCB0dXJucyBpdCBpbnRvIGEgcmVhbCBvYmplY3QuIE5vdGljZSBpdCBlbmRzIGluIFwiKVwiIGFuZCBpbmNsdWRlcyB0aGUge30gd3JhcHBlcnMuIFRoaXMgaXMgYmVjYXVzZSB3ZSBvbmx5IHVzZSB0aGlzIGZ1bmN0aW9uIGZvciBwYXJzaW5nIGVhc2UgY29uZmlncyBhbmQgcHJpb3JpdGl6ZWQgb3B0aW1pemF0aW9uIHJhdGhlciB0aGFuIHJldXNhYmlsaXR5LlxuICB2YXIgb2JqID0ge30sXG4gICAgICBzcGxpdCA9IHZhbHVlLnN1YnN0cigxLCB2YWx1ZS5sZW5ndGggLSAzKS5zcGxpdChcIjpcIiksXG4gICAgICBrZXkgPSBzcGxpdFswXSxcbiAgICAgIGkgPSAxLFxuICAgICAgbCA9IHNwbGl0Lmxlbmd0aCxcbiAgICAgIGluZGV4LFxuICAgICAgdmFsLFxuICAgICAgcGFyc2VkVmFsO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFsID0gc3BsaXRbaV07XG4gICAgaW5kZXggPSBpICE9PSBsIC0gMSA/IHZhbC5sYXN0SW5kZXhPZihcIixcIikgOiB2YWwubGVuZ3RoO1xuICAgIHBhcnNlZFZhbCA9IHZhbC5zdWJzdHIoMCwgaW5kZXgpO1xuICAgIG9ialtrZXldID0gaXNOYU4ocGFyc2VkVmFsKSA/IHBhcnNlZFZhbC5yZXBsYWNlKF9xdW90ZXNFeHAsIFwiXCIpLnRyaW0oKSA6ICtwYXJzZWRWYWw7XG4gICAga2V5ID0gdmFsLnN1YnN0cihpbmRleCArIDEpLnRyaW0oKTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59LFxuICAgIF92YWx1ZUluUGFyZW50aGVzZXMgPSBmdW5jdGlvbiBfdmFsdWVJblBhcmVudGhlc2VzKHZhbHVlKSB7XG4gIHZhciBvcGVuID0gdmFsdWUuaW5kZXhPZihcIihcIikgKyAxLFxuICAgICAgY2xvc2UgPSB2YWx1ZS5pbmRleE9mKFwiKVwiKSxcbiAgICAgIG5lc3RlZCA9IHZhbHVlLmluZGV4T2YoXCIoXCIsIG9wZW4pO1xuICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKG9wZW4sIH5uZXN0ZWQgJiYgbmVzdGVkIDwgY2xvc2UgPyB2YWx1ZS5pbmRleE9mKFwiKVwiLCBjbG9zZSArIDEpIDogY2xvc2UpO1xufSxcbiAgICBfY29uZmlnRWFzZUZyb21TdHJpbmcgPSBmdW5jdGlvbiBfY29uZmlnRWFzZUZyb21TdHJpbmcobmFtZSkge1xuICAvL25hbWUgY2FuIGJlIGEgc3RyaW5nIGxpa2UgXCJlbGFzdGljLm91dCgxLDAuNSlcIiwgYW5kIHBhc3MgaW4gX2Vhc2VNYXAgYXMgb2JqIGFuZCBpdCdsbCBwYXJzZSBpdCBvdXQgYW5kIGNhbGwgdGhlIGFjdHVhbCBmdW5jdGlvbiBsaWtlIF9lYXNlTWFwLkVsYXN0aWMuZWFzZU91dC5jb25maWcoMSwwLjUpLiBJdCB3aWxsIGFsc28gcGFyc2UgY3VzdG9tIGVhc2Ugc3RyaW5ncyBhcyBsb25nIGFzIEN1c3RvbUVhc2UgaXMgbG9hZGVkIGFuZCByZWdpc3RlcmVkIChpbnRlcm5hbGx5IGFzIF9lYXNlTWFwLl9DRSkuXG4gIHZhciBzcGxpdCA9IChuYW1lICsgXCJcIikuc3BsaXQoXCIoXCIpLFxuICAgICAgZWFzZSA9IF9lYXNlTWFwW3NwbGl0WzBdXTtcbiAgcmV0dXJuIGVhc2UgJiYgc3BsaXQubGVuZ3RoID4gMSAmJiBlYXNlLmNvbmZpZyA/IGVhc2UuY29uZmlnLmFwcGx5KG51bGwsIH5uYW1lLmluZGV4T2YoXCJ7XCIpID8gW19wYXJzZU9iamVjdEluU3RyaW5nKHNwbGl0WzFdKV0gOiBfdmFsdWVJblBhcmVudGhlc2VzKG5hbWUpLnNwbGl0KFwiLFwiKS5tYXAoX251bWVyaWNJZlBvc3NpYmxlKSkgOiBfZWFzZU1hcC5fQ0UgJiYgX2N1c3RvbUVhc2VFeHAudGVzdChuYW1lKSA/IF9lYXNlTWFwLl9DRShcIlwiLCBuYW1lKSA6IGVhc2U7XG59LFxuICAgIF9pbnZlcnRFYXNlID0gZnVuY3Rpb24gX2ludmVydEVhc2UoZWFzZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2UoMSAtIHApO1xuICB9O1xufSxcbiAgICAvLyBhbGxvdyB5b3lvRWFzZSB0byBiZSBzZXQgaW4gY2hpbGRyZW4gYW5kIGhhdmUgdGhvc2UgYWZmZWN0ZWQgd2hlbiB0aGUgcGFyZW50L2FuY2VzdG9yIHRpbWVsaW5lIHlveW9zLlxuX3Byb3BhZ2F0ZVlveW9FYXNlID0gZnVuY3Rpb24gX3Byb3BhZ2F0ZVlveW9FYXNlKHRpbWVsaW5lLCBpc1lveW8pIHtcbiAgdmFyIGNoaWxkID0gdGltZWxpbmUuX2ZpcnN0LFxuICAgICAgZWFzZTtcblxuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUaW1lbGluZSkge1xuICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLCBpc1lveW8pO1xuICAgIH0gZWxzZSBpZiAoY2hpbGQudmFycy55b3lvRWFzZSAmJiAoIWNoaWxkLl95b3lvIHx8ICFjaGlsZC5fcmVwZWF0KSAmJiBjaGlsZC5feW95byAhPT0gaXNZb3lvKSB7XG4gICAgICBpZiAoY2hpbGQudGltZWxpbmUpIHtcbiAgICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLnRpbWVsaW5lLCBpc1lveW8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWFzZSA9IGNoaWxkLl9lYXNlO1xuICAgICAgICBjaGlsZC5fZWFzZSA9IGNoaWxkLl95RWFzZTtcbiAgICAgICAgY2hpbGQuX3lFYXNlID0gZWFzZTtcbiAgICAgICAgY2hpbGQuX3lveW8gPSBpc1lveW87XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgfVxufSxcbiAgICBfcGFyc2VFYXNlID0gZnVuY3Rpb24gX3BhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkge1xuICByZXR1cm4gIWVhc2UgPyBkZWZhdWx0RWFzZSA6IChfaXNGdW5jdGlvbihlYXNlKSA/IGVhc2UgOiBfZWFzZU1hcFtlYXNlXSB8fCBfY29uZmlnRWFzZUZyb21TdHJpbmcoZWFzZSkpIHx8IGRlZmF1bHRFYXNlO1xufSxcbiAgICBfaW5zZXJ0RWFzZSA9IGZ1bmN0aW9uIF9pbnNlcnRFYXNlKG5hbWVzLCBlYXNlSW4sIGVhc2VPdXQsIGVhc2VJbk91dCkge1xuICBpZiAoZWFzZU91dCA9PT0gdm9pZCAwKSB7XG4gICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgICAgcmV0dXJuIDEgLSBlYXNlSW4oMSAtIHApO1xuICAgIH07XG4gIH1cblxuICBpZiAoZWFzZUluT3V0ID09PSB2b2lkIDApIHtcbiAgICBlYXNlSW5PdXQgPSBmdW5jdGlvbiBlYXNlSW5PdXQocCkge1xuICAgICAgcmV0dXJuIHAgPCAuNSA/IGVhc2VJbihwICogMikgLyAyIDogMSAtIGVhc2VJbigoMSAtIHApICogMikgLyAyO1xuICAgIH07XG4gIH1cblxuICB2YXIgZWFzZSA9IHtcbiAgICBlYXNlSW46IGVhc2VJbixcbiAgICBlYXNlT3V0OiBlYXNlT3V0LFxuICAgIGVhc2VJbk91dDogZWFzZUluT3V0XG4gIH0sXG4gICAgICBsb3dlcmNhc2VOYW1lO1xuXG4gIF9mb3JFYWNoTmFtZShuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBfZWFzZU1hcFtuYW1lXSA9IF9nbG9iYWxzW25hbWVdID0gZWFzZTtcbiAgICBfZWFzZU1hcFtsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXSA9IGVhc2VPdXQ7XG5cbiAgICBmb3IgKHZhciBwIGluIGVhc2UpIHtcbiAgICAgIF9lYXNlTWFwW2xvd2VyY2FzZU5hbWUgKyAocCA9PT0gXCJlYXNlSW5cIiA/IFwiLmluXCIgOiBwID09PSBcImVhc2VPdXRcIiA/IFwiLm91dFwiIDogXCIuaW5PdXRcIildID0gX2Vhc2VNYXBbbmFtZSArIFwiLlwiICsgcF0gPSBlYXNlW3BdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVhc2U7XG59LFxuICAgIF9lYXNlSW5PdXRGcm9tT3V0ID0gZnVuY3Rpb24gX2Vhc2VJbk91dEZyb21PdXQoZWFzZU91dCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcCA8IC41ID8gKDEgLSBlYXNlT3V0KDEgLSBwICogMikpIC8gMiA6IC41ICsgZWFzZU91dCgocCAtIC41KSAqIDIpIC8gMjtcbiAgfTtcbn0sXG4gICAgX2NvbmZpZ0VsYXN0aWMgPSBmdW5jdGlvbiBfY29uZmlnRWxhc3RpYyh0eXBlLCBhbXBsaXR1ZGUsIHBlcmlvZCkge1xuICB2YXIgcDEgPSBhbXBsaXR1ZGUgPj0gMSA/IGFtcGxpdHVkZSA6IDEsXG4gICAgICAvL25vdGU6IGlmIGFtcGxpdHVkZSBpcyA8IDEsIHdlIHNpbXBseSBhZGp1c3QgdGhlIHBlcmlvZCBmb3IgYSBtb3JlIG5hdHVyYWwgZmVlbC4gT3RoZXJ3aXNlIHRoZSBtYXRoIGRvZXNuJ3Qgd29yayByaWdodCBhbmQgdGhlIGN1cnZlIHN0YXJ0cyBhdCAxLlxuICBwMiA9IChwZXJpb2QgfHwgKHR5cGUgPyAuMyA6IC40NSkpIC8gKGFtcGxpdHVkZSA8IDEgPyBhbXBsaXR1ZGUgOiAxKSxcbiAgICAgIHAzID0gcDIgLyBfMlBJICogKE1hdGguYXNpbigxIC8gcDEpIHx8IDApLFxuICAgICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgIHJldHVybiBwID09PSAxID8gMSA6IHAxICogTWF0aC5wb3coMiwgLTEwICogcCkgKiBfc2luKChwIC0gcDMpICogcDIpICsgMTtcbiAgfSxcbiAgICAgIGVhc2UgPSB0eXBlID09PSBcIm91dFwiID8gZWFzZU91dCA6IHR5cGUgPT09IFwiaW5cIiA/IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIDEgLSBlYXNlT3V0KDEgLSBwKTtcbiAgfSA6IF9lYXNlSW5PdXRGcm9tT3V0KGVhc2VPdXQpO1xuXG4gIHAyID0gXzJQSSAvIHAyOyAvL3ByZWNhbGN1bGF0ZSB0byBvcHRpbWl6ZVxuXG4gIGVhc2UuY29uZmlnID0gZnVuY3Rpb24gKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gICAgcmV0dXJuIF9jb25maWdFbGFzdGljKHR5cGUsIGFtcGxpdHVkZSwgcGVyaW9kKTtcbiAgfTtcblxuICByZXR1cm4gZWFzZTtcbn0sXG4gICAgX2NvbmZpZ0JhY2sgPSBmdW5jdGlvbiBfY29uZmlnQmFjayh0eXBlLCBvdmVyc2hvb3QpIHtcbiAgaWYgKG92ZXJzaG9vdCA9PT0gdm9pZCAwKSB7XG4gICAgb3ZlcnNob290ID0gMS43MDE1ODtcbiAgfVxuXG4gIHZhciBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgcmV0dXJuIHAgPyAtLXAgKiBwICogKChvdmVyc2hvb3QgKyAxKSAqIHAgKyBvdmVyc2hvb3QpICsgMSA6IDA7XG4gIH0sXG4gICAgICBlYXNlID0gdHlwZSA9PT0gXCJvdXRcIiA/IGVhc2VPdXQgOiB0eXBlID09PSBcImluXCIgPyBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gZWFzZU91dCgxIC0gcCk7XG4gIH0gOiBfZWFzZUluT3V0RnJvbU91dChlYXNlT3V0KTtcblxuICBlYXNlLmNvbmZpZyA9IGZ1bmN0aW9uIChvdmVyc2hvb3QpIHtcbiAgICByZXR1cm4gX2NvbmZpZ0JhY2sodHlwZSwgb3ZlcnNob290KTtcbiAgfTtcblxuICByZXR1cm4gZWFzZTtcbn07IC8vIGEgY2hlYXBlciAoa2IgYW5kIGNwdSkgYnV0IG1vcmUgbWlsZCB3YXkgdG8gZ2V0IGEgcGFyYW1ldGVyaXplZCB3ZWlnaHRlZCBlYXNlIGJ5IGZlZWRpbmcgaW4gYSB2YWx1ZSBiZXR3ZWVuIC0xIChlYXNlSW4pIGFuZCAxIChlYXNlT3V0KSB3aGVyZSAwIGlzIGxpbmVhci5cbi8vIF93ZWlnaHRlZEVhc2UgPSByYXRpbyA9PiB7XG4vLyBcdGxldCB5ID0gMC41ICsgcmF0aW8gLyAyO1xuLy8gXHRyZXR1cm4gcCA9PiAoMiAqICgxIC0gcCkgKiBwICogeSArIHAgKiBwKTtcbi8vIH0sXG4vLyBhIHN0cm9uZ2VyIChidXQgbW9yZSBleHBlbnNpdmUga2IvY3B1KSBwYXJhbWV0ZXJpemVkIHdlaWdodGVkIGVhc2UgdGhhdCBsZXRzIHlvdSBmZWVkIGluIGEgdmFsdWUgYmV0d2VlbiAtMSAoZWFzZUluKSBhbmQgMSAoZWFzZU91dCkgd2hlcmUgMCBpcyBsaW5lYXIuXG4vLyBfd2VpZ2h0ZWRFYXNlU3Ryb25nID0gcmF0aW8gPT4ge1xuLy8gXHRyYXRpbyA9IC41ICsgcmF0aW8gLyAyO1xuLy8gXHRsZXQgbyA9IDEgLyAzICogKHJhdGlvIDwgLjUgPyByYXRpbyA6IDEgLSByYXRpbyksXG4vLyBcdFx0YiA9IHJhdGlvIC0gbyxcbi8vIFx0XHRjID0gcmF0aW8gKyBvO1xuLy8gXHRyZXR1cm4gcCA9PiBwID09PSAxID8gcCA6IDMgKiBiICogKDEgLSBwKSAqICgxIC0gcCkgKiBwICsgMyAqIGMgKiAoMSAtIHApICogcCAqIHAgKyBwICogcCAqIHA7XG4vLyB9O1xuXG5cbl9mb3JFYWNoTmFtZShcIkxpbmVhcixRdWFkLEN1YmljLFF1YXJ0LFF1aW50LFN0cm9uZ1wiLCBmdW5jdGlvbiAobmFtZSwgaSkge1xuICB2YXIgcG93ZXIgPSBpIDwgNSA/IGkgKyAxIDogaTtcblxuICBfaW5zZXJ0RWFzZShuYW1lICsgXCIsUG93ZXJcIiArIChwb3dlciAtIDEpLCBpID8gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gTWF0aC5wb3cocCwgcG93ZXIpO1xuICB9IDogZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcDtcbiAgfSwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIE1hdGgucG93KDEgLSBwLCBwb3dlcik7XG4gIH0sIGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAgPCAuNSA/IE1hdGgucG93KHAgKiAyLCBwb3dlcikgLyAyIDogMSAtIE1hdGgucG93KCgxIC0gcCkgKiAyLCBwb3dlcikgLyAyO1xuICB9KTtcbn0pO1xuXG5fZWFzZU1hcC5MaW5lYXIuZWFzZU5vbmUgPSBfZWFzZU1hcC5ub25lID0gX2Vhc2VNYXAuTGluZWFyLmVhc2VJbjtcblxuX2luc2VydEVhc2UoXCJFbGFzdGljXCIsIF9jb25maWdFbGFzdGljKFwiaW5cIiksIF9jb25maWdFbGFzdGljKFwib3V0XCIpLCBfY29uZmlnRWxhc3RpYygpKTtcblxuKGZ1bmN0aW9uIChuLCBjKSB7XG4gIHZhciBuMSA9IDEgLyBjLFxuICAgICAgbjIgPSAyICogbjEsXG4gICAgICBuMyA9IDIuNSAqIG4xLFxuICAgICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgIHJldHVybiBwIDwgbjEgPyBuICogcCAqIHAgOiBwIDwgbjIgPyBuICogTWF0aC5wb3cocCAtIDEuNSAvIGMsIDIpICsgLjc1IDogcCA8IG4zID8gbiAqIChwIC09IDIuMjUgLyBjKSAqIHAgKyAuOTM3NSA6IG4gKiBNYXRoLnBvdyhwIC0gMi42MjUgLyBjLCAyKSArIC45ODQzNzU7XG4gIH07XG5cbiAgX2luc2VydEVhc2UoXCJCb3VuY2VcIiwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2VPdXQoMSAtIHApO1xuICB9LCBlYXNlT3V0KTtcbn0pKDcuNTYyNSwgMi43NSk7XG5cbl9pbnNlcnRFYXNlKFwiRXhwb1wiLCBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gcCA/IE1hdGgucG93KDIsIDEwICogKHAgLSAxKSkgOiAwO1xufSk7XG5cbl9pbnNlcnRFYXNlKFwiQ2lyY1wiLCBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gLShfc3FydCgxIC0gcCAqIHApIC0gMSk7XG59KTtcblxuX2luc2VydEVhc2UoXCJTaW5lXCIsIGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBwID09PSAxID8gMSA6IC1fY29zKHAgKiBfSEFMRl9QSSkgKyAxO1xufSk7XG5cbl9pbnNlcnRFYXNlKFwiQmFja1wiLCBfY29uZmlnQmFjayhcImluXCIpLCBfY29uZmlnQmFjayhcIm91dFwiKSwgX2NvbmZpZ0JhY2soKSk7XG5cbl9lYXNlTWFwLlN0ZXBwZWRFYXNlID0gX2Vhc2VNYXAuc3RlcHMgPSBfZ2xvYmFscy5TdGVwcGVkRWFzZSA9IHtcbiAgY29uZmlnOiBmdW5jdGlvbiBjb25maWcoc3RlcHMsIGltbWVkaWF0ZVN0YXJ0KSB7XG4gICAgaWYgKHN0ZXBzID09PSB2b2lkIDApIHtcbiAgICAgIHN0ZXBzID0gMTtcbiAgICB9XG5cbiAgICB2YXIgcDEgPSAxIC8gc3RlcHMsXG4gICAgICAgIHAyID0gc3RlcHMgKyAoaW1tZWRpYXRlU3RhcnQgPyAwIDogMSksXG4gICAgICAgIHAzID0gaW1tZWRpYXRlU3RhcnQgPyAxIDogMCxcbiAgICAgICAgbWF4ID0gMSAtIF90aW55TnVtO1xuICAgIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuICgocDIgKiBfY2xhbXAoMCwgbWF4LCBwKSB8IDApICsgcDMpICogcDE7XG4gICAgfTtcbiAgfVxufTtcbl9kZWZhdWx0cy5lYXNlID0gX2Vhc2VNYXBbXCJxdWFkLm91dFwiXTtcblxuX2ZvckVhY2hOYW1lKFwib25Db21wbGV0ZSxvblVwZGF0ZSxvblN0YXJ0LG9uUmVwZWF0LG9uUmV2ZXJzZUNvbXBsZXRlLG9uSW50ZXJydXB0XCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfY2FsbGJhY2tOYW1lcyArPSBuYW1lICsgXCIsXCIgKyBuYW1lICsgXCJQYXJhbXMsXCI7XG59KTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ0FDSEVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5leHBvcnQgdmFyIEdTQ2FjaGUgPSBmdW5jdGlvbiBHU0NhY2hlKHRhcmdldCwgaGFybmVzcykge1xuICB0aGlzLmlkID0gX2dzSUQrKztcbiAgdGFyZ2V0Ll9nc2FwID0gdGhpcztcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIHRoaXMuaGFybmVzcyA9IGhhcm5lc3M7XG4gIHRoaXMuZ2V0ID0gaGFybmVzcyA/IGhhcm5lc3MuZ2V0IDogX2dldFByb3BlcnR5O1xuICB0aGlzLnNldCA9IGhhcm5lc3MgPyBoYXJuZXNzLmdldFNldHRlciA6IF9nZXRTZXR0ZXI7XG59O1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBBTklNQVRJT05cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuZXhwb3J0IHZhciBBbmltYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBbmltYXRpb24odmFycykge1xuICAgIHRoaXMudmFycyA9IHZhcnM7XG4gICAgdGhpcy5fZGVsYXkgPSArdmFycy5kZWxheSB8fCAwO1xuXG4gICAgaWYgKHRoaXMuX3JlcGVhdCA9IHZhcnMucmVwZWF0ID09PSBJbmZpbml0eSA/IC0yIDogdmFycy5yZXBlYXQgfHwgMCkge1xuICAgICAgLy8gVE9ETzogcmVwZWF0OiBJbmZpbml0eSBvbiBhIHRpbWVsaW5lJ3MgY2hpbGRyZW4gbXVzdCBmbGFnIHRoYXQgdGltZWxpbmUgaW50ZXJuYWxseSBhbmQgYWZmZWN0IGl0cyB0b3RhbER1cmF0aW9uLCBvdGhlcndpc2UgaXQnbGwgc3RvcCBpbiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uIHdoZW4gcmVhY2hpbmcgdGhlIHN0YXJ0LlxuICAgICAgdGhpcy5fckRlbGF5ID0gdmFycy5yZXBlYXREZWxheSB8fCAwO1xuICAgICAgdGhpcy5feW95byA9ICEhdmFycy55b3lvIHx8ICEhdmFycy55b3lvRWFzZTtcbiAgICB9XG5cbiAgICB0aGlzLl90cyA9IDE7XG5cbiAgICBfc2V0RHVyYXRpb24odGhpcywgK3ZhcnMuZHVyYXRpb24sIDEsIDEpO1xuXG4gICAgdGhpcy5kYXRhID0gdmFycy5kYXRhO1xuXG4gICAgaWYgKF9jb250ZXh0KSB7XG4gICAgICB0aGlzLl9jdHggPSBfY29udGV4dDtcblxuICAgICAgX2NvbnRleHQuZGF0YS5wdXNoKHRoaXMpO1xuICAgIH1cblxuICAgIF90aWNrZXJBY3RpdmUgfHwgX3RpY2tlci53YWtlKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVsYXkgPSBmdW5jdGlvbiBkZWxheSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgJiYgdGhpcy5zdGFydFRpbWUodGhpcy5fc3RhcnQgKyB2YWx1ZSAtIHRoaXMuX2RlbGF5KTtcbiAgICAgIHRoaXMuX2RlbGF5ID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZGVsYXk7XG4gIH07XG5cbiAgX3Byb3RvLmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxEdXJhdGlvbih0aGlzLl9yZXBlYXQgPiAwID8gdmFsdWUgKyAodmFsdWUgKyB0aGlzLl9yRGVsYXkpICogdGhpcy5fcmVwZWF0IDogdmFsdWUpIDogdGhpcy50b3RhbER1cmF0aW9uKCkgJiYgdGhpcy5fZHVyO1xuICB9O1xuXG4gIF9wcm90by50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24gdG90YWxEdXJhdGlvbih2YWx1ZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3REdXI7XG4gICAgfVxuXG4gICAgdGhpcy5fZGlydHkgPSAwO1xuICAgIHJldHVybiBfc2V0RHVyYXRpb24odGhpcywgdGhpcy5fcmVwZWF0IDwgMCA/IHZhbHVlIDogKHZhbHVlIC0gdGhpcy5fcmVwZWF0ICogdGhpcy5fckRlbGF5KSAvICh0aGlzLl9yZXBlYXQgKyAxKSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvdGFsVGltZSA9IGZ1bmN0aW9uIHRvdGFsVGltZShfdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIF93YWtlKCk7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90VGltZTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy5fZHA7XG5cbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyAmJiB0aGlzLl90cykge1xuICAgICAgX2FsaWduUGxheWhlYWQodGhpcywgX3RvdGFsVGltZSk7XG5cbiAgICAgICFwYXJlbnQuX2RwIHx8IHBhcmVudC5wYXJlbnQgfHwgX3Bvc3RBZGRDaGVja3MocGFyZW50LCB0aGlzKTsgLy8gZWRnZSBjYXNlOiBpZiB0aGlzIGlzIGEgY2hpbGQgb2YgYSB0aW1lbGluZSB0aGF0IGFscmVhZHkgY29tcGxldGVkLCBmb3IgZXhhbXBsZSwgd2UgbXVzdCByZS1hY3RpdmF0ZSB0aGUgcGFyZW50LlxuICAgICAgLy9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3IgdGltZWxpbmVzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZCwgd2Ugc2hvdWxkIHJlc2V0IHRoZWlyIHRvdGFsVGltZSgpIHdoaWNoIHdpbGwgYWxzbyBlbnN1cmUgdGhhdCB0aGV5J3JlIGxpbmVkIHVwIHByb3Blcmx5IGFuZCBlbmFibGVkLiBTa2lwIGZvciBhbmltYXRpb25zIHRoYXQgYXJlIG9uIHRoZSByb290ICh3YXN0ZWZ1bCkuIEV4YW1wbGU6IGEgVGltZWxpbmVMaXRlLmV4cG9ydFJvb3QoKSBpcyBwZXJmb3JtZWQgd2hlbiB0aGVyZSdzIGEgcGF1c2VkIHR3ZWVuIG9uIHRoZSByb290LCB0aGUgZXhwb3J0IHdpbGwgbm90IGNvbXBsZXRlIHVudGlsIHRoYXQgdHdlZW4gaXMgdW5wYXVzZWQsIGJ1dCBpbWFnaW5lIGEgY2hpbGQgZ2V0cyByZXN0YXJ0ZWQgbGF0ZXIsIGFmdGVyIGFsbCBbdW5wYXVzZWRdIHR3ZWVucyBoYXZlIGNvbXBsZXRlZC4gVGhlIHN0YXJ0IG9mIHRoYXQgY2hpbGQgd291bGQgZ2V0IHB1c2hlZCBvdXQsIGJ1dCBvbmUgb2YgdGhlIGFuY2VzdG9ycyBtYXkgaGF2ZSBjb21wbGV0ZWQuXG5cbiAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LnBhcmVudC5fdGltZSAhPT0gcGFyZW50Ll9zdGFydCArIChwYXJlbnQuX3RzID49IDAgPyBwYXJlbnQuX3RUaW1lIC8gcGFyZW50Ll90cyA6IChwYXJlbnQudG90YWxEdXJhdGlvbigpIC0gcGFyZW50Ll90VGltZSkgLyAtcGFyZW50Ll90cykpIHtcbiAgICAgICAgICBwYXJlbnQudG90YWxUaW1lKHBhcmVudC5fdFRpbWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnBhcmVudCAmJiB0aGlzLl9kcC5hdXRvUmVtb3ZlQ2hpbGRyZW4gJiYgKHRoaXMuX3RzID4gMCAmJiBfdG90YWxUaW1lIDwgdGhpcy5fdER1ciB8fCB0aGlzLl90cyA8IDAgJiYgX3RvdGFsVGltZSA+IDAgfHwgIXRoaXMuX3REdXIgJiYgIV90b3RhbFRpbWUpKSB7XG4gICAgICAgIC8vaWYgdGhlIGFuaW1hdGlvbiBkb2Vzbid0IGhhdmUgYSBwYXJlbnQsIHB1dCBpdCBiYWNrIGludG8gaXRzIGxhc3QgcGFyZW50IChyZWNvcmRlZCBhcyBfZHAgZm9yIGV4YWN0bHkgY2FzZXMgbGlrZSB0aGlzKS4gTGltaXQgdG8gcGFyZW50cyB3aXRoIGF1dG9SZW1vdmVDaGlsZHJlbiAobGlrZSBnbG9iYWxUaW1lbGluZSkgc28gdGhhdCBpZiB0aGUgdXNlciBtYW51YWxseSByZW1vdmVzIGFuIGFuaW1hdGlvbiBmcm9tIGEgdGltZWxpbmUgYW5kIHRoZW4gYWx0ZXJzIGl0cyBwbGF5aGVhZCwgaXQgZG9lc24ndCBnZXQgYWRkZWQgYmFjayBpbi5cbiAgICAgICAgX2FkZFRvVGltZWxpbmUodGhpcy5fZHAsIHRoaXMsIHRoaXMuX3N0YXJ0IC0gdGhpcy5fZGVsYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl90VGltZSAhPT0gX3RvdGFsVGltZSB8fCAhdGhpcy5fZHVyICYmICFzdXBwcmVzc0V2ZW50cyB8fCB0aGlzLl9pbml0dGVkICYmIE1hdGguYWJzKHRoaXMuX3pUaW1lKSA9PT0gX3RpbnlOdW0gfHwgIV90b3RhbFRpbWUgJiYgIXRoaXMuX2luaXR0ZWQgJiYgKHRoaXMuYWRkIHx8IHRoaXMuX3B0TG9va3VwKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIF9wdExvb2t1cCBvbiBhIFR3ZWVuIGluc3RhbmNlIHRvIGVuc3VyZSBpdCBoYXMgYWN0dWFsbHkgZmluaXNoZWQgYmVpbmcgaW5zdGFudGlhdGVkLCBvdGhlcndpc2UgaWYgdGhpcy5yZXZlcnNlKCkgZ2V0cyBjYWxsZWQgaW4gdGhlIEFuaW1hdGlvbiBjb25zdHJ1Y3RvciwgaXQgY291bGQgdHJpZ2dlciBhIHJlbmRlcigpIGhlcmUgZXZlbiB0aG91Z2ggdGhlIF90YXJnZXRzIHdlcmVuJ3QgcG9wdWxhdGVkLCB0aHVzIHdoZW4gX2luaXQoKSBpcyBjYWxsZWQgdGhlcmUgd29uJ3QgYmUgYW55IFByb3BUd2VlbnMgKGl0J2xsIGFjdCBsaWtlIHRoZSB0d2VlbiBpcyBub24tZnVuY3Rpb25hbClcbiAgICAgIHRoaXMuX3RzIHx8ICh0aGlzLl9wVGltZSA9IF90b3RhbFRpbWUpOyAvLyBvdGhlcndpc2UsIGlmIGFuIGFuaW1hdGlvbiBpcyBwYXVzZWQsIHRoZW4gdGhlIHBsYXloZWFkIGlzIG1vdmVkIGJhY2sgdG8gemVybywgdGhlbiByZXN1bWVkLCBpdCdkIHJldmVydCBiYWNrIHRvIHRoZSBvcmlnaW5hbCB0aW1lIGF0IHRoZSBwYXVzZVxuICAgICAgLy9pZiAoIXRoaXMuX2xvY2spIHsgLy8gYXZvaWQgZW5kbGVzcyByZWN1cnNpb24gKG5vdCBzdXJlIHdlIG5lZWQgdGhpcyB5ZXQgb3IgaWYgaXQncyB3b3J0aCB0aGUgcGVyZm9ybWFuY2UgaGl0KVxuICAgICAgLy8gICB0aGlzLl9sb2NrID0gMTtcblxuICAgICAgX2xhenlTYWZlUmVuZGVyKHRoaXMsIF90b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzKTsgLy8gICB0aGlzLl9sb2NrID0gMDtcbiAgICAgIC8vfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnRpbWUgPSBmdW5jdGlvbiB0aW1lKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUoTWF0aC5taW4odGhpcy50b3RhbER1cmF0aW9uKCksIHZhbHVlICsgX2VsYXBzZWRDeWNsZUR1cmF0aW9uKHRoaXMpKSAlICh0aGlzLl9kdXIgKyB0aGlzLl9yRGVsYXkpIHx8ICh2YWx1ZSA/IHRoaXMuX2R1ciA6IDApLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLl90aW1lOyAvLyBub3RlOiBpZiB0aGUgbW9kdWx1cyByZXN1bHRzIGluIDAsIHRoZSBwbGF5aGVhZCBjb3VsZCBiZSBleGFjdGx5IGF0IHRoZSBlbmQgb3IgdGhlIGJlZ2lubmluZywgYW5kIHdlIGFsd2F5cyBkZWZlciB0byB0aGUgRU5EIHdpdGggYSBub24temVybyB2YWx1ZSwgb3RoZXJ3aXNlIGlmIHlvdSBzZXQgdGhlIHRpbWUoKSB0byB0aGUgdmVyeSBlbmQgKGR1cmF0aW9uKCkpLCBpdCB3b3VsZCByZW5kZXIgYXQgdGhlIFNUQVJUIVxuICB9O1xuXG4gIF9wcm90by50b3RhbFByb2dyZXNzID0gZnVuY3Rpb24gdG90YWxQcm9ncmVzcyh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKHRoaXMudG90YWxEdXJhdGlvbigpICogdmFsdWUsIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMudG90YWxEdXJhdGlvbigpID8gTWF0aC5taW4oMSwgdGhpcy5fdFRpbWUgLyB0aGlzLl90RHVyKSA6IHRoaXMucmF3VGltZSgpID4gMCA/IDEgOiAwO1xuICB9O1xuXG4gIF9wcm90by5wcm9ncmVzcyA9IGZ1bmN0aW9uIHByb2dyZXNzKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUodGhpcy5kdXJhdGlvbigpICogKHRoaXMuX3lveW8gJiYgISh0aGlzLml0ZXJhdGlvbigpICYgMSkgPyAxIC0gdmFsdWUgOiB2YWx1ZSkgKyBfZWxhcHNlZEN5Y2xlRHVyYXRpb24odGhpcyksIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMuZHVyYXRpb24oKSA/IE1hdGgubWluKDEsIHRoaXMuX3RpbWUgLyB0aGlzLl9kdXIpIDogdGhpcy5yYXdUaW1lKCkgPiAwID8gMSA6IDA7XG4gIH07XG5cbiAgX3Byb3RvLml0ZXJhdGlvbiA9IGZ1bmN0aW9uIGl0ZXJhdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICB2YXIgY3ljbGVEdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKSArIHRoaXMuX3JEZWxheTtcblxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUodGhpcy5fdGltZSArICh2YWx1ZSAtIDEpICogY3ljbGVEdXJhdGlvbiwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy5fcmVwZWF0ID8gX2FuaW1hdGlvbkN5Y2xlKHRoaXMuX3RUaW1lLCBjeWNsZUR1cmF0aW9uKSArIDEgOiAxO1xuICB9IC8vIHBvdGVudGlhbCBmdXR1cmUgYWRkaXRpb246XG4gIC8vIGlzUGxheWluZ0JhY2t3YXJkcygpIHtcbiAgLy8gXHRsZXQgYW5pbWF0aW9uID0gdGhpcyxcbiAgLy8gXHRcdG9yaWVudGF0aW9uID0gMTsgLy8gMSA9IGZvcndhcmQsIC0xID0gYmFja3dhcmRcbiAgLy8gXHR3aGlsZSAoYW5pbWF0aW9uKSB7XG4gIC8vIFx0XHRvcmllbnRhdGlvbiAqPSBhbmltYXRpb24ucmV2ZXJzZWQoKSB8fCAoYW5pbWF0aW9uLnJlcGVhdCgpICYmICEoYW5pbWF0aW9uLml0ZXJhdGlvbigpICYgMSkpID8gLTEgOiAxO1xuICAvLyBcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uLnBhcmVudDtcbiAgLy8gXHR9XG4gIC8vIFx0cmV0dXJuIG9yaWVudGF0aW9uIDwgMDtcbiAgLy8gfVxuICA7XG5cbiAgX3Byb3RvLnRpbWVTY2FsZSA9IGZ1bmN0aW9uIHRpbWVTY2FsZSh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydHMgPT09IC1fdGlueU51bSA/IDAgOiB0aGlzLl9ydHM7IC8vIHJlY29yZGVkIHRpbWVTY2FsZS4gU3BlY2lhbCBjYXNlOiBpZiBzb21lb25lIGNhbGxzIHJldmVyc2UoKSBvbiBhbiBhbmltYXRpb24gd2l0aCB0aW1lU2NhbGUgb2YgMCwgd2UgYXNzaWduIGl0IC1fdGlueU51bSB0byByZW1lbWJlciBpdCdzIHJldmVyc2VkLlxuICAgIH1cblxuICAgIGlmICh0aGlzLl9ydHMgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgdFRpbWUgPSB0aGlzLnBhcmVudCAmJiB0aGlzLl90cyA/IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRoaXMucGFyZW50Ll90aW1lLCB0aGlzKSA6IHRoaXMuX3RUaW1lOyAvLyBtYWtlIHN1cmUgdG8gZG8gdGhlIHBhcmVudFRvQ2hpbGRUb3RhbFRpbWUoKSBCRUZPUkUgc2V0dGluZyB0aGUgbmV3IF90cyBiZWNhdXNlIHRoZSBvbGQgb25lIG11c3QgYmUgdXNlZCBpbiB0aGF0IGNhbGN1bGF0aW9uLlxuICAgIC8vIGZ1dHVyZSBhZGRpdGlvbj8gVXAgc2lkZTogZmFzdCBhbmQgbWluaW1hbCBmaWxlIHNpemUuIERvd24gc2lkZTogb25seSB3b3JrcyBvbiB0aGlzIGFuaW1hdGlvbjsgaWYgYSB0aW1lbGluZSBpcyByZXZlcnNlZCwgZm9yIGV4YW1wbGUsIGl0cyBjaGlsZHJlbnMnIG9uUmV2ZXJzZSB3b3VsZG4ndCBnZXQgY2FsbGVkLlxuICAgIC8vKCt2YWx1ZSA8IDAgJiYgdGhpcy5fcnRzID49IDApICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uUmV2ZXJzZVwiLCB0cnVlKTtcbiAgICAvLyBwcmlvcml0aXplIHJlbmRlcmluZyB3aGVyZSB0aGUgcGFyZW50J3MgcGxheWhlYWQgbGluZXMgdXAgaW5zdGVhZCBvZiB0aGlzLl90VGltZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIGEgdHdlZW4gdGhhdCdzIGFuaW1hdGluZyBhbm90aGVyIHR3ZWVuJ3MgdGltZVNjYWxlIGluIHRoZSBzYW1lIHJlbmRlcmluZyBsb29wIChzYW1lIHBhcmVudCksIHRodXMgaWYgdGhlIHRpbWVTY2FsZSB0d2VlbiByZW5kZXJzIGZpcnN0LCBpdCB3b3VsZCBhbHRlciBfc3RhcnQgQkVGT1JFIF90VGltZSB3YXMgc2V0IG9uIHRoYXQgdGljayAoaW4gdGhlIHJlbmRlcmluZyBsb29wKSwgZWZmZWN0aXZlbHkgZnJlZXppbmcgaXQgdW50aWwgdGhlIHRpbWVTY2FsZSB0d2VlbiBmaW5pc2hlcy5cblxuICAgIHRoaXMuX3J0cyA9ICt2YWx1ZSB8fCAwO1xuICAgIHRoaXMuX3RzID0gdGhpcy5fcHMgfHwgdmFsdWUgPT09IC1fdGlueU51bSA/IDAgOiB0aGlzLl9ydHM7IC8vIF90cyBpcyB0aGUgZnVuY3Rpb25hbCB0aW1lU2NhbGUgd2hpY2ggd291bGQgYmUgMCBpZiB0aGUgYW5pbWF0aW9uIGlzIHBhdXNlZC5cblxuICAgIHRoaXMudG90YWxUaW1lKF9jbGFtcCgtTWF0aC5hYnModGhpcy5fZGVsYXkpLCB0aGlzLl90RHVyLCB0VGltZSksIHN1cHByZXNzRXZlbnRzICE9PSBmYWxzZSk7XG5cbiAgICBfc2V0RW5kKHRoaXMpOyAvLyBpZiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgd2FzIGZhbHNlLCB0aGUgZW5kIHRpbWUgZGlkbid0IGdldCB1cGRhdGVkIGluIHRoZSBfYWxpZ25QbGF5aGVhZCgpIG1ldGhvZCwgc28gZG8gaXQgaGVyZS5cblxuXG4gICAgcmV0dXJuIF9yZWNhY2hlQW5jZXN0b3JzKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5wYXVzZWQgPSBmdW5jdGlvbiBwYXVzZWQodmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcHMgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9wcyA9IHZhbHVlO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcFRpbWUgPSB0aGlzLl90VGltZSB8fCBNYXRoLm1heCgtdGhpcy5fZGVsYXksIHRoaXMucmF3VGltZSgpKTsgLy8gaWYgdGhlIHBhdXNlIG9jY3VycyBkdXJpbmcgdGhlIGRlbGF5IHBoYXNlLCBtYWtlIHN1cmUgdGhhdCdzIGZhY3RvcmVkIGluIHdoZW4gcmVzdW1pbmcuXG5cbiAgICAgICAgdGhpcy5fdHMgPSB0aGlzLl9hY3QgPSAwOyAvLyBfdHMgaXMgdGhlIGZ1bmN0aW9uYWwgdGltZVNjYWxlLCBzbyBhIHBhdXNlZCB0d2VlbiB3b3VsZCBlZmZlY3RpdmVseSBoYXZlIGEgdGltZVNjYWxlIG9mIDAuIFdlIHJlY29yZCB0aGUgXCJyZWFsXCIgdGltZVNjYWxlIGFzIF9ydHMgKHJlY29yZGVkIHRpbWUgc2NhbGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfd2FrZSgpO1xuXG4gICAgICAgIHRoaXMuX3RzID0gdGhpcy5fcnRzOyAvL29ubHkgZGVmZXIgdG8gX3BUaW1lIChwYXVzZVRpbWUpIGlmIHRUaW1lIGlzIHplcm8uIFJlbWVtYmVyLCBzb21lb25lIGNvdWxkIHBhdXNlKCkgYW4gYW5pbWF0aW9uLCB0aGVuIHNjcnViIHRoZSBwbGF5aGVhZCBhbmQgcmVzdW1lKCkuIElmIHRoZSBwYXJlbnQgZG9lc24ndCBoYXZlIHNtb290aENoaWxkVGltaW5nLCB3ZSByZW5kZXIgYXQgdGhlIHJhd1RpbWUoKSBiZWNhdXNlIHRoZSBzdGFydFRpbWUgd29uJ3QgZ2V0IHVwZGF0ZWQuXG5cbiAgICAgICAgdGhpcy50b3RhbFRpbWUodGhpcy5wYXJlbnQgJiYgIXRoaXMucGFyZW50LnNtb290aENoaWxkVGltaW5nID8gdGhpcy5yYXdUaW1lKCkgOiB0aGlzLl90VGltZSB8fCB0aGlzLl9wVGltZSwgdGhpcy5wcm9ncmVzcygpID09PSAxICYmIE1hdGguYWJzKHRoaXMuX3pUaW1lKSAhPT0gX3RpbnlOdW0gJiYgKHRoaXMuX3RUaW1lIC09IF90aW55TnVtKSk7IC8vIGVkZ2UgY2FzZTogYW5pbWF0aW9uLnByb2dyZXNzKDEpLnBhdXNlKCkucGxheSgpIHdvdWxkbid0IHJlbmRlciBhZ2FpbiBiZWNhdXNlIHRoZSBwbGF5aGVhZCBpcyBhbHJlYWR5IGF0IHRoZSBlbmQsIGJ1dCB0aGUgY2FsbCB0byB0b3RhbFRpbWUoKSBiZWxvdyB3aWxsIGFkZCBpdCBiYWNrIHRvIGl0cyBwYXJlbnQuLi5hbmQgbm90IHJlbW92ZSBpdCBhZ2FpbiAoc2luY2UgcmVtb3Zpbmcgb25seSBoYXBwZW5zIHVwb24gcmVuZGVyaW5nIGF0IGEgbmV3IHRpbWUpLiBPZmZzZXR0aW5nIHRoZSBfdFRpbWUgc2xpZ2h0bHkgaXMgZG9uZSBzaW1wbHkgdG8gY2F1c2UgdGhlIGZpbmFsIHJlbmRlciBpbiB0b3RhbFRpbWUoKSB0aGF0J2xsIHBvcCBpdCBvZmYgaXRzIHRpbWVsaW5lIChpZiBhdXRvUmVtb3ZlQ2hpbGRyZW4gaXMgdHJ1ZSwgb2YgY291cnNlKS4gQ2hlY2sgdG8gbWFrZSBzdXJlIF96VGltZSBpc24ndCAtX3RpbnlOdW0gdG8gYXZvaWQgYW4gZWRnZSBjYXNlIHdoZXJlIHRoZSBwbGF5aGVhZCBpcyBwdXNoZWQgdG8gdGhlIGVuZCBidXQgSU5TSURFIGEgdHdlZW4vY2FsbGJhY2ssIHRoZSB0aW1lbGluZSBpdHNlbGYgaXMgcGF1c2VkIHRodXMgaGFsdGluZyByZW5kZXJpbmcgYW5kIGxlYXZpbmcgYSBmZXcgdW5yZW5kZXJlZC4gV2hlbiByZXN1bWluZywgaXQgd291bGRuJ3QgcmVuZGVyIHRob3NlIG90aGVyd2lzZS5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRUaW1lID0gZnVuY3Rpb24gc3RhcnRUaW1lKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3N0YXJ0ID0gdmFsdWU7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHA7XG4gICAgICBwYXJlbnQgJiYgKHBhcmVudC5fc29ydCB8fCAhdGhpcy5wYXJlbnQpICYmIF9hZGRUb1RpbWVsaW5lKHBhcmVudCwgdGhpcywgdmFsdWUgLSB0aGlzLl9kZWxheSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RhcnQ7XG4gIH07XG5cbiAgX3Byb3RvLmVuZFRpbWUgPSBmdW5jdGlvbiBlbmRUaW1lKGluY2x1ZGVSZXBlYXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0ICsgKF9pc05vdEZhbHNlKGluY2x1ZGVSZXBlYXRzKSA/IHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy5kdXJhdGlvbigpKSAvIE1hdGguYWJzKHRoaXMuX3RzIHx8IDEpO1xuICB9O1xuXG4gIF9wcm90by5yYXdUaW1lID0gZnVuY3Rpb24gcmF3VGltZSh3cmFwUmVwZWF0cykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLl9kcDsgLy8gX2RwID0gZGV0YWNoZWQgcGFyZW50XG5cbiAgICByZXR1cm4gIXBhcmVudCA/IHRoaXMuX3RUaW1lIDogd3JhcFJlcGVhdHMgJiYgKCF0aGlzLl90cyB8fCB0aGlzLl9yZXBlYXQgJiYgdGhpcy5fdGltZSAmJiB0aGlzLnRvdGFsUHJvZ3Jlc3MoKSA8IDEpID8gdGhpcy5fdFRpbWUgJSAodGhpcy5fZHVyICsgdGhpcy5fckRlbGF5KSA6ICF0aGlzLl90cyA/IHRoaXMuX3RUaW1lIDogX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUocGFyZW50LnJhd1RpbWUod3JhcFJlcGVhdHMpLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucmV2ZXJ0ID0gZnVuY3Rpb24gcmV2ZXJ0KGNvbmZpZykge1xuICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkge1xuICAgICAgY29uZmlnID0gX3JldmVydENvbmZpZztcbiAgICB9XG5cbiAgICB2YXIgcHJldklzUmV2ZXJ0aW5nID0gX3JldmVydGluZztcbiAgICBfcmV2ZXJ0aW5nID0gY29uZmlnO1xuXG4gICAgaWYgKHRoaXMuX2luaXR0ZWQgfHwgdGhpcy5fc3RhcnRBdCkge1xuICAgICAgdGhpcy50aW1lbGluZSAmJiB0aGlzLnRpbWVsaW5lLnJldmVydChjb25maWcpO1xuICAgICAgdGhpcy50b3RhbFRpbWUoLTAuMDEsIGNvbmZpZy5zdXBwcmVzc0V2ZW50cyk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhICE9PSBcIm5lc3RlZFwiICYmIGNvbmZpZy5raWxsICE9PSBmYWxzZSAmJiB0aGlzLmtpbGwoKTtcbiAgICBfcmV2ZXJ0aW5nID0gcHJldklzUmV2ZXJ0aW5nO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5nbG9iYWxUaW1lID0gZnVuY3Rpb24gZ2xvYmFsVGltZShyYXdUaW1lKSB7XG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMsXG4gICAgICAgIHRpbWUgPSBhcmd1bWVudHMubGVuZ3RoID8gcmF3VGltZSA6IGFuaW1hdGlvbi5yYXdUaW1lKCk7XG5cbiAgICB3aGlsZSAoYW5pbWF0aW9uKSB7XG4gICAgICB0aW1lID0gYW5pbWF0aW9uLl9zdGFydCArIHRpbWUgLyAoTWF0aC5hYnMoYW5pbWF0aW9uLl90cykgfHwgMSk7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24uX2RwO1xuICAgIH1cblxuICAgIHJldHVybiAhdGhpcy5wYXJlbnQgJiYgdGhpcy5fc2F0ID8gdGhpcy5fc2F0Lmdsb2JhbFRpbWUocmF3VGltZSkgOiB0aW1lOyAvLyB0aGUgX3N0YXJ0QXQgdHdlZW5zIGZvciAuZnJvbVRvKCkgYW5kIC5mcm9tKCkgdGhhdCBoYXZlIGltbWVkaWF0ZVJlbmRlciBzaG91bGQgYWx3YXlzIGJlIEZJUlNUIGluIHRoZSB0aW1lbGluZSAoaW1wb3J0YW50IGZvciBjb250ZXh0LnJldmVydCgpKS4gXCJfc2F0XCIgc3RhbmRzIGZvciBfc3RhcnRBdFR3ZWVuLCByZWZlcnJpbmcgdG8gdGhlIHBhcmVudCB0d2VlbiB0aGF0IGNyZWF0ZWQgdGhlIF9zdGFydEF0LiBXZSBtdXN0IGRpc2Nlcm4gaWYgdGhhdCB0d2VlbiBoYWQgaW1tZWRpYXRlUmVuZGVyIHNvIHRoYXQgd2UgY2FuIGtub3cgd2hldGhlciBvciBub3QgdG8gcHJpb3JpdGl6ZSBpdCBpbiByZXZlcnQoKS5cbiAgfTtcblxuICBfcHJvdG8ucmVwZWF0ID0gZnVuY3Rpb24gcmVwZWF0KHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3JlcGVhdCA9IHZhbHVlID09PSBJbmZpbml0eSA/IC0yIDogdmFsdWU7XG4gICAgICByZXR1cm4gX29uVXBkYXRlVG90YWxEdXJhdGlvbih0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVwZWF0ID09PSAtMiA/IEluZmluaXR5IDogdGhpcy5fcmVwZWF0O1xuICB9O1xuXG4gIF9wcm90by5yZXBlYXREZWxheSA9IGZ1bmN0aW9uIHJlcGVhdERlbGF5KHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciB0aW1lID0gdGhpcy5fdGltZTtcbiAgICAgIHRoaXMuX3JEZWxheSA9IHZhbHVlO1xuXG4gICAgICBfb25VcGRhdGVUb3RhbER1cmF0aW9uKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGltZSA/IHRoaXMudGltZSh0aW1lKSA6IHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JEZWxheTtcbiAgfTtcblxuICBfcHJvdG8ueW95byA9IGZ1bmN0aW9uIHlveW8odmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5feW95byA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3lveW87XG4gIH07XG5cbiAgX3Byb3RvLnNlZWsgPSBmdW5jdGlvbiBzZWVrKHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiB0aGlzLnRvdGFsVGltZShfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbiksIF9pc05vdEZhbHNlKHN1cHByZXNzRXZlbnRzKSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlc3RhcnQgPSBmdW5jdGlvbiByZXN0YXJ0KGluY2x1ZGVEZWxheSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5KCkudG90YWxUaW1lKGluY2x1ZGVEZWxheSA/IC10aGlzLl9kZWxheSA6IDAsIF9pc05vdEZhbHNlKHN1cHByZXNzRXZlbnRzKSk7XG4gIH07XG5cbiAgX3Byb3RvLnBsYXkgPSBmdW5jdGlvbiBwbGF5KGZyb20sIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgZnJvbSAhPSBudWxsICYmIHRoaXMuc2Vlayhmcm9tLCBzdXBwcmVzc0V2ZW50cyk7XG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZWQoZmFsc2UpLnBhdXNlZChmYWxzZSk7XG4gIH07XG5cbiAgX3Byb3RvLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKGZyb20sIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgZnJvbSAhPSBudWxsICYmIHRoaXMuc2Vlayhmcm9tIHx8IHRoaXMudG90YWxEdXJhdGlvbigpLCBzdXBwcmVzc0V2ZW50cyk7XG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZWQodHJ1ZSkucGF1c2VkKGZhbHNlKTtcbiAgfTtcblxuICBfcHJvdG8ucGF1c2UgPSBmdW5jdGlvbiBwYXVzZShhdFRpbWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgYXRUaW1lICE9IG51bGwgJiYgdGhpcy5zZWVrKGF0VGltZSwgc3VwcHJlc3NFdmVudHMpO1xuICAgIHJldHVybiB0aGlzLnBhdXNlZCh0cnVlKTtcbiAgfTtcblxuICBfcHJvdG8ucmVzdW1lID0gZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgIHJldHVybiB0aGlzLnBhdXNlZChmYWxzZSk7XG4gIH07XG5cbiAgX3Byb3RvLnJldmVyc2VkID0gZnVuY3Rpb24gcmV2ZXJzZWQodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgISF2YWx1ZSAhPT0gdGhpcy5yZXZlcnNlZCgpICYmIHRoaXMudGltZVNjYWxlKC10aGlzLl9ydHMgfHwgKHZhbHVlID8gLV90aW55TnVtIDogMCkpOyAvLyBpbiBjYXNlIHRpbWVTY2FsZSBpcyB6ZXJvLCByZXZlcnNpbmcgd291bGQgaGF2ZSBubyBlZmZlY3Qgc28gd2UgdXNlIF90aW55TnVtLlxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcnRzIDwgMDtcbiAgfTtcblxuICBfcHJvdG8uaW52YWxpZGF0ZSA9IGZ1bmN0aW9uIGludmFsaWRhdGUoKSB7XG4gICAgdGhpcy5faW5pdHRlZCA9IHRoaXMuX2FjdCA9IDA7XG4gICAgdGhpcy5felRpbWUgPSAtX3RpbnlOdW07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmlzQWN0aXZlID0gZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXMuX2RwLFxuICAgICAgICBzdGFydCA9IHRoaXMuX3N0YXJ0LFxuICAgICAgICByYXdUaW1lO1xuICAgIHJldHVybiAhISghcGFyZW50IHx8IHRoaXMuX3RzICYmIHRoaXMuX2luaXR0ZWQgJiYgcGFyZW50LmlzQWN0aXZlKCkgJiYgKHJhd1RpbWUgPSBwYXJlbnQucmF3VGltZSh0cnVlKSkgPj0gc3RhcnQgJiYgcmF3VGltZSA8IHRoaXMuZW5kVGltZSh0cnVlKSAtIF90aW55TnVtKTtcbiAgfTtcblxuICBfcHJvdG8uZXZlbnRDYWxsYmFjayA9IGZ1bmN0aW9uIGV2ZW50Q2FsbGJhY2sodHlwZSwgY2FsbGJhY2ssIHBhcmFtcykge1xuICAgIHZhciB2YXJzID0gdGhpcy52YXJzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIGRlbGV0ZSB2YXJzW3R5cGVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyc1t0eXBlXSA9IGNhbGxiYWNrO1xuICAgICAgICBwYXJhbXMgJiYgKHZhcnNbdHlwZSArIFwiUGFyYW1zXCJdID0gcGFyYW1zKTtcbiAgICAgICAgdHlwZSA9PT0gXCJvblVwZGF0ZVwiICYmICh0aGlzLl9vblVwZGF0ZSA9IGNhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhcnNbdHlwZV07XG4gIH07XG5cbiAgX3Byb3RvLnRoZW4gPSBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgdmFyIGYgPSBfaXNGdW5jdGlvbihvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IF9wYXNzVGhyb3VnaCxcbiAgICAgICAgICBfcmVzb2x2ZSA9IGZ1bmN0aW9uIF9yZXNvbHZlKCkge1xuICAgICAgICB2YXIgX3RoZW4gPSBzZWxmLnRoZW47XG4gICAgICAgIHNlbGYudGhlbiA9IG51bGw7IC8vIHRlbXBvcmFyaWx5IG51bGwgdGhlIHRoZW4oKSBtZXRob2QgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVlbnNvY2svR1NBUC9pc3N1ZXMvMzIyKVxuXG4gICAgICAgIF9pc0Z1bmN0aW9uKGYpICYmIChmID0gZihzZWxmKSkgJiYgKGYudGhlbiB8fCBmID09PSBzZWxmKSAmJiAoc2VsZi50aGVuID0gX3RoZW4pO1xuICAgICAgICByZXNvbHZlKGYpO1xuICAgICAgICBzZWxmLnRoZW4gPSBfdGhlbjtcbiAgICAgIH07XG5cbiAgICAgIGlmIChzZWxmLl9pbml0dGVkICYmIHNlbGYudG90YWxQcm9ncmVzcygpID09PSAxICYmIHNlbGYuX3RzID49IDAgfHwgIXNlbGYuX3RUaW1lICYmIHNlbGYuX3RzIDwgMCkge1xuICAgICAgICBfcmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5fcHJvbSA9IF9yZXNvbHZlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5raWxsID0gZnVuY3Rpb24ga2lsbCgpIHtcbiAgICBfaW50ZXJydXB0KHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBBbmltYXRpb247XG59KCk7XG5cbl9zZXREZWZhdWx0cyhBbmltYXRpb24ucHJvdG90eXBlLCB7XG4gIF90aW1lOiAwLFxuICBfc3RhcnQ6IDAsXG4gIF9lbmQ6IDAsXG4gIF90VGltZTogMCxcbiAgX3REdXI6IDAsXG4gIF9kaXJ0eTogMCxcbiAgX3JlcGVhdDogMCxcbiAgX3lveW86IGZhbHNlLFxuICBwYXJlbnQ6IG51bGwsXG4gIF9pbml0dGVkOiBmYWxzZSxcbiAgX3JEZWxheTogMCxcbiAgX3RzOiAxLFxuICBfZHA6IDAsXG4gIHJhdGlvOiAwLFxuICBfelRpbWU6IC1fdGlueU51bSxcbiAgX3Byb206IDAsXG4gIF9wczogZmFsc2UsXG4gIF9ydHM6IDFcbn0pO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRJTUVMSU5FXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5leHBvcnQgdmFyIFRpbWVsaW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5pbWF0aW9uKSB7XG4gIF9pbmhlcml0c0xvb3NlKFRpbWVsaW5lLCBfQW5pbWF0aW9uKTtcblxuICBmdW5jdGlvbiBUaW1lbGluZSh2YXJzLCBwb3NpdGlvbikge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgIHZhcnMgPSB7fTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9BbmltYXRpb24uY2FsbCh0aGlzLCB2YXJzKSB8fCB0aGlzO1xuICAgIF90aGlzLmxhYmVscyA9IHt9O1xuICAgIF90aGlzLnNtb290aENoaWxkVGltaW5nID0gISF2YXJzLnNtb290aENoaWxkVGltaW5nO1xuICAgIF90aGlzLmF1dG9SZW1vdmVDaGlsZHJlbiA9ICEhdmFycy5hdXRvUmVtb3ZlQ2hpbGRyZW47XG4gICAgX3RoaXMuX3NvcnQgPSBfaXNOb3RGYWxzZSh2YXJzLnNvcnRDaGlsZHJlbik7XG4gICAgX2dsb2JhbFRpbWVsaW5lICYmIF9hZGRUb1RpbWVsaW5lKHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZSwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHBvc2l0aW9uKTtcbiAgICB2YXJzLnJldmVyc2VkICYmIF90aGlzLnJldmVyc2UoKTtcbiAgICB2YXJzLnBhdXNlZCAmJiBfdGhpcy5wYXVzZWQodHJ1ZSk7XG4gICAgdmFycy5zY3JvbGxUcmlnZ2VyICYmIF9zY3JvbGxUcmlnZ2VyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCB2YXJzLnNjcm9sbFRyaWdnZXIpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gVGltZWxpbmUucHJvdG90eXBlO1xuXG4gIF9wcm90bzIudG8gPSBmdW5jdGlvbiB0byh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgIF9jcmVhdGVUd2VlblR5cGUoMCwgYXJndW1lbnRzLCB0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuZnJvbSA9IGZ1bmN0aW9uIGZyb20odGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICBfY3JlYXRlVHdlZW5UeXBlKDEsIGFyZ3VtZW50cywgdGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmZyb21UbyA9IGZ1bmN0aW9uIGZyb21Ubyh0YXJnZXRzLCBmcm9tVmFycywgdG9WYXJzLCBwb3NpdGlvbikge1xuICAgIF9jcmVhdGVUd2VlblR5cGUoMiwgYXJndW1lbnRzLCB0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgdmFycy5kdXJhdGlvbiA9IDA7XG4gICAgdmFycy5wYXJlbnQgPSB0aGlzO1xuICAgIF9pbmhlcml0RGVmYXVsdHModmFycykucmVwZWF0RGVsYXkgfHwgKHZhcnMucmVwZWF0ID0gMCk7XG4gICAgdmFycy5pbW1lZGlhdGVSZW5kZXIgPSAhIXZhcnMuaW1tZWRpYXRlUmVuZGVyO1xuICAgIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbiksIDEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuY2FsbCA9IGZ1bmN0aW9uIGNhbGwoY2FsbGJhY2ssIHBhcmFtcywgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gX2FkZFRvVGltZWxpbmUodGhpcywgVHdlZW4uZGVsYXllZENhbGwoMCwgY2FsbGJhY2ssIHBhcmFtcyksIHBvc2l0aW9uKTtcbiAgfSAvL09OTFkgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkhIE1heWJlIGRlbGV0ZT9cbiAgO1xuXG4gIF9wcm90bzIuc3RhZ2dlclRvID0gZnVuY3Rpb24gc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuICAgIHZhcnMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB2YXJzLnN0YWdnZXIgPSB2YXJzLnN0YWdnZXIgfHwgc3RhZ2dlcjtcbiAgICB2YXJzLm9uQ29tcGxldGUgPSBvbkNvbXBsZXRlQWxsO1xuICAgIHZhcnMub25Db21wbGV0ZVBhcmFtcyA9IG9uQ29tcGxldGVBbGxQYXJhbXM7XG4gICAgdmFycy5wYXJlbnQgPSB0aGlzO1xuICAgIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbikpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuc3RhZ2dlckZyb20gPSBmdW5jdGlvbiBzdGFnZ2VyRnJvbSh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpIHtcbiAgICB2YXJzLnJ1bkJhY2t3YXJkcyA9IDE7XG4gICAgX2luaGVyaXREZWZhdWx0cyh2YXJzKS5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZSh2YXJzLmltbWVkaWF0ZVJlbmRlcik7XG4gICAgcmV0dXJuIHRoaXMuc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcyk7XG4gIH07XG5cbiAgX3Byb3RvMi5zdGFnZ2VyRnJvbVRvID0gZnVuY3Rpb24gc3RhZ2dlckZyb21Ubyh0YXJnZXRzLCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpIHtcbiAgICB0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuICAgIF9pbmhlcml0RGVmYXVsdHModG9WYXJzKS5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZSh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyKTtcbiAgICByZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpO1xuICB9O1xuXG4gIF9wcm90bzIucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG4gICAgdmFyIHByZXZUaW1lID0gdGhpcy5fdGltZSxcbiAgICAgICAgdER1ciA9IHRoaXMuX2RpcnR5ID8gdGhpcy50b3RhbER1cmF0aW9uKCkgOiB0aGlzLl90RHVyLFxuICAgICAgICBkdXIgPSB0aGlzLl9kdXIsXG4gICAgICAgIHRUaW1lID0gdG90YWxUaW1lIDw9IDAgPyAwIDogX3JvdW5kUHJlY2lzZSh0b3RhbFRpbWUpLFxuICAgICAgICAvLyBpZiBhIHBhdXNlZCB0aW1lbGluZSBpcyByZXN1bWVkIChvciBpdHMgX3N0YXJ0IGlzIHVwZGF0ZWQgZm9yIGFub3RoZXIgcmVhc29uLi4ud2hpY2ggcm91bmRzIGl0KSwgdGhhdCBjb3VsZCByZXN1bHQgaW4gdGhlIHBsYXloZWFkIHNoaWZ0aW5nIGEgKip0aW55KiogYW1vdW50IGFuZCBhIHplcm8tZHVyYXRpb24gY2hpbGQgYXQgdGhhdCBzcG90IG1heSBnZXQgcmVuZGVyZWQgYXQgYSBkaWZmZXJlbnQgcmF0aW8sIGxpa2UgaXRzIHRvdGFsVGltZSBpbiByZW5kZXIoKSBtYXkgYmUgMWUtMTcgaW5zdGVhZCBvZiAwLCBmb3IgZXhhbXBsZS5cbiAgICBjcm9zc2luZ1N0YXJ0ID0gdGhpcy5felRpbWUgPCAwICE9PSB0b3RhbFRpbWUgPCAwICYmICh0aGlzLl9pbml0dGVkIHx8ICFkdXIpLFxuICAgICAgICB0aW1lLFxuICAgICAgICBjaGlsZCxcbiAgICAgICAgbmV4dCxcbiAgICAgICAgaXRlcmF0aW9uLFxuICAgICAgICBjeWNsZUR1cmF0aW9uLFxuICAgICAgICBwcmV2UGF1c2VkLFxuICAgICAgICBwYXVzZVR3ZWVuLFxuICAgICAgICB0aW1lU2NhbGUsXG4gICAgICAgIHByZXZTdGFydCxcbiAgICAgICAgcHJldkl0ZXJhdGlvbixcbiAgICAgICAgeW95byxcbiAgICAgICAgaXNZb3lvO1xuICAgIHRoaXMgIT09IF9nbG9iYWxUaW1lbGluZSAmJiB0VGltZSA+IHREdXIgJiYgdG90YWxUaW1lID49IDAgJiYgKHRUaW1lID0gdER1cik7XG5cbiAgICBpZiAodFRpbWUgIT09IHRoaXMuX3RUaW1lIHx8IGZvcmNlIHx8IGNyb3NzaW5nU3RhcnQpIHtcbiAgICAgIGlmIChwcmV2VGltZSAhPT0gdGhpcy5fdGltZSAmJiBkdXIpIHtcbiAgICAgICAgLy9pZiB0b3RhbER1cmF0aW9uKCkgZmluZHMgYSBjaGlsZCB3aXRoIGEgbmVnYXRpdmUgc3RhcnRUaW1lIGFuZCBzbW9vdGhDaGlsZFRpbWluZyBpcyB0cnVlLCB0aGluZ3MgZ2V0IHNoaWZ0ZWQgYXJvdW5kIGludGVybmFsbHkgc28gd2UgbmVlZCB0byBhZGp1c3QgdGhlIHRpbWUgYWNjb3JkaW5nbHkuIEZvciBleGFtcGxlLCBpZiBhIHR3ZWVuIHN0YXJ0cyBhdCAtMzAgd2UgbXVzdCBzaGlmdCBFVkVSWVRISU5HIGZvcndhcmQgMzAgc2Vjb25kcyBhbmQgbW92ZSB0aGlzIHRpbWVsaW5lJ3Mgc3RhcnRUaW1lIGJhY2t3YXJkIGJ5IDMwIHNlY29uZHMgc28gdGhhdCB0aGluZ3MgYWxpZ24gd2l0aCB0aGUgcGxheWhlYWQgKG5vIGp1bXApLlxuICAgICAgICB0VGltZSArPSB0aGlzLl90aW1lIC0gcHJldlRpbWU7XG4gICAgICAgIHRvdGFsVGltZSArPSB0aGlzLl90aW1lIC0gcHJldlRpbWU7XG4gICAgICB9XG5cbiAgICAgIHRpbWUgPSB0VGltZTtcbiAgICAgIHByZXZTdGFydCA9IHRoaXMuX3N0YXJ0O1xuICAgICAgdGltZVNjYWxlID0gdGhpcy5fdHM7XG4gICAgICBwcmV2UGF1c2VkID0gIXRpbWVTY2FsZTtcblxuICAgICAgaWYgKGNyb3NzaW5nU3RhcnQpIHtcbiAgICAgICAgZHVyIHx8IChwcmV2VGltZSA9IHRoaXMuX3pUaW1lKTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC5cblxuICAgICAgICAodG90YWxUaW1lIHx8ICFzdXBwcmVzc0V2ZW50cykgJiYgKHRoaXMuX3pUaW1lID0gdG90YWxUaW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3JlcGVhdCkge1xuICAgICAgICAvL2FkanVzdCB0aGUgdGltZSBmb3IgcmVwZWF0cyBhbmQgeW95b3NcbiAgICAgICAgeW95byA9IHRoaXMuX3lveW87XG4gICAgICAgIGN5Y2xlRHVyYXRpb24gPSBkdXIgKyB0aGlzLl9yRGVsYXk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3JlcGVhdCA8IC0xICYmIHRvdGFsVGltZSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b3RhbFRpbWUoY3ljbGVEdXJhdGlvbiAqIDEwMCArIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbWUgPSBfcm91bmRQcmVjaXNlKHRUaW1lICUgY3ljbGVEdXJhdGlvbik7IC8vcm91bmQgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzLiAoNCAlIDAuOCBzaG91bGQgYmUgMCBidXQgc29tZSBicm93c2VycyByZXBvcnQgaXQgYXMgMC43OTk5OTk5OSEpXG5cbiAgICAgICAgaWYgKHRUaW1lID09PSB0RHVyKSB7XG4gICAgICAgICAgLy8gdGhlIHREdXIgPT09IHRUaW1lIGlzIGZvciBlZGdlIGNhc2VzIHdoZXJlIHRoZXJlJ3MgYSBsZW5ndGh5IGRlY2ltYWwgb24gdGhlIGR1cmF0aW9uIGFuZCBpdCBtYXkgcmVhY2ggdGhlIHZlcnkgZW5kIGJ1dCB0aGUgdGltZSBpcyByZW5kZXJlZCBhcyBub3QtcXVpdGUtdGhlcmUgKHJlbWVtYmVyLCB0RHVyIGlzIHJvdW5kZWQgdG8gNCBkZWNpbWFscyB3aGVyZWFzIGR1ciBpc24ndClcbiAgICAgICAgICBpdGVyYXRpb24gPSB0aGlzLl9yZXBlYXQ7XG4gICAgICAgICAgdGltZSA9IGR1cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVyYXRpb24gPSB+fih0VGltZSAvIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgICAgaWYgKGl0ZXJhdGlvbiAmJiBpdGVyYXRpb24gPT09IHRUaW1lIC8gY3ljbGVEdXJhdGlvbikge1xuICAgICAgICAgICAgdGltZSA9IGR1cjtcbiAgICAgICAgICAgIGl0ZXJhdGlvbi0tO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpbWUgPiBkdXIgJiYgKHRpbWUgPSBkdXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldkl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbik7XG4gICAgICAgICFwcmV2VGltZSAmJiB0aGlzLl90VGltZSAmJiBwcmV2SXRlcmF0aW9uICE9PSBpdGVyYXRpb24gJiYgdGhpcy5fdFRpbWUgLSBwcmV2SXRlcmF0aW9uICogY3ljbGVEdXJhdGlvbiAtIHRoaXMuX2R1ciA8PSAwICYmIChwcmV2SXRlcmF0aW9uID0gaXRlcmF0aW9uKTsgLy8gZWRnZSBjYXNlIC0gaWYgc29tZW9uZSBkb2VzIGFkZFBhdXNlKCkgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIGEgcmVwZWF0aW5nIHRpbWVsaW5lLCB0aGF0IHBhdXNlIGlzIHRlY2huaWNhbGx5IGF0IHRoZSBzYW1lIHNwb3QgYXMgdGhlIGVuZCB3aGljaCBjYXVzZXMgdGhpcy5fdGltZSB0byBnZXQgc2V0IHRvIDAgd2hlbiB0aGUgdG90YWxUaW1lIHdvdWxkIG5vcm1hbGx5IHBsYWNlIHRoZSBwbGF5aGVhZCBhdCB0aGUgZW5kLiBTZWUgaHR0cHM6Ly9nc2FwLmNvbS9mb3J1bXMvdG9waWMvMjM4MjMtY2xvc2luZy1uYXYtYW5pbWF0aW9uLW5vdC13b3JraW5nLW9uLWllLWFuZC1pcGhvbmUtNi1tYXliZS1vdGhlci1vbGRlci1icm93c2VyLz90YWI9Y29tbWVudHMjY29tbWVudC0xMTMwMDUgYWxzbywgdGhpcy5fdFRpbWUgLSBwcmV2SXRlcmF0aW9uICogY3ljbGVEdXJhdGlvbiAtIHRoaXMuX2R1ciA8PSAwIGp1c3QgY2hlY2tzIHRvIG1ha2Ugc3VyZSBpdCB3YXNuJ3QgcHJldmlvdXNseSBpbiB0aGUgXCJyZXBlYXREZWxheVwiIHBvcnRpb25cblxuICAgICAgICBpZiAoeW95byAmJiBpdGVyYXRpb24gJiAxKSB7XG4gICAgICAgICAgdGltZSA9IGR1ciAtIHRpbWU7XG4gICAgICAgICAgaXNZb3lvID0gMTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICBtYWtlIHN1cmUgY2hpbGRyZW4gYXQgdGhlIGVuZC9iZWdpbm5pbmcgb2YgdGhlIHRpbWVsaW5lIGFyZSByZW5kZXJlZCBwcm9wZXJseS4gSWYsIGZvciBleGFtcGxlLFxuICAgICAgICBhIDMtc2Vjb25kIGxvbmcgdGltZWxpbmUgcmVuZGVyZWQgYXQgMi45IHNlY29uZHMgcHJldmlvdXNseSwgYW5kIG5vdyByZW5kZXJzIGF0IDMuMiBzZWNvbmRzICh3aGljaFxuICAgICAgICB3b3VsZCBnZXQgdHJhbnNsYXRlZCB0byAyLjggc2Vjb25kcyBpZiB0aGUgdGltZWxpbmUgeW95b3Mgb3IgMC4yIHNlY29uZHMgaWYgaXQganVzdCByZXBlYXRzKSwgdGhlcmVcbiAgICAgICAgY291bGQgYmUgYSBjYWxsYmFjayBvciBhIHNob3J0IHR3ZWVuIHRoYXQncyBhdCAyLjk1IG9yIDMgc2Vjb25kcyBpbiB3aGljaCB3b3VsZG4ndCByZW5kZXIuIFNvXG4gICAgICAgIHdlIG5lZWQgdG8gcHVzaCB0aGUgdGltZWxpbmUgdG8gdGhlIGVuZCAoYW5kL29yIGJlZ2lubmluZyBkZXBlbmRpbmcgb24gaXRzIHlveW8gdmFsdWUpLiBBbHNvIHdlIG11c3RcbiAgICAgICAgZW5zdXJlIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9yIGVuZCBvZiB0aGUgVGltZWxpbmUgd29yay5cbiAgICAgICAgKi9cblxuXG4gICAgICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24gJiYgIXRoaXMuX2xvY2spIHtcbiAgICAgICAgICB2YXIgcmV3aW5kaW5nID0geW95byAmJiBwcmV2SXRlcmF0aW9uICYgMSxcbiAgICAgICAgICAgICAgZG9lc1dyYXAgPSByZXdpbmRpbmcgPT09ICh5b3lvICYmIGl0ZXJhdGlvbiAmIDEpO1xuICAgICAgICAgIGl0ZXJhdGlvbiA8IHByZXZJdGVyYXRpb24gJiYgKHJld2luZGluZyA9ICFyZXdpbmRpbmcpO1xuICAgICAgICAgIHByZXZUaW1lID0gcmV3aW5kaW5nID8gMCA6IHRUaW1lICUgZHVyID8gZHVyIDogdFRpbWU7IC8vIGlmIHRoZSBwbGF5aGVhZCBpcyBsYW5kaW5nIGV4YWN0bHkgYXQgdGhlIGVuZCBvZiBhbiBpdGVyYXRpb24sIHVzZSB0aGF0IHRvdGFsVGltZSByYXRoZXIgdGhhbiBvbmx5IHRoZSBkdXJhdGlvbiwgb3RoZXJ3aXNlIGl0J2xsIHNraXAgdGhlIDJuZCByZW5kZXIgc2luY2UgaXQncyBlZmZlY3RpdmVseSBhdCB0aGUgc2FtZSB0aW1lLlxuXG4gICAgICAgICAgdGhpcy5fbG9jayA9IDE7XG4gICAgICAgICAgdGhpcy5yZW5kZXIocHJldlRpbWUgfHwgKGlzWW95byA/IDAgOiBfcm91bmRQcmVjaXNlKGl0ZXJhdGlvbiAqIGN5Y2xlRHVyYXRpb24pKSwgc3VwcHJlc3NFdmVudHMsICFkdXIpLl9sb2NrID0gMDtcbiAgICAgICAgICB0aGlzLl90VGltZSA9IHRUaW1lOyAvLyBpZiBhIHVzZXIgZ2V0cyB0aGUgaXRlcmF0aW9uKCkgaW5zaWRlIHRoZSBvblJlcGVhdCwgZm9yIGV4YW1wbGUsIGl0IHNob3VsZCBiZSBhY2N1cmF0ZS5cblxuICAgICAgICAgICFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnBhcmVudCAmJiBfY2FsbGJhY2sodGhpcywgXCJvblJlcGVhdFwiKTtcbiAgICAgICAgICB0aGlzLnZhcnMucmVwZWF0UmVmcmVzaCAmJiAhaXNZb3lvICYmICh0aGlzLmludmFsaWRhdGUoKS5fbG9jayA9IDEpO1xuXG4gICAgICAgICAgaWYgKHByZXZUaW1lICYmIHByZXZUaW1lICE9PSB0aGlzLl90aW1lIHx8IHByZXZQYXVzZWQgIT09ICF0aGlzLl90cyB8fCB0aGlzLnZhcnMub25SZXBlYXQgJiYgIXRoaXMucGFyZW50ICYmICF0aGlzLl9hY3QpIHtcbiAgICAgICAgICAgIC8vIGlmIHByZXZUaW1lIGlzIDAgYW5kIHdlIHJlbmRlciBhdCB0aGUgdmVyeSBlbmQsIF90aW1lIHdpbGwgYmUgdGhlIGVuZCwgdGh1cyB3b24ndCBtYXRjaC4gU28gaW4gdGhpcyBlZGdlIGNhc2UsIHByZXZUaW1lIHdvbid0IG1hdGNoIF90aW1lIGJ1dCB0aGF0J3Mgb2theS4gSWYgaXQgZ2V0cyBraWxsZWQgaW4gdGhlIG9uUmVwZWF0LCBlamVjdCBhcyB3ZWxsLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZHVyID0gdGhpcy5fZHVyOyAvLyBpbiBjYXNlIHRoZSBkdXJhdGlvbiBjaGFuZ2VkIGluIHRoZSBvblJlcGVhdFxuXG4gICAgICAgICAgdER1ciA9IHRoaXMuX3REdXI7XG5cbiAgICAgICAgICBpZiAoZG9lc1dyYXApIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2sgPSAyO1xuICAgICAgICAgICAgcHJldlRpbWUgPSByZXdpbmRpbmcgPyBkdXIgOiAtMC4wMDAxO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIocHJldlRpbWUsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgIWlzWW95byAmJiB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9sb2NrID0gMDtcblxuICAgICAgICAgIGlmICghdGhpcy5fdHMgJiYgIXByZXZQYXVzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0gLy9pbiBvcmRlciBmb3IgeW95b0Vhc2UgdG8gd29yayBwcm9wZXJseSB3aGVuIHRoZXJlJ3MgYSBzdGFnZ2VyLCB3ZSBtdXN0IHN3YXAgb3V0IHRoZSBlYXNlIGluIGVhY2ggc3ViLXR3ZWVuLlxuXG5cbiAgICAgICAgICBfcHJvcGFnYXRlWW95b0Vhc2UodGhpcywgaXNZb3lvKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faGFzUGF1c2UgJiYgIXRoaXMuX2ZvcmNpbmcgJiYgdGhpcy5fbG9jayA8IDIpIHtcbiAgICAgICAgcGF1c2VUd2VlbiA9IF9maW5kTmV4dFBhdXNlVHdlZW4odGhpcywgX3JvdW5kUHJlY2lzZShwcmV2VGltZSksIF9yb3VuZFByZWNpc2UodGltZSkpO1xuXG4gICAgICAgIGlmIChwYXVzZVR3ZWVuKSB7XG4gICAgICAgICAgdFRpbWUgLT0gdGltZSAtICh0aW1lID0gcGF1c2VUd2Vlbi5fc3RhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7XG4gICAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICAgIHRoaXMuX2FjdCA9ICF0aW1lU2NhbGU7IC8vYXMgbG9uZyBhcyBpdCdzIG5vdCBwYXVzZWQsIGZvcmNlIGl0IHRvIGJlIGFjdGl2ZSBzbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgaW5kZXBlbmRlbnQgb2YgdGhlIHBhcmVudCB0aW1lbGluZSwgaXQnbGwgYmUgZm9yY2VkIHRvIHJlLXJlbmRlciBvbiB0aGUgbmV4dCB0aWNrLlxuXG4gICAgICBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5fb25VcGRhdGUgPSB0aGlzLnZhcnMub25VcGRhdGU7XG4gICAgICAgIHRoaXMuX2luaXR0ZWQgPSAxO1xuICAgICAgICB0aGlzLl96VGltZSA9IHRvdGFsVGltZTtcbiAgICAgICAgcHJldlRpbWUgPSAwOyAvLyB1cG9uIGluaXQsIHRoZSBwbGF5aGVhZCBzaG91bGQgYWx3YXlzIGdvIGZvcndhcmQ7IHNvbWVvbmUgY291bGQgaW52YWxpZGF0ZSgpIGEgY29tcGxldGVkIHRpbWVsaW5lIGFuZCB0aGVuIGlmIHRoZXkgcmVzdGFydCgpLCB0aGF0IHdvdWxkIG1ha2UgY2hpbGQgdHdlZW5zIHJlbmRlciBpbiByZXZlcnNlIG9yZGVyIHdoaWNoIGNvdWxkIGxvY2sgaW4gdGhlIHdyb25nIHN0YXJ0aW5nIHZhbHVlcyBpZiB0aGV5IGJ1aWxkIG9uIGVhY2ggb3RoZXIsIGxpa2UgdGwudG8ob2JqLCB7eDogMTAwfSkudG8ob2JqLCB7eDogMH0pLlxuICAgICAgfVxuXG4gICAgICBpZiAoIXByZXZUaW1lICYmIHRpbWUgJiYgIXN1cHByZXNzRXZlbnRzICYmICFpdGVyYXRpb24pIHtcbiAgICAgICAgX2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcblxuICAgICAgICBpZiAodGhpcy5fdFRpbWUgIT09IHRUaW1lKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSB0aGUgb25TdGFydCB0cmlnZ2VyZWQgYSByZW5kZXIgYXQgYSBkaWZmZXJlbnQgc3BvdCwgZWplY3QuIExpa2UgaWYgc29tZW9uZSBkaWQgYW5pbWF0aW9uLnBhdXNlKDAuNSkgb3Igc29tZXRoaW5nIGluc2lkZSB0aGUgb25TdGFydC5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGltZSA+PSBwcmV2VGltZSAmJiB0b3RhbFRpbWUgPj0gMCkge1xuICAgICAgICBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuXG4gICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgIG5leHQgPSBjaGlsZC5fbmV4dDtcblxuICAgICAgICAgIGlmICgoY2hpbGQuX2FjdCB8fCB0aW1lID49IGNoaWxkLl9zdGFydCkgJiYgY2hpbGQuX3RzICYmIHBhdXNlVHdlZW4gIT09IGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgIC8vIGFuIGV4dHJlbWUgZWRnZSBjYXNlIC0gdGhlIGNoaWxkJ3MgcmVuZGVyIGNvdWxkIGRvIHNvbWV0aGluZyBsaWtlIGtpbGwoKSB0aGUgXCJuZXh0XCIgb25lIGluIHRoZSBsaW5rZWQgbGlzdCwgb3IgcmVwYXJlbnQgaXQuIEluIHRoYXQgY2FzZSB3ZSBtdXN0IHJlLWluaXRpYXRlIHRoZSB3aG9sZSByZW5kZXIgdG8gYmUgc2FmZS5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucmVuZGVyKGNoaWxkLl90cyA+IDAgPyAodGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgOiAoY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpICsgKHRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXG4gICAgICAgICAgICBpZiAodGltZSAhPT0gdGhpcy5fdGltZSB8fCAhdGhpcy5fdHMgJiYgIXByZXZQYXVzZWQpIHtcbiAgICAgICAgICAgICAgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuICAgICAgICAgICAgICBwYXVzZVR3ZWVuID0gMDtcbiAgICAgICAgICAgICAgbmV4dCAmJiAodFRpbWUgKz0gdGhpcy5felRpbWUgPSAtX3RpbnlOdW0pOyAvLyBpdCBkaWRuJ3QgZmluaXNoIHJlbmRlcmluZywgc28gZmxhZyB6VGltZSBhcyBuZWdhdGl2ZSBzbyB0aGF0IHNvIHRoYXQgdGhlIG5leHQgdGltZSByZW5kZXIoKSBpcyBjYWxsZWQgaXQnbGwgYmUgZm9yY2VkICh0byByZW5kZXIgYW55IHJlbWFpbmluZyBjaGlsZHJlbilcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkID0gdGhpcy5fbGFzdDtcbiAgICAgICAgdmFyIGFkanVzdGVkVGltZSA9IHRvdGFsVGltZSA8IDAgPyB0b3RhbFRpbWUgOiB0aW1lOyAvL3doZW4gdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgYmV5b25kIHRoZSBzdGFydCBvZiB0aGlzIHRpbWVsaW5lLCB3ZSBtdXN0IHBhc3MgdGhhdCBpbmZvcm1hdGlvbiBkb3duIHRvIHRoZSBjaGlsZCBhbmltYXRpb25zIHNvIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMga25vdyB3aGV0aGVyIHRvIHJlbmRlciB0aGVpciBzdGFydGluZyBvciBlbmRpbmcgdmFsdWVzLlxuXG4gICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgIG5leHQgPSBjaGlsZC5fcHJldjtcblxuICAgICAgICAgIGlmICgoY2hpbGQuX2FjdCB8fCBhZGp1c3RlZFRpbWUgPD0gY2hpbGQuX2VuZCkgJiYgY2hpbGQuX3RzICYmIHBhdXNlVHdlZW4gIT09IGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgIC8vIGFuIGV4dHJlbWUgZWRnZSBjYXNlIC0gdGhlIGNoaWxkJ3MgcmVuZGVyIGNvdWxkIGRvIHNvbWV0aGluZyBsaWtlIGtpbGwoKSB0aGUgXCJuZXh0XCIgb25lIGluIHRoZSBsaW5rZWQgbGlzdCwgb3IgcmVwYXJlbnQgaXQuIEluIHRoYXQgY2FzZSB3ZSBtdXN0IHJlLWluaXRpYXRlIHRoZSB3aG9sZSByZW5kZXIgdG8gYmUgc2FmZS5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucmVuZGVyKGNoaWxkLl90cyA+IDAgPyAoYWRqdXN0ZWRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cyA6IChjaGlsZC5fZGlydHkgPyBjaGlsZC50b3RhbER1cmF0aW9uKCkgOiBjaGlsZC5fdER1cikgKyAoYWRqdXN0ZWRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cywgc3VwcHJlc3NFdmVudHMsIGZvcmNlIHx8IF9yZXZlcnRpbmcgJiYgKGNoaWxkLl9pbml0dGVkIHx8IGNoaWxkLl9zdGFydEF0KSk7IC8vIGlmIHJldmVydGluZywgd2Ugc2hvdWxkIGFsd2F5cyBmb3JjZSByZW5kZXJzIG9mIGluaXR0ZWQgdHdlZW5zIChidXQgcmVtZW1iZXIgdGhhdCAuZnJvbVRvKCkgb3IgLmZyb20oKSBtYXkgaGF2ZSBhIF9zdGFydEF0IGJ1dCBub3QgX2luaXR0ZWQgeWV0KS4gSWYsIGZvciBleGFtcGxlLCBhIC5mcm9tVG8oKSB0d2VlbiB3aXRoIGEgc3RhZ2dlciAod2hpY2ggY3JlYXRlcyBhbiBpbnRlcm5hbCB0aW1lbGluZSkgZ2V0cyByZXZlcnRlZCBCRUZPUkUgc29tZSBvZiBpdHMgY2hpbGQgdHdlZW5zIHJlbmRlciBmb3IgdGhlIGZpcnN0IHRpbWUsIGl0IG1heSBub3QgcHJvcGVybHkgdHJpZ2dlciB0aGVtIHRvIHJldmVydC5cblxuICAgICAgICAgICAgaWYgKHRpbWUgIT09IHRoaXMuX3RpbWUgfHwgIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSB7XG4gICAgICAgICAgICAgIC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcbiAgICAgICAgICAgICAgcGF1c2VUd2VlbiA9IDA7XG4gICAgICAgICAgICAgIG5leHQgJiYgKHRUaW1lICs9IHRoaXMuX3pUaW1lID0gYWRqdXN0ZWRUaW1lID8gLV90aW55TnVtIDogX3RpbnlOdW0pOyAvLyBpdCBkaWRuJ3QgZmluaXNoIHJlbmRlcmluZywgc28gYWRqdXN0IHpUaW1lIHNvIHRoYXQgc28gdGhhdCB0aGUgbmV4dCB0aW1lIHJlbmRlcigpIGlzIGNhbGxlZCBpdCdsbCBiZSBmb3JjZWQgKHRvIHJlbmRlciBhbnkgcmVtYWluaW5nIGNoaWxkcmVuKVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoaWxkID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGF1c2VUd2VlbiAmJiAhc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICBwYXVzZVR3ZWVuLnJlbmRlcih0aW1lID49IHByZXZUaW1lID8gMCA6IC1fdGlueU51bSkuX3pUaW1lID0gdGltZSA+PSBwcmV2VGltZSA/IDEgOiAtMTtcblxuICAgICAgICBpZiAodGhpcy5fdHMpIHtcbiAgICAgICAgICAvL3RoZSBjYWxsYmFjayByZXN1bWVkIHBsYXliYWNrISBTbyBzaW5jZSB3ZSBtYXkgaGF2ZSBoZWxkIGJhY2sgdGhlIHBsYXloZWFkIGR1ZSB0byB3aGVyZSB0aGUgcGF1c2UgaXMgcG9zaXRpb25lZCwgZ28gYWhlYWQgYW5kIGp1bXAgdG8gd2hlcmUgaXQncyBTVVBQT1NFRCB0byBiZSAoaWYgbm8gcGF1c2UgaGFwcGVuZWQpLlxuICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gcHJldlN0YXJ0OyAvL2lmIHRoZSBwYXVzZSB3YXMgYXQgYW4gZWFybGllciB0aW1lIGFuZCB0aGUgdXNlciByZXN1bWVkIGluIHRoZSBjYWxsYmFjaywgaXQgY291bGQgcmVwb3NpdGlvbiB0aGUgdGltZWxpbmUgKGNoYW5naW5nIGl0cyBzdGFydFRpbWUpLCB0aHJvd2luZyB0aGluZ3Mgb2ZmIHNsaWdodGx5LCBzbyB3ZSBtYWtlIHN1cmUgdGhlIF9zdGFydCBkb2Vzbid0IHNoaWZ0LlxuXG4gICAgICAgICAgX3NldEVuZCh0aGlzKTtcblxuICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uVXBkYXRlXCIsIHRydWUpO1xuICAgICAgaWYgKHRUaW1lID09PSB0RHVyICYmIHRoaXMuX3RUaW1lID49IHRoaXMudG90YWxEdXJhdGlvbigpIHx8ICF0VGltZSAmJiBwcmV2VGltZSkgaWYgKHByZXZTdGFydCA9PT0gdGhpcy5fc3RhcnQgfHwgTWF0aC5hYnModGltZVNjYWxlKSAhPT0gTWF0aC5hYnModGhpcy5fdHMpKSBpZiAoIXRoaXMuX2xvY2spIHtcbiAgICAgICAgLy8gcmVtZW1iZXIsIGEgY2hpbGQncyBjYWxsYmFjayBtYXkgYWx0ZXIgdGhpcyB0aW1lbGluZSdzIHBsYXloZWFkIG9yIHRpbWVTY2FsZSB3aGljaCBpcyB3aHkgd2UgbmVlZCB0byBhZGQgc29tZSBvZiB0aGVzZSBjaGVja3MuXG4gICAgICAgICh0b3RhbFRpbWUgfHwgIWR1cikgJiYgKHRUaW1lID09PSB0RHVyICYmIHRoaXMuX3RzID4gMCB8fCAhdFRpbWUgJiYgdGhpcy5fdHMgPCAwKSAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0aGlzLCAxKTsgLy8gZG9uJ3QgcmVtb3ZlIGlmIHRoZSB0aW1lbGluZSBpcyByZXZlcnNlZCBhbmQgdGhlIHBsYXloZWFkIGlzbid0IGF0IDAsIG90aGVyd2lzZSB0bC5wcm9ncmVzcygxKS5yZXZlcnNlKCkgd29uJ3Qgd29yay4gT25seSByZW1vdmUgaWYgdGhlIHBsYXloZWFkIGlzIGF0IHRoZSBlbmQgYW5kIHRpbWVTY2FsZSBpcyBwb3NpdGl2ZSwgb3IgaWYgdGhlIHBsYXloZWFkIGlzIGF0IDAgYW5kIHRoZSB0aW1lU2NhbGUgaXMgbmVnYXRpdmUuXG5cbiAgICAgICAgaWYgKCFzdXBwcmVzc0V2ZW50cyAmJiAhKHRvdGFsVGltZSA8IDAgJiYgIXByZXZUaW1lKSAmJiAodFRpbWUgfHwgcHJldlRpbWUgfHwgIXREdXIpKSB7XG4gICAgICAgICAgX2NhbGxiYWNrKHRoaXMsIHRUaW1lID09PSB0RHVyICYmIHRvdGFsVGltZSA+PSAwID8gXCJvbkNvbXBsZXRlXCIgOiBcIm9uUmV2ZXJzZUNvbXBsZXRlXCIsIHRydWUpO1xuXG4gICAgICAgICAgdGhpcy5fcHJvbSAmJiAhKHRUaW1lIDwgdER1ciAmJiB0aGlzLnRpbWVTY2FsZSgpID4gMCkgJiYgdGhpcy5fcHJvbSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGQgPSBmdW5jdGlvbiBhZGQoY2hpbGQsIHBvc2l0aW9uKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBfaXNOdW1iZXIocG9zaXRpb24pIHx8IChwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uLCBjaGlsZCkpO1xuXG4gICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBBbmltYXRpb24pKSB7XG4gICAgICBpZiAoX2lzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuYWRkKG9iaiwgcG9zaXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNTdHJpbmcoY2hpbGQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZExhYmVsKGNoaWxkLCBwb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNGdW5jdGlvbihjaGlsZCkpIHtcbiAgICAgICAgY2hpbGQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcyAhPT0gY2hpbGQgPyBfYWRkVG9UaW1lbGluZSh0aGlzLCBjaGlsZCwgcG9zaXRpb24pIDogdGhpczsgLy9kb24ndCBhbGxvdyBhIHRpbWVsaW5lIHRvIGJlIGFkZGVkIHRvIGl0c2VsZiBhcyBhIGNoaWxkIVxuICB9O1xuXG4gIF9wcm90bzIuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRDaGlsZHJlbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgaWYgKG5lc3RlZCA9PT0gdm9pZCAwKSB7XG4gICAgICBuZXN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0d2VlbnMgPT09IHZvaWQgMCkge1xuICAgICAgdHdlZW5zID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGltZWxpbmVzID09PSB2b2lkIDApIHtcbiAgICAgIHRpbWVsaW5lcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlnbm9yZUJlZm9yZVRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgaWdub3JlQmVmb3JlVGltZSA9IC1fYmlnTnVtO1xuICAgIH1cblxuICAgIHZhciBhID0gW10sXG4gICAgICAgIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5fc3RhcnQgPj0gaWdub3JlQmVmb3JlVGltZSkge1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUd2Vlbikge1xuICAgICAgICAgIHR3ZWVucyAmJiBhLnB1c2goY2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVsaW5lcyAmJiBhLnB1c2goY2hpbGQpO1xuICAgICAgICAgIG5lc3RlZCAmJiBhLnB1c2guYXBwbHkoYSwgY2hpbGQuZ2V0Q2hpbGRyZW4odHJ1ZSwgdHdlZW5zLCB0aW1lbGluZXMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0QnlJZCA9IGZ1bmN0aW9uIGdldEJ5SWQoaWQpIHtcbiAgICB2YXIgYW5pbWF0aW9ucyA9IHRoaXMuZ2V0Q2hpbGRyZW4oMSwgMSwgMSksXG4gICAgICAgIGkgPSBhbmltYXRpb25zLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChhbmltYXRpb25zW2ldLnZhcnMuaWQgPT09IGlkKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRpb25zW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8yLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShjaGlsZCkge1xuICAgIGlmIChfaXNTdHJpbmcoY2hpbGQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmVMYWJlbChjaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKF9pc0Z1bmN0aW9uKGNoaWxkKSkge1xuICAgICAgcmV0dXJuIHRoaXMua2lsbFR3ZWVuc09mKGNoaWxkKTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0odGhpcywgY2hpbGQpO1xuXG4gICAgaWYgKGNoaWxkID09PSB0aGlzLl9yZWNlbnQpIHtcbiAgICAgIHRoaXMuX3JlY2VudCA9IHRoaXMuX2xhc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIudG90YWxUaW1lID0gZnVuY3Rpb24gdG90YWxUaW1lKF90b3RhbFRpbWUyLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RUaW1lO1xuICAgIH1cblxuICAgIHRoaXMuX2ZvcmNpbmcgPSAxO1xuXG4gICAgaWYgKCF0aGlzLl9kcCAmJiB0aGlzLl90cykge1xuICAgICAgLy9zcGVjaWFsIGNhc2UgZm9yIHRoZSBnbG9iYWwgdGltZWxpbmUgKG9yIGFueSBvdGhlciB0aGF0IGhhcyBubyBwYXJlbnQgb3IgZGV0YWNoZWQgcGFyZW50KS5cbiAgICAgIHRoaXMuX3N0YXJ0ID0gX3JvdW5kUHJlY2lzZShfdGlja2VyLnRpbWUgLSAodGhpcy5fdHMgPiAwID8gX3RvdGFsVGltZTIgLyB0aGlzLl90cyA6ICh0aGlzLnRvdGFsRHVyYXRpb24oKSAtIF90b3RhbFRpbWUyKSAvIC10aGlzLl90cykpO1xuICAgIH1cblxuICAgIF9BbmltYXRpb24ucHJvdG90eXBlLnRvdGFsVGltZS5jYWxsKHRoaXMsIF90b3RhbFRpbWUyLCBzdXBwcmVzc0V2ZW50cyk7XG5cbiAgICB0aGlzLl9mb3JjaW5nID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmFkZExhYmVsID0gZnVuY3Rpb24gYWRkTGFiZWwobGFiZWwsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5sYWJlbHNbbGFiZWxdID0gX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIucmVtb3ZlTGFiZWwgPSBmdW5jdGlvbiByZW1vdmVMYWJlbChsYWJlbCkge1xuICAgIGRlbGV0ZSB0aGlzLmxhYmVsc1tsYWJlbF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGRQYXVzZSA9IGZ1bmN0aW9uIGFkZFBhdXNlKHBvc2l0aW9uLCBjYWxsYmFjaywgcGFyYW1zKSB7XG4gICAgdmFyIHQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjayB8fCBfZW1wdHlGdW5jLCBwYXJhbXMpO1xuICAgIHQuZGF0YSA9IFwiaXNQYXVzZVwiO1xuICAgIHRoaXMuX2hhc1BhdXNlID0gMTtcbiAgICByZXR1cm4gX2FkZFRvVGltZWxpbmUodGhpcywgdCwgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pKTtcbiAgfTtcblxuICBfcHJvdG8yLnJlbW92ZVBhdXNlID0gZnVuY3Rpb24gcmVtb3ZlUGF1c2UocG9zaXRpb24pIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdDtcbiAgICBwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLl9zdGFydCA9PT0gcG9zaXRpb24gJiYgY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIpIHtcbiAgICAgICAgX3JlbW92ZUZyb21QYXJlbnQoY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8yLmtpbGxUd2VlbnNPZiA9IGZ1bmN0aW9uIGtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSkge1xuICAgIHZhciB0d2VlbnMgPSB0aGlzLmdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpLFxuICAgICAgICBpID0gdHdlZW5zLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuICE9PSB0d2VlbnNbaV0gJiYgdHdlZW5zW2ldLmtpbGwodGFyZ2V0cywgcHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0VHdlZW5zT2YgPSBmdW5jdGlvbiBnZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSB7XG4gICAgdmFyIGEgPSBbXSxcbiAgICAgICAgcGFyc2VkVGFyZ2V0cyA9IHRvQXJyYXkodGFyZ2V0cyksXG4gICAgICAgIGNoaWxkID0gdGhpcy5fZmlyc3QsXG4gICAgICAgIGlzR2xvYmFsVGltZSA9IF9pc051bWJlcihvbmx5QWN0aXZlKSxcbiAgICAgICAgLy8gYSBudW1iZXIgaXMgaW50ZXJwcmV0ZWQgYXMgYSBnbG9iYWwgdGltZS4gSWYgdGhlIGFuaW1hdGlvbiBzcGFuc1xuICAgIGNoaWxkcmVuO1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUd2Vlbikge1xuICAgICAgICBpZiAoX2FycmF5Q29udGFpbnNBbnkoY2hpbGQuX3RhcmdldHMsIHBhcnNlZFRhcmdldHMpICYmIChpc0dsb2JhbFRpbWUgPyAoIV9vdmVyd3JpdGluZ1R3ZWVuIHx8IGNoaWxkLl9pbml0dGVkICYmIGNoaWxkLl90cykgJiYgY2hpbGQuZ2xvYmFsVGltZSgwKSA8PSBvbmx5QWN0aXZlICYmIGNoaWxkLmdsb2JhbFRpbWUoY2hpbGQudG90YWxEdXJhdGlvbigpKSA+IG9ubHlBY3RpdmUgOiAhb25seUFjdGl2ZSB8fCBjaGlsZC5pc0FjdGl2ZSgpKSkge1xuICAgICAgICAgIC8vIG5vdGU6IGlmIHRoaXMgaXMgZm9yIG92ZXJ3cml0aW5nLCBpdCBzaG91bGQgb25seSBiZSBmb3IgdHdlZW5zIHRoYXQgYXJlbid0IHBhdXNlZCBhbmQgYXJlIGluaXR0ZWQuXG4gICAgICAgICAgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoY2hpbGRyZW4gPSBjaGlsZC5nZXRUd2VlbnNPZihwYXJzZWRUYXJnZXRzLCBvbmx5QWN0aXZlKSkubGVuZ3RoKSB7XG4gICAgICAgIGEucHVzaC5hcHBseShhLCBjaGlsZHJlbik7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH0gLy8gcG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlIC0gdGFyZ2V0cygpIG9uIHRpbWVsaW5lc1xuICAvLyB0YXJnZXRzKCkge1xuICAvLyBcdGxldCByZXN1bHQgPSBbXTtcbiAgLy8gXHR0aGlzLmdldENoaWxkcmVuKHRydWUsIHRydWUsIGZhbHNlKS5mb3JFYWNoKHQgPT4gcmVzdWx0LnB1c2goLi4udC50YXJnZXRzKCkpKTtcbiAgLy8gXHRyZXR1cm4gcmVzdWx0LmZpbHRlcigodiwgaSkgPT4gcmVzdWx0LmluZGV4T2YodikgPT09IGkpO1xuICAvLyB9XG4gIDtcblxuICBfcHJvdG8yLnR3ZWVuVG8gPSBmdW5jdGlvbiB0d2VlblRvKHBvc2l0aW9uLCB2YXJzKSB7XG4gICAgdmFycyA9IHZhcnMgfHwge307XG5cbiAgICB2YXIgdGwgPSB0aGlzLFxuICAgICAgICBlbmRUaW1lID0gX3BhcnNlUG9zaXRpb24odGwsIHBvc2l0aW9uKSxcbiAgICAgICAgX3ZhcnMgPSB2YXJzLFxuICAgICAgICBzdGFydEF0ID0gX3ZhcnMuc3RhcnRBdCxcbiAgICAgICAgX29uU3RhcnQgPSBfdmFycy5vblN0YXJ0LFxuICAgICAgICBvblN0YXJ0UGFyYW1zID0gX3ZhcnMub25TdGFydFBhcmFtcyxcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyID0gX3ZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICBpbml0dGVkLFxuICAgICAgICB0d2VlbiA9IFR3ZWVuLnRvKHRsLCBfc2V0RGVmYXVsdHMoe1xuICAgICAgZWFzZTogdmFycy5lYXNlIHx8IFwibm9uZVwiLFxuICAgICAgbGF6eTogZmFsc2UsXG4gICAgICBpbW1lZGlhdGVSZW5kZXI6IGZhbHNlLFxuICAgICAgdGltZTogZW5kVGltZSxcbiAgICAgIG92ZXJ3cml0ZTogXCJhdXRvXCIsXG4gICAgICBkdXJhdGlvbjogdmFycy5kdXJhdGlvbiB8fCBNYXRoLmFicygoZW5kVGltZSAtIChzdGFydEF0ICYmIFwidGltZVwiIGluIHN0YXJ0QXQgPyBzdGFydEF0LnRpbWUgOiB0bC5fdGltZSkpIC8gdGwudGltZVNjYWxlKCkpIHx8IF90aW55TnVtLFxuICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHtcbiAgICAgICAgdGwucGF1c2UoKTtcblxuICAgICAgICBpZiAoIWluaXR0ZWQpIHtcbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSB2YXJzLmR1cmF0aW9uIHx8IE1hdGguYWJzKChlbmRUaW1lIC0gKHN0YXJ0QXQgJiYgXCJ0aW1lXCIgaW4gc3RhcnRBdCA/IHN0YXJ0QXQudGltZSA6IHRsLl90aW1lKSkgLyB0bC50aW1lU2NhbGUoKSk7XG4gICAgICAgICAgdHdlZW4uX2R1ciAhPT0gZHVyYXRpb24gJiYgX3NldER1cmF0aW9uKHR3ZWVuLCBkdXJhdGlvbiwgMCwgMSkucmVuZGVyKHR3ZWVuLl90aW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBpbml0dGVkID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9vblN0YXJ0ICYmIF9vblN0YXJ0LmFwcGx5KHR3ZWVuLCBvblN0YXJ0UGFyYW1zIHx8IFtdKTsgLy9pbiBjYXNlIHRoZSB1c2VyIGhhZCBhbiBvblN0YXJ0IGluIHRoZSB2YXJzIC0gd2UgZG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgaXQuXG4gICAgICB9XG4gICAgfSwgdmFycykpO1xuXG4gICAgcmV0dXJuIGltbWVkaWF0ZVJlbmRlciA/IHR3ZWVuLnJlbmRlcigwKSA6IHR3ZWVuO1xuICB9O1xuXG4gIF9wcm90bzIudHdlZW5Gcm9tVG8gPSBmdW5jdGlvbiB0d2VlbkZyb21Ubyhmcm9tUG9zaXRpb24sIHRvUG9zaXRpb24sIHZhcnMpIHtcbiAgICByZXR1cm4gdGhpcy50d2VlblRvKHRvUG9zaXRpb24sIF9zZXREZWZhdWx0cyh7XG4gICAgICBzdGFydEF0OiB7XG4gICAgICAgIHRpbWU6IF9wYXJzZVBvc2l0aW9uKHRoaXMsIGZyb21Qb3NpdGlvbilcbiAgICAgIH1cbiAgICB9LCB2YXJzKSk7XG4gIH07XG5cbiAgX3Byb3RvMi5yZWNlbnQgPSBmdW5jdGlvbiByZWNlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlY2VudDtcbiAgfTtcblxuICBfcHJvdG8yLm5leHRMYWJlbCA9IGZ1bmN0aW9uIG5leHRMYWJlbChhZnRlclRpbWUpIHtcbiAgICBpZiAoYWZ0ZXJUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGFmdGVyVGltZSA9IHRoaXMuX3RpbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXRMYWJlbEluRGlyZWN0aW9uKHRoaXMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIGFmdGVyVGltZSkpO1xuICB9O1xuXG4gIF9wcm90bzIucHJldmlvdXNMYWJlbCA9IGZ1bmN0aW9uIHByZXZpb3VzTGFiZWwoYmVmb3JlVGltZSkge1xuICAgIGlmIChiZWZvcmVUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGJlZm9yZVRpbWUgPSB0aGlzLl90aW1lO1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0TGFiZWxJbkRpcmVjdGlvbih0aGlzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBiZWZvcmVUaW1lKSwgMSk7XG4gIH07XG5cbiAgX3Byb3RvMi5jdXJyZW50TGFiZWwgPSBmdW5jdGlvbiBjdXJyZW50TGFiZWwodmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuc2Vlayh2YWx1ZSwgdHJ1ZSkgOiB0aGlzLnByZXZpb3VzTGFiZWwodGhpcy5fdGltZSArIF90aW55TnVtKTtcbiAgfTtcblxuICBfcHJvdG8yLnNoaWZ0Q2hpbGRyZW4gPSBmdW5jdGlvbiBzaGlmdENoaWxkcmVuKGFtb3VudCwgYWRqdXN0TGFiZWxzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgaWYgKGlnbm9yZUJlZm9yZVRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgaWdub3JlQmVmb3JlVGltZSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3QsXG4gICAgICAgIGxhYmVscyA9IHRoaXMubGFiZWxzLFxuICAgICAgICBwO1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuX3N0YXJ0ID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgICAgY2hpbGQuX3N0YXJ0ICs9IGFtb3VudDtcbiAgICAgICAgY2hpbGQuX2VuZCArPSBhbW91bnQ7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgaWYgKGFkanVzdExhYmVscykge1xuICAgICAgZm9yIChwIGluIGxhYmVscykge1xuICAgICAgICBpZiAobGFiZWxzW3BdID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgICAgICBsYWJlbHNbcF0gKz0gYW1vdW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uIGludmFsaWRhdGUoc29mdCkge1xuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuICAgIHRoaXMuX2xvY2sgPSAwO1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBjaGlsZC5pbnZhbGlkYXRlKHNvZnQpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gX0FuaW1hdGlvbi5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMsIHNvZnQpO1xuICB9O1xuXG4gIF9wcm90bzIuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcihpbmNsdWRlTGFiZWxzKSB7XG4gICAgaWYgKGluY2x1ZGVMYWJlbHMgPT09IHZvaWQgMCkge1xuICAgICAgaW5jbHVkZUxhYmVscyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3QsXG4gICAgICAgIG5leHQ7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIG5leHQgPSBjaGlsZC5fbmV4dDtcbiAgICAgIHRoaXMucmVtb3ZlKGNoaWxkKTtcbiAgICAgIGNoaWxkID0gbmV4dDtcbiAgICB9XG5cbiAgICB0aGlzLl9kcCAmJiAodGhpcy5fdGltZSA9IHRoaXMuX3RUaW1lID0gdGhpcy5fcFRpbWUgPSAwKTtcbiAgICBpbmNsdWRlTGFiZWxzICYmICh0aGlzLmxhYmVscyA9IHt9KTtcbiAgICByZXR1cm4gX3VuY2FjaGUodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvMi50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24gdG90YWxEdXJhdGlvbih2YWx1ZSkge1xuICAgIHZhciBtYXggPSAwLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgY2hpbGQgPSBzZWxmLl9sYXN0LFxuICAgICAgICBwcmV2U3RhcnQgPSBfYmlnTnVtLFxuICAgICAgICBwcmV2LFxuICAgICAgICBzdGFydCxcbiAgICAgICAgcGFyZW50O1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBzZWxmLnRpbWVTY2FsZSgoc2VsZi5fcmVwZWF0IDwgMCA/IHNlbGYuZHVyYXRpb24oKSA6IHNlbGYudG90YWxEdXJhdGlvbigpKSAvIChzZWxmLnJldmVyc2VkKCkgPyAtdmFsdWUgOiB2YWx1ZSkpO1xuICAgIH1cblxuICAgIGlmIChzZWxmLl9kaXJ0eSkge1xuICAgICAgcGFyZW50ID0gc2VsZi5wYXJlbnQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBwcmV2ID0gY2hpbGQuX3ByZXY7IC8vcmVjb3JkIGl0IGhlcmUgaW4gY2FzZSB0aGUgdHdlZW4gY2hhbmdlcyBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2UuLi5cblxuICAgICAgICBjaGlsZC5fZGlydHkgJiYgY2hpbGQudG90YWxEdXJhdGlvbigpOyAvL2NvdWxkIGNoYW5nZSB0aGUgdHdlZW4uX3N0YXJ0VGltZSwgc28gbWFrZSBzdXJlIHRoZSBhbmltYXRpb24ncyBjYWNoZSBpcyBjbGVhbiBiZWZvcmUgYW5hbHl6aW5nIGl0LlxuXG4gICAgICAgIHN0YXJ0ID0gY2hpbGQuX3N0YXJ0O1xuXG4gICAgICAgIGlmIChzdGFydCA+IHByZXZTdGFydCAmJiBzZWxmLl9zb3J0ICYmIGNoaWxkLl90cyAmJiAhc2VsZi5fbG9jaykge1xuICAgICAgICAgIC8vaW4gY2FzZSBvbmUgb2YgdGhlIHR3ZWVucyBzaGlmdGVkIG91dCBvZiBvcmRlciwgaXQgbmVlZHMgdG8gYmUgcmUtaW5zZXJ0ZWQgaW50byB0aGUgY29ycmVjdCBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2VcbiAgICAgICAgICBzZWxmLl9sb2NrID0gMTsgLy9wcmV2ZW50IGVuZGxlc3MgcmVjdXJzaXZlIGNhbGxzIC0gdGhlcmUgYXJlIG1ldGhvZHMgdGhhdCBnZXQgdHJpZ2dlcmVkIHRoYXQgY2hlY2sgZHVyYXRpb24vdG90YWxEdXJhdGlvbiB3aGVuIHdlIGFkZCgpLlxuXG4gICAgICAgICAgX2FkZFRvVGltZWxpbmUoc2VsZiwgY2hpbGQsIHN0YXJ0IC0gY2hpbGQuX2RlbGF5LCAxKS5fbG9jayA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldlN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnQgPCAwICYmIGNoaWxkLl90cykge1xuICAgICAgICAgIC8vY2hpbGRyZW4gYXJlbid0IGFsbG93ZWQgdG8gaGF2ZSBuZWdhdGl2ZSBzdGFydFRpbWVzIHVubGVzcyBzbW9vdGhDaGlsZFRpbWluZyBpcyB0cnVlLCBzbyBhZGp1c3QgaGVyZSBpZiBvbmUgaXMgZm91bmQuXG4gICAgICAgICAgbWF4IC09IHN0YXJ0O1xuXG4gICAgICAgICAgaWYgKCFwYXJlbnQgJiYgIXNlbGYuX2RwIHx8IHBhcmVudCAmJiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcpIHtcbiAgICAgICAgICAgIHNlbGYuX3N0YXJ0ICs9IHN0YXJ0IC8gc2VsZi5fdHM7XG4gICAgICAgICAgICBzZWxmLl90aW1lIC09IHN0YXJ0O1xuICAgICAgICAgICAgc2VsZi5fdFRpbWUgLT0gc3RhcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5zaGlmdENoaWxkcmVuKC1zdGFydCwgZmFsc2UsIC0xZTk5OSk7XG4gICAgICAgICAgcHJldlN0YXJ0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkLl9lbmQgPiBtYXggJiYgY2hpbGQuX3RzICYmIChtYXggPSBjaGlsZC5fZW5kKTtcbiAgICAgICAgY2hpbGQgPSBwcmV2O1xuICAgICAgfVxuXG4gICAgICBfc2V0RHVyYXRpb24oc2VsZiwgc2VsZiA9PT0gX2dsb2JhbFRpbWVsaW5lICYmIHNlbGYuX3RpbWUgPiBtYXggPyBzZWxmLl90aW1lIDogbWF4LCAxLCAxKTtcblxuICAgICAgc2VsZi5fZGlydHkgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmLl90RHVyO1xuICB9O1xuXG4gIFRpbWVsaW5lLnVwZGF0ZVJvb3QgPSBmdW5jdGlvbiB1cGRhdGVSb290KHRpbWUpIHtcbiAgICBpZiAoX2dsb2JhbFRpbWVsaW5lLl90cykge1xuICAgICAgX2xhenlTYWZlUmVuZGVyKF9nbG9iYWxUaW1lbGluZSwgX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUodGltZSwgX2dsb2JhbFRpbWVsaW5lKSk7XG5cbiAgICAgIF9sYXN0UmVuZGVyZWRGcmFtZSA9IF90aWNrZXIuZnJhbWU7XG4gICAgfVxuXG4gICAgaWYgKF90aWNrZXIuZnJhbWUgPj0gX25leHRHQ0ZyYW1lKSB7XG4gICAgICBfbmV4dEdDRnJhbWUgKz0gX2NvbmZpZy5hdXRvU2xlZXAgfHwgMTIwO1xuICAgICAgdmFyIGNoaWxkID0gX2dsb2JhbFRpbWVsaW5lLl9maXJzdDtcbiAgICAgIGlmICghY2hpbGQgfHwgIWNoaWxkLl90cykgaWYgKF9jb25maWcuYXV0b1NsZWVwICYmIF90aWNrZXIuX2xpc3RlbmVycy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHdoaWxlIChjaGlsZCAmJiAhY2hpbGQuX3RzKSB7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkIHx8IF90aWNrZXIuc2xlZXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRpbWVsaW5lO1xufShBbmltYXRpb24pO1xuXG5fc2V0RGVmYXVsdHMoVGltZWxpbmUucHJvdG90eXBlLCB7XG4gIF9sb2NrOiAwLFxuICBfaGFzUGF1c2U6IDAsXG4gIF9mb3JjaW5nOiAwXG59KTtcblxudmFyIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBzZXR0ZXIsIHN0cmluZ0ZpbHRlciwgZnVuY1BhcmFtKSB7XG4gIC8vbm90ZTogd2UgY2FsbCBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHR3ZWVuSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cbiAgdmFyIHB0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LCBwcm9wLCAwLCAxLCBfcmVuZGVyQ29tcGxleFN0cmluZywgbnVsbCwgc2V0dGVyKSxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIG1hdGNoSW5kZXggPSAwLFxuICAgICAgcmVzdWx0LFxuICAgICAgc3RhcnROdW1zLFxuICAgICAgY29sb3IsXG4gICAgICBlbmROdW0sXG4gICAgICBjaHVuayxcbiAgICAgIHN0YXJ0TnVtLFxuICAgICAgaGFzUmFuZG9tLFxuICAgICAgYTtcbiAgcHQuYiA9IHN0YXJ0O1xuICBwdC5lID0gZW5kO1xuICBzdGFydCArPSBcIlwiOyAvL2Vuc3VyZSB2YWx1ZXMgYXJlIHN0cmluZ3NcblxuICBlbmQgKz0gXCJcIjtcblxuICBpZiAoaGFzUmFuZG9tID0gfmVuZC5pbmRleE9mKFwicmFuZG9tKFwiKSkge1xuICAgIGVuZCA9IF9yZXBsYWNlUmFuZG9tKGVuZCk7XG4gIH1cblxuICBpZiAoc3RyaW5nRmlsdGVyKSB7XG4gICAgYSA9IFtzdGFydCwgZW5kXTtcbiAgICBzdHJpbmdGaWx0ZXIoYSwgdGFyZ2V0LCBwcm9wKTsgLy9wYXNzIGFuIGFycmF5IHdpdGggdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgdmFsdWVzIGFuZCBsZXQgdGhlIGZpbHRlciBkbyB3aGF0ZXZlciBpdCBuZWVkcyB0byB0aGUgdmFsdWVzLlxuXG4gICAgc3RhcnQgPSBhWzBdO1xuICAgIGVuZCA9IGFbMV07XG4gIH1cblxuICBzdGFydE51bXMgPSBzdGFydC5tYXRjaChfY29tcGxleFN0cmluZ051bUV4cCkgfHwgW107XG5cbiAgd2hpbGUgKHJlc3VsdCA9IF9jb21wbGV4U3RyaW5nTnVtRXhwLmV4ZWMoZW5kKSkge1xuICAgIGVuZE51bSA9IHJlc3VsdFswXTtcbiAgICBjaHVuayA9IGVuZC5zdWJzdHJpbmcoaW5kZXgsIHJlc3VsdC5pbmRleCk7XG5cbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGNvbG9yID0gKGNvbG9yICsgMSkgJSA1O1xuICAgIH0gZWxzZSBpZiAoY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJyZ2JhKFwiKSB7XG4gICAgICBjb2xvciA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGVuZE51bSAhPT0gc3RhcnROdW1zW21hdGNoSW5kZXgrK10pIHtcbiAgICAgIHN0YXJ0TnVtID0gcGFyc2VGbG9hdChzdGFydE51bXNbbWF0Y2hJbmRleCAtIDFdKSB8fCAwOyAvL3RoZXNlIG5lc3RlZCBQcm9wVHdlZW5zIGFyZSBoYW5kbGVkIGluIGEgc3BlY2lhbCB3YXkgLSB3ZSdsbCBuZXZlciBhY3R1YWxseSBjYWxsIGEgcmVuZGVyIG9yIHNldHRlciBtZXRob2Qgb24gdGhlbS4gV2UnbGwganVzdCBsb29wIHRocm91Z2ggdGhlbSBpbiB0aGUgcGFyZW50IGNvbXBsZXggc3RyaW5nIFByb3BUd2VlbidzIHJlbmRlciBtZXRob2QuXG5cbiAgICAgIHB0Ll9wdCA9IHtcbiAgICAgICAgX25leHQ6IHB0Ll9wdCxcbiAgICAgICAgcDogY2h1bmsgfHwgbWF0Y2hJbmRleCA9PT0gMSA/IGNodW5rIDogXCIsXCIsXG4gICAgICAgIC8vbm90ZTogU1ZHIHNwZWMgYWxsb3dzIG9taXNzaW9uIG9mIGNvbW1hL3NwYWNlIHdoZW4gYSBuZWdhdGl2ZSBzaWduIGlzIHdlZGdlZCBiZXR3ZWVuIHR3byBudW1iZXJzLCBsaWtlIDIuNS01LjMgaW5zdGVhZCBvZiAyLjUsLTUuMyBidXQgd2hlbiB0d2VlbmluZywgdGhlIG5lZ2F0aXZlIHZhbHVlIG1heSBzd2l0Y2ggdG8gcG9zaXRpdmUsIHNvIHdlIGluc2VydCB0aGUgY29tbWEganVzdCBpbiBjYXNlLlxuICAgICAgICBzOiBzdGFydE51bSxcbiAgICAgICAgYzogZW5kTnVtLmNoYXJBdCgxKSA9PT0gXCI9XCIgPyBfcGFyc2VSZWxhdGl2ZShzdGFydE51bSwgZW5kTnVtKSAtIHN0YXJ0TnVtIDogcGFyc2VGbG9hdChlbmROdW0pIC0gc3RhcnROdW0sXG4gICAgICAgIG06IGNvbG9yICYmIGNvbG9yIDwgNCA/IE1hdGgucm91bmQgOiAwXG4gICAgICB9O1xuICAgICAgaW5kZXggPSBfY29tcGxleFN0cmluZ051bUV4cC5sYXN0SW5kZXg7XG4gICAgfVxuICB9XG5cbiAgcHQuYyA9IGluZGV4IDwgZW5kLmxlbmd0aCA/IGVuZC5zdWJzdHJpbmcoaW5kZXgsIGVuZC5sZW5ndGgpIDogXCJcIjsgLy93ZSB1c2UgdGhlIFwiY1wiIG9mIHRoZSBQcm9wVHdlZW4gdG8gc3RvcmUgdGhlIGZpbmFsIHBhcnQgb2YgdGhlIHN0cmluZyAoYWZ0ZXIgdGhlIGxhc3QgbnVtYmVyKVxuXG4gIHB0LmZwID0gZnVuY1BhcmFtO1xuXG4gIGlmIChfcmVsRXhwLnRlc3QoZW5kKSB8fCBoYXNSYW5kb20pIHtcbiAgICBwdC5lID0gMDsgLy9pZiB0aGUgZW5kIHN0cmluZyBjb250YWlucyByZWxhdGl2ZSB2YWx1ZXMgb3IgZHluYW1pYyByYW5kb20oLi4uKSB2YWx1ZXMsIGRlbGV0ZSB0aGUgZW5kIGl0IHNvIHRoYXQgb24gdGhlIGZpbmFsIHJlbmRlciB3ZSBkb24ndCBhY3R1YWxseSBzZXQgaXQgdG8gdGhlIHN0cmluZyB3aXRoICs9IG9yIC09IGNoYXJhY3RlcnMgKGZvcmNlcyBpdCB0byB1c2UgdGhlIGNhbGN1bGF0ZWQgdmFsdWUpLlxuICB9XG5cbiAgdGhpcy5fcHQgPSBwdDsgLy9zdGFydCB0aGUgbGlua2VkIGxpc3Qgd2l0aCB0aGlzIG5ldyBQcm9wVHdlZW4uIFJlbWVtYmVyLCB3ZSBjYWxsIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuLmNhbGwodHdlZW5JbnN0YW5jZS4uLikgdG8gZW5zdXJlIHRoYXQgaXQncyBzY29wZWQgcHJvcGVybHkuIFdlIG1heSBjYWxsIGl0IGZyb20gd2l0aGluIGEgcGx1Z2luIHRvbywgdGh1cyBcInRoaXNcIiB3b3VsZCByZWZlciB0byB0aGUgcGx1Z2luLlxuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX2FkZFByb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGRQcm9wVHdlZW4odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBpbmRleCwgdGFyZ2V0cywgbW9kaWZpZXIsIHN0cmluZ0ZpbHRlciwgZnVuY1BhcmFtLCBvcHRpb25hbCkge1xuICBfaXNGdW5jdGlvbihlbmQpICYmIChlbmQgPSBlbmQoaW5kZXggfHwgMCwgdGFyZ2V0LCB0YXJnZXRzKSk7XG4gIHZhciBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcHJvcF0sXG4gICAgICBwYXJzZWRTdGFydCA9IHN0YXJ0ICE9PSBcImdldFwiID8gc3RhcnQgOiAhX2lzRnVuY3Rpb24oY3VycmVudFZhbHVlKSA/IGN1cnJlbnRWYWx1ZSA6IGZ1bmNQYXJhbSA/IHRhcmdldFtwcm9wLmluZGV4T2YoXCJzZXRcIikgfHwgIV9pc0Z1bmN0aW9uKHRhcmdldFtcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKSA/IHByb3AgOiBcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKGZ1bmNQYXJhbSkgOiB0YXJnZXRbcHJvcF0oKSxcbiAgICAgIHNldHRlciA9ICFfaXNGdW5jdGlvbihjdXJyZW50VmFsdWUpID8gX3NldHRlclBsYWluIDogZnVuY1BhcmFtID8gX3NldHRlckZ1bmNXaXRoUGFyYW0gOiBfc2V0dGVyRnVuYyxcbiAgICAgIHB0O1xuXG4gIGlmIChfaXNTdHJpbmcoZW5kKSkge1xuICAgIGlmICh+ZW5kLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG4gICAgICBlbmQgPSBfcmVwbGFjZVJhbmRvbShlbmQpO1xuICAgIH1cblxuICAgIGlmIChlbmQuY2hhckF0KDEpID09PSBcIj1cIikge1xuICAgICAgcHQgPSBfcGFyc2VSZWxhdGl2ZShwYXJzZWRTdGFydCwgZW5kKSArIChnZXRVbml0KHBhcnNlZFN0YXJ0KSB8fCAwKTtcblxuICAgICAgaWYgKHB0IHx8IHB0ID09PSAwKSB7XG4gICAgICAgIC8vIHRvIGF2b2lkIGlzTmFOLCBsaWtlIGlmIHNvbWVvbmUgcGFzc2VzIGluIGEgdmFsdWUgbGlrZSBcIiE9IHdoYXRldmVyXCJcbiAgICAgICAgZW5kID0gcHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFvcHRpb25hbCB8fCBwYXJzZWRTdGFydCAhPT0gZW5kIHx8IF9mb3JjZUFsbFByb3BUd2VlbnMpIHtcbiAgICBpZiAoIWlzTmFOKHBhcnNlZFN0YXJ0ICogZW5kKSAmJiBlbmQgIT09IFwiXCIpIHtcbiAgICAgIC8vIGZ1biBmYWN0OiBhbnkgbnVtYmVyIG11bHRpcGxpZWQgYnkgXCJcIiBpcyBldmFsdWF0ZWQgYXMgdGhlIG51bWJlciAwIVxuICAgICAgcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCB0YXJnZXQsIHByb3AsICtwYXJzZWRTdGFydCB8fCAwLCBlbmQgLSAocGFyc2VkU3RhcnQgfHwgMCksIHR5cGVvZiBjdXJyZW50VmFsdWUgPT09IFwiYm9vbGVhblwiID8gX3JlbmRlckJvb2xlYW4gOiBfcmVuZGVyUGxhaW4sIDAsIHNldHRlcik7XG4gICAgICBmdW5jUGFyYW0gJiYgKHB0LmZwID0gZnVuY1BhcmFtKTtcbiAgICAgIG1vZGlmaWVyICYmIHB0Lm1vZGlmaWVyKG1vZGlmaWVyLCB0aGlzLCB0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRoaXMuX3B0ID0gcHQ7XG4gICAgfVxuXG4gICAgIWN1cnJlbnRWYWx1ZSAmJiAhKHByb3AgaW4gdGFyZ2V0KSAmJiBfbWlzc2luZ1BsdWdpbihwcm9wLCBlbmQpO1xuICAgIHJldHVybiBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHRoaXMsIHRhcmdldCwgcHJvcCwgcGFyc2VkU3RhcnQsIGVuZCwgc2V0dGVyLCBzdHJpbmdGaWx0ZXIgfHwgX2NvbmZpZy5zdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSk7XG4gIH1cbn0sXG4gICAgLy9jcmVhdGVzIGEgY29weSBvZiB0aGUgdmFycyBvYmplY3QgYW5kIHByb2Nlc3NlcyBhbnkgZnVuY3Rpb24tYmFzZWQgdmFsdWVzIChwdXR0aW5nIHRoZSByZXN1bHRpbmcgdmFsdWVzIGRpcmVjdGx5IGludG8gdGhlIGNvcHkpIGFzIHdlbGwgYXMgc3RyaW5ncyB3aXRoIFwicmFuZG9tKClcIiBpbiB0aGVtLiBJdCBkb2VzIE5PVCBwcm9jZXNzIHJlbGF0aXZlIHZhbHVlcy5cbl9wcm9jZXNzVmFycyA9IGZ1bmN0aW9uIF9wcm9jZXNzVmFycyh2YXJzLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzLCB0d2Vlbikge1xuICBfaXNGdW5jdGlvbih2YXJzKSAmJiAodmFycyA9IF9wYXJzZUZ1bmNPclN0cmluZyh2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykpO1xuXG4gIGlmICghX2lzT2JqZWN0KHZhcnMpIHx8IHZhcnMuc3R5bGUgJiYgdmFycy5ub2RlVHlwZSB8fCBfaXNBcnJheSh2YXJzKSB8fCBfaXNUeXBlZEFycmF5KHZhcnMpKSB7XG4gICAgcmV0dXJuIF9pc1N0cmluZyh2YXJzKSA/IF9wYXJzZUZ1bmNPclN0cmluZyh2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykgOiB2YXJzO1xuICB9XG5cbiAgdmFyIGNvcHkgPSB7fSxcbiAgICAgIHA7XG5cbiAgZm9yIChwIGluIHZhcnMpIHtcbiAgICBjb3B5W3BdID0gX3BhcnNlRnVuY09yU3RyaW5nKHZhcnNbcF0sIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKTtcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICBfY2hlY2tQbHVnaW4gPSBmdW5jdGlvbiBfY2hlY2tQbHVnaW4ocHJvcGVydHksIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSB7XG4gIHZhciBwbHVnaW4sIHB0LCBwdExvb2t1cCwgaTtcblxuICBpZiAoX3BsdWdpbnNbcHJvcGVydHldICYmIChwbHVnaW4gPSBuZXcgX3BsdWdpbnNbcHJvcGVydHldKCkpLmluaXQodGFyZ2V0LCBwbHVnaW4ucmF3VmFycyA/IHZhcnNbcHJvcGVydHldIDogX3Byb2Nlc3NWYXJzKHZhcnNbcHJvcGVydHldLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzLCB0d2VlbiksIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykgIT09IGZhbHNlKSB7XG4gICAgdHdlZW4uX3B0ID0gcHQgPSBuZXcgUHJvcFR3ZWVuKHR3ZWVuLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgMCwgMSwgcGx1Z2luLnJlbmRlciwgcGx1Z2luLCAwLCBwbHVnaW4ucHJpb3JpdHkpO1xuXG4gICAgaWYgKHR3ZWVuICE9PSBfcXVpY2tUd2Vlbikge1xuICAgICAgcHRMb29rdXAgPSB0d2Vlbi5fcHRMb29rdXBbdHdlZW4uX3RhcmdldHMuaW5kZXhPZih0YXJnZXQpXTsgLy9ub3RlOiB3ZSBjYW4ndCB1c2UgdHdlZW4uX3B0TG9va3VwW2luZGV4XSBiZWNhdXNlIGZvciBzdGFnZ2VyZWQgdHdlZW5zLCB0aGUgaW5kZXggZnJvbSB0aGUgZnVsbFRhcmdldHMgYXJyYXkgd29uJ3QgbWF0Y2ggd2hhdCBpdCBpcyBpbiBlYWNoIGluZGl2aWR1YWwgdHdlZW4gdGhhdCBzcGF3bnMgZnJvbSB0aGUgc3RhZ2dlci5cblxuICAgICAgaSA9IHBsdWdpbi5fcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHB0TG9va3VwW3BsdWdpbi5fcHJvcHNbaV1dID0gcHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBsdWdpbjtcbn0sXG4gICAgX292ZXJ3cml0aW5nVHdlZW4sXG4gICAgLy9zdG9yZSBhIHJlZmVyZW5jZSB0ZW1wb3JhcmlseSBzbyB3ZSBjYW4gYXZvaWQgb3ZlcndyaXRpbmcgaXRzZWxmLlxuX2ZvcmNlQWxsUHJvcFR3ZWVucyxcbiAgICBfaW5pdFR3ZWVuID0gZnVuY3Rpb24gX2luaXRUd2Vlbih0d2VlbiwgdGltZSwgdFRpbWUpIHtcbiAgdmFyIHZhcnMgPSB0d2Vlbi52YXJzLFxuICAgICAgZWFzZSA9IHZhcnMuZWFzZSxcbiAgICAgIHN0YXJ0QXQgPSB2YXJzLnN0YXJ0QXQsXG4gICAgICBpbW1lZGlhdGVSZW5kZXIgPSB2YXJzLmltbWVkaWF0ZVJlbmRlcixcbiAgICAgIGxhenkgPSB2YXJzLmxhenksXG4gICAgICBvblVwZGF0ZSA9IHZhcnMub25VcGRhdGUsXG4gICAgICBydW5CYWNrd2FyZHMgPSB2YXJzLnJ1bkJhY2t3YXJkcyxcbiAgICAgIHlveW9FYXNlID0gdmFycy55b3lvRWFzZSxcbiAgICAgIGtleWZyYW1lcyA9IHZhcnMua2V5ZnJhbWVzLFxuICAgICAgYXV0b1JldmVydCA9IHZhcnMuYXV0b1JldmVydCxcbiAgICAgIGR1ciA9IHR3ZWVuLl9kdXIsXG4gICAgICBwcmV2U3RhcnRBdCA9IHR3ZWVuLl9zdGFydEF0LFxuICAgICAgdGFyZ2V0cyA9IHR3ZWVuLl90YXJnZXRzLFxuICAgICAgcGFyZW50ID0gdHdlZW4ucGFyZW50LFxuICAgICAgZnVsbFRhcmdldHMgPSBwYXJlbnQgJiYgcGFyZW50LmRhdGEgPT09IFwibmVzdGVkXCIgPyBwYXJlbnQudmFycy50YXJnZXRzIDogdGFyZ2V0cyxcbiAgICAgIGF1dG9PdmVyd3JpdGUgPSB0d2Vlbi5fb3ZlcndyaXRlID09PSBcImF1dG9cIiAmJiAhX3N1cHByZXNzT3ZlcndyaXRlcyxcbiAgICAgIHRsID0gdHdlZW4udGltZWxpbmUsXG4gICAgICBjbGVhblZhcnMsXG4gICAgICBpLFxuICAgICAgcCxcbiAgICAgIHB0LFxuICAgICAgdGFyZ2V0LFxuICAgICAgaGFzUHJpb3JpdHksXG4gICAgICBnc0RhdGEsXG4gICAgICBoYXJuZXNzLFxuICAgICAgcGx1Z2luLFxuICAgICAgcHRMb29rdXAsXG4gICAgICBpbmRleCxcbiAgICAgIGhhcm5lc3NWYXJzLFxuICAgICAgb3ZlcndyaXR0ZW47XG4gIHRsICYmICgha2V5ZnJhbWVzIHx8ICFlYXNlKSAmJiAoZWFzZSA9IFwibm9uZVwiKTtcbiAgdHdlZW4uX2Vhc2UgPSBfcGFyc2VFYXNlKGVhc2UsIF9kZWZhdWx0cy5lYXNlKTtcbiAgdHdlZW4uX3lFYXNlID0geW95b0Vhc2UgPyBfaW52ZXJ0RWFzZShfcGFyc2VFYXNlKHlveW9FYXNlID09PSB0cnVlID8gZWFzZSA6IHlveW9FYXNlLCBfZGVmYXVsdHMuZWFzZSkpIDogMDtcblxuICBpZiAoeW95b0Vhc2UgJiYgdHdlZW4uX3lveW8gJiYgIXR3ZWVuLl9yZXBlYXQpIHtcbiAgICAvL3RoZXJlIG11c3QgaGF2ZSBiZWVuIGEgcGFyZW50IHRpbWVsaW5lIHdpdGggeW95bzp0cnVlIHRoYXQgaXMgY3VycmVudGx5IGluIGl0cyB5b3lvIHBoYXNlLCBzbyBmbGlwIHRoZSBlYXNlcy5cbiAgICB5b3lvRWFzZSA9IHR3ZWVuLl95RWFzZTtcbiAgICB0d2Vlbi5feUVhc2UgPSB0d2Vlbi5fZWFzZTtcbiAgICB0d2Vlbi5fZWFzZSA9IHlveW9FYXNlO1xuICB9XG5cbiAgdHdlZW4uX2Zyb20gPSAhdGwgJiYgISF2YXJzLnJ1bkJhY2t3YXJkczsgLy9uZXN0ZWQgdGltZWxpbmVzIHNob3VsZCBuZXZlciBydW4gYmFja3dhcmRzIC0gdGhlIGJhY2t3YXJkcy1uZXNzIGlzIGluIHRoZSBjaGlsZCB0d2VlbnMuXG5cbiAgaWYgKCF0bCB8fCBrZXlmcmFtZXMgJiYgIXZhcnMuc3RhZ2dlcikge1xuICAgIC8vaWYgdGhlcmUncyBhbiBpbnRlcm5hbCB0aW1lbGluZSwgc2tpcCBhbGwgdGhlIHBhcnNpbmcgYmVjYXVzZSB3ZSBwYXNzZWQgdGhhdCB0YXNrIGRvd24gdGhlIGNoYWluLlxuICAgIGhhcm5lc3MgPSB0YXJnZXRzWzBdID8gX2dldENhY2hlKHRhcmdldHNbMF0pLmhhcm5lc3MgOiAwO1xuICAgIGhhcm5lc3NWYXJzID0gaGFybmVzcyAmJiB2YXJzW2hhcm5lc3MucHJvcF07IC8vc29tZW9uZSBtYXkgbmVlZCB0byBzcGVjaWZ5IENTUy1zcGVjaWZpYyB2YWx1ZXMgQU5EIG5vbi1DU1MgdmFsdWVzLCBsaWtlIGlmIHRoZSBlbGVtZW50IGhhcyBhbiBcInhcIiBwcm9wZXJ0eSBwbHVzIGl0J3MgYSBzdGFuZGFyZCBET00gZWxlbWVudC4gV2UgYWxsb3cgcGVvcGxlIHRvIGRpc3Rpbmd1aXNoIGJ5IHdyYXBwaW5nIHBsdWdpbi1zcGVjaWZpYyBzdHVmZiBpbiBhIGNzczp7fSBvYmplY3QgZm9yIGV4YW1wbGUuXG5cbiAgICBjbGVhblZhcnMgPSBfY29weUV4Y2x1ZGluZyh2YXJzLCBfcmVzZXJ2ZWRQcm9wcyk7XG5cbiAgICBpZiAocHJldlN0YXJ0QXQpIHtcbiAgICAgIHByZXZTdGFydEF0Ll96VGltZSA8IDAgJiYgcHJldlN0YXJ0QXQucHJvZ3Jlc3MoMSk7IC8vIGluIGNhc2UgaXQncyBhIGxhenkgc3RhcnRBdCB0aGF0IGhhc24ndCByZW5kZXJlZCB5ZXQuXG5cbiAgICAgIHRpbWUgPCAwICYmIHJ1bkJhY2t3YXJkcyAmJiBpbW1lZGlhdGVSZW5kZXIgJiYgIWF1dG9SZXZlcnQgPyBwcmV2U3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpIDogcHJldlN0YXJ0QXQucmV2ZXJ0KHJ1bkJhY2t3YXJkcyAmJiBkdXIgPyBfcmV2ZXJ0Q29uZmlnTm9LaWxsIDogX3N0YXJ0QXRSZXZlcnRDb25maWcpOyAvLyBpZiBpdCdzIGEgXCJzdGFydEF0XCIgKG5vdCBcImZyb20oKVwiIG9yIHJ1bkJhY2t3YXJkczogdHJ1ZSksIHdlIG9ubHkgbmVlZCB0byBkbyBhIHNoYWxsb3cgcmV2ZXJ0IChrZWVwIHRyYW5zZm9ybXMgY2FjaGVkIGluIENTU1BsdWdpbilcbiAgICAgIC8vIGRvbid0IGp1c3QgX3JlbW92ZUZyb21QYXJlbnQocHJldlN0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKSkgYmVjYXVzZSB0aGF0J2xsIGxlYXZlIGlubGluZSBzdHlsZXMuIFdlJ3JlIGNyZWF0aW5nIGEgbmV3IF9zdGFydEF0IGZvciBcInN0YXJ0QXRcIiB0d2VlbnMgdGhhdCByZS1jYXB0dXJlIHRoaW5ncyB0byBlbnN1cmUgdGhhdCBpZiB0aGUgcHJlLXR3ZWVuIHZhbHVlcyBjaGFuZ2VkIHNpbmNlIHRoZSB0d2VlbiB3YXMgY3JlYXRlZCwgdGhleSdyZSByZWNvcmRlZC5cblxuICAgICAgcHJldlN0YXJ0QXQuX2xhenkgPSAwO1xuICAgIH1cblxuICAgIGlmIChzdGFydEF0KSB7XG4gICAgICBfcmVtb3ZlRnJvbVBhcmVudCh0d2Vlbi5fc3RhcnRBdCA9IFR3ZWVuLnNldCh0YXJnZXRzLCBfc2V0RGVmYXVsdHMoe1xuICAgICAgICBkYXRhOiBcImlzU3RhcnRcIixcbiAgICAgICAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIGltbWVkaWF0ZVJlbmRlcjogdHJ1ZSxcbiAgICAgICAgbGF6eTogIXByZXZTdGFydEF0ICYmIF9pc05vdEZhbHNlKGxhenkpLFxuICAgICAgICBzdGFydEF0OiBudWxsLFxuICAgICAgICBkZWxheTogMCxcbiAgICAgICAgb25VcGRhdGU6IG9uVXBkYXRlICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX2NhbGxiYWNrKHR3ZWVuLCBcIm9uVXBkYXRlXCIpO1xuICAgICAgICB9LFxuICAgICAgICBzdGFnZ2VyOiAwXG4gICAgICB9LCBzdGFydEF0KSkpOyAvL2NvcHkgdGhlIHByb3BlcnRpZXMvdmFsdWVzIGludG8gYSBuZXcgb2JqZWN0IHRvIGF2b2lkIGNvbGxpc2lvbnMsIGxpa2UgdmFyIHRvID0ge3g6MH0sIGZyb20gPSB7eDo1MDB9OyB0aW1lbGluZS5mcm9tVG8oZSwgZnJvbSwgdG8pLmZyb21UbyhlLCB0bywgZnJvbSk7XG5cblxuICAgICAgdHdlZW4uX3N0YXJ0QXQuX2RwID0gMDsgLy8gZG9uJ3QgYWxsb3cgaXQgdG8gZ2V0IHB1dCBiYWNrIGludG8gcm9vdCB0aW1lbGluZSEgTGlrZSB3aGVuIHJldmVydCgpIGlzIGNhbGxlZCBhbmQgdG90YWxUaW1lKCkgZ2V0cyBzZXQuXG5cbiAgICAgIHR3ZWVuLl9zdGFydEF0Ll9zYXQgPSB0d2VlbjsgLy8gdXNlZCBpbiBnbG9iYWxUaW1lKCkuIF9zYXQgc3RhbmRzIGZvciBfc3RhcnRBdFR3ZWVuXG5cbiAgICAgIHRpbWUgPCAwICYmIChfcmV2ZXJ0aW5nIHx8ICFpbW1lZGlhdGVSZW5kZXIgJiYgIWF1dG9SZXZlcnQpICYmIHR3ZWVuLl9zdGFydEF0LnJldmVydChfcmV2ZXJ0Q29uZmlnTm9LaWxsKTsgLy8gcmFyZSBlZGdlIGNhc2UsIGxpa2UgaWYgYSByZW5kZXIgaXMgZm9yY2VkIGluIHRoZSBuZWdhdGl2ZSBkaXJlY3Rpb24gb2YgYSBub24taW5pdHRlZCB0d2Vlbi5cblxuICAgICAgaWYgKGltbWVkaWF0ZVJlbmRlcikge1xuICAgICAgICBpZiAoZHVyICYmIHRpbWUgPD0gMCAmJiB0VGltZSA8PSAwKSB7XG4gICAgICAgICAgLy8gY2hlY2sgdFRpbWUgaGVyZSBiZWNhdXNlIGluIHRoZSBjYXNlIG9mIGEgeW95byB0d2VlbiB3aG9zZSBwbGF5aGVhZCBnZXRzIHB1c2hlZCB0byB0aGUgZW5kIGxpa2UgdHdlZW4ucHJvZ3Jlc3MoMSksIHdlIHNob3VsZCBhbGxvdyBpdCB0aHJvdWdoIHNvIHRoYXQgdGhlIG9uQ29tcGxldGUgZ2V0cyBmaXJlZCBwcm9wZXJseS5cbiAgICAgICAgICB0aW1lICYmICh0d2Vlbi5felRpbWUgPSB0aW1lKTtcbiAgICAgICAgICByZXR1cm47IC8vd2Ugc2tpcCBpbml0aWFsaXphdGlvbiBoZXJlIHNvIHRoYXQgb3ZlcndyaXRpbmcgZG9lc24ndCBvY2N1ciB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zLiBPdGhlcndpc2UsIGlmIHlvdSBjcmVhdGUgc2V2ZXJhbCBpbW1lZGlhdGVSZW5kZXI6dHJ1ZSB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0L3Byb3BlcnRpZXMgdG8gZHJvcCBpbnRvIGEgVGltZWxpbmUsIHRoZSBsYXN0IG9uZSBjcmVhdGVkIHdvdWxkIG92ZXJ3cml0ZSB0aGUgZmlyc3Qgb25lcyBiZWNhdXNlIHRoZXkgZGlkbid0IGdldCBwbGFjZWQgaW50byB0aGUgdGltZWxpbmUgeWV0IGJlZm9yZSB0aGUgZmlyc3QgcmVuZGVyIG9jY3VycyBhbmQga2lja3MgaW4gb3ZlcndyaXRpbmcuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJ1bkJhY2t3YXJkcyAmJiBkdXIpIHtcbiAgICAgIC8vZnJvbSgpIHR3ZWVucyBtdXN0IGJlIGhhbmRsZWQgdW5pcXVlbHk6IHRoZWlyIGJlZ2lubmluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZCBidXQgd2UgZG9uJ3Qgd2FudCBvdmVyd3JpdGluZyB0byBvY2N1ciB5ZXQgKHdoZW4gdGltZSBpcyBzdGlsbCAwKS4gV2FpdCB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zIGJlZm9yZSBkb2luZyBhbGwgdGhlIHJvdXRpbmVzIGxpa2Ugb3ZlcndyaXRpbmcuIEF0IHRoYXQgdGltZSwgd2Ugc2hvdWxkIHJlbmRlciBhdCB0aGUgRU5EIG9mIHRoZSB0d2VlbiB0byBlbnN1cmUgdGhhdCB0aGluZ3MgaW5pdGlhbGl6ZSBjb3JyZWN0bHkgKHJlbWVtYmVyLCBmcm9tKCkgdHdlZW5zIGdvIGJhY2t3YXJkcylcbiAgICAgIGlmICghcHJldlN0YXJ0QXQpIHtcbiAgICAgICAgdGltZSAmJiAoaW1tZWRpYXRlUmVuZGVyID0gZmFsc2UpOyAvL2luIHJhcmUgY2FzZXMgKGxpa2UgaWYgYSBmcm9tKCkgdHdlZW4gcnVucyBhbmQgdGhlbiBpcyBpbnZhbGlkYXRlKCktZWQpLCBpbW1lZGlhdGVSZW5kZXIgY291bGQgYmUgdHJ1ZSBidXQgdGhlIGluaXRpYWwgZm9yY2VkLXJlbmRlciBnZXRzIHNraXBwZWQsIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSB0aGUgcmVuZGVyIGluIHRoaXMgY29udGV4dCB3aGVuIHRoZSBfdGltZSBpcyBncmVhdGVyIHRoYW4gMFxuXG4gICAgICAgIHAgPSBfc2V0RGVmYXVsdHMoe1xuICAgICAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICAgICAgZGF0YTogXCJpc0Zyb21TdGFydFwiLFxuICAgICAgICAgIC8vd2UgdGFnIHRoZSB0d2VlbiB3aXRoIGFzIFwiaXNGcm9tU3RhcnRcIiBzbyB0aGF0IGlmIFtpbnNpZGUgYSBwbHVnaW5dIHdlIG5lZWQgdG8gb25seSBkbyBzb21ldGhpbmcgYXQgdGhlIHZlcnkgRU5EIG9mIGEgdHdlZW4sIHdlIGhhdmUgYSB3YXkgb2YgaWRlbnRpZnlpbmcgdGhpcyB0d2VlbiBhcyBtZXJlbHkgdGhlIG9uZSB0aGF0J3Mgc2V0dGluZyB0aGUgYmVnaW5uaW5nIHZhbHVlcyBmb3IgYSBcImZyb20oKVwiIHR3ZWVuLiBGb3IgZXhhbXBsZSwgY2xlYXJQcm9wcyBpbiBDU1NQbHVnaW4gc2hvdWxkIG9ubHkgZ2V0IGFwcGxpZWQgYXQgdGhlIHZlcnkgRU5EIG9mIGEgdHdlZW4gYW5kIHdpdGhvdXQgdGhpcyB0YWcsIGZyb20oLi4ue2hlaWdodDoxMDAsIGNsZWFyUHJvcHM6XCJoZWlnaHRcIiwgZGVsYXk6MX0pIHdvdWxkIHdpcGUgdGhlIGhlaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0d2VlbiBhbmQgYWZ0ZXIgMSBzZWNvbmQsIGl0J2Qga2ljayBiYWNrIGluLlxuICAgICAgICAgIGxhenk6IGltbWVkaWF0ZVJlbmRlciAmJiAhcHJldlN0YXJ0QXQgJiYgX2lzTm90RmFsc2UobGF6eSksXG4gICAgICAgICAgaW1tZWRpYXRlUmVuZGVyOiBpbW1lZGlhdGVSZW5kZXIsXG4gICAgICAgICAgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyByZW5kZXIgaW1tZWRpYXRlbHkgYnkgZGVmYXVsdCwgYnV0IGlmIHdlJ3JlIG5vdCBzcGVjaWZpY2FsbHkgaW5zdHJ1Y3RlZCB0byByZW5kZXIgdGhpcyB0d2VlbiBpbW1lZGlhdGVseSwgd2Ugc2hvdWxkIHNraXAgdGhpcyBhbmQgbWVyZWx5IF9pbml0KCkgdG8gcmVjb3JkIHRoZSBzdGFydGluZyB2YWx1ZXMgKHJlbmRlcmluZyB0aGVtIGltbWVkaWF0ZWx5IHdvdWxkIHB1c2ggdGhlbSB0byBjb21wbGV0aW9uIHdoaWNoIGlzIHdhc3RlZnVsIGluIHRoYXQgY2FzZSAtIHdlJ2QgaGF2ZSB0byByZW5kZXIoLTEpIGltbWVkaWF0ZWx5IGFmdGVyKVxuICAgICAgICAgIHN0YWdnZXI6IDAsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnQgLy9lbnN1cmVzIHRoYXQgbmVzdGVkIHR3ZWVucyB0aGF0IGhhZCBhIHN0YWdnZXIgYXJlIGhhbmRsZWQgcHJvcGVybHksIGxpa2UgZ3NhcC5mcm9tKFwiLmNsYXNzXCIsIHt5OiBnc2FwLnV0aWxzLndyYXAoWy0xMDAsMTAwXSksIHN0YWdnZXI6IDAuNX0pXG5cbiAgICAgICAgfSwgY2xlYW5WYXJzKTtcbiAgICAgICAgaGFybmVzc1ZhcnMgJiYgKHBbaGFybmVzcy5wcm9wXSA9IGhhcm5lc3NWYXJzKTsgLy8gaW4gY2FzZSBzb21lb25lIGRvZXMgc29tZXRoaW5nIGxpa2UgLmZyb20oLi4uLCB7Y3NzOnt9fSlcblxuICAgICAgICBfcmVtb3ZlRnJvbVBhcmVudCh0d2Vlbi5fc3RhcnRBdCA9IFR3ZWVuLnNldCh0YXJnZXRzLCBwKSk7XG5cbiAgICAgICAgdHdlZW4uX3N0YXJ0QXQuX2RwID0gMDsgLy8gZG9uJ3QgYWxsb3cgaXQgdG8gZ2V0IHB1dCBiYWNrIGludG8gcm9vdCB0aW1lbGluZSFcblxuICAgICAgICB0d2Vlbi5fc3RhcnRBdC5fc2F0ID0gdHdlZW47IC8vIHVzZWQgaW4gZ2xvYmFsVGltZSgpXG5cbiAgICAgICAgdGltZSA8IDAgJiYgKF9yZXZlcnRpbmcgPyB0d2Vlbi5fc3RhcnRBdC5yZXZlcnQoX3JldmVydENvbmZpZ05vS2lsbCkgOiB0d2Vlbi5fc3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpKTtcbiAgICAgICAgdHdlZW4uX3pUaW1lID0gdGltZTtcblxuICAgICAgICBpZiAoIWltbWVkaWF0ZVJlbmRlcikge1xuICAgICAgICAgIF9pbml0VHdlZW4odHdlZW4uX3N0YXJ0QXQsIF90aW55TnVtLCBfdGlueU51bSk7IC8vZW5zdXJlcyB0aGF0IHRoZSBpbml0aWFsIHZhbHVlcyBhcmUgcmVjb3JkZWRcblxuICAgICAgICB9IGVsc2UgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHdlZW4uX3B0ID0gdHdlZW4uX3B0Q2FjaGUgPSAwO1xuICAgIGxhenkgPSBkdXIgJiYgX2lzTm90RmFsc2UobGF6eSkgfHwgbGF6eSAmJiAhZHVyO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICBnc0RhdGEgPSB0YXJnZXQuX2dzYXAgfHwgX2hhcm5lc3ModGFyZ2V0cylbaV0uX2dzYXA7XG4gICAgICB0d2Vlbi5fcHRMb29rdXBbaV0gPSBwdExvb2t1cCA9IHt9O1xuICAgICAgX2xhenlMb29rdXBbZ3NEYXRhLmlkXSAmJiBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTsgLy9pZiBvdGhlciB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0IGhhdmUgcmVjZW50bHkgaW5pdHRlZCBidXQgaGF2ZW4ndCByZW5kZXJlZCB5ZXQsIHdlJ3ZlIGdvdCB0byBmb3JjZSB0aGUgcmVuZGVyIHNvIHRoYXQgdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcmUgY29ycmVjdCAoaW1hZ2luZSBwb3B1bGF0aW5nIGEgdGltZWxpbmUgd2l0aCBhIGJ1bmNoIG9mIHNlcXVlbnRpYWwgdHdlZW5zIGFuZCB0aGVuIGp1bXBpbmcgdG8gdGhlIGVuZClcblxuICAgICAgaW5kZXggPSBmdWxsVGFyZ2V0cyA9PT0gdGFyZ2V0cyA/IGkgOiBmdWxsVGFyZ2V0cy5pbmRleE9mKHRhcmdldCk7XG5cbiAgICAgIGlmIChoYXJuZXNzICYmIChwbHVnaW4gPSBuZXcgaGFybmVzcygpKS5pbml0KHRhcmdldCwgaGFybmVzc1ZhcnMgfHwgY2xlYW5WYXJzLCB0d2VlbiwgaW5kZXgsIGZ1bGxUYXJnZXRzKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgdHdlZW4uX3B0ID0gcHQgPSBuZXcgUHJvcFR3ZWVuKHR3ZWVuLl9wdCwgdGFyZ2V0LCBwbHVnaW4ubmFtZSwgMCwgMSwgcGx1Z2luLnJlbmRlciwgcGx1Z2luLCAwLCBwbHVnaW4ucHJpb3JpdHkpO1xuXG4gICAgICAgIHBsdWdpbi5fcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHB0TG9va3VwW25hbWVdID0gcHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBsdWdpbi5wcmlvcml0eSAmJiAoaGFzUHJpb3JpdHkgPSAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXJuZXNzIHx8IGhhcm5lc3NWYXJzKSB7XG4gICAgICAgIGZvciAocCBpbiBjbGVhblZhcnMpIHtcbiAgICAgICAgICBpZiAoX3BsdWdpbnNbcF0gJiYgKHBsdWdpbiA9IF9jaGVja1BsdWdpbihwLCBjbGVhblZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCBmdWxsVGFyZ2V0cykpKSB7XG4gICAgICAgICAgICBwbHVnaW4ucHJpb3JpdHkgJiYgKGhhc1ByaW9yaXR5ID0gMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHB0TG9va3VwW3BdID0gcHQgPSBfYWRkUHJvcFR3ZWVuLmNhbGwodHdlZW4sIHRhcmdldCwgcCwgXCJnZXRcIiwgY2xlYW5WYXJzW3BdLCBpbmRleCwgZnVsbFRhcmdldHMsIDAsIHZhcnMuc3RyaW5nRmlsdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHdlZW4uX29wICYmIHR3ZWVuLl9vcFtpXSAmJiB0d2Vlbi5raWxsKHRhcmdldCwgdHdlZW4uX29wW2ldKTtcblxuICAgICAgaWYgKGF1dG9PdmVyd3JpdGUgJiYgdHdlZW4uX3B0KSB7XG4gICAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gdHdlZW47XG5cbiAgICAgICAgX2dsb2JhbFRpbWVsaW5lLmtpbGxUd2VlbnNPZih0YXJnZXQsIHB0TG9va3VwLCB0d2Vlbi5nbG9iYWxUaW1lKHRpbWUpKTsgLy8gbWFrZSBzdXJlIHRoZSBvdmVyd3JpdGluZyBkb2Vzbid0IG92ZXJ3cml0ZSBUSElTIHR3ZWVuISEhXG5cblxuICAgICAgICBvdmVyd3JpdHRlbiA9ICF0d2Vlbi5wYXJlbnQ7XG4gICAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gMDtcbiAgICAgIH1cblxuICAgICAgdHdlZW4uX3B0ICYmIGxhenkgJiYgKF9sYXp5TG9va3VwW2dzRGF0YS5pZF0gPSAxKTtcbiAgICB9XG5cbiAgICBoYXNQcmlvcml0eSAmJiBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5KHR3ZWVuKTtcbiAgICB0d2Vlbi5fb25Jbml0ICYmIHR3ZWVuLl9vbkluaXQodHdlZW4pOyAvL3BsdWdpbnMgbGlrZSBSb3VuZFByb3BzIG11c3Qgd2FpdCB1bnRpbCBBTEwgb2YgdGhlIFByb3BUd2VlbnMgYXJlIGluc3RhbnRpYXRlZC4gSW4gdGhlIHBsdWdpbidzIGluaXQoKSBmdW5jdGlvbiwgaXQgc2V0cyB0aGUgX29uSW5pdCBvbiB0aGUgdHdlZW4gaW5zdGFuY2UuIE1heSBub3QgYmUgcHJldHR5L2ludHVpdGl2ZSwgYnV0IGl0J3MgZmFzdCBhbmQga2VlcHMgZmlsZSBzaXplIGRvd24uXG4gIH1cblxuICB0d2Vlbi5fb25VcGRhdGUgPSBvblVwZGF0ZTtcbiAgdHdlZW4uX2luaXR0ZWQgPSAoIXR3ZWVuLl9vcCB8fCB0d2Vlbi5fcHQpICYmICFvdmVyd3JpdHRlbjsgLy8gaWYgb3ZlcndyaXR0ZW5Qcm9wcyByZXN1bHRlZCBpbiB0aGUgZW50aXJlIHR3ZWVuIGJlaW5nIGtpbGxlZCwgZG8gTk9UIGZsYWcgaXQgYXMgaW5pdHRlZCBvciBlbHNlIGl0IG1heSByZW5kZXIgZm9yIG9uZSB0aWNrLlxuXG4gIGtleWZyYW1lcyAmJiB0aW1lIDw9IDAgJiYgdGwucmVuZGVyKF9iaWdOdW0sIHRydWUsIHRydWUpOyAvLyBpZiB0aGVyZSdzIGEgMCUga2V5ZnJhbWUsIGl0J2xsIHJlbmRlciBpbiB0aGUgXCJiZWZvcmVcIiBzdGF0ZSBmb3IgYW55IHN0YWdnZXJlZC9kZWxheWVkIGFuaW1hdGlvbnMgdGh1cyB3aGVuIHRoZSBmb2xsb3dpbmcgdHdlZW4gaW5pdGlhbGl6ZXMsIGl0J2xsIHVzZSB0aGUgXCJiZWZvcmVcIiBzdGF0ZSBpbnN0ZWFkIG9mIHRoZSBcImFmdGVyXCIgc3RhdGUgYXMgdGhlIGluaXRpYWwgdmFsdWVzLlxufSxcbiAgICBfdXBkYXRlUHJvcFR3ZWVucyA9IGZ1bmN0aW9uIF91cGRhdGVQcm9wVHdlZW5zKHR3ZWVuLCBwcm9wZXJ0eSwgdmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUsIHJhdGlvLCB0aW1lLCBza2lwUmVjdXJzaW9uKSB7XG4gIHZhciBwdENhY2hlID0gKHR3ZWVuLl9wdCAmJiB0d2Vlbi5fcHRDYWNoZSB8fCAodHdlZW4uX3B0Q2FjaGUgPSB7fSkpW3Byb3BlcnR5XSxcbiAgICAgIHB0LFxuICAgICAgcm9vdFBULFxuICAgICAgbG9va3VwLFxuICAgICAgaTtcblxuICBpZiAoIXB0Q2FjaGUpIHtcbiAgICBwdENhY2hlID0gdHdlZW4uX3B0Q2FjaGVbcHJvcGVydHldID0gW107XG4gICAgbG9va3VwID0gdHdlZW4uX3B0TG9va3VwO1xuICAgIGkgPSB0d2Vlbi5fdGFyZ2V0cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBwdCA9IGxvb2t1cFtpXVtwcm9wZXJ0eV07XG5cbiAgICAgIGlmIChwdCAmJiBwdC5kICYmIHB0LmQuX3B0KSB7XG4gICAgICAgIC8vIGl0J3MgYSBwbHVnaW4sIHNvIGZpbmQgdGhlIG5lc3RlZCBQcm9wVHdlZW5cbiAgICAgICAgcHQgPSBwdC5kLl9wdDtcblxuICAgICAgICB3aGlsZSAocHQgJiYgcHQucCAhPT0gcHJvcGVydHkgJiYgcHQuZnAgIT09IHByb3BlcnR5KSB7XG4gICAgICAgICAgLy8gXCJmcFwiIGlzIGZ1bmN0aW9uUGFyYW0gZm9yIHRoaW5ncyBsaWtlIHNldHRpbmcgQ1NTIHZhcmlhYmxlcyB3aGljaCByZXF1aXJlIC5zZXRQcm9wZXJ0eShcIi0tdmFyLW5hbWVcIiwgdmFsdWUpXG4gICAgICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXB0KSB7XG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIFByb3BUd2VlbiBhc3NvY2lhdGVkIHdpdGggdGhhdCBwcm9wZXJ0eSwgc28gd2UgbXVzdCBGT1JDRSBvbmUgdG8gYmUgY3JlYXRlZCBhbmQgZGl0Y2ggb3V0IG9mIHRoaXNcbiAgICAgICAgLy8gaWYgdGhlIHR3ZWVuIGhhcyBvdGhlciBwcm9wZXJ0aWVzIHRoYXQgYWxyZWFkeSByZW5kZXJlZCBhdCBuZXcgcG9zaXRpb25zLCB3ZSdkIG5vcm1hbGx5IGhhdmUgdG8gcmV3aW5kIHRvIHB1dCB0aGVtIGJhY2sgbGlrZSB0d2Vlbi5yZW5kZXIoMCwgdHJ1ZSkgYmVmb3JlIGZvcmNpbmcgYW4gX2luaXRUd2VlbigpLCBidXQgdGhhdCBjYW4gY3JlYXRlIGFub3RoZXIgZWRnZSBjYXNlIGxpa2UgdHdlZW5pbmcgYSB0aW1lbGluZSdzIHByb2dyZXNzIHdvdWxkIHRyaWdnZXIgb25VcGRhdGVzIHRvIGZpcmUgd2hpY2ggY291bGQgbW92ZSBvdGhlciB0aGluZ3MgYXJvdW5kLiBJdCdzIGJldHRlciB0byBqdXN0IGluZm9ybSB1c2VycyB0aGF0IC5yZXNldFRvKCkgc2hvdWxkIE9OTFkgYmUgdXNlZCBmb3IgdHdlZW5zIHRoYXQgYWxyZWFkeSBoYXZlIHRoYXQgcHJvcGVydHkuIEZvciBleGFtcGxlLCB5b3UgY2FuJ3QgZ3NhcC50byguLi57IHk6IDAgfSkgYW5kIHRoZW4gdHdlZW4ucmVzdFRvKFwieFwiLCAyMDApIGZvciBleGFtcGxlLlxuICAgICAgICBfZm9yY2VBbGxQcm9wVHdlZW5zID0gMTsgLy8gb3RoZXJ3aXNlLCB3aGVuIHdlIF9hZGRQcm9wVHdlZW4oKSBhbmQgaXQgZmluZHMgbm8gY2hhbmdlIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgdmFsdWVzLCBpdCBza2lwcyBjcmVhdGluZyBhIFByb3BUd2VlbiAoZm9yIGVmZmljaWVuY3kuLi53aHkgdHdlZW4gd2hlbiB0aGVyZSdzIG5vIGRpZmZlcmVuY2U/KSBidXQgaW4gdGhpcyBjYXNlIHdlIE5FRUQgdGhhdCBQcm9wVHdlZW4gY3JlYXRlZCBzbyB3ZSBjYW4gZWRpdCBpdC5cblxuICAgICAgICB0d2Vlbi52YXJzW3Byb3BlcnR5XSA9IFwiKz0wXCI7XG5cbiAgICAgICAgX2luaXRUd2Vlbih0d2VlbiwgdGltZSk7XG5cbiAgICAgICAgX2ZvcmNlQWxsUHJvcFR3ZWVucyA9IDA7XG4gICAgICAgIHJldHVybiBza2lwUmVjdXJzaW9uID8gX3dhcm4ocHJvcGVydHkgKyBcIiBub3QgZWxpZ2libGUgZm9yIHJlc2V0XCIpIDogMTsgLy8gaWYgc29tZW9uZSB0cmllcyB0byBkbyBhIHF1aWNrVG8oKSBvbiBhIHNwZWNpYWwgcHJvcGVydHkgbGlrZSBib3JkZXJSYWRpdXMgd2hpY2ggbXVzdCBnZXQgc3BsaXQgaW50byA0IGRpZmZlcmVudCBwcm9wZXJ0aWVzLCB0aGF0J3Mgbm90IGVsaWdpYmxlIGZvciAucmVzZXRUbygpLlxuICAgICAgfVxuXG4gICAgICBwdENhY2hlLnB1c2gocHQpO1xuICAgIH1cbiAgfVxuXG4gIGkgPSBwdENhY2hlLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgcm9vdFBUID0gcHRDYWNoZVtpXTtcbiAgICBwdCA9IHJvb3RQVC5fcHQgfHwgcm9vdFBUOyAvLyBjb21wbGV4IHZhbHVlcyBtYXkgaGF2ZSBuZXN0ZWQgUHJvcFR3ZWVucy4gV2Ugb25seSBhY2NvbW1vZGF0ZSB0aGUgRklSU1QgdmFsdWUuXG5cbiAgICBwdC5zID0gKHN0YXJ0IHx8IHN0YXJ0ID09PSAwKSAmJiAhc3RhcnRJc1JlbGF0aXZlID8gc3RhcnQgOiBwdC5zICsgKHN0YXJ0IHx8IDApICsgcmF0aW8gKiBwdC5jO1xuICAgIHB0LmMgPSB2YWx1ZSAtIHB0LnM7XG4gICAgcm9vdFBULmUgJiYgKHJvb3RQVC5lID0gX3JvdW5kKHZhbHVlKSArIGdldFVuaXQocm9vdFBULmUpKTsgLy8gbWFpbmx5IGZvciBDU1NQbHVnaW4gKGVuZCB2YWx1ZSlcblxuICAgIHJvb3RQVC5iICYmIChyb290UFQuYiA9IHB0LnMgKyBnZXRVbml0KHJvb3RQVC5iKSk7IC8vIChiZWdpbm5pbmcgdmFsdWUpXG4gIH1cbn0sXG4gICAgX2FkZEFsaWFzZXNUb1ZhcnMgPSBmdW5jdGlvbiBfYWRkQWxpYXNlc1RvVmFycyh0YXJnZXRzLCB2YXJzKSB7XG4gIHZhciBoYXJuZXNzID0gdGFyZ2V0c1swXSA/IF9nZXRDYWNoZSh0YXJnZXRzWzBdKS5oYXJuZXNzIDogMCxcbiAgICAgIHByb3BlcnR5QWxpYXNlcyA9IGhhcm5lc3MgJiYgaGFybmVzcy5hbGlhc2VzLFxuICAgICAgY29weSxcbiAgICAgIHAsXG4gICAgICBpLFxuICAgICAgYWxpYXNlcztcblxuICBpZiAoIXByb3BlcnR5QWxpYXNlcykge1xuICAgIHJldHVybiB2YXJzO1xuICB9XG5cbiAgY29weSA9IF9tZXJnZSh7fSwgdmFycyk7XG5cbiAgZm9yIChwIGluIHByb3BlcnR5QWxpYXNlcykge1xuICAgIGlmIChwIGluIGNvcHkpIHtcbiAgICAgIGFsaWFzZXMgPSBwcm9wZXJ0eUFsaWFzZXNbcF0uc3BsaXQoXCIsXCIpO1xuICAgICAgaSA9IGFsaWFzZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvcHlbYWxpYXNlc1tpXV0gPSBjb3B5W3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICAvLyBwYXJzZXMgbXVsdGlwbGUgZm9ybWF0cywgbGlrZSB7XCIwJVwiOiB7eDogMTAwfSwge1wiNTAlXCI6IHt4OiAtMjB9fSBhbmQgeyB4OiB7XCIwJVwiOiAxMDAsIFwiNTAlXCI6IC0yMH0gfSwgYW5kIGFuIFwiZWFzZVwiIGNhbiBiZSBzZXQgb24gYW55IG9iamVjdC4gV2UgcG9wdWxhdGUgYW4gXCJhbGxQcm9wc1wiIG9iamVjdCB3aXRoIGFuIEFycmF5IGZvciBlYWNoIHByb3BlcnR5LCBsaWtlIHt4OiBbe30sIHt9XSwgeTpbe30sIHt9XX0gd2l0aCBkYXRhIGZvciBlYWNoIHByb3BlcnR5IHR3ZWVuLiBUaGUgb2JqZWN0cyBoYXZlIGEgXCJ0XCIgKHRpbWUpLCBcInZcIiwgKHZhbHVlKSwgYW5kIFwiZVwiIChlYXNlKSBwcm9wZXJ0eS4gVGhpcyBhbGxvd3MgdXMgdG8gcGllY2UgdG9nZXRoZXIgYSB0aW1lbGluZSBsYXRlci5cbl9wYXJzZUtleWZyYW1lID0gZnVuY3Rpb24gX3BhcnNlS2V5ZnJhbWUocHJvcCwgb2JqLCBhbGxQcm9wcywgZWFzZUVhY2gpIHtcbiAgdmFyIGVhc2UgPSBvYmouZWFzZSB8fCBlYXNlRWFjaCB8fCBcInBvd2VyMS5pbk91dFwiLFxuICAgICAgcCxcbiAgICAgIGE7XG5cbiAgaWYgKF9pc0FycmF5KG9iaikpIHtcbiAgICBhID0gYWxsUHJvcHNbcHJvcF0gfHwgKGFsbFByb3BzW3Byb3BdID0gW10pOyAvLyB0ID0gdGltZSAob3V0IG9mIDEwMCksIHYgPSB2YWx1ZSwgZSA9IGVhc2VcblxuICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgcmV0dXJuIGEucHVzaCh7XG4gICAgICAgIHQ6IGkgLyAob2JqLmxlbmd0aCAtIDEpICogMTAwLFxuICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgZTogZWFzZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChwIGluIG9iaikge1xuICAgICAgYSA9IGFsbFByb3BzW3BdIHx8IChhbGxQcm9wc1twXSA9IFtdKTtcbiAgICAgIHAgPT09IFwiZWFzZVwiIHx8IGEucHVzaCh7XG4gICAgICAgIHQ6IHBhcnNlRmxvYXQocHJvcCksXG4gICAgICAgIHY6IG9ialtwXSxcbiAgICAgICAgZTogZWFzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59LFxuICAgIF9wYXJzZUZ1bmNPclN0cmluZyA9IGZ1bmN0aW9uIF9wYXJzZUZ1bmNPclN0cmluZyh2YWx1ZSwgdHdlZW4sIGksIHRhcmdldCwgdGFyZ2V0cykge1xuICByZXR1cm4gX2lzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbCh0d2VlbiwgaSwgdGFyZ2V0LCB0YXJnZXRzKSA6IF9pc1N0cmluZyh2YWx1ZSkgJiYgfnZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpID8gX3JlcGxhY2VSYW5kb20odmFsdWUpIDogdmFsdWU7XG59LFxuICAgIF9zdGFnZ2VyVHdlZW5Qcm9wcyA9IF9jYWxsYmFja05hbWVzICsgXCJyZXBlYXQscmVwZWF0RGVsYXkseW95byxyZXBlYXRSZWZyZXNoLHlveW9FYXNlLGF1dG9SZXZlcnRcIixcbiAgICBfc3RhZ2dlclByb3BzVG9Ta2lwID0ge307XG5cbl9mb3JFYWNoTmFtZShfc3RhZ2dlclR3ZWVuUHJvcHMgKyBcIixpZCxzdGFnZ2VyLGRlbGF5LGR1cmF0aW9uLHBhdXNlZCxzY3JvbGxUcmlnZ2VyXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfc3RhZ2dlclByb3BzVG9Ta2lwW25hbWVdID0gMTtcbn0pO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUV0VFTlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbmV4cG9ydCB2YXIgVHdlZW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BbmltYXRpb24yKSB7XG4gIF9pbmhlcml0c0xvb3NlKFR3ZWVuLCBfQW5pbWF0aW9uMik7XG5cbiAgZnVuY3Rpb24gVHdlZW4odGFyZ2V0cywgdmFycywgcG9zaXRpb24sIHNraXBJbmhlcml0KSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgIGlmICh0eXBlb2YgdmFycyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcG9zaXRpb24uZHVyYXRpb24gPSB2YXJzO1xuICAgICAgdmFycyA9IHBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIF90aGlzMyA9IF9BbmltYXRpb24yLmNhbGwodGhpcywgc2tpcEluaGVyaXQgPyB2YXJzIDogX2luaGVyaXREZWZhdWx0cyh2YXJzKSkgfHwgdGhpcztcbiAgICB2YXIgX3RoaXMzJHZhcnMgPSBfdGhpczMudmFycyxcbiAgICAgICAgZHVyYXRpb24gPSBfdGhpczMkdmFycy5kdXJhdGlvbixcbiAgICAgICAgZGVsYXkgPSBfdGhpczMkdmFycy5kZWxheSxcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyID0gX3RoaXMzJHZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICBzdGFnZ2VyID0gX3RoaXMzJHZhcnMuc3RhZ2dlcixcbiAgICAgICAgb3ZlcndyaXRlID0gX3RoaXMzJHZhcnMub3ZlcndyaXRlLFxuICAgICAgICBrZXlmcmFtZXMgPSBfdGhpczMkdmFycy5rZXlmcmFtZXMsXG4gICAgICAgIGRlZmF1bHRzID0gX3RoaXMzJHZhcnMuZGVmYXVsdHMsXG4gICAgICAgIHNjcm9sbFRyaWdnZXIgPSBfdGhpczMkdmFycy5zY3JvbGxUcmlnZ2VyLFxuICAgICAgICB5b3lvRWFzZSA9IF90aGlzMyR2YXJzLnlveW9FYXNlLFxuICAgICAgICBwYXJlbnQgPSB2YXJzLnBhcmVudCB8fCBfZ2xvYmFsVGltZWxpbmUsXG4gICAgICAgIHBhcnNlZFRhcmdldHMgPSAoX2lzQXJyYXkodGFyZ2V0cykgfHwgX2lzVHlwZWRBcnJheSh0YXJnZXRzKSA/IF9pc051bWJlcih0YXJnZXRzWzBdKSA6IFwibGVuZ3RoXCIgaW4gdmFycykgPyBbdGFyZ2V0c10gOiB0b0FycmF5KHRhcmdldHMpLFxuICAgICAgICB0bCxcbiAgICAgICAgaSxcbiAgICAgICAgY29weSxcbiAgICAgICAgbCxcbiAgICAgICAgcCxcbiAgICAgICAgY3VyVGFyZ2V0LFxuICAgICAgICBzdGFnZ2VyRnVuYyxcbiAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlO1xuICAgIF90aGlzMy5fdGFyZ2V0cyA9IHBhcnNlZFRhcmdldHMubGVuZ3RoID8gX2hhcm5lc3MocGFyc2VkVGFyZ2V0cykgOiBfd2FybihcIkdTQVAgdGFyZ2V0IFwiICsgdGFyZ2V0cyArIFwiIG5vdCBmb3VuZC4gaHR0cHM6Ly9nc2FwLmNvbVwiLCAhX2NvbmZpZy5udWxsVGFyZ2V0V2FybikgfHwgW107XG4gICAgX3RoaXMzLl9wdExvb2t1cCA9IFtdOyAvL1Byb3BUd2VlbiBsb29rdXAuIEFuIGFycmF5IGNvbnRhaW5pbmcgYW4gb2JqZWN0IGZvciBlYWNoIHRhcmdldCwgaGF2aW5nIGtleXMgZm9yIGVhY2ggdHdlZW5pbmcgcHJvcGVydHlcblxuICAgIF90aGlzMy5fb3ZlcndyaXRlID0gb3ZlcndyaXRlO1xuXG4gICAgaWYgKGtleWZyYW1lcyB8fCBzdGFnZ2VyIHx8IF9pc0Z1bmNPclN0cmluZyhkdXJhdGlvbikgfHwgX2lzRnVuY09yU3RyaW5nKGRlbGF5KSkge1xuICAgICAgdmFycyA9IF90aGlzMy52YXJzO1xuICAgICAgdGwgPSBfdGhpczMudGltZWxpbmUgPSBuZXcgVGltZWxpbmUoe1xuICAgICAgICBkYXRhOiBcIm5lc3RlZFwiLFxuICAgICAgICBkZWZhdWx0czogZGVmYXVsdHMgfHwge30sXG4gICAgICAgIHRhcmdldHM6IHBhcmVudCAmJiBwYXJlbnQuZGF0YSA9PT0gXCJuZXN0ZWRcIiA/IHBhcmVudC52YXJzLnRhcmdldHMgOiBwYXJzZWRUYXJnZXRzXG4gICAgICB9KTsgLy8gd2UgbmVlZCB0byBzdG9yZSB0aGUgdGFyZ2V0cyBiZWNhdXNlIGZvciBzdGFnZ2VycyBhbmQga2V5ZnJhbWVzLCB3ZSBlbmQgdXAgY3JlYXRpbmcgYW4gaW5kaXZpZHVhbCB0d2VlbiBmb3IgZWFjaCBidXQgZnVuY3Rpb24tYmFzZWQgdmFsdWVzIG5lZWQgdG8ga25vdyB0aGUgaW5kZXggYW5kIHRoZSB3aG9sZSBBcnJheSBvZiB0YXJnZXRzLlxuXG4gICAgICB0bC5raWxsKCk7XG4gICAgICB0bC5wYXJlbnQgPSB0bC5fZHAgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyk7XG4gICAgICB0bC5fc3RhcnQgPSAwO1xuXG4gICAgICBpZiAoc3RhZ2dlciB8fCBfaXNGdW5jT3JTdHJpbmcoZHVyYXRpb24pIHx8IF9pc0Z1bmNPclN0cmluZyhkZWxheSkpIHtcbiAgICAgICAgbCA9IHBhcnNlZFRhcmdldHMubGVuZ3RoO1xuICAgICAgICBzdGFnZ2VyRnVuYyA9IHN0YWdnZXIgJiYgZGlzdHJpYnV0ZShzdGFnZ2VyKTtcblxuICAgICAgICBpZiAoX2lzT2JqZWN0KHN0YWdnZXIpKSB7XG4gICAgICAgICAgLy91c2VycyBjYW4gcGFzcyBpbiBjYWxsYmFja3MgbGlrZSBvblN0YXJ0L29uQ29tcGxldGUgaW4gdGhlIHN0YWdnZXIgb2JqZWN0LiBUaGVzZSBzaG91bGQgZmlyZSB3aXRoIGVhY2ggaW5kaXZpZHVhbCB0d2Vlbi5cbiAgICAgICAgICBmb3IgKHAgaW4gc3RhZ2dlcikge1xuICAgICAgICAgICAgaWYgKH5fc3RhZ2dlclR3ZWVuUHJvcHMuaW5kZXhPZihwKSkge1xuICAgICAgICAgICAgICBzdGFnZ2VyVmFyc1RvTWVyZ2UgfHwgKHN0YWdnZXJWYXJzVG9NZXJnZSA9IHt9KTtcbiAgICAgICAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlW3BdID0gc3RhZ2dlcltwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY29weSA9IF9jb3B5RXhjbHVkaW5nKHZhcnMsIF9zdGFnZ2VyUHJvcHNUb1NraXApO1xuICAgICAgICAgIGNvcHkuc3RhZ2dlciA9IDA7XG4gICAgICAgICAgeW95b0Vhc2UgJiYgKGNvcHkueW95b0Vhc2UgPSB5b3lvRWFzZSk7XG4gICAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlICYmIF9tZXJnZShjb3B5LCBzdGFnZ2VyVmFyc1RvTWVyZ2UpO1xuICAgICAgICAgIGN1clRhcmdldCA9IHBhcnNlZFRhcmdldHNbaV07IC8vZG9uJ3QganVzdCBjb3B5IGR1cmF0aW9uIG9yIGRlbGF5IGJlY2F1c2UgaWYgdGhleSdyZSBhIHN0cmluZyBvciBmdW5jdGlvbiwgd2UnZCBlbmQgdXAgaW4gYW4gaW5maW5pdGUgbG9vcCBiZWNhdXNlIF9pc0Z1bmNPclN0cmluZygpIHdvdWxkIGV2YWx1YXRlIGFzIHRydWUgaW4gdGhlIGNoaWxkIHR3ZWVucywgZW50ZXJpbmcgdGhpcyBsb29wLCBldGMuIFNvIHdlIHBhcnNlIHRoZSB2YWx1ZSBzdHJhaWdodCBmcm9tIHZhcnMgYW5kIGRlZmF1bHQgdG8gMC5cblxuICAgICAgICAgIGNvcHkuZHVyYXRpb24gPSArX3BhcnNlRnVuY09yU3RyaW5nKGR1cmF0aW9uLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIGksIGN1clRhcmdldCwgcGFyc2VkVGFyZ2V0cyk7XG4gICAgICAgICAgY29weS5kZWxheSA9ICgrX3BhcnNlRnVuY09yU3RyaW5nKGRlbGF5LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIGksIGN1clRhcmdldCwgcGFyc2VkVGFyZ2V0cykgfHwgMCkgLSBfdGhpczMuX2RlbGF5O1xuXG4gICAgICAgICAgaWYgKCFzdGFnZ2VyICYmIGwgPT09IDEgJiYgY29weS5kZWxheSkge1xuICAgICAgICAgICAgLy8gaWYgc29tZW9uZSBkb2VzIGRlbGF5OlwicmFuZG9tKDEsIDUpXCIsIHJlcGVhdDotMSwgZm9yIGV4YW1wbGUsIHRoZSBkZWxheSBzaG91bGRuJ3QgYmUgaW5zaWRlIHRoZSByZXBlYXQuXG4gICAgICAgICAgICBfdGhpczMuX2RlbGF5ID0gZGVsYXkgPSBjb3B5LmRlbGF5O1xuICAgICAgICAgICAgX3RoaXMzLl9zdGFydCArPSBkZWxheTtcbiAgICAgICAgICAgIGNvcHkuZGVsYXkgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRsLnRvKGN1clRhcmdldCwgY29weSwgc3RhZ2dlckZ1bmMgPyBzdGFnZ2VyRnVuYyhpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpIDogMCk7XG4gICAgICAgICAgdGwuX2Vhc2UgPSBfZWFzZU1hcC5ub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgdGwuZHVyYXRpb24oKSA/IGR1cmF0aW9uID0gZGVsYXkgPSAwIDogX3RoaXMzLnRpbWVsaW5lID0gMDsgLy8gaWYgdGhlIHRpbWVsaW5lJ3MgZHVyYXRpb24gaXMgMCwgd2UgZG9uJ3QgbmVlZCBhIHRpbWVsaW5lIGludGVybmFsbHkhXG4gICAgICB9IGVsc2UgaWYgKGtleWZyYW1lcykge1xuICAgICAgICBfaW5oZXJpdERlZmF1bHRzKF9zZXREZWZhdWx0cyh0bC52YXJzLmRlZmF1bHRzLCB7XG4gICAgICAgICAgZWFzZTogXCJub25lXCJcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHRsLl9lYXNlID0gX3BhcnNlRWFzZShrZXlmcmFtZXMuZWFzZSB8fCB2YXJzLmVhc2UgfHwgXCJub25lXCIpO1xuICAgICAgICB2YXIgdGltZSA9IDAsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAga2YsXG4gICAgICAgICAgICB2O1xuXG4gICAgICAgIGlmIChfaXNBcnJheShrZXlmcmFtZXMpKSB7XG4gICAgICAgICAga2V5ZnJhbWVzLmZvckVhY2goZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGwudG8ocGFyc2VkVGFyZ2V0cywgZnJhbWUsIFwiPlwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0bC5kdXJhdGlvbigpOyAvLyB0byBlbnN1cmUgdGwuX2R1ciBpcyBjYWNoZWQgYmVjYXVzZSB3ZSB0YXAgaW50byBpdCBmb3IgcGVyZm9ybWFuY2UgcHVycG9zZXMgaW4gdGhlIHJlbmRlcigpIG1ldGhvZC5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3B5ID0ge307XG5cbiAgICAgICAgICBmb3IgKHAgaW4ga2V5ZnJhbWVzKSB7XG4gICAgICAgICAgICBwID09PSBcImVhc2VcIiB8fCBwID09PSBcImVhc2VFYWNoXCIgfHwgX3BhcnNlS2V5ZnJhbWUocCwga2V5ZnJhbWVzW3BdLCBjb3B5LCBrZXlmcmFtZXMuZWFzZUVhY2gpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAocCBpbiBjb3B5KSB7XG4gICAgICAgICAgICBhID0gY29weVtwXS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhLnQgLSBiLnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRpbWUgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBrZiA9IGFbaV07XG4gICAgICAgICAgICAgIHYgPSB7XG4gICAgICAgICAgICAgICAgZWFzZToga2YuZSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogKGtmLnQgLSAoaSA/IGFbaSAtIDFdLnQgOiAwKSkgLyAxMDAgKiBkdXJhdGlvblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB2W3BdID0ga2YudjtcbiAgICAgICAgICAgICAgdGwudG8ocGFyc2VkVGFyZ2V0cywgdiwgdGltZSk7XG4gICAgICAgICAgICAgIHRpbWUgKz0gdi5kdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0bC5kdXJhdGlvbigpIDwgZHVyYXRpb24gJiYgdGwudG8oe30sIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiAtIHRsLmR1cmF0aW9uKClcbiAgICAgICAgICB9KTsgLy8gaW4gY2FzZSBrZXlmcmFtZXMgZGlkbid0IGdvIHRvIDEwMCVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkdXJhdGlvbiB8fCBfdGhpczMuZHVyYXRpb24oZHVyYXRpb24gPSB0bC5kdXJhdGlvbigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMzLnRpbWVsaW5lID0gMDsgLy9zcGVlZCBvcHRpbWl6YXRpb24sIGZhc3RlciBsb29rdXBzIChubyBnb2luZyB1cCB0aGUgcHJvdG90eXBlIGNoYWluKVxuICAgIH1cblxuICAgIGlmIChvdmVyd3JpdGUgPT09IHRydWUgJiYgIV9zdXBwcmVzc092ZXJ3cml0ZXMpIHtcbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpO1xuXG4gICAgICBfZ2xvYmFsVGltZWxpbmUua2lsbFR3ZWVuc09mKHBhcnNlZFRhcmdldHMpO1xuXG4gICAgICBfb3ZlcndyaXRpbmdUd2VlbiA9IDA7XG4gICAgfVxuXG4gICAgX2FkZFRvVGltZWxpbmUocGFyZW50LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIHBvc2l0aW9uKTtcblxuICAgIHZhcnMucmV2ZXJzZWQgJiYgX3RoaXMzLnJldmVyc2UoKTtcbiAgICB2YXJzLnBhdXNlZCAmJiBfdGhpczMucGF1c2VkKHRydWUpO1xuXG4gICAgaWYgKGltbWVkaWF0ZVJlbmRlciB8fCAhZHVyYXRpb24gJiYgIWtleWZyYW1lcyAmJiBfdGhpczMuX3N0YXJ0ID09PSBfcm91bmRQcmVjaXNlKHBhcmVudC5fdGltZSkgJiYgX2lzTm90RmFsc2UoaW1tZWRpYXRlUmVuZGVyKSAmJiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpKSAmJiBwYXJlbnQuZGF0YSAhPT0gXCJuZXN0ZWRcIikge1xuICAgICAgX3RoaXMzLl90VGltZSA9IC1fdGlueU51bTsgLy9mb3JjZXMgYSByZW5kZXIgd2l0aG91dCBoYXZpbmcgdG8gc2V0IHRoZSByZW5kZXIoKSBcImZvcmNlXCIgcGFyYW1ldGVyIHRvIHRydWUgYmVjYXVzZSB3ZSB3YW50IHRvIGFsbG93IGxhenlpbmcgYnkgZGVmYXVsdCAodXNpbmcgdGhlIFwiZm9yY2VcIiBwYXJhbWV0ZXIgYWx3YXlzIGZvcmNlcyBhbiBpbW1lZGlhdGUgZnVsbCByZW5kZXIpXG5cbiAgICAgIF90aGlzMy5yZW5kZXIoTWF0aC5tYXgoMCwgLWRlbGF5KSB8fCAwKTsgLy9pbiBjYXNlIGRlbGF5IGlzIG5lZ2F0aXZlXG5cbiAgICB9XG5cbiAgICBzY3JvbGxUcmlnZ2VyICYmIF9zY3JvbGxUcmlnZ2VyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgc2Nyb2xsVHJpZ2dlcik7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIHZhciBfcHJvdG8zID0gVHdlZW4ucHJvdG90eXBlO1xuXG4gIF9wcm90bzMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG4gICAgdmFyIHByZXZUaW1lID0gdGhpcy5fdGltZSxcbiAgICAgICAgdER1ciA9IHRoaXMuX3REdXIsXG4gICAgICAgIGR1ciA9IHRoaXMuX2R1cixcbiAgICAgICAgaXNOZWdhdGl2ZSA9IHRvdGFsVGltZSA8IDAsXG4gICAgICAgIHRUaW1lID0gdG90YWxUaW1lID4gdER1ciAtIF90aW55TnVtICYmICFpc05lZ2F0aXZlID8gdER1ciA6IHRvdGFsVGltZSA8IF90aW55TnVtID8gMCA6IHRvdGFsVGltZSxcbiAgICAgICAgdGltZSxcbiAgICAgICAgcHQsXG4gICAgICAgIGl0ZXJhdGlvbixcbiAgICAgICAgY3ljbGVEdXJhdGlvbixcbiAgICAgICAgcHJldkl0ZXJhdGlvbixcbiAgICAgICAgaXNZb3lvLFxuICAgICAgICByYXRpbyxcbiAgICAgICAgdGltZWxpbmUsXG4gICAgICAgIHlveW9FYXNlO1xuXG4gICAgaWYgKCFkdXIpIHtcbiAgICAgIF9yZW5kZXJaZXJvRHVyYXRpb25Ud2Vlbih0aGlzLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgfSBlbHNlIGlmICh0VGltZSAhPT0gdGhpcy5fdFRpbWUgfHwgIXRvdGFsVGltZSB8fCBmb3JjZSB8fCAhdGhpcy5faW5pdHRlZCAmJiB0aGlzLl90VGltZSB8fCB0aGlzLl9zdGFydEF0ICYmIHRoaXMuX3pUaW1lIDwgMCAhPT0gaXNOZWdhdGl2ZSkge1xuICAgICAgLy90aGlzIHNlbnNlcyBpZiB3ZSdyZSBjcm9zc2luZyBvdmVyIHRoZSBzdGFydCB0aW1lLCBpbiB3aGljaCBjYXNlIHdlIG11c3QgcmVjb3JkIF96VGltZSBhbmQgZm9yY2UgdGhlIHJlbmRlciwgYnV0IHdlIGRvIGl0IGluIHRoaXMgbGVuZ3RoeSBjb25kaXRpb25hbCB3YXkgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgKHVzdWFsbHkgd2UgY2FuIHNraXAgdGhlIGNhbGN1bGF0aW9ucyk6IHRoaXMuX2luaXR0ZWQgJiYgKHRoaXMuX3pUaW1lIDwgMCkgIT09ICh0b3RhbFRpbWUgPCAwKVxuICAgICAgdGltZSA9IHRUaW1lO1xuICAgICAgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lO1xuXG4gICAgICBpZiAodGhpcy5fcmVwZWF0KSB7XG4gICAgICAgIC8vYWRqdXN0IHRoZSB0aW1lIGZvciByZXBlYXRzIGFuZCB5b3lvc1xuICAgICAgICBjeWNsZUR1cmF0aW9uID0gZHVyICsgdGhpcy5fckRlbGF5O1xuXG4gICAgICAgIGlmICh0aGlzLl9yZXBlYXQgPCAtMSAmJiBpc05lZ2F0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG90YWxUaW1lKGN5Y2xlRHVyYXRpb24gKiAxMDAgKyB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lID0gX3JvdW5kUHJlY2lzZSh0VGltZSAlIGN5Y2xlRHVyYXRpb24pOyAvL3JvdW5kIHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IGVycm9ycy4gKDQgJSAwLjggc2hvdWxkIGJlIDAgYnV0IHNvbWUgYnJvd3NlcnMgcmVwb3J0IGl0IGFzIDAuNzk5OTk5OTkhKVxuXG4gICAgICAgIGlmICh0VGltZSA9PT0gdER1cikge1xuICAgICAgICAgIC8vIHRoZSB0RHVyID09PSB0VGltZSBpcyBmb3IgZWRnZSBjYXNlcyB3aGVyZSB0aGVyZSdzIGEgbGVuZ3RoeSBkZWNpbWFsIG9uIHRoZSBkdXJhdGlvbiBhbmQgaXQgbWF5IHJlYWNoIHRoZSB2ZXJ5IGVuZCBidXQgdGhlIHRpbWUgaXMgcmVuZGVyZWQgYXMgbm90LXF1aXRlLXRoZXJlIChyZW1lbWJlciwgdER1ciBpcyByb3VuZGVkIHRvIDQgZGVjaW1hbHMgd2hlcmVhcyBkdXIgaXNuJ3QpXG4gICAgICAgICAgaXRlcmF0aW9uID0gdGhpcy5fcmVwZWF0O1xuICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlcmF0aW9uID0gfn4odFRpbWUgLyBjeWNsZUR1cmF0aW9uKTtcblxuICAgICAgICAgIGlmIChpdGVyYXRpb24gJiYgaXRlcmF0aW9uID09PSBfcm91bmRQcmVjaXNlKHRUaW1lIC8gY3ljbGVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgICAgICBpdGVyYXRpb24tLTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aW1lID4gZHVyICYmICh0aW1lID0gZHVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzWW95byA9IHRoaXMuX3lveW8gJiYgaXRlcmF0aW9uICYgMTtcblxuICAgICAgICBpZiAoaXNZb3lvKSB7XG4gICAgICAgICAgeW95b0Vhc2UgPSB0aGlzLl95RWFzZTtcbiAgICAgICAgICB0aW1lID0gZHVyIC0gdGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZJdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodGhpcy5fdFRpbWUsIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgIGlmICh0aW1lID09PSBwcmV2VGltZSAmJiAhZm9yY2UgJiYgdGhpcy5faW5pdHRlZCAmJiBpdGVyYXRpb24gPT09IHByZXZJdGVyYXRpb24pIHtcbiAgICAgICAgICAvL2NvdWxkIGJlIGR1cmluZyB0aGUgcmVwZWF0RGVsYXkgcGFydC4gTm8gbmVlZCB0byByZW5kZXIgYW5kIGZpcmUgY2FsbGJhY2tzLlxuICAgICAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uKSB7XG4gICAgICAgICAgdGltZWxpbmUgJiYgdGhpcy5feUVhc2UgJiYgX3Byb3BhZ2F0ZVlveW9FYXNlKHRpbWVsaW5lLCBpc1lveW8pOyAvL3JlcGVhdFJlZnJlc2ggZnVuY3Rpb25hbGl0eVxuXG4gICAgICAgICAgaWYgKHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgIXRoaXMuX2xvY2sgJiYgdGhpcy5fdGltZSAhPT0gY3ljbGVEdXJhdGlvbiAmJiB0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgICAgICAvLyB0aGlzLl90aW1lIHdpbGwgPT09IGN5Y2xlRHVyYXRpb24gd2hlbiB3ZSByZW5kZXIgYXQgRVhBQ1RMWSB0aGUgZW5kIG9mIGFuIGl0ZXJhdGlvbi4gV2l0aG91dCB0aGlzIGNvbmRpdGlvbiwgaXQnZCBvZnRlbiBkbyB0aGUgcmVwZWF0UmVmcmVzaCByZW5kZXIgVFdJQ0UgKGFnYWluIG9uIHRoZSB2ZXJ5IG5leHQgdGljaykuXG4gICAgICAgICAgICB0aGlzLl9sb2NrID0gZm9yY2UgPSAxOyAvL2ZvcmNlLCBvdGhlcndpc2UgaWYgbGF6eSBpcyB0cnVlLCB0aGUgX2F0dGVtcHRJbml0VHdlZW4oKSB3aWxsIHJldHVybiBhbmQgd2UnbGwganVtcCBvdXQgYW5kIGdldCBjYXVnaHQgYm91bmNpbmcgb24gZWFjaCB0aWNrLlxuXG4gICAgICAgICAgICB0aGlzLnJlbmRlcihfcm91bmRQcmVjaXNlKGN5Y2xlRHVyYXRpb24gKiBpdGVyYXRpb24pLCB0cnVlKS5pbnZhbGlkYXRlKCkuX2xvY2sgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcbiAgICAgICAgaWYgKF9hdHRlbXB0SW5pdFR3ZWVuKHRoaXMsIGlzTmVnYXRpdmUgPyB0b3RhbFRpbWUgOiB0aW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMsIHRUaW1lKSkge1xuICAgICAgICAgIHRoaXMuX3RUaW1lID0gMDsgLy8gaW4gY29uc3RydWN0b3IgaWYgaW1tZWRpYXRlUmVuZGVyIGlzIHRydWUsIHdlIHNldCBfdFRpbWUgdG8gLV90aW55TnVtIHRvIGhhdmUgdGhlIHBsYXloZWFkIGNyb3NzIHRoZSBzdGFydGluZyBwb2ludCBidXQgd2UgY2FuJ3QgbGVhdmUgX3RUaW1lIGFzIGEgbmVnYXRpdmUgbnVtYmVyLlxuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldlRpbWUgIT09IHRoaXMuX3RpbWUgJiYgIShmb3JjZSAmJiB0aGlzLnZhcnMucmVwZWF0UmVmcmVzaCAmJiBpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24pKSB7XG4gICAgICAgICAgLy8gcmFyZSBlZGdlIGNhc2UgLSBkdXJpbmcgaW5pdGlhbGl6YXRpb24sIGFuIG9uVXBkYXRlIGluIHRoZSBfc3RhcnRBdCAoLmZyb21UbygpKSBtaWdodCBmb3JjZSB0aGlzIHR3ZWVuIHRvIHJlbmRlciBhdCBhIGRpZmZlcmVudCBzcG90IGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIGRpdGNoIHRoaXMgcmVuZGVyKCkgY2FsbCBzbyB0aGF0IGl0IGRvZXNuJ3QgcmV2ZXJ0IHRoZSB2YWx1ZXMuIEJ1dCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gZHVtcCBpZiB3ZSdyZSBkb2luZyBhIHJlcGVhdFJlZnJlc2ggcmVuZGVyIVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGR1ciAhPT0gdGhpcy5fZHVyKSB7XG4gICAgICAgICAgLy8gd2hpbGUgaW5pdHRpbmcsIGEgcGx1Z2luIGxpa2UgSW5lcnRpYVBsdWdpbiBtaWdodCBhbHRlciB0aGUgZHVyYXRpb24sIHNvIHJlcnVuIGZyb20gdGhlIHN0YXJ0IHRvIGVuc3VyZSBldmVyeXRoaW5nIHJlbmRlcnMgYXMgaXQgc2hvdWxkLlxuICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fdFRpbWUgPSB0VGltZTtcbiAgICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuXG4gICAgICBpZiAoIXRoaXMuX2FjdCAmJiB0aGlzLl90cykge1xuICAgICAgICB0aGlzLl9hY3QgPSAxOyAvL2FzIGxvbmcgYXMgaXQncyBub3QgcGF1c2VkLCBmb3JjZSBpdCB0byBiZSBhY3RpdmUgc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIGluZGVwZW5kZW50IG9mIHRoZSBwYXJlbnQgdGltZWxpbmUsIGl0J2xsIGJlIGZvcmNlZCB0byByZS1yZW5kZXIgb24gdGhlIG5leHQgdGljay5cblxuICAgICAgICB0aGlzLl9sYXp5ID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yYXRpbyA9IHJhdGlvID0gKHlveW9FYXNlIHx8IHRoaXMuX2Vhc2UpKHRpbWUgLyBkdXIpO1xuXG4gICAgICBpZiAodGhpcy5fZnJvbSkge1xuICAgICAgICB0aGlzLnJhdGlvID0gcmF0aW8gPSAxIC0gcmF0aW87XG4gICAgICB9XG5cbiAgICAgIGlmICh0aW1lICYmICFwcmV2VGltZSAmJiAhc3VwcHJlc3NFdmVudHMgJiYgIWl0ZXJhdGlvbikge1xuICAgICAgICBfY2FsbGJhY2sodGhpcywgXCJvblN0YXJ0XCIpO1xuXG4gICAgICAgIGlmICh0aGlzLl90VGltZSAhPT0gdFRpbWUpIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBvblN0YXJ0IHRyaWdnZXJlZCBhIHJlbmRlciBhdCBhIGRpZmZlcmVudCBzcG90LCBlamVjdC4gTGlrZSBpZiBzb21lb25lIGRpZCBhbmltYXRpb24ucGF1c2UoMC41KSBvciBzb21ldGhpbmcgaW5zaWRlIHRoZSBvblN0YXJ0LlxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHB0ID0gdGhpcy5fcHQ7XG5cbiAgICAgIHdoaWxlIChwdCkge1xuICAgICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICAgIH1cblxuICAgICAgdGltZWxpbmUgJiYgdGltZWxpbmUucmVuZGVyKHRvdGFsVGltZSA8IDAgPyB0b3RhbFRpbWUgOiB0aW1lbGluZS5fZHVyICogdGltZWxpbmUuX2Vhc2UodGltZSAvIHRoaXMuX2R1ciksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkgfHwgdGhpcy5fc3RhcnRBdCAmJiAodGhpcy5felRpbWUgPSB0b3RhbFRpbWUpO1xuXG4gICAgICBpZiAodGhpcy5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgIGlzTmVnYXRpdmUgJiYgX3Jld2luZFN0YXJ0QXQodGhpcywgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpOyAvL25vdGU6IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSB0dWNrIHRoaXMgY29uZGl0aW9uYWwgbG9naWMgaW5zaWRlIGxlc3MgdHJhdmVsZWQgYXJlYXMgKG1vc3QgdHdlZW5zIGRvbid0IGhhdmUgYW4gb25VcGRhdGUpLiBXZSdkIGp1c3QgaGF2ZSBpdCBhdCB0aGUgZW5kIGJlZm9yZSB0aGUgb25Db21wbGV0ZSwgYnV0IHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQgYmVmb3JlIGFueSBvblVwZGF0ZSBpcyBjYWxsZWQsIHNvIHdlIEFMU08gcHV0IGl0IGhlcmUgYW5kIHRoZW4gaWYgaXQncyBub3QgY2FsbGVkLCB3ZSBkbyBzbyBsYXRlciBuZWFyIHRoZSBvbkNvbXBsZXRlLlxuXG4gICAgICAgIF9jYWxsYmFjayh0aGlzLCBcIm9uVXBkYXRlXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXBlYXQgJiYgaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uICYmIHRoaXMudmFycy5vblJlcGVhdCAmJiAhc3VwcHJlc3NFdmVudHMgJiYgdGhpcy5wYXJlbnQgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25SZXBlYXRcIik7XG5cbiAgICAgIGlmICgodFRpbWUgPT09IHRoaXMuX3REdXIgfHwgIXRUaW1lKSAmJiB0aGlzLl90VGltZSA9PT0gdFRpbWUpIHtcbiAgICAgICAgaXNOZWdhdGl2ZSAmJiAhdGhpcy5fb25VcGRhdGUgJiYgX3Jld2luZFN0YXJ0QXQodGhpcywgdG90YWxUaW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgKHRvdGFsVGltZSB8fCAhZHVyKSAmJiAodFRpbWUgPT09IHRoaXMuX3REdXIgJiYgdGhpcy5fdHMgPiAwIHx8ICF0VGltZSAmJiB0aGlzLl90cyA8IDApICYmIF9yZW1vdmVGcm9tUGFyZW50KHRoaXMsIDEpOyAvLyBkb24ndCByZW1vdmUgaWYgd2UncmUgcmVuZGVyaW5nIGF0IGV4YWN0bHkgYSB0aW1lIG9mIDAsIGFzIHRoZXJlIGNvdWxkIGJlIGF1dG9SZXZlcnQgdmFsdWVzIHRoYXQgc2hvdWxkIGdldCBzZXQgb24gdGhlIG5leHQgdGljayAoaWYgdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgYmV5b25kIHRoZSBzdGFydFRpbWUsIG5lZ2F0aXZlIHRvdGFsVGltZSkuIERvbid0IHJlbW92ZSBpZiB0aGUgdGltZWxpbmUgaXMgcmV2ZXJzZWQgYW5kIHRoZSBwbGF5aGVhZCBpc24ndCBhdCAwLCBvdGhlcndpc2UgdGwucHJvZ3Jlc3MoMSkucmV2ZXJzZSgpIHdvbid0IHdvcmsuIE9ubHkgcmVtb3ZlIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCB0aGUgZW5kIGFuZCB0aW1lU2NhbGUgaXMgcG9zaXRpdmUsIG9yIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCAwIGFuZCB0aGUgdGltZVNjYWxlIGlzIG5lZ2F0aXZlLlxuXG4gICAgICAgIGlmICghc3VwcHJlc3NFdmVudHMgJiYgIShpc05lZ2F0aXZlICYmICFwcmV2VGltZSkgJiYgKHRUaW1lIHx8IHByZXZUaW1lIHx8IGlzWW95bykpIHtcbiAgICAgICAgICAvLyBpZiBwcmV2VGltZSBhbmQgdFRpbWUgYXJlIHplcm8sIHdlIHNob3VsZG4ndCBmaXJlIHRoZSBvblJldmVyc2VDb21wbGV0ZS4gVGhpcyBjb3VsZCBoYXBwZW4gaWYgeW91IGdzYXAudG8oLi4uIHtwYXVzZWQ6dHJ1ZX0pLnBsYXkoKTtcbiAgICAgICAgICBfY2FsbGJhY2sodGhpcywgdFRpbWUgPT09IHREdXIgPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiwgdHJ1ZSk7XG5cbiAgICAgICAgICB0aGlzLl9wcm9tICYmICEodFRpbWUgPCB0RHVyICYmIHRoaXMudGltZVNjYWxlKCkgPiAwKSAmJiB0aGlzLl9wcm9tKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8zLnRhcmdldHMgPSBmdW5jdGlvbiB0YXJnZXRzKCkge1xuICAgIHJldHVybiB0aGlzLl90YXJnZXRzO1xuICB9O1xuXG4gIF9wcm90bzMuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uIGludmFsaWRhdGUoc29mdCkge1xuICAgIC8vIFwic29mdFwiIGdpdmVzIHVzIGEgd2F5IHRvIGNsZWFyIG91dCBldmVyeXRoaW5nIEVYQ0VQVCB0aGUgcmVjb3JkZWQgcHJlLVwiZnJvbVwiIHBvcnRpb24gb2YgZnJvbSgpIHR3ZWVucy4gT3RoZXJ3aXNlLCBmb3IgZXhhbXBsZSwgaWYgeW91IHR3ZWVuLnByb2dyZXNzKDEpLnJlbmRlcigwLCB0cnVlIHRydWUpLmludmFsaWRhdGUoKSwgdGhlIFwiZnJvbVwiIHZhbHVlcyB3b3VsZCBwZXJzaXN0IGFuZCB0aGVuIG9uIHRoZSBuZXh0IHJlbmRlciwgdGhlIGZyb20oKSB0d2VlbnMgd291bGQgaW5pdGlhbGl6ZSBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgd291bGQgbWF0Y2ggdGhlIFwiZnJvbVwiIHZhbHVlcywgdGh1cyBhbmltYXRlIGZyb20gdGhlIHNhbWUgdmFsdWUgdG8gdGhlIHNhbWUgdmFsdWUgKG5vIGFuaW1hdGlvbikuIFdlIHRhcCBpbnRvIHRoaXMgaW4gU2Nyb2xsVHJpZ2dlcidzIHJlZnJlc2goKSB3aGVyZSB3ZSBtdXN0IHB1c2ggYSB0d2VlbiB0byBjb21wbGV0aW9uIGFuZCB0aGVuIGJhY2sgYWdhaW4gYnV0IGhvbm9yIGl0cyBpbml0IHN0YXRlIGluIGNhc2UgdGhlIHR3ZWVuIGlzIGRlcGVuZGVudCBvbiBhbm90aGVyIHR3ZWVuIGZ1cnRoZXIgdXAgb24gdGhlIHBhZ2UuXG4gICAgKCFzb2Z0IHx8ICF0aGlzLnZhcnMucnVuQmFja3dhcmRzKSAmJiAodGhpcy5fc3RhcnRBdCA9IDApO1xuICAgIHRoaXMuX3B0ID0gdGhpcy5fb3AgPSB0aGlzLl9vblVwZGF0ZSA9IHRoaXMuX2xhenkgPSB0aGlzLnJhdGlvID0gMDtcbiAgICB0aGlzLl9wdExvb2t1cCA9IFtdO1xuICAgIHRoaXMudGltZWxpbmUgJiYgdGhpcy50aW1lbGluZS5pbnZhbGlkYXRlKHNvZnQpO1xuICAgIHJldHVybiBfQW5pbWF0aW9uMi5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMsIHNvZnQpO1xuICB9O1xuXG4gIF9wcm90bzMucmVzZXRUbyA9IGZ1bmN0aW9uIHJlc2V0VG8ocHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlLCBza2lwUmVjdXJzaW9uKSB7XG4gICAgX3RpY2tlckFjdGl2ZSB8fCBfdGlja2VyLndha2UoKTtcbiAgICB0aGlzLl90cyB8fCB0aGlzLnBsYXkoKTtcbiAgICB2YXIgdGltZSA9IE1hdGgubWluKHRoaXMuX2R1ciwgKHRoaXMuX2RwLl90aW1lIC0gdGhpcy5fc3RhcnQpICogdGhpcy5fdHMpLFxuICAgICAgICByYXRpbztcbiAgICB0aGlzLl9pbml0dGVkIHx8IF9pbml0VHdlZW4odGhpcywgdGltZSk7XG4gICAgcmF0aW8gPSB0aGlzLl9lYXNlKHRpbWUgLyB0aGlzLl9kdXIpOyAvLyBkb24ndCBqdXN0IGdldCB0d2Vlbi5yYXRpbyBiZWNhdXNlIGl0IG1heSBub3QgaGF2ZSByZW5kZXJlZCB5ZXQuXG4gICAgLy8gcG9zc2libGUgZnV0dXJlIGFkZGl0aW9uIHRvIGFsbG93IGFuIG9iamVjdCB3aXRoIG11bHRpcGxlIHZhbHVlcyB0byB1cGRhdGUsIGxpa2UgdHdlZW4ucmVzZXRUbyh7eDogMTAwLCB5OiAyMDB9KTsgQXQgdGhpcyBwb2ludCwgaXQgZG9lc24ndCBzZWVtIHdvcnRoIHRoZSBhZGRlZCBrYiBnaXZlbiB0aGUgZmFjdCB0aGF0IG1vc3QgdXNlcnMgd2lsbCBsaWtlbHkgb3B0IGZvciB0aGUgY29udmVuaWVudCBnc2FwLnF1aWNrVG8oKSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCB0aGlzIG1ldGhvZC5cbiAgICAvLyBpZiAoX2lzT2JqZWN0KHByb3BlcnR5KSkgeyAvLyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25cbiAgICAvLyBcdGZvciAocCBpbiBwcm9wZXJ0eSkge1xuICAgIC8vIFx0XHRpZiAoX3VwZGF0ZVByb3BUd2VlbnModGhpcywgcCwgcHJvcGVydHlbcF0sIHZhbHVlID8gdmFsdWVbcF0gOiBudWxsLCBzdGFydCwgcmF0aW8sIHRpbWUpKSB7XG4gICAgLy8gXHRcdFx0cmV0dXJuIHRoaXMucmVzZXRUbyhwcm9wZXJ0eSwgdmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUpOyAvLyBpZiBhIFByb3BUd2VlbiB3YXNuJ3QgZm91bmQgZm9yIHRoZSBwcm9wZXJ0eSwgaXQnbGwgZ2V0IGZvcmNlZCB3aXRoIGEgcmUtaW5pdGlhbGl6YXRpb24gc28gd2UgbmVlZCB0byBqdW1wIG91dCBhbmQgc3RhcnQgb3ZlciBhZ2Fpbi5cbiAgICAvLyBcdFx0fVxuICAgIC8vIFx0fVxuICAgIC8vIH0gZWxzZSB7XG5cbiAgICBpZiAoX3VwZGF0ZVByb3BUd2VlbnModGhpcywgcHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlLCByYXRpbywgdGltZSwgc2tpcFJlY3Vyc2lvbikpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc2V0VG8ocHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlLCAxKTsgLy8gaWYgYSBQcm9wVHdlZW4gd2Fzbid0IGZvdW5kIGZvciB0aGUgcHJvcGVydHksIGl0J2xsIGdldCBmb3JjZWQgd2l0aCBhIHJlLWluaXRpYWxpemF0aW9uIHNvIHdlIG5lZWQgdG8ganVtcCBvdXQgYW5kIHN0YXJ0IG92ZXIgYWdhaW4uXG4gICAgfSAvL31cblxuXG4gICAgX2FsaWduUGxheWhlYWQodGhpcywgMCk7XG5cbiAgICB0aGlzLnBhcmVudCB8fCBfYWRkTGlua2VkTGlzdEl0ZW0odGhpcy5fZHAsIHRoaXMsIFwiX2ZpcnN0XCIsIFwiX2xhc3RcIiwgdGhpcy5fZHAuX3NvcnQgPyBcIl9zdGFydFwiIDogMCk7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyKDApO1xuICB9O1xuXG4gIF9wcm90bzMua2lsbCA9IGZ1bmN0aW9uIGtpbGwodGFyZ2V0cywgdmFycykge1xuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgIHZhcnMgPSBcImFsbFwiO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0cyAmJiAoIXZhcnMgfHwgdmFycyA9PT0gXCJhbGxcIikpIHtcbiAgICAgIHRoaXMuX2xhenkgPSB0aGlzLl9wdCA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyBfaW50ZXJydXB0KHRoaXMpIDogdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy50aW1lbGluZSkge1xuICAgICAgdmFyIHREdXIgPSB0aGlzLnRpbWVsaW5lLnRvdGFsRHVyYXRpb24oKTtcbiAgICAgIHRoaXMudGltZWxpbmUua2lsbFR3ZWVuc09mKHRhcmdldHMsIHZhcnMsIF9vdmVyd3JpdGluZ1R3ZWVuICYmIF9vdmVyd3JpdGluZ1R3ZWVuLnZhcnMub3ZlcndyaXRlICE9PSB0cnVlKS5fZmlyc3QgfHwgX2ludGVycnVwdCh0aGlzKTsgLy8gaWYgbm90aGluZyBpcyBsZWZ0IHR3ZWVuaW5nLCBpbnRlcnJ1cHQuXG5cbiAgICAgIHRoaXMucGFyZW50ICYmIHREdXIgIT09IHRoaXMudGltZWxpbmUudG90YWxEdXJhdGlvbigpICYmIF9zZXREdXJhdGlvbih0aGlzLCB0aGlzLl9kdXIgKiB0aGlzLnRpbWVsaW5lLl90RHVyIC8gdER1ciwgMCwgMSk7IC8vIGlmIGEgbmVzdGVkIHR3ZWVuIGlzIGtpbGxlZCB0aGF0IGNoYW5nZXMgdGhlIGR1cmF0aW9uLCBpdCBzaG91bGQgYWZmZWN0IHRoaXMgdHdlZW4ncyBkdXJhdGlvbi4gV2UgbXVzdCB1c2UgdGhlIHJhdGlvLCB0aG91Z2gsIGJlY2F1c2Ugc29tZXRpbWVzIHRoZSBpbnRlcm5hbCB0aW1lbGluZSBpcyBzdHJldGNoZWQgbGlrZSBmb3Iga2V5ZnJhbWVzIHdoZXJlIHRoZXkgZG9uJ3QgYWxsIGFkZCB1cCB0byB3aGF0ZXZlciB0aGUgcGFyZW50IHR3ZWVuJ3MgZHVyYXRpb24gd2FzIHNldCB0by5cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZFRhcmdldHMgPSB0aGlzLl90YXJnZXRzLFxuICAgICAgICBraWxsaW5nVGFyZ2V0cyA9IHRhcmdldHMgPyB0b0FycmF5KHRhcmdldHMpIDogcGFyc2VkVGFyZ2V0cyxcbiAgICAgICAgcHJvcFR3ZWVuTG9va3VwID0gdGhpcy5fcHRMb29rdXAsXG4gICAgICAgIGZpcnN0UFQgPSB0aGlzLl9wdCxcbiAgICAgICAgb3ZlcndyaXR0ZW5Qcm9wcyxcbiAgICAgICAgY3VyTG9va3VwLFxuICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHAsXG4gICAgICAgIHB0LFxuICAgICAgICBpO1xuXG4gICAgaWYgKCghdmFycyB8fCB2YXJzID09PSBcImFsbFwiKSAmJiBfYXJyYXlzTWF0Y2gocGFyc2VkVGFyZ2V0cywga2lsbGluZ1RhcmdldHMpKSB7XG4gICAgICB2YXJzID09PSBcImFsbFwiICYmICh0aGlzLl9wdCA9IDApO1xuICAgICAgcmV0dXJuIF9pbnRlcnJ1cHQodGhpcyk7XG4gICAgfVxuXG4gICAgb3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX29wID0gdGhpcy5fb3AgfHwgW107XG5cbiAgICBpZiAodmFycyAhPT0gXCJhbGxcIikge1xuICAgICAgLy9zbyBwZW9wbGUgY2FuIHBhc3MgaW4gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lc1xuICAgICAgaWYgKF9pc1N0cmluZyh2YXJzKSkge1xuICAgICAgICBwID0ge307XG5cbiAgICAgICAgX2ZvckVhY2hOYW1lKHZhcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHBbbmFtZV0gPSAxO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXJzID0gcDtcbiAgICAgIH1cblxuICAgICAgdmFycyA9IF9hZGRBbGlhc2VzVG9WYXJzKHBhcnNlZFRhcmdldHMsIHZhcnMpO1xuICAgIH1cblxuICAgIGkgPSBwYXJzZWRUYXJnZXRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmICh+a2lsbGluZ1RhcmdldHMuaW5kZXhPZihwYXJzZWRUYXJnZXRzW2ldKSkge1xuICAgICAgICBjdXJMb29rdXAgPSBwcm9wVHdlZW5Mb29rdXBbaV07XG5cbiAgICAgICAgaWYgKHZhcnMgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgICBvdmVyd3JpdHRlblByb3BzW2ldID0gdmFycztcbiAgICAgICAgICBwcm9wcyA9IGN1ckxvb2t1cDtcbiAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyA9IHt9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1ck92ZXJ3cml0ZVByb3BzID0gb3ZlcndyaXR0ZW5Qcm9wc1tpXSA9IG92ZXJ3cml0dGVuUHJvcHNbaV0gfHwge307XG4gICAgICAgICAgcHJvcHMgPSB2YXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChwIGluIHByb3BzKSB7XG4gICAgICAgICAgcHQgPSBjdXJMb29rdXAgJiYgY3VyTG9va3VwW3BdO1xuXG4gICAgICAgICAgaWYgKHB0KSB7XG4gICAgICAgICAgICBpZiAoIShcImtpbGxcIiBpbiBwdC5kKSB8fCBwdC5kLmtpbGwocCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtKHRoaXMsIHB0LCBcIl9wdFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGN1ckxvb2t1cFtwXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3VyT3ZlcndyaXRlUHJvcHMgIT09IFwiYWxsXCIpIHtcbiAgICAgICAgICAgIGN1ck92ZXJ3cml0ZVByb3BzW3BdID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9pbml0dGVkICYmICF0aGlzLl9wdCAmJiBmaXJzdFBUICYmIF9pbnRlcnJ1cHQodGhpcyk7IC8vaWYgYWxsIHR3ZWVuaW5nIHByb3BlcnRpZXMgYXJlIGtpbGxlZCwga2lsbCB0aGUgdHdlZW4uIFdpdGhvdXQgdGhpcyBsaW5lLCBpZiB0aGVyZSdzIGEgdHdlZW4gd2l0aCBtdWx0aXBsZSB0YXJnZXRzIGFuZCB0aGVuIHlvdSBraWxsVHdlZW5zT2YoKSBlYWNoIHRhcmdldCBpbmRpdmlkdWFsbHksIHRoZSB0d2VlbiB3b3VsZCB0ZWNobmljYWxseSBzdGlsbCByZW1haW4gYWN0aXZlIGFuZCBmaXJlIGl0cyBvbkNvbXBsZXRlIGV2ZW4gdGhvdWdoIHRoZXJlIGFyZW4ndCBhbnkgbW9yZSBwcm9wZXJ0aWVzIHR3ZWVuaW5nLlxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgVHdlZW4udG8gPSBmdW5jdGlvbiB0byh0YXJnZXRzLCB2YXJzKSB7XG4gICAgcmV0dXJuIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzLCBhcmd1bWVudHNbMl0pO1xuICB9O1xuXG4gIFR3ZWVuLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRhcmdldHMsIHZhcnMpIHtcbiAgICByZXR1cm4gX2NyZWF0ZVR3ZWVuVHlwZSgxLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIFR3ZWVuLmRlbGF5ZWRDYWxsID0gZnVuY3Rpb24gZGVsYXllZENhbGwoZGVsYXksIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG4gICAgcmV0dXJuIG5ldyBUd2VlbihjYWxsYmFjaywgMCwge1xuICAgICAgaW1tZWRpYXRlUmVuZGVyOiBmYWxzZSxcbiAgICAgIGxhenk6IGZhbHNlLFxuICAgICAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgIG9uQ29tcGxldGU6IGNhbGxiYWNrLFxuICAgICAgb25SZXZlcnNlQ29tcGxldGU6IGNhbGxiYWNrLFxuICAgICAgb25Db21wbGV0ZVBhcmFtczogcGFyYW1zLFxuICAgICAgb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6IHBhcmFtcyxcbiAgICAgIGNhbGxiYWNrU2NvcGU6IHNjb3BlXG4gICAgfSk7IC8vIHdlIG11c3QgdXNlIG9uUmV2ZXJzZUNvbXBsZXRlIHRvbyBmb3IgdGhpbmdzIGxpa2UgdGltZWxpbmUuYWRkKCgpID0+IHsuLi59KSB3aGljaCBzaG91bGQgYmUgdHJpZ2dlcmVkIGluIEJPVEggZGlyZWN0aW9ucyAoZm9yd2FyZCBhbmQgcmV2ZXJzZSlcbiAgfTtcblxuICBUd2Vlbi5mcm9tVG8gPSBmdW5jdGlvbiBmcm9tVG8odGFyZ2V0cywgZnJvbVZhcnMsIHRvVmFycykge1xuICAgIHJldHVybiBfY3JlYXRlVHdlZW5UeXBlKDIsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgVHdlZW4uc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldHMsIHZhcnMpIHtcbiAgICB2YXJzLmR1cmF0aW9uID0gMDtcbiAgICB2YXJzLnJlcGVhdERlbGF5IHx8ICh2YXJzLnJlcGVhdCA9IDApO1xuICAgIHJldHVybiBuZXcgVHdlZW4odGFyZ2V0cywgdmFycyk7XG4gIH07XG5cbiAgVHdlZW4ua2lsbFR3ZWVuc09mID0gZnVuY3Rpb24ga2lsbFR3ZWVuc09mKHRhcmdldHMsIHByb3BzLCBvbmx5QWN0aXZlKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5raWxsVHdlZW5zT2YodGFyZ2V0cywgcHJvcHMsIG9ubHlBY3RpdmUpO1xuICB9O1xuXG4gIHJldHVybiBUd2Vlbjtcbn0oQW5pbWF0aW9uKTtcblxuX3NldERlZmF1bHRzKFR3ZWVuLnByb3RvdHlwZSwge1xuICBfdGFyZ2V0czogW10sXG4gIF9sYXp5OiAwLFxuICBfc3RhcnRBdDogMCxcbiAgX29wOiAwLFxuICBfb25Jbml0OiAwXG59KTsgLy9hZGQgdGhlIHBlcnRpbmVudCB0aW1lbGluZSBtZXRob2RzIHRvIFR3ZWVuIGluc3RhbmNlcyBzbyB0aGF0IHVzZXJzIGNhbiBjaGFpbiBjb252ZW5pZW50bHkgYW5kIGNyZWF0ZSBhIHRpbWVsaW5lIGF1dG9tYXRpY2FsbHkuIChyZW1vdmVkIGR1ZSB0byBjb25jZXJucyB0aGF0IGl0J2QgdWx0aW1hdGVseSBhZGQgdG8gbW9yZSBjb25mdXNpb24gZXNwZWNpYWxseSBmb3IgYmVnaW5uZXJzKVxuLy8gX2ZvckVhY2hOYW1lKFwidG8sZnJvbSxmcm9tVG8sc2V0LGNhbGwsYWRkLGFkZExhYmVsLGFkZFBhdXNlXCIsIG5hbWUgPT4ge1xuLy8gXHRUd2Vlbi5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbi8vIFx0XHRsZXQgdGwgPSBuZXcgVGltZWxpbmUoKTtcbi8vIFx0XHRyZXR1cm4gX2FkZFRvVGltZWxpbmUodGwsIHRoaXMpW25hbWVdLmFwcGx5KHRsLCB0b0FycmF5KGFyZ3VtZW50cykpO1xuLy8gXHR9XG4vLyB9KTtcbi8vZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIExldmVyYWdlIHRoZSB0aW1lbGluZSBjYWxscy5cblxuXG5fZm9yRWFjaE5hbWUoXCJzdGFnZ2VyVG8sc3RhZ2dlckZyb20sc3RhZ2dlckZyb21Ub1wiLCBmdW5jdGlvbiAobmFtZSkge1xuICBUd2VlbltuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGwgPSBuZXcgVGltZWxpbmUoKSxcbiAgICAgICAgcGFyYW1zID0gX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIHBhcmFtcy5zcGxpY2UobmFtZSA9PT0gXCJzdGFnZ2VyRnJvbVRvXCIgPyA1IDogNCwgMCwgMCk7XG4gICAgcmV0dXJuIHRsW25hbWVdLmFwcGx5KHRsLCBwYXJhbXMpO1xuICB9O1xufSk7XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFBST1BUV0VFTlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbnZhciBfc2V0dGVyUGxhaW4gPSBmdW5jdGlvbiBfc2V0dGVyUGxhaW4odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbn0sXG4gICAgX3NldHRlckZ1bmMgPSBmdW5jdGlvbiBfc2V0dGVyRnVuYyh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XSh2YWx1ZSk7XG59LFxuICAgIF9zZXR0ZXJGdW5jV2l0aFBhcmFtID0gZnVuY3Rpb24gX3NldHRlckZ1bmNXaXRoUGFyYW0odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEpIHtcbiAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eV0oZGF0YS5mcCwgdmFsdWUpO1xufSxcbiAgICBfc2V0dGVyQXR0cmlidXRlID0gZnVuY3Rpb24gX3NldHRlckF0dHJpYnV0ZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0LnNldEF0dHJpYnV0ZShwcm9wZXJ0eSwgdmFsdWUpO1xufSxcbiAgICBfZ2V0U2V0dGVyID0gZnVuY3Rpb24gX2dldFNldHRlcih0YXJnZXQsIHByb3BlcnR5KSB7XG4gIHJldHVybiBfaXNGdW5jdGlvbih0YXJnZXRbcHJvcGVydHldKSA/IF9zZXR0ZXJGdW5jIDogX2lzVW5kZWZpbmVkKHRhcmdldFtwcm9wZXJ0eV0pICYmIHRhcmdldC5zZXRBdHRyaWJ1dGUgPyBfc2V0dGVyQXR0cmlidXRlIDogX3NldHRlclBsYWluO1xufSxcbiAgICBfcmVuZGVyUGxhaW4gPSBmdW5jdGlvbiBfcmVuZGVyUGxhaW4ocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMDAwKSAvIDEwMDAwMDAsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyQm9vbGVhbiA9IGZ1bmN0aW9uIF9yZW5kZXJCb29sZWFuKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgISEoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pLCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlckNvbXBsZXhTdHJpbmcgPSBmdW5jdGlvbiBfcmVuZGVyQ29tcGxleFN0cmluZyhyYXRpbywgZGF0YSkge1xuICB2YXIgcHQgPSBkYXRhLl9wdCxcbiAgICAgIHMgPSBcIlwiO1xuXG4gIGlmICghcmF0aW8gJiYgZGF0YS5iKSB7XG4gICAgLy9iID0gYmVnaW5uaW5nIHN0cmluZ1xuICAgIHMgPSBkYXRhLmI7XG4gIH0gZWxzZSBpZiAocmF0aW8gPT09IDEgJiYgZGF0YS5lKSB7XG4gICAgLy9lID0gZW5kaW5nIHN0cmluZ1xuICAgIHMgPSBkYXRhLmU7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBzID0gcHQucCArIChwdC5tID8gcHQubShwdC5zICsgcHQuYyAqIHJhdGlvKSA6IE1hdGgucm91bmQoKHB0LnMgKyBwdC5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDApICsgczsgLy93ZSB1c2UgdGhlIFwicFwiIHByb3BlcnR5IGZvciB0aGUgdGV4dCBpbmJldHdlZW4gKGxpa2UgYSBzdWZmaXgpLiBBbmQgaW4gdGhlIGNvbnRleHQgb2YgYSBjb21wbGV4IHN0cmluZywgdGhlIG1vZGlmaWVyIChtKSBpcyB0eXBpY2FsbHkganVzdCBNYXRoLnJvdW5kKCksIGxpa2UgZm9yIFJHQiBjb2xvcnMuXG5cbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuXG4gICAgcyArPSBkYXRhLmM7IC8vd2UgdXNlIHRoZSBcImNcIiBvZiB0aGUgUHJvcFR3ZWVuIHRvIHN0b3JlIHRoZSBmaW5hbCBjaHVuayBvZiBub24tbnVtZXJpYyB0ZXh0LlxuICB9XG5cbiAgZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHMsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyUHJvcFR3ZWVucyA9IGZ1bmN0aW9uIF9yZW5kZXJQcm9wVHdlZW5zKHJhdGlvLCBkYXRhKSB7XG4gIHZhciBwdCA9IGRhdGEuX3B0O1xuXG4gIHdoaWxlIChwdCkge1xuICAgIHB0LnIocmF0aW8sIHB0LmQpO1xuICAgIHB0ID0gcHQuX25leHQ7XG4gIH1cbn0sXG4gICAgX2FkZFBsdWdpbk1vZGlmaWVyID0gZnVuY3Rpb24gX2FkZFBsdWdpbk1vZGlmaWVyKG1vZGlmaWVyLCB0d2VlbiwgdGFyZ2V0LCBwcm9wZXJ0eSkge1xuICB2YXIgcHQgPSB0aGlzLl9wdCxcbiAgICAgIG5leHQ7XG5cbiAgd2hpbGUgKHB0KSB7XG4gICAgbmV4dCA9IHB0Ll9uZXh0O1xuICAgIHB0LnAgPT09IHByb3BlcnR5ICYmIHB0Lm1vZGlmaWVyKG1vZGlmaWVyLCB0d2VlbiwgdGFyZ2V0KTtcbiAgICBwdCA9IG5leHQ7XG4gIH1cbn0sXG4gICAgX2tpbGxQcm9wVHdlZW5zT2YgPSBmdW5jdGlvbiBfa2lsbFByb3BUd2VlbnNPZihwcm9wZXJ0eSkge1xuICB2YXIgcHQgPSB0aGlzLl9wdCxcbiAgICAgIGhhc05vbkRlcGVuZGVudFJlbWFpbmluZyxcbiAgICAgIG5leHQ7XG5cbiAgd2hpbGUgKHB0KSB7XG4gICAgbmV4dCA9IHB0Ll9uZXh0O1xuXG4gICAgaWYgKHB0LnAgPT09IHByb3BlcnR5ICYmICFwdC5vcCB8fCBwdC5vcCA9PT0gcHJvcGVydHkpIHtcbiAgICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSh0aGlzLCBwdCwgXCJfcHRcIik7XG4gICAgfSBlbHNlIGlmICghcHQuZGVwKSB7XG4gICAgICBoYXNOb25EZXBlbmRlbnRSZW1haW5pbmcgPSAxO1xuICAgIH1cblxuICAgIHB0ID0gbmV4dDtcbiAgfVxuXG4gIHJldHVybiAhaGFzTm9uRGVwZW5kZW50UmVtYWluaW5nO1xufSxcbiAgICBfc2V0dGVyV2l0aE1vZGlmaWVyID0gZnVuY3Rpb24gX3NldHRlcldpdGhNb2RpZmllcih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSkge1xuICBkYXRhLm1TZXQodGFyZ2V0LCBwcm9wZXJ0eSwgZGF0YS5tLmNhbGwoZGF0YS50d2VlbiwgdmFsdWUsIGRhdGEubXQpLCBkYXRhKTtcbn0sXG4gICAgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSA9IGZ1bmN0aW9uIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkocGFyZW50KSB7XG4gIHZhciBwdCA9IHBhcmVudC5fcHQsXG4gICAgICBuZXh0LFxuICAgICAgcHQyLFxuICAgICAgZmlyc3QsXG4gICAgICBsYXN0OyAvL3NvcnRzIHRoZSBQcm9wVHdlZW4gbGlua2VkIGxpc3QgaW4gb3JkZXIgb2YgcHJpb3JpdHkgYmVjYXVzZSBzb21lIHBsdWdpbnMgbmVlZCB0byBkbyB0aGVpciB3b3JrIGFmdGVyIEFMTCBvZiB0aGUgUHJvcFR3ZWVucyB3ZXJlIGNyZWF0ZWQgKGxpa2UgUm91bmRQcm9wc1BsdWdpbiBhbmQgTW9kaWZpZXJzUGx1Z2luKVxuXG4gIHdoaWxlIChwdCkge1xuICAgIG5leHQgPSBwdC5fbmV4dDtcbiAgICBwdDIgPSBmaXJzdDtcblxuICAgIHdoaWxlIChwdDIgJiYgcHQyLnByID4gcHQucHIpIHtcbiAgICAgIHB0MiA9IHB0Mi5fbmV4dDtcbiAgICB9XG5cbiAgICBpZiAocHQuX3ByZXYgPSBwdDIgPyBwdDIuX3ByZXYgOiBsYXN0KSB7XG4gICAgICBwdC5fcHJldi5fbmV4dCA9IHB0O1xuICAgIH0gZWxzZSB7XG4gICAgICBmaXJzdCA9IHB0O1xuICAgIH1cblxuICAgIGlmIChwdC5fbmV4dCA9IHB0Mikge1xuICAgICAgcHQyLl9wcmV2ID0gcHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSBwdDtcbiAgICB9XG5cbiAgICBwdCA9IG5leHQ7XG4gIH1cblxuICBwYXJlbnQuX3B0ID0gZmlyc3Q7XG59OyAvL1Byb3BUd2VlbiBrZXk6IHQgPSB0YXJnZXQsIHAgPSBwcm9wLCByID0gcmVuZGVyZXIsIGQgPSBkYXRhLCBzID0gc3RhcnQsIGMgPSBjaGFuZ2UsIG9wID0gb3ZlcndyaXRlUHJvcGVydHkgKE9OTFkgcG9wdWxhdGVkIHdoZW4gaXQncyBkaWZmZXJlbnQgdGhhbiBwKSwgcHIgPSBwcmlvcml0eSwgX25leHQvX3ByZXYgZm9yIHRoZSBsaW5rZWQgbGlzdCBzaWJsaW5ncywgc2V0ID0gc2V0dGVyLCBtID0gbW9kaWZpZXIsIG1TZXQgPSBtb2RpZmllclNldHRlciAodGhlIG9yaWdpbmFsIHNldHRlciwgYmVmb3JlIGEgbW9kaWZpZXIgd2FzIGFkZGVkKVxuXG5cbmV4cG9ydCB2YXIgUHJvcFR3ZWVuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUHJvcFR3ZWVuKG5leHQsIHRhcmdldCwgcHJvcCwgc3RhcnQsIGNoYW5nZSwgcmVuZGVyZXIsIGRhdGEsIHNldHRlciwgcHJpb3JpdHkpIHtcbiAgICB0aGlzLnQgPSB0YXJnZXQ7XG4gICAgdGhpcy5zID0gc3RhcnQ7XG4gICAgdGhpcy5jID0gY2hhbmdlO1xuICAgIHRoaXMucCA9IHByb3A7XG4gICAgdGhpcy5yID0gcmVuZGVyZXIgfHwgX3JlbmRlclBsYWluO1xuICAgIHRoaXMuZCA9IGRhdGEgfHwgdGhpcztcbiAgICB0aGlzLnNldCA9IHNldHRlciB8fCBfc2V0dGVyUGxhaW47XG4gICAgdGhpcy5wciA9IHByaW9yaXR5IHx8IDA7XG4gICAgdGhpcy5fbmV4dCA9IG5leHQ7XG5cbiAgICBpZiAobmV4dCkge1xuICAgICAgbmV4dC5fcHJldiA9IHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90bzQgPSBQcm9wVHdlZW4ucHJvdG90eXBlO1xuXG4gIF9wcm90bzQubW9kaWZpZXIgPSBmdW5jdGlvbiBtb2RpZmllcihmdW5jLCB0d2VlbiwgdGFyZ2V0KSB7XG4gICAgdGhpcy5tU2V0ID0gdGhpcy5tU2V0IHx8IHRoaXMuc2V0OyAvL2luIGNhc2UgaXQgd2FzIGFscmVhZHkgc2V0IChhIFByb3BUd2VlbiBjYW4gb25seSBoYXZlIG9uZSBtb2RpZmllcilcblxuICAgIHRoaXMuc2V0ID0gX3NldHRlcldpdGhNb2RpZmllcjtcbiAgICB0aGlzLm0gPSBmdW5jO1xuICAgIHRoaXMubXQgPSB0YXJnZXQ7IC8vbW9kaWZpZXIgdGFyZ2V0XG5cbiAgICB0aGlzLnR3ZWVuID0gdHdlZW47XG4gIH07XG5cbiAgcmV0dXJuIFByb3BUd2Vlbjtcbn0oKTsgLy9Jbml0aWFsaXphdGlvbiB0YXNrc1xuXG5fZm9yRWFjaE5hbWUoX2NhbGxiYWNrTmFtZXMgKyBcInBhcmVudCxkdXJhdGlvbixlYXNlLGRlbGF5LG92ZXJ3cml0ZSxydW5CYWNrd2FyZHMsc3RhcnRBdCx5b3lvLGltbWVkaWF0ZVJlbmRlcixyZXBlYXQscmVwZWF0RGVsYXksZGF0YSxwYXVzZWQscmV2ZXJzZWQsbGF6eSxjYWxsYmFja1Njb3BlLHN0cmluZ0ZpbHRlcixpZCx5b3lvRWFzZSxzdGFnZ2VyLGluaGVyaXQscmVwZWF0UmVmcmVzaCxrZXlmcmFtZXMsYXV0b1JldmVydCxzY3JvbGxUcmlnZ2VyXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfcmVzZXJ2ZWRQcm9wc1tuYW1lXSA9IDE7XG59KTtcblxuX2dsb2JhbHMuVHdlZW5NYXggPSBfZ2xvYmFscy5Ud2VlbkxpdGUgPSBUd2Vlbjtcbl9nbG9iYWxzLlRpbWVsaW5lTGl0ZSA9IF9nbG9iYWxzLlRpbWVsaW5lTWF4ID0gVGltZWxpbmU7XG5fZ2xvYmFsVGltZWxpbmUgPSBuZXcgVGltZWxpbmUoe1xuICBzb3J0Q2hpbGRyZW46IGZhbHNlLFxuICBkZWZhdWx0czogX2RlZmF1bHRzLFxuICBhdXRvUmVtb3ZlQ2hpbGRyZW46IHRydWUsXG4gIGlkOiBcInJvb3RcIixcbiAgc21vb3RoQ2hpbGRUaW1pbmc6IHRydWVcbn0pO1xuX2NvbmZpZy5zdHJpbmdGaWx0ZXIgPSBfY29sb3JTdHJpbmdGaWx0ZXI7XG5cbnZhciBfbWVkaWEgPSBbXSxcbiAgICBfbGlzdGVuZXJzID0ge30sXG4gICAgX2VtcHR5QXJyYXkgPSBbXSxcbiAgICBfbGFzdE1lZGlhVGltZSA9IDAsXG4gICAgX2NvbnRleHRJRCA9IDAsXG4gICAgX2Rpc3BhdGNoID0gZnVuY3Rpb24gX2Rpc3BhdGNoKHR5cGUpIHtcbiAgcmV0dXJuIChfbGlzdGVuZXJzW3R5cGVdIHx8IF9lbXB0eUFycmF5KS5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gZigpO1xuICB9KTtcbn0sXG4gICAgX29uTWVkaWFDaGFuZ2UgPSBmdW5jdGlvbiBfb25NZWRpYUNoYW5nZSgpIHtcbiAgdmFyIHRpbWUgPSBEYXRlLm5vdygpLFxuICAgICAgbWF0Y2hlcyA9IFtdO1xuXG4gIGlmICh0aW1lIC0gX2xhc3RNZWRpYVRpbWUgPiAyKSB7XG4gICAgX2Rpc3BhdGNoKFwibWF0Y2hNZWRpYUluaXRcIik7XG5cbiAgICBfbWVkaWEuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgdmFyIHF1ZXJpZXMgPSBjLnF1ZXJpZXMsXG4gICAgICAgICAgY29uZGl0aW9ucyA9IGMuY29uZGl0aW9ucyxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBwLFxuICAgICAgICAgIGFueU1hdGNoLFxuICAgICAgICAgIHRvZ2dsZWQ7XG5cbiAgICAgIGZvciAocCBpbiBxdWVyaWVzKSB7XG4gICAgICAgIG1hdGNoID0gX3dpbi5tYXRjaE1lZGlhKHF1ZXJpZXNbcF0pLm1hdGNoZXM7IC8vIEZpcmVmb3ggZG9lc24ndCB1cGRhdGUgdGhlIFwibWF0Y2hlc1wiIHByb3BlcnR5IG9mIHRoZSBNZWRpYVF1ZXJ5TGlzdCBvYmplY3QgY29ycmVjdGx5IC0gaXQgb25seSBkb2VzIHNvIGFzIGl0IGNhbGxzIGl0cyBjaGFuZ2UgaGFuZGxlciAtIHNvIHdlIG11c3QgcmUtY3JlYXRlIGEgbWVkaWEgcXVlcnkgaGVyZSB0byBlbnN1cmUgaXQncyBhY2N1cmF0ZS5cblxuICAgICAgICBtYXRjaCAmJiAoYW55TWF0Y2ggPSAxKTtcblxuICAgICAgICBpZiAobWF0Y2ggIT09IGNvbmRpdGlvbnNbcF0pIHtcbiAgICAgICAgICBjb25kaXRpb25zW3BdID0gbWF0Y2g7XG4gICAgICAgICAgdG9nZ2xlZCA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRvZ2dsZWQpIHtcbiAgICAgICAgYy5yZXZlcnQoKTtcbiAgICAgICAgYW55TWF0Y2ggJiYgbWF0Y2hlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2Rpc3BhdGNoKFwibWF0Y2hNZWRpYVJldmVydFwiKTtcblxuICAgIG1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMub25NYXRjaChjLCBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICByZXR1cm4gYy5hZGQobnVsbCwgZnVuYyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBfbGFzdE1lZGlhVGltZSA9IHRpbWU7XG5cbiAgICBfZGlzcGF0Y2goXCJtYXRjaE1lZGlhXCIpO1xuICB9XG59O1xuXG52YXIgQ29udGV4dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbnRleHQoZnVuYywgc2NvcGUpIHtcbiAgICB0aGlzLnNlbGVjdG9yID0gc2NvcGUgJiYgc2VsZWN0b3Ioc2NvcGUpO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMuX3IgPSBbXTsgLy8gcmV0dXJuZWQvY2xlYW51cCBmdW5jdGlvbnNcblxuICAgIHRoaXMuaXNSZXZlcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuaWQgPSBfY29udGV4dElEKys7IC8vIHRvIHdvcmsgYXJvdW5kIGlzc3VlcyB0aGF0IGZyYW1ld29ya3MgbGlrZSBWdWUgY2F1c2UgYnkgbWFraW5nIHRoaW5ncyBpbnRvIFByb3hpZXMgd2hpY2ggbWFrZSBpdCBpbXBvc3NpYmxlIHRvIGRvIHNvbWV0aGluZyBsaWtlIF9tZWRpYS5pbmRleE9mKHRoaXMpIGJlY2F1c2UgXCJ0aGlzXCIgd291bGQgbm8gbG9uZ2VyIHJlZmVyIHRvIHRoZSBDb250ZXh0IGluc3RhbmNlIGl0c2VsZiAtIGl0J2QgcmVmZXIgdG8gYSBQcm94eSEgV2UgbmVlZGVkIGEgd2F5IHRvIGlkZW50aWZ5IHRoZSBjb250ZXh0IHVuaXF1ZWx5XG5cbiAgICBmdW5jICYmIHRoaXMuYWRkKGZ1bmMpO1xuICB9XG5cbiAgdmFyIF9wcm90bzUgPSBDb250ZXh0LnByb3RvdHlwZTtcblxuICBfcHJvdG81LmFkZCA9IGZ1bmN0aW9uIGFkZChuYW1lLCBmdW5jLCBzY29wZSkge1xuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBhZGRpdGlvbiBpZiB3ZSBuZWVkIHRoZSBhYmlsaXR5IHRvIGFkZCgpIGFuIGFuaW1hdGlvbiB0byBhIGNvbnRleHQgYW5kIGZvciB3aGF0ZXZlciByZWFzb24gY2Fubm90IGNyZWF0ZSB0aGF0IGFuaW1hdGlvbiBpbnNpZGUgb2YgYSBjb250ZXh0LmFkZCgoKSA9PiB7Li4ufSkgZnVuY3Rpb24uXG4gICAgLy8gaWYgKG5hbWUgJiYgX2lzRnVuY3Rpb24obmFtZS5yZXZlcnQpKSB7XG4gICAgLy8gXHR0aGlzLmRhdGEucHVzaChuYW1lKTtcbiAgICAvLyBcdHJldHVybiAobmFtZS5fY3R4ID0gdGhpcyk7XG4gICAgLy8gfVxuICAgIGlmIChfaXNGdW5jdGlvbihuYW1lKSkge1xuICAgICAgc2NvcGUgPSBmdW5jO1xuICAgICAgZnVuYyA9IG5hbWU7XG4gICAgICBuYW1lID0gX2lzRnVuY3Rpb247XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBmID0gZnVuY3Rpb24gZigpIHtcbiAgICAgIHZhciBwcmV2ID0gX2NvbnRleHQsXG4gICAgICAgICAgcHJldlNlbGVjdG9yID0gc2VsZi5zZWxlY3RvcixcbiAgICAgICAgICByZXN1bHQ7XG4gICAgICBwcmV2ICYmIHByZXYgIT09IHNlbGYgJiYgcHJldi5kYXRhLnB1c2goc2VsZik7XG4gICAgICBzY29wZSAmJiAoc2VsZi5zZWxlY3RvciA9IHNlbGVjdG9yKHNjb3BlKSk7XG4gICAgICBfY29udGV4dCA9IHNlbGY7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICBfaXNGdW5jdGlvbihyZXN1bHQpICYmIHNlbGYuX3IucHVzaChyZXN1bHQpO1xuICAgICAgX2NvbnRleHQgPSBwcmV2O1xuICAgICAgc2VsZi5zZWxlY3RvciA9IHByZXZTZWxlY3RvcjtcbiAgICAgIHNlbGYuaXNSZXZlcnRlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgc2VsZi5sYXN0ID0gZjtcbiAgICByZXR1cm4gbmFtZSA9PT0gX2lzRnVuY3Rpb24gPyBmKHNlbGYsIGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICByZXR1cm4gc2VsZi5hZGQobnVsbCwgZnVuYyk7XG4gICAgfSkgOiBuYW1lID8gc2VsZltuYW1lXSA9IGYgOiBmO1xuICB9O1xuXG4gIF9wcm90bzUuaWdub3JlID0gZnVuY3Rpb24gaWdub3JlKGZ1bmMpIHtcbiAgICB2YXIgcHJldiA9IF9jb250ZXh0O1xuICAgIF9jb250ZXh0ID0gbnVsbDtcbiAgICBmdW5jKHRoaXMpO1xuICAgIF9jb250ZXh0ID0gcHJldjtcbiAgfTtcblxuICBfcHJvdG81LmdldFR3ZWVucyA9IGZ1bmN0aW9uIGdldFR3ZWVucygpIHtcbiAgICB2YXIgYSA9IFtdO1xuICAgIHRoaXMuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIENvbnRleHQgPyBhLnB1c2guYXBwbHkoYSwgZS5nZXRUd2VlbnMoKSkgOiBlIGluc3RhbmNlb2YgVHdlZW4gJiYgIShlLnBhcmVudCAmJiBlLnBhcmVudC5kYXRhID09PSBcIm5lc3RlZFwiKSAmJiBhLnB1c2goZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgX3Byb3RvNS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuX3IubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgX3Byb3RvNS5raWxsID0gZnVuY3Rpb24ga2lsbChyZXZlcnQsIG1hdGNoTWVkaWEpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIGlmIChyZXZlcnQpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0d2VlbnMgPSBfdGhpczQuZ2V0VHdlZW5zKCksXG4gICAgICAgICAgICBpID0gX3RoaXM0LmRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgdDtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgLy8gRmxpcCBwbHVnaW4gdHdlZW5zIGFyZSB2ZXJ5IGRpZmZlcmVudCBpbiB0aGF0IHRoZXkgc2hvdWxkIGFjdHVhbGx5IGJlIHB1c2hlZCB0byB0aGVpciBlbmQuIFRoZSBwbHVnaW4gcmVwbGFjZXMgdGhlIHRpbWVsaW5lJ3MgLnJldmVydCgpIG1ldGhvZCB0byBkbyBleGFjdGx5IHRoYXQuIEJ1dCB3ZSBhbHNvIG5lZWQgdG8gcmVtb3ZlIGFueSBvZiB0aG9zZSBuZXN0ZWQgdHdlZW5zIGluc2lkZSB0aGUgZmxpcCB0aW1lbGluZSBzbyB0aGF0IHRoZXkgZG9uJ3QgZ2V0IGluZGl2aWR1YWxseSByZXZlcnRlZC5cbiAgICAgICAgICB0ID0gX3RoaXM0LmRhdGFbaV07XG5cbiAgICAgICAgICBpZiAodC5kYXRhID09PSBcImlzRmxpcFwiKSB7XG4gICAgICAgICAgICB0LnJldmVydCgpO1xuICAgICAgICAgICAgdC5nZXRDaGlsZHJlbih0cnVlLCB0cnVlLCBmYWxzZSkuZm9yRWFjaChmdW5jdGlvbiAodHdlZW4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHR3ZWVucy5zcGxpY2UodHdlZW5zLmluZGV4T2YodHdlZW4pLCAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBzYXZlIGFzIGFuIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBjYWNoZSB0aGUgZ2xvYmFsVGltZSBmb3IgZWFjaCB0d2VlbiB0byBvcHRpbWl6ZSBwZXJmb3JtYW5jZSBkdXJpbmcgdGhlIHNvcnRcblxuXG4gICAgICAgIHR3ZWVucy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZzogdC5fZHVyIHx8IHQuX2RlbGF5IHx8IHQuX3NhdCAmJiAhdC5fc2F0LnZhcnMuaW1tZWRpYXRlUmVuZGVyID8gdC5nbG9iYWxUaW1lKDApIDogLUluZmluaXR5LFxuICAgICAgICAgICAgdDogdFxuICAgICAgICAgIH07XG4gICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYi5nIC0gYS5nIHx8IC1JbmZpbml0eTtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAobykge1xuICAgICAgICAgIHJldHVybiBvLnQucmV2ZXJ0KHJldmVydCk7XG4gICAgICAgIH0pOyAvLyBub3RlOiBhbGwgb2YgdGhlIF9zdGFydEF0IHR3ZWVucyBzaG91bGQgYmUgcmV2ZXJ0ZWQgaW4gcmV2ZXJzZSBvcmRlciB0aGF0IHRoZXkgd2VyZSBjcmVhdGVkLCBhbmQgdGhleSdsbCBhbGwgaGF2ZSB0aGUgc2FtZSBnbG9iYWxUaW1lICgtMSkgc28gdGhlIFwiIHx8IC0xXCIgaW4gdGhlIHNvcnQga2VlcHMgdGhlIG9yZGVyIHByb3Blcmx5LlxuXG4gICAgICAgIGkgPSBfdGhpczQuZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBsb29wIGJhY2t3YXJkcyBzbyB0aGF0LCBmb3IgZXhhbXBsZSwgU3BsaXRUZXh0cyB0aGF0IHdlcmUgY3JlYXRlZCBsYXRlciBvbiB0aGUgc2FtZSBlbGVtZW50IGdldCByZXZlcnRlZCBmaXJzdFxuICAgICAgICAgIHQgPSBfdGhpczQuZGF0YVtpXTtcblxuICAgICAgICAgIGlmICh0IGluc3RhbmNlb2YgVGltZWxpbmUpIHtcbiAgICAgICAgICAgIGlmICh0LmRhdGEgIT09IFwibmVzdGVkXCIpIHtcbiAgICAgICAgICAgICAgdC5zY3JvbGxUcmlnZ2VyICYmIHQuc2Nyb2xsVHJpZ2dlci5yZXZlcnQoKTtcbiAgICAgICAgICAgICAgdC5raWxsKCk7IC8vIGRvbid0IHJldmVydCgpIHRoZSB0aW1lbGluZSBiZWNhdXNlIHRoYXQncyBkdXBsaWNhdGluZyBlZmZvcnRzIHNpbmNlIHdlIGFscmVhZHkgcmV2ZXJ0ZWQgYWxsIHRoZSB0d2VlbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgISh0IGluc3RhbmNlb2YgVHdlZW4pICYmIHQucmV2ZXJ0ICYmIHQucmV2ZXJ0KHJldmVydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM0Ll9yLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICByZXR1cm4gZihyZXZlcnQsIF90aGlzNCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF90aGlzNC5pc1JldmVydGVkID0gdHJ1ZTtcbiAgICAgIH0pKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLmtpbGwgJiYgZS5raWxsKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICBpZiAobWF0Y2hNZWRpYSkge1xuICAgICAgdmFyIGkgPSBfbWVkaWEubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIC8vIHByZXZpb3VzbHksIHdlIGNoZWNrZWQgX21lZGlhLmluZGV4T2YodGhpcyksIGJ1dCBzb21lIGZyYW1ld29ya3MgbGlrZSBWdWUgZW5mb3JjZSBQcm94eSBvYmplY3RzIHRoYXQgbWFrZSBpdCBpbXBvc3NpYmxlIHRvIGdldCB0aGUgcHJvcGVyIHJlc3VsdCB0aGF0IHdheSwgc28gd2UgbXVzdCB1c2UgYSB1bmlxdWUgSUQgbnVtYmVyIGluc3RlYWQuXG4gICAgICAgIF9tZWRpYVtpXS5pZCA9PT0gdGhpcy5pZCAmJiBfbWVkaWEuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG81LnJldmVydCA9IGZ1bmN0aW9uIHJldmVydChjb25maWcpIHtcbiAgICB0aGlzLmtpbGwoY29uZmlnIHx8IHt9KTtcbiAgfTtcblxuICByZXR1cm4gQ29udGV4dDtcbn0oKTtcblxudmFyIE1hdGNoTWVkaWEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXRjaE1lZGlhKHNjb3BlKSB7XG4gICAgdGhpcy5jb250ZXh0cyA9IFtdO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICBfY29udGV4dCAmJiBfY29udGV4dC5kYXRhLnB1c2godGhpcyk7XG4gIH1cblxuICB2YXIgX3Byb3RvNiA9IE1hdGNoTWVkaWEucHJvdG90eXBlO1xuXG4gIF9wcm90bzYuYWRkID0gZnVuY3Rpb24gYWRkKGNvbmRpdGlvbnMsIGZ1bmMsIHNjb3BlKSB7XG4gICAgX2lzT2JqZWN0KGNvbmRpdGlvbnMpIHx8IChjb25kaXRpb25zID0ge1xuICAgICAgbWF0Y2hlczogY29uZGl0aW9uc1xuICAgIH0pO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQoMCwgc2NvcGUgfHwgdGhpcy5zY29wZSksXG4gICAgICAgIGNvbmQgPSBjb250ZXh0LmNvbmRpdGlvbnMgPSB7fSxcbiAgICAgICAgbXEsXG4gICAgICAgIHAsXG4gICAgICAgIGFjdGl2ZTtcbiAgICBfY29udGV4dCAmJiAhY29udGV4dC5zZWxlY3RvciAmJiAoY29udGV4dC5zZWxlY3RvciA9IF9jb250ZXh0LnNlbGVjdG9yKTsgLy8gaW4gY2FzZSBhIGNvbnRleHQgaXMgY3JlYXRlZCBpbnNpZGUgYSBjb250ZXh0LiBMaWtlIGEgZ3NhcC5tYXRjaE1lZGlhKCkgdGhhdCdzIGluc2lkZSBhIHNjb3BlZCBnc2FwLmNvbnRleHQoKVxuXG4gICAgdGhpcy5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICAgIGZ1bmMgPSBjb250ZXh0LmFkZChcIm9uTWF0Y2hcIiwgZnVuYyk7XG4gICAgY29udGV4dC5xdWVyaWVzID0gY29uZGl0aW9ucztcblxuICAgIGZvciAocCBpbiBjb25kaXRpb25zKSB7XG4gICAgICBpZiAocCA9PT0gXCJhbGxcIikge1xuICAgICAgICBhY3RpdmUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXEgPSBfd2luLm1hdGNoTWVkaWEoY29uZGl0aW9uc1twXSk7XG5cbiAgICAgICAgaWYgKG1xKSB7XG4gICAgICAgICAgX21lZGlhLmluZGV4T2YoY29udGV4dCkgPCAwICYmIF9tZWRpYS5wdXNoKGNvbnRleHQpO1xuICAgICAgICAgIChjb25kW3BdID0gbXEubWF0Y2hlcykgJiYgKGFjdGl2ZSA9IDEpO1xuICAgICAgICAgIG1xLmFkZExpc3RlbmVyID8gbXEuYWRkTGlzdGVuZXIoX29uTWVkaWFDaGFuZ2UpIDogbXEuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBfb25NZWRpYUNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhY3RpdmUgJiYgZnVuYyhjb250ZXh0LCBmdW5jdGlvbiAoZikge1xuICAgICAgcmV0dXJuIGNvbnRleHQuYWRkKG51bGwsIGYpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHJlZnJlc2goKSB7XG4gIC8vIFx0bGV0IHRpbWUgPSBfbGFzdE1lZGlhVGltZSxcbiAgLy8gXHRcdG1lZGlhID0gX21lZGlhO1xuICAvLyBcdF9sYXN0TWVkaWFUaW1lID0gLTE7XG4gIC8vIFx0X21lZGlhID0gdGhpcy5jb250ZXh0cztcbiAgLy8gXHRfb25NZWRpYUNoYW5nZSgpO1xuICAvLyBcdF9sYXN0TWVkaWFUaW1lID0gdGltZTtcbiAgLy8gXHRfbWVkaWEgPSBtZWRpYTtcbiAgLy8gfVxuICA7XG5cbiAgX3Byb3RvNi5yZXZlcnQgPSBmdW5jdGlvbiByZXZlcnQoY29uZmlnKSB7XG4gICAgdGhpcy5raWxsKGNvbmZpZyB8fCB7fSk7XG4gIH07XG5cbiAgX3Byb3RvNi5raWxsID0gZnVuY3Rpb24ga2lsbChyZXZlcnQpIHtcbiAgICB0aGlzLmNvbnRleHRzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjLmtpbGwocmV2ZXJ0LCB0cnVlKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gTWF0Y2hNZWRpYTtcbn0oKTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogR1NBUFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbnZhciBfZ3NhcCA9IHtcbiAgcmVnaXN0ZXJQbHVnaW46IGZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICByZXR1cm4gX2NyZWF0ZVBsdWdpbihjb25maWcpO1xuICAgIH0pO1xuICB9LFxuICB0aW1lbGluZTogZnVuY3Rpb24gdGltZWxpbmUodmFycykge1xuICAgIHJldHVybiBuZXcgVGltZWxpbmUodmFycyk7XG4gIH0sXG4gIGdldFR3ZWVuc09mOiBmdW5jdGlvbiBnZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKTtcbiAgfSxcbiAgZ2V0UHJvcGVydHk6IGZ1bmN0aW9uIGdldFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpIHtcbiAgICBfaXNTdHJpbmcodGFyZ2V0KSAmJiAodGFyZ2V0ID0gdG9BcnJheSh0YXJnZXQpWzBdKTsgLy9pbiBjYXNlIHNlbGVjdG9yIHRleHQgb3IgYW4gYXJyYXkgaXMgcGFzc2VkIGluXG5cbiAgICB2YXIgZ2V0dGVyID0gX2dldENhY2hlKHRhcmdldCB8fCB7fSkuZ2V0LFxuICAgICAgICBmb3JtYXQgPSB1bml0ID8gX3Bhc3NUaHJvdWdoIDogX251bWVyaWNJZlBvc3NpYmxlO1xuXG4gICAgdW5pdCA9PT0gXCJuYXRpdmVcIiAmJiAodW5pdCA9IFwiXCIpO1xuICAgIHJldHVybiAhdGFyZ2V0ID8gdGFyZ2V0IDogIXByb3BlcnR5ID8gZnVuY3Rpb24gKHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSB7XG4gICAgICByZXR1cm4gZm9ybWF0KChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgX3BsdWdpbnNbcHJvcGVydHldLmdldCB8fCBnZXR0ZXIpKHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpKTtcbiAgICB9IDogZm9ybWF0KChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgX3BsdWdpbnNbcHJvcGVydHldLmdldCB8fCBnZXR0ZXIpKHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpKTtcbiAgfSxcbiAgcXVpY2tTZXR0ZXI6IGZ1bmN0aW9uIHF1aWNrU2V0dGVyKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHtcbiAgICB0YXJnZXQgPSB0b0FycmF5KHRhcmdldCk7XG5cbiAgICBpZiAodGFyZ2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBzZXR0ZXJzID0gdGFyZ2V0Lm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gZ3NhcC5xdWlja1NldHRlcih0LCBwcm9wZXJ0eSwgdW5pdCk7XG4gICAgICB9KSxcbiAgICAgICAgICBsID0gc2V0dGVycy5sZW5ndGg7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpID0gbDtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgc2V0dGVyc1tpXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gdGFyZ2V0WzBdIHx8IHt9O1xuXG4gICAgdmFyIFBsdWdpbiA9IF9wbHVnaW5zW3Byb3BlcnR5XSxcbiAgICAgICAgY2FjaGUgPSBfZ2V0Q2FjaGUodGFyZ2V0KSxcbiAgICAgICAgcCA9IGNhY2hlLmhhcm5lc3MgJiYgKGNhY2hlLmhhcm5lc3MuYWxpYXNlcyB8fCB7fSlbcHJvcGVydHldIHx8IHByb3BlcnR5LFxuICAgICAgICAvLyBpbiBjYXNlIGl0J3MgYW4gYWxpYXMsIGxpa2UgXCJyb3RhdGVcIiBmb3IgXCJyb3RhdGlvblwiLlxuICAgIHNldHRlciA9IFBsdWdpbiA/IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIHAgPSBuZXcgUGx1Z2luKCk7XG4gICAgICBfcXVpY2tUd2Vlbi5fcHQgPSAwO1xuICAgICAgcC5pbml0KHRhcmdldCwgdW5pdCA/IHZhbHVlICsgdW5pdCA6IHZhbHVlLCBfcXVpY2tUd2VlbiwgMCwgW3RhcmdldF0pO1xuICAgICAgcC5yZW5kZXIoMSwgcCk7XG4gICAgICBfcXVpY2tUd2Vlbi5fcHQgJiYgX3JlbmRlclByb3BUd2VlbnMoMSwgX3F1aWNrVHdlZW4pO1xuICAgIH0gOiBjYWNoZS5zZXQodGFyZ2V0LCBwKTtcblxuICAgIHJldHVybiBQbHVnaW4gPyBzZXR0ZXIgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBzZXR0ZXIodGFyZ2V0LCBwLCB1bml0ID8gdmFsdWUgKyB1bml0IDogdmFsdWUsIGNhY2hlLCAxKTtcbiAgICB9O1xuICB9LFxuICBxdWlja1RvOiBmdW5jdGlvbiBxdWlja1RvKHRhcmdldCwgcHJvcGVydHksIHZhcnMpIHtcbiAgICB2YXIgX21lcmdlMjtcblxuICAgIHZhciB0d2VlbiA9IGdzYXAudG8odGFyZ2V0LCBfbWVyZ2UoKF9tZXJnZTIgPSB7fSwgX21lcmdlMltwcm9wZXJ0eV0gPSBcIis9MC4xXCIsIF9tZXJnZTIucGF1c2VkID0gdHJ1ZSwgX21lcmdlMiksIHZhcnMgfHwge30pKSxcbiAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIGZ1bmModmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUpIHtcbiAgICAgIHJldHVybiB0d2Vlbi5yZXNldFRvKHByb3BlcnR5LCB2YWx1ZSwgc3RhcnQsIHN0YXJ0SXNSZWxhdGl2ZSk7XG4gICAgfTtcblxuICAgIGZ1bmMudHdlZW4gPSB0d2VlbjtcbiAgICByZXR1cm4gZnVuYztcbiAgfSxcbiAgaXNUd2VlbmluZzogZnVuY3Rpb24gaXNUd2VlbmluZyh0YXJnZXRzKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRUd2VlbnNPZih0YXJnZXRzLCB0cnVlKS5sZW5ndGggPiAwO1xuICB9LFxuICBkZWZhdWx0czogZnVuY3Rpb24gZGVmYXVsdHModmFsdWUpIHtcbiAgICB2YWx1ZSAmJiB2YWx1ZS5lYXNlICYmICh2YWx1ZS5lYXNlID0gX3BhcnNlRWFzZSh2YWx1ZS5lYXNlLCBfZGVmYXVsdHMuZWFzZSkpO1xuICAgIHJldHVybiBfbWVyZ2VEZWVwKF9kZWZhdWx0cywgdmFsdWUgfHwge30pO1xuICB9LFxuICBjb25maWc6IGZ1bmN0aW9uIGNvbmZpZyh2YWx1ZSkge1xuICAgIHJldHVybiBfbWVyZ2VEZWVwKF9jb25maWcsIHZhbHVlIHx8IHt9KTtcbiAgfSxcbiAgcmVnaXN0ZXJFZmZlY3Q6IGZ1bmN0aW9uIHJlZ2lzdGVyRWZmZWN0KF9yZWYzKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lLFxuICAgICAgICBlZmZlY3QgPSBfcmVmMy5lZmZlY3QsXG4gICAgICAgIHBsdWdpbnMgPSBfcmVmMy5wbHVnaW5zLFxuICAgICAgICBkZWZhdWx0cyA9IF9yZWYzLmRlZmF1bHRzLFxuICAgICAgICBleHRlbmRUaW1lbGluZSA9IF9yZWYzLmV4dGVuZFRpbWVsaW5lO1xuICAgIChwbHVnaW5zIHx8IFwiXCIpLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW5OYW1lKSB7XG4gICAgICByZXR1cm4gcGx1Z2luTmFtZSAmJiAhX3BsdWdpbnNbcGx1Z2luTmFtZV0gJiYgIV9nbG9iYWxzW3BsdWdpbk5hbWVdICYmIF93YXJuKG5hbWUgKyBcIiBlZmZlY3QgcmVxdWlyZXMgXCIgKyBwbHVnaW5OYW1lICsgXCIgcGx1Z2luLlwiKTtcbiAgICB9KTtcblxuICAgIF9lZmZlY3RzW25hbWVdID0gZnVuY3Rpb24gKHRhcmdldHMsIHZhcnMsIHRsKSB7XG4gICAgICByZXR1cm4gZWZmZWN0KHRvQXJyYXkodGFyZ2V0cyksIF9zZXREZWZhdWx0cyh2YXJzIHx8IHt9LCBkZWZhdWx0cyksIHRsKTtcbiAgICB9O1xuXG4gICAgaWYgKGV4dGVuZFRpbWVsaW5lKSB7XG4gICAgICBUaW1lbGluZS5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAodGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKF9lZmZlY3RzW25hbWVdKHRhcmdldHMsIF9pc09iamVjdCh2YXJzKSA/IHZhcnMgOiAocG9zaXRpb24gPSB2YXJzKSAmJiB7fSwgdGhpcyksIHBvc2l0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICByZWdpc3RlckVhc2U6IGZ1bmN0aW9uIHJlZ2lzdGVyRWFzZShuYW1lLCBlYXNlKSB7XG4gICAgX2Vhc2VNYXBbbmFtZV0gPSBfcGFyc2VFYXNlKGVhc2UpO1xuICB9LFxuICBwYXJzZUVhc2U6IGZ1bmN0aW9uIHBhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gX3BhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkgOiBfZWFzZU1hcDtcbiAgfSxcbiAgZ2V0QnlJZDogZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0QnlJZChpZCk7XG4gIH0sXG4gIGV4cG9ydFJvb3Q6IGZ1bmN0aW9uIGV4cG9ydFJvb3QodmFycywgaW5jbHVkZURlbGF5ZWRDYWxscykge1xuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgIHZhcnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgdGwgPSBuZXcgVGltZWxpbmUodmFycyksXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBuZXh0O1xuICAgIHRsLnNtb290aENoaWxkVGltaW5nID0gX2lzTm90RmFsc2UodmFycy5zbW9vdGhDaGlsZFRpbWluZyk7XG5cbiAgICBfZ2xvYmFsVGltZWxpbmUucmVtb3ZlKHRsKTtcblxuICAgIHRsLl9kcCA9IDA7IC8vb3RoZXJ3aXNlIGl0J2xsIGdldCByZS1hY3RpdmF0ZWQgd2hlbiBhZGRpbmcgY2hpbGRyZW4gYW5kIGJlIHJlLWludHJvZHVjZWQgaW50byBfZ2xvYmFsVGltZWxpbmUncyBsaW5rZWQgbGlzdCAodGhlbiBhZGRlZCB0byBpdHNlbGYpLlxuXG4gICAgdGwuX3RpbWUgPSB0bC5fdFRpbWUgPSBfZ2xvYmFsVGltZWxpbmUuX3RpbWU7XG4gICAgY2hpbGQgPSBfZ2xvYmFsVGltZWxpbmUuX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG5cbiAgICAgIGlmIChpbmNsdWRlRGVsYXllZENhbGxzIHx8ICEoIWNoaWxkLl9kdXIgJiYgY2hpbGQgaW5zdGFuY2VvZiBUd2VlbiAmJiBjaGlsZC52YXJzLm9uQ29tcGxldGUgPT09IGNoaWxkLl90YXJnZXRzWzBdKSkge1xuICAgICAgICBfYWRkVG9UaW1lbGluZSh0bCwgY2hpbGQsIGNoaWxkLl9zdGFydCAtIGNoaWxkLl9kZWxheSk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gbmV4dDtcbiAgICB9XG5cbiAgICBfYWRkVG9UaW1lbGluZShfZ2xvYmFsVGltZWxpbmUsIHRsLCAwKTtcblxuICAgIHJldHVybiB0bDtcbiAgfSxcbiAgY29udGV4dDogZnVuY3Rpb24gY29udGV4dChmdW5jLCBzY29wZSkge1xuICAgIHJldHVybiBmdW5jID8gbmV3IENvbnRleHQoZnVuYywgc2NvcGUpIDogX2NvbnRleHQ7XG4gIH0sXG4gIG1hdGNoTWVkaWE6IGZ1bmN0aW9uIG1hdGNoTWVkaWEoc2NvcGUpIHtcbiAgICByZXR1cm4gbmV3IE1hdGNoTWVkaWEoc2NvcGUpO1xuICB9LFxuICBtYXRjaE1lZGlhUmVmcmVzaDogZnVuY3Rpb24gbWF0Y2hNZWRpYVJlZnJlc2goKSB7XG4gICAgcmV0dXJuIF9tZWRpYS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICB2YXIgY29uZCA9IGMuY29uZGl0aW9ucyxcbiAgICAgICAgICBmb3VuZCxcbiAgICAgICAgICBwO1xuXG4gICAgICBmb3IgKHAgaW4gY29uZCkge1xuICAgICAgICBpZiAoY29uZFtwXSkge1xuICAgICAgICAgIGNvbmRbcF0gPSBmYWxzZTtcbiAgICAgICAgICBmb3VuZCA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm91bmQgJiYgYy5yZXZlcnQoKTtcbiAgICB9KSB8fCBfb25NZWRpYUNoYW5nZSgpO1xuICB9LFxuICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGEgPSBfbGlzdGVuZXJzW3R5cGVdIHx8IChfbGlzdGVuZXJzW3R5cGVdID0gW10pO1xuICAgIH5hLmluZGV4T2YoY2FsbGJhY2spIHx8IGEucHVzaChjYWxsYmFjayk7XG4gIH0sXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgYSA9IF9saXN0ZW5lcnNbdHlwZV0sXG4gICAgICAgIGkgPSBhICYmIGEuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgaSA+PSAwICYmIGEuc3BsaWNlKGksIDEpO1xuICB9LFxuICB1dGlsczoge1xuICAgIHdyYXA6IHdyYXAsXG4gICAgd3JhcFlveW86IHdyYXBZb3lvLFxuICAgIGRpc3RyaWJ1dGU6IGRpc3RyaWJ1dGUsXG4gICAgcmFuZG9tOiByYW5kb20sXG4gICAgc25hcDogc25hcCxcbiAgICBub3JtYWxpemU6IG5vcm1hbGl6ZSxcbiAgICBnZXRVbml0OiBnZXRVbml0LFxuICAgIGNsYW1wOiBjbGFtcCxcbiAgICBzcGxpdENvbG9yOiBzcGxpdENvbG9yLFxuICAgIHRvQXJyYXk6IHRvQXJyYXksXG4gICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgIG1hcFJhbmdlOiBtYXBSYW5nZSxcbiAgICBwaXBlOiBwaXBlLFxuICAgIHVuaXRpemU6IHVuaXRpemUsXG4gICAgaW50ZXJwb2xhdGU6IGludGVycG9sYXRlLFxuICAgIHNodWZmbGU6IHNodWZmbGVcbiAgfSxcbiAgaW5zdGFsbDogX2luc3RhbGwsXG4gIGVmZmVjdHM6IF9lZmZlY3RzLFxuICB0aWNrZXI6IF90aWNrZXIsXG4gIHVwZGF0ZVJvb3Q6IFRpbWVsaW5lLnVwZGF0ZVJvb3QsXG4gIHBsdWdpbnM6IF9wbHVnaW5zLFxuICBnbG9iYWxUaW1lbGluZTogX2dsb2JhbFRpbWVsaW5lLFxuICBjb3JlOiB7XG4gICAgUHJvcFR3ZWVuOiBQcm9wVHdlZW4sXG4gICAgZ2xvYmFsczogX2FkZEdsb2JhbCxcbiAgICBUd2VlbjogVHdlZW4sXG4gICAgVGltZWxpbmU6IFRpbWVsaW5lLFxuICAgIEFuaW1hdGlvbjogQW5pbWF0aW9uLFxuICAgIGdldENhY2hlOiBfZ2V0Q2FjaGUsXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtOiBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0sXG4gICAgcmV2ZXJ0aW5nOiBmdW5jdGlvbiByZXZlcnRpbmcoKSB7XG4gICAgICByZXR1cm4gX3JldmVydGluZztcbiAgICB9LFxuICAgIGNvbnRleHQ6IGZ1bmN0aW9uIGNvbnRleHQodG9BZGQpIHtcbiAgICAgIGlmICh0b0FkZCAmJiBfY29udGV4dCkge1xuICAgICAgICBfY29udGV4dC5kYXRhLnB1c2godG9BZGQpO1xuXG4gICAgICAgIHRvQWRkLl9jdHggPSBfY29udGV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9jb250ZXh0O1xuICAgIH0sXG4gICAgc3VwcHJlc3NPdmVyd3JpdGVzOiBmdW5jdGlvbiBzdXBwcmVzc092ZXJ3cml0ZXModmFsdWUpIHtcbiAgICAgIHJldHVybiBfc3VwcHJlc3NPdmVyd3JpdGVzID0gdmFsdWU7XG4gICAgfVxuICB9XG59O1xuXG5fZm9yRWFjaE5hbWUoXCJ0byxmcm9tLGZyb21UbyxkZWxheWVkQ2FsbCxzZXQsa2lsbFR3ZWVuc09mXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfZ3NhcFtuYW1lXSA9IFR3ZWVuW25hbWVdO1xufSk7XG5cbl90aWNrZXIuYWRkKFRpbWVsaW5lLnVwZGF0ZVJvb3QpO1xuXG5fcXVpY2tUd2VlbiA9IF9nc2FwLnRvKHt9LCB7XG4gIGR1cmF0aW9uOiAwXG59KTsgLy8gLS0tLSBFWFRSQSBQTFVHSU5TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBfZ2V0UGx1Z2luUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2dldFBsdWdpblByb3BUd2VlbihwbHVnaW4sIHByb3ApIHtcbiAgdmFyIHB0ID0gcGx1Z2luLl9wdDtcblxuICB3aGlsZSAocHQgJiYgcHQucCAhPT0gcHJvcCAmJiBwdC5vcCAhPT0gcHJvcCAmJiBwdC5mcCAhPT0gcHJvcCkge1xuICAgIHB0ID0gcHQuX25leHQ7XG4gIH1cblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9hZGRNb2RpZmllcnMgPSBmdW5jdGlvbiBfYWRkTW9kaWZpZXJzKHR3ZWVuLCBtb2RpZmllcnMpIHtcbiAgdmFyIHRhcmdldHMgPSB0d2Vlbi5fdGFyZ2V0cyxcbiAgICAgIHAsXG4gICAgICBpLFxuICAgICAgcHQ7XG5cbiAgZm9yIChwIGluIG1vZGlmaWVycykge1xuICAgIGkgPSB0YXJnZXRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHB0ID0gdHdlZW4uX3B0TG9va3VwW2ldW3BdO1xuXG4gICAgICBpZiAocHQgJiYgKHB0ID0gcHQuZCkpIHtcbiAgICAgICAgaWYgKHB0Ll9wdCkge1xuICAgICAgICAgIC8vIGlzIGEgcGx1Z2luXG4gICAgICAgICAgcHQgPSBfZ2V0UGx1Z2luUHJvcFR3ZWVuKHB0LCBwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB0ICYmIHB0Lm1vZGlmaWVyICYmIHB0Lm1vZGlmaWVyKG1vZGlmaWVyc1twXSwgdHdlZW4sIHRhcmdldHNbaV0sIHApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSxcbiAgICBfYnVpbGRNb2RpZmllclBsdWdpbiA9IGZ1bmN0aW9uIF9idWlsZE1vZGlmaWVyUGx1Z2luKG5hbWUsIG1vZGlmaWVyKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICByYXdWYXJzOiAxLFxuICAgIC8vZG9uJ3QgcHJlLXByb2Nlc3MgZnVuY3Rpb24tYmFzZWQgdmFsdWVzIG9yIFwicmFuZG9tKClcIiBzdHJpbmdzLlxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YXJzLCB0d2Vlbikge1xuICAgICAgdHdlZW4uX29uSW5pdCA9IGZ1bmN0aW9uICh0d2Vlbikge1xuICAgICAgICB2YXIgdGVtcCwgcDtcblxuICAgICAgICBpZiAoX2lzU3RyaW5nKHZhcnMpKSB7XG4gICAgICAgICAgdGVtcCA9IHt9O1xuXG4gICAgICAgICAgX2ZvckVhY2hOYW1lKHZhcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVtcFtuYW1lXSA9IDE7XG4gICAgICAgICAgfSk7IC8vaWYgdGhlIHVzZXIgcGFzc2VzIGluIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMgdG8gcm91bmRQcm9wcywgbGlrZSBcIngseVwiLCB3ZSByb3VuZCB0byB3aG9sZSBudW1iZXJzLlxuXG5cbiAgICAgICAgICB2YXJzID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RpZmllcikge1xuICAgICAgICAgIHRlbXAgPSB7fTtcblxuICAgICAgICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICAgICAgICB0ZW1wW3BdID0gbW9kaWZpZXIodmFyc1twXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFycyA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICBfYWRkTW9kaWZpZXJzKHR3ZWVuLCB2YXJzKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xufTsgLy9yZWdpc3RlciBjb3JlIHBsdWdpbnNcblxuXG5leHBvcnQgdmFyIGdzYXAgPSBfZ3NhcC5yZWdpc3RlclBsdWdpbih7XG4gIG5hbWU6IFwiYXR0clwiLFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgdmFyIHAsIHB0LCB2O1xuICAgIHRoaXMudHdlZW4gPSB0d2VlbjtcblxuICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICB2ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShwKSB8fCBcIlwiO1xuICAgICAgcHQgPSB0aGlzLmFkZCh0YXJnZXQsIFwic2V0QXR0cmlidXRlXCIsICh2IHx8IDApICsgXCJcIiwgdmFyc1twXSwgaW5kZXgsIHRhcmdldHMsIDAsIDAsIHApO1xuICAgICAgcHQub3AgPSBwO1xuICAgICAgcHQuYiA9IHY7IC8vIHJlY29yZCB0aGUgYmVnaW5uaW5nIHZhbHVlIHNvIHdlIGNhbiByZXZlcnQoKVxuXG4gICAgICB0aGlzLl9wcm9wcy5wdXNoKHApO1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocmF0aW8sIGRhdGEpIHtcbiAgICB2YXIgcHQgPSBkYXRhLl9wdDtcblxuICAgIHdoaWxlIChwdCkge1xuICAgICAgX3JldmVydGluZyA/IHB0LnNldChwdC50LCBwdC5wLCBwdC5iLCBwdCkgOiBwdC5yKHJhdGlvLCBwdC5kKTsgLy8gaWYgcmV2ZXJ0aW5nLCBnbyBiYWNrIHRvIHRoZSBvcmlnaW5hbCAocHQuYilcblxuICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICB9XG4gIH1cbn0sIHtcbiAgbmFtZTogXCJlbmRBcnJheVwiLFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFsdWUpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuYWRkKHRhcmdldCwgaSwgdGFyZ2V0W2ldIHx8IDAsIHZhbHVlW2ldLCAwLCAwLCAwLCAwLCAwLCAxKTtcbiAgICB9XG4gIH1cbn0sIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwicm91bmRQcm9wc1wiLCBfcm91bmRNb2RpZmllciksIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwibW9kaWZpZXJzXCIpLCBfYnVpbGRNb2RpZmllclBsdWdpbihcInNuYXBcIiwgc25hcCkpIHx8IF9nc2FwOyAvL3RvIHByZXZlbnQgdGhlIGNvcmUgcGx1Z2lucyBmcm9tIGJlaW5nIGRyb3BwZWQgdmlhIGFnZ3Jlc3NpdmUgdHJlZSBzaGFraW5nLCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGUgdmFyaWFibGUgZGVjbGFyYXRpb24gaW4gdGhpcyB3YXkuXG5cblR3ZWVuLnZlcnNpb24gPSBUaW1lbGluZS52ZXJzaW9uID0gZ3NhcC52ZXJzaW9uID0gXCIzLjEyLjVcIjtcbl9jb3JlUmVhZHkgPSAxO1xuX3dpbmRvd0V4aXN0cygpICYmIF93YWtlKCk7XG52YXIgUG93ZXIwID0gX2Vhc2VNYXAuUG93ZXIwLFxuICAgIFBvd2VyMSA9IF9lYXNlTWFwLlBvd2VyMSxcbiAgICBQb3dlcjIgPSBfZWFzZU1hcC5Qb3dlcjIsXG4gICAgUG93ZXIzID0gX2Vhc2VNYXAuUG93ZXIzLFxuICAgIFBvd2VyNCA9IF9lYXNlTWFwLlBvd2VyNCxcbiAgICBMaW5lYXIgPSBfZWFzZU1hcC5MaW5lYXIsXG4gICAgUXVhZCA9IF9lYXNlTWFwLlF1YWQsXG4gICAgQ3ViaWMgPSBfZWFzZU1hcC5DdWJpYyxcbiAgICBRdWFydCA9IF9lYXNlTWFwLlF1YXJ0LFxuICAgIFF1aW50ID0gX2Vhc2VNYXAuUXVpbnQsXG4gICAgU3Ryb25nID0gX2Vhc2VNYXAuU3Ryb25nLFxuICAgIEVsYXN0aWMgPSBfZWFzZU1hcC5FbGFzdGljLFxuICAgIEJhY2sgPSBfZWFzZU1hcC5CYWNrLFxuICAgIFN0ZXBwZWRFYXNlID0gX2Vhc2VNYXAuU3RlcHBlZEVhc2UsXG4gICAgQm91bmNlID0gX2Vhc2VNYXAuQm91bmNlLFxuICAgIFNpbmUgPSBfZWFzZU1hcC5TaW5lLFxuICAgIEV4cG8gPSBfZWFzZU1hcC5FeHBvLFxuICAgIENpcmMgPSBfZWFzZU1hcC5DaXJjO1xuZXhwb3J0IHsgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjIH07XG5leHBvcnQgeyBUd2VlbiBhcyBUd2Vlbk1heCwgVHdlZW4gYXMgVHdlZW5MaXRlLCBUaW1lbGluZSBhcyBUaW1lbGluZU1heCwgVGltZWxpbmUgYXMgVGltZWxpbmVMaXRlLCBnc2FwIGFzIGRlZmF1bHQsIHdyYXAsIHdyYXBZb3lvLCBkaXN0cmlidXRlLCByYW5kb20sIHNuYXAsIG5vcm1hbGl6ZSwgZ2V0VW5pdCwgY2xhbXAsIHNwbGl0Q29sb3IsIHRvQXJyYXksIHNlbGVjdG9yLCBtYXBSYW5nZSwgcGlwZSwgdW5pdGl6ZSwgaW50ZXJwb2xhdGUsIHNodWZmbGUgfTsgLy9leHBvcnQgc29tZSBpbnRlcm5hbCBtZXRob2RzL29yb2plY3RzIGZvciB1c2UgaW4gQ1NTUGx1Z2luIHNvIHRoYXQgd2UgY2FuIGV4dGVybmFsaXplIHRoYXQgZmlsZSBhbmQgYWxsb3cgY3VzdG9tIGJ1aWxkcyB0aGF0IGV4Y2x1ZGUgaXQuXG5cbmV4cG9ydCB7IF9nZXRQcm9wZXJ0eSwgX251bUV4cCwgX251bVdpdGhVbml0RXhwLCBfaXNTdHJpbmcsIF9pc1VuZGVmaW5lZCwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIF9yZWxFeHAsIF9zZXREZWZhdWx0cywgX3JlbW92ZUxpbmtlZExpc3RJdGVtLCBfZm9yRWFjaE5hbWUsIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHksIF9jb2xvclN0cmluZ0ZpbHRlciwgX3JlcGxhY2VSYW5kb20sIF9jaGVja1BsdWdpbiwgX3BsdWdpbnMsIF90aWNrZXIsIF9jb25maWcsIF9yb3VuZE1vZGlmaWVyLCBfcm91bmQsIF9taXNzaW5nUGx1Z2luLCBfZ2V0U2V0dGVyLCBfZ2V0Q2FjaGUsIF9jb2xvckV4cCwgX3BhcnNlUmVsYXRpdmUgfTsiXSwibmFtZXMiOlsiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIl9pbmhlcml0c0xvb3NlIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJfX3Byb3RvX18iLCJfY29uZmlnIiwiYXV0b1NsZWVwIiwiZm9yY2UzRCIsIm51bGxUYXJnZXRXYXJuIiwidW5pdHMiLCJsaW5lSGVpZ2h0IiwiX2RlZmF1bHRzIiwiZHVyYXRpb24iLCJvdmVyd3JpdGUiLCJkZWxheSIsIl9zdXBwcmVzc092ZXJ3cml0ZXMiLCJfcmV2ZXJ0aW5nIiwiX2NvbnRleHQiLCJfYmlnTnVtIiwiX3RpbnlOdW0iLCJfMlBJIiwiTWF0aCIsIlBJIiwiX0hBTEZfUEkiLCJfZ3NJRCIsIl9zcXJ0Iiwic3FydCIsIl9jb3MiLCJjb3MiLCJfc2luIiwic2luIiwiX2lzU3RyaW5nIiwidmFsdWUiLCJfaXNGdW5jdGlvbiIsIl9pc051bWJlciIsIl9pc1VuZGVmaW5lZCIsIl9pc09iamVjdCIsIl9pc05vdEZhbHNlIiwiX3dpbmRvd0V4aXN0cyIsIndpbmRvdyIsIl9pc0Z1bmNPclN0cmluZyIsIl9pc1R5cGVkQXJyYXkiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsIl9pc0FycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiX3N0cmljdE51bUV4cCIsIl9udW1FeHAiLCJfbnVtV2l0aFVuaXRFeHAiLCJfY29tcGxleFN0cmluZ051bUV4cCIsIl9yZWxFeHAiLCJfZGVsaW1pdGVkVmFsdWVFeHAiLCJfdW5pdEV4cCIsIl9nbG9iYWxUaW1lbGluZSIsIl93aW4iLCJfY29yZUluaXR0ZWQiLCJfZG9jIiwiX2dsb2JhbHMiLCJfaW5zdGFsbFNjb3BlIiwiX2NvcmVSZWFkeSIsIl9pbnN0YWxsIiwic2NvcGUiLCJfbWVyZ2UiLCJnc2FwIiwiX21pc3NpbmdQbHVnaW4iLCJwcm9wZXJ0eSIsImNvbnNvbGUiLCJ3YXJuIiwiX3dhcm4iLCJtZXNzYWdlIiwic3VwcHJlc3MiLCJfYWRkR2xvYmFsIiwibmFtZSIsIm9iaiIsIl9lbXB0eUZ1bmMiLCJfc3RhcnRBdFJldmVydENvbmZpZyIsInN1cHByZXNzRXZlbnRzIiwiaXNTdGFydCIsImtpbGwiLCJfcmV2ZXJ0Q29uZmlnTm9LaWxsIiwiX3JldmVydENvbmZpZyIsIl9yZXNlcnZlZFByb3BzIiwiX2xhenlUd2VlbnMiLCJfbGF6eUxvb2t1cCIsIl9sYXN0UmVuZGVyZWRGcmFtZSIsIl9wbHVnaW5zIiwiX2VmZmVjdHMiLCJfbmV4dEdDRnJhbWUiLCJfaGFybmVzc1BsdWdpbnMiLCJfY2FsbGJhY2tOYW1lcyIsIl9oYXJuZXNzIiwidGFyZ2V0cyIsInRhcmdldCIsImhhcm5lc3NQbHVnaW4iLCJpIiwiX2dzYXAiLCJoYXJuZXNzIiwibGVuZ3RoIiwidGFyZ2V0VGVzdCIsIkdTQ2FjaGUiLCJzcGxpY2UiLCJfZ2V0Q2FjaGUiLCJ0b0FycmF5IiwiX2dldFByb3BlcnR5IiwidiIsImdldEF0dHJpYnV0ZSIsIl9mb3JFYWNoTmFtZSIsIm5hbWVzIiwiZnVuYyIsInNwbGl0IiwiZm9yRWFjaCIsIl9yb3VuZCIsInJvdW5kIiwiX3JvdW5kUHJlY2lzZSIsIl9wYXJzZVJlbGF0aXZlIiwic3RhcnQiLCJvcGVyYXRvciIsImNoYXJBdCIsImVuZCIsInBhcnNlRmxvYXQiLCJzdWJzdHIiLCJfYXJyYXlDb250YWluc0FueSIsInRvU2VhcmNoIiwidG9GaW5kIiwibCIsImluZGV4T2YiLCJfbGF6eVJlbmRlciIsImEiLCJzbGljZSIsInR3ZWVuIiwiX2xhenkiLCJyZW5kZXIiLCJfbGF6eVNhZmVSZW5kZXIiLCJhbmltYXRpb24iLCJ0aW1lIiwiZm9yY2UiLCJfaW5pdHRlZCIsIl9zdGFydEF0IiwiX251bWVyaWNJZlBvc3NpYmxlIiwibiIsIm1hdGNoIiwidHJpbSIsIl9wYXNzVGhyb3VnaCIsInAiLCJfc2V0RGVmYXVsdHMiLCJkZWZhdWx0cyIsIl9zZXRLZXlmcmFtZURlZmF1bHRzIiwiZXhjbHVkZUR1cmF0aW9uIiwiYmFzZSIsInRvTWVyZ2UiLCJfbWVyZ2VEZWVwIiwiX2NvcHlFeGNsdWRpbmciLCJleGNsdWRpbmciLCJjb3B5IiwiX2luaGVyaXREZWZhdWx0cyIsInZhcnMiLCJwYXJlbnQiLCJrZXlmcmFtZXMiLCJpbmhlcml0IiwiX2RwIiwiX2FycmF5c01hdGNoIiwiYTEiLCJhMiIsIl9hZGRMaW5rZWRMaXN0SXRlbSIsImNoaWxkIiwiZmlyc3RQcm9wIiwibGFzdFByb3AiLCJzb3J0QnkiLCJwcmV2IiwidCIsIl9wcmV2IiwiX25leHQiLCJfcmVtb3ZlTGlua2VkTGlzdEl0ZW0iLCJuZXh0IiwiX3JlbW92ZUZyb21QYXJlbnQiLCJvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlIiwiYXV0b1JlbW92ZUNoaWxkcmVuIiwicmVtb3ZlIiwiX2FjdCIsIl91bmNhY2hlIiwiX2VuZCIsIl9kdXIiLCJfc3RhcnQiLCJfZGlydHkiLCJfcmVjYWNoZUFuY2VzdG9ycyIsInRvdGFsRHVyYXRpb24iLCJfcmV3aW5kU3RhcnRBdCIsInRvdGFsVGltZSIsInJldmVydCIsImltbWVkaWF0ZVJlbmRlciIsImF1dG9SZXZlcnQiLCJfaGFzTm9QYXVzZWRBbmNlc3RvcnMiLCJfdHMiLCJfZWxhcHNlZEN5Y2xlRHVyYXRpb24iLCJfcmVwZWF0IiwiX2FuaW1hdGlvbkN5Y2xlIiwiX3RUaW1lIiwiX3JEZWxheSIsInRUaW1lIiwiY3ljbGVEdXJhdGlvbiIsIndob2xlIiwiZmxvb3IiLCJfcGFyZW50VG9DaGlsZFRvdGFsVGltZSIsInBhcmVudFRpbWUiLCJfdER1ciIsIl9zZXRFbmQiLCJhYnMiLCJfcnRzIiwiX2FsaWduUGxheWhlYWQiLCJzbW9vdGhDaGlsZFRpbWluZyIsIl90aW1lIiwiX3Bvc3RBZGRDaGVja3MiLCJ0aW1lbGluZSIsImFkZCIsInJhd1RpbWUiLCJfY2xhbXAiLCJfelRpbWUiLCJfYWRkVG9UaW1lbGluZSIsInBvc2l0aW9uIiwic2tpcENoZWNrcyIsIl9wYXJzZVBvc2l0aW9uIiwiX2RlbGF5IiwidGltZVNjYWxlIiwiX3NvcnQiLCJfaXNGcm9tT3JGcm9tU3RhcnQiLCJfcmVjZW50IiwiX3Njcm9sbFRyaWdnZXIiLCJ0cmlnZ2VyIiwiU2Nyb2xsVHJpZ2dlciIsIl9hdHRlbXB0SW5pdFR3ZWVuIiwiX2luaXRUd2VlbiIsIl9wdCIsImxhenkiLCJfdGlja2VyIiwiZnJhbWUiLCJwdXNoIiwiX3BhcmVudFBsYXloZWFkSXNCZWZvcmVTdGFydCIsIl9yZWYiLCJfbG9jayIsIl9yZWYyIiwiZGF0YSIsIl9yZW5kZXJaZXJvRHVyYXRpb25Ud2VlbiIsInByZXZSYXRpbyIsInJhdGlvIiwicmVwZWF0RGVsYXkiLCJwdCIsIml0ZXJhdGlvbiIsInByZXZJdGVyYXRpb24iLCJfeW95byIsInJlcGVhdFJlZnJlc2giLCJpbnZhbGlkYXRlIiwiX2Zyb20iLCJyIiwiZCIsIl9vblVwZGF0ZSIsIl9jYWxsYmFjayIsIl9wcm9tIiwiX2ZpbmROZXh0UGF1c2VUd2VlbiIsInByZXZUaW1lIiwiX2ZpcnN0IiwiX2xhc3QiLCJfc2V0RHVyYXRpb24iLCJza2lwVW5jYWNoZSIsImxlYXZlUGxheWhlYWQiLCJyZXBlYXQiLCJkdXIiLCJ0b3RhbFByb2dyZXNzIiwiX29uVXBkYXRlVG90YWxEdXJhdGlvbiIsIlRpbWVsaW5lIiwiX3plcm9Qb3NpdGlvbiIsImVuZFRpbWUiLCJwZXJjZW50QW5pbWF0aW9uIiwibGFiZWxzIiwicmVjZW50IiwiY2xpcHBlZER1cmF0aW9uIiwib2Zmc2V0IiwiaXNQZXJjZW50IiwiaXNOYU4iLCJyZXBsYWNlIiwiX2NyZWF0ZVR3ZWVuVHlwZSIsInR5cGUiLCJwYXJhbXMiLCJpc0xlZ2FjeSIsInZhcnNJbmRleCIsImlyVmFycyIsInJ1bkJhY2t3YXJkcyIsInN0YXJ0QXQiLCJUd2VlbiIsIl9jb25kaXRpb25hbFJldHVybiIsIm1pbiIsIm1heCIsImdldFVuaXQiLCJleGVjIiwiY2xhbXAiLCJfc2xpY2UiLCJfaXNBcnJheUxpa2UiLCJub25FbXB0eSIsIm5vZGVUeXBlIiwiX2ZsYXR0ZW4iLCJhciIsImxlYXZlU3RyaW5ncyIsImFjY3VtdWxhdG9yIiwiX2FjY3VtdWxhdG9yIiwiYXBwbHkiLCJzZWxlY3RvciIsIl93YWtlIiwiY2FsbCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJlbCIsImN1cnJlbnQiLCJuYXRpdmVFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsInNodWZmbGUiLCJzb3J0IiwicmFuZG9tIiwiZGlzdHJpYnV0ZSIsImVhY2giLCJlYXNlIiwiX3BhcnNlRWFzZSIsImZyb20iLCJjYWNoZSIsImlzRGVjaW1hbCIsInJhdGlvcyIsImF4aXMiLCJyYXRpb1giLCJyYXRpb1kiLCJjZW50ZXIiLCJlZGdlcyIsImRpc3RhbmNlcyIsIm9yaWdpblgiLCJvcmlnaW5ZIiwieCIsInkiLCJqIiwid3JhcEF0IiwiZ3JpZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImxlZnQiLCJhbW91bnQiLCJiIiwidSIsIl9pbnZlcnRFYXNlIiwiX3JvdW5kTW9kaWZpZXIiLCJwb3ciLCJyYXciLCJzbmFwIiwic25hcFRvIiwicmFkaXVzIiwiaXMyRCIsInZhbHVlcyIsImluY3JlbWVudCIsImNsb3Nlc3QiLCJkeCIsImR5Iiwicm91bmRpbmdJbmNyZW1lbnQiLCJyZXR1cm5GdW5jdGlvbiIsInBpcGUiLCJfbGVuIiwiYXJndW1lbnRzIiwiZnVuY3Rpb25zIiwiX2tleSIsInJlZHVjZSIsImYiLCJ1bml0aXplIiwidW5pdCIsIm5vcm1hbGl6ZSIsIm1hcFJhbmdlIiwiX3dyYXBBcnJheSIsIndyYXBwZXIiLCJpbmRleCIsIndyYXAiLCJyYW5nZSIsIndyYXBZb3lvIiwidG90YWwiLCJfcmVwbGFjZVJhbmRvbSIsInMiLCJudW1zIiwiaW5NaW4iLCJpbk1heCIsIm91dE1pbiIsIm91dE1heCIsImluUmFuZ2UiLCJvdXRSYW5nZSIsImludGVycG9sYXRlIiwicHJvZ3Jlc3MiLCJtdXRhdGUiLCJpc1N0cmluZyIsIm1hc3RlciIsImludGVycG9sYXRvcnMiLCJpbCIsIl9hZGRQcm9wVHdlZW4iLCJfcmVuZGVyUHJvcFR3ZWVucyIsIl9nZXRMYWJlbEluRGlyZWN0aW9uIiwiZnJvbVRpbWUiLCJiYWNrd2FyZCIsImRpc3RhbmNlIiwibGFiZWwiLCJleGVjdXRlTGF6eUZpcnN0IiwiY2FsbGJhY2siLCJwcmV2Q29udGV4dCIsImNvbnRleHQiLCJfY3R4IiwicmVzdWx0IiwiY2FsbGJhY2tTY29wZSIsIl9pbnRlcnJ1cHQiLCJzY3JvbGxUcmlnZ2VyIiwiX3F1aWNrVHdlZW4iLCJfcmVnaXN0ZXJQbHVnaW5RdWV1ZSIsIl9jcmVhdGVQbHVnaW4iLCJjb25maWciLCJoZWFkbGVzcyIsImlzRnVuYyIsIlBsdWdpbiIsImluaXQiLCJfcHJvcHMiLCJpbnN0YW5jZURlZmF1bHRzIiwiX2tpbGxQcm9wVHdlZW5zT2YiLCJtb2RpZmllciIsIl9hZGRQbHVnaW5Nb2RpZmllciIsInJhd1ZhcnMiLCJzdGF0aWNzIiwiZ2V0IiwiZ2V0U2V0dGVyIiwiX2dldFNldHRlciIsImFsaWFzZXMiLCJyZWdpc3RlciIsInByb3AiLCJ0b1VwcGVyQ2FzZSIsIlByb3BUd2VlbiIsIl8yNTUiLCJfY29sb3JMb29rdXAiLCJhcXVhIiwibGltZSIsInNpbHZlciIsImJsYWNrIiwibWFyb29uIiwidGVhbCIsImJsdWUiLCJuYXZ5Iiwid2hpdGUiLCJvbGl2ZSIsInllbGxvdyIsIm9yYW5nZSIsImdyYXkiLCJwdXJwbGUiLCJncmVlbiIsInJlZCIsInBpbmsiLCJjeWFuIiwidHJhbnNwYXJlbnQiLCJfaHVlIiwiaCIsIm0xIiwibTIiLCJzcGxpdENvbG9yIiwidG9IU0wiLCJmb3JjZUFscGhhIiwiZyIsIndhc0hTTCIsInBhcnNlSW50IiwibWFwIiwiTnVtYmVyIiwiX2NvbG9yT3JkZXJEYXRhIiwiYyIsIl9jb2xvckV4cCIsIl9mb3JtYXRDb2xvcnMiLCJvcmRlck1hdGNoRGF0YSIsImNvbG9ycyIsInNoZWxsIiwiY29sb3IiLCJqb2luIiwic2hpZnQiLCJSZWdFeHAiLCJfaHNsRXhwIiwiX2NvbG9yU3RyaW5nRmlsdGVyIiwiY29tYmluZWQiLCJsYXN0SW5kZXgiLCJ0ZXN0IiwiX3RpY2tlckFjdGl2ZSIsIl9nZXRUaW1lIiwiRGF0ZSIsIm5vdyIsIl9sYWdUaHJlc2hvbGQiLCJfYWRqdXN0ZWRMYWciLCJfc3RhcnRUaW1lIiwiX2xhc3RVcGRhdGUiLCJfZ2FwIiwiX25leHRUaW1lIiwiX2xpc3RlbmVycyIsIl9pZCIsIl9yZXEiLCJfcmFmIiwiX3NlbGYiLCJfZGVsdGEiLCJfaSIsIl90aWNrIiwiZWxhcHNlZCIsIm1hbnVhbCIsIm92ZXJsYXAiLCJkaXNwYXRjaCIsInRpY2siLCJkZWx0YVJhdGlvIiwiZnBzIiwid2FrZSIsImRvY3VtZW50IiwiZ3NhcFZlcnNpb25zIiwidmVyc2lvbiIsIkdyZWVuU29ja0dsb2JhbHMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzbGVlcCIsInNldFRpbWVvdXQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNsZWFyVGltZW91dCIsImxhZ1Ntb290aGluZyIsInRocmVzaG9sZCIsImFkanVzdGVkTGFnIiwiSW5maW5pdHkiLCJfZnBzIiwib25jZSIsInByaW9yaXRpemUiLCJfZWFzZU1hcCIsIl9jdXN0b21FYXNlRXhwIiwiX3F1b3Rlc0V4cCIsIl9wYXJzZU9iamVjdEluU3RyaW5nIiwia2V5IiwidmFsIiwicGFyc2VkVmFsIiwibGFzdEluZGV4T2YiLCJfdmFsdWVJblBhcmVudGhlc2VzIiwib3BlbiIsImNsb3NlIiwibmVzdGVkIiwic3Vic3RyaW5nIiwiX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nIiwiX0NFIiwiX3Byb3BhZ2F0ZVlveW9FYXNlIiwiaXNZb3lvIiwieW95b0Vhc2UiLCJfZWFzZSIsIl95RWFzZSIsImRlZmF1bHRFYXNlIiwiX2luc2VydEVhc2UiLCJlYXNlSW4iLCJlYXNlT3V0IiwiZWFzZUluT3V0IiwibG93ZXJjYXNlTmFtZSIsInRvTG93ZXJDYXNlIiwiX2Vhc2VJbk91dEZyb21PdXQiLCJfY29uZmlnRWxhc3RpYyIsImFtcGxpdHVkZSIsInBlcmlvZCIsInAxIiwicDIiLCJwMyIsImFzaW4iLCJfY29uZmlnQmFjayIsIm92ZXJzaG9vdCIsInBvd2VyIiwiTGluZWFyIiwiZWFzZU5vbmUiLCJub25lIiwibjEiLCJuMiIsIm4zIiwiU3RlcHBlZEVhc2UiLCJzdGVwcyIsImltbWVkaWF0ZVN0YXJ0IiwiaWQiLCJzZXQiLCJBbmltYXRpb24iLCJ5b3lvIiwiX3Byb3RvIiwic3RhcnRUaW1lIiwiX3RvdGFsVGltZSIsIl9wdExvb2t1cCIsIl9wVGltZSIsIl9wcyIsInBhdXNlZCIsImluY2x1ZGVSZXBlYXRzIiwid3JhcFJlcGVhdHMiLCJwcmV2SXNSZXZlcnRpbmciLCJnbG9iYWxUaW1lIiwiX3NhdCIsInNlZWsiLCJyZXN0YXJ0IiwiaW5jbHVkZURlbGF5IiwicGxheSIsInJldmVyc2VkIiwicmV2ZXJzZSIsInBhdXNlIiwiYXRUaW1lIiwicmVzdW1lIiwiaXNBY3RpdmUiLCJldmVudENhbGxiYWNrIiwidGhlbiIsIm9uRnVsZmlsbGVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJfcmVzb2x2ZSIsIl90aGVuIiwiX0FuaW1hdGlvbiIsIl90aGlzIiwic29ydENoaWxkcmVuIiwiX3Byb3RvMiIsInRvIiwiZnJvbVRvIiwiZnJvbVZhcnMiLCJ0b1ZhcnMiLCJkZWxheWVkQ2FsbCIsInN0YWdnZXJUbyIsInN0YWdnZXIiLCJvbkNvbXBsZXRlQWxsIiwib25Db21wbGV0ZUFsbFBhcmFtcyIsIm9uQ29tcGxldGUiLCJvbkNvbXBsZXRlUGFyYW1zIiwic3RhZ2dlckZyb20iLCJzdGFnZ2VyRnJvbVRvIiwidER1ciIsImNyb3NzaW5nU3RhcnQiLCJwcmV2UGF1c2VkIiwicGF1c2VUd2VlbiIsInByZXZTdGFydCIsInJld2luZGluZyIsImRvZXNXcmFwIiwib25SZXBlYXQiLCJfaGFzUGF1c2UiLCJfZm9yY2luZyIsIm9uVXBkYXRlIiwiYWRqdXN0ZWRUaW1lIiwiX3RoaXMyIiwiYWRkTGFiZWwiLCJnZXRDaGlsZHJlbiIsInR3ZWVucyIsInRpbWVsaW5lcyIsImlnbm9yZUJlZm9yZVRpbWUiLCJnZXRCeUlkIiwiYW5pbWF0aW9ucyIsInJlbW92ZUxhYmVsIiwia2lsbFR3ZWVuc09mIiwiX3RvdGFsVGltZTIiLCJhZGRQYXVzZSIsInJlbW92ZVBhdXNlIiwicHJvcHMiLCJvbmx5QWN0aXZlIiwiZ2V0VHdlZW5zT2YiLCJfb3ZlcndyaXRpbmdUd2VlbiIsInBhcnNlZFRhcmdldHMiLCJpc0dsb2JhbFRpbWUiLCJjaGlsZHJlbiIsIl90YXJnZXRzIiwidHdlZW5UbyIsInRsIiwiX3ZhcnMiLCJfb25TdGFydCIsIm9uU3RhcnQiLCJvblN0YXJ0UGFyYW1zIiwiaW5pdHRlZCIsInR3ZWVuRnJvbVRvIiwiZnJvbVBvc2l0aW9uIiwidG9Qb3NpdGlvbiIsIm5leHRMYWJlbCIsImFmdGVyVGltZSIsInByZXZpb3VzTGFiZWwiLCJiZWZvcmVUaW1lIiwiY3VycmVudExhYmVsIiwic2hpZnRDaGlsZHJlbiIsImFkanVzdExhYmVscyIsInNvZnQiLCJjbGVhciIsImluY2x1ZGVMYWJlbHMiLCJ1cGRhdGVSb290IiwiX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4iLCJzZXR0ZXIiLCJzdHJpbmdGaWx0ZXIiLCJmdW5jUGFyYW0iLCJfcmVuZGVyQ29tcGxleFN0cmluZyIsIm1hdGNoSW5kZXgiLCJzdGFydE51bXMiLCJlbmROdW0iLCJjaHVuayIsInN0YXJ0TnVtIiwiaGFzUmFuZG9tIiwiZSIsIm0iLCJmcCIsIm9wdGlvbmFsIiwiY3VycmVudFZhbHVlIiwicGFyc2VkU3RhcnQiLCJfc2V0dGVyUGxhaW4iLCJfc2V0dGVyRnVuY1dpdGhQYXJhbSIsIl9zZXR0ZXJGdW5jIiwiX2ZvcmNlQWxsUHJvcFR3ZWVucyIsIl9yZW5kZXJCb29sZWFuIiwiX3JlbmRlclBsYWluIiwiX3Byb2Nlc3NWYXJzIiwiX3BhcnNlRnVuY09yU3RyaW5nIiwic3R5bGUiLCJfY2hlY2tQbHVnaW4iLCJwbHVnaW4iLCJwdExvb2t1cCIsInByaW9yaXR5IiwicHJldlN0YXJ0QXQiLCJmdWxsVGFyZ2V0cyIsImF1dG9PdmVyd3JpdGUiLCJfb3ZlcndyaXRlIiwiY2xlYW5WYXJzIiwiaGFzUHJpb3JpdHkiLCJnc0RhdGEiLCJoYXJuZXNzVmFycyIsIm92ZXJ3cml0dGVuIiwiX3B0Q2FjaGUiLCJfb3AiLCJfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5IiwiX29uSW5pdCIsIl91cGRhdGVQcm9wVHdlZW5zIiwic3RhcnRJc1JlbGF0aXZlIiwic2tpcFJlY3Vyc2lvbiIsInB0Q2FjaGUiLCJyb290UFQiLCJsb29rdXAiLCJfYWRkQWxpYXNlc1RvVmFycyIsInByb3BlcnR5QWxpYXNlcyIsIl9wYXJzZUtleWZyYW1lIiwiYWxsUHJvcHMiLCJlYXNlRWFjaCIsIl9zdGFnZ2VyVHdlZW5Qcm9wcyIsIl9zdGFnZ2VyUHJvcHNUb1NraXAiLCJfQW5pbWF0aW9uMiIsInNraXBJbmhlcml0IiwiX3RoaXMzIiwiX3RoaXMzJHZhcnMiLCJjdXJUYXJnZXQiLCJzdGFnZ2VyRnVuYyIsInN0YWdnZXJWYXJzVG9NZXJnZSIsImtmIiwiX3Byb3RvMyIsImlzTmVnYXRpdmUiLCJyZXNldFRvIiwia2lsbGluZ1RhcmdldHMiLCJwcm9wVHdlZW5Mb29rdXAiLCJmaXJzdFBUIiwib3ZlcndyaXR0ZW5Qcm9wcyIsImN1ckxvb2t1cCIsImN1ck92ZXJ3cml0ZVByb3BzIiwib25SZXZlcnNlQ29tcGxldGUiLCJvblJldmVyc2VDb21wbGV0ZVBhcmFtcyIsIl9zZXR0ZXJBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJoYXNOb25EZXBlbmRlbnRSZW1haW5pbmciLCJvcCIsImRlcCIsIl9zZXR0ZXJXaXRoTW9kaWZpZXIiLCJtU2V0IiwibXQiLCJwdDIiLCJmaXJzdCIsImxhc3QiLCJwciIsImNoYW5nZSIsInJlbmRlcmVyIiwiX3Byb3RvNCIsIlR3ZWVuTWF4IiwiVHdlZW5MaXRlIiwiVGltZWxpbmVMaXRlIiwiVGltZWxpbmVNYXgiLCJfbWVkaWEiLCJfZW1wdHlBcnJheSIsIl9sYXN0TWVkaWFUaW1lIiwiX2NvbnRleHRJRCIsIl9kaXNwYXRjaCIsIl9vbk1lZGlhQ2hhbmdlIiwibWF0Y2hlcyIsInF1ZXJpZXMiLCJjb25kaXRpb25zIiwiYW55TWF0Y2giLCJ0b2dnbGVkIiwibWF0Y2hNZWRpYSIsIm9uTWF0Y2giLCJDb250ZXh0IiwiX3IiLCJpc1JldmVydGVkIiwiX3Byb3RvNSIsInByZXZTZWxlY3RvciIsImlnbm9yZSIsImdldFR3ZWVucyIsIl90aGlzNCIsIm8iLCJNYXRjaE1lZGlhIiwiY29udGV4dHMiLCJfcHJvdG82IiwiY29uZCIsIm1xIiwiYWN0aXZlIiwiYWRkTGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVnaXN0ZXJQbHVnaW4iLCJfbGVuMiIsImFyZ3MiLCJfa2V5MiIsImdldFByb3BlcnR5IiwidW5jYWNoZSIsImdldHRlciIsImZvcm1hdCIsInF1aWNrU2V0dGVyIiwic2V0dGVycyIsInF1aWNrVG8iLCJfbWVyZ2UyIiwiaXNUd2VlbmluZyIsInJlZ2lzdGVyRWZmZWN0IiwiX3JlZjMiLCJlZmZlY3QiLCJwbHVnaW5zIiwiZXh0ZW5kVGltZWxpbmUiLCJwbHVnaW5OYW1lIiwicmVnaXN0ZXJFYXNlIiwicGFyc2VFYXNlIiwiZXhwb3J0Um9vdCIsImluY2x1ZGVEZWxheWVkQ2FsbHMiLCJtYXRjaE1lZGlhUmVmcmVzaCIsImZvdW5kIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInV0aWxzIiwiaW5zdGFsbCIsImVmZmVjdHMiLCJ0aWNrZXIiLCJnbG9iYWxUaW1lbGluZSIsImNvcmUiLCJnbG9iYWxzIiwiZ2V0Q2FjaGUiLCJyZXZlcnRpbmciLCJ0b0FkZCIsInN1cHByZXNzT3ZlcndyaXRlcyIsIl9nZXRQbHVnaW5Qcm9wVHdlZW4iLCJfYWRkTW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiX2J1aWxkTW9kaWZpZXJQbHVnaW4iLCJ0ZW1wIiwiUG93ZXIwIiwiUG93ZXIxIiwiUG93ZXIyIiwiUG93ZXIzIiwiUG93ZXI0IiwiUXVhZCIsIkN1YmljIiwiUXVhcnQiLCJRdWludCIsIlN0cm9uZyIsIkVsYXN0aWMiLCJCYWNrIiwiQm91bmNlIiwiU2luZSIsIkV4cG8iLCJDaXJjIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/gsap-core.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Back: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Back; },\n/* harmony export */   Bounce: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Bounce; },\n/* harmony export */   CSSPlugin: function() { return /* reexport safe */ _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin; },\n/* harmony export */   Circ: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Circ; },\n/* harmony export */   Cubic: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Cubic; },\n/* harmony export */   Elastic: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Elastic; },\n/* harmony export */   Expo: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Expo; },\n/* harmony export */   Linear: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Linear; },\n/* harmony export */   Power0: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power0; },\n/* harmony export */   Power1: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power1; },\n/* harmony export */   Power2: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power2; },\n/* harmony export */   Power3: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power3; },\n/* harmony export */   Power4: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power4; },\n/* harmony export */   Quad: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quad; },\n/* harmony export */   Quart: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quart; },\n/* harmony export */   Quint: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quint; },\n/* harmony export */   Sine: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Sine; },\n/* harmony export */   SteppedEase: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.SteppedEase; },\n/* harmony export */   Strong: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Strong; },\n/* harmony export */   TimelineLite: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineLite; },\n/* harmony export */   TimelineMax: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineMax; },\n/* harmony export */   TweenLite: function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TweenLite; },\n/* harmony export */   TweenMax: function() { return /* binding */ TweenMaxWithCSS; },\n/* harmony export */   \"default\": function() { return /* binding */ gsapWithCSS; },\n/* harmony export */   gsap: function() { return /* binding */ gsapWithCSS; }\n/* harmony export */ });\n/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/gsap-core.js\");\n/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSPlugin.js\");\n\n\nvar gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap, // to protect from tree shaking\nTweenMaxWithCSS = gsapWithCSS.core.Tween;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcU47QUFDMUs7QUFDM0MsSUFBSXVCLGNBQWN2QiwrQ0FBSUEsQ0FBQ3dCLGNBQWMsQ0FBQ0Ysb0RBQVNBLEtBQUt0QiwrQ0FBSUEsRUFDcEQsK0JBQStCO0FBQ25DeUIsa0JBQWtCRixZQUFZRyxJQUFJLENBQUNDLEtBQUs7QUFDc08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2dzYXBAMy4xMi41L25vZGVfbW9kdWxlcy9nc2FwL2luZGV4LmpzPzQzOTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ3NhcCwgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjLCBUd2VlbkxpdGUsIFRpbWVsaW5lTGl0ZSwgVGltZWxpbmVNYXggfSBmcm9tIFwiLi9nc2FwLWNvcmUuanNcIjtcbmltcG9ydCB7IENTU1BsdWdpbiB9IGZyb20gXCIuL0NTU1BsdWdpbi5qc1wiO1xudmFyIGdzYXBXaXRoQ1NTID0gZ3NhcC5yZWdpc3RlclBsdWdpbihDU1NQbHVnaW4pIHx8IGdzYXAsXG4gICAgLy8gdG8gcHJvdGVjdCBmcm9tIHRyZWUgc2hha2luZ1xuVHdlZW5NYXhXaXRoQ1NTID0gZ3NhcFdpdGhDU1MuY29yZS5Ud2VlbjtcbmV4cG9ydCB7IGdzYXBXaXRoQ1NTIGFzIGdzYXAsIGdzYXBXaXRoQ1NTIGFzIGRlZmF1bHQsIENTU1BsdWdpbiwgVHdlZW5NYXhXaXRoQ1NTIGFzIFR3ZWVuTWF4LCBUd2VlbkxpdGUsIFRpbWVsaW5lTWF4LCBUaW1lbGluZUxpdGUsIFBvd2VyMCwgUG93ZXIxLCBQb3dlcjIsIFBvd2VyMywgUG93ZXI0LCBMaW5lYXIsIFF1YWQsIEN1YmljLCBRdWFydCwgUXVpbnQsIFN0cm9uZywgRWxhc3RpYywgQmFjaywgU3RlcHBlZEVhc2UsIEJvdW5jZSwgU2luZSwgRXhwbywgQ2lyYyB9OyJdLCJuYW1lcyI6WyJnc2FwIiwiUG93ZXIwIiwiUG93ZXIxIiwiUG93ZXIyIiwiUG93ZXIzIiwiUG93ZXI0IiwiTGluZWFyIiwiUXVhZCIsIkN1YmljIiwiUXVhcnQiLCJRdWludCIsIlN0cm9uZyIsIkVsYXN0aWMiLCJCYWNrIiwiU3RlcHBlZEVhc2UiLCJCb3VuY2UiLCJTaW5lIiwiRXhwbyIsIkNpcmMiLCJUd2VlbkxpdGUiLCJUaW1lbGluZUxpdGUiLCJUaW1lbGluZU1heCIsIkNTU1BsdWdpbiIsImdzYXBXaXRoQ1NTIiwicmVnaXN0ZXJQbHVnaW4iLCJUd2Vlbk1heFdpdGhDU1MiLCJjb3JlIiwiVHdlZW4iLCJkZWZhdWx0IiwiVHdlZW5NYXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/matrix.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/matrix.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Matrix2D: function() { return /* binding */ Matrix2D; },\n/* harmony export */   _getCTM: function() { return /* binding */ _getCTM; },\n/* harmony export */   _getDocScrollLeft: function() { return /* binding */ _getDocScrollLeft; },\n/* harmony export */   _getDocScrollTop: function() { return /* binding */ _getDocScrollTop; },\n/* harmony export */   _isFixed: function() { return /* binding */ _isFixed; },\n/* harmony export */   _setDoc: function() { return /* binding */ _setDoc; },\n/* harmony export */   getGlobalMatrix: function() { return /* binding */ getGlobalMatrix; }\n/* harmony export */ });\n/*!\n * matrix 3.12.5\n * https://gsap.com\n *\n * Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var _doc, _win, _docElement, _body, _divContainer, _svgContainer, _identityMatrix, _gEl, _transformProp = \"transform\", _transformOriginProp = _transformProp + \"Origin\", _hasOffsetBug, _setDoc = function _setDoc(element) {\n    var doc = element.ownerDocument || element;\n    if (!(_transformProp in element.style) && \"msTransform\" in element.style) {\n        //to improve compatibility with old Microsoft browsers\n        _transformProp = \"msTransform\";\n        _transformOriginProp = _transformProp + \"Origin\";\n    }\n    while(doc.parentNode && (doc = doc.parentNode)){}\n    _win = window;\n    _identityMatrix = new Matrix2D();\n    if (doc) {\n        _doc = doc;\n        _docElement = doc.documentElement;\n        _body = doc.body;\n        _gEl = _doc.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"); // prevent any existing CSS from transforming it\n        _gEl.style.transform = \"none\"; // now test for the offset reporting bug. Use feature detection instead of browser sniffing to make things more bulletproof and future-proof. Hopefully Safari will fix their bug soon.\n        var d1 = doc.createElement(\"div\"), d2 = doc.createElement(\"div\"), root = doc && (doc.body || doc.firstElementChild);\n        if (root && root.appendChild) {\n            root.appendChild(d1);\n            d1.appendChild(d2);\n            d1.setAttribute(\"style\", \"position:static;transform:translate3d(0,0,1px)\");\n            _hasOffsetBug = d2.offsetParent !== d1;\n            root.removeChild(d1);\n        }\n    }\n    return doc;\n}, _forceNonZeroScale = function _forceNonZeroScale(e) {\n    // walks up the element's ancestors and finds any that had their scale set to 0 via GSAP, and changes them to 0.0001 to ensure that measurements work. Firefox has a bug that causes it to incorrectly report getBoundingClientRect() when scale is 0.\n    var a, cache;\n    while(e && e !== _body){\n        cache = e._gsap;\n        cache && cache.uncache && cache.get(e, \"x\"); // force re-parsing of transforms if necessary\n        if (cache && !cache.scaleX && !cache.scaleY && cache.renderTransform) {\n            cache.scaleX = cache.scaleY = 1e-4;\n            cache.renderTransform(1, cache);\n            a ? a.push(cache) : a = [\n                cache\n            ];\n        }\n        e = e.parentNode;\n    }\n    return a;\n}, // possible future addition: pass an element to _forceDisplay() and it'll walk up all its ancestors and make sure anything with display: none is set to display: block, and if there's no parentNode, it'll add it to the body. It returns an Array that you can then feed to _revertDisplay() to have it revert all the changes it made.\n// _forceDisplay = e => {\n// \tlet a = [],\n// \t\tparent;\n// \twhile (e && e !== _body) {\n// \t\tparent = e.parentNode;\n// \t\t(_win.getComputedStyle(e).display === \"none\" || !parent) && a.push(e, e.style.display, parent) && (e.style.display = \"block\");\n// \t\tparent || _body.appendChild(e);\n// \t\te = parent;\n// \t}\n// \treturn a;\n// },\n// _revertDisplay = a => {\n// \tfor (let i = 0; i < a.length; i+=3) {\n// \t\ta[i+1] ? (a[i].style.display = a[i+1]) : a[i].style.removeProperty(\"display\");\n// \t\ta[i+2] || a[i].parentNode.removeChild(a[i]);\n// \t}\n// },\n_svgTemps = [], //we create 3 elements for SVG, and 3 for other DOM elements and cache them for performance reasons. They get nested in _divContainer and _svgContainer so that just one element is added to the DOM on each successive attempt. Again, performance is key.\n_divTemps = [], _getDocScrollTop = function _getDocScrollTop() {\n    return _win.pageYOffset || _doc.scrollTop || _docElement.scrollTop || _body.scrollTop || 0;\n}, _getDocScrollLeft = function _getDocScrollLeft() {\n    return _win.pageXOffset || _doc.scrollLeft || _docElement.scrollLeft || _body.scrollLeft || 0;\n}, _svgOwner = function _svgOwner(element) {\n    return element.ownerSVGElement || ((element.tagName + \"\").toLowerCase() === \"svg\" ? element : null);\n}, _isFixed = function _isFixed(element) {\n    if (_win.getComputedStyle(element).position === \"fixed\") {\n        return true;\n    }\n    element = element.parentNode;\n    if (element && element.nodeType === 1) {\n        // avoid document fragments which will throw an error.\n        return _isFixed(element);\n    }\n}, _createSibling = function _createSibling(element, i) {\n    if (element.parentNode && (_doc || _setDoc(element))) {\n        var svg = _svgOwner(element), ns = svg ? svg.getAttribute(\"xmlns\") || \"http://www.w3.org/2000/svg\" : \"http://www.w3.org/1999/xhtml\", type = svg ? i ? \"rect\" : \"g\" : \"div\", x = i !== 2 ? 0 : 100, y = i === 3 ? 100 : 0, css = \"position:absolute;display:block;pointer-events:none;margin:0;padding:0;\", e = _doc.createElementNS ? _doc.createElementNS(ns.replace(/^https/, \"http\"), type) : _doc.createElement(type);\n        if (i) {\n            if (!svg) {\n                if (!_divContainer) {\n                    _divContainer = _createSibling(element);\n                    _divContainer.style.cssText = css;\n                }\n                e.style.cssText = css + \"width:0.1px;height:0.1px;top:\" + y + \"px;left:\" + x + \"px\";\n                _divContainer.appendChild(e);\n            } else {\n                _svgContainer || (_svgContainer = _createSibling(element));\n                e.setAttribute(\"width\", 0.01);\n                e.setAttribute(\"height\", 0.01);\n                e.setAttribute(\"transform\", \"translate(\" + x + \",\" + y + \")\");\n                _svgContainer.appendChild(e);\n            }\n        }\n        return e;\n    }\n    throw \"Need document and parent.\";\n}, _consolidate = function _consolidate(m) {\n    // replaces SVGTransformList.consolidate() because a bug in Firefox causes it to break pointer events. See https://gsap.com/forums/topic/23248-touch-is-not-working-on-draggable-in-firefox-windows-v324/?tab=comments#comment-109800\n    var c = new Matrix2D(), i = 0;\n    for(; i < m.numberOfItems; i++){\n        c.multiply(m.getItem(i).matrix);\n    }\n    return c;\n}, _getCTM = function _getCTM(svg) {\n    var m = svg.getCTM(), transform;\n    if (!m) {\n        // Firefox returns null for getCTM() on root <svg> elements, so this is a workaround using a <g> that we temporarily append.\n        transform = svg.style[_transformProp];\n        svg.style[_transformProp] = \"none\"; // a bug in Firefox causes css transforms to contaminate the getCTM()\n        svg.appendChild(_gEl);\n        m = _gEl.getCTM();\n        svg.removeChild(_gEl);\n        transform ? svg.style[_transformProp] = transform : svg.style.removeProperty(_transformProp.replace(/([A-Z])/g, \"-$1\").toLowerCase());\n    }\n    return m || _identityMatrix.clone(); // Firefox will still return null if the <svg> has a width/height of 0 in the browser.\n}, _placeSiblings = function _placeSiblings(element, adjustGOffset) {\n    var svg = _svgOwner(element), isRootSVG = element === svg, siblings = svg ? _svgTemps : _divTemps, parent = element.parentNode, container, m, b, x, y, cs;\n    if (element === _win) {\n        return element;\n    }\n    siblings.length || siblings.push(_createSibling(element, 1), _createSibling(element, 2), _createSibling(element, 3));\n    container = svg ? _svgContainer : _divContainer;\n    if (svg) {\n        if (isRootSVG) {\n            b = _getCTM(element);\n            x = -b.e / b.a;\n            y = -b.f / b.d;\n            m = _identityMatrix;\n        } else if (element.getBBox) {\n            b = element.getBBox();\n            m = element.transform ? element.transform.baseVal : {}; // IE11 doesn't follow the spec.\n            m = !m.numberOfItems ? _identityMatrix : m.numberOfItems > 1 ? _consolidate(m) : m.getItem(0).matrix; // don't call m.consolidate().matrix because a bug in Firefox makes pointer events not work when consolidate() is called on the same tick as getBoundingClientRect()! See https://gsap.com/forums/topic/23248-touch-is-not-working-on-draggable-in-firefox-windows-v324/?tab=comments#comment-109800\n            x = m.a * b.x + m.c * b.y;\n            y = m.b * b.x + m.d * b.y;\n        } else {\n            // may be a <mask> which has no getBBox() so just use defaults instead of throwing errors.\n            m = new Matrix2D();\n            x = y = 0;\n        }\n        if (adjustGOffset && element.tagName.toLowerCase() === \"g\") {\n            x = y = 0;\n        }\n        (isRootSVG ? svg : parent).appendChild(container);\n        container.setAttribute(\"transform\", \"matrix(\" + m.a + \",\" + m.b + \",\" + m.c + \",\" + m.d + \",\" + (m.e + x) + \",\" + (m.f + y) + \")\");\n    } else {\n        x = y = 0;\n        if (_hasOffsetBug) {\n            // some browsers (like Safari) have a bug that causes them to misreport offset values. When an ancestor element has a transform applied, it's supposed to treat it as if it's position: relative (new context). Safari botches this, so we need to find the closest ancestor (between the element and its offsetParent) that has a transform applied and if one is found, grab its offsetTop/Left and subtract them to compensate.\n            m = element.offsetParent;\n            b = element;\n            while(b && (b = b.parentNode) && b !== m && b.parentNode){\n                if ((_win.getComputedStyle(b)[_transformProp] + \"\").length > 4) {\n                    x = b.offsetLeft;\n                    y = b.offsetTop;\n                    b = 0;\n                }\n            }\n        }\n        cs = _win.getComputedStyle(element);\n        if (cs.position !== \"absolute\" && cs.position !== \"fixed\") {\n            m = element.offsetParent;\n            while(parent && parent !== m){\n                // if there's an ancestor element between the element and its offsetParent that's scrolled, we must factor that in.\n                x += parent.scrollLeft || 0;\n                y += parent.scrollTop || 0;\n                parent = parent.parentNode;\n            }\n        }\n        b = container.style;\n        b.top = element.offsetTop - y + \"px\";\n        b.left = element.offsetLeft - x + \"px\";\n        b[_transformProp] = cs[_transformProp];\n        b[_transformOriginProp] = cs[_transformOriginProp]; // b.border = m.border;\n        // b.borderLeftStyle = m.borderLeftStyle;\n        // b.borderTopStyle = m.borderTopStyle;\n        // b.borderLeftWidth = m.borderLeftWidth;\n        // b.borderTopWidth = m.borderTopWidth;\n        b.position = cs.position === \"fixed\" ? \"fixed\" : \"absolute\";\n        element.parentNode.appendChild(container);\n    }\n    return container;\n}, _setMatrix = function _setMatrix(m, a, b, c, d, e, f) {\n    m.a = a;\n    m.b = b;\n    m.c = c;\n    m.d = d;\n    m.e = e;\n    m.f = f;\n    return m;\n};\nvar Matrix2D = /*#__PURE__*/ function() {\n    function Matrix2D(a, b, c, d, e, f) {\n        if (a === void 0) {\n            a = 1;\n        }\n        if (b === void 0) {\n            b = 0;\n        }\n        if (c === void 0) {\n            c = 0;\n        }\n        if (d === void 0) {\n            d = 1;\n        }\n        if (e === void 0) {\n            e = 0;\n        }\n        if (f === void 0) {\n            f = 0;\n        }\n        _setMatrix(this, a, b, c, d, e, f);\n    }\n    var _proto = Matrix2D.prototype;\n    _proto.inverse = function inverse() {\n        var a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f, determinant = a * d - b * c || 1e-10;\n        return _setMatrix(this, d / determinant, -b / determinant, -c / determinant, a / determinant, (c * f - d * e) / determinant, -(a * f - b * e) / determinant);\n    };\n    _proto.multiply = function multiply(matrix) {\n        var a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f, a2 = matrix.a, b2 = matrix.c, c2 = matrix.b, d2 = matrix.d, e2 = matrix.e, f2 = matrix.f;\n        return _setMatrix(this, a2 * a + c2 * c, a2 * b + c2 * d, b2 * a + d2 * c, b2 * b + d2 * d, e + e2 * a + f2 * c, f + e2 * b + f2 * d);\n    };\n    _proto.clone = function clone() {\n        return new Matrix2D(this.a, this.b, this.c, this.d, this.e, this.f);\n    };\n    _proto.equals = function equals(matrix) {\n        var a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f;\n        return a === matrix.a && b === matrix.b && c === matrix.c && d === matrix.d && e === matrix.e && f === matrix.f;\n    };\n    _proto.apply = function apply(point, decoratee) {\n        if (decoratee === void 0) {\n            decoratee = {};\n        }\n        var x = point.x, y = point.y, a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f;\n        decoratee.x = x * a + y * c + e || 0;\n        decoratee.y = x * b + y * d + f || 0;\n        return decoratee;\n    };\n    return Matrix2D;\n}(); // Feed in an element and it'll return a 2D matrix (optionally inverted) so that you can translate between coordinate spaces.\n// Inverting lets you translate a global point into a local coordinate space. No inverting lets you go the other way.\n// We needed this to work around various browser bugs, like Firefox doesn't accurately report getScreenCTM() when there\n// are transforms applied to ancestor elements.\n// The matrix math to convert any x/y coordinate is as follows, which is wrapped in a convenient apply() method of Matrix2D above:\n//     tx = m.a * x + m.c * y + m.e\n//     ty = m.b * x + m.d * y + m.f\nfunction getGlobalMatrix(element, inverse, adjustGOffset, includeScrollInFixed) {\n    // adjustGOffset is typically used only when grabbing an element's PARENT's global matrix, and it ignores the x/y offset of any SVG <g> elements because they behave in a special way.\n    if (!element || !element.parentNode || (_doc || _setDoc(element)).documentElement === element) {\n        return new Matrix2D();\n    }\n    var zeroScales = _forceNonZeroScale(element), svg = _svgOwner(element), temps = svg ? _svgTemps : _divTemps, container = _placeSiblings(element, adjustGOffset), b1 = temps[0].getBoundingClientRect(), b2 = temps[1].getBoundingClientRect(), b3 = temps[2].getBoundingClientRect(), parent = container.parentNode, isFixed = !includeScrollInFixed && _isFixed(element), m = new Matrix2D((b2.left - b1.left) / 100, (b2.top - b1.top) / 100, (b3.left - b1.left) / 100, (b3.top - b1.top) / 100, b1.left + (isFixed ? 0 : _getDocScrollLeft()), b1.top + (isFixed ? 0 : _getDocScrollTop()));\n    parent.removeChild(container);\n    if (zeroScales) {\n        b1 = zeroScales.length;\n        while(b1--){\n            b2 = zeroScales[b1];\n            b2.scaleX = b2.scaleY = 0;\n            b2.renderTransform(1, b2);\n        }\n    }\n    return inverse ? m.inverse() : m;\n}\n // export function getMatrix(element) {\n // \t_doc || _setDoc(element);\n // \tlet m = (_win.getComputedStyle(element)[_transformProp] + \"\").substr(7).match(/[-.]*\\d+[.e\\-+]*\\d*[e\\-\\+]*\\d*/g),\n // \t\tis2D = m && m.length === 6;\n // \treturn !m || m.length < 6 ? new Matrix2D() : new Matrix2D(+m[0], +m[1], +m[is2D ? 2 : 4], +m[is2D ? 3 : 5], +m[is2D ? 4 : 12], +m[is2D ? 5 : 13]);\n // }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC91dGlscy9tYXRyaXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQVFBLEdBRUEsa0JBQWtCLEdBQ2xCLElBQUlBLE1BQ0FDLE1BQ0FDLGFBQ0FDLE9BQ0FDLGVBQ0FDLGVBQ0FDLGlCQUNBQyxNQUNBQyxpQkFBaUIsYUFDakJDLHVCQUF1QkQsaUJBQWlCLFVBQ3hDRSxlQUNBQyxVQUFVLFNBQVNBLFFBQVFDLE9BQU87SUFDcEMsSUFBSUMsTUFBTUQsUUFBUUUsYUFBYSxJQUFJRjtJQUVuQyxJQUFJLENBQUVKLENBQUFBLGtCQUFrQkksUUFBUUcsS0FBSyxLQUFLLGlCQUFpQkgsUUFBUUcsS0FBSyxFQUFFO1FBQ3hFLHNEQUFzRDtRQUN0RFAsaUJBQWlCO1FBQ2pCQyx1QkFBdUJELGlCQUFpQjtJQUMxQztJQUVBLE1BQU9LLElBQUlHLFVBQVUsSUFBS0gsQ0FBQUEsTUFBTUEsSUFBSUcsVUFBVSxFQUFHLENBQUM7SUFFbERmLE9BQU9nQjtJQUNQWCxrQkFBa0IsSUFBSVk7SUFFdEIsSUFBSUwsS0FBSztRQUNQYixPQUFPYTtRQUNQWCxjQUFjVyxJQUFJTSxlQUFlO1FBQ2pDaEIsUUFBUVUsSUFBSU8sSUFBSTtRQUNoQmIsT0FBT1AsS0FBS3FCLGVBQWUsQ0FBQyw4QkFBOEIsTUFBTSxnREFBZ0Q7UUFFaEhkLEtBQUtRLEtBQUssQ0FBQ08sU0FBUyxHQUFHLFFBQVEsdUxBQXVMO1FBRXROLElBQUlDLEtBQUtWLElBQUlXLGFBQWEsQ0FBQyxRQUN2QkMsS0FBS1osSUFBSVcsYUFBYSxDQUFDLFFBQ3ZCRSxPQUFPYixPQUFRQSxDQUFBQSxJQUFJTyxJQUFJLElBQUlQLElBQUljLGlCQUFpQjtRQUVwRCxJQUFJRCxRQUFRQSxLQUFLRSxXQUFXLEVBQUU7WUFDNUJGLEtBQUtFLFdBQVcsQ0FBQ0w7WUFDakJBLEdBQUdL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RSxHQUFHL0QsZUFBZSxDQUFDLEdBQUcrRDtRQUN4QjtJQUNGO0lBRUEsT0FBT0gsVUFBVTlCLEVBQUU4QixPQUFPLEtBQUs5QjtBQUNqQztBQUMyRSxDQUFDLHVDQUF1QztDQUNuSCw2QkFBNkI7Q0FDN0IscUhBQXFIO0NBQ3JILGdDQUFnQztDQUNoQyxzSkFBc0o7Q0FDdEosSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vZ3NhcEAzLjEyLjUvbm9kZV9tb2R1bGVzL2dzYXAvdXRpbHMvbWF0cml4LmpzPzU0ODMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBtYXRyaXggMy4xMi41XG4gKiBodHRwczovL2dzYXAuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyNCwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9nc2FwLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHU0FQIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIF9kb2MsXG4gICAgX3dpbixcbiAgICBfZG9jRWxlbWVudCxcbiAgICBfYm9keSxcbiAgICBfZGl2Q29udGFpbmVyLFxuICAgIF9zdmdDb250YWluZXIsXG4gICAgX2lkZW50aXR5TWF0cml4LFxuICAgIF9nRWwsXG4gICAgX3RyYW5zZm9ybVByb3AgPSBcInRyYW5zZm9ybVwiLFxuICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiLFxuICAgIF9oYXNPZmZzZXRCdWcsXG4gICAgX3NldERvYyA9IGZ1bmN0aW9uIF9zZXREb2MoZWxlbWVudCkge1xuICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGVsZW1lbnQ7XG5cbiAgaWYgKCEoX3RyYW5zZm9ybVByb3AgaW4gZWxlbWVudC5zdHlsZSkgJiYgXCJtc1RyYW5zZm9ybVwiIGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAvL3RvIGltcHJvdmUgY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBNaWNyb3NvZnQgYnJvd3NlcnNcbiAgICBfdHJhbnNmb3JtUHJvcCA9IFwibXNUcmFuc2Zvcm1cIjtcbiAgICBfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF90cmFuc2Zvcm1Qcm9wICsgXCJPcmlnaW5cIjtcbiAgfVxuXG4gIHdoaWxlIChkb2MucGFyZW50Tm9kZSAmJiAoZG9jID0gZG9jLnBhcmVudE5vZGUpKSB7fVxuXG4gIF93aW4gPSB3aW5kb3c7XG4gIF9pZGVudGl0eU1hdHJpeCA9IG5ldyBNYXRyaXgyRCgpO1xuXG4gIGlmIChkb2MpIHtcbiAgICBfZG9jID0gZG9jO1xuICAgIF9kb2NFbGVtZW50ID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICBfYm9keSA9IGRvYy5ib2R5O1xuICAgIF9nRWwgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTsgLy8gcHJldmVudCBhbnkgZXhpc3RpbmcgQ1NTIGZyb20gdHJhbnNmb3JtaW5nIGl0XG5cbiAgICBfZ0VsLnN0eWxlLnRyYW5zZm9ybSA9IFwibm9uZVwiOyAvLyBub3cgdGVzdCBmb3IgdGhlIG9mZnNldCByZXBvcnRpbmcgYnVnLiBVc2UgZmVhdHVyZSBkZXRlY3Rpb24gaW5zdGVhZCBvZiBicm93c2VyIHNuaWZmaW5nIHRvIG1ha2UgdGhpbmdzIG1vcmUgYnVsbGV0cHJvb2YgYW5kIGZ1dHVyZS1wcm9vZi4gSG9wZWZ1bGx5IFNhZmFyaSB3aWxsIGZpeCB0aGVpciBidWcgc29vbi5cblxuICAgIHZhciBkMSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICBkMiA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICByb290ID0gZG9jICYmIChkb2MuYm9keSB8fCBkb2MuZmlyc3RFbGVtZW50Q2hpbGQpO1xuXG4gICAgaWYgKHJvb3QgJiYgcm9vdC5hcHBlbmRDaGlsZCkge1xuICAgICAgcm9vdC5hcHBlbmRDaGlsZChkMSk7XG4gICAgICBkMS5hcHBlbmRDaGlsZChkMik7XG4gICAgICBkMS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcInBvc2l0aW9uOnN0YXRpYzt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDFweClcIik7XG4gICAgICBfaGFzT2Zmc2V0QnVnID0gZDIub2Zmc2V0UGFyZW50ICE9PSBkMTtcbiAgICAgIHJvb3QucmVtb3ZlQ2hpbGQoZDEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkb2M7XG59LFxuICAgIF9mb3JjZU5vblplcm9TY2FsZSA9IGZ1bmN0aW9uIF9mb3JjZU5vblplcm9TY2FsZShlKSB7XG4gIC8vIHdhbGtzIHVwIHRoZSBlbGVtZW50J3MgYW5jZXN0b3JzIGFuZCBmaW5kcyBhbnkgdGhhdCBoYWQgdGhlaXIgc2NhbGUgc2V0IHRvIDAgdmlhIEdTQVAsIGFuZCBjaGFuZ2VzIHRoZW0gdG8gMC4wMDAxIHRvIGVuc3VyZSB0aGF0IG1lYXN1cmVtZW50cyB3b3JrLiBGaXJlZm94IGhhcyBhIGJ1ZyB0aGF0IGNhdXNlcyBpdCB0byBpbmNvcnJlY3RseSByZXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgd2hlbiBzY2FsZSBpcyAwLlxuICB2YXIgYSwgY2FjaGU7XG5cbiAgd2hpbGUgKGUgJiYgZSAhPT0gX2JvZHkpIHtcbiAgICBjYWNoZSA9IGUuX2dzYXA7XG4gICAgY2FjaGUgJiYgY2FjaGUudW5jYWNoZSAmJiBjYWNoZS5nZXQoZSwgXCJ4XCIpOyAvLyBmb3JjZSByZS1wYXJzaW5nIG9mIHRyYW5zZm9ybXMgaWYgbmVjZXNzYXJ5XG5cbiAgICBpZiAoY2FjaGUgJiYgIWNhY2hlLnNjYWxlWCAmJiAhY2FjaGUuc2NhbGVZICYmIGNhY2hlLnJlbmRlclRyYW5zZm9ybSkge1xuICAgICAgY2FjaGUuc2NhbGVYID0gY2FjaGUuc2NhbGVZID0gMWUtNDtcbiAgICAgIGNhY2hlLnJlbmRlclRyYW5zZm9ybSgxLCBjYWNoZSk7XG4gICAgICBhID8gYS5wdXNoKGNhY2hlKSA6IGEgPSBbY2FjaGVdO1xuICAgIH1cblxuICAgIGUgPSBlLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gYTtcbn0sXG4gICAgLy8gcG9zc2libGUgZnV0dXJlIGFkZGl0aW9uOiBwYXNzIGFuIGVsZW1lbnQgdG8gX2ZvcmNlRGlzcGxheSgpIGFuZCBpdCdsbCB3YWxrIHVwIGFsbCBpdHMgYW5jZXN0b3JzIGFuZCBtYWtlIHN1cmUgYW55dGhpbmcgd2l0aCBkaXNwbGF5OiBub25lIGlzIHNldCB0byBkaXNwbGF5OiBibG9jaywgYW5kIGlmIHRoZXJlJ3Mgbm8gcGFyZW50Tm9kZSwgaXQnbGwgYWRkIGl0IHRvIHRoZSBib2R5LiBJdCByZXR1cm5zIGFuIEFycmF5IHRoYXQgeW91IGNhbiB0aGVuIGZlZWQgdG8gX3JldmVydERpc3BsYXkoKSB0byBoYXZlIGl0IHJldmVydCBhbGwgdGhlIGNoYW5nZXMgaXQgbWFkZS5cbi8vIF9mb3JjZURpc3BsYXkgPSBlID0+IHtcbi8vIFx0bGV0IGEgPSBbXSxcbi8vIFx0XHRwYXJlbnQ7XG4vLyBcdHdoaWxlIChlICYmIGUgIT09IF9ib2R5KSB7XG4vLyBcdFx0cGFyZW50ID0gZS5wYXJlbnROb2RlO1xuLy8gXHRcdChfd2luLmdldENvbXB1dGVkU3R5bGUoZSkuZGlzcGxheSA9PT0gXCJub25lXCIgfHwgIXBhcmVudCkgJiYgYS5wdXNoKGUsIGUuc3R5bGUuZGlzcGxheSwgcGFyZW50KSAmJiAoZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiKTtcbi8vIFx0XHRwYXJlbnQgfHwgX2JvZHkuYXBwZW5kQ2hpbGQoZSk7XG4vLyBcdFx0ZSA9IHBhcmVudDtcbi8vIFx0fVxuLy8gXHRyZXR1cm4gYTtcbi8vIH0sXG4vLyBfcmV2ZXJ0RGlzcGxheSA9IGEgPT4ge1xuLy8gXHRmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKz0zKSB7XG4vLyBcdFx0YVtpKzFdID8gKGFbaV0uc3R5bGUuZGlzcGxheSA9IGFbaSsxXSkgOiBhW2ldLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZGlzcGxheVwiKTtcbi8vIFx0XHRhW2krMl0gfHwgYVtpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGFbaV0pO1xuLy8gXHR9XG4vLyB9LFxuX3N2Z1RlbXBzID0gW10sXG4gICAgLy93ZSBjcmVhdGUgMyBlbGVtZW50cyBmb3IgU1ZHLCBhbmQgMyBmb3Igb3RoZXIgRE9NIGVsZW1lbnRzIGFuZCBjYWNoZSB0aGVtIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBUaGV5IGdldCBuZXN0ZWQgaW4gX2RpdkNvbnRhaW5lciBhbmQgX3N2Z0NvbnRhaW5lciBzbyB0aGF0IGp1c3Qgb25lIGVsZW1lbnQgaXMgYWRkZWQgdG8gdGhlIERPTSBvbiBlYWNoIHN1Y2Nlc3NpdmUgYXR0ZW1wdC4gQWdhaW4sIHBlcmZvcm1hbmNlIGlzIGtleS5cbl9kaXZUZW1wcyA9IFtdLFxuICAgIF9nZXREb2NTY3JvbGxUb3AgPSBmdW5jdGlvbiBfZ2V0RG9jU2Nyb2xsVG9wKCkge1xuICByZXR1cm4gX3dpbi5wYWdlWU9mZnNldCB8fCBfZG9jLnNjcm9sbFRvcCB8fCBfZG9jRWxlbWVudC5zY3JvbGxUb3AgfHwgX2JvZHkuc2Nyb2xsVG9wIHx8IDA7XG59LFxuICAgIF9nZXREb2NTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gX2dldERvY1Njcm9sbExlZnQoKSB7XG4gIHJldHVybiBfd2luLnBhZ2VYT2Zmc2V0IHx8IF9kb2Muc2Nyb2xsTGVmdCB8fCBfZG9jRWxlbWVudC5zY3JvbGxMZWZ0IHx8IF9ib2R5LnNjcm9sbExlZnQgfHwgMDtcbn0sXG4gICAgX3N2Z093bmVyID0gZnVuY3Rpb24gX3N2Z093bmVyKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQub3duZXJTVkdFbGVtZW50IHx8ICgoZWxlbWVudC50YWdOYW1lICsgXCJcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJzdmdcIiA/IGVsZW1lbnQgOiBudWxsKTtcbn0sXG4gICAgX2lzRml4ZWQgPSBmdW5jdGlvbiBfaXNGaXhlZChlbGVtZW50KSB7XG4gIGlmIChfd2luLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09IFwiZml4ZWRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgLy8gYXZvaWQgZG9jdW1lbnQgZnJhZ21lbnRzIHdoaWNoIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgcmV0dXJuIF9pc0ZpeGVkKGVsZW1lbnQpO1xuICB9XG59LFxuICAgIF9jcmVhdGVTaWJsaW5nID0gZnVuY3Rpb24gX2NyZWF0ZVNpYmxpbmcoZWxlbWVudCwgaSkge1xuICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICYmIChfZG9jIHx8IF9zZXREb2MoZWxlbWVudCkpKSB7XG4gICAgdmFyIHN2ZyA9IF9zdmdPd25lcihlbGVtZW50KSxcbiAgICAgICAgbnMgPSBzdmcgPyBzdmcuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIDogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsXG4gICAgICAgIHR5cGUgPSBzdmcgPyBpID8gXCJyZWN0XCIgOiBcImdcIiA6IFwiZGl2XCIsXG4gICAgICAgIHggPSBpICE9PSAyID8gMCA6IDEwMCxcbiAgICAgICAgeSA9IGkgPT09IDMgPyAxMDAgOiAwLFxuICAgICAgICBjc3MgPSBcInBvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7cG9pbnRlci1ldmVudHM6bm9uZTttYXJnaW46MDtwYWRkaW5nOjA7XCIsXG4gICAgICAgIGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyA/IF9kb2MuY3JlYXRlRWxlbWVudE5TKG5zLnJlcGxhY2UoL15odHRwcy8sIFwiaHR0cFwiKSwgdHlwZSkgOiBfZG9jLmNyZWF0ZUVsZW1lbnQodHlwZSk7XG5cbiAgICBpZiAoaSkge1xuICAgICAgaWYgKCFzdmcpIHtcbiAgICAgICAgaWYgKCFfZGl2Q29udGFpbmVyKSB7XG4gICAgICAgICAgX2RpdkNvbnRhaW5lciA9IF9jcmVhdGVTaWJsaW5nKGVsZW1lbnQpO1xuICAgICAgICAgIF9kaXZDb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGNzcztcbiAgICAgICAgfVxuXG4gICAgICAgIGUuc3R5bGUuY3NzVGV4dCA9IGNzcyArIFwid2lkdGg6MC4xcHg7aGVpZ2h0OjAuMXB4O3RvcDpcIiArIHkgKyBcInB4O2xlZnQ6XCIgKyB4ICsgXCJweFwiO1xuXG4gICAgICAgIF9kaXZDb250YWluZXIuYXBwZW5kQ2hpbGQoZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfc3ZnQ29udGFpbmVyIHx8IChfc3ZnQ29udGFpbmVyID0gX2NyZWF0ZVNpYmxpbmcoZWxlbWVudCkpO1xuICAgICAgICBlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIDAuMDEpO1xuICAgICAgICBlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCAwLjAxKTtcbiAgICAgICAgZS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpXCIpO1xuXG4gICAgICAgIF9zdmdDb250YWluZXIuYXBwZW5kQ2hpbGQoZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICB0aHJvdyBcIk5lZWQgZG9jdW1lbnQgYW5kIHBhcmVudC5cIjtcbn0sXG4gICAgX2NvbnNvbGlkYXRlID0gZnVuY3Rpb24gX2NvbnNvbGlkYXRlKG0pIHtcbiAgLy8gcmVwbGFjZXMgU1ZHVHJhbnNmb3JtTGlzdC5jb25zb2xpZGF0ZSgpIGJlY2F1c2UgYSBidWcgaW4gRmlyZWZveCBjYXVzZXMgaXQgdG8gYnJlYWsgcG9pbnRlciBldmVudHMuIFNlZSBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8yMzI0OC10b3VjaC1pcy1ub3Qtd29ya2luZy1vbi1kcmFnZ2FibGUtaW4tZmlyZWZveC13aW5kb3dzLXYzMjQvP3RhYj1jb21tZW50cyNjb21tZW50LTEwOTgwMFxuICB2YXIgYyA9IG5ldyBNYXRyaXgyRCgpLFxuICAgICAgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBtLm51bWJlck9mSXRlbXM7IGkrKykge1xuICAgIGMubXVsdGlwbHkobS5nZXRJdGVtKGkpLm1hdHJpeCk7XG4gIH1cblxuICByZXR1cm4gYztcbn0sXG4gICAgX2dldENUTSA9IGZ1bmN0aW9uIF9nZXRDVE0oc3ZnKSB7XG4gIHZhciBtID0gc3ZnLmdldENUTSgpLFxuICAgICAgdHJhbnNmb3JtO1xuXG4gIGlmICghbSkge1xuICAgIC8vIEZpcmVmb3ggcmV0dXJucyBudWxsIGZvciBnZXRDVE0oKSBvbiByb290IDxzdmc+IGVsZW1lbnRzLCBzbyB0aGlzIGlzIGEgd29ya2Fyb3VuZCB1c2luZyBhIDxnPiB0aGF0IHdlIHRlbXBvcmFyaWx5IGFwcGVuZC5cbiAgICB0cmFuc2Zvcm0gPSBzdmcuc3R5bGVbX3RyYW5zZm9ybVByb3BdO1xuICAgIHN2Zy5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSBcIm5vbmVcIjsgLy8gYSBidWcgaW4gRmlyZWZveCBjYXVzZXMgY3NzIHRyYW5zZm9ybXMgdG8gY29udGFtaW5hdGUgdGhlIGdldENUTSgpXG5cbiAgICBzdmcuYXBwZW5kQ2hpbGQoX2dFbCk7XG4gICAgbSA9IF9nRWwuZ2V0Q1RNKCk7XG4gICAgc3ZnLnJlbW92ZUNoaWxkKF9nRWwpO1xuICAgIHRyYW5zZm9ybSA/IHN2Zy5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm0gOiBzdmcuc3R5bGUucmVtb3ZlUHJvcGVydHkoX3RyYW5zZm9ybVByb3AucmVwbGFjZSgvKFtBLVpdKS9nLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIHJldHVybiBtIHx8IF9pZGVudGl0eU1hdHJpeC5jbG9uZSgpOyAvLyBGaXJlZm94IHdpbGwgc3RpbGwgcmV0dXJuIG51bGwgaWYgdGhlIDxzdmc+IGhhcyBhIHdpZHRoL2hlaWdodCBvZiAwIGluIHRoZSBicm93c2VyLlxufSxcbiAgICBfcGxhY2VTaWJsaW5ncyA9IGZ1bmN0aW9uIF9wbGFjZVNpYmxpbmdzKGVsZW1lbnQsIGFkanVzdEdPZmZzZXQpIHtcbiAgdmFyIHN2ZyA9IF9zdmdPd25lcihlbGVtZW50KSxcbiAgICAgIGlzUm9vdFNWRyA9IGVsZW1lbnQgPT09IHN2ZyxcbiAgICAgIHNpYmxpbmdzID0gc3ZnID8gX3N2Z1RlbXBzIDogX2RpdlRlbXBzLFxuICAgICAgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgbSxcbiAgICAgIGIsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGNzO1xuXG4gIGlmIChlbGVtZW50ID09PSBfd2luKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBzaWJsaW5ncy5sZW5ndGggfHwgc2libGluZ3MucHVzaChfY3JlYXRlU2libGluZyhlbGVtZW50LCAxKSwgX2NyZWF0ZVNpYmxpbmcoZWxlbWVudCwgMiksIF9jcmVhdGVTaWJsaW5nKGVsZW1lbnQsIDMpKTtcbiAgY29udGFpbmVyID0gc3ZnID8gX3N2Z0NvbnRhaW5lciA6IF9kaXZDb250YWluZXI7XG5cbiAgaWYgKHN2Zykge1xuICAgIGlmIChpc1Jvb3RTVkcpIHtcbiAgICAgIGIgPSBfZ2V0Q1RNKGVsZW1lbnQpO1xuICAgICAgeCA9IC1iLmUgLyBiLmE7XG4gICAgICB5ID0gLWIuZiAvIGIuZDtcbiAgICAgIG0gPSBfaWRlbnRpdHlNYXRyaXg7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LmdldEJCb3gpIHtcbiAgICAgIGIgPSBlbGVtZW50LmdldEJCb3goKTtcbiAgICAgIG0gPSBlbGVtZW50LnRyYW5zZm9ybSA/IGVsZW1lbnQudHJhbnNmb3JtLmJhc2VWYWwgOiB7fTsgLy8gSUUxMSBkb2Vzbid0IGZvbGxvdyB0aGUgc3BlYy5cblxuICAgICAgbSA9ICFtLm51bWJlck9mSXRlbXMgPyBfaWRlbnRpdHlNYXRyaXggOiBtLm51bWJlck9mSXRlbXMgPiAxID8gX2NvbnNvbGlkYXRlKG0pIDogbS5nZXRJdGVtKDApLm1hdHJpeDsgLy8gZG9uJ3QgY2FsbCBtLmNvbnNvbGlkYXRlKCkubWF0cml4IGJlY2F1c2UgYSBidWcgaW4gRmlyZWZveCBtYWtlcyBwb2ludGVyIGV2ZW50cyBub3Qgd29yayB3aGVuIGNvbnNvbGlkYXRlKCkgaXMgY2FsbGVkIG9uIHRoZSBzYW1lIHRpY2sgYXMgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkhIFNlZSBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8yMzI0OC10b3VjaC1pcy1ub3Qtd29ya2luZy1vbi1kcmFnZ2FibGUtaW4tZmlyZWZveC13aW5kb3dzLXYzMjQvP3RhYj1jb21tZW50cyNjb21tZW50LTEwOTgwMFxuXG4gICAgICB4ID0gbS5hICogYi54ICsgbS5jICogYi55O1xuICAgICAgeSA9IG0uYiAqIGIueCArIG0uZCAqIGIueTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbWF5IGJlIGEgPG1hc2s+IHdoaWNoIGhhcyBubyBnZXRCQm94KCkgc28ganVzdCB1c2UgZGVmYXVsdHMgaW5zdGVhZCBvZiB0aHJvd2luZyBlcnJvcnMuXG4gICAgICBtID0gbmV3IE1hdHJpeDJEKCk7XG4gICAgICB4ID0geSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGFkanVzdEdPZmZzZXQgJiYgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZ1wiKSB7XG4gICAgICB4ID0geSA9IDA7XG4gICAgfVxuXG4gICAgKGlzUm9vdFNWRyA/IHN2ZyA6IHBhcmVudCkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwibWF0cml4KFwiICsgbS5hICsgXCIsXCIgKyBtLmIgKyBcIixcIiArIG0uYyArIFwiLFwiICsgbS5kICsgXCIsXCIgKyAobS5lICsgeCkgKyBcIixcIiArIChtLmYgKyB5KSArIFwiKVwiKTtcbiAgfSBlbHNlIHtcbiAgICB4ID0geSA9IDA7XG5cbiAgICBpZiAoX2hhc09mZnNldEJ1Zykge1xuICAgICAgLy8gc29tZSBicm93c2VycyAobGlrZSBTYWZhcmkpIGhhdmUgYSBidWcgdGhhdCBjYXVzZXMgdGhlbSB0byBtaXNyZXBvcnQgb2Zmc2V0IHZhbHVlcy4gV2hlbiBhbiBhbmNlc3RvciBlbGVtZW50IGhhcyBhIHRyYW5zZm9ybSBhcHBsaWVkLCBpdCdzIHN1cHBvc2VkIHRvIHRyZWF0IGl0IGFzIGlmIGl0J3MgcG9zaXRpb246IHJlbGF0aXZlIChuZXcgY29udGV4dCkuIFNhZmFyaSBib3RjaGVzIHRoaXMsIHNvIHdlIG5lZWQgdG8gZmluZCB0aGUgY2xvc2VzdCBhbmNlc3RvciAoYmV0d2VlbiB0aGUgZWxlbWVudCBhbmQgaXRzIG9mZnNldFBhcmVudCkgdGhhdCBoYXMgYSB0cmFuc2Zvcm0gYXBwbGllZCBhbmQgaWYgb25lIGlzIGZvdW5kLCBncmFiIGl0cyBvZmZzZXRUb3AvTGVmdCBhbmQgc3VidHJhY3QgdGhlbSB0byBjb21wZW5zYXRlLlxuICAgICAgbSA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAgICAgYiA9IGVsZW1lbnQ7XG5cbiAgICAgIHdoaWxlIChiICYmIChiID0gYi5wYXJlbnROb2RlKSAmJiBiICE9PSBtICYmIGIucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoKF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShiKVtfdHJhbnNmb3JtUHJvcF0gKyBcIlwiKS5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgeCA9IGIub2Zmc2V0TGVmdDtcbiAgICAgICAgICB5ID0gYi5vZmZzZXRUb3A7XG4gICAgICAgICAgYiA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjcyA9IF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChjcy5wb3NpdGlvbiAhPT0gXCJhYnNvbHV0ZVwiICYmIGNzLnBvc2l0aW9uICE9PSBcImZpeGVkXCIpIHtcbiAgICAgIG0gPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcblxuICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQgIT09IG0pIHtcbiAgICAgICAgLy8gaWYgdGhlcmUncyBhbiBhbmNlc3RvciBlbGVtZW50IGJldHdlZW4gdGhlIGVsZW1lbnQgYW5kIGl0cyBvZmZzZXRQYXJlbnQgdGhhdCdzIHNjcm9sbGVkLCB3ZSBtdXN0IGZhY3RvciB0aGF0IGluLlxuICAgICAgICB4ICs9IHBhcmVudC5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgIHkgKz0gcGFyZW50LnNjcm9sbFRvcCB8fCAwO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiID0gY29udGFpbmVyLnN0eWxlO1xuICAgIGIudG9wID0gZWxlbWVudC5vZmZzZXRUb3AgLSB5ICsgXCJweFwiO1xuICAgIGIubGVmdCA9IGVsZW1lbnQub2Zmc2V0TGVmdCAtIHggKyBcInB4XCI7XG4gICAgYltfdHJhbnNmb3JtUHJvcF0gPSBjc1tfdHJhbnNmb3JtUHJvcF07XG4gICAgYltfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBjc1tfdHJhbnNmb3JtT3JpZ2luUHJvcF07IC8vIGIuYm9yZGVyID0gbS5ib3JkZXI7XG4gICAgLy8gYi5ib3JkZXJMZWZ0U3R5bGUgPSBtLmJvcmRlckxlZnRTdHlsZTtcbiAgICAvLyBiLmJvcmRlclRvcFN0eWxlID0gbS5ib3JkZXJUb3BTdHlsZTtcbiAgICAvLyBiLmJvcmRlckxlZnRXaWR0aCA9IG0uYm9yZGVyTGVmdFdpZHRoO1xuICAgIC8vIGIuYm9yZGVyVG9wV2lkdGggPSBtLmJvcmRlclRvcFdpZHRoO1xuXG4gICAgYi5wb3NpdGlvbiA9IGNzLnBvc2l0aW9uID09PSBcImZpeGVkXCIgPyBcImZpeGVkXCIgOiBcImFic29sdXRlXCI7XG4gICAgZWxlbWVudC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gIH1cblxuICByZXR1cm4gY29udGFpbmVyO1xufSxcbiAgICBfc2V0TWF0cml4ID0gZnVuY3Rpb24gX3NldE1hdHJpeChtLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIG0uYSA9IGE7XG4gIG0uYiA9IGI7XG4gIG0uYyA9IGM7XG4gIG0uZCA9IGQ7XG4gIG0uZSA9IGU7XG4gIG0uZiA9IGY7XG4gIHJldHVybiBtO1xufTtcblxuZXhwb3J0IHZhciBNYXRyaXgyRCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hdHJpeDJEKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBpZiAoYSA9PT0gdm9pZCAwKSB7XG4gICAgICBhID0gMTtcbiAgICB9XG5cbiAgICBpZiAoYiA9PT0gdm9pZCAwKSB7XG4gICAgICBiID0gMDtcbiAgICB9XG5cbiAgICBpZiAoYyA9PT0gdm9pZCAwKSB7XG4gICAgICBjID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZCA9PT0gdm9pZCAwKSB7XG4gICAgICBkID0gMTtcbiAgICB9XG5cbiAgICBpZiAoZSA9PT0gdm9pZCAwKSB7XG4gICAgICBlID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZiA9PT0gdm9pZCAwKSB7XG4gICAgICBmID0gMDtcbiAgICB9XG5cbiAgICBfc2V0TWF0cml4KHRoaXMsIGEsIGIsIGMsIGQsIGUsIGYpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE1hdHJpeDJELnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW52ZXJzZSA9IGZ1bmN0aW9uIGludmVyc2UoKSB7XG4gICAgdmFyIGEgPSB0aGlzLmEsXG4gICAgICAgIGIgPSB0aGlzLmIsXG4gICAgICAgIGMgPSB0aGlzLmMsXG4gICAgICAgIGQgPSB0aGlzLmQsXG4gICAgICAgIGUgPSB0aGlzLmUsXG4gICAgICAgIGYgPSB0aGlzLmYsXG4gICAgICAgIGRldGVybWluYW50ID0gYSAqIGQgLSBiICogYyB8fCAxZS0xMDtcbiAgICByZXR1cm4gX3NldE1hdHJpeCh0aGlzLCBkIC8gZGV0ZXJtaW5hbnQsIC1iIC8gZGV0ZXJtaW5hbnQsIC1jIC8gZGV0ZXJtaW5hbnQsIGEgLyBkZXRlcm1pbmFudCwgKGMgKiBmIC0gZCAqIGUpIC8gZGV0ZXJtaW5hbnQsIC0oYSAqIGYgLSBiICogZSkgLyBkZXRlcm1pbmFudCk7XG4gIH07XG5cbiAgX3Byb3RvLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobWF0cml4KSB7XG4gICAgdmFyIGEgPSB0aGlzLmEsXG4gICAgICAgIGIgPSB0aGlzLmIsXG4gICAgICAgIGMgPSB0aGlzLmMsXG4gICAgICAgIGQgPSB0aGlzLmQsXG4gICAgICAgIGUgPSB0aGlzLmUsXG4gICAgICAgIGYgPSB0aGlzLmYsXG4gICAgICAgIGEyID0gbWF0cml4LmEsXG4gICAgICAgIGIyID0gbWF0cml4LmMsXG4gICAgICAgIGMyID0gbWF0cml4LmIsXG4gICAgICAgIGQyID0gbWF0cml4LmQsXG4gICAgICAgIGUyID0gbWF0cml4LmUsXG4gICAgICAgIGYyID0gbWF0cml4LmY7XG4gICAgcmV0dXJuIF9zZXRNYXRyaXgodGhpcywgYTIgKiBhICsgYzIgKiBjLCBhMiAqIGIgKyBjMiAqIGQsIGIyICogYSArIGQyICogYywgYjIgKiBiICsgZDIgKiBkLCBlICsgZTIgKiBhICsgZjIgKiBjLCBmICsgZTIgKiBiICsgZjIgKiBkKTtcbiAgfTtcblxuICBfcHJvdG8uY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDJEKHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRoaXMuZCwgdGhpcy5lLCB0aGlzLmYpO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMobWF0cml4KSB7XG4gICAgdmFyIGEgPSB0aGlzLmEsXG4gICAgICAgIGIgPSB0aGlzLmIsXG4gICAgICAgIGMgPSB0aGlzLmMsXG4gICAgICAgIGQgPSB0aGlzLmQsXG4gICAgICAgIGUgPSB0aGlzLmUsXG4gICAgICAgIGYgPSB0aGlzLmY7XG4gICAgcmV0dXJuIGEgPT09IG1hdHJpeC5hICYmIGIgPT09IG1hdHJpeC5iICYmIGMgPT09IG1hdHJpeC5jICYmIGQgPT09IG1hdHJpeC5kICYmIGUgPT09IG1hdHJpeC5lICYmIGYgPT09IG1hdHJpeC5mO1xuICB9O1xuXG4gIF9wcm90by5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5KHBvaW50LCBkZWNvcmF0ZWUpIHtcbiAgICBpZiAoZGVjb3JhdGVlID09PSB2b2lkIDApIHtcbiAgICAgIGRlY29yYXRlZSA9IHt9O1xuICAgIH1cblxuICAgIHZhciB4ID0gcG9pbnQueCxcbiAgICAgICAgeSA9IHBvaW50LnksXG4gICAgICAgIGEgPSB0aGlzLmEsXG4gICAgICAgIGIgPSB0aGlzLmIsXG4gICAgICAgIGMgPSB0aGlzLmMsXG4gICAgICAgIGQgPSB0aGlzLmQsXG4gICAgICAgIGUgPSB0aGlzLmUsXG4gICAgICAgIGYgPSB0aGlzLmY7XG4gICAgZGVjb3JhdGVlLnggPSB4ICogYSArIHkgKiBjICsgZSB8fCAwO1xuICAgIGRlY29yYXRlZS55ID0geCAqIGIgKyB5ICogZCArIGYgfHwgMDtcbiAgICByZXR1cm4gZGVjb3JhdGVlO1xuICB9O1xuXG4gIHJldHVybiBNYXRyaXgyRDtcbn0oKTsgLy8gRmVlZCBpbiBhbiBlbGVtZW50IGFuZCBpdCdsbCByZXR1cm4gYSAyRCBtYXRyaXggKG9wdGlvbmFsbHkgaW52ZXJ0ZWQpIHNvIHRoYXQgeW91IGNhbiB0cmFuc2xhdGUgYmV0d2VlbiBjb29yZGluYXRlIHNwYWNlcy5cbi8vIEludmVydGluZyBsZXRzIHlvdSB0cmFuc2xhdGUgYSBnbG9iYWwgcG9pbnQgaW50byBhIGxvY2FsIGNvb3JkaW5hdGUgc3BhY2UuIE5vIGludmVydGluZyBsZXRzIHlvdSBnbyB0aGUgb3RoZXIgd2F5LlxuLy8gV2UgbmVlZGVkIHRoaXMgdG8gd29yayBhcm91bmQgdmFyaW91cyBicm93c2VyIGJ1Z3MsIGxpa2UgRmlyZWZveCBkb2Vzbid0IGFjY3VyYXRlbHkgcmVwb3J0IGdldFNjcmVlbkNUTSgpIHdoZW4gdGhlcmVcbi8vIGFyZSB0cmFuc2Zvcm1zIGFwcGxpZWQgdG8gYW5jZXN0b3IgZWxlbWVudHMuXG4vLyBUaGUgbWF0cml4IG1hdGggdG8gY29udmVydCBhbnkgeC95IGNvb3JkaW5hdGUgaXMgYXMgZm9sbG93cywgd2hpY2ggaXMgd3JhcHBlZCBpbiBhIGNvbnZlbmllbnQgYXBwbHkoKSBtZXRob2Qgb2YgTWF0cml4MkQgYWJvdmU6XG4vLyAgICAgdHggPSBtLmEgKiB4ICsgbS5jICogeSArIG0uZVxuLy8gICAgIHR5ID0gbS5iICogeCArIG0uZCAqIHkgKyBtLmZcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEdsb2JhbE1hdHJpeChlbGVtZW50LCBpbnZlcnNlLCBhZGp1c3RHT2Zmc2V0LCBpbmNsdWRlU2Nyb2xsSW5GaXhlZCkge1xuICAvLyBhZGp1c3RHT2Zmc2V0IGlzIHR5cGljYWxseSB1c2VkIG9ubHkgd2hlbiBncmFiYmluZyBhbiBlbGVtZW50J3MgUEFSRU5UJ3MgZ2xvYmFsIG1hdHJpeCwgYW5kIGl0IGlnbm9yZXMgdGhlIHgveSBvZmZzZXQgb2YgYW55IFNWRyA8Zz4gZWxlbWVudHMgYmVjYXVzZSB0aGV5IGJlaGF2ZSBpbiBhIHNwZWNpYWwgd2F5LlxuICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQucGFyZW50Tm9kZSB8fCAoX2RvYyB8fCBfc2V0RG9jKGVsZW1lbnQpKS5kb2N1bWVudEVsZW1lbnQgPT09IGVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDJEKCk7XG4gIH1cblxuICB2YXIgemVyb1NjYWxlcyA9IF9mb3JjZU5vblplcm9TY2FsZShlbGVtZW50KSxcbiAgICAgIHN2ZyA9IF9zdmdPd25lcihlbGVtZW50KSxcbiAgICAgIHRlbXBzID0gc3ZnID8gX3N2Z1RlbXBzIDogX2RpdlRlbXBzLFxuICAgICAgY29udGFpbmVyID0gX3BsYWNlU2libGluZ3MoZWxlbWVudCwgYWRqdXN0R09mZnNldCksXG4gICAgICBiMSA9IHRlbXBzWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgYjIgPSB0ZW1wc1sxXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGIzID0gdGVtcHNbMl0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBwYXJlbnQgPSBjb250YWluZXIucGFyZW50Tm9kZSxcbiAgICAgIGlzRml4ZWQgPSAhaW5jbHVkZVNjcm9sbEluRml4ZWQgJiYgX2lzRml4ZWQoZWxlbWVudCksXG4gICAgICBtID0gbmV3IE1hdHJpeDJEKChiMi5sZWZ0IC0gYjEubGVmdCkgLyAxMDAsIChiMi50b3AgLSBiMS50b3ApIC8gMTAwLCAoYjMubGVmdCAtIGIxLmxlZnQpIC8gMTAwLCAoYjMudG9wIC0gYjEudG9wKSAvIDEwMCwgYjEubGVmdCArIChpc0ZpeGVkID8gMCA6IF9nZXREb2NTY3JvbGxMZWZ0KCkpLCBiMS50b3AgKyAoaXNGaXhlZCA/IDAgOiBfZ2V0RG9jU2Nyb2xsVG9wKCkpKTtcblxuICBwYXJlbnQucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcblxuICBpZiAoemVyb1NjYWxlcykge1xuICAgIGIxID0gemVyb1NjYWxlcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoYjEtLSkge1xuICAgICAgYjIgPSB6ZXJvU2NhbGVzW2IxXTtcbiAgICAgIGIyLnNjYWxlWCA9IGIyLnNjYWxlWSA9IDA7XG4gICAgICBiMi5yZW5kZXJUcmFuc2Zvcm0oMSwgYjIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnZlcnNlID8gbS5pbnZlcnNlKCkgOiBtO1xufVxuZXhwb3J0IHsgX2dldERvY1Njcm9sbFRvcCwgX2dldERvY1Njcm9sbExlZnQsIF9zZXREb2MsIF9pc0ZpeGVkLCBfZ2V0Q1RNIH07IC8vIGV4cG9ydCBmdW5jdGlvbiBnZXRNYXRyaXgoZWxlbWVudCkge1xuLy8gXHRfZG9jIHx8IF9zZXREb2MoZWxlbWVudCk7XG4vLyBcdGxldCBtID0gKF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVtfdHJhbnNmb3JtUHJvcF0gKyBcIlwiKS5zdWJzdHIoNykubWF0Y2goL1stLl0qXFxkK1suZVxcLStdKlxcZCpbZVxcLVxcK10qXFxkKi9nKSxcbi8vIFx0XHRpczJEID0gbSAmJiBtLmxlbmd0aCA9PT0gNjtcbi8vIFx0cmV0dXJuICFtIHx8IG0ubGVuZ3RoIDwgNiA/IG5ldyBNYXRyaXgyRCgpIDogbmV3IE1hdHJpeDJEKCttWzBdLCArbVsxXSwgK21baXMyRCA/IDIgOiA0XSwgK21baXMyRCA/IDMgOiA1XSwgK21baXMyRCA/IDQgOiAxMl0sICttW2lzMkQgPyA1IDogMTNdKTtcbi8vIH0iXSwibmFtZXMiOlsiX2RvYyIsIl93aW4iLCJfZG9jRWxlbWVudCIsIl9ib2R5IiwiX2RpdkNvbnRhaW5lciIsIl9zdmdDb250YWluZXIiLCJfaWRlbnRpdHlNYXRyaXgiLCJfZ0VsIiwiX3RyYW5zZm9ybVByb3AiLCJfdHJhbnNmb3JtT3JpZ2luUHJvcCIsIl9oYXNPZmZzZXRCdWciLCJfc2V0RG9jIiwiZWxlbWVudCIsImRvYyIsIm93bmVyRG9jdW1lbnQiLCJzdHlsZSIsInBhcmVudE5vZGUiLCJ3aW5kb3ciLCJNYXRyaXgyRCIsImRvY3VtZW50RWxlbWVudCIsImJvZHkiLCJjcmVhdGVFbGVtZW50TlMiLCJ0cmFuc2Zvcm0iLCJkMSIsImNyZWF0ZUVsZW1lbnQiLCJkMiIsInJvb3QiLCJmaXJzdEVsZW1lbnRDaGlsZCIsImFwcGVuZENoaWxkIiwic2V0QXR0cmlidXRlIiwib2Zmc2V0UGFyZW50IiwicmVtb3ZlQ2hpbGQiLCJfZm9yY2VOb25aZXJvU2NhbGUiLCJlIiwiYSIsImNhY2hlIiwiX2dzYXAiLCJ1bmNhY2hlIiwiZ2V0Iiwic2NhbGVYIiwic2NhbGVZIiwicmVuZGVyVHJhbnNmb3JtIiwicHVzaCIsIl9zdmdUZW1wcyIsIl9kaXZUZW1wcyIsIl9nZXREb2NTY3JvbGxUb3AiLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsIl9nZXREb2NTY3JvbGxMZWZ0IiwicGFnZVhPZmZzZXQiLCJzY3JvbGxMZWZ0IiwiX3N2Z093bmVyIiwib3duZXJTVkdFbGVtZW50IiwidGFnTmFtZSIsInRvTG93ZXJDYXNlIiwiX2lzRml4ZWQiLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJub2RlVHlwZSIsIl9jcmVhdGVTaWJsaW5nIiwiaSIsInN2ZyIsIm5zIiwiZ2V0QXR0cmlidXRlIiwidHlwZSIsIngiLCJ5IiwiY3NzIiwicmVwbGFjZSIsImNzc1RleHQiLCJfY29uc29saWRhdGUiLCJtIiwiYyIsIm51bWJlck9mSXRlbXMiLCJtdWx0aXBseSIsImdldEl0ZW0iLCJtYXRyaXgiLCJfZ2V0Q1RNIiwiZ2V0Q1RNIiwicmVtb3ZlUHJvcGVydHkiLCJjbG9uZSIsIl9wbGFjZVNpYmxpbmdzIiwiYWRqdXN0R09mZnNldCIsImlzUm9vdFNWRyIsInNpYmxpbmdzIiwicGFyZW50IiwiY29udGFpbmVyIiwiYiIsImNzIiwibGVuZ3RoIiwiZiIsImQiLCJnZXRCQm94IiwiYmFzZVZhbCIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJ0b3AiLCJsZWZ0IiwiX3NldE1hdHJpeCIsIl9wcm90byIsInByb3RvdHlwZSIsImludmVyc2UiLCJkZXRlcm1pbmFudCIsImEyIiwiYjIiLCJjMiIsImUyIiwiZjIiLCJlcXVhbHMiLCJhcHBseSIsInBvaW50IiwiZGVjb3JhdGVlIiwiZ2V0R2xvYmFsTWF0cml4IiwiaW5jbHVkZVNjcm9sbEluRml4ZWQiLCJ6ZXJvU2NhbGVzIiwidGVtcHMiLCJiMSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImIzIiwiaXNGaXhlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/matrix.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/paths.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/paths.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bezierToPoints: function() { return /* binding */ bezierToPoints; },\n/* harmony export */   cacheRawPathMeasurements: function() { return /* binding */ cacheRawPathMeasurements; },\n/* harmony export */   convertToPath: function() { return /* binding */ convertToPath; },\n/* harmony export */   copyRawPath: function() { return /* binding */ copyRawPath; },\n/* harmony export */   flatPointsToSegment: function() { return /* binding */ flatPointsToSegment; },\n/* harmony export */   getClosestData: function() { return /* binding */ getClosestData; },\n/* harmony export */   getPositionOnPath: function() { return /* binding */ getPositionOnPath; },\n/* harmony export */   getRawPath: function() { return /* binding */ getRawPath; },\n/* harmony export */   getRotationAtProgress: function() { return /* binding */ getRotationAtProgress; },\n/* harmony export */   pointsToSegment: function() { return /* binding */ pointsToSegment; },\n/* harmony export */   rawPathToString: function() { return /* binding */ rawPathToString; },\n/* harmony export */   reverseSegment: function() { return /* binding */ reverseSegment; },\n/* harmony export */   simplifyPoints: function() { return /* binding */ simplifyPoints; },\n/* harmony export */   sliceRawPath: function() { return /* binding */ sliceRawPath; },\n/* harmony export */   stringToRawPath: function() { return /* binding */ stringToRawPath; },\n/* harmony export */   subdivideSegment: function() { return /* binding */ subdivideSegment; },\n/* harmony export */   subdivideSegmentNear: function() { return /* binding */ subdivideSegmentNear; },\n/* harmony export */   transformRawPath: function() { return /* binding */ transformRawPath; }\n/* harmony export */ });\n/*!\n * paths 3.12.5\n * https://gsap.com\n *\n * Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var _svgPathExp = /[achlmqstvz]|(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig, _numbersExp = /(?:(-)?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig, _scientific = /[\\+\\-]?\\d*\\.?\\d+e[\\+\\-]?\\d+/ig, _selectorExp = /(^[#\\.][a-z]|[a-y][a-z])/i, _DEG2RAD = Math.PI / 180, _RAD2DEG = 180 / Math.PI, _sin = Math.sin, _cos = Math.cos, _abs = Math.abs, _sqrt = Math.sqrt, _atan2 = Math.atan2, _largeNum = 1e8, _isString = function _isString(value) {\n    return typeof value === \"string\";\n}, _isNumber = function _isNumber(value) {\n    return typeof value === \"number\";\n}, _isUndefined = function _isUndefined(value) {\n    return typeof value === \"undefined\";\n}, _temp = {}, _temp2 = {}, _roundingNum = 1e5, _wrapProgress = function _wrapProgress(progress) {\n    return Math.round((progress + _largeNum) % 1 * _roundingNum) / _roundingNum || (progress < 0 ? 0 : 1);\n}, //if progress lands on 1, the % will make it 0 which is why we || 1, but not if it's negative because it makes more sense for motion to end at 0 in that case.\n_round = function _round(value) {\n    return Math.round(value * _roundingNum) / _roundingNum || 0;\n}, _roundPrecise = function _roundPrecise(value) {\n    return Math.round(value * 1e10) / 1e10 || 0;\n}, _splitSegment = function _splitSegment(rawPath, segIndex, i, t) {\n    var segment = rawPath[segIndex], shift = t === 1 ? 6 : subdivideSegment(segment, i, t);\n    if ((shift || !t) && shift + i + 2 < segment.length) {\n        rawPath.splice(segIndex, 0, segment.slice(0, i + shift + 2));\n        segment.splice(0, i + shift);\n        return 1;\n    }\n}, _getSampleIndex = function _getSampleIndex(samples, length, progress) {\n    // slightly slower way than doing this (when there's no lookup): segment.lookup[progress < 1 ? ~~(length / segment.minLength) : segment.lookup.length - 1] || 0;\n    var l = samples.length, i = ~~(progress * l);\n    if (samples[i] > length) {\n        while(--i && samples[i] > length){}\n        i < 0 && (i = 0);\n    } else {\n        while(samples[++i] < length && i < l){}\n    }\n    return i < l ? i : l - 1;\n}, _reverseRawPath = function _reverseRawPath(rawPath, skipOuter) {\n    var i = rawPath.length;\n    skipOuter || rawPath.reverse();\n    while(i--){\n        rawPath[i].reversed || reverseSegment(rawPath[i]);\n    }\n}, _copyMetaData = function _copyMetaData(source, copy) {\n    copy.totalLength = source.totalLength;\n    if (source.samples) {\n        //segment\n        copy.samples = source.samples.slice(0);\n        copy.lookup = source.lookup.slice(0);\n        copy.minLength = source.minLength;\n        copy.resolution = source.resolution;\n    } else if (source.totalPoints) {\n        //rawPath\n        copy.totalPoints = source.totalPoints;\n    }\n    return copy;\n}, //pushes a new segment into a rawPath, but if its starting values match the ending values of the last segment, it'll merge it into that same segment (to reduce the number of segments)\n_appendOrMerge = function _appendOrMerge(rawPath, segment) {\n    var index = rawPath.length, prevSeg = rawPath[index - 1] || [], l = prevSeg.length;\n    if (index && segment[0] === prevSeg[l - 2] && segment[1] === prevSeg[l - 1]) {\n        segment = prevSeg.concat(segment.slice(2));\n        index--;\n    }\n    rawPath[index] = segment;\n}, _bestDistance;\n/* TERMINOLOGY\n - RawPath - an array of arrays, one for each Segment. A single RawPath could have multiple \"M\" commands, defining Segments (paths aren't always connected).\n - Segment - an array containing a sequence of Cubic Bezier coordinates in alternating x, y, x, y format. Starting anchor, then control point 1, control point 2, and ending anchor, then the next control point 1, control point 2, anchor, etc. Uses less memory than an array with a bunch of {x, y} points.\n - Bezier - a single cubic Bezier with a starting anchor, two control points, and an ending anchor.\n - the variable \"t\" is typically the position along an individual Bezier path (time) and it's NOT linear, meaning it could accelerate/decelerate based on the control points whereas the \"p\" or \"progress\" value is linearly mapped to the whole path, so it shouldn't really accelerate/decelerate based on control points. So a progress of 0.2 would be almost exactly 20% along the path. \"t\" is ONLY in an individual Bezier piece.\n */ //accepts basic selector text, a path instance, a RawPath instance, or a Segment and returns a RawPath (makes it easy to homogenize things). If an element or selector text is passed in, it'll also cache the value so that if it's queried again, it'll just take the path data from there instead of parsing it all over again (as long as the path data itself hasn't changed - it'll check).\nfunction getRawPath(value) {\n    value = _isString(value) && _selectorExp.test(value) ? document.querySelector(value) || value : value;\n    var e = value.getAttribute ? value : 0, rawPath;\n    if (e && (value = value.getAttribute(\"d\"))) {\n        //implements caching\n        if (!e._gsPath) {\n            e._gsPath = {};\n        }\n        rawPath = e._gsPath[value];\n        return rawPath && !rawPath._dirty ? rawPath : e._gsPath[value] = stringToRawPath(value);\n    }\n    return !value ? console.warn(\"Expecting a <path> element or an SVG path data string\") : _isString(value) ? stringToRawPath(value) : _isNumber(value[0]) ? [\n        value\n    ] : value;\n} //copies a RawPath WITHOUT the length meta data (for speed)\nfunction copyRawPath(rawPath) {\n    var a = [], i = 0;\n    for(; i < rawPath.length; i++){\n        a[i] = _copyMetaData(rawPath[i], rawPath[i].slice(0));\n    }\n    return _copyMetaData(rawPath, a);\n}\nfunction reverseSegment(segment) {\n    var i = 0, y;\n    segment.reverse(); //this will invert the order y, x, y, x so we must flip it back.\n    for(; i < segment.length; i += 2){\n        y = segment[i];\n        segment[i] = segment[i + 1];\n        segment[i + 1] = y;\n    }\n    segment.reversed = !segment.reversed;\n}\nvar _createPath = function _createPath(e, ignore) {\n    var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\"), attr = [].slice.call(e.attributes), i = attr.length, name;\n    ignore = \",\" + ignore + \",\";\n    while(--i > -1){\n        name = attr[i].nodeName.toLowerCase(); //in Microsoft Edge, if you don't set the attribute with a lowercase name, it doesn't render correctly! Super weird.\n        if (ignore.indexOf(\",\" + name + \",\") < 0) {\n            path.setAttributeNS(null, name, attr[i].nodeValue);\n        }\n    }\n    return path;\n}, _typeAttrs = {\n    rect: \"rx,ry,x,y,width,height\",\n    circle: \"r,cx,cy\",\n    ellipse: \"rx,ry,cx,cy\",\n    line: \"x1,x2,y1,y2\"\n}, _attrToObj = function _attrToObj(e, attrs) {\n    var props = attrs ? attrs.split(\",\") : [], obj = {}, i = props.length;\n    while(--i > -1){\n        obj[props[i]] = +e.getAttribute(props[i]) || 0;\n    }\n    return obj;\n}; //converts an SVG shape like <circle>, <rect>, <polygon>, <polyline>, <ellipse>, etc. to a <path>, swapping it in and copying the attributes to match.\nfunction convertToPath(element, swap) {\n    var type = element.tagName.toLowerCase(), circ = 0.552284749831, data, x, y, r, ry, path, rcirc, rycirc, points, w, h, x2, x3, x4, x5, x6, y2, y3, y4, y5, y6, attr;\n    if (type === \"path\" || !element.getBBox) {\n        return element;\n    }\n    path = _createPath(element, \"x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points\");\n    attr = _attrToObj(element, _typeAttrs[type]);\n    if (type === \"rect\") {\n        r = attr.rx;\n        ry = attr.ry || r;\n        x = attr.x;\n        y = attr.y;\n        w = attr.width - r * 2;\n        h = attr.height - ry * 2;\n        if (r || ry) {\n            //if there are rounded corners, render cubic beziers\n            x2 = x + r * (1 - circ);\n            x3 = x + r;\n            x4 = x3 + w;\n            x5 = x4 + r * circ;\n            x6 = x4 + r;\n            y2 = y + ry * (1 - circ);\n            y3 = y + ry;\n            y4 = y3 + h;\n            y5 = y4 + ry * circ;\n            y6 = y4 + ry;\n            data = \"M\" + x6 + \",\" + y3 + \" V\" + y4 + \" C\" + [\n                x6,\n                y5,\n                x5,\n                y6,\n                x4,\n                y6,\n                x4 - (x4 - x3) / 3,\n                y6,\n                x3 + (x4 - x3) / 3,\n                y6,\n                x3,\n                y6,\n                x2,\n                y6,\n                x,\n                y5,\n                x,\n                y4,\n                x,\n                y4 - (y4 - y3) / 3,\n                x,\n                y3 + (y4 - y3) / 3,\n                x,\n                y3,\n                x,\n                y2,\n                x2,\n                y,\n                x3,\n                y,\n                x3 + (x4 - x3) / 3,\n                y,\n                x4 - (x4 - x3) / 3,\n                y,\n                x4,\n                y,\n                x5,\n                y,\n                x6,\n                y2,\n                x6,\n                y3\n            ].join(\",\") + \"z\";\n        } else {\n            data = \"M\" + (x + w) + \",\" + y + \" v\" + h + \" h\" + -w + \" v\" + -h + \" h\" + w + \"z\";\n        }\n    } else if (type === \"circle\" || type === \"ellipse\") {\n        if (type === \"circle\") {\n            r = ry = attr.r;\n            rycirc = r * circ;\n        } else {\n            r = attr.rx;\n            ry = attr.ry;\n            rycirc = ry * circ;\n        }\n        x = attr.cx;\n        y = attr.cy;\n        rcirc = r * circ;\n        data = \"M\" + (x + r) + \",\" + y + \" C\" + [\n            x + r,\n            y + rycirc,\n            x + rcirc,\n            y + ry,\n            x,\n            y + ry,\n            x - rcirc,\n            y + ry,\n            x - r,\n            y + rycirc,\n            x - r,\n            y,\n            x - r,\n            y - rycirc,\n            x - rcirc,\n            y - ry,\n            x,\n            y - ry,\n            x + rcirc,\n            y - ry,\n            x + r,\n            y - rycirc,\n            x + r,\n            y\n        ].join(\",\") + \"z\";\n    } else if (type === \"line\") {\n        data = \"M\" + attr.x1 + \",\" + attr.y1 + \" L\" + attr.x2 + \",\" + attr.y2; //previously, we just converted to \"Mx,y Lx,y\" but Safari has bugs that cause that not to render properly when using a stroke-dasharray that's not fully visible! Using a cubic bezier fixes that issue.\n    } else if (type === \"polyline\" || type === \"polygon\") {\n        points = (element.getAttribute(\"points\") + \"\").match(_numbersExp) || [];\n        x = points.shift();\n        y = points.shift();\n        data = \"M\" + x + \",\" + y + \" L\" + points.join(\",\");\n        if (type === \"polygon\") {\n            data += \",\" + x + \",\" + y + \"z\";\n        }\n    }\n    path.setAttribute(\"d\", rawPathToString(path._gsRawPath = stringToRawPath(data)));\n    if (swap && element.parentNode) {\n        element.parentNode.insertBefore(path, element);\n        element.parentNode.removeChild(element);\n    }\n    return path;\n} //returns the rotation (in degrees) at a particular progress on a rawPath (the slope of the tangent)\nfunction getRotationAtProgress(rawPath, progress) {\n    var d = getProgressData(rawPath, progress >= 1 ? 1 - 1e-9 : progress ? progress : 1e-9);\n    return getRotationAtBezierT(d.segment, d.i, d.t);\n}\nfunction getRotationAtBezierT(segment, i, t) {\n    var a = segment[i], b = segment[i + 2], c = segment[i + 4], x;\n    a += (b - a) * t;\n    b += (c - b) * t;\n    a += (b - a) * t;\n    x = b + (c + (segment[i + 6] - c) * t - b) * t - a;\n    a = segment[i + 1];\n    b = segment[i + 3];\n    c = segment[i + 5];\n    a += (b - a) * t;\n    b += (c - b) * t;\n    a += (b - a) * t;\n    return _round(_atan2(b + (c + (segment[i + 7] - c) * t - b) * t - a, x) * _RAD2DEG);\n}\nfunction sliceRawPath(rawPath, start, end) {\n    end = _isUndefined(end) ? 1 : _roundPrecise(end) || 0; // we must round to avoid issues like 4.15 / 8 = 0.8300000000000001 instead of 0.83 or 2.8 / 5 = 0.5599999999999999 instead of 0.56 and if someone is doing a loop like start: 2.8 / 0.5, end: 2.8 / 0.5 + 1.\n    start = _roundPrecise(start) || 0;\n    var loops = Math.max(0, ~~(_abs(end - start) - 1e-8)), path = copyRawPath(rawPath);\n    if (start > end) {\n        start = 1 - start;\n        end = 1 - end;\n        _reverseRawPath(path);\n        path.totalLength = 0;\n    }\n    if (start < 0 || end < 0) {\n        var offset = Math.abs(~~Math.min(start, end)) + 1;\n        start += offset;\n        end += offset;\n    }\n    path.totalLength || cacheRawPathMeasurements(path);\n    var wrap = end > 1, s = getProgressData(path, start, _temp, true), e = getProgressData(path, end, _temp2), eSeg = e.segment, sSeg = s.segment, eSegIndex = e.segIndex, sSegIndex = s.segIndex, ei = e.i, si = s.i, sameSegment = sSegIndex === eSegIndex, sameBezier = ei === si && sameSegment, wrapsBehind, sShift, eShift, i, copy, totalSegments, l, j;\n    if (wrap || loops) {\n        wrapsBehind = eSegIndex < sSegIndex || sameSegment && ei < si || sameBezier && e.t < s.t;\n        if (_splitSegment(path, sSegIndex, si, s.t)) {\n            sSegIndex++;\n            if (!wrapsBehind) {\n                eSegIndex++;\n                if (sameBezier) {\n                    e.t = (e.t - s.t) / (1 - s.t);\n                    ei = 0;\n                } else if (sameSegment) {\n                    ei -= si;\n                }\n            }\n        }\n        if (Math.abs(1 - (end - start)) < 1e-5) {\n            eSegIndex = sSegIndex - 1;\n        } else if (!e.t && eSegIndex) {\n            eSegIndex--;\n        } else if (_splitSegment(path, eSegIndex, ei, e.t) && wrapsBehind) {\n            sSegIndex++;\n        }\n        if (s.t === 1) {\n            sSegIndex = (sSegIndex + 1) % path.length;\n        }\n        copy = [];\n        totalSegments = path.length;\n        l = 1 + totalSegments * loops;\n        j = sSegIndex;\n        l += (totalSegments - sSegIndex + eSegIndex) % totalSegments;\n        for(i = 0; i < l; i++){\n            _appendOrMerge(copy, path[j++ % totalSegments]);\n        }\n        path = copy;\n    } else {\n        eShift = e.t === 1 ? 6 : subdivideSegment(eSeg, ei, e.t);\n        if (start !== end) {\n            sShift = subdivideSegment(sSeg, si, sameBezier ? s.t / e.t : s.t);\n            sameSegment && (eShift += sShift);\n            eSeg.splice(ei + eShift + 2);\n            (sShift || si) && sSeg.splice(0, si + sShift);\n            i = path.length;\n            while(i--){\n                //chop off any extra segments\n                (i < sSegIndex || i > eSegIndex) && path.splice(i, 1);\n            }\n        } else {\n            eSeg.angle = getRotationAtBezierT(eSeg, ei + eShift, 0); //record the value before we chop because it'll be impossible to determine the angle after its length is 0!\n            ei += eShift;\n            s = eSeg[ei];\n            e = eSeg[ei + 1];\n            eSeg.length = eSeg.totalLength = 0;\n            eSeg.totalPoints = path.totalPoints = 8;\n            eSeg.push(s, e, s, e, s, e, s, e);\n        }\n    }\n    path.totalLength = 0;\n    return path;\n} //measures a Segment according to its resolution (so if segment.resolution is 6, for example, it'll take 6 samples equally across each Bezier) and create/populate a \"samples\" Array that has the length up to each of those sample points (always increasing from the start) as well as a \"lookup\" array that's broken up according to the smallest distance between 2 samples. This gives us a very fast way of looking up a progress position rather than looping through all the points/Beziers. You can optionally have it only measure a subset, starting at startIndex and going for a specific number of beziers (remember, there are 3 x/y pairs each, for a total of 6 elements for each Bezier). It will also populate a \"totalLength\" property, but that's not generally super accurate because by default it'll only take 6 samples per Bezier. But for performance reasons, it's perfectly adequate for measuring progress values along the path. If you need a more accurate totalLength, either increase the resolution or use the more advanced bezierToPoints() method which keeps adding points until they don't deviate by more than a certain precision value.\nfunction measureSegment(segment, startIndex, bezierQty) {\n    startIndex = startIndex || 0;\n    if (!segment.samples) {\n        segment.samples = [];\n        segment.lookup = [];\n    }\n    var resolution = ~~segment.resolution || 12, inc = 1 / resolution, endIndex = bezierQty ? startIndex + bezierQty * 6 + 1 : segment.length, x1 = segment[startIndex], y1 = segment[startIndex + 1], samplesIndex = startIndex ? startIndex / 6 * resolution : 0, samples = segment.samples, lookup = segment.lookup, min = (startIndex ? segment.minLength : _largeNum) || _largeNum, prevLength = samples[samplesIndex + bezierQty * resolution - 1], length = startIndex ? samples[samplesIndex - 1] : 0, i, j, x4, x3, x2, xd, xd1, y4, y3, y2, yd, yd1, inv, t, lengthIndex, l, segLength;\n    samples.length = lookup.length = 0;\n    for(j = startIndex + 2; j < endIndex; j += 6){\n        x4 = segment[j + 4] - x1;\n        x3 = segment[j + 2] - x1;\n        x2 = segment[j] - x1;\n        y4 = segment[j + 5] - y1;\n        y3 = segment[j + 3] - y1;\n        y2 = segment[j + 1] - y1;\n        xd = xd1 = yd = yd1 = 0;\n        if (_abs(x4) < .01 && _abs(y4) < .01 && _abs(x2) + _abs(y2) < .01) {\n            //dump points that are sufficiently close (basically right on top of each other, making a bezier super tiny or 0 length)\n            if (segment.length > 8) {\n                segment.splice(j, 6);\n                j -= 6;\n                endIndex -= 6;\n            }\n        } else {\n            for(i = 1; i <= resolution; i++){\n                t = inc * i;\n                inv = 1 - t;\n                xd = xd1 - (xd1 = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t);\n                yd = yd1 - (yd1 = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t);\n                l = _sqrt(yd * yd + xd * xd);\n                if (l < min) {\n                    min = l;\n                }\n                length += l;\n                samples[samplesIndex++] = length;\n            }\n        }\n        x1 += x4;\n        y1 += y4;\n    }\n    if (prevLength) {\n        prevLength -= length;\n        for(; samplesIndex < samples.length; samplesIndex++){\n            samples[samplesIndex] += prevLength;\n        }\n    }\n    if (samples.length && min) {\n        segment.totalLength = segLength = samples[samples.length - 1] || 0;\n        segment.minLength = min;\n        if (segLength / min < 9999) {\n            // if the lookup would require too many values (memory problem), we skip this and instead we use a loop to lookup values directly in the samples Array\n            l = lengthIndex = 0;\n            for(i = 0; i < segLength; i += min){\n                lookup[l++] = samples[lengthIndex] < i ? ++lengthIndex : lengthIndex;\n            }\n        }\n    } else {\n        segment.totalLength = samples[0] = 0;\n    }\n    return startIndex ? length - samples[startIndex / 2 - 1] : length;\n}\nfunction cacheRawPathMeasurements(rawPath, resolution) {\n    var pathLength, points, i;\n    for(i = pathLength = points = 0; i < rawPath.length; i++){\n        rawPath[i].resolution = ~~resolution || 12; //steps per Bezier curve (anchor, 2 control points, to anchor)\n        points += rawPath[i].length;\n        pathLength += measureSegment(rawPath[i]);\n    }\n    rawPath.totalPoints = points;\n    rawPath.totalLength = pathLength;\n    return rawPath;\n} //divide segment[i] at position t (value between 0 and 1, progress along that particular cubic bezier segment that starts at segment[i]). Returns how many elements were spliced into the segment array (either 0 or 6)\nfunction subdivideSegment(segment, i, t) {\n    if (t <= 0 || t >= 1) {\n        return 0;\n    }\n    var ax = segment[i], ay = segment[i + 1], cp1x = segment[i + 2], cp1y = segment[i + 3], cp2x = segment[i + 4], cp2y = segment[i + 5], bx = segment[i + 6], by = segment[i + 7], x1a = ax + (cp1x - ax) * t, x2 = cp1x + (cp2x - cp1x) * t, y1a = ay + (cp1y - ay) * t, y2 = cp1y + (cp2y - cp1y) * t, x1 = x1a + (x2 - x1a) * t, y1 = y1a + (y2 - y1a) * t, x2a = cp2x + (bx - cp2x) * t, y2a = cp2y + (by - cp2y) * t;\n    x2 += (x2a - x2) * t;\n    y2 += (y2a - y2) * t;\n    segment.splice(i + 2, 4, _round(x1a), _round(y1a), _round(x1), _round(y1), _round(x1 + (x2 - x1) * t), _round(y1 + (y2 - y1) * t), _round(x2), _round(y2), _round(x2a), _round(y2a));\n    segment.samples && segment.samples.splice(i / 6 * segment.resolution | 0, 0, 0, 0, 0, 0, 0, 0);\n    return 6;\n} // returns an object {path, segment, segIndex, i, t}\nfunction getProgressData(rawPath, progress, decoratee, pushToNextIfAtEnd) {\n    decoratee = decoratee || {};\n    rawPath.totalLength || cacheRawPathMeasurements(rawPath);\n    if (progress < 0 || progress > 1) {\n        progress = _wrapProgress(progress);\n    }\n    var segIndex = 0, segment = rawPath[0], samples, resolution, length, min, max, i, t;\n    if (!progress) {\n        t = i = segIndex = 0;\n        segment = rawPath[0];\n    } else if (progress === 1) {\n        t = 1;\n        segIndex = rawPath.length - 1;\n        segment = rawPath[segIndex];\n        i = segment.length - 8;\n    } else {\n        if (rawPath.length > 1) {\n            //speed optimization: most of the time, there's only one segment so skip the recursion.\n            length = rawPath.totalLength * progress;\n            max = i = 0;\n            while((max += rawPath[i++].totalLength) < length){\n                segIndex = i;\n            }\n            segment = rawPath[segIndex];\n            min = max - segment.totalLength;\n            progress = (length - min) / (max - min) || 0;\n        }\n        samples = segment.samples;\n        resolution = segment.resolution; //how many samples per cubic bezier chunk\n        length = segment.totalLength * progress;\n        i = segment.lookup.length ? segment.lookup[~~(length / segment.minLength)] || 0 : _getSampleIndex(samples, length, progress);\n        min = i ? samples[i - 1] : 0;\n        max = samples[i];\n        if (max < length) {\n            min = max;\n            max = samples[++i];\n        }\n        t = 1 / resolution * ((length - min) / (max - min) + i % resolution);\n        i = ~~(i / resolution) * 6;\n        if (pushToNextIfAtEnd && t === 1) {\n            if (i + 6 < segment.length) {\n                i += 6;\n                t = 0;\n            } else if (segIndex + 1 < rawPath.length) {\n                i = t = 0;\n                segment = rawPath[++segIndex];\n            }\n        }\n    }\n    decoratee.t = t;\n    decoratee.i = i;\n    decoratee.path = rawPath;\n    decoratee.segment = segment;\n    decoratee.segIndex = segIndex;\n    return decoratee;\n}\nfunction getPositionOnPath(rawPath, progress, includeAngle, point) {\n    var segment = rawPath[0], result = point || {}, samples, resolution, length, min, max, i, t, a, inv;\n    if (progress < 0 || progress > 1) {\n        progress = _wrapProgress(progress);\n    }\n    segment.lookup || cacheRawPathMeasurements(rawPath);\n    if (rawPath.length > 1) {\n        //speed optimization: most of the time, there's only one segment so skip the recursion.\n        length = rawPath.totalLength * progress;\n        max = i = 0;\n        while((max += rawPath[i++].totalLength) < length){\n            segment = rawPath[i];\n        }\n        min = max - segment.totalLength;\n        progress = (length - min) / (max - min) || 0;\n    }\n    samples = segment.samples;\n    resolution = segment.resolution;\n    length = segment.totalLength * progress;\n    i = segment.lookup.length ? segment.lookup[progress < 1 ? ~~(length / segment.minLength) : segment.lookup.length - 1] || 0 : _getSampleIndex(samples, length, progress);\n    min = i ? samples[i - 1] : 0;\n    max = samples[i];\n    if (max < length) {\n        min = max;\n        max = samples[++i];\n    }\n    t = 1 / resolution * ((length - min) / (max - min) + i % resolution) || 0;\n    inv = 1 - t;\n    i = ~~(i / resolution) * 6;\n    a = segment[i];\n    result.x = _round((t * t * (segment[i + 6] - a) + 3 * inv * (t * (segment[i + 4] - a) + inv * (segment[i + 2] - a))) * t + a);\n    result.y = _round((t * t * (segment[i + 7] - (a = segment[i + 1])) + 3 * inv * (t * (segment[i + 5] - a) + inv * (segment[i + 3] - a))) * t + a);\n    if (includeAngle) {\n        result.angle = segment.totalLength ? getRotationAtBezierT(segment, i, t >= 1 ? 1 - 1e-9 : t ? t : 1e-9) : segment.angle || 0;\n    }\n    return result;\n} //applies a matrix transform to RawPath (or a segment in a RawPath) and returns whatever was passed in (it transforms the values in the array(s), not a copy).\nfunction transformRawPath(rawPath, a, b, c, d, tx, ty) {\n    var j = rawPath.length, segment, l, i, x, y;\n    while(--j > -1){\n        segment = rawPath[j];\n        l = segment.length;\n        for(i = 0; i < l; i += 2){\n            x = segment[i];\n            y = segment[i + 1];\n            segment[i] = x * a + y * c + tx;\n            segment[i + 1] = x * b + y * d + ty;\n        }\n    }\n    rawPath._dirty = 1;\n    return rawPath;\n} // translates SVG arc data into a segment (cubic beziers). Angle is in degrees.\nfunction arcToSegment(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {\n    if (lastX === x && lastY === y) {\n        return;\n    }\n    rx = _abs(rx);\n    ry = _abs(ry);\n    var angleRad = angle % 360 * _DEG2RAD, cosAngle = _cos(angleRad), sinAngle = _sin(angleRad), PI = Math.PI, TWOPI = PI * 2, dx2 = (lastX - x) / 2, dy2 = (lastY - y) / 2, x1 = cosAngle * dx2 + sinAngle * dy2, y1 = -sinAngle * dx2 + cosAngle * dy2, x1_sq = x1 * x1, y1_sq = y1 * y1, radiiCheck = x1_sq / (rx * rx) + y1_sq / (ry * ry);\n    if (radiiCheck > 1) {\n        rx = _sqrt(radiiCheck) * rx;\n        ry = _sqrt(radiiCheck) * ry;\n    }\n    var rx_sq = rx * rx, ry_sq = ry * ry, sq = (rx_sq * ry_sq - rx_sq * y1_sq - ry_sq * x1_sq) / (rx_sq * y1_sq + ry_sq * x1_sq);\n    if (sq < 0) {\n        sq = 0;\n    }\n    var coef = (largeArcFlag === sweepFlag ? -1 : 1) * _sqrt(sq), cx1 = coef * (rx * y1 / ry), cy1 = coef * -(ry * x1 / rx), sx2 = (lastX + x) / 2, sy2 = (lastY + y) / 2, cx = sx2 + (cosAngle * cx1 - sinAngle * cy1), cy = sy2 + (sinAngle * cx1 + cosAngle * cy1), ux = (x1 - cx1) / rx, uy = (y1 - cy1) / ry, vx = (-x1 - cx1) / rx, vy = (-y1 - cy1) / ry, temp = ux * ux + uy * uy, angleStart = (uy < 0 ? -1 : 1) * Math.acos(ux / _sqrt(temp)), angleExtent = (ux * vy - uy * vx < 0 ? -1 : 1) * Math.acos((ux * vx + uy * vy) / _sqrt(temp * (vx * vx + vy * vy)));\n    isNaN(angleExtent) && (angleExtent = PI); //rare edge case. Math.cos(-1) is NaN.\n    if (!sweepFlag && angleExtent > 0) {\n        angleExtent -= TWOPI;\n    } else if (sweepFlag && angleExtent < 0) {\n        angleExtent += TWOPI;\n    }\n    angleStart %= TWOPI;\n    angleExtent %= TWOPI;\n    var segments = Math.ceil(_abs(angleExtent) / (TWOPI / 4)), rawPath = [], angleIncrement = angleExtent / segments, controlLength = 4 / 3 * _sin(angleIncrement / 2) / (1 + _cos(angleIncrement / 2)), ma = cosAngle * rx, mb = sinAngle * rx, mc = sinAngle * -ry, md = cosAngle * ry, i;\n    for(i = 0; i < segments; i++){\n        angle = angleStart + i * angleIncrement;\n        x1 = _cos(angle);\n        y1 = _sin(angle);\n        ux = _cos(angle += angleIncrement);\n        uy = _sin(angle);\n        rawPath.push(x1 - controlLength * y1, y1 + controlLength * x1, ux + controlLength * uy, uy - controlLength * ux, ux, uy);\n    } //now transform according to the actual size of the ellipse/arc (the beziers were noramlized, between 0 and 1 on a circle).\n    for(i = 0; i < rawPath.length; i += 2){\n        x1 = rawPath[i];\n        y1 = rawPath[i + 1];\n        rawPath[i] = x1 * ma + y1 * mc + cx;\n        rawPath[i + 1] = x1 * mb + y1 * md + cy;\n    }\n    rawPath[i - 2] = x; //always set the end to exactly where it's supposed to be\n    rawPath[i - 1] = y;\n    return rawPath;\n} //Spits back a RawPath with absolute coordinates. Each segment starts with a \"moveTo\" command (x coordinate, then y) and then 2 control points (x, y, x, y), then anchor. The goal is to minimize memory and maximize speed.\nfunction stringToRawPath(d) {\n    var a = (d + \"\").replace(_scientific, function(m) {\n        var n = +m;\n        return n < 0.0001 && n > -0.0001 ? 0 : n;\n    }).match(_svgPathExp) || [], //some authoring programs spit out very small numbers in scientific notation like \"1e-5\", so make sure we round that down to 0 first.\n    path = [], relativeX = 0, relativeY = 0, twoThirds = 2 / 3, elements = a.length, points = 0, errorMessage = \"ERROR: malformed path: \" + d, i, j, x, y, command, isRelative, segment, startX, startY, difX, difY, beziers, prevCommand, flag1, flag2, line = function line(sx, sy, ex, ey) {\n        difX = (ex - sx) / 3;\n        difY = (ey - sy) / 3;\n        segment.push(sx + difX, sy + difY, ex - difX, ey - difY, ex, ey);\n    };\n    if (!d || !isNaN(a[0]) || isNaN(a[1])) {\n        console.log(errorMessage);\n        return path;\n    }\n    for(i = 0; i < elements; i++){\n        prevCommand = command;\n        if (isNaN(a[i])) {\n            command = a[i].toUpperCase();\n            isRelative = command !== a[i]; //lower case means relative\n        } else {\n            //commands like \"C\" can be strung together without any new command characters between.\n            i--;\n        }\n        x = +a[i + 1];\n        y = +a[i + 2];\n        if (isRelative) {\n            x += relativeX;\n            y += relativeY;\n        }\n        if (!i) {\n            startX = x;\n            startY = y;\n        } // \"M\" (move)\n        if (command === \"M\") {\n            if (segment) {\n                if (segment.length < 8) {\n                    //if the path data was funky and just had a M with no actual drawing anywhere, skip it.\n                    path.length -= 1;\n                } else {\n                    points += segment.length;\n                }\n            }\n            relativeX = startX = x;\n            relativeY = startY = y;\n            segment = [\n                x,\n                y\n            ];\n            path.push(segment);\n            i += 2;\n            command = \"L\"; //an \"M\" with more than 2 values gets interpreted as \"lineTo\" commands (\"L\").\n        // \"C\" (cubic bezier)\n        } else if (command === \"C\") {\n            if (!segment) {\n                segment = [\n                    0,\n                    0\n                ];\n            }\n            if (!isRelative) {\n                relativeX = relativeY = 0;\n            } //note: \"*1\" is just a fast/short way to cast the value as a Number. WAAAY faster in Chrome, slightly slower in Firefox.\n            segment.push(x, y, relativeX + a[i + 3] * 1, relativeY + a[i + 4] * 1, relativeX += a[i + 5] * 1, relativeY += a[i + 6] * 1);\n            i += 6; // \"S\" (continuation of cubic bezier)\n        } else if (command === \"S\") {\n            difX = relativeX;\n            difY = relativeY;\n            if (prevCommand === \"C\" || prevCommand === \"S\") {\n                difX += relativeX - segment[segment.length - 4];\n                difY += relativeY - segment[segment.length - 3];\n            }\n            if (!isRelative) {\n                relativeX = relativeY = 0;\n            }\n            segment.push(difX, difY, x, y, relativeX += a[i + 3] * 1, relativeY += a[i + 4] * 1);\n            i += 4; // \"Q\" (quadratic bezier)\n        } else if (command === \"Q\") {\n            difX = relativeX + (x - relativeX) * twoThirds;\n            difY = relativeY + (y - relativeY) * twoThirds;\n            if (!isRelative) {\n                relativeX = relativeY = 0;\n            }\n            relativeX += a[i + 3] * 1;\n            relativeY += a[i + 4] * 1;\n            segment.push(difX, difY, relativeX + (x - relativeX) * twoThirds, relativeY + (y - relativeY) * twoThirds, relativeX, relativeY);\n            i += 4; // \"T\" (continuation of quadratic bezier)\n        } else if (command === \"T\") {\n            difX = relativeX - segment[segment.length - 4];\n            difY = relativeY - segment[segment.length - 3];\n            segment.push(relativeX + difX, relativeY + difY, x + (relativeX + difX * 1.5 - x) * twoThirds, y + (relativeY + difY * 1.5 - y) * twoThirds, relativeX = x, relativeY = y);\n            i += 2; // \"H\" (horizontal line)\n        } else if (command === \"H\") {\n            line(relativeX, relativeY, relativeX = x, relativeY);\n            i += 1; // \"V\" (vertical line)\n        } else if (command === \"V\") {\n            //adjust values because the first (and only one) isn't x in this case, it's y.\n            line(relativeX, relativeY, relativeX, relativeY = x + (isRelative ? relativeY - relativeX : 0));\n            i += 1; // \"L\" (line) or \"Z\" (close)\n        } else if (command === \"L\" || command === \"Z\") {\n            if (command === \"Z\") {\n                x = startX;\n                y = startY;\n                segment.closed = true;\n            }\n            if (command === \"L\" || _abs(relativeX - x) > 0.5 || _abs(relativeY - y) > 0.5) {\n                line(relativeX, relativeY, x, y);\n                if (command === \"L\") {\n                    i += 2;\n                }\n            }\n            relativeX = x;\n            relativeY = y; // \"A\" (arc)\n        } else if (command === \"A\") {\n            flag1 = a[i + 4];\n            flag2 = a[i + 5];\n            difX = a[i + 6];\n            difY = a[i + 7];\n            j = 7;\n            if (flag1.length > 1) {\n                // for cases when the flags are merged, like \"a8 8 0 018 8\" (the 0 and 1 flags are WITH the x value of 8, but it could also be \"a8 8 0 01-8 8\" so it may include x or not)\n                if (flag1.length < 3) {\n                    difY = difX;\n                    difX = flag2;\n                    j--;\n                } else {\n                    difY = flag2;\n                    difX = flag1.substr(2);\n                    j -= 2;\n                }\n                flag2 = flag1.charAt(1);\n                flag1 = flag1.charAt(0);\n            }\n            beziers = arcToSegment(relativeX, relativeY, +a[i + 1], +a[i + 2], +a[i + 3], +flag1, +flag2, (isRelative ? relativeX : 0) + difX * 1, (isRelative ? relativeY : 0) + difY * 1);\n            i += j;\n            if (beziers) {\n                for(j = 0; j < beziers.length; j++){\n                    segment.push(beziers[j]);\n                }\n            }\n            relativeX = segment[segment.length - 2];\n            relativeY = segment[segment.length - 1];\n        } else {\n            console.log(errorMessage);\n        }\n    }\n    i = segment.length;\n    if (i < 6) {\n        //in case there's odd SVG like a M0,0 command at the very end.\n        path.pop();\n        i = 0;\n    } else if (segment[0] === segment[i - 2] && segment[1] === segment[i - 1]) {\n        segment.closed = true;\n    }\n    path.totalPoints = points + i;\n    return path;\n} //populates the points array in alternating x/y values (like [x, y, x, y...] instead of individual point objects [{x, y}, {x, y}...] to conserve memory and stay in line with how we're handling segment arrays\nfunction bezierToPoints(x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {\n    var x12 = (x1 + x2) / 2, y12 = (y1 + y2) / 2, x23 = (x2 + x3) / 2, y23 = (y2 + y3) / 2, x34 = (x3 + x4) / 2, y34 = (y3 + y4) / 2, x123 = (x12 + x23) / 2, y123 = (y12 + y23) / 2, x234 = (x23 + x34) / 2, y234 = (y23 + y34) / 2, x1234 = (x123 + x234) / 2, y1234 = (y123 + y234) / 2, dx = x4 - x1, dy = y4 - y1, d2 = _abs((x2 - x4) * dy - (y2 - y4) * dx), d3 = _abs((x3 - x4) * dy - (y3 - y4) * dx), length;\n    if (!points) {\n        points = [\n            x1,\n            y1,\n            x4,\n            y4\n        ];\n        index = 2;\n    }\n    points.splice(index || points.length - 2, 0, x1234, y1234);\n    if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {\n        length = points.length;\n        bezierToPoints(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);\n        bezierToPoints(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 2 + (points.length - length));\n    }\n    return points;\n}\n/*\nfunction getAngleBetweenPoints(x0, y0, x1, y1, x2, y2) { //angle between 3 points in radians\n\tvar dx1 = x1 - x0,\n\t\tdy1 = y1 - y0,\n\t\tdx2 = x2 - x1,\n\t\tdy2 = y2 - y1,\n\t\tdx3 = x2 - x0,\n\t\tdy3 = y2 - y0,\n\t\ta = dx1 * dx1 + dy1 * dy1,\n\t\tb = dx2 * dx2 + dy2 * dy2,\n\t\tc = dx3 * dx3 + dy3 * dy3;\n\treturn Math.acos( (a + b - c) / _sqrt(4 * a * b) );\n},\n*/ //pointsToSegment() doesn't handle flat coordinates (where y is always 0) the way we need (the resulting control points are always right on top of the anchors), so this function basically makes the control points go directly up and down, varying in length based on the curviness (more curvy, further control points)\nfunction flatPointsToSegment(points, curviness) {\n    if (curviness === void 0) {\n        curviness = 1;\n    }\n    var x = points[0], y = 0, segment = [\n        x,\n        y\n    ], i = 2;\n    for(; i < points.length; i += 2){\n        segment.push(x, y, points[i], y = (points[i] - x) * curviness / 2, x = points[i], -y);\n    }\n    return segment;\n} //points is an array of x/y points, like [x, y, x, y, x, y]\nfunction pointsToSegment(points, curviness) {\n    //points = simplifyPoints(points, tolerance);\n    _abs(points[0] - points[2]) < 1e-4 && _abs(points[1] - points[3]) < 1e-4 && (points = points.slice(2)); // if the first two points are super close, dump the first one.\n    var l = points.length - 2, x = +points[0], y = +points[1], nextX = +points[2], nextY = +points[3], segment = [\n        x,\n        y,\n        x,\n        y\n    ], dx2 = nextX - x, dy2 = nextY - y, closed = Math.abs(points[l] - x) < 0.001 && Math.abs(points[l + 1] - y) < 0.001, prevX, prevY, i, dx1, dy1, r1, r2, r3, tl, mx1, mx2, mxm, my1, my2, mym;\n    if (closed) {\n        // if the start and end points are basically on top of each other, close the segment by adding the 2nd point to the end, and the 2nd-to-last point to the beginning (we'll remove them at the end, but this allows the curvature to look perfect)\n        points.push(nextX, nextY);\n        nextX = x;\n        nextY = y;\n        x = points[l - 2];\n        y = points[l - 1];\n        points.unshift(x, y);\n        l += 4;\n    }\n    curviness = curviness || curviness === 0 ? +curviness : 1;\n    for(i = 2; i < l; i += 2){\n        prevX = x;\n        prevY = y;\n        x = nextX;\n        y = nextY;\n        nextX = +points[i + 2];\n        nextY = +points[i + 3];\n        if (x === nextX && y === nextY) {\n            continue;\n        }\n        dx1 = dx2;\n        dy1 = dy2;\n        dx2 = nextX - x;\n        dy2 = nextY - y;\n        r1 = _sqrt(dx1 * dx1 + dy1 * dy1); // r1, r2, and r3 correlate x and y (and z in the future). Basically 2D or 3D hypotenuse\n        r2 = _sqrt(dx2 * dx2 + dy2 * dy2);\n        r3 = _sqrt(Math.pow(dx2 / r2 + dx1 / r1, 2) + Math.pow(dy2 / r2 + dy1 / r1, 2));\n        tl = (r1 + r2) * curviness * 0.25 / r3;\n        mx1 = x - (x - prevX) * (r1 ? tl / r1 : 0);\n        mx2 = x + (nextX - x) * (r2 ? tl / r2 : 0);\n        mxm = x - (mx1 + ((mx2 - mx1) * (r1 * 3 / (r1 + r2) + 0.5) / 4 || 0));\n        my1 = y - (y - prevY) * (r1 ? tl / r1 : 0);\n        my2 = y + (nextY - y) * (r2 ? tl / r2 : 0);\n        mym = y - (my1 + ((my2 - my1) * (r1 * 3 / (r1 + r2) + 0.5) / 4 || 0));\n        if (x !== prevX || y !== prevY) {\n            segment.push(_round(mx1 + mxm), _round(my1 + mym), _round(x), _round(y), _round(mx2 + mxm), _round(my2 + mym));\n        }\n    }\n    x !== nextX || y !== nextY || segment.length < 4 ? segment.push(_round(nextX), _round(nextY), _round(nextX), _round(nextY)) : segment.length -= 2;\n    if (segment.length === 2) {\n        // only one point!\n        segment.push(x, y, x, y, x, y);\n    } else if (closed) {\n        segment.splice(0, 6);\n        segment.length = segment.length - 6;\n    }\n    return segment;\n} //returns the squared distance between an x/y coordinate and a segment between x1/y1 and x2/y2\nfunction pointToSegDist(x, y, x1, y1, x2, y2) {\n    var dx = x2 - x1, dy = y2 - y1, t;\n    if (dx || dy) {\n        t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n        if (t > 1) {\n            x1 = x2;\n            y1 = y2;\n        } else if (t > 0) {\n            x1 += dx * t;\n            y1 += dy * t;\n        }\n    }\n    return Math.pow(x - x1, 2) + Math.pow(y - y1, 2);\n}\nfunction simplifyStep(points, first, last, tolerance, simplified) {\n    var maxSqDist = tolerance, firstX = points[first], firstY = points[first + 1], lastX = points[last], lastY = points[last + 1], index, i, d;\n    for(i = first + 2; i < last; i += 2){\n        d = pointToSegDist(points[i], points[i + 1], firstX, firstY, lastX, lastY);\n        if (d > maxSqDist) {\n            index = i;\n            maxSqDist = d;\n        }\n    }\n    if (maxSqDist > tolerance) {\n        index - first > 2 && simplifyStep(points, first, index, tolerance, simplified);\n        simplified.push(points[index], points[index + 1]);\n        last - index > 2 && simplifyStep(points, index, last, tolerance, simplified);\n    }\n} //points is an array of x/y values like [x, y, x, y, x, y]\nfunction simplifyPoints(points, tolerance) {\n    var prevX = parseFloat(points[0]), prevY = parseFloat(points[1]), temp = [\n        prevX,\n        prevY\n    ], l = points.length - 2, i, x, y, dx, dy, result, last;\n    tolerance = Math.pow(tolerance || 1, 2);\n    for(i = 2; i < l; i += 2){\n        x = parseFloat(points[i]);\n        y = parseFloat(points[i + 1]);\n        dx = prevX - x;\n        dy = prevY - y;\n        if (dx * dx + dy * dy > tolerance) {\n            temp.push(x, y);\n            prevX = x;\n            prevY = y;\n        }\n    }\n    temp.push(parseFloat(points[l]), parseFloat(points[l + 1]));\n    last = temp.length - 2;\n    result = [\n        temp[0],\n        temp[1]\n    ];\n    simplifyStep(temp, 0, last, tolerance, result);\n    result.push(temp[last], temp[last + 1]);\n    return result;\n}\nfunction getClosestProgressOnBezier(iterations, px, py, start, end, slices, x0, y0, x1, y1, x2, y2, x3, y3) {\n    var inc = (end - start) / slices, best = 0, t = start, x, y, d, dx, dy, inv;\n    _bestDistance = _largeNum;\n    while(t <= end){\n        inv = 1 - t;\n        x = inv * inv * inv * x0 + 3 * inv * inv * t * x1 + 3 * inv * t * t * x2 + t * t * t * x3;\n        y = inv * inv * inv * y0 + 3 * inv * inv * t * y1 + 3 * inv * t * t * y2 + t * t * t * y3;\n        dx = x - px;\n        dy = y - py;\n        d = dx * dx + dy * dy;\n        if (d < _bestDistance) {\n            _bestDistance = d;\n            best = t;\n        }\n        t += inc;\n    }\n    return iterations > 1 ? getClosestProgressOnBezier(iterations - 1, px, py, Math.max(best - inc, 0), Math.min(best + inc, 1), slices, x0, y0, x1, y1, x2, y2, x3, y3) : best;\n}\nfunction getClosestData(rawPath, x, y, slices) {\n    //returns an object with the closest j, i, and t (j is the segment index, i is the index of the point in that segment, and t is the time/progress along that bezier)\n    var closest = {\n        j: 0,\n        i: 0,\n        t: 0\n    }, bestDistance = _largeNum, i, j, t, segment;\n    for(j = 0; j < rawPath.length; j++){\n        segment = rawPath[j];\n        for(i = 0; i < segment.length; i += 6){\n            t = getClosestProgressOnBezier(1, x, y, 0, 1, slices || 20, segment[i], segment[i + 1], segment[i + 2], segment[i + 3], segment[i + 4], segment[i + 5], segment[i + 6], segment[i + 7]);\n            if (bestDistance > _bestDistance) {\n                bestDistance = _bestDistance;\n                closest.j = j;\n                closest.i = i;\n                closest.t = t;\n            }\n        }\n    }\n    return closest;\n} //subdivide a Segment closest to a specific x,y coordinate\nfunction subdivideSegmentNear(x, y, segment, slices, iterations) {\n    var l = segment.length, bestDistance = _largeNum, bestT = 0, bestSegmentIndex = 0, t, i;\n    slices = slices || 20;\n    iterations = iterations || 3;\n    for(i = 0; i < l; i += 6){\n        t = getClosestProgressOnBezier(1, x, y, 0, 1, slices, segment[i], segment[i + 1], segment[i + 2], segment[i + 3], segment[i + 4], segment[i + 5], segment[i + 6], segment[i + 7]);\n        if (bestDistance > _bestDistance) {\n            bestDistance = _bestDistance;\n            bestT = t;\n            bestSegmentIndex = i;\n        }\n    }\n    t = getClosestProgressOnBezier(iterations, x, y, bestT - 0.05, bestT + 0.05, slices, segment[bestSegmentIndex], segment[bestSegmentIndex + 1], segment[bestSegmentIndex + 2], segment[bestSegmentIndex + 3], segment[bestSegmentIndex + 4], segment[bestSegmentIndex + 5], segment[bestSegmentIndex + 6], segment[bestSegmentIndex + 7]);\n    subdivideSegment(segment, bestSegmentIndex, t);\n    return bestSegmentIndex + 6;\n}\n/*\nTakes any of the following and converts it to an all Cubic Bezier SVG data string:\n- A <path> data string like \"M0,0 L2,4 v20,15 H100\"\n- A RawPath, like [[x, y, x, y, x, y, x, y][[x, y, x, y, x, y, x, y]]\n- A Segment, like [x, y, x, y, x, y, x, y]\n\nNote: all numbers are rounded down to the closest 0.001 to minimize memory, maximize speed, and avoid odd numbers like 1e-13\n*/ function rawPathToString(rawPath) {\n    if (_isNumber(rawPath[0])) {\n        //in case a segment is passed in instead\n        rawPath = [\n            rawPath\n        ];\n    }\n    var result = \"\", l = rawPath.length, sl, s, i, segment;\n    for(s = 0; s < l; s++){\n        segment = rawPath[s];\n        result += \"M\" + _round(segment[0]) + \",\" + _round(segment[1]) + \" C\";\n        sl = segment.length;\n        for(i = 2; i < sl; i++){\n            result += _round(segment[i++]) + \",\" + _round(segment[i++]) + \" \" + _round(segment[i++]) + \",\" + _round(segment[i++]) + \" \" + _round(segment[i++]) + \",\" + _round(segment[i]) + \" \";\n        }\n        if (segment.closed) {\n            result += \"z\";\n        }\n    }\n    return result;\n} /*\n// takes a segment with coordinates [x, y, x, y, ...] and converts the control points into angles and lengths [x, y, angle, length, angle, length, x, y, angle, length, ...] so that it animates more cleanly and avoids odd breaks/kinks. For example, if you animate from 1 o'clock to 6 o'clock, it'd just go directly/linearly rather than around. So the length would be very short in the middle of the tween.\nexport function cpCoordsToAngles(segment, copy) {\n\tvar result = copy ? segment.slice(0) : segment,\n\t\tx, y, i;\n\tfor (i = 0; i < segment.length; i+=6) {\n\t\tx = segment[i+2] - segment[i];\n\t\ty = segment[i+3] - segment[i+1];\n\t\tresult[i+2] = Math.atan2(y, x);\n\t\tresult[i+3] = Math.sqrt(x * x + y * y);\n\t\tx = segment[i+6] - segment[i+4];\n\t\ty = segment[i+7] - segment[i+5];\n\t\tresult[i+4] = Math.atan2(y, x);\n\t\tresult[i+5] = Math.sqrt(x * x + y * y);\n\t}\n\treturn result;\n}\n\n// takes a segment that was converted with cpCoordsToAngles() to have angles and lengths instead of coordinates for the control points, and converts it BACK into coordinates.\nexport function cpAnglesToCoords(segment, copy) {\n\tvar result = copy ? segment.slice(0) : segment,\n\t\tlength = segment.length,\n\t\trnd = 1000,\n\t\tangle, l, i, j;\n\tfor (i = 0; i < length; i+=6) {\n\t\tangle = segment[i+2];\n\t\tl = segment[i+3]; //length\n\t\tresult[i+2] = (((segment[i] + Math.cos(angle) * l) * rnd) | 0) / rnd;\n\t\tresult[i+3] = (((segment[i+1] + Math.sin(angle) * l) * rnd) | 0) / rnd;\n\t\tangle = segment[i+4];\n\t\tl = segment[i+5]; //length\n\t\tresult[i+4] = (((segment[i+6] - Math.cos(angle) * l) * rnd) | 0) / rnd;\n\t\tresult[i+5] = (((segment[i+7] - Math.sin(angle) * l) * rnd) | 0) / rnd;\n\t}\n\treturn result;\n}\n\n//adds an \"isSmooth\" array to each segment and populates it with a boolean value indicating whether or not it's smooth (the control points have basically the same slope). For any smooth control points, it converts the coordinates into angle (x, in radians) and length (y) and puts them into the same index value in a smoothData array.\nexport function populateSmoothData(rawPath) {\n\tlet j = rawPath.length,\n\t\tsmooth, segment, x, y, x2, y2, i, l, a, a2, isSmooth, smoothData;\n\twhile (--j > -1) {\n\t\tsegment = rawPath[j];\n\t\tisSmooth = segment.isSmooth = segment.isSmooth || [0, 0, 0, 0];\n\t\tsmoothData = segment.smoothData = segment.smoothData || [0, 0, 0, 0];\n\t\tisSmooth.length = 4;\n\t\tl = segment.length - 2;\n\t\tfor (i = 6; i < l; i += 6) {\n\t\t\tx = segment[i] - segment[i - 2];\n\t\t\ty = segment[i + 1] - segment[i - 1];\n\t\t\tx2 = segment[i + 2] - segment[i];\n\t\t\ty2 = segment[i + 3] - segment[i + 1];\n\t\t\ta = _atan2(y, x);\n\t\t\ta2 = _atan2(y2, x2);\n\t\t\tsmooth = (Math.abs(a - a2) < 0.09);\n\t\t\tif (smooth) {\n\t\t\t\tsmoothData[i - 2] = a;\n\t\t\t\tsmoothData[i + 2] = a2;\n\t\t\t\tsmoothData[i - 1] = _sqrt(x * x + y * y);\n\t\t\t\tsmoothData[i + 3] = _sqrt(x2 * x2 + y2 * y2);\n\t\t\t}\n\t\t\tisSmooth.push(smooth, smooth, 0, 0, smooth, smooth);\n\t\t}\n\t\t//if the first and last points are identical, check to see if there's a smooth transition. We must handle this a bit differently due to their positions in the array.\n\t\tif (segment[l] === segment[0] && segment[l+1] === segment[1]) {\n\t\t\tx = segment[0] - segment[l-2];\n\t\t\ty = segment[1] - segment[l-1];\n\t\t\tx2 = segment[2] - segment[0];\n\t\t\ty2 = segment[3] - segment[1];\n\t\t\ta = _atan2(y, x);\n\t\t\ta2 = _atan2(y2, x2);\n\t\t\tif (Math.abs(a - a2) < 0.09) {\n\t\t\t\tsmoothData[l-2] = a;\n\t\t\t\tsmoothData[2] = a2;\n\t\t\t\tsmoothData[l-1] = _sqrt(x * x + y * y);\n\t\t\t\tsmoothData[3] = _sqrt(x2 * x2 + y2 * y2);\n\t\t\t\tisSmooth[l-2] = isSmooth[l-1] = true; //don't change indexes 2 and 3 because we'll trigger everything from the END, and this will optimize file size a bit.\n\t\t\t}\n\t\t}\n\t}\n\treturn rawPath;\n}\nexport function pointToScreen(svgElement, point) {\n\tif (arguments.length < 2) { //by default, take the first set of coordinates in the path as the point\n\t\tlet rawPath = getRawPath(svgElement);\n\t\tpoint = svgElement.ownerSVGElement.createSVGPoint();\n\t\tpoint.x = rawPath[0][0];\n\t\tpoint.y = rawPath[0][1];\n\t}\n\treturn point.matrixTransform(svgElement.getScreenCTM());\n}\n\n*/ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC91dGlscy9wYXRocy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFRQSxHQUVBLGtCQUFrQixHQUNsQixJQUFJQSxjQUFjLG9EQUNkQyxjQUFjLDJDQUNkQyxjQUFjLGlDQUNkQyxlQUFlLDZCQUNmQyxXQUFXQyxLQUFLQyxFQUFFLEdBQUcsS0FDckJDLFdBQVcsTUFBTUYsS0FBS0MsRUFBRSxFQUN4QkUsT0FBT0gsS0FBS0ksR0FBRyxFQUNmQyxPQUFPTCxLQUFLTSxHQUFHLEVBQ2ZDLE9BQU9QLEtBQUtRLEdBQUcsRUFDZkMsUUFBUVQsS0FBS1UsSUFBSSxFQUNqQkMsU0FBU1gsS0FBS1ksS0FBSyxFQUNuQkMsWUFBWSxLQUNaQyxZQUFZLFNBQVNBLFVBQVVDLEtBQUs7SUFDdEMsT0FBTyxPQUFPQSxVQUFVO0FBQzFCLEdBQ0lDLFlBQVksU0FBU0EsVUFBVUQsS0FBSztJQUN0QyxPQUFPLE9BQU9BLFVBQVU7QUFDMUIsR0FDSUUsZUFBZSxTQUFTQSxhQUFhRixLQUFLO0lBQzVDLE9BQU8sT0FBT0EsVUFBVTtBQUMxQixHQUNJRyxRQUFRLENBQUMsR0FDVEMsU0FBUyxDQUFDLEdBQ1ZDLGVBQWUsS0FDZkMsZ0JBQWdCLFNBQVNBLGNBQWNDLFFBQVE7SUFDakQsT0FBT3RCLEtBQUt1QixLQUFLLENBQUMsQ0FBQ0QsV0FBV1QsU0FBUSxJQUFLLElBQUlPLGdCQUFnQkEsZ0JBQWlCRSxDQUFBQSxXQUFXLElBQUksSUFBSTtBQUNyRyxHQUNJLDhKQUE4SjtBQUNsS0UsU0FBUyxTQUFTQSxPQUFPVCxLQUFLO0lBQzVCLE9BQU9mLEtBQUt1QixLQUFLLENBQUNSLFFBQVFLLGdCQUFnQkEsZ0JBQWdCO0FBQzVELEdBQ0lLLGdCQUFnQixTQUFTQSxjQUFjVixLQUFLO0lBQzlDLE9BQU9mLEtBQUt1QixL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ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC91dGlscy9wYXRocy5qcz83MDllIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogcGF0aHMgMy4xMi41XG4gKiBodHRwczovL2dzYXAuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyNCwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9nc2FwLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHU0FQIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIF9zdmdQYXRoRXhwID0gL1thY2hsbXFzdHZ6XXwoLT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspPylbMC05XS9pZyxcbiAgICBfbnVtYmVyc0V4cCA9IC8oPzooLSk/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT8pWzAtOV0vaWcsXG4gICAgX3NjaWVudGlmaWMgPSAvW1xcK1xcLV0/XFxkKlxcLj9cXGQrZVtcXCtcXC1dP1xcZCsvaWcsXG4gICAgX3NlbGVjdG9yRXhwID0gLyheWyNcXC5dW2Etel18W2EteV1bYS16XSkvaSxcbiAgICBfREVHMlJBRCA9IE1hdGguUEkgLyAxODAsXG4gICAgX1JBRDJERUcgPSAxODAgLyBNYXRoLlBJLFxuICAgIF9zaW4gPSBNYXRoLnNpbixcbiAgICBfY29zID0gTWF0aC5jb3MsXG4gICAgX2FicyA9IE1hdGguYWJzLFxuICAgIF9zcXJ0ID0gTWF0aC5zcXJ0LFxuICAgIF9hdGFuMiA9IE1hdGguYXRhbjIsXG4gICAgX2xhcmdlTnVtID0gMWU4LFxuICAgIF9pc1N0cmluZyA9IGZ1bmN0aW9uIF9pc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufSxcbiAgICBfaXNOdW1iZXIgPSBmdW5jdGlvbiBfaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn0sXG4gICAgX2lzVW5kZWZpbmVkID0gZnVuY3Rpb24gX2lzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF90ZW1wID0ge30sXG4gICAgX3RlbXAyID0ge30sXG4gICAgX3JvdW5kaW5nTnVtID0gMWU1LFxuICAgIF93cmFwUHJvZ3Jlc3MgPSBmdW5jdGlvbiBfd3JhcFByb2dyZXNzKHByb2dyZXNzKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKChwcm9ncmVzcyArIF9sYXJnZU51bSkgJSAxICogX3JvdW5kaW5nTnVtKSAvIF9yb3VuZGluZ051bSB8fCAocHJvZ3Jlc3MgPCAwID8gMCA6IDEpO1xufSxcbiAgICAvL2lmIHByb2dyZXNzIGxhbmRzIG9uIDEsIHRoZSAlIHdpbGwgbWFrZSBpdCAwIHdoaWNoIGlzIHdoeSB3ZSB8fCAxLCBidXQgbm90IGlmIGl0J3MgbmVnYXRpdmUgYmVjYXVzZSBpdCBtYWtlcyBtb3JlIHNlbnNlIGZvciBtb3Rpb24gdG8gZW5kIGF0IDAgaW4gdGhhdCBjYXNlLlxuX3JvdW5kID0gZnVuY3Rpb24gX3JvdW5kKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogX3JvdW5kaW5nTnVtKSAvIF9yb3VuZGluZ051bSB8fCAwO1xufSxcbiAgICBfcm91bmRQcmVjaXNlID0gZnVuY3Rpb24gX3JvdW5kUHJlY2lzZSh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDFlMTApIC8gMWUxMCB8fCAwO1xufSxcbiAgICBfc3BsaXRTZWdtZW50ID0gZnVuY3Rpb24gX3NwbGl0U2VnbWVudChyYXdQYXRoLCBzZWdJbmRleCwgaSwgdCkge1xuICB2YXIgc2VnbWVudCA9IHJhd1BhdGhbc2VnSW5kZXhdLFxuICAgICAgc2hpZnQgPSB0ID09PSAxID8gNiA6IHN1YmRpdmlkZVNlZ21lbnQoc2VnbWVudCwgaSwgdCk7XG5cbiAgaWYgKChzaGlmdCB8fCAhdCkgJiYgc2hpZnQgKyBpICsgMiA8IHNlZ21lbnQubGVuZ3RoKSB7XG4gICAgcmF3UGF0aC5zcGxpY2Uoc2VnSW5kZXgsIDAsIHNlZ21lbnQuc2xpY2UoMCwgaSArIHNoaWZ0ICsgMikpO1xuICAgIHNlZ21lbnQuc3BsaWNlKDAsIGkgKyBzaGlmdCk7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn0sXG4gICAgX2dldFNhbXBsZUluZGV4ID0gZnVuY3Rpb24gX2dldFNhbXBsZUluZGV4KHNhbXBsZXMsIGxlbmd0aCwgcHJvZ3Jlc3MpIHtcbiAgLy8gc2xpZ2h0bHkgc2xvd2VyIHdheSB0aGFuIGRvaW5nIHRoaXMgKHdoZW4gdGhlcmUncyBubyBsb29rdXApOiBzZWdtZW50Lmxvb2t1cFtwcm9ncmVzcyA8IDEgPyB+fihsZW5ndGggLyBzZWdtZW50Lm1pbkxlbmd0aCkgOiBzZWdtZW50Lmxvb2t1cC5sZW5ndGggLSAxXSB8fCAwO1xuICB2YXIgbCA9IHNhbXBsZXMubGVuZ3RoLFxuICAgICAgaSA9IH5+KHByb2dyZXNzICogbCk7XG5cbiAgaWYgKHNhbXBsZXNbaV0gPiBsZW5ndGgpIHtcbiAgICB3aGlsZSAoLS1pICYmIHNhbXBsZXNbaV0gPiBsZW5ndGgpIHt9XG5cbiAgICBpIDwgMCAmJiAoaSA9IDApO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzYW1wbGVzWysraV0gPCBsZW5ndGggJiYgaSA8IGwpIHt9XG4gIH1cblxuICByZXR1cm4gaSA8IGwgPyBpIDogbCAtIDE7XG59LFxuICAgIF9yZXZlcnNlUmF3UGF0aCA9IGZ1bmN0aW9uIF9yZXZlcnNlUmF3UGF0aChyYXdQYXRoLCBza2lwT3V0ZXIpIHtcbiAgdmFyIGkgPSByYXdQYXRoLmxlbmd0aDtcbiAgc2tpcE91dGVyIHx8IHJhd1BhdGgucmV2ZXJzZSgpO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICByYXdQYXRoW2ldLnJldmVyc2VkIHx8IHJldmVyc2VTZWdtZW50KHJhd1BhdGhbaV0pO1xuICB9XG59LFxuICAgIF9jb3B5TWV0YURhdGEgPSBmdW5jdGlvbiBfY29weU1ldGFEYXRhKHNvdXJjZSwgY29weSkge1xuICBjb3B5LnRvdGFsTGVuZ3RoID0gc291cmNlLnRvdGFsTGVuZ3RoO1xuXG4gIGlmIChzb3VyY2Uuc2FtcGxlcykge1xuICAgIC8vc2VnbWVudFxuICAgIGNvcHkuc2FtcGxlcyA9IHNvdXJjZS5zYW1wbGVzLnNsaWNlKDApO1xuICAgIGNvcHkubG9va3VwID0gc291cmNlLmxvb2t1cC5zbGljZSgwKTtcbiAgICBjb3B5Lm1pbkxlbmd0aCA9IHNvdXJjZS5taW5MZW5ndGg7XG4gICAgY29weS5yZXNvbHV0aW9uID0gc291cmNlLnJlc29sdXRpb247XG4gIH0gZWxzZSBpZiAoc291cmNlLnRvdGFsUG9pbnRzKSB7XG4gICAgLy9yYXdQYXRoXG4gICAgY29weS50b3RhbFBvaW50cyA9IHNvdXJjZS50b3RhbFBvaW50cztcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICAvL3B1c2hlcyBhIG5ldyBzZWdtZW50IGludG8gYSByYXdQYXRoLCBidXQgaWYgaXRzIHN0YXJ0aW5nIHZhbHVlcyBtYXRjaCB0aGUgZW5kaW5nIHZhbHVlcyBvZiB0aGUgbGFzdCBzZWdtZW50LCBpdCdsbCBtZXJnZSBpdCBpbnRvIHRoYXQgc2FtZSBzZWdtZW50ICh0byByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWdtZW50cylcbl9hcHBlbmRPck1lcmdlID0gZnVuY3Rpb24gX2FwcGVuZE9yTWVyZ2UocmF3UGF0aCwgc2VnbWVudCkge1xuICB2YXIgaW5kZXggPSByYXdQYXRoLmxlbmd0aCxcbiAgICAgIHByZXZTZWcgPSByYXdQYXRoW2luZGV4IC0gMV0gfHwgW10sXG4gICAgICBsID0gcHJldlNlZy5sZW5ndGg7XG5cbiAgaWYgKGluZGV4ICYmIHNlZ21lbnRbMF0gPT09IHByZXZTZWdbbCAtIDJdICYmIHNlZ21lbnRbMV0gPT09IHByZXZTZWdbbCAtIDFdKSB7XG4gICAgc2VnbWVudCA9IHByZXZTZWcuY29uY2F0KHNlZ21lbnQuc2xpY2UoMikpO1xuICAgIGluZGV4LS07XG4gIH1cblxuICByYXdQYXRoW2luZGV4XSA9IHNlZ21lbnQ7XG59LFxuICAgIF9iZXN0RGlzdGFuY2U7XG4vKiBURVJNSU5PTE9HWVxuIC0gUmF3UGF0aCAtIGFuIGFycmF5IG9mIGFycmF5cywgb25lIGZvciBlYWNoIFNlZ21lbnQuIEEgc2luZ2xlIFJhd1BhdGggY291bGQgaGF2ZSBtdWx0aXBsZSBcIk1cIiBjb21tYW5kcywgZGVmaW5pbmcgU2VnbWVudHMgKHBhdGhzIGFyZW4ndCBhbHdheXMgY29ubmVjdGVkKS5cbiAtIFNlZ21lbnQgLSBhbiBhcnJheSBjb250YWluaW5nIGEgc2VxdWVuY2Ugb2YgQ3ViaWMgQmV6aWVyIGNvb3JkaW5hdGVzIGluIGFsdGVybmF0aW5nIHgsIHksIHgsIHkgZm9ybWF0LiBTdGFydGluZyBhbmNob3IsIHRoZW4gY29udHJvbCBwb2ludCAxLCBjb250cm9sIHBvaW50IDIsIGFuZCBlbmRpbmcgYW5jaG9yLCB0aGVuIHRoZSBuZXh0IGNvbnRyb2wgcG9pbnQgMSwgY29udHJvbCBwb2ludCAyLCBhbmNob3IsIGV0Yy4gVXNlcyBsZXNzIG1lbW9yeSB0aGFuIGFuIGFycmF5IHdpdGggYSBidW5jaCBvZiB7eCwgeX0gcG9pbnRzLlxuIC0gQmV6aWVyIC0gYSBzaW5nbGUgY3ViaWMgQmV6aWVyIHdpdGggYSBzdGFydGluZyBhbmNob3IsIHR3byBjb250cm9sIHBvaW50cywgYW5kIGFuIGVuZGluZyBhbmNob3IuXG4gLSB0aGUgdmFyaWFibGUgXCJ0XCIgaXMgdHlwaWNhbGx5IHRoZSBwb3NpdGlvbiBhbG9uZyBhbiBpbmRpdmlkdWFsIEJlemllciBwYXRoICh0aW1lKSBhbmQgaXQncyBOT1QgbGluZWFyLCBtZWFuaW5nIGl0IGNvdWxkIGFjY2VsZXJhdGUvZGVjZWxlcmF0ZSBiYXNlZCBvbiB0aGUgY29udHJvbCBwb2ludHMgd2hlcmVhcyB0aGUgXCJwXCIgb3IgXCJwcm9ncmVzc1wiIHZhbHVlIGlzIGxpbmVhcmx5IG1hcHBlZCB0byB0aGUgd2hvbGUgcGF0aCwgc28gaXQgc2hvdWxkbid0IHJlYWxseSBhY2NlbGVyYXRlL2RlY2VsZXJhdGUgYmFzZWQgb24gY29udHJvbCBwb2ludHMuIFNvIGEgcHJvZ3Jlc3Mgb2YgMC4yIHdvdWxkIGJlIGFsbW9zdCBleGFjdGx5IDIwJSBhbG9uZyB0aGUgcGF0aC4gXCJ0XCIgaXMgT05MWSBpbiBhbiBpbmRpdmlkdWFsIEJlemllciBwaWVjZS5cbiAqL1xuLy9hY2NlcHRzIGJhc2ljIHNlbGVjdG9yIHRleHQsIGEgcGF0aCBpbnN0YW5jZSwgYSBSYXdQYXRoIGluc3RhbmNlLCBvciBhIFNlZ21lbnQgYW5kIHJldHVybnMgYSBSYXdQYXRoIChtYWtlcyBpdCBlYXN5IHRvIGhvbW9nZW5pemUgdGhpbmdzKS4gSWYgYW4gZWxlbWVudCBvciBzZWxlY3RvciB0ZXh0IGlzIHBhc3NlZCBpbiwgaXQnbGwgYWxzbyBjYWNoZSB0aGUgdmFsdWUgc28gdGhhdCBpZiBpdCdzIHF1ZXJpZWQgYWdhaW4sIGl0J2xsIGp1c3QgdGFrZSB0aGUgcGF0aCBkYXRhIGZyb20gdGhlcmUgaW5zdGVhZCBvZiBwYXJzaW5nIGl0IGFsbCBvdmVyIGFnYWluIChhcyBsb25nIGFzIHRoZSBwYXRoIGRhdGEgaXRzZWxmIGhhc24ndCBjaGFuZ2VkIC0gaXQnbGwgY2hlY2spLlxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYXdQYXRoKHZhbHVlKSB7XG4gIHZhbHVlID0gX2lzU3RyaW5nKHZhbHVlKSAmJiBfc2VsZWN0b3JFeHAudGVzdCh2YWx1ZSkgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHZhbHVlKSB8fCB2YWx1ZSA6IHZhbHVlO1xuICB2YXIgZSA9IHZhbHVlLmdldEF0dHJpYnV0ZSA/IHZhbHVlIDogMCxcbiAgICAgIHJhd1BhdGg7XG5cbiAgaWYgKGUgJiYgKHZhbHVlID0gdmFsdWUuZ2V0QXR0cmlidXRlKFwiZFwiKSkpIHtcbiAgICAvL2ltcGxlbWVudHMgY2FjaGluZ1xuICAgIGlmICghZS5fZ3NQYXRoKSB7XG4gICAgICBlLl9nc1BhdGggPSB7fTtcbiAgICB9XG5cbiAgICByYXdQYXRoID0gZS5fZ3NQYXRoW3ZhbHVlXTtcbiAgICByZXR1cm4gcmF3UGF0aCAmJiAhcmF3UGF0aC5fZGlydHkgPyByYXdQYXRoIDogZS5fZ3NQYXRoW3ZhbHVlXSA9IHN0cmluZ1RvUmF3UGF0aCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gIXZhbHVlID8gY29uc29sZS53YXJuKFwiRXhwZWN0aW5nIGEgPHBhdGg+IGVsZW1lbnQgb3IgYW4gU1ZHIHBhdGggZGF0YSBzdHJpbmdcIikgOiBfaXNTdHJpbmcodmFsdWUpID8gc3RyaW5nVG9SYXdQYXRoKHZhbHVlKSA6IF9pc051bWJlcih2YWx1ZVswXSkgPyBbdmFsdWVdIDogdmFsdWU7XG59IC8vY29waWVzIGEgUmF3UGF0aCBXSVRIT1VUIHRoZSBsZW5ndGggbWV0YSBkYXRhIChmb3Igc3BlZWQpXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5UmF3UGF0aChyYXdQYXRoKSB7XG4gIHZhciBhID0gW10sXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgaSA8IHJhd1BhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBhW2ldID0gX2NvcHlNZXRhRGF0YShyYXdQYXRoW2ldLCByYXdQYXRoW2ldLnNsaWNlKDApKTtcbiAgfVxuXG4gIHJldHVybiBfY29weU1ldGFEYXRhKHJhd1BhdGgsIGEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2VTZWdtZW50KHNlZ21lbnQpIHtcbiAgdmFyIGkgPSAwLFxuICAgICAgeTtcbiAgc2VnbWVudC5yZXZlcnNlKCk7IC8vdGhpcyB3aWxsIGludmVydCB0aGUgb3JkZXIgeSwgeCwgeSwgeCBzbyB3ZSBtdXN0IGZsaXAgaXQgYmFjay5cblxuICBmb3IgKDsgaSA8IHNlZ21lbnQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB5ID0gc2VnbWVudFtpXTtcbiAgICBzZWdtZW50W2ldID0gc2VnbWVudFtpICsgMV07XG4gICAgc2VnbWVudFtpICsgMV0gPSB5O1xuICB9XG5cbiAgc2VnbWVudC5yZXZlcnNlZCA9ICFzZWdtZW50LnJldmVyc2VkO1xufVxuXG52YXIgX2NyZWF0ZVBhdGggPSBmdW5jdGlvbiBfY3JlYXRlUGF0aChlLCBpZ25vcmUpIHtcbiAgdmFyIHBhdGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInBhdGhcIiksXG4gICAgICBhdHRyID0gW10uc2xpY2UuY2FsbChlLmF0dHJpYnV0ZXMpLFxuICAgICAgaSA9IGF0dHIubGVuZ3RoLFxuICAgICAgbmFtZTtcbiAgaWdub3JlID0gXCIsXCIgKyBpZ25vcmUgKyBcIixcIjtcblxuICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICBuYW1lID0gYXR0cltpXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOyAvL2luIE1pY3Jvc29mdCBFZGdlLCBpZiB5b3UgZG9uJ3Qgc2V0IHRoZSBhdHRyaWJ1dGUgd2l0aCBhIGxvd2VyY2FzZSBuYW1lLCBpdCBkb2Vzbid0IHJlbmRlciBjb3JyZWN0bHkhIFN1cGVyIHdlaXJkLlxuXG4gICAgaWYgKGlnbm9yZS5pbmRleE9mKFwiLFwiICsgbmFtZSArIFwiLFwiKSA8IDApIHtcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgbmFtZSwgYXR0cltpXS5ub2RlVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufSxcbiAgICBfdHlwZUF0dHJzID0ge1xuICByZWN0OiBcInJ4LHJ5LHgseSx3aWR0aCxoZWlnaHRcIixcbiAgY2lyY2xlOiBcInIsY3gsY3lcIixcbiAgZWxsaXBzZTogXCJyeCxyeSxjeCxjeVwiLFxuICBsaW5lOiBcIngxLHgyLHkxLHkyXCJcbn0sXG4gICAgX2F0dHJUb09iaiA9IGZ1bmN0aW9uIF9hdHRyVG9PYmooZSwgYXR0cnMpIHtcbiAgdmFyIHByb3BzID0gYXR0cnMgPyBhdHRycy5zcGxpdChcIixcIikgOiBbXSxcbiAgICAgIG9iaiA9IHt9LFxuICAgICAgaSA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICBvYmpbcHJvcHNbaV1dID0gK2UuZ2V0QXR0cmlidXRlKHByb3BzW2ldKSB8fCAwO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07IC8vY29udmVydHMgYW4gU1ZHIHNoYXBlIGxpa2UgPGNpcmNsZT4sIDxyZWN0PiwgPHBvbHlnb24+LCA8cG9seWxpbmU+LCA8ZWxsaXBzZT4sIGV0Yy4gdG8gYSA8cGF0aD4sIHN3YXBwaW5nIGl0IGluIGFuZCBjb3B5aW5nIHRoZSBhdHRyaWJ1dGVzIHRvIG1hdGNoLlxuXG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9QYXRoKGVsZW1lbnQsIHN3YXApIHtcbiAgdmFyIHR5cGUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgIGNpcmMgPSAwLjU1MjI4NDc0OTgzMSxcbiAgICAgIGRhdGEsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHIsXG4gICAgICByeSxcbiAgICAgIHBhdGgsXG4gICAgICByY2lyYyxcbiAgICAgIHJ5Y2lyYyxcbiAgICAgIHBvaW50cyxcbiAgICAgIHcsXG4gICAgICBoLFxuICAgICAgeDIsXG4gICAgICB4MyxcbiAgICAgIHg0LFxuICAgICAgeDUsXG4gICAgICB4NixcbiAgICAgIHkyLFxuICAgICAgeTMsXG4gICAgICB5NCxcbiAgICAgIHk1LFxuICAgICAgeTYsXG4gICAgICBhdHRyO1xuXG4gIGlmICh0eXBlID09PSBcInBhdGhcIiB8fCAhZWxlbWVudC5nZXRCQm94KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBwYXRoID0gX2NyZWF0ZVBhdGgoZWxlbWVudCwgXCJ4LHksd2lkdGgsaGVpZ2h0LGN4LGN5LHJ4LHJ5LHIseDEseDIseTEseTIscG9pbnRzXCIpO1xuICBhdHRyID0gX2F0dHJUb09iaihlbGVtZW50LCBfdHlwZUF0dHJzW3R5cGVdKTtcblxuICBpZiAodHlwZSA9PT0gXCJyZWN0XCIpIHtcbiAgICByID0gYXR0ci5yeDtcbiAgICByeSA9IGF0dHIucnkgfHwgcjtcbiAgICB4ID0gYXR0ci54O1xuICAgIHkgPSBhdHRyLnk7XG4gICAgdyA9IGF0dHIud2lkdGggLSByICogMjtcbiAgICBoID0gYXR0ci5oZWlnaHQgLSByeSAqIDI7XG5cbiAgICBpZiAociB8fCByeSkge1xuICAgICAgLy9pZiB0aGVyZSBhcmUgcm91bmRlZCBjb3JuZXJzLCByZW5kZXIgY3ViaWMgYmV6aWVyc1xuICAgICAgeDIgPSB4ICsgciAqICgxIC0gY2lyYyk7XG4gICAgICB4MyA9IHggKyByO1xuICAgICAgeDQgPSB4MyArIHc7XG4gICAgICB4NSA9IHg0ICsgciAqIGNpcmM7XG4gICAgICB4NiA9IHg0ICsgcjtcbiAgICAgIHkyID0geSArIHJ5ICogKDEgLSBjaXJjKTtcbiAgICAgIHkzID0geSArIHJ5O1xuICAgICAgeTQgPSB5MyArIGg7XG4gICAgICB5NSA9IHk0ICsgcnkgKiBjaXJjO1xuICAgICAgeTYgPSB5NCArIHJ5O1xuICAgICAgZGF0YSA9IFwiTVwiICsgeDYgKyBcIixcIiArIHkzICsgXCIgVlwiICsgeTQgKyBcIiBDXCIgKyBbeDYsIHk1LCB4NSwgeTYsIHg0LCB5NiwgeDQgLSAoeDQgLSB4MykgLyAzLCB5NiwgeDMgKyAoeDQgLSB4MykgLyAzLCB5NiwgeDMsIHk2LCB4MiwgeTYsIHgsIHk1LCB4LCB5NCwgeCwgeTQgLSAoeTQgLSB5MykgLyAzLCB4LCB5MyArICh5NCAtIHkzKSAvIDMsIHgsIHkzLCB4LCB5MiwgeDIsIHksIHgzLCB5LCB4MyArICh4NCAtIHgzKSAvIDMsIHksIHg0IC0gKHg0IC0geDMpIC8gMywgeSwgeDQsIHksIHg1LCB5LCB4NiwgeTIsIHg2LCB5M10uam9pbihcIixcIikgKyBcInpcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IFwiTVwiICsgKHggKyB3KSArIFwiLFwiICsgeSArIFwiIHZcIiArIGggKyBcIiBoXCIgKyAtdyArIFwiIHZcIiArIC1oICsgXCIgaFwiICsgdyArIFwielwiO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSBcImNpcmNsZVwiIHx8IHR5cGUgPT09IFwiZWxsaXBzZVwiKSB7XG4gICAgaWYgKHR5cGUgPT09IFwiY2lyY2xlXCIpIHtcbiAgICAgIHIgPSByeSA9IGF0dHIucjtcbiAgICAgIHJ5Y2lyYyA9IHIgKiBjaXJjO1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gYXR0ci5yeDtcbiAgICAgIHJ5ID0gYXR0ci5yeTtcbiAgICAgIHJ5Y2lyYyA9IHJ5ICogY2lyYztcbiAgICB9XG5cbiAgICB4ID0gYXR0ci5jeDtcbiAgICB5ID0gYXR0ci5jeTtcbiAgICByY2lyYyA9IHIgKiBjaXJjO1xuICAgIGRhdGEgPSBcIk1cIiArICh4ICsgcikgKyBcIixcIiArIHkgKyBcIiBDXCIgKyBbeCArIHIsIHkgKyByeWNpcmMsIHggKyByY2lyYywgeSArIHJ5LCB4LCB5ICsgcnksIHggLSByY2lyYywgeSArIHJ5LCB4IC0gciwgeSArIHJ5Y2lyYywgeCAtIHIsIHksIHggLSByLCB5IC0gcnljaXJjLCB4IC0gcmNpcmMsIHkgLSByeSwgeCwgeSAtIHJ5LCB4ICsgcmNpcmMsIHkgLSByeSwgeCArIHIsIHkgLSByeWNpcmMsIHggKyByLCB5XS5qb2luKFwiLFwiKSArIFwielwiO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibGluZVwiKSB7XG4gICAgZGF0YSA9IFwiTVwiICsgYXR0ci54MSArIFwiLFwiICsgYXR0ci55MSArIFwiIExcIiArIGF0dHIueDIgKyBcIixcIiArIGF0dHIueTI7IC8vcHJldmlvdXNseSwgd2UganVzdCBjb252ZXJ0ZWQgdG8gXCJNeCx5IEx4LHlcIiBidXQgU2FmYXJpIGhhcyBidWdzIHRoYXQgY2F1c2UgdGhhdCBub3QgdG8gcmVuZGVyIHByb3Blcmx5IHdoZW4gdXNpbmcgYSBzdHJva2UtZGFzaGFycmF5IHRoYXQncyBub3QgZnVsbHkgdmlzaWJsZSEgVXNpbmcgYSBjdWJpYyBiZXppZXIgZml4ZXMgdGhhdCBpc3N1ZS5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBcInBvbHlsaW5lXCIgfHwgdHlwZSA9PT0gXCJwb2x5Z29uXCIpIHtcbiAgICBwb2ludHMgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJwb2ludHNcIikgKyBcIlwiKS5tYXRjaChfbnVtYmVyc0V4cCkgfHwgW107XG4gICAgeCA9IHBvaW50cy5zaGlmdCgpO1xuICAgIHkgPSBwb2ludHMuc2hpZnQoKTtcbiAgICBkYXRhID0gXCJNXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIgTFwiICsgcG9pbnRzLmpvaW4oXCIsXCIpO1xuXG4gICAgaWYgKHR5cGUgPT09IFwicG9seWdvblwiKSB7XG4gICAgICBkYXRhICs9IFwiLFwiICsgeCArIFwiLFwiICsgeSArIFwielwiO1xuICAgIH1cbiAgfVxuXG4gIHBhdGguc2V0QXR0cmlidXRlKFwiZFwiLCByYXdQYXRoVG9TdHJpbmcocGF0aC5fZ3NSYXdQYXRoID0gc3RyaW5nVG9SYXdQYXRoKGRhdGEpKSk7XG5cbiAgaWYgKHN3YXAgJiYgZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShwYXRoLCBlbGVtZW50KTtcbiAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gcGF0aDtcbn0gLy9yZXR1cm5zIHRoZSByb3RhdGlvbiAoaW4gZGVncmVlcykgYXQgYSBwYXJ0aWN1bGFyIHByb2dyZXNzIG9uIGEgcmF3UGF0aCAodGhlIHNsb3BlIG9mIHRoZSB0YW5nZW50KVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um90YXRpb25BdFByb2dyZXNzKHJhd1BhdGgsIHByb2dyZXNzKSB7XG4gIHZhciBkID0gZ2V0UHJvZ3Jlc3NEYXRhKHJhd1BhdGgsIHByb2dyZXNzID49IDEgPyAxIC0gMWUtOSA6IHByb2dyZXNzID8gcHJvZ3Jlc3MgOiAxZS05KTtcbiAgcmV0dXJuIGdldFJvdGF0aW9uQXRCZXppZXJUKGQuc2VnbWVudCwgZC5pLCBkLnQpO1xufVxuXG5mdW5jdGlvbiBnZXRSb3RhdGlvbkF0QmV6aWVyVChzZWdtZW50LCBpLCB0KSB7XG4gIHZhciBhID0gc2VnbWVudFtpXSxcbiAgICAgIGIgPSBzZWdtZW50W2kgKyAyXSxcbiAgICAgIGMgPSBzZWdtZW50W2kgKyA0XSxcbiAgICAgIHg7XG4gIGEgKz0gKGIgLSBhKSAqIHQ7XG4gIGIgKz0gKGMgLSBiKSAqIHQ7XG4gIGEgKz0gKGIgLSBhKSAqIHQ7XG4gIHggPSBiICsgKGMgKyAoc2VnbWVudFtpICsgNl0gLSBjKSAqIHQgLSBiKSAqIHQgLSBhO1xuICBhID0gc2VnbWVudFtpICsgMV07XG4gIGIgPSBzZWdtZW50W2kgKyAzXTtcbiAgYyA9IHNlZ21lbnRbaSArIDVdO1xuICBhICs9IChiIC0gYSkgKiB0O1xuICBiICs9IChjIC0gYikgKiB0O1xuICBhICs9IChiIC0gYSkgKiB0O1xuICByZXR1cm4gX3JvdW5kKF9hdGFuMihiICsgKGMgKyAoc2VnbWVudFtpICsgN10gLSBjKSAqIHQgLSBiKSAqIHQgLSBhLCB4KSAqIF9SQUQyREVHKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlUmF3UGF0aChyYXdQYXRoLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IF9pc1VuZGVmaW5lZChlbmQpID8gMSA6IF9yb3VuZFByZWNpc2UoZW5kKSB8fCAwOyAvLyB3ZSBtdXN0IHJvdW5kIHRvIGF2b2lkIGlzc3VlcyBsaWtlIDQuMTUgLyA4ID0gMC44MzAwMDAwMDAwMDAwMDAxIGluc3RlYWQgb2YgMC44MyBvciAyLjggLyA1ID0gMC41NTk5OTk5OTk5OTk5OTk5IGluc3RlYWQgb2YgMC41NiBhbmQgaWYgc29tZW9uZSBpcyBkb2luZyBhIGxvb3AgbGlrZSBzdGFydDogMi44IC8gMC41LCBlbmQ6IDIuOCAvIDAuNSArIDEuXG5cbiAgc3RhcnQgPSBfcm91bmRQcmVjaXNlKHN0YXJ0KSB8fCAwO1xuICB2YXIgbG9vcHMgPSBNYXRoLm1heCgwLCB+fihfYWJzKGVuZCAtIHN0YXJ0KSAtIDFlLTgpKSxcbiAgICAgIHBhdGggPSBjb3B5UmF3UGF0aChyYXdQYXRoKTtcblxuICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICBzdGFydCA9IDEgLSBzdGFydDtcbiAgICBlbmQgPSAxIC0gZW5kO1xuXG4gICAgX3JldmVyc2VSYXdQYXRoKHBhdGgpO1xuXG4gICAgcGF0aC50b3RhbExlbmd0aCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA8IDApIHtcbiAgICB2YXIgb2Zmc2V0ID0gTWF0aC5hYnMofn5NYXRoLm1pbihzdGFydCwgZW5kKSkgKyAxO1xuICAgIHN0YXJ0ICs9IG9mZnNldDtcbiAgICBlbmQgKz0gb2Zmc2V0O1xuICB9XG5cbiAgcGF0aC50b3RhbExlbmd0aCB8fCBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMocGF0aCk7XG4gIHZhciB3cmFwID0gZW5kID4gMSxcbiAgICAgIHMgPSBnZXRQcm9ncmVzc0RhdGEocGF0aCwgc3RhcnQsIF90ZW1wLCB0cnVlKSxcbiAgICAgIGUgPSBnZXRQcm9ncmVzc0RhdGEocGF0aCwgZW5kLCBfdGVtcDIpLFxuICAgICAgZVNlZyA9IGUuc2VnbWVudCxcbiAgICAgIHNTZWcgPSBzLnNlZ21lbnQsXG4gICAgICBlU2VnSW5kZXggPSBlLnNlZ0luZGV4LFxuICAgICAgc1NlZ0luZGV4ID0gcy5zZWdJbmRleCxcbiAgICAgIGVpID0gZS5pLFxuICAgICAgc2kgPSBzLmksXG4gICAgICBzYW1lU2VnbWVudCA9IHNTZWdJbmRleCA9PT0gZVNlZ0luZGV4LFxuICAgICAgc2FtZUJlemllciA9IGVpID09PSBzaSAmJiBzYW1lU2VnbWVudCxcbiAgICAgIHdyYXBzQmVoaW5kLFxuICAgICAgc1NoaWZ0LFxuICAgICAgZVNoaWZ0LFxuICAgICAgaSxcbiAgICAgIGNvcHksXG4gICAgICB0b3RhbFNlZ21lbnRzLFxuICAgICAgbCxcbiAgICAgIGo7XG5cbiAgaWYgKHdyYXAgfHwgbG9vcHMpIHtcbiAgICB3cmFwc0JlaGluZCA9IGVTZWdJbmRleCA8IHNTZWdJbmRleCB8fCBzYW1lU2VnbWVudCAmJiBlaSA8IHNpIHx8IHNhbWVCZXppZXIgJiYgZS50IDwgcy50O1xuXG4gICAgaWYgKF9zcGxpdFNlZ21lbnQocGF0aCwgc1NlZ0luZGV4LCBzaSwgcy50KSkge1xuICAgICAgc1NlZ0luZGV4Kys7XG5cbiAgICAgIGlmICghd3JhcHNCZWhpbmQpIHtcbiAgICAgICAgZVNlZ0luZGV4Kys7XG5cbiAgICAgICAgaWYgKHNhbWVCZXppZXIpIHtcbiAgICAgICAgICBlLnQgPSAoZS50IC0gcy50KSAvICgxIC0gcy50KTtcbiAgICAgICAgICBlaSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc2FtZVNlZ21lbnQpIHtcbiAgICAgICAgICBlaSAtPSBzaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChNYXRoLmFicygxIC0gKGVuZCAtIHN0YXJ0KSkgPCAxZS01KSB7XG4gICAgICBlU2VnSW5kZXggPSBzU2VnSW5kZXggLSAxO1xuICAgIH0gZWxzZSBpZiAoIWUudCAmJiBlU2VnSW5kZXgpIHtcbiAgICAgIGVTZWdJbmRleC0tO1xuICAgIH0gZWxzZSBpZiAoX3NwbGl0U2VnbWVudChwYXRoLCBlU2VnSW5kZXgsIGVpLCBlLnQpICYmIHdyYXBzQmVoaW5kKSB7XG4gICAgICBzU2VnSW5kZXgrKztcbiAgICB9XG5cbiAgICBpZiAocy50ID09PSAxKSB7XG4gICAgICBzU2VnSW5kZXggPSAoc1NlZ0luZGV4ICsgMSkgJSBwYXRoLmxlbmd0aDtcbiAgICB9XG5cbiAgICBjb3B5ID0gW107XG4gICAgdG90YWxTZWdtZW50cyA9IHBhdGgubGVuZ3RoO1xuICAgIGwgPSAxICsgdG90YWxTZWdtZW50cyAqIGxvb3BzO1xuICAgIGogPSBzU2VnSW5kZXg7XG4gICAgbCArPSAodG90YWxTZWdtZW50cyAtIHNTZWdJbmRleCArIGVTZWdJbmRleCkgJSB0b3RhbFNlZ21lbnRzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgX2FwcGVuZE9yTWVyZ2UoY29weSwgcGF0aFtqKysgJSB0b3RhbFNlZ21lbnRzXSk7XG4gICAgfVxuXG4gICAgcGF0aCA9IGNvcHk7XG4gIH0gZWxzZSB7XG4gICAgZVNoaWZ0ID0gZS50ID09PSAxID8gNiA6IHN1YmRpdmlkZVNlZ21lbnQoZVNlZywgZWksIGUudCk7XG5cbiAgICBpZiAoc3RhcnQgIT09IGVuZCkge1xuICAgICAgc1NoaWZ0ID0gc3ViZGl2aWRlU2VnbWVudChzU2VnLCBzaSwgc2FtZUJlemllciA/IHMudCAvIGUudCA6IHMudCk7XG4gICAgICBzYW1lU2VnbWVudCAmJiAoZVNoaWZ0ICs9IHNTaGlmdCk7XG4gICAgICBlU2VnLnNwbGljZShlaSArIGVTaGlmdCArIDIpO1xuICAgICAgKHNTaGlmdCB8fCBzaSkgJiYgc1NlZy5zcGxpY2UoMCwgc2kgKyBzU2hpZnQpO1xuICAgICAgaSA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIC8vY2hvcCBvZmYgYW55IGV4dHJhIHNlZ21lbnRzXG4gICAgICAgIChpIDwgc1NlZ0luZGV4IHx8IGkgPiBlU2VnSW5kZXgpICYmIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlU2VnLmFuZ2xlID0gZ2V0Um90YXRpb25BdEJlemllclQoZVNlZywgZWkgKyBlU2hpZnQsIDApOyAvL3JlY29yZCB0aGUgdmFsdWUgYmVmb3JlIHdlIGNob3AgYmVjYXVzZSBpdCdsbCBiZSBpbXBvc3NpYmxlIHRvIGRldGVybWluZSB0aGUgYW5nbGUgYWZ0ZXIgaXRzIGxlbmd0aCBpcyAwIVxuXG4gICAgICBlaSArPSBlU2hpZnQ7XG4gICAgICBzID0gZVNlZ1tlaV07XG4gICAgICBlID0gZVNlZ1tlaSArIDFdO1xuICAgICAgZVNlZy5sZW5ndGggPSBlU2VnLnRvdGFsTGVuZ3RoID0gMDtcbiAgICAgIGVTZWcudG90YWxQb2ludHMgPSBwYXRoLnRvdGFsUG9pbnRzID0gODtcbiAgICAgIGVTZWcucHVzaChzLCBlLCBzLCBlLCBzLCBlLCBzLCBlKTtcbiAgICB9XG4gIH1cblxuICBwYXRoLnRvdGFsTGVuZ3RoID0gMDtcbiAgcmV0dXJuIHBhdGg7XG59IC8vbWVhc3VyZXMgYSBTZWdtZW50IGFjY29yZGluZyB0byBpdHMgcmVzb2x1dGlvbiAoc28gaWYgc2VnbWVudC5yZXNvbHV0aW9uIGlzIDYsIGZvciBleGFtcGxlLCBpdCdsbCB0YWtlIDYgc2FtcGxlcyBlcXVhbGx5IGFjcm9zcyBlYWNoIEJlemllcikgYW5kIGNyZWF0ZS9wb3B1bGF0ZSBhIFwic2FtcGxlc1wiIEFycmF5IHRoYXQgaGFzIHRoZSBsZW5ndGggdXAgdG8gZWFjaCBvZiB0aG9zZSBzYW1wbGUgcG9pbnRzIChhbHdheXMgaW5jcmVhc2luZyBmcm9tIHRoZSBzdGFydCkgYXMgd2VsbCBhcyBhIFwibG9va3VwXCIgYXJyYXkgdGhhdCdzIGJyb2tlbiB1cCBhY2NvcmRpbmcgdG8gdGhlIHNtYWxsZXN0IGRpc3RhbmNlIGJldHdlZW4gMiBzYW1wbGVzLiBUaGlzIGdpdmVzIHVzIGEgdmVyeSBmYXN0IHdheSBvZiBsb29raW5nIHVwIGEgcHJvZ3Jlc3MgcG9zaXRpb24gcmF0aGVyIHRoYW4gbG9vcGluZyB0aHJvdWdoIGFsbCB0aGUgcG9pbnRzL0JlemllcnMuIFlvdSBjYW4gb3B0aW9uYWxseSBoYXZlIGl0IG9ubHkgbWVhc3VyZSBhIHN1YnNldCwgc3RhcnRpbmcgYXQgc3RhcnRJbmRleCBhbmQgZ29pbmcgZm9yIGEgc3BlY2lmaWMgbnVtYmVyIG9mIGJlemllcnMgKHJlbWVtYmVyLCB0aGVyZSBhcmUgMyB4L3kgcGFpcnMgZWFjaCwgZm9yIGEgdG90YWwgb2YgNiBlbGVtZW50cyBmb3IgZWFjaCBCZXppZXIpLiBJdCB3aWxsIGFsc28gcG9wdWxhdGUgYSBcInRvdGFsTGVuZ3RoXCIgcHJvcGVydHksIGJ1dCB0aGF0J3Mgbm90IGdlbmVyYWxseSBzdXBlciBhY2N1cmF0ZSBiZWNhdXNlIGJ5IGRlZmF1bHQgaXQnbGwgb25seSB0YWtlIDYgc2FtcGxlcyBwZXIgQmV6aWVyLiBCdXQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGl0J3MgcGVyZmVjdGx5IGFkZXF1YXRlIGZvciBtZWFzdXJpbmcgcHJvZ3Jlc3MgdmFsdWVzIGFsb25nIHRoZSBwYXRoLiBJZiB5b3UgbmVlZCBhIG1vcmUgYWNjdXJhdGUgdG90YWxMZW5ndGgsIGVpdGhlciBpbmNyZWFzZSB0aGUgcmVzb2x1dGlvbiBvciB1c2UgdGhlIG1vcmUgYWR2YW5jZWQgYmV6aWVyVG9Qb2ludHMoKSBtZXRob2Qgd2hpY2gga2VlcHMgYWRkaW5nIHBvaW50cyB1bnRpbCB0aGV5IGRvbid0IGRldmlhdGUgYnkgbW9yZSB0aGFuIGEgY2VydGFpbiBwcmVjaXNpb24gdmFsdWUuXG5cbmZ1bmN0aW9uIG1lYXN1cmVTZWdtZW50KHNlZ21lbnQsIHN0YXJ0SW5kZXgsIGJlemllclF0eSkge1xuICBzdGFydEluZGV4ID0gc3RhcnRJbmRleCB8fCAwO1xuXG4gIGlmICghc2VnbWVudC5zYW1wbGVzKSB7XG4gICAgc2VnbWVudC5zYW1wbGVzID0gW107XG4gICAgc2VnbWVudC5sb29rdXAgPSBbXTtcbiAgfVxuXG4gIHZhciByZXNvbHV0aW9uID0gfn5zZWdtZW50LnJlc29sdXRpb24gfHwgMTIsXG4gICAgICBpbmMgPSAxIC8gcmVzb2x1dGlvbixcbiAgICAgIGVuZEluZGV4ID0gYmV6aWVyUXR5ID8gc3RhcnRJbmRleCArIGJlemllclF0eSAqIDYgKyAxIDogc2VnbWVudC5sZW5ndGgsXG4gICAgICB4MSA9IHNlZ21lbnRbc3RhcnRJbmRleF0sXG4gICAgICB5MSA9IHNlZ21lbnRbc3RhcnRJbmRleCArIDFdLFxuICAgICAgc2FtcGxlc0luZGV4ID0gc3RhcnRJbmRleCA/IHN0YXJ0SW5kZXggLyA2ICogcmVzb2x1dGlvbiA6IDAsXG4gICAgICBzYW1wbGVzID0gc2VnbWVudC5zYW1wbGVzLFxuICAgICAgbG9va3VwID0gc2VnbWVudC5sb29rdXAsXG4gICAgICBtaW4gPSAoc3RhcnRJbmRleCA/IHNlZ21lbnQubWluTGVuZ3RoIDogX2xhcmdlTnVtKSB8fCBfbGFyZ2VOdW0sXG4gICAgICBwcmV2TGVuZ3RoID0gc2FtcGxlc1tzYW1wbGVzSW5kZXggKyBiZXppZXJRdHkgKiByZXNvbHV0aW9uIC0gMV0sXG4gICAgICBsZW5ndGggPSBzdGFydEluZGV4ID8gc2FtcGxlc1tzYW1wbGVzSW5kZXggLSAxXSA6IDAsXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIHg0LFxuICAgICAgeDMsXG4gICAgICB4MixcbiAgICAgIHhkLFxuICAgICAgeGQxLFxuICAgICAgeTQsXG4gICAgICB5MyxcbiAgICAgIHkyLFxuICAgICAgeWQsXG4gICAgICB5ZDEsXG4gICAgICBpbnYsXG4gICAgICB0LFxuICAgICAgbGVuZ3RoSW5kZXgsXG4gICAgICBsLFxuICAgICAgc2VnTGVuZ3RoO1xuICBzYW1wbGVzLmxlbmd0aCA9IGxvb2t1cC5sZW5ndGggPSAwO1xuXG4gIGZvciAoaiA9IHN0YXJ0SW5kZXggKyAyOyBqIDwgZW5kSW5kZXg7IGogKz0gNikge1xuICAgIHg0ID0gc2VnbWVudFtqICsgNF0gLSB4MTtcbiAgICB4MyA9IHNlZ21lbnRbaiArIDJdIC0geDE7XG4gICAgeDIgPSBzZWdtZW50W2pdIC0geDE7XG4gICAgeTQgPSBzZWdtZW50W2ogKyA1XSAtIHkxO1xuICAgIHkzID0gc2VnbWVudFtqICsgM10gLSB5MTtcbiAgICB5MiA9IHNlZ21lbnRbaiArIDFdIC0geTE7XG4gICAgeGQgPSB4ZDEgPSB5ZCA9IHlkMSA9IDA7XG5cbiAgICBpZiAoX2Ficyh4NCkgPCAuMDEgJiYgX2Ficyh5NCkgPCAuMDEgJiYgX2Ficyh4MikgKyBfYWJzKHkyKSA8IC4wMSkge1xuICAgICAgLy9kdW1wIHBvaW50cyB0aGF0IGFyZSBzdWZmaWNpZW50bHkgY2xvc2UgKGJhc2ljYWxseSByaWdodCBvbiB0b3Agb2YgZWFjaCBvdGhlciwgbWFraW5nIGEgYmV6aWVyIHN1cGVyIHRpbnkgb3IgMCBsZW5ndGgpXG4gICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiA4KSB7XG4gICAgICAgIHNlZ21lbnQuc3BsaWNlKGosIDYpO1xuICAgICAgICBqIC09IDY7XG4gICAgICAgIGVuZEluZGV4IC09IDY7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDE7IGkgPD0gcmVzb2x1dGlvbjsgaSsrKSB7XG4gICAgICAgIHQgPSBpbmMgKiBpO1xuICAgICAgICBpbnYgPSAxIC0gdDtcbiAgICAgICAgeGQgPSB4ZDEgLSAoeGQxID0gKHQgKiB0ICogeDQgKyAzICogaW52ICogKHQgKiB4MyArIGludiAqIHgyKSkgKiB0KTtcbiAgICAgICAgeWQgPSB5ZDEgLSAoeWQxID0gKHQgKiB0ICogeTQgKyAzICogaW52ICogKHQgKiB5MyArIGludiAqIHkyKSkgKiB0KTtcbiAgICAgICAgbCA9IF9zcXJ0KHlkICogeWQgKyB4ZCAqIHhkKTtcblxuICAgICAgICBpZiAobCA8IG1pbikge1xuICAgICAgICAgIG1pbiA9IGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGggKz0gbDtcbiAgICAgICAgc2FtcGxlc1tzYW1wbGVzSW5kZXgrK10gPSBsZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgeDEgKz0geDQ7XG4gICAgeTEgKz0geTQ7XG4gIH1cblxuICBpZiAocHJldkxlbmd0aCkge1xuICAgIHByZXZMZW5ndGggLT0gbGVuZ3RoO1xuXG4gICAgZm9yICg7IHNhbXBsZXNJbmRleCA8IHNhbXBsZXMubGVuZ3RoOyBzYW1wbGVzSW5kZXgrKykge1xuICAgICAgc2FtcGxlc1tzYW1wbGVzSW5kZXhdICs9IHByZXZMZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNhbXBsZXMubGVuZ3RoICYmIG1pbikge1xuICAgIHNlZ21lbnQudG90YWxMZW5ndGggPSBzZWdMZW5ndGggPSBzYW1wbGVzW3NhbXBsZXMubGVuZ3RoIC0gMV0gfHwgMDtcbiAgICBzZWdtZW50Lm1pbkxlbmd0aCA9IG1pbjtcblxuICAgIGlmIChzZWdMZW5ndGggLyBtaW4gPCA5OTk5KSB7XG4gICAgICAvLyBpZiB0aGUgbG9va3VwIHdvdWxkIHJlcXVpcmUgdG9vIG1hbnkgdmFsdWVzIChtZW1vcnkgcHJvYmxlbSksIHdlIHNraXAgdGhpcyBhbmQgaW5zdGVhZCB3ZSB1c2UgYSBsb29wIHRvIGxvb2t1cCB2YWx1ZXMgZGlyZWN0bHkgaW4gdGhlIHNhbXBsZXMgQXJyYXlcbiAgICAgIGwgPSBsZW5ndGhJbmRleCA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdMZW5ndGg7IGkgKz0gbWluKSB7XG4gICAgICAgIGxvb2t1cFtsKytdID0gc2FtcGxlc1tsZW5ndGhJbmRleF0gPCBpID8gKytsZW5ndGhJbmRleCA6IGxlbmd0aEluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZWdtZW50LnRvdGFsTGVuZ3RoID0gc2FtcGxlc1swXSA9IDA7XG4gIH1cblxuICByZXR1cm4gc3RhcnRJbmRleCA/IGxlbmd0aCAtIHNhbXBsZXNbc3RhcnRJbmRleCAvIDIgLSAxXSA6IGxlbmd0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyhyYXdQYXRoLCByZXNvbHV0aW9uKSB7XG4gIHZhciBwYXRoTGVuZ3RoLCBwb2ludHMsIGk7XG5cbiAgZm9yIChpID0gcGF0aExlbmd0aCA9IHBvaW50cyA9IDA7IGkgPCByYXdQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcmF3UGF0aFtpXS5yZXNvbHV0aW9uID0gfn5yZXNvbHV0aW9uIHx8IDEyOyAvL3N0ZXBzIHBlciBCZXppZXIgY3VydmUgKGFuY2hvciwgMiBjb250cm9sIHBvaW50cywgdG8gYW5jaG9yKVxuXG4gICAgcG9pbnRzICs9IHJhd1BhdGhbaV0ubGVuZ3RoO1xuICAgIHBhdGhMZW5ndGggKz0gbWVhc3VyZVNlZ21lbnQocmF3UGF0aFtpXSk7XG4gIH1cblxuICByYXdQYXRoLnRvdGFsUG9pbnRzID0gcG9pbnRzO1xuICByYXdQYXRoLnRvdGFsTGVuZ3RoID0gcGF0aExlbmd0aDtcbiAgcmV0dXJuIHJhd1BhdGg7XG59IC8vZGl2aWRlIHNlZ21lbnRbaV0gYXQgcG9zaXRpb24gdCAodmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBwcm9ncmVzcyBhbG9uZyB0aGF0IHBhcnRpY3VsYXIgY3ViaWMgYmV6aWVyIHNlZ21lbnQgdGhhdCBzdGFydHMgYXQgc2VnbWVudFtpXSkuIFJldHVybnMgaG93IG1hbnkgZWxlbWVudHMgd2VyZSBzcGxpY2VkIGludG8gdGhlIHNlZ21lbnQgYXJyYXkgKGVpdGhlciAwIG9yIDYpXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJkaXZpZGVTZWdtZW50KHNlZ21lbnQsIGksIHQpIHtcbiAgaWYgKHQgPD0gMCB8fCB0ID49IDEpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBheCA9IHNlZ21lbnRbaV0sXG4gICAgICBheSA9IHNlZ21lbnRbaSArIDFdLFxuICAgICAgY3AxeCA9IHNlZ21lbnRbaSArIDJdLFxuICAgICAgY3AxeSA9IHNlZ21lbnRbaSArIDNdLFxuICAgICAgY3AyeCA9IHNlZ21lbnRbaSArIDRdLFxuICAgICAgY3AyeSA9IHNlZ21lbnRbaSArIDVdLFxuICAgICAgYnggPSBzZWdtZW50W2kgKyA2XSxcbiAgICAgIGJ5ID0gc2VnbWVudFtpICsgN10sXG4gICAgICB4MWEgPSBheCArIChjcDF4IC0gYXgpICogdCxcbiAgICAgIHgyID0gY3AxeCArIChjcDJ4IC0gY3AxeCkgKiB0LFxuICAgICAgeTFhID0gYXkgKyAoY3AxeSAtIGF5KSAqIHQsXG4gICAgICB5MiA9IGNwMXkgKyAoY3AyeSAtIGNwMXkpICogdCxcbiAgICAgIHgxID0geDFhICsgKHgyIC0geDFhKSAqIHQsXG4gICAgICB5MSA9IHkxYSArICh5MiAtIHkxYSkgKiB0LFxuICAgICAgeDJhID0gY3AyeCArIChieCAtIGNwMngpICogdCxcbiAgICAgIHkyYSA9IGNwMnkgKyAoYnkgLSBjcDJ5KSAqIHQ7XG4gIHgyICs9ICh4MmEgLSB4MikgKiB0O1xuICB5MiArPSAoeTJhIC0geTIpICogdDtcbiAgc2VnbWVudC5zcGxpY2UoaSArIDIsIDQsIF9yb3VuZCh4MWEpLCAvL2ZpcnN0IGNvbnRyb2wgcG9pbnRcbiAgX3JvdW5kKHkxYSksIF9yb3VuZCh4MSksIC8vc2Vjb25kIGNvbnRyb2wgcG9pbnRcbiAgX3JvdW5kKHkxKSwgX3JvdW5kKHgxICsgKHgyIC0geDEpICogdCksIC8vbmV3IGZhYnJpY2F0ZWQgYW5jaG9yIG9uIGxpbmVcbiAgX3JvdW5kKHkxICsgKHkyIC0geTEpICogdCksIF9yb3VuZCh4MiksIC8vdGhpcmQgY29udHJvbCBwb2ludFxuICBfcm91bmQoeTIpLCBfcm91bmQoeDJhKSwgLy9mb3VydGggY29udHJvbCBwb2ludFxuICBfcm91bmQoeTJhKSk7XG4gIHNlZ21lbnQuc2FtcGxlcyAmJiBzZWdtZW50LnNhbXBsZXMuc3BsaWNlKGkgLyA2ICogc2VnbWVudC5yZXNvbHV0aW9uIHwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gIHJldHVybiA2O1xufSAvLyByZXR1cm5zIGFuIG9iamVjdCB7cGF0aCwgc2VnbWVudCwgc2VnSW5kZXgsIGksIHR9XG5cbmZ1bmN0aW9uIGdldFByb2dyZXNzRGF0YShyYXdQYXRoLCBwcm9ncmVzcywgZGVjb3JhdGVlLCBwdXNoVG9OZXh0SWZBdEVuZCkge1xuICBkZWNvcmF0ZWUgPSBkZWNvcmF0ZWUgfHwge307XG4gIHJhd1BhdGgudG90YWxMZW5ndGggfHwgY2FjaGVSYXdQYXRoTWVhc3VyZW1lbnRzKHJhd1BhdGgpO1xuXG4gIGlmIChwcm9ncmVzcyA8IDAgfHwgcHJvZ3Jlc3MgPiAxKSB7XG4gICAgcHJvZ3Jlc3MgPSBfd3JhcFByb2dyZXNzKHByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciBzZWdJbmRleCA9IDAsXG4gICAgICBzZWdtZW50ID0gcmF3UGF0aFswXSxcbiAgICAgIHNhbXBsZXMsXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgbGVuZ3RoLFxuICAgICAgbWluLFxuICAgICAgbWF4LFxuICAgICAgaSxcbiAgICAgIHQ7XG5cbiAgaWYgKCFwcm9ncmVzcykge1xuICAgIHQgPSBpID0gc2VnSW5kZXggPSAwO1xuICAgIHNlZ21lbnQgPSByYXdQYXRoWzBdO1xuICB9IGVsc2UgaWYgKHByb2dyZXNzID09PSAxKSB7XG4gICAgdCA9IDE7XG4gICAgc2VnSW5kZXggPSByYXdQYXRoLmxlbmd0aCAtIDE7XG4gICAgc2VnbWVudCA9IHJhd1BhdGhbc2VnSW5kZXhdO1xuICAgIGkgPSBzZWdtZW50Lmxlbmd0aCAtIDg7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHJhd1BhdGgubGVuZ3RoID4gMSkge1xuICAgICAgLy9zcGVlZCBvcHRpbWl6YXRpb246IG1vc3Qgb2YgdGhlIHRpbWUsIHRoZXJlJ3Mgb25seSBvbmUgc2VnbWVudCBzbyBza2lwIHRoZSByZWN1cnNpb24uXG4gICAgICBsZW5ndGggPSByYXdQYXRoLnRvdGFsTGVuZ3RoICogcHJvZ3Jlc3M7XG4gICAgICBtYXggPSBpID0gMDtcblxuICAgICAgd2hpbGUgKChtYXggKz0gcmF3UGF0aFtpKytdLnRvdGFsTGVuZ3RoKSA8IGxlbmd0aCkge1xuICAgICAgICBzZWdJbmRleCA9IGk7XG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQgPSByYXdQYXRoW3NlZ0luZGV4XTtcbiAgICAgIG1pbiA9IG1heCAtIHNlZ21lbnQudG90YWxMZW5ndGg7XG4gICAgICBwcm9ncmVzcyA9IChsZW5ndGggLSBtaW4pIC8gKG1heCAtIG1pbikgfHwgMDtcbiAgICB9XG5cbiAgICBzYW1wbGVzID0gc2VnbWVudC5zYW1wbGVzO1xuICAgIHJlc29sdXRpb24gPSBzZWdtZW50LnJlc29sdXRpb247IC8vaG93IG1hbnkgc2FtcGxlcyBwZXIgY3ViaWMgYmV6aWVyIGNodW5rXG5cbiAgICBsZW5ndGggPSBzZWdtZW50LnRvdGFsTGVuZ3RoICogcHJvZ3Jlc3M7XG4gICAgaSA9IHNlZ21lbnQubG9va3VwLmxlbmd0aCA/IHNlZ21lbnQubG9va3VwW35+KGxlbmd0aCAvIHNlZ21lbnQubWluTGVuZ3RoKV0gfHwgMCA6IF9nZXRTYW1wbGVJbmRleChzYW1wbGVzLCBsZW5ndGgsIHByb2dyZXNzKTtcbiAgICBtaW4gPSBpID8gc2FtcGxlc1tpIC0gMV0gOiAwO1xuICAgIG1heCA9IHNhbXBsZXNbaV07XG5cbiAgICBpZiAobWF4IDwgbGVuZ3RoKSB7XG4gICAgICBtaW4gPSBtYXg7XG4gICAgICBtYXggPSBzYW1wbGVzWysraV07XG4gICAgfVxuXG4gICAgdCA9IDEgLyByZXNvbHV0aW9uICogKChsZW5ndGggLSBtaW4pIC8gKG1heCAtIG1pbikgKyBpICUgcmVzb2x1dGlvbik7XG4gICAgaSA9IH5+KGkgLyByZXNvbHV0aW9uKSAqIDY7XG5cbiAgICBpZiAocHVzaFRvTmV4dElmQXRFbmQgJiYgdCA9PT0gMSkge1xuICAgICAgaWYgKGkgKyA2IDwgc2VnbWVudC5sZW5ndGgpIHtcbiAgICAgICAgaSArPSA2O1xuICAgICAgICB0ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoc2VnSW5kZXggKyAxIDwgcmF3UGF0aC5sZW5ndGgpIHtcbiAgICAgICAgaSA9IHQgPSAwO1xuICAgICAgICBzZWdtZW50ID0gcmF3UGF0aFsrK3NlZ0luZGV4XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWNvcmF0ZWUudCA9IHQ7XG4gIGRlY29yYXRlZS5pID0gaTtcbiAgZGVjb3JhdGVlLnBhdGggPSByYXdQYXRoO1xuICBkZWNvcmF0ZWUuc2VnbWVudCA9IHNlZ21lbnQ7XG4gIGRlY29yYXRlZS5zZWdJbmRleCA9IHNlZ0luZGV4O1xuICByZXR1cm4gZGVjb3JhdGVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9zaXRpb25PblBhdGgocmF3UGF0aCwgcHJvZ3Jlc3MsIGluY2x1ZGVBbmdsZSwgcG9pbnQpIHtcbiAgdmFyIHNlZ21lbnQgPSByYXdQYXRoWzBdLFxuICAgICAgcmVzdWx0ID0gcG9pbnQgfHwge30sXG4gICAgICBzYW1wbGVzLFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIGxlbmd0aCxcbiAgICAgIG1pbixcbiAgICAgIG1heCxcbiAgICAgIGksXG4gICAgICB0LFxuICAgICAgYSxcbiAgICAgIGludjtcblxuICBpZiAocHJvZ3Jlc3MgPCAwIHx8IHByb2dyZXNzID4gMSkge1xuICAgIHByb2dyZXNzID0gX3dyYXBQcm9ncmVzcyhwcm9ncmVzcyk7XG4gIH1cblxuICBzZWdtZW50Lmxvb2t1cCB8fCBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMocmF3UGF0aCk7XG5cbiAgaWYgKHJhd1BhdGgubGVuZ3RoID4gMSkge1xuICAgIC8vc3BlZWQgb3B0aW1pemF0aW9uOiBtb3N0IG9mIHRoZSB0aW1lLCB0aGVyZSdzIG9ubHkgb25lIHNlZ21lbnQgc28gc2tpcCB0aGUgcmVjdXJzaW9uLlxuICAgIGxlbmd0aCA9IHJhd1BhdGgudG90YWxMZW5ndGggKiBwcm9ncmVzcztcbiAgICBtYXggPSBpID0gMDtcblxuICAgIHdoaWxlICgobWF4ICs9IHJhd1BhdGhbaSsrXS50b3RhbExlbmd0aCkgPCBsZW5ndGgpIHtcbiAgICAgIHNlZ21lbnQgPSByYXdQYXRoW2ldO1xuICAgIH1cblxuICAgIG1pbiA9IG1heCAtIHNlZ21lbnQudG90YWxMZW5ndGg7XG4gICAgcHJvZ3Jlc3MgPSAobGVuZ3RoIC0gbWluKSAvIChtYXggLSBtaW4pIHx8IDA7XG4gIH1cblxuICBzYW1wbGVzID0gc2VnbWVudC5zYW1wbGVzO1xuICByZXNvbHV0aW9uID0gc2VnbWVudC5yZXNvbHV0aW9uO1xuICBsZW5ndGggPSBzZWdtZW50LnRvdGFsTGVuZ3RoICogcHJvZ3Jlc3M7XG4gIGkgPSBzZWdtZW50Lmxvb2t1cC5sZW5ndGggPyBzZWdtZW50Lmxvb2t1cFtwcm9ncmVzcyA8IDEgPyB+fihsZW5ndGggLyBzZWdtZW50Lm1pbkxlbmd0aCkgOiBzZWdtZW50Lmxvb2t1cC5sZW5ndGggLSAxXSB8fCAwIDogX2dldFNhbXBsZUluZGV4KHNhbXBsZXMsIGxlbmd0aCwgcHJvZ3Jlc3MpO1xuICBtaW4gPSBpID8gc2FtcGxlc1tpIC0gMV0gOiAwO1xuICBtYXggPSBzYW1wbGVzW2ldO1xuXG4gIGlmIChtYXggPCBsZW5ndGgpIHtcbiAgICBtaW4gPSBtYXg7XG4gICAgbWF4ID0gc2FtcGxlc1srK2ldO1xuICB9XG5cbiAgdCA9IDEgLyByZXNvbHV0aW9uICogKChsZW5ndGggLSBtaW4pIC8gKG1heCAtIG1pbikgKyBpICUgcmVzb2x1dGlvbikgfHwgMDtcbiAgaW52ID0gMSAtIHQ7XG4gIGkgPSB+fihpIC8gcmVzb2x1dGlvbikgKiA2O1xuICBhID0gc2VnbWVudFtpXTtcbiAgcmVzdWx0LnggPSBfcm91bmQoKHQgKiB0ICogKHNlZ21lbnRbaSArIDZdIC0gYSkgKyAzICogaW52ICogKHQgKiAoc2VnbWVudFtpICsgNF0gLSBhKSArIGludiAqIChzZWdtZW50W2kgKyAyXSAtIGEpKSkgKiB0ICsgYSk7XG4gIHJlc3VsdC55ID0gX3JvdW5kKCh0ICogdCAqIChzZWdtZW50W2kgKyA3XSAtIChhID0gc2VnbWVudFtpICsgMV0pKSArIDMgKiBpbnYgKiAodCAqIChzZWdtZW50W2kgKyA1XSAtIGEpICsgaW52ICogKHNlZ21lbnRbaSArIDNdIC0gYSkpKSAqIHQgKyBhKTtcblxuICBpZiAoaW5jbHVkZUFuZ2xlKSB7XG4gICAgcmVzdWx0LmFuZ2xlID0gc2VnbWVudC50b3RhbExlbmd0aCA/IGdldFJvdGF0aW9uQXRCZXppZXJUKHNlZ21lbnQsIGksIHQgPj0gMSA/IDEgLSAxZS05IDogdCA/IHQgOiAxZS05KSA6IHNlZ21lbnQuYW5nbGUgfHwgMDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59IC8vYXBwbGllcyBhIG1hdHJpeCB0cmFuc2Zvcm0gdG8gUmF3UGF0aCAob3IgYSBzZWdtZW50IGluIGEgUmF3UGF0aCkgYW5kIHJldHVybnMgd2hhdGV2ZXIgd2FzIHBhc3NlZCBpbiAoaXQgdHJhbnNmb3JtcyB0aGUgdmFsdWVzIGluIHRoZSBhcnJheShzKSwgbm90IGEgY29weSkuXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1SYXdQYXRoKHJhd1BhdGgsIGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICB2YXIgaiA9IHJhd1BhdGgubGVuZ3RoLFxuICAgICAgc2VnbWVudCxcbiAgICAgIGwsXG4gICAgICBpLFxuICAgICAgeCxcbiAgICAgIHk7XG5cbiAgd2hpbGUgKC0taiA+IC0xKSB7XG4gICAgc2VnbWVudCA9IHJhd1BhdGhbal07XG4gICAgbCA9IHNlZ21lbnQubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgeCA9IHNlZ21lbnRbaV07XG4gICAgICB5ID0gc2VnbWVudFtpICsgMV07XG4gICAgICBzZWdtZW50W2ldID0geCAqIGEgKyB5ICogYyArIHR4O1xuICAgICAgc2VnbWVudFtpICsgMV0gPSB4ICogYiArIHkgKiBkICsgdHk7XG4gICAgfVxuICB9XG5cbiAgcmF3UGF0aC5fZGlydHkgPSAxO1xuICByZXR1cm4gcmF3UGF0aDtcbn0gLy8gdHJhbnNsYXRlcyBTVkcgYXJjIGRhdGEgaW50byBhIHNlZ21lbnQgKGN1YmljIGJlemllcnMpLiBBbmdsZSBpcyBpbiBkZWdyZWVzLlxuXG5mdW5jdGlvbiBhcmNUb1NlZ21lbnQobGFzdFgsIGxhc3RZLCByeCwgcnksIGFuZ2xlLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgeCwgeSkge1xuICBpZiAobGFzdFggPT09IHggJiYgbGFzdFkgPT09IHkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByeCA9IF9hYnMocngpO1xuICByeSA9IF9hYnMocnkpO1xuXG4gIHZhciBhbmdsZVJhZCA9IGFuZ2xlICUgMzYwICogX0RFRzJSQUQsXG4gICAgICBjb3NBbmdsZSA9IF9jb3MoYW5nbGVSYWQpLFxuICAgICAgc2luQW5nbGUgPSBfc2luKGFuZ2xlUmFkKSxcbiAgICAgIFBJID0gTWF0aC5QSSxcbiAgICAgIFRXT1BJID0gUEkgKiAyLFxuICAgICAgZHgyID0gKGxhc3RYIC0geCkgLyAyLFxuICAgICAgZHkyID0gKGxhc3RZIC0geSkgLyAyLFxuICAgICAgeDEgPSBjb3NBbmdsZSAqIGR4MiArIHNpbkFuZ2xlICogZHkyLFxuICAgICAgeTEgPSAtc2luQW5nbGUgKiBkeDIgKyBjb3NBbmdsZSAqIGR5MixcbiAgICAgIHgxX3NxID0geDEgKiB4MSxcbiAgICAgIHkxX3NxID0geTEgKiB5MSxcbiAgICAgIHJhZGlpQ2hlY2sgPSB4MV9zcSAvIChyeCAqIHJ4KSArIHkxX3NxIC8gKHJ5ICogcnkpO1xuXG4gIGlmIChyYWRpaUNoZWNrID4gMSkge1xuICAgIHJ4ID0gX3NxcnQocmFkaWlDaGVjaykgKiByeDtcbiAgICByeSA9IF9zcXJ0KHJhZGlpQ2hlY2spICogcnk7XG4gIH1cblxuICB2YXIgcnhfc3EgPSByeCAqIHJ4LFxuICAgICAgcnlfc3EgPSByeSAqIHJ5LFxuICAgICAgc3EgPSAocnhfc3EgKiByeV9zcSAtIHJ4X3NxICogeTFfc3EgLSByeV9zcSAqIHgxX3NxKSAvIChyeF9zcSAqIHkxX3NxICsgcnlfc3EgKiB4MV9zcSk7XG5cbiAgaWYgKHNxIDwgMCkge1xuICAgIHNxID0gMDtcbiAgfVxuXG4gIHZhciBjb2VmID0gKGxhcmdlQXJjRmxhZyA9PT0gc3dlZXBGbGFnID8gLTEgOiAxKSAqIF9zcXJ0KHNxKSxcbiAgICAgIGN4MSA9IGNvZWYgKiAocnggKiB5MSAvIHJ5KSxcbiAgICAgIGN5MSA9IGNvZWYgKiAtKHJ5ICogeDEgLyByeCksXG4gICAgICBzeDIgPSAobGFzdFggKyB4KSAvIDIsXG4gICAgICBzeTIgPSAobGFzdFkgKyB5KSAvIDIsXG4gICAgICBjeCA9IHN4MiArIChjb3NBbmdsZSAqIGN4MSAtIHNpbkFuZ2xlICogY3kxKSxcbiAgICAgIGN5ID0gc3kyICsgKHNpbkFuZ2xlICogY3gxICsgY29zQW5nbGUgKiBjeTEpLFxuICAgICAgdXggPSAoeDEgLSBjeDEpIC8gcngsXG4gICAgICB1eSA9ICh5MSAtIGN5MSkgLyByeSxcbiAgICAgIHZ4ID0gKC14MSAtIGN4MSkgLyByeCxcbiAgICAgIHZ5ID0gKC15MSAtIGN5MSkgLyByeSxcbiAgICAgIHRlbXAgPSB1eCAqIHV4ICsgdXkgKiB1eSxcbiAgICAgIGFuZ2xlU3RhcnQgPSAodXkgPCAwID8gLTEgOiAxKSAqIE1hdGguYWNvcyh1eCAvIF9zcXJ0KHRlbXApKSxcbiAgICAgIGFuZ2xlRXh0ZW50ID0gKHV4ICogdnkgLSB1eSAqIHZ4IDwgMCA/IC0xIDogMSkgKiBNYXRoLmFjb3MoKHV4ICogdnggKyB1eSAqIHZ5KSAvIF9zcXJ0KHRlbXAgKiAodnggKiB2eCArIHZ5ICogdnkpKSk7XG5cbiAgaXNOYU4oYW5nbGVFeHRlbnQpICYmIChhbmdsZUV4dGVudCA9IFBJKTsgLy9yYXJlIGVkZ2UgY2FzZS4gTWF0aC5jb3MoLTEpIGlzIE5hTi5cblxuICBpZiAoIXN3ZWVwRmxhZyAmJiBhbmdsZUV4dGVudCA+IDApIHtcbiAgICBhbmdsZUV4dGVudCAtPSBUV09QSTtcbiAgfSBlbHNlIGlmIChzd2VlcEZsYWcgJiYgYW5nbGVFeHRlbnQgPCAwKSB7XG4gICAgYW5nbGVFeHRlbnQgKz0gVFdPUEk7XG4gIH1cblxuICBhbmdsZVN0YXJ0ICU9IFRXT1BJO1xuICBhbmdsZUV4dGVudCAlPSBUV09QSTtcblxuICB2YXIgc2VnbWVudHMgPSBNYXRoLmNlaWwoX2FicyhhbmdsZUV4dGVudCkgLyAoVFdPUEkgLyA0KSksXG4gICAgICByYXdQYXRoID0gW10sXG4gICAgICBhbmdsZUluY3JlbWVudCA9IGFuZ2xlRXh0ZW50IC8gc2VnbWVudHMsXG4gICAgICBjb250cm9sTGVuZ3RoID0gNCAvIDMgKiBfc2luKGFuZ2xlSW5jcmVtZW50IC8gMikgLyAoMSArIF9jb3MoYW5nbGVJbmNyZW1lbnQgLyAyKSksXG4gICAgICBtYSA9IGNvc0FuZ2xlICogcngsXG4gICAgICBtYiA9IHNpbkFuZ2xlICogcngsXG4gICAgICBtYyA9IHNpbkFuZ2xlICogLXJ5LFxuICAgICAgbWQgPSBjb3NBbmdsZSAqIHJ5LFxuICAgICAgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc2VnbWVudHM7IGkrKykge1xuICAgIGFuZ2xlID0gYW5nbGVTdGFydCArIGkgKiBhbmdsZUluY3JlbWVudDtcbiAgICB4MSA9IF9jb3MoYW5nbGUpO1xuICAgIHkxID0gX3NpbihhbmdsZSk7XG4gICAgdXggPSBfY29zKGFuZ2xlICs9IGFuZ2xlSW5jcmVtZW50KTtcbiAgICB1eSA9IF9zaW4oYW5nbGUpO1xuICAgIHJhd1BhdGgucHVzaCh4MSAtIGNvbnRyb2xMZW5ndGggKiB5MSwgeTEgKyBjb250cm9sTGVuZ3RoICogeDEsIHV4ICsgY29udHJvbExlbmd0aCAqIHV5LCB1eSAtIGNvbnRyb2xMZW5ndGggKiB1eCwgdXgsIHV5KTtcbiAgfSAvL25vdyB0cmFuc2Zvcm0gYWNjb3JkaW5nIHRvIHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGUgZWxsaXBzZS9hcmMgKHRoZSBiZXppZXJzIHdlcmUgbm9yYW1saXplZCwgYmV0d2VlbiAwIGFuZCAxIG9uIGEgY2lyY2xlKS5cblxuXG4gIGZvciAoaSA9IDA7IGkgPCByYXdQYXRoLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgeDEgPSByYXdQYXRoW2ldO1xuICAgIHkxID0gcmF3UGF0aFtpICsgMV07XG4gICAgcmF3UGF0aFtpXSA9IHgxICogbWEgKyB5MSAqIG1jICsgY3g7XG4gICAgcmF3UGF0aFtpICsgMV0gPSB4MSAqIG1iICsgeTEgKiBtZCArIGN5O1xuICB9XG5cbiAgcmF3UGF0aFtpIC0gMl0gPSB4OyAvL2Fsd2F5cyBzZXQgdGhlIGVuZCB0byBleGFjdGx5IHdoZXJlIGl0J3Mgc3VwcG9zZWQgdG8gYmVcblxuICByYXdQYXRoW2kgLSAxXSA9IHk7XG4gIHJldHVybiByYXdQYXRoO1xufSAvL1NwaXRzIGJhY2sgYSBSYXdQYXRoIHdpdGggYWJzb2x1dGUgY29vcmRpbmF0ZXMuIEVhY2ggc2VnbWVudCBzdGFydHMgd2l0aCBhIFwibW92ZVRvXCIgY29tbWFuZCAoeCBjb29yZGluYXRlLCB0aGVuIHkpIGFuZCB0aGVuIDIgY29udHJvbCBwb2ludHMgKHgsIHksIHgsIHkpLCB0aGVuIGFuY2hvci4gVGhlIGdvYWwgaXMgdG8gbWluaW1pemUgbWVtb3J5IGFuZCBtYXhpbWl6ZSBzcGVlZC5cblxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9SYXdQYXRoKGQpIHtcbiAgdmFyIGEgPSAoZCArIFwiXCIpLnJlcGxhY2UoX3NjaWVudGlmaWMsIGZ1bmN0aW9uIChtKSB7XG4gICAgdmFyIG4gPSArbTtcbiAgICByZXR1cm4gbiA8IDAuMDAwMSAmJiBuID4gLTAuMDAwMSA/IDAgOiBuO1xuICB9KS5tYXRjaChfc3ZnUGF0aEV4cCkgfHwgW10sXG4gICAgICAvL3NvbWUgYXV0aG9yaW5nIHByb2dyYW1zIHNwaXQgb3V0IHZlcnkgc21hbGwgbnVtYmVycyBpbiBzY2llbnRpZmljIG5vdGF0aW9uIGxpa2UgXCIxZS01XCIsIHNvIG1ha2Ugc3VyZSB3ZSByb3VuZCB0aGF0IGRvd24gdG8gMCBmaXJzdC5cbiAgcGF0aCA9IFtdLFxuICAgICAgcmVsYXRpdmVYID0gMCxcbiAgICAgIHJlbGF0aXZlWSA9IDAsXG4gICAgICB0d29UaGlyZHMgPSAyIC8gMyxcbiAgICAgIGVsZW1lbnRzID0gYS5sZW5ndGgsXG4gICAgICBwb2ludHMgPSAwLFxuICAgICAgZXJyb3JNZXNzYWdlID0gXCJFUlJPUjogbWFsZm9ybWVkIHBhdGg6IFwiICsgZCxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBjb21tYW5kLFxuICAgICAgaXNSZWxhdGl2ZSxcbiAgICAgIHNlZ21lbnQsXG4gICAgICBzdGFydFgsXG4gICAgICBzdGFydFksXG4gICAgICBkaWZYLFxuICAgICAgZGlmWSxcbiAgICAgIGJlemllcnMsXG4gICAgICBwcmV2Q29tbWFuZCxcbiAgICAgIGZsYWcxLFxuICAgICAgZmxhZzIsXG4gICAgICBsaW5lID0gZnVuY3Rpb24gbGluZShzeCwgc3ksIGV4LCBleSkge1xuICAgIGRpZlggPSAoZXggLSBzeCkgLyAzO1xuICAgIGRpZlkgPSAoZXkgLSBzeSkgLyAzO1xuICAgIHNlZ21lbnQucHVzaChzeCArIGRpZlgsIHN5ICsgZGlmWSwgZXggLSBkaWZYLCBleSAtIGRpZlksIGV4LCBleSk7XG4gIH07XG5cbiAgaWYgKCFkIHx8ICFpc05hTihhWzBdKSB8fCBpc05hTihhWzFdKSkge1xuICAgIGNvbnNvbGUubG9nKGVycm9yTWVzc2FnZSk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHM7IGkrKykge1xuICAgIHByZXZDb21tYW5kID0gY29tbWFuZDtcblxuICAgIGlmIChpc05hTihhW2ldKSkge1xuICAgICAgY29tbWFuZCA9IGFbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgIGlzUmVsYXRpdmUgPSBjb21tYW5kICE9PSBhW2ldOyAvL2xvd2VyIGNhc2UgbWVhbnMgcmVsYXRpdmVcbiAgICB9IGVsc2Uge1xuICAgICAgLy9jb21tYW5kcyBsaWtlIFwiQ1wiIGNhbiBiZSBzdHJ1bmcgdG9nZXRoZXIgd2l0aG91dCBhbnkgbmV3IGNvbW1hbmQgY2hhcmFjdGVycyBiZXR3ZWVuLlxuICAgICAgaS0tO1xuICAgIH1cblxuICAgIHggPSArYVtpICsgMV07XG4gICAgeSA9ICthW2kgKyAyXTtcblxuICAgIGlmIChpc1JlbGF0aXZlKSB7XG4gICAgICB4ICs9IHJlbGF0aXZlWDtcbiAgICAgIHkgKz0gcmVsYXRpdmVZO1xuICAgIH1cblxuICAgIGlmICghaSkge1xuICAgICAgc3RhcnRYID0geDtcbiAgICAgIHN0YXJ0WSA9IHk7XG4gICAgfSAvLyBcIk1cIiAobW92ZSlcblxuXG4gICAgaWYgKGNvbW1hbmQgPT09IFwiTVwiKSB7XG4gICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPCA4KSB7XG4gICAgICAgICAgLy9pZiB0aGUgcGF0aCBkYXRhIHdhcyBmdW5reSBhbmQganVzdCBoYWQgYSBNIHdpdGggbm8gYWN0dWFsIGRyYXdpbmcgYW55d2hlcmUsIHNraXAgaXQuXG4gICAgICAgICAgcGF0aC5sZW5ndGggLT0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ludHMgKz0gc2VnbWVudC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVsYXRpdmVYID0gc3RhcnRYID0geDtcbiAgICAgIHJlbGF0aXZlWSA9IHN0YXJ0WSA9IHk7XG4gICAgICBzZWdtZW50ID0gW3gsIHldO1xuICAgICAgcGF0aC5wdXNoKHNlZ21lbnQpO1xuICAgICAgaSArPSAyO1xuICAgICAgY29tbWFuZCA9IFwiTFwiOyAvL2FuIFwiTVwiIHdpdGggbW9yZSB0aGFuIDIgdmFsdWVzIGdldHMgaW50ZXJwcmV0ZWQgYXMgXCJsaW5lVG9cIiBjb21tYW5kcyAoXCJMXCIpLlxuICAgICAgLy8gXCJDXCIgKGN1YmljIGJlemllcilcbiAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiQ1wiKSB7XG4gICAgICBpZiAoIXNlZ21lbnQpIHtcbiAgICAgICAgc2VnbWVudCA9IFswLCAwXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1JlbGF0aXZlKSB7XG4gICAgICAgIHJlbGF0aXZlWCA9IHJlbGF0aXZlWSA9IDA7XG4gICAgICB9IC8vbm90ZTogXCIqMVwiIGlzIGp1c3QgYSBmYXN0L3Nob3J0IHdheSB0byBjYXN0IHRoZSB2YWx1ZSBhcyBhIE51bWJlci4gV0FBQVkgZmFzdGVyIGluIENocm9tZSwgc2xpZ2h0bHkgc2xvd2VyIGluIEZpcmVmb3guXG5cblxuICAgICAgc2VnbWVudC5wdXNoKHgsIHksIHJlbGF0aXZlWCArIGFbaSArIDNdICogMSwgcmVsYXRpdmVZICsgYVtpICsgNF0gKiAxLCByZWxhdGl2ZVggKz0gYVtpICsgNV0gKiAxLCByZWxhdGl2ZVkgKz0gYVtpICsgNl0gKiAxKTtcbiAgICAgIGkgKz0gNjsgLy8gXCJTXCIgKGNvbnRpbnVhdGlvbiBvZiBjdWJpYyBiZXppZXIpXG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSBcIlNcIikge1xuICAgICAgZGlmWCA9IHJlbGF0aXZlWDtcbiAgICAgIGRpZlkgPSByZWxhdGl2ZVk7XG5cbiAgICAgIGlmIChwcmV2Q29tbWFuZCA9PT0gXCJDXCIgfHwgcHJldkNvbW1hbmQgPT09IFwiU1wiKSB7XG4gICAgICAgIGRpZlggKz0gcmVsYXRpdmVYIC0gc2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDRdO1xuICAgICAgICBkaWZZICs9IHJlbGF0aXZlWSAtIHNlZ21lbnRbc2VnbWVudC5sZW5ndGggLSAzXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1JlbGF0aXZlKSB7XG4gICAgICAgIHJlbGF0aXZlWCA9IHJlbGF0aXZlWSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQucHVzaChkaWZYLCBkaWZZLCB4LCB5LCByZWxhdGl2ZVggKz0gYVtpICsgM10gKiAxLCByZWxhdGl2ZVkgKz0gYVtpICsgNF0gKiAxKTtcbiAgICAgIGkgKz0gNDsgLy8gXCJRXCIgKHF1YWRyYXRpYyBiZXppZXIpXG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSBcIlFcIikge1xuICAgICAgZGlmWCA9IHJlbGF0aXZlWCArICh4IC0gcmVsYXRpdmVYKSAqIHR3b1RoaXJkcztcbiAgICAgIGRpZlkgPSByZWxhdGl2ZVkgKyAoeSAtIHJlbGF0aXZlWSkgKiB0d29UaGlyZHM7XG5cbiAgICAgIGlmICghaXNSZWxhdGl2ZSkge1xuICAgICAgICByZWxhdGl2ZVggPSByZWxhdGl2ZVkgPSAwO1xuICAgICAgfVxuXG4gICAgICByZWxhdGl2ZVggKz0gYVtpICsgM10gKiAxO1xuICAgICAgcmVsYXRpdmVZICs9IGFbaSArIDRdICogMTtcbiAgICAgIHNlZ21lbnQucHVzaChkaWZYLCBkaWZZLCByZWxhdGl2ZVggKyAoeCAtIHJlbGF0aXZlWCkgKiB0d29UaGlyZHMsIHJlbGF0aXZlWSArICh5IC0gcmVsYXRpdmVZKSAqIHR3b1RoaXJkcywgcmVsYXRpdmVYLCByZWxhdGl2ZVkpO1xuICAgICAgaSArPSA0OyAvLyBcIlRcIiAoY29udGludWF0aW9uIG9mIHF1YWRyYXRpYyBiZXppZXIpXG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSBcIlRcIikge1xuICAgICAgZGlmWCA9IHJlbGF0aXZlWCAtIHNlZ21lbnRbc2VnbWVudC5sZW5ndGggLSA0XTtcbiAgICAgIGRpZlkgPSByZWxhdGl2ZVkgLSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gM107XG4gICAgICBzZWdtZW50LnB1c2gocmVsYXRpdmVYICsgZGlmWCwgcmVsYXRpdmVZICsgZGlmWSwgeCArIChyZWxhdGl2ZVggKyBkaWZYICogMS41IC0geCkgKiB0d29UaGlyZHMsIHkgKyAocmVsYXRpdmVZICsgZGlmWSAqIDEuNSAtIHkpICogdHdvVGhpcmRzLCByZWxhdGl2ZVggPSB4LCByZWxhdGl2ZVkgPSB5KTtcbiAgICAgIGkgKz0gMjsgLy8gXCJIXCIgKGhvcml6b250YWwgbGluZSlcbiAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiSFwiKSB7XG4gICAgICBsaW5lKHJlbGF0aXZlWCwgcmVsYXRpdmVZLCByZWxhdGl2ZVggPSB4LCByZWxhdGl2ZVkpO1xuICAgICAgaSArPSAxOyAvLyBcIlZcIiAodmVydGljYWwgbGluZSlcbiAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiVlwiKSB7XG4gICAgICAvL2FkanVzdCB2YWx1ZXMgYmVjYXVzZSB0aGUgZmlyc3QgKGFuZCBvbmx5IG9uZSkgaXNuJ3QgeCBpbiB0aGlzIGNhc2UsIGl0J3MgeS5cbiAgICAgIGxpbmUocmVsYXRpdmVYLCByZWxhdGl2ZVksIHJlbGF0aXZlWCwgcmVsYXRpdmVZID0geCArIChpc1JlbGF0aXZlID8gcmVsYXRpdmVZIC0gcmVsYXRpdmVYIDogMCkpO1xuICAgICAgaSArPSAxOyAvLyBcIkxcIiAobGluZSkgb3IgXCJaXCIgKGNsb3NlKVxuICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJMXCIgfHwgY29tbWFuZCA9PT0gXCJaXCIpIHtcbiAgICAgIGlmIChjb21tYW5kID09PSBcIlpcIikge1xuICAgICAgICB4ID0gc3RhcnRYO1xuICAgICAgICB5ID0gc3RhcnRZO1xuICAgICAgICBzZWdtZW50LmNsb3NlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21tYW5kID09PSBcIkxcIiB8fCBfYWJzKHJlbGF0aXZlWCAtIHgpID4gMC41IHx8IF9hYnMocmVsYXRpdmVZIC0geSkgPiAwLjUpIHtcbiAgICAgICAgbGluZShyZWxhdGl2ZVgsIHJlbGF0aXZlWSwgeCwgeSk7XG5cbiAgICAgICAgaWYgKGNvbW1hbmQgPT09IFwiTFwiKSB7XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlbGF0aXZlWCA9IHg7XG4gICAgICByZWxhdGl2ZVkgPSB5OyAvLyBcIkFcIiAoYXJjKVxuICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJBXCIpIHtcbiAgICAgIGZsYWcxID0gYVtpICsgNF07XG4gICAgICBmbGFnMiA9IGFbaSArIDVdO1xuICAgICAgZGlmWCA9IGFbaSArIDZdO1xuICAgICAgZGlmWSA9IGFbaSArIDddO1xuICAgICAgaiA9IDc7XG5cbiAgICAgIGlmIChmbGFnMS5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIGZvciBjYXNlcyB3aGVuIHRoZSBmbGFncyBhcmUgbWVyZ2VkLCBsaWtlIFwiYTggOCAwIDAxOCA4XCIgKHRoZSAwIGFuZCAxIGZsYWdzIGFyZSBXSVRIIHRoZSB4IHZhbHVlIG9mIDgsIGJ1dCBpdCBjb3VsZCBhbHNvIGJlIFwiYTggOCAwIDAxLTggOFwiIHNvIGl0IG1heSBpbmNsdWRlIHggb3Igbm90KVxuICAgICAgICBpZiAoZmxhZzEubGVuZ3RoIDwgMykge1xuICAgICAgICAgIGRpZlkgPSBkaWZYO1xuICAgICAgICAgIGRpZlggPSBmbGFnMjtcbiAgICAgICAgICBqLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlmWSA9IGZsYWcyO1xuICAgICAgICAgIGRpZlggPSBmbGFnMS5zdWJzdHIoMik7XG4gICAgICAgICAgaiAtPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgZmxhZzIgPSBmbGFnMS5jaGFyQXQoMSk7XG4gICAgICAgIGZsYWcxID0gZmxhZzEuY2hhckF0KDApO1xuICAgICAgfVxuXG4gICAgICBiZXppZXJzID0gYXJjVG9TZWdtZW50KHJlbGF0aXZlWCwgcmVsYXRpdmVZLCArYVtpICsgMV0sICthW2kgKyAyXSwgK2FbaSArIDNdLCArZmxhZzEsICtmbGFnMiwgKGlzUmVsYXRpdmUgPyByZWxhdGl2ZVggOiAwKSArIGRpZlggKiAxLCAoaXNSZWxhdGl2ZSA/IHJlbGF0aXZlWSA6IDApICsgZGlmWSAqIDEpO1xuICAgICAgaSArPSBqO1xuXG4gICAgICBpZiAoYmV6aWVycykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgYmV6aWVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNlZ21lbnQucHVzaChiZXppZXJzW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZWxhdGl2ZVggPSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gMl07XG4gICAgICByZWxhdGl2ZVkgPSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgaSA9IHNlZ21lbnQubGVuZ3RoO1xuXG4gIGlmIChpIDwgNikge1xuICAgIC8vaW4gY2FzZSB0aGVyZSdzIG9kZCBTVkcgbGlrZSBhIE0wLDAgY29tbWFuZCBhdCB0aGUgdmVyeSBlbmQuXG4gICAgcGF0aC5wb3AoKTtcbiAgICBpID0gMDtcbiAgfSBlbHNlIGlmIChzZWdtZW50WzBdID09PSBzZWdtZW50W2kgLSAyXSAmJiBzZWdtZW50WzFdID09PSBzZWdtZW50W2kgLSAxXSkge1xuICAgIHNlZ21lbnQuY2xvc2VkID0gdHJ1ZTtcbiAgfVxuXG4gIHBhdGgudG90YWxQb2ludHMgPSBwb2ludHMgKyBpO1xuICByZXR1cm4gcGF0aDtcbn0gLy9wb3B1bGF0ZXMgdGhlIHBvaW50cyBhcnJheSBpbiBhbHRlcm5hdGluZyB4L3kgdmFsdWVzIChsaWtlIFt4LCB5LCB4LCB5Li4uXSBpbnN0ZWFkIG9mIGluZGl2aWR1YWwgcG9pbnQgb2JqZWN0cyBbe3gsIHl9LCB7eCwgeX0uLi5dIHRvIGNvbnNlcnZlIG1lbW9yeSBhbmQgc3RheSBpbiBsaW5lIHdpdGggaG93IHdlJ3JlIGhhbmRsaW5nIHNlZ21lbnQgYXJyYXlzXG5cbmV4cG9ydCBmdW5jdGlvbiBiZXppZXJUb1BvaW50cyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIHRocmVzaG9sZCwgcG9pbnRzLCBpbmRleCkge1xuICB2YXIgeDEyID0gKHgxICsgeDIpIC8gMixcbiAgICAgIHkxMiA9ICh5MSArIHkyKSAvIDIsXG4gICAgICB4MjMgPSAoeDIgKyB4MykgLyAyLFxuICAgICAgeTIzID0gKHkyICsgeTMpIC8gMixcbiAgICAgIHgzNCA9ICh4MyArIHg0KSAvIDIsXG4gICAgICB5MzQgPSAoeTMgKyB5NCkgLyAyLFxuICAgICAgeDEyMyA9ICh4MTIgKyB4MjMpIC8gMixcbiAgICAgIHkxMjMgPSAoeTEyICsgeTIzKSAvIDIsXG4gICAgICB4MjM0ID0gKHgyMyArIHgzNCkgLyAyLFxuICAgICAgeTIzNCA9ICh5MjMgKyB5MzQpIC8gMixcbiAgICAgIHgxMjM0ID0gKHgxMjMgKyB4MjM0KSAvIDIsXG4gICAgICB5MTIzNCA9ICh5MTIzICsgeTIzNCkgLyAyLFxuICAgICAgZHggPSB4NCAtIHgxLFxuICAgICAgZHkgPSB5NCAtIHkxLFxuICAgICAgZDIgPSBfYWJzKCh4MiAtIHg0KSAqIGR5IC0gKHkyIC0geTQpICogZHgpLFxuICAgICAgZDMgPSBfYWJzKCh4MyAtIHg0KSAqIGR5IC0gKHkzIC0geTQpICogZHgpLFxuICAgICAgbGVuZ3RoO1xuXG4gIGlmICghcG9pbnRzKSB7XG4gICAgcG9pbnRzID0gW3gxLCB5MSwgeDQsIHk0XTtcbiAgICBpbmRleCA9IDI7XG4gIH1cblxuICBwb2ludHMuc3BsaWNlKGluZGV4IHx8IHBvaW50cy5sZW5ndGggLSAyLCAwLCB4MTIzNCwgeTEyMzQpO1xuXG4gIGlmICgoZDIgKyBkMykgKiAoZDIgKyBkMykgPiB0aHJlc2hvbGQgKiAoZHggKiBkeCArIGR5ICogZHkpKSB7XG4gICAgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcbiAgICBiZXppZXJUb1BvaW50cyh4MSwgeTEsIHgxMiwgeTEyLCB4MTIzLCB5MTIzLCB4MTIzNCwgeTEyMzQsIHRocmVzaG9sZCwgcG9pbnRzLCBpbmRleCk7XG4gICAgYmV6aWVyVG9Qb2ludHMoeDEyMzQsIHkxMjM0LCB4MjM0LCB5MjM0LCB4MzQsIHkzNCwgeDQsIHk0LCB0aHJlc2hvbGQsIHBvaW50cywgaW5kZXggKyAyICsgKHBvaW50cy5sZW5ndGggLSBsZW5ndGgpKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59XG4vKlxuZnVuY3Rpb24gZ2V0QW5nbGVCZXR3ZWVuUG9pbnRzKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIpIHsgLy9hbmdsZSBiZXR3ZWVuIDMgcG9pbnRzIGluIHJhZGlhbnNcblx0dmFyIGR4MSA9IHgxIC0geDAsXG5cdFx0ZHkxID0geTEgLSB5MCxcblx0XHRkeDIgPSB4MiAtIHgxLFxuXHRcdGR5MiA9IHkyIC0geTEsXG5cdFx0ZHgzID0geDIgLSB4MCxcblx0XHRkeTMgPSB5MiAtIHkwLFxuXHRcdGEgPSBkeDEgKiBkeDEgKyBkeTEgKiBkeTEsXG5cdFx0YiA9IGR4MiAqIGR4MiArIGR5MiAqIGR5Mixcblx0XHRjID0gZHgzICogZHgzICsgZHkzICogZHkzO1xuXHRyZXR1cm4gTWF0aC5hY29zKCAoYSArIGIgLSBjKSAvIF9zcXJ0KDQgKiBhICogYikgKTtcbn0sXG4qL1xuLy9wb2ludHNUb1NlZ21lbnQoKSBkb2Vzbid0IGhhbmRsZSBmbGF0IGNvb3JkaW5hdGVzICh3aGVyZSB5IGlzIGFsd2F5cyAwKSB0aGUgd2F5IHdlIG5lZWQgKHRoZSByZXN1bHRpbmcgY29udHJvbCBwb2ludHMgYXJlIGFsd2F5cyByaWdodCBvbiB0b3Agb2YgdGhlIGFuY2hvcnMpLCBzbyB0aGlzIGZ1bmN0aW9uIGJhc2ljYWxseSBtYWtlcyB0aGUgY29udHJvbCBwb2ludHMgZ28gZGlyZWN0bHkgdXAgYW5kIGRvd24sIHZhcnlpbmcgaW4gbGVuZ3RoIGJhc2VkIG9uIHRoZSBjdXJ2aW5lc3MgKG1vcmUgY3VydnksIGZ1cnRoZXIgY29udHJvbCBwb2ludHMpXG5cbmV4cG9ydCBmdW5jdGlvbiBmbGF0UG9pbnRzVG9TZWdtZW50KHBvaW50cywgY3VydmluZXNzKSB7XG4gIGlmIChjdXJ2aW5lc3MgPT09IHZvaWQgMCkge1xuICAgIGN1cnZpbmVzcyA9IDE7XG4gIH1cblxuICB2YXIgeCA9IHBvaW50c1swXSxcbiAgICAgIHkgPSAwLFxuICAgICAgc2VnbWVudCA9IFt4LCB5XSxcbiAgICAgIGkgPSAyO1xuXG4gIGZvciAoOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgc2VnbWVudC5wdXNoKHgsIHksIHBvaW50c1tpXSwgeSA9IChwb2ludHNbaV0gLSB4KSAqIGN1cnZpbmVzcyAvIDIsIHggPSBwb2ludHNbaV0sIC15KTtcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50O1xufSAvL3BvaW50cyBpcyBhbiBhcnJheSBvZiB4L3kgcG9pbnRzLCBsaWtlIFt4LCB5LCB4LCB5LCB4LCB5XVxuXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRzVG9TZWdtZW50KHBvaW50cywgY3VydmluZXNzKSB7XG4gIC8vcG9pbnRzID0gc2ltcGxpZnlQb2ludHMocG9pbnRzLCB0b2xlcmFuY2UpO1xuICBfYWJzKHBvaW50c1swXSAtIHBvaW50c1syXSkgPCAxZS00ICYmIF9hYnMocG9pbnRzWzFdIC0gcG9pbnRzWzNdKSA8IDFlLTQgJiYgKHBvaW50cyA9IHBvaW50cy5zbGljZSgyKSk7IC8vIGlmIHRoZSBmaXJzdCB0d28gcG9pbnRzIGFyZSBzdXBlciBjbG9zZSwgZHVtcCB0aGUgZmlyc3Qgb25lLlxuXG4gIHZhciBsID0gcG9pbnRzLmxlbmd0aCAtIDIsXG4gICAgICB4ID0gK3BvaW50c1swXSxcbiAgICAgIHkgPSArcG9pbnRzWzFdLFxuICAgICAgbmV4dFggPSArcG9pbnRzWzJdLFxuICAgICAgbmV4dFkgPSArcG9pbnRzWzNdLFxuICAgICAgc2VnbWVudCA9IFt4LCB5LCB4LCB5XSxcbiAgICAgIGR4MiA9IG5leHRYIC0geCxcbiAgICAgIGR5MiA9IG5leHRZIC0geSxcbiAgICAgIGNsb3NlZCA9IE1hdGguYWJzKHBvaW50c1tsXSAtIHgpIDwgMC4wMDEgJiYgTWF0aC5hYnMocG9pbnRzW2wgKyAxXSAtIHkpIDwgMC4wMDEsXG4gICAgICBwcmV2WCxcbiAgICAgIHByZXZZLFxuICAgICAgaSxcbiAgICAgIGR4MSxcbiAgICAgIGR5MSxcbiAgICAgIHIxLFxuICAgICAgcjIsXG4gICAgICByMyxcbiAgICAgIHRsLFxuICAgICAgbXgxLFxuICAgICAgbXgyLFxuICAgICAgbXhtLFxuICAgICAgbXkxLFxuICAgICAgbXkyLFxuICAgICAgbXltO1xuXG4gIGlmIChjbG9zZWQpIHtcbiAgICAvLyBpZiB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgYXJlIGJhc2ljYWxseSBvbiB0b3Agb2YgZWFjaCBvdGhlciwgY2xvc2UgdGhlIHNlZ21lbnQgYnkgYWRkaW5nIHRoZSAybmQgcG9pbnQgdG8gdGhlIGVuZCwgYW5kIHRoZSAybmQtdG8tbGFzdCBwb2ludCB0byB0aGUgYmVnaW5uaW5nICh3ZSdsbCByZW1vdmUgdGhlbSBhdCB0aGUgZW5kLCBidXQgdGhpcyBhbGxvd3MgdGhlIGN1cnZhdHVyZSB0byBsb29rIHBlcmZlY3QpXG4gICAgcG9pbnRzLnB1c2gobmV4dFgsIG5leHRZKTtcbiAgICBuZXh0WCA9IHg7XG4gICAgbmV4dFkgPSB5O1xuICAgIHggPSBwb2ludHNbbCAtIDJdO1xuICAgIHkgPSBwb2ludHNbbCAtIDFdO1xuICAgIHBvaW50cy51bnNoaWZ0KHgsIHkpO1xuICAgIGwgKz0gNDtcbiAgfVxuXG4gIGN1cnZpbmVzcyA9IGN1cnZpbmVzcyB8fCBjdXJ2aW5lc3MgPT09IDAgPyArY3VydmluZXNzIDogMTtcblxuICBmb3IgKGkgPSAyOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgcHJldlggPSB4O1xuICAgIHByZXZZID0geTtcbiAgICB4ID0gbmV4dFg7XG4gICAgeSA9IG5leHRZO1xuICAgIG5leHRYID0gK3BvaW50c1tpICsgMl07XG4gICAgbmV4dFkgPSArcG9pbnRzW2kgKyAzXTtcblxuICAgIGlmICh4ID09PSBuZXh0WCAmJiB5ID09PSBuZXh0WSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZHgxID0gZHgyO1xuICAgIGR5MSA9IGR5MjtcbiAgICBkeDIgPSBuZXh0WCAtIHg7XG4gICAgZHkyID0gbmV4dFkgLSB5O1xuICAgIHIxID0gX3NxcnQoZHgxICogZHgxICsgZHkxICogZHkxKTsgLy8gcjEsIHIyLCBhbmQgcjMgY29ycmVsYXRlIHggYW5kIHkgKGFuZCB6IGluIHRoZSBmdXR1cmUpLiBCYXNpY2FsbHkgMkQgb3IgM0QgaHlwb3RlbnVzZVxuXG4gICAgcjIgPSBfc3FydChkeDIgKiBkeDIgKyBkeTIgKiBkeTIpO1xuICAgIHIzID0gX3NxcnQoTWF0aC5wb3coZHgyIC8gcjIgKyBkeDEgLyByMSwgMikgKyBNYXRoLnBvdyhkeTIgLyByMiArIGR5MSAvIHIxLCAyKSk7XG4gICAgdGwgPSAocjEgKyByMikgKiBjdXJ2aW5lc3MgKiAwLjI1IC8gcjM7XG4gICAgbXgxID0geCAtICh4IC0gcHJldlgpICogKHIxID8gdGwgLyByMSA6IDApO1xuICAgIG14MiA9IHggKyAobmV4dFggLSB4KSAqIChyMiA/IHRsIC8gcjIgOiAwKTtcbiAgICBteG0gPSB4IC0gKG14MSArICgobXgyIC0gbXgxKSAqIChyMSAqIDMgLyAocjEgKyByMikgKyAwLjUpIC8gNCB8fCAwKSk7XG4gICAgbXkxID0geSAtICh5IC0gcHJldlkpICogKHIxID8gdGwgLyByMSA6IDApO1xuICAgIG15MiA9IHkgKyAobmV4dFkgLSB5KSAqIChyMiA/IHRsIC8gcjIgOiAwKTtcbiAgICBteW0gPSB5IC0gKG15MSArICgobXkyIC0gbXkxKSAqIChyMSAqIDMgLyAocjEgKyByMikgKyAwLjUpIC8gNCB8fCAwKSk7XG5cbiAgICBpZiAoeCAhPT0gcHJldlggfHwgeSAhPT0gcHJldlkpIHtcbiAgICAgIHNlZ21lbnQucHVzaChfcm91bmQobXgxICsgbXhtKSwgLy8gZmlyc3QgY29udHJvbCBwb2ludFxuICAgICAgX3JvdW5kKG15MSArIG15bSksIF9yb3VuZCh4KSwgLy8gYW5jaG9yXG4gICAgICBfcm91bmQoeSksIF9yb3VuZChteDIgKyBteG0pLCAvLyBzZWNvbmQgY29udHJvbCBwb2ludFxuICAgICAgX3JvdW5kKG15MiArIG15bSkpO1xuICAgIH1cbiAgfVxuXG4gIHggIT09IG5leHRYIHx8IHkgIT09IG5leHRZIHx8IHNlZ21lbnQubGVuZ3RoIDwgNCA/IHNlZ21lbnQucHVzaChfcm91bmQobmV4dFgpLCBfcm91bmQobmV4dFkpLCBfcm91bmQobmV4dFgpLCBfcm91bmQobmV4dFkpKSA6IHNlZ21lbnQubGVuZ3RoIC09IDI7XG5cbiAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAyKSB7XG4gICAgLy8gb25seSBvbmUgcG9pbnQhXG4gICAgc2VnbWVudC5wdXNoKHgsIHksIHgsIHksIHgsIHkpO1xuICB9IGVsc2UgaWYgKGNsb3NlZCkge1xuICAgIHNlZ21lbnQuc3BsaWNlKDAsIDYpO1xuICAgIHNlZ21lbnQubGVuZ3RoID0gc2VnbWVudC5sZW5ndGggLSA2O1xuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnQ7XG59IC8vcmV0dXJucyB0aGUgc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGFuIHgveSBjb29yZGluYXRlIGFuZCBhIHNlZ21lbnQgYmV0d2VlbiB4MS95MSBhbmQgeDIveTJcblxuZnVuY3Rpb24gcG9pbnRUb1NlZ0Rpc3QoeCwgeSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgdmFyIGR4ID0geDIgLSB4MSxcbiAgICAgIGR5ID0geTIgLSB5MSxcbiAgICAgIHQ7XG5cbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgdCA9ICgoeCAtIHgxKSAqIGR4ICsgKHkgLSB5MSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgaWYgKHQgPiAxKSB7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeTEgPSB5MjtcbiAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICB4MSArPSBkeCAqIHQ7XG4gICAgICB5MSArPSBkeSAqIHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE1hdGgucG93KHggLSB4MSwgMikgKyBNYXRoLnBvdyh5IC0geTEsIDIpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGlmeVN0ZXAocG9pbnRzLCBmaXJzdCwgbGFzdCwgdG9sZXJhbmNlLCBzaW1wbGlmaWVkKSB7XG4gIHZhciBtYXhTcURpc3QgPSB0b2xlcmFuY2UsXG4gICAgICBmaXJzdFggPSBwb2ludHNbZmlyc3RdLFxuICAgICAgZmlyc3RZID0gcG9pbnRzW2ZpcnN0ICsgMV0sXG4gICAgICBsYXN0WCA9IHBvaW50c1tsYXN0XSxcbiAgICAgIGxhc3RZID0gcG9pbnRzW2xhc3QgKyAxXSxcbiAgICAgIGluZGV4LFxuICAgICAgaSxcbiAgICAgIGQ7XG5cbiAgZm9yIChpID0gZmlyc3QgKyAyOyBpIDwgbGFzdDsgaSArPSAyKSB7XG4gICAgZCA9IHBvaW50VG9TZWdEaXN0KHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSwgZmlyc3RYLCBmaXJzdFksIGxhc3RYLCBsYXN0WSk7XG5cbiAgICBpZiAoZCA+IG1heFNxRGlzdCkge1xuICAgICAgaW5kZXggPSBpO1xuICAgICAgbWF4U3FEaXN0ID0gZDtcbiAgICB9XG4gIH1cblxuICBpZiAobWF4U3FEaXN0ID4gdG9sZXJhbmNlKSB7XG4gICAgaW5kZXggLSBmaXJzdCA+IDIgJiYgc2ltcGxpZnlTdGVwKHBvaW50cywgZmlyc3QsIGluZGV4LCB0b2xlcmFuY2UsIHNpbXBsaWZpZWQpO1xuICAgIHNpbXBsaWZpZWQucHVzaChwb2ludHNbaW5kZXhdLCBwb2ludHNbaW5kZXggKyAxXSk7XG4gICAgbGFzdCAtIGluZGV4ID4gMiAmJiBzaW1wbGlmeVN0ZXAocG9pbnRzLCBpbmRleCwgbGFzdCwgdG9sZXJhbmNlLCBzaW1wbGlmaWVkKTtcbiAgfVxufSAvL3BvaW50cyBpcyBhbiBhcnJheSBvZiB4L3kgdmFsdWVzIGxpa2UgW3gsIHksIHgsIHksIHgsIHldXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsaWZ5UG9pbnRzKHBvaW50cywgdG9sZXJhbmNlKSB7XG4gIHZhciBwcmV2WCA9IHBhcnNlRmxvYXQocG9pbnRzWzBdKSxcbiAgICAgIHByZXZZID0gcGFyc2VGbG9hdChwb2ludHNbMV0pLFxuICAgICAgdGVtcCA9IFtwcmV2WCwgcHJldlldLFxuICAgICAgbCA9IHBvaW50cy5sZW5ndGggLSAyLFxuICAgICAgaSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgZHgsXG4gICAgICBkeSxcbiAgICAgIHJlc3VsdCxcbiAgICAgIGxhc3Q7XG4gIHRvbGVyYW5jZSA9IE1hdGgucG93KHRvbGVyYW5jZSB8fCAxLCAyKTtcblxuICBmb3IgKGkgPSAyOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgeCA9IHBhcnNlRmxvYXQocG9pbnRzW2ldKTtcbiAgICB5ID0gcGFyc2VGbG9hdChwb2ludHNbaSArIDFdKTtcbiAgICBkeCA9IHByZXZYIC0geDtcbiAgICBkeSA9IHByZXZZIC0geTtcblxuICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA+IHRvbGVyYW5jZSkge1xuICAgICAgdGVtcC5wdXNoKHgsIHkpO1xuICAgICAgcHJldlggPSB4O1xuICAgICAgcHJldlkgPSB5O1xuICAgIH1cbiAgfVxuXG4gIHRlbXAucHVzaChwYXJzZUZsb2F0KHBvaW50c1tsXSksIHBhcnNlRmxvYXQocG9pbnRzW2wgKyAxXSkpO1xuICBsYXN0ID0gdGVtcC5sZW5ndGggLSAyO1xuICByZXN1bHQgPSBbdGVtcFswXSwgdGVtcFsxXV07XG4gIHNpbXBsaWZ5U3RlcCh0ZW1wLCAwLCBsYXN0LCB0b2xlcmFuY2UsIHJlc3VsdCk7XG4gIHJlc3VsdC5wdXNoKHRlbXBbbGFzdF0sIHRlbXBbbGFzdCArIDFdKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xvc2VzdFByb2dyZXNzT25CZXppZXIoaXRlcmF0aW9ucywgcHgsIHB5LCBzdGFydCwgZW5kLCBzbGljZXMsIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICB2YXIgaW5jID0gKGVuZCAtIHN0YXJ0KSAvIHNsaWNlcyxcbiAgICAgIGJlc3QgPSAwLFxuICAgICAgdCA9IHN0YXJ0LFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBkLFxuICAgICAgZHgsXG4gICAgICBkeSxcbiAgICAgIGludjtcbiAgX2Jlc3REaXN0YW5jZSA9IF9sYXJnZU51bTtcblxuICB3aGlsZSAodCA8PSBlbmQpIHtcbiAgICBpbnYgPSAxIC0gdDtcbiAgICB4ID0gaW52ICogaW52ICogaW52ICogeDAgKyAzICogaW52ICogaW52ICogdCAqIHgxICsgMyAqIGludiAqIHQgKiB0ICogeDIgKyB0ICogdCAqIHQgKiB4MztcbiAgICB5ID0gaW52ICogaW52ICogaW52ICogeTAgKyAzICogaW52ICogaW52ICogdCAqIHkxICsgMyAqIGludiAqIHQgKiB0ICogeTIgKyB0ICogdCAqIHQgKiB5MztcbiAgICBkeCA9IHggLSBweDtcbiAgICBkeSA9IHkgLSBweTtcbiAgICBkID0gZHggKiBkeCArIGR5ICogZHk7XG5cbiAgICBpZiAoZCA8IF9iZXN0RGlzdGFuY2UpIHtcbiAgICAgIF9iZXN0RGlzdGFuY2UgPSBkO1xuICAgICAgYmVzdCA9IHQ7XG4gICAgfVxuXG4gICAgdCArPSBpbmM7XG4gIH1cblxuICByZXR1cm4gaXRlcmF0aW9ucyA+IDEgPyBnZXRDbG9zZXN0UHJvZ3Jlc3NPbkJlemllcihpdGVyYXRpb25zIC0gMSwgcHgsIHB5LCBNYXRoLm1heChiZXN0IC0gaW5jLCAwKSwgTWF0aC5taW4oYmVzdCArIGluYywgMSksIHNsaWNlcywgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSA6IGJlc3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbG9zZXN0RGF0YShyYXdQYXRoLCB4LCB5LCBzbGljZXMpIHtcbiAgLy9yZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBjbG9zZXN0IGosIGksIGFuZCB0IChqIGlzIHRoZSBzZWdtZW50IGluZGV4LCBpIGlzIHRoZSBpbmRleCBvZiB0aGUgcG9pbnQgaW4gdGhhdCBzZWdtZW50LCBhbmQgdCBpcyB0aGUgdGltZS9wcm9ncmVzcyBhbG9uZyB0aGF0IGJlemllcilcbiAgdmFyIGNsb3Nlc3QgPSB7XG4gICAgajogMCxcbiAgICBpOiAwLFxuICAgIHQ6IDBcbiAgfSxcbiAgICAgIGJlc3REaXN0YW5jZSA9IF9sYXJnZU51bSxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgdCxcbiAgICAgIHNlZ21lbnQ7XG5cbiAgZm9yIChqID0gMDsgaiA8IHJhd1BhdGgubGVuZ3RoOyBqKyspIHtcbiAgICBzZWdtZW50ID0gcmF3UGF0aFtqXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzZWdtZW50Lmxlbmd0aDsgaSArPSA2KSB7XG4gICAgICB0ID0gZ2V0Q2xvc2VzdFByb2dyZXNzT25CZXppZXIoMSwgeCwgeSwgMCwgMSwgc2xpY2VzIHx8IDIwLCBzZWdtZW50W2ldLCBzZWdtZW50W2kgKyAxXSwgc2VnbWVudFtpICsgMl0sIHNlZ21lbnRbaSArIDNdLCBzZWdtZW50W2kgKyA0XSwgc2VnbWVudFtpICsgNV0sIHNlZ21lbnRbaSArIDZdLCBzZWdtZW50W2kgKyA3XSk7XG5cbiAgICAgIGlmIChiZXN0RGlzdGFuY2UgPiBfYmVzdERpc3RhbmNlKSB7XG4gICAgICAgIGJlc3REaXN0YW5jZSA9IF9iZXN0RGlzdGFuY2U7XG4gICAgICAgIGNsb3Nlc3QuaiA9IGo7XG4gICAgICAgIGNsb3Nlc3QuaSA9IGk7XG4gICAgICAgIGNsb3Nlc3QudCA9IHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsb3Nlc3Q7XG59IC8vc3ViZGl2aWRlIGEgU2VnbWVudCBjbG9zZXN0IHRvIGEgc3BlY2lmaWMgeCx5IGNvb3JkaW5hdGVcblxuZXhwb3J0IGZ1bmN0aW9uIHN1YmRpdmlkZVNlZ21lbnROZWFyKHgsIHksIHNlZ21lbnQsIHNsaWNlcywgaXRlcmF0aW9ucykge1xuICB2YXIgbCA9IHNlZ21lbnQubGVuZ3RoLFxuICAgICAgYmVzdERpc3RhbmNlID0gX2xhcmdlTnVtLFxuICAgICAgYmVzdFQgPSAwLFxuICAgICAgYmVzdFNlZ21lbnRJbmRleCA9IDAsXG4gICAgICB0LFxuICAgICAgaTtcbiAgc2xpY2VzID0gc2xpY2VzIHx8IDIwO1xuICBpdGVyYXRpb25zID0gaXRlcmF0aW9ucyB8fCAzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpICs9IDYpIHtcbiAgICB0ID0gZ2V0Q2xvc2VzdFByb2dyZXNzT25CZXppZXIoMSwgeCwgeSwgMCwgMSwgc2xpY2VzLCBzZWdtZW50W2ldLCBzZWdtZW50W2kgKyAxXSwgc2VnbWVudFtpICsgMl0sIHNlZ21lbnRbaSArIDNdLCBzZWdtZW50W2kgKyA0XSwgc2VnbWVudFtpICsgNV0sIHNlZ21lbnRbaSArIDZdLCBzZWdtZW50W2kgKyA3XSk7XG5cbiAgICBpZiAoYmVzdERpc3RhbmNlID4gX2Jlc3REaXN0YW5jZSkge1xuICAgICAgYmVzdERpc3RhbmNlID0gX2Jlc3REaXN0YW5jZTtcbiAgICAgIGJlc3RUID0gdDtcbiAgICAgIGJlc3RTZWdtZW50SW5kZXggPSBpO1xuICAgIH1cbiAgfVxuXG4gIHQgPSBnZXRDbG9zZXN0UHJvZ3Jlc3NPbkJlemllcihpdGVyYXRpb25zLCB4LCB5LCBiZXN0VCAtIDAuMDUsIGJlc3RUICsgMC4wNSwgc2xpY2VzLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXhdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXggKyAxXSwgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4ICsgMl0sIHNlZ21lbnRbYmVzdFNlZ21lbnRJbmRleCArIDNdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXggKyA0XSwgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4ICsgNV0sIHNlZ21lbnRbYmVzdFNlZ21lbnRJbmRleCArIDZdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXggKyA3XSk7XG4gIHN1YmRpdmlkZVNlZ21lbnQoc2VnbWVudCwgYmVzdFNlZ21lbnRJbmRleCwgdCk7XG4gIHJldHVybiBiZXN0U2VnbWVudEluZGV4ICsgNjtcbn1cbi8qXG5UYWtlcyBhbnkgb2YgdGhlIGZvbGxvd2luZyBhbmQgY29udmVydHMgaXQgdG8gYW4gYWxsIEN1YmljIEJlemllciBTVkcgZGF0YSBzdHJpbmc6XG4tIEEgPHBhdGg+IGRhdGEgc3RyaW5nIGxpa2UgXCJNMCwwIEwyLDQgdjIwLDE1IEgxMDBcIlxuLSBBIFJhd1BhdGgsIGxpa2UgW1t4LCB5LCB4LCB5LCB4LCB5LCB4LCB5XVtbeCwgeSwgeCwgeSwgeCwgeSwgeCwgeV1dXG4tIEEgU2VnbWVudCwgbGlrZSBbeCwgeSwgeCwgeSwgeCwgeSwgeCwgeV1cblxuTm90ZTogYWxsIG51bWJlcnMgYXJlIHJvdW5kZWQgZG93biB0byB0aGUgY2xvc2VzdCAwLjAwMSB0byBtaW5pbWl6ZSBtZW1vcnksIG1heGltaXplIHNwZWVkLCBhbmQgYXZvaWQgb2RkIG51bWJlcnMgbGlrZSAxZS0xM1xuKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhd1BhdGhUb1N0cmluZyhyYXdQYXRoKSB7XG4gIGlmIChfaXNOdW1iZXIocmF3UGF0aFswXSkpIHtcbiAgICAvL2luIGNhc2UgYSBzZWdtZW50IGlzIHBhc3NlZCBpbiBpbnN0ZWFkXG4gICAgcmF3UGF0aCA9IFtyYXdQYXRoXTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBcIlwiLFxuICAgICAgbCA9IHJhd1BhdGgubGVuZ3RoLFxuICAgICAgc2wsXG4gICAgICBzLFxuICAgICAgaSxcbiAgICAgIHNlZ21lbnQ7XG5cbiAgZm9yIChzID0gMDsgcyA8IGw7IHMrKykge1xuICAgIHNlZ21lbnQgPSByYXdQYXRoW3NdO1xuICAgIHJlc3VsdCArPSBcIk1cIiArIF9yb3VuZChzZWdtZW50WzBdKSArIFwiLFwiICsgX3JvdW5kKHNlZ21lbnRbMV0pICsgXCIgQ1wiO1xuICAgIHNsID0gc2VnbWVudC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAyOyBpIDwgc2w7IGkrKykge1xuICAgICAgcmVzdWx0ICs9IF9yb3VuZChzZWdtZW50W2krK10pICsgXCIsXCIgKyBfcm91bmQoc2VnbWVudFtpKytdKSArIFwiIFwiICsgX3JvdW5kKHNlZ21lbnRbaSsrXSkgKyBcIixcIiArIF9yb3VuZChzZWdtZW50W2krK10pICsgXCIgXCIgKyBfcm91bmQoc2VnbWVudFtpKytdKSArIFwiLFwiICsgX3JvdW5kKHNlZ21lbnRbaV0pICsgXCIgXCI7XG4gICAgfVxuXG4gICAgaWYgKHNlZ21lbnQuY2xvc2VkKSB7XG4gICAgICByZXN1bHQgKz0gXCJ6XCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qXG4vLyB0YWtlcyBhIHNlZ21lbnQgd2l0aCBjb29yZGluYXRlcyBbeCwgeSwgeCwgeSwgLi4uXSBhbmQgY29udmVydHMgdGhlIGNvbnRyb2wgcG9pbnRzIGludG8gYW5nbGVzIGFuZCBsZW5ndGhzIFt4LCB5LCBhbmdsZSwgbGVuZ3RoLCBhbmdsZSwgbGVuZ3RoLCB4LCB5LCBhbmdsZSwgbGVuZ3RoLCAuLi5dIHNvIHRoYXQgaXQgYW5pbWF0ZXMgbW9yZSBjbGVhbmx5IGFuZCBhdm9pZHMgb2RkIGJyZWFrcy9raW5rcy4gRm9yIGV4YW1wbGUsIGlmIHlvdSBhbmltYXRlIGZyb20gMSBvJ2Nsb2NrIHRvIDYgbydjbG9jaywgaXQnZCBqdXN0IGdvIGRpcmVjdGx5L2xpbmVhcmx5IHJhdGhlciB0aGFuIGFyb3VuZC4gU28gdGhlIGxlbmd0aCB3b3VsZCBiZSB2ZXJ5IHNob3J0IGluIHRoZSBtaWRkbGUgb2YgdGhlIHR3ZWVuLlxuZXhwb3J0IGZ1bmN0aW9uIGNwQ29vcmRzVG9BbmdsZXMoc2VnbWVudCwgY29weSkge1xuXHR2YXIgcmVzdWx0ID0gY29weSA/IHNlZ21lbnQuc2xpY2UoMCkgOiBzZWdtZW50LFxuXHRcdHgsIHksIGk7XG5cdGZvciAoaSA9IDA7IGkgPCBzZWdtZW50Lmxlbmd0aDsgaSs9Nikge1xuXHRcdHggPSBzZWdtZW50W2krMl0gLSBzZWdtZW50W2ldO1xuXHRcdHkgPSBzZWdtZW50W2krM10gLSBzZWdtZW50W2krMV07XG5cdFx0cmVzdWx0W2krMl0gPSBNYXRoLmF0YW4yKHksIHgpO1xuXHRcdHJlc3VsdFtpKzNdID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdHggPSBzZWdtZW50W2krNl0gLSBzZWdtZW50W2krNF07XG5cdFx0eSA9IHNlZ21lbnRbaSs3XSAtIHNlZ21lbnRbaSs1XTtcblx0XHRyZXN1bHRbaSs0XSA9IE1hdGguYXRhbjIoeSwgeCk7XG5cdFx0cmVzdWx0W2krNV0gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gdGFrZXMgYSBzZWdtZW50IHRoYXQgd2FzIGNvbnZlcnRlZCB3aXRoIGNwQ29vcmRzVG9BbmdsZXMoKSB0byBoYXZlIGFuZ2xlcyBhbmQgbGVuZ3RocyBpbnN0ZWFkIG9mIGNvb3JkaW5hdGVzIGZvciB0aGUgY29udHJvbCBwb2ludHMsIGFuZCBjb252ZXJ0cyBpdCBCQUNLIGludG8gY29vcmRpbmF0ZXMuXG5leHBvcnQgZnVuY3Rpb24gY3BBbmdsZXNUb0Nvb3JkcyhzZWdtZW50LCBjb3B5KSB7XG5cdHZhciByZXN1bHQgPSBjb3B5ID8gc2VnbWVudC5zbGljZSgwKSA6IHNlZ21lbnQsXG5cdFx0bGVuZ3RoID0gc2VnbWVudC5sZW5ndGgsXG5cdFx0cm5kID0gMTAwMCxcblx0XHRhbmdsZSwgbCwgaSwgajtcblx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSs9Nikge1xuXHRcdGFuZ2xlID0gc2VnbWVudFtpKzJdO1xuXHRcdGwgPSBzZWdtZW50W2krM107IC8vbGVuZ3RoXG5cdFx0cmVzdWx0W2krMl0gPSAoKChzZWdtZW50W2ldICsgTWF0aC5jb3MoYW5nbGUpICogbCkgKiBybmQpIHwgMCkgLyBybmQ7XG5cdFx0cmVzdWx0W2krM10gPSAoKChzZWdtZW50W2krMV0gKyBNYXRoLnNpbihhbmdsZSkgKiBsKSAqIHJuZCkgfCAwKSAvIHJuZDtcblx0XHRhbmdsZSA9IHNlZ21lbnRbaSs0XTtcblx0XHRsID0gc2VnbWVudFtpKzVdOyAvL2xlbmd0aFxuXHRcdHJlc3VsdFtpKzRdID0gKCgoc2VnbWVudFtpKzZdIC0gTWF0aC5jb3MoYW5nbGUpICogbCkgKiBybmQpIHwgMCkgLyBybmQ7XG5cdFx0cmVzdWx0W2krNV0gPSAoKChzZWdtZW50W2krN10gLSBNYXRoLnNpbihhbmdsZSkgKiBsKSAqIHJuZCkgfCAwKSAvIHJuZDtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vL2FkZHMgYW4gXCJpc1Ntb290aFwiIGFycmF5IHRvIGVhY2ggc2VnbWVudCBhbmQgcG9wdWxhdGVzIGl0IHdpdGggYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgaXQncyBzbW9vdGggKHRoZSBjb250cm9sIHBvaW50cyBoYXZlIGJhc2ljYWxseSB0aGUgc2FtZSBzbG9wZSkuIEZvciBhbnkgc21vb3RoIGNvbnRyb2wgcG9pbnRzLCBpdCBjb252ZXJ0cyB0aGUgY29vcmRpbmF0ZXMgaW50byBhbmdsZSAoeCwgaW4gcmFkaWFucykgYW5kIGxlbmd0aCAoeSkgYW5kIHB1dHMgdGhlbSBpbnRvIHRoZSBzYW1lIGluZGV4IHZhbHVlIGluIGEgc21vb3RoRGF0YSBhcnJheS5cbmV4cG9ydCBmdW5jdGlvbiBwb3B1bGF0ZVNtb290aERhdGEocmF3UGF0aCkge1xuXHRsZXQgaiA9IHJhd1BhdGgubGVuZ3RoLFxuXHRcdHNtb290aCwgc2VnbWVudCwgeCwgeSwgeDIsIHkyLCBpLCBsLCBhLCBhMiwgaXNTbW9vdGgsIHNtb290aERhdGE7XG5cdHdoaWxlICgtLWogPiAtMSkge1xuXHRcdHNlZ21lbnQgPSByYXdQYXRoW2pdO1xuXHRcdGlzU21vb3RoID0gc2VnbWVudC5pc1Ntb290aCA9IHNlZ21lbnQuaXNTbW9vdGggfHwgWzAsIDAsIDAsIDBdO1xuXHRcdHNtb290aERhdGEgPSBzZWdtZW50LnNtb290aERhdGEgPSBzZWdtZW50LnNtb290aERhdGEgfHwgWzAsIDAsIDAsIDBdO1xuXHRcdGlzU21vb3RoLmxlbmd0aCA9IDQ7XG5cdFx0bCA9IHNlZ21lbnQubGVuZ3RoIC0gMjtcblx0XHRmb3IgKGkgPSA2OyBpIDwgbDsgaSArPSA2KSB7XG5cdFx0XHR4ID0gc2VnbWVudFtpXSAtIHNlZ21lbnRbaSAtIDJdO1xuXHRcdFx0eSA9IHNlZ21lbnRbaSArIDFdIC0gc2VnbWVudFtpIC0gMV07XG5cdFx0XHR4MiA9IHNlZ21lbnRbaSArIDJdIC0gc2VnbWVudFtpXTtcblx0XHRcdHkyID0gc2VnbWVudFtpICsgM10gLSBzZWdtZW50W2kgKyAxXTtcblx0XHRcdGEgPSBfYXRhbjIoeSwgeCk7XG5cdFx0XHRhMiA9IF9hdGFuMih5MiwgeDIpO1xuXHRcdFx0c21vb3RoID0gKE1hdGguYWJzKGEgLSBhMikgPCAwLjA5KTtcblx0XHRcdGlmIChzbW9vdGgpIHtcblx0XHRcdFx0c21vb3RoRGF0YVtpIC0gMl0gPSBhO1xuXHRcdFx0XHRzbW9vdGhEYXRhW2kgKyAyXSA9IGEyO1xuXHRcdFx0XHRzbW9vdGhEYXRhW2kgLSAxXSA9IF9zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdFx0XHRzbW9vdGhEYXRhW2kgKyAzXSA9IF9zcXJ0KHgyICogeDIgKyB5MiAqIHkyKTtcblx0XHRcdH1cblx0XHRcdGlzU21vb3RoLnB1c2goc21vb3RoLCBzbW9vdGgsIDAsIDAsIHNtb290aCwgc21vb3RoKTtcblx0XHR9XG5cdFx0Ly9pZiB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnRzIGFyZSBpZGVudGljYWwsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgc21vb3RoIHRyYW5zaXRpb24uIFdlIG11c3QgaGFuZGxlIHRoaXMgYSBiaXQgZGlmZmVyZW50bHkgZHVlIHRvIHRoZWlyIHBvc2l0aW9ucyBpbiB0aGUgYXJyYXkuXG5cdFx0aWYgKHNlZ21lbnRbbF0gPT09IHNlZ21lbnRbMF0gJiYgc2VnbWVudFtsKzFdID09PSBzZWdtZW50WzFdKSB7XG5cdFx0XHR4ID0gc2VnbWVudFswXSAtIHNlZ21lbnRbbC0yXTtcblx0XHRcdHkgPSBzZWdtZW50WzFdIC0gc2VnbWVudFtsLTFdO1xuXHRcdFx0eDIgPSBzZWdtZW50WzJdIC0gc2VnbWVudFswXTtcblx0XHRcdHkyID0gc2VnbWVudFszXSAtIHNlZ21lbnRbMV07XG5cdFx0XHRhID0gX2F0YW4yKHksIHgpO1xuXHRcdFx0YTIgPSBfYXRhbjIoeTIsIHgyKTtcblx0XHRcdGlmIChNYXRoLmFicyhhIC0gYTIpIDwgMC4wOSkge1xuXHRcdFx0XHRzbW9vdGhEYXRhW2wtMl0gPSBhO1xuXHRcdFx0XHRzbW9vdGhEYXRhWzJdID0gYTI7XG5cdFx0XHRcdHNtb290aERhdGFbbC0xXSA9IF9zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdFx0XHRzbW9vdGhEYXRhWzNdID0gX3NxcnQoeDIgKiB4MiArIHkyICogeTIpO1xuXHRcdFx0XHRpc1Ntb290aFtsLTJdID0gaXNTbW9vdGhbbC0xXSA9IHRydWU7IC8vZG9uJ3QgY2hhbmdlIGluZGV4ZXMgMiBhbmQgMyBiZWNhdXNlIHdlJ2xsIHRyaWdnZXIgZXZlcnl0aGluZyBmcm9tIHRoZSBFTkQsIGFuZCB0aGlzIHdpbGwgb3B0aW1pemUgZmlsZSBzaXplIGEgYml0LlxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmF3UGF0aDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb2ludFRvU2NyZWVuKHN2Z0VsZW1lbnQsIHBvaW50KSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgeyAvL2J5IGRlZmF1bHQsIHRha2UgdGhlIGZpcnN0IHNldCBvZiBjb29yZGluYXRlcyBpbiB0aGUgcGF0aCBhcyB0aGUgcG9pbnRcblx0XHRsZXQgcmF3UGF0aCA9IGdldFJhd1BhdGgoc3ZnRWxlbWVudCk7XG5cdFx0cG9pbnQgPSBzdmdFbGVtZW50Lm93bmVyU1ZHRWxlbWVudC5jcmVhdGVTVkdQb2ludCgpO1xuXHRcdHBvaW50LnggPSByYXdQYXRoWzBdWzBdO1xuXHRcdHBvaW50LnkgPSByYXdQYXRoWzBdWzFdO1xuXHR9XG5cdHJldHVybiBwb2ludC5tYXRyaXhUcmFuc2Zvcm0oc3ZnRWxlbWVudC5nZXRTY3JlZW5DVE0oKSk7XG59XG5cbiovIl0sIm5hbWVzIjpbIl9zdmdQYXRoRXhwIiwiX251bWJlcnNFeHAiLCJfc2NpZW50aWZpYyIsIl9zZWxlY3RvckV4cCIsIl9ERUcyUkFEIiwiTWF0aCIsIlBJIiwiX1JBRDJERUciLCJfc2luIiwic2luIiwiX2NvcyIsImNvcyIsIl9hYnMiLCJhYnMiLCJfc3FydCIsInNxcnQiLCJfYXRhbjIiLCJhdGFuMiIsIl9sYXJnZU51bSIsIl9pc1N0cmluZyIsInZhbHVlIiwiX2lzTnVtYmVyIiwiX2lzVW5kZWZpbmVkIiwiX3RlbXAiLCJfdGVtcDIiLCJfcm91bmRpbmdOdW0iLCJfd3JhcFByb2dyZXNzIiwicHJvZ3Jlc3MiLCJyb3VuZCIsIl9yb3VuZCIsIl9yb3VuZFByZWNpc2UiLCJfc3BsaXRTZWdtZW50IiwicmF3UGF0aCIsInNlZ0luZGV4IiwiaSIsInQiLCJzZWdtZW50Iiwic2hpZnQiLCJzdWJkaXZpZGVTZWdtZW50IiwibGVuZ3RoIiwic3BsaWNlIiwic2xpY2UiLCJfZ2V0U2FtcGxlSW5kZXgiLCJzYW1wbGVzIiwibCIsIl9yZXZlcnNlUmF3UGF0aCIsInNraXBPdXRlciIsInJldmVyc2UiLCJyZXZlcnNlZCIsInJldmVyc2VTZWdtZW50IiwiX2NvcHlNZXRhRGF0YSIsInNvdXJjZSIsImNvcHkiLCJ0b3RhbExlbmd0aCIsImxvb2t1cCIsIm1pbkxlbmd0aCIsInJlc29sdXRpb24iLCJ0b3RhbFBvaW50cyIsIl9hcHBlbmRPck1lcmdlIiwiaW5kZXgiLCJwcmV2U2VnIiwiY29uY2F0IiwiX2Jlc3REaXN0YW5jZSIsImdldFJhd1BhdGgiLCJ0ZXN0IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiZSIsImdldEF0dHJpYnV0ZSIsIl9nc1BhdGgiLCJfZGlydHkiLCJzdHJpbmdUb1Jhd1BhdGgiLCJjb25zb2xlIiwid2FybiIsImNvcHlSYXdQYXRoIiwiYSIsInkiLCJfY3JlYXRlUGF0aCIsImlnbm9yZSIsInBhdGgiLCJjcmVhdGVFbGVtZW50TlMiLCJhdHRyIiwiY2FsbCIsImF0dHJpYnV0ZXMiLCJuYW1lIiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImluZGV4T2YiLCJzZXRBdHRyaWJ1dGVOUyIsIm5vZGVWYWx1ZSIsIl90eXBlQXR0cnMiLCJyZWN0IiwiY2lyY2xlIiwiZWxsaXBzZSIsImxpbmUiLCJfYXR0clRvT2JqIiwiYXR0cnMiLCJwcm9wcyIsInNwbGl0Iiwib2JqIiwiY29udmVydFRvUGF0aCIsImVsZW1lbnQiLCJzd2FwIiwidHlwZSIsInRhZ05hbWUiLCJjaXJjIiwiZGF0YSIsIngiLCJyIiwicnkiLCJyY2lyYyIsInJ5Y2lyYyIsInBvaW50cyIsInciLCJoIiwieDIiLCJ4MyIsIng0IiwieDUiLCJ4NiIsInkyIiwieTMiLCJ5NCIsInk1IiwieTYiLCJnZXRCQm94IiwicngiLCJ3aWR0aCIsImhlaWdodCIsImpvaW4iLCJjeCIsImN5IiwieDEiLCJ5MSIsIm1hdGNoIiwic2V0QXR0cmlidXRlIiwicmF3UGF0aFRvU3RyaW5nIiwiX2dzUmF3UGF0aCIsInBhcmVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJyZW1vdmVDaGlsZCIsImdldFJvdGF0aW9uQXRQcm9ncmVzcyIsImQiLCJnZXRQcm9ncmVzc0RhdGEiLCJnZXRSb3RhdGlvbkF0QmV6aWVyVCIsImIiLCJjIiwic2xpY2VSYXdQYXRoIiwic3RhcnQiLCJlbmQiLCJsb29wcyIsIm1heCIsIm9mZnNldCIsIm1pbiIsImNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyIsIndyYXAiLCJzIiwiZVNlZyIsInNTZWciLCJlU2VnSW5kZXgiLCJzU2VnSW5kZXgiLCJlaSIsInNpIiwic2FtZVNlZ21lbnQiLCJzYW1lQmV6aWVyIiwid3JhcHNCZWhpbmQiLCJzU2hpZnQiLCJlU2hpZnQiLCJ0b3RhbFNlZ21lbnRzIiwiaiIsImFuZ2xlIiwicHVzaCIsIm1lYXN1cmVTZWdtZW50Iiwic3RhcnRJbmRleCIsImJlemllclF0eSIsImluYyIsImVuZEluZGV4Iiwic2FtcGxlc0luZGV4IiwicHJldkxlbmd0aCIsInhkIiwieGQxIiwieWQiLCJ5ZDEiLCJpbnYiLCJsZW5ndGhJbmRleCIsInNlZ0xlbmd0aCIsInBhdGhMZW5ndGgiLCJheCIsImF5IiwiY3AxeCIsImNwMXkiLCJjcDJ4IiwiY3AyeSIsImJ4IiwiYnkiLCJ4MWEiLCJ5MWEiLCJ4MmEiLCJ5MmEiLCJkZWNvcmF0ZWUiLCJwdXNoVG9OZXh0SWZBdEVuZCIsImdldFBvc2l0aW9uT25QYXRoIiwiaW5jbHVkZUFuZ2xlIiwicG9pbnQiLCJyZXN1bHQiLCJ0cmFuc2Zvcm1SYXdQYXRoIiwidHgiLCJ0eSIsImFyY1RvU2VnbWVudCIsImxhc3RYIiwibGFzdFkiLCJsYXJnZUFyY0ZsYWciLCJzd2VlcEZsYWciLCJhbmdsZVJhZCIsImNvc0FuZ2xlIiwic2luQW5nbGUiLCJUV09QSSIsImR4MiIsImR5MiIsIngxX3NxIiwieTFfc3EiLCJyYWRpaUNoZWNrIiwicnhfc3EiLCJyeV9zcSIsInNxIiwiY29lZiIsImN4MSIsImN5MSIsInN4MiIsInN5MiIsInV4IiwidXkiLCJ2eCIsInZ5IiwidGVtcCIsImFuZ2xlU3RhcnQiLCJhY29zIiwiYW5nbGVFeHRlbnQiLCJpc05hTiIsInNlZ21lbnRzIiwiY2VpbCIsImFuZ2xlSW5jcmVtZW50IiwiY29udHJvbExlbmd0aCIsIm1hIiwibWIiLCJtYyIsIm1kIiwicmVwbGFjZSIsIm0iLCJuIiwicmVsYXRpdmVYIiwicmVsYXRpdmVZIiwidHdvVGhpcmRzIiwiZWxlbWVudHMiLCJlcnJvck1lc3NhZ2UiLCJjb21tYW5kIiwiaXNSZWxhdGl2ZSIsInN0YXJ0WCIsInN0YXJ0WSIsImRpZlgiLCJkaWZZIiwiYmV6aWVycyIsInByZXZDb21tYW5kIiwiZmxhZzEiLCJmbGFnMiIsInN4Iiwic3kiLCJleCIsImV5IiwibG9nIiwidG9VcHBlckNhc2UiLCJjbG9zZWQiLCJzdWJzdHIiLCJjaGFyQXQiLCJwb3AiLCJiZXppZXJUb1BvaW50cyIsInRocmVzaG9sZCIsIngxMiIsInkxMiIsIngyMyIsInkyMyIsIngzNCIsInkzNCIsIngxMjMiLCJ5MTIzIiwieDIzNCIsInkyMzQiLCJ4MTIzNCIsInkxMjM0IiwiZHgiLCJkeSIsImQyIiwiZDMiLCJmbGF0UG9pbnRzVG9TZWdtZW50IiwiY3VydmluZXNzIiwicG9pbnRzVG9TZWdtZW50IiwibmV4dFgiLCJuZXh0WSIsInByZXZYIiwicHJldlkiLCJkeDEiLCJkeTEiLCJyMSIsInIyIiwicjMiLCJ0bCIsIm14MSIsIm14MiIsIm14bSIsIm15MSIsIm15MiIsIm15bSIsInVuc2hpZnQiLCJwb3ciLCJwb2ludFRvU2VnRGlzdCIsInNpbXBsaWZ5U3RlcCIsImZpcnN0IiwibGFzdCIsInRvbGVyYW5jZSIsInNpbXBsaWZpZWQiLCJtYXhTcURpc3QiLCJmaXJzdFgiLCJmaXJzdFkiLCJzaW1wbGlmeVBvaW50cyIsInBhcnNlRmxvYXQiLCJnZXRDbG9zZXN0UHJvZ3Jlc3NPbkJlemllciIsIml0ZXJhdGlvbnMiLCJweCIsInB5Iiwic2xpY2VzIiwieDAiLCJ5MCIsImJlc3QiLCJnZXRDbG9zZXN0RGF0YSIsImNsb3Nlc3QiLCJiZXN0RGlzdGFuY2UiLCJzdWJkaXZpZGVTZWdtZW50TmVhciIsImJlc3RUIiwiYmVzdFNlZ21lbnRJbmRleCIsInNsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/paths.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/strings.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/strings.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   emojiExp: function() { return /* binding */ emojiExp; },\n/* harmony export */   emojiSafeSplit: function() { return /* binding */ emojiSafeSplit; },\n/* harmony export */   getText: function() { return /* binding */ getText; },\n/* harmony export */   splitInnerHTML: function() { return /* binding */ splitInnerHTML; }\n/* harmony export */ });\n/*!\n * strings: 3.12.5\n * https://gsap.com\n *\n * Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var _trimExp = /(?:^\\s+|\\s+$)/g;\nvar emojiExp = /([\\uD800-\\uDBFF][\\uDC00-\\uDFFF](?:[\\u200D\\uFE0F][\\uD800-\\uDBFF][\\uDC00-\\uDFFF]){2,}|\\uD83D\\uDC69(?:\\u200D(?:(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC67|(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC66)|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]\\uFE0F|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC6F\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3C-\\uDD3E\\uDDD6-\\uDDDF])\\u200D[\\u2640\\u2642]\\uFE0F|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642])\\uFE0F|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\uD83D\\uDC69\\u200D[\\u2695\\u2696\\u2708]|\\uD83D\\uDC68(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708]))\\uFE0F|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83D\\uDC69\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69]))|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67)\\uDB40\\uDC7F|\\uD83D\\uDC68(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92])|(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]))|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDD1-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\u200D(?:(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC67|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC66)|\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC69\\uDC6E\\uDC70-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3D\\uDD3E\\uDDD1-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])?|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDEEB\\uDEEC\\uDEF4-\\uDEF8]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD4C\\uDD50-\\uDD6B\\uDD80-\\uDD97\\uDDC0\\uDDD0-\\uDDE6])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEF8]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD4C\\uDD50-\\uDD6B\\uDD80-\\uDD97\\uDDC0\\uDDD0-\\uDDE6])\\uFE0F)/;\nfunction getText(e) {\n    var type = e.nodeType, result = \"\";\n    if (type === 1 || type === 9 || type === 11) {\n        if (typeof e.textContent === \"string\") {\n            return e.textContent;\n        } else {\n            for(e = e.firstChild; e; e = e.nextSibling){\n                result += getText(e);\n            }\n        }\n    } else if (type === 3 || type === 4) {\n        return e.nodeValue;\n    }\n    return result;\n}\nfunction splitInnerHTML(element, delimiter, trim, preserveSpaces) {\n    var node = element.firstChild, result = [], s;\n    while(node){\n        if (node.nodeType === 3) {\n            s = (node.nodeValue + \"\").replace(/^\\n+/g, \"\");\n            if (!preserveSpaces) {\n                s = s.replace(/\\s+/g, \" \");\n            }\n            result.push.apply(result, emojiSafeSplit(s, delimiter, trim, preserveSpaces));\n        } else if ((node.nodeName + \"\").toLowerCase() === \"br\") {\n            result[result.length - 1] += \"<br>\";\n        } else {\n            result.push(node.outerHTML);\n        }\n        node = node.nextSibling;\n    }\n    s = result.length;\n    while(s--){\n        result[s] === \"&\" && result.splice(s, 1, \"&amp;\");\n    }\n    return result;\n}\n/*\n//smaller kb version that only handles the simpler emoji's, which is often perfectly adequate.\n\nlet _emoji = \"[\\uE000-\\uF8FF]|\\uD83C[\\uDC00-\\uDFFF]|\\uD83D[\\uDC00-\\uDFFF]|[\\u2694-\\u2697]|\\uD83E[\\uDD10-\\uDD5D]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]\",\n\t_emojiExp = new RegExp(_emoji),\n\t_emojiAndCharsExp = new RegExp(_emoji + \"|.\", \"g\"),\n\t_emojiSafeSplit = (text, delimiter, trim) => {\n\t\tif (trim) {\n\t\t\ttext = text.replace(_trimExp, \"\");\n\t\t}\n\t\treturn ((delimiter === \"\" || !delimiter) && _emojiExp.test(text)) ? text.match(_emojiAndCharsExp) : text.split(delimiter || \"\");\n\t};\n */ function emojiSafeSplit(text, delimiter, trim, preserveSpaces) {\n    text += \"\"; // make sure it's cast as a string. Someone may pass in a number.\n    trim && (text = text.trim ? text.trim() : text.replace(_trimExp, \"\")); // IE9 and earlier compatibility\n    if (delimiter && delimiter !== \"\") {\n        return text.replace(/>/g, \"&gt;\").replace(/</g, \"&lt;\").split(delimiter);\n    }\n    var result = [], l = text.length, i = 0, j, character;\n    for(; i < l; i++){\n        character = text.charAt(i);\n        if (character.charCodeAt(0) >= 0xD800 && character.charCodeAt(0) <= 0xDBFF || text.charCodeAt(i + 1) >= 0xFE00 && text.charCodeAt(i + 1) <= 0xFE0F) {\n            //special emoji characters use 2 or 4 unicode characters that we must keep together.\n            j = ((text.substr(i, 12).split(emojiExp) || [])[1] || \"\").length || 2;\n            character = text.substr(i, j);\n            result.emoji = 1;\n            i += j - 1;\n        }\n        result.push(character === \">\" ? \"&gt;\" : character === \"<\" ? \"&lt;\" : preserveSpaces && character === \" \" && (text.charAt(i - 1) === \" \" || text.charAt(i + 1) === \" \") ? \"&nbsp;\" : character);\n    }\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9nc2FwQDMuMTIuNS9ub2RlX21vZHVsZXMvZ3NhcC91dGlscy9zdHJpbmdzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFRQSxHQUVBLGtCQUFrQixHQUNsQixJQUFJQSxXQUFXO0FBQ1IsSUFBSUMsV0FBVyw0Z09BQTRnTztBQUMzaE8sU0FBU0MsUUFBUUMsQ0FBQztJQUN2QixJQUFJQyxPQUFPRCxFQUFFRSxRQUFRLEVBQ2pCQyxTQUFTO0lBRWIsSUFBSUYsU0FBUyxLQUFLQSxTQUFTLEtBQUtBLFNBQVMsSUFBSTtRQUMzQyxJQUFJLE9BQU9ELEVBQUVJLFdBQVcsS0FBSyxVQUFVO1lBQ3JDLE9BQU9KLEVBQUVJLFdBQVc7UUFDdEIsT0FBTztZQUNMLElBQUtKLElBQUlBLEVBQUVLLFVBQVUsRUFBRUwsR0FBR0EsSUFBSUEsRUFBRU0sV0FBVyxDQUFFO2dCQUMzQ0gsVUFBVUosUUFBUUM7WUFDcEI7UUFDRjtJQUNGLE9BQU8sSUFBSUMsU0FBUyxLQUFLQSxTQUFTLEdBQUc7UUFDbkMsT0FBT0QsRUFBRU8sU0FBUztJQUNwQjtJQUVBLE9BQU9KO0FBQ1Q7QUFDTyxTQUFTSyxlQUFlQyxPQUFPLEVBQUVDLFNBQVMsRUFBRUMsSUFBSSxFQUFFQyxjQUFjO0lBQ3JFLElBQUlDLE9BQU9KLFFBQVFKLFVBQVUsRUFDekJGLFNBQVMsRUFBRSxFQUNYVztJQUVKLE1BQU9ELEtBQU07UUFDWCxJQUFJQSxLQUFLWCxRQUFRLEtBQUssR0FBRztZQUN2QlksSUFBSSxDQUFDRCxLQUFLTixTQUFTLEdBQUcsRUFBQyxFQUFHUSxPQUFPLENBQUMsU0FBUztZQUUzQyxJQUFJLENBQUNILGdCQUFnQjtnQkFDbkJFLElBQUlBLEVBQUVDLE9BQU8sQ0FBQyxRQUFRO1lBQ3hCO1lBRUFaLE9BQU9hLElBQUksQ0FBQ0MsS0FBSyxDQUFDZCxRQUFRZSxlQUFlSixHQUFHSixXQUFXQyxNQUFNQztRQUMvRCxPQUFPLElBQUksQ0FBQ0MsS0FBS00sUUFBUSxHQUFHLEVBQUMsRUFBR0MsV0FBVyxPQUFPLE1BQU07WUFDdERqQixNQUFNLENBQUNBLE9BQU9rQixNQUFNLEdBQUcsRUFBRSxJQUFJO1FBQy9CLE9BQU87WUFDTGxCLE9BQU9hLElBQUksQ0FBQ0gsS0FBS1MsU0FBUztRQUM1QjtRQUVBVCxPQUFPQSxLQUFLUCxXQUFXO0lBQ3pCO0lBRUFRLElBQUlYLE9BQU9rQixNQUFNO0lBRWpCLE1BQU9QLElBQUs7UUFDVlgsTUFBTSxDQUFDVyxFQUFFLEtBQUssT0FBT1gsT0FBT29CLE1BQU0sQ0FBQ1QsR0FBRyxHQUFHO0lBQzNDO0lBRUEsT0FBT1g7QUFDVDtBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUVNLFNBQVNlLGVBQWVNLElBQUksRUFBRWQsU0FBUyxFQUFFQyxJQUFJLEVBQUVDLGNBQWM7SUFDbEVZLFFBQVEsSUFBSSxpRUFBaUU7SUFFN0ViLFFBQVNhLENBQUFBLE9BQU9BLEtBQUtiLElBQUksR0FBR2EsS0FBS2IsSUFBSSxLQUFLYSxLQUFLVCxPQUFPLENBQUNsQixVQUFVLEdBQUUsR0FBSSxnQ0FBZ0M7SUFFdkcsSUFBSWEsYUFBYUEsY0FBYyxJQUFJO1FBQ2pDLE9BQU9jLEtBQUtULE9BQU8sQ0FBQyxNQUFNLFFBQVFBLE9BQU8sQ0FBQyxNQUFNLFFBQVFVLEtBQUssQ0FBQ2Y7SUFDaEU7SUFFQSxJQUFJUCxTQUFTLEVBQUUsRUFDWHVCLElBQUlGLEtBQUtILE1BQU0sRUFDZk0sSUFBSSxHQUNKQyxHQUNBQztJQUVKLE1BQU9GLElBQUlELEdBQUdDLElBQUs7UUFDakJFLFlBQVlMLEtBQUtNLE1BQU0sQ0FBQ0g7UUFFeEIsSUFBSUUsVUFBVUUsVUFBVSxDQUFDLE1BQU0sVUFBVUYsVUFBVUUsVUFBVSxDQUFDLE1BQU0sVUFBVVAsS0FBS08sVUFBVSxDQUFDSixJQUFJLE1BQU0sVUFBVUgsS0FBS08sVUFBVSxDQUFDSixJQUFJLE1BQU0sUUFBUTtZQUNsSixvRkFBb0Y7WUFDcEZDLElBQUksQ0FBQyxDQUFDSixLQUFLUSxNQUFNLENBQUNMLEdBQUcsSUFBSUYsS0FBSyxDQUFDM0IsYUFBYSxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBQyxFQUFHdUIsTUFBTSxJQUFJO1lBQ3BFUSxZQUFZTCxLQUFLUSxNQUFNLENBQUNMLEdBQUdDO1lBQzNCekIsT0FBTzhCLEtBQUssR0FBRztZQUNmTixLQUFLQyxJQUFJO1FBQ1g7UUFFQXpCLE9BQU9hLElBQUksQ0FBQ2EsY0FBYyxNQUFNLFNBQVNBLGNBQWMsTUFBTSxTQUFTakIsa0JBQWtCaUIsY0FBYyxPQUFRTCxDQUFBQSxLQUFLTSxNQUFNLENBQUNILElBQUksT0FBTyxPQUFPSCxLQUFLTSxNQUFNLENBQUNILElBQUksT0FBTyxHQUFFLElBQUssV0FBV0U7SUFDdkw7SUFFQSxPQUFPMUI7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vZ3NhcEAzLjEyLjUvbm9kZV9tb2R1bGVzL2dzYXAvdXRpbHMvc3RyaW5ncy5qcz8wNzIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogc3RyaW5nczogMy4xMi41XG4gKiBodHRwczovL2dzYXAuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyNCwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9nc2FwLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHU0FQIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIF90cmltRXhwID0gLyg/Ol5cXHMrfFxccyskKS9nO1xuZXhwb3J0IHZhciBlbW9qaUV4cCA9IC8oW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXSg/OltcXHUyMDBEXFx1RkUwRl1bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdKXsyLH18XFx1RDgzRFxcdURDNjkoPzpcXHUyMDBEKD86KD86XFx1RDgzRFxcdURDNjlcXHUyMDBEKT9cXHVEODNEXFx1REM2N3woPzpcXHVEODNEXFx1REM2OVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY2KXxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFxcdUQ4M0RcXHVEQzY5XFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzY5XFx1MjAwRCk/XFx1RDgzRFxcdURDNjZcXHUyMDBEXFx1RDgzRFxcdURDNjZ8XFx1RDgzRFxcdURDNjlcXHUyMDBEKD86XFx1RDgzRFxcdURDNjlcXHUyMDBEKT9cXHVEODNEXFx1REM2N1xcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8XFx1RDgzQ1xcdURGRjNcXHVGRTBGXFx1MjAwRFxcdUQ4M0NcXHVERjA4fCg/OlxcdUQ4M0NbXFx1REZDM1xcdURGQzRcXHVERkNBXXxcXHVEODNEW1xcdURDNkVcXHVEQzcxXFx1REM3M1xcdURDNzdcXHVEQzgxXFx1REM4MlxcdURDODZcXHVEQzg3XFx1REU0NS1cXHVERTQ3XFx1REU0QlxcdURFNERcXHVERTRFXFx1REVBM1xcdURFQjQtXFx1REVCNl18XFx1RDgzRVtcXHVERDI2XFx1REQzNy1cXHVERDM5XFx1REQzRFxcdUREM0VcXHVEREQ2LVxcdURERERdKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSlcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEZ8XFx1RDgzRFxcdURDNjkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdKXwoPzpcXHVEODNDW1xcdURGQzNcXHVERkM0XFx1REZDQV18XFx1RDgzRFtcXHVEQzZFXFx1REM2RlxcdURDNzFcXHVEQzczXFx1REM3N1xcdURDODFcXHVEQzgyXFx1REM4NlxcdURDODdcXHVERTQ1LVxcdURFNDdcXHVERTRCXFx1REU0RFxcdURFNEVcXHVERUEzXFx1REVCNC1cXHVERUI2XXxcXHVEODNFW1xcdUREMjZcXHVERDM3LVxcdUREMzlcXHVERDNDLVxcdUREM0VcXHVEREQ2LVxcdUREREZdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRnxcXHVEODNDXFx1RERGRFxcdUQ4M0NcXHVEREYwfFxcdUQ4M0NcXHVEREY2XFx1RDgzQ1xcdURERTZ8XFx1RDgzQ1xcdURERjRcXHVEODNDXFx1RERGMnxcXHVEODNDXFx1RERFOSg/OlxcdUQ4M0NbXFx1RERFQVxcdURERUNcXHVEREVGXFx1RERGMFxcdURERjJcXHVEREY0XFx1RERGRl0pfFxcdUQ4M0NcXHVEREY3KD86XFx1RDgzQ1tcXHVEREVBXFx1RERGNFxcdURERjhcXHVEREZBXFx1RERGQ10pfFxcdUQ4M0NcXHVEREU4KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERTlcXHVEREVCLVxcdURERUVcXHVEREYwLVxcdURERjVcXHVEREY3XFx1RERGQS1cXHVEREZGXSl8KD86XFx1MjZGOXxcXHVEODNDW1xcdURGQ0JcXHVERkNDXXxcXHVEODNEXFx1REQ3NSkoPzpcXHVGRTBGXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml18KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdKVxcdUZFMEZ8KD86XFx1RDgzRFxcdURDNDFcXHVGRTBGXFx1MjAwRFxcdUQ4M0RcXHVEREU4fFxcdUQ4M0RcXHVEQzY5KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNEXFx1REM2OVxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNEXFx1REM2OCg/Oig/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSlcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdKSlcXHVGRTBGfFxcdUQ4M0NcXHVEREYyKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOC1cXHVEREVEXFx1RERGMC1cXHVEREZGXSl8XFx1RDgzRFxcdURDNjlcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pfFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKSl8XFx1RDgzQ1xcdURERjEoPzpcXHVEODNDW1xcdURERTYtXFx1RERFOFxcdURERUVcXHVEREYwXFx1RERGNy1cXHVEREZCXFx1RERGRV0pfFxcdUQ4M0NcXHVEREVGKD86XFx1RDgzQ1tcXHVEREVBXFx1RERGMlxcdURERjRcXHVEREY1XSl8XFx1RDgzQ1xcdURERUQoPzpcXHVEODNDW1xcdURERjBcXHVEREYyXFx1RERGM1xcdURERjdcXHVEREY5XFx1RERGQV0pfFxcdUQ4M0NcXHVEREVCKD86XFx1RDgzQ1tcXHVEREVFLVxcdURERjBcXHVEREYyXFx1RERGNFxcdURERjddKXxbI1xcKjAtOV1cXHVGRTBGXFx1MjBFM3xcXHVEODNDXFx1RERFNyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERTdcXHVEREU5LVxcdURERUZcXHVEREYxLVxcdURERjRcXHVEREY2LVxcdURERjlcXHVEREZCXFx1RERGQ1xcdURERkVcXHVEREZGXSl8XFx1RDgzQ1xcdURERTYoPzpcXHVEODNDW1xcdURERTgtXFx1RERFQ1xcdURERUVcXHVEREYxXFx1RERGMlxcdURERjRcXHVEREY2LVxcdURERkFcXHVEREZDXFx1RERGRFxcdURERkZdKXxcXHVEODNDXFx1RERGRig/OlxcdUQ4M0NbXFx1RERFNlxcdURERjJcXHVEREZDXSl8XFx1RDgzQ1xcdURERjUoPzpcXHVEODNDW1xcdURERTZcXHVEREVBLVxcdURERURcXHVEREYwLVxcdURERjNcXHVEREY3LVxcdURERjlcXHVEREZDXFx1RERGRV0pfFxcdUQ4M0NcXHVEREZCKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUFcXHVEREVDXFx1RERFRVxcdURERjNcXHVEREZBXSl8XFx1RDgzQ1xcdURERjMoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQS1cXHVEREVDXFx1RERFRVxcdURERjFcXHVEREY0XFx1RERGNVxcdURERjdcXHVEREZBXFx1RERGRl0pfFxcdUQ4M0NcXHVERkY0XFx1REI0MFxcdURDNjdcXHVEQjQwXFx1REM2Mig/OlxcdURCNDBcXHVEQzc3XFx1REI0MFxcdURDNkNcXHVEQjQwXFx1REM3M3xcXHVEQjQwXFx1REM3M1xcdURCNDBcXHVEQzYzXFx1REI0MFxcdURDNzR8XFx1REI0MFxcdURDNjVcXHVEQjQwXFx1REM2RVxcdURCNDBcXHVEQzY3KVxcdURCNDBcXHVEQzdGfFxcdUQ4M0RcXHVEQzY4KD86XFx1MjAwRCg/OlxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRFxcdURDNjh8KD86KD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1MjAwRCk/XFx1RDgzRFxcdURDNjZcXHUyMDBEXFx1RDgzRFxcdURDNjZ8KD86KD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1MjAwRCk/XFx1RDgzRFxcdURDNjdcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdKXwoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdKSl8XFx1RDgzQ1xcdURERjgoPzpcXHVEODNDW1xcdURERTYtXFx1RERFQVxcdURERUMtXFx1RERGNFxcdURERjctXFx1RERGOVxcdURERkJcXHVEREZELVxcdURERkZdKXxcXHVEODNDXFx1RERGMCg/OlxcdUQ4M0NbXFx1RERFQVxcdURERUMtXFx1RERFRVxcdURERjJcXHVEREYzXFx1RERGNVxcdURERjdcXHVEREZDXFx1RERGRVxcdURERkZdKXxcXHVEODNDXFx1RERGRSg/OlxcdUQ4M0NbXFx1RERFQVxcdURERjldKXxcXHVEODNDXFx1RERFRSg/OlxcdUQ4M0NbXFx1RERFOC1cXHVEREVBXFx1RERGMS1cXHVEREY0XFx1RERGNi1cXHVEREY5XSl8XFx1RDgzQ1xcdURERjkoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFOVxcdURERUItXFx1RERFRFxcdURERUYtXFx1RERGNFxcdURERjdcXHVEREY5XFx1RERGQlxcdURERkNcXHVEREZGXSl8XFx1RDgzQ1xcdURERUMoPzpcXHVEODNDW1xcdURERTZcXHVEREU3XFx1RERFOS1cXHVEREVFXFx1RERGMS1cXHVEREYzXFx1RERGNS1cXHVEREZBXFx1RERGQ1xcdURERkVdKXxcXHVEODNDXFx1RERGQSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERUNcXHVEREYyXFx1RERGM1xcdURERjhcXHVEREZFXFx1RERGRl0pfFxcdUQ4M0NcXHVEREVBKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUFcXHVEREVDXFx1RERFRFxcdURERjctXFx1RERGQV0pfFxcdUQ4M0NcXHVEREZDKD86XFx1RDgzQ1tcXHVEREVCXFx1RERGOF0pfCg/OlxcdTI2Rjl8XFx1RDgzQ1tcXHVERkNCXFx1REZDQ118XFx1RDgzRFxcdURENzUpKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXwoPzpcXHVEODNDW1xcdURGQzNcXHVERkM0XFx1REZDQV18XFx1RDgzRFtcXHVEQzZFXFx1REM3MVxcdURDNzNcXHVEQzc3XFx1REM4MVxcdURDODJcXHVEQzg2XFx1REM4N1xcdURFNDUtXFx1REU0N1xcdURFNEJcXHVERTREXFx1REU0RVxcdURFQTNcXHVERUI0LVxcdURFQjZdfFxcdUQ4M0VbXFx1REQyNlxcdUREMzctXFx1REQzOVxcdUREM0RcXHVERDNFXFx1RERENi1cXHVEREREXSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OltcXHUyNjFEXFx1MjcwQS1cXHUyNzBEXXxcXHVEODNDW1xcdURGODVcXHVERkMyXFx1REZDN118XFx1RDgzRFtcXHVEQzQyXFx1REM0M1xcdURDNDYtXFx1REM1MFxcdURDNjZcXHVEQzY3XFx1REM3MFxcdURDNzJcXHVEQzc0LVxcdURDNzZcXHVEQzc4XFx1REM3Q1xcdURDODNcXHVEQzg1XFx1RENBQVxcdURENzRcXHVERDdBXFx1REQ5MFxcdUREOTVcXHVERDk2XFx1REU0Q1xcdURFNEZcXHVERUMwXFx1REVDQ118XFx1RDgzRVtcXHVERDE4LVxcdUREMUNcXHVERDFFXFx1REQxRlxcdUREMzAtXFx1REQzNlxcdURERDEtXFx1RERENV0pKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXxcXHVEODNEXFx1REM2OCg/OlxcdTIwMEQoPzooPzooPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHUyMDBEKT9cXHVEODNEXFx1REM2N3woPzooPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHUyMDBEKT9cXHVEODNEXFx1REM2Nil8XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXwoPzpbXFx1MjYxRFxcdTI2RjlcXHUyNzBBLVxcdTI3MERdfFxcdUQ4M0NbXFx1REY4NVxcdURGQzItXFx1REZDNFxcdURGQzdcXHVERkNBLVxcdURGQ0NdfFxcdUQ4M0RbXFx1REM0MlxcdURDNDNcXHVEQzQ2LVxcdURDNTBcXHVEQzY2LVxcdURDNjlcXHVEQzZFXFx1REM3MC1cXHVEQzc4XFx1REM3Q1xcdURDODEtXFx1REM4M1xcdURDODUtXFx1REM4N1xcdURDQUFcXHVERDc0XFx1REQ3NVxcdUREN0FcXHVERDkwXFx1REQ5NVxcdUREOTZcXHVERTQ1LVxcdURFNDdcXHVERTRCLVxcdURFNEZcXHVERUEzXFx1REVCNC1cXHVERUI2XFx1REVDMFxcdURFQ0NdfFxcdUQ4M0VbXFx1REQxOC1cXHVERDFDXFx1REQxRVxcdUREMUZcXHVERDI2XFx1REQzMC1cXHVERDM5XFx1REQzRFxcdUREM0VcXHVEREQxLVxcdURERERdKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/fCg/OltcXHUyMzFBXFx1MjMxQlxcdTIzRTktXFx1MjNFQ1xcdTIzRjBcXHUyM0YzXFx1MjVGRFxcdTI1RkVcXHUyNjE0XFx1MjYxNVxcdTI2NDgtXFx1MjY1M1xcdTI2N0ZcXHUyNjkzXFx1MjZBMVxcdTI2QUFcXHUyNkFCXFx1MjZCRFxcdTI2QkVcXHUyNkM0XFx1MjZDNVxcdTI2Q0VcXHUyNkQ0XFx1MjZFQVxcdTI2RjJcXHUyNkYzXFx1MjZGNVxcdTI2RkFcXHUyNkZEXFx1MjcwNVxcdTI3MEFcXHUyNzBCXFx1MjcyOFxcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3OTUtXFx1Mjc5N1xcdTI3QjBcXHUyN0JGXFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NV18XFx1RDgzQ1tcXHVEQzA0XFx1RENDRlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREU2LVxcdURERkZcXHVERTAxXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFMzZcXHVERTM4LVxcdURFM0FcXHVERTUwXFx1REU1MVxcdURGMDAtXFx1REYyMFxcdURGMkQtXFx1REYzNVxcdURGMzctXFx1REY3Q1xcdURGN0UtXFx1REY5M1xcdURGQTAtXFx1REZDQVxcdURGQ0YtXFx1REZEM1xcdURGRTAtXFx1REZGMFxcdURGRjRcXHVERkY4LVxcdURGRkZdfFxcdUQ4M0RbXFx1REMwMC1cXHVEQzNFXFx1REM0MFxcdURDNDItXFx1RENGQ1xcdURDRkYtXFx1REQzRFxcdURENEItXFx1REQ0RVxcdURENTAtXFx1REQ2N1xcdUREN0FcXHVERDk1XFx1REQ5NlxcdUREQTRcXHVEREZCLVxcdURFNEZcXHVERTgwLVxcdURFQzVcXHVERUNDXFx1REVEMC1cXHVERUQyXFx1REVFQlxcdURFRUNcXHVERUY0LVxcdURFRjhdfFxcdUQ4M0VbXFx1REQxMC1cXHVERDNBXFx1REQzQy1cXHVERDNFXFx1REQ0MC1cXHVERDQ1XFx1REQ0Ny1cXHVERDRDXFx1REQ1MC1cXHVERDZCXFx1REQ4MC1cXHVERDk3XFx1RERDMFxcdURERDAtXFx1RERFNl0pfCg/OlsjXFwqMC05XFx4QTlcXHhBRVxcdTIwM0NcXHUyMDQ5XFx1MjEyMlxcdTIxMzlcXHUyMTk0LVxcdTIxOTlcXHUyMUE5XFx1MjFBQVxcdTIzMUFcXHUyMzFCXFx1MjMyOFxcdTIzQ0ZcXHUyM0U5LVxcdTIzRjNcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkItXFx1MjVGRVxcdTI2MDAtXFx1MjYwNFxcdTI2MEVcXHUyNjExXFx1MjYxNFxcdTI2MTVcXHUyNjE4XFx1MjYxRFxcdTI2MjBcXHUyNjIyXFx1MjYyM1xcdTI2MjZcXHUyNjJBXFx1MjYyRVxcdTI2MkZcXHUyNjM4LVxcdTI2M0FcXHUyNjQwXFx1MjY0MlxcdTI2NDgtXFx1MjY1M1xcdTI2NjBcXHUyNjYzXFx1MjY2NVxcdTI2NjZcXHUyNjY4XFx1MjY3QlxcdTI2N0ZcXHUyNjkyLVxcdTI2OTdcXHUyNjk5XFx1MjY5QlxcdTI2OUNcXHUyNkEwXFx1MjZBMVxcdTI2QUFcXHUyNkFCXFx1MjZCMFxcdTI2QjFcXHUyNkJEXFx1MjZCRVxcdTI2QzRcXHUyNkM1XFx1MjZDOFxcdTI2Q0VcXHUyNkNGXFx1MjZEMVxcdTI2RDNcXHUyNkQ0XFx1MjZFOVxcdTI2RUFcXHUyNkYwLVxcdTI2RjVcXHUyNkY3LVxcdTI2RkFcXHUyNkZEXFx1MjcwMlxcdTI3MDVcXHUyNzA4LVxcdTI3MERcXHUyNzBGXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzI4XFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3NjNcXHUyNzY0XFx1Mjc5NS1cXHUyNzk3XFx1MjdBMVxcdTI3QjBcXHUyN0JGXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV18XFx1RDgzQ1tcXHVEQzA0XFx1RENDRlxcdURENzBcXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERFNi1cXHVEREZGXFx1REUwMVxcdURFMDJcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzQVxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERjIxXFx1REYyNC1cXHVERjkzXFx1REY5NlxcdURGOTdcXHVERjk5LVxcdURGOUJcXHVERjlFLVxcdURGRjBcXHVERkYzLVxcdURGRjVcXHVERkY3LVxcdURGRkZdfFxcdUQ4M0RbXFx1REMwMC1cXHVEQ0ZEXFx1RENGRi1cXHVERDNEXFx1REQ0OS1cXHVERDRFXFx1REQ1MC1cXHVERDY3XFx1REQ2RlxcdURENzBcXHVERDczLVxcdUREN0FcXHVERDg3XFx1REQ4QS1cXHVERDhEXFx1REQ5MFxcdUREOTVcXHVERDk2XFx1RERBNFxcdUREQTVcXHVEREE4XFx1RERCMVxcdUREQjJcXHVEREJDXFx1RERDMi1cXHVEREM0XFx1REREMS1cXHVEREQzXFx1REREQy1cXHVERERFXFx1RERFMVxcdURERTNcXHVEREU4XFx1RERFRlxcdURERjNcXHVEREZBLVxcdURFNEZcXHVERTgwLVxcdURFQzVcXHVERUNCLVxcdURFRDJcXHVERUUwLVxcdURFRTVcXHVERUU5XFx1REVFQlxcdURFRUNcXHVERUYwXFx1REVGMy1cXHVERUY4XXxcXHVEODNFW1xcdUREMTAtXFx1REQzQVxcdUREM0MtXFx1REQzRVxcdURENDAtXFx1REQ0NVxcdURENDctXFx1REQ0Q1xcdURENTAtXFx1REQ2QlxcdUREODAtXFx1REQ5N1xcdUREQzBcXHVEREQwLVxcdURERTZdKVxcdUZFMEYpLztcbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXh0KGUpIHtcbiAgdmFyIHR5cGUgPSBlLm5vZGVUeXBlLFxuICAgICAgcmVzdWx0ID0gXCJcIjtcblxuICBpZiAodHlwZSA9PT0gMSB8fCB0eXBlID09PSA5IHx8IHR5cGUgPT09IDExKSB7XG4gICAgaWYgKHR5cGVvZiBlLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZS50ZXh0Q29udGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChlID0gZS5maXJzdENoaWxkOyBlOyBlID0gZS5uZXh0U2libGluZykge1xuICAgICAgICByZXN1bHQgKz0gZ2V0VGV4dChlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gMyB8fCB0eXBlID09PSA0KSB7XG4gICAgcmV0dXJuIGUubm9kZVZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdElubmVySFRNTChlbGVtZW50LCBkZWxpbWl0ZXIsIHRyaW0sIHByZXNlcnZlU3BhY2VzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudC5maXJzdENoaWxkLFxuICAgICAgcmVzdWx0ID0gW10sXG4gICAgICBzO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIHMgPSAobm9kZS5ub2RlVmFsdWUgKyBcIlwiKS5yZXBsYWNlKC9eXFxuKy9nLCBcIlwiKTtcblxuICAgICAgaWYgKCFwcmVzZXJ2ZVNwYWNlcykge1xuICAgICAgICBzID0gcy5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBlbW9qaVNhZmVTcGxpdChzLCBkZWxpbWl0ZXIsIHRyaW0sIHByZXNlcnZlU3BhY2VzKSk7XG4gICAgfSBlbHNlIGlmICgobm9kZS5ub2RlTmFtZSArIFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwiYnJcIikge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSArPSBcIjxicj5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2gobm9kZS5vdXRlckhUTUwpO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICB9XG5cbiAgcyA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKHMtLSkge1xuICAgIHJlc3VsdFtzXSA9PT0gXCImXCIgJiYgcmVzdWx0LnNwbGljZShzLCAxLCBcIiZhbXA7XCIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qXG4vL3NtYWxsZXIga2IgdmVyc2lvbiB0aGF0IG9ubHkgaGFuZGxlcyB0aGUgc2ltcGxlciBlbW9qaSdzLCB3aGljaCBpcyBvZnRlbiBwZXJmZWN0bHkgYWRlcXVhdGUuXG5cbmxldCBfZW1vamkgPSBcIltcXHVFMDAwLVxcdUY4RkZdfFxcdUQ4M0NbXFx1REMwMC1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1REZGRl18W1xcdTI2OTQtXFx1MjY5N118XFx1RDgzRVtcXHVERDEwLVxcdURENURdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl1cIixcblx0X2Vtb2ppRXhwID0gbmV3IFJlZ0V4cChfZW1vamkpLFxuXHRfZW1vamlBbmRDaGFyc0V4cCA9IG5ldyBSZWdFeHAoX2Vtb2ppICsgXCJ8LlwiLCBcImdcIiksXG5cdF9lbW9qaVNhZmVTcGxpdCA9ICh0ZXh0LCBkZWxpbWl0ZXIsIHRyaW0pID0+IHtcblx0XHRpZiAodHJpbSkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZShfdHJpbUV4cCwgXCJcIik7XG5cdFx0fVxuXHRcdHJldHVybiAoKGRlbGltaXRlciA9PT0gXCJcIiB8fCAhZGVsaW1pdGVyKSAmJiBfZW1vamlFeHAudGVzdCh0ZXh0KSkgPyB0ZXh0Lm1hdGNoKF9lbW9qaUFuZENoYXJzRXhwKSA6IHRleHQuc3BsaXQoZGVsaW1pdGVyIHx8IFwiXCIpO1xuXHR9O1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlbW9qaVNhZmVTcGxpdCh0ZXh0LCBkZWxpbWl0ZXIsIHRyaW0sIHByZXNlcnZlU3BhY2VzKSB7XG4gIHRleHQgKz0gXCJcIjsgLy8gbWFrZSBzdXJlIGl0J3MgY2FzdCBhcyBhIHN0cmluZy4gU29tZW9uZSBtYXkgcGFzcyBpbiBhIG51bWJlci5cblxuICB0cmltICYmICh0ZXh0ID0gdGV4dC50cmltID8gdGV4dC50cmltKCkgOiB0ZXh0LnJlcGxhY2UoX3RyaW1FeHAsIFwiXCIpKTsgLy8gSUU5IGFuZCBlYXJsaWVyIGNvbXBhdGliaWxpdHlcblxuICBpZiAoZGVsaW1pdGVyICYmIGRlbGltaXRlciAhPT0gXCJcIikge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpLnNwbGl0KGRlbGltaXRlcik7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICBsID0gdGV4dC5sZW5ndGgsXG4gICAgICBpID0gMCxcbiAgICAgIGosXG4gICAgICBjaGFyYWN0ZXI7XG5cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBjaGFyYWN0ZXIgPSB0ZXh0LmNoYXJBdChpKTtcblxuICAgIGlmIChjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKSA+PSAweEQ4MDAgJiYgY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkgPD0gMHhEQkZGIHx8IHRleHQuY2hhckNvZGVBdChpICsgMSkgPj0gMHhGRTAwICYmIHRleHQuY2hhckNvZGVBdChpICsgMSkgPD0gMHhGRTBGKSB7XG4gICAgICAvL3NwZWNpYWwgZW1vamkgY2hhcmFjdGVycyB1c2UgMiBvciA0IHVuaWNvZGUgY2hhcmFjdGVycyB0aGF0IHdlIG11c3Qga2VlcCB0b2dldGhlci5cbiAgICAgIGogPSAoKHRleHQuc3Vic3RyKGksIDEyKS5zcGxpdChlbW9qaUV4cCkgfHwgW10pWzFdIHx8IFwiXCIpLmxlbmd0aCB8fCAyO1xuICAgICAgY2hhcmFjdGVyID0gdGV4dC5zdWJzdHIoaSwgaik7XG4gICAgICByZXN1bHQuZW1vamkgPSAxO1xuICAgICAgaSArPSBqIC0gMTtcbiAgICB9XG5cbiAgICByZXN1bHQucHVzaChjaGFyYWN0ZXIgPT09IFwiPlwiID8gXCImZ3Q7XCIgOiBjaGFyYWN0ZXIgPT09IFwiPFwiID8gXCImbHQ7XCIgOiBwcmVzZXJ2ZVNwYWNlcyAmJiBjaGFyYWN0ZXIgPT09IFwiIFwiICYmICh0ZXh0LmNoYXJBdChpIC0gMSkgPT09IFwiIFwiIHx8IHRleHQuY2hhckF0KGkgKyAxKSA9PT0gXCIgXCIpID8gXCImbmJzcDtcIiA6IGNoYXJhY3Rlcik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSJdLCJuYW1lcyI6WyJfdHJpbUV4cCIsImVtb2ppRXhwIiwiZ2V0VGV4dCIsImUiLCJ0eXBlIiwibm9kZVR5cGUiLCJyZXN1bHQiLCJ0ZXh0Q29udGVudCIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsIm5vZGVWYWx1ZSIsInNwbGl0SW5uZXJIVE1MIiwiZWxlbWVudCIsImRlbGltaXRlciIsInRyaW0iLCJwcmVzZXJ2ZVNwYWNlcyIsIm5vZGUiLCJzIiwicmVwbGFjZSIsInB1c2giLCJhcHBseSIsImVtb2ppU2FmZVNwbGl0Iiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImxlbmd0aCIsIm91dGVySFRNTCIsInNwbGljZSIsInRleHQiLCJzcGxpdCIsImwiLCJpIiwiaiIsImNoYXJhY3RlciIsImNoYXJBdCIsImNoYXJDb2RlQXQiLCJzdWJzdHIiLCJlbW9qaSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/utils/strings.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/image.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/image.js ***!
  \************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/lib/image-external */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-external.js\");\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=image.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2ltYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF1RDtBQUNWOztBQUU3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuNzcuMi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9pbWFnZS5qcz9mZDA3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbFwiO1xuZXhwb3J0ICogZnJvbSBcIi4uL3NoYXJlZC9saWIvaW1hZ2UtZXh0ZXJuYWxcIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/image.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/link.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/link.js ***!
  \***********************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _client_link__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/link */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/link.js\");\n/* harmony import */ var _client_link__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_link__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_link__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_link__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=link.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2xpbmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXlDO0FBQ1Y7O0FBRS9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2xpbmsuanM/ZGI0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi4uL2NsaWVudC9saW5rXCI7XG5leHBvcnQgKiBmcm9tIFwiLi4vY2xpZW50L2xpbmtcIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluay5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/navigation.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/navigation.js ***!
  \*****************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEOztBQUVoRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuNzcuMi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9uYXZpZ2F0aW9uLmpzPzU5MzIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4uL2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb25cIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/build/polyfills/process.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/build/polyfills/process.js ***!
  \**************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQyxtTUFBNEI7O0FBRXpQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/YTk1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={592:(e,r,t)=>{var n=t(722);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},722:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(592);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQyw4QkFBOEIsdUJBQXVCLFFBQVEsa0JBQWtCLFdBQVcsZ0JBQWdCLDhCQUE4QixxQkFBcUIsZ0JBQWdCLG1CQUFtQixpQkFBaUIsZ0NBQWdDLFdBQVcsT0FBTywyQkFBMkIsNkJBQTZCLEtBQUssOENBQThDLG9CQUFvQixNQUFNLFNBQVMsT0FBTyxtQkFBbUIsT0FBTyxZQUFZLGdDQUFnQyxjQUFjLE9BQU8sZ0NBQWdDLE9BQU8sZ0NBQWdDLHFDQUFxQyw0Q0FBNEMsMkNBQTJDLFNBQVMsZ0JBQWdCLElBQUksd0JBQXdCLE9BQU8sWUFBWSxPQUFPLHVCQUF1QixxQkFBcUIsT0FBTyx1QkFBdUIsT0FBTyxnQ0FBZ0MsT0FBTyxlQUFlLG9CQUFvQixpQkFBaUIsc0NBQXNDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsdUNBQXVDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsMkNBQTJDLGtCQUFrQiwyQ0FBMkMsS0FBSyw2QkFBNkIsMkJBQTJCLE1BQU0sT0FBTyxlQUFlLEVBQUUsb0JBQW9CLG9CQUFvQixLQUFLLEdBQUcsU0FBUyx3QkFBd0IsT0FBTyxhQUFhLHdDQUF3QyxZQUFZLHNCQUFzQixZQUFZLE9BQU8sNkJBQTZCLHFCQUFxQixPQUFPLHFCQUFxQixPQUFPLE1BQU0sZUFBZSxRQUFRLEdBQUcsU0FBUyxxQkFBcUIsd0NBQXdDLHNCQUFzQixxQkFBcUIsT0FBTyxhQUFhLEdBQUcseUJBQXlCLHlDQUF5QyxhQUFhLFlBQVksd0JBQXdCLE1BQU0sMERBQTBELFlBQVksNkJBQTZCLGtCQUFrQixvQkFBb0IscUJBQXFCLGFBQWEsZ0VBQWdFLFlBQVksT0FBTyxNQUFNLCtDQUErQyxLQUFLLG9DQUFvQyxhQUFhLDRCQUE0QixTQUFTLHlCQUF5QiwrQkFBK0IsVUFBVSxpQkFBaUIsTUFBTSxjQUFjLGtCQUFrQixTQUFTLGdCQUFnQixzQkFBc0IsV0FBVyxzQkFBc0IsU0FBUyxvREFBb0QsaURBQWlELDJDQUEyQyxRQUFRLHNCQUFzQixnQkFBZ0IsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuNzcuMi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qcz9lOWRmIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs1OTI6KGUscix0KT0+e3ZhciBuPXQoNzIyKTt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhPXR5cGVvZiBkb2N1bWVudD09PVwidW5kZWZpbmVkXCI7dmFyIG89QXJyYXkucHJvdG90eXBlLmZvckVhY2g7ZnVuY3Rpb24gZGVib3VuY2UoZSxyKXt2YXIgdD0wO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXM7dmFyIGk9YXJndW1lbnRzO3ZhciBhPWZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbCgpe3JldHVybiBlLmFwcGx5KG4saSl9O2NsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQoYSxyKX19ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0VXJsKGUpe3ZhciByPWlbZV07aWYoIXIpe2lmKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3I9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9ZWxzZXt2YXIgdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTt2YXIgYT10W3QubGVuZ3RoLTFdO2lmKGEpe3I9YS5zcmN9fWlbZV09cn1yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXIpe3JldHVybiBudWxsfXZhciB0PXIuc3BsaXQoLyhbXlxcXFwvXSspXFwuanMkLyk7dmFyIGk9dCYmdFsxXTtpZighaSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19aWYoIWUpe3JldHVybltyLnJlcGxhY2UoXCIuanNcIixcIi5jc3NcIildfXJldHVybiBlLnNwbGl0KFwiLFwiKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBSZWdFeHAoXCJcIi5jb25jYXQoaSxcIlxcXFwuanMkXCIpLFwiZ1wiKTtyZXR1cm4gbihyLnJlcGxhY2UodCxcIlwiLmNvbmNhdChlLnJlcGxhY2UoL3tmaWxlTmFtZX0vZyxpKSxcIi5jc3NcIikpKX0pKX19ZnVuY3Rpb24gdXBkYXRlQ3NzKGUscil7aWYoIXIpe2lmKCFlLmhyZWYpe3JldHVybn1yPWUuaHJlZi5zcGxpdChcIj9cIilbMF19aWYoIWlzVXJsUmVxdWVzdChyKSl7cmV0dXJufWlmKGUuaXNMb2FkZWQ9PT1mYWxzZSl7cmV0dXJufWlmKCFyfHwhKHIuaW5kZXhPZihcIi5jc3NcIik+LTEpKXtyZXR1cm59ZS52aXNpdGVkPXRydWU7dmFyIHQ9ZS5jbG9uZU5vZGUoKTt0LmlzTG9hZGVkPWZhbHNlO3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtpZih0LmlzTG9hZGVkKXtyZXR1cm59dC5pc0xvYWRlZD10cnVlO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuaHJlZj1cIlwiLmNvbmNhdChyLFwiP1wiKS5jb25jYXQoRGF0ZS5ub3coKSk7aWYoZS5uZXh0U2libGluZyl7ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpfWVsc2V7ZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpfX1mdW5jdGlvbiBnZXRSZWxvYWRVcmwoZSxyKXt2YXIgdDtlPW4oZSx7c3RyaXBXV1c6ZmFsc2V9KTtyLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihyKT4tMSl7dD1ufX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRTdHlsZShlKXtpZighZSl7cmV0dXJuIGZhbHNlfXZhciByPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO3ZhciB0PWZhbHNlO28uY2FsbChyLChmdW5jdGlvbihyKXtpZighci5ocmVmKXtyZXR1cm59dmFyIG49Z2V0UmVsb2FkVXJsKHIuaHJlZixlKTtpZighaXNVcmxSZXF1ZXN0KG4pKXtyZXR1cm59aWYoci52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufWlmKG4pe3VwZGF0ZUNzcyhyLG4pO3Q9dHJ1ZX19KSk7cmV0dXJuIHR9ZnVuY3Rpb24gcmVsb2FkQWxsKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7by5jYWxsKGUsKGZ1bmN0aW9uKGUpe2lmKGUudmlzaXRlZD09PXRydWUpe3JldHVybn11cGRhdGVDc3MoZSl9KSl9ZnVuY3Rpb24gaXNVcmxSZXF1ZXN0KGUpe2lmKCEvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly50ZXN0KGUpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYoYSl7Y29uc29sZS5sb2coXCJubyB3aW5kb3cuZG9jdW1lbnQgZm91bmQsIHdpbGwgbm90IEhNUiBDU1NcIik7cmV0dXJuIG5vb3B9dmFyIHQ9Z2V0Q3VycmVudFNjcmlwdFVybChlKTtmdW5jdGlvbiB1cGRhdGUoKXt2YXIgZT10KHIuZmlsZW5hbWUpO3ZhciBuPXJlbG9hZFN0eWxlKGUpO2lmKHIubG9jYWxzKXtjb25zb2xlLmxvZyhcIltITVJdIERldGVjdGVkIGxvY2FsIGNzcyBtb2R1bGVzLiBSZWxvYWQgYWxsIGNzc1wiKTtyZWxvYWRBbGwoKTtyZXR1cm59aWYobil7Y29uc29sZS5sb2coXCJbSE1SXSBjc3MgcmVsb2FkICVzXCIsZS5qb2luKFwiIFwiKSl9ZWxzZXtjb25zb2xlLmxvZyhcIltITVJdIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpfX1yZXR1cm4gZGVib3VuY2UodXBkYXRlLDUwKX19LDcyMjplPT57ZnVuY3Rpb24gbm9ybWFsaXplVXJsKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtzd2l0Y2gocil7Y2FzZVwiLi5cIjplLnBvcCgpO2JyZWFrO2Nhc2VcIi5cIjpicmVhaztkZWZhdWx0OmUucHVzaChyKX1yZXR1cm4gZX0pLFtdKS5qb2luKFwiL1wiKX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtpZigvXmRhdGE6L2kudGVzdChlKSl7cmV0dXJuIGV9dmFyIHI9ZS5pbmRleE9mKFwiLy9cIikhPT0tMT9lLnNwbGl0KFwiLy9cIilbMF0rXCIvL1wiOlwiXCI7dmFyIHQ9ZS5yZXBsYWNlKG5ldyBSZWdFeHAocixcImlcIiksXCJcIikuc3BsaXQoXCIvXCIpO3ZhciBuPXRbMF0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4kLyxcIlwiKTt0WzBdPVwiXCI7dmFyIGk9bm9ybWFsaXplVXJsKHQpO3JldHVybiByK24raX19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPXJbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNTkyKTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/picomatch/index.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/picomatch/index.js ***!
  \***************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/build/polyfills/process.js\");\n(()=>{\"use strict\";var t={170:(t,e,u)=>{const n=u(510);const isWindows=()=>{if(typeof navigator!==\"undefined\"&&navigator.platform){const t=navigator.platform.toLowerCase();return t===\"win32\"||t===\"windows\"}if(typeof process!==\"undefined\"&&process.platform){return process.platform===\"win32\"}return false};function picomatch(t,e,u=false){if(e&&(e.windows===null||e.windows===undefined)){e={...e,windows:isWindows()}}return n(t,e,u)}Object.assign(picomatch,n);t.exports=picomatch},154:t=>{const e=\"\\\\\\\\/\";const u=`[^${e}]`;const n=\"\\\\.\";const o=\"\\\\+\";const s=\"\\\\?\";const r=\"\\\\/\";const a=\"(?=.)\";const i=\"[^/]\";const c=`(?:${r}|$)`;const p=`(?:^|${r})`;const l=`${n}{1,2}${c}`;const f=`(?!${n})`;const A=`(?!${p}${l})`;const _=`(?!${n}{0,1}${c})`;const R=`(?!${l})`;const E=`[^.${r}]`;const h=`${i}*?`;const g=\"/\";const b={DOT_LITERAL:n,PLUS_LITERAL:o,QMARK_LITERAL:s,SLASH_LITERAL:r,ONE_CHAR:a,QMARK:i,END_ANCHOR:c,DOTS_SLASH:l,NO_DOT:f,NO_DOTS:A,NO_DOT_SLASH:_,NO_DOTS_SLASH:R,QMARK_NO_DOT:E,STAR:h,START_ANCHOR:p,SEP:g};const C={...b,SLASH_LITERAL:`[${e}]`,QMARK:u,STAR:`${u}*?`,DOTS_SLASH:`${n}{1,2}(?:[${e}]|$)`,NO_DOT:`(?!${n})`,NO_DOTS:`(?!(?:^|[${e}])${n}{1,2}(?:[${e}]|$))`,NO_DOT_SLASH:`(?!${n}{0,1}(?:[${e}]|$))`,NO_DOTS_SLASH:`(?!${n}{1,2}(?:[${e}]|$))`,QMARK_NO_DOT:`[^.${e}]`,START_ANCHOR:`(?:^|[${e}])`,END_ANCHOR:`(?:[${e}]|$)`,SEP:\"\\\\\"};const y={alnum:\"a-zA-Z0-9\",alpha:\"a-zA-Z\",ascii:\"\\\\x00-\\\\x7F\",blank:\" \\\\t\",cntrl:\"\\\\x00-\\\\x1F\\\\x7F\",digit:\"0-9\",graph:\"\\\\x21-\\\\x7E\",lower:\"a-z\",print:\"\\\\x20-\\\\x7E \",punct:\"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",space:\" \\\\t\\\\r\\\\n\\\\v\\\\f\",upper:\"A-Z\",word:\"A-Za-z0-9_\",xdigit:\"A-Fa-f0-9\"};t.exports={MAX_LENGTH:1024*64,POSIX_REGEX_SOURCE:y,REGEX_BACKSLASH:/\\\\(?![*+?^${}(|)[\\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\\].,$*+?^{}()|\\\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\\\?)((\\W)(\\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,REPLACEMENTS:{\"***\":\"*\",\"**/**\":\"**\",\"**/**/**\":\"**\"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,extglobChars(t){return{\"!\":{type:\"negate\",open:\"(?:(?!(?:\",close:`))${t.STAR})`},\"?\":{type:\"qmark\",open:\"(?:\",close:\")?\"},\"+\":{type:\"plus\",open:\"(?:\",close:\")+\"},\"*\":{type:\"star\",open:\"(?:\",close:\")*\"},\"@\":{type:\"at\",open:\"(?:\",close:\")\"}}},globChars(t){return t===true?C:b}}},697:(t,e,u)=>{const n=u(154);const o=u(96);const{MAX_LENGTH:s,POSIX_REGEX_SOURCE:r,REGEX_NON_SPECIAL_CHARS:a,REGEX_SPECIAL_CHARS_BACKREF:i,REPLACEMENTS:c}=n;const expandRange=(t,e)=>{if(typeof e.expandRange===\"function\"){return e.expandRange(...t,e)}t.sort();const u=`[${t.join(\"-\")}]`;try{new RegExp(u)}catch(e){return t.map((t=>o.escapeRegex(t))).join(\"..\")}return u};const syntaxError=(t,e)=>`Missing ${t}: \"${e}\" - use \"\\\\\\\\${e}\" to match literal characters`;const parse=(t,e)=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected a string\")}t=c[t]||t;const u={...e};const p=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;let l=t.length;if(l>p){throw new SyntaxError(`Input length: ${l}, exceeds maximum allowed length: ${p}`)}const f={type:\"bos\",value:\"\",output:u.prepend||\"\"};const A=[f];const _=u.capture?\"\":\"?:\";const R=n.globChars(u.windows);const E=n.extglobChars(R);const{DOT_LITERAL:h,PLUS_LITERAL:g,SLASH_LITERAL:b,ONE_CHAR:C,DOTS_SLASH:y,NO_DOT:$,NO_DOT_SLASH:x,NO_DOTS_SLASH:S,QMARK:H,QMARK_NO_DOT:v,STAR:d,START_ANCHOR:L}=R;const globstar=t=>`(${_}(?:(?!${L}${t.dot?y:h}).)*?)`;const T=u.dot?\"\":$;const O=u.dot?H:v;let k=u.bash===true?globstar(u):d;if(u.capture){k=`(${k})`}if(typeof u.noext===\"boolean\"){u.noextglob=u.noext}const m={input:t,index:-1,start:0,dot:u.dot===true,consumed:\"\",output:\"\",prefix:\"\",backtrack:false,negated:false,brackets:0,braces:0,parens:0,quotes:0,globstar:false,tokens:A};t=o.removePrefix(t,m);l=t.length;const w=[];const N=[];const I=[];let B=f;let G;const eos=()=>m.index===l-1;const D=m.peek=(e=1)=>t[m.index+e];const M=m.advance=()=>t[++m.index]||\"\";const remaining=()=>t.slice(m.index+1);const consume=(t=\"\",e=0)=>{m.consumed+=t;m.index+=e};const append=t=>{m.output+=t.output!=null?t.output:t.value;consume(t.value)};const negate=()=>{let t=1;while(D()===\"!\"&&(D(2)!==\"(\"||D(3)===\"?\")){M();m.start++;t++}if(t%2===0){return false}m.negated=true;m.start++;return true};const increment=t=>{m[t]++;I.push(t)};const decrement=t=>{m[t]--;I.pop()};const push=t=>{if(B.type===\"globstar\"){const e=m.braces>0&&(t.type===\"comma\"||t.type===\"brace\");const u=t.extglob===true||w.length&&(t.type===\"pipe\"||t.type===\"paren\");if(t.type!==\"slash\"&&t.type!==\"paren\"&&!e&&!u){m.output=m.output.slice(0,-B.output.length);B.type=\"star\";B.value=\"*\";B.output=k;m.output+=B.output}}if(w.length&&t.type!==\"paren\"){w[w.length-1].inner+=t.value}if(t.value||t.output)append(t);if(B&&B.type===\"text\"&&t.type===\"text\"){B.output=(B.output||B.value)+t.value;B.value+=t.value;return}t.prev=B;A.push(t);B=t};const extglobOpen=(t,e)=>{const n={...E[e],conditions:1,inner:\"\"};n.prev=B;n.parens=m.parens;n.output=m.output;const o=(u.capture?\"(\":\"\")+n.open;increment(\"parens\");push({type:t,value:e,output:m.output?\"\":C});push({type:\"paren\",extglob:true,value:M(),output:o});w.push(n)};const extglobClose=t=>{let n=t.close+(u.capture?\")\":\"\");let o;if(t.type===\"negate\"){let s=k;if(t.inner&&t.inner.length>1&&t.inner.includes(\"/\")){s=globstar(u)}if(s!==k||eos()||/^\\)+$/.test(remaining())){n=t.close=`)$))${s}`}if(t.inner.includes(\"*\")&&(o=remaining())&&/^\\.[^\\\\/.]+$/.test(o)){const u=parse(o,{...e,fastpaths:false}).output;n=t.close=`)${u})${s})`}if(t.prev.type===\"bos\"){m.negatedExtglob=true}}push({type:\"paren\",extglob:true,value:G,output:n});decrement(\"parens\")};if(u.fastpaths!==false&&!/(^[*!]|[/()[\\]{}\"])/.test(t)){let n=false;let s=t.replace(i,((t,e,u,o,s,r)=>{if(o===\"\\\\\"){n=true;return t}if(o===\"?\"){if(e){return e+o+(s?H.repeat(s.length):\"\")}if(r===0){return O+(s?H.repeat(s.length):\"\")}return H.repeat(u.length)}if(o===\".\"){return h.repeat(u.length)}if(o===\"*\"){if(e){return e+o+(s?k:\"\")}return k}return e?t:`\\\\${t}`}));if(n===true){if(u.unescape===true){s=s.replace(/\\\\/g,\"\")}else{s=s.replace(/\\\\+/g,(t=>t.length%2===0?\"\\\\\\\\\":t?\"\\\\\":\"\"))}}if(s===t&&u.contains===true){m.output=t;return m}m.output=o.wrapOutput(s,m,e);return m}while(!eos()){G=M();if(G===\"\\0\"){continue}if(G===\"\\\\\"){const t=D();if(t===\"/\"&&u.bash!==true){continue}if(t===\".\"||t===\";\"){continue}if(!t){G+=\"\\\\\";push({type:\"text\",value:G});continue}const e=/^\\\\+/.exec(remaining());let n=0;if(e&&e[0].length>2){n=e[0].length;m.index+=n;if(n%2!==0){G+=\"\\\\\"}}if(u.unescape===true){G=M()}else{G+=M()}if(m.brackets===0){push({type:\"text\",value:G});continue}}if(m.brackets>0&&(G!==\"]\"||B.value===\"[\"||B.value===\"[^\")){if(u.posix!==false&&G===\":\"){const t=B.value.slice(1);if(t.includes(\"[\")){B.posix=true;if(t.includes(\":\")){const t=B.value.lastIndexOf(\"[\");const e=B.value.slice(0,t);const u=B.value.slice(t+2);const n=r[u];if(n){B.value=e+n;m.backtrack=true;M();if(!f.output&&A.indexOf(B)===1){f.output=C}continue}}}}if(G===\"[\"&&D()!==\":\"||G===\"-\"&&D()===\"]\"){G=`\\\\${G}`}if(G===\"]\"&&(B.value===\"[\"||B.value===\"[^\")){G=`\\\\${G}`}if(u.posix===true&&G===\"!\"&&B.value===\"[\"){G=\"^\"}B.value+=G;append({value:G});continue}if(m.quotes===1&&G!=='\"'){G=o.escapeRegex(G);B.value+=G;append({value:G});continue}if(G==='\"'){m.quotes=m.quotes===1?0:1;if(u.keepQuotes===true){push({type:\"text\",value:G})}continue}if(G===\"(\"){increment(\"parens\");push({type:\"paren\",value:G});continue}if(G===\")\"){if(m.parens===0&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"(\"))}const t=w[w.length-1];if(t&&m.parens===t.parens+1){extglobClose(w.pop());continue}push({type:\"paren\",value:G,output:m.parens?\")\":\"\\\\)\"});decrement(\"parens\");continue}if(G===\"[\"){if(u.nobracket===true||!remaining().includes(\"]\")){if(u.nobracket!==true&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"closing\",\"]\"))}G=`\\\\${G}`}else{increment(\"brackets\")}push({type:\"bracket\",value:G});continue}if(G===\"]\"){if(u.nobracket===true||B&&B.type===\"bracket\"&&B.value.length===1){push({type:\"text\",value:G,output:`\\\\${G}`});continue}if(m.brackets===0){if(u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"[\"))}push({type:\"text\",value:G,output:`\\\\${G}`});continue}decrement(\"brackets\");const t=B.value.slice(1);if(B.posix!==true&&t[0]===\"^\"&&!t.includes(\"/\")){G=`/${G}`}B.value+=G;append({value:G});if(u.literalBrackets===false||o.hasRegexChars(t)){continue}const e=o.escapeRegex(B.value);m.output=m.output.slice(0,-B.value.length);if(u.literalBrackets===true){m.output+=e;B.value=e;continue}B.value=`(${_}${e}|${B.value})`;m.output+=B.value;continue}if(G===\"{\"&&u.nobrace!==true){increment(\"braces\");const t={type:\"brace\",value:G,output:\"(\",outputIndex:m.output.length,tokensIndex:m.tokens.length};N.push(t);push(t);continue}if(G===\"}\"){const t=N[N.length-1];if(u.nobrace===true||!t){push({type:\"text\",value:G,output:G});continue}let e=\")\";if(t.dots===true){const t=A.slice();const n=[];for(let e=t.length-1;e>=0;e--){A.pop();if(t[e].type===\"brace\"){break}if(t[e].type!==\"dots\"){n.unshift(t[e].value)}}e=expandRange(n,u);m.backtrack=true}if(t.comma!==true&&t.dots!==true){const u=m.output.slice(0,t.outputIndex);const n=m.tokens.slice(t.tokensIndex);t.value=t.output=\"\\\\{\";G=e=\"\\\\}\";m.output=u;for(const t of n){m.output+=t.output||t.value}}push({type:\"brace\",value:G,output:e});decrement(\"braces\");N.pop();continue}if(G===\"|\"){if(w.length>0){w[w.length-1].conditions++}push({type:\"text\",value:G});continue}if(G===\",\"){let t=G;const e=N[N.length-1];if(e&&I[I.length-1]===\"braces\"){e.comma=true;t=\"|\"}push({type:\"comma\",value:G,output:t});continue}if(G===\"/\"){if(B.type===\"dot\"&&m.index===m.start+1){m.start=m.index+1;m.consumed=\"\";m.output=\"\";A.pop();B=f;continue}push({type:\"slash\",value:G,output:b});continue}if(G===\".\"){if(m.braces>0&&B.type===\"dot\"){if(B.value===\".\")B.output=h;const t=N[N.length-1];B.type=\"dots\";B.output+=G;B.value+=G;t.dots=true;continue}if(m.braces+m.parens===0&&B.type!==\"bos\"&&B.type!==\"slash\"){push({type:\"text\",value:G,output:h});continue}push({type:\"dot\",value:G,output:h});continue}if(G===\"?\"){const t=B&&B.value===\"(\";if(!t&&u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"qmark\",G);continue}if(B&&B.type===\"paren\"){const t=D();let e=G;if(B.value===\"(\"&&!/[!=<:]/.test(t)||t===\"<\"&&!/<([!=]|\\w+>)/.test(remaining())){e=`\\\\${G}`}push({type:\"text\",value:G,output:e});continue}if(u.dot!==true&&(B.type===\"slash\"||B.type===\"bos\")){push({type:\"qmark\",value:G,output:v});continue}push({type:\"qmark\",value:G,output:H});continue}if(G===\"!\"){if(u.noextglob!==true&&D()===\"(\"){if(D(2)!==\"?\"||!/[!=<:]/.test(D(3))){extglobOpen(\"negate\",G);continue}}if(u.nonegate!==true&&m.index===0){negate();continue}}if(G===\"+\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"plus\",G);continue}if(B&&B.value===\"(\"||u.regex===false){push({type:\"plus\",value:G,output:g});continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\"||B.type===\"brace\")||m.parens>0){push({type:\"plus\",value:G});continue}push({type:\"plus\",value:g});continue}if(G===\"@\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){push({type:\"at\",extglob:true,value:G,output:\"\"});continue}push({type:\"text\",value:G});continue}if(G!==\"*\"){if(G===\"$\"||G===\"^\"){G=`\\\\${G}`}const t=a.exec(remaining());if(t){G+=t[0];m.index+=t[0].length}push({type:\"text\",value:G});continue}if(B&&(B.type===\"globstar\"||B.star===true)){B.type=\"star\";B.star=true;B.value+=G;B.output=k;m.backtrack=true;m.globstar=true;consume(G);continue}let e=remaining();if(u.noextglob!==true&&/^\\([^?]/.test(e)){extglobOpen(\"star\",G);continue}if(B.type===\"star\"){if(u.noglobstar===true){consume(G);continue}const n=B.prev;const o=n.prev;const s=n.type===\"slash\"||n.type===\"bos\";const r=o&&(o.type===\"star\"||o.type===\"globstar\");if(u.bash===true&&(!s||e[0]&&e[0]!==\"/\")){push({type:\"star\",value:G,output:\"\"});continue}const a=m.braces>0&&(n.type===\"comma\"||n.type===\"brace\");const i=w.length&&(n.type===\"pipe\"||n.type===\"paren\");if(!s&&n.type!==\"paren\"&&!a&&!i){push({type:\"star\",value:G,output:\"\"});continue}while(e.slice(0,3)===\"/**\"){const u=t[m.index+4];if(u&&u!==\"/\"){break}e=e.slice(3);consume(\"/**\",3)}if(n.type===\"bos\"&&eos()){B.type=\"globstar\";B.value+=G;B.output=globstar(u);m.output=B.output;m.globstar=true;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&!r&&eos()){m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=globstar(u)+(u.strictSlashes?\")\":\"|$)\");B.value+=G;m.globstar=true;m.output+=n.output+B.output;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&e[0]===\"/\"){const t=e[1]!==void 0?\"|$\":\"\";m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=`${globstar(u)}${b}|${b}${t})`;B.value+=G;m.output+=n.output+B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}if(n.type===\"bos\"&&e[0]===\"/\"){B.type=\"globstar\";B.value+=G;B.output=`(?:^|${b}|${globstar(u)}${b})`;m.output=B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}m.output=m.output.slice(0,-B.output.length);B.type=\"globstar\";B.output=globstar(u);B.value+=G;m.output+=B.output;m.globstar=true;consume(G);continue}const n={type:\"star\",value:G,output:k};if(u.bash===true){n.output=\".*?\";if(B.type===\"bos\"||B.type===\"slash\"){n.output=T+n.output}push(n);continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\")&&u.regex===true){n.output=G;push(n);continue}if(m.index===m.start||B.type===\"slash\"||B.type===\"dot\"){if(B.type===\"dot\"){m.output+=x;B.output+=x}else if(u.dot===true){m.output+=S;B.output+=S}else{m.output+=T;B.output+=T}if(D()!==\"*\"){m.output+=C;B.output+=C}}push(n)}while(m.brackets>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"]\"));m.output=o.escapeLast(m.output,\"[\");decrement(\"brackets\")}while(m.parens>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\")\"));m.output=o.escapeLast(m.output,\"(\");decrement(\"parens\")}while(m.braces>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"}\"));m.output=o.escapeLast(m.output,\"{\");decrement(\"braces\")}if(u.strictSlashes!==true&&(B.type===\"star\"||B.type===\"bracket\")){push({type:\"maybe_slash\",value:\"\",output:`${b}?`})}if(m.backtrack===true){m.output=\"\";for(const t of m.tokens){m.output+=t.output!=null?t.output:t.value;if(t.suffix){m.output+=t.suffix}}}return m};parse.fastpaths=(t,e)=>{const u={...e};const r=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;const a=t.length;if(a>r){throw new SyntaxError(`Input length: ${a}, exceeds maximum allowed length: ${r}`)}t=c[t]||t;const{DOT_LITERAL:i,SLASH_LITERAL:p,ONE_CHAR:l,DOTS_SLASH:f,NO_DOT:A,NO_DOTS:_,NO_DOTS_SLASH:R,STAR:E,START_ANCHOR:h}=n.globChars(u.windows);const g=u.dot?_:A;const b=u.dot?R:A;const C=u.capture?\"\":\"?:\";const y={negated:false,prefix:\"\"};let $=u.bash===true?\".*?\":E;if(u.capture){$=`(${$})`}const globstar=t=>{if(t.noglobstar===true)return $;return`(${C}(?:(?!${h}${t.dot?f:i}).)*?)`};const create=t=>{switch(t){case\"*\":return`${g}${l}${$}`;case\".*\":return`${i}${l}${$}`;case\"*.*\":return`${g}${$}${i}${l}${$}`;case\"*/*\":return`${g}${$}${p}${l}${b}${$}`;case\"**\":return g+globstar(u);case\"**/*\":return`(?:${g}${globstar(u)}${p})?${b}${l}${$}`;case\"**/*.*\":return`(?:${g}${globstar(u)}${p})?${b}${$}${i}${l}${$}`;case\"**/.*\":return`(?:${g}${globstar(u)}${p})?${i}${l}${$}`;default:{const e=/^(.*?)\\.(\\w+)$/.exec(t);if(!e)return;const u=create(e[1]);if(!u)return;return u+i+e[2]}}};const x=o.removePrefix(t,y);let S=create(x);if(S&&u.strictSlashes!==true){S+=`${p}?`}return S};t.exports=parse},510:(t,e,u)=>{const n=u(716);const o=u(697);const s=u(96);const r=u(154);const isObject=t=>t&&typeof t===\"object\"&&!Array.isArray(t);const picomatch=(t,e,u=false)=>{if(Array.isArray(t)){const n=t.map((t=>picomatch(t,e,u)));const arrayMatcher=t=>{for(const e of n){const u=e(t);if(u)return u}return false};return arrayMatcher}const n=isObject(t)&&t.tokens&&t.input;if(t===\"\"||typeof t!==\"string\"&&!n){throw new TypeError(\"Expected pattern to be a non-empty string\")}const o=e||{};const s=o.windows;const r=n?picomatch.compileRe(t,e):picomatch.makeRe(t,e,false,true);const a=r.state;delete r.state;let isIgnored=()=>false;if(o.ignore){const t={...e,ignore:null,onMatch:null,onResult:null};isIgnored=picomatch(o.ignore,t,u)}const matcher=(u,n=false)=>{const{isMatch:i,match:c,output:p}=picomatch.test(u,r,e,{glob:t,posix:s});const l={glob:t,state:a,regex:r,posix:s,input:u,output:p,match:c,isMatch:i};if(typeof o.onResult===\"function\"){o.onResult(l)}if(i===false){l.isMatch=false;return n?l:false}if(isIgnored(u)){if(typeof o.onIgnore===\"function\"){o.onIgnore(l)}l.isMatch=false;return n?l:false}if(typeof o.onMatch===\"function\"){o.onMatch(l)}return n?l:true};if(u){matcher.state=a}return matcher};picomatch.test=(t,e,u,{glob:n,posix:o}={})=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected input to be a string\")}if(t===\"\"){return{isMatch:false,output:\"\"}}const r=u||{};const a=r.format||(o?s.toPosixSlashes:null);let i=t===n;let c=i&&a?a(t):t;if(i===false){c=a?a(t):t;i=c===n}if(i===false||r.capture===true){if(r.matchBase===true||r.basename===true){i=picomatch.matchBase(t,e,u,o)}else{i=e.exec(c)}}return{isMatch:Boolean(i),match:i,output:c}};picomatch.matchBase=(t,e,u)=>{const n=e instanceof RegExp?e:picomatch.makeRe(e,u);return n.test(s.basename(t))};picomatch.isMatch=(t,e,u)=>picomatch(e,u)(t);picomatch.parse=(t,e)=>{if(Array.isArray(t))return t.map((t=>picomatch.parse(t,e)));return o(t,{...e,fastpaths:false})};picomatch.scan=(t,e)=>n(t,e);picomatch.compileRe=(t,e,u=false,n=false)=>{if(u===true){return t.output}const o=e||{};const s=o.contains?\"\":\"^\";const r=o.contains?\"\":\"$\";let a=`${s}(?:${t.output})${r}`;if(t&&t.negated===true){a=`^(?!${a}).*$`}const i=picomatch.toRegex(a,e);if(n===true){i.state=t}return i};picomatch.makeRe=(t,e={},u=false,n=false)=>{if(!t||typeof t!==\"string\"){throw new TypeError(\"Expected a non-empty string\")}let s={negated:false,fastpaths:true};if(e.fastpaths!==false&&(t[0]===\".\"||t[0]===\"*\")){s.output=o.fastpaths(t,e)}if(!s.output){s=o(t,e)}return picomatch.compileRe(s,e,u,n)};picomatch.toRegex=(t,e)=>{try{const u=e||{};return new RegExp(t,u.flags||(u.nocase?\"i\":\"\"))}catch(t){if(e&&e.debug===true)throw t;return/$^/}};picomatch.constants=r;t.exports=picomatch},716:(t,e,u)=>{const n=u(96);const{CHAR_ASTERISK:o,CHAR_AT:s,CHAR_BACKWARD_SLASH:r,CHAR_COMMA:a,CHAR_DOT:i,CHAR_EXCLAMATION_MARK:c,CHAR_FORWARD_SLASH:p,CHAR_LEFT_CURLY_BRACE:l,CHAR_LEFT_PARENTHESES:f,CHAR_LEFT_SQUARE_BRACKET:A,CHAR_PLUS:_,CHAR_QUESTION_MARK:R,CHAR_RIGHT_CURLY_BRACE:E,CHAR_RIGHT_PARENTHESES:h,CHAR_RIGHT_SQUARE_BRACKET:g}=u(154);const isPathSeparator=t=>t===p||t===r;const depth=t=>{if(t.isPrefix!==true){t.depth=t.isGlobstar?Infinity:1}};const scan=(t,e)=>{const u=e||{};const b=t.length-1;const C=u.parts===true||u.scanToEnd===true;const y=[];const $=[];const x=[];let S=t;let H=-1;let v=0;let d=0;let L=false;let T=false;let O=false;let k=false;let m=false;let w=false;let N=false;let I=false;let B=false;let G=false;let D=0;let M;let P;let K={value:\"\",depth:0,isGlob:false};const eos=()=>H>=b;const peek=()=>S.charCodeAt(H+1);const advance=()=>{M=P;return S.charCodeAt(++H)};while(H<b){P=advance();let t;if(P===r){N=K.backslashes=true;P=advance();if(P===l){w=true}continue}if(w===true||P===l){D++;while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;advance();continue}if(P===l){D++;continue}if(w!==true&&P===i&&(P=advance())===i){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(w!==true&&P===a){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===E){D--;if(D===0){w=false;L=K.isBrace=true;G=true;break}}}if(C===true){continue}break}if(P===p){y.push(H);$.push(K);K={value:\"\",depth:0,isGlob:false};if(G===true)continue;if(M===i&&H===v+1){v+=2;continue}d=H+1;continue}if(u.noext!==true){const t=P===_||P===s||P===o||P===R||P===c;if(t===true&&peek()===f){O=K.isGlob=true;k=K.isExtglob=true;G=true;if(P===c&&H===v){B=true}if(C===true){while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;P=advance();continue}if(P===h){O=K.isGlob=true;G=true;break}}continue}break}}if(P===o){if(M===o)m=K.isGlobstar=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===R){O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===A){while(eos()!==true&&(t=advance())){if(t===r){N=K.backslashes=true;advance();continue}if(t===g){T=K.isBracket=true;O=K.isGlob=true;G=true;break}}if(C===true){continue}break}if(u.nonegate!==true&&P===c&&H===v){I=K.negated=true;v++;continue}if(u.noparen!==true&&P===f){O=K.isGlob=true;if(C===true){while(eos()!==true&&(P=advance())){if(P===f){N=K.backslashes=true;P=advance();continue}if(P===h){G=true;break}}continue}break}if(O===true){G=true;if(C===true){continue}break}}if(u.noext===true){k=false;O=false}let U=S;let X=\"\";let F=\"\";if(v>0){X=S.slice(0,v);S=S.slice(v);d-=v}if(U&&O===true&&d>0){U=S.slice(0,d);F=S.slice(d)}else if(O===true){U=\"\";F=S}else{U=S}if(U&&U!==\"\"&&U!==\"/\"&&U!==S){if(isPathSeparator(U.charCodeAt(U.length-1))){U=U.slice(0,-1)}}if(u.unescape===true){if(F)F=n.removeBackslashes(F);if(U&&N===true){U=n.removeBackslashes(U)}}const Q={prefix:X,input:t,start:v,base:U,glob:F,isBrace:L,isBracket:T,isGlob:O,isExtglob:k,isGlobstar:m,negated:I,negatedExtglob:B};if(u.tokens===true){Q.maxDepth=0;if(!isPathSeparator(P)){$.push(K)}Q.tokens=$}if(u.parts===true||u.tokens===true){let e;for(let n=0;n<y.length;n++){const o=e?e+1:v;const s=y[n];const r=t.slice(o,s);if(u.tokens){if(n===0&&v!==0){$[n].isPrefix=true;$[n].value=X}else{$[n].value=r}depth($[n]);Q.maxDepth+=$[n].depth}if(n!==0||r!==\"\"){x.push(r)}e=s}if(e&&e+1<t.length){const n=t.slice(e+1);x.push(n);if(u.tokens){$[$.length-1].value=n;depth($[$.length-1]);Q.maxDepth+=$[$.length-1].depth}}Q.slashes=y;Q.parts=x}return Q};t.exports=scan},96:(t,e,u)=>{const{REGEX_BACKSLASH:n,REGEX_REMOVE_BACKSLASH:o,REGEX_SPECIAL_CHARS:s,REGEX_SPECIAL_CHARS_GLOBAL:r}=u(154);e.isObject=t=>t!==null&&typeof t===\"object\"&&!Array.isArray(t);e.hasRegexChars=t=>s.test(t);e.isRegexChar=t=>t.length===1&&e.hasRegexChars(t);e.escapeRegex=t=>t.replace(r,\"\\\\$1\");e.toPosixSlashes=t=>t.replace(n,\"/\");e.removeBackslashes=t=>t.replace(o,(t=>t===\"\\\\\"?\"\":t));e.escapeLast=(t,u,n)=>{const o=t.lastIndexOf(u,n);if(o===-1)return t;if(t[o-1]===\"\\\\\")return e.escapeLast(t,u,o-1);return`${t.slice(0,o)}\\\\${t.slice(o)}`};e.removePrefix=(t,e={})=>{let u=t;if(u.startsWith(\"./\")){u=u.slice(2);e.prefix=\"./\"}return u};e.wrapOutput=(t,e={},u={})=>{const n=u.contains?\"\":\"^\";const o=u.contains?\"\":\"$\";let s=`${n}(?:${t})${o}`;if(e.negated===true){s=`(?:^(?!${s}).*$)`}return s};e.basename=(t,{windows:e}={})=>{const u=t.split(e?/[\\\\/]/:\"/\");const n=u[u.length-1];if(n===\"\"){return u[u.length-2]}return n}}};var e={};function __nccwpck_require__(u){var n=e[u];if(n!==undefined){return n.exports}var o=e[u]={exports:{}};var s=true;try{t[u](o,o.exports,__nccwpck_require__);s=false}finally{if(s)delete e[u]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var u=__nccwpck_require__(170);module.exports=u})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGljb21hdGNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUEsTUFBTSxhQUFhLE9BQU8sY0FBYyxlQUFlLHFCQUFxQix1REFBdUQseUNBQXlDLGtDQUFrQyxVQUFVLE9BQU8sZ0JBQWdCLE9BQU8sV0FBVyxPQUFPLE9BQU8sb0JBQW9CLGNBQWMsZ0NBQWdDLGlEQUFpRCxHQUFHLDBCQUEwQixnQkFBZ0IsMkJBQTJCLG9CQUFvQixTQUFTLGdCQUFnQixhQUFhLEVBQUUsR0FBRyxjQUFjLGNBQWMsY0FBYyxjQUFjLGdCQUFnQixlQUFlLGNBQWMsRUFBRSxLQUFLLGdCQUFnQixFQUFFLEdBQUcsV0FBVyxHQUFHLElBQUksRUFBRSxFQUFFLEVBQUUsY0FBYyxFQUFFLEdBQUcsY0FBYyxFQUFFLEVBQUUsRUFBRSxHQUFHLGNBQWMsR0FBRyxJQUFJLEVBQUUsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLFdBQVcsRUFBRSxJQUFJLFlBQVksU0FBUyx3TUFBd00sU0FBUyx1QkFBdUIsRUFBRSxtQkFBbUIsRUFBRSxrQkFBa0IsR0FBRyxJQUFJLE1BQU0sRUFBRSxtQkFBbUIsRUFBRSx1QkFBdUIsRUFBRSxJQUFJLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMkJBQTJCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEVBQUUseUJBQXlCLEVBQUUsc0JBQXNCLEVBQUUsZ0JBQWdCLFNBQVMseUxBQXlMLGFBQWEsRUFBRSw4RUFBOEUsV0FBVyxzRUFBc0UscURBQXFELHlDQUF5QyxnR0FBZ0csNEVBQTRFLHVDQUF1QyxtM0JBQW0zQixPQUFPLEtBQUss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Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTQuMi4xX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjFfc2Fzc0AxLjc3LjIvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9waWNvbWF0Y2gvaW5kZXguanM/NWI1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgdD17MTcwOih0LGUsdSk9Pntjb25zdCBuPXUoNTEwKTtjb25zdCBpc1dpbmRvd3M9KCk9PntpZih0eXBlb2YgbmF2aWdhdG9yIT09XCJ1bmRlZmluZWRcIiYmbmF2aWdhdG9yLnBsYXRmb3JtKXtjb25zdCB0PW5hdmlnYXRvci5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO3JldHVybiB0PT09XCJ3aW4zMlwifHx0PT09XCJ3aW5kb3dzXCJ9aWYodHlwZW9mIHByb2Nlc3MhPT1cInVuZGVmaW5lZFwiJiZwcm9jZXNzLnBsYXRmb3JtKXtyZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybT09PVwid2luMzJcIn1yZXR1cm4gZmFsc2V9O2Z1bmN0aW9uIHBpY29tYXRjaCh0LGUsdT1mYWxzZSl7aWYoZSYmKGUud2luZG93cz09PW51bGx8fGUud2luZG93cz09PXVuZGVmaW5lZCkpe2U9ey4uLmUsd2luZG93czppc1dpbmRvd3MoKX19cmV0dXJuIG4odCxlLHUpfU9iamVjdC5hc3NpZ24ocGljb21hdGNoLG4pO3QuZXhwb3J0cz1waWNvbWF0Y2h9LDE1NDp0PT57Y29uc3QgZT1cIlxcXFxcXFxcL1wiO2NvbnN0IHU9YFteJHtlfV1gO2NvbnN0IG49XCJcXFxcLlwiO2NvbnN0IG89XCJcXFxcK1wiO2NvbnN0IHM9XCJcXFxcP1wiO2NvbnN0IHI9XCJcXFxcL1wiO2NvbnN0IGE9XCIoPz0uKVwiO2NvbnN0IGk9XCJbXi9dXCI7Y29uc3QgYz1gKD86JHtyfXwkKWA7Y29uc3QgcD1gKD86Xnwke3J9KWA7Y29uc3QgbD1gJHtufXsxLDJ9JHtjfWA7Y29uc3QgZj1gKD8hJHtufSlgO2NvbnN0IEE9YCg/ISR7cH0ke2x9KWA7Y29uc3QgXz1gKD8hJHtufXswLDF9JHtjfSlgO2NvbnN0IFI9YCg/ISR7bH0pYDtjb25zdCBFPWBbXi4ke3J9XWA7Y29uc3QgaD1gJHtpfSo/YDtjb25zdCBnPVwiL1wiO2NvbnN0IGI9e0RPVF9MSVRFUkFMOm4sUExVU19MSVRFUkFMOm8sUU1BUktfTElURVJBTDpzLFNMQVNIX0xJVEVSQUw6cixPTkVfQ0hBUjphLFFNQVJLOmksRU5EX0FOQ0hPUjpjLERPVFNfU0xBU0g6bCxOT19ET1Q6ZixOT19ET1RTOkEsTk9fRE9UX1NMQVNIOl8sTk9fRE9UU19TTEFTSDpSLFFNQVJLX05PX0RPVDpFLFNUQVI6aCxTVEFSVF9BTkNIT1I6cCxTRVA6Z307Y29uc3QgQz17Li4uYixTTEFTSF9MSVRFUkFMOmBbJHtlfV1gLFFNQVJLOnUsU1RBUjpgJHt1fSo/YCxET1RTX1NMQVNIOmAke259ezEsMn0oPzpbJHtlfV18JClgLE5PX0RPVDpgKD8hJHtufSlgLE5PX0RPVFM6YCg/ISg/Ol58WyR7ZX1dKSR7bn17MSwyfSg/Olske2V9XXwkKSlgLE5PX0RPVF9TTEFTSDpgKD8hJHtufXswLDF9KD86WyR7ZX1dfCQpKWAsTk9fRE9UU19TTEFTSDpgKD8hJHtufXsxLDJ9KD86WyR7ZX1dfCQpKWAsUU1BUktfTk9fRE9UOmBbXi4ke2V9XWAsU1RBUlRfQU5DSE9SOmAoPzpefFske2V9XSlgLEVORF9BTkNIT1I6YCg/Olske2V9XXwkKWAsU0VQOlwiXFxcXFwifTtjb25zdCB5PXthbG51bTpcImEtekEtWjAtOVwiLGFscGhhOlwiYS16QS1aXCIsYXNjaWk6XCJcXFxceDAwLVxcXFx4N0ZcIixibGFuazpcIiBcXFxcdFwiLGNudHJsOlwiXFxcXHgwMC1cXFxceDFGXFxcXHg3RlwiLGRpZ2l0OlwiMC05XCIsZ3JhcGg6XCJcXFxceDIxLVxcXFx4N0VcIixsb3dlcjpcImEtelwiLHByaW50OlwiXFxcXHgyMC1cXFxceDdFIFwiLHB1bmN0OlwiXFxcXC0hXFxcIiMkJSYnKClcXFxcKissLi86Ozw9Pj9AW1xcXFxdXl9ge3x9flwiLHNwYWNlOlwiIFxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGZcIix1cHBlcjpcIkEtWlwiLHdvcmQ6XCJBLVphLXowLTlfXCIseGRpZ2l0OlwiQS1GYS1mMC05XCJ9O3QuZXhwb3J0cz17TUFYX0xFTkdUSDoxMDI0KjY0LFBPU0lYX1JFR0VYX1NPVVJDRTp5LFJFR0VYX0JBQ0tTTEFTSDovXFxcXCg/IVsqKz9eJHt9KHwpW1xcXV0pL2csUkVHRVhfTk9OX1NQRUNJQUxfQ0hBUlM6L15bXkAhW1xcXS4sJCorP157fSgpfFxcXFwvXSsvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6L1stKis/Ll4ke30ofClbXFxdXS8sUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGOi8oXFxcXD8pKChcXFcpKFxcMyopKS9nLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOi8oWy0qKz8uXiR7fSh8KVtcXF1dKS9nLFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6Lyg/OlxcWy4qP1teXFxcXF1cXF18XFxcXCg/PS4pKS9nLFJFUExBQ0VNRU5UUzp7XCIqKipcIjpcIipcIixcIioqLyoqXCI6XCIqKlwiLFwiKiovKiovKipcIjpcIioqXCJ9LENIQVJfMDo0OCxDSEFSXzk6NTcsQ0hBUl9VUFBFUkNBU0VfQTo2NSxDSEFSX0xPV0VSQ0FTRV9BOjk3LENIQVJfVVBQRVJDQVNFX1o6OTAsQ0hBUl9MT1dFUkNBU0VfWjoxMjIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOjQwLENIQVJfUklHSFRfUEFSRU5USEVTRVM6NDEsQ0hBUl9BU1RFUklTSzo0MixDSEFSX0FNUEVSU0FORDozOCxDSEFSX0FUOjY0LENIQVJfQkFDS1dBUkRfU0xBU0g6OTIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46MTMsQ0hBUl9DSVJDVU1GTEVYX0FDQ0VOVDo5NCxDSEFSX0NPTE9OOjU4LENIQVJfQ09NTUE6NDQsQ0hBUl9ET1Q6NDYsQ0hBUl9ET1VCTEVfUVVPVEU6MzQsQ0hBUl9FUVVBTDo2MSxDSEFSX0VYQ0xBTUFUSU9OX01BUks6MzMsQ0hBUl9GT1JNX0ZFRUQ6MTIsQ0hBUl9GT1JXQVJEX1NMQVNIOjQ3LENIQVJfR1JBVkVfQUNDRU5UOjk2LENIQVJfSEFTSDozNSxDSEFSX0hZUEhFTl9NSU5VUzo0NSxDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDo2MCxDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6MTIzLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDo5MSxDSEFSX0xJTkVfRkVFRDoxMCxDSEFSX05PX0JSRUFLX1NQQUNFOjE2MCxDSEFSX1BFUkNFTlQ6MzcsQ0hBUl9QTFVTOjQzLENIQVJfUVVFU1RJT05fTUFSSzo2MyxDSEFSX1JJR0hUX0FOR0xFX0JSQUNLRVQ6NjIsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRToxMjUsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDo5MyxDSEFSX1NFTUlDT0xPTjo1OSxDSEFSX1NJTkdMRV9RVU9URTozOSxDSEFSX1NQQUNFOjMyLENIQVJfVEFCOjksQ0hBUl9VTkRFUlNDT1JFOjk1LENIQVJfVkVSVElDQUxfTElORToxMjQsQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0U6NjUyNzksZXh0Z2xvYkNoYXJzKHQpe3JldHVybntcIiFcIjp7dHlwZTpcIm5lZ2F0ZVwiLG9wZW46XCIoPzooPyEoPzpcIixjbG9zZTpgKSkke3QuU1RBUn0pYH0sXCI/XCI6e3R5cGU6XCJxbWFya1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIik/XCJ9LFwiK1wiOnt0eXBlOlwicGx1c1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIikrXCJ9LFwiKlwiOnt0eXBlOlwic3RhclwiLG9wZW46XCIoPzpcIixjbG9zZTpcIikqXCJ9LFwiQFwiOnt0eXBlOlwiYXRcIixvcGVuOlwiKD86XCIsY2xvc2U6XCIpXCJ9fX0sZ2xvYkNoYXJzKHQpe3JldHVybiB0PT09dHJ1ZT9DOmJ9fX0sNjk3Oih0LGUsdSk9Pntjb25zdCBuPXUoMTU0KTtjb25zdCBvPXUoOTYpO2NvbnN0e01BWF9MRU5HVEg6cyxQT1NJWF9SRUdFWF9TT1VSQ0U6cixSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzphLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjppLFJFUExBQ0VNRU5UUzpjfT1uO2NvbnN0IGV4cGFuZFJhbmdlPSh0LGUpPT57aWYodHlwZW9mIGUuZXhwYW5kUmFuZ2U9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBlLmV4cGFuZFJhbmdlKC4uLnQsZSl9dC5zb3J0KCk7Y29uc3QgdT1gWyR7dC5qb2luKFwiLVwiKX1dYDt0cnl7bmV3IFJlZ0V4cCh1KX1jYXRjaChlKXtyZXR1cm4gdC5tYXAoKHQ9Pm8uZXNjYXBlUmVnZXgodCkpKS5qb2luKFwiLi5cIil9cmV0dXJuIHV9O2NvbnN0IHN5bnRheEVycm9yPSh0LGUpPT5gTWlzc2luZyAke3R9OiBcIiR7ZX1cIiAtIHVzZSBcIlxcXFxcXFxcJHtlfVwiIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc2A7Y29uc3QgcGFyc2U9KHQsZSk9PntpZih0eXBlb2YgdCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKX10PWNbdF18fHQ7Y29uc3QgdT17Li4uZX07Y29uc3QgcD10eXBlb2YgdS5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsdS5tYXhMZW5ndGgpOnM7bGV0IGw9dC5sZW5ndGg7aWYobD5wKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtsfSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke3B9YCl9Y29uc3QgZj17dHlwZTpcImJvc1wiLHZhbHVlOlwiXCIsb3V0cHV0OnUucHJlcGVuZHx8XCJcIn07Y29uc3QgQT1bZl07Y29uc3QgXz11LmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgUj1uLmdsb2JDaGFycyh1LndpbmRvd3MpO2NvbnN0IEU9bi5leHRnbG9iQ2hhcnMoUik7Y29uc3R7RE9UX0xJVEVSQUw6aCxQTFVTX0xJVEVSQUw6ZyxTTEFTSF9MSVRFUkFMOmIsT05FX0NIQVI6QyxET1RTX1NMQVNIOnksTk9fRE9UOiQsTk9fRE9UX1NMQVNIOngsTk9fRE9UU19TTEFTSDpTLFFNQVJLOkgsUU1BUktfTk9fRE9UOnYsU1RBUjpkLFNUQVJUX0FOQ0hPUjpMfT1SO2NvbnN0IGdsb2JzdGFyPXQ9PmAoJHtffSg/Oig/ISR7TH0ke3QuZG90P3k6aH0pLikqPylgO2NvbnN0IFQ9dS5kb3Q/XCJcIjokO2NvbnN0IE89dS5kb3Q/SDp2O2xldCBrPXUuYmFzaD09PXRydWU/Z2xvYnN0YXIodSk6ZDtpZih1LmNhcHR1cmUpe2s9YCgke2t9KWB9aWYodHlwZW9mIHUubm9leHQ9PT1cImJvb2xlYW5cIil7dS5ub2V4dGdsb2I9dS5ub2V4dH1jb25zdCBtPXtpbnB1dDp0LGluZGV4Oi0xLHN0YXJ0OjAsZG90OnUuZG90PT09dHJ1ZSxjb25zdW1lZDpcIlwiLG91dHB1dDpcIlwiLHByZWZpeDpcIlwiLGJhY2t0cmFjazpmYWxzZSxuZWdhdGVkOmZhbHNlLGJyYWNrZXRzOjAsYnJhY2VzOjAscGFyZW5zOjAscXVvdGVzOjAsZ2xvYnN0YXI6ZmFsc2UsdG9rZW5zOkF9O3Q9by5yZW1vdmVQcmVmaXgodCxtKTtsPXQubGVuZ3RoO2NvbnN0IHc9W107Y29uc3QgTj1bXTtjb25zdCBJPVtdO2xldCBCPWY7bGV0IEc7Y29uc3QgZW9zPSgpPT5tLmluZGV4PT09bC0xO2NvbnN0IEQ9bS5wZWVrPShlPTEpPT50W20uaW5kZXgrZV07Y29uc3QgTT1tLmFkdmFuY2U9KCk9PnRbKyttLmluZGV4XXx8XCJcIjtjb25zdCByZW1haW5pbmc9KCk9PnQuc2xpY2UobS5pbmRleCsxKTtjb25zdCBjb25zdW1lPSh0PVwiXCIsZT0wKT0+e20uY29uc3VtZWQrPXQ7bS5pbmRleCs9ZX07Y29uc3QgYXBwZW5kPXQ9PnttLm91dHB1dCs9dC5vdXRwdXQhPW51bGw/dC5vdXRwdXQ6dC52YWx1ZTtjb25zdW1lKHQudmFsdWUpfTtjb25zdCBuZWdhdGU9KCk9PntsZXQgdD0xO3doaWxlKEQoKT09PVwiIVwiJiYoRCgyKSE9PVwiKFwifHxEKDMpPT09XCI/XCIpKXtNKCk7bS5zdGFydCsrO3QrK31pZih0JTI9PT0wKXtyZXR1cm4gZmFsc2V9bS5uZWdhdGVkPXRydWU7bS5zdGFydCsrO3JldHVybiB0cnVlfTtjb25zdCBpbmNyZW1lbnQ9dD0+e21bdF0rKztJLnB1c2godCl9O2NvbnN0IGRlY3JlbWVudD10PT57bVt0XS0tO0kucG9wKCl9O2NvbnN0IHB1c2g9dD0+e2lmKEIudHlwZT09PVwiZ2xvYnN0YXJcIil7Y29uc3QgZT1tLmJyYWNlcz4wJiYodC50eXBlPT09XCJjb21tYVwifHx0LnR5cGU9PT1cImJyYWNlXCIpO2NvbnN0IHU9dC5leHRnbG9iPT09dHJ1ZXx8dy5sZW5ndGgmJih0LnR5cGU9PT1cInBpcGVcInx8dC50eXBlPT09XCJwYXJlblwiKTtpZih0LnR5cGUhPT1cInNsYXNoXCImJnQudHlwZSE9PVwicGFyZW5cIiYmIWUmJiF1KXttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC1CLm91dHB1dC5sZW5ndGgpO0IudHlwZT1cInN0YXJcIjtCLnZhbHVlPVwiKlwiO0Iub3V0cHV0PWs7bS5vdXRwdXQrPUIub3V0cHV0fX1pZih3Lmxlbmd0aCYmdC50eXBlIT09XCJwYXJlblwiKXt3W3cubGVuZ3RoLTFdLmlubmVyKz10LnZhbHVlfWlmKHQudmFsdWV8fHQub3V0cHV0KWFwcGVuZCh0KTtpZihCJiZCLnR5cGU9PT1cInRleHRcIiYmdC50eXBlPT09XCJ0ZXh0XCIpe0Iub3V0cHV0PShCLm91dHB1dHx8Qi52YWx1ZSkrdC52YWx1ZTtCLnZhbHVlKz10LnZhbHVlO3JldHVybn10LnByZXY9QjtBLnB1c2godCk7Qj10fTtjb25zdCBleHRnbG9iT3Blbj0odCxlKT0+e2NvbnN0IG49ey4uLkVbZV0sY29uZGl0aW9uczoxLGlubmVyOlwiXCJ9O24ucHJldj1CO24ucGFyZW5zPW0ucGFyZW5zO24ub3V0cHV0PW0ub3V0cHV0O2NvbnN0IG89KHUuY2FwdHVyZT9cIihcIjpcIlwiKStuLm9wZW47aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6dCx2YWx1ZTplLG91dHB1dDptLm91dHB1dD9cIlwiOkN9KTtwdXNoKHt0eXBlOlwicGFyZW5cIixleHRnbG9iOnRydWUsdmFsdWU6TSgpLG91dHB1dDpvfSk7dy5wdXNoKG4pfTtjb25zdCBleHRnbG9iQ2xvc2U9dD0+e2xldCBuPXQuY2xvc2UrKHUuY2FwdHVyZT9cIilcIjpcIlwiKTtsZXQgbztpZih0LnR5cGU9PT1cIm5lZ2F0ZVwiKXtsZXQgcz1rO2lmKHQuaW5uZXImJnQuaW5uZXIubGVuZ3RoPjEmJnQuaW5uZXIuaW5jbHVkZXMoXCIvXCIpKXtzPWdsb2JzdGFyKHUpfWlmKHMhPT1rfHxlb3MoKXx8L15cXCkrJC8udGVzdChyZW1haW5pbmcoKSkpe249dC5jbG9zZT1gKSQpKSR7c31gfWlmKHQuaW5uZXIuaW5jbHVkZXMoXCIqXCIpJiYobz1yZW1haW5pbmcoKSkmJi9eXFwuW15cXFxcLy5dKyQvLnRlc3Qobykpe2NvbnN0IHU9cGFyc2Uobyx7Li4uZSxmYXN0cGF0aHM6ZmFsc2V9KS5vdXRwdXQ7bj10LmNsb3NlPWApJHt1fSkke3N9KWB9aWYodC5wcmV2LnR5cGU9PT1cImJvc1wiKXttLm5lZ2F0ZWRFeHRnbG9iPXRydWV9fXB1c2goe3R5cGU6XCJwYXJlblwiLGV4dGdsb2I6dHJ1ZSx2YWx1ZTpHLG91dHB1dDpufSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpfTtpZih1LmZhc3RwYXRocyE9PWZhbHNlJiYhLyheWyohXXxbLygpW1xcXXt9XCJdKS8udGVzdCh0KSl7bGV0IG49ZmFsc2U7bGV0IHM9dC5yZXBsYWNlKGksKCh0LGUsdSxvLHMscik9PntpZihvPT09XCJcXFxcXCIpe249dHJ1ZTtyZXR1cm4gdH1pZihvPT09XCI/XCIpe2lmKGUpe3JldHVybiBlK28rKHM/SC5yZXBlYXQocy5sZW5ndGgpOlwiXCIpfWlmKHI9PT0wKXtyZXR1cm4gTysocz9ILnJlcGVhdChzLmxlbmd0aCk6XCJcIil9cmV0dXJuIEgucmVwZWF0KHUubGVuZ3RoKX1pZihvPT09XCIuXCIpe3JldHVybiBoLnJlcGVhdCh1Lmxlbmd0aCl9aWYobz09PVwiKlwiKXtpZihlKXtyZXR1cm4gZStvKyhzP2s6XCJcIil9cmV0dXJuIGt9cmV0dXJuIGU/dDpgXFxcXCR7dH1gfSkpO2lmKG49PT10cnVlKXtpZih1LnVuZXNjYXBlPT09dHJ1ZSl7cz1zLnJlcGxhY2UoL1xcXFwvZyxcIlwiKX1lbHNle3M9cy5yZXBsYWNlKC9cXFxcKy9nLCh0PT50Lmxlbmd0aCUyPT09MD9cIlxcXFxcXFxcXCI6dD9cIlxcXFxcIjpcIlwiKSl9fWlmKHM9PT10JiZ1LmNvbnRhaW5zPT09dHJ1ZSl7bS5vdXRwdXQ9dDtyZXR1cm4gbX1tLm91dHB1dD1vLndyYXBPdXRwdXQocyxtLGUpO3JldHVybiBtfXdoaWxlKCFlb3MoKSl7Rz1NKCk7aWYoRz09PVwiXFwwXCIpe2NvbnRpbnVlfWlmKEc9PT1cIlxcXFxcIil7Y29uc3QgdD1EKCk7aWYodD09PVwiL1wiJiZ1LmJhc2ghPT10cnVlKXtjb250aW51ZX1pZih0PT09XCIuXCJ8fHQ9PT1cIjtcIil7Y29udGludWV9aWYoIXQpe0crPVwiXFxcXFwiO3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6R30pO2NvbnRpbnVlfWNvbnN0IGU9L15cXFxcKy8uZXhlYyhyZW1haW5pbmcoKSk7bGV0IG49MDtpZihlJiZlWzBdLmxlbmd0aD4yKXtuPWVbMF0ubGVuZ3RoO20uaW5kZXgrPW47aWYobiUyIT09MCl7Rys9XCJcXFxcXCJ9fWlmKHUudW5lc2NhcGU9PT10cnVlKXtHPU0oKX1lbHNle0crPU0oKX1pZihtLmJyYWNrZXRzPT09MCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9fWlmKG0uYnJhY2tldHM+MCYmKEchPT1cIl1cInx8Qi52YWx1ZT09PVwiW1wifHxCLnZhbHVlPT09XCJbXlwiKSl7aWYodS5wb3NpeCE9PWZhbHNlJiZHPT09XCI6XCIpe2NvbnN0IHQ9Qi52YWx1ZS5zbGljZSgxKTtpZih0LmluY2x1ZGVzKFwiW1wiKSl7Qi5wb3NpeD10cnVlO2lmKHQuaW5jbHVkZXMoXCI6XCIpKXtjb25zdCB0PUIudmFsdWUubGFzdEluZGV4T2YoXCJbXCIpO2NvbnN0IGU9Qi52YWx1ZS5zbGljZSgwLHQpO2NvbnN0IHU9Qi52YWx1ZS5zbGljZSh0KzIpO2NvbnN0IG49clt1XTtpZihuKXtCLnZhbHVlPWUrbjttLmJhY2t0cmFjaz10cnVlO00oKTtpZighZi5vdXRwdXQmJkEuaW5kZXhPZihCKT09PTEpe2Yub3V0cHV0PUN9Y29udGludWV9fX19aWYoRz09PVwiW1wiJiZEKCkhPT1cIjpcInx8Rz09PVwiLVwiJiZEKCk9PT1cIl1cIil7Rz1gXFxcXCR7R31gfWlmKEc9PT1cIl1cIiYmKEIudmFsdWU9PT1cIltcInx8Qi52YWx1ZT09PVwiW15cIikpe0c9YFxcXFwke0d9YH1pZih1LnBvc2l4PT09dHJ1ZSYmRz09PVwiIVwiJiZCLnZhbHVlPT09XCJbXCIpe0c9XCJeXCJ9Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtjb250aW51ZX1pZihtLnF1b3Rlcz09PTEmJkchPT0nXCInKXtHPW8uZXNjYXBlUmVnZXgoRyk7Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09J1wiJyl7bS5xdW90ZXM9bS5xdW90ZXM9PT0xPzA6MTtpZih1LmtlZXBRdW90ZXM9PT10cnVlKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KX1jb250aW51ZX1pZihHPT09XCIoXCIpe2luY3JlbWVudChcInBhcmVuc1wiKTtwdXNoKHt0eXBlOlwicGFyZW5cIix2YWx1ZTpHfSk7Y29udGludWV9aWYoRz09PVwiKVwiKXtpZihtLnBhcmVucz09PTAmJnUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCIoXCIpKX1jb25zdCB0PXdbdy5sZW5ndGgtMV07aWYodCYmbS5wYXJlbnM9PT10LnBhcmVucysxKXtleHRnbG9iQ2xvc2Uody5wb3AoKSk7Y29udGludWV9cHVzaCh7dHlwZTpcInBhcmVuXCIsdmFsdWU6RyxvdXRwdXQ6bS5wYXJlbnM/XCIpXCI6XCJcXFxcKVwifSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpO2NvbnRpbnVlfWlmKEc9PT1cIltcIil7aWYodS5ub2JyYWNrZXQ9PT10cnVlfHwhcmVtYWluaW5nKCkuaW5jbHVkZXMoXCJdXCIpKXtpZih1Lm5vYnJhY2tldCE9PXRydWUmJnUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJdXCIpKX1HPWBcXFxcJHtHfWB9ZWxzZXtpbmNyZW1lbnQoXCJicmFja2V0c1wiKX1wdXNoKHt0eXBlOlwiYnJhY2tldFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCJdXCIpe2lmKHUubm9icmFja2V0PT09dHJ1ZXx8QiYmQi50eXBlPT09XCJicmFja2V0XCImJkIudmFsdWUubGVuZ3RoPT09MSl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpgXFxcXCR7R31gfSk7Y29udGludWV9aWYobS5icmFja2V0cz09PTApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCJbXCIpKX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkcsb3V0cHV0OmBcXFxcJHtHfWB9KTtjb250aW51ZX1kZWNyZW1lbnQoXCJicmFja2V0c1wiKTtjb25zdCB0PUIudmFsdWUuc2xpY2UoMSk7aWYoQi5wb3NpeCE9PXRydWUmJnRbMF09PT1cIl5cIiYmIXQuaW5jbHVkZXMoXCIvXCIpKXtHPWAvJHtHfWB9Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtpZih1LmxpdGVyYWxCcmFja2V0cz09PWZhbHNlfHxvLmhhc1JlZ2V4Q2hhcnModCkpe2NvbnRpbnVlfWNvbnN0IGU9by5lc2NhcGVSZWdleChCLnZhbHVlKTttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC1CLnZhbHVlLmxlbmd0aCk7aWYodS5saXRlcmFsQnJhY2tldHM9PT10cnVlKXttLm91dHB1dCs9ZTtCLnZhbHVlPWU7Y29udGludWV9Qi52YWx1ZT1gKCR7X30ke2V9fCR7Qi52YWx1ZX0pYDttLm91dHB1dCs9Qi52YWx1ZTtjb250aW51ZX1pZihHPT09XCJ7XCImJnUubm9icmFjZSE9PXRydWUpe2luY3JlbWVudChcImJyYWNlc1wiKTtjb25zdCB0PXt0eXBlOlwiYnJhY2VcIix2YWx1ZTpHLG91dHB1dDpcIihcIixvdXRwdXRJbmRleDptLm91dHB1dC5sZW5ndGgsdG9rZW5zSW5kZXg6bS50b2tlbnMubGVuZ3RofTtOLnB1c2godCk7cHVzaCh0KTtjb250aW51ZX1pZihHPT09XCJ9XCIpe2NvbnN0IHQ9TltOLmxlbmd0aC0xXTtpZih1Lm5vYnJhY2U9PT10cnVlfHwhdCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpHfSk7Y29udGludWV9bGV0IGU9XCIpXCI7aWYodC5kb3RzPT09dHJ1ZSl7Y29uc3QgdD1BLnNsaWNlKCk7Y29uc3Qgbj1bXTtmb3IobGV0IGU9dC5sZW5ndGgtMTtlPj0wO2UtLSl7QS5wb3AoKTtpZih0W2VdLnR5cGU9PT1cImJyYWNlXCIpe2JyZWFrfWlmKHRbZV0udHlwZSE9PVwiZG90c1wiKXtuLnVuc2hpZnQodFtlXS52YWx1ZSl9fWU9ZXhwYW5kUmFuZ2Uobix1KTttLmJhY2t0cmFjaz10cnVlfWlmKHQuY29tbWEhPT10cnVlJiZ0LmRvdHMhPT10cnVlKXtjb25zdCB1PW0ub3V0cHV0LnNsaWNlKDAsdC5vdXRwdXRJbmRleCk7Y29uc3Qgbj1tLnRva2Vucy5zbGljZSh0LnRva2Vuc0luZGV4KTt0LnZhbHVlPXQub3V0cHV0PVwiXFxcXHtcIjtHPWU9XCJcXFxcfVwiO20ub3V0cHV0PXU7Zm9yKGNvbnN0IHQgb2Ygbil7bS5vdXRwdXQrPXQub3V0cHV0fHx0LnZhbHVlfX1wdXNoKHt0eXBlOlwiYnJhY2VcIix2YWx1ZTpHLG91dHB1dDplfSk7ZGVjcmVtZW50KFwiYnJhY2VzXCIpO04ucG9wKCk7Y29udGludWV9aWYoRz09PVwifFwiKXtpZih3Lmxlbmd0aD4wKXt3W3cubGVuZ3RoLTFdLmNvbmRpdGlvbnMrK31wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCIsXCIpe2xldCB0PUc7Y29uc3QgZT1OW04ubGVuZ3RoLTFdO2lmKGUmJklbSS5sZW5ndGgtMV09PT1cImJyYWNlc1wiKXtlLmNvbW1hPXRydWU7dD1cInxcIn1wdXNoKHt0eXBlOlwiY29tbWFcIix2YWx1ZTpHLG91dHB1dDp0fSk7Y29udGludWV9aWYoRz09PVwiL1wiKXtpZihCLnR5cGU9PT1cImRvdFwiJiZtLmluZGV4PT09bS5zdGFydCsxKXttLnN0YXJ0PW0uaW5kZXgrMTttLmNvbnN1bWVkPVwiXCI7bS5vdXRwdXQ9XCJcIjtBLnBvcCgpO0I9Zjtjb250aW51ZX1wdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpHLG91dHB1dDpifSk7Y29udGludWV9aWYoRz09PVwiLlwiKXtpZihtLmJyYWNlcz4wJiZCLnR5cGU9PT1cImRvdFwiKXtpZihCLnZhbHVlPT09XCIuXCIpQi5vdXRwdXQ9aDtjb25zdCB0PU5bTi5sZW5ndGgtMV07Qi50eXBlPVwiZG90c1wiO0Iub3V0cHV0Kz1HO0IudmFsdWUrPUc7dC5kb3RzPXRydWU7Y29udGludWV9aWYobS5icmFjZXMrbS5wYXJlbnM9PT0wJiZCLnR5cGUhPT1cImJvc1wiJiZCLnR5cGUhPT1cInNsYXNoXCIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6aH0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJkb3RcIix2YWx1ZTpHLG91dHB1dDpofSk7Y29udGludWV9aWYoRz09PVwiP1wiKXtjb25zdCB0PUImJkIudmFsdWU9PT1cIihcIjtpZighdCYmdS5ub2V4dGdsb2IhPT10cnVlJiZEKCk9PT1cIihcIiYmRCgyKSE9PVwiP1wiKXtleHRnbG9iT3BlbihcInFtYXJrXCIsRyk7Y29udGludWV9aWYoQiYmQi50eXBlPT09XCJwYXJlblwiKXtjb25zdCB0PUQoKTtsZXQgZT1HO2lmKEIudmFsdWU9PT1cIihcIiYmIS9bIT08Ol0vLnRlc3QodCl8fHQ9PT1cIjxcIiYmIS88KFshPV18XFx3Kz4pLy50ZXN0KHJlbWFpbmluZygpKSl7ZT1gXFxcXCR7R31gfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6ZX0pO2NvbnRpbnVlfWlmKHUuZG90IT09dHJ1ZSYmKEIudHlwZT09PVwic2xhc2hcInx8Qi50eXBlPT09XCJib3NcIikpe3B1c2goe3R5cGU6XCJxbWFya1wiLHZhbHVlOkcsb3V0cHV0OnZ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicW1hcmtcIix2YWx1ZTpHLG91dHB1dDpIfSk7Y29udGludWV9aWYoRz09PVwiIVwiKXtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJkQoKT09PVwiKFwiKXtpZihEKDIpIT09XCI/XCJ8fCEvWyE9PDpdLy50ZXN0KEQoMykpKXtleHRnbG9iT3BlbihcIm5lZ2F0ZVwiLEcpO2NvbnRpbnVlfX1pZih1Lm5vbmVnYXRlIT09dHJ1ZSYmbS5pbmRleD09PTApe25lZ2F0ZSgpO2NvbnRpbnVlfX1pZihHPT09XCIrXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCImJkQoMikhPT1cIj9cIil7ZXh0Z2xvYk9wZW4oXCJwbHVzXCIsRyk7Y29udGludWV9aWYoQiYmQi52YWx1ZT09PVwiKFwifHx1LnJlZ2V4PT09ZmFsc2Upe3B1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6RyxvdXRwdXQ6Z30pO2NvbnRpbnVlfWlmKEImJihCLnR5cGU9PT1cImJyYWNrZXRcInx8Qi50eXBlPT09XCJwYXJlblwifHxCLnR5cGU9PT1cImJyYWNlXCIpfHxtLnBhcmVucz4wKXtwdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOkd9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOmd9KTtjb250aW51ZX1pZihHPT09XCJAXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCImJkQoMikhPT1cIj9cIil7cHVzaCh7dHlwZTpcImF0XCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHIT09XCIqXCIpe2lmKEc9PT1cIiRcInx8Rz09PVwiXlwiKXtHPWBcXFxcJHtHfWB9Y29uc3QgdD1hLmV4ZWMocmVtYWluaW5nKCkpO2lmKHQpe0crPXRbMF07bS5pbmRleCs9dFswXS5sZW5ndGh9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiZ2xvYnN0YXJcInx8Qi5zdGFyPT09dHJ1ZSkpe0IudHlwZT1cInN0YXJcIjtCLnN0YXI9dHJ1ZTtCLnZhbHVlKz1HO0Iub3V0cHV0PWs7bS5iYWNrdHJhY2s9dHJ1ZTttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1sZXQgZT1yZW1haW5pbmcoKTtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJi9eXFwoW14/XS8udGVzdChlKSl7ZXh0Z2xvYk9wZW4oXCJzdGFyXCIsRyk7Y29udGludWV9aWYoQi50eXBlPT09XCJzdGFyXCIpe2lmKHUubm9nbG9ic3Rhcj09PXRydWUpe2NvbnN1bWUoRyk7Y29udGludWV9Y29uc3Qgbj1CLnByZXY7Y29uc3Qgbz1uLnByZXY7Y29uc3Qgcz1uLnR5cGU9PT1cInNsYXNoXCJ8fG4udHlwZT09PVwiYm9zXCI7Y29uc3Qgcj1vJiYoby50eXBlPT09XCJzdGFyXCJ8fG8udHlwZT09PVwiZ2xvYnN0YXJcIik7aWYodS5iYXNoPT09dHJ1ZSYmKCFzfHxlWzBdJiZlWzBdIT09XCIvXCIpKXtwdXNoKHt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1jb25zdCBhPW0uYnJhY2VzPjAmJihuLnR5cGU9PT1cImNvbW1hXCJ8fG4udHlwZT09PVwiYnJhY2VcIik7Y29uc3QgaT13Lmxlbmd0aCYmKG4udHlwZT09PVwicGlwZVwifHxuLnR5cGU9PT1cInBhcmVuXCIpO2lmKCFzJiZuLnR5cGUhPT1cInBhcmVuXCImJiFhJiYhaSl7cHVzaCh7dHlwZTpcInN0YXJcIix2YWx1ZTpHLG91dHB1dDpcIlwifSk7Y29udGludWV9d2hpbGUoZS5zbGljZSgwLDMpPT09XCIvKipcIil7Y29uc3QgdT10W20uaW5kZXgrNF07aWYodSYmdSE9PVwiL1wiKXticmVha31lPWUuc2xpY2UoMyk7Y29uc3VtZShcIi8qKlwiLDMpfWlmKG4udHlwZT09PVwiYm9zXCImJmVvcygpKXtCLnR5cGU9XCJnbG9ic3RhclwiO0IudmFsdWUrPUc7Qi5vdXRwdXQ9Z2xvYnN0YXIodSk7bS5vdXRwdXQ9Qi5vdXRwdXQ7bS5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoRyk7Y29udGludWV9aWYobi50eXBlPT09XCJzbGFzaFwiJiZuLnByZXYudHlwZSE9PVwiYm9zXCImJiFyJiZlb3MoKSl7bS5vdXRwdXQ9bS5vdXRwdXQuc2xpY2UoMCwtKG4ub3V0cHV0K0Iub3V0cHV0KS5sZW5ndGgpO24ub3V0cHV0PWAoPzoke24ub3V0cHV0fWA7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLm91dHB1dD1nbG9ic3Rhcih1KSsodS5zdHJpY3RTbGFzaGVzP1wiKVwiOlwifCQpXCIpO0IudmFsdWUrPUc7bS5nbG9ic3Rhcj10cnVlO20ub3V0cHV0Kz1uLm91dHB1dCtCLm91dHB1dDtjb25zdW1lKEcpO2NvbnRpbnVlfWlmKG4udHlwZT09PVwic2xhc2hcIiYmbi5wcmV2LnR5cGUhPT1cImJvc1wiJiZlWzBdPT09XCIvXCIpe2NvbnN0IHQ9ZVsxXSE9PXZvaWQgMD9cInwkXCI6XCJcIjttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC0obi5vdXRwdXQrQi5vdXRwdXQpLmxlbmd0aCk7bi5vdXRwdXQ9YCg/OiR7bi5vdXRwdXR9YDtCLnR5cGU9XCJnbG9ic3RhclwiO0Iub3V0cHV0PWAke2dsb2JzdGFyKHUpfSR7Yn18JHtifSR7dH0pYDtCLnZhbHVlKz1HO20ub3V0cHV0Kz1uLm91dHB1dCtCLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHK00oKSk7cHVzaCh7dHlwZTpcInNsYXNoXCIsdmFsdWU6XCIvXCIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1pZihuLnR5cGU9PT1cImJvc1wiJiZlWzBdPT09XCIvXCIpe0IudHlwZT1cImdsb2JzdGFyXCI7Qi52YWx1ZSs9RztCLm91dHB1dD1gKD86Xnwke2J9fCR7Z2xvYnN0YXIodSl9JHtifSlgO20ub3V0cHV0PUIub3V0cHV0O20uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEcrTSgpKTtwdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpcIi9cIixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfW0ub3V0cHV0PW0ub3V0cHV0LnNsaWNlKDAsLUIub3V0cHV0Lmxlbmd0aCk7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLm91dHB1dD1nbG9ic3Rhcih1KTtCLnZhbHVlKz1HO20ub3V0cHV0Kz1CLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1jb25zdCBuPXt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0Omt9O2lmKHUuYmFzaD09PXRydWUpe24ub3V0cHV0PVwiLio/XCI7aWYoQi50eXBlPT09XCJib3NcInx8Qi50eXBlPT09XCJzbGFzaFwiKXtuLm91dHB1dD1UK24ub3V0cHV0fXB1c2gobik7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiYnJhY2tldFwifHxCLnR5cGU9PT1cInBhcmVuXCIpJiZ1LnJlZ2V4PT09dHJ1ZSl7bi5vdXRwdXQ9RztwdXNoKG4pO2NvbnRpbnVlfWlmKG0uaW5kZXg9PT1tLnN0YXJ0fHxCLnR5cGU9PT1cInNsYXNoXCJ8fEIudHlwZT09PVwiZG90XCIpe2lmKEIudHlwZT09PVwiZG90XCIpe20ub3V0cHV0Kz14O0Iub3V0cHV0Kz14fWVsc2UgaWYodS5kb3Q9PT10cnVlKXttLm91dHB1dCs9UztCLm91dHB1dCs9U31lbHNle20ub3V0cHV0Kz1UO0Iub3V0cHV0Kz1UfWlmKEQoKSE9PVwiKlwiKXttLm91dHB1dCs9QztCLm91dHB1dCs9Q319cHVzaChuKX13aGlsZShtLmJyYWNrZXRzPjApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIl1cIikpO20ub3V0cHV0PW8uZXNjYXBlTGFzdChtLm91dHB1dCxcIltcIik7ZGVjcmVtZW50KFwiYnJhY2tldHNcIil9d2hpbGUobS5wYXJlbnM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiKVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwiKFwiKTtkZWNyZW1lbnQoXCJwYXJlbnNcIil9d2hpbGUobS5icmFjZXM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwifVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwie1wiKTtkZWNyZW1lbnQoXCJicmFjZXNcIil9aWYodS5zdHJpY3RTbGFzaGVzIT09dHJ1ZSYmKEIudHlwZT09PVwic3RhclwifHxCLnR5cGU9PT1cImJyYWNrZXRcIikpe3B1c2goe3R5cGU6XCJtYXliZV9zbGFzaFwiLHZhbHVlOlwiXCIsb3V0cHV0OmAke2J9P2B9KX1pZihtLmJhY2t0cmFjaz09PXRydWUpe20ub3V0cHV0PVwiXCI7Zm9yKGNvbnN0IHQgb2YgbS50b2tlbnMpe20ub3V0cHV0Kz10Lm91dHB1dCE9bnVsbD90Lm91dHB1dDp0LnZhbHVlO2lmKHQuc3VmZml4KXttLm91dHB1dCs9dC5zdWZmaXh9fX1yZXR1cm4gbX07cGFyc2UuZmFzdHBhdGhzPSh0LGUpPT57Y29uc3QgdT17Li4uZX07Y29uc3Qgcj10eXBlb2YgdS5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsdS5tYXhMZW5ndGgpOnM7Y29uc3QgYT10Lmxlbmd0aDtpZihhPnIpe3Rocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoOiAke2F9LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7cn1gKX10PWNbdF18fHQ7Y29uc3R7RE9UX0xJVEVSQUw6aSxTTEFTSF9MSVRFUkFMOnAsT05FX0NIQVI6bCxET1RTX1NMQVNIOmYsTk9fRE9UOkEsTk9fRE9UUzpfLE5PX0RPVFNfU0xBU0g6UixTVEFSOkUsU1RBUlRfQU5DSE9SOmh9PW4uZ2xvYkNoYXJzKHUud2luZG93cyk7Y29uc3QgZz11LmRvdD9fOkE7Y29uc3QgYj11LmRvdD9SOkE7Y29uc3QgQz11LmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgeT17bmVnYXRlZDpmYWxzZSxwcmVmaXg6XCJcIn07bGV0ICQ9dS5iYXNoPT09dHJ1ZT9cIi4qP1wiOkU7aWYodS5jYXB0dXJlKXskPWAoJHskfSlgfWNvbnN0IGdsb2JzdGFyPXQ9PntpZih0Lm5vZ2xvYnN0YXI9PT10cnVlKXJldHVybiAkO3JldHVybmAoJHtDfSg/Oig/ISR7aH0ke3QuZG90P2Y6aX0pLikqPylgfTtjb25zdCBjcmVhdGU9dD0+e3N3aXRjaCh0KXtjYXNlXCIqXCI6cmV0dXJuYCR7Z30ke2x9JHskfWA7Y2FzZVwiLipcIjpyZXR1cm5gJHtpfSR7bH0keyR9YDtjYXNlXCIqLipcIjpyZXR1cm5gJHtnfSR7JH0ke2l9JHtsfSR7JH1gO2Nhc2VcIiovKlwiOnJldHVybmAke2d9JHskfSR7cH0ke2x9JHtifSR7JH1gO2Nhc2VcIioqXCI6cmV0dXJuIGcrZ2xvYnN0YXIodSk7Y2FzZVwiKiovKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2J9JHtsfSR7JH1gO2Nhc2VcIioqLyouKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2J9JHskfSR7aX0ke2x9JHskfWA7Y2FzZVwiKiovLipcIjpyZXR1cm5gKD86JHtnfSR7Z2xvYnN0YXIodSl9JHtwfSk/JHtpfSR7bH0keyR9YDtkZWZhdWx0Ontjb25zdCBlPS9eKC4qPylcXC4oXFx3KykkLy5leGVjKHQpO2lmKCFlKXJldHVybjtjb25zdCB1PWNyZWF0ZShlWzFdKTtpZighdSlyZXR1cm47cmV0dXJuIHUraStlWzJdfX19O2NvbnN0IHg9by5yZW1vdmVQcmVmaXgodCx5KTtsZXQgUz1jcmVhdGUoeCk7aWYoUyYmdS5zdHJpY3RTbGFzaGVzIT09dHJ1ZSl7Uys9YCR7cH0/YH1yZXR1cm4gU307dC5leHBvcnRzPXBhcnNlfSw1MTA6KHQsZSx1KT0+e2NvbnN0IG49dSg3MTYpO2NvbnN0IG89dSg2OTcpO2NvbnN0IHM9dSg5Nik7Y29uc3Qgcj11KDE1NCk7Y29uc3QgaXNPYmplY3Q9dD0+dCYmdHlwZW9mIHQ9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheSh0KTtjb25zdCBwaWNvbWF0Y2g9KHQsZSx1PWZhbHNlKT0+e2lmKEFycmF5LmlzQXJyYXkodCkpe2NvbnN0IG49dC5tYXAoKHQ9PnBpY29tYXRjaCh0LGUsdSkpKTtjb25zdCBhcnJheU1hdGNoZXI9dD0+e2Zvcihjb25zdCBlIG9mIG4pe2NvbnN0IHU9ZSh0KTtpZih1KXJldHVybiB1fXJldHVybiBmYWxzZX07cmV0dXJuIGFycmF5TWF0Y2hlcn1jb25zdCBuPWlzT2JqZWN0KHQpJiZ0LnRva2VucyYmdC5pbnB1dDtpZih0PT09XCJcInx8dHlwZW9mIHQhPT1cInN0cmluZ1wiJiYhbil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpfWNvbnN0IG89ZXx8e307Y29uc3Qgcz1vLndpbmRvd3M7Y29uc3Qgcj1uP3BpY29tYXRjaC5jb21waWxlUmUodCxlKTpwaWNvbWF0Y2gubWFrZVJlKHQsZSxmYWxzZSx0cnVlKTtjb25zdCBhPXIuc3RhdGU7ZGVsZXRlIHIuc3RhdGU7bGV0IGlzSWdub3JlZD0oKT0+ZmFsc2U7aWYoby5pZ25vcmUpe2NvbnN0IHQ9ey4uLmUsaWdub3JlOm51bGwsb25NYXRjaDpudWxsLG9uUmVzdWx0Om51bGx9O2lzSWdub3JlZD1waWNvbWF0Y2goby5pZ25vcmUsdCx1KX1jb25zdCBtYXRjaGVyPSh1LG49ZmFsc2UpPT57Y29uc3R7aXNNYXRjaDppLG1hdGNoOmMsb3V0cHV0OnB9PXBpY29tYXRjaC50ZXN0KHUscixlLHtnbG9iOnQscG9zaXg6c30pO2NvbnN0IGw9e2dsb2I6dCxzdGF0ZTphLHJlZ2V4OnIscG9zaXg6cyxpbnB1dDp1LG91dHB1dDpwLG1hdGNoOmMsaXNNYXRjaDppfTtpZih0eXBlb2Ygby5vblJlc3VsdD09PVwiZnVuY3Rpb25cIil7by5vblJlc3VsdChsKX1pZihpPT09ZmFsc2Upe2wuaXNNYXRjaD1mYWxzZTtyZXR1cm4gbj9sOmZhbHNlfWlmKGlzSWdub3JlZCh1KSl7aWYodHlwZW9mIG8ub25JZ25vcmU9PT1cImZ1bmN0aW9uXCIpe28ub25JZ25vcmUobCl9bC5pc01hdGNoPWZhbHNlO3JldHVybiBuP2w6ZmFsc2V9aWYodHlwZW9mIG8ub25NYXRjaD09PVwiZnVuY3Rpb25cIil7by5vbk1hdGNoKGwpfXJldHVybiBuP2w6dHJ1ZX07aWYodSl7bWF0Y2hlci5zdGF0ZT1hfXJldHVybiBtYXRjaGVyfTtwaWNvbWF0Y2gudGVzdD0odCxlLHUse2dsb2I6bixwb3NpeDpvfT17fSk9PntpZih0eXBlb2YgdCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBpbnB1dCB0byBiZSBhIHN0cmluZ1wiKX1pZih0PT09XCJcIil7cmV0dXJue2lzTWF0Y2g6ZmFsc2Usb3V0cHV0OlwiXCJ9fWNvbnN0IHI9dXx8e307Y29uc3QgYT1yLmZvcm1hdHx8KG8/cy50b1Bvc2l4U2xhc2hlczpudWxsKTtsZXQgaT10PT09bjtsZXQgYz1pJiZhP2EodCk6dDtpZihpPT09ZmFsc2Upe2M9YT9hKHQpOnQ7aT1jPT09bn1pZihpPT09ZmFsc2V8fHIuY2FwdHVyZT09PXRydWUpe2lmKHIubWF0Y2hCYXNlPT09dHJ1ZXx8ci5iYXNlbmFtZT09PXRydWUpe2k9cGljb21hdGNoLm1hdGNoQmFzZSh0LGUsdSxvKX1lbHNle2k9ZS5leGVjKGMpfX1yZXR1cm57aXNNYXRjaDpCb29sZWFuKGkpLG1hdGNoOmksb3V0cHV0OmN9fTtwaWNvbWF0Y2gubWF0Y2hCYXNlPSh0LGUsdSk9Pntjb25zdCBuPWUgaW5zdGFuY2VvZiBSZWdFeHA/ZTpwaWNvbWF0Y2gubWFrZVJlKGUsdSk7cmV0dXJuIG4udGVzdChzLmJhc2VuYW1lKHQpKX07cGljb21hdGNoLmlzTWF0Y2g9KHQsZSx1KT0+cGljb21hdGNoKGUsdSkodCk7cGljb21hdGNoLnBhcnNlPSh0LGUpPT57aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdC5tYXAoKHQ9PnBpY29tYXRjaC5wYXJzZSh0LGUpKSk7cmV0dXJuIG8odCx7Li4uZSxmYXN0cGF0aHM6ZmFsc2V9KX07cGljb21hdGNoLnNjYW49KHQsZSk9Pm4odCxlKTtwaWNvbWF0Y2guY29tcGlsZVJlPSh0LGUsdT1mYWxzZSxuPWZhbHNlKT0+e2lmKHU9PT10cnVlKXtyZXR1cm4gdC5vdXRwdXR9Y29uc3Qgbz1lfHx7fTtjb25zdCBzPW8uY29udGFpbnM/XCJcIjpcIl5cIjtjb25zdCByPW8uY29udGFpbnM/XCJcIjpcIiRcIjtsZXQgYT1gJHtzfSg/OiR7dC5vdXRwdXR9KSR7cn1gO2lmKHQmJnQubmVnYXRlZD09PXRydWUpe2E9YF4oPyEke2F9KS4qJGB9Y29uc3QgaT1waWNvbWF0Y2gudG9SZWdleChhLGUpO2lmKG49PT10cnVlKXtpLnN0YXRlPXR9cmV0dXJuIGl9O3BpY29tYXRjaC5tYWtlUmU9KHQsZT17fSx1PWZhbHNlLG49ZmFsc2UpPT57aWYoIXR8fHR5cGVvZiB0IT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbm9uLWVtcHR5IHN0cmluZ1wiKX1sZXQgcz17bmVnYXRlZDpmYWxzZSxmYXN0cGF0aHM6dHJ1ZX07aWYoZS5mYXN0cGF0aHMhPT1mYWxzZSYmKHRbMF09PT1cIi5cInx8dFswXT09PVwiKlwiKSl7cy5vdXRwdXQ9by5mYXN0cGF0aHModCxlKX1pZighcy5vdXRwdXQpe3M9byh0LGUpfXJldHVybiBwaWNvbWF0Y2guY29tcGlsZVJlKHMsZSx1LG4pfTtwaWNvbWF0Y2gudG9SZWdleD0odCxlKT0+e3RyeXtjb25zdCB1PWV8fHt9O3JldHVybiBuZXcgUmVnRXhwKHQsdS5mbGFnc3x8KHUubm9jYXNlP1wiaVwiOlwiXCIpKX1jYXRjaCh0KXtpZihlJiZlLmRlYnVnPT09dHJ1ZSl0aHJvdyB0O3JldHVybi8kXi99fTtwaWNvbWF0Y2guY29uc3RhbnRzPXI7dC5leHBvcnRzPXBpY29tYXRjaH0sNzE2Oih0LGUsdSk9Pntjb25zdCBuPXUoOTYpO2NvbnN0e0NIQVJfQVNURVJJU0s6byxDSEFSX0FUOnMsQ0hBUl9CQUNLV0FSRF9TTEFTSDpyLENIQVJfQ09NTUE6YSxDSEFSX0RPVDppLENIQVJfRVhDTEFNQVRJT05fTUFSSzpjLENIQVJfRk9SV0FSRF9TTEFTSDpwLENIQVJfTEVGVF9DVVJMWV9CUkFDRTpsLENIQVJfTEVGVF9QQVJFTlRIRVNFUzpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUExVUzpfLENIQVJfUVVFU1RJT05fTUFSSzpSLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6RSxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmgsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpnfT11KDE1NCk7Y29uc3QgaXNQYXRoU2VwYXJhdG9yPXQ9PnQ9PT1wfHx0PT09cjtjb25zdCBkZXB0aD10PT57aWYodC5pc1ByZWZpeCE9PXRydWUpe3QuZGVwdGg9dC5pc0dsb2JzdGFyP0luZmluaXR5OjF9fTtjb25zdCBzY2FuPSh0LGUpPT57Y29uc3QgdT1lfHx7fTtjb25zdCBiPXQubGVuZ3RoLTE7Y29uc3QgQz11LnBhcnRzPT09dHJ1ZXx8dS5zY2FuVG9FbmQ9PT10cnVlO2NvbnN0IHk9W107Y29uc3QgJD1bXTtjb25zdCB4PVtdO2xldCBTPXQ7bGV0IEg9LTE7bGV0IHY9MDtsZXQgZD0wO2xldCBMPWZhbHNlO2xldCBUPWZhbHNlO2xldCBPPWZhbHNlO2xldCBrPWZhbHNlO2xldCBtPWZhbHNlO2xldCB3PWZhbHNlO2xldCBOPWZhbHNlO2xldCBJPWZhbHNlO2xldCBCPWZhbHNlO2xldCBHPWZhbHNlO2xldCBEPTA7bGV0IE07bGV0IFA7bGV0IEs9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2NvbnN0IGVvcz0oKT0+SD49Yjtjb25zdCBwZWVrPSgpPT5TLmNoYXJDb2RlQXQoSCsxKTtjb25zdCBhZHZhbmNlPSgpPT57TT1QO3JldHVybiBTLmNoYXJDb2RlQXQoKytIKX07d2hpbGUoSDxiKXtQPWFkdmFuY2UoKTtsZXQgdDtpZihQPT09cil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7aWYoUD09PWwpe3c9dHJ1ZX1jb250aW51ZX1pZih3PT09dHJ1ZXx8UD09PWwpe0QrKzt3aGlsZShlb3MoKSE9PXRydWUmJihQPWFkdmFuY2UoKSkpe2lmKFA9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWwpe0QrKztjb250aW51ZX1pZih3IT09dHJ1ZSYmUD09PWkmJihQPWFkdmFuY2UoKSk9PT1pKXtMPUsuaXNCcmFjZT10cnVlO089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKHchPT10cnVlJiZQPT09YSl7TD1LLmlzQnJhY2U9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2lmKEM9PT10cnVlKXtjb250aW51ZX1icmVha31pZihQPT09RSl7RC0tO2lmKEQ9PT0wKXt3PWZhbHNlO0w9Sy5pc0JyYWNlPXRydWU7Rz10cnVlO2JyZWFrfX19aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1wKXt5LnB1c2goSCk7JC5wdXNoKEspO0s9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2lmKEc9PT10cnVlKWNvbnRpbnVlO2lmKE09PT1pJiZIPT09disxKXt2Kz0yO2NvbnRpbnVlfWQ9SCsxO2NvbnRpbnVlfWlmKHUubm9leHQhPT10cnVlKXtjb25zdCB0PVA9PT1ffHxQPT09c3x8UD09PW98fFA9PT1SfHxQPT09YztpZih0PT09dHJ1ZSYmcGVlaygpPT09Zil7Tz1LLmlzR2xvYj10cnVlO2s9Sy5pc0V4dGdsb2I9dHJ1ZTtHPXRydWU7aWYoUD09PWMmJkg9PT12KXtCPXRydWV9aWYoQz09PXRydWUpe3doaWxlKGVvcygpIT09dHJ1ZSYmKFA9YWR2YW5jZSgpKSl7aWYoUD09PXIpe049Sy5iYWNrc2xhc2hlcz10cnVlO1A9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKFA9PT1oKXtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha319aWYoUD09PW8pe2lmKE09PT1vKW09Sy5pc0dsb2JzdGFyPXRydWU7Tz1LLmlzR2xvYj10cnVlO0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoUD09PVIpe089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1BKXt3aGlsZShlb3MoKSE9PXRydWUmJih0PWFkdmFuY2UoKSkpe2lmKHQ9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYodD09PWcpe1Q9Sy5pc0JyYWNrZXQ9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2JyZWFrfX1pZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYodS5ub25lZ2F0ZSE9PXRydWUmJlA9PT1jJiZIPT09dil7ST1LLm5lZ2F0ZWQ9dHJ1ZTt2Kys7Y29udGludWV9aWYodS5ub3BhcmVuIT09dHJ1ZSYmUD09PWYpe089Sy5pc0dsb2I9dHJ1ZTtpZihDPT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoUD1hZHZhbmNlKCkpKXtpZihQPT09Zil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWgpe0c9dHJ1ZTticmVha319Y29udGludWV9YnJlYWt9aWYoTz09PXRydWUpe0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9fWlmKHUubm9leHQ9PT10cnVlKXtrPWZhbHNlO089ZmFsc2V9bGV0IFU9UztsZXQgWD1cIlwiO2xldCBGPVwiXCI7aWYodj4wKXtYPVMuc2xpY2UoMCx2KTtTPVMuc2xpY2Uodik7ZC09dn1pZihVJiZPPT09dHJ1ZSYmZD4wKXtVPVMuc2xpY2UoMCxkKTtGPVMuc2xpY2UoZCl9ZWxzZSBpZihPPT09dHJ1ZSl7VT1cIlwiO0Y9U31lbHNle1U9U31pZihVJiZVIT09XCJcIiYmVSE9PVwiL1wiJiZVIT09Uyl7aWYoaXNQYXRoU2VwYXJhdG9yKFUuY2hhckNvZGVBdChVLmxlbmd0aC0xKSkpe1U9VS5zbGljZSgwLC0xKX19aWYodS51bmVzY2FwZT09PXRydWUpe2lmKEYpRj1uLnJlbW92ZUJhY2tzbGFzaGVzKEYpO2lmKFUmJk49PT10cnVlKXtVPW4ucmVtb3ZlQmFja3NsYXNoZXMoVSl9fWNvbnN0IFE9e3ByZWZpeDpYLGlucHV0OnQsc3RhcnQ6dixiYXNlOlUsZ2xvYjpGLGlzQnJhY2U6TCxpc0JyYWNrZXQ6VCxpc0dsb2I6Tyxpc0V4dGdsb2I6ayxpc0dsb2JzdGFyOm0sbmVnYXRlZDpJLG5lZ2F0ZWRFeHRnbG9iOkJ9O2lmKHUudG9rZW5zPT09dHJ1ZSl7US5tYXhEZXB0aD0wO2lmKCFpc1BhdGhTZXBhcmF0b3IoUCkpeyQucHVzaChLKX1RLnRva2Vucz0kfWlmKHUucGFydHM9PT10cnVlfHx1LnRva2Vucz09PXRydWUpe2xldCBlO2ZvcihsZXQgbj0wO248eS5sZW5ndGg7bisrKXtjb25zdCBvPWU/ZSsxOnY7Y29uc3Qgcz15W25dO2NvbnN0IHI9dC5zbGljZShvLHMpO2lmKHUudG9rZW5zKXtpZihuPT09MCYmdiE9PTApeyRbbl0uaXNQcmVmaXg9dHJ1ZTskW25dLnZhbHVlPVh9ZWxzZXskW25dLnZhbHVlPXJ9ZGVwdGgoJFtuXSk7US5tYXhEZXB0aCs9JFtuXS5kZXB0aH1pZihuIT09MHx8ciE9PVwiXCIpe3gucHVzaChyKX1lPXN9aWYoZSYmZSsxPHQubGVuZ3RoKXtjb25zdCBuPXQuc2xpY2UoZSsxKTt4LnB1c2gobik7aWYodS50b2tlbnMpeyRbJC5sZW5ndGgtMV0udmFsdWU9bjtkZXB0aCgkWyQubGVuZ3RoLTFdKTtRLm1heERlcHRoKz0kWyQubGVuZ3RoLTFdLmRlcHRofX1RLnNsYXNoZXM9eTtRLnBhcnRzPXh9cmV0dXJuIFF9O3QuZXhwb3J0cz1zY2FufSw5NjoodCxlLHUpPT57Y29uc3R7UkVHRVhfQkFDS1NMQVNIOm4sUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSDpvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6cyxSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDpyfT11KDE1NCk7ZS5pc09iamVjdD10PT50IT09bnVsbCYmdHlwZW9mIHQ9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheSh0KTtlLmhhc1JlZ2V4Q2hhcnM9dD0+cy50ZXN0KHQpO2UuaXNSZWdleENoYXI9dD0+dC5sZW5ndGg9PT0xJiZlLmhhc1JlZ2V4Q2hhcnModCk7ZS5lc2NhcGVSZWdleD10PT50LnJlcGxhY2UocixcIlxcXFwkMVwiKTtlLnRvUG9zaXhTbGFzaGVzPXQ9PnQucmVwbGFjZShuLFwiL1wiKTtlLnJlbW92ZUJhY2tzbGFzaGVzPXQ9PnQucmVwbGFjZShvLCh0PT50PT09XCJcXFxcXCI/XCJcIjp0KSk7ZS5lc2NhcGVMYXN0PSh0LHUsbik9Pntjb25zdCBvPXQubGFzdEluZGV4T2YodSxuKTtpZihvPT09LTEpcmV0dXJuIHQ7aWYodFtvLTFdPT09XCJcXFxcXCIpcmV0dXJuIGUuZXNjYXBlTGFzdCh0LHUsby0xKTtyZXR1cm5gJHt0LnNsaWNlKDAsbyl9XFxcXCR7dC5zbGljZShvKX1gfTtlLnJlbW92ZVByZWZpeD0odCxlPXt9KT0+e2xldCB1PXQ7aWYodS5zdGFydHNXaXRoKFwiLi9cIikpe3U9dS5zbGljZSgyKTtlLnByZWZpeD1cIi4vXCJ9cmV0dXJuIHV9O2Uud3JhcE91dHB1dD0odCxlPXt9LHU9e30pPT57Y29uc3Qgbj11LmNvbnRhaW5zP1wiXCI6XCJeXCI7Y29uc3Qgbz11LmNvbnRhaW5zP1wiXCI6XCIkXCI7bGV0IHM9YCR7bn0oPzoke3R9KSR7b31gO2lmKGUubmVnYXRlZD09PXRydWUpe3M9YCg/Ol4oPyEke3N9KS4qJClgfXJldHVybiBzfTtlLmJhc2VuYW1lPSh0LHt3aW5kb3dzOmV9PXt9KT0+e2NvbnN0IHU9dC5zcGxpdChlPy9bXFxcXC9dLzpcIi9cIik7Y29uc3Qgbj11W3UubGVuZ3RoLTFdO2lmKG49PT1cIlwiKXtyZXR1cm4gdVt1Lmxlbmd0aC0yXX1yZXR1cm4gbn19fTt2YXIgZT17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHUpe3ZhciBuPWVbdV07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgbz1lW3VdPXtleHBvcnRzOnt9fTt2YXIgcz10cnVlO3RyeXt0W3VdKG8sby5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO3M9ZmFsc2V9ZmluYWxseXtpZihzKWRlbGV0ZSBlW3VdfXJldHVybiBvLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB1PV9fbmNjd3Bja19yZXF1aXJlX18oMTcwKTttb2R1bGUuZXhwb3J0cz11fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/picomatch/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/process/browser.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/process/browser.js ***!
  \***************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuNzcuMi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz84ODM1Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.3.1/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js":
/*!************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.3.1/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js ***!
  \************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n// dispatch for CommonJS interop named imports.\n\nvar useState = React.useState,\n    useEffect = React.useEffect,\n    useLayoutEffect = React.useLayoutEffect,\n    useDebugValue = React.useDebugValue;\nvar didWarnOld18Alpha = false;\nvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n// because of a very particular set of implementation details and assumptions\n// -- change any one of them and it will break. The most important assumption\n// is that updates are always synchronous, because concurrent rendering is\n// only available in versions of React that also have a built-in\n// useSyncExternalStore API. And we only use this shim when the built-in API\n// does not exist.\n//\n// Do not assume that the clever hacks used by this hook also work in general.\n// The point of this shim is to replace the need for hacks by other libraries.\n\nfunction useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n// React do not expose a way to check if we're hydrating. So users of the shim\n// will need to track that themselves and return the correct value\n// from `getSnapshot`.\ngetServerSnapshot) {\n  {\n    if (!didWarnOld18Alpha) {\n      if (React.startTransition !== undefined) {\n        didWarnOld18Alpha = true;\n\n        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\n      }\n    }\n  } // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n\n\n  var value = getSnapshot();\n\n  {\n    if (!didWarnUncachedGetSnapshot) {\n      var cachedValue = getSnapshot();\n\n      if (!objectIs(value, cachedValue)) {\n        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  } // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n\n\n  var _useState = useState({\n    inst: {\n      value: value,\n      getSnapshot: getSnapshot\n    }\n  }),\n      inst = _useState[0].inst,\n      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n\n\n  useLayoutEffect(function () {\n    inst.value = value;\n    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n    // commit phase if there was an interleaved mutation. In concurrent mode\n    // this can happen all the time, but even in synchronous mode, an earlier\n    // effect may have mutated the store.\n\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n  }, [subscribe, value, getSnapshot]);\n  useEffect(function () {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n\n    var handleStoreChange = function () {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({\n          inst: inst\n        });\n      }\n    }; // Subscribe to the store and return a clean-up function.\n\n\n    return subscribe(handleStoreChange);\n  }, [subscribe]);\n  useDebugValue(value);\n  return value;\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  var prevValue = inst.value;\n\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  return getSnapshot();\n}\n\nvar canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n\nvar isServerEnvironment = !canUseDOM;\n\nvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\nvar useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;\n\nexports.useSyncExternalStore = useSyncExternalStore$2;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS91c2Utc3luYy1leHRlcm5hbC1zdG9yZUAxLjIuMF9yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQywwS0FBTzs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGVBQWU7QUFDaEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUixrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsS0FBSztBQUNyRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtDQUFrQztBQUNsQztBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmVAMS4yLjBfcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qcz83OGFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0uZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgICB2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIDtcbn1cblxudmFyIG9iamVjdElzID0gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGlzO1xuXG4vLyBkaXNwYXRjaCBmb3IgQ29tbW9uSlMgaW50ZXJvcCBuYW1lZCBpbXBvcnRzLlxuXG52YXIgdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZSxcbiAgICB1c2VFZmZlY3QgPSBSZWFjdC51c2VFZmZlY3QsXG4gICAgdXNlTGF5b3V0RWZmZWN0ID0gUmVhY3QudXNlTGF5b3V0RWZmZWN0LFxuICAgIHVzZURlYnVnVmFsdWUgPSBSZWFjdC51c2VEZWJ1Z1ZhbHVlO1xudmFyIGRpZFdhcm5PbGQxOEFscGhhID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSBmYWxzZTsgLy8gRGlzY2xhaW1lcjogVGhpcyBzaGltIGJyZWFrcyBtYW55IG9mIHRoZSBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3Ncbi8vIGJlY2F1c2Ugb2YgYSB2ZXJ5IHBhcnRpY3VsYXIgc2V0IG9mIGltcGxlbWVudGF0aW9uIGRldGFpbHMgYW5kIGFzc3VtcHRpb25zXG4vLyAtLSBjaGFuZ2UgYW55IG9uZSBvZiB0aGVtIGFuZCBpdCB3aWxsIGJyZWFrLiBUaGUgbW9zdCBpbXBvcnRhbnQgYXNzdW1wdGlvblxuLy8gaXMgdGhhdCB1cGRhdGVzIGFyZSBhbHdheXMgc3luY2hyb25vdXMsIGJlY2F1c2UgY29uY3VycmVudCByZW5kZXJpbmcgaXNcbi8vIG9ubHkgYXZhaWxhYmxlIGluIHZlcnNpb25zIG9mIFJlYWN0IHRoYXQgYWxzbyBoYXZlIGEgYnVpbHQtaW5cbi8vIHVzZVN5bmNFeHRlcm5hbFN0b3JlIEFQSS4gQW5kIHdlIG9ubHkgdXNlIHRoaXMgc2hpbSB3aGVuIHRoZSBidWlsdC1pbiBBUElcbi8vIGRvZXMgbm90IGV4aXN0LlxuLy9cbi8vIERvIG5vdCBhc3N1bWUgdGhhdCB0aGUgY2xldmVyIGhhY2tzIHVzZWQgYnkgdGhpcyBob29rIGFsc28gd29yayBpbiBnZW5lcmFsLlxuLy8gVGhlIHBvaW50IG9mIHRoaXMgc2hpbSBpcyB0byByZXBsYWNlIHRoZSBuZWVkIGZvciBoYWNrcyBieSBvdGhlciBsaWJyYXJpZXMuXG5cbmZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIC8vIE5vdGU6IFRoZSBzaGltIGRvZXMgbm90IHVzZSBnZXRTZXJ2ZXJTbmFwc2hvdCwgYmVjYXVzZSBwcmUtMTggdmVyc2lvbnMgb2Zcbi8vIFJlYWN0IGRvIG5vdCBleHBvc2UgYSB3YXkgdG8gY2hlY2sgaWYgd2UncmUgaHlkcmF0aW5nLiBTbyB1c2VycyBvZiB0aGUgc2hpbVxuLy8gd2lsbCBuZWVkIHRvIHRyYWNrIHRoYXQgdGhlbXNlbHZlcyBhbmQgcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlXG4vLyBmcm9tIGBnZXRTbmFwc2hvdGAuXG5nZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICB7XG4gICAgaWYgKCFkaWRXYXJuT2xkMThBbHBoYSkge1xuICAgICAgaWYgKFJlYWN0LnN0YXJ0VHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpZFdhcm5PbGQxOEFscGhhID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignWW91IGFyZSB1c2luZyBhbiBvdXRkYXRlZCwgcHJlLXJlbGVhc2UgYWxwaGEgb2YgUmVhY3QgMTggdGhhdCAnICsgJ2RvZXMgbm90IHN1cHBvcnQgdXNlU3luY0V4dGVybmFsU3RvcmUuIFRoZSAnICsgJ3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlIHNoaW0gd2lsbCBub3Qgd29yayBjb3JyZWN0bHkuIFVwZ3JhZGUgJyArICd0byBhIG5ld2VyIHByZS1yZWxlYXNlLicpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZWFkIHRoZSBjdXJyZW50IHNuYXBzaG90IGZyb20gdGhlIHN0b3JlIG9uIGV2ZXJ5IHJlbmRlci4gQWdhaW4sIHRoaXNcbiAgLy8gYnJlYWtzIHRoZSBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3MgaGVyZSBiZWNhdXNlIG9mIHNwZWNpZmljXG4gIC8vIGltcGxlbWVudGF0aW9uIGRldGFpbHMsIG1vc3QgaW1wb3J0YW50bHkgdGhhdCB1cGRhdGVzIGFyZVxuICAvLyBhbHdheXMgc3luY2hyb25vdXMuXG5cblxuICB2YXIgdmFsdWUgPSBnZXRTbmFwc2hvdCgpO1xuXG4gIHtcbiAgICBpZiAoIWRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90KSB7XG4gICAgICB2YXIgY2FjaGVkVmFsdWUgPSBnZXRTbmFwc2hvdCgpO1xuXG4gICAgICBpZiAoIW9iamVjdElzKHZhbHVlLCBjYWNoZWRWYWx1ZSkpIHtcbiAgICAgICAgZXJyb3IoJ1RoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wJyk7XG5cbiAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBCZWNhdXNlIHVwZGF0ZXMgYXJlIHN5bmNocm9ub3VzLCB3ZSBkb24ndCBxdWV1ZSB0aGVtLiBJbnN0ZWFkIHdlIGZvcmNlIGFcbiAgLy8gcmUtcmVuZGVyIHdoZW5ldmVyIHRoZSBzdWJzY3JpYmVkIHN0YXRlIGNoYW5nZXMgYnkgdXBkYXRpbmcgYW4gc29tZVxuICAvLyBhcmJpdHJhcnkgdXNlU3RhdGUgaG9vay4gVGhlbiwgZHVyaW5nIHJlbmRlciwgd2UgY2FsbCBnZXRTbmFwc2hvdCB0byByZWFkXG4gIC8vIHRoZSBjdXJyZW50IHZhbHVlLlxuICAvL1xuICAvLyBCZWNhdXNlIHdlIGRvbid0IGFjdHVhbGx5IHVzZSB0aGUgc3RhdGUgcmV0dXJuZWQgYnkgdGhlIHVzZVN0YXRlIGhvb2ssIHdlXG4gIC8vIGNhbiBzYXZlIGEgYml0IG9mIG1lbW9yeSBieSBzdG9yaW5nIG90aGVyIHN0dWZmIGluIHRoYXQgc2xvdC5cbiAgLy9cbiAgLy8gVG8gaW1wbGVtZW50IHRoZSBlYXJseSBiYWlsb3V0LCB3ZSBuZWVkIHRvIHRyYWNrIHNvbWUgdGhpbmdzIG9uIGEgbXV0YWJsZVxuICAvLyBvYmplY3QuIFVzdWFsbHksIHdlIHdvdWxkIHB1dCB0aGF0IGluIGEgdXNlUmVmIGhvb2ssIGJ1dCB3ZSBjYW4gc3Rhc2ggaXQgaW5cbiAgLy8gb3VyIHVzZVN0YXRlIGhvb2sgaW5zdGVhZC5cbiAgLy9cbiAgLy8gVG8gZm9yY2UgYSByZS1yZW5kZXIsIHdlIGNhbGwgZm9yY2VVcGRhdGUoe2luc3R9KS4gVGhhdCB3b3JrcyBiZWNhdXNlIHRoZVxuICAvLyBuZXcgb2JqZWN0IGFsd2F5cyBmYWlscyBhbiBlcXVhbGl0eSBjaGVjay5cblxuXG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZSh7XG4gICAgaW5zdDoge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZ2V0U25hcHNob3Q6IGdldFNuYXBzaG90XG4gICAgfVxuICB9KSxcbiAgICAgIGluc3QgPSBfdXNlU3RhdGVbMF0uaW5zdCxcbiAgICAgIGZvcmNlVXBkYXRlID0gX3VzZVN0YXRlWzFdOyAvLyBUcmFjayB0aGUgbGF0ZXN0IGdldFNuYXBzaG90IGZ1bmN0aW9uIHdpdGggYSByZWYuIFRoaXMgbmVlZHMgdG8gYmUgdXBkYXRlZFxuICAvLyBpbiB0aGUgbGF5b3V0IHBoYXNlIHNvIHdlIGNhbiBhY2Nlc3MgaXQgZHVyaW5nIHRoZSB0ZWFyaW5nIGNoZWNrIHRoYXRcbiAgLy8gaGFwcGVucyBvbiBzdWJzY3JpYmUuXG5cblxuICB1c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGluc3QudmFsdWUgPSB2YWx1ZTtcbiAgICBpbnN0LmdldFNuYXBzaG90ID0gZ2V0U25hcHNob3Q7IC8vIFdoZW5ldmVyIGdldFNuYXBzaG90IG9yIHN1YnNjcmliZSBjaGFuZ2VzLCB3ZSBuZWVkIHRvIGNoZWNrIGluIHRoZVxuICAgIC8vIGNvbW1pdCBwaGFzZSBpZiB0aGVyZSB3YXMgYW4gaW50ZXJsZWF2ZWQgbXV0YXRpb24uIEluIGNvbmN1cnJlbnQgbW9kZVxuICAgIC8vIHRoaXMgY2FuIGhhcHBlbiBhbGwgdGhlIHRpbWUsIGJ1dCBldmVuIGluIHN5bmNocm9ub3VzIG1vZGUsIGFuIGVhcmxpZXJcbiAgICAvLyBlZmZlY3QgbWF5IGhhdmUgbXV0YXRlZCB0aGUgc3RvcmUuXG5cbiAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgICBmb3JjZVVwZGF0ZSh7XG4gICAgICAgIGluc3Q6IGluc3RcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW3N1YnNjcmliZSwgdmFsdWUsIGdldFNuYXBzaG90XSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ2hlY2sgZm9yIGNoYW5nZXMgcmlnaHQgYmVmb3JlIHN1YnNjcmliaW5nLiBTdWJzZXF1ZW50IGNoYW5nZXMgd2lsbCBiZVxuICAgIC8vIGRldGVjdGVkIGluIHRoZSBzdWJzY3JpcHRpb24gaGFuZGxlci5cbiAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgICBmb3JjZVVwZGF0ZSh7XG4gICAgICAgIGluc3Q6IGluc3RcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVTdG9yZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFRPRE86IEJlY2F1c2UgdGhlcmUgaXMgbm8gY3Jvc3MtcmVuZGVyZXIgQVBJIGZvciBiYXRjaGluZyB1cGRhdGVzLCBpdCdzXG4gICAgICAvLyB1cCB0byB0aGUgY29uc3VtZXIgb2YgdGhpcyBsaWJyYXJ5IHRvIHdyYXAgdGhlaXIgc3Vic2NyaXB0aW9uIGV2ZW50XG4gICAgICAvLyB3aXRoIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzLiBTaG91bGQgd2UgdHJ5IHRvIGRldGVjdCB3aGVuIHRoaXMgaXNuJ3RcbiAgICAgIC8vIHRoZSBjYXNlIGFuZCBwcmludCBhIHdhcm5pbmcgaW4gZGV2ZWxvcG1lbnQ/XG4gICAgICAvLyBUaGUgc3RvcmUgY2hhbmdlZC4gQ2hlY2sgaWYgdGhlIHNuYXBzaG90IGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZVxuICAgICAgLy8gcmVhZCBmcm9tIHRoZSBzdG9yZS5cbiAgICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAgIC8vIEZvcmNlIGEgcmUtcmVuZGVyLlxuICAgICAgICBmb3JjZVVwZGF0ZSh7XG4gICAgICAgICAgaW5zdDogaW5zdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9OyAvLyBTdWJzY3JpYmUgdG8gdGhlIHN0b3JlIGFuZCByZXR1cm4gYSBjbGVhbi11cCBmdW5jdGlvbi5cblxuXG4gICAgcmV0dXJuIHN1YnNjcmliZShoYW5kbGVTdG9yZUNoYW5nZSk7XG4gIH0sIFtzdWJzY3JpYmVdKTtcbiAgdXNlRGVidWdWYWx1ZSh2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSB7XG4gIHZhciBsYXRlc3RHZXRTbmFwc2hvdCA9IGluc3QuZ2V0U25hcHNob3Q7XG4gIHZhciBwcmV2VmFsdWUgPSBpbnN0LnZhbHVlO1xuXG4gIHRyeSB7XG4gICAgdmFyIG5leHRWYWx1ZSA9IGxhdGVzdEdldFNuYXBzaG90KCk7XG4gICAgcmV0dXJuICFvYmplY3RJcyhwcmV2VmFsdWUsIG5leHRWYWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUkMShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAvLyBOb3RlOiBUaGUgc2hpbSBkb2VzIG5vdCB1c2UgZ2V0U2VydmVyU25hcHNob3QsIGJlY2F1c2UgcHJlLTE4IHZlcnNpb25zIG9mXG4gIC8vIFJlYWN0IGRvIG5vdCBleHBvc2UgYSB3YXkgdG8gY2hlY2sgaWYgd2UncmUgaHlkcmF0aW5nLiBTbyB1c2VycyBvZiB0aGUgc2hpbVxuICAvLyB3aWxsIG5lZWQgdG8gdHJhY2sgdGhhdCB0aGVtc2VsdmVzIGFuZCByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWVcbiAgLy8gZnJvbSBgZ2V0U25hcHNob3RgLlxuICByZXR1cm4gZ2V0U25hcHNob3QoKTtcbn1cblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpO1xuXG52YXIgaXNTZXJ2ZXJFbnZpcm9ubWVudCA9ICFjYW5Vc2VET007XG5cbnZhciBzaGltID0gaXNTZXJ2ZXJFbnZpcm9ubWVudCA/IHVzZVN5bmNFeHRlcm5hbFN0b3JlJDEgOiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTtcbnZhciB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQyID0gUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUgIT09IHVuZGVmaW5lZCA/IFJlYWN0LnVzZVN5bmNFeHRlcm5hbFN0b3JlIDogc2hpbTtcblxuZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlJDI7XG4gICAgICAgICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xufVxuICAgICAgICBcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.3.1/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.3.1/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js":
/*!**************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.3.1/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js ***!
  \**************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\nvar shim = __webpack_require__(/*! use-sync-external-store/shim */ \"(app-pages-browser)/./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.3.1/node_modules/use-sync-external-store/shim/index.js\");\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\nvar useSyncExternalStore = shim.useSyncExternalStore;\n\n// for CommonJS interop.\n\nvar useRef = React.useRef,\n    useEffect = React.useEffect,\n    useMemo = React.useMemo,\n    useDebugValue = React.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.\n\nfunction useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n  // Use this to track the rendered snapshot.\n  var instRef = useRef(null);\n  var inst;\n\n  if (instRef.current === null) {\n    inst = {\n      hasValue: false,\n      value: null\n    };\n    instRef.current = inst;\n  } else {\n    inst = instRef.current;\n  }\n\n  var _useMemo = useMemo(function () {\n    // Track the memoized state using closure variables that are local to this\n    // memoized instance of a getSnapshot function. Intentionally not using a\n    // useRef hook, because that state would be shared across all concurrent\n    // copies of the hook/component.\n    var hasMemo = false;\n    var memoizedSnapshot;\n    var memoizedSelection;\n\n    var memoizedSelector = function (nextSnapshot) {\n      if (!hasMemo) {\n        // The first time the hook is called, there is no memoized result.\n        hasMemo = true;\n        memoizedSnapshot = nextSnapshot;\n\n        var _nextSelection = selector(nextSnapshot);\n\n        if (isEqual !== undefined) {\n          // Even if the selector has changed, the currently rendered selection\n          // may be equal to the new selection. We should attempt to reuse the\n          // current value if possible, to preserve downstream memoizations.\n          if (inst.hasValue) {\n            var currentSelection = inst.value;\n\n            if (isEqual(currentSelection, _nextSelection)) {\n              memoizedSelection = currentSelection;\n              return currentSelection;\n            }\n          }\n        }\n\n        memoizedSelection = _nextSelection;\n        return _nextSelection;\n      } // We may be able to reuse the previous invocation's result.\n\n\n      // We may be able to reuse the previous invocation's result.\n      var prevSnapshot = memoizedSnapshot;\n      var prevSelection = memoizedSelection;\n\n      if (objectIs(prevSnapshot, nextSnapshot)) {\n        // The snapshot is the same as last time. Reuse the previous selection.\n        return prevSelection;\n      } // The snapshot has changed, so we need to compute a new selection.\n\n\n      // The snapshot has changed, so we need to compute a new selection.\n      var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n\n      // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n        return prevSelection;\n      }\n\n      memoizedSnapshot = nextSnapshot;\n      memoizedSelection = nextSelection;\n      return nextSelection;\n    }; // Assigning this to a constant so that Flow knows it can't change.\n\n\n    // Assigning this to a constant so that Flow knows it can't change.\n    var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;\n\n    var getSnapshotWithSelector = function () {\n      return memoizedSelector(getSnapshot());\n    };\n\n    var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function () {\n      return memoizedSelector(maybeGetServerSnapshot());\n    };\n    return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n  }, [getSnapshot, getServerSnapshot, selector, isEqual]),\n      getSelection = _useMemo[0],\n      getServerSelection = _useMemo[1];\n\n  var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n  useEffect(function () {\n    inst.hasValue = true;\n    inst.value = value;\n  }, [value]);\n  useDebugValue(value);\n  return value;\n}\n\nexports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS91c2Utc3luYy1leHRlcm5hbC1zdG9yZUAxLjIuMF9yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3dpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLDBLQUFPO0FBQ3JDLFdBQVcsbUJBQU8sQ0FBQyw0S0FBOEI7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS91c2Utc3luYy1leHRlcm5hbC1zdG9yZUAxLjIuMF9yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3dpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanM/NTQ2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3dpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgICB2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHNoaW0gPSByZXF1aXJlKCd1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltJyk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbnZhciB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IHNoaW0udXNlU3luY0V4dGVybmFsU3RvcmU7XG5cbi8vIGZvciBDb21tb25KUyBpbnRlcm9wLlxuXG52YXIgdXNlUmVmID0gUmVhY3QudXNlUmVmLFxuICAgIHVzZUVmZmVjdCA9IFJlYWN0LnVzZUVmZmVjdCxcbiAgICB1c2VNZW1vID0gUmVhY3QudXNlTWVtbyxcbiAgICB1c2VEZWJ1Z1ZhbHVlID0gUmVhY3QudXNlRGVidWdWYWx1ZTsgLy8gU2FtZSBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSwgYnV0IHN1cHBvcnRzIHNlbGVjdG9yIGFuZCBpc0VxdWFsIGFyZ3VtZW50cy5cblxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3Ioc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QsIHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIC8vIFVzZSB0aGlzIHRvIHRyYWNrIHRoZSByZW5kZXJlZCBzbmFwc2hvdC5cbiAgdmFyIGluc3RSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBpbnN0O1xuXG4gIGlmIChpbnN0UmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICBpbnN0ID0ge1xuICAgICAgaGFzVmFsdWU6IGZhbHNlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9O1xuICAgIGluc3RSZWYuY3VycmVudCA9IGluc3Q7XG4gIH0gZWxzZSB7XG4gICAgaW5zdCA9IGluc3RSZWYuY3VycmVudDtcbiAgfVxuXG4gIHZhciBfdXNlTWVtbyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIC8vIFRyYWNrIHRoZSBtZW1vaXplZCBzdGF0ZSB1c2luZyBjbG9zdXJlIHZhcmlhYmxlcyB0aGF0IGFyZSBsb2NhbCB0byB0aGlzXG4gICAgLy8gbWVtb2l6ZWQgaW5zdGFuY2Ugb2YgYSBnZXRTbmFwc2hvdCBmdW5jdGlvbi4gSW50ZW50aW9uYWxseSBub3QgdXNpbmcgYVxuICAgIC8vIHVzZVJlZiBob29rLCBiZWNhdXNlIHRoYXQgc3RhdGUgd291bGQgYmUgc2hhcmVkIGFjcm9zcyBhbGwgY29uY3VycmVudFxuICAgIC8vIGNvcGllcyBvZiB0aGUgaG9vay9jb21wb25lbnQuXG4gICAgdmFyIGhhc01lbW8gPSBmYWxzZTtcbiAgICB2YXIgbWVtb2l6ZWRTbmFwc2hvdDtcbiAgICB2YXIgbWVtb2l6ZWRTZWxlY3Rpb247XG5cbiAgICB2YXIgbWVtb2l6ZWRTZWxlY3RvciA9IGZ1bmN0aW9uIChuZXh0U25hcHNob3QpIHtcbiAgICAgIGlmICghaGFzTWVtbykge1xuICAgICAgICAvLyBUaGUgZmlyc3QgdGltZSB0aGUgaG9vayBpcyBjYWxsZWQsIHRoZXJlIGlzIG5vIG1lbW9pemVkIHJlc3VsdC5cbiAgICAgICAgaGFzTWVtbyA9IHRydWU7XG4gICAgICAgIG1lbW9pemVkU25hcHNob3QgPSBuZXh0U25hcHNob3Q7XG5cbiAgICAgICAgdmFyIF9uZXh0U2VsZWN0aW9uID0gc2VsZWN0b3IobmV4dFNuYXBzaG90KTtcblxuICAgICAgICBpZiAoaXNFcXVhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gRXZlbiBpZiB0aGUgc2VsZWN0b3IgaGFzIGNoYW5nZWQsIHRoZSBjdXJyZW50bHkgcmVuZGVyZWQgc2VsZWN0aW9uXG4gICAgICAgICAgLy8gbWF5IGJlIGVxdWFsIHRvIHRoZSBuZXcgc2VsZWN0aW9uLiBXZSBzaG91bGQgYXR0ZW1wdCB0byByZXVzZSB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IHZhbHVlIGlmIHBvc3NpYmxlLCB0byBwcmVzZXJ2ZSBkb3duc3RyZWFtIG1lbW9pemF0aW9ucy5cbiAgICAgICAgICBpZiAoaW5zdC5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBpbnN0LnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoaXNFcXVhbChjdXJyZW50U2VsZWN0aW9uLCBfbmV4dFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IF9uZXh0U2VsZWN0aW9uO1xuICAgICAgICByZXR1cm4gX25leHRTZWxlY3Rpb247XG4gICAgICB9IC8vIFdlIG1heSBiZSBhYmxlIHRvIHJldXNlIHRoZSBwcmV2aW91cyBpbnZvY2F0aW9uJ3MgcmVzdWx0LlxuXG5cbiAgICAgIC8vIFdlIG1heSBiZSBhYmxlIHRvIHJldXNlIHRoZSBwcmV2aW91cyBpbnZvY2F0aW9uJ3MgcmVzdWx0LlxuICAgICAgdmFyIHByZXZTbmFwc2hvdCA9IG1lbW9pemVkU25hcHNob3Q7XG4gICAgICB2YXIgcHJldlNlbGVjdGlvbiA9IG1lbW9pemVkU2VsZWN0aW9uO1xuXG4gICAgICBpZiAob2JqZWN0SXMocHJldlNuYXBzaG90LCBuZXh0U25hcHNob3QpKSB7XG4gICAgICAgIC8vIFRoZSBzbmFwc2hvdCBpcyB0aGUgc2FtZSBhcyBsYXN0IHRpbWUuIFJldXNlIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24uXG4gICAgICAgIHJldHVybiBwcmV2U2VsZWN0aW9uO1xuICAgICAgfSAvLyBUaGUgc25hcHNob3QgaGFzIGNoYW5nZWQsIHNvIHdlIG5lZWQgdG8gY29tcHV0ZSBhIG5ldyBzZWxlY3Rpb24uXG5cblxuICAgICAgLy8gVGhlIHNuYXBzaG90IGhhcyBjaGFuZ2VkLCBzbyB3ZSBuZWVkIHRvIGNvbXB1dGUgYSBuZXcgc2VsZWN0aW9uLlxuICAgICAgdmFyIG5leHRTZWxlY3Rpb24gPSBzZWxlY3RvcihuZXh0U25hcHNob3QpOyAvLyBJZiBhIGN1c3RvbSBpc0VxdWFsIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB1c2UgdGhhdCB0byBjaGVjayBpZiB0aGUgZGF0YVxuICAgICAgLy8gaGFzIGNoYW5nZWQuIElmIGl0IGhhc24ndCwgcmV0dXJuIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24uIFRoYXQgc2lnbmFsc1xuICAgICAgLy8gdG8gUmVhY3QgdGhhdCB0aGUgc2VsZWN0aW9ucyBhcmUgY29uY2VwdHVhbGx5IGVxdWFsLCBhbmQgd2UgY2FuIGJhaWxcbiAgICAgIC8vIG91dCBvZiByZW5kZXJpbmcuXG5cbiAgICAgIC8vIElmIGEgY3VzdG9tIGlzRXF1YWwgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHVzZSB0aGF0IHRvIGNoZWNrIGlmIHRoZSBkYXRhXG4gICAgICAvLyBoYXMgY2hhbmdlZC4gSWYgaXQgaGFzbid0LCByZXR1cm4gdGhlIHByZXZpb3VzIHNlbGVjdGlvbi4gVGhhdCBzaWduYWxzXG4gICAgICAvLyB0byBSZWFjdCB0aGF0IHRoZSBzZWxlY3Rpb25zIGFyZSBjb25jZXB0dWFsbHkgZXF1YWwsIGFuZCB3ZSBjYW4gYmFpbFxuICAgICAgLy8gb3V0IG9mIHJlbmRlcmluZy5cbiAgICAgIGlmIChpc0VxdWFsICE9PSB1bmRlZmluZWQgJiYgaXNFcXVhbChwcmV2U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gcHJldlNlbGVjdGlvbjtcbiAgICAgIH1cblxuICAgICAgbWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcbiAgICAgIG1lbW9pemVkU2VsZWN0aW9uID0gbmV4dFNlbGVjdGlvbjtcbiAgICAgIHJldHVybiBuZXh0U2VsZWN0aW9uO1xuICAgIH07IC8vIEFzc2lnbmluZyB0aGlzIHRvIGEgY29uc3RhbnQgc28gdGhhdCBGbG93IGtub3dzIGl0IGNhbid0IGNoYW5nZS5cblxuXG4gICAgLy8gQXNzaWduaW5nIHRoaXMgdG8gYSBjb25zdGFudCBzbyB0aGF0IEZsb3cga25vd3MgaXQgY2FuJ3QgY2hhbmdlLlxuICAgIHZhciBtYXliZUdldFNlcnZlclNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBnZXRTZXJ2ZXJTbmFwc2hvdDtcblxuICAgIHZhciBnZXRTbmFwc2hvdFdpdGhTZWxlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBtZW1vaXplZFNlbGVjdG9yKGdldFNuYXBzaG90KCkpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0U2VydmVyU25hcHNob3RXaXRoU2VsZWN0b3IgPSBtYXliZUdldFNlcnZlclNuYXBzaG90ID09PSBudWxsID8gdW5kZWZpbmVkIDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG1lbW9pemVkU2VsZWN0b3IobWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCgpKTtcbiAgICB9O1xuICAgIHJldHVybiBbZ2V0U25hcHNob3RXaXRoU2VsZWN0b3IsIGdldFNlcnZlclNuYXBzaG90V2l0aFNlbGVjdG9yXTtcbiAgfSwgW2dldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCwgc2VsZWN0b3IsIGlzRXF1YWxdKSxcbiAgICAgIGdldFNlbGVjdGlvbiA9IF91c2VNZW1vWzBdLFxuICAgICAgZ2V0U2VydmVyU2VsZWN0aW9uID0gX3VzZU1lbW9bMV07XG5cbiAgdmFyIHZhbHVlID0gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTZWxlY3Rpb24sIGdldFNlcnZlclNlbGVjdGlvbik7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaW5zdC5oYXNWYWx1ZSA9IHRydWU7XG4gICAgaW5zdC52YWx1ZSA9IHZhbHVlO1xuICB9LCBbdmFsdWVdKTtcbiAgdXNlRGVidWdWYWx1ZSh2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yO1xuICAgICAgICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT1cbiAgICAnZnVuY3Rpb24nXG4pIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgXG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.3.1/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.3.1/node_modules/use-sync-external-store/shim/index.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.3.1/node_modules/use-sync-external-store/shim/index.js ***!
  \**************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim.development.js */ \"(app-pages-browser)/./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.3.1/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS91c2Utc3luYy1leHRlcm5hbC1zdG9yZUAxLjIuMF9yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLDBRQUE4RTtBQUNoRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmVAMS4yLjBfcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzP2RmOTciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.3.1/node_modules/use-sync-external-store/shim/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.3.1/node_modules/use-sync-external-store/shim/with-selector.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.3.1/node_modules/use-sync-external-store/shim/with-selector.js ***!
  \**********************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim/with-selector.development.js */ \"(app-pages-browser)/./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.3.1/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS91c2Utc3luYy1leHRlcm5hbC1zdG9yZUAxLjIuMF9yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vd2l0aC1zZWxlY3Rvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsc1NBQTRGO0FBQzlGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS91c2Utc3luYy1leHRlcm5hbC1zdG9yZUAxLjIuMF9yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vd2l0aC1zZWxlY3Rvci5qcz82MDE3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3dpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.3.1/node_modules/use-sync-external-store/shim/with-selector.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/container/Styles.scss":
/*!*************************************************!*\
  !*** ./src/components/ui/container/Styles.scss ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"a212e55a6eb2\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL2NvbnRhaW5lci9TdHlsZXMuc2NzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdWkvY29udGFpbmVyL1N0eWxlcy5zY3NzPzJkYjEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJhMjEyZTU1YTZlYjJcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/container/Styles.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/about/About.module.scss":
/*!************************************************!*\
  !*** ./src/components/about/About.module.scss ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"about\":\"About_about__BlUPd\",\"about__container\":\"About_about__container___WzFy\",\"about__info\":\"About_about__info__oOT4u\",\"about__block\":\"About_about__block___XuLG\",\"about__blockText\":\"About_about__blockText__wHg2W\",\"about__blockButton\":\"About_about__blockButton__5Ddke\",\"about__content\":\"About_about__content__T_0Be\",\"about__contentHead\":\"About_about__contentHead__I4084\",\"about__contentHeadVideo\":\"About_about__contentHeadVideo__uUZbH\",\"about__contentHeadReputation\":\"About_about__contentHeadReputation__IyTTO\",\"about__contentHeadReputationItem\":\"About_about__contentHeadReputationItem__pLMyb\",\"about__contentProjects\":\"About_about__contentProjects__Bxl1s\",\"about__contentProjectsButton\":\"About_about__contentProjectsButton__MWV6G\",\"about__contentProjectsMobile\":\"About_about__contentProjectsMobile__sMwrR\",\"about__contentProjectsMobileTitle\":\"About_about__contentProjectsMobileTitle__hKOlW\",\"about__contentProjectsMobileText\":\"About_about__contentProjectsMobileText__XoIQs\",\"about__contentProjectsItem\":\"About_about__contentProjectsItem__OSwmK\",\"about__contentProjectsItemLogo\":\"About_about__contentProjectsItemLogo__zJvyW\",\"about__contentProjectsItemContent\":\"About_about__contentProjectsItemContent__w0OIK\",\"about__contentProjectsItemTitle\":\"About_about__contentProjectsItemTitle__ZDIy8\",\"about__contentProjectsItemText\":\"About_about__contentProjectsItemText__E3ngK\",\"about__contentProjectsItemMore\":\"About_about__contentProjectsItemMore__VuDDd\",\"about__contentProjectsItemLink\":\"About_about__contentProjectsItemLink__sWyi_\"};\n    if(true) {\n      // 1716545546742\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"b99573f23025\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Fib3V0L0Fib3V0Lm1vZHVsZS5zY3NzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCO0FBQ2xCLE9BQU8sSUFBVTtBQUNqQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHNYQUFxTixjQUFjLHNEQUFzRDtBQUN2VCxNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2Fib3V0L0Fib3V0Lm1vZHVsZS5zY3NzPzY1MzkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcImFib3V0XCI6XCJBYm91dF9hYm91dF9fQmxVUGRcIixcImFib3V0X19jb250YWluZXJcIjpcIkFib3V0X2Fib3V0X19jb250YWluZXJfX19XekZ5XCIsXCJhYm91dF9faW5mb1wiOlwiQWJvdXRfYWJvdXRfX2luZm9fX29PVDR1XCIsXCJhYm91dF9fYmxvY2tcIjpcIkFib3V0X2Fib3V0X19ibG9ja19fX1h1TEdcIixcImFib3V0X19ibG9ja1RleHRcIjpcIkFib3V0X2Fib3V0X19ibG9ja1RleHRfX3dIZzJXXCIsXCJhYm91dF9fYmxvY2tCdXR0b25cIjpcIkFib3V0X2Fib3V0X19ibG9ja0J1dHRvbl9fNURka2VcIixcImFib3V0X19jb250ZW50XCI6XCJBYm91dF9hYm91dF9fY29udGVudF9fVF8wQmVcIixcImFib3V0X19jb250ZW50SGVhZFwiOlwiQWJvdXRfYWJvdXRfX2NvbnRlbnRIZWFkX19JNDA4NFwiLFwiYWJvdXRfX2NvbnRlbnRIZWFkVmlkZW9cIjpcIkFib3V0X2Fib3V0X19jb250ZW50SGVhZFZpZGVvX191VVpiSFwiLFwiYWJvdXRfX2NvbnRlbnRIZWFkUmVwdXRhdGlvblwiOlwiQWJvdXRfYWJvdXRfX2NvbnRlbnRIZWFkUmVwdXRhdGlvbl9fSXlUVE9cIixcImFib3V0X19jb250ZW50SGVhZFJlcHV0YXRpb25JdGVtXCI6XCJBYm91dF9hYm91dF9fY29udGVudEhlYWRSZXB1dGF0aW9uSXRlbV9fcExNeWJcIixcImFib3V0X19jb250ZW50UHJvamVjdHNcIjpcIkFib3V0X2Fib3V0X19jb250ZW50UHJvamVjdHNfX0J4bDFzXCIsXCJhYm91dF9fY29udGVudFByb2plY3RzQnV0dG9uXCI6XCJBYm91dF9hYm91dF9fY29udGVudFByb2plY3RzQnV0dG9uX19NV1Y2R1wiLFwiYWJvdXRfX2NvbnRlbnRQcm9qZWN0c01vYmlsZVwiOlwiQWJvdXRfYWJvdXRfX2NvbnRlbnRQcm9qZWN0c01vYmlsZV9fc013clJcIixcImFib3V0X19jb250ZW50UHJvamVjdHNNb2JpbGVUaXRsZVwiOlwiQWJvdXRfYWJvdXRfX2NvbnRlbnRQcm9qZWN0c01vYmlsZVRpdGxlX19oS09sV1wiLFwiYWJvdXRfX2NvbnRlbnRQcm9qZWN0c01vYmlsZVRleHRcIjpcIkFib3V0X2Fib3V0X19jb250ZW50UHJvamVjdHNNb2JpbGVUZXh0X19Yb0lRc1wiLFwiYWJvdXRfX2NvbnRlbnRQcm9qZWN0c0l0ZW1cIjpcIkFib3V0X2Fib3V0X19jb250ZW50UHJvamVjdHNJdGVtX19PU3dtS1wiLFwiYWJvdXRfX2NvbnRlbnRQcm9qZWN0c0l0ZW1Mb2dvXCI6XCJBYm91dF9hYm91dF9fY29udGVudFByb2plY3RzSXRlbUxvZ29fX3pKdnlXXCIsXCJhYm91dF9fY29udGVudFByb2plY3RzSXRlbUNvbnRlbnRcIjpcIkFib3V0X2Fib3V0X19jb250ZW50UHJvamVjdHNJdGVtQ29udGVudF9fdzBPSUtcIixcImFib3V0X19jb250ZW50UHJvamVjdHNJdGVtVGl0bGVcIjpcIkFib3V0X2Fib3V0X19jb250ZW50UHJvamVjdHNJdGVtVGl0bGVfX1pESXk4XCIsXCJhYm91dF9fY29udGVudFByb2plY3RzSXRlbVRleHRcIjpcIkFib3V0X2Fib3V0X19jb250ZW50UHJvamVjdHNJdGVtVGV4dF9fRTNuZ0tcIixcImFib3V0X19jb250ZW50UHJvamVjdHNJdGVtTW9yZVwiOlwiQWJvdXRfYWJvdXRfX2NvbnRlbnRQcm9qZWN0c0l0ZW1Nb3JlX19WdUREZFwiLFwiYWJvdXRfX2NvbnRlbnRQcm9qZWN0c0l0ZW1MaW5rXCI6XCJBYm91dF9hYm91dF9fY29udGVudFByb2plY3RzSXRlbUxpbmtfX3NXeWlfXCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3MTY1NDU1NDY3NDJcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovVXNlcnMvNzk1MzMvRGVza3RvcC9mcm9udC1yYmFuZC9yYmFuZC9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuNzcuMi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgXG5tb2R1bGUuZXhwb3J0cy5fX2NoZWNrc3VtID0gXCJiOTk1NzNmMjMwMjVcIlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/about/About.module.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/descriptor/styles.module.scss":
/*!******************************************************!*\
  !*** ./src/components/descriptor/styles.module.scss ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"descriptor\":\"styles_descriptor__dc5aT\",\"descriptor__container\":\"styles_descriptor__container__EO5n_\",\"descriptor__actionsTrigger\":\"styles_descriptor__actionsTrigger__UFkJd\",\"descriptor__actions\":\"styles_descriptor__actions__v8wGg\",\"descriptor__actionsVideo\":\"styles_descriptor__actionsVideo__H03vh\",\"descriptor__actionsImage\":\"styles_descriptor__actionsImage__8aBPk\",\"descriptor__content\":\"styles_descriptor__content__U7hSy\",\"descriptor__contentRegion\":\"styles_descriptor__contentRegion__2rOPL\",\"descriptor__contentTitle\":\"styles_descriptor__contentTitle__WP4pF\",\"descriptor__contentText\":\"styles_descriptor__contentText__7MT3v\",\"descriptor__right\":\"styles_descriptor__right__cR7nn\",\"descriptor__rightQuantity\":\"styles_descriptor__rightQuantity__zs340\",\"descriptor__rightQuantityNumber\":\"styles_descriptor__rightQuantityNumber__SjuLN\",\"descriptor__rightQuantityText\":\"styles_descriptor__rightQuantityText__errBp\",\"descriptor__rightPrice\":\"styles_descriptor__rightPrice__Jk1T5\"};\n    if(true) {\n      // 1716545546740\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"0c843dc0bcae\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Rlc2NyaXB0b3Ivc3R5bGVzLm1vZHVsZS5zY3NzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCO0FBQ2xCLE9BQU8sSUFBVTtBQUNqQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHNYQUFxTixjQUFjLHNEQUFzRDtBQUN2VCxNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2Rlc2NyaXB0b3Ivc3R5bGVzLm1vZHVsZS5zY3NzPzhhZGIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcImRlc2NyaXB0b3JcIjpcInN0eWxlc19kZXNjcmlwdG9yX19kYzVhVFwiLFwiZGVzY3JpcHRvcl9fY29udGFpbmVyXCI6XCJzdHlsZXNfZGVzY3JpcHRvcl9fY29udGFpbmVyX19FTzVuX1wiLFwiZGVzY3JpcHRvcl9fYWN0aW9uc1RyaWdnZXJcIjpcInN0eWxlc19kZXNjcmlwdG9yX19hY3Rpb25zVHJpZ2dlcl9fVUZrSmRcIixcImRlc2NyaXB0b3JfX2FjdGlvbnNcIjpcInN0eWxlc19kZXNjcmlwdG9yX19hY3Rpb25zX192OHdHZ1wiLFwiZGVzY3JpcHRvcl9fYWN0aW9uc1ZpZGVvXCI6XCJzdHlsZXNfZGVzY3JpcHRvcl9fYWN0aW9uc1ZpZGVvX19IMDN2aFwiLFwiZGVzY3JpcHRvcl9fYWN0aW9uc0ltYWdlXCI6XCJzdHlsZXNfZGVzY3JpcHRvcl9fYWN0aW9uc0ltYWdlX184YUJQa1wiLFwiZGVzY3JpcHRvcl9fY29udGVudFwiOlwic3R5bGVzX2Rlc2NyaXB0b3JfX2NvbnRlbnRfX1U3aFN5XCIsXCJkZXNjcmlwdG9yX19jb250ZW50UmVnaW9uXCI6XCJzdHlsZXNfZGVzY3JpcHRvcl9fY29udGVudFJlZ2lvbl9fMnJPUExcIixcImRlc2NyaXB0b3JfX2NvbnRlbnRUaXRsZVwiOlwic3R5bGVzX2Rlc2NyaXB0b3JfX2NvbnRlbnRUaXRsZV9fV1A0cEZcIixcImRlc2NyaXB0b3JfX2NvbnRlbnRUZXh0XCI6XCJzdHlsZXNfZGVzY3JpcHRvcl9fY29udGVudFRleHRfXzdNVDN2XCIsXCJkZXNjcmlwdG9yX19yaWdodFwiOlwic3R5bGVzX2Rlc2NyaXB0b3JfX3JpZ2h0X19jUjdublwiLFwiZGVzY3JpcHRvcl9fcmlnaHRRdWFudGl0eVwiOlwic3R5bGVzX2Rlc2NyaXB0b3JfX3JpZ2h0UXVhbnRpdHlfX3pzMzQwXCIsXCJkZXNjcmlwdG9yX19yaWdodFF1YW50aXR5TnVtYmVyXCI6XCJzdHlsZXNfZGVzY3JpcHRvcl9fcmlnaHRRdWFudGl0eU51bWJlcl9fU2p1TE5cIixcImRlc2NyaXB0b3JfX3JpZ2h0UXVhbnRpdHlUZXh0XCI6XCJzdHlsZXNfZGVzY3JpcHRvcl9fcmlnaHRRdWFudGl0eVRleHRfX2VyckJwXCIsXCJkZXNjcmlwdG9yX19yaWdodFByaWNlXCI6XCJzdHlsZXNfZGVzY3JpcHRvcl9fcmlnaHRQcmljZV9fSmsxVDVcIn07XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTcxNjU0NTU0Njc0MFxuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCJDOi9Vc2Vycy83OTUzMy9EZXNrdG9wL2Zyb250LXJiYW5kL3JiYW5kL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiL19uZXh0L1wiLFwiZXNNb2R1bGVcIjpmYWxzZSxcImxvY2Fsc1wiOnRydWV9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgXG4gICAgfVxuICBcbm1vZHVsZS5leHBvcnRzLl9fY2hlY2tzdW0gPSBcIjBjODQzZGMwYmNhZVwiXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/descriptor/styles.module.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/motivations/Motivations.module.scss":
/*!************************************************************!*\
  !*** ./src/components/motivations/Motivations.module.scss ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"motivations\":\"Motivations_motivations__VGh23\",\"motivations__textWrap\":\"Motivations_motivations__textWrap__B_afA\",\"motivations__container\":\"Motivations_motivations__container__F1AOE\",\"motivations__item\":\"Motivations_motivations__item__c5_dd\",\"motivations__itemContent\":\"Motivations_motivations__itemContent__j_F9C\",\"motivations__itemContentImage\":\"Motivations_motivations__itemContentImage__tH4e0\",\"motivations__itemContentTitle\":\"Motivations_motivations__itemContentTitle__Pw5Ws\",\"motivations__itemText\":\"Motivations_motivations__itemText__khF8S\"};\n    if(true) {\n      // 1716545546736\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"fa2153e90166\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL21vdGl2YXRpb25zL01vdGl2YXRpb25zLm1vZHVsZS5zY3NzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCO0FBQ2xCLE9BQU8sSUFBVTtBQUNqQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHNYQUFxTixjQUFjLHNEQUFzRDtBQUN2VCxNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL21vdGl2YXRpb25zL01vdGl2YXRpb25zLm1vZHVsZS5zY3NzPzdhYjkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcIm1vdGl2YXRpb25zXCI6XCJNb3RpdmF0aW9uc19tb3RpdmF0aW9uc19fVkdoMjNcIixcIm1vdGl2YXRpb25zX190ZXh0V3JhcFwiOlwiTW90aXZhdGlvbnNfbW90aXZhdGlvbnNfX3RleHRXcmFwX19CX2FmQVwiLFwibW90aXZhdGlvbnNfX2NvbnRhaW5lclwiOlwiTW90aXZhdGlvbnNfbW90aXZhdGlvbnNfX2NvbnRhaW5lcl9fRjFBT0VcIixcIm1vdGl2YXRpb25zX19pdGVtXCI6XCJNb3RpdmF0aW9uc19tb3RpdmF0aW9uc19faXRlbV9fYzVfZGRcIixcIm1vdGl2YXRpb25zX19pdGVtQ29udGVudFwiOlwiTW90aXZhdGlvbnNfbW90aXZhdGlvbnNfX2l0ZW1Db250ZW50X19qX0Y5Q1wiLFwibW90aXZhdGlvbnNfX2l0ZW1Db250ZW50SW1hZ2VcIjpcIk1vdGl2YXRpb25zX21vdGl2YXRpb25zX19pdGVtQ29udGVudEltYWdlX190SDRlMFwiLFwibW90aXZhdGlvbnNfX2l0ZW1Db250ZW50VGl0bGVcIjpcIk1vdGl2YXRpb25zX21vdGl2YXRpb25zX19pdGVtQ29udGVudFRpdGxlX19QdzVXc1wiLFwibW90aXZhdGlvbnNfX2l0ZW1UZXh0XCI6XCJNb3RpdmF0aW9uc19tb3RpdmF0aW9uc19faXRlbVRleHRfX2toRjhTXCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3MTY1NDU1NDY3MzZcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovVXNlcnMvNzk1MzMvRGVza3RvcC9mcm9udC1yYmFuZC9yYmFuZC9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuNzcuMi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgXG5tb2R1bGUuZXhwb3J0cy5fX2NoZWNrc3VtID0gXCJmYTIxNTNlOTAxNjZcIlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/motivations/Motivations.module.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/our-projects/styles.module.scss":
/*!********************************************************!*\
  !*** ./src/components/our-projects/styles.module.scss ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"ourProjects\":\"styles_ourProjects__DK66l\",\"ourProjects__container\":\"styles_ourProjects__container__ZTXcp\",\"ourProjects__header\":\"styles_ourProjects__header__jPrOj\",\"ourProjects__moreMobile\":\"styles_ourProjects__moreMobile__hXglN\",\"ourProjects__more\":\"styles_ourProjects__more__ZIBTB\",\"ourProjects__grid\":\"styles_ourProjects__grid__jcdTJ\",\"ourProjects__item\":\"styles_ourProjects__item__gYlUK\",\"ourProjects__textWhite\":\"styles_ourProjects__textWhite__W_JOT\",\"ourProjects__itemImg\":\"styles_ourProjects__itemImg__DA7kH\",\"ourProjects__itemTitle\":\"styles_ourProjects__itemTitle__TplNK\",\"ourProjects__itemText\":\"styles_ourProjects__itemText__TI4jo\",\"ourProjects__itemImgShadow\":\"styles_ourProjects__itemImgShadow__JnmXh\"};\n    if(true) {\n      // 1716545546739\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"09dccc4e6268\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL291ci1wcm9qZWN0cy9zdHlsZXMubW9kdWxlLnNjc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsc1hBQXFOLGNBQWMsc0RBQXNEO0FBQ3ZULE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvb3VyLXByb2plY3RzL3N0eWxlcy5tb2R1bGUuc2Nzcz81NTdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJvdXJQcm9qZWN0c1wiOlwic3R5bGVzX291clByb2plY3RzX19ESzY2bFwiLFwib3VyUHJvamVjdHNfX2NvbnRhaW5lclwiOlwic3R5bGVzX291clByb2plY3RzX19jb250YWluZXJfX1pUWGNwXCIsXCJvdXJQcm9qZWN0c19faGVhZGVyXCI6XCJzdHlsZXNfb3VyUHJvamVjdHNfX2hlYWRlcl9falByT2pcIixcIm91clByb2plY3RzX19tb3JlTW9iaWxlXCI6XCJzdHlsZXNfb3VyUHJvamVjdHNfX21vcmVNb2JpbGVfX2hYZ2xOXCIsXCJvdXJQcm9qZWN0c19fbW9yZVwiOlwic3R5bGVzX291clByb2plY3RzX19tb3JlX19aSUJUQlwiLFwib3VyUHJvamVjdHNfX2dyaWRcIjpcInN0eWxlc19vdXJQcm9qZWN0c19fZ3JpZF9famNkVEpcIixcIm91clByb2plY3RzX19pdGVtXCI6XCJzdHlsZXNfb3VyUHJvamVjdHNfX2l0ZW1fX2dZbFVLXCIsXCJvdXJQcm9qZWN0c19fdGV4dFdoaXRlXCI6XCJzdHlsZXNfb3VyUHJvamVjdHNfX3RleHRXaGl0ZV9fV19KT1RcIixcIm91clByb2plY3RzX19pdGVtSW1nXCI6XCJzdHlsZXNfb3VyUHJvamVjdHNfX2l0ZW1JbWdfX0RBN2tIXCIsXCJvdXJQcm9qZWN0c19faXRlbVRpdGxlXCI6XCJzdHlsZXNfb3VyUHJvamVjdHNfX2l0ZW1UaXRsZV9fVHBsTktcIixcIm91clByb2plY3RzX19pdGVtVGV4dFwiOlwic3R5bGVzX291clByb2plY3RzX19pdGVtVGV4dF9fVEk0am9cIixcIm91clByb2plY3RzX19pdGVtSW1nU2hhZG93XCI6XCJzdHlsZXNfb3VyUHJvamVjdHNfX2l0ZW1JbWdTaGFkb3dfX0pubVhoXCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3MTY1NDU1NDY3MzlcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovVXNlcnMvNzk1MzMvRGVza3RvcC9mcm9udC1yYmFuZC9yYmFuZC9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuNzcuMi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgXG5tb2R1bGUuZXhwb3J0cy5fX2NoZWNrc3VtID0gXCIwOWRjY2M0ZTYyNjhcIlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/our-projects/styles.module.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/partners/styles.module.scss":
/*!****************************************************!*\
  !*** ./src/components/partners/styles.module.scss ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"partners\":\"styles_partners__vHku_\",\"partners__trigger\":\"styles_partners__trigger___C_90\",\"partners__container\":\"styles_partners__container__pluGa\",\"partners__item\":\"styles_partners__item__BjW3S\"};\n    if(true) {\n      // 1716545546733\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"c51df8da67f5\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3BhcnRuZXJzL3N0eWxlcy5tb2R1bGUuc2NzcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQjtBQUNsQixPQUFPLElBQVU7QUFDakI7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxzWEFBcU4sY0FBYyxzREFBc0Q7QUFDdlQsTUFBTSxVQUFVO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9wYXJ0bmVycy9zdHlsZXMubW9kdWxlLnNjc3M/Njk4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbm1vZHVsZS5leHBvcnRzID0ge1wicGFydG5lcnNcIjpcInN0eWxlc19wYXJ0bmVyc19fdkhrdV9cIixcInBhcnRuZXJzX190cmlnZ2VyXCI6XCJzdHlsZXNfcGFydG5lcnNfX3RyaWdnZXJfX19DXzkwXCIsXCJwYXJ0bmVyc19fY29udGFpbmVyXCI6XCJzdHlsZXNfcGFydG5lcnNfX2NvbnRhaW5lcl9fcGx1R2FcIixcInBhcnRuZXJzX19pdGVtXCI6XCJzdHlsZXNfcGFydG5lcnNfX2l0ZW1fX0JqVzNTXCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3MTY1NDU1NDY3MzNcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovVXNlcnMvNzk1MzMvRGVza3RvcC9mcm9udC1yYmFuZC9yYmFuZC9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuNzcuMi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgXG5tb2R1bGUuZXhwb3J0cy5fX2NoZWNrc3VtID0gXCJjNTFkZjhkYTY3ZjVcIlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/partners/styles.module.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/text-wrap/styles.module.scss":
/*!*****************************************************!*\
  !*** ./src/components/text-wrap/styles.module.scss ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"textWrap\":\"styles_textWrap__ncygv\",\"textWrap__item\":\"styles_textWrap__item__NF4R7\",\"textWrap_reverse\":\"styles_textWrap_reverse__n_Brp\"};\n    if(true) {\n      // 1716545546743\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"6729fb390805\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3RleHQtd3JhcC9zdHlsZXMubW9kdWxlLnNjc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsc1hBQXFOLGNBQWMsc0RBQXNEO0FBQ3ZULE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdGV4dC13cmFwL3N0eWxlcy5tb2R1bGUuc2Nzcz9jN2Q3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJ0ZXh0V3JhcFwiOlwic3R5bGVzX3RleHRXcmFwX19uY3lndlwiLFwidGV4dFdyYXBfX2l0ZW1cIjpcInN0eWxlc190ZXh0V3JhcF9faXRlbV9fTkY0UjdcIixcInRleHRXcmFwX3JldmVyc2VcIjpcInN0eWxlc190ZXh0V3JhcF9yZXZlcnNlX19uX0JycFwifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzE2NTQ1NTQ2NzQzXG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIkM6L1VzZXJzLzc5NTMzL0Rlc2t0b3AvZnJvbnQtcmJhbmQvcmJhbmQvbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTQuMi4xX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjFfc2Fzc0AxLjc3LjIvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIvX25leHQvXCIsXCJlc01vZHVsZVwiOmZhbHNlLFwibG9jYWxzXCI6dHJ1ZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBcbiAgICB9XG4gIFxubW9kdWxlLmV4cG9ydHMuX19jaGVja3N1bSA9IFwiNjcyOWZiMzkwODA1XCJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/text-wrap/styles.module.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/button/Button.module.scss":
/*!*****************************************************!*\
  !*** ./src/components/ui/button/Button.module.scss ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"button\":\"Button_button__9Ya7B\",\"button__follower\":\"Button_button__follower__Q8SIc\"};\n    if(true) {\n      // 1716545546913\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"9968da9ec3d4\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL2J1dHRvbi9CdXR0b24ubW9kdWxlLnNjc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsc1hBQXFOLGNBQWMsc0RBQXNEO0FBQ3ZULE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdWkvYnV0dG9uL0J1dHRvbi5tb2R1bGUuc2Nzcz83OGRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJidXR0b25cIjpcIkJ1dHRvbl9idXR0b25fXzlZYTdCXCIsXCJidXR0b25fX2ZvbGxvd2VyXCI6XCJCdXR0b25fYnV0dG9uX19mb2xsb3dlcl9fUThTSWNcIn07XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTcxNjU0NTU0NjkxM1xuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCJDOi9Vc2Vycy83OTUzMy9EZXNrdG9wL2Zyb250LXJiYW5kL3JiYW5kL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiL19uZXh0L1wiLFwiZXNNb2R1bGVcIjpmYWxzZSxcImxvY2Fsc1wiOnRydWV9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgXG4gICAgfVxuICBcbm1vZHVsZS5leHBvcnRzLl9fY2hlY2tzdW0gPSBcIjk5NjhkYTllYzNkNFwiXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/button/Button.module.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/useful/Useful.module.scss":
/*!**************************************************!*\
  !*** ./src/components/useful/Useful.module.scss ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"useful\":\"Useful_useful__fSVKD\",\"useful__container\":\"Useful_useful__container__HjfFq\",\"useful__header\":\"Useful_useful__header__k5AI5\",\"useful__more\":\"Useful_useful__more__COiwE\",\"useful__slider\":\"Useful_useful__slider__StNMd\",\"useful__sliderSlide\":\"Useful_useful__sliderSlide__CQ4BS\",\"useful__sliderSlideImg\":\"Useful_useful__sliderSlideImg__MiXp_\",\"useful__sliderSlideTitle\":\"Useful_useful__sliderSlideTitle__HnKJx\",\"useful__sliderSlideText\":\"Useful_useful__sliderSlideText__s5iHF\"};\n    if(true) {\n      // 1716545546729\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"63df689cea01\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VzZWZ1bC9Vc2VmdWwubW9kdWxlLnNjc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsc1hBQXFOLGNBQWMsc0RBQXNEO0FBQ3ZULE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdXNlZnVsL1VzZWZ1bC5tb2R1bGUuc2Nzcz8zMmEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJ1c2VmdWxcIjpcIlVzZWZ1bF91c2VmdWxfX2ZTVktEXCIsXCJ1c2VmdWxfX2NvbnRhaW5lclwiOlwiVXNlZnVsX3VzZWZ1bF9fY29udGFpbmVyX19IamZGcVwiLFwidXNlZnVsX19oZWFkZXJcIjpcIlVzZWZ1bF91c2VmdWxfX2hlYWRlcl9fazVBSTVcIixcInVzZWZ1bF9fbW9yZVwiOlwiVXNlZnVsX3VzZWZ1bF9fbW9yZV9fQ09pd0VcIixcInVzZWZ1bF9fc2xpZGVyXCI6XCJVc2VmdWxfdXNlZnVsX19zbGlkZXJfX1N0Tk1kXCIsXCJ1c2VmdWxfX3NsaWRlclNsaWRlXCI6XCJVc2VmdWxfdXNlZnVsX19zbGlkZXJTbGlkZV9fQ1E0QlNcIixcInVzZWZ1bF9fc2xpZGVyU2xpZGVJbWdcIjpcIlVzZWZ1bF91c2VmdWxfX3NsaWRlclNsaWRlSW1nX19NaVhwX1wiLFwidXNlZnVsX19zbGlkZXJTbGlkZVRpdGxlXCI6XCJVc2VmdWxfdXNlZnVsX19zbGlkZXJTbGlkZVRpdGxlX19IbktKeFwiLFwidXNlZnVsX19zbGlkZXJTbGlkZVRleHRcIjpcIlVzZWZ1bF91c2VmdWxfX3NsaWRlclNsaWRlVGV4dF9fczVpSEZcIn07XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTcxNjU0NTU0NjcyOVxuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCJDOi9Vc2Vycy83OTUzMy9EZXNrdG9wL2Zyb250LXJiYW5kL3JiYW5kL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiL19uZXh0L1wiLFwiZXNNb2R1bGVcIjpmYWxzZSxcImxvY2Fsc1wiOnRydWV9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgXG4gICAgfVxuICBcbm1vZHVsZS5leHBvcnRzLl9fY2hlY2tzdW0gPSBcIjYzZGY2ODljZWEwMVwiXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/useful/Useful.module.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/add-locale.js":
/*!********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/add-locale.js ***!
  \********************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_to_consumable_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"addLocale\", ({\n    enumerable: true,\n    get: function get() {\n        return addLocale;\n    }\n}));\nvar _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/normalize-trailing-slash.js\");\nvar addLocale = function addLocale(path) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (false) { var _require; }\n    return path;\n};\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=add-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FkZC1sb2NhbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7NkNBR2FBOzs7ZUFBQUE7OztrREFGOEI7QUFFcEMsSUFBTUEsWUFBdUIsbUJBQUNDLElBQUFBO3FDQUFTQyxPQUFBQSxJQUFBQSxNQUFBQSxPQUFBQSxJQUFBQSxPQUFBQSxJQUFBQSxJQUFBQSxPQUFBQSxHQUFBQSxPQUFBQSxNQUFBQSxPQUFBQTtRQUFBQSxJQUFBQSxDQUFBQSxPQUFBQSxFQUFBQSxHQUFBQSxTQUFBQSxDQUFBQSxLQUFBQTs7SUFDNUMsSUFBSUMsS0FBK0IsRUFBRSxpQkFJckM7SUFDQSxPQUFPRjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L2FkZC1sb2NhbGUudHM/ZmFhZSJdLCJuYW1lcyI6WyJhZGRMb2NhbGUiLCJwYXRoIiwiYXJncyIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwicmVxdWlyZSIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/add-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/get-domain-locale.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/get-domain-locale.js ***!
  \***************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getDomainLocale\", ({\n    enumerable: true,\n    get: function get() {\n        return getDomainLocale;\n    }\n}));\nvar _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/normalize-trailing-slash.js\");\nvar basePath =  false || \"\";\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) { var finalLocale, proto, domain, target, detectDomainLocale, normalizeLocalePath; } else {\n        return false;\n    }\n}\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2dldC1kb21haW4tbG9jYWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7bURBT2dCQTs7O2VBQUFBOzs7a0RBSjJCO0FBRTNDLElBQU1DLFdBQVdDLE1BQW1DLElBQWU7QUFFNUQsU0FBU0YsZ0JBQ2RLLElBQVksRUFDWkMsTUFBdUIsRUFDdkJDLE9BQWtCLEVBQ2xCQyxhQUE4QjtJQUU5QixJQUFJTixLQUErQixFQUFFLG9GQWdCckMsTUFBTztRQUNMLE9BQU87SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L2dldC1kb21haW4tbG9jYWxlLnRzPzFkNGUiXSwibmFtZXMiOlsiZ2V0RG9tYWluTG9jYWxlIiwiYmFzZVBhdGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInBhdGgiLCJsb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwicmVxdWlyZSIsImRldGVjdERvbWFpbkxvY2FsZSIsInRhcmdldCIsImRldGVjdGVkTG9jYWxlIiwiZG9tYWluIiwidW5kZWZpbmVkIiwicHJvdG8iLCJodHRwIiwiZmluYWxMb2NhbGUiLCJkZWZhdWx0TG9jYWxlIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/image-component.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/image-component.js ***!
  \*************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\nvar _object_without_properties = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_without_properties.js\");\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nvar _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_to_consumable_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Image\", ({\n    enumerable: true,\n    get: function get() {\n        return Image;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-runtime.js\");\nvar _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\"));\nvar _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react-dom/index.js\"));\nvar _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/head */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/head.js\"));\nvar _getimgprops = __webpack_require__(/*! ../shared/lib/get-img-props */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/get-img-props.js\");\nvar _imageconfig = __webpack_require__(/*! ../shared/lib/image-config */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config.js\");\nvar _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nvar _warnonce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils/warn-once.js\");\nvar _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nvar _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-loader.js\"));\n// This is replaced by webpack define plugin\nvar configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[{\"protocol\":\"https\",\"hostname\":\"upload.wikimedia.org\",\"pathname\":\"/wikipedia/**\"}]};\nif (typeof window === \"undefined\") {\n    globalThis.__NEXT_IMAGE_IMPORTED = true;\n}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput) {\n    var src = img == null ? void 0 : img.src;\n    if (!img || img[\"data-loaded-src\"] === src) {\n        return;\n    }\n    img[\"data-loaded-src\"] = src;\n    var p = \"decode\" in img ? img.decode() : Promise.resolve();\n    p[\"catch\"](function() {}).then(function() {\n        if (!img.parentElement || !img.isConnected) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (placeholder !== \"empty\") {\n            setBlurComplete(true);\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            var event = new Event(\"load\");\n            Object.defineProperty(event, \"target\", {\n                writable: false,\n                value: img\n            });\n            var prevented = false;\n            var stopped = false;\n            onLoadRef.current(_object_spread_props._(_object_spread._({}, event), {\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: function() {\n                    return prevented;\n                },\n                isPropagationStopped: function() {\n                    return stopped;\n                },\n                persist: function() {},\n                preventDefault: function() {\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: function() {\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            }));\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            var origSrc = new URL(src, \"http://n\").searchParams.get(\"url\") || src;\n            if (img.getAttribute(\"data-nimg\") === \"fill\") {\n                if (!unoptimized && (!sizesInput || sizesInput === \"100vw\")) {\n                    var widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        if (sizesInput === \"100vw\") {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" prop and \"sizes\" prop of \"100vw\", but image is not rendered at full viewport width. Please adjust \"sizes\" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        } else {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        }\n                    }\n                }\n                if (img.parentElement) {\n                    var position = window.getComputedStyle(img.parentElement).position;\n                    var valid = [\n                        \"absolute\",\n                        \"fixed\",\n                        \"relative\"\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and parent element with invalid \"position\". Provided \"' + position + '\" should be one of ' + valid.map(String).join(\",\") + \".\");\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');\n                }\n            }\n            var heightModified = img.height.toString() !== img.getAttribute(\"height\");\n            var widthModified = img.width.toString() !== img.getAttribute(\"width\");\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.');\n            }\n        }\n    });\n}\nfunction getDynamicProps(fetchPriority) {\n    var _react_version_split = _sliced_to_array._(_react.version.split(\".\", 2), 2), majorStr = _react_version_split[0], minorStr = _react_version_split[1];\n    var major = parseInt(majorStr, 10);\n    var minor = parseInt(minorStr, 10);\n    if (major > 18 || major === 18 && minor >= 3) {\n        // In React 18.3.0 or newer, we must use camelCase\n        // prop to avoid \"Warning: Invalid DOM property\".\n        // See https://github.com/facebook/react/pull/25927\n        return {\n            fetchPriority: fetchPriority\n        };\n    }\n    // In React 18.2.0 or older, we must use lowercase prop\n    // to avoid \"Warning: Invalid DOM property\".\n    return {\n        fetchpriority: fetchPriority\n    };\n}\nvar ImageElement = /*#__PURE__*/ (0, _react.forwardRef)(function(param, forwardedRef) {\n    var src = param.src, srcSet = param.srcSet, sizes = param.sizes, height = param.height, width = param.width, decoding = param.decoding, className = param.className, style = param.style, fetchPriority = param.fetchPriority, placeholder = param.placeholder, loading = param.loading, unoptimized = param.unoptimized, fill = param.fill, onLoadRef = param.onLoadRef, onLoadingCompleteRef = param.onLoadingCompleteRef, setBlurComplete = param.setBlurComplete, setShowAltText = param.setShowAltText, sizesInput = param.sizesInput, onLoad = param.onLoad, onError = param.onError, rest = _object_without_properties._(param, [\n        \"src\",\n        \"srcSet\",\n        \"sizes\",\n        \"height\",\n        \"width\",\n        \"decoding\",\n        \"className\",\n        \"style\",\n        \"fetchPriority\",\n        \"placeholder\",\n        \"loading\",\n        \"unoptimized\",\n        \"fill\",\n        \"onLoadRef\",\n        \"onLoadingCompleteRef\",\n        \"setBlurComplete\",\n        \"setShowAltText\",\n        \"sizesInput\",\n        \"onLoad\",\n        \"onError\"\n    ]);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"img\", _object_spread_props._(_object_spread._({}, rest, getDynamicProps(fetchPriority)), {\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading: loading,\n        width: width,\n        height: height,\n        decoding: decoding,\n        \"data-nimg\": fill ? \"fill\" : \"1\",\n        className: className,\n        style: style,\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes: sizes,\n        srcSet: srcSet,\n        src: src,\n        ref: (0, _react.useCallback)(function(img) {\n            if (forwardedRef) {\n                if (typeof forwardedRef === \"function\") forwardedRef(img);\n                else if (typeof forwardedRef === \"object\") {\n                    // @ts-ignore - .current is read only it's usually assigned by react internally\n                    forwardedRef.current = img;\n                }\n            }\n            if (!img) {\n                return;\n            }\n            if (onError) {\n                // If the image has an error before react hydrates, then the error is lost.\n                // The workaround is to wait until the image is mounted which is after hydration,\n                // then we set the src again to trigger the error handler (if there was an error).\n                // eslint-disable-next-line no-self-assign\n                img.src = img.src;\n            }\n            if (true) {\n                if (!src) {\n                    console.error('Image is missing required \"src\" property:', img);\n                }\n                if (img.getAttribute(\"alt\") === null) {\n                    console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n                }\n            }\n            if (img.complete) {\n                handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n            }\n        }, [\n            src,\n            placeholder,\n            onLoadRef,\n            onLoadingCompleteRef,\n            setBlurComplete,\n            onError,\n            unoptimized,\n            sizesInput,\n            forwardedRef\n        ]),\n        onLoad: function(event) {\n            var img = event.currentTarget;\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n        },\n        onError: function(event) {\n            // if the real image fails to load, this will ensure \"alt\" is visible\n            setShowAltText(true);\n            if (placeholder !== \"empty\") {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    }));\n});\nfunction ImagePreload(param) {\n    var isAppRouter = param.isAppRouter, imgAttributes = param.imgAttributes;\n    var opts = _object_spread._({\n        as: \"image\",\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: imgAttributes.crossOrigin,\n        referrerPolicy: imgAttributes.referrerPolicy\n    }, getDynamicProps(imgAttributes.fetchPriority));\n    if (isAppRouter && _reactdom[\"default\"].preload) {\n        // See https://github.com/facebook/react/pull/26940\n        _reactdom[\"default\"].preload(imgAttributes.src, opts);\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head[\"default\"], {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", _object_spread._({\n            rel: \"preload\",\n            // Note how we omit the `href` attribute, as it would only be relevant\n            // for browsers that do not support `imagesrcset`, and in those cases\n            // it would cause the incorrect image to be preloaded.\n            //\n            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n            href: imgAttributes.srcSet ? undefined : imgAttributes.src\n        }, opts), \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)\n    });\n}\n_c = ImagePreload;\nvar Image = /*#__PURE__*/ (0, _react.forwardRef)(function(props, forwardedRef) {\n    var pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);\n    // We're in the app directory if there is no pages router.\n    var isAppRouter = !pagesRouter;\n    var configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);\n    var config = (0, _react.useMemo)(function() {\n        var c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        var allSizes = _to_consumable_array._(c.deviceSizes).concat(_to_consumable_array._(c.imageSizes)).sort(function(a, b) {\n            return a - b;\n        });\n        var deviceSizes = c.deviceSizes.sort(function(a, b) {\n            return a - b;\n        });\n        return _object_spread_props._(_object_spread._({}, c), {\n            allSizes: allSizes,\n            deviceSizes: deviceSizes\n        });\n    }, [\n        configContext\n    ]);\n    var onLoad = props.onLoad, onLoadingComplete = props.onLoadingComplete;\n    var onLoadRef = (0, _react.useRef)(onLoad);\n    (0, _react.useEffect)(function() {\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    var onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    (0, _react.useEffect)(function() {\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    var _ref = _sliced_to_array._((0, _react.useState)(false), 2), blurComplete = _ref[0], setBlurComplete = _ref[1];\n    var _ref1 = _sliced_to_array._((0, _react.useState)(false), 2), showAltText = _ref1[0], setShowAltText = _ref1[1];\n    var _ref2 = (0, _getimgprops.getImgProps)(props, {\n        defaultLoader: _imageloader[\"default\"],\n        imgConf: config,\n        blurComplete: blurComplete,\n        showAltText: showAltText\n    }), imgAttributes = _ref2.props, imgMeta = _ref2.meta;\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, _object_spread_props._(_object_spread._({}, imgAttributes), {\n                unoptimized: imgMeta.unoptimized,\n                placeholder: imgMeta.placeholder,\n                fill: imgMeta.fill,\n                onLoadRef: onLoadRef,\n                onLoadingCompleteRef: onLoadingCompleteRef,\n                setBlurComplete: setBlurComplete,\n                setShowAltText: setShowAltText,\n                sizesInput: props.sizes,\n                ref: forwardedRef\n            })),\n            imgMeta.priority ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {\n                isAppRouter: isAppRouter,\n                imgAttributes: imgAttributes\n            }) : null\n        ]\n    });\n});\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=image-component.js.map\nvar _c;\n$RefreshReg$(_c, \"ImagePreload\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLWNvbXBvbmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZFQWFpQjttREFDV0EsQ0FBQSxDQUFBQyxtQkFBQUEsQ0FBQTt1Q0FZTzs7dUNBRVZBLG1CQUFBQSxDQUFBOzs7QUFNekIsSUFBQUMsZUFBQSxjQUFBQyx5QkFBNENILENBQUEsQ0FBQUMsbUJBQUFBLENBQUE7QUFDNUMsNENBQThCRztBQUU5QixJQUFJQyxZQUFPQywyU0FBd0I7SUFDL0JFLE9BQUFBLFdBQW1CQyxhQUFBQTtJQUN2QkQsV0FBQUMscUJBQUE7QUFtQkE7QUFDQSwwRUFBaUQ7QUFDakQsaURBR0VDO1NBTUFDLGNBQVlDLEdBQUFBLEVBQUFBLFdBQUFBLEVBQUFBLFNBQVEsRUFBQUMsb0JBQUEsRUFBQUMsZUFBQSxFQUFBQyxXQUFBLEVBQUFDLFVBQUE7SUFDcEIsSUFBS0osTUFBT0EsT0FBSSxnQkFBa0JBLElBQUtLLEdBQUFBO1FBQ3JDLENBQUFMLE9BQUFBLEdBQUEsd0JBQUFLLEtBQUE7UUFDRjtJQUNBTDtJQUNBQSxHQUFBLG1CQUFzQkEsR0FBQUE7SUFDdEJNLElBQUVDLElBQU0sWUFBZVAsTUFBQUEsSUFBQVEsTUFBQSxLQUFBQyxRQUFBQyxPQUFBO2NBQ3JCLENBQUksWUFBS0MsR0FBQUEsSUFBQUEsQ0FBQUE7WUFDUCxDQUFBWCxJQUFBVyxhQUFBLEtBQUFYLElBQUFZLFdBQUEsRUFBd0M7WUFDeEMsd0NBQXVCO1lBQ3ZCO1lBQ0Esc0NBQXNCO1lBQ3RCO1lBQ0E7WUFDRjtRQUNBO1lBQ0VWLGdCQUFnQjtZQUNsQkEsZ0JBQUE7UUFDQTtZQUNFSixhQUFBLGdCQUFBQSxVQUFBZSxPQUFBLEVBQStDO1lBQy9DLCtDQUEwQztZQUMxQztZQUNBLDJDQUF3QjtZQUN4QkMsSUFBQUEsUUFBT0MsSUFBQUEsTUFBZUM7bUJBQW1CQyxjQUFVLENBQUFELE9BQUE7Z0JBQU9FLFVBQU9sQjtnQkFBSWtCLE9BQUFsQjtZQUNyRTtZQUNBLElBQUltQixZQUFVO1lBQ2RyQixJQUFBQSxVQUFVZTtzQkFDTEcsT0FBSyw2Q0FDUkk7Z0JBQ0FDLGFBQUFBO2dCQUNBQyxlQUFRdEI7Z0JBQ1J1QixRQUFBQTtnQkFDQUMsb0JBQUFBOzJCQUFzQkM7O2dCQUN0QkMsc0JBQWdCOzJCQUFBUDs7Z0JBQ2hCUSxTQUFBQSxZQUFBQTtnQ0FDYztvQkFDWlgsWUFBTVc7b0JBQ1JYLE1BQUFXLGNBQUE7Z0JBQ0FDO2lDQUNZO29CQUNWWixVQUFNWTtvQkFDUlosTUFBQVksZUFBQTtnQkFDRjs7UUFFRjtZQUNFM0Isd0JBQXFCWSxPQUFRYixLQUFBQSxJQUFBQSxxQkFBQUEsT0FBQUEsRUFBQUE7WUFDL0JDLHFCQUFBWSxPQUFBLENBQUFiO1FBQ0E7WUFDRTZCLElBQXdCeEIsRUFBSztZQUM3QixJQUFJTCxVQUFJOEIsSUFBWUMsSUFBQzFCLEtBQUEsWUFBaUIyQixZQUFRLENBQUFDLEdBQUEsV0FBQTVCO2dCQUM1Q0wsSUFBSThCLFlBQUMzQixDQUFBQSxpQkFBaUJDLFFBQWNBO29CQUNsQyxDQUFBRCxlQUFJK0IsQ0FBQUEsQ0FBQUEsY0FDRUMsZUFBQUEsT0FBd0JDLEdBQUFBO29CQUM5QixJQUFJRixxQkFBcUJsQyxJQUFBbUMscUJBQUssR0FBQUMsS0FBQSxHQUFBMUMsT0FBQTJDLFVBQUE7d0JBQzVCSCxxQkFBbUI7NEJBQ2pCSSxlQUFBQSxTQUNFOzRCQUVKLElBQU9DLFVBQUFELFFBQUEsdUJBQUFFLFVBQUE7K0JBQ0xGOzRCQUdGLElBQUFDLFVBQUFELFFBQUEsdUJBQUFFLFVBQUE7d0JBQ0Y7b0JBQ0Y7Z0JBQ0E7b0JBQ0V4QyxJQUFBVyxhQUFnQixFQUFFO29CQUNsQixJQUFNOEIsV0FBUS9DLE9BQUFnRCxnQkFBQSxDQUFBMUMsSUFBQVcsYUFBQSxFQUFSOEI7d0JBQVNBLFFBQUE7d0JBQVk7d0JBQVM7d0JBQVc7cUJBQy9DO3dCQUNFSCxDQUFBQSxNQUFBQSxRQUFBQSxDQUFBQSxXQUNHO3dCQUlMLElBQUFDLFVBQUFELFFBQUEsdUJBQUFFLFVBQUEsd0VBQUFHLFdBQUEsd0JBQUFGLE1BQUFHLEdBQUEsQ0FBQUMsUUFBQUMsSUFBQTtvQkFDRjtnQkFDQTtvQkFDRVIsSUFBQUEsTUFBQUEsS0FBQUEsR0FBQUE7b0JBR0YsSUFBQUMsVUFBQUQsUUFBQSx1QkFBQUUsVUFBQTtnQkFDRjtZQUVBO1lBRUEsSUFBTU8saUJBQWdCL0MsSUFBSW9DLE1BQU1ZLENBQUFBLFFBQVEsT0FBT2hELElBQUk4QixZQUFhO1lBQ2hFLElBQ0dtQixnQkFBa0JqRCxJQUFDK0MsS0FBQUEsQ0FBQUEsUUFDbkIsT0FBQ0UsSUFBQUEsWUFBa0JGLENBQUFBO2dCQUVwQlQsa0JBQUFBLENBQUFBLGlCQUNHLENBQUFXLGtCQUEwQkYsZUFBQTtnQkFFL0IsSUFBQVIsVUFBQUQsUUFBQSx1QkFBQUUsVUFBQTtZQUNGO1FBQ0Y7SUFDRjtBQUVBO1NBR0VVLGdCQUFpQkMsYUFBWUM7SUFDN0IsSUFBdUJDLDBDQUFBQSxPQUFVRCxPQUFBLENBQUFFLEtBQUEsY0FBM0JDLFdBQWlCRix5QkFBVEcsV0FBU0g7SUFDdkIsSUFBTUksUUFBUUQsU0FBU0wsVUFBVTtJQUNqQyxJQUFJSSxRQUFRQyxTQUFPRCxVQUFVO1FBQzNCQSxRQUFBLE1BQUFBLFVBQUEsTUFBQUUsU0FBQTtRQUNBLGtEQUFpRDtRQUNqRDtRQUNBLG1EQUFPO2VBQUVDO1lBQWNBLGVBQUFBO1FBQ3pCO0lBQ0E7SUFDQSx1REFBNEM7SUFDNUMsNENBQU87V0FBRUM7UUFBNkJBLGVBQUFEO0lBQ3hDO0FBRUE7bUJBTU1FLFdBQUFBLEdBQU0sSUFDTnhCLE9BQ0F5QixVQUNBQyxFQUFBQSxTQUFBQSxPQUNBQztJQWlCRixJQUFBMUQsTUFDR0wsTUFESEssS0FBQTJELFNBQ0doRSxNQURIZ0UsUUFBQUMsUUFDR2pFLE1BREhpRSxPQUNFTCxTQUFDNUQsTUFBRDRELFFBQUF4QixRQUFDcEMsTUFBRG9DLE9BQUF5QixXQUFDN0QsTUFBRDZELFVBQUM3RCxZQUFBQSxNQUFBQSxXQUFBQSxRQUFBQSxNQUFBQSxPQUFBQSxnQkFBQUEsTUFBQUEsZUFBQUEsY0FBQUEsTUFBQUEsYUFBQUEsVUFBQUEsTUFBQUEsU0FBQUEsY0FBQUEsTUFBQUEsYUFBQUEsT0FBQUEsTUFBQUEsTUFBQUEsWUFBQUEsTUFBQUEsV0FBQUEsdUJBQUFBLE1BQUFBLHNCQUFBQSxrQkFBQUEsTUFBQUEsaUJBQUFBLGlCQUFBQSxNQUFBQSxnQkFBQUEsYUFBQUEsTUFBQUEsWUFBQUEsU0FBQUEsTUFBQUEsUUFBQUEsVUFBQUEsTUFBQUEsU0FBQUEsb0NBQUFBO1FBREhLO1FBQUEyRDtRQUFBQztRQUNFTDtRQUFBeEI7UUFBQXlCO1FBQUM3RDtRQUFBQTtRQUFBQTtRQUFBQTtRQUFBQTtRQUFBQTtRQUFBQTtRQUFBQTtRQUFBQTtRQUFBQTtRQUFBQTtRQUFBQTtRQUFBQTtRQUFBQTs7V0FDUyxrQkFBQW1FLFlBQUFDLEdBQUEscURBQ0psQixNQUNKQSxnQkFBQVE7UUFDQTtRQUNBLHdFQUFxRDtRQUNyRFcscURBQVNBO1FBQ1RqQyxTQUFPQTtRQUNQd0IsT0FBQUE7UUFDQUMsUUFBQUE7UUFDQVMsVUFBQUE7UUFDQVIsYUFBV0EsT0FBQUEsU0FBQUE7UUFDWEMsV0FBT0E7UUFDUEEsT0FBQUE7UUFDQSx1RUFBbUU7UUFDbkU7UUFDQTtRQUNBLDBFQUEyQjtRQUMzQjtRQUNBRSxzREFBT0E7UUFDUEQsT0FBQUE7UUFDQTNELFFBQUtBO1FBQ0xrRSxLQUFLQzthQUVELElBQUlDLE9BQUFBLFdBQWMsV0FBQXpFO2dCQUNoQnlFLGNBQVdBOzJCQUNGQSxpQkFBT0EsWUFBaUJBLGFBQVV6RTtxQkFDekMsV0FBQXlFLGlCQUFBO29CQUNBQSwrRUFBdUJ6RTtvQkFDekJ5RSxhQUFBNUQsT0FBQSxHQUFBYjtnQkFDRjtZQUNBO2dCQUNFLENBQUFBLEtBQUE7Z0JBQ0Y7WUFDQTtnQkFDRTBFLFNBQUE7Z0JBQ0E7Z0JBQ0E7Z0JBQ0Esa0ZBQTBDO2dCQUMxQzFFLDBDQUFpQjtnQkFDbkJBLElBQUFLLEdBQUEsR0FBQUwsSUFBQUssR0FBQTtZQUNBO2dCQUNFd0IsSUFBVTtvQkFDUjhDLENBQUFBLEtBQUFBO29CQUNGQSxRQUFBQyxLQUFBLDhDQUFBNUU7Z0JBQ0E7b0JBQ0UyRSxJQUFBQSxZQUNHO29CQUVMQSxRQUFBQyxLQUFBO2dCQUNGO1lBQ0E7Z0JBQ0U3RSxJQUFBQSxRQUFBQSxFQUNFQztnQkFRSkQsY0FBQUMsS0FBQTZFLGFBQUEvRSxXQUFBRyxzQkFBQUMsaUJBQUFDLGFBQUFDO1lBRUY7O1lBRUV5RTtZQUNBL0U7WUFDQUc7WUFDQUM7WUFDQXdFO1lBQ0F2RTtZQUNBQztZQUNBcUU7WUFDREE7U0FFSEs7Z0JBQ0UsU0FBQTlEO1lBQ0FqQixJQUFBQSxNQUFBQSxNQUNFQyxhQUNBNkU7WUFPSjlFLGNBQUFDLEtBQUE2RSxhQUFBL0UsV0FBQUcsc0JBQUFDLGlCQUFBQyxhQUFBQztRQUNBc0U7aUJBQ0UsU0FBQTFEO1lBQ0ErRCxxRUFBZTtZQUNmQSxlQUFJRjtnQkFDRkEsZ0JBQUE7Z0JBQ0EzRSwyRUFBZ0I7Z0JBQ2xCQSxnQkFBQTtZQUNBO2dCQUNFd0UsU0FBUTFEO2dCQUNWMEQsUUFBQTFEO1lBQ0Y7OztBQU1SO1NBQXNCZ0UsYUFDVEMsS0FDWEM7SUFLQSxJQUFNQyxjQUFPRixNQUFQRSxhQUFPRCxnQkFBQUQsTUFBQUM7UUFDWEUsT0FBSTtRQUNKQyxJQUFBQTtRQUNBQyxhQUFZSixjQUFjakIsTUFBSztRQUMvQnNCLFlBQUFBLGNBQWFMLEtBQWNLO1FBQzNCQyxhQUFBQSxjQUFnQk4sV0FBY007UUFDOUJBLGdCQUFHdEMsY0FBZ0JnQyxjQUFjeEI7T0FDbkNSLGdCQUFBZ0MsY0FBQXhCLGFBQUE7UUFHRStCLGVBQUFDLFNBQUFDLENBQUFBLFVBQUEsQ0FBQUMsT0FBQTtRQUNBQyxtREFFRTtRQUNBVixTQUFBQSxDQUFBQSxVQUFBQSxDQUFBQSxPQUFBQSxDQUFBQSxjQUFBQSxHQUFBQSxFQUVGQTtRQUNGO0lBRUE7V0FFSSxrQkFBQWhCLFlBQUFDLEdBQUEsRUFBQTBCLEtBQUFILENBQUFBLFVBQUNJLEVBQUFBO2tCQU9LLGtCQUFBNUIsWUFBQUMsR0FBQTtZQUNKNEIsS0FBQTtZQUNBLHNFQUFxRTtZQUNyRSxxRUFBc0Q7WUFDdEQsc0RBQUU7WUFDRjtZQUNBQyw4RUFBMEQ7WUFDekRBLE1BQUdkLGNBQUluQixNQUFBLEdBQUFrQyxZQUFBaEIsY0FBQTdFLEdBQUE7V0FaTjhFO0lBZ0JWO0FBT087S0FyRGVIO0lBdURsQm1CLFFBQW9CQyxXQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxPQUFBQSxVQUFXRSxFQUFBQSxTQUFBQSxPQUFBQTtJQUMvQixJQUFBRCxjQUFBLElBQUFFLE9BQUFILFVBQUEsRUFBQUksNEJBQTBERixhQUFBO0lBQzFELDBEQUFxQkQ7SUFFckIsSUFBTUksY0FBQUEsQ0FBQUE7SUFDTixJQUFNQyxnQkFBU0MsQ0FBQUEsR0FBQUEsT0FBT1AsVUFBQyxFQUFBUSxpQ0FBQUMsa0JBQUE7UUFDckJILFNBQVVqSCxDQUFBQSxHQUFBQSxPQUFBQSxPQUFhZ0gsRUFBQUE7UUFDdkIsSUFBTUssSUFBQUEsYUFBV0wsaUJBQUFNLGFBQUFDLGtCQUFBO3VCQUFNQyx1QkFBZ0JDLEVBQUU1QixXQUFVLFNBQUU2Qix1QkFBS0QsRUFBQ0UsVUFBYUMsR0FDeEVGLElBQU1GLENBQUFBLFNBQUFBLEdBQUFBO21CQUFBQSxJQUFBQTs7UUFDTixJQUFBQSxjQUFPQyxFQUFBRCxXQUFBLENBQUFFLElBQUEsVUFBQUMsR0FBQUM7bUJBQUFELElBQUFDOztlQUFLSCw0Q0FBR0o7WUFBVUcsVUFBQUE7WUFBWUEsYUFBQUE7OztRQUNyQlI7S0FFbEI7SUFDQSxJQUFNM0csU0FBbUJnRixNQUFuQmhGLFFBQUFBLG9CQUFtQmdGLE1BQW5CaEY7SUFFTndILElBQUFBLFlBQUFBLENBQUFBLEdBQVVmLE9BQUFnQixNQUFBLEVBQUF6QztRQUNSaEYsT0FBQUEsU0FBVWUsRUFBTztRQUNoQmYsVUFBQWUsT0FBQSxHQUFBaUU7O1FBQVFBO0tBRVg7SUFFQXdDLElBQUFBLHVCQUFVLElBQUFmLE9BQUFnQixNQUFBLEVBQUFDO1FBQ1J2SCxPQUFBQSxTQUFBQSxFQUFBQTtRQUNDQSxxQkFBQVksT0FBQSxHQUFBMkc7O1FBQW1CQTtLQUV0QjtJQUNBLElBQXNDQywwQkFBQUEsQ0FBQUEsR0FBQUEsT0FBQUEsUUFBUyxjQUF4Q0MsZUFBK0JELFNBQWxCMUMsa0JBQWtCMEM7SUFFdEMsSUFBb0NFLDJCQUFBQSxDQUFBQSxHQUFBQSxPQUFZQyxRQUFBQSxFQUFBQSxZQUExQ0YsY0FBOEJDLFVBQXJCekMsaUJBQXFCeUM7UUFDckIsWUFBQUUsYUFBQUQsV0FBQSxFQUFBRSxPQUFBO1FBQ2JDLGVBQVNyQixZQUFBQSxDQUFBQSxVQUFBQTtRQUNUc0IsU0FBQUE7UUFDQU4sY0FBQUE7UUFDRkEsYUFBQUE7SUFFQSxJQU5FTyxnQkFBYSxNQUFiQSxPQUFBQSxVQUFhLE1BQWJBOzs7dUJBVVUvQyxHQUFBQSxDQUFBQSxHQUFBQSxZQUFhZCxHQUFBLEVBQUE4RCxjQUFBLDRDQUNqQi9IO2dCQUNBMEUsYUFBYThDLFFBQVE5QyxXQUFXO2dCQUNoQ3NELGFBQU1SLFFBQVk5QyxXQUFBO2dCQUNsQi9FLE1BQUFBLFFBQVdBLElBQUFBO2dCQUNYRyxXQUFBQTtnQkFDQUMsc0JBQWlCQTtnQkFDakI2RSxpQkFBZ0JBO2dCQUNoQjNFLGdCQUFZMEg7Z0JBQ1p2RCxZQUFLRSxNQUFBQSxLQUFBQTs7O29CQUtMZ0IsUUFBQUEsR0FBYUEsV0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsWUFBQUEsR0FBQUEsRUFBQUEsY0FBQUE7Z0JBQ2JQLGFBQUFBOytCQUVBQTs7O0lBR1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9jbGllbnQvaW1hZ2UtY29tcG9uZW50LnRzeD81MWUxIl0sIm5hbWVzIjpbIl8iLCJyZXF1aXJlIiwiX2ltYWdlbG9hZGVyIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiX19ORVhUX0lNQUdFX09QVFMiLCJjb25maWdFbnYiLCJ3aW5kb3ciLCJlbnYiLCJnbG9iYWxUaGlzIiwiX19ORVhUX0lNQUdFX0lNUE9SVEVEIiwib25Mb2FkUmVmIiwiaGFuZGxlTG9hZGluZyIsImltZyIsIm9uTG9hZGluZ0NvbXBsZXRlUmVmIiwic2V0Qmx1ckNvbXBsZXRlIiwidW5vcHRpbWl6ZWQiLCJzaXplc0lucHV0Iiwic3JjIiwicCIsImNhdGNoIiwiZGVjb2RlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwYXJlbnRFbGVtZW50IiwiaXNDb25uZWN0ZWQiLCJjdXJyZW50IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJldmVudCIsIndyaXRhYmxlIiwidmFsdWUiLCJzdG9wcGVkIiwibmF0aXZlRXZlbnQiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0IiwiaXNEZWZhdWx0UHJldmVudGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJwcmV2ZW50ZWQiLCJwZXJzaXN0IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJwcm9jZXNzIiwiZ2V0QXR0cmlidXRlIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwiZ2V0Iiwid2lkdGhWaWV3cG9ydFJhdGlvIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJpbm5lcldpZHRoIiwid2Fybk9uY2UiLCJfd2Fybm9uY2UiLCJvcmlnU3JjIiwidmFsaWQiLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJtYXAiLCJTdHJpbmciLCJqb2luIiwid2lkdGhNb2RpZmllZCIsInRvU3RyaW5nIiwiaGVpZ2h0TW9kaWZpZWQiLCJnZXREeW5hbWljUHJvcHMiLCJtaW5vclN0ciIsInZlcnNpb24iLCJtYWpvclN0ciIsInNwbGl0IiwibWFqb3IiLCJwYXJzZUludCIsIm1pbm9yIiwiZmV0Y2hQcmlvcml0eSIsImZldGNocHJpb3JpdHkiLCJoZWlnaHQiLCJkZWNvZGluZyIsImNsYXNzTmFtZSIsInN0eWxlIiwic3JjU2V0Iiwic2l6ZXMiLCJyZXN0IiwiX2pzeHJ1bnRpbWUiLCJqc3giLCJsb2FkaW5nIiwiZGF0YS1uaW1nIiwicmVmIiwidXNlQ2FsbGJhY2siLCJmb3J3YXJkZWRSZWYiLCJvbkVycm9yIiwiY29uc29sZSIsImVycm9yIiwicGxhY2Vob2xkZXIiLCJvbkxvYWQiLCJzZXRTaG93QWx0VGV4dCIsIkltYWdlUHJlbG9hZCIsInBhcmFtIiwiaW1nQXR0cmlidXRlcyIsIm9wdHMiLCJhcyIsImltYWdlU3JjU2V0IiwiaW1hZ2VTaXplcyIsImNyb3NzT3JpZ2luIiwicmVmZXJyZXJQb2xpY3kiLCJpc0FwcFJvdXRlciIsIl9yZWFjdGRvbSIsImRlZmF1bHQiLCJwcmVsb2FkIiwiUmVhY3RET00iLCJfaGVhZCIsImxpbmsiLCJyZWwiLCJocmVmIiwidW5kZWZpbmVkIiwiSW1hZ2UiLCJ1c2VDb250ZXh0IiwicGFnZXNSb3V0ZXIiLCJSb3V0ZXJDb250ZXh0IiwiX3JlYWN0IiwiX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiY29uZmlnQ29udGV4dCIsImNvbmZpZyIsInVzZU1lbW8iLCJfaW1hZ2Vjb25maWdjb250ZXh0c2hhcmVkcnVudGltZSIsIkltYWdlQ29uZmlnQ29udGV4dCIsImFsbFNpemVzIiwiX2ltYWdlY29uZmlnIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiZGV2aWNlU2l6ZXMiLCJjIiwic29ydCIsImEiLCJiIiwidXNlRWZmZWN0IiwidXNlUmVmIiwib25Mb2FkaW5nQ29tcGxldGUiLCJ1c2VTdGF0ZSIsInNob3dBbHRUZXh0IiwiaW1nTWV0YSIsImdldEltZ1Byb3BzIiwiX2dldGltZ3Byb3BzIiwicHJvcHMiLCJpbWdDb25mIiwiYmx1ckNvbXBsZXRlIiwiZGVmYXVsdExvYWRlciIsIkltYWdlRWxlbWVudCIsImZpbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/image-component.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/link.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/link.js ***!
  \**************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\nvar _object_without_properties = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_without_properties.js\");\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nvar _type_of = __webpack_require__(/*! @swc/helpers/_/_type_of */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_type_of.js\");\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function get() {\n        return _default;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-runtime.js\");\nvar _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\"));\nvar _resolvehref = __webpack_require__(/*! ./resolve-href */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/resolve-href.js\");\nvar _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nvar _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils.js\");\nvar _addlocale = __webpack_require__(/*! ./add-locale */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/add-locale.js\");\nvar _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nvar _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nvar _useintersection = __webpack_require__(/*! ./use-intersection */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/use-intersection.js\");\nvar _getdomainlocale = __webpack_require__(/*! ./get-domain-locale */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/get-domain-locale.js\");\nvar _addbasepath = __webpack_require__(/*! ./add-base-path */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/add-base-path.js\");\nvar _routerreducertypes = __webpack_require__(/*! ./components/router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nvar prefetched = new Set();\nfunction prefetch(router, href, as, options, appOptions, isAppRouter) {\n    if (typeof window === \"undefined\") {\n        return;\n    }\n    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    if (!isAppRouter && !(0, _islocalurl.isLocalURL)(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        var locale = typeof options.locale !== \"undefined\" ? options.locale : \"locale\" in router ? router.locale : undefined;\n        var prefetchedKey = href + \"%\" + as + \"%\" + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    var prefetchPromise = isAppRouter ? router.prefetch(href, appOptions) : router.prefetch(href, as, options);\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    Promise.resolve(prefetchPromise)[\"catch\"](function(err) {\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    var eventTarget = event.currentTarget;\n    var target = eventTarget.getAttribute(\"target\");\n    return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter) {\n    var nodeName = e.currentTarget.nodeName;\n    // anchors inside an svg have a lowercase nodeName\n    var isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    !isAppRouter && !(0, _islocalurl.isLocalURL)(href))) {\n        // ignore click for browsers default behavior\n        return;\n    }\n    e.preventDefault();\n    var navigate = function() {\n        // If the router is an NextRouter instance it will have `beforePopState`\n        var routerScroll = scroll != null ? scroll : true;\n        if (\"beforePopState\" in router) {\n            router[replace ? \"replace\" : \"push\"](href, as, {\n                shallow: shallow,\n                locale: locale,\n                scroll: routerScroll\n            });\n        } else {\n            router[replace ? \"replace\" : \"push\"](as || href, {\n                scroll: routerScroll\n            });\n        }\n    };\n    if (isAppRouter) {\n        _react[\"default\"].startTransition(navigate);\n    } else {\n        navigate();\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === \"string\") {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\n/**\n * A React component that extends the HTML `<a>` element to provide [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)\n * and client-side navigation between routes.\n *\n * It is the primary way to navigate between routes in Next.js.\n *\n * Read more: [Next.js docs: `<Link>`](https://nextjs.org/docs/app/api-reference/components/link)\n */ var Link = /*#__PURE__*/ _s(_react[\"default\"].forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n    _s();\n    var children;\n    var hrefProp = props.href, asProp = props.as, childrenProp = props.children, tmp = props.prefetch, prefetchProp = tmp === void 0 ? null : tmp, passHref = props.passHref, replace = props.replace, shallow = props.shallow, scroll = props.scroll, locale = props.locale, onClick = props.onClick, onMouseEnterProp = props.onMouseEnter, onTouchStartProp = props.onTouchStart, _props_legacyBehavior = props.legacyBehavior, legacyBehavior = _props_legacyBehavior === void 0 ? false : _props_legacyBehavior, restProps = _object_without_properties._(props, [\n        \"href\",\n        \"as\",\n        \"children\",\n        \"prefetch\",\n        \"passHref\",\n        \"replace\",\n        \"shallow\",\n        \"scroll\",\n        \"locale\",\n        \"onClick\",\n        \"onMouseEnter\",\n        \"onTouchStart\",\n        \"legacyBehavior\"\n    ]);\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n        children = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            children: children\n        });\n    }\n    var pagesRouter = _react[\"default\"].useContext(_routercontextsharedruntime.RouterContext);\n    var appRouter = _react[\"default\"].useContext(_approutercontextsharedruntime.AppRouterContext);\n    var router = pagesRouter != null ? pagesRouter : appRouter;\n    // We're in the app directory if there is no pages router.\n    var isAppRouter = !pagesRouter;\n    var prefetchEnabled = prefetchProp !== false;\n    /**\n     * The possible states for prefetch are:\n     * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n     * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n     * - false: we will not prefetch if in the viewport at all\n     */ var appPrefetchKind = prefetchProp === null ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;\n    if (true) {\n        var createPropError = function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + (typeof window !== \"undefined\" ? \"\\nOpen your browser's console to view the Component stack trace.\" : \"\"));\n        };\n        // TypeScript trick for type-guarding:\n        var requiredPropsGuard = {\n            href: true\n        };\n        var requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach(function(key) {\n            if (key === \"href\") {\n                if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`string` or `object`\",\n                        actual: props[key] === null ? \"null\" : _type_of._(props[key])\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                var _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        var optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        var optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach(function(key) {\n            var valType = _type_of._(props[key]);\n            if (key === \"as\") {\n                if (props[key] && valType !== \"string\" && valType !== \"object\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`string` or `object`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"locale\") {\n                if (props[key] && valType !== \"string\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`string`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n                if (props[key] && valType !== \"function\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`function`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n                if (props[key] != null && valType !== \"boolean\") {\n                    throw createPropError({\n                        key: key,\n                        expected: \"`boolean`\",\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                var _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        var hasWarned = _react[\"default\"].useRef(false);\n        if (props.prefetch && !hasWarned.current && !isAppRouter) {\n            hasWarned.current = true;\n            console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n        }\n    }\n    if (true) {\n        if (isAppRouter && !asProp) {\n            var href;\n            if (typeof hrefProp === \"string\") {\n                href = hrefProp;\n            } else if (typeof hrefProp === \"object\" && typeof hrefProp.pathname === \"string\") {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                var hasDynamicSegment = href.split(\"/\").some(function(segment) {\n                    return segment.startsWith(\"[\") && segment.endsWith(\"]\");\n                });\n                if (hasDynamicSegment) {\n                    throw new Error(\"Dynamic href `\" + href + \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\");\n                }\n            }\n        }\n    }\n    var _react_default_useMemo = _react[\"default\"].useMemo(function() {\n        if (!pagesRouter) {\n            var resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n        var _ref = _sliced_to_array._((0, _resolvehref.resolveHref)(pagesRouter, hrefProp, true), 2), resolvedHref1 = _ref[0], resolvedAs = _ref[1];\n        return {\n            href: resolvedHref1,\n            as: asProp ? (0, _resolvehref.resolveHref)(pagesRouter, asProp) : resolvedAs || resolvedHref1\n        };\n    }, [\n        pagesRouter,\n        hrefProp,\n        asProp\n    ]), href1 = _react_default_useMemo.href, as = _react_default_useMemo.as;\n    var previousHref = _react[\"default\"].useRef(href1);\n    var previousAs = _react[\"default\"].useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    var child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n            }\n            try {\n                child = _react[\"default\"].Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\");\n                }\n                throw new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + (typeof window !== \"undefined\" ? \" \\nOpen your browser's console to view the Component stack trace.\" : \"\"));\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === \"a\") {\n                throw new Error(\"Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor\");\n            }\n        }\n    }\n    var childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n    var _ref = _sliced_to_array._((0, _useintersection.useIntersection)({\n        rootMargin: \"200px\"\n    }), 3), setIntersectionRef = _ref[0], isVisible = _ref[1], resetVisible = _ref[2];\n    var setRef = _react[\"default\"].useCallback(function(el) {\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href1) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href1;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === \"function\") childRef(el);\n            else if (typeof childRef === \"object\") {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href1,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react[\"default\"].useEffect(function() {\n        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n        if (true) {\n            return;\n        }\n        if (!router) {\n            return;\n        }\n        // If we don't need to prefetch the URL, don't do prefetch.\n        if (!isVisible || !prefetchEnabled) {\n            return;\n        }\n        // Prefetch the URL.\n        prefetch(router, href1, as, {\n            locale: locale\n        }, {\n            kind: appPrefetchKind\n        }, isAppRouter);\n    }, [\n        as,\n        href1,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        pagesRouter == null ? void 0 : pagesRouter.locale,\n        router,\n        isAppRouter,\n        appPrefetchKind\n    ]);\n    var childProps = {\n        ref: setRef,\n        onClick: function(e) {\n            if (true) {\n                if (!e) {\n                    throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                }\n            }\n            if (!legacyBehavior && typeof onClick === \"function\") {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href1, as, replace, shallow, scroll, locale, isAppRouter);\n        },\n        onMouseEnter: function(e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === \"function\") {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if ((!prefetchEnabled || \"development\" === \"development\") && isAppRouter) {\n                return;\n            }\n            prefetch(router, href1, as, {\n                locale: locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        },\n        onTouchStart:  false ? 0 : function onTouchStart(e) {\n            if (!legacyBehavior && typeof onTouchStartProp === \"function\") {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href1, as, {\n                locale: locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n        var curLocale = typeof locale !== \"undefined\" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        var localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getdomainlocale.getDomainLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n        childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react[\"default\"].cloneElement(child, childProps) : /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", _object_spread_props._(_object_spread._({}, restProps, childProps), {\n        children: children\n    }));\n}, \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\")), \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\");\n_c1 = Link;\nvar _default = Link;\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xpbmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyQkFTNEJBLHlCQUFBQyxDQUFBLENBQUFDLG1CQUFBQSxDQUFBO3VDQUNEO3NDQUNEO3FDQUNJOzs7O3FDQVFFQSxtQkFBQUEsQ0FBQTsyQ0FDQTsyQ0FDSjs7QUEyRjVCLElBQU1DLHNCQUFpQkMsbUJBQUFBLENBQUFBLHNQQUFBQTtBQVV2QixJQUFBRCxhQUNFRSxJQUFBQTtTQU9JQyxTQUFPQyxNQUFBQSxFQUFXQyxJQUFBLEVBQUFDLEVBQUEsRUFBQUMsT0FBYSxFQUFBQyxVQUFBLEVBQUFDLFdBQUE7UUFDakMsT0FBQUwsV0FBQTtRQUNGO0lBRUE7SUFDQSxnSkFBdUM7UUFDckMsQ0FBQUssZUFBQSxLQUFBQyxZQUFBQyxVQUFBLEVBQUFOLE9BQUE7UUFDRjtJQUVBO0lBQ0EsNEVBQVk7SUFDWixZQUFLRTtRQUNILENBQUFBLFFBQU1LLHFCQUNKO1FBQ0EsSUFBQUEsU0FPRixPQUFNQyxRQUFBQSxNQUFBQSxLQUFnQlIsY0FBa0JFLFFBQU1LLE1BQUFBLEdBQUFBLFlBQUFBLFNBQUFBLE9BQUFBLE1BQUFBLEdBQUFBO1FBRTlDLElBQUFDLGdCQUFBUixPQUFBLE1BQUFDLEtBQUEsTUFBQU07UUFDQSxrRUFBbUM7WUFDakNaLFdBQUFjLEdBQUEsQ0FBQUQsZ0JBQUE7WUFDRjtRQUVBO1FBQ0FiLCtCQUFlYTtRQUNqQmIsV0FBQWUsR0FBQSxDQUFBRjtJQUVBO0lBSUEsSUFBQUcsa0JBQUFQLGNBQUFQLE9BQUFDLFFBQUEsQ0FBQUUsTUFBdURHLGNBQUFOLE9BQUFDLFFBQUEsQ0FBQUUsTUFBQUMsSUFBQUM7SUFDdkQ7SUFDQSwwREFB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QUEsU0FBQThDLGVBQXVFLGdCQUFBQSxZQUFBOUMsTUFBQTtRQUN2RSx1RUFBdUU7UUFDdkUsdUVBQ2VtSDtRQVFmRixJQUFBQSxlQUNFRyxDQUFBQSxlQUNBQyxPQUFBQSxLQUFBQSxJQUFBQSxZQUFZQyxjQUFBQSxLQUFBQSxDQUFBQSxHQUFTQyxpQkFBZ0J6RSxlQUFBQSxFQUFBQSxJQUFBQSxXQUFBQSxlQUFhMEUsT0FBQUEsS0FBYSxJQUFBMUUsWUFBQTJFLE9BQUEsRUFBQTNFLGVBQUEsZ0JBQUFBLFlBQUE0RSxhQUFBO1FBQ25FVCxXQUFBeEgsSUFBQSxHQUFBMkgsZ0JBQUEsSUFBQU8sYUFBQU4sV0FBQSxNQUFBTyxXQUFBTixTQUFBLEVBQUE1SCxJQUFBd0gsV0FBQXBFLGVBQUEsZ0JBQUFBLFlBQUEwRSxhQUFBO0lBRUE7V0FHU0ssaUJBQVMsY0FBQTdGLE1BQUFDLENBQUFBLFVBQUEsQ0FBQTZGLFlBQUEsQ0FBQXRDLE9BQUF5QixjQUFBLGtCQUFBYyxZQUFBQyxHQUFBLG1EQUFNZiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2NsaWVudC9saW5rLnRzeD9hY2YwIl0sIm5hbWVzIjpbIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsIl8iLCJyZXF1aXJlIiwicHJlZmV0Y2hlZCIsIlNldCIsInJvdXRlciIsInByZWZldGNoIiwid2luZG93IiwiaHJlZiIsImFzIiwib3B0aW9ucyIsImFwcE9wdGlvbnMiLCJpc0FwcFJvdXRlciIsIl9pc2xvY2FsdXJsIiwiaXNMb2NhbFVSTCIsImxvY2FsZSIsInByZWZldGNoZWRLZXkiLCJoYXMiLCJhZGQiLCJwcmVmZXRjaFByb21pc2UiLCJQcm9taXNlIiwiZXJyIiwicHJvY2VzcyIsImVudiIsImNhdGNoIiwiaXNNb2RpZmllZEV2ZW50IiwiZXZlbnQiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0IiwiZXZlbnRUYXJnZXQiLCJuYXRpdmVFdmVudCIsIndoaWNoIiwibWV0YUtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsImxpbmtDbGlja2VkIiwiZSIsInJlcGxhY2UiLCJzaGFsbG93Iiwic2Nyb2xsIiwibm9kZU5hbWUiLCJpc0FuY2hvck5vZGVOYW1lIiwicHJldmVudERlZmF1bHQiLCJuYXZpZ2F0ZSIsInJvdXRlclNjcm9sbCIsIlJlYWN0IiwiX3JlYWN0IiwiZGVmYXVsdCIsInN0YXJ0VHJhbnNpdGlvbiIsImZvcm1hdFN0cmluZ09yVXJsIiwidXJsT2JqT3JTdHJpbmciLCJfZm9ybWF0dXJsIiwiZm9ybWF0VXJsIiwiY2hpbGRyZW4iLCJjaGlsZHJlblByb3AiLCJsZWdhY3lCZWhhdmlvciIsImEiLCJhcHBSb3V0ZXIiLCJ1c2VDb250ZXh0IiwiQXBwUm91dGVyQ29udGV4dCIsInBhZ2VzUm91dGVyIiwicHJlZmV0Y2hFbmFibGVkIiwicHJlZmV0Y2hQcm9wIiwiX3JvdXRlcnJlZHVjZXJ0eXBlcyIsIlByZWZldGNoS2luZCIsIkFVVE8iLCJGVUxMIiwiYXJncyIsImNyZWF0ZVByb3BFcnJvciIsIkVycm9yIiwia2V5IiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJyZXF1aXJlZFByb3BzIiwiT2JqZWN0IiwicHJvcHMiLCJwYXNzSHJlZiIsIm9uQ2xpY2siLCJvbk1vdXNlRW50ZXIiLCJvblRvdWNoU3RhcnQiLCJvcHRpb25hbFByb3BzIiwidmFsVHlwZSIsImhhc1dhcm5lZCIsImN1cnJlbnQiLCJjb25zb2xlIiwid2FybiIsImFzUHJvcCIsImhyZWZQcm9wIiwicGF0aG5hbWUiLCJoYXNEeW5hbWljU2VnbWVudCIsInNwbGl0Iiwic29tZSIsInNlZ21lbnQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJ1c2VNZW1vIiwicmVzb2x2ZWRIcmVmIiwiX3Jlc29sdmVocmVmIiwicmVzb2x2ZUhyZWYiLCJyZXNvbHZlZEFzIiwicHJldmlvdXNBcyIsInVzZVJlZiIsImNoaWxkIiwiTk9ERV9FTlYiLCJDaGlsZHJlbiIsIm9ubHkiLCJ0eXBlIiwiY2hpbGRSZWYiLCJzZXRJbnRlcnNlY3Rpb25SZWYiLCJpc1Zpc2libGUiLCJyZXNldFZpc2libGUiLCJ1c2VJbnRlcnNlY3Rpb24iLCJfdXNlaW50ZXJzZWN0aW9uIiwicm9vdE1hcmdpbiIsInNldFJlZiIsInVzZUNhbGxiYWNrIiwiZWwiLCJwcmV2aW91c0hyZWYiLCJ1c2VFZmZlY3QiLCJhcHBQcmVmZXRjaEtpbmQiLCJyZWYiLCJkZWZhdWx0UHJldmVudGVkIiwib25Nb3VzZUVudGVyUHJvcCIsInByaW9yaXR5IiwiYnlwYXNzUHJlZmV0Y2hlZENoZWNrIiwib25Ub3VjaFN0YXJ0UHJvcCIsInVuZGVmaW5lZCIsImNoaWxkUHJvcHMiLCJjdXJMb2NhbGUiLCJpc0xvY2FsZURvbWFpbiIsImxvY2FsZURvbWFpbiIsImFkZEJhc2VQYXRoIiwiYWRkTG9jYWxlIiwiX2dldGRvbWFpbmxvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsIl9hZGRiYXNlcGF0aCIsIl9hZGRsb2NhbGUiLCJyZXN0UHJvcHMiLCJjbG9uZUVsZW1lbnQiLCJfanN4cnVudGltZSIsImpzeCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/request-idle-callback.js":
/*!*******************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/request-idle-callback.js ***!
  \*******************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    cancelIdleCallback: function cancelIdleCallback1() {\n        return cancelIdleCallback;\n    },\n    requestIdleCallback: function requestIdleCallback1() {\n        return requestIdleCallback;\n    }\n});\nvar requestIdleCallback = typeof self !== \"undefined\" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    var start = Date.now();\n    return self.setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function timeRemaining() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nvar cancelIdleCallback = typeof self !== \"undefined\" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFnQmFBLG9CQUFrQixTQUFsQkE7ZUFBQUE7O0lBaEJBQyxxQkFBbUIsU0FBbkJBO2VBQUFBOzs7QUFBTixJQUFNQSxzQkFDWCxPQUFRQyxTQUFTLGVBQ2ZBLEtBQUtELG1CQUFtQixJQUN4QkMsS0FBS0QsbUJBQW1CLENBQUNFLElBQUksQ0FBQ0MsV0FDaEMsU0FBVUMsRUFBdUI7SUFDL0IsSUFBSUMsUUFBUUMsS0FBS0MsR0FBRztJQUNwQixPQUFPTixLQUFLTyxVQUFVLENBQUM7UUFDckJKLEdBQUc7WUFDREssWUFBWTtZQUNaQyxlQUFlLFNBQWZBO2dCQUNFLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLEtBQU1OLENBQUFBLEtBQUtDLEdBQUcsS0FBS0YsS0FBQUE7WUFDeEM7UUFDRjtJQUNGLEdBQUc7QUFDTDtBQUVLLElBQU1OLHFCQUNYLE9BQVFFLFNBQVMsZUFDZkEsS0FBS0Ysa0JBQWtCLElBQ3ZCRSxLQUFLRixrQkFBa0IsQ0FBQ0csSUFBSSxDQUFDQyxXQUMvQixTQUFVVSxFQUFVO0lBQ2xCLE9BQU9DLGFBQWFEO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay50cz8wNWY0Il0sIm5hbWVzIjpbImNhbmNlbElkbGVDYWxsYmFjayIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJzZWxmIiwiYmluZCIsIndpbmRvdyIsImNiIiwic3RhcnQiLCJEYXRlIiwibm93Iiwic2V0VGltZW91dCIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiTWF0aCIsIm1heCIsImlkIiwiY2xlYXJUaW1lb3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/resolve-href.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/resolve-href.js ***!
  \**********************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"resolveHref\", ({\n    enumerable: true,\n    get: function get() {\n        return resolveHref;\n    }\n}));\nvar _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nvar _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nvar _omit = __webpack_require__(/*! ../shared/lib/router/utils/omit */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/omit.js\");\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils.js\");\nvar _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/normalize-trailing-slash.js\");\nvar _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nvar _utils1 = __webpack_require__(/*! ../shared/lib/router/utils */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/index.js\");\nvar _interpolateas = __webpack_require__(/*! ../shared/lib/router/utils/interpolate-as */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    var base;\n    var urlAsString = typeof href === \"string\" ? href : (0, _formaturl.formatWithValidation)(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    var urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    var urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    var urlParts = urlAsStringNoProto.split(\"?\", 1);\n    if ((urlParts[0] || \"\").match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n        var normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : \"\") + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith(\"#\") ? router.asPath : router.pathname, \"http://n\");\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL(\"/\", \"http://n\");\n    }\n    try {\n        var finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n        var interpolatedAs = \"\";\n        if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            var query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n            var _ref = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query), result = _ref.result, params = _ref.params;\n            if (result) {\n                interpolatedAs = (0, _formaturl.formatWithValidation)({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: (0, _omit.omit)(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        var resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=resolve-href.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3Jlc29sdmUtaHJlZi5qcyIsIm1hcHBpbmdzIjoiOzs7OytDQXlCZ0JBOzs7ZUFBQUE7Ozt1Q0F2QnVCO3FDQUNGO2dDQUNoQjtpQ0FDb0I7a0RBQ0U7c0NBQ2hCO2tDQUNJO3lDQUNEO0FBZ0J2QixTQUFTQSxZQUNkQyxNQUFrQixFQUNsQkMsSUFBUyxFQUNUQyxTQUFtQjtJQUVuQiw0Q0FBNEM7SUFDNUMsSUFBSUM7SUFDSixJQUFJQyxjQUFjLE9BQU9ILFNBQVMsV0FBV0EsT0FBT0ksQ0FBQUEsR0FBQUEsV0FBQUEsb0JBQW9CLEVBQUNKO0lBRXpFLDZEQUE2RDtJQUM3RCxtREFBbUQ7SUFDbkQsSUFBTUssZ0JBQWdCRixZQUFZRyxLQUFLLENBQUM7SUFDeEMsSUFBTUMscUJBQXFCRixnQkFDdkJGLFlBQVlLLEtBQUssQ0FBQ0gsYUFBYSxDQUFDLEVBQUUsQ0FBQ0ksTUFBTSxJQUN6Q047SUFFSixJQUFNTyxXQUFXSCxtQkFBbUJJLEtBQUssQ0FBQyxLQUFLO0lBRS9DLElBQUksQ0FBQ0QsUUFBUSxDQUFDLEVBQUUsSUFBSSxJQUFJSixLQUFLLENBQUMsY0FBYztRQUMxQ00sUUFBUUMsS0FBSyxDQUNYLG1CQUFpQlYsY0FBWSx1Q0FBb0NKLE9BQU9lLFFBQVEsR0FBQztRQUVuRixJQUFNQyxnQkFBZ0JDLENBQUFBLEdBQUFBLE9BQUFBLHdCQUF3QixFQUFDVDtRQUMvQ0osY0FBYyxDQUFDRSxnQkFBZ0JBLGFBQWEsQ0FBQyxFQUFFLEdBQUcsTUFBTVU7SUFDMUQ7SUFFQSwyREFBMkQ7SUFDM0QsSUFBSSxDQUFDRSxDQUFBQSxHQUFBQSxZQUFBQSxVQUFVLEVBQUNkLGNBQWM7UUFDNUIsT0FBUUYsWUFBWTtZQUFDRTtTQUFZLEdBQUdBO0lBQ3RDO0lBRUEsSUFBSTtRQUNGRCxPQUFPLElBQUlnQixJQUNUZixZQUFZZ0IsVUFBVSxDQUFDLE9BQU9wQixPQUFPcUIsTUFBTSxHQUFHckIsT0FBT2UsUUFBUSxFQUM3RDtJQUVKLEVBQUUsT0FBT08sR0FBRztRQUNWLGtEQUFrRDtRQUNsRG5CLE9BQU8sSUFBSWdCLElBQUksS0FBSztJQUN0QjtJQUVBLElBQUk7UUFDRixJQUFNSSxXQUFXLElBQUlKLElBQUlmLGFBQWFEO1FBQ3RDb0IsU0FBU1IsUUFBUSxHQUFHUyxDQUFBQSxHQUFBQSx3QkFBQUEsMEJBQTBCLEVBQUNELFNBQVNSLFFBQVE7UUFDaEUsSUFBSVUsaUJBQWlCO1FBRXJCLElBQ0VDLENBQUFBLEdBQUFBLFFBQUFBLGNBQWMsRUFBQ0gsU0FBU1IsUUFBUSxLQUNoQ1EsU0FBU0ksWUFBWSxJQUNyQnpCLFdBQ0E7WUFDQSxJQUFNMEIsUUFBUUMsQ0FBQUEsR0FBQUEsYUFBQUEsc0JBQXNCLEVBQUNOLFNBQVNJLFlBQVk7WUFFMUQsSUFBMkJHLE9BQUFBLENBQUFBLEdBQUFBLGVBQUFBLGFBQWEsRUFDdENQLFNBQVNSLFFBQVEsRUFDakJRLFNBQVNSLFFBQVEsRUFDakJhLFFBSE1HLFNBQW1CRCxLQUFuQkMsUUFBUUMsU0FBV0YsS0FBWEU7WUFNaEIsSUFBSUQsUUFBUTtnQkFDVk4saUJBQWlCcEIsQ0FBQUEsR0FBQUEsV0FBQUEsb0JBQW9CLEVBQUM7b0JBQ3BDVSxVQUFVZ0I7b0JBQ1ZFLE1BQU1WLFNBQVNVLElBQUk7b0JBQ25CTCxPQUFPTSxDQUFBQSxHQUFBQSxNQUFBQSxJQUFJLEVBQUNOLE9BQU9JO2dCQUNyQjtZQUNGO1FBQ0Y7UUFFQSxvRUFBb0U7UUFDcEUsSUFBTUcsZUFDSlosU0FBU2EsTUFBTSxLQUFLakMsS0FBS2lDLE1BQU0sR0FDM0JiLFNBQVN0QixJQUFJLENBQUNRLEtBQUssQ0FBQ2MsU0FBU2EsTUFBTSxDQUFDMUIsTUFBTSxJQUMxQ2EsU0FBU3RCLElBQUk7UUFFbkIsT0FBT0MsWUFDSDtZQUFDaUM7WUFBY1Ysa0JBQWtCVTtTQUFhLEdBQzlDQTtJQUNOLEVBQUUsT0FBT2IsR0FBRztRQUNWLE9BQU9wQixZQUFZO1lBQUNFO1NBQVksR0FBR0E7SUFDckM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2NsaWVudC9yZXNvbHZlLWhyZWYudHM/ZTZkMiJdLCJuYW1lcyI6WyJyZXNvbHZlSHJlZiIsInJvdXRlciIsImhyZWYiLCJyZXNvbHZlQXMiLCJiYXNlIiwidXJsQXNTdHJpbmciLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsInVybFByb3RvTWF0Y2giLCJtYXRjaCIsInVybEFzU3RyaW5nTm9Qcm90byIsInNsaWNlIiwibGVuZ3RoIiwidXJsUGFydHMiLCJzcGxpdCIsImNvbnNvbGUiLCJlcnJvciIsInBhdGhuYW1lIiwibm9ybWFsaXplZFVybCIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsImlzTG9jYWxVUkwiLCJVUkwiLCJzdGFydHNXaXRoIiwiYXNQYXRoIiwiXyIsImZpbmFsVXJsIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJpbnRlcnBvbGF0ZWRBcyIsImlzRHluYW1pY1JvdXRlIiwic2VhcmNoUGFyYW1zIiwicXVlcnkiLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IiwiaW50ZXJwb2xhdGVBcyIsInJlc3VsdCIsInBhcmFtcyIsImhhc2giLCJvbWl0IiwicmVzb2x2ZWRIcmVmIiwib3JpZ2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/resolve-href.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/use-intersection.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/use-intersection.js ***!
  \**************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useIntersection\", ({\n    enumerable: true,\n    get: function get() {\n        return useIntersection;\n    }\n}));\nvar _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\nvar _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/request-idle-callback.js\");\nvar hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nvar observers = new Map();\nvar idList = [];\nfunction createObserver(options) {\n    var id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    var existing = idList.find(function(obj) {\n        return obj.root === id.root && obj.margin === id.margin;\n    });\n    var instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    var elements = new Map();\n    var observer = new IntersectionObserver(function(entries) {\n        entries.forEach(function(entry) {\n            var callback = elements.get(entry.target);\n            var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id: id,\n        observer: observer,\n        elements: elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    var _createObserver = createObserver(options), id = _createObserver.id, observer = _createObserver.observer, elements = _createObserver.elements;\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements[\"delete\"](element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers[\"delete\"](id);\n            var index = idList.findIndex(function(obj) {\n                return obj.root === id.root && obj.margin === id.margin;\n            });\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    var rootRef = param.rootRef, rootMargin = param.rootMargin, disabled = param.disabled;\n    var isDisabled = disabled || !hasIntersectionObserver;\n    var _ref = _sliced_to_array._((0, _react.useState)(false), 2), visible = _ref[0], setVisible = _ref[1];\n    var elementRef = (0, _react.useRef)(null);\n    var setElement = (0, _react.useCallback)(function(element) {\n        elementRef.current = element;\n    }, []);\n    (0, _react.useEffect)(function() {\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            var element = elementRef.current;\n            if (element && element.tagName) {\n                var unobserve = observe(element, function(isVisible) {\n                    return isVisible && setVisible(isVisible);\n                }, {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin: rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                var idleCallback = (0, _requestidlecallback.requestIdleCallback)(function() {\n                    return setVisible(true);\n                });\n                return function() {\n                    return (0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n                };\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    var resetVisible = (0, _react.useCallback)(function() {\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7bURBK0ZnQkE7OztlQUFBQTs7O2lDQS9GeUM7K0NBSWxEO0FBcUJQLElBQU1DLDBCQUEwQixPQUFPQyx5QkFBeUI7QUFFaEUsSUFBTUMsWUFBWSxJQUFJQztBQUN0QixJQUFNQyxTQUF1QixFQUFFO0FBRS9CLFNBQVNDLGVBQWVDLE9BQW9DO0lBQzFELElBQU1DLEtBQUs7UUFDVEMsTUFBTUYsUUFBUUUsSUFBSSxJQUFJO1FBQ3RCQyxRQUFRSCxRQUFRSSxVQUFVLElBQUk7SUFDaEM7SUFDQSxJQUFNQyxXQUFXUCxPQUFPUSxJQUFJLENBQzFCLFNBQUNDO2VBQVFBLElBQUlMLElBQUksS0FBS0QsR0FBR0MsSUFBSSxJQUFJSyxJQUFJSixNQUFNLEtBQUtGLEdBQUdFLE1BQU07O0lBRTNELElBQUlLO0lBRUosSUFBSUgsVUFBVTtRQUNaRyxXQUFXWixVQUFVYSxHQUFHLENBQUNKO1FBQ3pCLElBQUlHLFVBQVU7WUFDWixPQUFPQTtRQUNUO0lBQ0Y7SUFFQSxJQUFNRSxXQUFXLElBQUliO0lBQ3JCLElBQU1jLFdBQVcsSUFBSWhCLHFCQUFxQixTQUFDaUI7UUFDekNBLFFBQVFDLE9BQU8sQ0FBQyxTQUFDQztZQUNmLElBQU1DLFdBQVdMLFNBQVNELEdBQUcsQ0FBQ0ssTUFBTUUsTUFBTTtZQUMxQyxJQUFNQyxZQUFZSCxNQUFNSSxjQUFjLElBQUlKLE1BQU1LLGlCQUFpQixHQUFHO1lBQ3BFLElBQUlKLFlBQVlFLFdBQVc7Z0JBQ3pCRixTQUFTRTtZQUNYO1FBQ0Y7SUFDRixHQUFHakI7SUFDSFEsV0FBVztRQUNUUCxJQUFBQTtRQUNBVSxVQUFBQTtRQUNBRCxVQUFBQTtJQUNGO0lBRUFaLE9BQU9zQixJQUFJLENBQUNuQjtJQUNaTCxVQUFVeUIsR0FBRyxDQUFDcEIsSUFBSU87SUFDbEIsT0FBT0E7QUFDVDtBQUVBLFNBQVNjLFFBQ1BDLE9BQWdCLEVBQ2hCUixRQUF5QixFQUN6QmYsT0FBb0M7SUFFcEMsSUFBbUNELGtCQUFBQSxlQUFlQyxVQUExQ0MsS0FBMkJGLGdCQUEzQkUsSUFBSVUsV0FBdUJaLGdCQUF2QlksVUFBVUQsV0FBYVgsZ0JBQWJXO0lBQ3RCQSxTQUFTVyxHQUFHLENBQUNFLFNBQVNSO0lBRXRCSixTQUFTVyxPQUFPLENBQUNDO0lBQ2pCLE9BQU8sU0FBU0M7UUFDZGQsUUFBU2UsQ0FBQUEsU0FBTSxDQUFDRjtRQUNoQlosU0FBU2EsU0FBUyxDQUFDRDtRQUVuQix1REFBdUQ7UUFDdkQsSUFBSWIsU0FBU2dCLElBQUksS0FBSyxHQUFHO1lBQ3ZCZixTQUFTZ0IsVUFBVTtZQUNuQi9CLFNBQVU2QixDQUFBQSxTQUFNLENBQUN4QjtZQUNqQixJQUFNMkIsUUFBUTlCLE9BQU8rQixTQUFTLENBQzVCLFNBQUN0Qjt1QkFBUUEsSUFBSUwsSUFBSSxLQUFLRCxHQUFHQyxJQUFJLElBQUlLLElBQUlKLE1BQU0sS0FBS0YsR0FBR0UsTUFBTTs7WUFFM0QsSUFBSXlCLFFBQVEsQ0FBQyxHQUFHO2dCQUNkOUIsT0FBT2dDLE1BQU0sQ0FBQ0YsT0FBTztZQUN2QjtRQUNGO0lBQ0Y7QUFDRjtBQUVPLFNBQVNuQyxnQkFBbUNzQyxLQUlqQztJQUppQyxJQUNqREMsVUFEaURELE1BQ2pEQyxTQUNBNUIsYUFGaUQyQixNQUVqRDNCLFlBQ0E2QixXQUhpREYsTUFHakRFO0lBRUEsSUFBTUMsYUFBc0JELFlBQVksQ0FBQ3ZDO0lBRXpDLElBQThCeUMsMEJBQUFBLENBQUFBLEdBQUFBLE9BQUFBLFFBQVEsRUFBQyxZQUFoQ0MsVUFBdUJELFNBQWRFLGFBQWNGO0lBQzlCLElBQU1HLGFBQWFDLENBQUFBLEdBQUFBLE9BQUFBLE1BQU0sRUFBVztJQUNwQyxJQUFNQyxhQUFhQyxDQUFBQSxHQUFBQSxPQUFBQSxXQUFXLEVBQUMsU0FBQ2xCO1FBQzlCZSxXQUFXSSxPQUFPLEdBQUduQjtJQUN2QixHQUFHLEVBQUU7SUFFTG9CLENBQUFBLEdBQUFBLE9BQUFBLFNBQVMsRUFBQztRQUNSLElBQUlqRCx5QkFBeUI7WUFDM0IsSUFBSXdDLGNBQWNFLFNBQVM7WUFFM0IsSUFBTWIsVUFBVWUsV0FBV0ksT0FBTztZQUNsQyxJQUFJbkIsV0FBV0EsUUFBUXFCLE9BQU8sRUFBRTtnQkFDOUIsSUFBTXBCLFlBQVlGLFFBQ2hCQyxTQUNBLFNBQUNOOzJCQUFjQSxhQUFhb0IsV0FBV3BCO21CQUN2QztvQkFBRWYsTUFBTThCLFdBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFFBQVNVLE9BQU87b0JBQUV0QyxZQUFBQTtnQkFBVztnQkFHdkMsT0FBT29CO1lBQ1Q7UUFDRixPQUFPO1lBQ0wsSUFBSSxDQUFDWSxTQUFTO2dCQUNaLElBQU1TLGVBQWVDLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBbUIsRUFBQzsyQkFBTVQsV0FBVzs7Z0JBQzFELE9BQU87MkJBQU1VLENBQUFBLEdBQUFBLHFCQUFBQSxrQkFBa0IsRUFBQ0Y7O1lBQ2xDO1FBQ0Y7SUFDQSx1REFBdUQ7SUFDekQsR0FBRztRQUFDWDtRQUFZOUI7UUFBWTRCO1FBQVNJO1FBQVNFLFdBQVdJLE9BQU87S0FBQztJQUVqRSxJQUFNTSxlQUFlUCxDQUFBQSxHQUFBQSxPQUFBQSxXQUFXLEVBQUM7UUFDL0JKLFdBQVc7SUFDYixHQUFHLEVBQUU7SUFFTCxPQUFPO1FBQUNHO1FBQVlKO1FBQVNZO0tBQWE7QUFDNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9jbGllbnQvdXNlLWludGVyc2VjdGlvbi50c3g/NTdlZSJdLCJuYW1lcyI6WyJ1c2VJbnRlcnNlY3Rpb24iLCJoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwib2JzZXJ2ZXJzIiwiTWFwIiwiaWRMaXN0IiwiY3JlYXRlT2JzZXJ2ZXIiLCJvcHRpb25zIiwiaWQiLCJyb290IiwibWFyZ2luIiwicm9vdE1hcmdpbiIsImV4aXN0aW5nIiwiZmluZCIsIm9iaiIsImluc3RhbmNlIiwiZ2V0IiwiZWxlbWVudHMiLCJvYnNlcnZlciIsImVudHJpZXMiLCJmb3JFYWNoIiwiZW50cnkiLCJjYWxsYmFjayIsInRhcmdldCIsImlzVmlzaWJsZSIsImlzSW50ZXJzZWN0aW5nIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJwdXNoIiwic2V0Iiwib2JzZXJ2ZSIsImVsZW1lbnQiLCJ1bm9ic2VydmUiLCJkZWxldGUiLCJzaXplIiwiZGlzY29ubmVjdCIsImluZGV4IiwiZmluZEluZGV4Iiwic3BsaWNlIiwicGFyYW0iLCJyb290UmVmIiwiZGlzYWJsZWQiLCJpc0Rpc2FibGVkIiwidXNlU3RhdGUiLCJ2aXNpYmxlIiwic2V0VmlzaWJsZSIsImVsZW1lbnRSZWYiLCJ1c2VSZWYiLCJzZXRFbGVtZW50IiwidXNlQ2FsbGJhY2siLCJjdXJyZW50IiwidXNlRWZmZWN0IiwidGFnTmFtZSIsImlkbGVDYWxsYmFjayIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJyZXNldFZpc2libGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/amp-context.shared-runtime.js":
/*!****************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/amp-context.shared-runtime.js ***!
  \****************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AmpStateContext\", ({\n    enumerable: true,\n    get: function get() {\n        return AmpStateContext;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\"));\nvar AmpStateContext = _react[\"default\"].createContext({});\nif (true) {\n    AmpStateContext.displayName = \"AmpStateContext\";\n} //# sourceMappingURL=amp-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQUVhQTs7O2VBQUFBOzs7OzBFQUZLO0FBRVgsSUFBTUEsa0JBQXNDQyxNQUFBQSxDQUFBQSxVQUFLLENBQUNDLGFBQWEsQ0FBQyxDQUFDO0FBRXhFLElBQUlDLElBQXlCLEVBQWM7SUFDekNILGdCQUFnQkksV0FBVyxHQUFHO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS50cz85NjQxIl0sIm5hbWVzIjpbIkFtcFN0YXRlQ29udGV4dCIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/amp-mode.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/amp-mode.js ***!
  \**********************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isInAmpMode\", ({\n    enumerable: true,\n    get: function get() {\n        return isInAmpMode;\n    }\n}));\nfunction isInAmpMode(param) {\n    var _ref = param === void 0 ? {} : param, _ref_ampFirst = _ref.ampFirst, ampFirst = _ref_ampFirst === void 0 ? false : _ref_ampFirst, _ref_hybrid = _ref.hybrid, hybrid = _ref_hybrid === void 0 ? false : _ref_hybrid, _ref_hasQuery = _ref.hasQuery, hasQuery = _ref_hasQuery === void 0 ? false : _ref_hasQuery;\n    return ampFirst || hybrid && hasQuery;\n} //# sourceMappingURL=amp-mode.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtbW9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7OytDQUFnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0EsWUFBWUMsS0FBQTtJQUFBLElBQUFBLE9BQUFBLFVBQUEsU0FJeEIsQ0FBQyxJQUp1QkEsdUJBQUFBLEtBQzFCQyxVQUFBQSxzQ0FBVyxxQ0FEZUQsS0FFMUJFLFFBQUFBLGtDQUFTLHFDQUZpQkYsS0FHMUJHLFVBQUFBLHNDQUFXO0lBRVgsT0FBT0YsWUFBYUMsVUFBVUM7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2FtcC1tb2RlLnRzP2NlMDQiXSwibmFtZXMiOlsiaXNJbkFtcE1vZGUiLCJwYXJhbSIsImFtcEZpcnN0IiwiaHlicmlkIiwiaGFzUXVlcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/amp-mode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/escape-regexp.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/escape-regexp.js ***!
  \***************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// regexp is based on https://github.com/sindresorhus/escape-string-regexp\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"escapeStringRegexp\", ({\n    enumerable: true,\n    get: function get() {\n        return escapeStringRegexp;\n    }\n}));\nvar reHasRegExp = /[|\\\\{}()[\\]^$+*?.-]/;\nvar reReplaceRegExp = /[|\\\\{}()[\\]^$+*?.-]/g;\nfunction escapeStringRegexp(str) {\n    // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23\n    if (reHasRegExp.test(str)) {\n        return str.replace(reReplaceRegExp, \"\\\\$&\");\n    }\n    return str;\n} //# sourceMappingURL=escape-regexp.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLmpzIiwibWFwcGluZ3MiOiJBQUFBLDBFQUEwRTs7Ozs7c0RBSTFEQTs7O2VBQUFBOzs7QUFIaEIsSUFBTUMsY0FBYztBQUNwQixJQUFNQyxrQkFBa0I7QUFFakIsU0FBU0YsbUJBQW1CRyxHQUFXO0lBQzVDLCtHQUErRztJQUMvRyxJQUFJRixZQUFZRyxJQUFJLENBQUNELE1BQU07UUFDekIsT0FBT0EsSUFBSUUsT0FBTyxDQUFDSCxpQkFBaUI7SUFDdEM7SUFDQSxPQUFPQztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLnRzP2RjYjEiXSwibmFtZXMiOlsiZXNjYXBlU3RyaW5nUmVnZXhwIiwicmVIYXNSZWdFeHAiLCJyZVJlcGxhY2VSZWdFeHAiLCJzdHIiLCJ0ZXN0IiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/escape-regexp.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/get-img-props.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/get-img-props.js ***!
  \***************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\nvar _object_without_properties = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_without_properties.js\");\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nvar _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_to_consumable_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImgProps\", ({\n    enumerable: true,\n    get: function get() {\n        return getImgProps;\n    }\n}));\nvar _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils/warn-once.js\");\nvar _imageblursvg = __webpack_require__(/*! ./image-blur-svg */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-blur-svg.js\");\nvar _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config.js\");\nvar VALID_LOADING_VALUES = [\n    \"lazy\",\n    \"eager\",\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src[\"default\"] !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\nvar allImgs = new Map();\nvar perfObserver;\nfunction getInt(x) {\n    if (typeof x === \"undefined\") {\n        return x;\n    }\n    if (typeof x === \"number\") {\n        return Number.isFinite(x) ? x : NaN;\n    }\n    if (typeof x === \"string\" && /^[0-9]+$/.test(x)) {\n        return parseInt(x, 10);\n    }\n    return NaN;\n}\nfunction getWidths(param, width, sizes) {\n    var deviceSizes = param.deviceSizes, allSizes = param.allSizes;\n    if (sizes) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        var viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        var percentSizes = [];\n        for(var match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            var _Math;\n            var smallestRatio = (_Math = Math).min.apply(_Math, _to_consumable_array._(percentSizes)) * 0.01;\n            return {\n                widths: allSizes.filter(function(s) {\n                    return s >= deviceSizes[0] * smallestRatio;\n                }),\n                kind: \"w\"\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: \"w\"\n        };\n    }\n    if (typeof width !== \"number\") {\n        return {\n            widths: deviceSizes,\n            kind: \"w\"\n        };\n    }\n    var widths = _to_consumable_array._(new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n    // > blue colors. Showing a 3x resolution image in the app vs a 2x\n    // > resolution image will be visually the same, though the 3x image\n    // > takes significantly more data. Even true 3x resolution screens are\n    // > wasteful as the human eye cannot see that level of detail without\n    // > something like a magnifying glass.\n    // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n    [\n        width,\n        width * 2 /*, width * 3*/ \n    ].map(function(w) {\n        return allSizes.find(function(p) {\n            return p >= w;\n        }) || allSizes[allSizes.length - 1];\n    })));\n    return {\n        widths: widths,\n        kind: \"x\"\n    };\n}\nfunction generateImgAttrs(param) {\n    var config = param.config, src = param.src, unoptimized = param.unoptimized, width = param.width, quality = param.quality, sizes = param.sizes, loader = param.loader;\n    if (unoptimized) {\n        return {\n            src: src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    var _getWidths = getWidths(config, width, sizes), widths = _getWidths.widths, kind = _getWidths.kind;\n    var last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n        srcSet: widths.map(function(w, i) {\n            return loader({\n                config: config,\n                src: src,\n                quality: quality,\n                width: w\n            }) + \" \" + (kind === \"w\" ? w : i + 1) + kind;\n        }).join(\", \"),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config: config,\n            src: src,\n            quality: quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getImgProps(param, _state) {\n    var src = param.src, sizes = param.sizes, _param_unoptimized = param.unoptimized, unoptimized = _param_unoptimized === void 0 ? false : _param_unoptimized, _param_priority = param.priority, priority = _param_priority === void 0 ? false : _param_priority, loading = param.loading, className = param.className, quality = param.quality, width = param.width, height = param.height, _param_fill = param.fill, fill = _param_fill === void 0 ? false : _param_fill, style = param.style, overrideSrc = param.overrideSrc, onLoad = param.onLoad, onLoadingComplete = param.onLoadingComplete, _param_placeholder = param.placeholder, placeholder = _param_placeholder === void 0 ? \"empty\" : _param_placeholder, blurDataURL = param.blurDataURL, fetchPriority = param.fetchPriority, layout = param.layout, objectFit = param.objectFit, objectPosition = param.objectPosition, lazyBoundary = param.lazyBoundary, lazyRoot = param.lazyRoot, rest = _object_without_properties._(param, [\n        \"src\",\n        \"sizes\",\n        \"unoptimized\",\n        \"priority\",\n        \"loading\",\n        \"className\",\n        \"quality\",\n        \"width\",\n        \"height\",\n        \"fill\",\n        \"style\",\n        \"overrideSrc\",\n        \"onLoad\",\n        \"onLoadingComplete\",\n        \"placeholder\",\n        \"blurDataURL\",\n        \"fetchPriority\",\n        \"layout\",\n        \"objectFit\",\n        \"objectPosition\",\n        \"lazyBoundary\",\n        \"lazyRoot\"\n    ]);\n    var imgConf = _state.imgConf, showAltText = _state.showAltText, blurComplete = _state.blurComplete, defaultLoader = _state.defaultLoader;\n    var config;\n    var c = imgConf || _imageconfig.imageConfigDefault;\n    if (\"allSizes\" in c) {\n        config = c;\n    } else {\n        var allSizes = _to_consumable_array._(c.deviceSizes).concat(_to_consumable_array._(c.imageSizes)).sort(function(a, b) {\n            return a - b;\n        });\n        var deviceSizes = c.deviceSizes.sort(function(a, b) {\n            return a - b;\n        });\n        config = _object_spread_props._(_object_spread._({}, c), {\n            allSizes: allSizes,\n            deviceSizes: deviceSizes\n        });\n    }\n    if (typeof defaultLoader === \"undefined\") {\n        throw new Error(\"images.loaderFile detected but the file is missing default export.\\nRead more: https://nextjs.org/docs/messages/invalid-images-config\");\n    }\n    var loader = rest.loader || defaultLoader;\n    // Remove property so it's not spread on <img> element\n    delete rest.loader;\n    delete rest.srcSet;\n    // This special value indicates that the user\n    // didn't define a \"loader\" prop or \"loader\" config.\n    var isDefaultLoader = \"__next_img_default\" in loader;\n    if (isDefaultLoader) {\n        if (config.loader === \"custom\") {\n            throw new Error('Image with src \"' + src + '\" is missing \"loader\" prop.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n        }\n    } else {\n        // The user defined a \"loader\" prop or config.\n        // Since the config object is internal only, we\n        // must not pass it to the user-defined \"loader\".\n        var customImageLoader = loader;\n        loader = function(obj) {\n            var _ = obj.config, opts = _object_without_properties._(obj, [\n                \"config\"\n            ]);\n            return customImageLoader(opts);\n        };\n    }\n    if (layout) {\n        if (layout === \"fill\") {\n            fill = true;\n        }\n        var layoutToStyle = {\n            intrinsic: {\n                maxWidth: \"100%\",\n                height: \"auto\"\n            },\n            responsive: {\n                width: \"100%\",\n                height: \"auto\"\n            }\n        };\n        var layoutToSizes = {\n            responsive: \"100vw\",\n            fill: \"100vw\"\n        };\n        var layoutStyle = layoutToStyle[layout];\n        if (layoutStyle) {\n            style = _object_spread._({}, style, layoutStyle);\n        }\n        var layoutSizes = layoutToSizes[layout];\n        if (layoutSizes && !sizes) {\n            sizes = layoutSizes;\n        }\n    }\n    var staticSrc = \"\";\n    var widthInt = getInt(width);\n    var heightInt = getInt(height);\n    var blurWidth;\n    var blurHeight;\n    if (isStaticImport(src)) {\n        var staticImageData = isStaticRequire(src) ? src[\"default\"] : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \" + JSON.stringify(staticImageData));\n        }\n        if (!staticImageData.height || !staticImageData.width) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \" + JSON.stringify(staticImageData));\n        }\n        blurWidth = staticImageData.blurWidth;\n        blurHeight = staticImageData.blurHeight;\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!fill) {\n            if (!widthInt && !heightInt) {\n                widthInt = staticImageData.width;\n                heightInt = staticImageData.height;\n            } else if (widthInt && !heightInt) {\n                var ratio = widthInt / staticImageData.width;\n                heightInt = Math.round(staticImageData.height * ratio);\n            } else if (!widthInt && heightInt) {\n                var ratio1 = heightInt / staticImageData.height;\n                widthInt = Math.round(staticImageData.width * ratio1);\n            }\n        }\n    }\n    src = typeof src === \"string\" ? src : staticSrc;\n    var isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n    if (!src || src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    if (isDefaultLoader && src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        unoptimized = true;\n    }\n    if (priority) {\n        fetchPriority = \"high\";\n    }\n    var qualityInt = getInt(quality);\n    if (true) {\n        if (config.output === \"export\" && isDefaultLoader && !unoptimized) {\n            throw new Error(\"Image Optimization using the default loader is not compatible with `{ output: 'export' }`.\\n  Possible solutions:\\n    - Remove `{ output: 'export' }` and run \\\"next start\\\" to run server mode including the Image Optimization API.\\n    - Configure `{ images: { unoptimized: true } }` in `next.config.js` to disable the Image Optimization API.\\n  Read more: https://nextjs.org/docs/messages/export-image-api\");\n        }\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            unoptimized = true;\n        } else {\n            if (fill) {\n                if (width) {\n                    throw new Error('Image with src \"' + src + '\" has both \"width\" and \"fill\" properties. Only one should be used.');\n                }\n                if (height) {\n                    throw new Error('Image with src \"' + src + '\" has both \"height\" and \"fill\" properties. Only one should be used.');\n                }\n                if ((style == null ? void 0 : style.position) && style.position !== \"absolute\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.width) && style.width !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.height) && style.height !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.');\n                }\n            } else {\n                if (typeof widthInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"width\" property.');\n                } else if (isNaN(widthInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"width\" property. Expected a numeric value in pixels but received \"' + width + '\".');\n                }\n                if (typeof heightInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"height\" property.');\n                } else if (isNaN(heightInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"height\" property. Expected a numeric value in pixels but received \"' + height + '\".');\n                }\n            }\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"loading\" property. Provided \"' + loading + '\" should be one of ' + VALID_LOADING_VALUES.map(String).join(\",\") + \".\");\n        }\n        if (priority && loading === \"lazy\") {\n            throw new Error('Image with src \"' + src + '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.');\n        }\n        if (placeholder !== \"empty\" && placeholder !== \"blur\" && !placeholder.startsWith(\"data:image/\")) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"placeholder\" property \"' + placeholder + '\".');\n        }\n        if (placeholder !== \"empty\") {\n            if (widthInt && heightInt && widthInt * heightInt < 1600) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is smaller than 40x40. Consider removing the \"placeholder\" property to improve performance.');\n            }\n        }\n        if (placeholder === \"blur\" && !blurDataURL) {\n            var VALID_BLUR_EXT = [\n                \"jpeg\",\n                \"png\",\n                \"webp\",\n                \"avif\"\n            ] // should match next-image-loader\n            ;\n            throw new Error('Image with src \"' + src + '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n        Possible solutions:\\n          - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n          - Change the \"src\" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(\",\") + ' (animated images not supported)\\n          - Remove the \"placeholder\" property, effectively no blur effect\\n        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url');\n        }\n        if (\"ref\" in rest) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using unsupported \"ref\" property. Consider using the \"onLoad\" property instead.');\n        }\n        if (!unoptimized && !isDefaultLoader) {\n            var urlStr = loader({\n                config: config,\n                src: src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            var url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        if (onLoadingComplete) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using deprecated \"onLoadingComplete\" property. Please use the \"onLoad\" property instead.');\n        }\n        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n        try {\n            for(var _iterator = Object.entries({\n                layout: layout,\n                objectFit: objectFit,\n                objectPosition: objectPosition,\n                lazyBoundary: lazyBoundary,\n                lazyRoot: lazyRoot\n            })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var _step_value = _sliced_to_array._(_step.value, 2), legacyKey = _step_value[0], legacyValue = _step_value[1];\n                if (legacyValue) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has legacy prop \"' + legacyKey + '\". Did you forget to run the codemod?' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13\");\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                    _iterator[\"return\"]();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n        if (typeof window !== \"undefined\" && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver(function(entryList) {\n                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n                try {\n                    for(var _iterator = entryList.getEntries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                        var entry = _step.value;\n                        var _entry_element;\n                        // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                        var imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || \"\";\n                        var lcpImage = allImgs.get(imgSrc);\n                        if (lcpImage && !lcpImage.priority && lcpImage.placeholder === \"empty\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n                            // https://web.dev/lcp/#measure-lcp-in-javascript\n                            (0, _warnonce.warnOnce)('Image with src \"' + lcpImage.src + '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.' + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally{\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                            _iterator[\"return\"]();\n                        }\n                    } finally{\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: \"largest-contentful-paint\",\n                    buffered: true\n                });\n            } catch (err) {\n                // Log error but don't crash the app\n                console.error(err);\n            }\n        }\n    }\n    var imgStyle = Object.assign(fill ? {\n        position: \"absolute\",\n        height: \"100%\",\n        width: \"100%\",\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        objectFit: objectFit,\n        objectPosition: objectPosition\n    } : {}, showAltText ? {} : {\n        color: \"transparent\"\n    }, style);\n    var backgroundImage = !blurComplete && placeholder !== \"empty\" ? placeholder === \"blur\" ? 'url(\"data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({\n        widthInt: widthInt,\n        heightInt: heightInt,\n        blurWidth: blurWidth,\n        blurHeight: blurHeight,\n        blurDataURL: blurDataURL || \"\",\n        objectFit: imgStyle.objectFit\n    }) + '\")' : 'url(\"' + placeholder + '\")' // assume `data:image/`\n     : null;\n    var placeholderStyle = backgroundImage ? {\n        backgroundSize: imgStyle.objectFit || \"cover\",\n        backgroundPosition: imgStyle.objectPosition || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage: backgroundImage\n    } : {};\n    if (true) {\n        if (placeholderStyle.backgroundImage && placeholder === \"blur\" && (blurDataURL == null ? void 0 : blurDataURL.startsWith(\"/\"))) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            placeholderStyle.backgroundImage = 'url(\"' + blurDataURL + '\")';\n        }\n    }\n    var imgAttributes = generateImgAttrs({\n        config: config,\n        src: src,\n        unoptimized: unoptimized,\n        width: widthInt,\n        quality: qualityInt,\n        sizes: sizes,\n        loader: loader\n    });\n    if (true) {\n        if (typeof window !== \"undefined\") {\n            var fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src: src,\n                priority: priority,\n                placeholder: placeholder\n            });\n        }\n    }\n    var props = _object_spread_props._(_object_spread._({}, rest), {\n        loading: isLazy ? \"lazy\" : loading,\n        fetchPriority: fetchPriority,\n        width: widthInt,\n        height: heightInt,\n        decoding: \"async\",\n        className: className,\n        style: _object_spread._({}, imgStyle, placeholderStyle),\n        sizes: imgAttributes.sizes,\n        srcSet: imgAttributes.srcSet,\n        src: overrideSrc || imgAttributes.src\n    });\n    var meta = {\n        unoptimized: unoptimized,\n        priority: priority,\n        placeholder: placeholder,\n        fill: fill\n    };\n    return {\n        props: props,\n        meta: meta\n    };\n} //# sourceMappingURL=get-img-props.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OzsrQ0EyT2dCQTs7O2VBQUFBOzs7b0NBM09TO3dDQUNPO3VDQUNHO0FBNkVuQyxJQUFNQyx1QkFBdUI7SUFBQztJQUFRO0lBQVNDO0NBQVU7QUFrQnpELFNBQVNDLGdCQUNQQyxHQUFvQztJQUVwQyxPQUFPQSxHQUF1QkMsQ0FBQUEsVUFBTyxLQUFLSDtBQUM1QztBQUVBLFNBQVNJLGtCQUNQRixHQUFvQztJQUVwQyxPQUFPQSxJQUF5QkEsR0FBRyxLQUFLRjtBQUMxQztBQUVBLFNBQVNLLGVBQWVILEdBQTBCO0lBQ2hELE9BQ0UsT0FBT0EsUUFBUSxZQUNkRCxDQUFBQSxnQkFBZ0JDLFFBQ2ZFLGtCQUFrQkYsSUFBQUE7QUFFeEI7QUFFQSxJQUFNSSxVQUFVLElBQUlDO0FBSXBCLElBQUlDO0FBRUosU0FBU0MsT0FBT0MsQ0FBVTtJQUN4QixJQUFJLE9BQU9BLE1BQU0sYUFBYTtRQUM1QixPQUFPQTtJQUNUO0lBQ0EsSUFBSSxPQUFPQSxNQUFNLFVBQVU7UUFDekIsT0FBT0MsT0FBT0MsUUFBUSxDQUFDRixLQUFLQSxJQUFJRztJQUNsQztJQUNBLElBQUksT0FBT0gsTUFBTSxZQUFZLFdBQVdJLElBQUksQ0FBQ0osSUFBSTtRQUMvQyxPQUFPSyxTQUFTTCxHQUFHO0lBQ3JCO0lBQ0EsT0FBT0c7QUFDVDtBQUVBLFNBQVNHLFVBQ1BDLEtBQXNDLEVBQ3RDQyxLQUF5QixFQUN6QkMsS0FBeUI7SUFGekIsSUFBRUMsY0FBRkgsTUFBRUcsYUFBYUMsV0FBZkosTUFBZUk7SUFJZixJQUFJRixPQUFPO1FBQ1QseURBQXlEO1FBQ3pELElBQU1H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QSxJQUFJOEQsSUFBeUIsRUFBYztRQUN6QyxJQUFJLE9BQU9rQixXQUFXLGFBQWE7WUFDakMsSUFBSTRCO1lBQ0osSUFBSTtnQkFDRkEsVUFBVSxJQUFJcEMsSUFBSW1DLGNBQWNySixHQUFHO1lBQ3JDLEVBQUUsT0FBT3VKLEdBQUc7Z0JBQ1ZELFVBQVUsSUFBSXBDLElBQUltQyxjQUFjckosR0FBRyxFQUFFMEgsT0FBTzhCLFFBQVEsQ0FBQ0MsSUFBSTtZQUMzRDtZQUNBckosUUFBUXNKLEdBQUcsQ0FBQ0osUUFBUUcsSUFBSSxFQUFFO2dCQUFFekosS0FBQUE7Z0JBQUtnRCxVQUFBQTtnQkFBVVMsYUFBQUE7WUFBWTtRQUN6RDtJQUNGO0lBRUEsSUFBTWtHLFFBQWtCLDRDQUNuQjFGO1FBQ0hoQixTQUFTa0QsU0FBUyxTQUFTbEQ7UUFDM0JVLGVBQUFBO1FBQ0EzQyxPQUFPMEU7UUFDUHZDLFFBQVF3QztRQUNSaUUsVUFBVTtRQUNWMUcsV0FBQUE7UUFDQUcsT0FBTyxxQkFBS21GLFVBQWFTO1FBQ3pCaEksT0FBT29JLGNBQWNwSSxLQUFLO1FBQzFCMEIsUUFBUTBHLGNBQWMxRyxNQUFNO1FBQzVCM0MsS0FBS3NELGVBQWUrRixjQUFjckosR0FBRzs7SUFFdkMsSUFBTTZKLE9BQU87UUFBRXJILGFBQUFBO1FBQWFRLFVBQUFBO1FBQVVTLGFBQUFBO1FBQWFMLE1BQUFBO0lBQUs7SUFDeEQsT0FBTztRQUFFdUcsT0FBQUE7UUFBT0UsTUFBQUE7SUFBSztBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvZ2V0LWltZy1wcm9wcy50cz9lYzkxIl0sIm5hbWVzIjpbImdldEltZ1Byb3BzIiwiVkFMSURfTE9BRElOR19WQUxVRVMiLCJ1bmRlZmluZWQiLCJpc1N0YXRpY1JlcXVpcmUiLCJzcmMiLCJkZWZhdWx0IiwiaXNTdGF0aWNJbWFnZURhdGEiLCJpc1N0YXRpY0ltcG9ydCIsImFsbEltZ3MiLCJNYXAiLCJwZXJmT2JzZXJ2ZXIiLCJnZXRJbnQiLCJ4IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJOYU4iLCJ0ZXN0IiwicGFyc2VJbnQiLCJnZXRXaWR0aHMiLCJwYXJhbSIsIndpZHRoIiwic2l6ZXMiLCJkZXZpY2VTaXplcyIsImFsbFNpemVzIiwidmlld3BvcnRXaWR0aFJlIiwicGVyY2VudFNpemVzIiwibWF0Y2giLCJleGVjIiwicHVzaCIsImxlbmd0aCIsIk1hdGgiLCJzbWFsbGVzdFJhdGlvIiwibWluIiwid2lkdGhzIiwiZmlsdGVyIiwicyIsImtpbmQiLCJTZXQiLCJtYXAiLCJ3IiwiZmluZCIsInAiLCJnZW5lcmF0ZUltZ0F0dHJzIiwiY29uZmlnIiwidW5vcHRpbWl6ZWQiLCJxdWFsaXR5IiwibG9hZGVyIiwic3JjU2V0IiwibGFzdCIsImkiLCJqb2luIiwiX3N0YXRlIiwicHJpb3JpdHkiLCJsb2FkaW5nIiwiY2xhc3NOYW1lIiwiaGVpZ2h0IiwiZmlsbCIsInN0eWxlIiwib3ZlcnJpZGVTcmMiLCJvbkxvYWQiLCJvbkxvYWRpbmdDb21wbGV0ZSIsInBsYWNlaG9sZGVyIiwiYmx1ckRhdGFVUkwiLCJmZXRjaFByaW9yaXR5IiwibGF5b3V0Iiwib2JqZWN0Rml0Iiwib2JqZWN0UG9zaXRpb24iLCJsYXp5Qm91bmRhcnkiLCJsYXp5Um9vdCIsInJlc3QiLCJpbWdDb25mIiwic2hvd0FsdFRleHQiLCJibHVyQ29tcGxldGUiLCJkZWZhdWx0TG9hZGVyIiwiYyIsImltYWdlQ29uZmlnRGVmYXVsdCIsImltYWdlU2l6ZXMiLCJzb3J0IiwiYSIsImIiLCJFcnJvciIsImlzRGVmYXVsdExvYWRlciIsImN1c3RvbUltYWdlTG9hZGVyIiwib2JqIiwiXyIsIm9wdHMiLCJsYXlvdXRUb1N0eWxlIiwiaW50cmluc2ljIiwibWF4V2lkdGgiLCJyZXNwb25zaXZlIiwibGF5b3V0VG9TaXplcyIsImxheW91dFN0eWxlIiwibGF5b3V0U2l6ZXMiLCJzdGF0aWNTcmMiLCJ3aWR0aEludCIsImhlaWdodEludCIsImJsdXJXaWR0aCIsImJsdXJIZWlnaHQiLCJzdGF0aWNJbWFnZURhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwicmF0aW8iLCJyb3VuZCIsImlzTGF6eSIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsImRhbmdlcm91c2x5QWxsb3dTVkciLCJxdWFsaXR5SW50IiwicHJvY2VzcyIsIm91dHB1dCIsInBvc2l0aW9uIiwiaXNOYU4iLCJpbmNsdWRlcyIsIlN0cmluZyIsIndhcm5PbmNlIiwiVkFMSURfQkxVUl9FWFQiLCJ1cmxTdHIiLCJ1cmwiLCJVUkwiLCJlcnIiLCJwYXRobmFtZSIsInNlYXJjaCIsIk9iamVjdCIsImVudHJpZXMiLCJsZWdhY3lLZXkiLCJsZWdhY3lWYWx1ZSIsIndpbmRvdyIsIlBlcmZvcm1hbmNlT2JzZXJ2ZXIiLCJlbnRyeUxpc3QiLCJnZXRFbnRyaWVzIiwiZW50cnkiLCJpbWdTcmMiLCJlbGVtZW50IiwibGNwSW1hZ2UiLCJnZXQiLCJvYnNlcnZlIiwidHlwZSIsImJ1ZmZlcmVkIiwiY29uc29sZSIsImVycm9yIiwiaW1nU3R5bGUiLCJhc3NpZ24iLCJsZWZ0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJjb2xvciIsImJhY2tncm91bmRJbWFnZSIsImdldEltYWdlQmx1clN2ZyIsInBsYWNlaG9sZGVyU3R5bGUiLCJiYWNrZ3JvdW5kU2l6ZSIsImJhY2tncm91bmRQb3NpdGlvbiIsImJhY2tncm91bmRSZXBlYXQiLCJpbWdBdHRyaWJ1dGVzIiwiZnVsbFVybCIsImUiLCJsb2NhdGlvbiIsImhyZWYiLCJzZXQiLCJwcm9wcyIsImRlY29kaW5nIiwibWV0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/get-img-props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/head.js":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/head.js ***!
  \******************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    \"default\": function _default1() {\n        return _default;\n    },\n    defaultHead: function defaultHead1() {\n        return defaultHead;\n    }\n});\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-runtime.js\");\nvar _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\"));\nvar _sideeffect = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./side-effect */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/side-effect.js\"));\nvar _ampcontextsharedruntime = __webpack_require__(/*! ./amp-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\");\nvar _headmanagercontextsharedruntime = __webpack_require__(/*! ./head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nvar _ampmode = __webpack_require__(/*! ./amp-mode */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/amp-mode.js\");\nvar _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils/warn-once.js\");\nfunction defaultHead(inAmpMode) {\n    if (inAmpMode === void 0) inAmpMode = false;\n    var head = [\n        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            charSet: \"utf-8\"\n        })\n    ];\n    if (!inAmpMode) {\n        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            name: \"viewport\",\n            content: \"width=device-width\"\n        }));\n    }\n    return head;\n}\nfunction onlyReactElement(list, child) {\n    // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n    if (typeof child === \"string\" || typeof child === \"number\") {\n        return list;\n    }\n    // Adds support for React.Fragment\n    if (child.type === _react[\"default\"].Fragment) {\n        return list.concat(_react[\"default\"].Children.toArray(child.props.children).reduce(function(fragmentList, fragmentChild) {\n            if (typeof fragmentChild === \"string\" || typeof fragmentChild === \"number\") {\n                return fragmentList;\n            }\n            return fragmentList.concat(fragmentChild);\n        }, []));\n    }\n    return list.concat(child);\n}\nvar METATYPES = [\n    \"name\",\n    \"httpEquiv\",\n    \"charSet\",\n    \"itemProp\"\n];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/ function unique() {\n    var keys = new Set();\n    var tags = new Set();\n    var metaTypes = new Set();\n    var metaCategories = {};\n    return function(h) {\n        var isUnique = true;\n        var hasKey = false;\n        if (h.key && typeof h.key !== \"number\" && h.key.indexOf(\"$\") > 0) {\n            hasKey = true;\n            var key = h.key.slice(h.key.indexOf(\"$\") + 1);\n            if (keys.has(key)) {\n                isUnique = false;\n            } else {\n                keys.add(key);\n            }\n        }\n        // eslint-disable-next-line default-case\n        switch(h.type){\n            case \"title\":\n            case \"base\":\n                if (tags.has(h.type)) {\n                    isUnique = false;\n                } else {\n                    tags.add(h.type);\n                }\n                break;\n            case \"meta\":\n                for(var i = 0, len = METATYPES.length; i < len; i++){\n                    var metatype = METATYPES[i];\n                    if (!h.props.hasOwnProperty(metatype)) continue;\n                    if (metatype === \"charSet\") {\n                        if (metaTypes.has(metatype)) {\n                            isUnique = false;\n                        } else {\n                            metaTypes.add(metatype);\n                        }\n                    } else {\n                        var category = h.props[metatype];\n                        var categories = metaCategories[metatype] || new Set();\n                        if ((metatype !== \"name\" || !hasKey) && categories.has(category)) {\n                            isUnique = false;\n                        } else {\n                            categories.add(category);\n                            metaCategories[metatype] = categories;\n                        }\n                    }\n                }\n                break;\n        }\n        return isUnique;\n    };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */ function reduceComponents(headChildrenElements, props) {\n    var inAmpMode = props.inAmpMode;\n    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map(function(c, i) {\n        var key = c.key || i;\n        if (false) { var newProps; }\n        if (true) {\n            // omit JSON-LD structured data snippets from the warning\n            if (c.type === \"script\" && c.props[\"type\"] !== \"application/ld+json\") {\n                var srcMessage = c.props[\"src\"] ? '<script> tag with src=\"' + c.props[\"src\"] + '\"' : \"inline <script>\";\n                (0, _warnonce.warnOnce)(\"Do not add <script> tags using next/head (see \" + srcMessage + \"). Use next/script instead. \\nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component\");\n            } else if (c.type === \"link\" && c.props[\"rel\"] === \"stylesheet\") {\n                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel=\"stylesheet\"> tag with href=\"' + c.props[\"href\"] + '\"). Use Document instead. \\nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');\n            }\n        }\n        return /*#__PURE__*/ _react[\"default\"].cloneElement(c, {\n            key: key\n        });\n    });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */ function Head(param) {\n    var children = param.children;\n    var ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);\n    var headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect[\"default\"], {\n        reduceComponentsToState: reduceComponents,\n        headManager: headManager,\n        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),\n        children: children\n    });\n}\n_c = Head;\nvar _default = Head;\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=head.js.map\nvar _c;\n$RefreshReg$(_c, \"Head\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9oZWFkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztRQXFNQUEsU0FBbUI7OztJQXhMSEM7aUJBQUFBOzs7Ozs7Ozt5REFUZ0JDLENBQUEsQ0FBQUMsbUJBQUFBLENBQUE7O3VDQUVKQSxtQkFBQUEsQ0FBQTs7QUFPckIsSUFBQUMsWUFBU0gsbUJBQUFBLENBQVlJLDRMQUFBQTtTQUFBQSxZQUFBQSxTQUFBQTtJQUMxQixJQUFBQSxjQUFhLFFBQUFBLFlBQUE7O21CQUFPQyxHQUFRLElBQUFDLFlBQUFDLEdBQUE7O1FBQVc7S0FDdkM7UUFDRUMsQ0FBQUEsV0FBUzthQUFPQyxJQUFBQSxDQUFLLGtCQUFBSCxZQUFBQyxHQUFBO1lBQVdHLE1BQUFBOztRQUNsQztJQUNBO0lBQ0YsT0FBQUY7QUFFQTtTQUlFRyxpQkFBQUMsSUFBQSxFQUFBQyxLQUFBO0lBQ0EsOEZBQTREO1FBQzFELE9BQU9ELFVBQUFBLFlBQUFBLE9BQUFBLFVBQUFBLFVBQUFBO1FBQ1QsT0FBQUE7SUFDQTtJQUNBLGtDQUF5QkU7UUFDdkJELE1BQUFFLElBQU9ILEtBQUtJLE1BQ1ZDLENBQUFBLFVBQUEsQ0FBQUgsUUFBQTtRQUNBSSxPQUFBQSxLQUFBQSxNQUFNQyxDQUVKQyxNQUNFQyxDQUFBQSxVQUFBQSxDQUNBQyxRQUFBQSxDQUFBQSxPQUFBQSxDQUFBQSxNQUFBQSxLQUFBQSxDQUFBQSxRQUFBQSxFQUFBQSxNQUFBQSx3QkFHU0E7Z0JBR1AsT0FBT0Qsa0JBQUFBLFlBQUFBLE9BQUFBLGtCQUFBQSxVQUFBQTtnQkFDVCxPQUFBQTtZQUNBO1lBRUYsT0FBRUEsYUFBQUwsTUFBQSxDQUFBTTtRQUdSO0lBQ0E7SUFDRixPQUFB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SUFDWixlQUFpQkUsTUFBWEQ7SUFDTixJQUFNRSxXQUFBQSxDQUFBQSxHQUFjRCxPQUFBQSxVQUFBQSxFQUFBQSx5QkFBV0UsZUFBQUE7SUFDL0IsSUFBQUQsY0FBQSxDQUNFLEdBQUF6QyxPQUFBd0MsVUFBQSxFQUFDRyxpQ0FBTUQsa0JBQUE7V0FDTEUsV0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsWUFBeUJDLEdBQUFBLEVBQUFBLFdBQUFBLENBQUFBLFVBQUFBLEVBQUFBO1FBQ3pCSix5QkFBYUE7UUFDYnpELGFBQVc4RDttQkFFVlQsQ0FBQUEsR0FBQUEsU0FBQUEsV0FBQUEsRUFBQUE7O0lBR1A7O0tBWmdCQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvaGVhZC50c3g/MzY3MCJdLCJuYW1lcyI6WyJleHBvcnRzIiwiZGVmYXVsdEhlYWQiLCJfIiwicmVxdWlyZSIsIl93YXJub25jZSIsImluQW1wTW9kZSIsImNoYXJTZXQiLCJfanN4cnVudGltZSIsImpzeCIsImhlYWQiLCJuYW1lIiwiY29udGVudCIsIm9ubHlSZWFjdEVsZW1lbnQiLCJsaXN0IiwiY2hpbGQiLCJGcmFnbWVudCIsInR5cGUiLCJjb25jYXQiLCJkZWZhdWx0IiwiUmVhY3QiLCJDaGlsZHJlbiIsIl9yZWFjdCIsImZyYWdtZW50TGlzdCIsImZyYWdtZW50Q2hpbGQiLCJNRVRBVFlQRVMiLCJrZXlzIiwidGFncyIsIlNldCIsIm1ldGFUeXBlcyIsIm1ldGFDYXRlZ29yaWVzIiwiaCIsImlzVW5pcXVlIiwiaGFzS2V5Iiwia2V5IiwiaW5kZXhPZiIsImFkZCIsImkiLCJtZXRhdHlwZSIsImxlbiIsImhhc093blByb3BlcnR5IiwiY2F0ZWdvcmllcyIsImhhcyIsImNhdGVnb3J5IiwicHJvcHMiLCJoZWFkQ2hpbGRyZW5FbGVtZW50cyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImMiLCJfX05FWFRfT1BUSU1JWkVfRk9OVFMiLCJzb21lIiwidXJsIiwibmV3UHJvcHMiLCJzdGFydHNXaXRoIiwidW5kZWZpbmVkIiwiY2xvbmVFbGVtZW50Iiwic3JjTWVzc2FnZSIsIndhcm5PbmNlIiwiY2hpbGRyZW4iLCJwYXJhbSIsImFtcFN0YXRlIiwidXNlQ29udGV4dCIsImhlYWRNYW5hZ2VyIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiRWZmZWN0IiwicmVkdWNlQ29tcG9uZW50c1RvU3RhdGUiLCJyZWR1Y2VDb21wb25lbnRzIiwiaXNJbkFtcE1vZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/head.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-blur-svg.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-blur-svg.js ***!
  \****************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * A shared function, used on both client and server, to generate a SVG blur placeholder.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImageBlurSvg\", ({\n    enumerable: true,\n    get: function get() {\n        return getImageBlurSvg;\n    }\n}));\nfunction getImageBlurSvg(param) {\n    var widthInt = param.widthInt, heightInt = param.heightInt, blurWidth = param.blurWidth, blurHeight = param.blurHeight, blurDataURL = param.blurDataURL, objectFit = param.objectFit;\n    var std = 20;\n    var svgWidth = blurWidth ? blurWidth * 40 : widthInt;\n    var svgHeight = blurHeight ? blurHeight * 40 : heightInt;\n    var viewBox = svgWidth && svgHeight ? \"viewBox='0 0 \" + svgWidth + \" \" + svgHeight + \"'\" : \"\";\n    var preserveAspectRatio = viewBox ? \"none\" : objectFit === \"contain\" ? \"xMidYMid\" : objectFit === \"cover\" ? \"xMidYMid slice\" : \"none\";\n    return \"%3Csvg xmlns='http://www.w3.org/2000/svg' \" + viewBox + \"%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='\" + preserveAspectRatio + \"' style='filter: url(%23b);' href='\" + blurDataURL + \"'/%3E%3C/svg%3E\";\n} //# sourceMappingURL=image-blur-svg.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQzs7OzttREFDZUE7OztlQUFBQTs7O0FBQVQsU0FBU0EsZ0JBQWdCQyxLQWMvQjtJQWQrQixJQUM5QkMsV0FEOEJELE1BQzlCQyxVQUNBQyxZQUY4QkYsTUFFOUJFLFdBQ0FDLFlBSDhCSCxNQUc5QkcsV0FDQUMsYUFKOEJKLE1BSTlCSSxZQUNBQyxjQUw4QkwsTUFLOUJLLGFBQ0FDLFlBTjhCTixNQU05Qk07SUFTQSxJQUFNQyxNQUFNO0lBQ1osSUFBTUMsV0FBV0wsWUFBWUEsWUFBWSxLQUFLRjtJQUM5QyxJQUFNUSxZQUFZTCxhQUFhQSxhQUFhLEtBQUtGO0lBRWpELElBQU1RLFVBQ0pGLFlBQVlDLFlBQVksa0JBQWdCRCxXQUFTLE1BQUdDLFlBQVUsTUFBSztJQUNyRSxJQUFNRSxzQkFBc0JELFVBQ3hCLFNBQ0FKLGNBQWMsWUFDZCxhQUNBQSxjQUFjLFVBQ2QsbUJBQ0E7SUFFSixPQUFPLCtDQUE2Q0ksVUFBUSw4RkFBMkZILE1BQUksb1FBQWlRQSxNQUFJLGdHQUE2Rkksc0JBQW9CLHdDQUFxQ04sY0FBWTtBQUNwa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2ltYWdlLWJsdXItc3ZnLnRzP2M3OWMiXSwibmFtZXMiOlsiZ2V0SW1hZ2VCbHVyU3ZnIiwicGFyYW0iLCJ3aWR0aEludCIsImhlaWdodEludCIsImJsdXJXaWR0aCIsImJsdXJIZWlnaHQiLCJibHVyRGF0YVVSTCIsIm9iamVjdEZpdCIsInN0ZCIsInN2Z1dpZHRoIiwic3ZnSGVpZ2h0Iiwidmlld0JveCIsInByZXNlcnZlQXNwZWN0UmF0aW8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-blur-svg.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js":
/*!*************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js ***!
  \*************************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ImageConfigContext\", ({\n    enumerable: true,\n    get: function get() {\n        return ImageConfigContext;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\"));\nvar _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config.js\");\nvar ImageConfigContext = _react[\"default\"].createContext(_imageconfig.imageConfigDefault);\nif (true) {\n    ImageConfigContext.displayName = \"ImageConfigContext\";\n} //# sourceMappingURL=image-config-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O3NEQUlhQTs7O2VBQUFBOzs7OzBFQUpLO3VDQUVpQjtBQUU1QixJQUFNQSxxQkFDWEMsTUFBQUEsQ0FBQUEsVUFBSyxDQUFDQyxhQUFhLENBQXNCQyxhQUFBQSxrQkFBa0I7QUFFN0QsSUFBSUMsSUFBeUIsRUFBYztJQUN6Q0osbUJBQW1CSyxXQUFXLEdBQUc7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0LnNoYXJlZC1ydW50aW1lLnRzPzNkNzUiXSwibmFtZXMiOlsiSW1hZ2VDb25maWdDb250ZXh0IiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwiaW1hZ2VDb25maWdEZWZhdWx0IiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config.js ***!
  \**************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    VALID_LOADERS: function VALID_LOADERS1() {\n        return VALID_LOADERS;\n    },\n    imageConfigDefault: function imageConfigDefault1() {\n        return imageConfigDefault;\n    }\n});\nvar VALID_LOADERS = [\n    \"default\",\n    \"imgix\",\n    \"cloudinary\",\n    \"akamai\",\n    \"custom\"\n];\nvar imageConfigDefault = {\n    deviceSizes: [\n        640,\n        750,\n        828,\n        1080,\n        1200,\n        1920,\n        2048,\n        3840\n    ],\n    imageSizes: [\n        16,\n        32,\n        48,\n        64,\n        96,\n        128,\n        256,\n        384\n    ],\n    path: \"/_next/image\",\n    loader: \"default\",\n    loaderFile: \"\",\n    domains: [],\n    disableStaticImages: false,\n    minimumCacheTTL: 60,\n    formats: [\n        \"image/webp\"\n    ],\n    dangerouslyAllowSVG: false,\n    contentSecurityPolicy: \"script-src 'none'; frame-src 'none'; sandbox;\",\n    contentDispositionType: \"inline\",\n    remotePatterns: [],\n    unoptimized: false\n}; //# sourceMappingURL=image-config.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBQWFBLGVBQWEsU0FBYkE7ZUFBQUE7O0lBc0dBQyxvQkFBa0IsU0FBbEJBO2VBQUFBOzs7QUF0R04sSUFBTUQsZ0JBQWdCO0lBQzNCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQWdHTSxJQUFNQyxxQkFBMEM7SUFDckRDLGFBQWE7UUFBQztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO0tBQUs7SUFDMURDLFlBQVk7UUFBQztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSztRQUFLO0tBQUk7SUFDL0NDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxZQUFZO0lBQ1pDLFNBQVMsRUFBRTtJQUNYQyxxQkFBcUI7SUFDckJDLGlCQUFpQjtJQUNqQkMsU0FBUztRQUFDO0tBQWE7SUFDdkJDLHFCQUFxQjtJQUNyQkMsdUJBQXdCO0lBQ3hCQyx3QkFBd0I7SUFDeEJDLGdCQUFnQixFQUFFO0lBQ2xCQyxhQUFhO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy50cz8xMzRhIl0sIm5hbWVzIjpbIlZBTElEX0xPQURFUlMiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJkZXZpY2VTaXplcyIsImltYWdlU2l6ZXMiLCJwYXRoIiwibG9hZGVyIiwibG9hZGVyRmlsZSIsImRvbWFpbnMiLCJkaXNhYmxlU3RhdGljSW1hZ2VzIiwibWluaW11bUNhY2hlVFRMIiwiZm9ybWF0cyIsImRhbmdlcm91c2x5QWxsb3dTVkciLCJjb250ZW50U2VjdXJpdHlQb2xpY3kiLCJjb250ZW50RGlzcG9zaXRpb25UeXBlIiwicmVtb3RlUGF0dGVybnMiLCJ1bm9wdGltaXplZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-config.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-external.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-external.js ***!
  \****************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    \"default\": function _default1() {\n        return _default;\n    },\n    getImageProps: function getImageProps1() {\n        return getImageProps;\n    }\n});\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _getimgprops = __webpack_require__(/*! ./get-img-props */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/get-img-props.js\");\nvar _imagecomponent = __webpack_require__(/*! ../../client/image-component */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/image-component.js\");\nvar _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-loader.js\"));\nfunction getImageProps(imgProps) {\n    var props = (0, _getimgprops.getImgProps)(imgProps, {\n        defaultLoader: _imageloader[\"default\"],\n        // This is replaced by webpack define plugin\n        imgConf: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[{\"protocol\":\"https\",\"hostname\":\"upload.wikimedia.org\",\"pathname\":\"/wikipedia/**\"}]}\n    }).props;\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        // Normally we don't care about undefined props because we pass to JSX,\n        // but this exported function could be used by the end user for anything\n        // so we delete undefined props to clean it up a little.\n        for(var _iterator = Object.entries(props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n            var _step_value = _sliced_to_array._(_step.value, 2), key = _step_value[0], value = _step_value[1];\n            if (value === undefined) {\n                delete props[key];\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                _iterator[\"return\"]();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    return {\n        props: props\n    };\n}\nvar _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0lBaUNBQSxXQUFvQixTQUFwQkE7ZUFBQUM7O0lBakJnQkMsZUFBYSxTQUFiQTtlQUFBQTs7Ozt1Q0FiWTswQ0FDTjtnRkFHSTtBQVNuQixTQUFTQSxjQUFjQyxRQUFvQjtJQUNoRCxJQUFNLFFBQVlFLENBQUFBLEdBQUFBLGFBQUFBLFdBQVcsRUFBQ0YsVUFBVTtRQUN0Q0csZUFBQUEsWUFBQUEsQ0FBQUEsVUFBYTtRQUNiLDRDQUE0QztRQUM1Q0MsU0FBU0MsMlNBQTZCO0lBQ3hDLEdBSlFKO1FBUUg7O1FBSEwsdUVBQXVFO1FBQ3ZFLHdFQUF3RTtRQUN4RSx3REFBd0Q7UUFDeEQsUUFBSyxZQUFzQk8sT0FBT0MsT0FBTyxDQUFDUiwyQkFBckMsd0dBQTZDO1lBQTdDLHNEQUFPUyxzQkFBS0M7WUFDZixJQUFJQSxVQUFVQyxXQUFXO2dCQUN2QixPQUFPWCxLQUFLLENBQUNTLElBQTBCO1lBQ3pDO1FBQ0Y7O1FBSks7UUFBQTs7O2lCQUFBO2dCQUFBOzs7Z0JBQUE7c0JBQUE7Ozs7SUFLTCxPQUFPO1FBQUVULE9BQUFBO0lBQU07QUFDakI7SUFFQUgsV0FBZWUsZ0JBQUFBLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2ltYWdlLWV4dGVybmFsLnRzeD8zODI2Il0sIm5hbWVzIjpbImRlZmF1bHQiLCJfZGVmYXVsdCIsImdldEltYWdlUHJvcHMiLCJpbWdQcm9wcyIsInByb3BzIiwiZ2V0SW1nUHJvcHMiLCJkZWZhdWx0TG9hZGVyIiwiaW1nQ29uZiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSU1BR0VfT1BUUyIsIk9iamVjdCIsImVudHJpZXMiLCJrZXkiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsIkltYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-external.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-loader.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-loader.js ***!
  \**************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function get() {\n        return _default;\n    }\n}));\nfunction defaultLoader(param) {\n    var config = param.config, src = param.src, width = param.width, quality = param.quality;\n    if (true) {\n        var missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push(\"src\");\n        if (!width) missingValues.push(\"width\");\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \" + missingValues.join(\", \") + \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \" + JSON.stringify({\n                src: src,\n                width: width,\n                quality: quality\n            }));\n        }\n        if (src.startsWith(\"//\")) {\n            throw new Error('Failed to parse src \"' + src + '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)');\n        }\n        if (!src.startsWith(\"/\") && (config.domains || config.remotePatterns)) {\n            var parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"' + src + '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)');\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                var hasMatch = (__webpack_require__(/*! ./match-remote-pattern */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/match-remote-pattern.js\").hasMatch);\n                if (!hasMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw new Error(\"Invalid src prop (\" + src + ') on `next/image`, hostname \"' + parsedSrc.hostname + '\" is not configured under images in your `next.config.js`\\n' + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n                }\n            }\n        }\n    }\n    return config.path + \"?url=\" + encodeURIComponent(src) + \"&w=\" + width + \"&q=\" + (quality || 75) + ( false ? 0 : \"\");\n}\n// We use this to determine if the import is the default loader\n// or a custom loader defined by the user in next.config.js\ndefaultLoader.__next_img_default = true;\nvar _default = defaultLoader; //# sourceMappingURL=image-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7OzsyQ0F3RUE7OztlQUFBQTs7O0FBdEVBLFNBQVNDLGNBQWNDLEtBS007SUFMTixJQUNyQkMsU0FEcUJELE1BQ3JCQyxRQUNBQyxNQUZxQkYsTUFFckJFLEtBQ0FDLFFBSHFCSCxNQUdyQkcsT0FDQUMsVUFKcUJKLE1BSXJCSTtJQUVBLElBQUlDLElBQXlCLEVBQWM7UUFDekMsSUFBTUMsZ0JBQWdCLEVBQUU7UUFFeEIseURBQXlEO1FBQ3pELElBQUksQ0FBQ0osS0FBS0ksY0FBY0MsSUFBSSxDQUFDO1FBQzdCLElBQUksQ0FBQ0osT0FBT0csY0FBY0MsSUFBSSxDQUFDO1FBRS9CLElBQUlELGNBQWNFLE1BQU0sR0FBRyxHQUFHO1lBQzVCLE1BQU0sSUFBSUMsTUFDUixzQ0FBb0NILGNBQWNJLElBQUksQ0FDcEQsUUFDQSxnR0FBK0ZDLEtBQUtDLFNBQVMsQ0FDN0c7Z0JBQUVWLEtBQUFBO2dCQUFLQyxPQUFBQTtnQkFBT0MsU0FBQUE7WUFBUTtRQUc1QjtRQUVBLElBQUlGLElBQUlXLFVBQVUsQ0FBQyxPQUFPO1lBQ3hCLE1BQU0sSUFBSUosTUFDUiwwQkFBd0JQLE1BQUk7UUFFaEM7UUFFQSxJQUFJLENBQUNBLElBQUlXLFVBQVUsQ0FBQyxRQUFTWixDQUFBQSxPQUFPYSxPQUFPLElBQUliLE9BQU9jLGNBQWMsR0FBRztZQUNyRSxJQUFJQztZQUNKLElBQUk7Z0JBQ0ZBLFlBQVksSUFBSUMsSUFBSWY7WUFDdEIsRUFBRSxPQUFPZ0IsS0FBSztnQkFDWkMsUUFBUUMsS0FBSyxDQUFDRjtnQkFDZCxNQUFNLElBQUlULE1BQ1IsMEJBQXdCUCxNQUFJO1lBRWhDO1lBRUEsSUFDRUcsSUFFNkIsRUFDN0I7Z0JBQ0EsdUVBQXVFO2dCQUN2RSxJQUFNLFdBQWVtQixzT0FBYkQ7Z0JBQ1IsSUFBSSxDQUFDQSxTQUFTdEIsT0FBT2EsT0FBTyxFQUFFYixPQUFPYyxjQUFjLEVBQUVDLFlBQVk7b0JBQy9ELE1BQU0sSUFBSVAsTUFDUix1QkFBcUJQLE1BQUksa0NBQWlDYyxVQUFVUyxRQUFRLEdBQUMsZ0VBQzFFO2dCQUVQO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsT0FBT3hCLE9BQVV5QixJQUFJLEdBQUMsVUFBT0MsbUJBQW1CekIsT0FBSyxRQUFLQyxRQUFNLFFBQzlEQyxDQUFBQSxXQUFXLE1BRVhDLENBQUFBLE1BQThCLEdBQzFCLENBQXNDLEdBQ3RDO0FBRVI7QUFFQSwrREFBK0Q7QUFDL0QsMkRBQTJEO0FBQzNETixjQUFjOEIsa0JBQWtCLEdBQUc7SUFFbkMvQixXQUFlQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyLnRzP2QyODAiXSwibmFtZXMiOlsiX2RlZmF1bHQiLCJkZWZhdWx0TG9hZGVyIiwicGFyYW0iLCJjb25maWciLCJzcmMiLCJ3aWR0aCIsInF1YWxpdHkiLCJwcm9jZXNzIiwibWlzc2luZ1ZhbHVlcyIsInB1c2giLCJsZW5ndGgiLCJFcnJvciIsImpvaW4iLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhcnRzV2l0aCIsImRvbWFpbnMiLCJyZW1vdGVQYXR0ZXJucyIsInBhcnNlZFNyYyIsIlVSTCIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsImVudiIsIk5FWFRfUlVOVElNRSIsImhhc01hdGNoIiwicmVxdWlyZSIsImhvc3RuYW1lIiwicGF0aCIsImVuY29kZVVSSUNvbXBvbmVudCIsIk5FWFRfREVQTE9ZTUVOVF9JRCIsIl9fbmV4dF9pbWdfZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/image-loader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!**********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \**********************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasMatch: function hasMatch1() {\n        return hasMatch;\n    },\n    matchRemotePattern: function matchRemotePattern1() {\n        return matchRemotePattern;\n    }\n});\nvar _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchRemotePattern(pattern, url) {\n    if (pattern.protocol !== undefined) {\n        var actualProto = url.protocol.slice(0, -1);\n        if (pattern.protocol !== actualProto) {\n            return false;\n        }\n    }\n    if (pattern.port !== undefined) {\n        if (pattern.port !== url.port) {\n            return false;\n        }\n    }\n    if (pattern.hostname === undefined) {\n        throw new Error(\"Pattern should define hostname but found\\n\" + JSON.stringify(pattern));\n    } else {\n        if (!(0, _picomatch.makeRe)(pattern.hostname).test(url.hostname)) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : \"**\", {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasMatch(domains, remotePatterns, url) {\n    return domains.some(function(domain) {\n        return url.hostname === domain;\n    }) || remotePatterns.some(function(p) {\n        return matchRemotePattern(p, url);\n    });\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1yZW1vdGUtcGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFpQ2dCQSxVQUFRLFNBQVJBO2VBQUFBOztJQTlCQUMsb0JBQWtCLFNBQWxCQTtlQUFBQTs7O3FDQUZPO0FBRWhCLFNBQVNBLG1CQUFtQkMsT0FBc0IsRUFBRUMsR0FBUTtJQUNqRSxJQUFJRCxRQUFRRSxRQUFRLEtBQUtDLFdBQVc7UUFDbEMsSUFBTUMsY0FBY0gsSUFBSUMsUUFBUSxDQUFDRyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQzNDLElBQUlMLFFBQVFFLFFBQVEsS0FBS0UsYUFBYTtZQUNwQyxPQUFPO1FBQ1Q7SUFDRjtJQUNBLElBQUlKLFFBQVFNLElBQUksS0FBS0gsV0FBVztRQUM5QixJQUFJSCxRQUFRTSxJQUFJLEtBQUtMLElBQUlLLElBQUksRUFBRTtZQUM3QixPQUFPO1FBQ1Q7SUFDRjtJQUVBLElBQUlOLFFBQVFPLFFBQVEsS0FBS0osV0FBVztRQUNsQyxNQUFNLElBQUlLLE1BQ1IsK0NBQTZDQyxLQUFLQyxTQUFTLENBQUNWO0lBRWhFLE9BQU87UUFDTCxJQUFJLENBQUNXLENBQUFBLEdBQUFBLFdBQUFBLE1BQU0sRUFBQ1gsUUFBUU8sUUFBUSxFQUFFSyxJQUFJLENBQUNYLElBQUlNLFFBQVEsR0FBRztZQUNoRCxPQUFPO1FBQ1Q7SUFDRjtRQUVZUDtJQUFaLElBQUksQ0FBQ1csQ0FBQUEsR0FBQUEsV0FBQUEsTUFBTSxFQUFDWCxDQUFBQSxvQkFBQUEsUUFBUWEsUUFBUSxZQUFoQmIsb0JBQW9CLE1BQU07UUFBRWMsS0FBSztJQUFLLEdBQUdGLElBQUksQ0FBQ1gsSUFBSVksUUFBUSxHQUFHO1FBQ3ZFLE9BQU87SUFDVDtJQUVBLE9BQU87QUFDVDtBQUVPLFNBQVNmLFNBQ2RpQixPQUFpQixFQUNqQkMsY0FBK0IsRUFDL0JmLEdBQVE7SUFFUixPQUNFYyxRQUFRRSxJQUFJLENBQUMsU0FBQ0M7ZUFBV2pCLElBQUlNLFFBQVEsS0FBS1c7VUFDMUNGLGVBQWVDLElBQUksQ0FBQyxTQUFDRTtlQUFNcEIsbUJBQW1Cb0IsR0FBR2xCOztBQUVyRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvbWF0Y2gtcmVtb3RlLXBhdHRlcm4udHM/ZDYxZCJdLCJuYW1lcyI6WyJoYXNNYXRjaCIsIm1hdGNoUmVtb3RlUGF0dGVybiIsInBhdHRlcm4iLCJ1cmwiLCJwcm90b2NvbCIsInVuZGVmaW5lZCIsImFjdHVhbFByb3RvIiwic2xpY2UiLCJwb3J0IiwiaG9zdG5hbWUiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJtYWtlUmUiLCJ0ZXN0IiwicGF0aG5hbWUiLCJkb3QiLCJkb21haW5zIiwicmVtb3RlUGF0dGVybnMiLCJzb21lIiwiZG9tYWluIiwicCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!*******************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \*******************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function get() {\n        return RouterContext;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\"));\nvar RouterContext = _react[\"default\"].createContext(null);\nif (true) {\n    RouterContext.displayName = \"RouterContext\";\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O2lEQUdhQTs7O2VBQUFBOzs7OzBFQUhLO0FBR1gsSUFBTUEsZ0JBQWdCQyxNQUFBQSxDQUFBQSxVQUFLLENBQUNDLGFBQWEsQ0FBb0I7QUFFcEUsSUFBSUMsSUFBeUIsRUFBYztJQUN6Q0gsY0FBY0ksV0FBVyxHQUFHO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS50cz82MzZjIl0sIm5hbWVzIjpbIlJvdXRlckNvbnRleHQiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \*************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatUrl: function formatUrl1() {\n        return formatUrl;\n    },\n    formatWithValidation: function formatWithValidation1() {\n        return formatWithValidation;\n    },\n    urlObjectKeys: function urlObjectKeys1() {\n        return urlObjectKeys;\n    }\n});\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./querystring */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/querystring.js\"));\nvar slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    var auth = urlObj.auth, hostname = urlObj.hostname;\n    var protocol = urlObj.protocol || \"\";\n    var pathname = urlObj.pathname || \"\";\n    var hash = urlObj.hash || \"\";\n    var query = urlObj.query || \"\";\n    var host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, \":\") + \"@\" : \"\";\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(\":\") ? \"[\" + hostname + \"]\" : hostname);\n        if (urlObj.port) {\n            host += \":\" + urlObj.port;\n        }\n    }\n    if (query && typeof query === \"object\") {\n        query = String(_querystring.urlQueryToSearchParams(query));\n    }\n    var search = urlObj.search || query && \"?\" + query || \"\";\n    if (protocol && !protocol.endsWith(\":\")) protocol += \":\";\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = \"//\" + (host || \"\");\n        if (pathname && pathname[0] !== \"/\") pathname = \"/\" + pathname;\n    } else if (!host) {\n        host = \"\";\n    }\n    if (hash && hash[0] !== \"#\") hash = \"#\" + hash;\n    if (search && search[0] !== \"?\") search = \"?\" + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace(\"#\", \"%23\");\n    return \"\" + protocol + host + pathname + search + hash;\n}\nvar urlObjectKeys = [\n    \"auth\",\n    \"hash\",\n    \"host\",\n    \"hostname\",\n    \"href\",\n    \"path\",\n    \"pathname\",\n    \"port\",\n    \"protocol\",\n    \"query\",\n    \"search\",\n    \"slashes\"\n];\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === \"object\") {\n            Object.keys(url).forEach(function(key) {\n                if (!urlObjectKeys.includes(key)) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \" + key);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx1Q0FBdUM7QUFDdkMsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5Qzs7Ozs7Ozs7Ozs7OztJQVF6QkEsV0FBUyxTQUFUQTtlQUFBQTs7SUE2REFDLHNCQUFvQixTQUFwQkE7ZUFBQUE7O0lBZkhDLGVBQWEsU0FBYkE7ZUFBQUE7Ozs7aUZBbERnQjtBQUU3QixJQUFNQyxtQkFBbUI7QUFFbEIsU0FBU0gsVUFBVUksTUFBaUI7SUFDekMsSUFBTUMsT0FBbUJELE9BQW5CQyxNQUFNQyxXQUFhRixPQUFiRTtJQUNaLElBQUlDLFdBQVdILE9BQU9HLFFBQVEsSUFBSTtJQUNsQyxJQUFJQyxXQUFXSixPQUFPSSxRQUFRLElBQUk7SUFDbEMsSUFBSUMsT0FBT0wsT0FBT0ssSUFBSSxJQUFJO0lBQzFCLElBQUlDLFFBQVFOLE9BQU9NLEtBQUssSUFBSTtJQUM1QixJQUFJQyxPQUF1QjtJQUUzQk4sT0FBT0EsT0FBT08sbUJBQW1CUCxNQUFNUSxPQUFPLENBQUMsUUFBUSxPQUFPLE1BQU07SUFFcEUsSUFBSVQsT0FBT08sSUFBSSxFQUFFO1FBQ2ZBLE9BQU9OLE9BQU9ELE9BQU9PLElBQUk7SUFDM0IsT0FBTyxJQUFJTCxVQUFVO1FBQ25CSyxPQUFPTixPQUFRLEVBQUNDLFNBQVNRLE9BQU8sQ0FBQyxPQUFPLE1BQUlSLFdBQVMsTUFBS0EsUUFBQUE7UUFDMUQsSUFBSUYsT0FBT1csSUFBSSxFQUFFO1lBQ2ZKLFFBQVEsTUFBTVAsT0FBT1csSUFBSTtRQUMzQjtJQUNGO0lBRUEsSUFBSUwsU0FBUyxPQUFPQSxVQUFVLFVBQVU7UUFDdENBLFFBQVFNLE9BQU9DLGFBQVlDLHNCQUFzQixDQUFDUjtJQUNwRDtJQUVBLElBQUlTLFNBQVNmLE9BQU9lLE1BQU0sSUFBS1QsU0FBUyxNQUFJQSxTQUFZO0lBRXhELElBQUlILFlBQVksQ0FBQ0EsU0FBU2EsUUFBUSxDQUFDLE1BQU1iLFlBQVk7SUFFckQsSUFDRUgsT0FBT2lCLE9BQU8sSUFDYixDQUFDLENBQUNkLFlBQVlKLGlCQUFpQm1CLElBQUksQ0FBQ2YsU0FBQUEsS0FBY0ksU0FBUyxPQUM1RDtRQUNBQSxPQUFPLE9BQVFBLENBQUFBLFFBQVE7UUFDdkIsSUFBSUgsWUFBWUEsUUFBUSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxXQUFXLE1BQU1BO0lBQ3hELE9BQU8sSUFBSSxDQUFDRyxNQUFNO1FBQ2hCQSxPQUFPO0lBQ1Q7SUFFQSxJQUFJRixRQUFRQSxJQUFJLENBQUMsRUFBRSxLQUFLLEtBQUtBLE9BQU8sTUFBTUE7SUFDMUMsSUFBSVUsVUFBVUEsTUFBTSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxTQUFTLE1BQU1BO0lBRWhEWCxXQUFXQSxTQUFTSyxPQUFPLENBQUMsU0FBU0Q7SUFDckNPLFNBQVNBLE9BQU9OLE9BQU8sQ0FBQyxLQUFLO0lBRTdCLE9BQU8sS0FBR04sV0FBV0ksT0FBT0gsV0FBV1csU0FBU1Y7QUFDbEQ7QUFFTyxJQUFNUCxnQkFBZ0I7SUFDM0I7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFTSxTQUFTRCxxQkFBcUJzQixHQUFjO0lBQ2pELElBQUlDLElBQXlCLEVBQWU7UUFDMUMsSUFBSUQsUUFBUSxRQUFRLE9BQU9BLFFBQVEsVUFBVTtZQUMzQ0UsT0FBT0MsSUFBSSxDQUFDSCxLQUFLSSxPQUFPLENBQUMsU0FBQ0M7Z0JBQ3hCLElBQUksQ0FBQzFCLGNBQWMyQixRQUFRLENBQUNELE1BQU07b0JBQ2hDRSxRQUFRQyxJQUFJLENBQ1YsdURBQXFESDtnQkFFekQ7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPNUIsVUFBVXVCO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC50cz8xYjg3Il0sIm5hbWVzIjpbImZvcm1hdFVybCIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwidXJsT2JqZWN0S2V5cyIsInNsYXNoZWRQcm90b2NvbHMiLCJ1cmxPYmoiLCJhdXRoIiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInBhdGhuYW1lIiwiaGFzaCIsInF1ZXJ5IiwiaG9zdCIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlcGxhY2UiLCJpbmRleE9mIiwicG9ydCIsIlN0cmluZyIsInF1ZXJ5c3RyaW5nIiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsInNlYXJjaCIsImVuZHNXaXRoIiwic2xhc2hlcyIsInRlc3QiLCJ1cmwiLCJwcm9jZXNzIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJpbmNsdWRlcyIsImNvbnNvbGUiLCJ3YXJuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/format-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/index.js":
/*!********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/index.js ***!
  \********************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getSortedRoutes: function getSortedRoutes() {\n        return _sortedroutes.getSortedRoutes;\n    },\n    isDynamicRoute: function isDynamicRoute() {\n        return _isdynamic.isDynamicRoute;\n    }\n});\nvar _sortedroutes = __webpack_require__(/*! ./sorted-routes */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\");\nvar _isdynamic = __webpack_require__(/*! ./is-dynamic */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\"); //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBQVNBLGlCQUFlLFNBQWZBO2VBQUFBLGNBQUFBLGVBQWU7O0lBQ2ZDLGdCQUFjLFNBQWRBO2VBQUFBLFdBQUFBLGNBQWM7Ozt3Q0FEUztxQ0FDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2luZGV4LnRzPzcyZDUiXSwibmFtZXMiOlsiZ2V0U29ydGVkUm91dGVzIiwiaXNEeW5hbWljUm91dGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/interpolate-as.js":
/*!*****************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/interpolate-as.js ***!
  \*****************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"interpolateAs\", ({\n    enumerable: true,\n    get: function get() {\n        return interpolateAs;\n    }\n}));\nvar _routematcher = __webpack_require__(/*! ./route-matcher */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nvar _routeregex = __webpack_require__(/*! ./route-regex */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nfunction interpolateAs(route, asPathname, query) {\n    var interpolatedRoute = \"\";\n    var dynamicRegex = (0, _routeregex.getRouteRegex)(route);\n    var dynamicGroups = dynamicRegex.groups;\n    var dynamicMatches = (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : \"\") || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    var params = Object.keys(dynamicGroups);\n    if (!params.every(function(param) {\n        var value = dynamicMatches[param] || \"\";\n        var _dynamicGroups_param = dynamicGroups[param], repeat = _dynamicGroups_param.repeat, optional = _dynamicGroups_param.optional;\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        var replaced = \"[\" + (repeat ? \"...\" : \"\") + param + \"]\";\n        if (optional) {\n            replaced = (!value ? \"/\" : \"\") + \"[\" + replaced + \"]\";\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        function(segment) {\n            return encodeURIComponent(segment);\n        }).join(\"/\") : encodeURIComponent(value)) || \"/\");\n    })) {\n        interpolatedRoute = \"\" // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params: params,\n        result: interpolatedRoute\n    };\n} //# sourceMappingURL=interpolate-as.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJwb2xhdGUtYXMuanMiLCJtYXBwaW5ncyI6Ijs7OztpREFLZ0JBOzs7ZUFBQUE7Ozt3Q0FIZ0I7c0NBQ0Y7QUFFdkIsU0FBU0EsY0FDZEMsS0FBYSxFQUNiQyxVQUFrQixFQUNsQkMsS0FBcUI7SUFFckIsSUFBSUMsb0JBQW9CO0lBRXhCLElBQU1DLGVBQWVDLENBQUFBLEdBQUFBLFlBQUFBLGFBQWEsRUFBQ0w7SUFDbkMsSUFBTU0sZ0JBQWdCRixhQUFhRyxNQUFNO0lBQ3pDLElBQU1DLGlCQUVIUCxDQUFBQSxlQUFlRCxRQUFRUyxDQUFBQSxHQUFBQSxjQUFBQSxlQUFlLEVBQUNMLGNBQWNILGNBQWMsT0FDcEUsZ0RBQWdEO0lBQ2hELHNFQUFzRTtJQUN0RUM7SUFFRkMsb0JBQW9CSDtJQUNwQixJQUFNVSxTQUFTQyxPQUFPQyxJQUFJLENBQUNOO0lBRTNCLElBQ0UsQ0FBQ0ksT0FBT0csS0FBSyxDQUFDLFNBQUNDO1FBQ2IsSUFBSUMsUUFBUVAsY0FBYyxDQUFDTSxNQUFNLElBQUk7UUFDckMsSUFBNkJSLHVCQUFBQSxhQUFhLENBQUNRLE1BQU0sRUFBekNFLFNBQXFCVixxQkFBckJVLFFBQVFDLFdBQWFYLHFCQUFiVztRQUVoQixpQ0FBaUM7UUFDakMsMERBQTBEO1FBQzFELElBQUlDLFdBQVcsTUFBSUYsQ0FBQUEsU0FBUyxRQUFRLE1BQUtGLFFBQU07UUFDL0MsSUFBSUcsVUFBVTtZQUNaQyxXQUFXLENBQUcsQ0FBQ0gsUUFBUSxNQUFNLE1BQUcsTUFBR0csV0FBUztRQUM5QztRQUNBLElBQUlGLFVBQVUsQ0FBQ0csTUFBTUMsT0FBTyxDQUFDTCxRQUFRQSxRQUFRO1lBQUNBO1NBQU07UUFFcEQsT0FDRSxDQUFDRSxZQUFZSCxTQUFTTixjQUFBQSxLQUN0Qiw2Q0FBNkM7UUFDNUNMLENBQUFBLG9CQUNDQSxrQkFBbUJrQixPQUFPLENBQ3hCSCxVQUNBRixTQUNJRCxNQUNHTyxHQUFHLENBRUYsdURBQXVEO1FBQ3ZELGtEQUFrRDtRQUNsRCxvQ0FBb0M7UUFDcEMsU0FBQ0M7bUJBQVlDLG1CQUFtQkQ7V0FFakNFLElBQUksQ0FBQyxPQUNSRCxtQkFBbUJULFdBQ3BCO0lBRVgsSUFDQTtRQUNBWixvQkFBb0IsR0FBRyxtQ0FBbUM7O0lBRTFELHVFQUF1RTtJQUN2RSxrREFBa0Q7SUFDcEQ7SUFDQSxPQUFPO1FBQ0xPLFFBQUFBO1FBQ0FnQixRQUFRdkI7SUFDVjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJwb2xhdGUtYXMudHM/OWUzMSJdLCJuYW1lcyI6WyJpbnRlcnBvbGF0ZUFzIiwicm91dGUiLCJhc1BhdGhuYW1lIiwicXVlcnkiLCJpbnRlcnBvbGF0ZWRSb3V0ZSIsImR5bmFtaWNSZWdleCIsImdldFJvdXRlUmVnZXgiLCJkeW5hbWljR3JvdXBzIiwiZ3JvdXBzIiwiZHluYW1pY01hdGNoZXMiLCJnZXRSb3V0ZU1hdGNoZXIiLCJwYXJhbXMiLCJPYmplY3QiLCJrZXlzIiwiZXZlcnkiLCJwYXJhbSIsInZhbHVlIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJyZXBsYWNlZCIsIkFycmF5IiwiaXNBcnJheSIsInJlcGxhY2UiLCJtYXAiLCJzZWdtZW50IiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwiam9pbiIsInJlc3VsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js ***!
  \*************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isDynamicRoute\", ({\n    enumerable: true,\n    get: function get() {\n        return isDynamicRoute;\n    }\n}));\nvar _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/server/future/helpers/interception-routes.js\");\n// Identify /[param]/ in route string\nvar TEST_ROUTE = /\\/\\[[^/]+?\\](?=\\/|$)/;\nfunction isDynamicRoute(route) {\n    if ((0, _interceptionroutes.isInterceptionRouteAppPath)(route)) {\n        route = (0, _interceptionroutes.extractInterceptionRouteInformation)(route).interceptedRoute;\n    }\n    return TEST_ROUTE.test(route);\n} //# sourceMappingURL=is-dynamic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy5qcyIsIm1hcHBpbmdzIjoiOzs7O2tEQVFnQkE7OztlQUFBQTs7OzhDQUxUO0FBRVAscUNBQXFDO0FBQ3JDLElBQU1DLGFBQWE7QUFFWixTQUFTRCxlQUFlRSxLQUFhO0lBQzFDLElBQUlDLENBQUFBLEdBQUFBLG9CQUFBQSwwQkFBMEIsRUFBQ0QsUUFBUTtRQUNyQ0EsUUFBUUUsQ0FBQUEsR0FBQUEsb0JBQUFBLG1DQUFtQyxFQUFDRixPQUFPRyxnQkFBZ0I7SUFDckU7SUFFQSxPQUFPSixXQUFXSyxJQUFJLENBQUNKO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy50cz84MmRjIl0sIm5hbWVzIjpbImlzRHluYW1pY1JvdXRlIiwiVEVTVF9ST1VURSIsInJvdXRlIiwiaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgiLCJleHRyYWN0SW50ZXJjZXB0aW9uUm91dGVJbmZvcm1hdGlvbiIsImludGVyY2VwdGVkUm91dGUiLCJ0ZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/is-local-url.js":
/*!***************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/is-local-url.js ***!
  \***************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isLocalURL\", ({\n    enumerable: true,\n    get: function get() {\n        return isLocalURL;\n    }\n}));\nvar _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils.js\");\nvar _hasbasepath = __webpack_require__(/*! ../../../../client/has-base-path */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/client/has-base-path.js\");\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils.isAbsoluteUrl)(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        var locationOrigin = (0, _utils.getLocationOrigin)();\n        var resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n} //# sourceMappingURL=is-local-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7OENBTWdCQTs7O2VBQUFBOzs7aUNBTmlDO3VDQUNyQjtBQUtyQixTQUFTQSxXQUFXQyxHQUFXO0lBQ3BDLGdFQUFnRTtJQUNoRSxJQUFJLENBQUNDLENBQUFBLEdBQUFBLE9BQUFBLGFBQWEsRUFBQ0QsTUFBTSxPQUFPO0lBQ2hDLElBQUk7UUFDRiw0REFBNEQ7UUFDNUQsSUFBTUUsaUJBQWlCQyxDQUFBQSxHQUFBQSxPQUFBQSxpQkFBaUI7UUFDeEMsSUFBTUMsV0FBVyxJQUFJQyxJQUFJTCxLQUFLRTtRQUM5QixPQUFPRSxTQUFTRSxNQUFNLEtBQUtKLGtCQUFrQkssQ0FBQUEsR0FBQUEsYUFBQUEsV0FBVyxFQUFDSCxTQUFTSSxRQUFRO0lBQzVFLEVBQUUsT0FBT0MsR0FBRztRQUNWLE9BQU87SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLnRzPzA0ZTUiXSwibmFtZXMiOlsiaXNMb2NhbFVSTCIsInVybCIsImlzQWJzb2x1dGVVcmwiLCJsb2NhdGlvbk9yaWdpbiIsImdldExvY2F0aW9uT3JpZ2luIiwicmVzb2x2ZWQiLCJVUkwiLCJvcmlnaW4iLCJoYXNCYXNlUGF0aCIsInBhdGhuYW1lIiwiXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/is-local-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/omit.js":
/*!*******************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/omit.js ***!
  \*******************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"omit\", ({\n    enumerable: true,\n    get: function get() {\n        return omit;\n    }\n}));\nfunction omit(object, keys) {\n    var omitted = {};\n    Object.keys(object).forEach(function(key) {\n        if (!keys.includes(key)) {\n            omitted[key] = object[key];\n        }\n    });\n    return omitted;\n} //# sourceMappingURL=omit.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvb21pdC5qcyIsIm1hcHBpbmdzIjoiOzs7O3dDQUFnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0EsS0FDZEMsTUFBUyxFQUNUQyxJQUFTO0lBRVQsSUFBTUMsVUFBc0MsQ0FBQztJQUM3Q0MsT0FBT0YsSUFBSSxDQUFDRCxRQUFRSSxPQUFPLENBQUMsU0FBQ0M7UUFDM0IsSUFBSSxDQUFDSixLQUFLSyxRQUFRLENBQUNELE1BQVc7WUFDNUJILE9BQU8sQ0FBQ0csSUFBSSxHQUFHTCxNQUFNLENBQUNLLElBQUk7UUFDNUI7SUFDRjtJQUNBLE9BQU9IO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9vbWl0LnRzP2I3YTgiXSwibmFtZXMiOlsib21pdCIsIm9iamVjdCIsImtleXMiLCJvbWl0dGVkIiwiT2JqZWN0IiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/omit.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!**************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \**************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    assign: function assign1() {\n        return assign;\n    },\n    searchParamsToUrlQuery: function searchParamsToUrlQuery1() {\n        return searchParamsToUrlQuery;\n    },\n    urlQueryToSearchParams: function urlQueryToSearchParams1() {\n        return urlQueryToSearchParams;\n    }\n});\nfunction searchParamsToUrlQuery(searchParams) {\n    var query = {};\n    searchParams.forEach(function(value, key) {\n        if (typeof query[key] === \"undefined\") {\n            query[key] = value;\n        } else if (Array.isArray(query[key])) {\n            query[key].push(value);\n        } else {\n            query[key] = [\n                query[key],\n                value\n            ];\n        }\n    });\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === \"string\" || typeof param === \"number\" && !isNaN(param) || typeof param === \"boolean\") {\n        return String(param);\n    } else {\n        return \"\";\n    }\n}\nfunction urlQueryToSearchParams(urlQuery) {\n    var result = new URLSearchParams();\n    Object.entries(urlQuery).forEach(function(param) {\n        var _param = _sliced_to_array._(param, 2), key = _param[0], value = _param[1];\n        if (Array.isArray(value)) {\n            value.forEach(function(item) {\n                return result.append(key, stringifyUrlQueryParam(item));\n            });\n        } else {\n            result.set(key, stringifyUrlQueryParam(value));\n        }\n    });\n    return result;\n}\nfunction assign(target) {\n    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        searchParamsList[_key - 1] = arguments[_key];\n    }\n    searchParamsList.forEach(function(searchParams) {\n        Array.from(searchParams.keys()).forEach(function(key) {\n            return target[\"delete\"](key);\n        });\n        searchParams.forEach(function(value, key) {\n            return target.append(key, value);\n        });\n    });\n    return target;\n} //# sourceMappingURL=querystring.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztJQTRDZ0JBLFFBQU0sU0FBTkE7ZUFBQUE7O0lBMUNBQyx3QkFBc0IsU0FBdEJBO2VBQUFBOztJQTRCQUMsd0JBQXNCLFNBQXRCQTtlQUFBQTs7O0FBNUJULFNBQVNELHVCQUNkRSxZQUE2QjtJQUU3QixJQUFNQyxRQUF3QixDQUFDO0lBQy9CRCxhQUFhRSxPQUFPLENBQUMsU0FBQ0MsT0FBT0M7UUFDM0IsSUFBSSxPQUFPSCxLQUFLLENBQUNHLElBQUksS0FBSyxhQUFhO1lBQ3JDSCxLQUFLLENBQUNHLElBQUksR0FBR0Q7UUFDZixPQUFPLElBQUlFLE1BQU1DLE9BQU8sQ0FBQ0wsS0FBSyxDQUFDRyxJQUFJLEdBQUc7WUFDbENILEtBQUssQ0FBQ0csSUFBSSxDQUFjRyxJQUFJLENBQUNKO1FBQ2pDLE9BQU87WUFDTEYsS0FBSyxDQUFDRyxJQUFJLEdBQUc7Z0JBQUNILEtBQUssQ0FBQ0csSUFBSTtnQkFBWUQ7YUFBTTtRQUM1QztJQUNGO0lBQ0EsT0FBT0Y7QUFDVDtBQUVBLFNBQVNPLHVCQUF1QkMsS0FBYztJQUM1QyxJQUNFLE9BQU9BLFVBQVUsWUFDaEIsT0FBT0EsVUFBVSxZQUFZLENBQUNDLE1BQU1ELFVBQ3JDLE9BQU9BLFVBQVUsV0FDakI7UUFDQSxPQUFPRSxPQUFPRjtJQUNoQixPQUFPO1FBQ0wsT0FBTztJQUNUO0FBQ0Y7QUFFTyxTQUFTVix1QkFDZGEsUUFBd0I7SUFFeEIsSUFBTUMsU0FBUyxJQUFJQztJQUNuQkMsT0FBT0MsT0FBTyxDQUFDSixVQUFVVixPQUFPLENBQUMsU0FBQU87WUFBYUEsNEJBQUFBLFdBQVhMLE1BQVdLLFdBQU5OLFFBQU1NO1FBQzVDLElBQUlKLE1BQU1DLE9BQU8sQ0FBQ0gsUUFBUTtZQUN4QkEsTUFBTUQsT0FBTyxDQUFDLFNBQUNlO3VCQUFTSixPQUFPSyxNQUFNLENBQUNkLEtBQUtJLHVCQUF1QlM7O1FBQ3BFLE9BQU87WUFDTEosT0FBT00sR0FBRyxDQUFDZixLQUFLSSx1QkFBdUJMO1FBQ3pDO0lBQ0Y7SUFDQSxPQUFPVTtBQUNUO0FBRU8sU0FBU2hCLE9BQ2R1QixNQUF1QjtJQUN2QixRQUFBQyxPQUFBQyxVQUFBQyxNQUFBLEVBQUFDLG1CQUFBLElBQUFuQixNQUFBZ0IsT0FBQSxJQUFBQSxPQUFBLFFBQUFJLE9BQUEsR0FBQUEsT0FBQUosTUFBQUksT0FBQTtRQUFHRCxnQkFBQUEsQ0FBSEMsT0FBQSxLQUFBSCxTQUFBLENBQUFHLEtBQXNDOztJQUV0Q0QsaUJBQWlCdEIsT0FBTyxDQUFDLFNBQUNGO1FBQ3hCSyxNQUFNcUIsSUFBSSxDQUFDMUIsYUFBYTJCLElBQUksSUFBSXpCLE9BQU8sQ0FBQyxTQUFDRTttQkFBUWdCLE1BQU9RLENBQUFBLFNBQU0sQ0FBQ3hCOztRQUMvREosYUFBYUUsT0FBTyxDQUFDLFNBQUNDLE9BQU9DO21CQUFRZ0IsT0FBT0YsTUFBTSxDQUFDZCxLQUFLRDs7SUFDMUQ7SUFDQSxPQUFPaUI7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nLnRzPzgyZmEiXSwibmFtZXMiOlsiYXNzaWduIiwic2VhcmNoUGFyYW1zVG9VcmxRdWVyeSIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJzZWFyY2hQYXJhbXMiLCJxdWVyeSIsImZvckVhY2giLCJ2YWx1ZSIsImtleSIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJzdHJpbmdpZnlVcmxRdWVyeVBhcmFtIiwicGFyYW0iLCJpc05hTiIsIlN0cmluZyIsInVybFF1ZXJ5IiwicmVzdWx0IiwiVVJMU2VhcmNoUGFyYW1zIiwiT2JqZWN0IiwiZW50cmllcyIsIml0ZW0iLCJhcHBlbmQiLCJzZXQiLCJ0YXJnZXQiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic2VhcmNoUGFyYW1zTGlzdCIsIl9rZXkiLCJmcm9tIiwia2V5cyIsImRlbGV0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/querystring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/route-matcher.js":
/*!****************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/route-matcher.js ***!
  \****************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getRouteMatcher\", ({\n    enumerable: true,\n    get: function get() {\n        return getRouteMatcher;\n    }\n}));\nvar _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils.js\");\nfunction getRouteMatcher(param) {\n    var re = param.re, groups = param.groups;\n    return function(pathname) {\n        var routeMatch = re.exec(pathname);\n        if (!routeMatch) {\n            return false;\n        }\n        var decode = function(param) {\n            try {\n                return decodeURIComponent(param);\n            } catch (_) {\n                throw new _utils.DecodeError(\"failed to decode param\");\n            }\n        };\n        var params = {};\n        Object.keys(groups).forEach(function(slugName) {\n            var g = groups[slugName];\n            var m = routeMatch[g.pos];\n            if (m !== undefined) {\n                params[slugName] = ~m.indexOf(\"/\") ? m.split(\"/\").map(function(entry) {\n                    return decode(entry);\n                }) : g.repeat ? [\n                    decode(m)\n                ] : decode(m);\n            }\n        });\n        return params;\n    };\n} //# sourceMappingURL=route-matcher.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQVdnQkE7OztlQUFBQTs7O2lDQVZZO0FBVXJCLFNBQVNBLGdCQUFnQkMsS0FBMEI7SUFBMUIsSUFBRUMsS0FBRkQsTUFBRUMsSUFBSUMsU0FBTkYsTUFBTUU7SUFDcEMsT0FBTyxTQUFDQztRQUNOLElBQU1DLGFBQWFILEdBQUdJLElBQUksQ0FBQ0Y7UUFDM0IsSUFBSSxDQUFDQyxZQUFZO1lBQ2YsT0FBTztRQUNUO1FBRUEsSUFBTUUsU0FBUyxTQUFDTjtZQUNkLElBQUk7Z0JBQ0YsT0FBT08sbUJBQW1CUDtZQUM1QixFQUFFLE9BQU9RLEdBQUc7Z0JBQ1YsTUFBTSxJQUFJQyxPQUFBQSxXQUFXLENBQUM7WUFDeEI7UUFDRjtRQUNBLElBQU1DLFNBQXFELENBQUM7UUFFNURDLE9BQU9DLElBQUksQ0FBQ1YsUUFBUVcsT0FBTyxDQUFDLFNBQUNDO1lBQzNCLElBQU1DLElBQUliLE1BQU0sQ0FBQ1ksU0FBUztZQUMxQixJQUFNRSxJQUFJWixVQUFVLENBQUNXLEVBQUVFLEdBQUcsQ0FBQztZQUMzQixJQUFJRCxNQUFNRSxXQUFXO2dCQUNuQlIsTUFBTSxDQUFDSSxTQUFTLEdBQUcsQ0FBQ0UsRUFBRUcsT0FBTyxDQUFDLE9BQzFCSCxFQUFFSSxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDLFNBQUNDOzJCQUFVaEIsT0FBT2dCO3FCQUNuQ1AsRUFBRVEsTUFBTSxHQUNSO29CQUFDakIsT0FBT1U7aUJBQUcsR0FDWFYsT0FBT1U7WUFDYjtRQUNGO1FBQ0EsT0FBT047SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci50cz8zMTc5Il0sIm5hbWVzIjpbImdldFJvdXRlTWF0Y2hlciIsInBhcmFtIiwicmUiLCJncm91cHMiLCJwYXRobmFtZSIsInJvdXRlTWF0Y2giLCJleGVjIiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiXyIsIkRlY29kZUVycm9yIiwicGFyYW1zIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJzbHVnTmFtZSIsImciLCJtIiwicG9zIiwidW5kZWZpbmVkIiwiaW5kZXhPZiIsInNwbGl0IiwibWFwIiwiZW50cnkiLCJyZXBlYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/route-matcher.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/route-regex.js":
/*!**************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/route-regex.js ***!
  \**************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getNamedMiddlewareRegex: function getNamedMiddlewareRegex1() {\n        return getNamedMiddlewareRegex;\n    },\n    getNamedRouteRegex: function getNamedRouteRegex1() {\n        return getNamedRouteRegex;\n    },\n    getRouteRegex: function getRouteRegex1() {\n        return getRouteRegex;\n    }\n});\nvar _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/server/future/helpers/interception-routes.js\");\nvar _escaperegexp = __webpack_require__(/*! ../../escape-regexp */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/escape-regexp.js\");\nvar _removetrailingslash = __webpack_require__(/*! ./remove-trailing-slash */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nvar NEXT_QUERY_PARAM_PREFIX = \"nxtP\";\nvar NEXT_INTERCEPTION_MARKER_PREFIX = \"nxtI\";\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n */ function parseParameter(param) {\n    var optional = param.startsWith(\"[\") && param.endsWith(\"]\");\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    var repeat = param.startsWith(\"...\");\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat: repeat,\n        optional: optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    var segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    var groups = {};\n    var groupIndex = 1;\n    return {\n        parameterizedRoute: segments.map(function(segment) {\n            var markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find(function(m) {\n                return segment.startsWith(m);\n            });\n            var paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (markerMatch && paramMatches) {\n                var _parseParameter = parseParameter(paramMatches[1]), key = _parseParameter.key, optional = _parseParameter.optional, repeat = _parseParameter.repeat;\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat: repeat,\n                    optional: optional\n                };\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\";\n            } else if (paramMatches) {\n                var _parseParameter1 = parseParameter(paramMatches[1]), key1 = _parseParameter1.key, repeat1 = _parseParameter1.repeat, optional1 = _parseParameter1.optional;\n                groups[key1] = {\n                    pos: groupIndex++,\n                    repeat: repeat1,\n                    optional: optional1\n                };\n                return repeat1 ? optional1 ? \"(?:/(.+?))?\" : \"/(.+?)\" : \"/([^/]+?)\";\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        groups: groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    var _getParametrizedRoute = getParametrizedRoute(normalizedRoute), parameterizedRoute = _getParametrizedRoute.parameterizedRoute, groups = _getParametrizedRoute.groups;\n    return {\n        re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n        groups: groups\n    };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */ function buildGetSafeRouteKey() {\n    var i = 0;\n    return function() {\n        var routeKey = \"\";\n        var j = ++i;\n        while(j > 0){\n            routeKey += String.fromCharCode(97 + (j - 1) % 26);\n            j = Math.floor((j - 1) / 26);\n        }\n        return routeKey;\n    };\n}\nfunction getSafeKeyFromSegment(param) {\n    var interceptionMarker = param.interceptionMarker, getSafeRouteKey = param.getSafeRouteKey, segment = param.segment, routeKeys = param.routeKeys, keyPrefix = param.keyPrefix;\n    var _parseParameter = parseParameter(segment), key = _parseParameter.key, optional = _parseParameter.optional, repeat = _parseParameter.repeat;\n    // replace any non-word characters since they can break\n    // the named regex\n    var cleanedKey = key.replace(/\\W/g, \"\");\n    if (keyPrefix) {\n        cleanedKey = \"\" + keyPrefix + cleanedKey;\n    }\n    var invalidKey = false;\n    // check if the key is still invalid and fallback to using a known\n    // safe key\n    if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n        invalidKey = true;\n    }\n    if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n        invalidKey = true;\n    }\n    if (invalidKey) {\n        cleanedKey = getSafeRouteKey();\n    }\n    if (keyPrefix) {\n        routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n    } else {\n        routeKeys[cleanedKey] = key;\n    }\n    // if the segment has an interception marker, make sure that's part of the regex pattern\n    // this is to ensure that the route with the interception marker doesn't incorrectly match\n    // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])\n    var interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : \"\";\n    return repeat ? optional ? \"(?:/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?))?\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?)\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">[^/]+?)\";\n}\nfunction getNamedParametrizedRoute(route, prefixRouteKeys) {\n    var segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    var getSafeRouteKey = buildGetSafeRouteKey();\n    var routeKeys = {};\n    return {\n        namedParameterizedRoute: segments.map(function(segment) {\n            var hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some(function(m) {\n                return segment.startsWith(m);\n            });\n            var paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (hasInterceptionMarker && paramMatches) {\n                var _segment_split = _sliced_to_array._(segment.split(paramMatches[0]), 1), usedMarker = _segment_split[0];\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey: getSafeRouteKey,\n                    interceptionMarker: usedMarker,\n                    segment: paramMatches[1],\n                    routeKeys: routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n                });\n            } else if (paramMatches) {\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey: getSafeRouteKey,\n                    segment: paramMatches[1],\n                    routeKeys: routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined\n                });\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        routeKeys: routeKeys\n    };\n}\nfunction getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n    var result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n    return _object_spread_props._(_object_spread._({}, getRouteRegex(normalizedRoute)), {\n        namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n        routeKeys: result.routeKeys\n    });\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n    var parameterizedRoute = getParametrizedRoute(normalizedRoute).parameterizedRoute;\n    var _options_catchAll = options.catchAll, catchAll = _options_catchAll === void 0 ? true : _options_catchAll;\n    if (parameterizedRoute === \"/\") {\n        var catchAllRegex = catchAll ? \".*\" : \"\";\n        return {\n            namedRegex: \"^/\" + catchAllRegex + \"$\"\n        };\n    }\n    var namedParameterizedRoute = getNamedParametrizedRoute(normalizedRoute, false).namedParameterizedRoute;\n    var catchAllGroupedRegex = catchAll ? \"(?:(/.*)?)\" : \"\";\n    return {\n        namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n    };\n} //# sourceMappingURL=route-regex.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMk5nQkEseUJBQXVCLFNBQXZCQTtlQUFBQTs7SUFoQkFDLG9CQUFrQixTQUFsQkE7ZUFBQUE7O0lBbklBQyxlQUFhLFNBQWJBO2VBQUFBOzs7OENBeEUyQjt3Q0FDUjsrQ0FDQztBQUVwQyxJQUFNQywwQkFBMEI7QUFDaEMsSUFBTUMsa0NBQWtDO0FBYXhDOzs7Ozs7O0NBT0MsR0FDRCxTQUFTQyxlQUFlQyxLQUFhO0lBQ25DLElBQU1DLFdBQVdELE1BQU1FLFVBQVUsQ0FBQyxRQUFRRixNQUFNRyxRQUFRLENBQUM7SUFDekQsSUFBSUYsVUFBVTtRQUNaRCxRQUFRQSxNQUFNSSxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQzFCO0lBQ0EsSUFBTUMsU0FBU0wsTUFBTUUsVUFBVSxDQUFDO0lBQ2hDLElBQUlHLFFBQVE7UUFDVkwsUUFBUUEsTUFBTUksS0FBSyxDQUFDO0lBQ3RCO0lBQ0EsT0FBTztRQUFFRSxLQUFLTjtRQUFPSyxRQUFBQTtRQUFRSixVQUFBQTtJQUFTO0FBQ3hDO0FBRUEsU0FBU00scUJBQXFCQyxLQUFhO0lBQ3pDLElBQU1DLFdBQVdDLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBbUIsRUFBQ0YsT0FBT0osS0FBSyxDQUFDLEdBQUdPLEtBQUssQ0FBQztJQUMzRCxJQUFNQyxTQUF5QyxDQUFDO0lBQ2hELElBQUlDLGFBQWE7SUFDakIsT0FBTztRQUNMQyxvQkFBb0JMLFNBQ2pCTSxHQUFHLENBQUMsU0FBQ0M7WUFDSixJQUFNQyxjQUFjQyxvQkFBQUEsMEJBQTBCLENBQUNDLElBQUksQ0FB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Q0YsT0FBTztnQkFDTCxPQUFPLE1BQUkvQixDQUFBQSxHQUFBQSxjQUFBQSxrQkFBa0IsRUFBQ1I7WUFDaEM7UUFDRixHQUNDUyxJQUFJLENBQUM7UUFDUmUsV0FBQUE7SUFDRjtBQUNGO0FBVU8sU0FBUzdDLG1CQUNkK0IsZUFBdUIsRUFDdkI4QixjQUF1QjtJQUV2QixJQUFNQyxTQUFTUiwwQkFBMEJ2QixpQkFBaUI4QjtJQUMxRCxPQUFPLDRDQUNGNUQsY0FBYzhCO1FBQ2pCZ0MsWUFBWSxNQUFJRCxPQUFPTix1QkFBdUIsR0FBQztRQUMvQ1gsV0FBV2lCLE9BQU9qQixTQUFTOztBQUUvQjtBQU1PLFNBQVM5Qyx3QkFDZGdDLGVBQXVCLEVBQ3ZCaUMsT0FFQztJQUVELElBQU0scUJBQXlCcEQscUJBQXFCbUIsaUJBQTVDWjtJQUNSLHdCQUE0QjZDLFFBQXBCQyxVQUFBQSwwQ0FBVztJQUNuQixJQUFJOUMsdUJBQXVCLEtBQUs7UUFDOUIsSUFBSStDLGdCQUFnQkQsV0FBVyxPQUFPO1FBQ3RDLE9BQU87WUFDTEYsWUFBWSxPQUFLRyxnQkFBYztRQUNqQztJQUNGO0lBRUEsSUFBTSwwQkFBOEJaLDBCQUNsQ3ZCLGlCQUNBLE9BRk15QjtJQUlSLElBQUlXLHVCQUF1QkYsV0FBVyxlQUFlO0lBQ3JELE9BQU87UUFDTEYsWUFBWSxNQUFJUCwwQkFBMEJXLHVCQUFxQjtJQUNqRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXgudHM/MTZhMSJdLCJuYW1lcyI6WyJnZXROYW1lZE1pZGRsZXdhcmVSZWdleCIsImdldE5hbWVkUm91dGVSZWdleCIsImdldFJvdXRlUmVnZXgiLCJORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCIsIk5FWFRfSU5URVJDRVBUSU9OX01BUktFUl9QUkVGSVgiLCJwYXJzZVBhcmFtZXRlciIsInBhcmFtIiwib3B0aW9uYWwiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJzbGljZSIsInJlcGVhdCIsImtleSIsImdldFBhcmFtZXRyaXplZFJvdXRlIiwicm91dGUiLCJzZWdtZW50cyIsInJlbW92ZVRyYWlsaW5nU2xhc2giLCJzcGxpdCIsImdyb3VwcyIsImdyb3VwSW5kZXgiLCJwYXJhbWV0ZXJpemVkUm91dGUiLCJtYXAiLCJzZWdtZW50IiwibWFya2VyTWF0Y2giLCJJTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUyIsImZpbmQiLCJtIiwicGFyYW1NYXRjaGVzIiwibWF0Y2giLCJwb3MiLCJlc2NhcGVTdHJpbmdSZWdleHAiLCJqb2luIiwibm9ybWFsaXplZFJvdXRlIiwicmUiLCJSZWdFeHAiLCJidWlsZEdldFNhZmVSb3V0ZUtleSIsImkiLCJyb3V0ZUtleSIsImoiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJNYXRoIiwiZmxvb3IiLCJnZXRTYWZlS2V5RnJvbVNlZ21lbnQiLCJpbnRlcmNlcHRpb25NYXJrZXIiLCJnZXRTYWZlUm91dGVLZXkiLCJyb3V0ZUtleXMiLCJrZXlQcmVmaXgiLCJjbGVhbmVkS2V5IiwicmVwbGFjZSIsImludmFsaWRLZXkiLCJsZW5ndGgiLCJpc05hTiIsInBhcnNlSW50IiwiaW50ZXJjZXB0aW9uUHJlZml4IiwiZ2V0TmFtZWRQYXJhbWV0cml6ZWRSb3V0ZSIsInByZWZpeFJvdXRlS2V5cyIsIm5hbWVkUGFyYW1ldGVyaXplZFJvdXRlIiwiaGFzSW50ZXJjZXB0aW9uTWFya2VyIiwic29tZSIsInVzZWRNYXJrZXIiLCJ1bmRlZmluZWQiLCJwcmVmaXhSb3V0ZUtleSIsInJlc3VsdCIsIm5hbWVkUmVnZXgiLCJvcHRpb25zIiwiY2F0Y2hBbGwiLCJjYXRjaEFsbFJlZ2V4IiwiY2F0Y2hBbGxHcm91cGVkUmVnZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/route-regex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js":
/*!****************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js ***!
  \****************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_class_call_check.js\");\nvar _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_create_class.js\");\nvar _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_to_consumable_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getSortedRoutes\", ({\n    enumerable: true,\n    get: function get() {\n        return getSortedRoutes;\n    }\n}));\nvar UrlNode = /*#__PURE__*/ function() {\n    function UrlNode() {\n        _class_call_check._(this, UrlNode);\n        this.placeholder = true;\n        this.children = new Map();\n        this.slugName = null;\n        this.restSlugName = null;\n        this.optionalRestSlugName = null;\n    }\n    _create_class._(UrlNode, [\n        {\n            key: \"insert\",\n            value: function insert(urlPath) {\n                this._insert(urlPath.split(\"/\").filter(Boolean), [], false);\n            }\n        },\n        {\n            key: \"smoosh\",\n            value: function smoosh() {\n                return this._smoosh();\n            }\n        },\n        {\n            key: \"_smoosh\",\n            value: function _smoosh(prefix) {\n                var _this = this;\n                if (prefix === void 0) prefix = \"/\";\n                var childrenPaths = _to_consumable_array._(this.children.keys()).sort();\n                if (this.slugName !== null) {\n                    childrenPaths.splice(childrenPaths.indexOf(\"[]\"), 1);\n                }\n                if (this.restSlugName !== null) {\n                    childrenPaths.splice(childrenPaths.indexOf(\"[...]\"), 1);\n                }\n                if (this.optionalRestSlugName !== null) {\n                    childrenPaths.splice(childrenPaths.indexOf(\"[[...]]\"), 1);\n                }\n                var routes = childrenPaths.map(function(c) {\n                    return _this.children.get(c)._smoosh(\"\" + prefix + c + \"/\");\n                }).reduce(function(prev, curr) {\n                    return _to_consumable_array._(prev).concat(_to_consumable_array._(curr));\n                }, []);\n                if (this.slugName !== null) {\n                    var _routes;\n                    (_routes = routes).push.apply(_routes, _to_consumable_array._(this.children.get(\"[]\")._smoosh(prefix + \"[\" + this.slugName + \"]/\")));\n                }\n                if (!this.placeholder) {\n                    var r = prefix === \"/\" ? \"/\" : prefix.slice(0, -1);\n                    if (this.optionalRestSlugName != null) {\n                        throw new Error('You cannot define a route with the same specificity as a optional catch-all route (\"' + r + '\" and \"' + r + \"[[...\" + this.optionalRestSlugName + ']]\").');\n                    }\n                    routes.unshift(r);\n                }\n                if (this.restSlugName !== null) {\n                    var _routes1;\n                    (_routes1 = routes).push.apply(_routes1, _to_consumable_array._(this.children.get(\"[...]\")._smoosh(prefix + \"[...\" + this.restSlugName + \"]/\")));\n                }\n                if (this.optionalRestSlugName !== null) {\n                    var _routes2;\n                    (_routes2 = routes).push.apply(_routes2, _to_consumable_array._(this.children.get(\"[[...]]\")._smoosh(prefix + \"[[...\" + this.optionalRestSlugName + \"]]/\")));\n                }\n                return routes;\n            }\n        },\n        {\n            key: \"_insert\",\n            value: function _insert(urlPaths, slugNames, isCatchAll) {\n                if (urlPaths.length === 0) {\n                    this.placeholder = false;\n                    return;\n                }\n                if (isCatchAll) {\n                    throw new Error(\"Catch-all must be the last part of the URL.\");\n                }\n                // The next segment in the urlPaths list\n                var nextSegment = urlPaths[0];\n                // Check if the segment matches `[something]`\n                if (nextSegment.startsWith(\"[\") && nextSegment.endsWith(\"]\")) {\n                    var handleSlug = function handleSlug(previousSlug, nextSlug) {\n                        if (previousSlug !== null) {\n                            // If the specific segment already has a slug but the slug is not `something`\n                            // This prevents collisions like:\n                            // pages/[post]/index.js\n                            // pages/[id]/index.js\n                            // Because currently multiple dynamic params on the same segment level are not supported\n                            if (previousSlug !== nextSlug) {\n                                // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n                                throw new Error(\"You cannot use different slug names for the same dynamic path ('\" + previousSlug + \"' !== '\" + nextSlug + \"').\");\n                            }\n                        }\n                        slugNames.forEach(function(slug) {\n                            if (slug === nextSlug) {\n                                throw new Error('You cannot have the same slug name \"' + nextSlug + '\" repeat within a single dynamic path');\n                            }\n                            if (slug.replace(/\\W/g, \"\") === nextSegment.replace(/\\W/g, \"\")) {\n                                throw new Error('You cannot have the slug names \"' + slug + '\" and \"' + nextSlug + '\" differ only by non-word symbols within a single dynamic path');\n                            }\n                        });\n                        slugNames.push(nextSlug);\n                    };\n                    // Strip `[` and `]`, leaving only `something`\n                    var segmentName = nextSegment.slice(1, -1);\n                    var isOptional = false;\n                    if (segmentName.startsWith(\"[\") && segmentName.endsWith(\"]\")) {\n                        // Strip optional `[` and `]`, leaving only `something`\n                        segmentName = segmentName.slice(1, -1);\n                        isOptional = true;\n                    }\n                    if (segmentName.startsWith(\"...\")) {\n                        // Strip `...`, leaving only `something`\n                        segmentName = segmentName.substring(3);\n                        isCatchAll = true;\n                    }\n                    if (segmentName.startsWith(\"[\") || segmentName.endsWith(\"]\")) {\n                        throw new Error(\"Segment names may not start or end with extra brackets ('\" + segmentName + \"').\");\n                    }\n                    if (segmentName.startsWith(\".\")) {\n                        throw new Error(\"Segment names may not start with erroneous periods ('\" + segmentName + \"').\");\n                    }\n                    if (isCatchAll) {\n                        if (isOptional) {\n                            if (this.restSlugName != null) {\n                                throw new Error('You cannot use both an required and optional catch-all route at the same level (\"[...' + this.restSlugName + ']\" and \"' + urlPaths[0] + '\" ).');\n                            }\n                            handleSlug(this.optionalRestSlugName, segmentName);\n                            // slugName is kept as it can only be one particular slugName\n                            this.optionalRestSlugName = segmentName;\n                            // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n                            nextSegment = \"[[...]]\";\n                        } else {\n                            if (this.optionalRestSlugName != null) {\n                                throw new Error('You cannot use both an optional and required catch-all route at the same level (\"[[...' + this.optionalRestSlugName + ']]\" and \"' + urlPaths[0] + '\").');\n                            }\n                            handleSlug(this.restSlugName, segmentName);\n                            // slugName is kept as it can only be one particular slugName\n                            this.restSlugName = segmentName;\n                            // nextSegment is overwritten to [...] so that it can later be sorted specifically\n                            nextSegment = \"[...]\";\n                        }\n                    } else {\n                        if (isOptional) {\n                            throw new Error('Optional route parameters are not yet supported (\"' + urlPaths[0] + '\").');\n                        }\n                        handleSlug(this.slugName, segmentName);\n                        // slugName is kept as it can only be one particular slugName\n                        this.slugName = segmentName;\n                        // nextSegment is overwritten to [] so that it can later be sorted specifically\n                        nextSegment = \"[]\";\n                    }\n                }\n                // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n                if (!this.children.has(nextSegment)) {\n                    this.children.set(nextSegment, new UrlNode());\n                }\n                this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n            }\n        }\n    ]);\n    return UrlNode;\n}();\nfunction getSortedRoutes(normalizedPages) {\n    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n    // Only 1 dynamic segment per nesting level\n    // So in the case that is test/integration/dynamic-routing it'll be this:\n    // pages/[post]/comments.js\n    // pages/blog/[post]/comment/[id].js\n    // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n    // So in this case `UrlNode` created here has `this.slugName === 'post'`\n    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n    // Instead what has to be passed through is the upwards path's dynamic names\n    var root = new UrlNode();\n    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n    normalizedPages.forEach(function(pagePath) {\n        return root.insert(pagePath);\n    });\n    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n    return root.smoosh();\n} //# sourceMappingURL=sorted-routes.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvc29ydGVkLXJvdXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O21EQXFNZ0JBOzs7ZUFBQUE7OztBQXJNaEI7YUFBTUM7a0NBQUFBO2FBQ0pDLFdBQUFBLEdBQXVCO2FBQ3ZCQyxRQUFBQSxHQUFpQyxJQUFJQzthQUNyQ0MsUUFBQUEsR0FBMEI7YUFDMUJDLFlBQUFBLEdBQThCO2FBQzlCQyxvQkFBQUEsR0FBc0M7O29CQUxsQ047O1lBT0pPLEtBQUFBO21CQUFBQSxTQUFBQSxPQUFPQyxPQUFlO2dCQUNwQixJQUFJLENBQUNDLE9BQU8sQ0FBQ0QsUUFBUUUsS0FBSyxDQUFDLEtBQUtDLE1BQU0sQ0FBQ0MsVUFBVSxFQUFFLEVBQUU7WUFDdkQ7OztZQUVBQyxLQUFBQTttQkFBQUEsU0FBQUE7Z0JBQ0UsT0FBTyxJQUFJLENBQUNDLE9BQU87WUFDckI7OztZQUVRQSxLQUFBQTttQkFBQUEsU0FBQUEsUUFBUUMsTUFBb0I7O2dCQUFwQkEsSUFBQUEsV0FBQUEsS0FBQUEsR0FBQUEsU0FBaUI7Z0JBQy9CLElBQU1DLGdCQUFnQix1QkFBSSxJQUFJLENBQUNkLFFBQVEsQ0FBQ2UsSUFBSSxJQUFJQyxJQUFJO2dCQUNwRCxJQUFJLElBQUksQ0FBQ2QsUUFBUSxLQUFLLE1BQU07b0JBQzFCWSxjQUFjRyxNQUFNLENBQUNILGNBQWNJLE9BQU8sQ0FBQyxPQUFPO2dCQUNwRDtnQkFDQSxJQUFJLElBQUksQ0FBQ2YsWUFBWSxLQUFLLE1BQU07b0JBQzlCVyxjQUFjRyxNQUFNLENBQUNILGNBQWNJLE9BQU8sQ0FBQyxVQUFVO2dCQUN2RDtnQkFDQSxJQUFJLElBQUksQ0FBQ2Qsb0JBQW9CLEtB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S3ZDLE1BQU07QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9zb3J0ZWQtcm91dGVzLnRzP2Q1M2IiXSwibmFtZXMiOlsiZ2V0U29ydGVkUm91dGVzIiwiVXJsTm9kZSIsInBsYWNlaG9sZGVyIiwiY2hpbGRyZW4iLCJNYXAiLCJzbHVnTmFtZSIsInJlc3RTbHVnTmFtZSIsIm9wdGlvbmFsUmVzdFNsdWdOYW1lIiwiaW5zZXJ0IiwidXJsUGF0aCIsIl9pbnNlcnQiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJzbW9vc2giLCJfc21vb3NoIiwicHJlZml4IiwiY2hpbGRyZW5QYXRocyIsImtleXMiLCJzb3J0Iiwic3BsaWNlIiwiaW5kZXhPZiIsInJvdXRlcyIsIm1hcCIsImMiLCJnZXQiLCJyZWR1Y2UiLCJwcmV2IiwiY3VyciIsInB1c2giLCJyIiwic2xpY2UiLCJFcnJvciIsInVuc2hpZnQiLCJ1cmxQYXRocyIsInNsdWdOYW1lcyIsImlzQ2F0Y2hBbGwiLCJsZW5ndGgiLCJuZXh0U2VnbWVudCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsImhhbmRsZVNsdWciLCJwcmV2aW91c1NsdWciLCJuZXh0U2x1ZyIsImZvckVhY2giLCJzbHVnIiwicmVwbGFjZSIsInNlZ21lbnROYW1lIiwiaXNPcHRpb25hbCIsInN1YnN0cmluZyIsImhhcyIsInNldCIsIm5vcm1hbGl6ZWRQYWdlcyIsInJvb3QiLCJwYWdlUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/side-effect.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/side-effect.js ***!
  \*************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function get() {\n        return SideEffect;\n    }\n}));\nvar _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\nvar isServer = typeof window === \"undefined\";\nvar useClientOnlyLayoutEffect = isServer ? function() {} : _react.useLayoutEffect;\nvar useClientOnlyEffect = isServer ? function() {} : _react.useEffect;\nfunction SideEffect(props) {\n    _s();\n    var headManager = props.headManager, reduceComponentsToState = props.reduceComponentsToState;\n    function emitChange() {\n        if (headManager && headManager.mountedInstances) {\n            var headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n            headManager.updateHead(reduceComponentsToState(headElements, props));\n        }\n    }\n    if (isServer) {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        emitChange();\n    }\n    useClientOnlyLayoutEffect(function() {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        return function() {\n            var _headManager_mountedInstances;\n            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances[\"delete\"](props.children);\n        };\n    });\n    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n    // being rendered, we only trigger the method from the last one.\n    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n    // singleton in the layout effect pass, and actually trigger it in the effect pass.\n    useClientOnlyLayoutEffect(function() {\n        if (headManager) {\n            headManager._pendingUpdate = emitChange;\n        }\n        return function() {\n            if (headManager) {\n                headManager._pendingUpdate = emitChange;\n            }\n        };\n    });\n    useClientOnlyEffect(function() {\n        if (headManager && headManager._pendingUpdate) {\n            headManager._pendingUpdate();\n            headManager._pendingUpdate = null;\n        }\n        return function() {\n            if (headManager && headManager._pendingUpdate) {\n                headManager._pendingUpdate();\n                headManager._pendingUpdate = null;\n            }\n        };\n    });\n    return null;\n} //# sourceMappingURL=side-effect.js.map\n_s(SideEffect, \"gHVkikNHNxjVdD11eJBzaqkCiPY=\", false, function() {\n    return [\n        useClientOnlyLayoutEffect,\n        useClientOnlyLayoutEffect,\n        useClientOnlyEffect\n    ];\n});\n_c = SideEffect;\nvar _c;\n$RefreshReg$(_c, \"SideEffect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9zaWRlLWVmZmVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7MkNBb0JBOzs7ZUFBd0JBOzs7aUNBbkI2QjtBQWVyRCxJQUFNQyxXQUFXLE9BQU9DLFdBQVc7QUFDbkMsSUFBTUMsNEJBQTRCRixXQUFXLFlBQU8sSUFBSUcsT0FBQUEsZUFBZTtBQUN2RSxJQUFNQyxzQkFBc0JKLFdBQVcsWUFBTyxJQUFJSyxPQUFBQSxTQUFTO0FBRTVDLFNBQVNOLFdBQVdPLEtBQXNCOztJQUN2RCxJQUFRQyxjQUF5Q0QsTUFBekNDLGFBQWFDLDBCQUE0QkYsTUFBNUJFO0lBRXJCLFNBQVNDO1FBQ1AsSUFBSUYsZUFBZUEsWUFBWUcsZ0JBQWdCLEVBQUU7WUFDL0MsSUFBTUMsZUFBZUMsT0FBQUEsUUFBUSxDQUFDQyxPQUFPLENBQ25DQyxNQUFNQyxJQUFJLENBQUNSLFlBQVlHLGdCQUFnQixFQUEwQk0sTUFBTSxDQUNyRUM7WUFHSlYsWUFBWVcsVUFBVSxDQUFDVix3QkFBd0JHLGNBQWNMO1FBQy9EO0lBQ0Y7SUFFQSxJQUFJTixVQUFVO1lBQ1pPO1FBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBZ0IscUJBQTdCSCw4QkFBK0JZLEdBQUcsQ0FBQ2IsTUFBTWMsUUFBUTtRQUNqRFg7SUFDRjtJQUVBUCwwQkFBMEI7WUFDeEJLO1FBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBZ0IscUJBQTdCSCw4QkFBK0JZLEdBQUcsQ0FBQ2IsTUFBTWMsUUFBUTtRQUNqRCxPQUFPO2dCQUNMYjtZQUFBQSxlQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSxnQ0FBQUEsWUFBYUcsZ0JBQWdCLHFCQUE3QkgsNkJBQStCYyxDQUFBQSxTQUFNLENBQUNmLE1BQU1jLFFBQVE7UUFDdEQ7SUFDRjtJQUVBLGtGQUFrRjtJQUNsRixvRkFBb0Y7SUFDcEYsZ0VBQWdFO0lBQ2hFLHFGQUFxRjtJQUNyRixtRkFBbUY7SUFDbkZsQiwwQkFBMEI7UUFDeEIsSUFBSUssYUFBYTtZQUNmQSxZQUFZZSxjQUFjLEdBQUdiO1FBQy9CO1FBQ0EsT0FBTztZQUNMLElBQUlGLGFBQWE7Z0JBQ2ZBLFlBQVllLGNBQWMsR0FBR2I7WUFDL0I7UUFDRjtJQUNGO0lBRUFMLG9CQUFvQjtRQUNsQixJQUFJRyxlQUFlQSxZQUFZZSxjQUFjLEVBQUU7WUFDN0NmLFlBQVllLGNBQWM7WUFDMUJmLFlBQVllLGNBQWMsR0FBRztRQUMvQjtRQUNBLE9BQU87WUFDTCxJQUFJZixlQUFlQSxZQUFZZSxjQUFjLEVBQUU7Z0JBQzdDZixZQUFZZSxjQUFjO2dCQUMxQmYsWUFBWWUsY0FBYyxHQUFHO1lBQy9CO1FBQ0Y7SUFDRjtJQUVBLE9BQU87QUFDVDtHQXhEd0J2Qjs7UUFtQnRCRztRQVlBQTtRQVdBRTs7O0tBMUNzQkwiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3NpZGUtZWZmZWN0LnRzeD9lOGRkIl0sIm5hbWVzIjpbIlNpZGVFZmZlY3QiLCJpc1NlcnZlciIsIndpbmRvdyIsInVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VDbGllbnRPbmx5RWZmZWN0IiwidXNlRWZmZWN0IiwicHJvcHMiLCJoZWFkTWFuYWdlciIsInJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIiwiZW1pdENoYW5nZSIsIm1vdW50ZWRJbnN0YW5jZXMiLCJoZWFkRWxlbWVudHMiLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJBcnJheSIsImZyb20iLCJmaWx0ZXIiLCJCb29sZWFuIiwidXBkYXRlSGVhZCIsImFkZCIsImNoaWxkcmVuIiwiZGVsZXRlIiwiX3BlbmRpbmdVcGRhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/side-effect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils.js":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils.js ***!
  \*******************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _async_to_generator = __webpack_require__(/*! @swc/helpers/_/_async_to_generator */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_async_to_generator.js\");\nvar _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_class_call_check.js\");\nvar _inherits = __webpack_require__(/*! @swc/helpers/_/_inherits */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_inherits.js\");\nvar _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_to_consumable_array.js\");\nvar _wrap_native_super = __webpack_require__(/*! @swc/helpers/_/_wrap_native_super */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_wrap_native_super.js\");\nvar _create_super = __webpack_require__(/*! @swc/helpers/_/_create_super */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_create_super.js\");\nvar _ts_generator = __webpack_require__(/*! @swc/helpers/_/_ts_generator */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_ts_generator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DecodeError: function DecodeError1() {\n        return DecodeError;\n    },\n    MiddlewareNotFoundError: function MiddlewareNotFoundError1() {\n        return MiddlewareNotFoundError;\n    },\n    MissingStaticPage: function MissingStaticPage1() {\n        return MissingStaticPage;\n    },\n    NormalizeError: function NormalizeError1() {\n        return NormalizeError;\n    },\n    PageNotFoundError: function PageNotFoundError1() {\n        return PageNotFoundError;\n    },\n    SP: function SP1() {\n        return SP;\n    },\n    ST: function ST1() {\n        return ST;\n    },\n    WEB_VITALS: function WEB_VITALS1() {\n        return WEB_VITALS;\n    },\n    execOnce: function execOnce1() {\n        return execOnce;\n    },\n    getDisplayName: function getDisplayName1() {\n        return getDisplayName;\n    },\n    getLocationOrigin: function getLocationOrigin1() {\n        return getLocationOrigin;\n    },\n    getURL: function getURL1() {\n        return getURL;\n    },\n    isAbsoluteUrl: function isAbsoluteUrl1() {\n        return isAbsoluteUrl;\n    },\n    isResSent: function isResSent1() {\n        return isResSent;\n    },\n    loadGetInitialProps: function loadGetInitialProps1() {\n        return loadGetInitialProps;\n    },\n    normalizeRepeatedSlashes: function normalizeRepeatedSlashes1() {\n        return normalizeRepeatedSlashes;\n    },\n    stringifyError: function stringifyError1() {\n        return stringifyError;\n    }\n});\nvar WEB_VITALS = [\n    \"CLS\",\n    \"FCP\",\n    \"FID\",\n    \"INP\",\n    \"LCP\",\n    \"TTFB\"\n];\nfunction execOnce(fn) {\n    var used = false;\n    var result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn.apply(void 0, _to_consumable_array._(args));\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nvar ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nvar isAbsoluteUrl = function(url) {\n    return ABSOLUTE_URL_REGEX.test(url);\n};\nfunction getLocationOrigin() {\n    var _window_location = window.location, protocol = _window_location.protocol, hostname = _window_location.hostname, port = _window_location.port;\n    return protocol + \"//\" + hostname + (port ? \":\" + port : \"\");\n}\nfunction getURL() {\n    var href = window.location.href;\n    var origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === \"string\" ? Component : Component.displayName || Component.name || \"Unknown\";\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    var urlParts = url.split(\"?\");\n    var urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, \"/\").replace(/\\/\\/+/g, \"/\") + (urlParts[1] ? \"?\" + urlParts.slice(1).join(\"?\") : \"\");\n}\nfunction loadGetInitialProps(App, ctx) {\n    return _loadGetInitialProps.apply(this, arguments);\n}\nfunction _loadGetInitialProps() {\n    _loadGetInitialProps = _async_to_generator._(function(App, ctx) {\n        var _App_prototype, message, res, _tmp, props, message1;\n        return _ts_generator._(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    if (true) {\n                        ;\n                        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {\n                            message = '\"' + getDisplayName(App) + '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';\n                            throw new Error(message);\n                        }\n                    }\n                    // when called from _app `ctx` is nested in `ctx`\n                    res = ctx.res || ctx.ctx && ctx.ctx.res;\n                    if (!!App.getInitialProps) return [\n                        3,\n                        3\n                    ];\n                    if (!(ctx.ctx && ctx.Component)) return [\n                        3,\n                        2\n                    ];\n                    _tmp = {};\n                    return [\n                        4,\n                        loadGetInitialProps(ctx.Component, ctx.ctx)\n                    ];\n                case 1:\n                    // @ts-ignore pageProps default\n                    return [\n                        2,\n                        (_tmp.pageProps = _state.sent(), _tmp)\n                    ];\n                case 2:\n                    return [\n                        2,\n                        {}\n                    ];\n                case 3:\n                    return [\n                        4,\n                        App.getInitialProps(ctx)\n                    ];\n                case 4:\n                    props = _state.sent();\n                    if (res && isResSent(res)) {\n                        return [\n                            2,\n                            props\n                        ];\n                    }\n                    if (!props) {\n                        message1 = '\"' + getDisplayName(App) + '.getInitialProps()\" should resolve to an object. But found \"' + props + '\" instead.';\n                        throw new Error(message1);\n                    }\n                    if (true) {\n                        if (Object.keys(props).length === 0 && !ctx.ctx) {\n                            console.warn(\"\" + getDisplayName(App) + \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\");\n                        }\n                    }\n                    return [\n                        2,\n                        props\n                    ];\n            }\n        });\n    });\n    return _loadGetInitialProps.apply(this, arguments);\n}\nvar SP = typeof performance !== \"undefined\";\nvar ST = SP && [\n    \"mark\",\n    \"measure\",\n    \"getEntriesByName\"\n].every(function(method) {\n    return typeof performance[method] === \"function\";\n});\nvar DecodeError = /*#__PURE__*/ function(Error1) {\n    _inherits._(DecodeError, Error1);\n    var _super = _create_super._(DecodeError);\n    function DecodeError() {\n        _class_call_check._(this, DecodeError);\n        return _super.apply(this, arguments);\n    }\n    return DecodeError;\n}(_wrap_native_super._(Error));\nvar NormalizeError = /*#__PURE__*/ function(Error1) {\n    _inherits._(NormalizeError, Error1);\n    var _super = _create_super._(NormalizeError);\n    function NormalizeError() {\n        _class_call_check._(this, NormalizeError);\n        return _super.apply(this, arguments);\n    }\n    return NormalizeError;\n}(_wrap_native_super._(Error));\nvar PageNotFoundError = /*#__PURE__*/ function(Error1) {\n    _inherits._(PageNotFoundError, Error1);\n    var _super = _create_super._(PageNotFoundError);\n    function PageNotFoundError(page) {\n        _class_call_check._(this, PageNotFoundError);\n        var _this;\n        _this = _super.call(this);\n        _this.code = \"ENOENT\";\n        _this.name = \"PageNotFoundError\";\n        _this.message = \"Cannot find module for page: \" + page;\n        return _this;\n    }\n    return PageNotFoundError;\n}(_wrap_native_super._(Error));\nvar MissingStaticPage = /*#__PURE__*/ function(Error1) {\n    _inherits._(MissingStaticPage, Error1);\n    var _super = _create_super._(MissingStaticPage);\n    function MissingStaticPage(page, message) {\n        _class_call_check._(this, MissingStaticPage);\n        var _this;\n        _this = _super.call(this);\n        _this.message = \"Failed to load static file for page: \" + page + \" \" + message;\n        return _this;\n    }\n    return MissingStaticPage;\n}(_wrap_native_super._(Error));\nvar MiddlewareNotFoundError = /*#__PURE__*/ function(Error1) {\n    _inherits._(MiddlewareNotFoundError, Error1);\n    var _super = _create_super._(MiddlewareNotFoundError);\n    function MiddlewareNotFoundError() {\n        _class_call_check._(this, MiddlewareNotFoundError);\n        var _this;\n        _this = _super.call(this);\n        _this.code = \"ENOENT\";\n        _this.message = \"Cannot find the middleware module\";\n        return _this;\n    }\n    return MiddlewareNotFoundError;\n}(_wrap_native_super._(Error));\nfunction stringifyError(error) {\n    return JSON.stringify({\n        message: error.message,\n        stack: error.stack\n    });\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBb2FhQSxhQUFXLFNBQVhBO2VBQUFBOztJQW9CQUMseUJBQXVCLFNBQXZCQTtlQUFBQTs7SUFQQUMsbUJBQWlCLFNBQWpCQTtlQUFBQTs7SUFaQUMsZ0JBQWMsU0FBZEE7ZUFBQUE7O0lBQ0FDLG1CQUFpQixTQUFqQkE7ZUFBQUE7O0lBVEFDLElBQUUsU0FBRkE7ZUFBQUE7O0lBQ0FDLElBQUUsU0FBRkE7ZUFBQUE7O0lBbFhBQyxZQUFVLFNBQVZBO2VBQUFBOztJQXNRR0MsVUFBUSxTQUFSQTtlQUFBQTs7SUErQkFDLGdCQUFjLFNBQWRBO2VBQUFBOztJQVhBQyxtQkFBaUIsU0FBakJBO2VBQUFBOztJQUtBQyxRQUFNLFNBQU5BO2VBQUFBOztJQVBIQyxlQUFhLFNBQWJBO2VBQUFBOztJQW1CR0MsV0FBUyxTQUFUQTtlQUFBQTs7SUFrQk1DLHFCQUFtQixTQUFuQkE7ZUFBQUE7O0lBZE5DLDBCQUF3QixTQUF4QkE7ZUFBQUE7O0lBK0dBQyxnQkFBYyxTQUFkQTtlQUFBQTs7O0FBOVpULElBQU1ULGFBQWE7SUFBQztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87Q0FBTztBQXNROUQsU0FBU0MsU0FDZFMsRUFBSztJQUVMLElBQUlDLE9BQU87SUFDWCxJQUFJQztJQUVKLE9BQVE7eUNBQUlDLE9BQUFBLElBQUFBLE1BQUFBLE9BQUFBLE9BQUFBLEdBQUFBLE9BQUFBLE1BQUFBLE9BQUFBO1lBQUFBLElBQUFBLENBQUFBLEtBQUFBLEdBQUFBLFNBQUFBLENBQUFBLEtBQUFBOztRQUNWLElBQUksQ0FBQ0YsTUFBTTtZQUNUQSxPQUFP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SUFBTVQsS0FBSyxPQUFPcUQsZ0JBQWdCO0FBQ2xDLElBQU1wRCxLQUNYRCxNQUNBO0lBQUU7SUFBUTtJQUFXO0NBQW1CLENBQVdzRCxLQUFLLENBQ3RELFNBQUNDO1dBQVcsT0FBT0YsV0FBVyxDQUFDRSxPQUFPLEtBQUs7O0FBR3hDO2dCQUFNNUQ7aUNBQUFBO2FBQUFBO2tDQUFBQTs7O1dBQUFBO3VCQUFvQm9EO0FBQzFCO2dCQUFNakQ7aUNBQUFBO2FBQUFBO2tDQUFBQTs7O1dBQUFBO3VCQUF1QmlEO0FBQzdCO2dCQUFNaEQ7aUNBQUFBO2FBQUFBLGtCQUdDeUQsSUFBWTtrQ0FIYnpEOzs7UUFLVCxNQUFLMEQsSUFBSSxHQUFHO1FBQ1osTUFBSzNCLElBQUksR0FBRztRQUNaLE1BQUtZLE9BQU8sR0FBRyxrQ0FBZ0NjOzs7V0FQdEN6RDt1QkFBMEJnRDtBQVdoQztnQkFBTWxEO2lDQUFBQTthQUFBQSxrQkFDQzJELElBQVksRUFBRWQsT0FBZTtrQ0FEOUI3Qzs7O1FBR1QsTUFBSzZDLE9BQU8sR0FBRywwQ0FBd0NjLE9BQUssTUFBR2Q7OztXQUh0RDdDO3VCQUEwQmtEO0FBT2hDO2dCQUFNbkQ7aUNBQUFBO2FBQUFBO2tDQUFBQTs7O1FBSVQsTUFBSzZELElBQUksR0FBRztRQUNaLE1BQUtmLE9BQU8sR0FBSTs7O1dBTFA5Qzt1QkFBZ0NtRDtBQWtCdEMsU0FBU3BDLGVBQWUrQyxLQUFZO0lBQ3pDLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQztRQUFFbEIsU0FBU2dCLE1BQU1oQixPQUFPO1FBQUVtQixPQUFPSCxNQUFNRyxLQUFLO0lBQUM7QUFDckUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3V0aWxzLnRzPzFiZDUiXSwibmFtZXMiOlsiRGVjb2RlRXJyb3IiLCJNaWRkbGV3YXJlTm90Rm91bmRFcnJvciIsIk1pc3NpbmdTdGF0aWNQYWdlIiwiTm9ybWFsaXplRXJyb3IiLCJQYWdlTm90Rm91bmRFcnJvciIsIlNQIiwiU1QiLCJXRUJfVklUQUxTIiwiZXhlY09uY2UiLCJnZXREaXNwbGF5TmFtZSIsImdldExvY2F0aW9uT3JpZ2luIiwiZ2V0VVJMIiwiaXNBYnNvbHV0ZVVybCIsImlzUmVzU2VudCIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMiLCJzdHJpbmdpZnlFcnJvciIsImZuIiwidXNlZCIsInJlc3VsdCIsImFyZ3MiLCJBQlNPTFVURV9VUkxfUkVHRVgiLCJ1cmwiLCJ0ZXN0Iiwid2luZG93IiwibG9jYXRpb24iLCJwcm90b2NvbCIsImhvc3RuYW1lIiwicG9ydCIsImhyZWYiLCJvcmlnaW4iLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJDb21wb25lbnQiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJyZXMiLCJmaW5pc2hlZCIsImhlYWRlcnNTZW50IiwidXJsUGFydHMiLCJzcGxpdCIsInVybE5vUXVlcnkiLCJyZXBsYWNlIiwic2xpY2UiLCJqb2luIiwiQXBwIiwiY3R4IiwibWVzc2FnZSIsInByb3BzIiwicHJvY2VzcyIsInByb3RvdHlwZSIsImdldEluaXRpYWxQcm9wcyIsIkVycm9yIiwicGFnZVByb3BzIiwiT2JqZWN0Iiwia2V5cyIsImNvbnNvbGUiLCJ3YXJuIiwicGVyZm9ybWFuY2UiLCJldmVyeSIsIm1ldGhvZCIsInBhZ2UiLCJjb2RlIiwiZXJyb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/shared/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/about/About.tsx":
/*!****************************************!*\
  !*** ./src/components/about/About.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   About: function() { return /* binding */ About; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/image.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/link.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _text_wrap_TextWrap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../text-wrap/TextWrap */ \"(app-pages-browser)/./src/components/text-wrap/TextWrap.tsx\");\n/* harmony import */ var _text_wrap_TextWrapItem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../text-wrap/TextWrapItem */ \"(app-pages-browser)/./src/components/text-wrap/TextWrapItem.tsx\");\n/* harmony import */ var _ui_button_Button__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../ui/button/Button */ \"(app-pages-browser)/./src/components/ui/button/Button.tsx\");\n/* harmony import */ var _ui_container_Container__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../ui/container/Container */ \"(app-pages-browser)/./src/components/ui/container/Container.tsx\");\n/* harmony import */ var _About_module_scss__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./About.module.scss */ \"(app-pages-browser)/./src/components/about/About.module.scss\");\n/* harmony import */ var _About_module_scss__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_About_module_scss__WEBPACK_IMPORTED_MODULE_9__);\n/* __next_internal_client_entry_do_not_use__ About auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\nvar text = [\n    {\n        image: \"/repText1.svg\"\n    },\n    {\n        image: \"/repText2.svg\"\n    }\n];\nvar aboutInfo = [\n    {\n        texts: [\n            \"RBand c        ,       .\",\n            \"     ,  ,          -.\"\n        ],\n        button: {\n            text: \" \",\n            href: \"#\"\n        }\n    },\n    {\n        texts: [\n            \"       .            .\"\n        ],\n        button: {\n            text: \"  \",\n            href: \"#\"\n        }\n    }\n];\nvar textReputation = [\n    {\n        numbers: \"1200+\",\n        text: \"    -\"\n    },\n    {\n        numbers: \"12+\",\n        text: \"  web-  \"\n    },\n    {\n        numbers: \"10+\",\n        text: \"     \"\n    },\n    {\n        numbers: \"260+\",\n        text: \"  \"\n    }\n];\nvar projects = [\n    {\n        image: \"/home-projects/1.svg\",\n        name: \" \",\n        text: \"        \",\n        href: \"#\"\n    },\n    {\n        image: \"/home-projects/2.svg\",\n        name: \" \",\n        text: \"        \",\n        href: \"#\"\n    },\n    {\n        image: \"/home-projects/3.svg\",\n        name: \" \",\n        text: \"        \",\n        href: \"#\"\n    },\n    {\n        image: \"/home-projects/4.svg\",\n        name: \" \",\n        text: \"        \",\n        href: \"#\"\n    },\n    {\n        image: \"/home-projects/5.svg\",\n        name: \" \",\n        text: \"        \",\n        href: \"#\"\n    },\n    {\n        image: \"/home-projects/6.svg\",\n        name: \" \",\n        text: \"        \",\n        href: \"#\"\n    },\n    {\n        image: \"/home-projects/7.svg\",\n        name: \" \",\n        text: \"        \",\n        href: \"#\"\n    },\n    {\n        image: \"/home-projects/8.svg\",\n        name: \" \",\n        text: \"        \",\n        href: \"#\"\n    },\n    {\n        image: \"/home-projects/9.svg\",\n        name: \" \",\n        text: \"        \",\n        href: \"#\"\n    },\n    {\n        image: \"/home-projects/10.svg\",\n        name: \" \",\n        text: \"        \",\n        href: \"#\"\n    },\n    {\n        image: \"/home-projects/11.svg\",\n        name: \" \",\n        text: \"        \",\n        href: \"#\"\n    },\n    {\n        image: \"/home-projects/12.svg\",\n        name: \" \",\n        text: \"        \",\n        href: \"#\"\n    },\n    {\n        image: \"/home-projects/13.svg\",\n        name: \" \",\n        text: \"        \",\n        href: \"#\"\n    },\n    {\n        image: \"/home-projects/14.svg\",\n        name: \" \",\n        text: \"        \",\n        href: \"#\"\n    }\n];\nfunction About() {\n    var _this = this;\n    _s();\n    var textRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null);\n    var router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter)();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n        className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about),\n        children: [\n            text.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_text_wrap_TextWrap__WEBPACK_IMPORTED_MODULE_5__.TextWrap, {\n                id: \"about-text-wrap\",\n                className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__textWrap),\n                ref: textRef,\n                children: text.map(function(t, i) {\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_text_wrap_TextWrapItem__WEBPACK_IMPORTED_MODULE_6__.TextWrapItem, {\n                        image: t.image,\n                        index: i,\n                        reference: textRef,\n                        id: \"#about-text-wrap\"\n                    }, i, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                        lineNumber: 164,\n                        columnNumber: 8\n                    }, _this);\n                })\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                lineNumber: 157,\n                columnNumber: 5\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_container_Container__WEBPACK_IMPORTED_MODULE_8__.Container, {\n                variant: \"xl\",\n                className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__container),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__info),\n                        children: aboutInfo.length > 0 && aboutInfo.map(function(about, index) {\n                            return about.texts.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__block),\n                                children: [\n                                    about.texts.map(function(text, i) {\n                                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__blockText),\n                                            children: text\n                                        }, i, false, {\n                                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                            lineNumber: 189,\n                                            columnNumber: 12\n                                        }, _this);\n                                    }),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_button_Button__WEBPACK_IMPORTED_MODULE_7__.Button, {\n                                        className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__blockButton),\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            onClick: function() {\n                                                return router.push(about.button.href);\n                                            },\n                                            children: about.button.text\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                            lineNumber: 197,\n                                            columnNumber: 12\n                                        }, _this)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                        lineNumber: 196,\n                                        columnNumber: 11\n                                    }, _this)\n                                ]\n                            }, index, true, {\n                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                lineNumber: 184,\n                                columnNumber: 10\n                            }, _this);\n                        })\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                        lineNumber: 179,\n                        columnNumber: 5\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__content),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__contentHead),\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__contentHeadVideo),\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                                                src: \"/about-img.png\",\n                                                alt: \"about images\",\n                                                fill: true,\n                                                sizes: \"100vw\",\n                                                objectFit: \"cover\",\n                                                objectPosition: \"center\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                                lineNumber: 209,\n                                                columnNumber: 8\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"video\", {\n                                                loop: true,\n                                                autoPlay: true,\n                                                preload: \"auto\",\n                                                muted: true,\n                                                playsInline: true,\n                                                controls: false,\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"source\", {\n                                                    src: \"/about-video.mp4\",\n                                                    type: \"video/mp4\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                                    lineNumber: 225,\n                                                    columnNumber: 9\n                                                }, this)\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                                lineNumber: 217,\n                                                columnNumber: 8\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                        lineNumber: 208,\n                                        columnNumber: 7\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__contentHeadReputation),\n                                        children: textReputation.map(function(rep, index) {\n                                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__contentHeadReputationItem),\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                                            children: rep.numbers\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                                            lineNumber: 238,\n                                                            columnNumber: 11\n                                                        }, _this)\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                                        lineNumber: 237,\n                                                        columnNumber: 10\n                                                    }, _this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                        children: rep.text\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                                        lineNumber: 240,\n                                                        columnNumber: 10\n                                                    }, _this)\n                                                ]\n                                            }, index, true, {\n                                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                                lineNumber: 233,\n                                                columnNumber: 9\n                                            }, _this);\n                                        })\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                        lineNumber: 231,\n                                        columnNumber: 7\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                lineNumber: 207,\n                                columnNumber: 6\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__contentProjects),\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__contentProjectsMobile),\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h6\", {\n                                                className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__contentProjectsMobileTitle),\n                                                children: [\n                                                    \" \",\n                                                    projects.length,\n                                                    \"  \"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                                lineNumber: 247,\n                                                columnNumber: 8\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__contentProjectsMobileText),\n                                                children: \" ,  .\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                                lineNumber: 250,\n                                                columnNumber: 8\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_button_Button__WEBPACK_IMPORTED_MODULE_7__.Button, {\n                                                className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__contentProjectsButton),\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    onClick: function() {\n                                                        return router.push(\"/reviews\");\n                                                    },\n                                                    children: \"  \"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                                    lineNumber: 254,\n                                                    columnNumber: 9\n                                                }, this)\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                                lineNumber: 253,\n                                                columnNumber: 8\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                        lineNumber: 246,\n                                        columnNumber: 7\n                                    }, this),\n                                    projects.length > 0 && projects.map(function(project, index) {\n                                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__contentProjectsItem),\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__contentProjectsItemLogo),\n                                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                                                        src: project.image,\n                                                        alt: project.name,\n                                                        width: 260,\n                                                        height: 130\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                                        lineNumber: 267,\n                                                        columnNumber: 11\n                                                    }, _this)\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                                    lineNumber: 266,\n                                                    columnNumber: 10\n                                                }, _this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__contentProjectsItemContent),\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h6\", {\n                                                            className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__contentProjectsItemTitle),\n                                                            children: project.name\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                                            lineNumber: 275,\n                                                            columnNumber: 11\n                                                        }, _this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                            className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__contentProjectsItemText),\n                                                            children: project.text\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                                            lineNumber: 278,\n                                                            columnNumber: 11\n                                                        }, _this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                            className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__contentProjectsItemMore),\n                                                            children: \" \"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                                            lineNumber: 281,\n                                                            columnNumber: 11\n                                                        }, _this)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                                    lineNumber: 274,\n                                                    columnNumber: 10\n                                                }, _this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                                    href: project.href,\n                                                    className: (_About_module_scss__WEBPACK_IMPORTED_MODULE_9___default().about__contentProjectsItemLink),\n                                                    target: \"_blank\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                                    lineNumber: 285,\n                                                    columnNumber: 10\n                                                }, _this)\n                                            ]\n                                        }, index, true, {\n                                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                            lineNumber: 262,\n                                            columnNumber: 9\n                                        }, _this);\n                                    })\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                                lineNumber: 245,\n                                columnNumber: 6\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                        lineNumber: 206,\n                        columnNumber: 5\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n                lineNumber: 175,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\about\\\\About.tsx\",\n        lineNumber: 155,\n        columnNumber: 3\n    }, this);\n}\n_s(About, \"zvl0WPesqbiIdYScawps83Ay9wQ=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter\n    ];\n});\n_c = About;\nvar _c;\n$RefreshReg$(_c, \"About\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Fib3V0L0Fib3V0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFOEI7QUFDRjtBQUNlO0FBQ2I7QUFFa0I7QUFDUTtBQUNaO0FBQ1M7QUFFWjtBQUV6QyxJQUFNUyxPQUFPO0lBQ1o7UUFDQ0MsT0FBTztJQUNSO0lBQ0E7UUFDQ0EsT0FBTztJQUNSO0NBQ0E7QUFFRCxJQUFNQyxZQUFZO0lBQ2pCO1FBQ0NDLE9BQU87WUFDTjtZQUNBO1NBQ0E7UUFDREMsUUFBUTtZQUNQSixNQUFNO1lBQ05LLE1BQU07UUFDUDtJQUNEO0lBQ0E7UUFDQ0YsT0FBTztZQUNOO1NBQ0E7UUFDREMsUUFBUTtZQUNQSixNQUFNO1lBQ05LLE1BQU07UUFDUDtJQUNEO0NBQ0E7QUFFRCxJQUFNQyxpQkFBaUI7SUFDdEI7UUFDQ0MsU0FBUztRQUNUUCxNQUFNO0lBQ1A7SUFDQTtRQUNDTyxTQUFTO1FBQ1RQLE1BQU07SUFDUDtJQUNBO1FBQ0NPLFNBQVM7UUFDVFAsTUFBTTtJQUNQO0lBQ0E7UUFDQ08sU0FBUztRQUNUUCxNQUFNO0lBQ1A7Q0FDQTtBQUVELElBQU1RLFdBQVc7SUFDaEI7UUFDQ1AsT0FBTztRQUNQUSxNQUFNO1FBQ05ULE1BQU07UUFDTkssTUFBTTtJQUNQO0lBQ0E7UUFDQ0osT0FBTztRQUNQUSxNQUFNO1FBQ05ULE1BQU07UUFDTkssTUFBTTtJQUNQO0lBQ0E7UUFDQ0osT0FBTztRQUNQUSxNQUFNO1FBQ05ULE1BQU07UUFDTkssTUFBTTtJQUNQO0lBQ0E7UUFDQ0osT0FBTztRQUNQUSxNQUFNO1FBQ05ULE1BQU07UUFDTkssTUFBTTtJQUNQO0lBQ0E7UUFDQ0osT0FBTztRQUNQUSxNQUFNO1FBQ05ULE1BQU07UUFDTkssTUFBTTtJQUNQO0lBQ0E7UUFDQ0osT0FBTztRQUNQUSxNQUFNO1FBQ05ULE1BQU07UUFDTkssTUFBTTtJQUNQO0lBQ0E7UUFDQ0osT0FBTztRQUNQUSxNQUFN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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ2Q7R0FsSmdCYjs7UUFFQWpCLHNEQUFTQTs7O0tBRlRpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9hYm91dC9BYm91dC50c3g/NjI0MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCBJbWFnZSBmcm9tICduZXh0L2ltYWdlJ1xyXG5pbXBvcnQgTGluayBmcm9tICduZXh0L2xpbmsnXHJcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvbmF2aWdhdGlvbidcclxuaW1wb3J0IHsgdXNlUmVmIH0gZnJvbSAncmVhY3QnXHJcblxyXG5pbXBvcnQgeyBUZXh0V3JhcCB9IGZyb20gJy4uL3RleHQtd3JhcC9UZXh0V3JhcCdcclxuaW1wb3J0IHsgVGV4dFdyYXBJdGVtIH0gZnJvbSAnLi4vdGV4dC13cmFwL1RleHRXcmFwSXRlbSdcclxuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSAnLi4vdWkvYnV0dG9uL0J1dHRvbidcclxuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi4vdWkvY29udGFpbmVyL0NvbnRhaW5lcidcclxuXHJcbmltcG9ydCBjbGFzc2VzIGZyb20gJy4vQWJvdXQubW9kdWxlLnNjc3MnXHJcblxyXG5jb25zdCB0ZXh0ID0gW1xyXG5cdHtcclxuXHRcdGltYWdlOiAnL3JlcFRleHQxLnN2ZydcclxuXHR9LFxyXG5cdHtcclxuXHRcdGltYWdlOiAnL3JlcFRleHQyLnN2ZydcclxuXHR9XHJcbl1cclxuXHJcbmNvbnN0IGFib3V0SW5mbyA9IFtcclxuXHR7XHJcblx0XHR0ZXh0czogW1xyXG5cdFx0XHQnUkJhbmQgY9C+0LHRgNCw0Lsg0LIg0YHQtdCx0LUg0YHQv9C10YbQuNCw0LvQuNGB0YLQvtCyINGBINCz0LvRg9Cx0L7QutC40Lwg0LfQvdCw0L3QuNC10Lwg0L/RgNC40LrQu9Cw0LTQvdGL0YUg0L3QsNGD0LosINCw0LrRgtGD0LDQu9GM0L3Ri9GFINGC0LXRhdC90L7Qu9C+0LPQuNC5INC4INC/0L7QvdC40LzQsNC90LjQtdC8INC40YUg0L/QvtGB0YLQvtGP0L3QvdC+0LPQviDRgNCw0LfQstC40YLQuNGPLicsXHJcblx0XHRcdCfQndCw0YjQsCDQstC+0LLQu9C10YfQtdC90L3QvtGB0YLRjCDQsiDRgdC/0LXRhtC40YTQuNC60YMg0LrQvtC80L/QsNC90LjQuCDQutC70LjQvdC10YLQsCwg0YPQvNC10L3QuNC1INGB0LvRi9GI0LDRgtGMLCDRiNC40YDQvtC60LjQuSDQutGA0YPQs9C+0LfQvtGAINC4INC30L3QsNC90LjQtSDRgdC+0LLRgNC10LzQtdC90L3Ri9GFINC40L3RgdGC0YDRg9C80LXQvdGC0L7QsiDQv9GA0LjQstC+0LTRj9GCINC6INGN0YTRhNC10LrRgtC40LLRi9C8INCx0LjQt9C90LXRgS3RgNC10YjQtdC90LjRj9C8LidcclxuXHRcdF0sXHJcblx0XHRidXR0b246IHtcclxuXHRcdFx0dGV4dDogJ9C+INC60L7QvNC/0LDQvdC40LgnLFxyXG5cdFx0XHRocmVmOiAnIydcclxuXHRcdH1cclxuXHR9LFxyXG5cdHtcclxuXHRcdHRleHRzOiBbXHJcblx0XHRcdCfQndCw0LQg0LrQsNC20LTRi9C8INC/0YDQvtC10LrRgtC+0Lwg0LzRiyDRgNCw0LHQvtGC0LDQtdC8INC60LDQuiDQvdCw0LQg0YHQstC+0LjQvC4g0JTQvtCy0L7Qu9GM0L3Ri9C1INC60LvQuNC10L3RgtGLINC4INGD0YHQv9C10YjQvdC+INGA0LXQsNC70LjQt9C+0LLQsNC90L3Ri9C1INC/0YDQvtC10LrRgtGLIOKAkyDRjdGC0L4g0LvRg9GH0YjQtdC1INC/0L7QtNGC0LLQtdGA0LbQtNC10L3QuNC1INC90LDRiNC10Lkg0LrQvtC80L/QtdGC0LXQvdGC0L3QvtGB0YLQuC4nXHJcblx0XHRdLFxyXG5cdFx0YnV0dG9uOiB7XHJcblx0XHRcdHRleHQ6ICfQvtGC0LfRi9Cy0Ysg0L3QsCDRgNC10YHRg9GA0YHQsNGFJyxcclxuXHRcdFx0aHJlZjogJyMnXHJcblx0XHR9XHJcblx0fVxyXG5dXHJcblxyXG5jb25zdCB0ZXh0UmVwdXRhdGlvbiA9IFtcclxuXHR7XHJcblx0XHRudW1iZXJzOiAnMTIwMCsnLFxyXG5cdFx0dGV4dDogJ9Cj0YHQv9C10YjQvdC+INGA0LXQsNC70LjQt9C+0LLQsNC90L3Ri9GFINGB0LDQudGC0L7QsiDQuCDQtNC40LfQsNC50L0t0L/RgNC+0LXQutGC0L7QsidcclxuXHR9LFxyXG5cdHtcclxuXHRcdG51bWJlcnM6ICcxMisnLFxyXG5cdFx0dGV4dDogJ9C70LXRgiDQvtC/0YvRgtCwIHdlYi3RgNCw0LfRgNCw0LHQvtGC0LrQuCDQuCDQtNC40LfQsNC50L3QsCdcclxuXHR9LFxyXG5cdHtcclxuXHRcdG51bWJlcnM6ICcxMCsnLFxyXG5cdFx0dGV4dDogJ9GB0YLRgNCw0L0g0LTQvtCy0LXRgNGP0Y7RgiDQvdCw0Lwg0YDQsNC30YDQsNCx0L7RgtC60YMg0YHQstC+0LjRhSDQv9GA0L7QtdC60YLQvtCyJ1xyXG5cdH0sXHJcblx0e1xyXG5cdFx0bnVtYmVyczogJzI2MCsnLFxyXG5cdFx0dGV4dDogJ9C00L7QstC+0LvRjNC90YvRhSDQv9C+0YHRgtC+0Y/QvdC90YvRhSDQutC70LjQtdC90YLQvtCyJ1xyXG5cdH1cclxuXVxyXG5cclxuY29uc3QgcHJvamVjdHMgPSBbXHJcblx0e1xyXG5cdFx0aW1hZ2U6ICcvaG9tZS1wcm9qZWN0cy8xLnN2ZycsXHJcblx0XHRuYW1lOiAn0JrQpNClINCh0YLQsNGA0L7QtNGD0LHQtdGGJyxcclxuXHRcdHRleHQ6ICfQntC00LjQvSDQuNC3INC70LjQtNC10YDQvtCyINC/0L4g0LLRi9GA0LDRidC40LLQsNC90LjRjiDQt9C10YDQvdC+0LLRi9GFINC4INC60LDRgNGC0L7RhNC10LvRjNC90YvRhSDQutGD0LvRjNGC0YPRgCcsXHJcblx0XHRocmVmOiAnIydcclxuXHR9LFxyXG5cdHtcclxuXHRcdGltYWdlOiAnL2hvbWUtcHJvamVjdHMvMi5zdmcnLFxyXG5cdFx0bmFtZTogJ9Ca0KTQpSDQodGC0LDRgNC+0LTRg9Cx0LXRhicsXHJcblx0XHR0ZXh0OiAn0J7QtNC40L0g0LjQtyDQu9C40LTQtdGA0L7QsiDQv9C+INCy0YvRgNCw0YnQuNCy0LDQvdC40Y4g0LfQtdGA0L3QvtCy0YvRhSDQuCDQutCw0YDRgtC+0YTQtdC70YzQvdGL0YUg0LrRg9C70YzRgtGD0YAnLFxyXG5cdFx0aHJlZjogJyMnXHJcblx0fSxcclxuXHR7XHJcblx0XHRpbWFnZTogJy9ob21lLXByb2plY3RzLzMuc3ZnJyxcclxuXHRcdG5hbWU6ICfQmtCk0KUg0KHRgtCw0YDQvtC00YPQsdC10YYnLFxyXG5cdFx0dGV4dDogJ9Ce0LTQuNC9INC40Lcg0LvQuNC00LXRgNC+0LIg0L/QviDQstGL0YDQsNGJ0LjQstCw0L3QuNGOINC30LXRgNC90L7QstGL0YUg0Lgg0LrQsNGA0YLQvtGE0LXQu9GM0L3Ri9GFINC60YPQu9GM0YLRg9GAJyxcclxuXHRcdGhyZWY6ICcjJ1xyXG5cdH0sXHJcblx0e1xyXG5cdFx0aW1hZ2U6ICcvaG9tZS1wcm9qZWN0cy80LnN2ZycsXHJcblx0XHRuYW1lOiAn0JrQpNClINCh0YLQsNGA0L7QtNGD0LHQtdGGJyxcclxuXHRcdHRleHQ6ICfQntC00LjQvSDQuNC3INC70LjQtNC10YDQvtCyINC/0L4g0LLRi9GA0LDRidC40LLQsNC90LjRjiDQt9C10YDQvdC+0LLRi9GFINC4INC60LDRgNGC0L7RhNC10LvRjNC90YvRhSDQutGD0LvRjNGC0YPRgCcsXHJcblx0XHRocmVmOiAnIydcclxuXHR9LFxyXG5cdHtcclxuXHRcdGltYWdlOiAnL2hvbWUtcHJvamVjdHMvNS5zdmcnLFxyXG5cdFx0bmFtZTogJ9Ca0KTQpSDQodGC0LDRgNC+0LTRg9Cx0LXRhicsXHJcblx0XHR0ZXh0OiAn0J7QtNC40L0g0LjQtyDQu9C40LTQtdGA0L7QsiDQv9C+INCy0YvRgNCw0YnQuNCy0LDQvdC40Y4g0LfQtdGA0L3QvtCy0YvRhSDQuCDQutCw0YDRgtC+0YTQtdC70YzQvdGL0YUg0LrRg9C70YzRgtGD0YAnLFxyXG5cdFx0aHJlZjogJyMnXHJcblx0fSxcclxuXHR7XHJcblx0XHRpbWFnZTogJy9ob21lLXByb2plY3RzLzYuc3ZnJyxcclxuXHRcdG5hbWU6ICfQmtCk0KUg0KHRgtCw0YDQvtC00YPQsdC10YYnLFxyXG5cdFx0dGV4dDogJ9Ce0LTQuNC9INC40Lcg0LvQuNC00LXRgNC+0LIg0L/QviDQstGL0YDQsNGJ0LjQstCw0L3QuNGOINC30LXRgNC90L7QstGL0YUg0Lgg0LrQsNGA0YLQvtGE0LXQu9GM0L3Ri9GFINC60YPQu9GM0YLRg9GAJyxcclxuXHRcdGhyZWY6ICcjJ1xyXG5cdH0sXHJcblx0e1xyXG5cdFx0aW1hZ2U6ICcvaG9tZS1wcm9qZWN0cy83LnN2ZycsXHJcblx0XHRuYW1lOiAn0JrQpNClINCh0YLQsNGA0L7QtNGD0LHQtdGGJyxcclxuXHRcdHRleHQ6ICfQntC00LjQvSDQuNC3INC70LjQtNC10YDQvtCyINC/0L4g0LLRi9GA0LDRidC40LLQsNC90LjRjiDQt9C10YDQvdC+0LLRi9GFINC4INC60LDRgNGC0L7RhNC10LvRjNC90YvRhSDQutGD0LvRjNGC0YPRgCcsXHJcblx0XHRocmVmOiAnIydcclxuXHR9LFxyXG5cdHtcclxuXHRcdGltYWdlOiAnL2hvbWUtcHJvamVjdHMvOC5zdmcnLFxyXG5cdFx0bmFtZTogJ9Ca0KTQpSDQodGC0LDRgNC+0LTRg9Cx0LXRhicsXHJcblx0XHR0ZXh0OiAn0J7QtNC40L0g0LjQtyDQu9C40LTQtdGA0L7QsiDQv9C+INCy0YvRgNCw0YnQuNCy0LDQvdC40Y4g0LfQtdGA0L3QvtCy0YvRhSDQuCDQutCw0YDRgtC+0YTQtdC70YzQvdGL0YUg0LrRg9C70YzRgtGD0YAnLFxyXG5cdFx0aHJlZjogJyMnXHJcblx0fSxcclxuXHR7XHJcblx0XHRpbWFnZTogJy9ob21lLXByb2plY3RzLzkuc3ZnJyxcclxuXHRcdG5hbWU6ICfQmtCk0KUg0KHRgtCw0YDQvtC00YPQsdC10YYnLFxyXG5cdFx0dGV4dDogJ9Ce0LTQuNC9INC40Lcg0LvQuNC00LXRgNC+0LIg0L/QviDQstGL0YDQsNGJ0LjQstCw0L3QuNGOINC30LXRgNC90L7QstGL0YUg0Lgg0LrQsNGA0YLQvtGE0LXQu9GM0L3Ri9GFINC60YPQu9GM0YLRg9GAJyxcclxuXHRcdGhyZWY6ICcjJ1xyXG5cdH0sXHJcblx0e1xyXG5cdFx0aW1hZ2U6ICcvaG9tZS1wcm9qZWN0cy8xMC5zdmcnLFxyXG5cdFx0bmFtZTogJ9Ca0KTQpSDQodGC0LDRgNC+0LTRg9Cx0LXRhicsXHJcblx0XHR0ZXh0OiAn0J7QtNC40L0g0LjQtyDQu9C40LTQtdGA0L7QsiDQv9C+INCy0YvRgNCw0YnQuNCy0LDQvdC40Y4g0LfQtdGA0L3QvtCy0YvRhSDQuCDQutCw0YDRgtC+0YTQtdC70YzQvdGL0YUg0LrRg9C70YzRgtGD0YAnLFxyXG5cdFx0aHJlZjogJyMnXHJcblx0fSxcclxuXHR7XHJcblx0XHRpbWFnZTogJy9ob21lLXByb2plY3RzLzExLnN2ZycsXHJcblx0XHRuYW1lOiAn0JrQpNClINCh0YLQsNGA0L7QtNGD0LHQtdGGJyxcclxuXHRcdHRleHQ6ICfQntC00LjQvSDQuNC3INC70LjQtNC10YDQvtCyINC/0L4g0LLRi9GA0LDRidC40LLQsNC90LjRjiDQt9C10YDQvdC+0LLRi9GFINC4INC60LDRgNGC0L7RhNC10LvRjNC90YvRhSDQutGD0LvRjNGC0YPRgCcsXHJcblx0XHRocmVmOiAnIydcclxuXHR9LFxyXG5cdHtcclxuXHRcdGltYWdlOiAnL2hvbWUtcHJvamVjdHMvMTIuc3ZnJyxcclxuXHRcdG5hbWU6ICfQmtCk0KUg0KHRgtCw0YDQvtC00YPQsdC10YYnLFxyXG5cdFx0dGV4dDogJ9Ce0LTQuNC9INC40Lcg0LvQuNC00LXRgNC+0LIg0L/QviDQstGL0YDQsNGJ0LjQstCw0L3QuNGOINC30LXRgNC90L7QstGL0YUg0Lgg0LrQsNGA0YLQvtGE0LXQu9GM0L3Ri9GFINC60YPQu9GM0YLRg9GAJyxcclxuXHRcdGhyZWY6ICcjJ1xyXG5cdH0sXHJcblx0e1xyXG5cdFx0aW1hZ2U6ICcvaG9tZS1wcm9qZWN0cy8xMy5zdmcnLFxyXG5cdFx0bmFtZTogJ9Ca0KTQpSDQodGC0LDRgNC+0LTRg9Cx0LXRhicsXHJcblx0XHR0ZXh0OiAn0J7QtNC40L0g0LjQtyDQu9C40LTQtdGA0L7QsiDQv9C+INCy0YvRgNCw0YnQuNCy0LDQvdC40Y4g0LfQtdGA0L3QvtCy0YvRhSDQuCDQutCw0YDRgtC+0YTQtdC70YzQvdGL0YUg0LrRg9C70YzRgtGD0YAnLFxyXG5cdFx0aHJlZjogJyMnXHJcblx0fSxcclxuXHR7XHJcblx0XHRpbWFnZTogJy9ob21lLXByb2plY3RzLzE0LnN2ZycsXHJcblx0XHRuYW1lOiAn0JrQpNClINCh0YLQsNGA0L7QtNGD0LHQtdGGJyxcclxuXHRcdHRleHQ6ICfQntC00LjQvSDQuNC3INC70LjQtNC10YDQvtCyINC/0L4g0LLRi9GA0LDRidC40LLQsNC90LjRjiDQt9C10YDQvdC+0LLRi9GFINC4INC60LDRgNGC0L7RhNC10LvRjNC90YvRhSDQutGD0LvRjNGC0YPRgCcsXHJcblx0XHRocmVmOiAnIydcclxuXHR9XHJcbl1cclxuZXhwb3J0IGZ1bmN0aW9uIEFib3V0KCkge1xyXG5cdGNvbnN0IHRleHRSZWYgPSB1c2VSZWYobnVsbClcclxuXHRjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKVxyXG5cdHJldHVybiAoXHJcblx0XHQ8c2VjdGlvbiBjbGFzc05hbWU9e2NsYXNzZXMuYWJvdXR9PlxyXG5cdFx0XHR7dGV4dC5sZW5ndGggPiAwICYmIChcclxuXHRcdFx0XHQ8VGV4dFdyYXBcclxuXHRcdFx0XHRcdGlkPSdhYm91dC10ZXh0LXdyYXAnXHJcblx0XHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzZXMuYWJvdXRfX3RleHRXcmFwfVxyXG5cdFx0XHRcdFx0cmVmPXt0ZXh0UmVmfVxyXG5cdFx0XHRcdD5cclxuXHRcdFx0XHRcdHt0ZXh0Lm1hcCgodCwgaSkgPT4ge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gKFxyXG5cdFx0XHRcdFx0XHRcdDxUZXh0V3JhcEl0ZW1cclxuXHRcdFx0XHRcdFx0XHRcdGltYWdlPXt0LmltYWdlfVxyXG5cdFx0XHRcdFx0XHRcdFx0aW5kZXg9e2l9XHJcblx0XHRcdFx0XHRcdFx0XHRrZXk9e2l9XHJcblx0XHRcdFx0XHRcdFx0XHRyZWZlcmVuY2U9e3RleHRSZWZ9XHJcblx0XHRcdFx0XHRcdFx0XHRpZD0nI2Fib3V0LXRleHQtd3JhcCdcclxuXHRcdFx0XHRcdFx0XHQvPlxyXG5cdFx0XHRcdFx0XHQpXHJcblx0XHRcdFx0XHR9KX1cclxuXHRcdFx0XHQ8L1RleHRXcmFwPlxyXG5cdFx0XHQpfVxyXG5cdFx0XHQ8Q29udGFpbmVyXHJcblx0XHRcdFx0dmFyaWFudD0neGwnXHJcblx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc2VzLmFib3V0X19jb250YWluZXJ9XHJcblx0XHRcdD5cclxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlcy5hYm91dF9faW5mb30+XHJcblx0XHRcdFx0XHR7YWJvdXRJbmZvLmxlbmd0aCA+IDAgJiZcclxuXHRcdFx0XHRcdFx0YWJvdXRJbmZvLm1hcChcclxuXHRcdFx0XHRcdFx0XHQoYWJvdXQsIGluZGV4KSA9PlxyXG5cdFx0XHRcdFx0XHRcdFx0YWJvdXQudGV4dHMubGVuZ3RoID4gMCAmJiAoXHJcblx0XHRcdFx0XHRcdFx0XHRcdDxkaXZcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXk9e2luZGV4fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17Y2xhc3Nlcy5hYm91dF9fYmxvY2t9XHJcblx0XHRcdFx0XHRcdFx0XHRcdD5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7YWJvdXQudGV4dHMubWFwKCh0ZXh0LCBpKSA9PiAoXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8cFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRrZXk9e2l9XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17Y2xhc3Nlcy5hYm91dF9fYmxvY2tUZXh0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7dGV4dH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvcD5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpKX1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8QnV0dG9uIGNsYXNzTmFtZT17Y2xhc3Nlcy5hYm91dF9fYmxvY2tCdXR0b259PlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gb25DbGljaz17KCkgPT4gcm91dGVyLnB1c2goYWJvdXQuYnV0dG9uLmhyZWYpfT5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0e2Fib3V0LmJ1dHRvbi50ZXh0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PC9zcGFuPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDwvQnV0dG9uPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdFx0XHRcdClcclxuXHRcdFx0XHRcdFx0KX1cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHJcblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuYWJvdXRfX2NvbnRlbnR9PlxyXG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuYWJvdXRfX2NvbnRlbnRIZWFkfT5cclxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuYWJvdXRfX2NvbnRlbnRIZWFkVmlkZW99PlxyXG5cdFx0XHRcdFx0XHRcdDxJbWFnZVxyXG5cdFx0XHRcdFx0XHRcdFx0c3JjPScvYWJvdXQtaW1nLnBuZydcclxuXHRcdFx0XHRcdFx0XHRcdGFsdD0nYWJvdXQgaW1hZ2VzJ1xyXG5cdFx0XHRcdFx0XHRcdFx0ZmlsbFxyXG5cdFx0XHRcdFx0XHRcdFx0c2l6ZXM9JzEwMHZ3J1xyXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0Rml0PSdjb3ZlcidcclxuXHRcdFx0XHRcdFx0XHRcdG9iamVjdFBvc2l0aW9uPSdjZW50ZXInXHJcblx0XHRcdFx0XHRcdFx0Lz5cclxuXHRcdFx0XHRcdFx0XHQ8dmlkZW9cclxuXHRcdFx0XHRcdFx0XHRcdGxvb3BcclxuXHRcdFx0XHRcdFx0XHRcdGF1dG9QbGF5XHJcblx0XHRcdFx0XHRcdFx0XHRwcmVsb2FkPSdhdXRvJ1xyXG5cdFx0XHRcdFx0XHRcdFx0bXV0ZWQ9e3RydWV9XHJcblx0XHRcdFx0XHRcdFx0XHRwbGF5c0lubGluZVxyXG5cdFx0XHRcdFx0XHRcdFx0Y29udHJvbHM9e2ZhbHNlfVxyXG5cdFx0XHRcdFx0XHRcdD5cclxuXHRcdFx0XHRcdFx0XHRcdDxzb3VyY2VcclxuXHRcdFx0XHRcdFx0XHRcdFx0c3JjPScvYWJvdXQtdmlkZW8ubXA0J1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlPSd2aWRlby9tcDQnXHJcblx0XHRcdFx0XHRcdFx0XHQvPlxyXG5cdFx0XHRcdFx0XHRcdDwvdmlkZW8+XHJcblx0XHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlcy5hYm91dF9fY29udGVudEhlYWRSZXB1dGF0aW9ufT5cclxuXHRcdFx0XHRcdFx0XHR7dGV4dFJlcHV0YXRpb24ubWFwKChyZXAsIGluZGV4KSA9PiAoXHJcblx0XHRcdFx0XHRcdFx0XHQ8ZGl2XHJcblx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17Y2xhc3Nlcy5hYm91dF9fY29udGVudEhlYWRSZXB1dGF0aW9uSXRlbX1cclxuXHRcdFx0XHRcdFx0XHRcdFx0a2V5PXtpbmRleH1cclxuXHRcdFx0XHRcdFx0XHRcdD5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PHA+XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0PHN0cm9uZz57cmVwLm51bWJlcnN9PC9zdHJvbmc+XHJcblx0XHRcdFx0XHRcdFx0XHRcdDwvcD5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PHA+e3JlcC50ZXh0fTwvcD5cclxuXHRcdFx0XHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdFx0XHRcdCkpfVxyXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuYWJvdXRfX2NvbnRlbnRQcm9qZWN0c30+XHJcblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzLmFib3V0X19jb250ZW50UHJvamVjdHNNb2JpbGV9PlxyXG5cdFx0XHRcdFx0XHRcdDxoNiBjbGFzc05hbWU9e2NsYXNzZXMuYWJvdXRfX2NvbnRlbnRQcm9qZWN0c01vYmlsZVRpdGxlfT5cclxuXHRcdFx0XHRcdFx0XHRcdNCR0L7Qu9C10LUge3Byb2plY3RzLmxlbmd0aH0g0LrRgNGD0YLRi9GFINC60LvQuNC10L3RgtC+0LJcclxuXHRcdFx0XHRcdFx0XHQ8L2g2PlxyXG5cdFx0XHRcdFx0XHRcdDxwIGNsYXNzTmFtZT17Y2xhc3Nlcy5hYm91dF9fY29udGVudFByb2plY3RzTW9iaWxlVGV4dH0+XHJcblx0XHRcdFx0XHRcdFx0XHTQlNC+0LLQtdGA0LjRgtC10LvRjNC90YvQtSDQvtGC0L3QvtGI0LXQvdC40Y8sINC/0YDQvtCy0LXRgNC10L3QvdGL0LUg0LLRgNC10LzQtdC90LXQvC5cclxuXHRcdFx0XHRcdFx0XHQ8L3A+XHJcblx0XHRcdFx0XHRcdFx0PEJ1dHRvbiBjbGFzc05hbWU9e2NsYXNzZXMuYWJvdXRfX2NvbnRlbnRQcm9qZWN0c0J1dHRvbn0+XHJcblx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBvbkNsaWNrPXsoKSA9PiByb3V0ZXIucHVzaCgnL3Jldmlld3MnKX0+XHJcblx0XHRcdFx0XHRcdFx0XHRcdNGB0LzQvtGC0YDQtdGC0Ywg0LLRgdC1INC+0YLQt9GL0LLRi1xyXG5cdFx0XHRcdFx0XHRcdFx0PC9zcGFuPlxyXG5cdFx0XHRcdFx0XHRcdDwvQnV0dG9uPlxyXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHJcblx0XHRcdFx0XHRcdHtwcm9qZWN0cy5sZW5ndGggPiAwICYmXHJcblx0XHRcdFx0XHRcdFx0cHJvamVjdHMubWFwKChwcm9qZWN0LCBpbmRleCkgPT4gKFxyXG5cdFx0XHRcdFx0XHRcdFx0PGRpdlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRrZXk9e2luZGV4fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzZXMuYWJvdXRfX2NvbnRlbnRQcm9qZWN0c0l0ZW19XHJcblx0XHRcdFx0XHRcdFx0XHQ+XHJcblx0XHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzLmFib3V0X19jb250ZW50UHJvamVjdHNJdGVtTG9nb30+XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0PEltYWdlXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzcmM9e3Byb2plY3QuaW1hZ2V9XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhbHQ9e3Byb2plY3QubmFtZX1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdpZHRoPXsyNjB9XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRoZWlnaHQ9ezEzMH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuYWJvdXRfX2NvbnRlbnRQcm9qZWN0c0l0ZW1Db250ZW50fT5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8aDYgY2xhc3NOYW1lPXtjbGFzc2VzLmFib3V0X19jb250ZW50UHJvamVjdHNJdGVtVGl0bGV9PlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e3Byb2plY3QubmFtZX1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8L2g2PlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxwIGNsYXNzTmFtZT17Y2xhc3Nlcy5hYm91dF9fY29udGVudFByb2plY3RzSXRlbVRleHR9PlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e3Byb2plY3QudGV4dH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8L3A+XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPXtjbGFzc2VzLmFib3V0X19jb250ZW50UHJvamVjdHNJdGVtTW9yZX0+XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHTQodC80L7RgtGA0LXRgtGMINC/0YDQvtC10LrRglxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHRcdFx0XHRcdDxMaW5rXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aHJlZj17cHJvamVjdC5ocmVmfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17Y2xhc3Nlcy5hYm91dF9fY29udGVudFByb2plY3RzSXRlbUxpbmt9XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0PSdfYmxhbmsnXHJcblx0XHRcdFx0XHRcdFx0XHRcdD48L0xpbms+XHJcblx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdFx0XHQpKX1cclxuXHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHQ8L0NvbnRhaW5lcj5cclxuXHRcdDwvc2VjdGlvbj5cclxuXHQpXHJcbn1cclxuIl0sIm5hbWVzIjpbIkltYWdlIiwiTGluayIsInVzZVJvdXRlciIsInVzZVJlZiIsIlRleHRXcmFwIiwiVGV4dFdyYXBJdGVtIiwiQnV0dG9uIiwiQ29udGFpbmVyIiwiY2xhc3NlcyIsInRleHQiLCJpbWFnZSIsImFib3V0SW5mbyIsInRleHRzIiwiYnV0dG9uIiwiaHJlZiIsInRleHRSZXB1dGF0aW9uIiwibnVtYmVycyIsInByb2plY3RzIiwibmFtZSIsIkFib3V0IiwidGV4dFJlZiIsInJvdXRlciIsInNlY3Rpb24iLCJjbGFzc05hbWUiLCJhYm91dCIsImxlbmd0aCIsImlkIiwiYWJvdXRfX3RleHRXcmFwIiwicmVmIiwibWFwIiwidCIsImkiLCJpbmRleCIsInJlZmVyZW5jZSIsInZhcmlhbnQiLCJhYm91dF9fY29udGFpbmVyIiwiZGl2IiwiYWJvdXRfX2luZm8iLCJhYm91dF9fYmxvY2siLCJwIiwiYWJvdXRfX2Jsb2NrVGV4dCIsImFib3V0X19ibG9ja0J1dHRvbiIsInNwYW4iLCJvbkNsaWNrIiwicHVzaCIsImFib3V0X19jb250ZW50IiwiYWJvdXRfX2NvbnRlbnRIZWFkIiwiYWJvdXRfX2NvbnRlbnRIZWFkVmlkZW8iLCJzcmMiLCJhbHQiLCJmaWxsIiwic2l6ZXMiLCJvYmplY3RGaXQiLCJvYmplY3RQb3NpdGlvbiIsInZpZGVvIiwibG9vcCIsImF1dG9QbGF5IiwicHJlbG9hZCIsIm11dGVkIiwicGxheXNJbmxpbmUiLCJjb250cm9scyIsInNvdXJjZSIsInR5cGUiLCJhYm91dF9fY29udGVudEhlYWRSZXB1dGF0aW9uIiwicmVwIiwiYWJvdXRfX2NvbnRlbnRIZWFkUmVwdXRhdGlvbkl0ZW0iLCJzdHJvbmciLCJhYm91dF9fY29udGVudFByb2plY3RzIiwiYWJvdXRfX2NvbnRlbnRQcm9qZWN0c01vYmlsZSIsImg2IiwiYWJvdXRfX2NvbnRlbnRQcm9qZWN0c01vYmlsZVRpdGxlIiwiYWJvdXRfX2NvbnRlbnRQcm9qZWN0c01vYmlsZVRleHQiLCJhYm91dF9fY29udGVudFByb2plY3RzQnV0dG9uIiwicHJvamVjdCIsImFib3V0X19jb250ZW50UHJvamVjdHNJdGVtIiwiYWJvdXRfX2NvbnRlbnRQcm9qZWN0c0l0ZW1Mb2dvIiwid2lkdGgiLCJoZWlnaHQiLCJhYm91dF9fY29udGVudFByb2plY3RzSXRlbUNvbnRlbnQiLCJhYm91dF9fY29udGVudFByb2plY3RzSXRlbVRpdGxlIiwiYWJvdXRfX2NvbnRlbnRQcm9qZWN0c0l0ZW1UZXh0IiwiYWJvdXRfX2NvbnRlbnRQcm9qZWN0c0l0ZW1Nb3JlIiwiYWJvdXRfX2NvbnRlbnRQcm9qZWN0c0l0ZW1MaW5rIiwidGFyZ2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/about/About.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/descriptor/Descriptor.tsx":
/*!**************************************************!*\
  !*** ./src/components/descriptor/Descriptor.tsx ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Descriptor: function() { return /* binding */ Descriptor; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _gsap_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @gsap/react */ \"(app-pages-browser)/./node_modules/.pnpm/@gsap+react@2.1.1/node_modules/@gsap/react/src/index.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! gsap */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js\");\n/* harmony import */ var gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! gsap/ScrollTrigger */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollTrigger.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/image.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _components_ui_container_Container__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/components/ui/container/Container */ \"(app-pages-browser)/./src/components/ui/container/Container.tsx\");\n/* harmony import */ var _hooks_useScroll__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/hooks/useScroll */ \"(app-pages-browser)/./src/hooks/useScroll.ts\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./styles.module.scss */ \"(app-pages-browser)/./src/components/descriptor/styles.module.scss\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_styles_module_scss__WEBPACK_IMPORTED_MODULE_7__);\n/* __next_internal_client_entry_do_not_use__ Descriptor auto */ \n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\ngsap__WEBPACK_IMPORTED_MODULE_8__[\"default\"].registerPlugin(gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_9__.ScrollTrigger, gsap__WEBPACK_IMPORTED_MODULE_8__[\"default\"], _gsap_react__WEBPACK_IMPORTED_MODULE_1__.useGSAP);\nfunction Descriptor() {\n    _s();\n    var _useState = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_10__._)((0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(false), 2), isPlay = _useState[0], setIsPlay = _useState[1];\n    var _useState1 = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_10__._)((0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(0), 2), translateContent = _useState1[0], setTranslateContent = _useState1[1];\n    var _useState2 = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_10__._)((0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(1), 2), opacityContent = _useState2[0], setOpacityContent = _useState2[1];\n    var _useState3 = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_10__._)((0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(1), 2), scaleContent = _useState3[0], setScaleContent = _useState3[1];\n    var quantityRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null);\n    var contentRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null);\n    var backgroundRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null);\n    var priceRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null);\n    var descriptorRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null);\n    var videoRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null);\n    var actionsRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null);\n    var scroll = (0,_hooks_useScroll__WEBPACK_IMPORTED_MODULE_6__.useScroll)().scroll;\n    (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(function() {\n        var _videoRef_current, _videoRef_current1;\n        var translate = scroll / 40;\n        var opacity = 1 - scroll / 1000;\n        var scale = 1 - scroll / 2000;\n        if (translate < 20) {\n            setTranslateContent(translate);\n        }\n        if (opacity >= 0) {\n            setOpacityContent(opacity);\n        }\n        if (scale >= 0) {\n            setScaleContent(scale);\n        }\n        if (scroll > descriptorRef.current.clientHeight && !((_videoRef_current = videoRef.current) === null || _videoRef_current === void 0 ? void 0 : _videoRef_current.paused) && isPlay) {\n            var _videoRef_current2;\n            (_videoRef_current2 = videoRef.current) === null || _videoRef_current2 === void 0 ? void 0 : _videoRef_current2.pause();\n        } else if (scroll <= descriptorRef.current.clientHeight && ((_videoRef_current1 = videoRef.current) === null || _videoRef_current1 === void 0 ? void 0 : _videoRef_current1.paused) && isPlay) {\n            var _videoRef_current3;\n            (_videoRef_current3 = videoRef.current) === null || _videoRef_current3 === void 0 ? void 0 : _videoRef_current3.play();\n        }\n    }, [\n        scroll\n    ]);\n    (0,_gsap_react__WEBPACK_IMPORTED_MODULE_1__.useGSAP)(function() {\n        var tl = gsap__WEBPACK_IMPORTED_MODULE_8__[\"default\"].timeline();\n        tl.to(backgroundRef.current, {\n            maskSize: \"50dvh 50dvh\",\n            duration: 1\n        }).to(backgroundRef.current, {\n            maskSize: \"100vw 100vh\",\n            delay: 0.5,\n            duration: 1\n        }).to(backgroundRef.current, {\n            maskSize: \"100% 100%\"\n        });\n        gsap__WEBPACK_IMPORTED_MODULE_8__[\"default\"].to(actionsRef.current, {\n            delay: 1.5,\n            scale: 1,\n            duration: 1,\n            onComplete: function() {\n                var _videoRef_current;\n                setIsPlay(true);\n                if (((_videoRef_current = videoRef.current) === null || _videoRef_current === void 0 ? void 0 : _videoRef_current.readyState) === 4) {\n                    var _videoRef_current1;\n                    (_videoRef_current1 = videoRef.current) === null || _videoRef_current1 === void 0 ? void 0 : _videoRef_current1.play();\n                }\n            }\n        });\n        gsap__WEBPACK_IMPORTED_MODULE_8__[\"default\"].to([\n            quantityRef.current,\n            contentRef.current\n        ], {\n            transform: \"none\",\n            scale: 1,\n            duration: 1,\n            delay: 1.6\n        });\n        gsap__WEBPACK_IMPORTED_MODULE_8__[\"default\"].to(priceRef.current, {\n            opacity: 1,\n            delay: 2.1,\n            duration: 0.3\n        });\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])((_styles_module_scss__WEBPACK_IMPORTED_MODULE_7___default().descriptor)),\n        id: \"descriptor\",\n        ref: descriptorRef,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_container_Container__WEBPACK_IMPORTED_MODULE_5__.Container, {\n            variant: \"xl\",\n            className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_7___default().descriptor__container),\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_7___default().descriptor__actionsTrigger),\n                    ref: backgroundRef,\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_7___default().descriptor__actions),\n                        ref: actionsRef,\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_7___default().descriptor__actionsImage),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                    src: \"/descriptor.jpeg\",\n                                    alt: \"descriptor\",\n                                    sizes: \"100vw\",\n                                    fill: true\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n                                    lineNumber: 118,\n                                    columnNumber: 8\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n                                lineNumber: 117,\n                                columnNumber: 7\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_7___default().descriptor__actionsVideo),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"video\", {\n                                    ref: videoRef,\n                                    preload: \"auto\",\n                                    controls: false,\n                                    autoPlay: isPlay,\n                                    loop: true,\n                                    playsInline: true,\n                                    muted: true,\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"source\", {\n                                        src: \"/descriptor.mp4\",\n                                        type: \"video/mp4\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n                                        lineNumber: 135,\n                                        columnNumber: 9\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n                                    lineNumber: 126,\n                                    columnNumber: 8\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n                                lineNumber: 125,\n                                columnNumber: 7\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n                        lineNumber: 113,\n                        columnNumber: 6\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n                    lineNumber: 109,\n                    columnNumber: 5\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        transform: \"translateY(-\".concat(translateContent, \"%) scale(\").concat(scaleContent, \")\"),\n                        position: \"relative\",\n                        zIndex: \"2\",\n                        opacity: opacityContent,\n                        height: \"100%\"\n                    },\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_7___default().descriptor__content),\n                        ref: contentRef,\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"site-title-1\", (_styles_module_scss__WEBPACK_IMPORTED_MODULE_7___default().descriptor__contentTitle)),\n                                children: [\n                                    \"   \",\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_7___default().descriptor__contentRegion),\n                                        children: \" \"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n                                        lineNumber: 161,\n                                        columnNumber: 8\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n                                lineNumber: 157,\n                                columnNumber: 7\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_7___default().descriptor__contentText),\n                                children: \"           .    .\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n                                lineNumber: 165,\n                                columnNumber: 7\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n                        lineNumber: 153,\n                        columnNumber: 6\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n                    lineNumber: 144,\n                    columnNumber: 5\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_7___default().descriptor__right),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_7___default().descriptor__rightQuantity),\n                            ref: quantityRef,\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_7___default().descriptor__rightQuantityNumber),\n                                    children: \"+ 150\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n                                    lineNumber: 177,\n                                    columnNumber: 7\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_7___default().descriptor__rightQuantityText),\n                                    children: \"    \"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n                                    lineNumber: 178,\n                                    columnNumber: 7\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n                            lineNumber: 173,\n                            columnNumber: 6\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_7___default().descriptor__rightPrice),\n                            ref: priceRef,\n                            style: isPlay ? {\n                                transform: \"translateY(-\".concat(translateContent, \"%) scale(\").concat(scaleContent, \")\"),\n                                opacity: opacityContent\n                            } : {},\n                            children: [\n                                \" \",\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    children: \"200 000 \"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n                                    lineNumber: 195,\n                                    columnNumber: 7\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    children: \"30 . \"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n                                    lineNumber: 196,\n                                    columnNumber: 7\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n                            lineNumber: 182,\n                            columnNumber: 6\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n                    lineNumber: 172,\n                    columnNumber: 5\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n            lineNumber: 105,\n            columnNumber: 4\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\descriptor\\\\Descriptor.tsx\",\n        lineNumber: 100,\n        columnNumber: 3\n    }, this);\n}\n_s(Descriptor, \"V/TKtXnVMz7riuMdXUYfsVNlSEA=\", false, function() {\n    return [\n        _hooks_useScroll__WEBPACK_IMPORTED_MODULE_6__.useScroll,\n        _gsap_react__WEBPACK_IMPORTED_MODULE_1__.useGSAP\n    ];\n});\n_c = Descriptor;\nvar _c;\n$RefreshReg$(_c, \"Descriptor\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Rlc2NyaXB0b3IvRGVzY3JpcHRvci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFcUM7QUFDaEI7QUFDRTtBQUMyQjtBQUNwQjtBQUNxQjtBQUVZO0FBRWxCO0FBRUg7QUFFMUNFLDRDQUFJQSxDQUFDUyxjQUFjLENBQUNSLDZEQUFhQSxFQUFFRCw0Q0FBSUEsRUFBRUYsZ0RBQU9BO0FBRXpDLFNBQVNZOztJQUNmLElBQTRCTCxZQUFBQSxnRUFBQUEsQ0FBQUEsK0NBQVFBLENBQUMsWUFBOUJNLFNBQXFCTixjQUFiTyxZQUFhUDtJQUM1QixJQUFnREEsYUFBQUEsZ0VBQUFBLENBQUFBLCtDQUFRQSxDQUFDLFFBQWxEUSxtQkFBeUNSLGVBQXZCUyxzQkFBdUJUO0lBQ2hELElBQTRDQSxhQUFBQSxnRUFBQUEsQ0FBQUEsK0NBQVFBLENBQUMsUUFBOUNVLGlCQUFxQ1YsZUFBckJXLG9CQUFxQlg7SUFDNUMsSUFBd0NBLGFBQUFBLGdFQUFBQSxDQUFBQSwrQ0FBUUEsQ0FBQyxRQUExQ1ksZUFBaUNaLGVBQW5CYSxrQkFBbUJiO0lBRXhDLElBQU1jLGNBQWNmLDZDQUFNQSxDQUFDO0lBQzNCLElBQU1nQixhQUFhaEIsNkNBQU1BLENBQU07SUFDL0IsSUFBTWlCLGdCQUFnQmpCLDZDQUFNQSxDQUFDO0lBQzdCLElBQU1rQixXQUFXbEIsNkNBQU1BLENBQUM7SUFDeEIsSUFBTW1CLGdCQUFnQm5CLDZDQUFNQSxDQUFNO0lBQ2xDLElBQU1vQixXQUFXcEIsNkNBQU1BLENBQW1CO0lBQzFDLElBQU1xQixhQUFhckIsNkNBQU1BLENBQUM7SUFDMUIsSUFBTSxTQUFhRywyREFBU0EsR0FBcEJtQjtJQUVSdkIsZ0RBQVNBLENBQUM7WUFnQlBxQixtQkFNREE7UUFyQkQsSUFBTUcsWUFBWUQsU0FBUztRQUMzQixJQUFNRSxVQUFVLElBQUlGLFNBQVM7UUFDN0IsSUFBTUcsUUFBUSxJQUFJ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QixPQUFPO3dCQUNOMUIsV0FBVyxlQUEyQzFCLE9BQTVCSixrQkFBaUIsYUFBd0IsT0FBYkksY0FBYTt3QkFDbkVxRCxVQUFVO3dCQUNWQyxRQUFRO3dCQUNSM0MsU0FBU2I7d0JBQ1R5RCxRQUFRO29CQUNUOzhCQUVBLDRFQUFDckI7d0JBQ0FOLFdBQVdyQyxnRkFBMkI7d0JBQ3RDd0MsS0FBSzVCOzswQ0FFTCw4REFBQ3NEO2dDQUNBN0IsV0FBVzlDLGdEQUFFQSxDQUFDLGdCQUFnQlMscUZBQWdDOztvQ0FDOUQ7a0RBRUEsOERBQUNvRTt3Q0FBSy9CLFdBQVdyQyxzRkFBaUM7a0RBQUU7Ozs7Ozs7Ozs7OzswQ0FJckQsOERBQUNzRTtnQ0FBRWpDLFdBQVdyQyxvRkFBK0I7MENBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCQU9qRCw4REFBQzJDO29CQUFJTixXQUFXckMsOEVBQXlCOztzQ0FDeEMsOERBQUMyQzs0QkFDQU4sV0FBV3JDLHNGQUFpQzs0QkFDNUN3QyxLQUFLN0I7OzhDQUVMLDhEQUFDZ0M7b0NBQUlOLFdBQVdyQyw0RkFBdUM7OENBQUU7Ozs7Ozs4Q0FDekQsOERBQUMyQztvQ0FBSU4sV0FBV3JDLDBGQUFxQzs4Q0FBRTs7Ozs7Ozs7Ozs7O3NDQUl4RCw4REFBQzJDOzRCQUNBTixXQUFXckMsbUZBQThCOzRCQUN6Q3dDLEtBQUsxQjs0QkFDTCtDLE9BQ0MxRCxTQUNHO2dDQUNBZ0MsV0FBVyxlQUEyQzFCLE9BQTVCSixrQkFBaUIsYUFBd0IsT0FBYkksY0FBYTtnQ0FDbkVXLFNBQVNiOzRCQUNWLElBQ0MsQ0FBQzs7Z0NBRUw7OENBRUEsOERBQUM2RDs4Q0FBSzs7Ozs7OzhDQUNOLDhEQUFDQTs4Q0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNWjtHQXhMZ0JsRTs7UUFhSUgsdURBQVNBO1FBK0I1QlQsZ0RBQU9BOzs7S0E1Q1FZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2Rlc2NyaXB0b3IvRGVzY3JpcHRvci50c3g/YWY2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCB7IHVzZUdTQVAgfSBmcm9tICdAZ3NhcC9yZWFjdCdcclxuaW1wb3J0IGNuIGZyb20gJ2Nsc3gnXHJcbmltcG9ydCBnc2FwIGZyb20gJ2dzYXAnXHJcbmltcG9ydCB7IFNjcm9sbFRyaWdnZXIgfSBmcm9tICdnc2FwL1Njcm9sbFRyaWdnZXInXHJcbmltcG9ydCBJbWFnZSBmcm9tICduZXh0L2ltYWdlJ1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcclxuXHJcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJ0AvY29tcG9uZW50cy91aS9jb250YWluZXIvQ29udGFpbmVyJ1xyXG5cclxuaW1wb3J0IHsgdXNlU2Nyb2xsIH0gZnJvbSAnQC9ob29rcy91c2VTY3JvbGwnXHJcblxyXG5pbXBvcnQgY2xhc3NlcyBmcm9tICcuL3N0eWxlcy5tb2R1bGUuc2NzcydcclxuXHJcbmdzYXAucmVnaXN0ZXJQbHVnaW4oU2Nyb2xsVHJpZ2dlciwgZ3NhcCwgdXNlR1NBUClcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBEZXNjcmlwdG9yKCkge1xyXG5cdGNvbnN0IFtpc1BsYXksIHNldElzUGxheV0gPSB1c2VTdGF0ZShmYWxzZSlcclxuXHRjb25zdCBbdHJhbnNsYXRlQ29udGVudCwgc2V0VHJhbnNsYXRlQ29udGVudF0gPSB1c2VTdGF0ZSgwKVxyXG5cdGNvbnN0IFtvcGFjaXR5Q29udGVudCwgc2V0T3BhY2l0eUNvbnRlbnRdID0gdXNlU3RhdGUoMSlcclxuXHRjb25zdCBbc2NhbGVDb250ZW50LCBzZXRTY2FsZUNvbnRlbnRdID0gdXNlU3RhdGUoMSlcclxuXHJcblx0Y29uc3QgcXVhbnRpdHlSZWYgPSB1c2VSZWYobnVsbClcclxuXHRjb25zdCBjb250ZW50UmVmID0gdXNlUmVmPGFueT4obnVsbClcclxuXHRjb25zdCBiYWNrZ3JvdW5kUmVmID0gdXNlUmVmKG51bGwpXHJcblx0Y29uc3QgcHJpY2VSZWYgPSB1c2VSZWYobnVsbClcclxuXHRjb25zdCBkZXNjcmlwdG9yUmVmID0gdXNlUmVmPGFueT4obnVsbClcclxuXHRjb25zdCB2aWRlb1JlZiA9IHVzZVJlZjxIVE1MVmlkZW9FbGVtZW50PihudWxsKVxyXG5cdGNvbnN0IGFjdGlvbnNSZWYgPSB1c2VSZWYobnVsbClcclxuXHRjb25zdCB7IHNjcm9sbCB9ID0gdXNlU2Nyb2xsKClcclxuXHJcblx0dXNlRWZmZWN0KCgpID0+IHtcclxuXHRcdGNvbnN0IHRyYW5zbGF0ZSA9IHNjcm9sbCAvIDQwXHJcblx0XHRjb25zdCBvcGFjaXR5ID0gMSAtIHNjcm9sbCAvIDEwMDBcclxuXHRcdGNvbnN0IHNjYWxlID0gMSAtIHNjcm9sbCAvIDIwMDBcclxuXHRcdGlmICh0cmFuc2xhdGUgPCAyMCkge1xyXG5cdFx0XHRzZXRUcmFuc2xhdGVDb250ZW50KHRyYW5zbGF0ZSlcclxuXHRcdH1cclxuXHRcdGlmIChvcGFjaXR5ID49IDApIHtcclxuXHRcdFx0c2V0T3BhY2l0eUNvbnRlbnQob3BhY2l0eSlcclxuXHRcdH1cclxuXHRcdGlmIChzY2FsZSA+PSAwKSB7XHJcblx0XHRcdHNldFNjYWxlQ29udGVudChzY2FsZSlcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoXHJcblx0XHRcdHNjcm9sbCA+IGRlc2NyaXB0b3JSZWYuY3VycmVudC5jbGllbnRIZWlnaHQgJiZcclxuXHRcdFx0IXZpZGVvUmVmLmN1cnJlbnQ/LnBhdXNlZCAmJlxyXG5cdFx0XHRpc1BsYXlcclxuXHRcdCkge1xyXG5cdFx0XHR2aWRlb1JlZi5jdXJyZW50Py5wYXVzZSgpXHJcblx0XHR9IGVsc2UgaWYgKFxyXG5cdFx0XHRzY3JvbGwgPD0gZGVzY3JpcHRvclJlZi5jdXJyZW50LmNsaWVudEhlaWdodCAmJlxyXG5cdFx0XHR2aWRlb1JlZi5jdXJyZW50Py5wYXVzZWQgJiZcclxuXHRcdFx0aXNQbGF5XHJcblx0XHQpIHtcclxuXHRcdFx0dmlkZW9SZWYuY3VycmVudD8ucGxheSgpXHJcblx0XHR9XHJcblx0fSwgW3Njcm9sbF0pXHJcblxyXG5cdHVzZUdTQVAoKCkgPT4ge1xyXG5cdFx0Y29uc3QgdGwgPSBnc2FwLnRpbWVsaW5lKClcclxuXHRcdHRsLnRvKGJhY2tncm91bmRSZWYuY3VycmVudCwge1xyXG5cdFx0XHRtYXNrU2l6ZTogJzUwZHZoIDUwZHZoJyxcclxuXHRcdFx0ZHVyYXRpb246IDFcclxuXHRcdH0pXHJcblx0XHRcdC50byhiYWNrZ3JvdW5kUmVmLmN1cnJlbnQsIHtcclxuXHRcdFx0XHRtYXNrU2l6ZTogJzEwMHZ3IDEwMHZoJyxcclxuXHRcdFx0XHRkZWxheTogMC41LFxyXG5cdFx0XHRcdGR1cmF0aW9uOiAxXHJcblx0XHRcdH0pXHJcblx0XHRcdC50byhiYWNrZ3JvdW5kUmVmLmN1cnJlbnQsIHsgbWFza1NpemU6ICcxMDAlIDEwMCUnIH0pXHJcblxyXG5cdFx0Z3NhcC50byhhY3Rpb25zUmVmLmN1cnJlbnQsIHtcclxuXHRcdFx0ZGVsYXk6IDEuNSxcclxuXHRcdFx0c2NhbGU6IDEsXHJcblx0XHRcdGR1cmF0aW9uOiAxLFxyXG5cdFx0XHRvbkNvbXBsZXRlOiAoKSA9PiB7XHJcblx0XHRcdFx0c2V0SXNQbGF5KHRydWUpXHJcblx0XHRcdFx0aWYgKHZpZGVvUmVmLmN1cnJlbnQ/LnJlYWR5U3RhdGUgPT09IDQpIHtcclxuXHRcdFx0XHRcdHZpZGVvUmVmLmN1cnJlbnQ/LnBsYXkoKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSlcclxuXHRcdGdzYXAudG8oW3F1YW50aXR5UmVmLmN1cnJlbnQsIGNvbnRlbnRSZWYuY3VycmVudF0sIHtcclxuXHRcdFx0dHJhbnNmb3JtOiAnbm9uZScsXHJcblx0XHRcdHNjYWxlOiAxLFxyXG5cdFx0XHRkdXJhdGlvbjogMSxcclxuXHRcdFx0ZGVsYXk6IDEuNlxyXG5cdFx0fSlcclxuXHRcdGdzYXAudG8ocHJpY2VSZWYuY3VycmVudCwge1xyXG5cdFx0XHRvcGFjaXR5OiAxLFxyXG5cdFx0XHRkZWxheTogMi4xLFxyXG5cdFx0XHRkdXJhdGlvbjogMC4zXHJcblx0XHR9KVxyXG5cdH0pXHJcblxyXG5cdHJldHVybiAoXHJcblx0XHQ8c2VjdGlvblxyXG5cdFx0XHRjbGFzc05hbWU9e2NuKGNsYXNzZXMuZGVzY3JpcHRvcil9XHJcblx0XHRcdGlkPSdkZXNjcmlwdG9yJ1xyXG5cdFx0XHRyZWY9e2Rlc2NyaXB0b3JSZWZ9XHJcblx0XHQ+XHJcblx0XHRcdDxDb250YWluZXJcclxuXHRcdFx0XHR2YXJpYW50PSd4bCdcclxuXHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzZXMuZGVzY3JpcHRvcl9fY29udGFpbmVyfVxyXG5cdFx0XHQ+XHJcblx0XHRcdFx0PGRpdlxyXG5cdFx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc2VzLmRlc2NyaXB0b3JfX2FjdGlvbnNUcmlnZ2VyfVxyXG5cdFx0XHRcdFx0cmVmPXtiYWNrZ3JvdW5kUmVmfVxyXG5cdFx0XHRcdD5cclxuXHRcdFx0XHRcdDxkaXZcclxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc2VzLmRlc2NyaXB0b3JfX2FjdGlvbnN9XHJcblx0XHRcdFx0XHRcdHJlZj17YWN0aW9uc1JlZn1cclxuXHRcdFx0XHRcdD5cclxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuZGVzY3JpcHRvcl9fYWN0aW9uc0ltYWdlfT5cclxuXHRcdFx0XHRcdFx0XHQ8SW1hZ2VcclxuXHRcdFx0XHRcdFx0XHRcdHNyYz0nL2Rlc2NyaXB0b3IuanBlZydcclxuXHRcdFx0XHRcdFx0XHRcdGFsdD0nZGVzY3JpcHRvcidcclxuXHRcdFx0XHRcdFx0XHRcdHNpemVzPScxMDB2dydcclxuXHRcdFx0XHRcdFx0XHRcdGZpbGxcclxuXHRcdFx0XHRcdFx0XHQvPlxyXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuZGVzY3JpcHRvcl9fYWN0aW9uc1ZpZGVvfT5cclxuXHRcdFx0XHRcdFx0XHQ8dmlkZW9cclxuXHRcdFx0XHRcdFx0XHRcdHJlZj17dmlkZW9SZWZ9XHJcblx0XHRcdFx0XHRcdFx0XHRwcmVsb2FkPSdhdXRvJ1xyXG5cdFx0XHRcdFx0XHRcdFx0Y29udHJvbHM9e2ZhbHNlfVxyXG5cdFx0XHRcdFx0XHRcdFx0YXV0b1BsYXk9e2lzUGxheX1cclxuXHRcdFx0XHRcdFx0XHRcdGxvb3BcclxuXHRcdFx0XHRcdFx0XHRcdHBsYXlzSW5saW5lXHJcblx0XHRcdFx0XHRcdFx0XHRtdXRlZFxyXG5cdFx0XHRcdFx0XHRcdD5cclxuXHRcdFx0XHRcdFx0XHRcdDxzb3VyY2VcclxuXHRcdFx0XHRcdFx0XHRcdFx0c3JjPScvZGVzY3JpcHRvci5tcDQnXHJcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGU9J3ZpZGVvL21wNCdcclxuXHRcdFx0XHRcdFx0XHRcdC8+XHJcblx0XHRcdFx0XHRcdFx0PC92aWRlbz5cclxuXHRcdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHJcblx0XHRcdFx0PGRpdlxyXG5cdFx0XHRcdFx0c3R5bGU9e3tcclxuXHRcdFx0XHRcdFx0dHJhbnNmb3JtOiBgdHJhbnNsYXRlWSgtJHt0cmFuc2xhdGVDb250ZW50fSUpIHNjYWxlKCR7c2NhbGVDb250ZW50fSlgLFxyXG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuXHRcdFx0XHRcdFx0ekluZGV4OiAnMicsXHJcblx0XHRcdFx0XHRcdG9wYWNpdHk6IG9wYWNpdHlDb250ZW50LFxyXG5cdFx0XHRcdFx0XHRoZWlnaHQ6ICcxMDAlJ1xyXG5cdFx0XHRcdFx0fX1cclxuXHRcdFx0XHQ+XHJcblx0XHRcdFx0XHQ8ZGl2XHJcblx0XHRcdFx0XHRcdGNsYXNzTmFtZT17Y2xhc3Nlcy5kZXNjcmlwdG9yX19jb250ZW50fVxyXG5cdFx0XHRcdFx0XHRyZWY9e2NvbnRlbnRSZWZ9XHJcblx0XHRcdFx0XHQ+XHJcblx0XHRcdFx0XHRcdDxoMVxyXG5cdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17Y24oJ3NpdGUtdGl0bGUtMScsIGNsYXNzZXMuZGVzY3JpcHRvcl9fY29udGVudFRpdGxlKX1cclxuXHRcdFx0XHRcdFx0PlxyXG5cdFx0XHRcdFx0XHRcdNCh0J7Ql9CU0JDQldCcINGB0LDQudGC0Ysg0LTQu9GPINCx0LjQt9C90LXRgdCwXHJcblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPXtjbGFzc2VzLmRlc2NyaXB0b3JfX2NvbnRlbnRSZWdpb259PlxyXG5cdFx0XHRcdFx0XHRcdFx00JIg0LXQutCw0YLQtdGA0LjQvdCx0YPRgNCz0LVcclxuXHRcdFx0XHRcdFx0XHQ8L3NwYW4+XHJcblx0XHRcdFx0XHRcdDwvaDE+XHJcblx0XHRcdFx0XHRcdDxwIGNsYXNzTmFtZT17Y2xhc3Nlcy5kZXNjcmlwdG9yX19jb250ZW50VGV4dH0+XHJcblx0XHRcdFx0XHRcdFx00YHQvtC30LTQsNC00LjQvCDRgdCw0LnRgiDQtNC70Y8g0LHQuNC30L3QtdGB0LAg0YEg0L/RgNC10LfQtdC90YLQsNGG0LjQtdC5INGD0YHQu9GD0LMg0Lgg0YbQtdC70LXQstGL0LzQuFxyXG5cdFx0XHRcdFx0XHRcdNC00LXQudGB0YLQstC40Y/QvNC4INC00LvRjyDQt9Cw0Y/QstC+0LouINCg0LXRiNC40Lwg0LfQsNC00LDRh9C4INC40LzQuNC00LbQsCDQutC+0LzQv9Cw0L3QuNC4LlxyXG5cdFx0XHRcdFx0XHQ8L3A+XHJcblx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHJcblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuZGVzY3JpcHRvcl9fcmlnaHR9PlxyXG5cdFx0XHRcdFx0PGRpdlxyXG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzZXMuZGVzY3JpcHRvcl9fcmlnaHRRdWFudGl0eX1cclxuXHRcdFx0XHRcdFx0cmVmPXtxdWFudGl0eVJlZn1cclxuXHRcdFx0XHRcdD5cclxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuZGVzY3JpcHRvcl9fcmlnaHRRdWFudGl0eU51bWJlcn0+KyAxNTA8L2Rpdj5cclxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMuZGVzY3JpcHRvcl9fcmlnaHRRdWFudGl0eVRleHR9PlxyXG5cdFx0XHRcdFx0XHRcdNGD0YHQv9C10YjQvdC+INC30LDQv9GD0YnQtdC90L3Ri9GFINGB0LDQudGC0L7QsiDQuCDRgdC10YDQstC40YHQvtCyXHJcblx0XHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHQ8ZGl2XHJcblx0XHRcdFx0XHRcdGNsYXNzTmFtZT17Y2xhc3Nlcy5kZXNjcmlwdG9yX19yaWdodFByaWNlfVxyXG5cdFx0XHRcdFx0XHRyZWY9e3ByaWNlUmVmfVxyXG5cdFx0XHRcdFx0XHRzdHlsZT17XHJcblx0XHRcdFx0XHRcdFx0aXNQbGF5XHJcblx0XHRcdFx0XHRcdFx0XHQ/IHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm06IGB0cmFuc2xhdGVZKC0ke3RyYW5zbGF0ZUNvbnRlbnR9JSkgc2NhbGUoJHtzY2FsZUNvbnRlbnR9KWAsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3BhY2l0eTogb3BhY2l0eUNvbnRlbnRcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0OiB7fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHQ+XHJcblx0XHRcdFx0XHRcdNCh0YLQsNGA0YIg0L7RglxyXG5cdFx0XHRcdFx0XHQ8c3Bhbj4yMDAgMDAwIOKCvTwvc3Bhbj5cclxuXHRcdFx0XHRcdFx0PHNwYW4+MzAg0YDQsNCxLiDQtNC90LXQuTwvc3Bhbj5cclxuXHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHQ8L0NvbnRhaW5lcj5cclxuXHRcdDwvc2VjdGlvbj5cclxuXHQpXHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUdTQVAiLCJjbiIsImdzYXAiLCJTY3JvbGxUcmlnZ2VyIiwiSW1hZ2UiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIkNvbnRhaW5lciIsInVzZVNjcm9sbCIsImNsYXNzZXMiLCJyZWdpc3RlclBsdWdpbiIsIkRlc2NyaXB0b3IiLCJpc1BsYXkiLCJzZXRJc1BsYXkiLCJ0cmFuc2xhdGVDb250ZW50Iiwic2V0VHJhbnNsYXRlQ29udGVudCIsIm9wYWNpdHlDb250ZW50Iiwic2V0T3BhY2l0eUNvbnRlbnQiLCJzY2FsZUNvbnRlbnQiLCJzZXRTY2FsZUNvbnRlbnQiLCJxdWFudGl0eVJlZiIsImNvbnRlbnRSZWYiLCJiYWNrZ3JvdW5kUmVmIiwicHJpY2VSZWYiLCJkZXNjcmlwdG9yUmVmIiwidmlkZW9SZWYiLCJhY3Rpb25zUmVmIiwic2Nyb2xsIiwidHJhbnNsYXRlIiwib3BhY2l0eSIsInNjYWxlIiwiY3VycmVudCIsImNsaWVudEhlaWdodCIsInBhdXNlZCIsInBhdXNlIiwicGxheSIsInRsIiwidGltZWxpbmUiLCJ0byIsIm1hc2tTaXplIiwiZHVyYXRpb24iLCJkZWxheSIsIm9uQ29tcGxldGUiLCJyZWFkeVN0YXRlIiwidHJhbnNmb3JtIiwic2VjdGlvbiIsImNsYXNzTmFtZSIsImRlc2NyaXB0b3IiLCJpZCIsInJlZiIsInZhcmlhbnQiLCJkZXNjcmlwdG9yX19jb250YWluZXIiLCJkaXYiLCJkZXNjcmlwdG9yX19hY3Rpb25zVHJpZ2dlciIsImRlc2NyaXB0b3JfX2FjdGlvbnMiLCJkZXNjcmlwdG9yX19hY3Rpb25zSW1hZ2UiLCJzcmMiLCJhbHQiLCJzaXplcyIsImZpbGwiLCJkZXNjcmlwdG9yX19hY3Rpb25zVmlkZW8iLCJ2aWRlbyIsInByZWxvYWQiLCJjb250cm9scyIsImF1dG9QbGF5IiwibG9vcCIsInBsYXlzSW5saW5lIiwibXV0ZWQiLCJzb3VyY2UiLCJ0eXBlIiwic3R5bGUiLCJwb3NpdGlvbiIsInpJbmRleCIsImhlaWdodCIsImRlc2NyaXB0b3JfX2NvbnRlbnQiLCJoMSIsImRlc2NyaXB0b3JfX2NvbnRlbnRUaXRsZSIsInNwYW4iLCJkZXNjcmlwdG9yX19jb250ZW50UmVnaW9uIiwicCIsImRlc2NyaXB0b3JfX2NvbnRlbnRUZXh0IiwiZGVzY3JpcHRvcl9fcmlnaHQiLCJkZXNjcmlwdG9yX19yaWdodFF1YW50aXR5IiwiZGVzY3JpcHRvcl9fcmlnaHRRdWFudGl0eU51bWJlciIsImRlc2NyaXB0b3JfX3JpZ2h0UXVhbnRpdHlUZXh0IiwiZGVzY3JpcHRvcl9fcmlnaHRQcmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/descriptor/Descriptor.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/motivations/Motivations.tsx":
/*!****************************************************!*\
  !*** ./src/components/motivations/Motivations.tsx ***!
  \****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Motivations: function() { return /* binding */ Motivations; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _text_wrap_TextWrap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../text-wrap/TextWrap */ \"(app-pages-browser)/./src/components/text-wrap/TextWrap.tsx\");\n/* harmony import */ var _text_wrap_TextWrapItem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../text-wrap/TextWrapItem */ \"(app-pages-browser)/./src/components/text-wrap/TextWrapItem.tsx\");\n/* harmony import */ var _ui_container_Container__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ui/container/Container */ \"(app-pages-browser)/./src/components/ui/container/Container.tsx\");\n/* harmony import */ var _Motivations_module_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Motivations.module.scss */ \"(app-pages-browser)/./src/components/motivations/Motivations.module.scss\");\n/* harmony import */ var _Motivations_module_scss__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_Motivations_module_scss__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _MotivationsItem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MotivationsItem */ \"(app-pages-browser)/./src/components/motivations/MotivationsItem.tsx\");\n/* __next_internal_client_entry_do_not_use__ Motivations auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nvar text = [\n    {\n        image: \"/home-motivations/wrap1.svg\"\n    },\n    {\n        image: \"/home-motivations/wrap2.svg\"\n    }\n];\nvar motivations = [\n    {\n        image: \"/home-motivations/1.svg\",\n        title: \"   \",\n        texts: [\n            \"    ,    ,   .\",\n            \"            .\"\n        ]\n    },\n    {\n        image: \"/home-motivations/2.svg\",\n        title: \"  =  \",\n        texts: [\n            \"       .     .\",\n            \"   ,       -.\"\n        ]\n    },\n    {\n        image: \"/home-motivations/3.gif\",\n        title: \"       \",\n        texts: [\n            \"  -    ,   ,       .\",\n            \"             .\"\n        ]\n    },\n    {\n        image: \"/home-motivations/4.svg\",\n        title: \"  =  \",\n        texts: [\n            \"      ,      -.\",\n            \"      : , , ,       .\",\n            \"       !\"\n        ]\n    }\n];\nfunction Motivations() {\n    var _this = this;\n    _s();\n    var textRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n        className: (_Motivations_module_scss__WEBPACK_IMPORTED_MODULE_5___default().motivations),\n        children: [\n            text.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_text_wrap_TextWrap__WEBPACK_IMPORTED_MODULE_2__.TextWrap, {\n                id: \"motivation-text-wrap\",\n                className: (_Motivations_module_scss__WEBPACK_IMPORTED_MODULE_5___default().motivations__textWrap),\n                ref: textRef,\n                children: text.map(function(t, i) {\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_text_wrap_TextWrapItem__WEBPACK_IMPORTED_MODULE_3__.TextWrapItem, {\n                        image: t.image,\n                        index: i,\n                        reference: textRef,\n                        id: \"#motivation-text-wrap\"\n                    }, i, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\motivations\\\\Motivations.tsx\",\n                        lineNumber: 69,\n                        columnNumber: 8\n                    }, _this);\n                })\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\motivations\\\\Motivations.tsx\",\n                lineNumber: 62,\n                columnNumber: 5\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_container_Container__WEBPACK_IMPORTED_MODULE_4__.Container, {\n                variant: \"xl\",\n                className: (_Motivations_module_scss__WEBPACK_IMPORTED_MODULE_5___default().motivations__container),\n                children: motivations.length > 0 && motivations.map(function(motivation, index) {\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_MotivationsItem__WEBPACK_IMPORTED_MODULE_6__.MotivationsItem, {\n                        image: motivation.image,\n                        title: motivation.title,\n                        texts: motivation.texts\n                    }, index, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\motivations\\\\Motivations.tsx\",\n                        lineNumber: 86,\n                        columnNumber: 7\n                    }, _this);\n                })\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\motivations\\\\Motivations.tsx\",\n                lineNumber: 80,\n                columnNumber: 4\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\motivations\\\\Motivations.tsx\",\n        lineNumber: 60,\n        columnNumber: 3\n    }, this);\n}\n_s(Motivations, \"w6wg8oN6T1JIeHvMfowtaM3MyjI=\");\n_c = Motivations;\nvar _c;\n$RefreshReg$(_c, \"Motivations\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL21vdGl2YXRpb25zL01vdGl2YXRpb25zLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFFOEI7QUFFa0I7QUFDUTtBQUNIO0FBRU47QUFDSTtBQUVuRCxJQUFNTSxPQUFPO0lBQ1o7UUFDQ0MsT0FBTztJQUNSO0lBQ0E7UUFDQ0EsT0FBTztJQUNSO0NBQ0E7QUFFRCxJQUFNQyxjQUFjO0lBQ25CO1FBQ0NELE9BQU87UUFDUEUsT0FBTztRQUNQQyxPQUFPO1lBQ047WUFDQTtTQUNBO0lBQ0Y7SUFDQTtRQUNDSCxPQUFPO1FBQ1BFLE9BQU87UUFDUEMsT0FBTztZQUNOO1lBQ0E7U0FDQTtJQUNGO0lBQ0E7UUFDQ0gsT0FBTztRQUNQRSxPQUFPO1FBQ1BDLE9BQU87WUFDTjtZQUNBO1NBQ0E7SUFDRjtJQUNBO1FBQ0NILE9BQU87UUFDUEUsT0FBTztRQUNQQyxPQUFPO1lBQ047WUFDQTtZQUNBO1NBQ0E7SUFDRjtDQUNBO0FBRU0sU0FBU0M7OztJQUNmLElBQU1DLFVBQVVaLDZDQUFNQSxDQUFDO0lBQ3ZCLHFCQUNDLDhEQUFDYTtRQUFRQyxXQUFXViw2RUFBbUI7O1lBQ3JDRSxLQUFLUyxNQUFNLEdBQUcsbUJBQ2QsOERBQUNkLHlEQUFRQTtnQkFDUmUsSUFBRztnQkFDSEYsV0FBV1YsdUZBQTZCO2dCQUN4Q2MsS0FBS047MEJBRUpOLEtBQUthLEdBQUcsQ0FBQyxTQUFDQyxHQUFHQztvQkFDYixxQkFDQyw4REFBQ25CLGlFQUFZQTt3QkFDWkssT0FBT2EsRUFBRWIsS0FBSzt3QkFDZGUsT0FBT0Q7d0JBRVBFLFdBQVdYO3dCQUNYSSxJQUFHO3VCQUZFSzs7Ozs7Z0JBS1I7Ozs7OzswQkFHRiw4REFBQ2xCLDhEQUFTQTtnQkFDVHFCLFNBQVE7Z0JBQ1JWLFdBQVdWLHdGQUE4QjswQkFFeENJLFlBQVlPLE1BQU0sR0FBRyxLQUNyQlAsWUFBWVcsR0FBRyxDQUFDLFNBQUNPLFlBQVlKO3lDQUM1Qiw4REFBQ2pCLDZEQUFlQTt3QkFFZkUsT0FBT21CLFdBQVduQixLQUFLO3dCQUN2QkUsT0FBT2lCLFdBQVdqQixLQUFLO3dCQUN2QkMsT0FBT2dCLFdBQVdoQixLQUFLO3VCQUhsQlk7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBU1o7R0F2Q2dCWDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9tb3RpdmF0aW9ucy9Nb3RpdmF0aW9ucy50c3g/OTBhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCB7IHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xyXG5cclxuaW1wb3J0IHsgVGV4dFdyYXAgfSBmcm9tICcuLi90ZXh0LXdyYXAvVGV4dFdyYXAnXHJcbmltcG9ydCB7IFRleHRXcmFwSXRlbSB9IGZyb20gJy4uL3RleHQtd3JhcC9UZXh0V3JhcEl0ZW0nXHJcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJy4uL3VpL2NvbnRhaW5lci9Db250YWluZXInXHJcblxyXG5pbXBvcnQgY2xhc3NlcyBmcm9tICcuL01vdGl2YXRpb25zLm1vZHVsZS5zY3NzJ1xyXG5pbXBvcnQgeyBNb3RpdmF0aW9uc0l0ZW0gfSBmcm9tICcuL01vdGl2YXRpb25zSXRlbSdcclxuXHJcbmNvbnN0IHRleHQgPSBbXHJcblx0e1xyXG5cdFx0aW1hZ2U6ICcvaG9tZS1tb3RpdmF0aW9ucy93cmFwMS5zdmcnXHJcblx0fSxcclxuXHR7XHJcblx0XHRpbWFnZTogJy9ob21lLW1vdGl2YXRpb25zL3dyYXAyLnN2ZydcclxuXHR9XHJcbl1cclxuXHJcbmNvbnN0IG1vdGl2YXRpb25zID0gW1xyXG5cdHtcclxuXHRcdGltYWdlOiAnL2hvbWUtbW90aXZhdGlvbnMvMS5zdmcnLFxyXG5cdFx0dGl0bGU6ICfQkNC90LDQu9C40Lcg0L/RgNC+0LXQutGC0LDQuCDRgNCw0LfRgNCw0LHQvtGC0LrQsCDRgdGC0YDQsNGC0LXQs9C40LgnLFxyXG5cdFx0dGV4dHM6IFtcclxuXHRcdFx0J9Cc0Ysg0LLRgdC10LPQtNCwINC/0YDQvtCy0L7QtNC40Lwg0LDQvdCw0LvQuNC3INC/0YDQvtC10LrRgtCwLCDQuNC30YPRh9Cw0LXQvCDRhtC10LvQuCDQuCDQt9Cw0LTQsNGH0LgsINC/0L7QtNCx0LjRgNCw0LXQvCDRjdGE0YTQtdC60YLQuNCy0L3Ri9C1INC40L3RgdGC0YDRg9C80LXQvdGC0YsuJyxcclxuXHRcdFx0J9CR0LXQtyDQs9GA0LDQvNC+0YLQvdC+0LPQviDQv9C70LDQvdC40YDQvtCy0LDQvdC40Y8g0LHQuNC30L3QtdGBINGA0LjRgdC60YPQtdGCINC/0L7RgtC10YDRj9GC0Ywg0LjQvdCy0LXRgdGC0LjRhtC40Lgg0Lgg0LLRgNC10LzRjyDQtNC70Y8g0YDQtdGI0LXQvdC40Y8g0L/QvtGB0YLQsNCy0LvQtdC90L3Ri9GFINC30LDQtNCw0YcuJ1xyXG5cdFx0XVxyXG5cdH0sXHJcblx0e1xyXG5cdFx0aW1hZ2U6ICcvaG9tZS1tb3RpdmF0aW9ucy8yLnN2ZycsXHJcblx0XHR0aXRsZTogJ9Ca0YDQtdCw0YLQuNCy0L3Ri9C5INC/0L7QtNGF0L7QtCA9INC40L3RgdGC0YDRg9C80LXQvdGCINC/0YDQvtC00LDQticsXHJcblx0XHR0ZXh0czogW1xyXG5cdFx0XHQn0JIg0L3QsNGB0YvRidC10L3QvdC+0Lwg0YDRi9C90LrQtSDQv9GA0LjRgdGD0YLQstC40Y8g0L3QtdC00L7RgdGC0LDRgtC+0YfQvdC+IOKAkyDQvdC10L7QsdGF0L7QtNC40LzQviDQstGL0LTQtdC70Y/RgtGM0YHRjy4g0KjQsNCx0LvQvtC90L3Ri9C1INGA0LXRiNC10L3QuNGPINGD0LbQtSDQvdC1INGA0LDQsdC+0YLQsNGO0YIuJyxcclxuXHRcdFx0J9CR0LjQt9C90LXRgdGDINC90LXQvtCx0YXQvtC00LjQvNGLINGB0LLQtdC20LjQtSDQuNC00LXQuCwg0YPQvdC40LrQsNC70YzQvdGL0LUg0YDQtdGI0LXQvdC40Y8g0Lgg0YHQvtCy0YDQtdC80LXQvdC90YvQtSDQuNC90YHRgtGA0YPQvNC10L3RgtGLINC00LvRjyDQsdC40LfQvdC10YEt0LfQsNC00LDRhy4nXHJcblx0XHRdXHJcblx0fSxcclxuXHR7XHJcblx0XHRpbWFnZTogJy9ob21lLW1vdGl2YXRpb25zLzMuZ2lmJyxcclxuXHRcdHRpdGxlOiAn0JjQt9GD0YfQsNC10Lwg0LLQsNGI0YMg0KbQkCDQuCDQv9C+0LzQvtCz0LDQtdC8INCy0YvQtNC10LvQuNGC0YzRgdGPINGB0YDQtdC00Lgg0LrQvtC90LrRg9GA0LXQvdGC0L7QsicsXHJcblx0XHR0ZXh0czogW1xyXG5cdFx0XHQn0KDQsNC30YDQsNCx0L7RgtC60LAg0LvRjtCx0L7Qs9C+INCx0LjQt9C90LXRgS3QuNC90YHRgtGA0YPQvNC10L3RgtCwINC90LDRh9C40L3QsNC10YLRgdGPINGBINC/0L7RgdGC0LDQvdC+0LLQutC4INGG0LXQu9C10LksINCw0L3QsNC70LjQt9CwINGG0LXQu9C10LLQvtC5INCw0YPQtNC40YLQvtGA0LjQuCwg0LXQtSDQv9C+0YLRgNC10LHQvdC+0YHRgtC10Lkg0Lgg0LLRi9GP0LLQu9C10L3QuNGPINC60L7QvdC60YPRgNC10L3RgtC90YvRhSDQv9GA0LXQuNC80YPRidC10YHRgtCyINC60L7QvNC/0LDQvdC40LguJyxcclxuXHRcdFx0J9Cf0YDQtdC90LXQsdGA0LXQttC10L3QuNC1INGN0YLQuNC8INGN0YLQsNC/0L7QvCDQstC70LXRh9GR0YIg0LfQsCDRgdC+0LHQvtC5INGA0LjRgdC6INGB0L7Qt9C00LDQvdC40Y8g0L3QtSDRjdGE0YTQtdC60YLQuNCy0L3QvtCz0L4g0YDQtdGB0YPRgNGB0LAg0YEg0L3QuNC30LrQvtC5INC60L7QvdCy0LXRgNGB0LjQtdC5LidcclxuXHRcdF1cclxuXHR9LFxyXG5cdHtcclxuXHRcdGltYWdlOiAnL2hvbWUtbW90aXZhdGlvbnMvNC5zdmcnLFxyXG5cdFx0dGl0bGU6ICfQrdGE0YTQtdC60YLQuNCy0L3Ri9C1INGA0LXRiNC10L3QuNGPID0g0KPRgdC/0LXRiNC90YvQuSDQsdC40LfQvdC10YEnLFxyXG5cdFx0dGV4dHM6IFtcclxuXHRcdFx0J9Cg0LDQt9Cy0LjRgtC40LUg0L3QsNGI0LXQuSDQutC+0LzQv9Cw0L3QuNC4INC30LDQstC40YHQuNGCINC+0YIg0YPRgdC/0LXRhdCwINC/0YDQvtC10LrRgtC+0LIsINC/0L7RjdGC0L7QvNGDINC80Ysg0L/RgNC10LTQu9Cw0LPQsNC10Lwg0YLQvtC70YzQutC+INGN0YTRhNC10LrRgtC40LLQvdGL0LUg0LHQuNC30L3QtdGBLdGA0LXRiNC10L3QuNGPLicsXHJcblx0XHRcdCfQnNGLINGA0LDQt9C00LXQu9GP0LXQvCDRhtC10L3QvdC+0YHRgtC4INC90LDRiNC40YUg0LrQu9C40LXQvdGC0L7QsiDQutCw0Log0YHQstC+0Lg6INGC0LDQudC80LjQvdCzLCDQv9GA0LjQsdGL0LvRjCwg0LrQvtC80L/QtdGC0LXQvdGC0L3QvtGB0YLRjCwg0LTQtdC70L7QstCw0Y8g0Y3RgtC40LrQsCDQuCDQu9GO0LHQvtCy0Ywg0Log0YHQstC+0LXQvNGDINC00LXQu9GDLicsXHJcblx0XHRcdCfQl9Cw0LvQvtCzINGD0YHQv9C10YjQvdC+0LPQviDQv9GA0L7QtdC60YLQsCDigJMg0LLRi9Cx0L7RgCDQs9GA0LDQvNC+0YLQvdC+0LPQviDQvNC+0YLQuNCy0LjRgNC+0LLQsNC90L3QvtCz0L4g0YDQsNC30YDQsNCx0L7RgtGH0LjQutCwISdcclxuXHRcdF1cclxuXHR9XHJcbl1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBNb3RpdmF0aW9ucygpIHtcclxuXHRjb25zdCB0ZXh0UmVmID0gdXNlUmVmKG51bGwpXHJcblx0cmV0dXJuIChcclxuXHRcdDxzZWN0aW9uIGNsYXNzTmFtZT17Y2xhc3Nlcy5tb3RpdmF0aW9uc30+XHJcblx0XHRcdHt0ZXh0Lmxlbmd0aCA+IDAgJiYgKFxyXG5cdFx0XHRcdDxUZXh0V3JhcFxyXG5cdFx0XHRcdFx0aWQ9J21vdGl2YXRpb24tdGV4dC13cmFwJ1xyXG5cdFx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc2VzLm1vdGl2YXRpb25zX190ZXh0V3JhcH1cclxuXHRcdFx0XHRcdHJlZj17dGV4dFJlZn1cclxuXHRcdFx0XHQ+XHJcblx0XHRcdFx0XHR7dGV4dC5tYXAoKHQsIGkpID0+IHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIChcclxuXHRcdFx0XHRcdFx0XHQ8VGV4dFdyYXBJdGVtXHJcblx0XHRcdFx0XHRcdFx0XHRpbWFnZT17dC5pbWFnZX1cclxuXHRcdFx0XHRcdFx0XHRcdGluZGV4PXtpfVxyXG5cdFx0XHRcdFx0XHRcdFx0a2V5PXtpfVxyXG5cdFx0XHRcdFx0XHRcdFx0cmVmZXJlbmNlPXt0ZXh0UmVmfVxyXG5cdFx0XHRcdFx0XHRcdFx0aWQ9JyNtb3RpdmF0aW9uLXRleHQtd3JhcCdcclxuXHRcdFx0XHRcdFx0XHQvPlxyXG5cdFx0XHRcdFx0XHQpXHJcblx0XHRcdFx0XHR9KX1cclxuXHRcdFx0XHQ8L1RleHRXcmFwPlxyXG5cdFx0XHQpfVxyXG5cdFx0XHQ8Q29udGFpbmVyXHJcblx0XHRcdFx0dmFyaWFudD0neGwnXHJcblx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc2VzLm1vdGl2YXRpb25zX19jb250YWluZXJ9XHJcblx0XHRcdD5cclxuXHRcdFx0XHR7bW90aXZhdGlvbnMubGVuZ3RoID4gMCAmJlxyXG5cdFx0XHRcdFx0bW90aXZhdGlvbnMubWFwKChtb3RpdmF0aW9uLCBpbmRleCkgPT4gKFxyXG5cdFx0XHRcdFx0XHQ8TW90aXZhdGlvbnNJdGVtXHJcblx0XHRcdFx0XHRcdFx0a2V5PXtpbmRleH1cclxuXHRcdFx0XHRcdFx0XHRpbWFnZT17bW90aXZhdGlvbi5pbWFnZX1cclxuXHRcdFx0XHRcdFx0XHR0aXRsZT17bW90aXZhdGlvbi50aXRsZX1cclxuXHRcdFx0XHRcdFx0XHR0ZXh0cz17bW90aXZhdGlvbi50ZXh0c31cclxuXHRcdFx0XHRcdFx0Lz5cclxuXHRcdFx0XHRcdCkpfVxyXG5cdFx0XHQ8L0NvbnRhaW5lcj5cclxuXHRcdDwvc2VjdGlvbj5cclxuXHQpXHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZVJlZiIsIlRleHRXcmFwIiwiVGV4dFdyYXBJdGVtIiwiQ29udGFpbmVyIiwiY2xhc3NlcyIsIk1vdGl2YXRpb25zSXRlbSIsInRleHQiLCJpbWFnZSIsIm1vdGl2YXRpb25zIiwidGl0bGUiLCJ0ZXh0cyIsIk1vdGl2YXRpb25zIiwidGV4dFJlZiIsInNlY3Rpb24iLCJjbGFzc05hbWUiLCJsZW5ndGgiLCJpZCIsIm1vdGl2YXRpb25zX190ZXh0V3JhcCIsInJlZiIsIm1hcCIsInQiLCJpIiwiaW5kZXgiLCJyZWZlcmVuY2UiLCJ2YXJpYW50IiwibW90aXZhdGlvbnNfX2NvbnRhaW5lciIsIm1vdGl2YXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/motivations/Motivations.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/motivations/MotivationsItem.tsx":
/*!********************************************************!*\
  !*** ./src/components/motivations/MotivationsItem.tsx ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MotivationsItem: function() { return /* binding */ MotivationsItem; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/image.js\");\n/* harmony import */ var _Motivations_module_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Motivations.module.scss */ \"(app-pages-browser)/./src/components/motivations/Motivations.module.scss\");\n/* harmony import */ var _Motivations_module_scss__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Motivations_module_scss__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nfunction MotivationsItem(param) {\n    var _this = this;\n    var image = param.image, texts = param.texts, title = param.title;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_Motivations_module_scss__WEBPACK_IMPORTED_MODULE_2___default().motivations__item),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_Motivations_module_scss__WEBPACK_IMPORTED_MODULE_2___default().motivations__itemContent),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_Motivations_module_scss__WEBPACK_IMPORTED_MODULE_2___default().motivations__itemContentImage),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                            src: image,\n                            alt: title,\n                            width: 107,\n                            height: 90\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\motivations\\\\MotivationsItem.tsx\",\n                            lineNumber: 16,\n                            columnNumber: 6\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\motivations\\\\MotivationsItem.tsx\",\n                        lineNumber: 15,\n                        columnNumber: 5\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h6\", {\n                        className: (_Motivations_module_scss__WEBPACK_IMPORTED_MODULE_2___default().motivations__itemContentTitle),\n                        children: title\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\motivations\\\\MotivationsItem.tsx\",\n                        lineNumber: 23,\n                        columnNumber: 5\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\motivations\\\\MotivationsItem.tsx\",\n                lineNumber: 14,\n                columnNumber: 4\n            }, this),\n            texts.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_Motivations_module_scss__WEBPACK_IMPORTED_MODULE_2___default().motivations__itemText),\n                children: texts.map(function(text, index) {\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: text\n                    }, index, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\motivations\\\\MotivationsItem.tsx\",\n                        lineNumber: 28,\n                        columnNumber: 7\n                    }, _this);\n                })\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\motivations\\\\MotivationsItem.tsx\",\n                lineNumber: 26,\n                columnNumber: 5\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\motivations\\\\MotivationsItem.tsx\",\n        lineNumber: 13,\n        columnNumber: 3\n    }, this);\n}\n_c = MotivationsItem;\nvar _c;\n$RefreshReg$(_c, \"MotivationsItem\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL21vdGl2YXRpb25zL01vdGl2YXRpb25zSXRlbS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQThCO0FBRWlCO0FBUXhDLFNBQVNFLGdCQUFnQixLQUF5Qzs7UUFBdkNDLFFBQUYsTUFBRUEsT0FBT0MsUUFBVCxNQUFTQSxPQUFPQyxRQUFoQixNQUFnQkE7SUFDL0MscUJBQ0MsOERBQUNDO1FBQUlDLFdBQVdOLG1GQUF5Qjs7MEJBQ3hDLDhEQUFDSztnQkFBSUMsV0FBV04sMEZBQWdDOztrQ0FDL0MsOERBQUNLO3dCQUFJQyxXQUFXTiwrRkFBcUM7a0NBQ3BELDRFQUFDRCxrREFBS0E7NEJBQ0xXLEtBQUtSOzRCQUNMUyxLQUFLUDs0QkFDTFEsT0FBTzs0QkFDUEMsUUFBUTs7Ozs7Ozs7Ozs7a0NBR1YsOERBQUNDO3dCQUFHUixXQUFXTiwrRkFBcUM7a0NBQUdJOzs7Ozs7Ozs7Ozs7WUFFdkRELE1BQU1hLE1BQU0sR0FBRyxtQkFDZiw4REFBQ1g7Z0JBQUlDLFdBQVdOLHVGQUE2QjswQkFDM0NHLE1BQU1lLEdBQUcsQ0FBQyxTQUFDQyxNQUFNQzt5Q0FDakIsOERBQUNDO2tDQUFlRjt1QkFBUkM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTWQ7S0F2QmdCbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvbW90aXZhdGlvbnMvTW90aXZhdGlvbnNJdGVtLnRzeD8yZmIzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBJbWFnZSBmcm9tICduZXh0L2ltYWdlJ1xyXG5cclxuaW1wb3J0IGNsYXNzZXMgZnJvbSAnLi9Nb3RpdmF0aW9ucy5tb2R1bGUuc2NzcydcclxuXHJcbmludGVyZmFjZSBJTW90aXZhdGlvbnNJdGVtIHtcclxuXHRpbWFnZTogc3RyaW5nXHJcblx0dGl0bGU6IHN0cmluZ1xyXG5cdHRleHRzOiBBcnJheTxzdHJpbmc+XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBNb3RpdmF0aW9uc0l0ZW0oeyBpbWFnZSwgdGV4dHMsIHRpdGxlIH06IElNb3RpdmF0aW9uc0l0ZW0pIHtcclxuXHRyZXR1cm4gKFxyXG5cdFx0PGRpdiBjbGFzc05hbWU9e2NsYXNzZXMubW90aXZhdGlvbnNfX2l0ZW19PlxyXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlcy5tb3RpdmF0aW9uc19faXRlbUNvbnRlbnR9PlxyXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzLm1vdGl2YXRpb25zX19pdGVtQ29udGVudEltYWdlfT5cclxuXHRcdFx0XHRcdDxJbWFnZVxyXG5cdFx0XHRcdFx0XHRzcmM9e2ltYWdlfVxyXG5cdFx0XHRcdFx0XHRhbHQ9e3RpdGxlfVxyXG5cdFx0XHRcdFx0XHR3aWR0aD17MTA3fVxyXG5cdFx0XHRcdFx0XHRoZWlnaHQ9ezkwfVxyXG5cdFx0XHRcdFx0Lz5cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHQ8aDYgY2xhc3NOYW1lPXtjbGFzc2VzLm1vdGl2YXRpb25zX19pdGVtQ29udGVudFRpdGxlfT57dGl0bGV9PC9oNj5cclxuXHRcdFx0PC9kaXY+XHJcblx0XHRcdHt0ZXh0cy5sZW5ndGggPiAwICYmIChcclxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlcy5tb3RpdmF0aW9uc19faXRlbVRleHR9PlxyXG5cdFx0XHRcdFx0e3RleHRzLm1hcCgodGV4dCwgaW5kZXgpID0+IChcclxuXHRcdFx0XHRcdFx0PHAga2V5PXtpbmRleH0+e3RleHR9PC9wPlxyXG5cdFx0XHRcdFx0KSl9XHJcblx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdCl9XHJcblx0XHQ8L2Rpdj5cclxuXHQpXHJcbn1cclxuIl0sIm5hbWVzIjpbIkltYWdlIiwiY2xhc3NlcyIsIk1vdGl2YXRpb25zSXRlbSIsImltYWdlIiwidGV4dHMiLCJ0aXRsZSIsImRpdiIsImNsYXNzTmFtZSIsIm1vdGl2YXRpb25zX19pdGVtIiwibW90aXZhdGlvbnNfX2l0ZW1Db250ZW50IiwibW90aXZhdGlvbnNfX2l0ZW1Db250ZW50SW1hZ2UiLCJzcmMiLCJhbHQiLCJ3aWR0aCIsImhlaWdodCIsImg2IiwibW90aXZhdGlvbnNfX2l0ZW1Db250ZW50VGl0bGUiLCJsZW5ndGgiLCJtb3RpdmF0aW9uc19faXRlbVRleHQiLCJtYXAiLCJ0ZXh0IiwiaW5kZXgiLCJwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/motivations/MotivationsItem.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/our-projects/Projects.tsx":
/*!**************************************************!*\
  !*** ./src/components/our-projects/Projects.tsx ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Projects: function() { return /* binding */ Projects; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _components_ui_container_Container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/ui/container/Container */ \"(app-pages-browser)/./src/components/ui/container/Container.tsx\");\n/* harmony import */ var _ui_reference_Reference__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ui/reference/Reference */ \"(app-pages-browser)/./src/components/ui/reference/Reference.tsx\");\n/* harmony import */ var _ProjectsGrid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ProjectsGrid */ \"(app-pages-browser)/./src/components/our-projects/ProjectsGrid.tsx\");\n/* harmony import */ var _ProjectsHeader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ProjectsHeader */ \"(app-pages-browser)/./src/components/our-projects/ProjectsHeader.tsx\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./styles.module.scss */ \"(app-pages-browser)/./src/components/our-projects/styles.module.scss\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_module_scss__WEBPACK_IMPORTED_MODULE_5__);\n/* __next_internal_client_entry_do_not_use__ Projects auto */ \n\n\n\n\n\nfunction Projects(projects) {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n        className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_5___default().ourProjects),\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_container_Container__WEBPACK_IMPORTED_MODULE_1__.Container, {\n            variant: \"xl\",\n            className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_5___default().ourProjects__container),\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ProjectsHeader__WEBPACK_IMPORTED_MODULE_4__.ProjectsHeader, {}, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\our-projects\\\\Projects.tsx\",\n                    lineNumber: 19,\n                    columnNumber: 5\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ProjectsGrid__WEBPACK_IMPORTED_MODULE_3__.ProjectsGrid, {}, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\our-projects\\\\Projects.tsx\",\n                    lineNumber: 20,\n                    columnNumber: 5\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_reference_Reference__WEBPACK_IMPORTED_MODULE_2__.Reference, {\n                    href: \"/\",\n                    className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_5___default().ourProjects__moreMobile),\n                    children: \"  \"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\our-projects\\\\Projects.tsx\",\n                    lineNumber: 21,\n                    columnNumber: 5\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\our-projects\\\\Projects.tsx\",\n            lineNumber: 15,\n            columnNumber: 4\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\our-projects\\\\Projects.tsx\",\n        lineNumber: 14,\n        columnNumber: 3\n    }, this);\n}\n_c = Projects;\nvar _c;\n$RefreshReg$(_c, \"Projects\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL291ci1wcm9qZWN0cy9Qcm9qZWN0cy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRStEO0FBRVY7QUFFUjtBQUNJO0FBRVA7QUFFbkMsU0FBU0ssU0FBU0MsUUFBc0I7SUFDOUMscUJBQ0MsOERBQUNDO1FBQVFDLFdBQVdKLHdFQUFtQjtrQkFDdEMsNEVBQUNKLHlFQUFTQTtZQUNUVSxTQUFRO1lBQ1JGLFdBQVdKLG1GQUE4Qjs7OEJBRXpDLDhEQUFDRCwyREFBY0E7Ozs7OzhCQUNmLDhEQUFDRCx1REFBWUE7Ozs7OzhCQUNiLDhEQUFDRCw4REFBU0E7b0JBQ1RXLE1BQUs7b0JBQ0xKLFdBQVdKLG9GQUErQjs4QkFDMUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTUw7S0FsQmdCQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9vdXItcHJvamVjdHMvUHJvamVjdHMudHN4PzdiYjYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXHJcblxyXG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tICdAL2NvbXBvbmVudHMvdWkvY29udGFpbmVyL0NvbnRhaW5lcidcclxuXHJcbmltcG9ydCB7IFJlZmVyZW5jZSB9IGZyb20gJy4uL3VpL3JlZmVyZW5jZS9SZWZlcmVuY2UnXHJcblxyXG5pbXBvcnQgeyBQcm9qZWN0c0dyaWQgfSBmcm9tICcuL1Byb2plY3RzR3JpZCdcclxuaW1wb3J0IHsgUHJvamVjdHNIZWFkZXIgfSBmcm9tICcuL1Byb2plY3RzSGVhZGVyJ1xyXG5pbXBvcnQgeyBUeXBlUHJvamVjdHMgfSBmcm9tICcuL3Byb2plY3RzLnR5cGVzJ1xyXG5pbXBvcnQgY2xhc3NlcyBmcm9tICcuL3N0eWxlcy5tb2R1bGUuc2NzcydcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBQcm9qZWN0cyhwcm9qZWN0czogVHlwZVByb2plY3RzKSB7XHJcblx0cmV0dXJuIChcclxuXHRcdDxzZWN0aW9uIGNsYXNzTmFtZT17Y2xhc3Nlcy5vdXJQcm9qZWN0c30+XHJcblx0XHRcdDxDb250YWluZXJcclxuXHRcdFx0XHR2YXJpYW50PSd4bCdcclxuXHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzZXMub3VyUHJvamVjdHNfX2NvbnRhaW5lcn1cclxuXHRcdFx0PlxyXG5cdFx0XHRcdDxQcm9qZWN0c0hlYWRlciAvPlxyXG5cdFx0XHRcdDxQcm9qZWN0c0dyaWQgLz5cclxuXHRcdFx0XHQ8UmVmZXJlbmNlXHJcblx0XHRcdFx0XHRocmVmPScvJ1xyXG5cdFx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc2VzLm91clByb2plY3RzX19tb3JlTW9iaWxlfVxyXG5cdFx0XHRcdD5cclxuXHRcdFx0XHRcdNGB0LzQvtGC0YDQtdGC0Ywg0LLRgdC1INC60LXQudGB0YtcclxuXHRcdFx0XHQ8L1JlZmVyZW5jZT5cclxuXHRcdFx0PC9Db250YWluZXI+XHJcblx0XHQ8L3NlY3Rpb24+XHJcblx0KVxyXG59XHJcbiJdLCJuYW1lcyI6WyJDb250YWluZXIiLCJSZWZlcmVuY2UiLCJQcm9qZWN0c0dyaWQiLCJQcm9qZWN0c0hlYWRlciIsImNsYXNzZXMiLCJQcm9qZWN0cyIsInByb2plY3RzIiwic2VjdGlvbiIsImNsYXNzTmFtZSIsIm91clByb2plY3RzIiwidmFyaWFudCIsIm91clByb2plY3RzX19jb250YWluZXIiLCJocmVmIiwib3VyUHJvamVjdHNfX21vcmVNb2JpbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/our-projects/Projects.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/our-projects/ProjectsGrid.tsx":
/*!******************************************************!*\
  !*** ./src/components/our-projects/ProjectsGrid.tsx ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProjectsGrid: function() { return /* binding */ ProjectsGrid; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\n/* harmony import */ var _swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _gsap_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @gsap/react */ \"(app-pages-browser)/./node_modules/.pnpm/@gsap+react@2.1.1/node_modules/@gsap/react/src/index.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! gsap */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js\");\n/* harmony import */ var gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! gsap/ScrollTrigger */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollTrigger.js\");\n/* harmony import */ var _store_our_project_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/store/our-project.store */ \"(app-pages-browser)/./src/store/our-project.store.ts\");\n/* harmony import */ var _ProjectsItem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ProjectsItem */ \"(app-pages-browser)/./src/components/our-projects/ProjectsItem.tsx\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./styles.module.scss */ \"(app-pages-browser)/./src/components/our-projects/styles.module.scss\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_module_scss__WEBPACK_IMPORTED_MODULE_5__);\n/* __next_internal_client_entry_do_not_use__ ProjectsGrid auto */ \n\n\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\nfunction ProjectsGrid() {\n    var _this = this;\n    _s();\n    var projects = (0,_store_our_project_store__WEBPACK_IMPORTED_MODULE_3__.useProjectStore)(function(state) {\n        return state.projects;\n    });\n    (0,_gsap_react__WEBPACK_IMPORTED_MODULE_2__.useGSAP)(function() {\n        gsap__WEBPACK_IMPORTED_MODULE_6__[\"default\"].registerPlugin(gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_7__.ScrollTrigger);\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_5___default().ourProjects__grid),\n        children: projects === null || projects === void 0 ? void 0 : projects.map(function(item, index) {\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(_ProjectsItem__WEBPACK_IMPORTED_MODULE_4__.ProjectsItem, (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_8__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_9__._)({}, item), {\n                key: index,\n                __source: {\n                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\our-projects\\\\ProjectsGrid.tsx\",\n                    lineNumber: 21,\n                    columnNumber: 6\n                },\n                __self: _this\n            }));\n        })\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\our-projects\\\\ProjectsGrid.tsx\",\n        lineNumber: 18,\n        columnNumber: 3\n    }, this);\n}\n_s(ProjectsGrid, \"bBOiTYmJarxRk9qpQn5p/v4wy/0=\", false, function() {\n    return [\n        _store_our_project_store__WEBPACK_IMPORTED_MODULE_3__.useProjectStore,\n        _gsap_react__WEBPACK_IMPORTED_MODULE_2__.useGSAP\n    ];\n});\n_c = ProjectsGrid;\nvar _c;\n$RefreshReg$(_c, \"ProjectsGrid\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL291ci1wcm9qZWN0cy9Qcm9qZWN0c0dyaWQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVxQztBQUNkO0FBQzJCO0FBRVM7QUFFZDtBQUNIO0FBRW5DLFNBQVNNOzs7SUFDZixJQUFNQyxXQUFXSix5RUFBZUEsQ0FBQ0ssU0FBQUE7ZUFBU0EsTUFBTUQsUUFBUTs7SUFDeERQLG9EQUFPQSxDQUFDO1FBQ1BDLDRDQUFJQSxDQUFDUSxjQUFjLENBQUNQLDZEQUFhQTtJQUNsQztJQUNBLHFCQUNDLDhEQUFDUTtRQUFJQyxXQUFXTiw4RUFBeUI7a0JBQ3ZDRSxxQkFBQUEsK0JBQUFBLFNBQVVNLEdBQUcsQ0FBQyxTQUFDQyxNQUFNQztZQUNyQixxQkFDQyxxREFBQ1gsdURBQVlBLEVBQUFBLG1FQUFBQSxDQUFBQSw2REFBQUEsS0FDUlU7Z0JBQ0pFLEtBQUtEOzs7Ozs7OztRQUdSOzs7Ozs7QUFHSDtHQWpCZ0JUOztRQUNFSCxxRUFBZUE7UUFDaENILGdEQUFPQTs7O0tBRlFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL291ci1wcm9qZWN0cy9Qcm9qZWN0c0dyaWQudHN4PzUwZTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXHJcblxyXG5pbXBvcnQgeyB1c2VHU0FQIH0gZnJvbSAnQGdzYXAvcmVhY3QnXHJcbmltcG9ydCBnc2FwIGZyb20gJ2dzYXAnXHJcbmltcG9ydCB7IFNjcm9sbFRyaWdnZXIgfSBmcm9tICdnc2FwL1Njcm9sbFRyaWdnZXInXHJcblxyXG5pbXBvcnQgeyB1c2VQcm9qZWN0U3RvcmUgfSBmcm9tICdAL3N0b3JlL291ci1wcm9qZWN0LnN0b3JlJ1xyXG5cclxuaW1wb3J0IHsgUHJvamVjdHNJdGVtIH0gZnJvbSAnLi9Qcm9qZWN0c0l0ZW0nXHJcbmltcG9ydCBjbGFzc2VzIGZyb20gJy4vc3R5bGVzLm1vZHVsZS5zY3NzJ1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFByb2plY3RzR3JpZCgpIHtcclxuXHRjb25zdCBwcm9qZWN0cyA9IHVzZVByb2plY3RTdG9yZShzdGF0ZSA9PiBzdGF0ZS5wcm9qZWN0cylcclxuXHR1c2VHU0FQKCgpID0+IHtcclxuXHRcdGdzYXAucmVnaXN0ZXJQbHVnaW4oU2Nyb2xsVHJpZ2dlcilcclxuXHR9KVxyXG5cdHJldHVybiAoXHJcblx0XHQ8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlcy5vdXJQcm9qZWN0c19fZ3JpZH0+XHJcblx0XHRcdHtwcm9qZWN0cz8ubWFwKChpdGVtLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRcdHJldHVybiAoXHJcblx0XHRcdFx0XHQ8UHJvamVjdHNJdGVtXHJcblx0XHRcdFx0XHRcdHsuLi5pdGVtfVxyXG5cdFx0XHRcdFx0XHRrZXk9e2luZGV4fVxyXG5cdFx0XHRcdFx0Lz5cclxuXHRcdFx0XHQpXHJcblx0XHRcdH0pfVxyXG5cdFx0PC9kaXY+XHJcblx0KVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VHU0FQIiwiZ3NhcCIsIlNjcm9sbFRyaWdnZXIiLCJ1c2VQcm9qZWN0U3RvcmUiLCJQcm9qZWN0c0l0ZW0iLCJjbGFzc2VzIiwiUHJvamVjdHNHcmlkIiwicHJvamVjdHMiLCJzdGF0ZSIsInJlZ2lzdGVyUGx1Z2luIiwiZGl2IiwiY2xhc3NOYW1lIiwib3VyUHJvamVjdHNfX2dyaWQiLCJtYXAiLCJpdGVtIiwiaW5kZXgiLCJrZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/our-projects/ProjectsGrid.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/our-projects/ProjectsHeader.tsx":
/*!********************************************************!*\
  !*** ./src/components/our-projects/ProjectsHeader.tsx ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProjectsHeader: function() { return /* binding */ ProjectsHeader; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var _ui_Heading_Heading__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ui/Heading/Heading */ \"(app-pages-browser)/./src/components/ui/Heading/Heading.tsx\");\n/* harmony import */ var _ui_reference_Reference__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ui/reference/Reference */ \"(app-pages-browser)/./src/components/ui/reference/Reference.tsx\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./styles.module.scss */ \"(app-pages-browser)/./src/components/our-projects/styles.module.scss\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_styles_module_scss__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\nfunction ProjectsHeader(param) {\n    var title = param.title, projects = param.projects;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_4___default().ourProjects__header),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_Heading_Heading__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                tag: \"h4\",\n                className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"site-title-2\", (_styles_module_scss__WEBPACK_IMPORTED_MODULE_4___default().ourProjects__title)),\n                children: \" \"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\our-projects\\\\ProjectsHeader.tsx\",\n                lineNumber: 12,\n                columnNumber: 4\n            }, this),\n            projects && (projects === null || projects === void 0 ? void 0 : projects.length) > 0 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: projects[0].title\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\our-projects\\\\ProjectsHeader.tsx\",\n                lineNumber: 19,\n                columnNumber: 5\n            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_reference_Reference__WEBPACK_IMPORTED_MODULE_3__.Reference, {\n                href: \"/\",\n                className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_4___default().ourProjects__more),\n                children: \"  \"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\our-projects\\\\ProjectsHeader.tsx\",\n                lineNumber: 21,\n                columnNumber: 5\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\our-projects\\\\ProjectsHeader.tsx\",\n        lineNumber: 11,\n        columnNumber: 3\n    }, this);\n}\n_c = ProjectsHeader;\nvar _c;\n$RefreshReg$(_c, \"ProjectsHeader\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL291ci1wcm9qZWN0cy9Qcm9qZWN0c0hlYWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBcUI7QUFFc0I7QUFDVTtBQUdYO0FBRW5DLFNBQVNJLGVBQWUsS0FBb0M7UUFBbENDLFFBQUYsTUFBRUEsT0FBT0MsV0FBVCxNQUFTQTtJQUN2QyxxQkFDQyw4REFBQ0M7UUFBSUMsV0FBV0wsZ0ZBQTJCOzswQkFDMUMsOERBQUNGLDJEQUFPQTtnQkFDUFMsS0FBSTtnQkFDSkYsV0FBV1IsZ0RBQUVBLENBQUMsZ0JBQWdCRywrRUFBMEI7MEJBQ3hEOzs7Ozs7WUFHQUcsWUFBWUEsQ0FBQUEscUJBQUFBLCtCQUFBQSxTQUFVTSxNQUFNLElBQUcsa0JBQy9CLDhEQUFDTDswQkFBS0QsUUFBUSxDQUFDLEVBQUUsQ0FBQ0QsS0FBSzs7Ozs7cUNBRXZCLDhEQUFDSCw4REFBU0E7Z0JBQ1RXLE1BQUs7Z0JBQ0xMLFdBQVdMLDhFQUF5QjswQkFDcEM7Ozs7Ozs7Ozs7OztBQU1MO0tBckJnQkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvb3VyLXByb2plY3RzL1Byb2plY3RzSGVhZGVyLnRzeD8wNGQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjbiBmcm9tICdjbHN4J1xyXG5cclxuaW1wb3J0IEhlYWRpbmcgZnJvbSAnLi4vdWkvSGVhZGluZy9IZWFkaW5nJ1xyXG5pbXBvcnQgeyBSZWZlcmVuY2UgfSBmcm9tICcuLi91aS9yZWZlcmVuY2UvUmVmZXJlbmNlJ1xyXG5cclxuaW1wb3J0IHsgSVByb2plY3RzU2xpZGVzIH0gZnJvbSAnLi9wcm9qZWN0cy50eXBlcydcclxuaW1wb3J0IGNsYXNzZXMgZnJvbSAnLi9zdHlsZXMubW9kdWxlLnNjc3MnXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gUHJvamVjdHNIZWFkZXIoeyB0aXRsZSwgcHJvamVjdHMgfTogSVByb2plY3RzU2xpZGVzKSB7XHJcblx0cmV0dXJuIChcclxuXHRcdDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzLm91clByb2plY3RzX19oZWFkZXJ9PlxyXG5cdFx0XHQ8SGVhZGluZ1xyXG5cdFx0XHRcdHRhZz0naDQnXHJcblx0XHRcdFx0Y2xhc3NOYW1lPXtjbignc2l0ZS10aXRsZS0yJywgY2xhc3Nlcy5vdXJQcm9qZWN0c19fdGl0bGUpfVxyXG5cdFx0XHQ+XHJcblx0XHRcdFx00J3QsNGI0Lgg0L/RgNC+0LXQutGC0YtcclxuXHRcdFx0PC9IZWFkaW5nPlxyXG5cdFx0XHR7cHJvamVjdHMgJiYgcHJvamVjdHM/Lmxlbmd0aCA+IDAgPyAoXHJcblx0XHRcdFx0PGRpdj57cHJvamVjdHNbMF0udGl0bGV9PC9kaXY+XHJcblx0XHRcdCkgOiAoXHJcblx0XHRcdFx0PFJlZmVyZW5jZVxyXG5cdFx0XHRcdFx0aHJlZj0nLydcclxuXHRcdFx0XHRcdGNsYXNzTmFtZT17Y2xhc3Nlcy5vdXJQcm9qZWN0c19fbW9yZX1cclxuXHRcdFx0XHQ+XHJcblx0XHRcdFx0XHTQodC80L7RgtGA0LXRgtGMINCy0YHQtSDQutC10LnRgdGLXHJcblx0XHRcdFx0PC9SZWZlcmVuY2U+XHJcblx0XHRcdCl9XHJcblx0XHQ8L2Rpdj5cclxuXHQpXHJcbn1cclxuIl0sIm5hbWVzIjpbImNuIiwiSGVhZGluZyIsIlJlZmVyZW5jZSIsImNsYXNzZXMiLCJQcm9qZWN0c0hlYWRlciIsInRpdGxlIiwicHJvamVjdHMiLCJkaXYiLCJjbGFzc05hbWUiLCJvdXJQcm9qZWN0c19faGVhZGVyIiwidGFnIiwib3VyUHJvamVjdHNfX3RpdGxlIiwibGVuZ3RoIiwiaHJlZiIsIm91clByb2plY3RzX19tb3JlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/our-projects/ProjectsHeader.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/our-projects/ProjectsItem.tsx":
/*!******************************************************!*\
  !*** ./src/components/our-projects/ProjectsItem.tsx ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProjectsItem: function() { return /* binding */ ProjectsItem; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _gsap_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @gsap/react */ \"(app-pages-browser)/./node_modules/.pnpm/@gsap+react@2.1.1/node_modules/@gsap/react/src/index.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! gsap */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js\");\n/* harmony import */ var gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! gsap/ScrollTrigger */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollTrigger.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/image.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./styles.module.scss */ \"(app-pages-browser)/./src/components/our-projects/styles.module.scss\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_module_scss__WEBPACK_IMPORTED_MODULE_5__);\n/* __next_internal_client_entry_do_not_use__ ProjectsItem auto */ \n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nfunction ProjectsItem(param) {\n    var _this = this;\n    var href = param.href, image = param.image, text = param.text, title = param.title, shadow = param.shadow, textColor = param.textColor, video = param.video;\n    _s();\n    var itemRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null);\n    var animationRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null);\n    var _useState = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_6__._)((0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(false), 2), isVisible = _useState[0], setIsVisible = _useState[1];\n    (0,_gsap_react__WEBPACK_IMPORTED_MODULE_1__.useGSAP)(function() {\n        gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_7__.ScrollTrigger.create({\n            trigger: itemRef.current,\n            start: \"top bottom\",\n            end: \"bottom top\",\n            animation: gsap__WEBPACK_IMPORTED_MODULE_8__[\"default\"].to(animationRef.current, {\n                translateY: 0,\n                opacity: 1,\n                duration: 1\n            }),\n            onToggle: function(self) {\n                if (self.isActive) {\n                    var _self_trigger;\n                    var video = (_self_trigger = self.trigger) === null || _self_trigger === void 0 ? void 0 : _self_trigger.querySelector(\"video\");\n                    setIsVisible(!isVisible);\n                    if (video) video.play();\n                } else {\n                    var _self_trigger1;\n                    var video1 = (_self_trigger1 = self.trigger) === null || _self_trigger1 === void 0 ? void 0 : _self_trigger1.querySelector(\"video\");\n                    if (video1) video1.pause();\n                }\n            }\n        });\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: animationRef,\n        style: {\n            transform: \"translateY(100%)\",\n            opacity: 0\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n            href: href,\n            className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])((_styles_module_scss__WEBPACK_IMPORTED_MODULE_5___default().ourProjects__item), textColor === \"white\" ? (_styles_module_scss__WEBPACK_IMPORTED_MODULE_5___default().ourProjects__textWhite) : \"\"),\n            ref: itemRef,\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])((_styles_module_scss__WEBPACK_IMPORTED_MODULE_5___default().ourProjects__itemImg), shadow ? (_styles_module_scss__WEBPACK_IMPORTED_MODULE_5___default().ourProjects__itemImgShadow) : \"\"),\n                    children: [\n                        image && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                            src: image,\n                            fill: true,\n                            alt: title\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\our-projects\\\\ProjectsItem.tsx\",\n                            lineNumber: 72,\n                            columnNumber: 7\n                        }, this),\n                        isVisible && (video === null || video === void 0 ? void 0 : video.length) ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"video\", {\n                            loop: true,\n                            autoPlay: true,\n                            preload: \"auto\",\n                            muted: true,\n                            playsInline: true,\n                            controls: false,\n                            poster: image,\n                            children: video.map(function(v, i) {\n                                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"source\", {\n                                    src: v.src,\n                                    type: v.type\n                                }, i, false, {\n                                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\our-projects\\\\ProjectsItem.tsx\",\n                                    lineNumber: 90,\n                                    columnNumber: 9\n                                }, _this);\n                            })\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\our-projects\\\\ProjectsItem.tsx\",\n                            lineNumber: 80,\n                            columnNumber: 7\n                        }, this) : null\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\our-projects\\\\ProjectsItem.tsx\",\n                    lineNumber: 65,\n                    columnNumber: 5\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h6\", {\n                    className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_5___default().ourProjects__itemTitle),\n                    children: title\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\our-projects\\\\ProjectsItem.tsx\",\n                    lineNumber: 100,\n                    columnNumber: 5\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_5___default().ourProjects__itemText),\n                    children: text\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\our-projects\\\\ProjectsItem.tsx\",\n                    lineNumber: 101,\n                    columnNumber: 5\n                }, this)\n            ]\n        }, Math.random(), true, {\n            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\our-projects\\\\ProjectsItem.tsx\",\n            lineNumber: 56,\n            columnNumber: 4\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\our-projects\\\\ProjectsItem.tsx\",\n        lineNumber: 52,\n        columnNumber: 3\n    }, this);\n}\n_s(ProjectsItem, \"jYCVrgJbY3f0e+WGzHdj6LeiZ8Q=\", false, function() {\n    return [\n        _gsap_react__WEBPACK_IMPORTED_MODULE_1__.useGSAP\n    ];\n});\n_c = ProjectsItem;\nvar _c;\n$RefreshReg$(_c, \"ProjectsItem\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL291ci1wcm9qZWN0cy9Qcm9qZWN0c0l0ZW0udHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVxQztBQUNoQjtBQUNFO0FBQzJCO0FBQ3BCO0FBQ1U7QUFJRTtBQUluQyxTQUFTUSxhQUFhLEtBUWY7O1FBUGJDLE9BRDRCLE1BQzVCQSxNQUNBQyxRQUY0QixNQUU1QkEsT0FDQUMsT0FINEIsTUFHNUJBLE1BQ0FDLFFBSjRCLE1BSTVCQSxPQUNBQyxTQUw0QixNQUs1QkEsUUFDQUMsWUFONEIsTUFNNUJBLFdBQ0FDLFFBUDRCLE1BTzVCQTs7SUFFQSxJQUFNQyxVQUFVWCw2Q0FBTUEsQ0FBQztJQUN2QixJQUFNWSxlQUFlWiw2Q0FBTUEsQ0FBQztJQUM1QixJQUFrQ0MsWUFBQUEsK0RBQUFBLENBQUFBLCtDQUFRQSxDQUFVLFlBQTdDWSxZQUEyQlosY0FBaEJhLGVBQWdCYjtJQUNsQ04sb0RBQU9BLENBQUM7UUFDUEcsNkRBQWFBLENBQUNpQixNQUFNLENBQUM7WUFDcEJDLFNBQVNMLFFBQVFNLE9BQU87WUFDeEJDLE9BQU87WUFDUEMsS0FBSztZQUNMQyxXQUFXdkIsNENBQUlBLENBQUN3QixFQUFFLENBQUNULGFBQWFLLE9BQU8sRUFBRTtnQkFDeENLLFlBQVk7Z0JBQ1pDLFNBQVM7Z0JBQ1RDLFVBQVU7WUFDWDtZQUNBQyxVQUFVQyxTQUFBQTtnQkFDVCxJQUFJQSxLQUFLQyxRQUFRLEVBQUU7d0JBQ0pEO29CQUFkLElBQU1oQixTQUFRZ0IsZ0JBQUFBLEtBQUtWLE9BQU8sY0FBWlUsb0NBQUFBLGNBQWNFLGFBQWEsQ0FBQztvQkFDMUNkLGFBQWEsQ0FBQ0Q7b0JBRWQsSUFBSUgsT0FBT0EsTUFBTW1CLElBQUk7Z0JBQ3RCLE9BQU87d0JBQ1FIO29CQUFkLElBQU1oQixVQUFRZ0IsaUJBQUFBLEtBQUtWLE9BQU8sY0FBWlUscUNBQUFBLGVBQWNFLGFBQWEsQ0FBQztvQkFDMUMsSUFBSWxCLFFBQU9BLE9BQU1vQixLQUFLO2dCQUN2QjtZQUNEO1FBQ0Q7SUFDRDtJQUNBLHFCQUNDLDhEQUFDQztRQUNBQyxLQUFLcEI7UUFDTHFCLE9BQU87WUFBRUMsV0FBVztZQUFvQlgsU0FBUztRQUFFO2tCQUVuRCw0RUFBQ1k7WUFDQS9CLE1BQU1BO1lBQ05nQyxXQUFXeEMsZ0RBQUVBLENBQ1pNLDhFQUF5QixFQUN6Qk8sY0FBYyxVQUFVUCxtRkFBOEIsR0FBRztZQUcxRDhCLEtBQUtyQjs7OEJBRUwsOERBQUNvQjtvQkFDQUssV0FBV3hDLGdEQUFFQSxDQUNaTSxpRkFBNEIsRUFDNUJNLFNBQVNOLHVGQUFrQyxHQUFHOzt3QkFHOUNHLHVCQUNBLDhEQUFDTixrREFBS0E7NEJBQ0wwQyxLQUFLcEM7NEJBQ0xxQyxNQUFNOzRCQUNOQyxLQUFLcEM7Ozs7Ozt3QkFJTk0sY0FBYUgsa0JBQUFBLDRCQUFBQSxNQUFPa0MsTUFBTSxrQkFDMUIsOERBQUNsQzs0QkFDQW1DLElBQUk7NEJBQ0pDLFFBQVE7NEJBQ1JDLFNBQVE7NEJBQ1JDLE9BQU87NEJBQ1BDLFdBQVc7NEJBQ1hDLFVBQVU7NEJBQ1ZDLFFBQVE5QztzQ0FFUEssTUFBTTBDLEdBQUcsQ0FBQyxTQUFDQyxHQUFHQztxREFDZCw4REFBQ0M7b0NBQ0FkLEtBQUtZLEVBQUVaLEdBQUc7b0NBQ1ZlLE1BQU1ILEVBQUVHLElBQUk7bUNBQ1BGOzs7Ozs7Ozs7O21DQUlMOzs7Ozs7OzhCQUdMLDhEQUFDRztvQkFBR3JCLFdBQVdsQyxtRkFBOEI7OEJBQUdLOzs7Ozs7OEJBQ2hELDhEQUFDb0Q7b0JBQUV2QixXQUFXbEMsa0ZBQTZCOzhCQUFHSTs7Ozs7OztXQXZDekN1RCxLQUFLQyxNQUFNOzs7Ozs7Ozs7O0FBMkNwQjtHQXpGZ0IzRDs7UUFZZlIsZ0RBQU9BOzs7S0FaUVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvb3VyLXByb2plY3RzL1Byb2plY3RzSXRlbS50c3g/YzYzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCB7IHVzZUdTQVAgfSBmcm9tICdAZ3NhcC9yZWFjdCdcclxuaW1wb3J0IGNuIGZyb20gJ2Nsc3gnXHJcbmltcG9ydCBnc2FwIGZyb20gJ2dzYXAnXHJcbmltcG9ydCB7IFNjcm9sbFRyaWdnZXIgfSBmcm9tICdnc2FwL1Njcm9sbFRyaWdnZXInXHJcbmltcG9ydCBJbWFnZSBmcm9tICduZXh0L2ltYWdlJ1xyXG5pbXBvcnQgeyB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXHJcblxyXG5pbXBvcnQgeyBJUHJvamVjdCB9IGZyb20gJ0Avc3RvcmUvb3VyLXByb2plY3Quc3RvcmUnXHJcblxyXG5pbXBvcnQgY2xhc3NlcyBmcm9tICcuL3N0eWxlcy5tb2R1bGUuc2NzcydcclxuXHJcbnR5cGUgVHlwZVByb2plY3QgPSBJUHJvamVjdFxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFByb2plY3RzSXRlbSh7XHJcblx0aHJlZixcclxuXHRpbWFnZSxcclxuXHR0ZXh0LFxyXG5cdHRpdGxlLFxyXG5cdHNoYWRvdyxcclxuXHR0ZXh0Q29sb3IsXHJcblx0dmlkZW9cclxufTogVHlwZVByb2plY3QpIHtcclxuXHRjb25zdCBpdGVtUmVmID0gdXNlUmVmKG51bGwpXHJcblx0Y29uc3QgYW5pbWF0aW9uUmVmID0gdXNlUmVmKG51bGwpXHJcblx0Y29uc3QgW2lzVmlzaWJsZSwgc2V0SXNWaXNpYmxlXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKVxyXG5cdHVzZUdTQVAoKCkgPT4ge1xyXG5cdFx0U2Nyb2xsVHJpZ2dlci5jcmVhdGUoe1xyXG5cdFx0XHR0cmlnZ2VyOiBpdGVtUmVmLmN1cnJlbnQsXHJcblx0XHRcdHN0YXJ0OiAndG9wIGJvdHRvbScsXHJcblx0XHRcdGVuZDogJ2JvdHRvbSB0b3AnLFxyXG5cdFx0XHRhbmltYXRpb246IGdzYXAudG8oYW5pbWF0aW9uUmVmLmN1cnJlbnQsIHtcclxuXHRcdFx0XHR0cmFuc2xhdGVZOiAwLFxyXG5cdFx0XHRcdG9wYWNpdHk6IDEsXHJcblx0XHRcdFx0ZHVyYXRpb246IDFcclxuXHRcdFx0fSksXHJcblx0XHRcdG9uVG9nZ2xlOiBzZWxmID0+IHtcclxuXHRcdFx0XHRpZiAoc2VsZi5pc0FjdGl2ZSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgdmlkZW8gPSBzZWxmLnRyaWdnZXI/LnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJylcclxuXHRcdFx0XHRcdHNldElzVmlzaWJsZSghaXNWaXNpYmxlKVxyXG5cclxuXHRcdFx0XHRcdGlmICh2aWRlbykgdmlkZW8ucGxheSgpXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNvbnN0IHZpZGVvID0gc2VsZi50cmlnZ2VyPy5xdWVyeVNlbGVjdG9yKCd2aWRlbycpXHJcblx0XHRcdFx0XHRpZiAodmlkZW8pIHZpZGVvLnBhdXNlKClcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pXHJcblx0fSlcclxuXHRyZXR1cm4gKFxyXG5cdFx0PGRpdlxyXG5cdFx0XHRyZWY9e2FuaW1hdGlvblJlZn1cclxuXHRcdFx0c3R5bGU9e3sgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgxMDAlKScsIG9wYWNpdHk6IDAgfX1cclxuXHRcdD5cclxuXHRcdFx0PGFcclxuXHRcdFx0XHRocmVmPXtocmVmfVxyXG5cdFx0XHRcdGNsYXNzTmFtZT17Y24oXHJcblx0XHRcdFx0XHRjbGFzc2VzLm91clByb2plY3RzX19pdGVtLFxyXG5cdFx0XHRcdFx0dGV4dENvbG9yID09PSAnd2hpdGUnID8gY2xhc3Nlcy5vdXJQcm9qZWN0c19fdGV4dFdoaXRlIDogJydcclxuXHRcdFx0XHQpfVxyXG5cdFx0XHRcdGtleT17TWF0aC5yYW5kb20oKX1cclxuXHRcdFx0XHRyZWY9e2l0ZW1SZWZ9XHJcblx0XHRcdD5cclxuXHRcdFx0XHQ8ZGl2XHJcblx0XHRcdFx0XHRjbGFzc05hbWU9e2NuKFxyXG5cdFx0XHRcdFx0XHRjbGFzc2VzLm91clByb2plY3RzX19pdGVtSW1nLFxyXG5cdFx0XHRcdFx0XHRzaGFkb3cgPyBjbGFzc2VzLm91clByb2plY3RzX19pdGVtSW1nU2hhZG93IDogJydcclxuXHRcdFx0XHRcdCl9XHJcblx0XHRcdFx0PlxyXG5cdFx0XHRcdFx0e2ltYWdlICYmIChcclxuXHRcdFx0XHRcdFx0PEltYWdlXHJcblx0XHRcdFx0XHRcdFx0c3JjPXtpbWFnZX1cclxuXHRcdFx0XHRcdFx0XHRmaWxsPXt0cnVlfVxyXG5cdFx0XHRcdFx0XHRcdGFsdD17dGl0bGV9XHJcblx0XHRcdFx0XHRcdC8+XHJcblx0XHRcdFx0XHQpfVxyXG5cclxuXHRcdFx0XHRcdHtpc1Zpc2libGUgJiYgdmlkZW8/Lmxlbmd0aCA/IChcclxuXHRcdFx0XHRcdFx0PHZpZGVvXHJcblx0XHRcdFx0XHRcdFx0bG9vcFxyXG5cdFx0XHRcdFx0XHRcdGF1dG9QbGF5XHJcblx0XHRcdFx0XHRcdFx0cHJlbG9hZD0nYXV0bydcclxuXHRcdFx0XHRcdFx0XHRtdXRlZD17dHJ1ZX1cclxuXHRcdFx0XHRcdFx0XHRwbGF5c0lubGluZVxyXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2xzPXtmYWxzZX1cclxuXHRcdFx0XHRcdFx0XHRwb3N0ZXI9e2ltYWdlfVxyXG5cdFx0XHRcdFx0XHQ+XHJcblx0XHRcdFx0XHRcdFx0e3ZpZGVvLm1hcCgodiwgaSkgPT4gKFxyXG5cdFx0XHRcdFx0XHRcdFx0PHNvdXJjZVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRzcmM9e3Yuc3JjfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlPXt2LnR5cGV9XHJcblx0XHRcdFx0XHRcdFx0XHRcdGtleT17aX1cclxuXHRcdFx0XHRcdFx0XHRcdC8+XHJcblx0XHRcdFx0XHRcdFx0KSl9XHJcblx0XHRcdFx0XHRcdDwvdmlkZW8+XHJcblx0XHRcdFx0XHQpIDogbnVsbH1cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHJcblx0XHRcdFx0PGg2IGNsYXNzTmFtZT17Y2xhc3Nlcy5vdXJQcm9qZWN0c19faXRlbVRpdGxlfT57dGl0bGV9PC9oNj5cclxuXHRcdFx0XHQ8cCBjbGFzc05hbWU9e2NsYXNzZXMub3VyUHJvamVjdHNfX2l0ZW1UZXh0fT57dGV4dH08L3A+XHJcblx0XHRcdDwvYT5cclxuXHRcdDwvZGl2PlxyXG5cdClcclxufVxyXG4iXSwibmFtZXMiOlsidXNlR1NBUCIsImNuIiwiZ3NhcCIsIlNjcm9sbFRyaWdnZXIiLCJJbWFnZSIsInVzZVJlZiIsInVzZVN0YXRlIiwiY2xhc3NlcyIsIlByb2plY3RzSXRlbSIsImhyZWYiLCJpbWFnZSIsInRleHQiLCJ0aXRsZSIsInNoYWRvdyIsInRleHRDb2xvciIsInZpZGVvIiwiaXRlbVJlZiIsImFuaW1hdGlvblJlZiIsImlzVmlzaWJsZSIsInNldElzVmlzaWJsZSIsImNyZWF0ZSIsInRyaWdnZXIiLCJjdXJyZW50Iiwic3RhcnQiLCJlbmQiLCJhbmltYXRpb24iLCJ0byIsInRyYW5zbGF0ZVkiLCJvcGFjaXR5IiwiZHVyYXRpb24iLCJvblRvZ2dsZSIsInNlbGYiLCJpc0FjdGl2ZSIsInF1ZXJ5U2VsZWN0b3IiLCJwbGF5IiwicGF1c2UiLCJkaXYiLCJyZWYiLCJzdHlsZSIsInRyYW5zZm9ybSIsImEiLCJjbGFzc05hbWUiLCJvdXJQcm9qZWN0c19faXRlbSIsIm91clByb2plY3RzX190ZXh0V2hpdGUiLCJvdXJQcm9qZWN0c19faXRlbUltZyIsIm91clByb2plY3RzX19pdGVtSW1nU2hhZG93Iiwic3JjIiwiZmlsbCIsImFsdCIsImxlbmd0aCIsImxvb3AiLCJhdXRvUGxheSIsInByZWxvYWQiLCJtdXRlZCIsInBsYXlzSW5saW5lIiwiY29udHJvbHMiLCJwb3N0ZXIiLCJtYXAiLCJ2IiwiaSIsInNvdXJjZSIsInR5cGUiLCJoNiIsIm91clByb2plY3RzX19pdGVtVGl0bGUiLCJwIiwib3VyUHJvamVjdHNfX2l0ZW1UZXh0IiwiTWF0aCIsInJhbmRvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/our-projects/ProjectsItem.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/partners/Partners.tsx":
/*!**********************************************!*\
  !*** ./src/components/partners/Partners.tsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Partners: function() { return /* binding */ Partners; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _gsap_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @gsap/react */ \"(app-pages-browser)/./node_modules/.pnpm/@gsap+react@2.1.1/node_modules/@gsap/react/src/index.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! gsap */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _hooks_useScroll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/hooks/useScroll */ \"(app-pages-browser)/./src/hooks/useScroll.ts\");\n/* harmony import */ var _ui_container_Container__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ui/container/Container */ \"(app-pages-browser)/./src/components/ui/container/Container.tsx\");\n/* harmony import */ var _PartnersItem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PartnersItem */ \"(app-pages-browser)/./src/components/partners/PartnersItem.tsx\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./styles.module.scss */ \"(app-pages-browser)/./src/components/partners/styles.module.scss\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_styles_module_scss__WEBPACK_IMPORTED_MODULE_6__);\n/* __next_internal_client_entry_do_not_use__ Partners auto */ \n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nfunction Partners(partners) {\n    var _this = this;\n    var _Object_values;\n    _s();\n    var partnersRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    var scroll = (0,_hooks_useScroll__WEBPACK_IMPORTED_MODULE_3__.useScroll)().scroll;\n    var _useState = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_7__._)((0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false), 2), isAnimate = _useState[0], setIsAnimate = _useState[1];\n    (0,_gsap_react__WEBPACK_IMPORTED_MODULE_1__.useGSAP)(function() {\n        if (scroll <= 0 && !isAnimate) {\n            gsap__WEBPACK_IMPORTED_MODULE_8__[\"default\"].to(partnersRef.current, {\n                translateY: 0,\n                opacity: 1,\n                delay: 1.9,\n                duration: 0.5,\n                onComplete: function() {\n                    setIsAnimate(true);\n                }\n            });\n        }\n    }, {\n        scope: partnersRef\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_6___default().partners),\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_6___default().partners__trigger),\n            ref: partnersRef,\n            style: !isAnimate && scroll <= 0 ? {\n                transform: \"translateY(100%)\",\n                opacity: 0\n            } : {\n                opacity: 1\n            },\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_container_Container__WEBPACK_IMPORTED_MODULE_4__.Container, {\n                variant: \"xl\",\n                className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_6___default().partners__container),\n                children: (_Object_values = Object.values(partners)) === null || _Object_values === void 0 ? void 0 : _Object_values.map(function(partner) {\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_PartnersItem__WEBPACK_IMPORTED_MODULE_5__.PartnersItem, {\n                        href: partner.href,\n                        image: partner.image\n                    }, partner.image, false, {\n                        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\partners\\\\Partners.tsx\",\n                        lineNumber: 55,\n                        columnNumber: 7\n                    }, _this);\n                })\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\partners\\\\Partners.tsx\",\n                lineNumber: 50,\n                columnNumber: 5\n            }, this)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\partners\\\\Partners.tsx\",\n            lineNumber: 38,\n            columnNumber: 4\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\partners\\\\Partners.tsx\",\n        lineNumber: 37,\n        columnNumber: 3\n    }, this);\n}\n_s(Partners, \"c4CQoFAlsi6GTtzXmx8YhF8JwTo=\", false, function() {\n    return [\n        _hooks_useScroll__WEBPACK_IMPORTED_MODULE_3__.useScroll,\n        _gsap_react__WEBPACK_IMPORTED_MODULE_1__.useGSAP\n    ];\n});\n_c = Partners;\nvar _c;\n$RefreshReg$(_c, \"Partners\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3BhcnRuZXJzL1BhcnRuZXJzLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFcUM7QUFDZDtBQUNpQjtBQUVLO0FBRVE7QUFFUjtBQUNIO0FBRW5DLFNBQVNRLFNBQVNDLFFBQWdEOztRQXdDbkVDOztJQXZDTCxJQUFNQyxjQUFjVCw2Q0FBTUEsQ0FBQztJQUMzQixJQUFNLFNBQWFFLDJEQUFTQSxHQUFwQlE7SUFDUixJQUFrQ1QsWUFBQUEsK0RBQUFBLENBQUFBLCtDQUFRQSxDQUFDLFlBQXBDVSxZQUEyQlYsY0FBaEJXLGVBQWdCWDtJQUVsQ0gsb0RBQU9BLENBQ047UUFDQyxJQUFJWSxVQUFVLEtBQUssQ0FBQ0MsV0FBVztZQUM5QlosNENBQUlBLENBQUNjLEVBQUUsQ0FBQ0osWUFBWUssT0FBTyxFQUFFO2dCQUM1QkMsWUFBWTtnQkFDWkMsU0FBUztnQkFDVEMsT0FBTztnQkFDUEMsVUFBVTtnQkFDVkMsWUFBWTtvQkFDWFAsYUFBYTtnQkFDZDtZQUNEO1FBQ0Q7SUFDRCxHQUNBO1FBQUVRLE9BQU9YO0lBQVk7SUFHdEIscUJBQ0MsOERBQUNZO1FBQUlDLFdBQVdqQixxRUFBZ0I7a0JBQy9CLDRFQUFDZ0I7WUFDQUMsV0FBV2pCLDhFQUF5QjtZQUNwQ21CLEtBQUtmO1lBQ0xnQixPQUNDLENBQUNkLGFBQWFELFVBQVUsSUFDckI7Z0JBQ0FnQixXQUFXO2dCQUNYVixTQUFTO1lBQ1YsSUFDQztnQkFBRUEsU0FBUztZQUFFO3NCQUdqQiw0RUFBQ2IsOERBQVNBO2dCQUNUd0IsU0FBUTtnQkFDUkwsV0FBV2pCLGdGQUEyQjsyQkFFckNHLGlCQUFBQSxPQUFPcUIsTUFBTSxDQUFDdEIsdUJBQWRDLHFDQUFBQSxlQUF5QnNCLEdBQUcsQ0FBQ0MsU0FBQUE7eUNBQzdCLDhEQUFDM0IsdURBQVlBO3dCQUVaNEIsTUFBTUQsUUFBUUMsSUFBSTt3QkFDbEJDLE9BQU9GLFFBQVFFLEtBQUs7dUJBRmZGLFFBQVFFLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVN6QjtHQW5EZ0IzQjs7UUFFSUosdURBQVNBO1FBRzVCSixnREFBT0E7OztLQUxRUSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9wYXJ0bmVycy9QYXJ0bmVycy50c3g/NmU2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCB7IHVzZUdTQVAgfSBmcm9tICdAZ3NhcC9yZWFjdCdcclxuaW1wb3J0IGdzYXAgZnJvbSAnZ3NhcCdcclxuaW1wb3J0IHsgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xyXG5cclxuaW1wb3J0IHsgdXNlU2Nyb2xsIH0gZnJvbSAnQC9ob29rcy91c2VTY3JvbGwnXHJcblxyXG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tICcuLi91aS9jb250YWluZXIvQ29udGFpbmVyJ1xyXG5cclxuaW1wb3J0IHsgUGFydG5lcnNJdGVtIH0gZnJvbSAnLi9QYXJ0bmVyc0l0ZW0nXHJcbmltcG9ydCBjbGFzc2VzIGZyb20gJy4vc3R5bGVzLm1vZHVsZS5zY3NzJ1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFBhcnRuZXJzKHBhcnRuZXJzOiBBcnJheTx7IGhyZWY6IHN0cmluZzsgaW1hZ2U6IHN0cmluZyB9Pikge1xyXG5cdGNvbnN0IHBhcnRuZXJzUmVmID0gdXNlUmVmKG51bGwpXHJcblx0Y29uc3QgeyBzY3JvbGwgfSA9IHVzZVNjcm9sbCgpXHJcblx0Y29uc3QgW2lzQW5pbWF0ZSwgc2V0SXNBbmltYXRlXSA9IHVzZVN0YXRlKGZhbHNlKVxyXG5cclxuXHR1c2VHU0FQKFxyXG5cdFx0KCkgPT4ge1xyXG5cdFx0XHRpZiAoc2Nyb2xsIDw9IDAgJiYgIWlzQW5pbWF0ZSkge1xyXG5cdFx0XHRcdGdzYXAudG8ocGFydG5lcnNSZWYuY3VycmVudCwge1xyXG5cdFx0XHRcdFx0dHJhbnNsYXRlWTogMCxcclxuXHRcdFx0XHRcdG9wYWNpdHk6IDEsXHJcblx0XHRcdFx0XHRkZWxheTogMS45LFxyXG5cdFx0XHRcdFx0ZHVyYXRpb246IDAuNSxcclxuXHRcdFx0XHRcdG9uQ29tcGxldGU6ICgpID0+IHtcclxuXHRcdFx0XHRcdFx0c2V0SXNBbmltYXRlKHRydWUpXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdHsgc2NvcGU6IHBhcnRuZXJzUmVmIH1cclxuXHQpXHJcblxyXG5cdHJldHVybiAoXHJcblx0XHQ8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlcy5wYXJ0bmVyc30+XHJcblx0XHRcdDxkaXZcclxuXHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzZXMucGFydG5lcnNfX3RyaWdnZXJ9XHJcblx0XHRcdFx0cmVmPXtwYXJ0bmVyc1JlZn1cclxuXHRcdFx0XHRzdHlsZT17XHJcblx0XHRcdFx0XHQhaXNBbmltYXRlICYmIHNjcm9sbCA8PSAwXHJcblx0XHRcdFx0XHRcdD8ge1xyXG5cdFx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtOiAndHJhbnNsYXRlWSgxMDAlKScsXHJcblx0XHRcdFx0XHRcdFx0XHRvcGFjaXR5OiAwXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHQ6IHsgb3BhY2l0eTogMSB9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHQ+XHJcblx0XHRcdFx0PENvbnRhaW5lclxyXG5cdFx0XHRcdFx0dmFyaWFudD0neGwnXHJcblx0XHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzZXMucGFydG5lcnNfX2NvbnRhaW5lcn1cclxuXHRcdFx0XHQ+XHJcblx0XHRcdFx0XHR7T2JqZWN0LnZhbHVlcyhwYXJ0bmVycyk/Lm1hcChwYXJ0bmVyID0+IChcclxuXHRcdFx0XHRcdFx0PFBhcnRuZXJzSXRlbVxyXG5cdFx0XHRcdFx0XHRcdGtleT17cGFydG5lci5pbWFnZX1cclxuXHRcdFx0XHRcdFx0XHRocmVmPXtwYXJ0bmVyLmhyZWZ9XHJcblx0XHRcdFx0XHRcdFx0aW1hZ2U9e3BhcnRuZXIuaW1hZ2V9XHJcblx0XHRcdFx0XHRcdC8+XHJcblx0XHRcdFx0XHQpKX1cclxuXHRcdFx0XHQ8L0NvbnRhaW5lcj5cclxuXHRcdFx0PC9kaXY+XHJcblx0XHQ8L2Rpdj5cclxuXHQpXHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUdTQVAiLCJnc2FwIiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VTY3JvbGwiLCJDb250YWluZXIiLCJQYXJ0bmVyc0l0ZW0iLCJjbGFzc2VzIiwiUGFydG5lcnMiLCJwYXJ0bmVycyIsIk9iamVjdCIsInBhcnRuZXJzUmVmIiwic2Nyb2xsIiwiaXNBbmltYXRlIiwic2V0SXNBbmltYXRlIiwidG8iLCJjdXJyZW50IiwidHJhbnNsYXRlWSIsIm9wYWNpdHkiLCJkZWxheSIsImR1cmF0aW9uIiwib25Db21wbGV0ZSIsInNjb3BlIiwiZGl2IiwiY2xhc3NOYW1lIiwicGFydG5lcnNfX3RyaWdnZXIiLCJyZWYiLCJzdHlsZSIsInRyYW5zZm9ybSIsInZhcmlhbnQiLCJwYXJ0bmVyc19fY29udGFpbmVyIiwidmFsdWVzIiwibWFwIiwicGFydG5lciIsImhyZWYiLCJpbWFnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/partners/Partners.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/partners/PartnersItem.tsx":
/*!**************************************************!*\
  !*** ./src/components/partners/PartnersItem.tsx ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PartnersItem: function() { return /* binding */ PartnersItem; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/image.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/link.js\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./styles.module.scss */ \"(app-pages-browser)/./src/components/partners/styles.module.scss\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_styles_module_scss__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nfunction PartnersItem(param) {\n    var href = param.href, image = param.image;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n        href: href,\n        className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default().partners__item),\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n            src: image,\n            alt: image,\n            // fill\n            width: 160,\n            height: 52\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\partners\\\\PartnersItem.tsx\",\n            lineNumber: 12,\n            columnNumber: 4\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\partners\\\\PartnersItem.tsx\",\n        lineNumber: 8,\n        columnNumber: 3\n    }, this);\n}\n_c = PartnersItem;\nvar _c;\n$RefreshReg$(_c, \"PartnersItem\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3BhcnRuZXJzL1BhcnRuZXJzSXRlbS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE4QjtBQUNGO0FBRWM7QUFFbkMsU0FBU0csYUFBYSxLQUFnRDtRQUE5Q0MsT0FBRixNQUFFQSxNQUFNQyxRQUFSLE1BQVFBO0lBQ3BDLHFCQUNDLDhEQUFDSixpREFBSUE7UUFDSkcsTUFBTUE7UUFDTkUsV0FBV0osMkVBQXNCO2tCQUVqQyw0RUFBQ0Ysa0RBQUtBO1lBQ0xRLEtBQUtIO1lBQ0xJLEtBQUtKO1lBQ0wsT0FBTztZQUNQSyxPQUFPO1lBQ1BDLFFBQVE7Ozs7Ozs7Ozs7O0FBSVo7S0FmZ0JSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3BhcnRuZXJzL1BhcnRuZXJzSXRlbS50c3g/YTFiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSW1hZ2UgZnJvbSAnbmV4dC9pbWFnZSdcclxuaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJ1xyXG5cclxuaW1wb3J0IGNsYXNzZXMgZnJvbSAnLi9zdHlsZXMubW9kdWxlLnNjc3MnXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gUGFydG5lcnNJdGVtKHsgaHJlZiwgaW1hZ2UgfTogeyBpbWFnZTogc3RyaW5nOyBocmVmOiBzdHJpbmcgfSkge1xyXG5cdHJldHVybiAoXHJcblx0XHQ8TGlua1xyXG5cdFx0XHRocmVmPXtocmVmfVxyXG5cdFx0XHRjbGFzc05hbWU9e2NsYXNzZXMucGFydG5lcnNfX2l0ZW19XHJcblx0XHQ+XHJcblx0XHRcdDxJbWFnZVxyXG5cdFx0XHRcdHNyYz17aW1hZ2V9XHJcblx0XHRcdFx0YWx0PXtpbWFnZX1cclxuXHRcdFx0XHQvLyBmaWxsXHJcblx0XHRcdFx0d2lkdGg9ezE2MH1cclxuXHRcdFx0XHRoZWlnaHQ9ezUyfVxyXG5cdFx0XHQvPlxyXG5cdFx0PC9MaW5rPlxyXG5cdClcclxufVxyXG4iXSwibmFtZXMiOlsiSW1hZ2UiLCJMaW5rIiwiY2xhc3NlcyIsIlBhcnRuZXJzSXRlbSIsImhyZWYiLCJpbWFnZSIsImNsYXNzTmFtZSIsInBhcnRuZXJzX19pdGVtIiwic3JjIiwiYWx0Iiwid2lkdGgiLCJoZWlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/partners/PartnersItem.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/text-wrap/TextWrap.tsx":
/*!***********************************************!*\
  !*** ./src/components/text-wrap/TextWrap.tsx ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextWrap: function() { return /* binding */ TextWrap; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\n/* harmony import */ var _swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\n/* harmony import */ var _swc_helpers_object_without_properties__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_without_properties.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./styles.module.scss */ \"(app-pages-browser)/./src/components/text-wrap/styles.module.scss\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_styles_module_scss__WEBPACK_IMPORTED_MODULE_3__);\n/* __next_internal_client_entry_do_not_use__ TextWrap auto */ \n\n\nvar _this = undefined;\n\n\n\n\nvar TextWrap = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_2__.forwardRef)(_c = function(_param, reference) {\n    var children = _param.children, className = _param.className, variant = _param.variant, rest = (0,_swc_helpers_object_without_properties__WEBPACK_IMPORTED_MODULE_4__._)(_param, [\n        \"children\",\n        \"className\",\n        \"variant\"\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_5__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_6__._)({\n        ref: reference,\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])((_styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default().textWrap), variant === \"reverse\" ? (_styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default().textWrap_reverse) : \"\", className)\n    }, rest), {\n        children: children\n    }), void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\text-wrap\\\\TextWrap.tsx\",\n        lineNumber: 17,\n        columnNumber: 4\n    }, _this);\n});\n_c1 = TextWrap;\nTextWrap.displayName = \"TextWrap\";\n\nvar _c, _c1;\n$RefreshReg$(_c, \"TextWrap$forwardRef\");\n$RefreshReg$(_c1, \"TextWrap\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3RleHQtd3JhcC9UZXh0V3JhcC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRXFCO0FBQ2dEO0FBRTNCO0FBUTFDLElBQU1HLHlCQUFXRixpREFBVUEsTUFDMUIsaUJBQXVERztRQUFwREMsa0JBQUFBLFVBQVVDLG1CQUFBQSxXQUFXQyxpQkFBQUEsU0FBWUMsT0FBQUEseUVBQUFBO1FBQWpDSDtRQUFVQztRQUFXQzs7SUFDdkIscUJBQ0MsOERBQUNFLE9BQUFBLG1FQUFBQSxDQUFBQSw2REFBQUE7UUFDQUMsS0FBS047UUFDTEUsV0FBV04sZ0RBQUVBLENBQ1pFLHFFQUFnQixFQUNoQkssWUFBWSxZQUFZTCw2RUFBd0IsR0FBRyxJQUNuREk7T0FFR0U7a0JBRUhIOzs7Ozs7QUFHSjs7QUFHREYsU0FBU1UsV0FBVyxHQUFHO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdGV4dC13cmFwL1RleHRXcmFwLnRzeD82NGI0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG5cclxuaW1wb3J0IGNuIGZyb20gJ2Nsc3gnXHJcbmltcG9ydCB7IEhUTUxBdHRyaWJ1dGVzLCBQcm9wc1dpdGhDaGlsZHJlbiwgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0J1xyXG5cclxuaW1wb3J0IGNsYXNzZXMgZnJvbSAnLi9zdHlsZXMubW9kdWxlLnNjc3MnXHJcblxyXG50eXBlIFR5cGVUZXh0V3JhcFZhcmlhbnQgPSAncmV2ZXJzZSdcclxuXHJcbmludGVyZmFjZSBJVGV4dFdyYXAgZXh0ZW5kcyBQcm9wc1dpdGhDaGlsZHJlbjxIVE1MQXR0cmlidXRlczxIVE1MRGl2RWxlbWVudD4+IHtcclxuXHR2YXJpYW50PzogVHlwZVRleHRXcmFwVmFyaWFudFxyXG59XHJcblxyXG5jb25zdCBUZXh0V3JhcCA9IGZvcndhcmRSZWYoXHJcblx0KHsgY2hpbGRyZW4sIGNsYXNzTmFtZSwgdmFyaWFudCwgLi4ucmVzdCB9OiBJVGV4dFdyYXAsIHJlZmVyZW5jZTogYW55KSA9PiB7XHJcblx0XHRyZXR1cm4gKFxyXG5cdFx0XHQ8ZGl2XHJcblx0XHRcdFx0cmVmPXtyZWZlcmVuY2V9XHJcblx0XHRcdFx0Y2xhc3NOYW1lPXtjbihcclxuXHRcdFx0XHRcdGNsYXNzZXMudGV4dFdyYXAsXHJcblx0XHRcdFx0XHR2YXJpYW50ID09PSAncmV2ZXJzZScgPyBjbGFzc2VzLnRleHRXcmFwX3JldmVyc2UgOiAnJyxcclxuXHRcdFx0XHRcdGNsYXNzTmFtZVxyXG5cdFx0XHRcdCl9XHJcblx0XHRcdFx0ey4uLnJlc3R9XHJcblx0XHRcdD5cclxuXHRcdFx0XHR7Y2hpbGRyZW59XHJcblx0XHRcdDwvZGl2PlxyXG5cdFx0KVxyXG5cdH1cclxuKVxyXG5cclxuVGV4dFdyYXAuZGlzcGxheU5hbWUgPSAnVGV4dFdyYXAnXHJcbmV4cG9ydCB7IFRleHRXcmFwIH1cclxuIl0sIm5hbWVzIjpbImNuIiwiZm9yd2FyZFJlZiIsImNsYXNzZXMiLCJUZXh0V3JhcCIsInJlZmVyZW5jZSIsImNoaWxkcmVuIiwiY2xhc3NOYW1lIiwidmFyaWFudCIsInJlc3QiLCJkaXYiLCJyZWYiLCJ0ZXh0V3JhcCIsInRleHRXcmFwX3JldmVyc2UiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/text-wrap/TextWrap.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/text-wrap/TextWrapItem.tsx":
/*!***************************************************!*\
  !*** ./src/components/text-wrap/TextWrapItem.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextWrapItem: function() { return /* binding */ TextWrapItem; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _gsap_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @gsap/react */ \"(app-pages-browser)/./node_modules/.pnpm/@gsap+react@2.1.1/node_modules/@gsap/react/src/index.js\");\n/* harmony import */ var gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gsap/ScrollTrigger */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollTrigger.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./styles.module.scss */ \"(app-pages-browser)/./src/components/text-wrap/styles.module.scss\");\n/* harmony import */ var _styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_styles_module_scss__WEBPACK_IMPORTED_MODULE_3__);\n/* __next_internal_client_entry_do_not_use__ TextWrapItem auto */ \n\nvar _s = $RefreshSig$();\n\n\n\n\nfunction TextWrapItem(param) {\n    var image = param.image, index = param.index, id = param.id, reference = param.reference;\n    _s();\n    var _useState = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_4__._)((0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(50), 2), translate = _useState[0], setTranslate = _useState[1];\n    (0,_gsap_react__WEBPACK_IMPORTED_MODULE_1__.useGSAP)(function() {\n        gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_5__.ScrollTrigger.create({\n            trigger: id,\n            start: \"top bottom\",\n            end: \"bottom top\",\n            onUpdate: function(self) {\n                if (index % 2 === 0) {\n                    setTranslate(Number(self.progress * 100) - 50);\n                } else {\n                    setTranslate(Number(self.progress * 100 * -1) + 50);\n                }\n            }\n        });\n    }, {\n        scope: reference.current\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_module_scss__WEBPACK_IMPORTED_MODULE_3___default().textWrap__item),\n        style: {\n            transform: \"translateX(\".concat(translate, \"%)\"),\n            willChange: \"transform\"\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n            src: image,\n            alt: \"text wrap\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\text-wrap\\\\TextWrapItem.tsx\",\n            lineNumber: 47,\n            columnNumber: 4\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\text-wrap\\\\TextWrapItem.tsx\",\n        lineNumber: 40,\n        columnNumber: 3\n    }, this);\n}\n_s(TextWrapItem, \"Du/Qe7asUBFrUNEbdBFxV8Q3F4Y=\", false, function() {\n    return [\n        _gsap_react__WEBPACK_IMPORTED_MODULE_1__.useGSAP\n    ];\n});\n_c = TextWrapItem;\nvar _c;\n$RefreshReg$(_c, \"TextWrapItem\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3RleHQtd3JhcC9UZXh0V3JhcEl0ZW0udHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUVxQztBQUNhO0FBQ2xCO0FBRVU7QUFFbkMsU0FBU0ksYUFBYSxLQVU1QjtRQVRBQyxRQUQ0QixNQUM1QkEsT0FDQUMsUUFGNEIsTUFFNUJBLE9BQ0FDLEtBSDRCLE1BRzVCQSxJQUNBQyxZQUo0QixNQUk1QkE7O0lBT0EsSUFBa0NOLFlBQUFBLCtEQUFBQSxDQUFBQSwrQ0FBUUEsQ0FBUyxTQUE1Q08sWUFBMkJQLGNBQWhCUSxlQUFnQlI7SUFFbENGLG9EQUFPQSxDQUNOO1FBQ0NDLDZEQUFhQSxDQUFDVSxNQUFNLENBQUM7WUFDcEJDLFNBQVNMO1lBQ1RNLE9BQU87WUFDUEMsS0FBSztZQUNMQyxVQUFVQyxTQUFBQTtnQkFDVCxJQUFJVixRQUFRLE1BQU0sR0FBRztvQkFDcEJJLGFBQWFPLE9BQU9ELEtBQUtFLFFBQVEsR0FBRyxPQUFPO2dCQUM1QyxPQUFPO29CQUNOUixhQUFhTyxPQUFPRCxLQUFLRSxRQUFRLEdBQUcsTUFBTSxDQUFDLEtBQUs7Z0JBQ2pEO1lBQ0Q7UUFDRDtJQUNELEdBQ0E7UUFBRUMsT0FBT1gsVUFBVVksT0FBTztJQUFDO0lBRTVCLHFCQUNDLDhEQUFDQztRQUNBQyxXQUFXbkIsMkVBQXNCO1FBQ2pDcUIsT0FBTztZQUNOQyxXQUFXLGNBQXdCLE9BQVZoQixXQUFVO1lBQ25DaUIsWUFBWTtRQUNiO2tCQUVBLDRFQUFDQztZQUNBQyxLQUFLdkI7WUFDTHdCLEtBQUk7Ozs7Ozs7Ozs7O0FBSVI7R0E1Q2dCekI7O1FBYWZKLGdEQUFPQTs7O0tBYlFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3RleHQtd3JhcC9UZXh0V3JhcEl0ZW0udHN4P2EyNjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXHJcblxyXG5pbXBvcnQgeyB1c2VHU0FQIH0gZnJvbSAnQGdzYXAvcmVhY3QnXHJcbmltcG9ydCB7IFNjcm9sbFRyaWdnZXIgfSBmcm9tICdnc2FwL1Njcm9sbFRyaWdnZXInXHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXHJcblxyXG5pbXBvcnQgY2xhc3NlcyBmcm9tICcuL3N0eWxlcy5tb2R1bGUuc2NzcydcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBUZXh0V3JhcEl0ZW0oe1xyXG5cdGltYWdlLFxyXG5cdGluZGV4LFxyXG5cdGlkLFxyXG5cdHJlZmVyZW5jZVxyXG59OiB7XHJcblx0aW1hZ2U6IHN0cmluZ1xyXG5cdGluZGV4OiBudW1iZXJcclxuXHRpZDogc3RyaW5nXHJcblx0cmVmZXJlbmNlOiBhbnlcclxufSkge1xyXG5cdGNvbnN0IFt0cmFuc2xhdGUsIHNldFRyYW5zbGF0ZV0gPSB1c2VTdGF0ZTxudW1iZXI+KDUwKVxyXG5cclxuXHR1c2VHU0FQKFxyXG5cdFx0KCkgPT4ge1xyXG5cdFx0XHRTY3JvbGxUcmlnZ2VyLmNyZWF0ZSh7XHJcblx0XHRcdFx0dHJpZ2dlcjogaWQsXHJcblx0XHRcdFx0c3RhcnQ6ICd0b3AgYm90dG9tJyxcclxuXHRcdFx0XHRlbmQ6ICdib3R0b20gdG9wJyxcclxuXHRcdFx0XHRvblVwZGF0ZTogc2VsZiA9PiB7XHJcblx0XHRcdFx0XHRpZiAoaW5kZXggJSAyID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdHNldFRyYW5zbGF0ZShOdW1iZXIoc2VsZi5wcm9ncmVzcyAqIDEwMCkgLSA1MClcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHNldFRyYW5zbGF0ZShOdW1iZXIoc2VsZi5wcm9ncmVzcyAqIDEwMCAqIC0xKSArIDUwKVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSlcclxuXHRcdH0sXHJcblx0XHR7IHNjb3BlOiByZWZlcmVuY2UuY3VycmVudCB9XHJcblx0KVxyXG5cdHJldHVybiAoXHJcblx0XHQ8ZGl2XHJcblx0XHRcdGNsYXNzTmFtZT17Y2xhc3Nlcy50ZXh0V3JhcF9faXRlbX1cclxuXHRcdFx0c3R5bGU9e3tcclxuXHRcdFx0XHR0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7dHJhbnNsYXRlfSUpYCxcclxuXHRcdFx0XHR3aWxsQ2hhbmdlOiAndHJhbnNmb3JtJ1xyXG5cdFx0XHR9fVxyXG5cdFx0PlxyXG5cdFx0XHQ8aW1nXHJcblx0XHRcdFx0c3JjPXtpbWFnZX1cclxuXHRcdFx0XHRhbHQ9J3RleHQgd3JhcCdcclxuXHRcdFx0Lz5cclxuXHRcdDwvZGl2PlxyXG5cdClcclxufVxyXG4iXSwibmFtZXMiOlsidXNlR1NBUCIsIlNjcm9sbFRyaWdnZXIiLCJ1c2VTdGF0ZSIsImNsYXNzZXMiLCJUZXh0V3JhcEl0ZW0iLCJpbWFnZSIsImluZGV4IiwiaWQiLCJyZWZlcmVuY2UiLCJ0cmFuc2xhdGUiLCJzZXRUcmFuc2xhdGUiLCJjcmVhdGUiLCJ0cmlnZ2VyIiwic3RhcnQiLCJlbmQiLCJvblVwZGF0ZSIsInNlbGYiLCJOdW1iZXIiLCJwcm9ncmVzcyIsInNjb3BlIiwiY3VycmVudCIsImRpdiIsImNsYXNzTmFtZSIsInRleHRXcmFwX19pdGVtIiwic3R5bGUiLCJ0cmFuc2Zvcm0iLCJ3aWxsQ2hhbmdlIiwiaW1nIiwic3JjIiwiYWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/text-wrap/TextWrapItem.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/Heading/Heading.tsx":
/*!***********************************************!*\
  !*** ./src/components/ui/Heading/Heading.tsx ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\n/* harmony import */ var _swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\n/* harmony import */ var _swc_helpers_object_without_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_without_properties.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _gsap_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @gsap/react */ \"(app-pages-browser)/./node_modules/.pnpm/@gsap+react@2.1.1/node_modules/@gsap/react/src/index.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gsap */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\nvar _this = undefined;\n\nvar _s = $RefreshSig$();\n\n\n\nvar Heading = function(_param) {\n    var tag = _param.tag, children = _param.children, rest = (0,_swc_helpers_object_without_properties__WEBPACK_IMPORTED_MODULE_3__._)(_param, [\n        \"tag\",\n        \"children\"\n    ]);\n    _s();\n    var headingRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    var Tag = function(props) {\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_2__.createElement)(tag, (0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_4__._)({\n            ref: headingRef\n        }, props), children);\n    };\n    (0,_gsap_react__WEBPACK_IMPORTED_MODULE_1__.useGSAP)(function() {\n        gsap__WEBPACK_IMPORTED_MODULE_5__[\"default\"].to(headingRef.current, {\n            scrollTrigger: {\n                trigger: headingRef.current\n            },\n            translateY: 0,\n            opacity: 1,\n            delay: 0.3\n        });\n    }, {\n        scope: headingRef\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Tag, (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_6__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_4__._)({}, rest), {\n        style: {\n            transform: \"translateY(100%)\",\n            opacity: \"0\"\n        },\n        children: children\n    }), void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\Heading\\\\Heading.tsx\",\n        lineNumber: 29,\n        columnNumber: 3\n    }, _this);\n};\n_s(Heading, \"uWpZP/yP9jgKurMrr7ZSPVR3Kuo=\", false, function() {\n    return [\n        _gsap_react__WEBPACK_IMPORTED_MODULE_1__.useGSAP\n    ];\n});\n_c = Heading;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Heading);\nvar _c;\n$RefreshReg$(_c, \"Heading\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL0hlYWRpbmcvSGVhZGluZy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBRXFDO0FBQ2Q7QUFDc0I7QUFJN0MsSUFBTUksVUFBVTtRQUFHQyxhQUFBQSxLQUFLQyxrQkFBQUEsVUFBYUMsT0FBQUEseUVBQUFBO1FBQWxCRjtRQUFLQzs7O0lBQ3ZCLElBQU1FLGFBQWFMLDZDQUFNQSxDQUFDO0lBQzFCLElBQU1NLE1BQU0sU0FBQ0M7NkJBQ1pSLG9EQUFhQSxDQUFDRyxLQUFLO1lBQUVNLEtBQUtIO1dBQWVFLFFBQVNKOztJQUVuRE4sb0RBQU9BLENBQ047UUFDQ0MsNENBQUlBLENBQUNXLEVBQUUsQ0FBQ0osV0FBV0ssT0FBTyxFQUFFO1lBQzNCQyxlQUFlO2dCQUNkQyxTQUFTUCxXQUFXSyxPQUFPO1lBQzVCO1lBQ0FHLFlBQVk7WUFDWkMsU0FBUztZQUNUQyxPQUFPO1FBQ1I7SUFDRCxHQUNBO1FBQUVDLE9BQU9YO0lBQVc7SUFHckIscUJBQ0MsOERBQUNDLEtBQUFBLG1FQUFBQSxDQUFBQSw2REFBQUEsS0FDSUY7UUFDSmEsT0FBTztZQUFFQyxXQUFXO1lBQW9CSixTQUFTO1FBQUk7a0JBRXBEWDs7Ozs7O0FBR0o7R0EzQk1GOztRQUtMSixnREFBT0E7OztLQUxGSTtBQTZCTiwrREFBZUEsT0FBT0EsRUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy91aS9IZWFkaW5nL0hlYWRpbmcudHN4PzZjZGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXHJcblxyXG5pbXBvcnQgeyB1c2VHU0FQIH0gZnJvbSAnQGdzYXAvcmVhY3QnXHJcbmltcG9ydCBnc2FwIGZyb20gJ2dzYXAnXHJcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xyXG5cclxuaW1wb3J0IHsgVHlwZUhlYWRpbmcsIFR5cGVSZWYgfSBmcm9tICcuL0hlYWRpbmcudHlwZXMnXHJcblxyXG5jb25zdCBIZWFkaW5nID0gKHsgdGFnLCBjaGlsZHJlbiwgLi4ucmVzdCB9OiBUeXBlSGVhZGluZyAmIFR5cGVSZWYpID0+IHtcclxuXHRjb25zdCBoZWFkaW5nUmVmID0gdXNlUmVmKG51bGwpXHJcblx0Y29uc3QgVGFnID0gKHByb3BzOiBhbnkpID0+XHJcblx0XHRjcmVhdGVFbGVtZW50KHRhZywgeyByZWY6IGhlYWRpbmdSZWYsIC4uLnByb3BzIH0sIGNoaWxkcmVuKVxyXG5cclxuXHR1c2VHU0FQKFxyXG5cdFx0KCkgPT4ge1xyXG5cdFx0XHRnc2FwLnRvKGhlYWRpbmdSZWYuY3VycmVudCwge1xyXG5cdFx0XHRcdHNjcm9sbFRyaWdnZXI6IHtcclxuXHRcdFx0XHRcdHRyaWdnZXI6IGhlYWRpbmdSZWYuY3VycmVudFxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0dHJhbnNsYXRlWTogMCxcclxuXHRcdFx0XHRvcGFjaXR5OiAxLFxyXG5cdFx0XHRcdGRlbGF5OiAwLjNcclxuXHRcdFx0fSlcclxuXHRcdH0sXHJcblx0XHR7IHNjb3BlOiBoZWFkaW5nUmVmIH1cclxuXHQpXHJcblxyXG5cdHJldHVybiAoXHJcblx0XHQ8VGFnXHJcblx0XHRcdHsuLi5yZXN0fVxyXG5cdFx0XHRzdHlsZT17eyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDEwMCUpJywgb3BhY2l0eTogJzAnIH19XHJcblx0XHQ+XHJcblx0XHRcdHtjaGlsZHJlbn1cclxuXHRcdDwvVGFnPlxyXG5cdClcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgSGVhZGluZ1xyXG4iXSwibmFtZXMiOlsidXNlR1NBUCIsImdzYXAiLCJjcmVhdGVFbGVtZW50IiwidXNlUmVmIiwiSGVhZGluZyIsInRhZyIsImNoaWxkcmVuIiwicmVzdCIsImhlYWRpbmdSZWYiLCJUYWciLCJwcm9wcyIsInJlZiIsInRvIiwiY3VycmVudCIsInNjcm9sbFRyaWdnZXIiLCJ0cmlnZ2VyIiwidHJhbnNsYXRlWSIsIm9wYWNpdHkiLCJkZWxheSIsInNjb3BlIiwic3R5bGUiLCJ0cmFuc2Zvcm0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/Heading/Heading.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/button/Button.tsx":
/*!*********************************************!*\
  !*** ./src/components/ui/button/Button.tsx ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: function() { return /* binding */ Button; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _gsap_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @gsap/react */ \"(app-pages-browser)/./node_modules/.pnpm/@gsap+react@2.1.1/node_modules/@gsap/react/src/index.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var gsap_all__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gsap/all */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/all.js\");\n/* harmony import */ var gsap_all__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! gsap/all */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Observer.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _Button_module_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Button.module.scss */ \"(app-pages-browser)/./src/components/ui/button/Button.module.scss\");\n/* harmony import */ var _Button_module_scss__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_Button_module_scss__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ Button auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\ngsap_all__WEBPACK_IMPORTED_MODULE_5__[\"default\"].registerPlugin(gsap_all__WEBPACK_IMPORTED_MODULE_6__.Observer);\nfunction Button(param) {\n    var className = param.className, children = param.children;\n    _s();\n    var buttonRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    var followerRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    (0,_gsap_react__WEBPACK_IMPORTED_MODULE_1__.useGSAP)(function() {\n        gsap_all__WEBPACK_IMPORTED_MODULE_6__.Observer.create({\n            target: buttonRef.current,\n            type: \"pointer\",\n            onMove: function(self) {\n                gsap_all__WEBPACK_IMPORTED_MODULE_5__[\"default\"].to(followerRef.current, {\n                    duration: 0,\n                    delay: 0,\n                    translateX: // @ts-ignore\n                    self.event.layerX / buttonRef.current.clientWidth * 100 + \"%\",\n                    translateY: // @ts-ignore\n                    self.event.layerY / buttonRef.current.clientHeight * 100 + \"%\"\n                });\n            },\n            onHover: function(self) {\n                gsap_all__WEBPACK_IMPORTED_MODULE_5__[\"default\"].to(followerRef.current, {\n                    duration: 0.3,\n                    delay: 0,\n                    scale: 1\n                });\n            },\n            onHoverEnd: function(self) {\n                gsap_all__WEBPACK_IMPORTED_MODULE_5__[\"default\"].to(followerRef.current, {\n                    duration: 0.3,\n                    delay: 0,\n                    scale: 0\n                });\n            }\n        });\n    }, {\n        scope: buttonRef,\n        dependencies: []\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])((_Button_module_scss__WEBPACK_IMPORTED_MODULE_4___default().button), className),\n        ref: buttonRef,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_Button_module_scss__WEBPACK_IMPORTED_MODULE_4___default().button__follower),\n                ref: followerRef\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\button\\\\Button.tsx\",\n                lineNumber: 60,\n                columnNumber: 4\n            }, this),\n            children\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\button\\\\Button.tsx\",\n        lineNumber: 56,\n        columnNumber: 3\n    }, this);\n}\n_s(Button, \"TyTrjn40Km3a6xFdnGkidyihL4w=\", false, function() {\n    return [\n        _gsap_react__WEBPACK_IMPORTED_MODULE_1__.useGSAP\n    ];\n});\n_c = Button;\nvar _c;\n$RefreshReg$(_c, \"Button\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL2J1dHRvbi9CdXR0b24udHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUVxQztBQUNoQjtBQUNvQjtBQUN3QjtBQUV2QjtBQUUxQ0UsZ0RBQUlBLENBQUNJLGNBQWMsQ0FBQ0gsOENBQVFBO0FBRXJCLFNBQVNJLE9BQU8sS0FHa0Q7UUFGeEVDLFlBRHNCLE1BQ3RCQSxXQUNBQyxXQUZzQixNQUV0QkE7O0lBRUEsSUFBTUMsWUFBWU4sNkNBQU1BO0lBQ3hCLElBQU1PLGNBQWNQLDZDQUFNQTtJQUUxQkosb0RBQU9BLENBQ047UUFDQ0csOENBQVFBLENBQUNTLE1BQU0sQ0FBQztZQUNmQyxRQUFRSCxVQUFVSSxPQUFPO1lBQ3pCQyxNQUFNO1lBRU5DLFFBQVEsU0FBQ0M7Z0JBQ1JmLGdEQUFJQSxDQUFDZ0IsRUFBRSxDQUFDUCxZQUFZRyxPQUFPLEVBQUU7b0JBQzVCSyxVQUFVO29CQUNWQyxPQUFPO29CQUNQQyxZQUVDLGFBRGE7b0JBQ1pKLEtBQUtLLEtBQUssQ0FBQ0MsTUFBTSxHQUFHYixVQUFVSSxPQUFPLENBQUNVLFdBQVcsR0FBSSxNQUFNO29CQUM3REMsWUFFQyxhQURhO29CQUNaUixLQUFLSyxLQUFLLENBQUNJLE1BQU0sR0FBR2hCLFVBQVVJLE9BQU8sQ0FBQ2EsWUFBWSxHQUFJLE1BQU07Z0JBQy9EO1lBQ0Q7WUFDQUMsU0FBUyxTQUFDWDtnQkFDVGYsZ0RBQUlBLENBQUNnQixFQUFFLENBQUNQLFlBQVlHLE9BQU8sRUFBRTtvQkFDNUJLLFVBQVU7b0JBQ1ZDLE9BQU87b0JBQ1BTLE9BQU87Z0JBQ1I7WUFDRDtZQUNBQyxZQUFZLFNBQUNiO2dCQUNaZixnREFBSUEsQ0FBQ2dCLEVBQUUsQ0FBQ1AsWUFBWUcsT0FBTyxFQUFFO29CQUM1QkssVUFBVTtvQkFDVkMsT0FBTztvQkFDUFMsT0FBTztnQkFDUjtZQUNEO1FBQ0Q7SUFDRCxHQUNBO1FBQUVFLE9BQU9yQjtRQUFXc0IsY0FBYyxFQUFFO0lBQUM7SUFFdEMscUJBQ0MsOERBQUNDO1FBQ0F6QixXQUFXUCxnREFBRUEsQ0FBQ0ksbUVBQWMsRUFBRUc7UUFDOUIwQixLQUFLeEI7OzBCQUVMLDhEQUFDeUI7Z0JBQ0EzQixXQUFXSCw2RUFBd0I7Z0JBQ25DNkIsS0FBS3ZCOzs7Ozs7WUFFTEY7Ozs7Ozs7QUFHSjtHQXZEZ0JGOztRQU9mUCxnREFBT0E7OztLQVBRTyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy91aS9idXR0b24vQnV0dG9uLnRzeD9kZjBiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG5cclxuaW1wb3J0IHsgdXNlR1NBUCB9IGZyb20gJ0Bnc2FwL3JlYWN0J1xyXG5pbXBvcnQgY24gZnJvbSAnY2xzeCdcclxuaW1wb3J0IGdzYXAsIHsgT2JzZXJ2ZXIgfSBmcm9tICdnc2FwL2FsbCdcclxuaW1wb3J0IHsgSFRNTEF0dHJpYnV0ZXMsIFByb3BzV2l0aENoaWxkcmVuLCB1c2VSZWYgfSBmcm9tICdyZWFjdCdcclxuXHJcbmltcG9ydCBjbGFzc2VzIGZyb20gJy4vQnV0dG9uLm1vZHVsZS5zY3NzJ1xyXG5cclxuZ3NhcC5yZWdpc3RlclBsdWdpbihPYnNlcnZlcilcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBCdXR0b24oe1xyXG5cdGNsYXNzTmFtZSxcclxuXHRjaGlsZHJlblxyXG59OiBQcm9wc1dpdGhDaGlsZHJlbjxIVE1MQXR0cmlidXRlczxIVE1MQnV0dG9uRWxlbWVudCB8IEhUTUxMaW5rRWxlbWVudD4+KSB7XHJcblx0Y29uc3QgYnV0dG9uUmVmID0gdXNlUmVmPGFueT4oKVxyXG5cdGNvbnN0IGZvbGxvd2VyUmVmID0gdXNlUmVmPGFueT4oKVxyXG5cclxuXHR1c2VHU0FQKFxyXG5cdFx0KCkgPT4ge1xyXG5cdFx0XHRPYnNlcnZlci5jcmVhdGUoe1xyXG5cdFx0XHRcdHRhcmdldDogYnV0dG9uUmVmLmN1cnJlbnQsXHJcblx0XHRcdFx0dHlwZTogJ3BvaW50ZXInLFxyXG5cclxuXHRcdFx0XHRvbk1vdmU6IChzZWxmOiBPYnNlcnZlcikgPT4ge1xyXG5cdFx0XHRcdFx0Z3NhcC50byhmb2xsb3dlclJlZi5jdXJyZW50LCB7XHJcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiAwLFxyXG5cdFx0XHRcdFx0XHRkZWxheTogMCxcclxuXHRcdFx0XHRcdFx0dHJhbnNsYXRlWDpcclxuXHRcdFx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHRcdFx0XHRcdFx0KHNlbGYuZXZlbnQubGF5ZXJYIC8gYnV0dG9uUmVmLmN1cnJlbnQuY2xpZW50V2lkdGgpICogMTAwICsgJyUnLFxyXG5cdFx0XHRcdFx0XHR0cmFuc2xhdGVZOlxyXG5cdFx0XHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdFx0XHRcdFx0XHQoc2VsZi5ldmVudC5sYXllclkgLyBidXR0b25SZWYuY3VycmVudC5jbGllbnRIZWlnaHQpICogMTAwICsgJyUnXHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0b25Ib3ZlcjogKHNlbGY6IE9ic2VydmVyKSA9PiB7XHJcblx0XHRcdFx0XHRnc2FwLnRvKGZvbGxvd2VyUmVmLmN1cnJlbnQsIHtcclxuXHRcdFx0XHRcdFx0ZHVyYXRpb246IDAuMyxcclxuXHRcdFx0XHRcdFx0ZGVsYXk6IDAsXHJcblx0XHRcdFx0XHRcdHNjYWxlOiAxXHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0b25Ib3ZlckVuZDogKHNlbGY6IE9ic2VydmVyKSA9PiB7XHJcblx0XHRcdFx0XHRnc2FwLnRvKGZvbGxvd2VyUmVmLmN1cnJlbnQsIHtcclxuXHRcdFx0XHRcdFx0ZHVyYXRpb246IDAuMyxcclxuXHRcdFx0XHRcdFx0ZGVsYXk6IDAsXHJcblx0XHRcdFx0XHRcdHNjYWxlOiAwXHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSlcclxuXHRcdH0sXHJcblx0XHR7IHNjb3BlOiBidXR0b25SZWYsIGRlcGVuZGVuY2llczogW10gfVxyXG5cdClcclxuXHRyZXR1cm4gKFxyXG5cdFx0PGJ1dHRvblxyXG5cdFx0XHRjbGFzc05hbWU9e2NuKGNsYXNzZXMuYnV0dG9uLCBjbGFzc05hbWUpfVxyXG5cdFx0XHRyZWY9e2J1dHRvblJlZn1cclxuXHRcdD5cclxuXHRcdFx0PGRpdlxyXG5cdFx0XHRcdGNsYXNzTmFtZT17Y2xhc3Nlcy5idXR0b25fX2ZvbGxvd2VyfVxyXG5cdFx0XHRcdHJlZj17Zm9sbG93ZXJSZWZ9XHJcblx0XHRcdD48L2Rpdj5cclxuXHRcdFx0e2NoaWxkcmVufVxyXG5cdFx0PC9idXR0b24+XHJcblx0KVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VHU0FQIiwiY24iLCJnc2FwIiwiT2JzZXJ2ZXIiLCJ1c2VSZWYiLCJjbGFzc2VzIiwicmVnaXN0ZXJQbHVnaW4iLCJCdXR0b24iLCJjbGFzc05hbWUiLCJjaGlsZHJlbiIsImJ1dHRvblJlZiIsImZvbGxvd2VyUmVmIiwiY3JlYXRlIiwidGFyZ2V0IiwiY3VycmVudCIsInR5cGUiLCJvbk1vdmUiLCJzZWxmIiwidG8iLCJkdXJhdGlvbiIsImRlbGF5IiwidHJhbnNsYXRlWCIsImV2ZW50IiwibGF5ZXJYIiwiY2xpZW50V2lkdGgiLCJ0cmFuc2xhdGVZIiwibGF5ZXJZIiwiY2xpZW50SGVpZ2h0Iiwib25Ib3ZlciIsInNjYWxlIiwib25Ib3ZlckVuZCIsInNjb3BlIiwiZGVwZW5kZW5jaWVzIiwiYnV0dG9uIiwicmVmIiwiZGl2IiwiYnV0dG9uX19mb2xsb3dlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/button/Button.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/container/Container.tsx":
/*!***************************************************!*\
  !*** ./src/components/ui/container/Container.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Container: function() { return /* binding */ Container; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\n/* harmony import */ var _swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\n/* harmony import */ var _swc_helpers_object_without_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_without_properties.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var _Styles_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Styles.scss */ \"(app-pages-browser)/./src/components/ui/container/Styles.scss\");\n\n\n\n\n\n\nfunction Container(_param) {\n    var variant = _param.variant, children = _param.children, className = _param.className, rest = (0,_swc_helpers_object_without_properties__WEBPACK_IMPORTED_MODULE_3__._)(_param, [\n        \"variant\",\n        \"children\",\n        \"className\"\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_4__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_5__._)({\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(variant ? \"container-\" + variant : \"container\", className)\n    }, rest), {\n        children: children\n    }), void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\container\\\\Container.tsx\",\n        lineNumber: 12,\n        columnNumber: 3\n    }, this);\n}\n_c = Container;\nvar _c;\n$RefreshReg$(_c, \"Container\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL2NvbnRhaW5lci9Db250YWluZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXNCO0FBQ0M7QUFHaEIsU0FBU0MsVUFBVTtRQUN6QkMsVUFEeUIsT0FDekJBLFNBQ0FDLFdBRnlCLE9BRXpCQSxVQUNBQyxZQUh5QixPQUd6QkEsV0FDR0MsT0FBQUEseUVBQUFBLENBSnNCO1FBQ3pCSDtRQUNBQztRQUNBQzs7SUFHQSxxQkFDQyw4REFBQ0UsT0FBQUEsbUVBQUFBLENBQUFBLDZEQUFBQTtRQUNBRixXQUFXSixnREFBRUEsQ0FBQ0UsVUFBVSxlQUFlQSxVQUFVLGFBQWFFO09BQzFEQztrQkFFSEY7Ozs7OztBQUdKO0tBZGdCRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy91aS9jb250YWluZXIvQ29udGFpbmVyLnRzeD8zZmVlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjbiBmcm9tICdjbHN4JztcclxuaW1wb3J0ICcuL1N0eWxlcy5zY3NzJztcclxuaW1wb3J0IHsgSUNvbnRhaW5lciB9IGZyb20gJy4vY29udGFpbmVyLnR5cGVzJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDb250YWluZXIoe1xyXG5cdHZhcmlhbnQsXHJcblx0Y2hpbGRyZW4sXHJcblx0Y2xhc3NOYW1lLFxyXG5cdC4uLnJlc3RcclxufTogSUNvbnRhaW5lcikge1xyXG5cdHJldHVybiAoXHJcblx0XHQ8ZGl2XHJcblx0XHRcdGNsYXNzTmFtZT17Y24odmFyaWFudCA/ICdjb250YWluZXItJyArIHZhcmlhbnQgOiAnY29udGFpbmVyJywgY2xhc3NOYW1lKX1cclxuXHRcdFx0ey4uLnJlc3R9XHJcblx0XHQ+XHJcblx0XHRcdHtjaGlsZHJlbn1cclxuXHRcdDwvZGl2PlxyXG5cdCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbImNuIiwiQ29udGFpbmVyIiwidmFyaWFudCIsImNoaWxkcmVuIiwiY2xhc3NOYW1lIiwicmVzdCIsImRpdiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/container/Container.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/reference/Reference.tsx":
/*!***************************************************!*\
  !*** ./src/components/ui/reference/Reference.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Reference: function() { return /* binding */ Reference; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\n/* harmony import */ var _swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\n/* harmony import */ var _swc_helpers_object_without_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_without_properties.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _gsap_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @gsap/react */ \"(app-pages-browser)/./node_modules/.pnpm/@gsap+react@2.1.1/node_modules/@gsap/react/src/index.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var gsap_all__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! gsap/all */ \"(app-pages-browser)/./node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/all.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/link.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ Reference auto */ \n\n\n\nvar _s = $RefreshSig$();\n\n\n\n\n\nfunction Reference(_param) {\n    var children = _param.children, className = _param.className, rest = (0,_swc_helpers_object_without_properties__WEBPACK_IMPORTED_MODULE_5__._)(_param, [\n        \"children\",\n        \"className\"\n    ]);\n    _s();\n    var linkRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null);\n    (0,_gsap_react__WEBPACK_IMPORTED_MODULE_1__.useGSAP)(function() {\n        gsap_all__WEBPACK_IMPORTED_MODULE_6__[\"default\"].to(linkRef.current, {\n            scrollTrigger: {\n                trigger: linkRef.current\n            },\n            opacity: 1,\n            translateY: 0,\n            delay: 0.7\n        });\n    }, {\n        scope: linkRef\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_3__[\"default\"], (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_7__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_8__._)({\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(className),\n        ref: linkRef\n    }, rest), {\n        style: {\n            opacity: 0,\n            transform: \"translateY(100%)\"\n        },\n        children: children\n    }), void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\ui\\\\reference\\\\Reference.tsx\",\n        lineNumber: 27,\n        columnNumber: 3\n    }, this);\n}\n_s(Reference, \"6tZYbcCgfRFlDccc0Uexpu3luNY=\", false, function() {\n    return [\n        _gsap_react__WEBPACK_IMPORTED_MODULE_1__.useGSAP\n    ];\n});\n_c = Reference;\nvar _c;\n$RefreshReg$(_c, \"Reference\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL3JlZmVyZW5jZS9SZWZlcmVuY2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFcUM7QUFDaEI7QUFDTTtBQUNDO0FBQ0U7QUFJdkIsU0FBU0ssVUFBVTtRQUFFQyxXQUFGLE9BQUVBLFVBQVVDLFlBQVosT0FBWUEsV0FBY0MsT0FBQUEseUVBQUFBLENBQTFCO1FBQUVGO1FBQVVDOzs7SUFDckMsSUFBTUUsVUFBVUwsNkNBQU1BLENBQW9CO0lBQzFDSixvREFBT0EsQ0FDTjtRQUNDRSxnREFBSUEsQ0FBQ1EsRUFBRSxDQUFDRCxRQUFRRSxPQUFPLEVBQUU7WUFDeEJDLGVBQWU7Z0JBQ2RDLFNBQVNKLFFBQVFFLE9BQU87WUFDekI7WUFDQUcsU0FBUztZQUNUQyxZQUFZO1lBQ1pDLE9BQU87UUFDUjtJQUNELEdBQ0E7UUFBRUMsT0FBT1I7SUFBUTtJQUVsQixxQkFDQyw4REFBQ04saURBQUlBLEVBQUFBLG1FQUFBQSxDQUFBQSw2REFBQUE7UUFDSkksV0FBV04sZ0RBQUVBLENBQUNNO1FBQ2RXLEtBQUtUO09BQ0REO1FBQ0pXLE9BQU87WUFBRUwsU0FBUztZQUFHTSxXQUFXO1FBQW1CO2tCQUVsRGQ7Ozs7OztBQUdKO0dBekJnQkQ7O1FBRWZMLGdEQUFPQTs7O0tBRlFLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3VpL3JlZmVyZW5jZS9SZWZlcmVuY2UudHN4PzQyODgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXHJcblxyXG5pbXBvcnQgeyB1c2VHU0FQIH0gZnJvbSAnQGdzYXAvcmVhY3QnXHJcbmltcG9ydCBjbiBmcm9tICdjbHN4J1xyXG5pbXBvcnQgZ3NhcCBmcm9tICdnc2FwL2FsbCdcclxuaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJ1xyXG5pbXBvcnQgeyB1c2VSZWYgfSBmcm9tICdyZWFjdCdcclxuXHJcbmltcG9ydCB7IElSZWZlcmVuY2UgfSBmcm9tICcuL3JlZmVyZW5jZS50eXBlcydcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBSZWZlcmVuY2UoeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCAuLi5yZXN0IH06IElSZWZlcmVuY2UpIHtcclxuXHRjb25zdCBsaW5rUmVmID0gdXNlUmVmPEhUTUxBbmNob3JFbGVtZW50PihudWxsKVxyXG5cdHVzZUdTQVAoXHJcblx0XHQoKSA9PiB7XHJcblx0XHRcdGdzYXAudG8obGlua1JlZi5jdXJyZW50LCB7XHJcblx0XHRcdFx0c2Nyb2xsVHJpZ2dlcjoge1xyXG5cdFx0XHRcdFx0dHJpZ2dlcjogbGlua1JlZi5jdXJyZW50XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRvcGFjaXR5OiAxLFxyXG5cdFx0XHRcdHRyYW5zbGF0ZVk6IDAsXHJcblx0XHRcdFx0ZGVsYXk6IDAuN1xyXG5cdFx0XHR9KVxyXG5cdFx0fSxcclxuXHRcdHsgc2NvcGU6IGxpbmtSZWYgfVxyXG5cdClcclxuXHRyZXR1cm4gKFxyXG5cdFx0PExpbmtcclxuXHRcdFx0Y2xhc3NOYW1lPXtjbihjbGFzc05hbWUpfVxyXG5cdFx0XHRyZWY9e2xpbmtSZWZ9XHJcblx0XHRcdHsuLi5yZXN0fVxyXG5cdFx0XHRzdHlsZT17eyBvcGFjaXR5OiAwLCB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDEwMCUpJyB9fVxyXG5cdFx0PlxyXG5cdFx0XHR7Y2hpbGRyZW59XHJcblx0XHQ8L0xpbms+XHJcblx0KVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VHU0FQIiwiY24iLCJnc2FwIiwiTGluayIsInVzZVJlZiIsIlJlZmVyZW5jZSIsImNoaWxkcmVuIiwiY2xhc3NOYW1lIiwicmVzdCIsImxpbmtSZWYiLCJ0byIsImN1cnJlbnQiLCJzY3JvbGxUcmlnZ2VyIiwidHJpZ2dlciIsIm9wYWNpdHkiLCJ0cmFuc2xhdGVZIiwiZGVsYXkiLCJzY29wZSIsInJlZiIsInN0eWxlIiwidHJhbnNmb3JtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/reference/Reference.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/useful/UsefulSlider.tsx":
/*!************************************************!*\
  !*** ./src/components/useful/UsefulSlider.tsx ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UsefulSlider: function() { return /* binding */ UsefulSlider; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/image.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/api/link.js\");\n/* harmony import */ var swiper_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! swiper/react */ \"(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/swiper-react.mjs\");\n/* harmony import */ var _Useful_module_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Useful.module.scss */ \"(app-pages-browser)/./src/components/useful/Useful.module.scss\");\n/* harmony import */ var _Useful_module_scss__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_Useful_module_scss__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ UsefulSlider auto */ \n\n\n\n\nfunction UsefulSlider(slides) {\n    var _this = this;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(swiper_react__WEBPACK_IMPORTED_MODULE_3__.Swiper, {\n        slidesPerView: \"auto\",\n        loop: true,\n        className: (_Useful_module_scss__WEBPACK_IMPORTED_MODULE_4___default().useful__slider),\n        children: Object.values(slides).map(function(slide, index) {\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(swiper_react__WEBPACK_IMPORTED_MODULE_3__.SwiperSlide, {\n                className: (_Useful_module_scss__WEBPACK_IMPORTED_MODULE_4___default().useful__sliderSlide),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                    href: slide.href,\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_Useful_module_scss__WEBPACK_IMPORTED_MODULE_4___default().useful__sliderSlideImg),\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                                src: slide.image,\n                                alt: slide.title,\n                                width: 456,\n                                height: 300\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\useful\\\\UsefulSlider.tsx\",\n                                lineNumber: 30,\n                                columnNumber: 8\n                            }, _this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\useful\\\\UsefulSlider.tsx\",\n                            lineNumber: 29,\n                            columnNumber: 7\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h6\", {\n                            className: (_Useful_module_scss__WEBPACK_IMPORTED_MODULE_4___default().useful__sliderSlideTitle),\n                            children: slide.title\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\useful\\\\UsefulSlider.tsx\",\n                            lineNumber: 37,\n                            columnNumber: 7\n                        }, _this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: (_Useful_module_scss__WEBPACK_IMPORTED_MODULE_4___default().useful__sliderSlideText),\n                            children: slide.text\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\useful\\\\UsefulSlider.tsx\",\n                            lineNumber: 38,\n                            columnNumber: 7\n                        }, _this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\useful\\\\UsefulSlider.tsx\",\n                    lineNumber: 28,\n                    columnNumber: 6\n                }, _this)\n            }, index, false, {\n                fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\useful\\\\UsefulSlider.tsx\",\n                lineNumber: 24,\n                columnNumber: 5\n            }, _this);\n        })\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\79533\\\\Desktop\\\\front-rband\\\\rband\\\\src\\\\components\\\\useful\\\\UsefulSlider.tsx\",\n        lineNumber: 18,\n        columnNumber: 3\n    }, this);\n}\n_c = UsefulSlider;\nvar _c;\n$RefreshReg$(_c, \"UsefulSlider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VzZWZ1bC9Vc2VmdWxTbGlkZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBRThCO0FBQ0Y7QUFDc0I7QUFFUjtBQVNuQyxTQUFTSyxhQUFhQyxNQUFxQjs7SUFDakQscUJBQ0MsOERBQUNKLGdEQUFNQTtRQUNOSyxlQUFjO1FBQ2RDLE1BQU07UUFDTkMsV0FBV0wsMkVBQXNCO2tCQUVoQ08sT0FBT0MsTUFBTSxDQUFDTixRQUFRTyxHQUFHLENBQUMsU0FBQ0MsT0FBT0M7aUNBQ2xDLDhEQUFDWixxREFBV0E7Z0JBQ1hNLFdBQVdMLGdGQUEyQjswQkFHdEMsNEVBQUNILGlEQUFJQTtvQkFBQ2dCLE1BQU1ILE1BQU1HLElBQUk7O3NDQUNyQiw4REFBQ0M7NEJBQUlULFdBQVdMLG1GQUE4QjtzQ0FDN0MsNEVBQUNKLGtEQUFLQTtnQ0FDTG9CLEtBQUtOLE1BQU1PLEtBQUs7Z0NBQ2hCQyxLQUFLUixNQUFNUyxLQUFLO2dDQUNoQkMsT0FBTztnQ0FDUEMsUUFBUTs7Ozs7Ozs7Ozs7c0NBR1YsOERBQUNDOzRCQUFHakIsV0FBV0wscUZBQWdDO3NDQUFHVSxNQUFNUyxLQUFLOzs7Ozs7c0NBQzdELDhEQUFDSzs0QkFBRW5CLFdBQVdMLG9GQUErQjtzQ0FBR1UsTUFBTWdCLElBQUk7Ozs7Ozs7Ozs7OztlQVp0RGY7Ozs7Ozs7Ozs7O0FBa0JWO0tBNUJnQlYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdXNlZnVsL1VzZWZ1bFNsaWRlci50c3g/NTJmMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCBJbWFnZSBmcm9tICduZXh0L2ltYWdlJ1xyXG5pbXBvcnQgTGluayBmcm9tICduZXh0L2xpbmsnXHJcbmltcG9ydCB7IFN3aXBlciwgU3dpcGVyU2xpZGUgfSBmcm9tICdzd2lwZXIvcmVhY3QnXHJcblxyXG5pbXBvcnQgY2xhc3NlcyBmcm9tICcuL1VzZWZ1bC5tb2R1bGUuc2NzcydcclxuXHJcbmludGVyZmFjZSBJUHJvcHMge1xyXG5cdHRpdGxlOiBzdHJpbmdcclxuXHRocmVmOiBzdHJpbmdcclxuXHR0ZXh0OiBzdHJpbmdcclxuXHRpbWFnZTogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBVc2VmdWxTbGlkZXIoc2xpZGVzOiBBcnJheTxJUHJvcHM+KSB7XHJcblx0cmV0dXJuIChcclxuXHRcdDxTd2lwZXJcclxuXHRcdFx0c2xpZGVzUGVyVmlldz0nYXV0bydcclxuXHRcdFx0bG9vcD17dHJ1ZX1cclxuXHRcdFx0Y2xhc3NOYW1lPXtjbGFzc2VzLnVzZWZ1bF9fc2xpZGVyfVxyXG5cdFx0PlxyXG5cdFx0XHR7T2JqZWN0LnZhbHVlcyhzbGlkZXMpLm1hcCgoc2xpZGUsIGluZGV4KSA9PiAoXHJcblx0XHRcdFx0PFN3aXBlclNsaWRlXHJcblx0XHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzZXMudXNlZnVsX19zbGlkZXJTbGlkZX1cclxuXHRcdFx0XHRcdGtleT17aW5kZXh9XHJcblx0XHRcdFx0PlxyXG5cdFx0XHRcdFx0PExpbmsgaHJlZj17c2xpZGUuaHJlZn0+XHJcblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzLnVzZWZ1bF9fc2xpZGVyU2xpZGVJbWd9PlxyXG5cdFx0XHRcdFx0XHRcdDxJbWFnZVxyXG5cdFx0XHRcdFx0XHRcdFx0c3JjPXtzbGlkZS5pbWFnZX1cclxuXHRcdFx0XHRcdFx0XHRcdGFsdD17c2xpZGUudGl0bGV9XHJcblx0XHRcdFx0XHRcdFx0XHR3aWR0aD17NDU2fVxyXG5cdFx0XHRcdFx0XHRcdFx0aGVpZ2h0PXszMDB9XHJcblx0XHRcdFx0XHRcdFx0Lz5cclxuXHRcdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHRcdDxoNiBjbGFzc05hbWU9e2NsYXNzZXMudXNlZnVsX19zbGlkZXJTbGlkZVRpdGxlfT57c2xpZGUudGl0bGV9PC9oNj5cclxuXHRcdFx0XHRcdFx0PHAgY2xhc3NOYW1lPXtjbGFzc2VzLnVzZWZ1bF9fc2xpZGVyU2xpZGVUZXh0fT57c2xpZGUudGV4dH08L3A+XHJcblx0XHRcdFx0XHQ8L0xpbms+XHJcblx0XHRcdFx0PC9Td2lwZXJTbGlkZT5cclxuXHRcdFx0KSl9XHJcblx0XHQ8L1N3aXBlcj5cclxuXHQpXHJcbn1cclxuIl0sIm5hbWVzIjpbIkltYWdlIiwiTGluayIsIlN3aXBlciIsIlN3aXBlclNsaWRlIiwiY2xhc3NlcyIsIlVzZWZ1bFNsaWRlciIsInNsaWRlcyIsInNsaWRlc1BlclZpZXciLCJsb29wIiwiY2xhc3NOYW1lIiwidXNlZnVsX19zbGlkZXIiLCJPYmplY3QiLCJ2YWx1ZXMiLCJtYXAiLCJzbGlkZSIsImluZGV4IiwidXNlZnVsX19zbGlkZXJTbGlkZSIsImhyZWYiLCJkaXYiLCJ1c2VmdWxfX3NsaWRlclNsaWRlSW1nIiwic3JjIiwiaW1hZ2UiLCJhbHQiLCJ0aXRsZSIsIndpZHRoIiwiaGVpZ2h0IiwiaDYiLCJ1c2VmdWxfX3NsaWRlclNsaWRlVGl0bGUiLCJwIiwidXNlZnVsX19zbGlkZXJTbGlkZVRleHQiLCJ0ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/useful/UsefulSlider.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/useScroll.ts":
/*!********************************!*\
  !*** ./src/hooks/useScroll.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useScroll: function() { return /* binding */ useScroll; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction useScroll() {\n    var _useState = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_1__._)((0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), 2), scroll = _useState[0], setScroll = _useState[1];\n    var handleScroll = function(e) {\n        setScroll(e.currentTarget.scrollY);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        window.addEventListener(\"scroll\", handleScroll);\n        setScroll(window.scrollY);\n        return function() {\n            window.removeEventListener(\"scroll\", handleScroll);\n        };\n    }, []);\n    return {\n        scroll: scroll,\n        setScroll: setScroll\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VTY3JvbGwudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMkM7QUFFcEMsU0FBU0U7SUFDZixJQUE0QkQsWUFBQUEsK0RBQUFBLENBQUFBLCtDQUFRQSxDQUFTLFFBQXRDRSxTQUFxQkYsY0FBYkcsWUFBYUg7SUFFNUIsSUFBTUksZUFBZSxTQUFDQztRQUNyQkYsVUFBVSxFQUFHRyxhQUFhLENBQVlDLE9BQU87SUFDOUM7SUFFQVIsZ0RBQVNBLENBQUM7UUFDVFMsT0FBT0MsZ0JBQWdCLENBQUMsVUFBVUw7UUFDbENELFVBQVVLLE9BQU9ELE9BQU87UUFFeEIsT0FBTztZQUNOQyxPQUFPRSxtQkFBbUIsQ0FBQyxVQUFVTjtRQUN0QztJQUNELEdBQUcsRUFBRTtJQUNMLE9BQU87UUFBRUYsUUFBQUE7UUFBUUMsV0FBQUE7SUFBVTtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaG9va3MvdXNlU2Nyb2xsLnRzPzI3ODIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNjcm9sbCgpIHtcclxuXHRjb25zdCBbc2Nyb2xsLCBzZXRTY3JvbGxdID0gdXNlU3RhdGU8bnVtYmVyPigwKVxyXG5cclxuXHRjb25zdCBoYW5kbGVTY3JvbGwgPSAoZTogRXZlbnQpID0+IHtcclxuXHRcdHNldFNjcm9sbCgoZS5jdXJyZW50VGFyZ2V0IGFzIFdpbmRvdykuc2Nyb2xsWSlcclxuXHR9XHJcblxyXG5cdHVzZUVmZmVjdCgoKSA9PiB7XHJcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKVxyXG5cdFx0c2V0U2Nyb2xsKHdpbmRvdy5zY3JvbGxZKVxyXG5cclxuXHRcdHJldHVybiAoKSA9PiB7XHJcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVTY3JvbGwpXHJcblx0XHR9XHJcblx0fSwgW10pXHJcblx0cmV0dXJuIHsgc2Nyb2xsLCBzZXRTY3JvbGwgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZVNjcm9sbCIsInNjcm9sbCIsInNldFNjcm9sbCIsImhhbmRsZVNjcm9sbCIsImUiLCJjdXJyZW50VGFyZ2V0Iiwic2Nyb2xsWSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useScroll.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/store/our-project.store.ts":
/*!****************************************!*\
  !*** ./src/store/our-project.store.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useProjectStore: function() { return /* binding */ useProjectStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/.pnpm/zustand@4.5.2_@types+react@18.3.2_react@18.3.1/node_modules/zustand/esm/index.mjs\");\n\nvar useProjectStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)()(function(set) {\n    return {\n        projects: [\n            {\n                title: \"  \\xab\\xbb, \",\n                text: \"  ,   .\",\n                href: \"/\",\n                textColor: \"white\",\n                shadow: true,\n                image: \"/project3.jpg\",\n                video: [\n                    {\n                        src: \"/termotron_oblojka.mp4\",\n                        type: \"video/mp4\"\n                    }\n                ]\n            },\n            {\n                title: \"C   \\xab\\xbb, \",\n                text: \"C      .\",\n                href: \"/\",\n                image: \"/project1.jpg\"\n            },\n            {\n                title: \"C   \\xab\\xbb, \",\n                text: \"C      .\",\n                href: \"/\",\n                textColor: \"white\",\n                image: \"/project2.jpg\"\n            },\n            {\n                title: \"C   \\xab\\xbb, \",\n                text: \"C      .\",\n                href: \"/\",\n                image: \"/project4.jpg\"\n            },\n            {\n                title: \"C   \\xab\\xbb, \",\n                text: \"C      .\",\n                href: \"/\",\n                textColor: \"white\",\n                image: \"/project2.jpg\"\n            },\n            {\n                title: \"C   \\xab\\xbb, \",\n                text: \"C      .\",\n                href: \"/\",\n                image: \"/project4.jpg\"\n            }\n        ]\n    };\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS9vdXItcHJvamVjdC5zdG9yZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFnQztBQXVCekIsSUFBTUMsa0JBQWtCRCwrQ0FBTUEsR0FBa0JFLFNBQUFBO1dBQVE7UUFDOURDLFVBQVU7WUFDVDtnQkFDQ0MsT0FBTztnQkFDUEMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkMsV0FBVztnQkFDWEMsUUFBUTtnQkFDUkMsT0FBTztnQkFDUEMsT0FBTztvQkFDTjt3QkFDQ0MsS0FBSzt3QkFDTEMsTUFBTTtvQkFDUDtpQkFDQTtZQUNGO1lBQ0E7Z0JBQ0NSLE9BQU87Z0JBQ1BDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05HLE9BQU87WUFDUjtZQUNBO2dCQUNDTCxPQUFPO2dCQUNQQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNOQyxXQUFXO2dCQUNYRSxPQUFPO1lBQ1I7WUFDQTtnQkFDQ0wsT0FBTztnQkFDUEMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkcsT0FBTztZQUNSO1lBQ0E7Z0JBQ0NMLE9BQU87Z0JBQ1BDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05DLFdBQVc7Z0JBQ1hFLE9BQU87WUFDUjtZQUNBO2dCQUNDTCxPQUFPO2dCQUNQQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNORyxPQUFPO1lBQ1I7U0FDQTtJQUNGO0dBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N0b3JlL291ci1wcm9qZWN0LnN0b3JlLnRzPzc4YmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCdcclxuXHJcbnR5cGUgVHlwZVRleHRDb2xvclByb2plY3RzID0gJ3doaXRlJ1xyXG5cclxudHlwZSBUeXBlVmlkZW9Qcm9qZWN0cyA9IHtcclxuXHRzcmM6IHN0cmluZ1xyXG5cdHR5cGU6IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElQcm9qZWN0IHtcclxuXHR0aXRsZTogc3RyaW5nXHJcblx0dGV4dDogc3RyaW5nXHJcblx0aHJlZjogc3RyaW5nXHJcblx0dGV4dENvbG9yPzogVHlwZVRleHRDb2xvclByb2plY3RzXHJcblx0c2hhZG93PzogYm9vbGVhblxyXG5cdGltYWdlOiBzdHJpbmdcclxuXHR2aWRlbz86IEFycmF5PFR5cGVWaWRlb1Byb2plY3RzPlxyXG59XHJcblxyXG5pbnRlcmZhY2UgSVByb2plY3RTdG9yZSB7XHJcblx0cHJvamVjdHM/OiBJUHJvamVjdFtdXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB1c2VQcm9qZWN0U3RvcmUgPSBjcmVhdGU8SVByb2plY3RTdG9yZT4oKShzZXQgPT4gKHtcclxuXHRwcm9qZWN0czogW1xyXG5cdFx0e1xyXG5cdFx0XHR0aXRsZTogJ9Ch0LDQudGCINC30LDQstC+0LTQsCDCq9Ci0LXRgNC80L7RgtGA0L7QvcK7LCDQoNC+0YHRgdC40Y8nLFxyXG5cdFx0XHR0ZXh0OiAn0KHQvtGH0LXRgtCw0L3QuNC1INC80L3QvtCz0L7Qu9C10YLQvdC10LPQviDQvtC/0YvRgtCwLCDQvNC+0YnQvdC+0YHRgtC4INC4INC40L3QvdC+0LLQsNGG0LjQuS4nLFxyXG5cdFx0XHRocmVmOiAnLycsXHJcblx0XHRcdHRleHRDb2xvcjogJ3doaXRlJyxcclxuXHRcdFx0c2hhZG93OiB0cnVlLFxyXG5cdFx0XHRpbWFnZTogJy9wcm9qZWN0My5qcGcnLFxyXG5cdFx0XHR2aWRlbzogW1xyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHNyYzogJy90ZXJtb3Ryb25fb2Jsb2prYS5tcDQnLFxyXG5cdFx0XHRcdFx0dHlwZTogJ3ZpZGVvL21wNCdcclxuXHRcdFx0XHR9XHJcblx0XHRcdF1cclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdHRpdGxlOiAnQ9Cw0LnRgiDQtNC10LLQtdC70L7Qv9C10YDRgdC60L7QuSDQutC+0LzQv9Cw0L3QuNC4IMKr0KHQkNCa0KHCuywg0KDQvtGB0YHQuNGPJyxcclxuXHRcdFx0dGV4dDogJ0PQvtCy0YDQtdC80LXQvdC90YvQuSDQv9C+0LTRhdC+0LQg0LIg0L/RgNC+0LXQutGC0LjRgNC+0LLQsNC90LjQuCDRgdCw0LnRgtCwINC4INC60LLQsNGA0YLQuNGALicsXHJcblx0XHRcdGhyZWY6ICcvJyxcclxuXHRcdFx0aW1hZ2U6ICcvcHJvamVjdDEuanBnJ1xyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0dGl0bGU6ICdD0LDQudGCINC00LXQstC10LvQvtC/0LXRgNGB0LrQvtC5INC60L7QvNC/0LDQvdC40LggwqvQodCQ0JrQocK7LCDQoNC+0YHRgdC40Y8nLFxyXG5cdFx0XHR0ZXh0OiAnQ9C+0LLRgNC10LzQtdC90L3Ri9C5INC/0L7QtNGF0L7QtCDQsiDQv9GA0L7QtdC60YLQuNGA0L7QstCw0L3QuNC4INGB0LDQudGC0LAg0Lgg0LrQstCw0YDRgtC40YAuJyxcclxuXHRcdFx0aHJlZjogJy8nLFxyXG5cdFx0XHR0ZXh0Q29sb3I6ICd3aGl0ZScsXHJcblx0XHRcdGltYWdlOiAnL3Byb2plY3QyLmpwZydcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdHRpdGxlOiAnQ9Cw0LnRgiDQtNC10LLQtdC70L7Qv9C10YDRgdC60L7QuSDQutC+0LzQv9Cw0L3QuNC4IMKr0KHQkNCa0KHCuywg0KDQvtGB0YHQuNGPJyxcclxuXHRcdFx0dGV4dDogJ0PQvtCy0YDQtdC80LXQvdC90YvQuSDQv9C+0LTRhdC+0LQg0LIg0L/RgNC+0LXQutGC0LjRgNC+0LLQsNC90LjQuCDRgdCw0LnRgtCwINC4INC60LLQsNGA0YLQuNGALicsXHJcblx0XHRcdGhyZWY6ICcvJyxcclxuXHRcdFx0aW1hZ2U6ICcvcHJvamVjdDQuanBnJ1xyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0dGl0bGU6ICdD0LDQudGCINC00LXQstC10LvQvtC/0LXRgNGB0LrQvtC5INC60L7QvNC/0LDQvdC40LggwqvQodCQ0JrQocK7LCDQoNC+0YHRgdC40Y8nLFxyXG5cdFx0XHR0ZXh0OiAnQ9C+0LLRgNC10LzQtdC90L3Ri9C5INC/0L7QtNGF0L7QtCDQsiDQv9GA0L7QtdC60YLQuNGA0L7QstCw0L3QuNC4INGB0LDQudGC0LAg0Lgg0LrQstCw0YDRgtC40YAuJyxcclxuXHRcdFx0aHJlZjogJy8nLFxyXG5cdFx0XHR0ZXh0Q29sb3I6ICd3aGl0ZScsXHJcblx0XHRcdGltYWdlOiAnL3Byb2plY3QyLmpwZydcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdHRpdGxlOiAnQ9Cw0LnRgiDQtNC10LLQtdC70L7Qv9C10YDRgdC60L7QuSDQutC+0LzQv9Cw0L3QuNC4IMKr0KHQkNCa0KHCuywg0KDQvtGB0YHQuNGPJyxcclxuXHRcdFx0dGV4dDogJ0PQvtCy0YDQtdC80LXQvdC90YvQuSDQv9C+0LTRhdC+0LQg0LIg0L/RgNC+0LXQutGC0LjRgNC+0LLQsNC90LjQuCDRgdCw0LnRgtCwINC4INC60LLQsNGA0YLQuNGALicsXHJcblx0XHRcdGhyZWY6ICcvJyxcclxuXHRcdFx0aW1hZ2U6ICcvcHJvamVjdDQuanBnJ1xyXG5cdFx0fVxyXG5cdF1cclxufSkpXHJcbiJdLCJuYW1lcyI6WyJjcmVhdGUiLCJ1c2VQcm9qZWN0U3RvcmUiLCJzZXQiLCJwcm9qZWN0cyIsInRpdGxlIiwidGV4dCIsImhyZWYiLCJ0ZXh0Q29sb3IiLCJzaGFkb3ciLCJpbWFnZSIsInZpZGVvIiwic3JjIiwidHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/our-project.store.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!*******************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*******************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyw2TEFBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz82YTBlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!*********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \*********************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMV9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS43Ny4yL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSxxUkFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTQuMi4xX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjFfc2Fzc0AxLjc3LjIvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/NjdhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: function() { return /* binding */ clsx; }\n/* harmony export */ });\nfunction r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}/* harmony default export */ __webpack_exports__[\"default\"] = (clsx);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9jbHN4QDIuMS4xL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGNBQWMsYUFBYSwrQ0FBK0MsZ0RBQWdELGVBQWUsUUFBUSxJQUFJLDBDQUEwQyx5Q0FBeUMsU0FBZ0IsZ0JBQWdCLHdDQUF3QyxJQUFJLG1EQUFtRCxTQUFTLCtEQUFlLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nsc3hAMi4xLjEvbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm1qcz8wNjYyIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKXt2YXIgbz1lLmxlbmd0aDtmb3IodD0wO3Q8bzt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpfWVsc2UgZm9yKGYgaW4gZSllW2ZdJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCIsbz1hcmd1bWVudHMubGVuZ3RoO2Y8bztmKyspKGU9YXJndW1lbnRzW2ZdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/ssr-window.esm.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/ssr-window.esm.mjs ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: function() { return /* binding */ getWindow; },\n/* harmony export */   g: function() { return /* binding */ getDocument; }\n/* harmony export */ });\n/**\n * SSR Window 4.0.2\n * Better handling for window object in SSR environment\n * https://github.com/nolimits4web/ssr-window\n *\n * Copyright 2021, Vladimir Kharlampidi\n *\n * Licensed under MIT\n *\n * Released on: December 13, 2021\n */ /* eslint-disable no-param-reassign */ function isObject(obj) {\n    return obj !== null && typeof obj === \"object\" && \"constructor\" in obj && obj.constructor === Object;\n}\nfunction extend(target, src) {\n    if (target === void 0) {\n        target = {};\n    }\n    if (src === void 0) {\n        src = {};\n    }\n    Object.keys(src).forEach(function(key) {\n        if (typeof target[key] === \"undefined\") target[key] = src[key];\n        else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {\n            extend(target[key], src[key]);\n        }\n    });\n}\nvar ssrDocument = {\n    body: {},\n    addEventListener: function() {},\n    removeEventListener: function() {},\n    activeElement: {\n        blur: function() {},\n        nodeName: \"\"\n    },\n    querySelector: function() {\n        return null;\n    },\n    querySelectorAll: function() {\n        return [];\n    },\n    getElementById: function() {\n        return null;\n    },\n    createEvent: function() {\n        return {\n            initEvent: function() {}\n        };\n    },\n    createElement: function() {\n        return {\n            children: [],\n            childNodes: [],\n            style: {},\n            setAttribute: function() {},\n            getElementsByTagName: function() {\n                return [];\n            }\n        };\n    },\n    createElementNS: function() {\n        return {};\n    },\n    importNode: function() {\n        return null;\n    },\n    location: {\n        hash: \"\",\n        host: \"\",\n        hostname: \"\",\n        href: \"\",\n        origin: \"\",\n        pathname: \"\",\n        protocol: \"\",\n        search: \"\"\n    }\n};\nfunction getDocument() {\n    var doc = typeof document !== \"undefined\" ? document : {};\n    extend(doc, ssrDocument);\n    return doc;\n}\nvar ssrWindow = {\n    document: ssrDocument,\n    navigator: {\n        userAgent: \"\"\n    },\n    location: {\n        hash: \"\",\n        host: \"\",\n        hostname: \"\",\n        href: \"\",\n        origin: \"\",\n        pathname: \"\",\n        protocol: \"\",\n        search: \"\"\n    },\n    history: {\n        replaceState: function() {},\n        pushState: function() {},\n        go: function() {},\n        back: function() {}\n    },\n    CustomEvent: function CustomEvent() {\n        return this;\n    },\n    addEventListener: function() {},\n    removeEventListener: function() {},\n    getComputedStyle: function() {\n        return {\n            getPropertyValue: function() {\n                return \"\";\n            }\n        };\n    },\n    Image: function() {},\n    Date: function() {},\n    screen: {},\n    setTimeout: function() {},\n    clearTimeout: function() {},\n    matchMedia: function() {\n        return {};\n    },\n    requestAnimationFrame: function(callback) {\n        if (typeof setTimeout === \"undefined\") {\n            callback();\n            return null;\n        }\n        return setTimeout(callback, 0);\n    },\n    cancelAnimationFrame: function(id) {\n        if (typeof setTimeout === \"undefined\") {\n            return;\n        }\n        clearTimeout(id);\n    }\n};\nfunction getWindow() {\n    var win = typeof window !== \"undefined\" ? window : {};\n    extend(win, ssrWindow);\n    return win;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zd2lwZXJAMTEuMS4zL25vZGVfbW9kdWxlcy9zd2lwZXIvc2hhcmVkL3Nzci13aW5kb3cuZXNtLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Ozs7Ozs7O0NBVUMsR0FDRCxvQ0FBb0MsR0FDcEMsU0FBU0EsU0FBU0MsR0FBRztJQUNuQixPQUFPQSxRQUFRLFFBQVEsT0FBT0EsUUFBUSxZQUFZLGlCQUFpQkEsT0FBT0EsSUFBSUMsV0FBVyxLQUFLQztBQUNoRztBQUNBLFNBQVNDLE9BQU9DLE1BQU0sRUFBRUMsR0FBRztJQUN6QixJQUFJRCxXQUFXLEtBQUssR0FBRztRQUNyQkEsU0FBUyxDQUFDO0lBQ1o7SUFDQSxJQUFJQyxRQUFRLEtBQUssR0FBRztRQUNsQkEsTUFBTSxDQUFDO0lBQ1Q7SUFDQUgsT0FBT0ksSUFBSSxDQUFDRCxLQUFLRSxPQUFPLENBQUNDLFNBQUFBO1FBQ3ZCLElBQUksT0FBT0osTUFBTSxDQUFDSSxJQUFJLEtBQUssYUFBYUosTUFBTSxDQUFDSSxJQUFJLEdBQUdILEdBQUcsQ0FBQ0csSUFBSTthQUFNLElBQUlULFNBQVNNLEdBQUcsQ0FBQ0csSUFBSSxLQUFLVCxTQUFTSyxNQUFNLENBQUNJLElBQUksS0FBS04sT0FBT0ksSUFBSSxDQUFDRCxHQUFHLENBQUNHLElBQUksRUFBRUMsTUFBTSxHQUFHLEdBQUc7WUFDdkpOLE9BQU9DLE1BQU0sQ0FBQ0ksSUFBSSxFQUFFSCxHQUFHLENBQUNHLElBQUk7UUFDOUI7SUFDRjtBQUNGO0FBQ0EsSUFBTUUsY0FBYztJQUNsQkMsTUFBTSxDQUFDO0lBQ1BDLGtCQUFBQSxZQUFvQjtJQUNwQkMscUJBQUFBLFlBQXVCO0lBQ3ZCQyxlQUFlO1FBQ2JDLE1BQUFBLFlBQVE7UUFDUkMsVUFBVTtJQUNaO0lBQ0FDLGVBQUFBO1FBQ0UsT0FBTztJQUNUO0lBQ0FDLGtCQUFBQTtRQUNFLE9BQU8sRUFBRTtJQUNYO0lBQ0FDLGdCQUFBQTtRQUNFLE9BQU87SUFDVDtJQUNBQyxhQUFBQTtRQUNFLE9BQU87WUFDTEMsV0FBQUEsWUFBYTtRQUNmO0lBQ0Y7SUFDQUMsZUFBQUE7UUFDRSxPQUFPO1lBQ0xDLFVBQVUsRUFBRTtZQUNaQyxZQUFZLEVBQUU7WUFDZEMsT0FBTyxDQUFDO1lBQ1JDLGNBQUFBLFlBQWdCO1lBQ2hCQyxzQkFBQUE7Z0JBQ0UsT0FBTyxFQUFFO1lBQ1g7UUFDRjtJQUNGO0lBQ0FDLGlCQUFBQTtRQUNFLE9BQU8sQ0FBQztJQUNWO0lBQ0FDLFlBQUFBO1FBQ0UsT0FBTztJQUNUO0lBQ0FDLFVBQVU7UUFDUkMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLFVBQVU7UUFDVkMsTUFBTTtRQUNOQyxRQUFRO1FBQ1JDLFVBQVU7UUFDVkMsVUFBVTtRQUNWQyxRQUFRO0lBQ1Y7QUFDRjtBQUNBLFNBQVNDO0lBQ1AsSUFBTUMsTUFBTSxPQUFPQyxhQUFhLGNBQWNBLFdBQVcsQ0FBQztJQUMxRHRDLE9BQU9xQyxLQUFLOUI7SUFDWixPQUFPOEI7QUFDVDtBQUNBLElBQU1FLFlBQVk7SUFDaEJELFVBQVUvQjtJQUNWaUMsV0FBVztRQUNUQyxXQUFXO0lBQ2I7SUFDQWQsVUFBVTtRQUNSQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsVUFBVTtRQUNWQyxNQUFNO1FBQ05DLFFBQVE7UUFDUkMsVUFBVTtRQUNWQyxVQUFVO1FBQ1ZDLFFBQVE7SUFDVjtJQUNBTyxTQUFTO1FBQ1BDLGNBQUFBLFlBQWdCO1FBQ2hCQyxXQUFBQSxZQUFhO1FBQ2JDLElBQUFBLFlBQU07UUFDTkMsTUFBQUEsWUFBUTtJQUNWO0lBQ0FDLGFBQWEsU0FBU0E7UUFDcEIsT0FBTyxJQUFJO0lBQ2I7SUFDQXRDLGtCQUFBQSxZQUFvQjtJQUNwQkMscUJBQUFBLFlBQXVCO0lBQ3ZCc0Msa0JBQUFBO1FBQ0UsT0FBTztZQUNMQyxrQkFBQUE7Z0JBQ0UsT0FBTztZQUNUO1FBQ0Y7SUFDRjtJQUNBQyxPQUFBQSxZQUFTO0lBQ1RDLE1BQUFBLFlBQVE7SUFDUkMsUUFBUSxDQUFDO0lBQ1RDLFlBQUFBLFlBQWM7SUFDZEMsY0FBQUEsWUFBZ0I7SUFDaEJDLFlBQUFBO1FBQ0UsT0FBTyxDQUFDO0lBQ1Y7SUFDQUMsdUJBQUFBLFNBQXNCQyxRQUFRO1FBQzVCLElBQUksT0FBT0osZUFBZSxhQUFhO1lBQ3JDSTtZQUNBLE9BQU87UUFDVDtRQUNBLE9BQU9KLFdBQVdJLFVBQVU7SUFDOUI7SUFDQUMsc0JBQUFBLFNBQXFCQyxFQUFFO1FBQ3JCLElBQUksT0FBT04sZUFBZSxhQUFhO1lBQ3JDO1FBQ0Y7UUFDQUMsYUFBYUs7SUFDZjtBQUNGO0FBQ0EsU0FBU0M7SUFDUCxJQUFNQyxNQUFNLE9BQU9DLFdBQVcsY0FBY0EsU0FBUyxDQUFDO0lBQ3REOUQsT0FBTzZELEtBQUt0QjtJQUNaLE9BQU9zQjtBQUNUO0FBRTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zd2lwZXJAMTEuMS4zL25vZGVfbW9kdWxlcy9zd2lwZXIvc2hhcmVkL3Nzci13aW5kb3cuZXNtLm1qcz9hN2UwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU1NSIFdpbmRvdyA0LjAuMlxuICogQmV0dGVyIGhhbmRsaW5nIGZvciB3aW5kb3cgb2JqZWN0IGluIFNTUiBlbnZpcm9ubWVudFxuICogaHR0cHM6Ly9naXRodWIuY29tL25vbGltaXRzNHdlYi9zc3Itd2luZG93XG4gKlxuICogQ29weXJpZ2h0IDIwMjEsIFZsYWRpbWlyIEtoYXJsYW1waWRpXG4gKlxuICogTGljZW5zZWQgdW5kZXIgTUlUXG4gKlxuICogUmVsZWFzZWQgb246IERlY2VtYmVyIDEzLCAyMDIxXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAnY29uc3RydWN0b3InIGluIG9iaiAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbn1cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNyYykge1xuICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHtcbiAgICB0YXJnZXQgPSB7fTtcbiAgfVxuICBpZiAoc3JjID09PSB2b2lkIDApIHtcbiAgICBzcmMgPSB7fTtcbiAgfVxuICBPYmplY3Qua2V5cyhzcmMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAodHlwZW9mIHRhcmdldFtrZXldID09PSAndW5kZWZpbmVkJykgdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtlbHNlIGlmIChpc09iamVjdChzcmNba2V5XSkgJiYgaXNPYmplY3QodGFyZ2V0W2tleV0pICYmIE9iamVjdC5rZXlzKHNyY1trZXldKS5sZW5ndGggPiAwKSB7XG4gICAgICBleHRlbmQodGFyZ2V0W2tleV0sIHNyY1trZXldKTtcbiAgICB9XG4gIH0pO1xufVxuY29uc3Qgc3NyRG9jdW1lbnQgPSB7XG4gIGJvZHk6IHt9LFxuICBhZGRFdmVudExpc3RlbmVyKCkge30sXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB7fSxcbiAgYWN0aXZlRWxlbWVudDoge1xuICAgIGJsdXIoKSB7fSxcbiAgICBub2RlTmFtZTogJydcbiAgfSxcbiAgcXVlcnlTZWxlY3RvcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgcXVlcnlTZWxlY3RvckFsbCgpIHtcbiAgICByZXR1cm4gW107XG4gIH0sXG4gIGdldEVsZW1lbnRCeUlkKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBjcmVhdGVFdmVudCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5pdEV2ZW50KCkge31cbiAgICB9O1xuICB9LFxuICBjcmVhdGVFbGVtZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICAgIHN0eWxlOiB7fSxcbiAgICAgIHNldEF0dHJpYnV0ZSgpIHt9LFxuICAgICAgZ2V0RWxlbWVudHNCeVRhZ05hbWUoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBjcmVhdGVFbGVtZW50TlMoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9LFxuICBpbXBvcnROb2RlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBsb2NhdGlvbjoge1xuICAgIGhhc2g6ICcnLFxuICAgIGhvc3Q6ICcnLFxuICAgIGhvc3RuYW1lOiAnJyxcbiAgICBocmVmOiAnJyxcbiAgICBvcmlnaW46ICcnLFxuICAgIHBhdGhuYW1lOiAnJyxcbiAgICBwcm90b2NvbDogJycsXG4gICAgc2VhcmNoOiAnJ1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XG4gIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHt9O1xuICBleHRlbmQoZG9jLCBzc3JEb2N1bWVudCk7XG4gIHJldHVybiBkb2M7XG59XG5jb25zdCBzc3JXaW5kb3cgPSB7XG4gIGRvY3VtZW50OiBzc3JEb2N1bWVudCxcbiAgbmF2aWdhdG9yOiB7XG4gICAgdXNlckFnZW50OiAnJ1xuICB9LFxuICBsb2NhdGlvbjoge1xuICAgIGhhc2g6ICcnLFxuICAgIGhvc3Q6ICcnLFxuICAgIGhvc3RuYW1lOiAnJyxcbiAgICBocmVmOiAnJyxcbiAgICBvcmlnaW46ICcnLFxuICAgIHBhdGhuYW1lOiAnJyxcbiAgICBwcm90b2NvbDogJycsXG4gICAgc2VhcmNoOiAnJ1xuICB9LFxuICBoaXN0b3J5OiB7XG4gICAgcmVwbGFjZVN0YXRlKCkge30sXG4gICAgcHVzaFN0YXRlKCkge30sXG4gICAgZ28oKSB7fSxcbiAgICBiYWNrKCkge31cbiAgfSxcbiAgQ3VzdG9tRXZlbnQ6IGZ1bmN0aW9uIEN1c3RvbUV2ZW50KCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRFdmVudExpc3RlbmVyKCkge30sXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB7fSxcbiAgZ2V0Q29tcHV0ZWRTdHlsZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0UHJvcGVydHlWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIEltYWdlKCkge30sXG4gIERhdGUoKSB7fSxcbiAgc2NyZWVuOiB7fSxcbiAgc2V0VGltZW91dCgpIHt9LFxuICBjbGVhclRpbWVvdXQoKSB7fSxcbiAgbWF0Y2hNZWRpYSgpIHtcbiAgICByZXR1cm4ge307XG4gIH0sXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICB9LFxuICBjYW5jZWxBbmltYXRpb25GcmFtZShpZCkge1xuICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldFdpbmRvdygpIHtcbiAgY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fTtcbiAgZXh0ZW5kKHdpbiwgc3NyV2luZG93KTtcbiAgcmV0dXJuIHdpbjtcbn1cblxuZXhwb3J0IHsgZ2V0V2luZG93IGFzIGEsIGdldERvY3VtZW50IGFzIGcgfTtcbiJdLCJuYW1lcyI6WyJpc09iamVjdCIsIm9iaiIsImNvbnN0cnVjdG9yIiwiT2JqZWN0IiwiZXh0ZW5kIiwidGFyZ2V0Iiwic3JjIiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJsZW5ndGgiLCJzc3JEb2N1bWVudCIsImJvZHkiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFjdGl2ZUVsZW1lbnQiLCJibHVyIiwibm9kZU5hbWUiLCJxdWVyeVNlbGVjdG9yIiwicXVlcnlTZWxlY3RvckFsbCIsImdldEVsZW1lbnRCeUlkIiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJjcmVhdGVFbGVtZW50IiwiY2hpbGRyZW4iLCJjaGlsZE5vZGVzIiwic3R5bGUiLCJzZXRBdHRyaWJ1dGUiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImNyZWF0ZUVsZW1lbnROUyIsImltcG9ydE5vZGUiLCJsb2NhdGlvbiIsImhhc2giLCJob3N0IiwiaG9zdG5hbWUiLCJocmVmIiwib3JpZ2luIiwicGF0aG5hbWUiLCJwcm90b2NvbCIsInNlYXJjaCIsImdldERvY3VtZW50IiwiZG9jIiwiZG9jdW1lbnQiLCJzc3JXaW5kb3ciLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJoaXN0b3J5IiwicmVwbGFjZVN0YXRlIiwicHVzaFN0YXRlIiwiZ28iLCJiYWNrIiwiQ3VzdG9tRXZlbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsIkltYWdlIiwiRGF0ZSIsInNjcmVlbiIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJtYXRjaE1lZGlhIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FsbGJhY2siLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImlkIiwiZ2V0V2luZG93Iiwid2luIiwid2luZG93IiwiYSIsImciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/ssr-window.esm.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/swiper-core.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/swiper-core.mjs ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: function() { return /* binding */ Swiper; },\n/* harmony export */   d: function() { return /* binding */ defaults; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_class_call_check__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_class_call_check.js\");\n/* harmony import */ var _swc_helpers_create_class__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @swc/helpers/_/_create_class */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_create_class.js\");\n/* harmony import */ var _swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_define_property */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_define_property.js\");\n/* harmony import */ var _swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\n/* harmony import */ var _swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread_props.js\");\n/* harmony import */ var _swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\n/* harmony import */ var _swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_to_consumable_array.js\");\n/* harmony import */ var _ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ssr-window.esm.mjs */ \"(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/ssr-window.esm.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.mjs */ \"(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/utils.mjs\");\n\n\n\n\n\n\n\n\n\nvar support;\nfunction calcSupport() {\n    var window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    var document1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n    return {\n        smoothScroll: document1.documentElement && document1.documentElement.style && \"scrollBehavior\" in document1.documentElement.style,\n        touch: !!(\"ontouchstart\" in window1 || window1.DocumentTouch && document1 instanceof window1.DocumentTouch)\n    };\n}\nfunction getSupport() {\n    if (!support) {\n        support = calcSupport();\n    }\n    return support;\n}\nvar deviceCached;\nfunction calcDevice(_temp) {\n    var userAgent = (_temp === void 0 ? {} : _temp).userAgent;\n    var support = getSupport();\n    var window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    var platform = window1.navigator.platform;\n    var ua = userAgent || window1.navigator.userAgent;\n    var device = {\n        ios: false,\n        android: false\n    };\n    var screenWidth = window1.screen.width;\n    var screenHeight = window1.screen.height;\n    var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n    var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n    var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n    var iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n    var windows = platform === \"Win32\";\n    var macos = platform === \"MacIntel\";\n    // iPadOs 13 fix\n    var iPadScreens = [\n        \"1024x1366\",\n        \"1366x1024\",\n        \"834x1194\",\n        \"1194x834\",\n        \"834x1112\",\n        \"1112x834\",\n        \"768x1024\",\n        \"1024x768\",\n        \"820x1180\",\n        \"1180x820\",\n        \"810x1080\",\n        \"1080x810\"\n    ];\n    if (!ipad && macos && support.touch && iPadScreens.indexOf(\"\".concat(screenWidth, \"x\").concat(screenHeight)) >= 0) {\n        ipad = ua.match(/(Version)\\/([\\d.]+)/);\n        if (!ipad) ipad = [\n            0,\n            1,\n            \"13_0_0\"\n        ];\n        macos = false;\n    }\n    // Android\n    if (android && !windows) {\n        device.os = \"android\";\n        device.android = true;\n    }\n    if (ipad || iphone || ipod) {\n        device.os = \"ios\";\n        device.ios = true;\n    }\n    // Export object\n    return device;\n}\nfunction getDevice(overrides) {\n    if (overrides === void 0) {\n        overrides = {};\n    }\n    if (!deviceCached) {\n        deviceCached = calcDevice(overrides);\n    }\n    return deviceCached;\n}\nvar browser;\nfunction calcBrowser() {\n    var window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    var device = getDevice();\n    var needPerspectiveFix = false;\n    function isSafari() {\n        var ua = window1.navigator.userAgent.toLowerCase();\n        return ua.indexOf(\"safari\") >= 0 && ua.indexOf(\"chrome\") < 0 && ua.indexOf(\"android\") < 0;\n    }\n    if (isSafari()) {\n        var ua = String(window1.navigator.userAgent);\n        if (ua.includes(\"Version/\")) {\n            var _ua_split__split__split_map = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_2__._)(ua.split(\"Version/\")[1].split(\" \")[0].split(\".\").map(function(num) {\n                return Number(num);\n            }), 2), major = _ua_split__split__split_map[0], minor = _ua_split__split__split_map[1];\n            needPerspectiveFix = major < 16 || major === 16 && minor < 2;\n        }\n    }\n    var isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window1.navigator.userAgent);\n    var isSafariBrowser = isSafari();\n    var need3dFix = isSafariBrowser || isWebView && device.ios;\n    return {\n        isSafari: needPerspectiveFix || isSafariBrowser,\n        needPerspectiveFix: needPerspectiveFix,\n        need3dFix: need3dFix,\n        isWebView: isWebView\n    };\n}\nfunction getBrowser() {\n    if (!browser) {\n        browser = calcBrowser();\n    }\n    return browser;\n}\nfunction Resize(_ref) {\n    var swiper = _ref.swiper, on = _ref.on, emit = _ref.emit;\n    var window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    var observer = null;\n    var animationFrame = null;\n    var resizeHandler = function() {\n        if (!swiper || swiper.destroyed || !swiper.initialized) return;\n        emit(\"beforeResize\");\n        emit(\"resize\");\n    };\n    var createObserver = function() {\n        if (!swiper || swiper.destroyed || !swiper.initialized) return;\n        observer = new ResizeObserver(function(entries) {\n            animationFrame = window1.requestAnimationFrame(function() {\n                var width = swiper.width, height = swiper.height;\n                var newWidth = width;\n                var newHeight = height;\n                entries.forEach(function(_ref2) {\n                    var contentBoxSize = _ref2.contentBoxSize, contentRect = _ref2.contentRect, target = _ref2.target;\n                    if (target && target !== swiper.el) return;\n                    newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n                    newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n                });\n                if (newWidth !== width || newHeight !== height) {\n                    resizeHandler();\n                }\n            });\n        });\n        observer.observe(swiper.el);\n    };\n    var removeObserver = function() {\n        if (animationFrame) {\n            window1.cancelAnimationFrame(animationFrame);\n        }\n        if (observer && observer.unobserve && swiper.el) {\n            observer.unobserve(swiper.el);\n            observer = null;\n        }\n    };\n    var orientationChangeHandler = function() {\n        if (!swiper || swiper.destroyed || !swiper.initialized) return;\n        emit(\"orientationchange\");\n    };\n    on(\"init\", function() {\n        if (swiper.params.resizeObserver && typeof window1.ResizeObserver !== \"undefined\") {\n            createObserver();\n            return;\n        }\n        window1.addEventListener(\"resize\", resizeHandler);\n        window1.addEventListener(\"orientationchange\", orientationChangeHandler);\n    });\n    on(\"destroy\", function() {\n        removeObserver();\n        window1.removeEventListener(\"resize\", resizeHandler);\n        window1.removeEventListener(\"orientationchange\", orientationChangeHandler);\n    });\n}\n_c = Resize;\nfunction Observer(_ref) {\n    var swiper = _ref.swiper, extendParams = _ref.extendParams, on = _ref.on, emit = _ref.emit;\n    var observers = [];\n    var window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    var attach = function attach(target, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var ObserverFunc = window1.MutationObserver || window1.WebkitMutationObserver;\n        var observer = new ObserverFunc(function(mutations) {\n            // The observerUpdate event should only be triggered\n            // once despite the number of mutations.  Additional\n            // triggers are redundant and are very costly\n            if (swiper.__preventObserver__) return;\n            if (mutations.length === 1) {\n                emit(\"observerUpdate\", mutations[0]);\n                return;\n            }\n            var observerUpdate = function observerUpdate() {\n                emit(\"observerUpdate\", mutations[0]);\n            };\n            if (window1.requestAnimationFrame) {\n                window1.requestAnimationFrame(observerUpdate);\n            } else {\n                window1.setTimeout(observerUpdate, 0);\n            }\n        });\n        observer.observe(target, {\n            attributes: typeof options.attributes === \"undefined\" ? true : options.attributes,\n            childList: typeof options.childList === \"undefined\" ? true : options.childList,\n            characterData: typeof options.characterData === \"undefined\" ? true : options.characterData\n        });\n        observers.push(observer);\n    };\n    var init = function() {\n        if (!swiper.params.observer) return;\n        if (swiper.params.observeParents) {\n            var containerParents = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.a)(swiper.hostEl);\n            for(var i = 0; i < containerParents.length; i += 1){\n                attach(containerParents[i]);\n            }\n        }\n        // Observe container\n        attach(swiper.hostEl, {\n            childList: swiper.params.observeSlideChildren\n        });\n        // Observe wrapper\n        attach(swiper.wrapperEl, {\n            attributes: false\n        });\n    };\n    var destroy = function() {\n        observers.forEach(function(observer) {\n            observer.disconnect();\n        });\n        observers.splice(0, observers.length);\n    };\n    extendParams({\n        observer: false,\n        observeParents: false,\n        observeSlideChildren: false\n    });\n    on(\"init\", init);\n    on(\"destroy\", destroy);\n}\n_c1 = Observer;\n/* eslint-disable no-underscore-dangle */ var eventsEmitter = {\n    on: function(events, handler, priority) {\n        var self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (typeof handler !== \"function\") return self;\n        var method = priority ? \"unshift\" : \"push\";\n        events.split(\" \").forEach(function(event) {\n            if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n            self.eventsListeners[event][method](handler);\n        });\n        return self;\n    },\n    once: function(events, handler, priority) {\n        var self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (typeof handler !== \"function\") return self;\n        function onceHandler() {\n            self.off(events, onceHandler);\n            if (onceHandler.__emitterProxy) {\n                delete onceHandler.__emitterProxy;\n            }\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            handler.apply(self, args);\n        }\n        onceHandler.__emitterProxy = handler;\n        return self.on(events, onceHandler, priority);\n    },\n    onAny: function(handler, priority) {\n        var self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (typeof handler !== \"function\") return self;\n        var method = priority ? \"unshift\" : \"push\";\n        if (self.eventsAnyListeners.indexOf(handler) < 0) {\n            self.eventsAnyListeners[method](handler);\n        }\n        return self;\n    },\n    offAny: function(handler) {\n        var self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (!self.eventsAnyListeners) return self;\n        var index = self.eventsAnyListeners.indexOf(handler);\n        if (index >= 0) {\n            self.eventsAnyListeners.splice(index, 1);\n        }\n        return self;\n    },\n    off: function(events, handler) {\n        var self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (!self.eventsListeners) return self;\n        events.split(\" \").forEach(function(event) {\n            if (typeof handler === \"undefined\") {\n                self.eventsListeners[event] = [];\n            } else if (self.eventsListeners[event]) {\n                self.eventsListeners[event].forEach(function(eventHandler, index) {\n                    if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {\n                        self.eventsListeners[event].splice(index, 1);\n                    }\n                });\n            }\n        });\n        return self;\n    },\n    emit: function() {\n        var self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (!self.eventsListeners) return self;\n        var events;\n        var data;\n        var context;\n        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            args[_key2] = arguments[_key2];\n        }\n        if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n            events = args[0];\n            data = args.slice(1, args.length);\n            context = self;\n        } else {\n            events = args[0].events;\n            data = args[0].data;\n            context = args[0].context || self;\n        }\n        data.unshift(context);\n        var eventsArray = Array.isArray(events) ? events : events.split(\" \");\n        eventsArray.forEach(function(event) {\n            if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n                self.eventsAnyListeners.forEach(function(eventHandler) {\n                    eventHandler.apply(context, [\n                        event\n                    ].concat((0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_3__._)(data)));\n                });\n            }\n            if (self.eventsListeners && self.eventsListeners[event]) {\n                self.eventsListeners[event].forEach(function(eventHandler) {\n                    eventHandler.apply(context, data);\n                });\n            }\n        });\n        return self;\n    }\n};\nfunction updateSize() {\n    var swiper = this;\n    var width;\n    var height;\n    var el = swiper.el;\n    if (typeof swiper.params.width !== \"undefined\" && swiper.params.width !== null) {\n        width = swiper.params.width;\n    } else {\n        width = el.clientWidth;\n    }\n    if (typeof swiper.params.height !== \"undefined\" && swiper.params.height !== null) {\n        height = swiper.params.height;\n    } else {\n        height = el.clientHeight;\n    }\n    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {\n        return;\n    }\n    // Subtract paddings\n    width = width - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(el, \"padding-left\") || 0, 10) - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(el, \"padding-right\") || 0, 10);\n    height = height - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(el, \"padding-top\") || 0, 10) - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(el, \"padding-bottom\") || 0, 10);\n    if (Number.isNaN(width)) width = 0;\n    if (Number.isNaN(height)) height = 0;\n    Object.assign(swiper, {\n        width: width,\n        height: height,\n        size: swiper.isHorizontal() ? width : height\n    });\n}\nfunction updateSlides() {\n    var swiper = this;\n    function getDirectionPropertyValue(node, label) {\n        return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);\n    }\n    var params = swiper.params;\n    var wrapperEl = swiper.wrapperEl, slidesEl = swiper.slidesEl, swiperSize = swiper.size, rtl = swiper.rtlTranslate, wrongRTL = swiper.wrongRTL;\n    var isVirtual = swiper.virtual && params.virtual.enabled;\n    var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n    var slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, \".\".concat(swiper.params.slideClass, \", swiper-slide\"));\n    var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n    var snapGrid = [];\n    var slidesGrid = [];\n    var slidesSizesGrid = [];\n    var offsetBefore = params.slidesOffsetBefore;\n    if (typeof offsetBefore === \"function\") {\n        offsetBefore = params.slidesOffsetBefore.call(swiper);\n    }\n    var offsetAfter = params.slidesOffsetAfter;\n    if (typeof offsetAfter === \"function\") {\n        offsetAfter = params.slidesOffsetAfter.call(swiper);\n    }\n    var previousSnapGridLength = swiper.snapGrid.length;\n    var previousSlidesGridLength = swiper.slidesGrid.length;\n    var spaceBetween = params.spaceBetween;\n    var slidePosition = -offsetBefore;\n    var prevSlideSize = 0;\n    var index = 0;\n    if (typeof swiperSize === \"undefined\") {\n        return;\n    }\n    if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) {\n        spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiperSize;\n    } else if (typeof spaceBetween === \"string\") {\n        spaceBetween = parseFloat(spaceBetween);\n    }\n    swiper.virtualSize = -spaceBetween;\n    // reset margins\n    slides.forEach(function(slideEl) {\n        if (rtl) {\n            slideEl.style.marginLeft = \"\";\n        } else {\n            slideEl.style.marginRight = \"\";\n        }\n        slideEl.style.marginBottom = \"\";\n        slideEl.style.marginTop = \"\";\n    });\n    // reset cssMode offsets\n    if (params.centeredSlides && params.cssMode) {\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, \"--swiper-centered-offset-before\", \"\");\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, \"--swiper-centered-offset-after\", \"\");\n    }\n    var gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n    if (gridEnabled) {\n        swiper.grid.initSlides(slides);\n    } else if (swiper.grid) {\n        swiper.grid.unsetSlides();\n    }\n    // Calc slides\n    var slideSize;\n    var shouldResetSlideSize = params.slidesPerView === \"auto\" && params.breakpoints && Object.keys(params.breakpoints).filter(function(key) {\n        return typeof params.breakpoints[key].slidesPerView !== \"undefined\";\n    }).length > 0;\n    for(var i = 0; i < slidesLength; i += 1){\n        slideSize = 0;\n        var slide = void 0;\n        if (slides[i]) slide = slides[i];\n        if (gridEnabled) {\n            swiper.grid.updateSlide(i, slide, slides);\n        }\n        if (slides[i] && (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(slide, \"display\") === \"none\") continue; // eslint-disable-line\n        if (params.slidesPerView === \"auto\") {\n            if (shouldResetSlideSize) {\n                slides[i].style[swiper.getDirectionLabel(\"width\")] = \"\";\n            }\n            var slideStyles = getComputedStyle(slide);\n            var currentTransform = slide.style.transform;\n            var currentWebKitTransform = slide.style.webkitTransform;\n            if (currentTransform) {\n                slide.style.transform = \"none\";\n            }\n            if (currentWebKitTransform) {\n                slide.style.webkitTransform = \"none\";\n            }\n            if (params.roundLengths) {\n                slideSize = swiper.isHorizontal() ? (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.f)(slide, \"width\", true) : (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.f)(slide, \"height\", true);\n            } else {\n                // eslint-disable-next-line\n                var width = getDirectionPropertyValue(slideStyles, \"width\");\n                var paddingLeft = getDirectionPropertyValue(slideStyles, \"padding-left\");\n                var paddingRight = getDirectionPropertyValue(slideStyles, \"padding-right\");\n                var marginLeft = getDirectionPropertyValue(slideStyles, \"margin-left\");\n                var marginRight = getDirectionPropertyValue(slideStyles, \"margin-right\");\n                var boxSizing = slideStyles.getPropertyValue(\"box-sizing\");\n                if (boxSizing && boxSizing === \"border-box\") {\n                    slideSize = width + marginLeft + marginRight;\n                } else {\n                    var clientWidth = slide.clientWidth, offsetWidth = slide.offsetWidth;\n                    slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n                }\n            }\n            if (currentTransform) {\n                slide.style.transform = currentTransform;\n            }\n            if (currentWebKitTransform) {\n                slide.style.webkitTransform = currentWebKitTransform;\n            }\n            if (params.roundLengths) slideSize = Math.floor(slideSize);\n        } else {\n            slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n            if (params.roundLengths) slideSize = Math.floor(slideSize);\n            if (slides[i]) {\n                slides[i].style[swiper.getDirectionLabel(\"width\")] = \"\".concat(slideSize, \"px\");\n            }\n        }\n        if (slides[i]) {\n            slides[i].swiperSlideSize = slideSize;\n        }\n        slidesSizesGrid.push(slideSize);\n        if (params.centeredSlides) {\n            slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n            if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n            if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n            if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n            if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n            if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n            slidesGrid.push(slidePosition);\n        } else {\n            if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n            if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n            slidesGrid.push(slidePosition);\n            slidePosition = slidePosition + slideSize + spaceBetween;\n        }\n        swiper.virtualSize += slideSize + spaceBetween;\n        prevSlideSize = slideSize;\n        index += 1;\n    }\n    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n    if (rtl && wrongRTL && (params.effect === \"slide\" || params.effect === \"coverflow\")) {\n        wrapperEl.style.width = \"\".concat(swiper.virtualSize + spaceBetween, \"px\");\n    }\n    if (params.setWrapperSize) {\n        wrapperEl.style[swiper.getDirectionLabel(\"width\")] = \"\".concat(swiper.virtualSize + spaceBetween, \"px\");\n    }\n    if (gridEnabled) {\n        swiper.grid.updateWrapperSize(slideSize, snapGrid);\n    }\n    // Remove last grid elements depending on width\n    if (!params.centeredSlides) {\n        var newSlidesGrid = [];\n        for(var i1 = 0; i1 < snapGrid.length; i1 += 1){\n            var slidesGridItem = snapGrid[i1];\n            if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n            if (snapGrid[i1] <= swiper.virtualSize - swiperSize) {\n                newSlidesGrid.push(slidesGridItem);\n            }\n        }\n        snapGrid = newSlidesGrid;\n        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n            snapGrid.push(swiper.virtualSize - swiperSize);\n        }\n    }\n    if (isVirtual && params.loop) {\n        var size = slidesSizesGrid[0] + spaceBetween;\n        if (params.slidesPerGroup > 1) {\n            var groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n            var groupSize = size * params.slidesPerGroup;\n            for(var i2 = 0; i2 < groups; i2 += 1){\n                snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n            }\n        }\n        for(var i3 = 0; i3 < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i3 += 1){\n            if (params.slidesPerGroup === 1) {\n                snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n            }\n            slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n            swiper.virtualSize += size;\n        }\n    }\n    if (snapGrid.length === 0) snapGrid = [\n        0\n    ];\n    if (spaceBetween !== 0) {\n        var key = swiper.isHorizontal() && rtl ? \"marginLeft\" : swiper.getDirectionLabel(\"marginRight\");\n        slides.filter(function(_, slideIndex) {\n            if (!params.cssMode || params.loop) return true;\n            if (slideIndex === slides.length - 1) {\n                return false;\n            }\n            return true;\n        }).forEach(function(slideEl) {\n            slideEl.style[key] = \"\".concat(spaceBetween, \"px\");\n        });\n    }\n    if (params.centeredSlides && params.centeredSlidesBounds) {\n        var allSlidesSize = 0;\n        slidesSizesGrid.forEach(function(slideSizeValue) {\n            allSlidesSize += slideSizeValue + (spaceBetween || 0);\n        });\n        allSlidesSize -= spaceBetween;\n        var maxSnap = allSlidesSize - swiperSize;\n        snapGrid = snapGrid.map(function(snap) {\n            if (snap <= 0) return -offsetBefore;\n            if (snap > maxSnap) return maxSnap + offsetAfter;\n            return snap;\n        });\n    }\n    if (params.centerInsufficientSlides) {\n        var allSlidesSize1 = 0;\n        slidesSizesGrid.forEach(function(slideSizeValue) {\n            allSlidesSize1 += slideSizeValue + (spaceBetween || 0);\n        });\n        allSlidesSize1 -= spaceBetween;\n        var offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);\n        if (allSlidesSize1 + offsetSize < swiperSize) {\n            var allSlidesOffset = (swiperSize - allSlidesSize1 - offsetSize) / 2;\n            snapGrid.forEach(function(snap, snapIndex) {\n                snapGrid[snapIndex] = snap - allSlidesOffset;\n            });\n            slidesGrid.forEach(function(snap, snapIndex) {\n                slidesGrid[snapIndex] = snap + allSlidesOffset;\n            });\n        }\n    }\n    Object.assign(swiper, {\n        slides: slides,\n        snapGrid: snapGrid,\n        slidesGrid: slidesGrid,\n        slidesSizesGrid: slidesSizesGrid\n    });\n    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, \"--swiper-centered-offset-before\", \"\".concat(-snapGrid[0], \"px\"));\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, \"--swiper-centered-offset-after\", \"\".concat(swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2, \"px\"));\n        var addToSnapGrid = -swiper.snapGrid[0];\n        var addToSlidesGrid = -swiper.slidesGrid[0];\n        swiper.snapGrid = swiper.snapGrid.map(function(v) {\n            return v + addToSnapGrid;\n        });\n        swiper.slidesGrid = swiper.slidesGrid.map(function(v) {\n            return v + addToSlidesGrid;\n        });\n    }\n    if (slidesLength !== previousSlidesLength) {\n        swiper.emit(\"slidesLengthChange\");\n    }\n    if (snapGrid.length !== previousSnapGridLength) {\n        if (swiper.params.watchOverflow) swiper.checkOverflow();\n        swiper.emit(\"snapGridLengthChange\");\n    }\n    if (slidesGrid.length !== previousSlidesGridLength) {\n        swiper.emit(\"slidesGridLengthChange\");\n    }\n    if (params.watchSlidesProgress) {\n        swiper.updateSlidesOffset();\n    }\n    swiper.emit(\"slidesUpdated\");\n    if (!isVirtual && !params.cssMode && (params.effect === \"slide\" || params.effect === \"fade\")) {\n        var backFaceHiddenClass = \"\".concat(params.containerModifierClass, \"backface-hidden\");\n        var hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n        if (slidesLength <= params.maxBackfaceHiddenSlides) {\n            if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n        } else if (hasClassBackfaceClassAdded) {\n            swiper.el.classList.remove(backFaceHiddenClass);\n        }\n    }\n}\nfunction updateAutoHeight(speed) {\n    var swiper = this;\n    var activeSlides = [];\n    var isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n    var newHeight = 0;\n    var i;\n    if (typeof speed === \"number\") {\n        swiper.setTransition(speed);\n    } else if (speed === true) {\n        swiper.setTransition(swiper.params.speed);\n    }\n    var getSlideByIndex = function(index) {\n        if (isVirtual) {\n            return swiper.slides[swiper.getSlideIndexByData(index)];\n        }\n        return swiper.slides[index];\n    };\n    // Find slides currently in view\n    if (swiper.params.slidesPerView !== \"auto\" && swiper.params.slidesPerView > 1) {\n        if (swiper.params.centeredSlides) {\n            (swiper.visibleSlides || []).forEach(function(slide) {\n                activeSlides.push(slide);\n            });\n        } else {\n            for(i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1){\n                var index = swiper.activeIndex + i;\n                if (index > swiper.slides.length && !isVirtual) break;\n                activeSlides.push(getSlideByIndex(index));\n            }\n        }\n    } else {\n        activeSlides.push(getSlideByIndex(swiper.activeIndex));\n    }\n    // Find new height from highest slide in view\n    for(i = 0; i < activeSlides.length; i += 1){\n        if (typeof activeSlides[i] !== \"undefined\") {\n            var height = activeSlides[i].offsetHeight;\n            newHeight = height > newHeight ? height : newHeight;\n        }\n    }\n    // Update Height\n    if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = \"\".concat(newHeight, \"px\");\n}\nfunction updateSlidesOffset() {\n    var swiper = this;\n    var slides = swiper.slides;\n    // eslint-disable-next-line\n    var minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;\n    for(var i = 0; i < slides.length; i += 1){\n        slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();\n    }\n}\nvar toggleSlideClasses$1 = function(slideEl, condition, className) {\n    if (condition && !slideEl.classList.contains(className)) {\n        slideEl.classList.add(className);\n    } else if (!condition && slideEl.classList.contains(className)) {\n        slideEl.classList.remove(className);\n    }\n};\nfunction updateSlidesProgress(translate) {\n    if (translate === void 0) {\n        translate = this && this.translate || 0;\n    }\n    var swiper = this;\n    var params = swiper.params;\n    var slides = swiper.slides, rtl = swiper.rtlTranslate, snapGrid = swiper.snapGrid;\n    if (slides.length === 0) return;\n    if (typeof slides[0].swiperSlideOffset === \"undefined\") swiper.updateSlidesOffset();\n    var offsetCenter = -translate;\n    if (rtl) offsetCenter = translate;\n    swiper.visibleSlidesIndexes = [];\n    swiper.visibleSlides = [];\n    var spaceBetween = params.spaceBetween;\n    if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) {\n        spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiper.size;\n    } else if (typeof spaceBetween === \"string\") {\n        spaceBetween = parseFloat(spaceBetween);\n    }\n    for(var i = 0; i < slides.length; i += 1){\n        var slide = slides[i];\n        var slideOffset = slide.swiperSlideOffset;\n        if (params.cssMode && params.centeredSlides) {\n            slideOffset -= slides[0].swiperSlideOffset;\n        }\n        var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n        var originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n        var slideBefore = -(offsetCenter - slideOffset);\n        var slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n        var isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];\n        var isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n        if (isVisible) {\n            swiper.visibleSlides.push(slide);\n            swiper.visibleSlidesIndexes.push(i);\n        }\n        toggleSlideClasses$1(slide, isVisible, params.slideVisibleClass);\n        toggleSlideClasses$1(slide, isFullyVisible, params.slideFullyVisibleClass);\n        slide.progress = rtl ? -slideProgress : slideProgress;\n        slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n    }\n}\nfunction updateProgress(translate) {\n    var swiper = this;\n    if (typeof translate === \"undefined\") {\n        var multiplier = swiper.rtlTranslate ? -1 : 1;\n        // eslint-disable-next-line\n        translate = swiper && swiper.translate && swiper.translate * multiplier || 0;\n    }\n    var params = swiper.params;\n    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n    var progress = swiper.progress, isBeginning = swiper.isBeginning, isEnd = swiper.isEnd, progressLoop = swiper.progressLoop;\n    var wasBeginning = isBeginning;\n    var wasEnd = isEnd;\n    if (translatesDiff === 0) {\n        progress = 0;\n        isBeginning = true;\n        isEnd = true;\n    } else {\n        progress = (translate - swiper.minTranslate()) / translatesDiff;\n        var isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;\n        var isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;\n        isBeginning = isBeginningRounded || progress <= 0;\n        isEnd = isEndRounded || progress >= 1;\n        if (isBeginningRounded) progress = 0;\n        if (isEndRounded) progress = 1;\n    }\n    if (params.loop) {\n        var firstSlideIndex = swiper.getSlideIndexByData(0);\n        var lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n        var firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n        var lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n        var translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n        var translateAbs = Math.abs(translate);\n        if (translateAbs >= firstSlideTranslate) {\n            progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n        } else {\n            progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n        }\n        if (progressLoop > 1) progressLoop -= 1;\n    }\n    Object.assign(swiper, {\n        progress: progress,\n        progressLoop: progressLoop,\n        isBeginning: isBeginning,\n        isEnd: isEnd\n    });\n    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);\n    if (isBeginning && !wasBeginning) {\n        swiper.emit(\"reachBeginning toEdge\");\n    }\n    if (isEnd && !wasEnd) {\n        swiper.emit(\"reachEnd toEdge\");\n    }\n    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {\n        swiper.emit(\"fromEdge\");\n    }\n    swiper.emit(\"progress\", progress);\n}\nvar toggleSlideClasses = function(slideEl, condition, className) {\n    if (condition && !slideEl.classList.contains(className)) {\n        slideEl.classList.add(className);\n    } else if (!condition && slideEl.classList.contains(className)) {\n        slideEl.classList.remove(className);\n    }\n};\nfunction updateSlidesClasses() {\n    var swiper = this;\n    var slides = swiper.slides, params = swiper.params, slidesEl = swiper.slidesEl, activeIndex = swiper.activeIndex;\n    var isVirtual = swiper.virtual && params.virtual.enabled;\n    var gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n    var getFilteredSlide = function(selector) {\n        return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, \".\".concat(params.slideClass).concat(selector, \", swiper-slide\").concat(selector))[0];\n    };\n    var activeSlide;\n    var prevSlide;\n    var nextSlide;\n    if (isVirtual) {\n        if (params.loop) {\n            var slideIndex = activeIndex - swiper.virtual.slidesBefore;\n            if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;\n            if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;\n            activeSlide = getFilteredSlide('[data-swiper-slide-index=\"'.concat(slideIndex, '\"]'));\n        } else {\n            activeSlide = getFilteredSlide('[data-swiper-slide-index=\"'.concat(activeIndex, '\"]'));\n        }\n    } else {\n        if (gridEnabled) {\n            activeSlide = slides.filter(function(slideEl) {\n                return slideEl.column === activeIndex;\n            })[0];\n            nextSlide = slides.filter(function(slideEl) {\n                return slideEl.column === activeIndex + 1;\n            })[0];\n            prevSlide = slides.filter(function(slideEl) {\n                return slideEl.column === activeIndex - 1;\n            })[0];\n        } else {\n            activeSlide = slides[activeIndex];\n        }\n    }\n    if (activeSlide) {\n        if (!gridEnabled) {\n            // Next Slide\n            nextSlide = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)(activeSlide, \".\".concat(params.slideClass, \", swiper-slide\"))[0];\n            if (params.loop && !nextSlide) {\n                nextSlide = slides[0];\n            }\n            // Prev Slide\n            prevSlide = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.q)(activeSlide, \".\".concat(params.slideClass, \", swiper-slide\"))[0];\n            if (params.loop && !prevSlide === 0) {\n                prevSlide = slides[slides.length - 1];\n            }\n        }\n    }\n    slides.forEach(function(slideEl) {\n        toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);\n        toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);\n        toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);\n    });\n    swiper.emitSlidesClasses();\n}\nvar processLazyPreloader = function(swiper, imageEl) {\n    if (!swiper || swiper.destroyed || !swiper.params) return;\n    var slideSelector = function() {\n        return swiper.isElement ? \"swiper-slide\" : \".\".concat(swiper.params.slideClass);\n    };\n    var slideEl = imageEl.closest(slideSelector());\n    if (slideEl) {\n        var lazyEl = slideEl.querySelector(\".\".concat(swiper.params.lazyPreloaderClass));\n        if (!lazyEl && swiper.isElement) {\n            if (slideEl.shadowRoot) {\n                lazyEl = slideEl.shadowRoot.querySelector(\".\".concat(swiper.params.lazyPreloaderClass));\n            } else {\n                // init later\n                requestAnimationFrame(function() {\n                    if (slideEl.shadowRoot) {\n                        lazyEl = slideEl.shadowRoot.querySelector(\".\".concat(swiper.params.lazyPreloaderClass));\n                        if (lazyEl) lazyEl.remove();\n                    }\n                });\n            }\n        }\n        if (lazyEl) lazyEl.remove();\n    }\n};\nvar unlazy = function(swiper, index) {\n    if (!swiper.slides[index]) return;\n    var imageEl = swiper.slides[index].querySelector('[loading=\"lazy\"]');\n    if (imageEl) imageEl.removeAttribute(\"loading\");\n};\nvar preload = function(swiper) {\n    if (!swiper || swiper.destroyed || !swiper.params) return;\n    var amount = swiper.params.lazyPreloadPrevNext;\n    var len = swiper.slides.length;\n    if (!len || !amount || amount < 0) return;\n    amount = Math.min(amount, len);\n    var slidesPerView = swiper.params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);\n    var activeIndex = swiper.activeIndex;\n    if (swiper.params.grid && swiper.params.grid.rows > 1) {\n        var _preloadColumns;\n        var activeColumn = activeIndex;\n        var preloadColumns = [\n            activeColumn - amount\n        ];\n        (_preloadColumns = preloadColumns).push.apply(_preloadColumns, (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_3__._)(Array.from({\n            length: amount\n        }).map(function(_, i) {\n            return activeColumn + slidesPerView + i;\n        })));\n        swiper.slides.forEach(function(slideEl, i) {\n            if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);\n        });\n        return;\n    }\n    var slideIndexLastInView = activeIndex + slidesPerView - 1;\n    if (swiper.params.rewind || swiper.params.loop) {\n        for(var i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1){\n            var realIndex = (i % len + len) % len;\n            if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);\n        }\n    } else {\n        for(var i1 = Math.max(activeIndex - amount, 0); i1 <= Math.min(slideIndexLastInView + amount, len - 1); i1 += 1){\n            if (i1 !== activeIndex && (i1 > slideIndexLastInView || i1 < activeIndex)) {\n                unlazy(swiper, i1);\n            }\n        }\n    }\n};\nfunction getActiveIndexByTranslate(swiper) {\n    var slidesGrid = swiper.slidesGrid, params = swiper.params;\n    var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n    var activeIndex;\n    for(var i = 0; i < slidesGrid.length; i += 1){\n        if (typeof slidesGrid[i + 1] !== \"undefined\") {\n            if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n                activeIndex = i;\n            } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n                activeIndex = i + 1;\n            }\n        } else if (translate >= slidesGrid[i]) {\n            activeIndex = i;\n        }\n    }\n    // Normalize slideIndex\n    if (params.normalizeSlideIndex) {\n        if (activeIndex < 0 || typeof activeIndex === \"undefined\") activeIndex = 0;\n    }\n    return activeIndex;\n}\nfunction updateActiveIndex(newActiveIndex) {\n    var swiper = this;\n    var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n    var snapGrid = swiper.snapGrid, params = swiper.params, previousIndex = swiper.activeIndex, previousRealIndex = swiper.realIndex, previousSnapIndex = swiper.snapIndex;\n    var activeIndex = newActiveIndex;\n    var snapIndex;\n    var getVirtualRealIndex = function(aIndex) {\n        var realIndex = aIndex - swiper.virtual.slidesBefore;\n        if (realIndex < 0) {\n            realIndex = swiper.virtual.slides.length + realIndex;\n        }\n        if (realIndex >= swiper.virtual.slides.length) {\n            realIndex -= swiper.virtual.slides.length;\n        }\n        return realIndex;\n    };\n    if (typeof activeIndex === \"undefined\") {\n        activeIndex = getActiveIndexByTranslate(swiper);\n    }\n    if (snapGrid.indexOf(translate) >= 0) {\n        snapIndex = snapGrid.indexOf(translate);\n    } else {\n        var skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n    }\n    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n    if (activeIndex === previousIndex && !swiper.params.loop) {\n        if (snapIndex !== previousSnapIndex) {\n            swiper.snapIndex = snapIndex;\n            swiper.emit(\"snapIndexChange\");\n        }\n        return;\n    }\n    if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n        swiper.realIndex = getVirtualRealIndex(activeIndex);\n        return;\n    }\n    var gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n    // Get real index\n    var realIndex;\n    if (swiper.virtual && params.virtual.enabled && params.loop) {\n        realIndex = getVirtualRealIndex(activeIndex);\n    } else if (gridEnabled) {\n        var firstSlideInColumn = swiper.slides.filter(function(slideEl) {\n            return slideEl.column === activeIndex;\n        })[0];\n        var activeSlideIndex = parseInt(firstSlideInColumn.getAttribute(\"data-swiper-slide-index\"), 10);\n        if (Number.isNaN(activeSlideIndex)) {\n            activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);\n        }\n        realIndex = Math.floor(activeSlideIndex / params.grid.rows);\n    } else if (swiper.slides[activeIndex]) {\n        var slideIndex = swiper.slides[activeIndex].getAttribute(\"data-swiper-slide-index\");\n        if (slideIndex) {\n            realIndex = parseInt(slideIndex, 10);\n        } else {\n            realIndex = activeIndex;\n        }\n    } else {\n        realIndex = activeIndex;\n    }\n    Object.assign(swiper, {\n        previousSnapIndex: previousSnapIndex,\n        snapIndex: snapIndex,\n        previousRealIndex: previousRealIndex,\n        realIndex: realIndex,\n        previousIndex: previousIndex,\n        activeIndex: activeIndex\n    });\n    if (swiper.initialized) {\n        preload(swiper);\n    }\n    swiper.emit(\"activeIndexChange\");\n    swiper.emit(\"snapIndexChange\");\n    if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n        if (previousRealIndex !== realIndex) {\n            swiper.emit(\"realIndexChange\");\n        }\n        swiper.emit(\"slideChange\");\n    }\n}\nfunction updateClickedSlide(el, path) {\n    var swiper = this;\n    var params = swiper.params;\n    var slide = el.closest(\".\".concat(params.slideClass, \", swiper-slide\"));\n    if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) {\n        (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_3__._)(path.slice(path.indexOf(el) + 1, path.length)).forEach(function(pathEl) {\n            if (!slide && pathEl.matches && pathEl.matches(\".\".concat(params.slideClass, \", swiper-slide\"))) {\n                slide = pathEl;\n            }\n        });\n    }\n    var slideFound = false;\n    var slideIndex;\n    if (slide) {\n        for(var i = 0; i < swiper.slides.length; i += 1){\n            if (swiper.slides[i] === slide) {\n                slideFound = true;\n                slideIndex = i;\n                break;\n            }\n        }\n    }\n    if (slide && slideFound) {\n        swiper.clickedSlide = slide;\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n            swiper.clickedIndex = parseInt(slide.getAttribute(\"data-swiper-slide-index\"), 10);\n        } else {\n            swiper.clickedIndex = slideIndex;\n        }\n    } else {\n        swiper.clickedSlide = undefined;\n        swiper.clickedIndex = undefined;\n        return;\n    }\n    if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\n        swiper.slideToClickedSlide();\n    }\n}\nvar update = {\n    updateSize: updateSize,\n    updateSlides: updateSlides,\n    updateAutoHeight: updateAutoHeight,\n    updateSlidesOffset: updateSlidesOffset,\n    updateSlidesProgress: updateSlidesProgress,\n    updateProgress: updateProgress,\n    updateSlidesClasses: updateSlidesClasses,\n    updateActiveIndex: updateActiveIndex,\n    updateClickedSlide: updateClickedSlide\n};\nfunction getSwiperTranslate(axis) {\n    if (axis === void 0) {\n        axis = this.isHorizontal() ? \"x\" : \"y\";\n    }\n    var swiper = this;\n    var params = swiper.params, rtl = swiper.rtlTranslate, translate = swiper.translate, wrapperEl = swiper.wrapperEl;\n    if (params.virtualTranslate) {\n        return rtl ? -translate : translate;\n    }\n    if (params.cssMode) {\n        return translate;\n    }\n    var currentTranslate = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.j)(wrapperEl, axis);\n    currentTranslate += swiper.cssOverflowAdjustment();\n    if (rtl) currentTranslate = -currentTranslate;\n    return currentTranslate || 0;\n}\nfunction setTranslate(translate, byController) {\n    var swiper = this;\n    var rtl = swiper.rtlTranslate, params = swiper.params, wrapperEl = swiper.wrapperEl, progress = swiper.progress;\n    var x = 0;\n    var y = 0;\n    var z = 0;\n    if (swiper.isHorizontal()) {\n        x = rtl ? -translate : translate;\n    } else {\n        y = translate;\n    }\n    if (params.roundLengths) {\n        x = Math.floor(x);\n        y = Math.floor(y);\n    }\n    swiper.previousTranslate = swiper.translate;\n    swiper.translate = swiper.isHorizontal() ? x : y;\n    if (params.cssMode) {\n        wrapperEl[swiper.isHorizontal() ? \"scrollLeft\" : \"scrollTop\"] = swiper.isHorizontal() ? -x : -y;\n    } else if (!params.virtualTranslate) {\n        if (swiper.isHorizontal()) {\n            x -= swiper.cssOverflowAdjustment();\n        } else {\n            y -= swiper.cssOverflowAdjustment();\n        }\n        wrapperEl.style.transform = \"translate3d(\".concat(x, \"px, \").concat(y, \"px, \").concat(z, \"px)\");\n    }\n    // Check if we need to update progress\n    var newProgress;\n    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n    if (translatesDiff === 0) {\n        newProgress = 0;\n    } else {\n        newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n    }\n    if (newProgress !== progress) {\n        swiper.updateProgress(translate);\n    }\n    swiper.emit(\"setTranslate\", swiper.translate, byController);\n}\nfunction minTranslate() {\n    return -this.snapGrid[0];\n}\nfunction maxTranslate() {\n    return -this.snapGrid[this.snapGrid.length - 1];\n}\nfunction translateTo(translate, speed, runCallbacks, translateBounds, internal) {\n    if (translate === void 0) {\n        translate = 0;\n    }\n    if (speed === void 0) {\n        speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    if (translateBounds === void 0) {\n        translateBounds = true;\n    }\n    var swiper = this;\n    var params = swiper.params, wrapperEl = swiper.wrapperEl;\n    if (swiper.animating && params.preventInteractionOnTransition) {\n        return false;\n    }\n    var _$minTranslate = swiper.minTranslate();\n    var _$maxTranslate = swiper.maxTranslate();\n    var newTranslate;\n    if (translateBounds && translate > _$minTranslate) newTranslate = _$minTranslate;\n    else if (translateBounds && translate < _$maxTranslate) newTranslate = _$maxTranslate;\n    else newTranslate = translate;\n    // Update progress\n    swiper.updateProgress(newTranslate);\n    if (params.cssMode) {\n        var isH = swiper.isHorizontal();\n        if (speed === 0) {\n            wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = -newTranslate;\n        } else {\n            if (!swiper.support.smoothScroll) {\n                (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.r)({\n                    swiper: swiper,\n                    targetPosition: -newTranslate,\n                    side: isH ? \"left\" : \"top\"\n                });\n                return true;\n            }\n            var _obj;\n            wrapperEl.scrollTo((_obj = {}, (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_4__._)(_obj, isH ? \"left\" : \"top\", -newTranslate), (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_4__._)(_obj, \"behavior\", \"smooth\"), _obj));\n        }\n        return true;\n    }\n    if (speed === 0) {\n        swiper.setTransition(0);\n        swiper.setTranslate(newTranslate);\n        if (runCallbacks) {\n            swiper.emit(\"beforeTransitionStart\", speed, internal);\n            swiper.emit(\"transitionEnd\");\n        }\n    } else {\n        swiper.setTransition(speed);\n        swiper.setTranslate(newTranslate);\n        if (runCallbacks) {\n            swiper.emit(\"beforeTransitionStart\", speed, internal);\n            swiper.emit(\"transitionStart\");\n        }\n        if (!swiper.animating) {\n            swiper.animating = true;\n            if (!swiper.onTranslateToWrapperTransitionEnd) {\n                swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n                    if (!swiper || swiper.destroyed) return;\n                    if (e.target !== this) return;\n                    swiper.wrapperEl.removeEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n                    swiper.onTranslateToWrapperTransitionEnd = null;\n                    delete swiper.onTranslateToWrapperTransitionEnd;\n                    swiper.animating = false;\n                    if (runCallbacks) {\n                        swiper.emit(\"transitionEnd\");\n                    }\n                };\n            }\n            swiper.wrapperEl.addEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n        }\n    }\n    return true;\n}\nvar translate = {\n    getTranslate: getSwiperTranslate,\n    setTranslate: setTranslate,\n    minTranslate: minTranslate,\n    maxTranslate: maxTranslate,\n    translateTo: translateTo\n};\nfunction setTransition(duration, byController) {\n    var swiper = this;\n    if (!swiper.params.cssMode) {\n        swiper.wrapperEl.style.transitionDuration = \"\".concat(duration, \"ms\");\n        swiper.wrapperEl.style.transitionDelay = duration === 0 ? \"0ms\" : \"\";\n    }\n    swiper.emit(\"setTransition\", duration, byController);\n}\nfunction transitionEmit(_ref) {\n    var swiper = _ref.swiper, runCallbacks = _ref.runCallbacks, direction = _ref.direction, step = _ref.step;\n    var activeIndex = swiper.activeIndex, previousIndex = swiper.previousIndex;\n    var dir = direction;\n    if (!dir) {\n        if (activeIndex > previousIndex) dir = \"next\";\n        else if (activeIndex < previousIndex) dir = \"prev\";\n        else dir = \"reset\";\n    }\n    swiper.emit(\"transition\".concat(step));\n    if (runCallbacks && activeIndex !== previousIndex) {\n        if (dir === \"reset\") {\n            swiper.emit(\"slideResetTransition\".concat(step));\n            return;\n        }\n        swiper.emit(\"slideChangeTransition\".concat(step));\n        if (dir === \"next\") {\n            swiper.emit(\"slideNextTransition\".concat(step));\n        } else {\n            swiper.emit(\"slidePrevTransition\".concat(step));\n        }\n    }\n}\nfunction transitionStart(runCallbacks, direction) {\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    var swiper = this;\n    var params = swiper.params;\n    if (params.cssMode) return;\n    if (params.autoHeight) {\n        swiper.updateAutoHeight();\n    }\n    transitionEmit({\n        swiper: swiper,\n        runCallbacks: runCallbacks,\n        direction: direction,\n        step: \"Start\"\n    });\n}\nfunction transitionEnd(runCallbacks, direction) {\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    var swiper = this;\n    var params = swiper.params;\n    swiper.animating = false;\n    if (params.cssMode) return;\n    swiper.setTransition(0);\n    transitionEmit({\n        swiper: swiper,\n        runCallbacks: runCallbacks,\n        direction: direction,\n        step: \"End\"\n    });\n}\nvar transition = {\n    setTransition: setTransition,\n    transitionStart: transitionStart,\n    transitionEnd: transitionEnd\n};\nfunction slideTo(index, speed, runCallbacks, internal, initial) {\n    if (index === void 0) {\n        index = 0;\n    }\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    if (typeof index === \"string\") {\n        index = parseInt(index, 10);\n    }\n    var swiper = this;\n    var slideIndex = index;\n    if (slideIndex < 0) slideIndex = 0;\n    var params = swiper.params, snapGrid = swiper.snapGrid, slidesGrid = swiper.slidesGrid, previousIndex = swiper.previousIndex, activeIndex = swiper.activeIndex, rtl = swiper.rtlTranslate, wrapperEl = swiper.wrapperEl, enabled = swiper.enabled;\n    if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {\n        return false;\n    }\n    if (typeof speed === \"undefined\") {\n        speed = swiper.params.speed;\n    }\n    var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n    var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n    var translate = -snapGrid[snapIndex];\n    // Normalize slideIndex\n    if (params.normalizeSlideIndex) {\n        for(var i = 0; i < slidesGrid.length; i += 1){\n            var normalizedTranslate = -Math.floor(translate * 100);\n            var normalizedGrid = Math.floor(slidesGrid[i] * 100);\n            var normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n            if (typeof slidesGrid[i + 1] !== \"undefined\") {\n                if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n                    slideIndex = i;\n                } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n                    slideIndex = i + 1;\n                }\n            } else if (normalizedTranslate >= normalizedGrid) {\n                slideIndex = i;\n            }\n        }\n    }\n    // Directions locks\n    if (swiper.initialized && slideIndex !== activeIndex) {\n        if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {\n            return false;\n        }\n        if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n            if ((activeIndex || 0) !== slideIndex) {\n                return false;\n            }\n        }\n    }\n    if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n        swiper.emit(\"beforeSlideChangeStart\");\n    }\n    // Update progress\n    swiper.updateProgress(translate);\n    var direction;\n    if (slideIndex > activeIndex) direction = \"next\";\n    else if (slideIndex < activeIndex) direction = \"prev\";\n    else direction = \"reset\";\n    // Update Index\n    if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n        swiper.updateActiveIndex(slideIndex);\n        // Update Height\n        if (params.autoHeight) {\n            swiper.updateAutoHeight();\n        }\n        swiper.updateSlidesClasses();\n        if (params.effect !== \"slide\") {\n            swiper.setTranslate(translate);\n        }\n        if (direction !== \"reset\") {\n            swiper.transitionStart(runCallbacks, direction);\n            swiper.transitionEnd(runCallbacks, direction);\n        }\n        return false;\n    }\n    if (params.cssMode) {\n        var isH = swiper.isHorizontal();\n        var t = rtl ? translate : -translate;\n        if (speed === 0) {\n            var isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n            if (isVirtual) {\n                swiper.wrapperEl.style.scrollSnapType = \"none\";\n                swiper._immediateVirtual = true;\n            }\n            if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n                swiper._cssModeVirtualInitialSet = true;\n                requestAnimationFrame(function() {\n                    wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n                });\n            } else {\n                wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n            }\n            if (isVirtual) {\n                requestAnimationFrame(function() {\n                    swiper.wrapperEl.style.scrollSnapType = \"\";\n                    swiper._immediateVirtual = false;\n                });\n            }\n        } else {\n            if (!swiper.support.smoothScroll) {\n                (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.r)({\n                    swiper: swiper,\n                    targetPosition: t,\n                    side: isH ? \"left\" : \"top\"\n                });\n                return true;\n            }\n            var _obj;\n            wrapperEl.scrollTo((_obj = {}, (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_4__._)(_obj, isH ? \"left\" : \"top\", t), (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_4__._)(_obj, \"behavior\", \"smooth\"), _obj));\n        }\n        return true;\n    }\n    swiper.setTransition(speed);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit(\"beforeTransitionStart\", speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n    if (speed === 0) {\n        swiper.transitionEnd(runCallbacks, direction);\n    } else if (!swiper.animating) {\n        swiper.animating = true;\n        if (!swiper.onSlideToWrapperTransitionEnd) {\n            swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n                if (!swiper || swiper.destroyed) return;\n                if (e.target !== this) return;\n                swiper.wrapperEl.removeEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n                swiper.onSlideToWrapperTransitionEnd = null;\n                delete swiper.onSlideToWrapperTransitionEnd;\n                swiper.transitionEnd(runCallbacks, direction);\n            };\n        }\n        swiper.wrapperEl.addEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n    }\n    return true;\n}\nfunction slideToLoop(index, speed, runCallbacks, internal) {\n    if (index === void 0) {\n        index = 0;\n    }\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    if (typeof index === \"string\") {\n        var indexAsNumber = parseInt(index, 10);\n        index = indexAsNumber;\n    }\n    var swiper = this;\n    if (swiper.destroyed) return;\n    if (typeof speed === \"undefined\") {\n        speed = swiper.params.speed;\n    }\n    var gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;\n    var newIndex = index;\n    if (swiper.params.loop) {\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n            // eslint-disable-next-line\n            newIndex = newIndex + swiper.virtual.slidesBefore;\n        } else {\n            var targetSlideIndex;\n            if (gridEnabled) {\n                var slideIndex = newIndex * swiper.params.grid.rows;\n                targetSlideIndex = swiper.slides.filter(function(slideEl) {\n                    return slideEl.getAttribute(\"data-swiper-slide-index\") * 1 === slideIndex;\n                })[0].column;\n            } else {\n                targetSlideIndex = swiper.getSlideIndexByData(newIndex);\n            }\n            var cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;\n            var centeredSlides = swiper.params.centeredSlides;\n            var slidesPerView = swiper.params.slidesPerView;\n            if (slidesPerView === \"auto\") {\n                slidesPerView = swiper.slidesPerViewDynamic();\n            } else {\n                slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));\n                if (centeredSlides && slidesPerView % 2 === 0) {\n                    slidesPerView = slidesPerView + 1;\n                }\n            }\n            var needLoopFix = cols - targetSlideIndex < slidesPerView;\n            if (centeredSlides) {\n                needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);\n            }\n            if (internal && centeredSlides && swiper.params.slidesPerView !== \"auto\" && !gridEnabled) {\n                needLoopFix = false;\n            }\n            if (needLoopFix) {\n                var direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? \"prev\" : \"next\" : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? \"next\" : \"prev\";\n                swiper.loopFix({\n                    direction: direction,\n                    slideTo: true,\n                    activeSlideIndex: direction === \"next\" ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,\n                    slideRealIndex: direction === \"next\" ? swiper.realIndex : undefined\n                });\n            }\n            if (gridEnabled) {\n                var slideIndex1 = newIndex * swiper.params.grid.rows;\n                newIndex = swiper.slides.filter(function(slideEl) {\n                    return slideEl.getAttribute(\"data-swiper-slide-index\") * 1 === slideIndex1;\n                })[0].column;\n            } else {\n                newIndex = swiper.getSlideIndexByData(newIndex);\n            }\n        }\n    }\n    requestAnimationFrame(function() {\n        swiper.slideTo(newIndex, speed, runCallbacks, internal);\n    });\n    return swiper;\n}\n/* eslint no-unused-vars: \"off\" */ function slideNext(speed, runCallbacks, internal) {\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    var swiper = this;\n    var enabled = swiper.enabled, params = swiper.params, animating = swiper.animating;\n    if (!enabled || swiper.destroyed) return swiper;\n    if (typeof speed === \"undefined\") {\n        speed = swiper.params.speed;\n    }\n    var perGroup = params.slidesPerGroup;\n    if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n        perGroup = Math.max(swiper.slidesPerViewDynamic(\"current\", true), 1);\n    }\n    var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n    var isVirtual = swiper.virtual && params.virtual.enabled;\n    if (params.loop) {\n        if (animating && !isVirtual && params.loopPreventsSliding) return false;\n        swiper.loopFix({\n            direction: \"next\"\n        });\n        // eslint-disable-next-line\n        swiper._clientLeft = swiper.wrapperEl.clientLeft;\n        if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {\n            requestAnimationFrame(function() {\n                swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n            });\n            return true;\n        }\n    }\n    if (params.rewind && swiper.isEnd) {\n        return swiper.slideTo(0, speed, runCallbacks, internal);\n    }\n    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n}\n/* eslint no-unused-vars: \"off\" */ function slidePrev(speed, runCallbacks, internal) {\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    var swiper = this;\n    var params = swiper.params, snapGrid = swiper.snapGrid, slidesGrid = swiper.slidesGrid, rtlTranslate = swiper.rtlTranslate, enabled = swiper.enabled, animating = swiper.animating;\n    if (!enabled || swiper.destroyed) return swiper;\n    if (typeof speed === \"undefined\") {\n        speed = swiper.params.speed;\n    }\n    var isVirtual = swiper.virtual && params.virtual.enabled;\n    if (params.loop) {\n        if (animating && !isVirtual && params.loopPreventsSliding) return false;\n        swiper.loopFix({\n            direction: \"prev\"\n        });\n        // eslint-disable-next-line\n        swiper._clientLeft = swiper.wrapperEl.clientLeft;\n    }\n    var translate = rtlTranslate ? swiper.translate : -swiper.translate;\n    function normalize(val) {\n        if (val < 0) return -Math.floor(Math.abs(val));\n        return Math.floor(val);\n    }\n    var normalizedTranslate = normalize(translate);\n    var normalizedSnapGrid = snapGrid.map(function(val) {\n        return normalize(val);\n    });\n    var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n    if (typeof prevSnap === \"undefined\" && params.cssMode) {\n        var prevSnapIndex;\n        snapGrid.forEach(function(snap, snapIndex) {\n            if (normalizedTranslate >= snap) {\n                // prevSnap = snap;\n                prevSnapIndex = snapIndex;\n            }\n        });\n        if (typeof prevSnapIndex !== \"undefined\") {\n            prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n        }\n    }\n    var prevIndex = 0;\n    if (typeof prevSnap !== \"undefined\") {\n        prevIndex = slidesGrid.indexOf(prevSnap);\n        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n        if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n            prevIndex = prevIndex - swiper.slidesPerViewDynamic(\"previous\", true) + 1;\n            prevIndex = Math.max(prevIndex, 0);\n        }\n    }\n    if (params.rewind && swiper.isBeginning) {\n        var lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n        return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n    } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {\n        requestAnimationFrame(function() {\n            swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n        });\n        return true;\n    }\n    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n}\n/* eslint no-unused-vars: \"off\" */ function slideReset(speed, runCallbacks, internal) {\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    var swiper = this;\n    if (swiper.destroyed) return;\n    if (typeof speed === \"undefined\") {\n        speed = swiper.params.speed;\n    }\n    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n}\n/* eslint no-unused-vars: \"off\" */ function slideToClosest(speed, runCallbacks, internal, threshold) {\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    if (threshold === void 0) {\n        threshold = 0.5;\n    }\n    var swiper = this;\n    if (swiper.destroyed) return;\n    if (typeof speed === \"undefined\") {\n        speed = swiper.params.speed;\n    }\n    var index = swiper.activeIndex;\n    var skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n    var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n    var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n    if (translate >= swiper.snapGrid[snapIndex]) {\n        // The current translate is on or after the current snap index, so the choice\n        // is between the current index and the one after it.\n        var currentSnap = swiper.snapGrid[snapIndex];\n        var nextSnap = swiper.snapGrid[snapIndex + 1];\n        if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n            index += swiper.params.slidesPerGroup;\n        }\n    } else {\n        // The current translate is before the current snap index, so the choice\n        // is between the current index and the one before it.\n        var prevSnap = swiper.snapGrid[snapIndex - 1];\n        var currentSnap1 = swiper.snapGrid[snapIndex];\n        if (translate - prevSnap <= (currentSnap1 - prevSnap) * threshold) {\n            index -= swiper.params.slidesPerGroup;\n        }\n    }\n    index = Math.max(index, 0);\n    index = Math.min(index, swiper.slidesGrid.length - 1);\n    return swiper.slideTo(index, speed, runCallbacks, internal);\n}\nfunction slideToClickedSlide() {\n    var swiper = this;\n    if (swiper.destroyed) return;\n    var params = swiper.params, slidesEl = swiper.slidesEl;\n    var slidesPerView = params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n    var slideToIndex = swiper.clickedIndex;\n    var realIndex;\n    var slideSelector = swiper.isElement ? \"swiper-slide\" : \".\".concat(params.slideClass);\n    if (params.loop) {\n        if (swiper.animating) return;\n        realIndex = parseInt(swiper.clickedSlide.getAttribute(\"data-swiper-slide-index\"), 10);\n        if (params.centeredSlides) {\n            if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n                swiper.loopFix();\n                slideToIndex = swiper.getSlideIndex((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, \"\".concat(slideSelector, '[data-swiper-slide-index=\"').concat(realIndex, '\"]'))[0]);\n                (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(function() {\n                    swiper.slideTo(slideToIndex);\n                });\n            } else {\n                swiper.slideTo(slideToIndex);\n            }\n        } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n            swiper.loopFix();\n            slideToIndex = swiper.getSlideIndex((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, \"\".concat(slideSelector, '[data-swiper-slide-index=\"').concat(realIndex, '\"]'))[0]);\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(function() {\n                swiper.slideTo(slideToIndex);\n            });\n        } else {\n            swiper.slideTo(slideToIndex);\n        }\n    } else {\n        swiper.slideTo(slideToIndex);\n    }\n}\nvar slide = {\n    slideTo: slideTo,\n    slideToLoop: slideToLoop,\n    slideNext: slideNext,\n    slidePrev: slidePrev,\n    slideReset: slideReset,\n    slideToClosest: slideToClosest,\n    slideToClickedSlide: slideToClickedSlide\n};\nfunction loopCreate(slideRealIndex) {\n    var swiper = this;\n    var params = swiper.params, slidesEl = swiper.slidesEl;\n    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n    var initSlides = function() {\n        var slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, \".\".concat(params.slideClass, \", swiper-slide\"));\n        slides.forEach(function(el, index) {\n            el.setAttribute(\"data-swiper-slide-index\", index);\n        });\n    };\n    var gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n    var slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);\n    var shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;\n    var shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;\n    var addBlankSlides = function(amountOfSlides) {\n        for(var i = 0; i < amountOfSlides; i += 1){\n            var slideEl = swiper.isElement ? (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(\"swiper-slide\", [\n                params.slideBlankClass\n            ]) : (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(\"div\", [\n                params.slideClass,\n                params.slideBlankClass\n            ]);\n            swiper.slidesEl.append(slideEl);\n        }\n    };\n    if (shouldFillGroup) {\n        if (params.loopAddBlankSlides) {\n            var slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;\n            addBlankSlides(slidesToAdd);\n            swiper.recalcSlides();\n            swiper.updateSlides();\n        } else {\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)(\"Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)\");\n        }\n        initSlides();\n    } else if (shouldFillGrid) {\n        if (params.loopAddBlankSlides) {\n            var slidesToAdd1 = params.grid.rows - swiper.slides.length % params.grid.rows;\n            addBlankSlides(slidesToAdd1);\n            swiper.recalcSlides();\n            swiper.updateSlides();\n        } else {\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)(\"Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)\");\n        }\n        initSlides();\n    } else {\n        initSlides();\n    }\n    swiper.loopFix({\n        slideRealIndex: slideRealIndex,\n        direction: params.centeredSlides ? undefined : \"next\"\n    });\n}\nfunction loopFix(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp, slideRealIndex = _ref.slideRealIndex, _ref_slideTo = _ref.slideTo, _$slideTo = _ref_slideTo === void 0 ? true : _ref_slideTo, direction = _ref.direction, _$setTranslate = _ref.setTranslate, activeSlideIndex = _ref.activeSlideIndex, byController = _ref.byController, byMousewheel = _ref.byMousewheel;\n    var swiper = this;\n    if (!swiper.params.loop) return;\n    swiper.emit(\"beforeLoopFix\");\n    var slides = swiper.slides, allowSlidePrev = swiper.allowSlidePrev, allowSlideNext = swiper.allowSlideNext, slidesEl = swiper.slidesEl, params = swiper.params;\n    var centeredSlides = params.centeredSlides;\n    swiper.allowSlidePrev = true;\n    swiper.allowSlideNext = true;\n    if (swiper.virtual && params.virtual.enabled) {\n        if (_$slideTo) {\n            if (!params.centeredSlides && swiper.snapIndex === 0) {\n                swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n            } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {\n                swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n            } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n                swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n            }\n        }\n        swiper.allowSlidePrev = allowSlidePrev;\n        swiper.allowSlideNext = allowSlideNext;\n        swiper.emit(\"loopFix\");\n        return;\n    }\n    var slidesPerView = params.slidesPerView;\n    if (slidesPerView === \"auto\") {\n        slidesPerView = swiper.slidesPerViewDynamic();\n    } else {\n        slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));\n        if (centeredSlides && slidesPerView % 2 === 0) {\n            slidesPerView = slidesPerView + 1;\n        }\n    }\n    var slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;\n    var loopedSlides = slidesPerGroup;\n    if (loopedSlides % slidesPerGroup !== 0) {\n        loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;\n    }\n    loopedSlides += params.loopAdditionalSlides;\n    swiper.loopedSlides = loopedSlides;\n    var gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n    if (slides.length < slidesPerView + loopedSlides) {\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)(\"Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters\");\n    } else if (gridEnabled && params.grid.fill === \"row\") {\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)(\"Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`\");\n    }\n    var prependSlidesIndexes = [];\n    var appendSlidesIndexes = [];\n    var activeIndex = swiper.activeIndex;\n    if (typeof activeSlideIndex === \"undefined\") {\n        activeSlideIndex = swiper.getSlideIndex(slides.filter(function(el) {\n            return el.classList.contains(params.slideActiveClass);\n        })[0]);\n    } else {\n        activeIndex = activeSlideIndex;\n    }\n    var isNext = direction === \"next\" || !direction;\n    var isPrev = direction === \"prev\" || !direction;\n    var slidesPrepended = 0;\n    var slidesAppended = 0;\n    var cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;\n    var activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;\n    var activeColIndexWithShift = activeColIndex + (centeredSlides && typeof _$setTranslate === \"undefined\" ? -slidesPerView / 2 + 0.5 : 0);\n    // prepend last slides before start\n    if (activeColIndexWithShift < loopedSlides) {\n        slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);\n        for(var i = 0; i < loopedSlides - activeColIndexWithShift; i += 1){\n            var index = i - Math.floor(i / cols) * cols;\n            if (gridEnabled) {\n                var colIndexToPrepend = cols - index - 1;\n                for(var i1 = slides.length - 1; i1 >= 0; i1 -= 1){\n                    if (slides[i1].column === colIndexToPrepend) prependSlidesIndexes.push(i1);\n                }\n            // slides.forEach((slide, slideIndex) => {\n            //   if (slide.column === colIndexToPrepend) prependSlidesIndexes.push(slideIndex);\n            // });\n            } else {\n                prependSlidesIndexes.push(cols - index - 1);\n            }\n        }\n    } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {\n        var _loop = function(i2) {\n            var index = i2 - Math.floor(i2 / cols) * cols;\n            if (gridEnabled) {\n                slides.forEach(function(slide, slideIndex) {\n                    if (slide.column === index) appendSlidesIndexes.push(slideIndex);\n                });\n            } else {\n                appendSlidesIndexes.push(index);\n            }\n        };\n        slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);\n        for(var i2 = 0; i2 < slidesAppended; i2 += 1)_loop(i2);\n    }\n    swiper.__preventObserver__ = true;\n    requestAnimationFrame(function() {\n        swiper.__preventObserver__ = false;\n    });\n    if (isPrev) {\n        prependSlidesIndexes.forEach(function(index) {\n            slides[index].swiperLoopMoveDOM = true;\n            slidesEl.prepend(slides[index]);\n            slides[index].swiperLoopMoveDOM = false;\n        });\n    }\n    if (isNext) {\n        appendSlidesIndexes.forEach(function(index) {\n            slides[index].swiperLoopMoveDOM = true;\n            slidesEl.append(slides[index]);\n            slides[index].swiperLoopMoveDOM = false;\n        });\n    }\n    swiper.recalcSlides();\n    if (params.slidesPerView === \"auto\") {\n        swiper.updateSlides();\n    } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {\n        swiper.slides.forEach(function(slide, slideIndex) {\n            swiper.grid.updateSlide(slideIndex, slide, swiper.slides);\n        });\n    }\n    if (params.watchSlidesProgress) {\n        swiper.updateSlidesOffset();\n    }\n    if (_$slideTo) {\n        if (prependSlidesIndexes.length > 0 && isPrev) {\n            if (typeof slideRealIndex === \"undefined\") {\n                var currentSlideTranslate = swiper.slidesGrid[activeIndex];\n                var newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n                var diff = newSlideTranslate - currentSlideTranslate;\n                if (byMousewheel) {\n                    swiper.setTranslate(swiper.translate - diff);\n                } else {\n                    swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);\n                    if (_$setTranslate) {\n                        swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;\n                        swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;\n                    }\n                }\n            } else {\n                if (_$setTranslate) {\n                    var shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;\n                    swiper.slideTo(swiper.activeIndex + shift, 0, false, true);\n                    swiper.touchEventsData.currentTranslate = swiper.translate;\n                }\n            }\n        } else if (appendSlidesIndexes.length > 0 && isNext) {\n            if (typeof slideRealIndex === \"undefined\") {\n                var currentSlideTranslate1 = swiper.slidesGrid[activeIndex];\n                var newSlideTranslate1 = swiper.slidesGrid[activeIndex - slidesAppended];\n                var diff1 = newSlideTranslate1 - currentSlideTranslate1;\n                if (byMousewheel) {\n                    swiper.setTranslate(swiper.translate - diff1);\n                } else {\n                    swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n                    if (_$setTranslate) {\n                        swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff1;\n                        swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff1;\n                    }\n                }\n            } else {\n                var shift1 = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;\n                swiper.slideTo(swiper.activeIndex - shift1, 0, false, true);\n            }\n        }\n    }\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    if (swiper.controller && swiper.controller.control && !byController) {\n        var loopParams = {\n            slideRealIndex: slideRealIndex,\n            direction: direction,\n            setTranslate: _$setTranslate,\n            activeSlideIndex: activeSlideIndex,\n            byController: true\n        };\n        if (Array.isArray(swiper.controller.control)) {\n            swiper.controller.control.forEach(function(c) {\n                if (!c.destroyed && c.params.loop) c.loopFix((0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_5__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_6__._)({}, loopParams), {\n                    slideTo: c.params.slidesPerView === params.slidesPerView ? _$slideTo : false\n                }));\n            });\n        } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {\n            swiper.controller.control.loopFix((0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_5__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_6__._)({}, loopParams), {\n                slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? _$slideTo : false\n            }));\n        }\n    }\n    swiper.emit(\"loopFix\");\n}\nfunction loopDestroy() {\n    var swiper = this;\n    var params = swiper.params, slidesEl = swiper.slidesEl;\n    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n    swiper.recalcSlides();\n    var newSlidesOrder = [];\n    swiper.slides.forEach(function(slideEl) {\n        var index = typeof slideEl.swiperSlideIndex === \"undefined\" ? slideEl.getAttribute(\"data-swiper-slide-index\") * 1 : slideEl.swiperSlideIndex;\n        newSlidesOrder[index] = slideEl;\n    });\n    swiper.slides.forEach(function(slideEl) {\n        slideEl.removeAttribute(\"data-swiper-slide-index\");\n    });\n    newSlidesOrder.forEach(function(slideEl) {\n        slidesEl.append(slideEl);\n    });\n    swiper.recalcSlides();\n    swiper.slideTo(swiper.realIndex, 0);\n}\nvar loop = {\n    loopCreate: loopCreate,\n    loopFix: loopFix,\n    loopDestroy: loopDestroy\n};\nfunction setGrabCursor(moving) {\n    var swiper = this;\n    if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n    var el = swiper.params.touchEventsTarget === \"container\" ? swiper.el : swiper.wrapperEl;\n    if (swiper.isElement) {\n        swiper.__preventObserver__ = true;\n    }\n    el.style.cursor = \"move\";\n    el.style.cursor = moving ? \"grabbing\" : \"grab\";\n    if (swiper.isElement) {\n        requestAnimationFrame(function() {\n            swiper.__preventObserver__ = false;\n        });\n    }\n}\nfunction unsetGrabCursor() {\n    var swiper = this;\n    if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\n        return;\n    }\n    if (swiper.isElement) {\n        swiper.__preventObserver__ = true;\n    }\n    swiper[swiper.params.touchEventsTarget === \"container\" ? \"el\" : \"wrapperEl\"].style.cursor = \"\";\n    if (swiper.isElement) {\n        requestAnimationFrame(function() {\n            swiper.__preventObserver__ = false;\n        });\n    }\n}\nvar grabCursor = {\n    setGrabCursor: setGrabCursor,\n    unsetGrabCursor: unsetGrabCursor\n};\n// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\nfunction closestElement(selector, base) {\n    if (base === void 0) {\n        base = this;\n    }\n    function __closestFrom(el) {\n        if (!el || el === (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)() || el === (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)()) return null;\n        if (el.assignedSlot) el = el.assignedSlot;\n        var found = el.closest(selector);\n        if (!found && !el.getRootNode) {\n            return null;\n        }\n        return found || __closestFrom(el.getRootNode().host);\n    }\n    return __closestFrom(base);\n}\nfunction preventEdgeSwipe(swiper, event, startX) {\n    var window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    var params = swiper.params;\n    var edgeSwipeDetection = params.edgeSwipeDetection;\n    var edgeSwipeThreshold = params.edgeSwipeThreshold;\n    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window1.innerWidth - edgeSwipeThreshold)) {\n        if (edgeSwipeDetection === \"prevent\") {\n            event.preventDefault();\n            return true;\n        }\n        return false;\n    }\n    return true;\n}\nfunction onTouchStart(event) {\n    var swiper = this;\n    var document1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n    var e = event;\n    if (e.originalEvent) e = e.originalEvent;\n    var data = swiper.touchEventsData;\n    if (e.type === \"pointerdown\") {\n        if (data.pointerId !== null && data.pointerId !== e.pointerId) {\n            return;\n        }\n        data.pointerId = e.pointerId;\n    } else if (e.type === \"touchstart\" && e.targetTouches.length === 1) {\n        data.touchId = e.targetTouches[0].identifier;\n    }\n    if (e.type === \"touchstart\") {\n        // don't proceed touch event\n        preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);\n        return;\n    }\n    var params = swiper.params, touches = swiper.touches, enabled = swiper.enabled;\n    if (!enabled) return;\n    if (!params.simulateTouch && e.pointerType === \"mouse\") return;\n    if (swiper.animating && params.preventInteractionOnTransition) {\n        return;\n    }\n    if (!swiper.animating && params.cssMode && params.loop) {\n        swiper.loopFix();\n    }\n    var targetEl = e.target;\n    if (params.touchEventsTarget === \"wrapper\") {\n        if (!swiper.wrapperEl.contains(targetEl)) return;\n    }\n    if (\"which\" in e && e.which === 3) return;\n    if (\"button\" in e && e.button > 0) return;\n    if (data.isTouched && data.isMoved) return;\n    // change target el for shadow root component\n    var swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== \"\";\n    // eslint-disable-next-line\n    var eventPath = e.composedPath ? e.composedPath() : e.path;\n    if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n        targetEl = eventPath[0];\n    }\n    var noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : \".\".concat(params.noSwipingClass);\n    var isTargetShadow = !!(e.target && e.target.shadowRoot);\n    // use closestElement for shadow root element to get the actual closest for nested shadow root element\n    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {\n        swiper.allowClick = true;\n        return;\n    }\n    if (params.swipeHandler) {\n        if (!targetEl.closest(params.swipeHandler)) return;\n    }\n    touches.currentX = e.pageX;\n    touches.currentY = e.pageY;\n    var startX = touches.currentX;\n    var startY = touches.currentY;\n    // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n    if (!preventEdgeSwipe(swiper, e, startX)) {\n        return;\n    }\n    Object.assign(data, {\n        isTouched: true,\n        isMoved: false,\n        allowTouchCallbacks: true,\n        isScrolling: undefined,\n        startMoving: undefined\n    });\n    touches.startX = startX;\n    touches.startY = startY;\n    data.touchStartTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();\n    swiper.allowClick = true;\n    swiper.updateSize();\n    swiper.swipeDirection = undefined;\n    if (params.threshold > 0) data.allowThresholdMove = false;\n    var preventDefault = true;\n    if (targetEl.matches(data.focusableElements)) {\n        preventDefault = false;\n        if (targetEl.nodeName === \"SELECT\") {\n            data.isTouched = false;\n        }\n    }\n    if (document1.activeElement && document1.activeElement.matches(data.focusableElements) && document1.activeElement !== targetEl) {\n        document1.activeElement.blur();\n    }\n    var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {\n        e.preventDefault();\n    }\n    if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {\n        swiper.freeMode.onTouchStart();\n    }\n    swiper.emit(\"touchStart\", e);\n}\nfunction onTouchMove(event) {\n    var document1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n    var swiper = this;\n    var data = swiper.touchEventsData;\n    var params = swiper.params, touches = swiper.touches, rtl = swiper.rtlTranslate, enabled = swiper.enabled;\n    if (!enabled) return;\n    if (!params.simulateTouch && event.pointerType === \"mouse\") return;\n    var e = event;\n    if (e.originalEvent) e = e.originalEvent;\n    if (e.type === \"pointermove\") {\n        if (data.touchId !== null) return; // return from pointer if we use touch\n        var id = e.pointerId;\n        if (id !== data.pointerId) return;\n    }\n    var targetTouch;\n    if (e.type === \"touchmove\") {\n        targetTouch = (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_3__._)(e.changedTouches).filter(function(t) {\n            return t.identifier === data.touchId;\n        })[0];\n        if (!targetTouch || targetTouch.identifier !== data.touchId) return;\n    } else {\n        targetTouch = e;\n    }\n    if (!data.isTouched) {\n        if (data.startMoving && data.isScrolling) {\n            swiper.emit(\"touchMoveOpposite\", e);\n        }\n        return;\n    }\n    var pageX = targetTouch.pageX;\n    var pageY = targetTouch.pageY;\n    if (e.preventedByNestedSwiper) {\n        touches.startX = pageX;\n        touches.startY = pageY;\n        return;\n    }\n    if (!swiper.allowTouchMove) {\n        if (!e.target.matches(data.focusableElements)) {\n            swiper.allowClick = false;\n        }\n        if (data.isTouched) {\n            Object.assign(touches, {\n                startX: pageX,\n                startY: pageY,\n                currentX: pageX,\n                currentY: pageY\n            });\n            data.touchStartTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();\n        }\n        return;\n    }\n    if (params.touchReleaseOnEdges && !params.loop) {\n        if (swiper.isVertical()) {\n            // Vertical\n            if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n                data.isTouched = false;\n                data.isMoved = false;\n                return;\n            }\n        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {\n            return;\n        }\n    }\n    if (document1.activeElement) {\n        if (e.target === document1.activeElement && e.target.matches(data.focusableElements)) {\n            data.isMoved = true;\n            swiper.allowClick = false;\n            return;\n        }\n    }\n    if (data.allowTouchCallbacks) {\n        swiper.emit(\"touchMove\", e);\n    }\n    touches.previousX = touches.currentX;\n    touches.previousY = touches.currentY;\n    touches.currentX = pageX;\n    touches.currentY = pageY;\n    var diffX = touches.currentX - touches.startX;\n    var diffY = touches.currentY - touches.startY;\n    if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) return;\n    if (typeof data.isScrolling === \"undefined\") {\n        var touchAngle;\n        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {\n            data.isScrolling = false;\n        } else {\n            // eslint-disable-next-line\n            if (diffX * diffX + diffY * diffY >= 25) {\n                touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n                data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n            }\n        }\n    }\n    if (data.isScrolling) {\n        swiper.emit(\"touchMoveOpposite\", e);\n    }\n    if (typeof data.startMoving === \"undefined\") {\n        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n            data.startMoving = true;\n        }\n    }\n    if (data.isScrolling || e.type === \"touchmove\" && data.preventTouchMoveFromPointerMove) {\n        data.isTouched = false;\n        return;\n    }\n    if (!data.startMoving) {\n        return;\n    }\n    swiper.allowClick = false;\n    if (!params.cssMode && e.cancelable) {\n        e.preventDefault();\n    }\n    if (params.touchMoveStopPropagation && !params.nested) {\n        e.stopPropagation();\n    }\n    var diff = swiper.isHorizontal() ? diffX : diffY;\n    var touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;\n    if (params.oneWayMovement) {\n        diff = Math.abs(diff) * (rtl ? 1 : -1);\n        touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n    }\n    touches.diff = diff;\n    diff *= params.touchRatio;\n    if (rtl) {\n        diff = -diff;\n        touchesDiff = -touchesDiff;\n    }\n    var prevTouchesDirection = swiper.touchesDirection;\n    swiper.swipeDirection = diff > 0 ? \"prev\" : \"next\";\n    swiper.touchesDirection = touchesDiff > 0 ? \"prev\" : \"next\";\n    var isLoop = swiper.params.loop && !params.cssMode;\n    var allowLoopFix = swiper.touchesDirection === \"next\" && swiper.allowSlideNext || swiper.touchesDirection === \"prev\" && swiper.allowSlidePrev;\n    if (!data.isMoved) {\n        if (isLoop && allowLoopFix) {\n            swiper.loopFix({\n                direction: swiper.swipeDirection\n            });\n        }\n        data.startTranslate = swiper.getTranslate();\n        swiper.setTransition(0);\n        if (swiper.animating) {\n            var evt = new window.CustomEvent(\"transitionend\", {\n                bubbles: true,\n                cancelable: true,\n                detail: {\n                    bySwiperTouchMove: true\n                }\n            });\n            swiper.wrapperEl.dispatchEvent(evt);\n        }\n        data.allowMomentumBounce = false;\n        // Grab Cursor\n        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n            swiper.setGrabCursor(true);\n        }\n        swiper.emit(\"sliderFirstMove\", e);\n    }\n    var loopFixed;\n    new Date().getTime();\n    if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {\n        Object.assign(touches, {\n            startX: pageX,\n            startY: pageY,\n            currentX: pageX,\n            currentY: pageY,\n            startTranslate: data.currentTranslate\n        });\n        data.loopSwapReset = true;\n        data.startTranslate = data.currentTranslate;\n        return;\n    }\n    swiper.emit(\"sliderMove\", e);\n    data.isMoved = true;\n    data.currentTranslate = diff + data.startTranslate;\n    var disableParentSwiper = true;\n    var resistanceRatio = params.resistanceRatio;\n    if (params.touchReleaseOnEdges) {\n        resistanceRatio = 0;\n    }\n    if (diff > 0) {\n        if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] : swiper.minTranslate())) {\n            swiper.loopFix({\n                direction: \"prev\",\n                setTranslate: true,\n                activeSlideIndex: 0\n            });\n        }\n        if (data.currentTranslate > swiper.minTranslate()) {\n            disableParentSwiper = false;\n            if (params.resistance) {\n                data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);\n            }\n        }\n    } else if (diff < 0) {\n        if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] : swiper.maxTranslate())) {\n            swiper.loopFix({\n                direction: \"next\",\n                setTranslate: true,\n                activeSlideIndex: swiper.slides.length - (params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))\n            });\n        }\n        if (data.currentTranslate < swiper.maxTranslate()) {\n            disableParentSwiper = false;\n            if (params.resistance) {\n                data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);\n            }\n        }\n    }\n    if (disableParentSwiper) {\n        e.preventedByNestedSwiper = true;\n    }\n    // Directions locks\n    if (!swiper.allowSlideNext && swiper.swipeDirection === \"next\" && data.currentTranslate < data.startTranslate) {\n        data.currentTranslate = data.startTranslate;\n    }\n    if (!swiper.allowSlidePrev && swiper.swipeDirection === \"prev\" && data.currentTranslate > data.startTranslate) {\n        data.currentTranslate = data.startTranslate;\n    }\n    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n        data.currentTranslate = data.startTranslate;\n    }\n    // Threshold\n    if (params.threshold > 0) {\n        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n            if (!data.allowThresholdMove) {\n                data.allowThresholdMove = true;\n                touches.startX = touches.currentX;\n                touches.startY = touches.currentY;\n                data.currentTranslate = data.startTranslate;\n                touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n                return;\n            }\n        } else {\n            data.currentTranslate = data.startTranslate;\n            return;\n        }\n    }\n    if (!params.followFinger || params.cssMode) return;\n    // Update active index in free mode\n    if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n    }\n    if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n        swiper.freeMode.onTouchMove();\n    }\n    // Update progress\n    swiper.updateProgress(data.currentTranslate);\n    // Update translate\n    swiper.setTranslate(data.currentTranslate);\n}\nfunction onTouchEnd(event) {\n    var swiper = this;\n    var data = swiper.touchEventsData;\n    var e = event;\n    if (e.originalEvent) e = e.originalEvent;\n    var targetTouch;\n    var isTouchEvent = e.type === \"touchend\" || e.type === \"touchcancel\";\n    if (!isTouchEvent) {\n        if (data.touchId !== null) return; // return from pointer if we use touch\n        if (e.pointerId !== data.pointerId) return;\n        targetTouch = e;\n    } else {\n        targetTouch = (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_3__._)(e.changedTouches).filter(function(t) {\n            return t.identifier === data.touchId;\n        })[0];\n        if (!targetTouch || targetTouch.identifier !== data.touchId) return;\n    }\n    if ([\n        \"pointercancel\",\n        \"pointerout\",\n        \"pointerleave\",\n        \"contextmenu\"\n    ].includes(e.type)) {\n        var proceed = [\n            \"pointercancel\",\n            \"contextmenu\"\n        ].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);\n        if (!proceed) {\n            return;\n        }\n    }\n    data.pointerId = null;\n    data.touchId = null;\n    var params = swiper.params, touches = swiper.touches, rtl = swiper.rtlTranslate, slidesGrid = swiper.slidesGrid, enabled = swiper.enabled;\n    if (!enabled) return;\n    if (!params.simulateTouch && e.pointerType === \"mouse\") return;\n    if (data.allowTouchCallbacks) {\n        swiper.emit(\"touchEnd\", e);\n    }\n    data.allowTouchCallbacks = false;\n    if (!data.isTouched) {\n        if (data.isMoved && params.grabCursor) {\n            swiper.setGrabCursor(false);\n        }\n        data.isMoved = false;\n        data.startMoving = false;\n        return;\n    }\n    // Return Grab Cursor\n    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n        swiper.setGrabCursor(false);\n    }\n    // Time diff\n    var touchEndTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();\n    var timeDiff = touchEndTime - data.touchStartTime;\n    // Tap, doubleTap, Click\n    if (swiper.allowClick) {\n        var pathTree = e.path || e.composedPath && e.composedPath();\n        swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);\n        swiper.emit(\"tap click\", e);\n        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n            swiper.emit(\"doubleTap doubleClick\", e);\n        }\n    }\n    data.lastClickTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();\n    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(function() {\n        if (!swiper.destroyed) swiper.allowClick = true;\n    });\n    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {\n        data.isTouched = false;\n        data.isMoved = false;\n        data.startMoving = false;\n        return;\n    }\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    var currentPos;\n    if (params.followFinger) {\n        currentPos = rtl ? swiper.translate : -swiper.translate;\n    } else {\n        currentPos = -data.currentTranslate;\n    }\n    if (params.cssMode) {\n        return;\n    }\n    if (params.freeMode && params.freeMode.enabled) {\n        swiper.freeMode.onTouchEnd({\n            currentPos: currentPos\n        });\n        return;\n    }\n    // Find current slide\n    var swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;\n    var stopIndex = 0;\n    var groupSize = swiper.slidesSizesGrid[0];\n    for(var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup){\n        var increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n        if (typeof slidesGrid[i + increment] !== \"undefined\") {\n            if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n                stopIndex = i;\n                groupSize = slidesGrid[i + increment] - slidesGrid[i];\n            }\n        } else if (swipeToLast || currentPos >= slidesGrid[i]) {\n            stopIndex = i;\n            groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n        }\n    }\n    var rewindFirstIndex = null;\n    var rewindLastIndex = null;\n    if (params.rewind) {\n        if (swiper.isBeginning) {\n            rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n        } else if (swiper.isEnd) {\n            rewindFirstIndex = 0;\n        }\n    }\n    // Find current slide size\n    var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n    var increment1 = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n    if (timeDiff > params.longSwipesMs) {\n        // Long touches\n        if (!params.longSwipes) {\n            swiper.slideTo(swiper.activeIndex);\n            return;\n        }\n        if (swiper.swipeDirection === \"next\") {\n            if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment1);\n            else swiper.slideTo(stopIndex);\n        }\n        if (swiper.swipeDirection === \"prev\") {\n            if (ratio > 1 - params.longSwipesRatio) {\n                swiper.slideTo(stopIndex + increment1);\n            } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n                swiper.slideTo(rewindLastIndex);\n            } else {\n                swiper.slideTo(stopIndex);\n            }\n        }\n    } else {\n        // Short swipes\n        if (!params.shortSwipes) {\n            swiper.slideTo(swiper.activeIndex);\n            return;\n        }\n        var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n        if (!isNavButtonTarget) {\n            if (swiper.swipeDirection === \"next\") {\n                swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment1);\n            }\n            if (swiper.swipeDirection === \"prev\") {\n                swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n            }\n        } else if (e.target === swiper.navigation.nextEl) {\n            swiper.slideTo(stopIndex + increment1);\n        } else {\n            swiper.slideTo(stopIndex);\n        }\n    }\n}\nfunction onResize() {\n    var swiper = this;\n    var params = swiper.params, el = swiper.el;\n    if (el && el.offsetWidth === 0) return;\n    // Breakpoints\n    if (params.breakpoints) {\n        swiper.setBreakpoint();\n    }\n    // Save locks\n    var allowSlideNext = swiper.allowSlideNext, allowSlidePrev = swiper.allowSlidePrev, snapGrid = swiper.snapGrid;\n    var isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n    // Disable locks on resize\n    swiper.allowSlideNext = true;\n    swiper.allowSlidePrev = true;\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateSlidesClasses();\n    var isVirtualLoop = isVirtual && params.loop;\n    if ((params.slidesPerView === \"auto\" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {\n        swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n    } else {\n        if (swiper.params.loop && !isVirtual) {\n            swiper.slideToLoop(swiper.realIndex, 0, false, true);\n        } else {\n            swiper.slideTo(swiper.activeIndex, 0, false, true);\n        }\n    }\n    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n        clearTimeout(swiper.autoplay.resizeTimeout);\n        swiper.autoplay.resizeTimeout = setTimeout(function() {\n            if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n                swiper.autoplay.resume();\n            }\n        }, 500);\n    }\n    // Return locks after resize\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n        swiper.checkOverflow();\n    }\n}\nfunction onClick(e) {\n    var swiper = this;\n    if (!swiper.enabled) return;\n    if (!swiper.allowClick) {\n        if (swiper.params.preventClicks) e.preventDefault();\n        if (swiper.params.preventClicksPropagation && swiper.animating) {\n            e.stopPropagation();\n            e.stopImmediatePropagation();\n        }\n    }\n}\nfunction onScroll() {\n    var swiper = this;\n    var wrapperEl = swiper.wrapperEl, rtlTranslate = swiper.rtlTranslate, enabled = swiper.enabled;\n    if (!enabled) return;\n    swiper.previousTranslate = swiper.translate;\n    if (swiper.isHorizontal()) {\n        swiper.translate = -wrapperEl.scrollLeft;\n    } else {\n        swiper.translate = -wrapperEl.scrollTop;\n    }\n    // eslint-disable-next-line\n    if (swiper.translate === 0) swiper.translate = 0;\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n    var newProgress;\n    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n    if (translatesDiff === 0) {\n        newProgress = 0;\n    } else {\n        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n    }\n    if (newProgress !== swiper.progress) {\n        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n    }\n    swiper.emit(\"setTranslate\", swiper.translate, false);\n}\nfunction onLoad(e) {\n    var swiper = this;\n    processLazyPreloader(swiper, e.target);\n    if (swiper.params.cssMode || swiper.params.slidesPerView !== \"auto\" && !swiper.params.autoHeight) {\n        return;\n    }\n    swiper.update();\n}\nfunction onDocumentTouchStart() {\n    var swiper = this;\n    if (swiper.documentTouchHandlerProceeded) return;\n    swiper.documentTouchHandlerProceeded = true;\n    if (swiper.params.touchReleaseOnEdges) {\n        swiper.el.style.touchAction = \"auto\";\n    }\n}\nvar events = function(swiper, method) {\n    var document1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n    var params = swiper.params, el = swiper.el, wrapperEl = swiper.wrapperEl, device = swiper.device;\n    var capture = !!params.nested;\n    var domMethod = method === \"on\" ? \"addEventListener\" : \"removeEventListener\";\n    var swiperMethod = method;\n    // Touch Events\n    document1[domMethod](\"touchstart\", swiper.onDocumentTouchStart, {\n        passive: false,\n        capture: capture\n    });\n    el[domMethod](\"touchstart\", swiper.onTouchStart, {\n        passive: false\n    });\n    el[domMethod](\"pointerdown\", swiper.onTouchStart, {\n        passive: false\n    });\n    document1[domMethod](\"touchmove\", swiper.onTouchMove, {\n        passive: false,\n        capture: capture\n    });\n    document1[domMethod](\"pointermove\", swiper.onTouchMove, {\n        passive: false,\n        capture: capture\n    });\n    document1[domMethod](\"touchend\", swiper.onTouchEnd, {\n        passive: true\n    });\n    document1[domMethod](\"pointerup\", swiper.onTouchEnd, {\n        passive: true\n    });\n    document1[domMethod](\"pointercancel\", swiper.onTouchEnd, {\n        passive: true\n    });\n    document1[domMethod](\"touchcancel\", swiper.onTouchEnd, {\n        passive: true\n    });\n    document1[domMethod](\"pointerout\", swiper.onTouchEnd, {\n        passive: true\n    });\n    document1[domMethod](\"pointerleave\", swiper.onTouchEnd, {\n        passive: true\n    });\n    document1[domMethod](\"contextmenu\", swiper.onTouchEnd, {\n        passive: true\n    });\n    // Prevent Links Clicks\n    if (params.preventClicks || params.preventClicksPropagation) {\n        el[domMethod](\"click\", swiper.onClick, true);\n    }\n    if (params.cssMode) {\n        wrapperEl[domMethod](\"scroll\", swiper.onScroll);\n    }\n    // Resize handler\n    if (params.updateOnWindowResize) {\n        swiper[swiperMethod](device.ios || device.android ? \"resize orientationchange observerUpdate\" : \"resize observerUpdate\", onResize, true);\n    } else {\n        swiper[swiperMethod](\"observerUpdate\", onResize, true);\n    }\n    // Images loader\n    el[domMethod](\"load\", swiper.onLoad, {\n        capture: true\n    });\n};\nfunction attachEvents() {\n    var swiper = this;\n    var params = swiper.params;\n    swiper.onTouchStart = onTouchStart.bind(swiper);\n    swiper.onTouchMove = onTouchMove.bind(swiper);\n    swiper.onTouchEnd = onTouchEnd.bind(swiper);\n    swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);\n    if (params.cssMode) {\n        swiper.onScroll = onScroll.bind(swiper);\n    }\n    swiper.onClick = onClick.bind(swiper);\n    swiper.onLoad = onLoad.bind(swiper);\n    events(swiper, \"on\");\n}\nfunction detachEvents() {\n    var swiper = this;\n    events(swiper, \"off\");\n}\nvar events$1 = {\n    attachEvents: attachEvents,\n    detachEvents: detachEvents\n};\nvar isGridEnabled = function(swiper, params) {\n    return swiper.grid && params.grid && params.grid.rows > 1;\n};\nfunction setBreakpoint() {\n    var swiper = this;\n    var realIndex = swiper.realIndex, initialized = swiper.initialized, params = swiper.params, el = swiper.el;\n    var breakpoints = params.breakpoints;\n    if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;\n    // Get breakpoint for window width and update parameters\n    var breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n    if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n    var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n    var breakpointParams = breakpointOnlyParams || swiper.originalParams;\n    var wasMultiRow = isGridEnabled(swiper, params);\n    var isMultiRow = isGridEnabled(swiper, breakpointParams);\n    var wasGrabCursor = swiper.params.grabCursor;\n    var isGrabCursor = breakpointParams.grabCursor;\n    var wasEnabled = params.enabled;\n    if (wasMultiRow && !isMultiRow) {\n        el.classList.remove(\"\".concat(params.containerModifierClass, \"grid\"), \"\".concat(params.containerModifierClass, \"grid-column\"));\n        swiper.emitContainerClasses();\n    } else if (!wasMultiRow && isMultiRow) {\n        el.classList.add(\"\".concat(params.containerModifierClass, \"grid\"));\n        if (breakpointParams.grid.fill && breakpointParams.grid.fill === \"column\" || !breakpointParams.grid.fill && params.grid.fill === \"column\") {\n            el.classList.add(\"\".concat(params.containerModifierClass, \"grid-column\"));\n        }\n        swiper.emitContainerClasses();\n    }\n    if (wasGrabCursor && !isGrabCursor) {\n        swiper.unsetGrabCursor();\n    } else if (!wasGrabCursor && isGrabCursor) {\n        swiper.setGrabCursor();\n    }\n    // Toggle navigation, pagination, scrollbar\n    [\n        \"navigation\",\n        \"pagination\",\n        \"scrollbar\"\n    ].forEach(function(prop) {\n        if (typeof breakpointParams[prop] === \"undefined\") return;\n        var wasModuleEnabled = params[prop] && params[prop].enabled;\n        var isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n        if (wasModuleEnabled && !isModuleEnabled) {\n            swiper[prop].disable();\n        }\n        if (!wasModuleEnabled && isModuleEnabled) {\n            swiper[prop].enable();\n        }\n    });\n    var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n    var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n    var wasLoop = params.loop;\n    if (directionChanged && initialized) {\n        swiper.changeDirection();\n    }\n    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)(swiper.params, breakpointParams);\n    var isEnabled = swiper.params.enabled;\n    var hasLoop = swiper.params.loop;\n    Object.assign(swiper, {\n        allowTouchMove: swiper.params.allowTouchMove,\n        allowSlideNext: swiper.params.allowSlideNext,\n        allowSlidePrev: swiper.params.allowSlidePrev\n    });\n    if (wasEnabled && !isEnabled) {\n        swiper.disable();\n    } else if (!wasEnabled && isEnabled) {\n        swiper.enable();\n    }\n    swiper.currentBreakpoint = breakpoint;\n    swiper.emit(\"_beforeBreakpoint\", breakpointParams);\n    if (initialized) {\n        if (needsReLoop) {\n            swiper.loopDestroy();\n            swiper.loopCreate(realIndex);\n            swiper.updateSlides();\n        } else if (!wasLoop && hasLoop) {\n            swiper.loopCreate(realIndex);\n            swiper.updateSlides();\n        } else if (wasLoop && !hasLoop) {\n            swiper.loopDestroy();\n        }\n    }\n    swiper.emit(\"breakpoint\", breakpointParams);\n}\nfunction getBreakpoint(breakpoints, base, containerEl) {\n    if (base === void 0) {\n        base = \"window\";\n    }\n    if (!breakpoints || base === \"container\" && !containerEl) return undefined;\n    var breakpoint = false;\n    var window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    var currentHeight = base === \"window\" ? window1.innerHeight : containerEl.clientHeight;\n    var points = Object.keys(breakpoints).map(function(point) {\n        if (typeof point === \"string\" && point.indexOf(\"@\") === 0) {\n            var minRatio = parseFloat(point.substr(1));\n            var value = currentHeight * minRatio;\n            return {\n                value: value,\n                point: point\n            };\n        }\n        return {\n            value: point,\n            point: point\n        };\n    });\n    points.sort(function(a, b) {\n        return parseInt(a.value, 10) - parseInt(b.value, 10);\n    });\n    for(var i = 0; i < points.length; i += 1){\n        var _points_i = points[i], point = _points_i.point, value = _points_i.value;\n        if (base === \"window\") {\n            if (window1.matchMedia(\"(min-width: \".concat(value, \"px)\")).matches) {\n                breakpoint = point;\n            }\n        } else if (value <= containerEl.clientWidth) {\n            breakpoint = point;\n        }\n    }\n    return breakpoint || \"max\";\n}\nvar breakpoints = {\n    setBreakpoint: setBreakpoint,\n    getBreakpoint: getBreakpoint\n};\nfunction prepareClasses(entries, prefix) {\n    var resultClasses = [];\n    entries.forEach(function(item) {\n        if (typeof item === \"object\") {\n            Object.keys(item).forEach(function(classNames) {\n                if (item[classNames]) {\n                    resultClasses.push(prefix + classNames);\n                }\n            });\n        } else if (typeof item === \"string\") {\n            resultClasses.push(prefix + item);\n        }\n    });\n    return resultClasses;\n}\nfunction addClasses() {\n    var _classNames, _el_classList;\n    var swiper = this;\n    var classNames = swiper.classNames, params = swiper.params, rtl = swiper.rtl, el = swiper.el, device = swiper.device;\n    // prettier-ignore\n    var suffixes = prepareClasses([\n        \"initialized\",\n        params.direction,\n        {\n            \"free-mode\": swiper.params.freeMode && params.freeMode.enabled\n        },\n        {\n            autoheight: params.autoHeight\n        },\n        {\n            rtl: rtl\n        },\n        {\n            grid: params.grid && params.grid.rows > 1\n        },\n        {\n            \"grid-column\": params.grid && params.grid.rows > 1 && params.grid.fill === \"column\"\n        },\n        {\n            android: device.android\n        },\n        {\n            ios: device.ios\n        },\n        {\n            \"css-mode\": params.cssMode\n        },\n        {\n            centered: params.cssMode && params.centeredSlides\n        },\n        {\n            \"watch-progress\": params.watchSlidesProgress\n        }\n    ], params.containerModifierClass);\n    (_classNames = classNames).push.apply(_classNames, (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_3__._)(suffixes));\n    (_el_classList = el.classList).add.apply(_el_classList, (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_3__._)(classNames));\n    swiper.emitContainerClasses();\n}\nfunction removeClasses() {\n    var _el_classList;\n    var swiper = this;\n    var el = swiper.el, classNames = swiper.classNames;\n    (_el_classList = el.classList).remove.apply(_el_classList, (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_3__._)(classNames));\n    swiper.emitContainerClasses();\n}\nvar classes = {\n    addClasses: addClasses,\n    removeClasses: removeClasses\n};\nfunction checkOverflow() {\n    var swiper = this;\n    var wasLocked = swiper.isLocked, params = swiper.params;\n    var slidesOffsetBefore = params.slidesOffsetBefore;\n    if (slidesOffsetBefore) {\n        var lastSlideIndex = swiper.slides.length - 1;\n        var lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n        swiper.isLocked = swiper.size > lastSlideRightEdge;\n    } else {\n        swiper.isLocked = swiper.snapGrid.length === 1;\n    }\n    if (params.allowSlideNext === true) {\n        swiper.allowSlideNext = !swiper.isLocked;\n    }\n    if (params.allowSlidePrev === true) {\n        swiper.allowSlidePrev = !swiper.isLocked;\n    }\n    if (wasLocked && wasLocked !== swiper.isLocked) {\n        swiper.isEnd = false;\n    }\n    if (wasLocked !== swiper.isLocked) {\n        swiper.emit(swiper.isLocked ? \"lock\" : \"unlock\");\n    }\n}\nvar checkOverflow$1 = {\n    checkOverflow: checkOverflow\n};\nvar defaults = {\n    init: true,\n    direction: \"horizontal\",\n    oneWayMovement: false,\n    swiperElementNodeName: \"SWIPER-CONTAINER\",\n    touchEventsTarget: \"wrapper\",\n    initialSlide: 0,\n    speed: 300,\n    cssMode: false,\n    updateOnWindowResize: true,\n    resizeObserver: true,\n    nested: false,\n    createElements: false,\n    eventsPrefix: \"swiper\",\n    enabled: true,\n    focusableElements: \"input, select, option, textarea, button, video, label\",\n    // Overrides\n    width: null,\n    height: null,\n    //\n    preventInteractionOnTransition: false,\n    // ssr\n    userAgent: null,\n    url: null,\n    // To support iOS's swipe-to-go-back gesture (when being used in-app).\n    edgeSwipeDetection: false,\n    edgeSwipeThreshold: 20,\n    // Autoheight\n    autoHeight: false,\n    // Set wrapper width\n    setWrapperSize: false,\n    // Virtual Translate\n    virtualTranslate: false,\n    // Effects\n    effect: \"slide\",\n    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n    // Breakpoints\n    breakpoints: undefined,\n    breakpointsBase: \"window\",\n    // Slides grid\n    spaceBetween: 0,\n    slidesPerView: 1,\n    slidesPerGroup: 1,\n    slidesPerGroupSkip: 0,\n    slidesPerGroupAuto: false,\n    centeredSlides: false,\n    centeredSlidesBounds: false,\n    slidesOffsetBefore: 0,\n    // in px\n    slidesOffsetAfter: 0,\n    // in px\n    normalizeSlideIndex: true,\n    centerInsufficientSlides: false,\n    // Disable swiper and hide navigation when container not overflow\n    watchOverflow: true,\n    // Round length\n    roundLengths: false,\n    // Touches\n    touchRatio: 1,\n    touchAngle: 45,\n    simulateTouch: true,\n    shortSwipes: true,\n    longSwipes: true,\n    longSwipesRatio: 0.5,\n    longSwipesMs: 300,\n    followFinger: true,\n    allowTouchMove: true,\n    threshold: 5,\n    touchMoveStopPropagation: false,\n    touchStartPreventDefault: true,\n    touchStartForcePreventDefault: false,\n    touchReleaseOnEdges: false,\n    // Unique Navigation Elements\n    uniqueNavElements: true,\n    // Resistance\n    resistance: true,\n    resistanceRatio: 0.85,\n    // Progress\n    watchSlidesProgress: false,\n    // Cursor\n    grabCursor: false,\n    // Clicks\n    preventClicks: true,\n    preventClicksPropagation: true,\n    slideToClickedSlide: false,\n    // loop\n    loop: false,\n    loopAddBlankSlides: true,\n    loopAdditionalSlides: 0,\n    loopPreventsSliding: true,\n    // rewind\n    rewind: false,\n    // Swiping/no swiping\n    allowSlidePrev: true,\n    allowSlideNext: true,\n    swipeHandler: null,\n    // '.swipe-handler',\n    noSwiping: true,\n    noSwipingClass: \"swiper-no-swiping\",\n    noSwipingSelector: null,\n    // Passive Listeners\n    passiveListeners: true,\n    maxBackfaceHiddenSlides: 10,\n    // NS\n    containerModifierClass: \"swiper-\",\n    // NEW\n    slideClass: \"swiper-slide\",\n    slideBlankClass: \"swiper-slide-blank\",\n    slideActiveClass: \"swiper-slide-active\",\n    slideVisibleClass: \"swiper-slide-visible\",\n    slideFullyVisibleClass: \"swiper-slide-fully-visible\",\n    slideNextClass: \"swiper-slide-next\",\n    slidePrevClass: \"swiper-slide-prev\",\n    wrapperClass: \"swiper-wrapper\",\n    lazyPreloaderClass: \"swiper-lazy-preloader\",\n    lazyPreloadPrevNext: 0,\n    // Callbacks\n    runCallbacksOnInit: true,\n    // Internals\n    _emitClasses: false\n};\nfunction moduleExtendParams(params, allModulesParams) {\n    return function extendParams(obj) {\n        if (obj === void 0) {\n            obj = {};\n        }\n        var moduleParamName = Object.keys(obj)[0];\n        var moduleParams = obj[moduleParamName];\n        if (typeof moduleParams !== \"object\" || moduleParams === null) {\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)(allModulesParams, obj);\n            return;\n        }\n        if (params[moduleParamName] === true) {\n            params[moduleParamName] = {\n                enabled: true\n            };\n        }\n        if (moduleParamName === \"navigation\" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {\n            params[moduleParamName].auto = true;\n        }\n        if ([\n            \"pagination\",\n            \"scrollbar\"\n        ].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {\n            params[moduleParamName].auto = true;\n        }\n        if (!(moduleParamName in params && \"enabled\" in moduleParams)) {\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)(allModulesParams, obj);\n            return;\n        }\n        if (typeof params[moduleParamName] === \"object\" && !(\"enabled\" in params[moduleParamName])) {\n            params[moduleParamName].enabled = true;\n        }\n        if (!params[moduleParamName]) params[moduleParamName] = {\n            enabled: false\n        };\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)(allModulesParams, obj);\n    };\n}\n/* eslint no-param-reassign: \"off\" */ var prototypes = {\n    eventsEmitter: eventsEmitter,\n    update: update,\n    translate: translate,\n    transition: transition,\n    slide: slide,\n    loop: loop,\n    grabCursor: grabCursor,\n    events: events$1,\n    breakpoints: breakpoints,\n    checkOverflow: checkOverflow$1,\n    classes: classes\n};\nvar extendedDefaults = {};\nvar Swiper = /*#__PURE__*/ function() {\n    \"use strict\";\n    function Swiper() {\n        (0,_swc_helpers_class_call_check__WEBPACK_IMPORTED_MODULE_7__._)(this, Swiper);\n        var el;\n        var params;\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === \"Object\") {\n            params = args[0];\n        } else {\n            var ref;\n            ref = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_2__._)(args, 2), el = ref[0], params = ref[1], ref;\n        }\n        if (!params) params = {};\n        params = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)({}, params);\n        if (el && !params.el) params.el = el;\n        var document1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n        if (params.el && typeof params.el === \"string\" && document1.querySelectorAll(params.el).length > 1) {\n            var swipers = [];\n            document1.querySelectorAll(params.el).forEach(function(containerEl) {\n                var newParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)({}, params, {\n                    el: containerEl\n                });\n                swipers.push(new Swiper(newParams));\n            });\n            // eslint-disable-next-line no-constructor-return\n            return swipers;\n        }\n        // Swiper Instance\n        var swiper = this;\n        swiper.__swiper__ = true;\n        swiper.support = getSupport();\n        swiper.device = getDevice({\n            userAgent: params.userAgent\n        });\n        swiper.browser = getBrowser();\n        swiper.eventsListeners = {};\n        swiper.eventsAnyListeners = [];\n        swiper.modules = (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_3__._)(swiper.__modules__);\n        if (params.modules && Array.isArray(params.modules)) {\n            var _swiper_modules;\n            (_swiper_modules = swiper.modules).push.apply(_swiper_modules, (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_3__._)(params.modules));\n        }\n        var allModulesParams = {};\n        swiper.modules.forEach(function(mod) {\n            mod({\n                params: params,\n                swiper: swiper,\n                extendParams: moduleExtendParams(params, allModulesParams),\n                on: swiper.on.bind(swiper),\n                once: swiper.once.bind(swiper),\n                off: swiper.off.bind(swiper),\n                emit: swiper.emit.bind(swiper)\n            });\n        });\n        // Extend defaults with modules params\n        var swiperParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)({}, defaults, allModulesParams);\n        // Extend defaults with passed params\n        swiper.params = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)({}, swiperParams, extendedDefaults, params);\n        swiper.originalParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)({}, swiper.params);\n        swiper.passedParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)({}, params);\n        // add event listeners\n        if (swiper.params && swiper.params.on) {\n            Object.keys(swiper.params.on).forEach(function(eventName) {\n                swiper.on(eventName, swiper.params.on[eventName]);\n            });\n        }\n        if (swiper.params && swiper.params.onAny) {\n            swiper.onAny(swiper.params.onAny);\n        }\n        // Extend Swiper\n        Object.assign(swiper, {\n            enabled: swiper.params.enabled,\n            el: el,\n            // Classes\n            classNames: [],\n            // Slides\n            slides: [],\n            slidesGrid: [],\n            snapGrid: [],\n            slidesSizesGrid: [],\n            // isDirection\n            isHorizontal: function() {\n                return swiper.params.direction === \"horizontal\";\n            },\n            isVertical: function() {\n                return swiper.params.direction === \"vertical\";\n            },\n            // Indexes\n            activeIndex: 0,\n            realIndex: 0,\n            //\n            isBeginning: true,\n            isEnd: false,\n            // Props\n            translate: 0,\n            previousTranslate: 0,\n            progress: 0,\n            velocity: 0,\n            animating: false,\n            cssOverflowAdjustment: function() {\n                // Returns 0 unless `translate` is > 2**23\n                // Should be subtracted from css values to prevent overflow\n                return Math.trunc(this.translate / Math.pow(2, 23)) * Math.pow(2, 23);\n            },\n            // Locks\n            allowSlideNext: swiper.params.allowSlideNext,\n            allowSlidePrev: swiper.params.allowSlidePrev,\n            // Touch Events\n            touchEventsData: {\n                isTouched: undefined,\n                isMoved: undefined,\n                allowTouchCallbacks: undefined,\n                touchStartTime: undefined,\n                isScrolling: undefined,\n                currentTranslate: undefined,\n                startTranslate: undefined,\n                allowThresholdMove: undefined,\n                // Form elements to match\n                focusableElements: swiper.params.focusableElements,\n                // Last click time\n                lastClickTime: 0,\n                clickTimeout: undefined,\n                // Velocities\n                velocities: [],\n                allowMomentumBounce: undefined,\n                startMoving: undefined,\n                pointerId: null,\n                touchId: null\n            },\n            // Clicks\n            allowClick: true,\n            // Touches\n            allowTouchMove: swiper.params.allowTouchMove,\n            touches: {\n                startX: 0,\n                startY: 0,\n                currentX: 0,\n                currentY: 0,\n                diff: 0\n            },\n            // Images\n            imagesToLoad: [],\n            imagesLoaded: 0\n        });\n        swiper.emit(\"_swiper\");\n        // Init\n        if (swiper.params.init) {\n            swiper.init();\n        }\n        // Return app instance\n        // eslint-disable-next-line no-constructor-return\n        return swiper;\n    }\n    (0,_swc_helpers_create_class__WEBPACK_IMPORTED_MODULE_8__._)(Swiper, [\n        {\n            key: \"getDirectionLabel\",\n            value: function getDirectionLabel(property) {\n                if (this.isHorizontal()) {\n                    return property;\n                }\n                // prettier-ignore\n                return ({\n                    width: \"height\",\n                    \"margin-top\": \"margin-left\",\n                    \"margin-bottom \": \"margin-right\",\n                    \"margin-left\": \"margin-top\",\n                    \"margin-right\": \"margin-bottom\",\n                    \"padding-left\": \"padding-top\",\n                    \"padding-right\": \"padding-bottom\",\n                    marginRight: \"marginBottom\"\n                })[property];\n            }\n        },\n        {\n            key: \"getSlideIndex\",\n            value: function getSlideIndex(slideEl) {\n                var _this = this, slidesEl = _this.slidesEl, params = _this.params;\n                var slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, \".\".concat(params.slideClass, \", swiper-slide\"));\n                var firstSlideIndex = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.h)(slides[0]);\n                return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.h)(slideEl) - firstSlideIndex;\n            }\n        },\n        {\n            key: \"getSlideIndexByData\",\n            value: function getSlideIndexByData(index) {\n                return this.getSlideIndex(this.slides.filter(function(slideEl) {\n                    return slideEl.getAttribute(\"data-swiper-slide-index\") * 1 === index;\n                })[0]);\n            }\n        },\n        {\n            key: \"recalcSlides\",\n            value: function recalcSlides() {\n                var swiper = this;\n                var slidesEl = swiper.slidesEl, params = swiper.params;\n                swiper.slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, \".\".concat(params.slideClass, \", swiper-slide\"));\n            }\n        },\n        {\n            key: \"enable\",\n            value: function enable() {\n                var swiper = this;\n                if (swiper.enabled) return;\n                swiper.enabled = true;\n                if (swiper.params.grabCursor) {\n                    swiper.setGrabCursor();\n                }\n                swiper.emit(\"enable\");\n            }\n        },\n        {\n            key: \"disable\",\n            value: function disable() {\n                var swiper = this;\n                if (!swiper.enabled) return;\n                swiper.enabled = false;\n                if (swiper.params.grabCursor) {\n                    swiper.unsetGrabCursor();\n                }\n                swiper.emit(\"disable\");\n            }\n        },\n        {\n            key: \"setProgress\",\n            value: function setProgress(progress, speed) {\n                var swiper = this;\n                progress = Math.min(Math.max(progress, 0), 1);\n                var min = swiper.minTranslate();\n                var max = swiper.maxTranslate();\n                var current = (max - min) * progress + min;\n                swiper.translateTo(current, typeof speed === \"undefined\" ? 0 : speed);\n                swiper.updateActiveIndex();\n                swiper.updateSlidesClasses();\n            }\n        },\n        {\n            key: \"emitContainerClasses\",\n            value: function emitContainerClasses() {\n                var swiper = this;\n                if (!swiper.params._emitClasses || !swiper.el) return;\n                var cls = swiper.el.className.split(\" \").filter(function(className) {\n                    return className.indexOf(\"swiper\") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n                });\n                swiper.emit(\"_containerClasses\", cls.join(\" \"));\n            }\n        },\n        {\n            key: \"getSlideClasses\",\n            value: function getSlideClasses(slideEl) {\n                var swiper = this;\n                if (swiper.destroyed) return \"\";\n                return slideEl.className.split(\" \").filter(function(className) {\n                    return className.indexOf(\"swiper-slide\") === 0 || className.indexOf(swiper.params.slideClass) === 0;\n                }).join(\" \");\n            }\n        },\n        {\n            key: \"emitSlidesClasses\",\n            value: function emitSlidesClasses() {\n                var swiper = this;\n                if (!swiper.params._emitClasses || !swiper.el) return;\n                var updates = [];\n                swiper.slides.forEach(function(slideEl) {\n                    var classNames = swiper.getSlideClasses(slideEl);\n                    updates.push({\n                        slideEl: slideEl,\n                        classNames: classNames\n                    });\n                    swiper.emit(\"_slideClass\", slideEl, classNames);\n                });\n                swiper.emit(\"_slideClasses\", updates);\n            }\n        },\n        {\n            key: \"slidesPerViewDynamic\",\n            value: function slidesPerViewDynamic(view, exact) {\n                if (view === void 0) {\n                    view = \"current\";\n                }\n                if (exact === void 0) {\n                    exact = false;\n                }\n                var swiper = this;\n                var params = swiper.params, slides = swiper.slides, slidesGrid = swiper.slidesGrid, slidesSizesGrid = swiper.slidesSizesGrid, swiperSize = swiper.size, activeIndex = swiper.activeIndex;\n                var spv = 1;\n                if (typeof params.slidesPerView === \"number\") return params.slidesPerView;\n                if (params.centeredSlides) {\n                    var slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;\n                    var breakLoop;\n                    for(var i = activeIndex + 1; i < slides.length; i += 1){\n                        if (slides[i] && !breakLoop) {\n                            slideSize += Math.ceil(slides[i].swiperSlideSize);\n                            spv += 1;\n                            if (slideSize > swiperSize) breakLoop = true;\n                        }\n                    }\n                    for(var i1 = activeIndex - 1; i1 >= 0; i1 -= 1){\n                        if (slides[i1] && !breakLoop) {\n                            slideSize += slides[i1].swiperSlideSize;\n                            spv += 1;\n                            if (slideSize > swiperSize) breakLoop = true;\n                        }\n                    }\n                } else {\n                    // eslint-disable-next-line\n                    if (view === \"current\") {\n                        for(var i2 = activeIndex + 1; i2 < slides.length; i2 += 1){\n                            var slideInView = exact ? slidesGrid[i2] + slidesSizesGrid[i2] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i2] - slidesGrid[activeIndex] < swiperSize;\n                            if (slideInView) {\n                                spv += 1;\n                            }\n                        }\n                    } else {\n                        // previous\n                        for(var i3 = activeIndex - 1; i3 >= 0; i3 -= 1){\n                            var slideInView1 = slidesGrid[activeIndex] - slidesGrid[i3] < swiperSize;\n                            if (slideInView1) {\n                                spv += 1;\n                            }\n                        }\n                    }\n                }\n                return spv;\n            }\n        },\n        {\n            key: \"update\",\n            value: function update() {\n                var swiper = this;\n                if (!swiper || swiper.destroyed) return;\n                var snapGrid = swiper.snapGrid, params = swiper.params;\n                // Breakpoints\n                if (params.breakpoints) {\n                    swiper.setBreakpoint();\n                }\n                (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_3__._)(swiper.el.querySelectorAll('[loading=\"lazy\"]')).forEach(function(imageEl) {\n                    if (imageEl.complete) {\n                        processLazyPreloader(swiper, imageEl);\n                    }\n                });\n                swiper.updateSize();\n                swiper.updateSlides();\n                swiper.updateProgress();\n                swiper.updateSlidesClasses();\n                function setTranslate() {\n                    var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n                    var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n                    swiper.setTranslate(newTranslate);\n                    swiper.updateActiveIndex();\n                    swiper.updateSlidesClasses();\n                }\n                var translated;\n                if (params.freeMode && params.freeMode.enabled && !params.cssMode) {\n                    setTranslate();\n                    if (params.autoHeight) {\n                        swiper.updateAutoHeight();\n                    }\n                } else {\n                    if ((params.slidesPerView === \"auto\" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {\n                        var slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n                        translated = swiper.slideTo(slides.length - 1, 0, false, true);\n                    } else {\n                        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n                    }\n                    if (!translated) {\n                        setTranslate();\n                    }\n                }\n                if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n                    swiper.checkOverflow();\n                }\n                swiper.emit(\"update\");\n            }\n        },\n        {\n            key: \"changeDirection\",\n            value: function changeDirection(newDirection, needUpdate) {\n                if (needUpdate === void 0) {\n                    needUpdate = true;\n                }\n                var swiper = this;\n                var currentDirection = swiper.params.direction;\n                if (!newDirection) {\n                    // eslint-disable-next-line\n                    newDirection = currentDirection === \"horizontal\" ? \"vertical\" : \"horizontal\";\n                }\n                if (newDirection === currentDirection || newDirection !== \"horizontal\" && newDirection !== \"vertical\") {\n                    return swiper;\n                }\n                swiper.el.classList.remove(\"\".concat(swiper.params.containerModifierClass).concat(currentDirection));\n                swiper.el.classList.add(\"\".concat(swiper.params.containerModifierClass).concat(newDirection));\n                swiper.emitContainerClasses();\n                swiper.params.direction = newDirection;\n                swiper.slides.forEach(function(slideEl) {\n                    if (newDirection === \"vertical\") {\n                        slideEl.style.width = \"\";\n                    } else {\n                        slideEl.style.height = \"\";\n                    }\n                });\n                swiper.emit(\"changeDirection\");\n                if (needUpdate) swiper.update();\n                return swiper;\n            }\n        },\n        {\n            key: \"changeLanguageDirection\",\n            value: function changeLanguageDirection(direction) {\n                var swiper = this;\n                if (swiper.rtl && direction === \"rtl\" || !swiper.rtl && direction === \"ltr\") return;\n                swiper.rtl = direction === \"rtl\";\n                swiper.rtlTranslate = swiper.params.direction === \"horizontal\" && swiper.rtl;\n                if (swiper.rtl) {\n                    swiper.el.classList.add(\"\".concat(swiper.params.containerModifierClass, \"rtl\"));\n                    swiper.el.dir = \"rtl\";\n                } else {\n                    swiper.el.classList.remove(\"\".concat(swiper.params.containerModifierClass, \"rtl\"));\n                    swiper.el.dir = \"ltr\";\n                }\n                swiper.update();\n            }\n        },\n        {\n            key: \"mount\",\n            value: function mount(element) {\n                var swiper = this;\n                if (swiper.mounted) return true;\n                // Find el\n                var el = element || swiper.params.el;\n                if (typeof el === \"string\") {\n                    el = document.querySelector(el);\n                }\n                if (!el) {\n                    return false;\n                }\n                el.swiper = swiper;\n                if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {\n                    swiper.isElement = true;\n                }\n                var getWrapperSelector = function() {\n                    return \".\".concat((swiper.params.wrapperClass || \"\").trim().split(\" \").join(\".\"));\n                };\n                var getWrapper = function() {\n                    if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n                        var res = el.shadowRoot.querySelector(getWrapperSelector());\n                        // Children needs to return slot items\n                        return res;\n                    }\n                    return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(el, getWrapperSelector())[0];\n                };\n                // Find Wrapper\n                var wrapperEl = getWrapper();\n                if (!wrapperEl && swiper.params.createElements) {\n                    wrapperEl = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(\"div\", swiper.params.wrapperClass);\n                    el.append(wrapperEl);\n                    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(el, \".\".concat(swiper.params.slideClass)).forEach(function(slideEl) {\n                        wrapperEl.append(slideEl);\n                    });\n                }\n                Object.assign(swiper, {\n                    el: el,\n                    wrapperEl: wrapperEl,\n                    slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,\n                    hostEl: swiper.isElement ? el.parentNode.host : el,\n                    mounted: true,\n                    // RTL\n                    rtl: el.dir.toLowerCase() === \"rtl\" || (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(el, \"direction\") === \"rtl\",\n                    rtlTranslate: swiper.params.direction === \"horizontal\" && (el.dir.toLowerCase() === \"rtl\" || (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(el, \"direction\") === \"rtl\"),\n                    wrongRTL: (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(wrapperEl, \"display\") === \"-webkit-box\"\n                });\n                return true;\n            }\n        },\n        {\n            key: \"init\",\n            value: function init(el) {\n                var swiper = this;\n                if (swiper.initialized) return swiper;\n                var mounted = swiper.mount(el);\n                if (mounted === false) return swiper;\n                swiper.emit(\"beforeInit\");\n                // Set breakpoint\n                if (swiper.params.breakpoints) {\n                    swiper.setBreakpoint();\n                }\n                // Add Classes\n                swiper.addClasses();\n                // Update size\n                swiper.updateSize();\n                // Update slides\n                swiper.updateSlides();\n                if (swiper.params.watchOverflow) {\n                    swiper.checkOverflow();\n                }\n                // Set Grab Cursor\n                if (swiper.params.grabCursor && swiper.enabled) {\n                    swiper.setGrabCursor();\n                }\n                // Slide To Initial Slide\n                if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n                    swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);\n                } else {\n                    swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n                }\n                // Create loop\n                if (swiper.params.loop) {\n                    swiper.loopCreate();\n                }\n                // Attach events\n                swiper.attachEvents();\n                var lazyElements = (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_3__._)(swiper.el.querySelectorAll('[loading=\"lazy\"]'));\n                if (swiper.isElement) {\n                    var _lazyElements;\n                    (_lazyElements = lazyElements).push.apply(_lazyElements, (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_3__._)(swiper.hostEl.querySelectorAll('[loading=\"lazy\"]')));\n                }\n                lazyElements.forEach(function(imageEl) {\n                    if (imageEl.complete) {\n                        processLazyPreloader(swiper, imageEl);\n                    } else {\n                        imageEl.addEventListener(\"load\", function(e) {\n                            processLazyPreloader(swiper, e.target);\n                        });\n                    }\n                });\n                preload(swiper);\n                // Init Flag\n                swiper.initialized = true;\n                preload(swiper);\n                // Emit\n                swiper.emit(\"init\");\n                swiper.emit(\"afterInit\");\n                return swiper;\n            }\n        },\n        {\n            key: \"destroy\",\n            value: function destroy(deleteInstance, cleanStyles) {\n                if (deleteInstance === void 0) {\n                    deleteInstance = true;\n                }\n                if (cleanStyles === void 0) {\n                    cleanStyles = true;\n                }\n                var swiper = this;\n                var params = swiper.params, el = swiper.el, wrapperEl = swiper.wrapperEl, slides = swiper.slides;\n                if (typeof swiper.params === \"undefined\" || swiper.destroyed) {\n                    return null;\n                }\n                swiper.emit(\"beforeDestroy\");\n                // Init Flag\n                swiper.initialized = false;\n                // Detach events\n                swiper.detachEvents();\n                // Destroy loop\n                if (params.loop) {\n                    swiper.loopDestroy();\n                }\n                // Cleanup styles\n                if (cleanStyles) {\n                    swiper.removeClasses();\n                    el.removeAttribute(\"style\");\n                    wrapperEl.removeAttribute(\"style\");\n                    if (slides && slides.length) {\n                        slides.forEach(function(slideEl) {\n                            slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n                            slideEl.removeAttribute(\"style\");\n                            slideEl.removeAttribute(\"data-swiper-slide-index\");\n                        });\n                    }\n                }\n                swiper.emit(\"destroy\");\n                // Detach emitter events\n                Object.keys(swiper.eventsListeners).forEach(function(eventName) {\n                    swiper.off(eventName);\n                });\n                if (deleteInstance !== false) {\n                    swiper.el.swiper = null;\n                    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.v)(swiper);\n                }\n                swiper.destroyed = true;\n                return null;\n            }\n        }\n    ], [\n        {\n            key: \"extendDefaults\",\n            value: function extendDefaults(newDefaults) {\n                (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)(extendedDefaults, newDefaults);\n            }\n        },\n        {\n            key: \"extendedDefaults\",\n            get: function get() {\n                return extendedDefaults;\n            }\n        },\n        {\n            key: \"defaults\",\n            get: function get() {\n                return defaults;\n            }\n        },\n        {\n            key: \"installModule\",\n            value: function installModule(mod) {\n                if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n                var modules = Swiper.prototype.__modules__;\n                if (typeof mod === \"function\" && modules.indexOf(mod) < 0) {\n                    modules.push(mod);\n                }\n            }\n        },\n        {\n            key: \"use\",\n            value: function use(module) {\n                if (Array.isArray(module)) {\n                    module.forEach(function(m) {\n                        return Swiper.installModule(m);\n                    });\n                    return Swiper;\n                }\n                Swiper.installModule(module);\n                return Swiper;\n            }\n        }\n    ]);\n    return Swiper;\n}();\nObject.keys(prototypes).forEach(function(prototypeGroup) {\n    Object.keys(prototypes[prototypeGroup]).forEach(function(protoMethod) {\n        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n    });\n});\nSwiper.use([\n    Resize,\n    Observer\n]);\n\nvar _c, _c1;\n$RefreshReg$(_c, \"Resize\");\n$RefreshReg$(_c1, \"Observer\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zd2lwZXJAMTEuMS4zL25vZGVfbW9kdWxlcy9zd2lwZXIvc2hhcmVkL3N3aXBlci1jb3JlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0U7QUFDd1E7QUFFaFYsSUFBSW1DO0FBQ0osU0FBU0M7SUFDUCxJQUFNQyxVQUFTcEMsc0RBQVNBO0lBQ3hCLElBQU1xQyxZQUFXbkMsc0RBQVdBO0lBQzVCLE9BQU87UUFDTG9DLGNBQWNELFVBQVNFLGVBQWUsSUFBSUYsVUFBU0UsZUFBZSxDQUFDQyxLQUFLLElBQUksb0JBQW9CSCxVQUFTRSxlQUFlLENBQUNDLEtBQUs7UUFDOUhDLE9BQU8sQ0FBQyxDQUFFLG1CQUFrQkwsV0FBVUEsUUFBT00sYUFBYSxJQUFJTCxxQkFBb0JELFFBQU9NLGFBQWE7SUFDeEc7QUFDRjtBQUNBLFNBQVNDO0lBQ1AsSUFBSSxDQUFDVCxTQUFTO1FBQ1pBLFVBQVVDO0lBQ1o7SUFDQSxPQUFPRDtBQUNUO0FBRUEsSUFBSVU7QUFDSixTQUFTQyxXQUFXQyxLQUFLO0lBQ3ZCLElBQUksWUFFQUEsQ0FBQUEsVUFBVSxLQUFLLElBQUksQ0FBQyxJQUFJQSxLQUFJLEVBRDlCQztJQUVGLElBQU1iLFVBQVVTO0lBQ2hCLElBQU1QLFVBQVNwQyxzREFBU0E7SUFDeEIsSUFBTWdELFdBQVdaLFFBQU9hLFNBQVMsQ0FBQ0QsUUFBUTtJQUMxQyxJQUFNRSxLQUFLSCxhQUFhWCxRQUFPYSxTQUFTLENBQUNGLFNBQVM7SUFDbEQsSUFBTUksU0FBUztRQUNiQyxLQUFLO1FBQ0xDLFNBQVM7SUFDWDtJQUNBLElBQU1DLGNBQWNsQixRQUFPbUIsTUFBTSxDQUFDQyxLQUFLO0lBQ3ZDLElBQU1DLGVBQWVyQixRQUFPbUIsTUFBTSxDQUFDRyxNQUFNO0lBQ3pDLElBQU1MLFVBQVVILEdBQUdTLEtBQUssQ0FBQyxnQ0FBZ0Msc0JBQXNCO0lBQy9FLElBQUlDLE9B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LENBQUNPLFdBQVcsRUFBRVIsT0FBT0MsU0FBUyxDQUFDTyxXQUFXLEdBQUcsRUFBRTtnQkFDcEUsSUFBTUQsVUFBVVAsT0FBT0MsU0FBUyxDQUFDTyxXQUFXO2dCQUM1QyxJQUFJLE9BQU9DLFFBQVEsY0FBY0YsUUFBUTdxQixPQUFPLENBQUMrcUIsT0FBTyxHQUFHO29CQUN6REYsUUFBUXRtQixJQUFJLENBQUN3bUI7Z0JBQ2Y7WUFDRjs7O1lBQ082QyxLQUFBQTttQkFBUCxTQUFPQSxJQUFJQyxNQUFNO2dCQUNmLElBQUk1bkIsTUFBTVksT0FBTyxDQUFDZ25CLFNBQVM7b0JBQ3pCQSxPQUFPdnJCLE9BQU8sQ0FBQ3dyQixTQUFBQTsrQkFBS3hELE9BQU9xRCxhQUFhLENBQUNHOztvQkFDekMsT0E5a0JBeEQ7Z0JBK2tCRjtnQkEva0JFQSxPQWdsQktxRCxhQUFhLENBQUNFO2dCQUNyQixPQWpsQkV2RDtZQWtsQko7OztXQWxsQklBOztBQW9sQk45aUIsT0FBT3FELElBQUksQ0FBQ3VmLFlBQVk5bkIsT0FBTyxDQUFDeXJCLFNBQUFBO0lBQzlCdm1CLE9BQU9xRCxJQUFJLENBQUN1ZixVQUFVLENBQUMyRCxlQUFlLEVBQUV6ckIsT0FBTyxDQUFDMHJCLFNBQUFBO1FBQzlDMUQsT0FBT0MsU0FBUyxDQUFDeUQsWUFBWSxHQUFHNUQsVUFBVSxDQUFDMkQsZUFBZSxDQUFDQyxZQUFZO0lBQ3pFO0FBQ0Y7QUFDQTFELE9BQU9zRCxHQUFHLENBQUM7SUFBQ3RzQjtJQUFRaUM7Q0FBUztBQUVTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zd2lwZXJAMTEuMS4zL25vZGVfbW9kdWxlcy9zd2lwZXIvc2hhcmVkL3N3aXBlci1jb3JlLm1qcz82Yzg0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGEgYXMgZ2V0V2luZG93LCBnIGFzIGdldERvY3VtZW50IH0gZnJvbSAnLi9zc3Itd2luZG93LmVzbS5tanMnO1xuaW1wb3J0IHsgYSBhcyBlbGVtZW50UGFyZW50cywgbyBhcyBlbGVtZW50U3R5bGUsIGUgYXMgZWxlbWVudENoaWxkcmVuLCBzIGFzIHNldENTU1Byb3BlcnR5LCBmIGFzIGVsZW1lbnRPdXRlclNpemUsIHAgYXMgZWxlbWVudE5leHRBbGwsIHEgYXMgZWxlbWVudFByZXZBbGwsIGogYXMgZ2V0VHJhbnNsYXRlLCByIGFzIGFuaW1hdGVDU1NNb2RlU2Nyb2xsLCBuIGFzIG5leHRUaWNrLCB0IGFzIHNob3dXYXJuaW5nLCBjIGFzIGNyZWF0ZUVsZW1lbnQsIGQgYXMgbm93LCB1IGFzIGV4dGVuZCwgaCBhcyBlbGVtZW50SW5kZXgsIHYgYXMgZGVsZXRlUHJvcHMgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5cbmxldCBzdXBwb3J0O1xuZnVuY3Rpb24gY2FsY1N1cHBvcnQoKSB7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gIHJldHVybiB7XG4gICAgc21vb3RoU2Nyb2xsOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmICdzY3JvbGxCZWhhdmlvcicgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLFxuICAgIHRvdWNoOiAhISgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaClcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFN1cHBvcnQoKSB7XG4gIGlmICghc3VwcG9ydCkge1xuICAgIHN1cHBvcnQgPSBjYWxjU3VwcG9ydCgpO1xuICB9XG4gIHJldHVybiBzdXBwb3J0O1xufVxuXG5sZXQgZGV2aWNlQ2FjaGVkO1xuZnVuY3Rpb24gY2FsY0RldmljZShfdGVtcCkge1xuICBsZXQge1xuICAgIHVzZXJBZ2VudFxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNvbnN0IHN1cHBvcnQgPSBnZXRTdXBwb3J0KCk7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICBjb25zdCBwbGF0Zm9ybSA9IHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm07XG4gIGNvbnN0IHVhID0gdXNlckFnZW50IHx8IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICBjb25zdCBkZXZpY2UgPSB7XG4gICAgaW9zOiBmYWxzZSxcbiAgICBhbmRyb2lkOiBmYWxzZVxuICB9O1xuICBjb25zdCBzY3JlZW5XaWR0aCA9IHdpbmRvdy5zY3JlZW4ud2lkdGg7XG4gIGNvbnN0IHNjcmVlbkhlaWdodCA9IHdpbmRvdy5zY3JlZW4uaGVpZ2h0O1xuICBjb25zdCBhbmRyb2lkID0gdWEubWF0Y2goLyhBbmRyb2lkKTs/W1xcc1xcL10rKFtcXGQuXSspPy8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGxldCBpcGFkID0gdWEubWF0Y2goLyhpUGFkKS4qT1NcXHMoW1xcZF9dKykvKTtcbiAgY29uc3QgaXBvZCA9IHVhLm1hdGNoKC8oaVBvZCkoLipPU1xccyhbXFxkX10rKSk/Lyk7XG4gIGNvbnN0IGlwaG9uZSA9ICFpcGFkICYmIHVhLm1hdGNoKC8oaVBob25lXFxzT1N8aU9TKVxccyhbXFxkX10rKS8pO1xuICBjb25zdCB3aW5kb3dzID0gcGxhdGZvcm0gPT09ICdXaW4zMic7XG4gIGxldCBtYWNvcyA9IHBsYXRmb3JtID09PSAnTWFjSW50ZWwnO1xuXG4gIC8vIGlQYWRPcyAxMyBmaXhcbiAgY29uc3QgaVBhZFNjcmVlbnMgPSBbJzEwMjR4MTM2NicsICcxMzY2eDEwMjQnLCAnODM0eDExOTQnLCAnMTE5NHg4MzQnLCAnODM0eDExMTInLCAnMTExMng4MzQnLCAnNzY4eDEwMjQnLCAnMTAyNHg3NjgnLCAnODIweDExODAnLCAnMTE4MHg4MjAnLCAnODEweDEwODAnLCAnMTA4MHg4MTAnXTtcbiAgaWYgKCFpcGFkICYmIG1hY29zICYmIHN1cHBvcnQudG91Y2ggJiYgaVBhZFNjcmVlbnMuaW5kZXhPZihgJHtzY3JlZW5XaWR0aH14JHtzY3JlZW5IZWlnaHR9YCkgPj0gMCkge1xuICAgIGlwYWQgPSB1YS5tYXRjaCgvKFZlcnNpb24pXFwvKFtcXGQuXSspLyk7XG4gICAgaWYgKCFpcGFkKSBpcGFkID0gWzAsIDEsICcxM18wXzAnXTtcbiAgICBtYWNvcyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gQW5kcm9pZFxuICBpZiAoYW5kcm9pZCAmJiAhd2luZG93cykge1xuICAgIGRldmljZS5vcyA9ICdhbmRyb2lkJztcbiAgICBkZXZpY2UuYW5kcm9pZCA9IHRydWU7XG4gIH1cbiAgaWYgKGlwYWQgfHwgaXBob25lIHx8IGlwb2QpIHtcbiAgICBkZXZpY2Uub3MgPSAnaW9zJztcbiAgICBkZXZpY2UuaW9zID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBvYmplY3RcbiAgcmV0dXJuIGRldmljZTtcbn1cbmZ1bmN0aW9uIGdldERldmljZShvdmVycmlkZXMpIHtcbiAgaWYgKG92ZXJyaWRlcyA9PT0gdm9pZCAwKSB7XG4gICAgb3ZlcnJpZGVzID0ge307XG4gIH1cbiAgaWYgKCFkZXZpY2VDYWNoZWQpIHtcbiAgICBkZXZpY2VDYWNoZWQgPSBjYWxjRGV2aWNlKG92ZXJyaWRlcyk7XG4gIH1cbiAgcmV0dXJuIGRldmljZUNhY2hlZDtcbn1cblxubGV0IGJyb3dzZXI7XG5mdW5jdGlvbiBjYWxjQnJvd3NlcigpIHtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gIGNvbnN0IGRldmljZSA9IGdldERldmljZSgpO1xuICBsZXQgbmVlZFBlcnNwZWN0aXZlRml4ID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICAgIGNvbnN0IHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gdWEuaW5kZXhPZignc2FmYXJpJykgPj0gMCAmJiB1YS5pbmRleE9mKCdjaHJvbWUnKSA8IDAgJiYgdWEuaW5kZXhPZignYW5kcm9pZCcpIDwgMDtcbiAgfVxuICBpZiAoaXNTYWZhcmkoKSkge1xuICAgIGNvbnN0IHVhID0gU3RyaW5nKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICBpZiAodWEuaW5jbHVkZXMoJ1ZlcnNpb24vJykpIHtcbiAgICAgIGNvbnN0IFttYWpvciwgbWlub3JdID0gdWEuc3BsaXQoJ1ZlcnNpb24vJylbMV0uc3BsaXQoJyAnKVswXS5zcGxpdCgnLicpLm1hcChudW0gPT4gTnVtYmVyKG51bSkpO1xuICAgICAgbmVlZFBlcnNwZWN0aXZlRml4ID0gbWFqb3IgPCAxNiB8fCBtYWpvciA9PT0gMTYgJiYgbWlub3IgPCAyO1xuICAgIH1cbiAgfVxuICBjb25zdCBpc1dlYlZpZXcgPSAvKGlQaG9uZXxpUG9kfGlQYWQpLipBcHBsZVdlYktpdCg/IS4qU2FmYXJpKS9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBjb25zdCBpc1NhZmFyaUJyb3dzZXIgPSBpc1NhZmFyaSgpO1xuICBjb25zdCBuZWVkM2RGaXggPSBpc1NhZmFyaUJyb3dzZXIgfHwgaXNXZWJWaWV3ICYmIGRldmljZS5pb3M7XG4gIHJldHVybiB7XG4gICAgaXNTYWZhcmk6IG5lZWRQZXJzcGVjdGl2ZUZpeCB8fCBpc1NhZmFyaUJyb3dzZXIsXG4gICAgbmVlZFBlcnNwZWN0aXZlRml4LFxuICAgIG5lZWQzZEZpeCxcbiAgICBpc1dlYlZpZXdcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEJyb3dzZXIoKSB7XG4gIGlmICghYnJvd3Nlcikge1xuICAgIGJyb3dzZXIgPSBjYWxjQnJvd3NlcigpO1xuICB9XG4gIHJldHVybiBicm93c2VyO1xufVxuXG5mdW5jdGlvbiBSZXNpemUoX3JlZikge1xuICBsZXQge1xuICAgIHN3aXBlcixcbiAgICBvbixcbiAgICBlbWl0XG4gIH0gPSBfcmVmO1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgbGV0IG9ic2VydmVyID0gbnVsbDtcbiAgbGV0IGFuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgY29uc3QgcmVzaXplSGFuZGxlciA9ICgpID0+IHtcbiAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFzd2lwZXIuaW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgICBlbWl0KCdiZWZvcmVSZXNpemUnKTtcbiAgICBlbWl0KCdyZXNpemUnKTtcbiAgfTtcbiAgY29uc3QgY3JlYXRlT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLmluaXRpYWxpemVkKSByZXR1cm47XG4gICAgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICBhbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0XG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgIGxldCBuZXdXaWR0aCA9IHdpZHRoO1xuICAgICAgICBsZXQgbmV3SGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goX3JlZjIgPT4ge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBjb250ZW50Qm94U2l6ZSxcbiAgICAgICAgICAgIGNvbnRlbnRSZWN0LFxuICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBzd2lwZXIuZWwpIHJldHVybjtcbiAgICAgICAgICBuZXdXaWR0aCA9IGNvbnRlbnRSZWN0ID8gY29udGVudFJlY3Qud2lkdGggOiAoY29udGVudEJveFNpemVbMF0gfHwgY29udGVudEJveFNpemUpLmlubGluZVNpemU7XG4gICAgICAgICAgbmV3SGVpZ2h0ID0gY29udGVudFJlY3QgPyBjb250ZW50UmVjdC5oZWlnaHQgOiAoY29udGVudEJveFNpemVbMF0gfHwgY29udGVudEJveFNpemUpLmJsb2NrU2l6ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdXaWR0aCAhPT0gd2lkdGggfHwgbmV3SGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICByZXNpemVIYW5kbGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoc3dpcGVyLmVsKTtcbiAgfTtcbiAgY29uc3QgcmVtb3ZlT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWUpO1xuICAgIH1cbiAgICBpZiAob2JzZXJ2ZXIgJiYgb2JzZXJ2ZXIudW5vYnNlcnZlICYmIHN3aXBlci5lbCkge1xuICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKHN3aXBlci5lbCk7XG4gICAgICBvYnNlcnZlciA9IG51bGw7XG4gICAgfVxuICB9O1xuICBjb25zdCBvcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLmluaXRpYWxpemVkKSByZXR1cm47XG4gICAgZW1pdCgnb3JpZW50YXRpb25jaGFuZ2UnKTtcbiAgfTtcbiAgb24oJ2luaXQnLCAoKSA9PiB7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMucmVzaXplT2JzZXJ2ZXIgJiYgdHlwZW9mIHdpbmRvdy5SZXNpemVPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNyZWF0ZU9ic2VydmVyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVIYW5kbGVyKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCBvcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIpO1xuICB9KTtcbiAgb24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgcmVtb3ZlT2JzZXJ2ZXIoKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgb3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIE9ic2VydmVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgZXh0ZW5kUGFyYW1zLFxuICAgIG9uLFxuICAgIGVtaXRcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IG9ic2VydmVycyA9IFtdO1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgY29uc3QgYXR0YWNoID0gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgT2JzZXJ2ZXJGdW5jID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYmtpdE11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2ZXJGdW5jKG11dGF0aW9ucyA9PiB7XG4gICAgICAvLyBUaGUgb2JzZXJ2ZXJVcGRhdGUgZXZlbnQgc2hvdWxkIG9ubHkgYmUgdHJpZ2dlcmVkXG4gICAgICAvLyBvbmNlIGRlc3BpdGUgdGhlIG51bWJlciBvZiBtdXRhdGlvbnMuICBBZGRpdGlvbmFsXG4gICAgICAvLyB0cmlnZ2VycyBhcmUgcmVkdW5kYW50IGFuZCBhcmUgdmVyeSBjb3N0bHlcbiAgICAgIGlmIChzd2lwZXIuX19wcmV2ZW50T2JzZXJ2ZXJfXykgcmV0dXJuO1xuICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZW1pdCgnb2JzZXJ2ZXJVcGRhdGUnLCBtdXRhdGlvbnNbMF0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvYnNlcnZlclVwZGF0ZSA9IGZ1bmN0aW9uIG9ic2VydmVyVXBkYXRlKCkge1xuICAgICAgICBlbWl0KCdvYnNlcnZlclVwZGF0ZScsIG11dGF0aW9uc1swXSk7XG4gICAgICB9O1xuICAgICAgaWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShvYnNlcnZlclVwZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChvYnNlcnZlclVwZGF0ZSwgMCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQsIHtcbiAgICAgIGF0dHJpYnV0ZXM6IHR5cGVvZiBvcHRpb25zLmF0dHJpYnV0ZXMgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMuYXR0cmlidXRlcyxcbiAgICAgIGNoaWxkTGlzdDogdHlwZW9mIG9wdGlvbnMuY2hpbGRMaXN0ID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBvcHRpb25zLmNoaWxkTGlzdCxcbiAgICAgIGNoYXJhY3RlckRhdGE6IHR5cGVvZiBvcHRpb25zLmNoYXJhY3RlckRhdGEgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMuY2hhcmFjdGVyRGF0YVxuICAgIH0pO1xuICAgIG9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgfTtcbiAgY29uc3QgaW5pdCA9ICgpID0+IHtcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMub2JzZXJ2ZXIpIHJldHVybjtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5vYnNlcnZlUGFyZW50cykge1xuICAgICAgY29uc3QgY29udGFpbmVyUGFyZW50cyA9IGVsZW1lbnRQYXJlbnRzKHN3aXBlci5ob3N0RWwpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250YWluZXJQYXJlbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGF0dGFjaChjb250YWluZXJQYXJlbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gT2JzZXJ2ZSBjb250YWluZXJcbiAgICBhdHRhY2goc3dpcGVyLmhvc3RFbCwge1xuICAgICAgY2hpbGRMaXN0OiBzd2lwZXIucGFyYW1zLm9ic2VydmVTbGlkZUNoaWxkcmVuXG4gICAgfSk7XG5cbiAgICAvLyBPYnNlcnZlIHdyYXBwZXJcbiAgICBhdHRhY2goc3dpcGVyLndyYXBwZXJFbCwge1xuICAgICAgYXR0cmlidXRlczogZmFsc2VcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcbiAgICBvYnNlcnZlcnMuZm9yRWFjaChvYnNlcnZlciA9PiB7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXJzLnNwbGljZSgwLCBvYnNlcnZlcnMubGVuZ3RoKTtcbiAgfTtcbiAgZXh0ZW5kUGFyYW1zKHtcbiAgICBvYnNlcnZlcjogZmFsc2UsXG4gICAgb2JzZXJ2ZVBhcmVudHM6IGZhbHNlLFxuICAgIG9ic2VydmVTbGlkZUNoaWxkcmVuOiBmYWxzZVxuICB9KTtcbiAgb24oJ2luaXQnLCBpbml0KTtcbiAgb24oJ2Rlc3Ryb3knLCBkZXN0cm95KTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cblxudmFyIGV2ZW50c0VtaXR0ZXIgPSB7XG4gIG9uKGV2ZW50cywgaGFuZGxlciwgcHJpb3JpdHkpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHJldHVybiBzZWxmO1xuICAgIGNvbnN0IG1ldGhvZCA9IHByaW9yaXR5ID8gJ3Vuc2hpZnQnIDogJ3B1c2gnO1xuICAgIGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgaWYgKCFzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0pIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdW21ldGhvZF0oaGFuZGxlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG4gIG9uY2UoZXZlbnRzLCBoYW5kbGVyLCBwcmlvcml0eSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5ldmVudHNMaXN0ZW5lcnMgfHwgc2VsZi5kZXN0cm95ZWQpIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHNlbGY7XG4gICAgZnVuY3Rpb24gb25jZUhhbmRsZXIoKSB7XG4gICAgICBzZWxmLm9mZihldmVudHMsIG9uY2VIYW5kbGVyKTtcbiAgICAgIGlmIChvbmNlSGFuZGxlci5fX2VtaXR0ZXJQcm94eSkge1xuICAgICAgICBkZWxldGUgb25jZUhhbmRsZXIuX19lbWl0dGVyUHJveHk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuICAgIG9uY2VIYW5kbGVyLl9fZW1pdHRlclByb3h5ID0gaGFuZGxlcjtcbiAgICByZXR1cm4gc2VsZi5vbihldmVudHMsIG9uY2VIYW5kbGVyLCBwcmlvcml0eSk7XG4gIH0sXG4gIG9uQW55KGhhbmRsZXIsIHByaW9yaXR5KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLmV2ZW50c0xpc3RlbmVycyB8fCBzZWxmLmRlc3Ryb3llZCkgcmV0dXJuIHNlbGY7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gc2VsZjtcbiAgICBjb25zdCBtZXRob2QgPSBwcmlvcml0eSA/ICd1bnNoaWZ0JyA6ICdwdXNoJztcbiAgICBpZiAoc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuaW5kZXhPZihoYW5kbGVyKSA8IDApIHtcbiAgICAgIHNlbGYuZXZlbnRzQW55TGlzdGVuZXJzW21ldGhvZF0oaGFuZGxlcik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xuICB9LFxuICBvZmZBbnkoaGFuZGxlcikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5ldmVudHNMaXN0ZW5lcnMgfHwgc2VsZi5kZXN0cm95ZWQpIHJldHVybiBzZWxmO1xuICAgIGlmICghc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMpIHJldHVybiBzZWxmO1xuICAgIGNvbnN0IGluZGV4ID0gc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG4gIG9mZihldmVudHMsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzKSByZXR1cm4gc2VsZjtcbiAgICBldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0uZm9yRWFjaCgoZXZlbnRIYW5kbGVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChldmVudEhhbmRsZXIgPT09IGhhbmRsZXIgfHwgZXZlbnRIYW5kbGVyLl9fZW1pdHRlclByb3h5ICYmIGV2ZW50SGFuZGxlci5fX2VtaXR0ZXJQcm94eSA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcbiAgZW1pdCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzKSByZXR1cm4gc2VsZjtcbiAgICBsZXQgZXZlbnRzO1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBjb250ZXh0O1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgIGV2ZW50cyA9IGFyZ3NbMF07XG4gICAgICBkYXRhID0gYXJncy5zbGljZSgxLCBhcmdzLmxlbmd0aCk7XG4gICAgICBjb250ZXh0ID0gc2VsZjtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnRzID0gYXJnc1swXS5ldmVudHM7XG4gICAgICBkYXRhID0gYXJnc1swXS5kYXRhO1xuICAgICAgY29udGV4dCA9IGFyZ3NbMF0uY29udGV4dCB8fCBzZWxmO1xuICAgIH1cbiAgICBkYXRhLnVuc2hpZnQoY29udGV4dCk7XG4gICAgY29uc3QgZXZlbnRzQXJyYXkgPSBBcnJheS5pc0FycmF5KGV2ZW50cykgPyBldmVudHMgOiBldmVudHMuc3BsaXQoJyAnKTtcbiAgICBldmVudHNBcnJheS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIGlmIChzZWxmLmV2ZW50c0FueUxpc3RlbmVycyAmJiBzZWxmLmV2ZW50c0FueUxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuZm9yRWFjaChldmVudEhhbmRsZXIgPT4ge1xuICAgICAgICAgIGV2ZW50SGFuZGxlci5hcHBseShjb250ZXh0LCBbZXZlbnQsIC4uLmRhdGFdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5ldmVudHNMaXN0ZW5lcnMgJiYgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XS5mb3JFYWNoKGV2ZW50SGFuZGxlciA9PiB7XG4gICAgICAgICAgZXZlbnRIYW5kbGVyLmFwcGx5KGNvbnRleHQsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlU2l6ZSgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgbGV0IHdpZHRoO1xuICBsZXQgaGVpZ2h0O1xuICBjb25zdCBlbCA9IHN3aXBlci5lbDtcbiAgaWYgKHR5cGVvZiBzd2lwZXIucGFyYW1zLndpZHRoICE9PSAndW5kZWZpbmVkJyAmJiBzd2lwZXIucGFyYW1zLndpZHRoICE9PSBudWxsKSB7XG4gICAgd2lkdGggPSBzd2lwZXIucGFyYW1zLndpZHRoO1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gZWwuY2xpZW50V2lkdGg7XG4gIH1cbiAgaWYgKHR5cGVvZiBzd2lwZXIucGFyYW1zLmhlaWdodCAhPT0gJ3VuZGVmaW5lZCcgJiYgc3dpcGVyLnBhcmFtcy5oZWlnaHQgIT09IG51bGwpIHtcbiAgICBoZWlnaHQgPSBzd2lwZXIucGFyYW1zLmhlaWdodDtcbiAgfSBlbHNlIHtcbiAgICBoZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQ7XG4gIH1cbiAgaWYgKHdpZHRoID09PSAwICYmIHN3aXBlci5pc0hvcml6b250YWwoKSB8fCBoZWlnaHQgPT09IDAgJiYgc3dpcGVyLmlzVmVydGljYWwoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFN1YnRyYWN0IHBhZGRpbmdzXG4gIHdpZHRoID0gd2lkdGggLSBwYXJzZUludChlbGVtZW50U3R5bGUoZWwsICdwYWRkaW5nLWxlZnQnKSB8fCAwLCAxMCkgLSBwYXJzZUludChlbGVtZW50U3R5bGUoZWwsICdwYWRkaW5nLXJpZ2h0JykgfHwgMCwgMTApO1xuICBoZWlnaHQgPSBoZWlnaHQgLSBwYXJzZUludChlbGVtZW50U3R5bGUoZWwsICdwYWRkaW5nLXRvcCcpIHx8IDAsIDEwKSAtIHBhcnNlSW50KGVsZW1lbnRTdHlsZShlbCwgJ3BhZGRpbmctYm90dG9tJykgfHwgMCwgMTApO1xuICBpZiAoTnVtYmVyLmlzTmFOKHdpZHRoKSkgd2lkdGggPSAwO1xuICBpZiAoTnVtYmVyLmlzTmFOKGhlaWdodCkpIGhlaWdodCA9IDA7XG4gIE9iamVjdC5hc3NpZ24oc3dpcGVyLCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHNpemU6IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHdpZHRoIDogaGVpZ2h0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTbGlkZXMoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGZ1bmN0aW9uIGdldERpcmVjdGlvblByb3BlcnR5VmFsdWUobm9kZSwgbGFiZWwpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChub2RlLmdldFByb3BlcnR5VmFsdWUoc3dpcGVyLmdldERpcmVjdGlvbkxhYmVsKGxhYmVsKSkgfHwgMCk7XG4gIH1cbiAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcbiAgY29uc3Qge1xuICAgIHdyYXBwZXJFbCxcbiAgICBzbGlkZXNFbCxcbiAgICBzaXplOiBzd2lwZXJTaXplLFxuICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgIHdyb25nUlRMXG4gIH0gPSBzd2lwZXI7XG4gIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7XG4gIGNvbnN0IHByZXZpb3VzU2xpZGVzTGVuZ3RoID0gaXNWaXJ0dWFsID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IHN3aXBlci5zbGlkZXMubGVuZ3RoO1xuICBjb25zdCBzbGlkZXMgPSBlbGVtZW50Q2hpbGRyZW4oc2xpZGVzRWwsIGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9LCBzd2lwZXItc2xpZGVgKTtcbiAgY29uc3Qgc2xpZGVzTGVuZ3RoID0gaXNWaXJ0dWFsID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IHNsaWRlcy5sZW5ndGg7XG4gIGxldCBzbmFwR3JpZCA9IFtdO1xuICBjb25zdCBzbGlkZXNHcmlkID0gW107XG4gIGNvbnN0IHNsaWRlc1NpemVzR3JpZCA9IFtdO1xuICBsZXQgb2Zmc2V0QmVmb3JlID0gcGFyYW1zLnNsaWRlc09mZnNldEJlZm9yZTtcbiAgaWYgKHR5cGVvZiBvZmZzZXRCZWZvcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvZmZzZXRCZWZvcmUgPSBwYXJhbXMuc2xpZGVzT2Zmc2V0QmVmb3JlLmNhbGwoc3dpcGVyKTtcbiAgfVxuICBsZXQgb2Zmc2V0QWZ0ZXIgPSBwYXJhbXMuc2xpZGVzT2Zmc2V0QWZ0ZXI7XG4gIGlmICh0eXBlb2Ygb2Zmc2V0QWZ0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvZmZzZXRBZnRlciA9IHBhcmFtcy5zbGlkZXNPZmZzZXRBZnRlci5jYWxsKHN3aXBlcik7XG4gIH1cbiAgY29uc3QgcHJldmlvdXNTbmFwR3JpZExlbmd0aCA9IHN3aXBlci5zbmFwR3JpZC5sZW5ndGg7XG4gIGNvbnN0IHByZXZpb3VzU2xpZGVzR3JpZExlbmd0aCA9IHN3aXBlci5zbGlkZXNHcmlkLmxlbmd0aDtcbiAgbGV0IHNwYWNlQmV0d2VlbiA9IHBhcmFtcy5zcGFjZUJldHdlZW47XG4gIGxldCBzbGlkZVBvc2l0aW9uID0gLW9mZnNldEJlZm9yZTtcbiAgbGV0IHByZXZTbGlkZVNpemUgPSAwO1xuICBsZXQgaW5kZXggPSAwO1xuICBpZiAodHlwZW9mIHN3aXBlclNpemUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2Ygc3BhY2VCZXR3ZWVuID09PSAnc3RyaW5nJyAmJiBzcGFjZUJldHdlZW4uaW5kZXhPZignJScpID49IDApIHtcbiAgICBzcGFjZUJldHdlZW4gPSBwYXJzZUZsb2F0KHNwYWNlQmV0d2Vlbi5yZXBsYWNlKCclJywgJycpKSAvIDEwMCAqIHN3aXBlclNpemU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNwYWNlQmV0d2VlbiA9PT0gJ3N0cmluZycpIHtcbiAgICBzcGFjZUJldHdlZW4gPSBwYXJzZUZsb2F0KHNwYWNlQmV0d2Vlbik7XG4gIH1cbiAgc3dpcGVyLnZpcnR1YWxTaXplID0gLXNwYWNlQmV0d2VlbjtcblxuICAvLyByZXNldCBtYXJnaW5zXG4gIHNsaWRlcy5mb3JFYWNoKHNsaWRlRWwgPT4ge1xuICAgIGlmIChydGwpIHtcbiAgICAgIHNsaWRlRWwuc3R5bGUubWFyZ2luTGVmdCA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzbGlkZUVsLnN0eWxlLm1hcmdpblJpZ2h0ID0gJyc7XG4gICAgfVxuICAgIHNsaWRlRWwuc3R5bGUubWFyZ2luQm90dG9tID0gJyc7XG4gICAgc2xpZGVFbC5zdHlsZS5tYXJnaW5Ub3AgPSAnJztcbiAgfSk7XG5cbiAgLy8gcmVzZXQgY3NzTW9kZSBvZmZzZXRzXG4gIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgcGFyYW1zLmNzc01vZGUpIHtcbiAgICBzZXRDU1NQcm9wZXJ0eSh3cmFwcGVyRWwsICctLXN3aXBlci1jZW50ZXJlZC1vZmZzZXQtYmVmb3JlJywgJycpO1xuICAgIHNldENTU1Byb3BlcnR5KHdyYXBwZXJFbCwgJy0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1hZnRlcicsICcnKTtcbiAgfVxuICBjb25zdCBncmlkRW5hYmxlZCA9IHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxICYmIHN3aXBlci5ncmlkO1xuICBpZiAoZ3JpZEVuYWJsZWQpIHtcbiAgICBzd2lwZXIuZ3JpZC5pbml0U2xpZGVzKHNsaWRlcyk7XG4gIH0gZWxzZSBpZiAoc3dpcGVyLmdyaWQpIHtcbiAgICBzd2lwZXIuZ3JpZC51bnNldFNsaWRlcygpO1xuICB9XG5cbiAgLy8gQ2FsYyBzbGlkZXNcbiAgbGV0IHNsaWRlU2l6ZTtcbiAgY29uc3Qgc2hvdWxkUmVzZXRTbGlkZVNpemUgPSBwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nICYmIHBhcmFtcy5icmVha3BvaW50cyAmJiBPYmplY3Qua2V5cyhwYXJhbXMuYnJlYWtwb2ludHMpLmZpbHRlcihrZXkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgcGFyYW1zLmJyZWFrcG9pbnRzW2tleV0uc2xpZGVzUGVyVmlldyAhPT0gJ3VuZGVmaW5lZCc7XG4gIH0pLmxlbmd0aCA+IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzTGVuZ3RoOyBpICs9IDEpIHtcbiAgICBzbGlkZVNpemUgPSAwO1xuICAgIGxldCBzbGlkZTtcbiAgICBpZiAoc2xpZGVzW2ldKSBzbGlkZSA9IHNsaWRlc1tpXTtcbiAgICBpZiAoZ3JpZEVuYWJsZWQpIHtcbiAgICAgIHN3aXBlci5ncmlkLnVwZGF0ZVNsaWRlKGksIHNsaWRlLCBzbGlkZXMpO1xuICAgIH1cbiAgICBpZiAoc2xpZGVzW2ldICYmIGVsZW1lbnRTdHlsZShzbGlkZSwgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnKSBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgaWYgKHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycpIHtcbiAgICAgIGlmIChzaG91bGRSZXNldFNsaWRlU2l6ZSkge1xuICAgICAgICBzbGlkZXNbaV0uc3R5bGVbc3dpcGVyLmdldERpcmVjdGlvbkxhYmVsKCd3aWR0aCcpXSA9IGBgO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2xpZGVTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKHNsaWRlKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBzbGlkZS5zdHlsZS50cmFuc2Zvcm07XG4gICAgICBjb25zdCBjdXJyZW50V2ViS2l0VHJhbnNmb3JtID0gc2xpZGUuc3R5bGUud2Via2l0VHJhbnNmb3JtO1xuICAgICAgaWYgKGN1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgc2xpZGUuc3R5bGUudHJhbnNmb3JtID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRXZWJLaXRUcmFuc2Zvcm0pIHtcbiAgICAgICAgc2xpZGUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHtcbiAgICAgICAgc2xpZGVTaXplID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gZWxlbWVudE91dGVyU2l6ZShzbGlkZSwgJ3dpZHRoJywgdHJ1ZSkgOiBlbGVtZW50T3V0ZXJTaXplKHNsaWRlLCAnaGVpZ2h0JywgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgY29uc3Qgd2lkdGggPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAnd2lkdGgnKTtcbiAgICAgICAgY29uc3QgcGFkZGluZ0xlZnQgPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAncGFkZGluZy1sZWZ0Jyk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdSaWdodCA9IGdldERpcmVjdGlvblByb3BlcnR5VmFsdWUoc2xpZGVTdHlsZXMsICdwYWRkaW5nLXJpZ2h0Jyk7XG4gICAgICAgIGNvbnN0IG1hcmdpbkxlZnQgPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAnbWFyZ2luLWxlZnQnKTtcbiAgICAgICAgY29uc3QgbWFyZ2luUmlnaHQgPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAnbWFyZ2luLXJpZ2h0Jyk7XG4gICAgICAgIGNvbnN0IGJveFNpemluZyA9IHNsaWRlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ2JveC1zaXppbmcnKTtcbiAgICAgICAgaWYgKGJveFNpemluZyAmJiBib3hTaXppbmcgPT09ICdib3JkZXItYm94Jykge1xuICAgICAgICAgIHNsaWRlU2l6ZSA9IHdpZHRoICsgbWFyZ2luTGVmdCArIG1hcmdpblJpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNsaWVudFdpZHRoLFxuICAgICAgICAgICAgb2Zmc2V0V2lkdGhcbiAgICAgICAgICB9ID0gc2xpZGU7XG4gICAgICAgICAgc2xpZGVTaXplID0gd2lkdGggKyBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodCArIG1hcmdpbkxlZnQgKyBtYXJnaW5SaWdodCArIChvZmZzZXRXaWR0aCAtIGNsaWVudFdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgc2xpZGUuc3R5bGUudHJhbnNmb3JtID0gY3VycmVudFRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50V2ViS2l0VHJhbnNmb3JtKSB7XG4gICAgICAgIHNsaWRlLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IGN1cnJlbnRXZWJLaXRUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykgc2xpZGVTaXplID0gTWF0aC5mbG9vcihzbGlkZVNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzbGlkZVNpemUgPSAoc3dpcGVyU2l6ZSAtIChwYXJhbXMuc2xpZGVzUGVyVmlldyAtIDEpICogc3BhY2VCZXR3ZWVuKSAvIHBhcmFtcy5zbGlkZXNQZXJWaWV3O1xuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlU2l6ZSA9IE1hdGguZmxvb3Ioc2xpZGVTaXplKTtcbiAgICAgIGlmIChzbGlkZXNbaV0pIHtcbiAgICAgICAgc2xpZGVzW2ldLnN0eWxlW3N3aXBlci5nZXREaXJlY3Rpb25MYWJlbCgnd2lkdGgnKV0gPSBgJHtzbGlkZVNpemV9cHhgO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2xpZGVzW2ldKSB7XG4gICAgICBzbGlkZXNbaV0uc3dpcGVyU2xpZGVTaXplID0gc2xpZGVTaXplO1xuICAgIH1cbiAgICBzbGlkZXNTaXplc0dyaWQucHVzaChzbGlkZVNpemUpO1xuICAgIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgIHNsaWRlUG9zaXRpb24gPSBzbGlkZVBvc2l0aW9uICsgc2xpZGVTaXplIC8gMiArIHByZXZTbGlkZVNpemUgLyAyICsgc3BhY2VCZXR3ZWVuO1xuICAgICAgaWYgKHByZXZTbGlkZVNpemUgPT09IDAgJiYgaSAhPT0gMCkgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gLSBzd2lwZXJTaXplIC8gMiAtIHNwYWNlQmV0d2VlbjtcbiAgICAgIGlmIChpID09PSAwKSBzbGlkZVBvc2l0aW9uID0gc2xpZGVQb3NpdGlvbiAtIHN3aXBlclNpemUgLyAyIC0gc3BhY2VCZXR3ZWVuO1xuICAgICAgaWYgKE1hdGguYWJzKHNsaWRlUG9zaXRpb24pIDwgMSAvIDEwMDApIHNsaWRlUG9zaXRpb24gPSAwO1xuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlUG9zaXRpb24gPSBNYXRoLmZsb29yKHNsaWRlUG9zaXRpb24pO1xuICAgICAgaWYgKGluZGV4ICUgcGFyYW1zLnNsaWRlc1Blckdyb3VwID09PSAwKSBzbmFwR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgICAgc2xpZGVzR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykgc2xpZGVQb3NpdGlvbiA9IE1hdGguZmxvb3Ioc2xpZGVQb3NpdGlvbik7XG4gICAgICBpZiAoKGluZGV4IC0gTWF0aC5taW4oc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIGluZGV4KSkgJSBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwID09PSAwKSBzbmFwR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgICAgc2xpZGVzR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgICAgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gKyBzbGlkZVNpemUgKyBzcGFjZUJldHdlZW47XG4gICAgfVxuICAgIHN3aXBlci52aXJ0dWFsU2l6ZSArPSBzbGlkZVNpemUgKyBzcGFjZUJldHdlZW47XG4gICAgcHJldlNsaWRlU2l6ZSA9IHNsaWRlU2l6ZTtcbiAgICBpbmRleCArPSAxO1xuICB9XG4gIHN3aXBlci52aXJ0dWFsU2l6ZSA9IE1hdGgubWF4KHN3aXBlci52aXJ0dWFsU2l6ZSwgc3dpcGVyU2l6ZSkgKyBvZmZzZXRBZnRlcjtcbiAgaWYgKHJ0bCAmJiB3cm9uZ1JUTCAmJiAocGFyYW1zLmVmZmVjdCA9PT0gJ3NsaWRlJyB8fCBwYXJhbXMuZWZmZWN0ID09PSAnY292ZXJmbG93JykpIHtcbiAgICB3cmFwcGVyRWwuc3R5bGUud2lkdGggPSBgJHtzd2lwZXIudmlydHVhbFNpemUgKyBzcGFjZUJldHdlZW59cHhgO1xuICB9XG4gIGlmIChwYXJhbXMuc2V0V3JhcHBlclNpemUpIHtcbiAgICB3cmFwcGVyRWwuc3R5bGVbc3dpcGVyLmdldERpcmVjdGlvbkxhYmVsKCd3aWR0aCcpXSA9IGAke3N3aXBlci52aXJ0dWFsU2l6ZSArIHNwYWNlQmV0d2Vlbn1weGA7XG4gIH1cbiAgaWYgKGdyaWRFbmFibGVkKSB7XG4gICAgc3dpcGVyLmdyaWQudXBkYXRlV3JhcHBlclNpemUoc2xpZGVTaXplLCBzbmFwR3JpZCk7XG4gIH1cblxuICAvLyBSZW1vdmUgbGFzdCBncmlkIGVsZW1lbnRzIGRlcGVuZGluZyBvbiB3aWR0aFxuICBpZiAoIXBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgIGNvbnN0IG5ld1NsaWRlc0dyaWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNuYXBHcmlkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBsZXQgc2xpZGVzR3JpZEl0ZW0gPSBzbmFwR3JpZFtpXTtcbiAgICAgIGlmIChwYXJhbXMucm91bmRMZW5ndGhzKSBzbGlkZXNHcmlkSXRlbSA9IE1hdGguZmxvb3Ioc2xpZGVzR3JpZEl0ZW0pO1xuICAgICAgaWYgKHNuYXBHcmlkW2ldIDw9IHN3aXBlci52aXJ0dWFsU2l6ZSAtIHN3aXBlclNpemUpIHtcbiAgICAgICAgbmV3U2xpZGVzR3JpZC5wdXNoKHNsaWRlc0dyaWRJdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc25hcEdyaWQgPSBuZXdTbGlkZXNHcmlkO1xuICAgIGlmIChNYXRoLmZsb29yKHN3aXBlci52aXJ0dWFsU2l6ZSAtIHN3aXBlclNpemUpIC0gTWF0aC5mbG9vcihzbmFwR3JpZFtzbmFwR3JpZC5sZW5ndGggLSAxXSkgPiAxKSB7XG4gICAgICBzbmFwR3JpZC5wdXNoKHN3aXBlci52aXJ0dWFsU2l6ZSAtIHN3aXBlclNpemUpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNWaXJ0dWFsICYmIHBhcmFtcy5sb29wKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHNsaWRlc1NpemVzR3JpZFswXSArIHNwYWNlQmV0d2VlbjtcbiAgICBpZiAocGFyYW1zLnNsaWRlc1Blckdyb3VwID4gMSkge1xuICAgICAgY29uc3QgZ3JvdXBzID0gTWF0aC5jZWlsKChzd2lwZXIudmlydHVhbC5zbGlkZXNCZWZvcmUgKyBzd2lwZXIudmlydHVhbC5zbGlkZXNBZnRlcikgLyBwYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuICAgICAgY29uc3QgZ3JvdXBTaXplID0gc2l6ZSAqIHBhcmFtcy5zbGlkZXNQZXJHcm91cDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzOyBpICs9IDEpIHtcbiAgICAgICAgc25hcEdyaWQucHVzaChzbmFwR3JpZFtzbmFwR3JpZC5sZW5ndGggLSAxXSArIGdyb3VwU2l6ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3dpcGVyLnZpcnR1YWwuc2xpZGVzQmVmb3JlICsgc3dpcGVyLnZpcnR1YWwuc2xpZGVzQWZ0ZXI7IGkgKz0gMSkge1xuICAgICAgaWYgKHBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PT0gMSkge1xuICAgICAgICBzbmFwR3JpZC5wdXNoKHNuYXBHcmlkW3NuYXBHcmlkLmxlbmd0aCAtIDFdICsgc2l6ZSk7XG4gICAgICB9XG4gICAgICBzbGlkZXNHcmlkLnB1c2goc2xpZGVzR3JpZFtzbGlkZXNHcmlkLmxlbmd0aCAtIDFdICsgc2l6ZSk7XG4gICAgICBzd2lwZXIudmlydHVhbFNpemUgKz0gc2l6ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHNuYXBHcmlkLmxlbmd0aCA9PT0gMCkgc25hcEdyaWQgPSBbMF07XG4gIGlmIChzcGFjZUJldHdlZW4gIT09IDApIHtcbiAgICBjb25zdCBrZXkgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgJiYgcnRsID8gJ21hcmdpbkxlZnQnIDogc3dpcGVyLmdldERpcmVjdGlvbkxhYmVsKCdtYXJnaW5SaWdodCcpO1xuICAgIHNsaWRlcy5maWx0ZXIoKF8sIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgIGlmICghcGFyYW1zLmNzc01vZGUgfHwgcGFyYW1zLmxvb3ApIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHNsaWRlSW5kZXggPT09IHNsaWRlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pLmZvckVhY2goc2xpZGVFbCA9PiB7XG4gICAgICBzbGlkZUVsLnN0eWxlW2tleV0gPSBgJHtzcGFjZUJldHdlZW59cHhgO1xuICAgIH0pO1xuICB9XG4gIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgcGFyYW1zLmNlbnRlcmVkU2xpZGVzQm91bmRzKSB7XG4gICAgbGV0IGFsbFNsaWRlc1NpemUgPSAwO1xuICAgIHNsaWRlc1NpemVzR3JpZC5mb3JFYWNoKHNsaWRlU2l6ZVZhbHVlID0+IHtcbiAgICAgIGFsbFNsaWRlc1NpemUgKz0gc2xpZGVTaXplVmFsdWUgKyAoc3BhY2VCZXR3ZWVuIHx8IDApO1xuICAgIH0pO1xuICAgIGFsbFNsaWRlc1NpemUgLT0gc3BhY2VCZXR3ZWVuO1xuICAgIGNvbnN0IG1heFNuYXAgPSBhbGxTbGlkZXNTaXplIC0gc3dpcGVyU2l6ZTtcbiAgICBzbmFwR3JpZCA9IHNuYXBHcmlkLm1hcChzbmFwID0+IHtcbiAgICAgIGlmIChzbmFwIDw9IDApIHJldHVybiAtb2Zmc2V0QmVmb3JlO1xuICAgICAgaWYgKHNuYXAgPiBtYXhTbmFwKSByZXR1cm4gbWF4U25hcCArIG9mZnNldEFmdGVyO1xuICAgICAgcmV0dXJuIHNuYXA7XG4gICAgfSk7XG4gIH1cbiAgaWYgKHBhcmFtcy5jZW50ZXJJbnN1ZmZpY2llbnRTbGlkZXMpIHtcbiAgICBsZXQgYWxsU2xpZGVzU2l6ZSA9IDA7XG4gICAgc2xpZGVzU2l6ZXNHcmlkLmZvckVhY2goc2xpZGVTaXplVmFsdWUgPT4ge1xuICAgICAgYWxsU2xpZGVzU2l6ZSArPSBzbGlkZVNpemVWYWx1ZSArIChzcGFjZUJldHdlZW4gfHwgMCk7XG4gICAgfSk7XG4gICAgYWxsU2xpZGVzU2l6ZSAtPSBzcGFjZUJldHdlZW47XG4gICAgY29uc3Qgb2Zmc2V0U2l6ZSA9IChwYXJhbXMuc2xpZGVzT2Zmc2V0QmVmb3JlIHx8IDApICsgKHBhcmFtcy5zbGlkZXNPZmZzZXRBZnRlciB8fCAwKTtcbiAgICBpZiAoYWxsU2xpZGVzU2l6ZSArIG9mZnNldFNpemUgPCBzd2lwZXJTaXplKSB7XG4gICAgICBjb25zdCBhbGxTbGlkZXNPZmZzZXQgPSAoc3dpcGVyU2l6ZSAtIGFsbFNsaWRlc1NpemUgLSBvZmZzZXRTaXplKSAvIDI7XG4gICAgICBzbmFwR3JpZC5mb3JFYWNoKChzbmFwLCBzbmFwSW5kZXgpID0+IHtcbiAgICAgICAgc25hcEdyaWRbc25hcEluZGV4XSA9IHNuYXAgLSBhbGxTbGlkZXNPZmZzZXQ7XG4gICAgICB9KTtcbiAgICAgIHNsaWRlc0dyaWQuZm9yRWFjaCgoc25hcCwgc25hcEluZGV4KSA9PiB7XG4gICAgICAgIHNsaWRlc0dyaWRbc25hcEluZGV4XSA9IHNuYXAgKyBhbGxTbGlkZXNPZmZzZXQ7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICBzbGlkZXMsXG4gICAgc25hcEdyaWQsXG4gICAgc2xpZGVzR3JpZCxcbiAgICBzbGlkZXNTaXplc0dyaWRcbiAgfSk7XG4gIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgcGFyYW1zLmNzc01vZGUgJiYgIXBhcmFtcy5jZW50ZXJlZFNsaWRlc0JvdW5kcykge1xuICAgIHNldENTU1Byb3BlcnR5KHdyYXBwZXJFbCwgJy0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1iZWZvcmUnLCBgJHstc25hcEdyaWRbMF19cHhgKTtcbiAgICBzZXRDU1NQcm9wZXJ0eSh3cmFwcGVyRWwsICctLXN3aXBlci1jZW50ZXJlZC1vZmZzZXQtYWZ0ZXInLCBgJHtzd2lwZXIuc2l6ZSAvIDIgLSBzbGlkZXNTaXplc0dyaWRbc2xpZGVzU2l6ZXNHcmlkLmxlbmd0aCAtIDFdIC8gMn1weGApO1xuICAgIGNvbnN0IGFkZFRvU25hcEdyaWQgPSAtc3dpcGVyLnNuYXBHcmlkWzBdO1xuICAgIGNvbnN0IGFkZFRvU2xpZGVzR3JpZCA9IC1zd2lwZXIuc2xpZGVzR3JpZFswXTtcbiAgICBzd2lwZXIuc25hcEdyaWQgPSBzd2lwZXIuc25hcEdyaWQubWFwKHYgPT4gdiArIGFkZFRvU25hcEdyaWQpO1xuICAgIHN3aXBlci5zbGlkZXNHcmlkID0gc3dpcGVyLnNsaWRlc0dyaWQubWFwKHYgPT4gdiArIGFkZFRvU2xpZGVzR3JpZCk7XG4gIH1cbiAgaWYgKHNsaWRlc0xlbmd0aCAhPT0gcHJldmlvdXNTbGlkZXNMZW5ndGgpIHtcbiAgICBzd2lwZXIuZW1pdCgnc2xpZGVzTGVuZ3RoQ2hhbmdlJyk7XG4gIH1cbiAgaWYgKHNuYXBHcmlkLmxlbmd0aCAhPT0gcHJldmlvdXNTbmFwR3JpZExlbmd0aCkge1xuICAgIGlmIChzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cpIHN3aXBlci5jaGVja092ZXJmbG93KCk7XG4gICAgc3dpcGVyLmVtaXQoJ3NuYXBHcmlkTGVuZ3RoQ2hhbmdlJyk7XG4gIH1cbiAgaWYgKHNsaWRlc0dyaWQubGVuZ3RoICE9PSBwcmV2aW91c1NsaWRlc0dyaWRMZW5ndGgpIHtcbiAgICBzd2lwZXIuZW1pdCgnc2xpZGVzR3JpZExlbmd0aENoYW5nZScpO1xuICB9XG4gIGlmIChwYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcykge1xuICAgIHN3aXBlci51cGRhdGVTbGlkZXNPZmZzZXQoKTtcbiAgfVxuICBzd2lwZXIuZW1pdCgnc2xpZGVzVXBkYXRlZCcpO1xuICBpZiAoIWlzVmlydHVhbCAmJiAhcGFyYW1zLmNzc01vZGUgJiYgKHBhcmFtcy5lZmZlY3QgPT09ICdzbGlkZScgfHwgcGFyYW1zLmVmZmVjdCA9PT0gJ2ZhZGUnKSkge1xuICAgIGNvbnN0IGJhY2tGYWNlSGlkZGVuQ2xhc3MgPSBgJHtwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31iYWNrZmFjZS1oaWRkZW5gO1xuICAgIGNvbnN0IGhhc0NsYXNzQmFja2ZhY2VDbGFzc0FkZGVkID0gc3dpcGVyLmVsLmNsYXNzTGlzdC5jb250YWlucyhiYWNrRmFjZUhpZGRlbkNsYXNzKTtcbiAgICBpZiAoc2xpZGVzTGVuZ3RoIDw9IHBhcmFtcy5tYXhCYWNrZmFjZUhpZGRlblNsaWRlcykge1xuICAgICAgaWYgKCFoYXNDbGFzc0JhY2tmYWNlQ2xhc3NBZGRlZCkgc3dpcGVyLmVsLmNsYXNzTGlzdC5hZGQoYmFja0ZhY2VIaWRkZW5DbGFzcyk7XG4gICAgfSBlbHNlIGlmIChoYXNDbGFzc0JhY2tmYWNlQ2xhc3NBZGRlZCkge1xuICAgICAgc3dpcGVyLmVsLmNsYXNzTGlzdC5yZW1vdmUoYmFja0ZhY2VIaWRkZW5DbGFzcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUF1dG9IZWlnaHQoc3BlZWQpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgYWN0aXZlU2xpZGVzID0gW107XG4gIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkO1xuICBsZXQgbmV3SGVpZ2h0ID0gMDtcbiAgbGV0IGk7XG4gIGlmICh0eXBlb2Ygc3BlZWQgPT09ICdudW1iZXInKSB7XG4gICAgc3dpcGVyLnNldFRyYW5zaXRpb24oc3BlZWQpO1xuICB9IGVsc2UgaWYgKHNwZWVkID09PSB0cnVlKSB7XG4gICAgc3dpcGVyLnNldFRyYW5zaXRpb24oc3dpcGVyLnBhcmFtcy5zcGVlZCk7XG4gIH1cbiAgY29uc3QgZ2V0U2xpZGVCeUluZGV4ID0gaW5kZXggPT4ge1xuICAgIGlmIChpc1ZpcnR1YWwpIHtcbiAgICAgIHJldHVybiBzd2lwZXIuc2xpZGVzW3N3aXBlci5nZXRTbGlkZUluZGV4QnlEYXRhKGluZGV4KV07XG4gICAgfVxuICAgIHJldHVybiBzd2lwZXIuc2xpZGVzW2luZGV4XTtcbiAgfTtcbiAgLy8gRmluZCBzbGlkZXMgY3VycmVudGx5IGluIHZpZXdcbiAgaWYgKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyAhPT0gJ2F1dG8nICYmIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyA+IDEpIHtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgKHN3aXBlci52aXNpYmxlU2xpZGVzIHx8IFtdKS5mb3JFYWNoKHNsaWRlID0+IHtcbiAgICAgICAgYWN0aXZlU2xpZGVzLnB1c2goc2xpZGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBNYXRoLmNlaWwoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3KTsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4ICsgaTtcbiAgICAgICAgaWYgKGluZGV4ID4gc3dpcGVyLnNsaWRlcy5sZW5ndGggJiYgIWlzVmlydHVhbCkgYnJlYWs7XG4gICAgICAgIGFjdGl2ZVNsaWRlcy5wdXNoKGdldFNsaWRlQnlJbmRleChpbmRleCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhY3RpdmVTbGlkZXMucHVzaChnZXRTbGlkZUJ5SW5kZXgoc3dpcGVyLmFjdGl2ZUluZGV4KSk7XG4gIH1cblxuICAvLyBGaW5kIG5ldyBoZWlnaHQgZnJvbSBoaWdoZXN0IHNsaWRlIGluIHZpZXdcbiAgZm9yIChpID0gMDsgaSA8IGFjdGl2ZVNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmICh0eXBlb2YgYWN0aXZlU2xpZGVzW2ldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gYWN0aXZlU2xpZGVzW2ldLm9mZnNldEhlaWdodDtcbiAgICAgIG5ld0hlaWdodCA9IGhlaWdodCA+IG5ld0hlaWdodCA/IGhlaWdodCA6IG5ld0hlaWdodDtcbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGUgSGVpZ2h0XG4gIGlmIChuZXdIZWlnaHQgfHwgbmV3SGVpZ2h0ID09PSAwKSBzd2lwZXIud3JhcHBlckVsLnN0eWxlLmhlaWdodCA9IGAke25ld0hlaWdodH1weGA7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNsaWRlc09mZnNldCgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qgc2xpZGVzID0gc3dpcGVyLnNsaWRlcztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIGNvbnN0IG1pbnVzT2Zmc2V0ID0gc3dpcGVyLmlzRWxlbWVudCA/IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHN3aXBlci53cmFwcGVyRWwub2Zmc2V0TGVmdCA6IHN3aXBlci53cmFwcGVyRWwub2Zmc2V0VG9wIDogMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBzbGlkZXNbaV0uc3dpcGVyU2xpZGVPZmZzZXQgPSAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gc2xpZGVzW2ldLm9mZnNldExlZnQgOiBzbGlkZXNbaV0ub2Zmc2V0VG9wKSAtIG1pbnVzT2Zmc2V0IC0gc3dpcGVyLmNzc092ZXJmbG93QWRqdXN0bWVudCgpO1xuICB9XG59XG5cbmNvbnN0IHRvZ2dsZVNsaWRlQ2xhc3NlcyQxID0gKHNsaWRlRWwsIGNvbmRpdGlvbiwgY2xhc3NOYW1lKSA9PiB7XG4gIGlmIChjb25kaXRpb24gJiYgIXNsaWRlRWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpIHtcbiAgICBzbGlkZUVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgfSBlbHNlIGlmICghY29uZGl0aW9uICYmIHNsaWRlRWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpIHtcbiAgICBzbGlkZUVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHVwZGF0ZVNsaWRlc1Byb2dyZXNzKHRyYW5zbGF0ZSkge1xuICBpZiAodHJhbnNsYXRlID09PSB2b2lkIDApIHtcbiAgICB0cmFuc2xhdGUgPSB0aGlzICYmIHRoaXMudHJhbnNsYXRlIHx8IDA7XG4gIH1cbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcbiAgY29uc3Qge1xuICAgIHNsaWRlcyxcbiAgICBydGxUcmFuc2xhdGU6IHJ0bCxcbiAgICBzbmFwR3JpZFxuICB9ID0gc3dpcGVyO1xuICBpZiAoc2xpZGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICBpZiAodHlwZW9mIHNsaWRlc1swXS5zd2lwZXJTbGlkZU9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHN3aXBlci51cGRhdGVTbGlkZXNPZmZzZXQoKTtcbiAgbGV0IG9mZnNldENlbnRlciA9IC10cmFuc2xhdGU7XG4gIGlmIChydGwpIG9mZnNldENlbnRlciA9IHRyYW5zbGF0ZTtcbiAgc3dpcGVyLnZpc2libGVTbGlkZXNJbmRleGVzID0gW107XG4gIHN3aXBlci52aXNpYmxlU2xpZGVzID0gW107XG4gIGxldCBzcGFjZUJldHdlZW4gPSBwYXJhbXMuc3BhY2VCZXR3ZWVuO1xuICBpZiAodHlwZW9mIHNwYWNlQmV0d2VlbiA9PT0gJ3N0cmluZycgJiYgc3BhY2VCZXR3ZWVuLmluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgc3BhY2VCZXR3ZWVuID0gcGFyc2VGbG9hdChzcGFjZUJldHdlZW4ucmVwbGFjZSgnJScsICcnKSkgLyAxMDAgKiBzd2lwZXIuc2l6ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3BhY2VCZXR3ZWVuID09PSAnc3RyaW5nJykge1xuICAgIHNwYWNlQmV0d2VlbiA9IHBhcnNlRmxvYXQoc3BhY2VCZXR3ZWVuKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHNsaWRlID0gc2xpZGVzW2ldO1xuICAgIGxldCBzbGlkZU9mZnNldCA9IHNsaWRlLnN3aXBlclNsaWRlT2Zmc2V0O1xuICAgIGlmIChwYXJhbXMuY3NzTW9kZSAmJiBwYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgIHNsaWRlT2Zmc2V0IC09IHNsaWRlc1swXS5zd2lwZXJTbGlkZU9mZnNldDtcbiAgICB9XG4gICAgY29uc3Qgc2xpZGVQcm9ncmVzcyA9IChvZmZzZXRDZW50ZXIgKyAocGFyYW1zLmNlbnRlcmVkU2xpZGVzID8gc3dpcGVyLm1pblRyYW5zbGF0ZSgpIDogMCkgLSBzbGlkZU9mZnNldCkgLyAoc2xpZGUuc3dpcGVyU2xpZGVTaXplICsgc3BhY2VCZXR3ZWVuKTtcbiAgICBjb25zdCBvcmlnaW5hbFNsaWRlUHJvZ3Jlc3MgPSAob2Zmc2V0Q2VudGVyIC0gc25hcEdyaWRbMF0gKyAocGFyYW1zLmNlbnRlcmVkU2xpZGVzID8gc3dpcGVyLm1pblRyYW5zbGF0ZSgpIDogMCkgLSBzbGlkZU9mZnNldCkgLyAoc2xpZGUuc3dpcGVyU2xpZGVTaXplICsgc3BhY2VCZXR3ZWVuKTtcbiAgICBjb25zdCBzbGlkZUJlZm9yZSA9IC0ob2Zmc2V0Q2VudGVyIC0gc2xpZGVPZmZzZXQpO1xuICAgIGNvbnN0IHNsaWRlQWZ0ZXIgPSBzbGlkZUJlZm9yZSArIHN3aXBlci5zbGlkZXNTaXplc0dyaWRbaV07XG4gICAgY29uc3QgaXNGdWxseVZpc2libGUgPSBzbGlkZUJlZm9yZSA+PSAwICYmIHNsaWRlQmVmb3JlIDw9IHN3aXBlci5zaXplIC0gc3dpcGVyLnNsaWRlc1NpemVzR3JpZFtpXTtcbiAgICBjb25zdCBpc1Zpc2libGUgPSBzbGlkZUJlZm9yZSA+PSAwICYmIHNsaWRlQmVmb3JlIDwgc3dpcGVyLnNpemUgLSAxIHx8IHNsaWRlQWZ0ZXIgPiAxICYmIHNsaWRlQWZ0ZXIgPD0gc3dpcGVyLnNpemUgfHwgc2xpZGVCZWZvcmUgPD0gMCAmJiBzbGlkZUFmdGVyID49IHN3aXBlci5zaXplO1xuICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgIHN3aXBlci52aXNpYmxlU2xpZGVzLnB1c2goc2xpZGUpO1xuICAgICAgc3dpcGVyLnZpc2libGVTbGlkZXNJbmRleGVzLnB1c2goaSk7XG4gICAgfVxuICAgIHRvZ2dsZVNsaWRlQ2xhc3NlcyQxKHNsaWRlLCBpc1Zpc2libGUsIHBhcmFtcy5zbGlkZVZpc2libGVDbGFzcyk7XG4gICAgdG9nZ2xlU2xpZGVDbGFzc2VzJDEoc2xpZGUsIGlzRnVsbHlWaXNpYmxlLCBwYXJhbXMuc2xpZGVGdWxseVZpc2libGVDbGFzcyk7XG4gICAgc2xpZGUucHJvZ3Jlc3MgPSBydGwgPyAtc2xpZGVQcm9ncmVzcyA6IHNsaWRlUHJvZ3Jlc3M7XG4gICAgc2xpZGUub3JpZ2luYWxQcm9ncmVzcyA9IHJ0bCA/IC1vcmlnaW5hbFNsaWRlUHJvZ3Jlc3MgOiBvcmlnaW5hbFNsaWRlUHJvZ3Jlc3M7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlUHJvZ3Jlc3ModHJhbnNsYXRlKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGlmICh0eXBlb2YgdHJhbnNsYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IG11bHRpcGxpZXIgPSBzd2lwZXIucnRsVHJhbnNsYXRlID8gLTEgOiAxO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHRyYW5zbGF0ZSA9IHN3aXBlciAmJiBzd2lwZXIudHJhbnNsYXRlICYmIHN3aXBlci50cmFuc2xhdGUgKiBtdWx0aXBsaWVyIHx8IDA7XG4gIH1cbiAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcbiAgY29uc3QgdHJhbnNsYXRlc0RpZmYgPSBzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XG4gIGxldCB7XG4gICAgcHJvZ3Jlc3MsXG4gICAgaXNCZWdpbm5pbmcsXG4gICAgaXNFbmQsXG4gICAgcHJvZ3Jlc3NMb29wXG4gIH0gPSBzd2lwZXI7XG4gIGNvbnN0IHdhc0JlZ2lubmluZyA9IGlzQmVnaW5uaW5nO1xuICBjb25zdCB3YXNFbmQgPSBpc0VuZDtcbiAgaWYgKHRyYW5zbGF0ZXNEaWZmID09PSAwKSB7XG4gICAgcHJvZ3Jlc3MgPSAwO1xuICAgIGlzQmVnaW5uaW5nID0gdHJ1ZTtcbiAgICBpc0VuZCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcHJvZ3Jlc3MgPSAodHJhbnNsYXRlIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSAvIHRyYW5zbGF0ZXNEaWZmO1xuICAgIGNvbnN0IGlzQmVnaW5uaW5nUm91bmRlZCA9IE1hdGguYWJzKHRyYW5zbGF0ZSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKSkgPCAxO1xuICAgIGNvbnN0IGlzRW5kUm91bmRlZCA9IE1hdGguYWJzKHRyYW5zbGF0ZSAtIHN3aXBlci5tYXhUcmFuc2xhdGUoKSkgPCAxO1xuICAgIGlzQmVnaW5uaW5nID0gaXNCZWdpbm5pbmdSb3VuZGVkIHx8IHByb2dyZXNzIDw9IDA7XG4gICAgaXNFbmQgPSBpc0VuZFJvdW5kZWQgfHwgcHJvZ3Jlc3MgPj0gMTtcbiAgICBpZiAoaXNCZWdpbm5pbmdSb3VuZGVkKSBwcm9ncmVzcyA9IDA7XG4gICAgaWYgKGlzRW5kUm91bmRlZCkgcHJvZ3Jlc3MgPSAxO1xuICB9XG4gIGlmIChwYXJhbXMubG9vcCkge1xuICAgIGNvbnN0IGZpcnN0U2xpZGVJbmRleCA9IHN3aXBlci5nZXRTbGlkZUluZGV4QnlEYXRhKDApO1xuICAgIGNvbnN0IGxhc3RTbGlkZUluZGV4ID0gc3dpcGVyLmdldFNsaWRlSW5kZXhCeURhdGEoc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxKTtcbiAgICBjb25zdCBmaXJzdFNsaWRlVHJhbnNsYXRlID0gc3dpcGVyLnNsaWRlc0dyaWRbZmlyc3RTbGlkZUluZGV4XTtcbiAgICBjb25zdCBsYXN0U2xpZGVUcmFuc2xhdGUgPSBzd2lwZXIuc2xpZGVzR3JpZFtsYXN0U2xpZGVJbmRleF07XG4gICAgY29uc3QgdHJhbnNsYXRlTWF4ID0gc3dpcGVyLnNsaWRlc0dyaWRbc3dpcGVyLnNsaWRlc0dyaWQubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgdHJhbnNsYXRlQWJzID0gTWF0aC5hYnModHJhbnNsYXRlKTtcbiAgICBpZiAodHJhbnNsYXRlQWJzID49IGZpcnN0U2xpZGVUcmFuc2xhdGUpIHtcbiAgICAgIHByb2dyZXNzTG9vcCA9ICh0cmFuc2xhdGVBYnMgLSBmaXJzdFNsaWRlVHJhbnNsYXRlKSAvIHRyYW5zbGF0ZU1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvZ3Jlc3NMb29wID0gKHRyYW5zbGF0ZUFicyArIHRyYW5zbGF0ZU1heCAtIGxhc3RTbGlkZVRyYW5zbGF0ZSkgLyB0cmFuc2xhdGVNYXg7XG4gICAgfVxuICAgIGlmIChwcm9ncmVzc0xvb3AgPiAxKSBwcm9ncmVzc0xvb3AgLT0gMTtcbiAgfVxuICBPYmplY3QuYXNzaWduKHN3aXBlciwge1xuICAgIHByb2dyZXNzLFxuICAgIHByb2dyZXNzTG9vcCxcbiAgICBpc0JlZ2lubmluZyxcbiAgICBpc0VuZFxuICB9KTtcbiAgaWYgKHBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzIHx8IHBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiBwYXJhbXMuYXV0b0hlaWdodCkgc3dpcGVyLnVwZGF0ZVNsaWRlc1Byb2dyZXNzKHRyYW5zbGF0ZSk7XG4gIGlmIChpc0JlZ2lubmluZyAmJiAhd2FzQmVnaW5uaW5nKSB7XG4gICAgc3dpcGVyLmVtaXQoJ3JlYWNoQmVnaW5uaW5nIHRvRWRnZScpO1xuICB9XG4gIGlmIChpc0VuZCAmJiAhd2FzRW5kKSB7XG4gICAgc3dpcGVyLmVtaXQoJ3JlYWNoRW5kIHRvRWRnZScpO1xuICB9XG4gIGlmICh3YXNCZWdpbm5pbmcgJiYgIWlzQmVnaW5uaW5nIHx8IHdhc0VuZCAmJiAhaXNFbmQpIHtcbiAgICBzd2lwZXIuZW1pdCgnZnJvbUVkZ2UnKTtcbiAgfVxuICBzd2lwZXIuZW1pdCgncHJvZ3Jlc3MnLCBwcm9ncmVzcyk7XG59XG5cbmNvbnN0IHRvZ2dsZVNsaWRlQ2xhc3NlcyA9IChzbGlkZUVsLCBjb25kaXRpb24sIGNsYXNzTmFtZSkgPT4ge1xuICBpZiAoY29uZGl0aW9uICYmICFzbGlkZUVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKSB7XG4gICAgc2xpZGVFbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSBpZiAoIWNvbmRpdGlvbiAmJiBzbGlkZUVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKSB7XG4gICAgc2xpZGVFbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gIH1cbn07XG5mdW5jdGlvbiB1cGRhdGVTbGlkZXNDbGFzc2VzKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgc2xpZGVzLFxuICAgIHBhcmFtcyxcbiAgICBzbGlkZXNFbCxcbiAgICBhY3RpdmVJbmRleFxuICB9ID0gc3dpcGVyO1xuICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkO1xuICBjb25zdCBncmlkRW5hYmxlZCA9IHN3aXBlci5ncmlkICYmIHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxO1xuICBjb25zdCBnZXRGaWx0ZXJlZFNsaWRlID0gc2VsZWN0b3IgPT4ge1xuICAgIHJldHVybiBlbGVtZW50Q2hpbGRyZW4oc2xpZGVzRWwsIGAuJHtwYXJhbXMuc2xpZGVDbGFzc30ke3NlbGVjdG9yfSwgc3dpcGVyLXNsaWRlJHtzZWxlY3Rvcn1gKVswXTtcbiAgfTtcbiAgbGV0IGFjdGl2ZVNsaWRlO1xuICBsZXQgcHJldlNsaWRlO1xuICBsZXQgbmV4dFNsaWRlO1xuICBpZiAoaXNWaXJ0dWFsKSB7XG4gICAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgICBsZXQgc2xpZGVJbmRleCA9IGFjdGl2ZUluZGV4IC0gc3dpcGVyLnZpcnR1YWwuc2xpZGVzQmVmb3JlO1xuICAgICAgaWYgKHNsaWRlSW5kZXggPCAwKSBzbGlkZUluZGV4ID0gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCArIHNsaWRlSW5kZXg7XG4gICAgICBpZiAoc2xpZGVJbmRleCA+PSBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoKSBzbGlkZUluZGV4IC09IHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGg7XG4gICAgICBhY3RpdmVTbGlkZSA9IGdldEZpbHRlcmVkU2xpZGUoYFtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7c2xpZGVJbmRleH1cIl1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWN0aXZlU2xpZGUgPSBnZXRGaWx0ZXJlZFNsaWRlKGBbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2FjdGl2ZUluZGV4fVwiXWApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZ3JpZEVuYWJsZWQpIHtcbiAgICAgIGFjdGl2ZVNsaWRlID0gc2xpZGVzLmZpbHRlcihzbGlkZUVsID0+IHNsaWRlRWwuY29sdW1uID09PSBhY3RpdmVJbmRleClbMF07XG4gICAgICBuZXh0U2xpZGUgPSBzbGlkZXMuZmlsdGVyKHNsaWRlRWwgPT4gc2xpZGVFbC5jb2x1bW4gPT09IGFjdGl2ZUluZGV4ICsgMSlbMF07XG4gICAgICBwcmV2U2xpZGUgPSBzbGlkZXMuZmlsdGVyKHNsaWRlRWwgPT4gc2xpZGVFbC5jb2x1bW4gPT09IGFjdGl2ZUluZGV4IC0gMSlbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdGl2ZVNsaWRlID0gc2xpZGVzW2FjdGl2ZUluZGV4XTtcbiAgICB9XG4gIH1cbiAgaWYgKGFjdGl2ZVNsaWRlKSB7XG4gICAgaWYgKCFncmlkRW5hYmxlZCkge1xuICAgICAgLy8gTmV4dCBTbGlkZVxuICAgICAgbmV4dFNsaWRlID0gZWxlbWVudE5leHRBbGwoYWN0aXZlU2xpZGUsIGAuJHtwYXJhbXMuc2xpZGVDbGFzc30sIHN3aXBlci1zbGlkZWApWzBdO1xuICAgICAgaWYgKHBhcmFtcy5sb29wICYmICFuZXh0U2xpZGUpIHtcbiAgICAgICAgbmV4dFNsaWRlID0gc2xpZGVzWzBdO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmV2IFNsaWRlXG4gICAgICBwcmV2U2xpZGUgPSBlbGVtZW50UHJldkFsbChhY3RpdmVTbGlkZSwgYC4ke3BhcmFtcy5zbGlkZUNsYXNzfSwgc3dpcGVyLXNsaWRlYClbMF07XG4gICAgICBpZiAocGFyYW1zLmxvb3AgJiYgIXByZXZTbGlkZSA9PT0gMCkge1xuICAgICAgICBwcmV2U2xpZGUgPSBzbGlkZXNbc2xpZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzbGlkZXMuZm9yRWFjaChzbGlkZUVsID0+IHtcbiAgICB0b2dnbGVTbGlkZUNsYXNzZXMoc2xpZGVFbCwgc2xpZGVFbCA9PT0gYWN0aXZlU2xpZGUsIHBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzKTtcbiAgICB0b2dnbGVTbGlkZUNsYXNzZXMoc2xpZGVFbCwgc2xpZGVFbCA9PT0gbmV4dFNsaWRlLCBwYXJhbXMuc2xpZGVOZXh0Q2xhc3MpO1xuICAgIHRvZ2dsZVNsaWRlQ2xhc3NlcyhzbGlkZUVsLCBzbGlkZUVsID09PSBwcmV2U2xpZGUsIHBhcmFtcy5zbGlkZVByZXZDbGFzcyk7XG4gIH0pO1xuICBzd2lwZXIuZW1pdFNsaWRlc0NsYXNzZXMoKTtcbn1cblxuY29uc3QgcHJvY2Vzc0xhenlQcmVsb2FkZXIgPSAoc3dpcGVyLCBpbWFnZUVsKSA9PiB7XG4gIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQgfHwgIXN3aXBlci5wYXJhbXMpIHJldHVybjtcbiAgY29uc3Qgc2xpZGVTZWxlY3RvciA9ICgpID0+IHN3aXBlci5pc0VsZW1lbnQgPyBgc3dpcGVyLXNsaWRlYCA6IGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9YDtcbiAgY29uc3Qgc2xpZGVFbCA9IGltYWdlRWwuY2xvc2VzdChzbGlkZVNlbGVjdG9yKCkpO1xuICBpZiAoc2xpZGVFbCkge1xuICAgIGxldCBsYXp5RWwgPSBzbGlkZUVsLnF1ZXJ5U2VsZWN0b3IoYC4ke3N3aXBlci5wYXJhbXMubGF6eVByZWxvYWRlckNsYXNzfWApO1xuICAgIGlmICghbGF6eUVsICYmIHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICAgIGlmIChzbGlkZUVsLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgbGF6eUVsID0gc2xpZGVFbC5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoYC4ke3N3aXBlci5wYXJhbXMubGF6eVByZWxvYWRlckNsYXNzfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW5pdCBsYXRlclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIGlmIChzbGlkZUVsLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgIGxhenlFbCA9IHNsaWRlRWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKGAuJHtzd2lwZXIucGFyYW1zLmxhenlQcmVsb2FkZXJDbGFzc31gKTtcbiAgICAgICAgICAgIGlmIChsYXp5RWwpIGxhenlFbC5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGF6eUVsKSBsYXp5RWwucmVtb3ZlKCk7XG4gIH1cbn07XG5jb25zdCB1bmxhenkgPSAoc3dpcGVyLCBpbmRleCkgPT4ge1xuICBpZiAoIXN3aXBlci5zbGlkZXNbaW5kZXhdKSByZXR1cm47XG4gIGNvbnN0IGltYWdlRWwgPSBzd2lwZXIuc2xpZGVzW2luZGV4XS5xdWVyeVNlbGVjdG9yKCdbbG9hZGluZz1cImxhenlcIl0nKTtcbiAgaWYgKGltYWdlRWwpIGltYWdlRWwucmVtb3ZlQXR0cmlidXRlKCdsb2FkaW5nJyk7XG59O1xuY29uc3QgcHJlbG9hZCA9IHN3aXBlciA9PiB7XG4gIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQgfHwgIXN3aXBlci5wYXJhbXMpIHJldHVybjtcbiAgbGV0IGFtb3VudCA9IHN3aXBlci5wYXJhbXMubGF6eVByZWxvYWRQcmV2TmV4dDtcbiAgY29uc3QgbGVuID0gc3dpcGVyLnNsaWRlcy5sZW5ndGg7XG4gIGlmICghbGVuIHx8ICFhbW91bnQgfHwgYW1vdW50IDwgMCkgcmV0dXJuO1xuICBhbW91bnQgPSBNYXRoLm1pbihhbW91bnQsIGxlbik7XG4gIGNvbnN0IHNsaWRlc1BlclZpZXcgPSBzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyA/IHN3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygpIDogTWF0aC5jZWlsKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyk7XG4gIGNvbnN0IGFjdGl2ZUluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4O1xuICBpZiAoc3dpcGVyLnBhcmFtcy5ncmlkICYmIHN3aXBlci5wYXJhbXMuZ3JpZC5yb3dzID4gMSkge1xuICAgIGNvbnN0IGFjdGl2ZUNvbHVtbiA9IGFjdGl2ZUluZGV4O1xuICAgIGNvbnN0IHByZWxvYWRDb2x1bW5zID0gW2FjdGl2ZUNvbHVtbiAtIGFtb3VudF07XG4gICAgcHJlbG9hZENvbHVtbnMucHVzaCguLi5BcnJheS5mcm9tKHtcbiAgICAgIGxlbmd0aDogYW1vdW50XG4gICAgfSkubWFwKChfLCBpKSA9PiB7XG4gICAgICByZXR1cm4gYWN0aXZlQ29sdW1uICsgc2xpZGVzUGVyVmlldyArIGk7XG4gICAgfSkpO1xuICAgIHN3aXBlci5zbGlkZXMuZm9yRWFjaCgoc2xpZGVFbCwgaSkgPT4ge1xuICAgICAgaWYgKHByZWxvYWRDb2x1bW5zLmluY2x1ZGVzKHNsaWRlRWwuY29sdW1uKSkgdW5sYXp5KHN3aXBlciwgaSk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHNsaWRlSW5kZXhMYXN0SW5WaWV3ID0gYWN0aXZlSW5kZXggKyBzbGlkZXNQZXJWaWV3IC0gMTtcbiAgaWYgKHN3aXBlci5wYXJhbXMucmV3aW5kIHx8IHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgIGZvciAobGV0IGkgPSBhY3RpdmVJbmRleCAtIGFtb3VudDsgaSA8PSBzbGlkZUluZGV4TGFzdEluVmlldyArIGFtb3VudDsgaSArPSAxKSB7XG4gICAgICBjb25zdCByZWFsSW5kZXggPSAoaSAlIGxlbiArIGxlbikgJSBsZW47XG4gICAgICBpZiAocmVhbEluZGV4IDwgYWN0aXZlSW5kZXggfHwgcmVhbEluZGV4ID4gc2xpZGVJbmRleExhc3RJblZpZXcpIHVubGF6eShzd2lwZXIsIHJlYWxJbmRleCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSBNYXRoLm1heChhY3RpdmVJbmRleCAtIGFtb3VudCwgMCk7IGkgPD0gTWF0aC5taW4oc2xpZGVJbmRleExhc3RJblZpZXcgKyBhbW91bnQsIGxlbiAtIDEpOyBpICs9IDEpIHtcbiAgICAgIGlmIChpICE9PSBhY3RpdmVJbmRleCAmJiAoaSA+IHNsaWRlSW5kZXhMYXN0SW5WaWV3IHx8IGkgPCBhY3RpdmVJbmRleCkpIHtcbiAgICAgICAgdW5sYXp5KHN3aXBlciwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRBY3RpdmVJbmRleEJ5VHJhbnNsYXRlKHN3aXBlcikge1xuICBjb25zdCB7XG4gICAgc2xpZGVzR3JpZCxcbiAgICBwYXJhbXNcbiAgfSA9IHN3aXBlcjtcbiAgY29uc3QgdHJhbnNsYXRlID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcbiAgbGV0IGFjdGl2ZUluZGV4O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0dyaWQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAodHlwZW9mIHNsaWRlc0dyaWRbaSArIDFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHRyYW5zbGF0ZSA+PSBzbGlkZXNHcmlkW2ldICYmIHRyYW5zbGF0ZSA8IHNsaWRlc0dyaWRbaSArIDFdIC0gKHNsaWRlc0dyaWRbaSArIDFdIC0gc2xpZGVzR3JpZFtpXSkgLyAyKSB7XG4gICAgICAgIGFjdGl2ZUluZGV4ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAodHJhbnNsYXRlID49IHNsaWRlc0dyaWRbaV0gJiYgdHJhbnNsYXRlIDwgc2xpZGVzR3JpZFtpICsgMV0pIHtcbiAgICAgICAgYWN0aXZlSW5kZXggPSBpICsgMTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRyYW5zbGF0ZSA+PSBzbGlkZXNHcmlkW2ldKSB7XG4gICAgICBhY3RpdmVJbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIC8vIE5vcm1hbGl6ZSBzbGlkZUluZGV4XG4gIGlmIChwYXJhbXMubm9ybWFsaXplU2xpZGVJbmRleCkge1xuICAgIGlmIChhY3RpdmVJbmRleCA8IDAgfHwgdHlwZW9mIGFjdGl2ZUluZGV4ID09PSAndW5kZWZpbmVkJykgYWN0aXZlSW5kZXggPSAwO1xuICB9XG4gIHJldHVybiBhY3RpdmVJbmRleDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUFjdGl2ZUluZGV4KG5ld0FjdGl2ZUluZGV4KSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IHN3aXBlci5ydGxUcmFuc2xhdGUgPyBzd2lwZXIudHJhbnNsYXRlIDogLXN3aXBlci50cmFuc2xhdGU7XG4gIGNvbnN0IHtcbiAgICBzbmFwR3JpZCxcbiAgICBwYXJhbXMsXG4gICAgYWN0aXZlSW5kZXg6IHByZXZpb3VzSW5kZXgsXG4gICAgcmVhbEluZGV4OiBwcmV2aW91c1JlYWxJbmRleCxcbiAgICBzbmFwSW5kZXg6IHByZXZpb3VzU25hcEluZGV4XG4gIH0gPSBzd2lwZXI7XG4gIGxldCBhY3RpdmVJbmRleCA9IG5ld0FjdGl2ZUluZGV4O1xuICBsZXQgc25hcEluZGV4O1xuICBjb25zdCBnZXRWaXJ0dWFsUmVhbEluZGV4ID0gYUluZGV4ID0+IHtcbiAgICBsZXQgcmVhbEluZGV4ID0gYUluZGV4IC0gc3dpcGVyLnZpcnR1YWwuc2xpZGVzQmVmb3JlO1xuICAgIGlmIChyZWFsSW5kZXggPCAwKSB7XG4gICAgICByZWFsSW5kZXggPSBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoICsgcmVhbEluZGV4O1xuICAgIH1cbiAgICBpZiAocmVhbEluZGV4ID49IHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGgpIHtcbiAgICAgIHJlYWxJbmRleCAtPSBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVhbEluZGV4O1xuICB9O1xuICBpZiAodHlwZW9mIGFjdGl2ZUluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgIGFjdGl2ZUluZGV4ID0gZ2V0QWN0aXZlSW5kZXhCeVRyYW5zbGF0ZShzd2lwZXIpO1xuICB9XG4gIGlmIChzbmFwR3JpZC5pbmRleE9mKHRyYW5zbGF0ZSkgPj0gMCkge1xuICAgIHNuYXBJbmRleCA9IHNuYXBHcmlkLmluZGV4T2YodHJhbnNsYXRlKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBza2lwID0gTWF0aC5taW4ocGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCwgYWN0aXZlSW5kZXgpO1xuICAgIHNuYXBJbmRleCA9IHNraXAgKyBNYXRoLmZsb29yKChhY3RpdmVJbmRleCAtIHNraXApIC8gcGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcbiAgfVxuICBpZiAoc25hcEluZGV4ID49IHNuYXBHcmlkLmxlbmd0aCkgc25hcEluZGV4ID0gc25hcEdyaWQubGVuZ3RoIC0gMTtcbiAgaWYgKGFjdGl2ZUluZGV4ID09PSBwcmV2aW91c0luZGV4ICYmICFzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICBpZiAoc25hcEluZGV4ICE9PSBwcmV2aW91c1NuYXBJbmRleCkge1xuICAgICAgc3dpcGVyLnNuYXBJbmRleCA9IHNuYXBJbmRleDtcbiAgICAgIHN3aXBlci5lbWl0KCdzbmFwSW5kZXhDaGFuZ2UnKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChhY3RpdmVJbmRleCA9PT0gcHJldmlvdXNJbmRleCAmJiBzd2lwZXIucGFyYW1zLmxvb3AgJiYgc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHtcbiAgICBzd2lwZXIucmVhbEluZGV4ID0gZ2V0VmlydHVhbFJlYWxJbmRleChhY3RpdmVJbmRleCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGdyaWRFbmFibGVkID0gc3dpcGVyLmdyaWQgJiYgcGFyYW1zLmdyaWQgJiYgcGFyYW1zLmdyaWQucm93cyA+IDE7XG5cbiAgLy8gR2V0IHJlYWwgaW5kZXhcbiAgbGV0IHJlYWxJbmRleDtcbiAgaWYgKHN3aXBlci52aXJ0dWFsICYmIHBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgJiYgcGFyYW1zLmxvb3ApIHtcbiAgICByZWFsSW5kZXggPSBnZXRWaXJ0dWFsUmVhbEluZGV4KGFjdGl2ZUluZGV4KTtcbiAgfSBlbHNlIGlmIChncmlkRW5hYmxlZCkge1xuICAgIGNvbnN0IGZpcnN0U2xpZGVJbkNvbHVtbiA9IHN3aXBlci5zbGlkZXMuZmlsdGVyKHNsaWRlRWwgPT4gc2xpZGVFbC5jb2x1bW4gPT09IGFjdGl2ZUluZGV4KVswXTtcbiAgICBsZXQgYWN0aXZlU2xpZGVJbmRleCA9IHBhcnNlSW50KGZpcnN0U2xpZGVJbkNvbHVtbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JyksIDEwKTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGFjdGl2ZVNsaWRlSW5kZXgpKSB7XG4gICAgICBhY3RpdmVTbGlkZUluZGV4ID0gTWF0aC5tYXgoc3dpcGVyLnNsaWRlcy5pbmRleE9mKGZpcnN0U2xpZGVJbkNvbHVtbiksIDApO1xuICAgIH1cbiAgICByZWFsSW5kZXggPSBNYXRoLmZsb29yKGFjdGl2ZVNsaWRlSW5kZXggLyBwYXJhbXMuZ3JpZC5yb3dzKTtcbiAgfSBlbHNlIGlmIChzd2lwZXIuc2xpZGVzW2FjdGl2ZUluZGV4XSkge1xuICAgIGNvbnN0IHNsaWRlSW5kZXggPSBzd2lwZXIuc2xpZGVzW2FjdGl2ZUluZGV4XS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyk7XG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgIHJlYWxJbmRleCA9IHBhcnNlSW50KHNsaWRlSW5kZXgsIDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVhbEluZGV4ID0gYWN0aXZlSW5kZXg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlYWxJbmRleCA9IGFjdGl2ZUluZGV4O1xuICB9XG4gIE9iamVjdC5hc3NpZ24oc3dpcGVyLCB7XG4gICAgcHJldmlvdXNTbmFwSW5kZXgsXG4gICAgc25hcEluZGV4LFxuICAgIHByZXZpb3VzUmVhbEluZGV4LFxuICAgIHJlYWxJbmRleCxcbiAgICBwcmV2aW91c0luZGV4LFxuICAgIGFjdGl2ZUluZGV4XG4gIH0pO1xuICBpZiAoc3dpcGVyLmluaXRpYWxpemVkKSB7XG4gICAgcHJlbG9hZChzd2lwZXIpO1xuICB9XG4gIHN3aXBlci5lbWl0KCdhY3RpdmVJbmRleENoYW5nZScpO1xuICBzd2lwZXIuZW1pdCgnc25hcEluZGV4Q2hhbmdlJyk7XG4gIGlmIChzd2lwZXIuaW5pdGlhbGl6ZWQgfHwgc3dpcGVyLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQpIHtcbiAgICBpZiAocHJldmlvdXNSZWFsSW5kZXggIT09IHJlYWxJbmRleCkge1xuICAgICAgc3dpcGVyLmVtaXQoJ3JlYWxJbmRleENoYW5nZScpO1xuICAgIH1cbiAgICBzd2lwZXIuZW1pdCgnc2xpZGVDaGFuZ2UnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDbGlja2VkU2xpZGUoZWwsIHBhdGgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcbiAgbGV0IHNsaWRlID0gZWwuY2xvc2VzdChgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LCBzd2lwZXItc2xpZGVgKTtcbiAgaWYgKCFzbGlkZSAmJiBzd2lwZXIuaXNFbGVtZW50ICYmIHBhdGggJiYgcGF0aC5sZW5ndGggPiAxICYmIHBhdGguaW5jbHVkZXMoZWwpKSB7XG4gICAgWy4uLnBhdGguc2xpY2UocGF0aC5pbmRleE9mKGVsKSArIDEsIHBhdGgubGVuZ3RoKV0uZm9yRWFjaChwYXRoRWwgPT4ge1xuICAgICAgaWYgKCFzbGlkZSAmJiBwYXRoRWwubWF0Y2hlcyAmJiBwYXRoRWwubWF0Y2hlcyhgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LCBzd2lwZXItc2xpZGVgKSkge1xuICAgICAgICBzbGlkZSA9IHBhdGhFbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsZXQgc2xpZGVGb3VuZCA9IGZhbHNlO1xuICBsZXQgc2xpZGVJbmRleDtcbiAgaWYgKHNsaWRlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzd2lwZXIuc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoc3dpcGVyLnNsaWRlc1tpXSA9PT0gc2xpZGUpIHtcbiAgICAgICAgc2xpZGVGb3VuZCA9IHRydWU7XG4gICAgICAgIHNsaWRlSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHNsaWRlICYmIHNsaWRlRm91bmQpIHtcbiAgICBzd2lwZXIuY2xpY2tlZFNsaWRlID0gc2xpZGU7XG4gICAgaWYgKHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkKSB7XG4gICAgICBzd2lwZXIuY2xpY2tlZEluZGV4ID0gcGFyc2VJbnQoc2xpZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpLCAxMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5jbGlja2VkSW5kZXggPSBzbGlkZUluZGV4O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzd2lwZXIuY2xpY2tlZFNsaWRlID0gdW5kZWZpbmVkO1xuICAgIHN3aXBlci5jbGlja2VkSW5kZXggPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwYXJhbXMuc2xpZGVUb0NsaWNrZWRTbGlkZSAmJiBzd2lwZXIuY2xpY2tlZEluZGV4ICE9PSB1bmRlZmluZWQgJiYgc3dpcGVyLmNsaWNrZWRJbmRleCAhPT0gc3dpcGVyLmFjdGl2ZUluZGV4KSB7XG4gICAgc3dpcGVyLnNsaWRlVG9DbGlja2VkU2xpZGUoKTtcbiAgfVxufVxuXG52YXIgdXBkYXRlID0ge1xuICB1cGRhdGVTaXplLFxuICB1cGRhdGVTbGlkZXMsXG4gIHVwZGF0ZUF1dG9IZWlnaHQsXG4gIHVwZGF0ZVNsaWRlc09mZnNldCxcbiAgdXBkYXRlU2xpZGVzUHJvZ3Jlc3MsXG4gIHVwZGF0ZVByb2dyZXNzLFxuICB1cGRhdGVTbGlkZXNDbGFzc2VzLFxuICB1cGRhdGVBY3RpdmVJbmRleCxcbiAgdXBkYXRlQ2xpY2tlZFNsaWRlXG59O1xuXG5mdW5jdGlvbiBnZXRTd2lwZXJUcmFuc2xhdGUoYXhpcykge1xuICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7XG4gICAgYXhpcyA9IHRoaXMuaXNIb3Jpem9udGFsKCkgPyAneCcgOiAneSc7XG4gIH1cbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHBhcmFtcyxcbiAgICBydGxUcmFuc2xhdGU6IHJ0bCxcbiAgICB0cmFuc2xhdGUsXG4gICAgd3JhcHBlckVsXG4gIH0gPSBzd2lwZXI7XG4gIGlmIChwYXJhbXMudmlydHVhbFRyYW5zbGF0ZSkge1xuICAgIHJldHVybiBydGwgPyAtdHJhbnNsYXRlIDogdHJhbnNsYXRlO1xuICB9XG4gIGlmIChwYXJhbXMuY3NzTW9kZSkge1xuICAgIHJldHVybiB0cmFuc2xhdGU7XG4gIH1cbiAgbGV0IGN1cnJlbnRUcmFuc2xhdGUgPSBnZXRUcmFuc2xhdGUod3JhcHBlckVsLCBheGlzKTtcbiAgY3VycmVudFRyYW5zbGF0ZSArPSBzd2lwZXIuY3NzT3ZlcmZsb3dBZGp1c3RtZW50KCk7XG4gIGlmIChydGwpIGN1cnJlbnRUcmFuc2xhdGUgPSAtY3VycmVudFRyYW5zbGF0ZTtcbiAgcmV0dXJuIGN1cnJlbnRUcmFuc2xhdGUgfHwgMDtcbn1cblxuZnVuY3Rpb24gc2V0VHJhbnNsYXRlKHRyYW5zbGF0ZSwgYnlDb250cm9sbGVyKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBydGxUcmFuc2xhdGU6IHJ0bCxcbiAgICBwYXJhbXMsXG4gICAgd3JhcHBlckVsLFxuICAgIHByb2dyZXNzXG4gIH0gPSBzd2lwZXI7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBjb25zdCB6ID0gMDtcbiAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgIHggPSBydGwgPyAtdHJhbnNsYXRlIDogdHJhbnNsYXRlO1xuICB9IGVsc2Uge1xuICAgIHkgPSB0cmFuc2xhdGU7XG4gIH1cbiAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHtcbiAgICB4ID0gTWF0aC5mbG9vcih4KTtcbiAgICB5ID0gTWF0aC5mbG9vcih5KTtcbiAgfVxuICBzd2lwZXIucHJldmlvdXNUcmFuc2xhdGUgPSBzd2lwZXIudHJhbnNsYXRlO1xuICBzd2lwZXIudHJhbnNsYXRlID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8geCA6IHk7XG4gIGlmIChwYXJhbXMuY3NzTW9kZSkge1xuICAgIHdyYXBwZXJFbFtzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAnc2Nyb2xsTGVmdCcgOiAnc2Nyb2xsVG9wJ10gPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAteCA6IC15O1xuICB9IGVsc2UgaWYgKCFwYXJhbXMudmlydHVhbFRyYW5zbGF0ZSkge1xuICAgIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHggLT0gc3dpcGVyLmNzc092ZXJmbG93QWRqdXN0bWVudCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB5IC09IHN3aXBlci5jc3NPdmVyZmxvd0FkanVzdG1lbnQoKTtcbiAgICB9XG4gICAgd3JhcHBlckVsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3h9cHgsICR7eX1weCwgJHt6fXB4KWA7XG4gIH1cblxuICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSBwcm9ncmVzc1xuICBsZXQgbmV3UHJvZ3Jlc3M7XG4gIGNvbnN0IHRyYW5zbGF0ZXNEaWZmID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICBpZiAodHJhbnNsYXRlc0RpZmYgPT09IDApIHtcbiAgICBuZXdQcm9ncmVzcyA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbmV3UHJvZ3Jlc3MgPSAodHJhbnNsYXRlIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSAvIHRyYW5zbGF0ZXNEaWZmO1xuICB9XG4gIGlmIChuZXdQcm9ncmVzcyAhPT0gcHJvZ3Jlc3MpIHtcbiAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3ModHJhbnNsYXRlKTtcbiAgfVxuICBzd2lwZXIuZW1pdCgnc2V0VHJhbnNsYXRlJywgc3dpcGVyLnRyYW5zbGF0ZSwgYnlDb250cm9sbGVyKTtcbn1cblxuZnVuY3Rpb24gbWluVHJhbnNsYXRlKCkge1xuICByZXR1cm4gLXRoaXMuc25hcEdyaWRbMF07XG59XG5cbmZ1bmN0aW9uIG1heFRyYW5zbGF0ZSgpIHtcbiAgcmV0dXJuIC10aGlzLnNuYXBHcmlkW3RoaXMuc25hcEdyaWQubGVuZ3RoIC0gMV07XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVRvKHRyYW5zbGF0ZSwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgdHJhbnNsYXRlQm91bmRzLCBpbnRlcm5hbCkge1xuICBpZiAodHJhbnNsYXRlID09PSB2b2lkIDApIHtcbiAgICB0cmFuc2xhdGUgPSAwO1xuICB9XG4gIGlmIChzcGVlZCA9PT0gdm9pZCAwKSB7XG4gICAgc3BlZWQgPSB0aGlzLnBhcmFtcy5zcGVlZDtcbiAgfVxuICBpZiAocnVuQ2FsbGJhY2tzID09PSB2b2lkIDApIHtcbiAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICB9XG4gIGlmICh0cmFuc2xhdGVCb3VuZHMgPT09IHZvaWQgMCkge1xuICAgIHRyYW5zbGF0ZUJvdW5kcyA9IHRydWU7XG4gIH1cbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHBhcmFtcyxcbiAgICB3cmFwcGVyRWxcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKHN3aXBlci5hbmltYXRpbmcgJiYgcGFyYW1zLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBtaW5UcmFuc2xhdGUgPSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XG4gIGNvbnN0IG1heFRyYW5zbGF0ZSA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKTtcbiAgbGV0IG5ld1RyYW5zbGF0ZTtcbiAgaWYgKHRyYW5zbGF0ZUJvdW5kcyAmJiB0cmFuc2xhdGUgPiBtaW5UcmFuc2xhdGUpIG5ld1RyYW5zbGF0ZSA9IG1pblRyYW5zbGF0ZTtlbHNlIGlmICh0cmFuc2xhdGVCb3VuZHMgJiYgdHJhbnNsYXRlIDwgbWF4VHJhbnNsYXRlKSBuZXdUcmFuc2xhdGUgPSBtYXhUcmFuc2xhdGU7ZWxzZSBuZXdUcmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5cbiAgLy8gVXBkYXRlIHByb2dyZXNzXG4gIHN3aXBlci51cGRhdGVQcm9ncmVzcyhuZXdUcmFuc2xhdGUpO1xuICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICBjb25zdCBpc0ggPSBzd2lwZXIuaXNIb3Jpem9udGFsKCk7XG4gICAgaWYgKHNwZWVkID09PSAwKSB7XG4gICAgICB3cmFwcGVyRWxbaXNIID8gJ3Njcm9sbExlZnQnIDogJ3Njcm9sbFRvcCddID0gLW5ld1RyYW5zbGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFzd2lwZXIuc3VwcG9ydC5zbW9vdGhTY3JvbGwpIHtcbiAgICAgICAgYW5pbWF0ZUNTU01vZGVTY3JvbGwoe1xuICAgICAgICAgIHN3aXBlcixcbiAgICAgICAgICB0YXJnZXRQb3NpdGlvbjogLW5ld1RyYW5zbGF0ZSxcbiAgICAgICAgICBzaWRlOiBpc0ggPyAnbGVmdCcgOiAndG9wJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB3cmFwcGVyRWwuc2Nyb2xsVG8oe1xuICAgICAgICBbaXNIID8gJ2xlZnQnIDogJ3RvcCddOiAtbmV3VHJhbnNsYXRlLFxuICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoc3BlZWQgPT09IDApIHtcbiAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbigwKTtcbiAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKG5ld1RyYW5zbGF0ZSk7XG4gICAgaWYgKHJ1bkNhbGxiYWNrcykge1xuICAgICAgc3dpcGVyLmVtaXQoJ2JlZm9yZVRyYW5zaXRpb25TdGFydCcsIHNwZWVkLCBpbnRlcm5hbCk7XG4gICAgICBzd2lwZXIuZW1pdCgndHJhbnNpdGlvbkVuZCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihzcGVlZCk7XG4gICAgc3dpcGVyLnNldFRyYW5zbGF0ZShuZXdUcmFuc2xhdGUpO1xuICAgIGlmIChydW5DYWxsYmFja3MpIHtcbiAgICAgIHN3aXBlci5lbWl0KCdiZWZvcmVUcmFuc2l0aW9uU3RhcnQnLCBzcGVlZCwgaW50ZXJuYWwpO1xuICAgICAgc3dpcGVyLmVtaXQoJ3RyYW5zaXRpb25TdGFydCcpO1xuICAgIH1cbiAgICBpZiAoIXN3aXBlci5hbmltYXRpbmcpIHtcbiAgICAgIHN3aXBlci5hbmltYXRpbmcgPSB0cnVlO1xuICAgICAgaWYgKCFzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSB7XG4gICAgICAgIHN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kKGUpIHtcbiAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzKSByZXR1cm47XG4gICAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCA9IG51bGw7XG4gICAgICAgICAgZGVsZXRlIHN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQ7XG4gICAgICAgICAgc3dpcGVyLmFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChydW5DYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHN3aXBlci5lbWl0KCd0cmFuc2l0aW9uRW5kJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc3dpcGVyLndyYXBwZXJFbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgdHJhbnNsYXRlID0ge1xuICBnZXRUcmFuc2xhdGU6IGdldFN3aXBlclRyYW5zbGF0ZSxcbiAgc2V0VHJhbnNsYXRlLFxuICBtaW5UcmFuc2xhdGUsXG4gIG1heFRyYW5zbGF0ZSxcbiAgdHJhbnNsYXRlVG9cbn07XG5cbmZ1bmN0aW9uIHNldFRyYW5zaXRpb24oZHVyYXRpb24sIGJ5Q29udHJvbGxlcikge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBpZiAoIXN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gYCR7ZHVyYXRpb259bXNgO1xuICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gZHVyYXRpb24gPT09IDAgPyBgMG1zYCA6ICcnO1xuICB9XG4gIHN3aXBlci5lbWl0KCdzZXRUcmFuc2l0aW9uJywgZHVyYXRpb24sIGJ5Q29udHJvbGxlcik7XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25FbWl0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgcnVuQ2FsbGJhY2tzLFxuICAgIGRpcmVjdGlvbixcbiAgICBzdGVwXG4gIH0gPSBfcmVmO1xuICBjb25zdCB7XG4gICAgYWN0aXZlSW5kZXgsXG4gICAgcHJldmlvdXNJbmRleFxuICB9ID0gc3dpcGVyO1xuICBsZXQgZGlyID0gZGlyZWN0aW9uO1xuICBpZiAoIWRpcikge1xuICAgIGlmIChhY3RpdmVJbmRleCA+IHByZXZpb3VzSW5kZXgpIGRpciA9ICduZXh0JztlbHNlIGlmIChhY3RpdmVJbmRleCA8IHByZXZpb3VzSW5kZXgpIGRpciA9ICdwcmV2JztlbHNlIGRpciA9ICdyZXNldCc7XG4gIH1cbiAgc3dpcGVyLmVtaXQoYHRyYW5zaXRpb24ke3N0ZXB9YCk7XG4gIGlmIChydW5DYWxsYmFja3MgJiYgYWN0aXZlSW5kZXggIT09IHByZXZpb3VzSW5kZXgpIHtcbiAgICBpZiAoZGlyID09PSAncmVzZXQnKSB7XG4gICAgICBzd2lwZXIuZW1pdChgc2xpZGVSZXNldFRyYW5zaXRpb24ke3N0ZXB9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KGBzbGlkZUNoYW5nZVRyYW5zaXRpb24ke3N0ZXB9YCk7XG4gICAgaWYgKGRpciA9PT0gJ25leHQnKSB7XG4gICAgICBzd2lwZXIuZW1pdChgc2xpZGVOZXh0VHJhbnNpdGlvbiR7c3RlcH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpcGVyLmVtaXQoYHNsaWRlUHJldlRyYW5zaXRpb24ke3N0ZXB9YCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25TdGFydChydW5DYWxsYmFja3MsIGRpcmVjdGlvbikge1xuICBpZiAocnVuQ2FsbGJhY2tzID09PSB2b2lkIDApIHtcbiAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXNcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKHBhcmFtcy5jc3NNb2RlKSByZXR1cm47XG4gIGlmIChwYXJhbXMuYXV0b0hlaWdodCkge1xuICAgIHN3aXBlci51cGRhdGVBdXRvSGVpZ2h0KCk7XG4gIH1cbiAgdHJhbnNpdGlvbkVtaXQoe1xuICAgIHN3aXBlcixcbiAgICBydW5DYWxsYmFja3MsXG4gICAgZGlyZWN0aW9uLFxuICAgIHN0ZXA6ICdTdGFydCdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25FbmQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pIHtcbiAgaWYgKHJ1bkNhbGxiYWNrcyA9PT0gdm9pZCAwKSB7XG4gICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgcGFyYW1zXG4gIH0gPSBzd2lwZXI7XG4gIHN3aXBlci5hbmltYXRpbmcgPSBmYWxzZTtcbiAgaWYgKHBhcmFtcy5jc3NNb2RlKSByZXR1cm47XG4gIHN3aXBlci5zZXRUcmFuc2l0aW9uKDApO1xuICB0cmFuc2l0aW9uRW1pdCh7XG4gICAgc3dpcGVyLFxuICAgIHJ1bkNhbGxiYWNrcyxcbiAgICBkaXJlY3Rpb24sXG4gICAgc3RlcDogJ0VuZCdcbiAgfSk7XG59XG5cbnZhciB0cmFuc2l0aW9uID0ge1xuICBzZXRUcmFuc2l0aW9uLFxuICB0cmFuc2l0aW9uU3RhcnQsXG4gIHRyYW5zaXRpb25FbmRcbn07XG5cbmZ1bmN0aW9uIHNsaWRlVG8oaW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsLCBpbml0aWFsKSB7XG4gIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgaW5kZXggPSAwO1xuICB9XG4gIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3N0cmluZycpIHtcbiAgICBpbmRleCA9IHBhcnNlSW50KGluZGV4LCAxMCk7XG4gIH1cbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgbGV0IHNsaWRlSW5kZXggPSBpbmRleDtcbiAgaWYgKHNsaWRlSW5kZXggPCAwKSBzbGlkZUluZGV4ID0gMDtcbiAgY29uc3Qge1xuICAgIHBhcmFtcyxcbiAgICBzbmFwR3JpZCxcbiAgICBzbGlkZXNHcmlkLFxuICAgIHByZXZpb3VzSW5kZXgsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgd3JhcHBlckVsLFxuICAgIGVuYWJsZWRcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKCFlbmFibGVkICYmICFpbnRlcm5hbCAmJiAhaW5pdGlhbCB8fCBzd2lwZXIuZGVzdHJveWVkIHx8IHN3aXBlci5hbmltYXRpbmcgJiYgcGFyYW1zLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHNwZWVkID09PSAndW5kZWZpbmVkJykge1xuICAgIHNwZWVkID0gc3dpcGVyLnBhcmFtcy5zcGVlZDtcbiAgfVxuICBjb25zdCBza2lwID0gTWF0aC5taW4oc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIHNsaWRlSW5kZXgpO1xuICBsZXQgc25hcEluZGV4ID0gc2tpcCArIE1hdGguZmxvb3IoKHNsaWRlSW5kZXggLSBza2lwKSAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuICBpZiAoc25hcEluZGV4ID49IHNuYXBHcmlkLmxlbmd0aCkgc25hcEluZGV4ID0gc25hcEdyaWQubGVuZ3RoIC0gMTtcbiAgY29uc3QgdHJhbnNsYXRlID0gLXNuYXBHcmlkW3NuYXBJbmRleF07XG4gIC8vIE5vcm1hbGl6ZSBzbGlkZUluZGV4XG4gIGlmIChwYXJhbXMubm9ybWFsaXplU2xpZGVJbmRleCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzR3JpZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZFRyYW5zbGF0ZSA9IC1NYXRoLmZsb29yKHRyYW5zbGF0ZSAqIDEwMCk7XG4gICAgICBjb25zdCBub3JtYWxpemVkR3JpZCA9IE1hdGguZmxvb3Ioc2xpZGVzR3JpZFtpXSAqIDEwMCk7XG4gICAgICBjb25zdCBub3JtYWxpemVkR3JpZE5leHQgPSBNYXRoLmZsb29yKHNsaWRlc0dyaWRbaSArIDFdICogMTAwKTtcbiAgICAgIGlmICh0eXBlb2Ygc2xpZGVzR3JpZFtpICsgMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChub3JtYWxpemVkVHJhbnNsYXRlID49IG5vcm1hbGl6ZWRHcmlkICYmIG5vcm1hbGl6ZWRUcmFuc2xhdGUgPCBub3JtYWxpemVkR3JpZE5leHQgLSAobm9ybWFsaXplZEdyaWROZXh0IC0gbm9ybWFsaXplZEdyaWQpIC8gMikge1xuICAgICAgICAgIHNsaWRlSW5kZXggPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRUcmFuc2xhdGUgPj0gbm9ybWFsaXplZEdyaWQgJiYgbm9ybWFsaXplZFRyYW5zbGF0ZSA8IG5vcm1hbGl6ZWRHcmlkTmV4dCkge1xuICAgICAgICAgIHNsaWRlSW5kZXggPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub3JtYWxpemVkVHJhbnNsYXRlID49IG5vcm1hbGl6ZWRHcmlkKSB7XG4gICAgICAgIHNsaWRlSW5kZXggPSBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBEaXJlY3Rpb25zIGxvY2tzXG4gIGlmIChzd2lwZXIuaW5pdGlhbGl6ZWQgJiYgc2xpZGVJbmRleCAhPT0gYWN0aXZlSW5kZXgpIHtcbiAgICBpZiAoIXN3aXBlci5hbGxvd1NsaWRlTmV4dCAmJiAocnRsID8gdHJhbnNsYXRlID4gc3dpcGVyLnRyYW5zbGF0ZSAmJiB0cmFuc2xhdGUgPiBzd2lwZXIubWluVHJhbnNsYXRlKCkgOiB0cmFuc2xhdGUgPCBzd2lwZXIudHJhbnNsYXRlICYmIHRyYW5zbGF0ZSA8IHN3aXBlci5taW5UcmFuc2xhdGUoKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFzd2lwZXIuYWxsb3dTbGlkZVByZXYgJiYgdHJhbnNsYXRlID4gc3dpcGVyLnRyYW5zbGF0ZSAmJiB0cmFuc2xhdGUgPiBzd2lwZXIubWF4VHJhbnNsYXRlKCkpIHtcbiAgICAgIGlmICgoYWN0aXZlSW5kZXggfHwgMCkgIT09IHNsaWRlSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoc2xpZGVJbmRleCAhPT0gKHByZXZpb3VzSW5kZXggfHwgMCkgJiYgcnVuQ2FsbGJhY2tzKSB7XG4gICAgc3dpcGVyLmVtaXQoJ2JlZm9yZVNsaWRlQ2hhbmdlU3RhcnQnKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSBwcm9ncmVzc1xuICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3ModHJhbnNsYXRlKTtcbiAgbGV0IGRpcmVjdGlvbjtcbiAgaWYgKHNsaWRlSW5kZXggPiBhY3RpdmVJbmRleCkgZGlyZWN0aW9uID0gJ25leHQnO2Vsc2UgaWYgKHNsaWRlSW5kZXggPCBhY3RpdmVJbmRleCkgZGlyZWN0aW9uID0gJ3ByZXYnO2Vsc2UgZGlyZWN0aW9uID0gJ3Jlc2V0JztcblxuICAvLyBVcGRhdGUgSW5kZXhcbiAgaWYgKHJ0bCAmJiAtdHJhbnNsYXRlID09PSBzd2lwZXIudHJhbnNsYXRlIHx8ICFydGwgJiYgdHJhbnNsYXRlID09PSBzd2lwZXIudHJhbnNsYXRlKSB7XG4gICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KHNsaWRlSW5kZXgpO1xuICAgIC8vIFVwZGF0ZSBIZWlnaHRcbiAgICBpZiAocGFyYW1zLmF1dG9IZWlnaHQpIHtcbiAgICAgIHN3aXBlci51cGRhdGVBdXRvSGVpZ2h0KCk7XG4gICAgfVxuICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgaWYgKHBhcmFtcy5lZmZlY3QgIT09ICdzbGlkZScpIHtcbiAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUodHJhbnNsYXRlKTtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ3Jlc2V0Jykge1xuICAgICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gICAgICBzd2lwZXIudHJhbnNpdGlvbkVuZChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICBjb25zdCBpc0ggPSBzd2lwZXIuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdCA9IHJ0bCA/IHRyYW5zbGF0ZSA6IC10cmFuc2xhdGU7XG4gICAgaWYgKHNwZWVkID09PSAwKSB7XG4gICAgICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcbiAgICAgIGlmIChpc1ZpcnR1YWwpIHtcbiAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9ICdub25lJztcbiAgICAgICAgc3dpcGVyLl9pbW1lZGlhdGVWaXJ0dWFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1ZpcnR1YWwgJiYgIXN3aXBlci5fY3NzTW9kZVZpcnR1YWxJbml0aWFsU2V0ICYmIHN3aXBlci5wYXJhbXMuaW5pdGlhbFNsaWRlID4gMCkge1xuICAgICAgICBzd2lwZXIuX2Nzc01vZGVWaXJ0dWFsSW5pdGlhbFNldCA9IHRydWU7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgd3JhcHBlckVsW2lzSCA/ICdzY3JvbGxMZWZ0JyA6ICdzY3JvbGxUb3AnXSA9IHQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JhcHBlckVsW2lzSCA/ICdzY3JvbGxMZWZ0JyA6ICdzY3JvbGxUb3AnXSA9IHQ7XG4gICAgICB9XG4gICAgICBpZiAoaXNWaXJ0dWFsKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9ICcnO1xuICAgICAgICAgIHN3aXBlci5faW1tZWRpYXRlVmlydHVhbCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFzd2lwZXIuc3VwcG9ydC5zbW9vdGhTY3JvbGwpIHtcbiAgICAgICAgYW5pbWF0ZUNTU01vZGVTY3JvbGwoe1xuICAgICAgICAgIHN3aXBlcixcbiAgICAgICAgICB0YXJnZXRQb3NpdGlvbjogdCxcbiAgICAgICAgICBzaWRlOiBpc0ggPyAnbGVmdCcgOiAndG9wJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB3cmFwcGVyRWwuc2Nyb2xsVG8oe1xuICAgICAgICBbaXNIID8gJ2xlZnQnIDogJ3RvcCddOiB0LFxuICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzd2lwZXIuc2V0VHJhbnNpdGlvbihzcGVlZCk7XG4gIHN3aXBlci5zZXRUcmFuc2xhdGUodHJhbnNsYXRlKTtcbiAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KHNsaWRlSW5kZXgpO1xuICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICBzd2lwZXIuZW1pdCgnYmVmb3JlVHJhbnNpdGlvblN0YXJ0Jywgc3BlZWQsIGludGVybmFsKTtcbiAgc3dpcGVyLnRyYW5zaXRpb25TdGFydChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gIGlmIChzcGVlZCA9PT0gMCkge1xuICAgIHN3aXBlci50cmFuc2l0aW9uRW5kKHJ1bkNhbGxiYWNrcywgZGlyZWN0aW9uKTtcbiAgfSBlbHNlIGlmICghc3dpcGVyLmFuaW1hdGluZykge1xuICAgIHN3aXBlci5hbmltYXRpbmcgPSB0cnVlO1xuICAgIGlmICghc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSB7XG4gICAgICBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kKGUpIHtcbiAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICBpZiAoZS50YXJnZXQgIT09IHRoaXMpIHJldHVybjtcbiAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIHN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZDtcbiAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25FbmQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgc3dpcGVyLndyYXBwZXJFbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc2xpZGVUb0xvb3AoaW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKSB7XG4gIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgaW5kZXggPSAwO1xuICB9XG4gIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBpbmRleEFzTnVtYmVyID0gcGFyc2VJbnQoaW5kZXgsIDEwKTtcbiAgICBpbmRleCA9IGluZGV4QXNOdW1iZXI7XG4gIH1cbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcbiAgaWYgKHR5cGVvZiBzcGVlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzcGVlZCA9IHN3aXBlci5wYXJhbXMuc3BlZWQ7XG4gIH1cbiAgY29uc3QgZ3JpZEVuYWJsZWQgPSBzd2lwZXIuZ3JpZCAmJiBzd2lwZXIucGFyYW1zLmdyaWQgJiYgc3dpcGVyLnBhcmFtcy5ncmlkLnJvd3MgPiAxO1xuICBsZXQgbmV3SW5kZXggPSBpbmRleDtcbiAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgIGlmIChzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBuZXdJbmRleCA9IG5ld0luZGV4ICsgc3dpcGVyLnZpcnR1YWwuc2xpZGVzQmVmb3JlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdGFyZ2V0U2xpZGVJbmRleDtcbiAgICAgIGlmIChncmlkRW5hYmxlZCkge1xuICAgICAgICBjb25zdCBzbGlkZUluZGV4ID0gbmV3SW5kZXggKiBzd2lwZXIucGFyYW1zLmdyaWQucm93cztcbiAgICAgICAgdGFyZ2V0U2xpZGVJbmRleCA9IHN3aXBlci5zbGlkZXMuZmlsdGVyKHNsaWRlRWwgPT4gc2xpZGVFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JykgKiAxID09PSBzbGlkZUluZGV4KVswXS5jb2x1bW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRTbGlkZUluZGV4ID0gc3dpcGVyLmdldFNsaWRlSW5kZXhCeURhdGEobmV3SW5kZXgpO1xuICAgICAgfVxuICAgICAgY29uc3QgY29scyA9IGdyaWRFbmFibGVkID8gTWF0aC5jZWlsKHN3aXBlci5zbGlkZXMubGVuZ3RoIC8gc3dpcGVyLnBhcmFtcy5ncmlkLnJvd3MpIDogc3dpcGVyLnNsaWRlcy5sZW5ndGg7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNlbnRlcmVkU2xpZGVzXG4gICAgICB9ID0gc3dpcGVyLnBhcmFtcztcbiAgICAgIGxldCBzbGlkZXNQZXJWaWV3ID0gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3O1xuICAgICAgaWYgKHNsaWRlc1BlclZpZXcgPT09ICdhdXRvJykge1xuICAgICAgICBzbGlkZXNQZXJWaWV3ID0gc3dpcGVyLnNsaWRlc1BlclZpZXdEeW5hbWljKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbGlkZXNQZXJWaWV3ID0gTWF0aC5jZWlsKHBhcnNlRmxvYXQoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3LCAxMCkpO1xuICAgICAgICBpZiAoY2VudGVyZWRTbGlkZXMgJiYgc2xpZGVzUGVyVmlldyAlIDIgPT09IDApIHtcbiAgICAgICAgICBzbGlkZXNQZXJWaWV3ID0gc2xpZGVzUGVyVmlldyArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBuZWVkTG9vcEZpeCA9IGNvbHMgLSB0YXJnZXRTbGlkZUluZGV4IDwgc2xpZGVzUGVyVmlldztcbiAgICAgIGlmIChjZW50ZXJlZFNsaWRlcykge1xuICAgICAgICBuZWVkTG9vcEZpeCA9IG5lZWRMb29wRml4IHx8IHRhcmdldFNsaWRlSW5kZXggPCBNYXRoLmNlaWwoc2xpZGVzUGVyVmlldyAvIDIpO1xuICAgICAgfVxuICAgICAgaWYgKGludGVybmFsICYmIGNlbnRlcmVkU2xpZGVzICYmIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyAhPT0gJ2F1dG8nICYmICFncmlkRW5hYmxlZCkge1xuICAgICAgICBuZWVkTG9vcEZpeCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRMb29wRml4KSB7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGNlbnRlcmVkU2xpZGVzID8gdGFyZ2V0U2xpZGVJbmRleCA8IHN3aXBlci5hY3RpdmVJbmRleCA/ICdwcmV2JyA6ICduZXh0JyA6IHRhcmdldFNsaWRlSW5kZXggLSBzd2lwZXIuYWN0aXZlSW5kZXggLSAxIDwgc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID8gJ25leHQnIDogJ3ByZXYnO1xuICAgICAgICBzd2lwZXIubG9vcEZpeCh7XG4gICAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICAgIHNsaWRlVG86IHRydWUsXG4gICAgICAgICAgYWN0aXZlU2xpZGVJbmRleDogZGlyZWN0aW9uID09PSAnbmV4dCcgPyB0YXJnZXRTbGlkZUluZGV4ICsgMSA6IHRhcmdldFNsaWRlSW5kZXggLSBjb2xzICsgMSxcbiAgICAgICAgICBzbGlkZVJlYWxJbmRleDogZGlyZWN0aW9uID09PSAnbmV4dCcgPyBzd2lwZXIucmVhbEluZGV4IDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGdyaWRFbmFibGVkKSB7XG4gICAgICAgIGNvbnN0IHNsaWRlSW5kZXggPSBuZXdJbmRleCAqIHN3aXBlci5wYXJhbXMuZ3JpZC5yb3dzO1xuICAgICAgICBuZXdJbmRleCA9IHN3aXBlci5zbGlkZXMuZmlsdGVyKHNsaWRlRWwgPT4gc2xpZGVFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JykgKiAxID09PSBzbGlkZUluZGV4KVswXS5jb2x1bW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdJbmRleCA9IHN3aXBlci5nZXRTbGlkZUluZGV4QnlEYXRhKG5ld0luZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICBzd2lwZXIuc2xpZGVUbyhuZXdJbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xuICB9KTtcbiAgcmV0dXJuIHN3aXBlcjtcbn1cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBcIm9mZlwiICovXG5mdW5jdGlvbiBzbGlkZU5leHQoc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpIHtcbiAgaWYgKHJ1bkNhbGxiYWNrcyA9PT0gdm9pZCAwKSB7XG4gICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCxcbiAgICBwYXJhbXMsXG4gICAgYW5pbWF0aW5nXG4gIH0gPSBzd2lwZXI7XG4gIGlmICghZW5hYmxlZCB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm4gc3dpcGVyO1xuICBpZiAodHlwZW9mIHNwZWVkID09PSAndW5kZWZpbmVkJykge1xuICAgIHNwZWVkID0gc3dpcGVyLnBhcmFtcy5zcGVlZDtcbiAgfVxuICBsZXQgcGVyR3JvdXAgPSBwYXJhbXMuc2xpZGVzUGVyR3JvdXA7XG4gIGlmIChwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nICYmIHBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PT0gMSAmJiBwYXJhbXMuc2xpZGVzUGVyR3JvdXBBdXRvKSB7XG4gICAgcGVyR3JvdXAgPSBNYXRoLm1heChzd2lwZXIuc2xpZGVzUGVyVmlld0R5bmFtaWMoJ2N1cnJlbnQnLCB0cnVlKSwgMSk7XG4gIH1cbiAgY29uc3QgaW5jcmVtZW50ID0gc3dpcGVyLmFjdGl2ZUluZGV4IDwgcGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCA/IDEgOiBwZXJHcm91cDtcbiAgY29uc3QgaXNWaXJ0dWFsID0gc3dpcGVyLnZpcnR1YWwgJiYgcGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcbiAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgaWYgKGFuaW1hdGluZyAmJiAhaXNWaXJ0dWFsICYmIHBhcmFtcy5sb29wUHJldmVudHNTbGlkaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpcGVyLmxvb3BGaXgoe1xuICAgICAgZGlyZWN0aW9uOiAnbmV4dCdcbiAgICB9KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBzd2lwZXIuX2NsaWVudExlZnQgPSBzd2lwZXIud3JhcHBlckVsLmNsaWVudExlZnQ7XG4gICAgaWYgKHN3aXBlci5hY3RpdmVJbmRleCA9PT0gc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxICYmIHBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXggKyBpbmNyZW1lbnQsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChwYXJhbXMucmV3aW5kICYmIHN3aXBlci5pc0VuZCkge1xuICAgIHJldHVybiBzd2lwZXIuc2xpZGVUbygwLCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCk7XG4gIH1cbiAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCArIGluY3JlbWVudCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xufVxuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFwib2ZmXCIgKi9cbmZ1bmN0aW9uIHNsaWRlUHJldihzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCkge1xuICBpZiAocnVuQ2FsbGJhY2tzID09PSB2b2lkIDApIHtcbiAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsXG4gICAgc25hcEdyaWQsXG4gICAgc2xpZGVzR3JpZCxcbiAgICBydGxUcmFuc2xhdGUsXG4gICAgZW5hYmxlZCxcbiAgICBhbmltYXRpbmdcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKCFlbmFibGVkIHx8IHN3aXBlci5kZXN0cm95ZWQpIHJldHVybiBzd2lwZXI7XG4gIGlmICh0eXBlb2Ygc3BlZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3BlZWQgPSBzd2lwZXIucGFyYW1zLnNwZWVkO1xuICB9XG4gIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7XG4gIGlmIChwYXJhbXMubG9vcCkge1xuICAgIGlmIChhbmltYXRpbmcgJiYgIWlzVmlydHVhbCAmJiBwYXJhbXMubG9vcFByZXZlbnRzU2xpZGluZykgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXBlci5sb29wRml4KHtcbiAgICAgIGRpcmVjdGlvbjogJ3ByZXYnXG4gICAgfSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgc3dpcGVyLl9jbGllbnRMZWZ0ID0gc3dpcGVyLndyYXBwZXJFbC5jbGllbnRMZWZ0O1xuICB9XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IHJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcbiAgZnVuY3Rpb24gbm9ybWFsaXplKHZhbCkge1xuICAgIGlmICh2YWwgPCAwKSByZXR1cm4gLU1hdGguZmxvb3IoTWF0aC5hYnModmFsKSk7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IodmFsKTtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkVHJhbnNsYXRlID0gbm9ybWFsaXplKHRyYW5zbGF0ZSk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRTbmFwR3JpZCA9IHNuYXBHcmlkLm1hcCh2YWwgPT4gbm9ybWFsaXplKHZhbCkpO1xuICBsZXQgcHJldlNuYXAgPSBzbmFwR3JpZFtub3JtYWxpemVkU25hcEdyaWQuaW5kZXhPZihub3JtYWxpemVkVHJhbnNsYXRlKSAtIDFdO1xuICBpZiAodHlwZW9mIHByZXZTbmFwID09PSAndW5kZWZpbmVkJyAmJiBwYXJhbXMuY3NzTW9kZSkge1xuICAgIGxldCBwcmV2U25hcEluZGV4O1xuICAgIHNuYXBHcmlkLmZvckVhY2goKHNuYXAsIHNuYXBJbmRleCkgPT4ge1xuICAgICAgaWYgKG5vcm1hbGl6ZWRUcmFuc2xhdGUgPj0gc25hcCkge1xuICAgICAgICAvLyBwcmV2U25hcCA9IHNuYXA7XG4gICAgICAgIHByZXZTbmFwSW5kZXggPSBzbmFwSW5kZXg7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBwcmV2U25hcEluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcHJldlNuYXAgPSBzbmFwR3JpZFtwcmV2U25hcEluZGV4ID4gMCA/IHByZXZTbmFwSW5kZXggLSAxIDogcHJldlNuYXBJbmRleF07XG4gICAgfVxuICB9XG4gIGxldCBwcmV2SW5kZXggPSAwO1xuICBpZiAodHlwZW9mIHByZXZTbmFwICE9PSAndW5kZWZpbmVkJykge1xuICAgIHByZXZJbmRleCA9IHNsaWRlc0dyaWQuaW5kZXhPZihwcmV2U25hcCk7XG4gICAgaWYgKHByZXZJbmRleCA8IDApIHByZXZJbmRleCA9IHN3aXBlci5hY3RpdmVJbmRleCAtIDE7XG4gICAgaWYgKHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycgJiYgcGFyYW1zLnNsaWRlc1Blckdyb3VwID09PSAxICYmIHBhcmFtcy5zbGlkZXNQZXJHcm91cEF1dG8pIHtcbiAgICAgIHByZXZJbmRleCA9IHByZXZJbmRleCAtIHN3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygncHJldmlvdXMnLCB0cnVlKSArIDE7XG4gICAgICBwcmV2SW5kZXggPSBNYXRoLm1heChwcmV2SW5kZXgsIDApO1xuICAgIH1cbiAgfVxuICBpZiAocGFyYW1zLnJld2luZCAmJiBzd2lwZXIuaXNCZWdpbm5pbmcpIHtcbiAgICBjb25zdCBsYXN0SW5kZXggPSBzd2lwZXIucGFyYW1zLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgJiYgc3dpcGVyLnZpcnR1YWwgPyBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoIC0gMSA6IHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gc3dpcGVyLnNsaWRlVG8obGFzdEluZGV4LCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCk7XG4gIH0gZWxzZSBpZiAocGFyYW1zLmxvb3AgJiYgc3dpcGVyLmFjdGl2ZUluZGV4ID09PSAwICYmIHBhcmFtcy5jc3NNb2RlKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHByZXZJbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBzd2lwZXIuc2xpZGVUbyhwcmV2SW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbn1cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBcIm9mZlwiICovXG5mdW5jdGlvbiBzbGlkZVJlc2V0KHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKSB7XG4gIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XG4gIH1cbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcbiAgaWYgKHR5cGVvZiBzcGVlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzcGVlZCA9IHN3aXBlci5wYXJhbXMuc3BlZWQ7XG4gIH1cbiAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xufVxuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFwib2ZmXCIgKi9cbmZ1bmN0aW9uIHNsaWRlVG9DbG9zZXN0KHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsLCB0aHJlc2hvbGQpIHtcbiAgaWYgKHJ1bkNhbGxiYWNrcyA9PT0gdm9pZCAwKSB7XG4gICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgfVxuICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICB0aHJlc2hvbGQgPSAwLjU7XG4gIH1cbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcbiAgaWYgKHR5cGVvZiBzcGVlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzcGVlZCA9IHN3aXBlci5wYXJhbXMuc3BlZWQ7XG4gIH1cbiAgbGV0IGluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4O1xuICBjb25zdCBza2lwID0gTWF0aC5taW4oc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIGluZGV4KTtcbiAgY29uc3Qgc25hcEluZGV4ID0gc2tpcCArIE1hdGguZmxvb3IoKGluZGV4IC0gc2tpcCkgLyBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcbiAgY29uc3QgdHJhbnNsYXRlID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcbiAgaWYgKHRyYW5zbGF0ZSA+PSBzd2lwZXIuc25hcEdyaWRbc25hcEluZGV4XSkge1xuICAgIC8vIFRoZSBjdXJyZW50IHRyYW5zbGF0ZSBpcyBvbiBvciBhZnRlciB0aGUgY3VycmVudCBzbmFwIGluZGV4LCBzbyB0aGUgY2hvaWNlXG4gICAgLy8gaXMgYmV0d2VlbiB0aGUgY3VycmVudCBpbmRleCBhbmQgdGhlIG9uZSBhZnRlciBpdC5cbiAgICBjb25zdCBjdXJyZW50U25hcCA9IHN3aXBlci5zbmFwR3JpZFtzbmFwSW5kZXhdO1xuICAgIGNvbnN0IG5leHRTbmFwID0gc3dpcGVyLnNuYXBHcmlkW3NuYXBJbmRleCArIDFdO1xuICAgIGlmICh0cmFuc2xhdGUgLSBjdXJyZW50U25hcCA+IChuZXh0U25hcCAtIGN1cnJlbnRTbmFwKSAqIHRocmVzaG9sZCkge1xuICAgICAgaW5kZXggKz0gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgdHJhbnNsYXRlIGlzIGJlZm9yZSB0aGUgY3VycmVudCBzbmFwIGluZGV4LCBzbyB0aGUgY2hvaWNlXG4gICAgLy8gaXMgYmV0d2VlbiB0aGUgY3VycmVudCBpbmRleCBhbmQgdGhlIG9uZSBiZWZvcmUgaXQuXG4gICAgY29uc3QgcHJldlNuYXAgPSBzd2lwZXIuc25hcEdyaWRbc25hcEluZGV4IC0gMV07XG4gICAgY29uc3QgY3VycmVudFNuYXAgPSBzd2lwZXIuc25hcEdyaWRbc25hcEluZGV4XTtcbiAgICBpZiAodHJhbnNsYXRlIC0gcHJldlNuYXAgPD0gKGN1cnJlbnRTbmFwIC0gcHJldlNuYXApICogdGhyZXNob2xkKSB7XG4gICAgICBpbmRleCAtPSBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuICAgIH1cbiAgfVxuICBpbmRleCA9IE1hdGgubWF4KGluZGV4LCAwKTtcbiAgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgc3dpcGVyLnNsaWRlc0dyaWQubGVuZ3RoIC0gMSk7XG4gIHJldHVybiBzd2lwZXIuc2xpZGVUbyhpbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xufVxuXG5mdW5jdGlvbiBzbGlkZVRvQ2xpY2tlZFNsaWRlKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBpZiAoc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICBjb25zdCB7XG4gICAgcGFyYW1zLFxuICAgIHNsaWRlc0VsXG4gIH0gPSBzd2lwZXI7XG4gIGNvbnN0IHNsaWRlc1BlclZpZXcgPSBwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nID8gc3dpcGVyLnNsaWRlc1BlclZpZXdEeW5hbWljKCkgOiBwYXJhbXMuc2xpZGVzUGVyVmlldztcbiAgbGV0IHNsaWRlVG9JbmRleCA9IHN3aXBlci5jbGlja2VkSW5kZXg7XG4gIGxldCByZWFsSW5kZXg7XG4gIGNvbnN0IHNsaWRlU2VsZWN0b3IgPSBzd2lwZXIuaXNFbGVtZW50ID8gYHN3aXBlci1zbGlkZWAgOiBgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9YDtcbiAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgaWYgKHN3aXBlci5hbmltYXRpbmcpIHJldHVybjtcbiAgICByZWFsSW5kZXggPSBwYXJzZUludChzd2lwZXIuY2xpY2tlZFNsaWRlLmdldEF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSwgMTApO1xuICAgIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgIGlmIChzbGlkZVRvSW5kZXggPCBzd2lwZXIubG9vcGVkU2xpZGVzIC0gc2xpZGVzUGVyVmlldyAvIDIgfHwgc2xpZGVUb0luZGV4ID4gc3dpcGVyLnNsaWRlcy5sZW5ndGggLSBzd2lwZXIubG9vcGVkU2xpZGVzICsgc2xpZGVzUGVyVmlldyAvIDIpIHtcbiAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgICAgc2xpZGVUb0luZGV4ID0gc3dpcGVyLmdldFNsaWRlSW5kZXgoZWxlbWVudENoaWxkcmVuKHNsaWRlc0VsLCBgJHtzbGlkZVNlbGVjdG9yfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7cmVhbEluZGV4fVwiXWApWzBdKTtcbiAgICAgICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc2xpZGVUb0luZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNsaWRlVG9JbmRleCA+IHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gc2xpZGVzUGVyVmlldykge1xuICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgIHNsaWRlVG9JbmRleCA9IHN3aXBlci5nZXRTbGlkZUluZGV4KGVsZW1lbnRDaGlsZHJlbihzbGlkZXNFbCwgYCR7c2xpZGVTZWxlY3Rvcn1bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3JlYWxJbmRleH1cIl1gKVswXSk7XG4gICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpcGVyLnNsaWRlVG8oc2xpZGVUb0luZGV4KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3dpcGVyLnNsaWRlVG8oc2xpZGVUb0luZGV4KTtcbiAgfVxufVxuXG52YXIgc2xpZGUgPSB7XG4gIHNsaWRlVG8sXG4gIHNsaWRlVG9Mb29wLFxuICBzbGlkZU5leHQsXG4gIHNsaWRlUHJldixcbiAgc2xpZGVSZXNldCxcbiAgc2xpZGVUb0Nsb3Nlc3QsXG4gIHNsaWRlVG9DbGlja2VkU2xpZGVcbn07XG5cbmZ1bmN0aW9uIGxvb3BDcmVhdGUoc2xpZGVSZWFsSW5kZXgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHBhcmFtcyxcbiAgICBzbGlkZXNFbFxuICB9ID0gc3dpcGVyO1xuICBpZiAoIXBhcmFtcy5sb29wIHx8IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkKSByZXR1cm47XG4gIGNvbnN0IGluaXRTbGlkZXMgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2xpZGVzID0gZWxlbWVudENoaWxkcmVuKHNsaWRlc0VsLCBgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LCBzd2lwZXItc2xpZGVgKTtcbiAgICBzbGlkZXMuZm9yRWFjaCgoZWwsIGluZGV4KSA9PiB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JywgaW5kZXgpO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBncmlkRW5hYmxlZCA9IHN3aXBlci5ncmlkICYmIHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxO1xuICBjb25zdCBzbGlkZXNQZXJHcm91cCA9IHBhcmFtcy5zbGlkZXNQZXJHcm91cCAqIChncmlkRW5hYmxlZCA/IHBhcmFtcy5ncmlkLnJvd3MgOiAxKTtcbiAgY29uc3Qgc2hvdWxkRmlsbEdyb3VwID0gc3dpcGVyLnNsaWRlcy5sZW5ndGggJSBzbGlkZXNQZXJHcm91cCAhPT0gMDtcbiAgY29uc3Qgc2hvdWxkRmlsbEdyaWQgPSBncmlkRW5hYmxlZCAmJiBzd2lwZXIuc2xpZGVzLmxlbmd0aCAlIHBhcmFtcy5ncmlkLnJvd3MgIT09IDA7XG4gIGNvbnN0IGFkZEJsYW5rU2xpZGVzID0gYW1vdW50T2ZTbGlkZXMgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW1vdW50T2ZTbGlkZXM7IGkgKz0gMSkge1xuICAgICAgY29uc3Qgc2xpZGVFbCA9IHN3aXBlci5pc0VsZW1lbnQgPyBjcmVhdGVFbGVtZW50KCdzd2lwZXItc2xpZGUnLCBbcGFyYW1zLnNsaWRlQmxhbmtDbGFzc10pIDogY3JlYXRlRWxlbWVudCgnZGl2JywgW3BhcmFtcy5zbGlkZUNsYXNzLCBwYXJhbXMuc2xpZGVCbGFua0NsYXNzXSk7XG4gICAgICBzd2lwZXIuc2xpZGVzRWwuYXBwZW5kKHNsaWRlRWwpO1xuICAgIH1cbiAgfTtcbiAgaWYgKHNob3VsZEZpbGxHcm91cCkge1xuICAgIGlmIChwYXJhbXMubG9vcEFkZEJsYW5rU2xpZGVzKSB7XG4gICAgICBjb25zdCBzbGlkZXNUb0FkZCA9IHNsaWRlc1Blckdyb3VwIC0gc3dpcGVyLnNsaWRlcy5sZW5ndGggJSBzbGlkZXNQZXJHcm91cDtcbiAgICAgIGFkZEJsYW5rU2xpZGVzKHNsaWRlc1RvQWRkKTtcbiAgICAgIHN3aXBlci5yZWNhbGNTbGlkZXMoKTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvd1dhcm5pbmcoJ1N3aXBlciBMb29wIFdhcm5pbmc6IFRoZSBudW1iZXIgb2Ygc2xpZGVzIGlzIG5vdCBldmVuIHRvIHNsaWRlc1Blckdyb3VwLCBsb29wIG1vZGUgbWF5IG5vdCBmdW5jdGlvbiBwcm9wZXJseS4gWW91IG5lZWQgdG8gYWRkIG1vcmUgc2xpZGVzIChvciBtYWtlIGR1cGxpY2F0ZXMsIG9yIGVtcHR5IHNsaWRlcyknKTtcbiAgICB9XG4gICAgaW5pdFNsaWRlcygpO1xuICB9IGVsc2UgaWYgKHNob3VsZEZpbGxHcmlkKSB7XG4gICAgaWYgKHBhcmFtcy5sb29wQWRkQmxhbmtTbGlkZXMpIHtcbiAgICAgIGNvbnN0IHNsaWRlc1RvQWRkID0gcGFyYW1zLmdyaWQucm93cyAtIHN3aXBlci5zbGlkZXMubGVuZ3RoICUgcGFyYW1zLmdyaWQucm93cztcbiAgICAgIGFkZEJsYW5rU2xpZGVzKHNsaWRlc1RvQWRkKTtcbiAgICAgIHN3aXBlci5yZWNhbGNTbGlkZXMoKTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvd1dhcm5pbmcoJ1N3aXBlciBMb29wIFdhcm5pbmc6IFRoZSBudW1iZXIgb2Ygc2xpZGVzIGlzIG5vdCBldmVuIHRvIGdyaWQucm93cywgbG9vcCBtb2RlIG1heSBub3QgZnVuY3Rpb24gcHJvcGVybHkuIFlvdSBuZWVkIHRvIGFkZCBtb3JlIHNsaWRlcyAob3IgbWFrZSBkdXBsaWNhdGVzLCBvciBlbXB0eSBzbGlkZXMpJyk7XG4gICAgfVxuICAgIGluaXRTbGlkZXMoKTtcbiAgfSBlbHNlIHtcbiAgICBpbml0U2xpZGVzKCk7XG4gIH1cbiAgc3dpcGVyLmxvb3BGaXgoe1xuICAgIHNsaWRlUmVhbEluZGV4LFxuICAgIGRpcmVjdGlvbjogcGFyYW1zLmNlbnRlcmVkU2xpZGVzID8gdW5kZWZpbmVkIDogJ25leHQnXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBsb29wRml4KF90ZW1wKSB7XG4gIGxldCB7XG4gICAgc2xpZGVSZWFsSW5kZXgsXG4gICAgc2xpZGVUbyA9IHRydWUsXG4gICAgZGlyZWN0aW9uLFxuICAgIHNldFRyYW5zbGF0ZSxcbiAgICBhY3RpdmVTbGlkZUluZGV4LFxuICAgIGJ5Q29udHJvbGxlcixcbiAgICBieU1vdXNld2hlZWxcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBpZiAoIXN3aXBlci5wYXJhbXMubG9vcCkgcmV0dXJuO1xuICBzd2lwZXIuZW1pdCgnYmVmb3JlTG9vcEZpeCcpO1xuICBjb25zdCB7XG4gICAgc2xpZGVzLFxuICAgIGFsbG93U2xpZGVQcmV2LFxuICAgIGFsbG93U2xpZGVOZXh0LFxuICAgIHNsaWRlc0VsLFxuICAgIHBhcmFtc1xuICB9ID0gc3dpcGVyO1xuICBjb25zdCB7XG4gICAgY2VudGVyZWRTbGlkZXNcbiAgfSA9IHBhcmFtcztcbiAgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID0gdHJ1ZTtcbiAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gdHJ1ZTtcbiAgaWYgKHN3aXBlci52aXJ0dWFsICYmIHBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHtcbiAgICBpZiAoc2xpZGVUbykge1xuICAgICAgaWYgKCFwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgc3dpcGVyLnNuYXBJbmRleCA9PT0gMCkge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoLCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiBzd2lwZXIuc25hcEluZGV4IDwgcGFyYW1zLnNsaWRlc1BlclZpZXcpIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCArIHN3aXBlci5zbmFwSW5kZXgsIDAsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3dpcGVyLnNuYXBJbmRleCA9PT0gc3dpcGVyLnNuYXBHcmlkLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnZpcnR1YWwuc2xpZGVzQmVmb3JlLCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IGFsbG93U2xpZGVQcmV2O1xuICAgIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IGFsbG93U2xpZGVOZXh0O1xuICAgIHN3aXBlci5lbWl0KCdsb29wRml4Jyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzbGlkZXNQZXJWaWV3ID0gcGFyYW1zLnNsaWRlc1BlclZpZXc7XG4gIGlmIChzbGlkZXNQZXJWaWV3ID09PSAnYXV0bycpIHtcbiAgICBzbGlkZXNQZXJWaWV3ID0gc3dpcGVyLnNsaWRlc1BlclZpZXdEeW5hbWljKCk7XG4gIH0gZWxzZSB7XG4gICAgc2xpZGVzUGVyVmlldyA9IE1hdGguY2VpbChwYXJzZUZsb2F0KHBhcmFtcy5zbGlkZXNQZXJWaWV3LCAxMCkpO1xuICAgIGlmIChjZW50ZXJlZFNsaWRlcyAmJiBzbGlkZXNQZXJWaWV3ICUgMiA9PT0gMCkge1xuICAgICAgc2xpZGVzUGVyVmlldyA9IHNsaWRlc1BlclZpZXcgKyAxO1xuICAgIH1cbiAgfVxuICBjb25zdCBzbGlkZXNQZXJHcm91cCA9IHBhcmFtcy5zbGlkZXNQZXJHcm91cEF1dG8gPyBzbGlkZXNQZXJWaWV3IDogcGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuICBsZXQgbG9vcGVkU2xpZGVzID0gc2xpZGVzUGVyR3JvdXA7XG4gIGlmIChsb29wZWRTbGlkZXMgJSBzbGlkZXNQZXJHcm91cCAhPT0gMCkge1xuICAgIGxvb3BlZFNsaWRlcyArPSBzbGlkZXNQZXJHcm91cCAtIGxvb3BlZFNsaWRlcyAlIHNsaWRlc1Blckdyb3VwO1xuICB9XG4gIGxvb3BlZFNsaWRlcyArPSBwYXJhbXMubG9vcEFkZGl0aW9uYWxTbGlkZXM7XG4gIHN3aXBlci5sb29wZWRTbGlkZXMgPSBsb29wZWRTbGlkZXM7XG4gIGNvbnN0IGdyaWRFbmFibGVkID0gc3dpcGVyLmdyaWQgJiYgcGFyYW1zLmdyaWQgJiYgcGFyYW1zLmdyaWQucm93cyA+IDE7XG4gIGlmIChzbGlkZXMubGVuZ3RoIDwgc2xpZGVzUGVyVmlldyArIGxvb3BlZFNsaWRlcykge1xuICAgIHNob3dXYXJuaW5nKCdTd2lwZXIgTG9vcCBXYXJuaW5nOiBUaGUgbnVtYmVyIG9mIHNsaWRlcyBpcyBub3QgZW5vdWdoIGZvciBsb29wIG1vZGUsIGl0IHdpbGwgYmUgZGlzYWJsZWQgYW5kIG5vdCBmdW5jdGlvbiBwcm9wZXJseS4gWW91IG5lZWQgdG8gYWRkIG1vcmUgc2xpZGVzIChvciBtYWtlIGR1cGxpY2F0ZXMpIG9yIGxvd2VyIHRoZSB2YWx1ZXMgb2Ygc2xpZGVzUGVyVmlldyBhbmQgc2xpZGVzUGVyR3JvdXAgcGFyYW1ldGVycycpO1xuICB9IGVsc2UgaWYgKGdyaWRFbmFibGVkICYmIHBhcmFtcy5ncmlkLmZpbGwgPT09ICdyb3cnKSB7XG4gICAgc2hvd1dhcm5pbmcoJ1N3aXBlciBMb29wIFdhcm5pbmc6IExvb3AgbW9kZSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGdyaWQuZmlsbCA9IGByb3dgJyk7XG4gIH1cbiAgY29uc3QgcHJlcGVuZFNsaWRlc0luZGV4ZXMgPSBbXTtcbiAgY29uc3QgYXBwZW5kU2xpZGVzSW5kZXhlcyA9IFtdO1xuICBsZXQgYWN0aXZlSW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXg7XG4gIGlmICh0eXBlb2YgYWN0aXZlU2xpZGVJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBhY3RpdmVTbGlkZUluZGV4ID0gc3dpcGVyLmdldFNsaWRlSW5kZXgoc2xpZGVzLmZpbHRlcihlbCA9PiBlbC5jbGFzc0xpc3QuY29udGFpbnMocGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3MpKVswXSk7XG4gIH0gZWxzZSB7XG4gICAgYWN0aXZlSW5kZXggPSBhY3RpdmVTbGlkZUluZGV4O1xuICB9XG4gIGNvbnN0IGlzTmV4dCA9IGRpcmVjdGlvbiA9PT0gJ25leHQnIHx8ICFkaXJlY3Rpb247XG4gIGNvbnN0IGlzUHJldiA9IGRpcmVjdGlvbiA9PT0gJ3ByZXYnIHx8ICFkaXJlY3Rpb247XG4gIGxldCBzbGlkZXNQcmVwZW5kZWQgPSAwO1xuICBsZXQgc2xpZGVzQXBwZW5kZWQgPSAwO1xuICBjb25zdCBjb2xzID0gZ3JpZEVuYWJsZWQgPyBNYXRoLmNlaWwoc2xpZGVzLmxlbmd0aCAvIHBhcmFtcy5ncmlkLnJvd3MpIDogc2xpZGVzLmxlbmd0aDtcbiAgY29uc3QgYWN0aXZlQ29sSW5kZXggPSBncmlkRW5hYmxlZCA/IHNsaWRlc1thY3RpdmVTbGlkZUluZGV4XS5jb2x1bW4gOiBhY3RpdmVTbGlkZUluZGV4O1xuICBjb25zdCBhY3RpdmVDb2xJbmRleFdpdGhTaGlmdCA9IGFjdGl2ZUNvbEluZGV4ICsgKGNlbnRlcmVkU2xpZGVzICYmIHR5cGVvZiBzZXRUcmFuc2xhdGUgPT09ICd1bmRlZmluZWQnID8gLXNsaWRlc1BlclZpZXcgLyAyICsgMC41IDogMCk7XG4gIC8vIHByZXBlbmQgbGFzdCBzbGlkZXMgYmVmb3JlIHN0YXJ0XG4gIGlmIChhY3RpdmVDb2xJbmRleFdpdGhTaGlmdCA8IGxvb3BlZFNsaWRlcykge1xuICAgIHNsaWRlc1ByZXBlbmRlZCA9IE1hdGgubWF4KGxvb3BlZFNsaWRlcyAtIGFjdGl2ZUNvbEluZGV4V2l0aFNoaWZ0LCBzbGlkZXNQZXJHcm91cCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb29wZWRTbGlkZXMgLSBhY3RpdmVDb2xJbmRleFdpdGhTaGlmdDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGkgLSBNYXRoLmZsb29yKGkgLyBjb2xzKSAqIGNvbHM7XG4gICAgICBpZiAoZ3JpZEVuYWJsZWQpIHtcbiAgICAgICAgY29uc3QgY29sSW5kZXhUb1ByZXBlbmQgPSBjb2xzIC0gaW5kZXggLSAxO1xuICAgICAgICBmb3IgKGxldCBpID0gc2xpZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgaWYgKHNsaWRlc1tpXS5jb2x1bW4gPT09IGNvbEluZGV4VG9QcmVwZW5kKSBwcmVwZW5kU2xpZGVzSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNsaWRlcy5mb3JFYWNoKChzbGlkZSwgc2xpZGVJbmRleCkgPT4ge1xuICAgICAgICAvLyAgIGlmIChzbGlkZS5jb2x1bW4gPT09IGNvbEluZGV4VG9QcmVwZW5kKSBwcmVwZW5kU2xpZGVzSW5kZXhlcy5wdXNoKHNsaWRlSW5kZXgpO1xuICAgICAgICAvLyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXBlbmRTbGlkZXNJbmRleGVzLnB1c2goY29scyAtIGluZGV4IC0gMSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFjdGl2ZUNvbEluZGV4V2l0aFNoaWZ0ICsgc2xpZGVzUGVyVmlldyA+IGNvbHMgLSBsb29wZWRTbGlkZXMpIHtcbiAgICBzbGlkZXNBcHBlbmRlZCA9IE1hdGgubWF4KGFjdGl2ZUNvbEluZGV4V2l0aFNoaWZ0IC0gKGNvbHMgLSBsb29wZWRTbGlkZXMgKiAyKSwgc2xpZGVzUGVyR3JvdXApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzQXBwZW5kZWQ7IGkgKz0gMSkge1xuICAgICAgY29uc3QgaW5kZXggPSBpIC0gTWF0aC5mbG9vcihpIC8gY29scykgKiBjb2xzO1xuICAgICAgaWYgKGdyaWRFbmFibGVkKSB7XG4gICAgICAgIHNsaWRlcy5mb3JFYWNoKChzbGlkZSwgc2xpZGVJbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChzbGlkZS5jb2x1bW4gPT09IGluZGV4KSBhcHBlbmRTbGlkZXNJbmRleGVzLnB1c2goc2xpZGVJbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwZW5kU2xpZGVzSW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3dpcGVyLl9fcHJldmVudE9ic2VydmVyX18gPSB0cnVlO1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIHN3aXBlci5fX3ByZXZlbnRPYnNlcnZlcl9fID0gZmFsc2U7XG4gIH0pO1xuICBpZiAoaXNQcmV2KSB7XG4gICAgcHJlcGVuZFNsaWRlc0luZGV4ZXMuZm9yRWFjaChpbmRleCA9PiB7XG4gICAgICBzbGlkZXNbaW5kZXhdLnN3aXBlckxvb3BNb3ZlRE9NID0gdHJ1ZTtcbiAgICAgIHNsaWRlc0VsLnByZXBlbmQoc2xpZGVzW2luZGV4XSk7XG4gICAgICBzbGlkZXNbaW5kZXhdLnN3aXBlckxvb3BNb3ZlRE9NID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGlzTmV4dCkge1xuICAgIGFwcGVuZFNsaWRlc0luZGV4ZXMuZm9yRWFjaChpbmRleCA9PiB7XG4gICAgICBzbGlkZXNbaW5kZXhdLnN3aXBlckxvb3BNb3ZlRE9NID0gdHJ1ZTtcbiAgICAgIHNsaWRlc0VsLmFwcGVuZChzbGlkZXNbaW5kZXhdKTtcbiAgICAgIHNsaWRlc1tpbmRleF0uc3dpcGVyTG9vcE1vdmVET00gPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuICBzd2lwZXIucmVjYWxjU2xpZGVzKCk7XG4gIGlmIChwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nKSB7XG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuICB9IGVsc2UgaWYgKGdyaWRFbmFibGVkICYmIChwcmVwZW5kU2xpZGVzSW5kZXhlcy5sZW5ndGggPiAwICYmIGlzUHJldiB8fCBhcHBlbmRTbGlkZXNJbmRleGVzLmxlbmd0aCA+IDAgJiYgaXNOZXh0KSkge1xuICAgIHN3aXBlci5zbGlkZXMuZm9yRWFjaCgoc2xpZGUsIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgIHN3aXBlci5ncmlkLnVwZGF0ZVNsaWRlKHNsaWRlSW5kZXgsIHNsaWRlLCBzd2lwZXIuc2xpZGVzKTtcbiAgICB9KTtcbiAgfVxuICBpZiAocGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MpIHtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzT2Zmc2V0KCk7XG4gIH1cbiAgaWYgKHNsaWRlVG8pIHtcbiAgICBpZiAocHJlcGVuZFNsaWRlc0luZGV4ZXMubGVuZ3RoID4gMCAmJiBpc1ByZXYpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2xpZGVSZWFsSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTbGlkZVRyYW5zbGF0ZSA9IHN3aXBlci5zbGlkZXNHcmlkW2FjdGl2ZUluZGV4XTtcbiAgICAgICAgY29uc3QgbmV3U2xpZGVUcmFuc2xhdGUgPSBzd2lwZXIuc2xpZGVzR3JpZFthY3RpdmVJbmRleCArIHNsaWRlc1ByZXBlbmRlZF07XG4gICAgICAgIGNvbnN0IGRpZmYgPSBuZXdTbGlkZVRyYW5zbGF0ZSAtIGN1cnJlbnRTbGlkZVRyYW5zbGF0ZTtcbiAgICAgICAgaWYgKGJ5TW91c2V3aGVlbCkge1xuICAgICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUoc3dpcGVyLnRyYW5zbGF0ZSAtIGRpZmYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKGFjdGl2ZUluZGV4ICsgTWF0aC5jZWlsKHNsaWRlc1ByZXBlbmRlZCksIDAsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICBpZiAoc2V0VHJhbnNsYXRlKSB7XG4gICAgICAgICAgICBzd2lwZXIudG91Y2hFdmVudHNEYXRhLnN0YXJ0VHJhbnNsYXRlID0gc3dpcGVyLnRvdWNoRXZlbnRzRGF0YS5zdGFydFRyYW5zbGF0ZSAtIGRpZmY7XG4gICAgICAgICAgICBzd2lwZXIudG91Y2hFdmVudHNEYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBzd2lwZXIudG91Y2hFdmVudHNEYXRhLmN1cnJlbnRUcmFuc2xhdGUgLSBkaWZmO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNldFRyYW5zbGF0ZSkge1xuICAgICAgICAgIGNvbnN0IHNoaWZ0ID0gZ3JpZEVuYWJsZWQgPyBwcmVwZW5kU2xpZGVzSW5kZXhlcy5sZW5ndGggLyBwYXJhbXMuZ3JpZC5yb3dzIDogcHJlcGVuZFNsaWRlc0luZGV4ZXMubGVuZ3RoO1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCArIHNoaWZ0LCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgc3dpcGVyLnRvdWNoRXZlbnRzRGF0YS5jdXJyZW50VHJhbnNsYXRlID0gc3dpcGVyLnRyYW5zbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXBwZW5kU2xpZGVzSW5kZXhlcy5sZW5ndGggPiAwICYmIGlzTmV4dCkge1xuICAgICAgaWYgKHR5cGVvZiBzbGlkZVJlYWxJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFNsaWRlVHJhbnNsYXRlID0gc3dpcGVyLnNsaWRlc0dyaWRbYWN0aXZlSW5kZXhdO1xuICAgICAgICBjb25zdCBuZXdTbGlkZVRyYW5zbGF0ZSA9IHN3aXBlci5zbGlkZXNHcmlkW2FjdGl2ZUluZGV4IC0gc2xpZGVzQXBwZW5kZWRdO1xuICAgICAgICBjb25zdCBkaWZmID0gbmV3U2xpZGVUcmFuc2xhdGUgLSBjdXJyZW50U2xpZGVUcmFuc2xhdGU7XG4gICAgICAgIGlmIChieU1vdXNld2hlZWwpIHtcbiAgICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKHN3aXBlci50cmFuc2xhdGUgLSBkaWZmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhhY3RpdmVJbmRleCAtIHNsaWRlc0FwcGVuZGVkLCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKHNldFRyYW5zbGF0ZSkge1xuICAgICAgICAgICAgc3dpcGVyLnRvdWNoRXZlbnRzRGF0YS5zdGFydFRyYW5zbGF0ZSA9IHN3aXBlci50b3VjaEV2ZW50c0RhdGEuc3RhcnRUcmFuc2xhdGUgLSBkaWZmO1xuICAgICAgICAgICAgc3dpcGVyLnRvdWNoRXZlbnRzRGF0YS5jdXJyZW50VHJhbnNsYXRlID0gc3dpcGVyLnRvdWNoRXZlbnRzRGF0YS5jdXJyZW50VHJhbnNsYXRlIC0gZGlmZjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNoaWZ0ID0gZ3JpZEVuYWJsZWQgPyBhcHBlbmRTbGlkZXNJbmRleGVzLmxlbmd0aCAvIHBhcmFtcy5ncmlkLnJvd3MgOiBhcHBlbmRTbGlkZXNJbmRleGVzLmxlbmd0aDtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4IC0gc2hpZnQsIDAsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID0gYWxsb3dTbGlkZVByZXY7XG4gIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IGFsbG93U2xpZGVOZXh0O1xuICBpZiAoc3dpcGVyLmNvbnRyb2xsZXIgJiYgc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbCAmJiAhYnlDb250cm9sbGVyKSB7XG4gICAgY29uc3QgbG9vcFBhcmFtcyA9IHtcbiAgICAgIHNsaWRlUmVhbEluZGV4LFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgc2V0VHJhbnNsYXRlLFxuICAgICAgYWN0aXZlU2xpZGVJbmRleCxcbiAgICAgIGJ5Q29udHJvbGxlcjogdHJ1ZVxuICAgIH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbCkpIHtcbiAgICAgIHN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wuZm9yRWFjaChjID0+IHtcbiAgICAgICAgaWYgKCFjLmRlc3Ryb3llZCAmJiBjLnBhcmFtcy5sb29wKSBjLmxvb3BGaXgoe1xuICAgICAgICAgIC4uLmxvb3BQYXJhbXMsXG4gICAgICAgICAgc2xpZGVUbzogYy5wYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gcGFyYW1zLnNsaWRlc1BlclZpZXcgPyBzbGlkZVRvIDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wgaW5zdGFuY2VvZiBzd2lwZXIuY29uc3RydWN0b3IgJiYgc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbC5wYXJhbXMubG9vcCkge1xuICAgICAgc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbC5sb29wRml4KHtcbiAgICAgICAgLi4ubG9vcFBhcmFtcyxcbiAgICAgICAgc2xpZGVUbzogc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbC5wYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gcGFyYW1zLnNsaWRlc1BlclZpZXcgPyBzbGlkZVRvIDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBzd2lwZXIuZW1pdCgnbG9vcEZpeCcpO1xufVxuXG5mdW5jdGlvbiBsb29wRGVzdHJveSgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHBhcmFtcyxcbiAgICBzbGlkZXNFbFxuICB9ID0gc3dpcGVyO1xuICBpZiAoIXBhcmFtcy5sb29wIHx8IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkKSByZXR1cm47XG4gIHN3aXBlci5yZWNhbGNTbGlkZXMoKTtcbiAgY29uc3QgbmV3U2xpZGVzT3JkZXIgPSBbXTtcbiAgc3dpcGVyLnNsaWRlcy5mb3JFYWNoKHNsaWRlRWwgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gdHlwZW9mIHNsaWRlRWwuc3dpcGVyU2xpZGVJbmRleCA9PT0gJ3VuZGVmaW5lZCcgPyBzbGlkZUVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSAqIDEgOiBzbGlkZUVsLnN3aXBlclNsaWRlSW5kZXg7XG4gICAgbmV3U2xpZGVzT3JkZXJbaW5kZXhdID0gc2xpZGVFbDtcbiAgfSk7XG4gIHN3aXBlci5zbGlkZXMuZm9yRWFjaChzbGlkZUVsID0+IHtcbiAgICBzbGlkZUVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKTtcbiAgfSk7XG4gIG5ld1NsaWRlc09yZGVyLmZvckVhY2goc2xpZGVFbCA9PiB7XG4gICAgc2xpZGVzRWwuYXBwZW5kKHNsaWRlRWwpO1xuICB9KTtcbiAgc3dpcGVyLnJlY2FsY1NsaWRlcygpO1xuICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIucmVhbEluZGV4LCAwKTtcbn1cblxudmFyIGxvb3AgPSB7XG4gIGxvb3BDcmVhdGUsXG4gIGxvb3BGaXgsXG4gIGxvb3BEZXN0cm95XG59O1xuXG5mdW5jdGlvbiBzZXRHcmFiQ3Vyc29yKG1vdmluZykge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBpZiAoIXN3aXBlci5wYXJhbXMuc2ltdWxhdGVUb3VjaCB8fCBzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgc3dpcGVyLmlzTG9ja2VkIHx8IHN3aXBlci5wYXJhbXMuY3NzTW9kZSkgcmV0dXJuO1xuICBjb25zdCBlbCA9IHN3aXBlci5wYXJhbXMudG91Y2hFdmVudHNUYXJnZXQgPT09ICdjb250YWluZXInID8gc3dpcGVyLmVsIDogc3dpcGVyLndyYXBwZXJFbDtcbiAgaWYgKHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICBzd2lwZXIuX19wcmV2ZW50T2JzZXJ2ZXJfXyA9IHRydWU7XG4gIH1cbiAgZWwuc3R5bGUuY3Vyc29yID0gJ21vdmUnO1xuICBlbC5zdHlsZS5jdXJzb3IgPSBtb3ZpbmcgPyAnZ3JhYmJpbmcnIDogJ2dyYWInO1xuICBpZiAoc3dpcGVyLmlzRWxlbWVudCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBzd2lwZXIuX19wcmV2ZW50T2JzZXJ2ZXJfXyA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc2V0R3JhYkN1cnNvcigpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuaXNMb2NrZWQgfHwgc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzd2lwZXIuaXNFbGVtZW50KSB7XG4gICAgc3dpcGVyLl9fcHJldmVudE9ic2VydmVyX18gPSB0cnVlO1xuICB9XG4gIHN3aXBlcltzd2lwZXIucGFyYW1zLnRvdWNoRXZlbnRzVGFyZ2V0ID09PSAnY29udGFpbmVyJyA/ICdlbCcgOiAnd3JhcHBlckVsJ10uc3R5bGUuY3Vyc29yID0gJyc7XG4gIGlmIChzd2lwZXIuaXNFbGVtZW50KSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHN3aXBlci5fX3ByZXZlbnRPYnNlcnZlcl9fID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIGdyYWJDdXJzb3IgPSB7XG4gIHNldEdyYWJDdXJzb3IsXG4gIHVuc2V0R3JhYkN1cnNvclxufTtcblxuLy8gTW9kaWZpZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NDUyMDU1NC9jdXN0b20tZWxlbWVudC1nZXRyb290bm9kZS1jbG9zZXN0LWZ1bmN0aW9uLWNyb3NzaW5nLW11bHRpcGxlLXBhcmVudC1zaGFkb3dkXG5mdW5jdGlvbiBjbG9zZXN0RWxlbWVudChzZWxlY3RvciwgYmFzZSkge1xuICBpZiAoYmFzZSA9PT0gdm9pZCAwKSB7XG4gICAgYmFzZSA9IHRoaXM7XG4gIH1cbiAgZnVuY3Rpb24gX19jbG9zZXN0RnJvbShlbCkge1xuICAgIGlmICghZWwgfHwgZWwgPT09IGdldERvY3VtZW50KCkgfHwgZWwgPT09IGdldFdpbmRvdygpKSByZXR1cm4gbnVsbDtcbiAgICBpZiAoZWwuYXNzaWduZWRTbG90KSBlbCA9IGVsLmFzc2lnbmVkU2xvdDtcbiAgICBjb25zdCBmb3VuZCA9IGVsLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICAgIGlmICghZm91bmQgJiYgIWVsLmdldFJvb3ROb2RlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kIHx8IF9fY2xvc2VzdEZyb20oZWwuZ2V0Um9vdE5vZGUoKS5ob3N0KTtcbiAgfVxuICByZXR1cm4gX19jbG9zZXN0RnJvbShiYXNlKTtcbn1cbmZ1bmN0aW9uIHByZXZlbnRFZGdlU3dpcGUoc3dpcGVyLCBldmVudCwgc3RhcnRYKSB7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICBjb25zdCB7XG4gICAgcGFyYW1zXG4gIH0gPSBzd2lwZXI7XG4gIGNvbnN0IGVkZ2VTd2lwZURldGVjdGlvbiA9IHBhcmFtcy5lZGdlU3dpcGVEZXRlY3Rpb247XG4gIGNvbnN0IGVkZ2VTd2lwZVRocmVzaG9sZCA9IHBhcmFtcy5lZGdlU3dpcGVUaHJlc2hvbGQ7XG4gIGlmIChlZGdlU3dpcGVEZXRlY3Rpb24gJiYgKHN0YXJ0WCA8PSBlZGdlU3dpcGVUaHJlc2hvbGQgfHwgc3RhcnRYID49IHdpbmRvdy5pbm5lcldpZHRoIC0gZWRnZVN3aXBlVGhyZXNob2xkKSkge1xuICAgIGlmIChlZGdlU3dpcGVEZXRlY3Rpb24gPT09ICdwcmV2ZW50Jykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBvblRvdWNoU3RhcnQoZXZlbnQpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICBsZXQgZSA9IGV2ZW50O1xuICBpZiAoZS5vcmlnaW5hbEV2ZW50KSBlID0gZS5vcmlnaW5hbEV2ZW50O1xuICBjb25zdCBkYXRhID0gc3dpcGVyLnRvdWNoRXZlbnRzRGF0YTtcbiAgaWYgKGUudHlwZSA9PT0gJ3BvaW50ZXJkb3duJykge1xuICAgIGlmIChkYXRhLnBvaW50ZXJJZCAhPT0gbnVsbCAmJiBkYXRhLnBvaW50ZXJJZCAhPT0gZS5wb2ludGVySWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGF0YS5wb2ludGVySWQgPSBlLnBvaW50ZXJJZDtcbiAgfSBlbHNlIGlmIChlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgZGF0YS50b3VjaElkID0gZS50YXJnZXRUb3VjaGVzWzBdLmlkZW50aWZpZXI7XG4gIH1cbiAgaWYgKGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgLy8gZG9uJ3QgcHJvY2VlZCB0b3VjaCBldmVudFxuICAgIHByZXZlbnRFZGdlU3dpcGUoc3dpcGVyLCBlLCBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVgpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7XG4gICAgcGFyYW1zLFxuICAgIHRvdWNoZXMsXG4gICAgZW5hYmxlZFxuICB9ID0gc3dpcGVyO1xuICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgaWYgKCFwYXJhbXMuc2ltdWxhdGVUb3VjaCAmJiBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSByZXR1cm47XG4gIGlmIChzd2lwZXIuYW5pbWF0aW5nICYmIHBhcmFtcy5wcmV2ZW50SW50ZXJhY3Rpb25PblRyYW5zaXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFzd2lwZXIuYW5pbWF0aW5nICYmIHBhcmFtcy5jc3NNb2RlICYmIHBhcmFtcy5sb29wKSB7XG4gICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgfVxuICBsZXQgdGFyZ2V0RWwgPSBlLnRhcmdldDtcbiAgaWYgKHBhcmFtcy50b3VjaEV2ZW50c1RhcmdldCA9PT0gJ3dyYXBwZXInKSB7XG4gICAgaWYgKCFzd2lwZXIud3JhcHBlckVsLmNvbnRhaW5zKHRhcmdldEVsKSkgcmV0dXJuO1xuICB9XG4gIGlmICgnd2hpY2gnIGluIGUgJiYgZS53aGljaCA9PT0gMykgcmV0dXJuO1xuICBpZiAoJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiA+IDApIHJldHVybjtcbiAgaWYgKGRhdGEuaXNUb3VjaGVkICYmIGRhdGEuaXNNb3ZlZCkgcmV0dXJuO1xuXG4gIC8vIGNoYW5nZSB0YXJnZXQgZWwgZm9yIHNoYWRvdyByb290IGNvbXBvbmVudFxuICBjb25zdCBzd2lwaW5nQ2xhc3NIYXNWYWx1ZSA9ICEhcGFyYW1zLm5vU3dpcGluZ0NsYXNzICYmIHBhcmFtcy5ub1N3aXBpbmdDbGFzcyAhPT0gJyc7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBjb25zdCBldmVudFBhdGggPSBlLmNvbXBvc2VkUGF0aCA/IGUuY29tcG9zZWRQYXRoKCkgOiBlLnBhdGg7XG4gIGlmIChzd2lwaW5nQ2xhc3NIYXNWYWx1ZSAmJiBlLnRhcmdldCAmJiBlLnRhcmdldC5zaGFkb3dSb290ICYmIGV2ZW50UGF0aCkge1xuICAgIHRhcmdldEVsID0gZXZlbnRQYXRoWzBdO1xuICB9XG4gIGNvbnN0IG5vU3dpcGluZ1NlbGVjdG9yID0gcGFyYW1zLm5vU3dpcGluZ1NlbGVjdG9yID8gcGFyYW1zLm5vU3dpcGluZ1NlbGVjdG9yIDogYC4ke3BhcmFtcy5ub1N3aXBpbmdDbGFzc31gO1xuICBjb25zdCBpc1RhcmdldFNoYWRvdyA9ICEhKGUudGFyZ2V0ICYmIGUudGFyZ2V0LnNoYWRvd1Jvb3QpO1xuXG4gIC8vIHVzZSBjbG9zZXN0RWxlbWVudCBmb3Igc2hhZG93IHJvb3QgZWxlbWVudCB0byBnZXQgdGhlIGFjdHVhbCBjbG9zZXN0IGZvciBuZXN0ZWQgc2hhZG93IHJvb3QgZWxlbWVudFxuICBpZiAocGFyYW1zLm5vU3dpcGluZyAmJiAoaXNUYXJnZXRTaGFkb3cgPyBjbG9zZXN0RWxlbWVudChub1N3aXBpbmdTZWxlY3RvciwgdGFyZ2V0RWwpIDogdGFyZ2V0RWwuY2xvc2VzdChub1N3aXBpbmdTZWxlY3RvcikpKSB7XG4gICAgc3dpcGVyLmFsbG93Q2xpY2sgPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocGFyYW1zLnN3aXBlSGFuZGxlcikge1xuICAgIGlmICghdGFyZ2V0RWwuY2xvc2VzdChwYXJhbXMuc3dpcGVIYW5kbGVyKSkgcmV0dXJuO1xuICB9XG4gIHRvdWNoZXMuY3VycmVudFggPSBlLnBhZ2VYO1xuICB0b3VjaGVzLmN1cnJlbnRZID0gZS5wYWdlWTtcbiAgY29uc3Qgc3RhcnRYID0gdG91Y2hlcy5jdXJyZW50WDtcbiAgY29uc3Qgc3RhcnRZID0gdG91Y2hlcy5jdXJyZW50WTtcblxuICAvLyBEbyBOT1Qgc3RhcnQgaWYgaU9TIGVkZ2Ugc3dpcGUgaXMgZGV0ZWN0ZWQuIE90aGVyd2lzZSBpT1MgYXBwIGNhbm5vdCBzd2lwZS10by1nby1iYWNrIGFueW1vcmVcblxuICBpZiAoIXByZXZlbnRFZGdlU3dpcGUoc3dpcGVyLCBlLCBzdGFydFgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIE9iamVjdC5hc3NpZ24oZGF0YSwge1xuICAgIGlzVG91Y2hlZDogdHJ1ZSxcbiAgICBpc01vdmVkOiBmYWxzZSxcbiAgICBhbGxvd1RvdWNoQ2FsbGJhY2tzOiB0cnVlLFxuICAgIGlzU2Nyb2xsaW5nOiB1bmRlZmluZWQsXG4gICAgc3RhcnRNb3Zpbmc6IHVuZGVmaW5lZFxuICB9KTtcbiAgdG91Y2hlcy5zdGFydFggPSBzdGFydFg7XG4gIHRvdWNoZXMuc3RhcnRZID0gc3RhcnRZO1xuICBkYXRhLnRvdWNoU3RhcnRUaW1lID0gbm93KCk7XG4gIHN3aXBlci5hbGxvd0NsaWNrID0gdHJ1ZTtcbiAgc3dpcGVyLnVwZGF0ZVNpemUoKTtcbiAgc3dpcGVyLnN3aXBlRGlyZWN0aW9uID0gdW5kZWZpbmVkO1xuICBpZiAocGFyYW1zLnRocmVzaG9sZCA+IDApIGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlID0gZmFsc2U7XG4gIGxldCBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gIGlmICh0YXJnZXRFbC5tYXRjaGVzKGRhdGEuZm9jdXNhYmxlRWxlbWVudHMpKSB7XG4gICAgcHJldmVudERlZmF1bHQgPSBmYWxzZTtcbiAgICBpZiAodGFyZ2V0RWwubm9kZU5hbWUgPT09ICdTRUxFQ1QnKSB7XG4gICAgICBkYXRhLmlzVG91Y2hlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50Lm1hdGNoZXMoZGF0YS5mb2N1c2FibGVFbGVtZW50cykgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gdGFyZ2V0RWwpIHtcbiAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgfVxuICBjb25zdCBzaG91bGRQcmV2ZW50RGVmYXVsdCA9IHByZXZlbnREZWZhdWx0ICYmIHN3aXBlci5hbGxvd1RvdWNoTW92ZSAmJiBwYXJhbXMudG91Y2hTdGFydFByZXZlbnREZWZhdWx0O1xuICBpZiAoKHBhcmFtcy50b3VjaFN0YXJ0Rm9yY2VQcmV2ZW50RGVmYXVsdCB8fCBzaG91bGRQcmV2ZW50RGVmYXVsdCkgJiYgIXRhcmdldEVsLmlzQ29udGVudEVkaXRhYmxlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGlmIChwYXJhbXMuZnJlZU1vZGUgJiYgcGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQgJiYgc3dpcGVyLmZyZWVNb2RlICYmIHN3aXBlci5hbmltYXRpbmcgJiYgIXBhcmFtcy5jc3NNb2RlKSB7XG4gICAgc3dpcGVyLmZyZWVNb2RlLm9uVG91Y2hTdGFydCgpO1xuICB9XG4gIHN3aXBlci5lbWl0KCd0b3VjaFN0YXJ0JywgZSk7XG59XG5cbmZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGV2ZW50KSB7XG4gIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgZGF0YSA9IHN3aXBlci50b3VjaEV2ZW50c0RhdGE7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsXG4gICAgdG91Y2hlcyxcbiAgICBydGxUcmFuc2xhdGU6IHJ0bCxcbiAgICBlbmFibGVkXG4gIH0gPSBzd2lwZXI7XG4gIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICBpZiAoIXBhcmFtcy5zaW11bGF0ZVRvdWNoICYmIGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSByZXR1cm47XG4gIGxldCBlID0gZXZlbnQ7XG4gIGlmIChlLm9yaWdpbmFsRXZlbnQpIGUgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gIGlmIChlLnR5cGUgPT09ICdwb2ludGVybW92ZScpIHtcbiAgICBpZiAoZGF0YS50b3VjaElkICE9PSBudWxsKSByZXR1cm47IC8vIHJldHVybiBmcm9tIHBvaW50ZXIgaWYgd2UgdXNlIHRvdWNoXG4gICAgY29uc3QgaWQgPSBlLnBvaW50ZXJJZDtcbiAgICBpZiAoaWQgIT09IGRhdGEucG9pbnRlcklkKSByZXR1cm47XG4gIH1cbiAgbGV0IHRhcmdldFRvdWNoO1xuICBpZiAoZS50eXBlID09PSAndG91Y2htb3ZlJykge1xuICAgIHRhcmdldFRvdWNoID0gWy4uLmUuY2hhbmdlZFRvdWNoZXNdLmZpbHRlcih0ID0+IHQuaWRlbnRpZmllciA9PT0gZGF0YS50b3VjaElkKVswXTtcbiAgICBpZiAoIXRhcmdldFRvdWNoIHx8IHRhcmdldFRvdWNoLmlkZW50aWZpZXIgIT09IGRhdGEudG91Y2hJZCkgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldFRvdWNoID0gZTtcbiAgfVxuICBpZiAoIWRhdGEuaXNUb3VjaGVkKSB7XG4gICAgaWYgKGRhdGEuc3RhcnRNb3ZpbmcgJiYgZGF0YS5pc1Njcm9sbGluZykge1xuICAgICAgc3dpcGVyLmVtaXQoJ3RvdWNoTW92ZU9wcG9zaXRlJywgZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwYWdlWCA9IHRhcmdldFRvdWNoLnBhZ2VYO1xuICBjb25zdCBwYWdlWSA9IHRhcmdldFRvdWNoLnBhZ2VZO1xuICBpZiAoZS5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlcikge1xuICAgIHRvdWNoZXMuc3RhcnRYID0gcGFnZVg7XG4gICAgdG91Y2hlcy5zdGFydFkgPSBwYWdlWTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFzd2lwZXIuYWxsb3dUb3VjaE1vdmUpIHtcbiAgICBpZiAoIWUudGFyZ2V0Lm1hdGNoZXMoZGF0YS5mb2N1c2FibGVFbGVtZW50cykpIHtcbiAgICAgIHN3aXBlci5hbGxvd0NsaWNrID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkYXRhLmlzVG91Y2hlZCkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0b3VjaGVzLCB7XG4gICAgICAgIHN0YXJ0WDogcGFnZVgsXG4gICAgICAgIHN0YXJ0WTogcGFnZVksXG4gICAgICAgIGN1cnJlbnRYOiBwYWdlWCxcbiAgICAgICAgY3VycmVudFk6IHBhZ2VZXG4gICAgICB9KTtcbiAgICAgIGRhdGEudG91Y2hTdGFydFRpbWUgPSBub3coKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwYXJhbXMudG91Y2hSZWxlYXNlT25FZGdlcyAmJiAhcGFyYW1zLmxvb3ApIHtcbiAgICBpZiAoc3dpcGVyLmlzVmVydGljYWwoKSkge1xuICAgICAgLy8gVmVydGljYWxcbiAgICAgIGlmIChwYWdlWSA8IHRvdWNoZXMuc3RhcnRZICYmIHN3aXBlci50cmFuc2xhdGUgPD0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIHx8IHBhZ2VZID4gdG91Y2hlcy5zdGFydFkgJiYgc3dpcGVyLnRyYW5zbGF0ZSA+PSBzd2lwZXIubWluVHJhbnNsYXRlKCkpIHtcbiAgICAgICAgZGF0YS5pc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgZGF0YS5pc01vdmVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhZ2VYIDwgdG91Y2hlcy5zdGFydFggJiYgc3dpcGVyLnRyYW5zbGF0ZSA8PSBzd2lwZXIubWF4VHJhbnNsYXRlKCkgfHwgcGFnZVggPiB0b3VjaGVzLnN0YXJ0WCAmJiBzd2lwZXIudHJhbnNsYXRlID49IHN3aXBlci5taW5UcmFuc2xhdGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBlLnRhcmdldC5tYXRjaGVzKGRhdGEuZm9jdXNhYmxlRWxlbWVudHMpKSB7XG4gICAgICBkYXRhLmlzTW92ZWQgPSB0cnVlO1xuICAgICAgc3dpcGVyLmFsbG93Q2xpY2sgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKGRhdGEuYWxsb3dUb3VjaENhbGxiYWNrcykge1xuICAgIHN3aXBlci5lbWl0KCd0b3VjaE1vdmUnLCBlKTtcbiAgfVxuICB0b3VjaGVzLnByZXZpb3VzWCA9IHRvdWNoZXMuY3VycmVudFg7XG4gIHRvdWNoZXMucHJldmlvdXNZID0gdG91Y2hlcy5jdXJyZW50WTtcbiAgdG91Y2hlcy5jdXJyZW50WCA9IHBhZ2VYO1xuICB0b3VjaGVzLmN1cnJlbnRZID0gcGFnZVk7XG4gIGNvbnN0IGRpZmZYID0gdG91Y2hlcy5jdXJyZW50WCAtIHRvdWNoZXMuc3RhcnRYO1xuICBjb25zdCBkaWZmWSA9IHRvdWNoZXMuY3VycmVudFkgLSB0b3VjaGVzLnN0YXJ0WTtcbiAgaWYgKHN3aXBlci5wYXJhbXMudGhyZXNob2xkICYmIE1hdGguc3FydChkaWZmWCAqKiAyICsgZGlmZlkgKiogMikgPCBzd2lwZXIucGFyYW1zLnRocmVzaG9sZCkgcmV0dXJuO1xuICBpZiAodHlwZW9mIGRhdGEuaXNTY3JvbGxpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbGV0IHRvdWNoQW5nbGU7XG4gICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSAmJiB0b3VjaGVzLmN1cnJlbnRZID09PSB0b3VjaGVzLnN0YXJ0WSB8fCBzd2lwZXIuaXNWZXJ0aWNhbCgpICYmIHRvdWNoZXMuY3VycmVudFggPT09IHRvdWNoZXMuc3RhcnRYKSB7XG4gICAgICBkYXRhLmlzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgaWYgKGRpZmZYICogZGlmZlggKyBkaWZmWSAqIGRpZmZZID49IDI1KSB7XG4gICAgICAgIHRvdWNoQW5nbGUgPSBNYXRoLmF0YW4yKE1hdGguYWJzKGRpZmZZKSwgTWF0aC5hYnMoZGlmZlgpKSAqIDE4MCAvIE1hdGguUEk7XG4gICAgICAgIGRhdGEuaXNTY3JvbGxpbmcgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB0b3VjaEFuZ2xlID4gcGFyYW1zLnRvdWNoQW5nbGUgOiA5MCAtIHRvdWNoQW5nbGUgPiBwYXJhbXMudG91Y2hBbmdsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGRhdGEuaXNTY3JvbGxpbmcpIHtcbiAgICBzd2lwZXIuZW1pdCgndG91Y2hNb3ZlT3Bwb3NpdGUnLCBlKTtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGEuc3RhcnRNb3ZpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHRvdWNoZXMuY3VycmVudFggIT09IHRvdWNoZXMuc3RhcnRYIHx8IHRvdWNoZXMuY3VycmVudFkgIT09IHRvdWNoZXMuc3RhcnRZKSB7XG4gICAgICBkYXRhLnN0YXJ0TW92aW5nID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGRhdGEuaXNTY3JvbGxpbmcgfHwgZS50eXBlID09PSAndG91Y2htb3ZlJyAmJiBkYXRhLnByZXZlbnRUb3VjaE1vdmVGcm9tUG9pbnRlck1vdmUpIHtcbiAgICBkYXRhLmlzVG91Y2hlZCA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWRhdGEuc3RhcnRNb3ZpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc3dpcGVyLmFsbG93Q2xpY2sgPSBmYWxzZTtcbiAgaWYgKCFwYXJhbXMuY3NzTW9kZSAmJiBlLmNhbmNlbGFibGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgaWYgKHBhcmFtcy50b3VjaE1vdmVTdG9wUHJvcGFnYXRpb24gJiYgIXBhcmFtcy5uZXN0ZWQpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG4gIGxldCBkaWZmID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gZGlmZlggOiBkaWZmWTtcbiAgbGV0IHRvdWNoZXNEaWZmID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gdG91Y2hlcy5jdXJyZW50WCAtIHRvdWNoZXMucHJldmlvdXNYIDogdG91Y2hlcy5jdXJyZW50WSAtIHRvdWNoZXMucHJldmlvdXNZO1xuICBpZiAocGFyYW1zLm9uZVdheU1vdmVtZW50KSB7XG4gICAgZGlmZiA9IE1hdGguYWJzKGRpZmYpICogKHJ0bCA/IDEgOiAtMSk7XG4gICAgdG91Y2hlc0RpZmYgPSBNYXRoLmFicyh0b3VjaGVzRGlmZikgKiAocnRsID8gMSA6IC0xKTtcbiAgfVxuICB0b3VjaGVzLmRpZmYgPSBkaWZmO1xuICBkaWZmICo9IHBhcmFtcy50b3VjaFJhdGlvO1xuICBpZiAocnRsKSB7XG4gICAgZGlmZiA9IC1kaWZmO1xuICAgIHRvdWNoZXNEaWZmID0gLXRvdWNoZXNEaWZmO1xuICB9XG4gIGNvbnN0IHByZXZUb3VjaGVzRGlyZWN0aW9uID0gc3dpcGVyLnRvdWNoZXNEaXJlY3Rpb247XG4gIHN3aXBlci5zd2lwZURpcmVjdGlvbiA9IGRpZmYgPiAwID8gJ3ByZXYnIDogJ25leHQnO1xuICBzd2lwZXIudG91Y2hlc0RpcmVjdGlvbiA9IHRvdWNoZXNEaWZmID4gMCA/ICdwcmV2JyA6ICduZXh0JztcbiAgY29uc3QgaXNMb29wID0gc3dpcGVyLnBhcmFtcy5sb29wICYmICFwYXJhbXMuY3NzTW9kZTtcbiAgY29uc3QgYWxsb3dMb29wRml4ID0gc3dpcGVyLnRvdWNoZXNEaXJlY3Rpb24gPT09ICduZXh0JyAmJiBzd2lwZXIuYWxsb3dTbGlkZU5leHQgfHwgc3dpcGVyLnRvdWNoZXNEaXJlY3Rpb24gPT09ICdwcmV2JyAmJiBzd2lwZXIuYWxsb3dTbGlkZVByZXY7XG4gIGlmICghZGF0YS5pc01vdmVkKSB7XG4gICAgaWYgKGlzTG9vcCAmJiBhbGxvd0xvb3BGaXgpIHtcbiAgICAgIHN3aXBlci5sb29wRml4KHtcbiAgICAgICAgZGlyZWN0aW9uOiBzd2lwZXIuc3dpcGVEaXJlY3Rpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICBkYXRhLnN0YXJ0VHJhbnNsYXRlID0gc3dpcGVyLmdldFRyYW5zbGF0ZSgpO1xuICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKDApO1xuICAgIGlmIChzd2lwZXIuYW5pbWF0aW5nKSB7XG4gICAgICBjb25zdCBldnQgPSBuZXcgd2luZG93LkN1c3RvbUV2ZW50KCd0cmFuc2l0aW9uZW5kJywge1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICBieVN3aXBlclRvdWNoTW92ZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHN3aXBlci53cmFwcGVyRWwuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgIH1cbiAgICBkYXRhLmFsbG93TW9tZW50dW1Cb3VuY2UgPSBmYWxzZTtcbiAgICAvLyBHcmFiIEN1cnNvclxuICAgIGlmIChwYXJhbXMuZ3JhYkN1cnNvciAmJiAoc3dpcGVyLmFsbG93U2xpZGVOZXh0ID09PSB0cnVlIHx8IHN3aXBlci5hbGxvd1NsaWRlUHJldiA9PT0gdHJ1ZSkpIHtcbiAgICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKHRydWUpO1xuICAgIH1cbiAgICBzd2lwZXIuZW1pdCgnc2xpZGVyRmlyc3RNb3ZlJywgZSk7XG4gIH1cbiAgbGV0IGxvb3BGaXhlZDtcbiAgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIGlmIChkYXRhLmlzTW92ZWQgJiYgZGF0YS5hbGxvd1RocmVzaG9sZE1vdmUgJiYgcHJldlRvdWNoZXNEaXJlY3Rpb24gIT09IHN3aXBlci50b3VjaGVzRGlyZWN0aW9uICYmIGlzTG9vcCAmJiBhbGxvd0xvb3BGaXggJiYgTWF0aC5hYnMoZGlmZikgPj0gMSkge1xuICAgIE9iamVjdC5hc3NpZ24odG91Y2hlcywge1xuICAgICAgc3RhcnRYOiBwYWdlWCxcbiAgICAgIHN0YXJ0WTogcGFnZVksXG4gICAgICBjdXJyZW50WDogcGFnZVgsXG4gICAgICBjdXJyZW50WTogcGFnZVksXG4gICAgICBzdGFydFRyYW5zbGF0ZTogZGF0YS5jdXJyZW50VHJhbnNsYXRlXG4gICAgfSk7XG4gICAgZGF0YS5sb29wU3dhcFJlc2V0ID0gdHJ1ZTtcbiAgICBkYXRhLnN0YXJ0VHJhbnNsYXRlID0gZGF0YS5jdXJyZW50VHJhbnNsYXRlO1xuICAgIHJldHVybjtcbiAgfVxuICBzd2lwZXIuZW1pdCgnc2xpZGVyTW92ZScsIGUpO1xuICBkYXRhLmlzTW92ZWQgPSB0cnVlO1xuICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBkaWZmICsgZGF0YS5zdGFydFRyYW5zbGF0ZTtcbiAgbGV0IGRpc2FibGVQYXJlbnRTd2lwZXIgPSB0cnVlO1xuICBsZXQgcmVzaXN0YW5jZVJhdGlvID0gcGFyYW1zLnJlc2lzdGFuY2VSYXRpbztcbiAgaWYgKHBhcmFtcy50b3VjaFJlbGVhc2VPbkVkZ2VzKSB7XG4gICAgcmVzaXN0YW5jZVJhdGlvID0gMDtcbiAgfVxuICBpZiAoZGlmZiA+IDApIHtcbiAgICBpZiAoaXNMb29wICYmIGFsbG93TG9vcEZpeCAmJiAhbG9vcEZpeGVkICYmIGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlICYmIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA+IChwYXJhbXMuY2VudGVyZWRTbGlkZXMgPyBzd2lwZXIubWluVHJhbnNsYXRlKCkgLSBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkW3N3aXBlci5hY3RpdmVJbmRleCArIDFdIDogc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSkge1xuICAgICAgc3dpcGVyLmxvb3BGaXgoe1xuICAgICAgICBkaXJlY3Rpb246ICdwcmV2JyxcbiAgICAgICAgc2V0VHJhbnNsYXRlOiB0cnVlLFxuICAgICAgICBhY3RpdmVTbGlkZUluZGV4OiAwXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGRhdGEuY3VycmVudFRyYW5zbGF0ZSA+IHN3aXBlci5taW5UcmFuc2xhdGUoKSkge1xuICAgICAgZGlzYWJsZVBhcmVudFN3aXBlciA9IGZhbHNlO1xuICAgICAgaWYgKHBhcmFtcy5yZXNpc3RhbmNlKSB7XG4gICAgICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IHN3aXBlci5taW5UcmFuc2xhdGUoKSAtIDEgKyAoLXN3aXBlci5taW5UcmFuc2xhdGUoKSArIGRhdGEuc3RhcnRUcmFuc2xhdGUgKyBkaWZmKSAqKiByZXNpc3RhbmNlUmF0aW87XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpZmYgPCAwKSB7XG4gICAgaWYgKGlzTG9vcCAmJiBhbGxvd0xvb3BGaXggJiYgIWxvb3BGaXhlZCAmJiBkYXRhLmFsbG93VGhyZXNob2xkTW92ZSAmJiBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPCAocGFyYW1zLmNlbnRlcmVkU2xpZGVzID8gc3dpcGVyLm1heFRyYW5zbGF0ZSgpICsgc3dpcGVyLnNsaWRlc1NpemVzR3JpZFtzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkLmxlbmd0aCAtIDFdIDogc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSkge1xuICAgICAgc3dpcGVyLmxvb3BGaXgoe1xuICAgICAgICBkaXJlY3Rpb246ICduZXh0JyxcbiAgICAgICAgc2V0VHJhbnNsYXRlOiB0cnVlLFxuICAgICAgICBhY3RpdmVTbGlkZUluZGV4OiBzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIChwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nID8gc3dpcGVyLnNsaWRlc1BlclZpZXdEeW5hbWljKCkgOiBNYXRoLmNlaWwocGFyc2VGbG9hdChwYXJhbXMuc2xpZGVzUGVyVmlldywgMTApKSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jdXJyZW50VHJhbnNsYXRlIDwgc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSB7XG4gICAgICBkaXNhYmxlUGFyZW50U3dpcGVyID0gZmFsc2U7XG4gICAgICBpZiAocGFyYW1zLnJlc2lzdGFuY2UpIHtcbiAgICAgICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpICsgMSAtIChzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBkYXRhLnN0YXJ0VHJhbnNsYXRlIC0gZGlmZikgKiogcmVzaXN0YW5jZVJhdGlvO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZGlzYWJsZVBhcmVudFN3aXBlcikge1xuICAgIGUucHJldmVudGVkQnlOZXN0ZWRTd2lwZXIgPSB0cnVlO1xuICB9XG5cbiAgLy8gRGlyZWN0aW9ucyBsb2Nrc1xuICBpZiAoIXN3aXBlci5hbGxvd1NsaWRlTmV4dCAmJiBzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICduZXh0JyAmJiBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPCBkYXRhLnN0YXJ0VHJhbnNsYXRlKSB7XG4gICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGF0YS5zdGFydFRyYW5zbGF0ZTtcbiAgfVxuICBpZiAoIXN3aXBlci5hbGxvd1NsaWRlUHJldiAmJiBzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICdwcmV2JyAmJiBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPiBkYXRhLnN0YXJ0VHJhbnNsYXRlKSB7XG4gICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGF0YS5zdGFydFRyYW5zbGF0ZTtcbiAgfVxuICBpZiAoIXN3aXBlci5hbGxvd1NsaWRlUHJldiAmJiAhc3dpcGVyLmFsbG93U2xpZGVOZXh0KSB7XG4gICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGF0YS5zdGFydFRyYW5zbGF0ZTtcbiAgfVxuXG4gIC8vIFRocmVzaG9sZFxuICBpZiAocGFyYW1zLnRocmVzaG9sZCA+IDApIHtcbiAgICBpZiAoTWF0aC5hYnMoZGlmZikgPiBwYXJhbXMudGhyZXNob2xkIHx8IGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlKSB7XG4gICAgICBpZiAoIWRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlKSB7XG4gICAgICAgIGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlID0gdHJ1ZTtcbiAgICAgICAgdG91Y2hlcy5zdGFydFggPSB0b3VjaGVzLmN1cnJlbnRYO1xuICAgICAgICB0b3VjaGVzLnN0YXJ0WSA9IHRvdWNoZXMuY3VycmVudFk7XG4gICAgICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRhdGEuc3RhcnRUcmFuc2xhdGU7XG4gICAgICAgIHRvdWNoZXMuZGlmZiA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHRvdWNoZXMuY3VycmVudFggLSB0b3VjaGVzLnN0YXJ0WCA6IHRvdWNoZXMuY3VycmVudFkgLSB0b3VjaGVzLnN0YXJ0WTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoIXBhcmFtcy5mb2xsb3dGaW5nZXIgfHwgcGFyYW1zLmNzc01vZGUpIHJldHVybjtcblxuICAvLyBVcGRhdGUgYWN0aXZlIGluZGV4IGluIGZyZWUgbW9kZVxuICBpZiAocGFyYW1zLmZyZWVNb2RlICYmIHBhcmFtcy5mcmVlTW9kZS5lbmFibGVkICYmIHN3aXBlci5mcmVlTW9kZSB8fCBwYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcykge1xuICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gIH1cbiAgaWYgKHBhcmFtcy5mcmVlTW9kZSAmJiBwYXJhbXMuZnJlZU1vZGUuZW5hYmxlZCAmJiBzd2lwZXIuZnJlZU1vZGUpIHtcbiAgICBzd2lwZXIuZnJlZU1vZGUub25Ub3VjaE1vdmUoKTtcbiAgfVxuICAvLyBVcGRhdGUgcHJvZ3Jlc3NcbiAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKGRhdGEuY3VycmVudFRyYW5zbGF0ZSk7XG4gIC8vIFVwZGF0ZSB0cmFuc2xhdGVcbiAgc3dpcGVyLnNldFRyYW5zbGF0ZShkYXRhLmN1cnJlbnRUcmFuc2xhdGUpO1xufVxuXG5mdW5jdGlvbiBvblRvdWNoRW5kKGV2ZW50KSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IGRhdGEgPSBzd2lwZXIudG91Y2hFdmVudHNEYXRhO1xuICBsZXQgZSA9IGV2ZW50O1xuICBpZiAoZS5vcmlnaW5hbEV2ZW50KSBlID0gZS5vcmlnaW5hbEV2ZW50O1xuICBsZXQgdGFyZ2V0VG91Y2g7XG4gIGNvbnN0IGlzVG91Y2hFdmVudCA9IGUudHlwZSA9PT0gJ3RvdWNoZW5kJyB8fCBlLnR5cGUgPT09ICd0b3VjaGNhbmNlbCc7XG4gIGlmICghaXNUb3VjaEV2ZW50KSB7XG4gICAgaWYgKGRhdGEudG91Y2hJZCAhPT0gbnVsbCkgcmV0dXJuOyAvLyByZXR1cm4gZnJvbSBwb2ludGVyIGlmIHdlIHVzZSB0b3VjaFxuICAgIGlmIChlLnBvaW50ZXJJZCAhPT0gZGF0YS5wb2ludGVySWQpIHJldHVybjtcbiAgICB0YXJnZXRUb3VjaCA9IGU7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0VG91Y2ggPSBbLi4uZS5jaGFuZ2VkVG91Y2hlc10uZmlsdGVyKHQgPT4gdC5pZGVudGlmaWVyID09PSBkYXRhLnRvdWNoSWQpWzBdO1xuICAgIGlmICghdGFyZ2V0VG91Y2ggfHwgdGFyZ2V0VG91Y2guaWRlbnRpZmllciAhPT0gZGF0YS50b3VjaElkKSByZXR1cm47XG4gIH1cbiAgaWYgKFsncG9pbnRlcmNhbmNlbCcsICdwb2ludGVyb3V0JywgJ3BvaW50ZXJsZWF2ZScsICdjb250ZXh0bWVudSddLmluY2x1ZGVzKGUudHlwZSkpIHtcbiAgICBjb25zdCBwcm9jZWVkID0gWydwb2ludGVyY2FuY2VsJywgJ2NvbnRleHRtZW51J10uaW5jbHVkZXMoZS50eXBlKSAmJiAoc3dpcGVyLmJyb3dzZXIuaXNTYWZhcmkgfHwgc3dpcGVyLmJyb3dzZXIuaXNXZWJWaWV3KTtcbiAgICBpZiAoIXByb2NlZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgZGF0YS5wb2ludGVySWQgPSBudWxsO1xuICBkYXRhLnRvdWNoSWQgPSBudWxsO1xuICBjb25zdCB7XG4gICAgcGFyYW1zLFxuICAgIHRvdWNoZXMsXG4gICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgc2xpZGVzR3JpZCxcbiAgICBlbmFibGVkXG4gIH0gPSBzd2lwZXI7XG4gIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICBpZiAoIXBhcmFtcy5zaW11bGF0ZVRvdWNoICYmIGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHJldHVybjtcbiAgaWYgKGRhdGEuYWxsb3dUb3VjaENhbGxiYWNrcykge1xuICAgIHN3aXBlci5lbWl0KCd0b3VjaEVuZCcsIGUpO1xuICB9XG4gIGRhdGEuYWxsb3dUb3VjaENhbGxiYWNrcyA9IGZhbHNlO1xuICBpZiAoIWRhdGEuaXNUb3VjaGVkKSB7XG4gICAgaWYgKGRhdGEuaXNNb3ZlZCAmJiBwYXJhbXMuZ3JhYkN1cnNvcikge1xuICAgICAgc3dpcGVyLnNldEdyYWJDdXJzb3IoZmFsc2UpO1xuICAgIH1cbiAgICBkYXRhLmlzTW92ZWQgPSBmYWxzZTtcbiAgICBkYXRhLnN0YXJ0TW92aW5nID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUmV0dXJuIEdyYWIgQ3Vyc29yXG4gIGlmIChwYXJhbXMuZ3JhYkN1cnNvciAmJiBkYXRhLmlzTW92ZWQgJiYgZGF0YS5pc1RvdWNoZWQgJiYgKHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9PT0gdHJ1ZSB8fCBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPT09IHRydWUpKSB7XG4gICAgc3dpcGVyLnNldEdyYWJDdXJzb3IoZmFsc2UpO1xuICB9XG5cbiAgLy8gVGltZSBkaWZmXG4gIGNvbnN0IHRvdWNoRW5kVGltZSA9IG5vdygpO1xuICBjb25zdCB0aW1lRGlmZiA9IHRvdWNoRW5kVGltZSAtIGRhdGEudG91Y2hTdGFydFRpbWU7XG5cbiAgLy8gVGFwLCBkb3VibGVUYXAsIENsaWNrXG4gIGlmIChzd2lwZXIuYWxsb3dDbGljaykge1xuICAgIGNvbnN0IHBhdGhUcmVlID0gZS5wYXRoIHx8IGUuY29tcG9zZWRQYXRoICYmIGUuY29tcG9zZWRQYXRoKCk7XG4gICAgc3dpcGVyLnVwZGF0ZUNsaWNrZWRTbGlkZShwYXRoVHJlZSAmJiBwYXRoVHJlZVswXSB8fCBlLnRhcmdldCwgcGF0aFRyZWUpO1xuICAgIHN3aXBlci5lbWl0KCd0YXAgY2xpY2snLCBlKTtcbiAgICBpZiAodGltZURpZmYgPCAzMDAgJiYgdG91Y2hFbmRUaW1lIC0gZGF0YS5sYXN0Q2xpY2tUaW1lIDwgMzAwKSB7XG4gICAgICBzd2lwZXIuZW1pdCgnZG91YmxlVGFwIGRvdWJsZUNsaWNrJywgZSk7XG4gICAgfVxuICB9XG4gIGRhdGEubGFzdENsaWNrVGltZSA9IG5vdygpO1xuICBuZXh0VGljaygoKSA9PiB7XG4gICAgaWYgKCFzd2lwZXIuZGVzdHJveWVkKSBzd2lwZXIuYWxsb3dDbGljayA9IHRydWU7XG4gIH0pO1xuICBpZiAoIWRhdGEuaXNUb3VjaGVkIHx8ICFkYXRhLmlzTW92ZWQgfHwgIXN3aXBlci5zd2lwZURpcmVjdGlvbiB8fCB0b3VjaGVzLmRpZmYgPT09IDAgJiYgIWRhdGEubG9vcFN3YXBSZXNldCB8fCBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPT09IGRhdGEuc3RhcnRUcmFuc2xhdGUgJiYgIWRhdGEubG9vcFN3YXBSZXNldCkge1xuICAgIGRhdGEuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgZGF0YS5pc01vdmVkID0gZmFsc2U7XG4gICAgZGF0YS5zdGFydE1vdmluZyA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuICBkYXRhLmlzVG91Y2hlZCA9IGZhbHNlO1xuICBkYXRhLmlzTW92ZWQgPSBmYWxzZTtcbiAgZGF0YS5zdGFydE1vdmluZyA9IGZhbHNlO1xuICBsZXQgY3VycmVudFBvcztcbiAgaWYgKHBhcmFtcy5mb2xsb3dGaW5nZXIpIHtcbiAgICBjdXJyZW50UG9zID0gcnRsID8gc3dpcGVyLnRyYW5zbGF0ZSA6IC1zd2lwZXIudHJhbnNsYXRlO1xuICB9IGVsc2Uge1xuICAgIGN1cnJlbnRQb3MgPSAtZGF0YS5jdXJyZW50VHJhbnNsYXRlO1xuICB9XG4gIGlmIChwYXJhbXMuY3NzTW9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocGFyYW1zLmZyZWVNb2RlICYmIHBhcmFtcy5mcmVlTW9kZS5lbmFibGVkKSB7XG4gICAgc3dpcGVyLmZyZWVNb2RlLm9uVG91Y2hFbmQoe1xuICAgICAgY3VycmVudFBvc1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZpbmQgY3VycmVudCBzbGlkZVxuICBjb25zdCBzd2lwZVRvTGFzdCA9IGN1cnJlbnRQb3MgPj0gLXN3aXBlci5tYXhUcmFuc2xhdGUoKSAmJiAhc3dpcGVyLnBhcmFtcy5sb29wO1xuICBsZXQgc3RvcEluZGV4ID0gMDtcbiAgbGV0IGdyb3VwU2l6ZSA9IHN3aXBlci5zbGlkZXNTaXplc0dyaWRbMF07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzR3JpZC5sZW5ndGg7IGkgKz0gaSA8IHBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAgPyAxIDogcGFyYW1zLnNsaWRlc1Blckdyb3VwKSB7XG4gICAgY29uc3QgaW5jcmVtZW50ID0gaSA8IHBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAgLSAxID8gMSA6IHBhcmFtcy5zbGlkZXNQZXJHcm91cDtcbiAgICBpZiAodHlwZW9mIHNsaWRlc0dyaWRbaSArIGluY3JlbWVudF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoc3dpcGVUb0xhc3QgfHwgY3VycmVudFBvcyA+PSBzbGlkZXNHcmlkW2ldICYmIGN1cnJlbnRQb3MgPCBzbGlkZXNHcmlkW2kgKyBpbmNyZW1lbnRdKSB7XG4gICAgICAgIHN0b3BJbmRleCA9IGk7XG4gICAgICAgIGdyb3VwU2l6ZSA9IHNsaWRlc0dyaWRbaSArIGluY3JlbWVudF0gLSBzbGlkZXNHcmlkW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3dpcGVUb0xhc3QgfHwgY3VycmVudFBvcyA+PSBzbGlkZXNHcmlkW2ldKSB7XG4gICAgICBzdG9wSW5kZXggPSBpO1xuICAgICAgZ3JvdXBTaXplID0gc2xpZGVzR3JpZFtzbGlkZXNHcmlkLmxlbmd0aCAtIDFdIC0gc2xpZGVzR3JpZFtzbGlkZXNHcmlkLmxlbmd0aCAtIDJdO1xuICAgIH1cbiAgfVxuICBsZXQgcmV3aW5kRmlyc3RJbmRleCA9IG51bGw7XG4gIGxldCByZXdpbmRMYXN0SW5kZXggPSBudWxsO1xuICBpZiAocGFyYW1zLnJld2luZCkge1xuICAgIGlmIChzd2lwZXIuaXNCZWdpbm5pbmcpIHtcbiAgICAgIHJld2luZExhc3RJbmRleCA9IHBhcmFtcy52aXJ0dWFsICYmIHBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgJiYgc3dpcGVyLnZpcnR1YWwgPyBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoIC0gMSA6IHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMTtcbiAgICB9IGVsc2UgaWYgKHN3aXBlci5pc0VuZCkge1xuICAgICAgcmV3aW5kRmlyc3RJbmRleCA9IDA7XG4gICAgfVxuICB9XG4gIC8vIEZpbmQgY3VycmVudCBzbGlkZSBzaXplXG4gIGNvbnN0IHJhdGlvID0gKGN1cnJlbnRQb3MgLSBzbGlkZXNHcmlkW3N0b3BJbmRleF0pIC8gZ3JvdXBTaXplO1xuICBjb25zdCBpbmNyZW1lbnQgPSBzdG9wSW5kZXggPCBwYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwIC0gMSA/IDEgOiBwYXJhbXMuc2xpZGVzUGVyR3JvdXA7XG4gIGlmICh0aW1lRGlmZiA+IHBhcmFtcy5sb25nU3dpcGVzTXMpIHtcbiAgICAvLyBMb25nIHRvdWNoZXNcbiAgICBpZiAoIXBhcmFtcy5sb25nU3dpcGVzKSB7XG4gICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLnN3aXBlRGlyZWN0aW9uID09PSAnbmV4dCcpIHtcbiAgICAgIGlmIChyYXRpbyA+PSBwYXJhbXMubG9uZ1N3aXBlc1JhdGlvKSBzd2lwZXIuc2xpZGVUbyhwYXJhbXMucmV3aW5kICYmIHN3aXBlci5pc0VuZCA/IHJld2luZEZpcnN0SW5kZXggOiBzdG9wSW5kZXggKyBpbmNyZW1lbnQpO2Vsc2Ugc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4KTtcbiAgICB9XG4gICAgaWYgKHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ3ByZXYnKSB7XG4gICAgICBpZiAocmF0aW8gPiAxIC0gcGFyYW1zLmxvbmdTd2lwZXNSYXRpbykge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhzdG9wSW5kZXggKyBpbmNyZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChyZXdpbmRMYXN0SW5kZXggIT09IG51bGwgJiYgcmF0aW8gPCAwICYmIE1hdGguYWJzKHJhdGlvKSA+IHBhcmFtcy5sb25nU3dpcGVzUmF0aW8pIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8ocmV3aW5kTGFzdEluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFNob3J0IHN3aXBlc1xuICAgIGlmICghcGFyYW1zLnNob3J0U3dpcGVzKSB7XG4gICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc05hdkJ1dHRvblRhcmdldCA9IHN3aXBlci5uYXZpZ2F0aW9uICYmIChlLnRhcmdldCA9PT0gc3dpcGVyLm5hdmlnYXRpb24ubmV4dEVsIHx8IGUudGFyZ2V0ID09PSBzd2lwZXIubmF2aWdhdGlvbi5wcmV2RWwpO1xuICAgIGlmICghaXNOYXZCdXR0b25UYXJnZXQpIHtcbiAgICAgIGlmIChzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICduZXh0Jykge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhyZXdpbmRGaXJzdEluZGV4ICE9PSBudWxsID8gcmV3aW5kRmlyc3RJbmRleCA6IHN0b3BJbmRleCArIGluY3JlbWVudCk7XG4gICAgICB9XG4gICAgICBpZiAoc3dpcGVyLnN3aXBlRGlyZWN0aW9uID09PSAncHJldicpIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8ocmV3aW5kTGFzdEluZGV4ICE9PSBudWxsID8gcmV3aW5kTGFzdEluZGV4IDogc3RvcEluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGUudGFyZ2V0ID09PSBzd2lwZXIubmF2aWdhdGlvbi5uZXh0RWwpIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCArIGluY3JlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgcGFyYW1zLFxuICAgIGVsXG4gIH0gPSBzd2lwZXI7XG4gIGlmIChlbCAmJiBlbC5vZmZzZXRXaWR0aCA9PT0gMCkgcmV0dXJuO1xuXG4gIC8vIEJyZWFrcG9pbnRzXG4gIGlmIChwYXJhbXMuYnJlYWtwb2ludHMpIHtcbiAgICBzd2lwZXIuc2V0QnJlYWtwb2ludCgpO1xuICB9XG5cbiAgLy8gU2F2ZSBsb2Nrc1xuICBjb25zdCB7XG4gICAgYWxsb3dTbGlkZU5leHQsXG4gICAgYWxsb3dTbGlkZVByZXYsXG4gICAgc25hcEdyaWRcbiAgfSA9IHN3aXBlcjtcbiAgY29uc3QgaXNWaXJ0dWFsID0gc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7XG5cbiAgLy8gRGlzYWJsZSBsb2NrcyBvbiByZXNpemVcbiAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gdHJ1ZTtcbiAgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID0gdHJ1ZTtcbiAgc3dpcGVyLnVwZGF0ZVNpemUoKTtcbiAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICBjb25zdCBpc1ZpcnR1YWxMb29wID0gaXNWaXJ0dWFsICYmIHBhcmFtcy5sb29wO1xuICBpZiAoKHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycgfHwgcGFyYW1zLnNsaWRlc1BlclZpZXcgPiAxKSAmJiBzd2lwZXIuaXNFbmQgJiYgIXN3aXBlci5pc0JlZ2lubmluZyAmJiAhc3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiAhaXNWaXJ0dWFsTG9vcCkge1xuICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMSwgMCwgZmFsc2UsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3AgJiYgIWlzVmlydHVhbCkge1xuICAgICAgc3dpcGVyLnNsaWRlVG9Mb29wKHN3aXBlci5yZWFsSW5kZXgsIDAsIGZhbHNlLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4LCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIGlmIChzd2lwZXIuYXV0b3BsYXkgJiYgc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcgJiYgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCkge1xuICAgIGNsZWFyVGltZW91dChzd2lwZXIuYXV0b3BsYXkucmVzaXplVGltZW91dCk7XG4gICAgc3dpcGVyLmF1dG9wbGF5LnJlc2l6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChzd2lwZXIuYXV0b3BsYXkgJiYgc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcgJiYgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCkge1xuICAgICAgICBzd2lwZXIuYXV0b3BsYXkucmVzdW1lKCk7XG4gICAgICB9XG4gICAgfSwgNTAwKTtcbiAgfVxuICAvLyBSZXR1cm4gbG9ja3MgYWZ0ZXIgcmVzaXplXG4gIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IGFsbG93U2xpZGVQcmV2O1xuICBzd2lwZXIuYWxsb3dTbGlkZU5leHQgPSBhbGxvd1NsaWRlTmV4dDtcbiAgaWYgKHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzbmFwR3JpZCAhPT0gc3dpcGVyLnNuYXBHcmlkKSB7XG4gICAgc3dpcGVyLmNoZWNrT3ZlcmZsb3coKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKCFzd2lwZXIuZW5hYmxlZCkgcmV0dXJuO1xuICBpZiAoIXN3aXBlci5hbGxvd0NsaWNrKSB7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMucHJldmVudENsaWNrcykgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLnByZXZlbnRDbGlja3NQcm9wYWdhdGlvbiAmJiBzd2lwZXIuYW5pbWF0aW5nKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25TY3JvbGwoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICB3cmFwcGVyRWwsXG4gICAgcnRsVHJhbnNsYXRlLFxuICAgIGVuYWJsZWRcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gIHN3aXBlci5wcmV2aW91c1RyYW5zbGF0ZSA9IHN3aXBlci50cmFuc2xhdGU7XG4gIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICBzd2lwZXIudHJhbnNsYXRlID0gLXdyYXBwZXJFbC5zY3JvbGxMZWZ0O1xuICB9IGVsc2Uge1xuICAgIHN3aXBlci50cmFuc2xhdGUgPSAtd3JhcHBlckVsLnNjcm9sbFRvcDtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgaWYgKHN3aXBlci50cmFuc2xhdGUgPT09IDApIHN3aXBlci50cmFuc2xhdGUgPSAwO1xuICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgbGV0IG5ld1Byb2dyZXNzO1xuICBjb25zdCB0cmFuc2xhdGVzRGlmZiA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKTtcbiAgaWYgKHRyYW5zbGF0ZXNEaWZmID09PSAwKSB7XG4gICAgbmV3UHJvZ3Jlc3MgPSAwO1xuICB9IGVsc2Uge1xuICAgIG5ld1Byb2dyZXNzID0gKHN3aXBlci50cmFuc2xhdGUgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpIC8gdHJhbnNsYXRlc0RpZmY7XG4gIH1cbiAgaWYgKG5ld1Byb2dyZXNzICE9PSBzd2lwZXIucHJvZ3Jlc3MpIHtcbiAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MocnRsVHJhbnNsYXRlID8gLXN3aXBlci50cmFuc2xhdGUgOiBzd2lwZXIudHJhbnNsYXRlKTtcbiAgfVxuICBzd2lwZXIuZW1pdCgnc2V0VHJhbnNsYXRlJywgc3dpcGVyLnRyYW5zbGF0ZSwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBvbkxvYWQoZSkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBwcm9jZXNzTGF6eVByZWxvYWRlcihzd2lwZXIsIGUudGFyZ2V0KTtcbiAgaWYgKHN3aXBlci5wYXJhbXMuY3NzTW9kZSB8fCBzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcgIT09ICdhdXRvJyAmJiAhc3dpcGVyLnBhcmFtcy5hdXRvSGVpZ2h0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN3aXBlci51cGRhdGUoKTtcbn1cblxuZnVuY3Rpb24gb25Eb2N1bWVudFRvdWNoU3RhcnQoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGlmIChzd2lwZXIuZG9jdW1lbnRUb3VjaEhhbmRsZXJQcm9jZWVkZWQpIHJldHVybjtcbiAgc3dpcGVyLmRvY3VtZW50VG91Y2hIYW5kbGVyUHJvY2VlZGVkID0gdHJ1ZTtcbiAgaWYgKHN3aXBlci5wYXJhbXMudG91Y2hSZWxlYXNlT25FZGdlcykge1xuICAgIHN3aXBlci5lbC5zdHlsZS50b3VjaEFjdGlvbiA9ICdhdXRvJztcbiAgfVxufVxuXG5jb25zdCBldmVudHMgPSAoc3dpcGVyLCBtZXRob2QpID0+IHtcbiAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICBjb25zdCB7XG4gICAgcGFyYW1zLFxuICAgIGVsLFxuICAgIHdyYXBwZXJFbCxcbiAgICBkZXZpY2VcbiAgfSA9IHN3aXBlcjtcbiAgY29uc3QgY2FwdHVyZSA9ICEhcGFyYW1zLm5lc3RlZDtcbiAgY29uc3QgZG9tTWV0aG9kID0gbWV0aG9kID09PSAnb24nID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICBjb25zdCBzd2lwZXJNZXRob2QgPSBtZXRob2Q7XG5cbiAgLy8gVG91Y2ggRXZlbnRzXG4gIGRvY3VtZW50W2RvbU1ldGhvZF0oJ3RvdWNoc3RhcnQnLCBzd2lwZXIub25Eb2N1bWVudFRvdWNoU3RhcnQsIHtcbiAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICBjYXB0dXJlXG4gIH0pO1xuICBlbFtkb21NZXRob2RdKCd0b3VjaHN0YXJ0Jywgc3dpcGVyLm9uVG91Y2hTdGFydCwge1xuICAgIHBhc3NpdmU6IGZhbHNlXG4gIH0pO1xuICBlbFtkb21NZXRob2RdKCdwb2ludGVyZG93bicsIHN3aXBlci5vblRvdWNoU3RhcnQsIHtcbiAgICBwYXNzaXZlOiBmYWxzZVxuICB9KTtcbiAgZG9jdW1lbnRbZG9tTWV0aG9kXSgndG91Y2htb3ZlJywgc3dpcGVyLm9uVG91Y2hNb3ZlLCB7XG4gICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgY2FwdHVyZVxuICB9KTtcbiAgZG9jdW1lbnRbZG9tTWV0aG9kXSgncG9pbnRlcm1vdmUnLCBzd2lwZXIub25Ub3VjaE1vdmUsIHtcbiAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICBjYXB0dXJlXG4gIH0pO1xuICBkb2N1bWVudFtkb21NZXRob2RdKCd0b3VjaGVuZCcsIHN3aXBlci5vblRvdWNoRW5kLCB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9KTtcbiAgZG9jdW1lbnRbZG9tTWV0aG9kXSgncG9pbnRlcnVwJywgc3dpcGVyLm9uVG91Y2hFbmQsIHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH0pO1xuICBkb2N1bWVudFtkb21NZXRob2RdKCdwb2ludGVyY2FuY2VsJywgc3dpcGVyLm9uVG91Y2hFbmQsIHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH0pO1xuICBkb2N1bWVudFtkb21NZXRob2RdKCd0b3VjaGNhbmNlbCcsIHN3aXBlci5vblRvdWNoRW5kLCB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9KTtcbiAgZG9jdW1lbnRbZG9tTWV0aG9kXSgncG9pbnRlcm91dCcsIHN3aXBlci5vblRvdWNoRW5kLCB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9KTtcbiAgZG9jdW1lbnRbZG9tTWV0aG9kXSgncG9pbnRlcmxlYXZlJywgc3dpcGVyLm9uVG91Y2hFbmQsIHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH0pO1xuICBkb2N1bWVudFtkb21NZXRob2RdKCdjb250ZXh0bWVudScsIHN3aXBlci5vblRvdWNoRW5kLCB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9KTtcblxuICAvLyBQcmV2ZW50IExpbmtzIENsaWNrc1xuICBpZiAocGFyYW1zLnByZXZlbnRDbGlja3MgfHwgcGFyYW1zLnByZXZlbnRDbGlja3NQcm9wYWdhdGlvbikge1xuICAgIGVsW2RvbU1ldGhvZF0oJ2NsaWNrJywgc3dpcGVyLm9uQ2xpY2ssIHRydWUpO1xuICB9XG4gIGlmIChwYXJhbXMuY3NzTW9kZSkge1xuICAgIHdyYXBwZXJFbFtkb21NZXRob2RdKCdzY3JvbGwnLCBzd2lwZXIub25TY3JvbGwpO1xuICB9XG5cbiAgLy8gUmVzaXplIGhhbmRsZXJcbiAgaWYgKHBhcmFtcy51cGRhdGVPbldpbmRvd1Jlc2l6ZSkge1xuICAgIHN3aXBlcltzd2lwZXJNZXRob2RdKGRldmljZS5pb3MgfHwgZGV2aWNlLmFuZHJvaWQgPyAncmVzaXplIG9yaWVudGF0aW9uY2hhbmdlIG9ic2VydmVyVXBkYXRlJyA6ICdyZXNpemUgb2JzZXJ2ZXJVcGRhdGUnLCBvblJlc2l6ZSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3dpcGVyW3N3aXBlck1ldGhvZF0oJ29ic2VydmVyVXBkYXRlJywgb25SZXNpemUsIHRydWUpO1xuICB9XG5cbiAgLy8gSW1hZ2VzIGxvYWRlclxuICBlbFtkb21NZXRob2RdKCdsb2FkJywgc3dpcGVyLm9uTG9hZCwge1xuICAgIGNhcHR1cmU6IHRydWVcbiAgfSk7XG59O1xuZnVuY3Rpb24gYXR0YWNoRXZlbnRzKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgcGFyYW1zXG4gIH0gPSBzd2lwZXI7XG4gIHN3aXBlci5vblRvdWNoU3RhcnQgPSBvblRvdWNoU3RhcnQuYmluZChzd2lwZXIpO1xuICBzd2lwZXIub25Ub3VjaE1vdmUgPSBvblRvdWNoTW92ZS5iaW5kKHN3aXBlcik7XG4gIHN3aXBlci5vblRvdWNoRW5kID0gb25Ub3VjaEVuZC5iaW5kKHN3aXBlcik7XG4gIHN3aXBlci5vbkRvY3VtZW50VG91Y2hTdGFydCA9IG9uRG9jdW1lbnRUb3VjaFN0YXJ0LmJpbmQoc3dpcGVyKTtcbiAgaWYgKHBhcmFtcy5jc3NNb2RlKSB7XG4gICAgc3dpcGVyLm9uU2Nyb2xsID0gb25TY3JvbGwuYmluZChzd2lwZXIpO1xuICB9XG4gIHN3aXBlci5vbkNsaWNrID0gb25DbGljay5iaW5kKHN3aXBlcik7XG4gIHN3aXBlci5vbkxvYWQgPSBvbkxvYWQuYmluZChzd2lwZXIpO1xuICBldmVudHMoc3dpcGVyLCAnb24nKTtcbn1cbmZ1bmN0aW9uIGRldGFjaEV2ZW50cygpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgZXZlbnRzKHN3aXBlciwgJ29mZicpO1xufVxudmFyIGV2ZW50cyQxID0ge1xuICBhdHRhY2hFdmVudHMsXG4gIGRldGFjaEV2ZW50c1xufTtcblxuY29uc3QgaXNHcmlkRW5hYmxlZCA9IChzd2lwZXIsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gc3dpcGVyLmdyaWQgJiYgcGFyYW1zLmdyaWQgJiYgcGFyYW1zLmdyaWQucm93cyA+IDE7XG59O1xuZnVuY3Rpb24gc2V0QnJlYWtwb2ludCgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHJlYWxJbmRleCxcbiAgICBpbml0aWFsaXplZCxcbiAgICBwYXJhbXMsXG4gICAgZWxcbiAgfSA9IHN3aXBlcjtcbiAgY29uc3QgYnJlYWtwb2ludHMgPSBwYXJhbXMuYnJlYWtwb2ludHM7XG4gIGlmICghYnJlYWtwb2ludHMgfHwgYnJlYWtwb2ludHMgJiYgT2JqZWN0LmtleXMoYnJlYWtwb2ludHMpLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gIC8vIEdldCBicmVha3BvaW50IGZvciB3aW5kb3cgd2lkdGggYW5kIHVwZGF0ZSBwYXJhbWV0ZXJzXG4gIGNvbnN0IGJyZWFrcG9pbnQgPSBzd2lwZXIuZ2V0QnJlYWtwb2ludChicmVha3BvaW50cywgc3dpcGVyLnBhcmFtcy5icmVha3BvaW50c0Jhc2UsIHN3aXBlci5lbCk7XG4gIGlmICghYnJlYWtwb2ludCB8fCBzd2lwZXIuY3VycmVudEJyZWFrcG9pbnQgPT09IGJyZWFrcG9pbnQpIHJldHVybjtcbiAgY29uc3QgYnJlYWtwb2ludE9ubHlQYXJhbXMgPSBicmVha3BvaW50IGluIGJyZWFrcG9pbnRzID8gYnJlYWtwb2ludHNbYnJlYWtwb2ludF0gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGJyZWFrcG9pbnRQYXJhbXMgPSBicmVha3BvaW50T25seVBhcmFtcyB8fCBzd2lwZXIub3JpZ2luYWxQYXJhbXM7XG4gIGNvbnN0IHdhc011bHRpUm93ID0gaXNHcmlkRW5hYmxlZChzd2lwZXIsIHBhcmFtcyk7XG4gIGNvbnN0IGlzTXVsdGlSb3cgPSBpc0dyaWRFbmFibGVkKHN3aXBlciwgYnJlYWtwb2ludFBhcmFtcyk7XG4gIGNvbnN0IHdhc0dyYWJDdXJzb3IgPSBzd2lwZXIucGFyYW1zLmdyYWJDdXJzb3I7XG4gIGNvbnN0IGlzR3JhYkN1cnNvciA9IGJyZWFrcG9pbnRQYXJhbXMuZ3JhYkN1cnNvcjtcbiAgY29uc3Qgd2FzRW5hYmxlZCA9IHBhcmFtcy5lbmFibGVkO1xuICBpZiAod2FzTXVsdGlSb3cgJiYgIWlzTXVsdGlSb3cpIHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGAke3BhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfWdyaWRgLCBgJHtwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ncmlkLWNvbHVtbmApO1xuICAgIHN3aXBlci5lbWl0Q29udGFpbmVyQ2xhc3NlcygpO1xuICB9IGVsc2UgaWYgKCF3YXNNdWx0aVJvdyAmJiBpc011bHRpUm93KSB7XG4gICAgZWwuY2xhc3NMaXN0LmFkZChgJHtwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ncmlkYCk7XG4gICAgaWYgKGJyZWFrcG9pbnRQYXJhbXMuZ3JpZC5maWxsICYmIGJyZWFrcG9pbnRQYXJhbXMuZ3JpZC5maWxsID09PSAnY29sdW1uJyB8fCAhYnJlYWtwb2ludFBhcmFtcy5ncmlkLmZpbGwgJiYgcGFyYW1zLmdyaWQuZmlsbCA9PT0gJ2NvbHVtbicpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoYCR7cGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9Z3JpZC1jb2x1bW5gKTtcbiAgICB9XG4gICAgc3dpcGVyLmVtaXRDb250YWluZXJDbGFzc2VzKCk7XG4gIH1cbiAgaWYgKHdhc0dyYWJDdXJzb3IgJiYgIWlzR3JhYkN1cnNvcikge1xuICAgIHN3aXBlci51bnNldEdyYWJDdXJzb3IoKTtcbiAgfSBlbHNlIGlmICghd2FzR3JhYkN1cnNvciAmJiBpc0dyYWJDdXJzb3IpIHtcbiAgICBzd2lwZXIuc2V0R3JhYkN1cnNvcigpO1xuICB9XG5cbiAgLy8gVG9nZ2xlIG5hdmlnYXRpb24sIHBhZ2luYXRpb24sIHNjcm9sbGJhclxuICBbJ25hdmlnYXRpb24nLCAncGFnaW5hdGlvbicsICdzY3JvbGxiYXInXS5mb3JFYWNoKHByb3AgPT4ge1xuICAgIGlmICh0eXBlb2YgYnJlYWtwb2ludFBhcmFtc1twcm9wXSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBjb25zdCB3YXNNb2R1bGVFbmFibGVkID0gcGFyYW1zW3Byb3BdICYmIHBhcmFtc1twcm9wXS5lbmFibGVkO1xuICAgIGNvbnN0IGlzTW9kdWxlRW5hYmxlZCA9IGJyZWFrcG9pbnRQYXJhbXNbcHJvcF0gJiYgYnJlYWtwb2ludFBhcmFtc1twcm9wXS5lbmFibGVkO1xuICAgIGlmICh3YXNNb2R1bGVFbmFibGVkICYmICFpc01vZHVsZUVuYWJsZWQpIHtcbiAgICAgIHN3aXBlcltwcm9wXS5kaXNhYmxlKCk7XG4gICAgfVxuICAgIGlmICghd2FzTW9kdWxlRW5hYmxlZCAmJiBpc01vZHVsZUVuYWJsZWQpIHtcbiAgICAgIHN3aXBlcltwcm9wXS5lbmFibGUoKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBkaXJlY3Rpb25DaGFuZ2VkID0gYnJlYWtwb2ludFBhcmFtcy5kaXJlY3Rpb24gJiYgYnJlYWtwb2ludFBhcmFtcy5kaXJlY3Rpb24gIT09IHBhcmFtcy5kaXJlY3Rpb247XG4gIGNvbnN0IG5lZWRzUmVMb29wID0gcGFyYW1zLmxvb3AgJiYgKGJyZWFrcG9pbnRQYXJhbXMuc2xpZGVzUGVyVmlldyAhPT0gcGFyYW1zLnNsaWRlc1BlclZpZXcgfHwgZGlyZWN0aW9uQ2hhbmdlZCk7XG4gIGNvbnN0IHdhc0xvb3AgPSBwYXJhbXMubG9vcDtcbiAgaWYgKGRpcmVjdGlvbkNoYW5nZWQgJiYgaW5pdGlhbGl6ZWQpIHtcbiAgICBzd2lwZXIuY2hhbmdlRGlyZWN0aW9uKCk7XG4gIH1cbiAgZXh0ZW5kKHN3aXBlci5wYXJhbXMsIGJyZWFrcG9pbnRQYXJhbXMpO1xuICBjb25zdCBpc0VuYWJsZWQgPSBzd2lwZXIucGFyYW1zLmVuYWJsZWQ7XG4gIGNvbnN0IGhhc0xvb3AgPSBzd2lwZXIucGFyYW1zLmxvb3A7XG4gIE9iamVjdC5hc3NpZ24oc3dpcGVyLCB7XG4gICAgYWxsb3dUb3VjaE1vdmU6IHN3aXBlci5wYXJhbXMuYWxsb3dUb3VjaE1vdmUsXG4gICAgYWxsb3dTbGlkZU5leHQ6IHN3aXBlci5wYXJhbXMuYWxsb3dTbGlkZU5leHQsXG4gICAgYWxsb3dTbGlkZVByZXY6IHN3aXBlci5wYXJhbXMuYWxsb3dTbGlkZVByZXZcbiAgfSk7XG4gIGlmICh3YXNFbmFibGVkICYmICFpc0VuYWJsZWQpIHtcbiAgICBzd2lwZXIuZGlzYWJsZSgpO1xuICB9IGVsc2UgaWYgKCF3YXNFbmFibGVkICYmIGlzRW5hYmxlZCkge1xuICAgIHN3aXBlci5lbmFibGUoKTtcbiAgfVxuICBzd2lwZXIuY3VycmVudEJyZWFrcG9pbnQgPSBicmVha3BvaW50O1xuICBzd2lwZXIuZW1pdCgnX2JlZm9yZUJyZWFrcG9pbnQnLCBicmVha3BvaW50UGFyYW1zKTtcbiAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgaWYgKG5lZWRzUmVMb29wKSB7XG4gICAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcbiAgICAgIHN3aXBlci5sb29wQ3JlYXRlKHJlYWxJbmRleCk7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzKCk7XG4gICAgfSBlbHNlIGlmICghd2FzTG9vcCAmJiBoYXNMb29wKSB7XG4gICAgICBzd2lwZXIubG9vcENyZWF0ZShyZWFsSW5kZXgpO1xuICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuICAgIH0gZWxzZSBpZiAod2FzTG9vcCAmJiAhaGFzTG9vcCkge1xuICAgICAgc3dpcGVyLmxvb3BEZXN0cm95KCk7XG4gICAgfVxuICB9XG4gIHN3aXBlci5lbWl0KCdicmVha3BvaW50JywgYnJlYWtwb2ludFBhcmFtcyk7XG59XG5cbmZ1bmN0aW9uIGdldEJyZWFrcG9pbnQoYnJlYWtwb2ludHMsIGJhc2UsIGNvbnRhaW5lckVsKSB7XG4gIGlmIChiYXNlID09PSB2b2lkIDApIHtcbiAgICBiYXNlID0gJ3dpbmRvdyc7XG4gIH1cbiAgaWYgKCFicmVha3BvaW50cyB8fCBiYXNlID09PSAnY29udGFpbmVyJyAmJiAhY29udGFpbmVyRWwpIHJldHVybiB1bmRlZmluZWQ7XG4gIGxldCBicmVha3BvaW50ID0gZmFsc2U7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICBjb25zdCBjdXJyZW50SGVpZ2h0ID0gYmFzZSA9PT0gJ3dpbmRvdycgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiBjb250YWluZXJFbC5jbGllbnRIZWlnaHQ7XG4gIGNvbnN0IHBvaW50cyA9IE9iamVjdC5rZXlzKGJyZWFrcG9pbnRzKS5tYXAocG9pbnQgPT4ge1xuICAgIGlmICh0eXBlb2YgcG9pbnQgPT09ICdzdHJpbmcnICYmIHBvaW50LmluZGV4T2YoJ0AnKSA9PT0gMCkge1xuICAgICAgY29uc3QgbWluUmF0aW8gPSBwYXJzZUZsb2F0KHBvaW50LnN1YnN0cigxKSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGN1cnJlbnRIZWlnaHQgKiBtaW5SYXRpbztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBwb2ludFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBwb2ludCxcbiAgICAgIHBvaW50XG4gICAgfTtcbiAgfSk7XG4gIHBvaW50cy5zb3J0KChhLCBiKSA9PiBwYXJzZUludChhLnZhbHVlLCAxMCkgLSBwYXJzZUludChiLnZhbHVlLCAxMCkpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBvaW50LFxuICAgICAgdmFsdWVcbiAgICB9ID0gcG9pbnRzW2ldO1xuICAgIGlmIChiYXNlID09PSAnd2luZG93Jykge1xuICAgICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKGAobWluLXdpZHRoOiAke3ZhbHVlfXB4KWApLm1hdGNoZXMpIHtcbiAgICAgICAgYnJlYWtwb2ludCA9IHBvaW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsdWUgPD0gY29udGFpbmVyRWwuY2xpZW50V2lkdGgpIHtcbiAgICAgIGJyZWFrcG9pbnQgPSBwb2ludDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJyZWFrcG9pbnQgfHwgJ21heCc7XG59XG5cbnZhciBicmVha3BvaW50cyA9IHtcbiAgc2V0QnJlYWtwb2ludCxcbiAgZ2V0QnJlYWtwb2ludFxufTtcblxuZnVuY3Rpb24gcHJlcGFyZUNsYXNzZXMoZW50cmllcywgcHJlZml4KSB7XG4gIGNvbnN0IHJlc3VsdENsYXNzZXMgPSBbXTtcbiAgZW50cmllcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKGl0ZW0pLmZvckVhY2goY2xhc3NOYW1lcyA9PiB7XG4gICAgICAgIGlmIChpdGVtW2NsYXNzTmFtZXNdKSB7XG4gICAgICAgICAgcmVzdWx0Q2xhc3Nlcy5wdXNoKHByZWZpeCArIGNsYXNzTmFtZXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgcmVzdWx0Q2xhc3Nlcy5wdXNoKHByZWZpeCArIGl0ZW0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHRDbGFzc2VzO1xufVxuZnVuY3Rpb24gYWRkQ2xhc3NlcygpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIGNsYXNzTmFtZXMsXG4gICAgcGFyYW1zLFxuICAgIHJ0bCxcbiAgICBlbCxcbiAgICBkZXZpY2VcbiAgfSA9IHN3aXBlcjtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIGNvbnN0IHN1ZmZpeGVzID0gcHJlcGFyZUNsYXNzZXMoWydpbml0aWFsaXplZCcsIHBhcmFtcy5kaXJlY3Rpb24sIHtcbiAgICAnZnJlZS1tb2RlJzogc3dpcGVyLnBhcmFtcy5mcmVlTW9kZSAmJiBwYXJhbXMuZnJlZU1vZGUuZW5hYmxlZFxuICB9LCB7XG4gICAgJ2F1dG9oZWlnaHQnOiBwYXJhbXMuYXV0b0hlaWdodFxuICB9LCB7XG4gICAgJ3J0bCc6IHJ0bFxuICB9LCB7XG4gICAgJ2dyaWQnOiBwYXJhbXMuZ3JpZCAmJiBwYXJhbXMuZ3JpZC5yb3dzID4gMVxuICB9LCB7XG4gICAgJ2dyaWQtY29sdW1uJzogcGFyYW1zLmdyaWQgJiYgcGFyYW1zLmdyaWQucm93cyA+IDEgJiYgcGFyYW1zLmdyaWQuZmlsbCA9PT0gJ2NvbHVtbidcbiAgfSwge1xuICAgICdhbmRyb2lkJzogZGV2aWNlLmFuZHJvaWRcbiAgfSwge1xuICAgICdpb3MnOiBkZXZpY2UuaW9zXG4gIH0sIHtcbiAgICAnY3NzLW1vZGUnOiBwYXJhbXMuY3NzTW9kZVxuICB9LCB7XG4gICAgJ2NlbnRlcmVkJzogcGFyYW1zLmNzc01vZGUgJiYgcGFyYW1zLmNlbnRlcmVkU2xpZGVzXG4gIH0sIHtcbiAgICAnd2F0Y2gtcHJvZ3Jlc3MnOiBwYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzc1xuICB9XSwgcGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MpO1xuICBjbGFzc05hbWVzLnB1c2goLi4uc3VmZml4ZXMpO1xuICBlbC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xuICBzd2lwZXIuZW1pdENvbnRhaW5lckNsYXNzZXMoKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NlcygpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIGVsLFxuICAgIGNsYXNzTmFtZXNcbiAgfSA9IHN3aXBlcjtcbiAgZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc05hbWVzKTtcbiAgc3dpcGVyLmVtaXRDb250YWluZXJDbGFzc2VzKCk7XG59XG5cbnZhciBjbGFzc2VzID0ge1xuICBhZGRDbGFzc2VzLFxuICByZW1vdmVDbGFzc2VzXG59O1xuXG5mdW5jdGlvbiBjaGVja092ZXJmbG93KCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgaXNMb2NrZWQ6IHdhc0xvY2tlZCxcbiAgICBwYXJhbXNcbiAgfSA9IHN3aXBlcjtcbiAgY29uc3Qge1xuICAgIHNsaWRlc09mZnNldEJlZm9yZVxuICB9ID0gcGFyYW1zO1xuICBpZiAoc2xpZGVzT2Zmc2V0QmVmb3JlKSB7XG4gICAgY29uc3QgbGFzdFNsaWRlSW5kZXggPSBzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgbGFzdFNsaWRlUmlnaHRFZGdlID0gc3dpcGVyLnNsaWRlc0dyaWRbbGFzdFNsaWRlSW5kZXhdICsgc3dpcGVyLnNsaWRlc1NpemVzR3JpZFtsYXN0U2xpZGVJbmRleF0gKyBzbGlkZXNPZmZzZXRCZWZvcmUgKiAyO1xuICAgIHN3aXBlci5pc0xvY2tlZCA9IHN3aXBlci5zaXplID4gbGFzdFNsaWRlUmlnaHRFZGdlO1xuICB9IGVsc2Uge1xuICAgIHN3aXBlci5pc0xvY2tlZCA9IHN3aXBlci5zbmFwR3JpZC5sZW5ndGggPT09IDE7XG4gIH1cbiAgaWYgKHBhcmFtcy5hbGxvd1NsaWRlTmV4dCA9PT0gdHJ1ZSkge1xuICAgIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9ICFzd2lwZXIuaXNMb2NrZWQ7XG4gIH1cbiAgaWYgKHBhcmFtcy5hbGxvd1NsaWRlUHJldiA9PT0gdHJ1ZSkge1xuICAgIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9ICFzd2lwZXIuaXNMb2NrZWQ7XG4gIH1cbiAgaWYgKHdhc0xvY2tlZCAmJiB3YXNMb2NrZWQgIT09IHN3aXBlci5pc0xvY2tlZCkge1xuICAgIHN3aXBlci5pc0VuZCA9IGZhbHNlO1xuICB9XG4gIGlmICh3YXNMb2NrZWQgIT09IHN3aXBlci5pc0xvY2tlZCkge1xuICAgIHN3aXBlci5lbWl0KHN3aXBlci5pc0xvY2tlZCA/ICdsb2NrJyA6ICd1bmxvY2snKTtcbiAgfVxufVxudmFyIGNoZWNrT3ZlcmZsb3ckMSA9IHtcbiAgY2hlY2tPdmVyZmxvd1xufTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBpbml0OiB0cnVlLFxuICBkaXJlY3Rpb246ICdob3Jpem9udGFsJyxcbiAgb25lV2F5TW92ZW1lbnQ6IGZhbHNlLFxuICBzd2lwZXJFbGVtZW50Tm9kZU5hbWU6ICdTV0lQRVItQ09OVEFJTkVSJyxcbiAgdG91Y2hFdmVudHNUYXJnZXQ6ICd3cmFwcGVyJyxcbiAgaW5pdGlhbFNsaWRlOiAwLFxuICBzcGVlZDogMzAwLFxuICBjc3NNb2RlOiBmYWxzZSxcbiAgdXBkYXRlT25XaW5kb3dSZXNpemU6IHRydWUsXG4gIHJlc2l6ZU9ic2VydmVyOiB0cnVlLFxuICBuZXN0ZWQ6IGZhbHNlLFxuICBjcmVhdGVFbGVtZW50czogZmFsc2UsXG4gIGV2ZW50c1ByZWZpeDogJ3N3aXBlcicsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIGZvY3VzYWJsZUVsZW1lbnRzOiAnaW5wdXQsIHNlbGVjdCwgb3B0aW9uLCB0ZXh0YXJlYSwgYnV0dG9uLCB2aWRlbywgbGFiZWwnLFxuICAvLyBPdmVycmlkZXNcbiAgd2lkdGg6IG51bGwsXG4gIGhlaWdodDogbnVsbCxcbiAgLy9cbiAgcHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uOiBmYWxzZSxcbiAgLy8gc3NyXG4gIHVzZXJBZ2VudDogbnVsbCxcbiAgdXJsOiBudWxsLFxuICAvLyBUbyBzdXBwb3J0IGlPUydzIHN3aXBlLXRvLWdvLWJhY2sgZ2VzdHVyZSAod2hlbiBiZWluZyB1c2VkIGluLWFwcCkuXG4gIGVkZ2VTd2lwZURldGVjdGlvbjogZmFsc2UsXG4gIGVkZ2VTd2lwZVRocmVzaG9sZDogMjAsXG4gIC8vIEF1dG9oZWlnaHRcbiAgYXV0b0hlaWdodDogZmFsc2UsXG4gIC8vIFNldCB3cmFwcGVyIHdpZHRoXG4gIHNldFdyYXBwZXJTaXplOiBmYWxzZSxcbiAgLy8gVmlydHVhbCBUcmFuc2xhdGVcbiAgdmlydHVhbFRyYW5zbGF0ZTogZmFsc2UsXG4gIC8vIEVmZmVjdHNcbiAgZWZmZWN0OiAnc2xpZGUnLFxuICAvLyAnc2xpZGUnIG9yICdmYWRlJyBvciAnY3ViZScgb3IgJ2NvdmVyZmxvdycgb3IgJ2ZsaXAnXG5cbiAgLy8gQnJlYWtwb2ludHNcbiAgYnJlYWtwb2ludHM6IHVuZGVmaW5lZCxcbiAgYnJlYWtwb2ludHNCYXNlOiAnd2luZG93JyxcbiAgLy8gU2xpZGVzIGdyaWRcbiAgc3BhY2VCZXR3ZWVuOiAwLFxuICBzbGlkZXNQZXJWaWV3OiAxLFxuICBzbGlkZXNQZXJHcm91cDogMSxcbiAgc2xpZGVzUGVyR3JvdXBTa2lwOiAwLFxuICBzbGlkZXNQZXJHcm91cEF1dG86IGZhbHNlLFxuICBjZW50ZXJlZFNsaWRlczogZmFsc2UsXG4gIGNlbnRlcmVkU2xpZGVzQm91bmRzOiBmYWxzZSxcbiAgc2xpZGVzT2Zmc2V0QmVmb3JlOiAwLFxuICAvLyBpbiBweFxuICBzbGlkZXNPZmZzZXRBZnRlcjogMCxcbiAgLy8gaW4gcHhcbiAgbm9ybWFsaXplU2xpZGVJbmRleDogdHJ1ZSxcbiAgY2VudGVySW5zdWZmaWNpZW50U2xpZGVzOiBmYWxzZSxcbiAgLy8gRGlzYWJsZSBzd2lwZXIgYW5kIGhpZGUgbmF2aWdhdGlvbiB3aGVuIGNvbnRhaW5lciBub3Qgb3ZlcmZsb3dcbiAgd2F0Y2hPdmVyZmxvdzogdHJ1ZSxcbiAgLy8gUm91bmQgbGVuZ3RoXG4gIHJvdW5kTGVuZ3RoczogZmFsc2UsXG4gIC8vIFRvdWNoZXNcbiAgdG91Y2hSYXRpbzogMSxcbiAgdG91Y2hBbmdsZTogNDUsXG4gIHNpbXVsYXRlVG91Y2g6IHRydWUsXG4gIHNob3J0U3dpcGVzOiB0cnVlLFxuICBsb25nU3dpcGVzOiB0cnVlLFxuICBsb25nU3dpcGVzUmF0aW86IDAuNSxcbiAgbG9uZ1N3aXBlc01zOiAzMDAsXG4gIGZvbGxvd0ZpbmdlcjogdHJ1ZSxcbiAgYWxsb3dUb3VjaE1vdmU6IHRydWUsXG4gIHRocmVzaG9sZDogNSxcbiAgdG91Y2hNb3ZlU3RvcFByb3BhZ2F0aW9uOiBmYWxzZSxcbiAgdG91Y2hTdGFydFByZXZlbnREZWZhdWx0OiB0cnVlLFxuICB0b3VjaFN0YXJ0Rm9yY2VQcmV2ZW50RGVmYXVsdDogZmFsc2UsXG4gIHRvdWNoUmVsZWFzZU9uRWRnZXM6IGZhbHNlLFxuICAvLyBVbmlxdWUgTmF2aWdhdGlvbiBFbGVtZW50c1xuICB1bmlxdWVOYXZFbGVtZW50czogdHJ1ZSxcbiAgLy8gUmVzaXN0YW5jZVxuICByZXNpc3RhbmNlOiB0cnVlLFxuICByZXNpc3RhbmNlUmF0aW86IDAuODUsXG4gIC8vIFByb2dyZXNzXG4gIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IGZhbHNlLFxuICAvLyBDdXJzb3JcbiAgZ3JhYkN1cnNvcjogZmFsc2UsXG4gIC8vIENsaWNrc1xuICBwcmV2ZW50Q2xpY2tzOiB0cnVlLFxuICBwcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb246IHRydWUsXG4gIHNsaWRlVG9DbGlja2VkU2xpZGU6IGZhbHNlLFxuICAvLyBsb29wXG4gIGxvb3A6IGZhbHNlLFxuICBsb29wQWRkQmxhbmtTbGlkZXM6IHRydWUsXG4gIGxvb3BBZGRpdGlvbmFsU2xpZGVzOiAwLFxuICBsb29wUHJldmVudHNTbGlkaW5nOiB0cnVlLFxuICAvLyByZXdpbmRcbiAgcmV3aW5kOiBmYWxzZSxcbiAgLy8gU3dpcGluZy9ubyBzd2lwaW5nXG4gIGFsbG93U2xpZGVQcmV2OiB0cnVlLFxuICBhbGxvd1NsaWRlTmV4dDogdHJ1ZSxcbiAgc3dpcGVIYW5kbGVyOiBudWxsLFxuICAvLyAnLnN3aXBlLWhhbmRsZXInLFxuICBub1N3aXBpbmc6IHRydWUsXG4gIG5vU3dpcGluZ0NsYXNzOiAnc3dpcGVyLW5vLXN3aXBpbmcnLFxuICBub1N3aXBpbmdTZWxlY3RvcjogbnVsbCxcbiAgLy8gUGFzc2l2ZSBMaXN0ZW5lcnNcbiAgcGFzc2l2ZUxpc3RlbmVyczogdHJ1ZSxcbiAgbWF4QmFja2ZhY2VIaWRkZW5TbGlkZXM6IDEwLFxuICAvLyBOU1xuICBjb250YWluZXJNb2RpZmllckNsYXNzOiAnc3dpcGVyLScsXG4gIC8vIE5FV1xuICBzbGlkZUNsYXNzOiAnc3dpcGVyLXNsaWRlJyxcbiAgc2xpZGVCbGFua0NsYXNzOiAnc3dpcGVyLXNsaWRlLWJsYW5rJyxcbiAgc2xpZGVBY3RpdmVDbGFzczogJ3N3aXBlci1zbGlkZS1hY3RpdmUnLFxuICBzbGlkZVZpc2libGVDbGFzczogJ3N3aXBlci1zbGlkZS12aXNpYmxlJyxcbiAgc2xpZGVGdWxseVZpc2libGVDbGFzczogJ3N3aXBlci1zbGlkZS1mdWxseS12aXNpYmxlJyxcbiAgc2xpZGVOZXh0Q2xhc3M6ICdzd2lwZXItc2xpZGUtbmV4dCcsXG4gIHNsaWRlUHJldkNsYXNzOiAnc3dpcGVyLXNsaWRlLXByZXYnLFxuICB3cmFwcGVyQ2xhc3M6ICdzd2lwZXItd3JhcHBlcicsXG4gIGxhenlQcmVsb2FkZXJDbGFzczogJ3N3aXBlci1sYXp5LXByZWxvYWRlcicsXG4gIGxhenlQcmVsb2FkUHJldk5leHQ6IDAsXG4gIC8vIENhbGxiYWNrc1xuICBydW5DYWxsYmFja3NPbkluaXQ6IHRydWUsXG4gIC8vIEludGVybmFsc1xuICBfZW1pdENsYXNzZXM6IGZhbHNlXG59O1xuXG5mdW5jdGlvbiBtb2R1bGVFeHRlbmRQYXJhbXMocGFyYW1zLCBhbGxNb2R1bGVzUGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBleHRlbmRQYXJhbXMob2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gdm9pZCAwKSB7XG4gICAgICBvYmogPSB7fTtcbiAgICB9XG4gICAgY29uc3QgbW9kdWxlUGFyYW1OYW1lID0gT2JqZWN0LmtleXMob2JqKVswXTtcbiAgICBjb25zdCBtb2R1bGVQYXJhbXMgPSBvYmpbbW9kdWxlUGFyYW1OYW1lXTtcbiAgICBpZiAodHlwZW9mIG1vZHVsZVBhcmFtcyAhPT0gJ29iamVjdCcgfHwgbW9kdWxlUGFyYW1zID09PSBudWxsKSB7XG4gICAgICBleHRlbmQoYWxsTW9kdWxlc1BhcmFtcywgb2JqKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdID09PSB0cnVlKSB7XG4gICAgICBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSA9IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZVBhcmFtTmFtZSA9PT0gJ25hdmlnYXRpb24nICYmIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdICYmIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdLmVuYWJsZWQgJiYgIXBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdLnByZXZFbCAmJiAhcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0ubmV4dEVsKSB7XG4gICAgICBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXS5hdXRvID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKFsncGFnaW5hdGlvbicsICdzY3JvbGxiYXInXS5pbmRleE9mKG1vZHVsZVBhcmFtTmFtZSkgPj0gMCAmJiBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSAmJiBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXS5lbmFibGVkICYmICFwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXS5lbCkge1xuICAgICAgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0uYXV0byA9IHRydWU7XG4gICAgfVxuICAgIGlmICghKG1vZHVsZVBhcmFtTmFtZSBpbiBwYXJhbXMgJiYgJ2VuYWJsZWQnIGluIG1vZHVsZVBhcmFtcykpIHtcbiAgICAgIGV4dGVuZChhbGxNb2R1bGVzUGFyYW1zLCBvYmopO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdID09PSAnb2JqZWN0JyAmJiAhKCdlbmFibGVkJyBpbiBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSkpIHtcbiAgICAgIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdLmVuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdKSBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSA9IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgfTtcbiAgICBleHRlbmQoYWxsTW9kdWxlc1BhcmFtcywgb2JqKTtcbiAgfTtcbn1cblxuLyogZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOiBcIm9mZlwiICovXG5jb25zdCBwcm90b3R5cGVzID0ge1xuICBldmVudHNFbWl0dGVyLFxuICB1cGRhdGUsXG4gIHRyYW5zbGF0ZSxcbiAgdHJhbnNpdGlvbixcbiAgc2xpZGUsXG4gIGxvb3AsXG4gIGdyYWJDdXJzb3IsXG4gIGV2ZW50czogZXZlbnRzJDEsXG4gIGJyZWFrcG9pbnRzLFxuICBjaGVja092ZXJmbG93OiBjaGVja092ZXJmbG93JDEsXG4gIGNsYXNzZXNcbn07XG5jb25zdCBleHRlbmRlZERlZmF1bHRzID0ge307XG5jbGFzcyBTd2lwZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgZWw7XG4gICAgbGV0IHBhcmFtcztcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBhcmdzWzBdLmNvbnN0cnVjdG9yICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmdzWzBdKS5zbGljZSg4LCAtMSkgPT09ICdPYmplY3QnKSB7XG4gICAgICBwYXJhbXMgPSBhcmdzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBbZWwsIHBhcmFtc10gPSBhcmdzO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcykgcGFyYW1zID0ge307XG4gICAgcGFyYW1zID0gZXh0ZW5kKHt9LCBwYXJhbXMpO1xuICAgIGlmIChlbCAmJiAhcGFyYW1zLmVsKSBwYXJhbXMuZWwgPSBlbDtcbiAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gICAgaWYgKHBhcmFtcy5lbCAmJiB0eXBlb2YgcGFyYW1zLmVsID09PSAnc3RyaW5nJyAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHBhcmFtcy5lbCkubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3Qgc3dpcGVycyA9IFtdO1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChwYXJhbXMuZWwpLmZvckVhY2goY29udGFpbmVyRWwgPT4ge1xuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBleHRlbmQoe30sIHBhcmFtcywge1xuICAgICAgICAgIGVsOiBjb250YWluZXJFbFxuICAgICAgICB9KTtcbiAgICAgICAgc3dpcGVycy5wdXNoKG5ldyBTd2lwZXIobmV3UGFyYW1zKSk7XG4gICAgICB9KTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdHJ1Y3Rvci1yZXR1cm5cbiAgICAgIHJldHVybiBzd2lwZXJzO1xuICAgIH1cblxuICAgIC8vIFN3aXBlciBJbnN0YW5jZVxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgc3dpcGVyLl9fc3dpcGVyX18gPSB0cnVlO1xuICAgIHN3aXBlci5zdXBwb3J0ID0gZ2V0U3VwcG9ydCgpO1xuICAgIHN3aXBlci5kZXZpY2UgPSBnZXREZXZpY2Uoe1xuICAgICAgdXNlckFnZW50OiBwYXJhbXMudXNlckFnZW50XG4gICAgfSk7XG4gICAgc3dpcGVyLmJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgc3dpcGVyLmV2ZW50c0xpc3RlbmVycyA9IHt9O1xuICAgIHN3aXBlci5ldmVudHNBbnlMaXN0ZW5lcnMgPSBbXTtcbiAgICBzd2lwZXIubW9kdWxlcyA9IFsuLi5zd2lwZXIuX19tb2R1bGVzX19dO1xuICAgIGlmIChwYXJhbXMubW9kdWxlcyAmJiBBcnJheS5pc0FycmF5KHBhcmFtcy5tb2R1bGVzKSkge1xuICAgICAgc3dpcGVyLm1vZHVsZXMucHVzaCguLi5wYXJhbXMubW9kdWxlcyk7XG4gICAgfVxuICAgIGNvbnN0IGFsbE1vZHVsZXNQYXJhbXMgPSB7fTtcbiAgICBzd2lwZXIubW9kdWxlcy5mb3JFYWNoKG1vZCA9PiB7XG4gICAgICBtb2Qoe1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHN3aXBlcixcbiAgICAgICAgZXh0ZW5kUGFyYW1zOiBtb2R1bGVFeHRlbmRQYXJhbXMocGFyYW1zLCBhbGxNb2R1bGVzUGFyYW1zKSxcbiAgICAgICAgb246IHN3aXBlci5vbi5iaW5kKHN3aXBlciksXG4gICAgICAgIG9uY2U6IHN3aXBlci5vbmNlLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgb2ZmOiBzd2lwZXIub2ZmLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgZW1pdDogc3dpcGVyLmVtaXQuYmluZChzd2lwZXIpXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEV4dGVuZCBkZWZhdWx0cyB3aXRoIG1vZHVsZXMgcGFyYW1zXG4gICAgY29uc3Qgc3dpcGVyUGFyYW1zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgYWxsTW9kdWxlc1BhcmFtcyk7XG5cbiAgICAvLyBFeHRlbmQgZGVmYXVsdHMgd2l0aCBwYXNzZWQgcGFyYW1zXG4gICAgc3dpcGVyLnBhcmFtcyA9IGV4dGVuZCh7fSwgc3dpcGVyUGFyYW1zLCBleHRlbmRlZERlZmF1bHRzLCBwYXJhbXMpO1xuICAgIHN3aXBlci5vcmlnaW5hbFBhcmFtcyA9IGV4dGVuZCh7fSwgc3dpcGVyLnBhcmFtcyk7XG4gICAgc3dpcGVyLnBhc3NlZFBhcmFtcyA9IGV4dGVuZCh7fSwgcGFyYW1zKTtcblxuICAgIC8vIGFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICBpZiAoc3dpcGVyLnBhcmFtcyAmJiBzd2lwZXIucGFyYW1zLm9uKSB7XG4gICAgICBPYmplY3Qua2V5cyhzd2lwZXIucGFyYW1zLm9uKS5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICAgIHN3aXBlci5vbihldmVudE5hbWUsIHN3aXBlci5wYXJhbXMub25bZXZlbnROYW1lXSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN3aXBlci5wYXJhbXMgJiYgc3dpcGVyLnBhcmFtcy5vbkFueSkge1xuICAgICAgc3dpcGVyLm9uQW55KHN3aXBlci5wYXJhbXMub25BbnkpO1xuICAgIH1cblxuICAgIC8vIEV4dGVuZCBTd2lwZXJcbiAgICBPYmplY3QuYXNzaWduKHN3aXBlciwge1xuICAgICAgZW5hYmxlZDogc3dpcGVyLnBhcmFtcy5lbmFibGVkLFxuICAgICAgZWwsXG4gICAgICAvLyBDbGFzc2VzXG4gICAgICBjbGFzc05hbWVzOiBbXSxcbiAgICAgIC8vIFNsaWRlc1xuICAgICAgc2xpZGVzOiBbXSxcbiAgICAgIHNsaWRlc0dyaWQ6IFtdLFxuICAgICAgc25hcEdyaWQ6IFtdLFxuICAgICAgc2xpZGVzU2l6ZXNHcmlkOiBbXSxcbiAgICAgIC8vIGlzRGlyZWN0aW9uXG4gICAgICBpc0hvcml6b250YWwoKSB7XG4gICAgICAgIHJldHVybiBzd2lwZXIucGFyYW1zLmRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnO1xuICAgICAgfSxcbiAgICAgIGlzVmVydGljYWwoKSB7XG4gICAgICAgIHJldHVybiBzd2lwZXIucGFyYW1zLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJztcbiAgICAgIH0sXG4gICAgICAvLyBJbmRleGVzXG4gICAgICBhY3RpdmVJbmRleDogMCxcbiAgICAgIHJlYWxJbmRleDogMCxcbiAgICAgIC8vXG4gICAgICBpc0JlZ2lubmluZzogdHJ1ZSxcbiAgICAgIGlzRW5kOiBmYWxzZSxcbiAgICAgIC8vIFByb3BzXG4gICAgICB0cmFuc2xhdGU6IDAsXG4gICAgICBwcmV2aW91c1RyYW5zbGF0ZTogMCxcbiAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgdmVsb2NpdHk6IDAsXG4gICAgICBhbmltYXRpbmc6IGZhbHNlLFxuICAgICAgY3NzT3ZlcmZsb3dBZGp1c3RtZW50KCkge1xuICAgICAgICAvLyBSZXR1cm5zIDAgdW5sZXNzIGB0cmFuc2xhdGVgIGlzID4gMioqMjNcbiAgICAgICAgLy8gU2hvdWxkIGJlIHN1YnRyYWN0ZWQgZnJvbSBjc3MgdmFsdWVzIHRvIHByZXZlbnQgb3ZlcmZsb3dcbiAgICAgICAgcmV0dXJuIE1hdGgudHJ1bmModGhpcy50cmFuc2xhdGUgLyAyICoqIDIzKSAqIDIgKiogMjM7XG4gICAgICB9LFxuICAgICAgLy8gTG9ja3NcbiAgICAgIGFsbG93U2xpZGVOZXh0OiBzd2lwZXIucGFyYW1zLmFsbG93U2xpZGVOZXh0LFxuICAgICAgYWxsb3dTbGlkZVByZXY6IHN3aXBlci5wYXJhbXMuYWxsb3dTbGlkZVByZXYsXG4gICAgICAvLyBUb3VjaCBFdmVudHNcbiAgICAgIHRvdWNoRXZlbnRzRGF0YToge1xuICAgICAgICBpc1RvdWNoZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgaXNNb3ZlZDogdW5kZWZpbmVkLFxuICAgICAgICBhbGxvd1RvdWNoQ2FsbGJhY2tzOiB1bmRlZmluZWQsXG4gICAgICAgIHRvdWNoU3RhcnRUaW1lOiB1bmRlZmluZWQsXG4gICAgICAgIGlzU2Nyb2xsaW5nOiB1bmRlZmluZWQsXG4gICAgICAgIGN1cnJlbnRUcmFuc2xhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhcnRUcmFuc2xhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgYWxsb3dUaHJlc2hvbGRNb3ZlOiB1bmRlZmluZWQsXG4gICAgICAgIC8vIEZvcm0gZWxlbWVudHMgdG8gbWF0Y2hcbiAgICAgICAgZm9jdXNhYmxlRWxlbWVudHM6IHN3aXBlci5wYXJhbXMuZm9jdXNhYmxlRWxlbWVudHMsXG4gICAgICAgIC8vIExhc3QgY2xpY2sgdGltZVxuICAgICAgICBsYXN0Q2xpY2tUaW1lOiAwLFxuICAgICAgICBjbGlja1RpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgLy8gVmVsb2NpdGllc1xuICAgICAgICB2ZWxvY2l0aWVzOiBbXSxcbiAgICAgICAgYWxsb3dNb21lbnR1bUJvdW5jZTogdW5kZWZpbmVkLFxuICAgICAgICBzdGFydE1vdmluZzogdW5kZWZpbmVkLFxuICAgICAgICBwb2ludGVySWQ6IG51bGwsXG4gICAgICAgIHRvdWNoSWQ6IG51bGxcbiAgICAgIH0sXG4gICAgICAvLyBDbGlja3NcbiAgICAgIGFsbG93Q2xpY2s6IHRydWUsXG4gICAgICAvLyBUb3VjaGVzXG4gICAgICBhbGxvd1RvdWNoTW92ZTogc3dpcGVyLnBhcmFtcy5hbGxvd1RvdWNoTW92ZSxcbiAgICAgIHRvdWNoZXM6IHtcbiAgICAgICAgc3RhcnRYOiAwLFxuICAgICAgICBzdGFydFk6IDAsXG4gICAgICAgIGN1cnJlbnRYOiAwLFxuICAgICAgICBjdXJyZW50WTogMCxcbiAgICAgICAgZGlmZjogMFxuICAgICAgfSxcbiAgICAgIC8vIEltYWdlc1xuICAgICAgaW1hZ2VzVG9Mb2FkOiBbXSxcbiAgICAgIGltYWdlc0xvYWRlZDogMFxuICAgIH0pO1xuICAgIHN3aXBlci5lbWl0KCdfc3dpcGVyJyk7XG5cbiAgICAvLyBJbml0XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuaW5pdCkge1xuICAgICAgc3dpcGVyLmluaXQoKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYXBwIGluc3RhbmNlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxuICAgIHJldHVybiBzd2lwZXI7XG4gIH1cbiAgZ2V0RGlyZWN0aW9uTGFiZWwocHJvcGVydHkpIHtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgcmV0dXJuIHByb3BlcnR5O1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICByZXR1cm4ge1xuICAgICAgJ3dpZHRoJzogJ2hlaWdodCcsXG4gICAgICAnbWFyZ2luLXRvcCc6ICdtYXJnaW4tbGVmdCcsXG4gICAgICAnbWFyZ2luLWJvdHRvbSAnOiAnbWFyZ2luLXJpZ2h0JyxcbiAgICAgICdtYXJnaW4tbGVmdCc6ICdtYXJnaW4tdG9wJyxcbiAgICAgICdtYXJnaW4tcmlnaHQnOiAnbWFyZ2luLWJvdHRvbScsXG4gICAgICAncGFkZGluZy1sZWZ0JzogJ3BhZGRpbmctdG9wJyxcbiAgICAgICdwYWRkaW5nLXJpZ2h0JzogJ3BhZGRpbmctYm90dG9tJyxcbiAgICAgICdtYXJnaW5SaWdodCc6ICdtYXJnaW5Cb3R0b20nXG4gICAgfVtwcm9wZXJ0eV07XG4gIH1cbiAgZ2V0U2xpZGVJbmRleChzbGlkZUVsKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2xpZGVzRWwsXG4gICAgICBwYXJhbXNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzbGlkZXMgPSBlbGVtZW50Q2hpbGRyZW4oc2xpZGVzRWwsIGAuJHtwYXJhbXMuc2xpZGVDbGFzc30sIHN3aXBlci1zbGlkZWApO1xuICAgIGNvbnN0IGZpcnN0U2xpZGVJbmRleCA9IGVsZW1lbnRJbmRleChzbGlkZXNbMF0pO1xuICAgIHJldHVybiBlbGVtZW50SW5kZXgoc2xpZGVFbCkgLSBmaXJzdFNsaWRlSW5kZXg7XG4gIH1cbiAgZ2V0U2xpZGVJbmRleEJ5RGF0YShpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldFNsaWRlSW5kZXgodGhpcy5zbGlkZXMuZmlsdGVyKHNsaWRlRWwgPT4gc2xpZGVFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JykgKiAxID09PSBpbmRleClbMF0pO1xuICB9XG4gIHJlY2FsY1NsaWRlcygpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHNsaWRlc0VsLFxuICAgICAgcGFyYW1zXG4gICAgfSA9IHN3aXBlcjtcbiAgICBzd2lwZXIuc2xpZGVzID0gZWxlbWVudENoaWxkcmVuKHNsaWRlc0VsLCBgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LCBzd2lwZXItc2xpZGVgKTtcbiAgfVxuICBlbmFibGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoc3dpcGVyLmVuYWJsZWQpIHJldHVybjtcbiAgICBzd2lwZXIuZW5hYmxlZCA9IHRydWU7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuZ3JhYkN1cnNvcikge1xuICAgICAgc3dpcGVyLnNldEdyYWJDdXJzb3IoKTtcbiAgICB9XG4gICAgc3dpcGVyLmVtaXQoJ2VuYWJsZScpO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoIXN3aXBlci5lbmFibGVkKSByZXR1cm47XG4gICAgc3dpcGVyLmVuYWJsZWQgPSBmYWxzZTtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5ncmFiQ3Vyc29yKSB7XG4gICAgICBzd2lwZXIudW5zZXRHcmFiQ3Vyc29yKCk7XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KCdkaXNhYmxlJyk7XG4gIH1cbiAgc2V0UHJvZ3Jlc3MocHJvZ3Jlc3MsIHNwZWVkKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBwcm9ncmVzcyA9IE1hdGgubWluKE1hdGgubWF4KHByb2dyZXNzLCAwKSwgMSk7XG4gICAgY29uc3QgbWluID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgIGNvbnN0IG1heCA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKTtcbiAgICBjb25zdCBjdXJyZW50ID0gKG1heCAtIG1pbikgKiBwcm9ncmVzcyArIG1pbjtcbiAgICBzd2lwZXIudHJhbnNsYXRlVG8oY3VycmVudCwgdHlwZW9mIHNwZWVkID09PSAndW5kZWZpbmVkJyA/IDAgOiBzcGVlZCk7XG4gICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgfVxuICBlbWl0Q29udGFpbmVyQ2xhc3NlcygpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmICghc3dpcGVyLnBhcmFtcy5fZW1pdENsYXNzZXMgfHwgIXN3aXBlci5lbCkgcmV0dXJuO1xuICAgIGNvbnN0IGNscyA9IHN3aXBlci5lbC5jbGFzc05hbWUuc3BsaXQoJyAnKS5maWx0ZXIoY2xhc3NOYW1lID0+IHtcbiAgICAgIHJldHVybiBjbGFzc05hbWUuaW5kZXhPZignc3dpcGVyJykgPT09IDAgfHwgY2xhc3NOYW1lLmluZGV4T2Yoc3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzKSA9PT0gMDtcbiAgICB9KTtcbiAgICBzd2lwZXIuZW1pdCgnX2NvbnRhaW5lckNsYXNzZXMnLCBjbHMuam9pbignICcpKTtcbiAgfVxuICBnZXRTbGlkZUNsYXNzZXMoc2xpZGVFbCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKHN3aXBlci5kZXN0cm95ZWQpIHJldHVybiAnJztcbiAgICByZXR1cm4gc2xpZGVFbC5jbGFzc05hbWUuc3BsaXQoJyAnKS5maWx0ZXIoY2xhc3NOYW1lID0+IHtcbiAgICAgIHJldHVybiBjbGFzc05hbWUuaW5kZXhPZignc3dpcGVyLXNsaWRlJykgPT09IDAgfHwgY2xhc3NOYW1lLmluZGV4T2Yoc3dpcGVyLnBhcmFtcy5zbGlkZUNsYXNzKSA9PT0gMDtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cbiAgZW1pdFNsaWRlc0NsYXNzZXMoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuX2VtaXRDbGFzc2VzIHx8ICFzd2lwZXIuZWwpIHJldHVybjtcbiAgICBjb25zdCB1cGRhdGVzID0gW107XG4gICAgc3dpcGVyLnNsaWRlcy5mb3JFYWNoKHNsaWRlRWwgPT4ge1xuICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IHN3aXBlci5nZXRTbGlkZUNsYXNzZXMoc2xpZGVFbCk7XG4gICAgICB1cGRhdGVzLnB1c2goe1xuICAgICAgICBzbGlkZUVsLFxuICAgICAgICBjbGFzc05hbWVzXG4gICAgICB9KTtcbiAgICAgIHN3aXBlci5lbWl0KCdfc2xpZGVDbGFzcycsIHNsaWRlRWwsIGNsYXNzTmFtZXMpO1xuICAgIH0pO1xuICAgIHN3aXBlci5lbWl0KCdfc2xpZGVDbGFzc2VzJywgdXBkYXRlcyk7XG4gIH1cbiAgc2xpZGVzUGVyVmlld0R5bmFtaWModmlldywgZXhhY3QpIHtcbiAgICBpZiAodmlldyA9PT0gdm9pZCAwKSB7XG4gICAgICB2aWV3ID0gJ2N1cnJlbnQnO1xuICAgIH1cbiAgICBpZiAoZXhhY3QgPT09IHZvaWQgMCkge1xuICAgICAgZXhhY3QgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBwYXJhbXMsXG4gICAgICBzbGlkZXMsXG4gICAgICBzbGlkZXNHcmlkLFxuICAgICAgc2xpZGVzU2l6ZXNHcmlkLFxuICAgICAgc2l6ZTogc3dpcGVyU2l6ZSxcbiAgICAgIGFjdGl2ZUluZGV4XG4gICAgfSA9IHN3aXBlcjtcbiAgICBsZXQgc3B2ID0gMTtcbiAgICBpZiAodHlwZW9mIHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnbnVtYmVyJykgcmV0dXJuIHBhcmFtcy5zbGlkZXNQZXJWaWV3O1xuICAgIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgIGxldCBzbGlkZVNpemUgPSBzbGlkZXNbYWN0aXZlSW5kZXhdID8gTWF0aC5jZWlsKHNsaWRlc1thY3RpdmVJbmRleF0uc3dpcGVyU2xpZGVTaXplKSA6IDA7XG4gICAgICBsZXQgYnJlYWtMb29wO1xuICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4ICsgMTsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoc2xpZGVzW2ldICYmICFicmVha0xvb3ApIHtcbiAgICAgICAgICBzbGlkZVNpemUgKz0gTWF0aC5jZWlsKHNsaWRlc1tpXS5zd2lwZXJTbGlkZVNpemUpO1xuICAgICAgICAgIHNwdiArPSAxO1xuICAgICAgICAgIGlmIChzbGlkZVNpemUgPiBzd2lwZXJTaXplKSBicmVha0xvb3AgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gYWN0aXZlSW5kZXggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBpZiAoc2xpZGVzW2ldICYmICFicmVha0xvb3ApIHtcbiAgICAgICAgICBzbGlkZVNpemUgKz0gc2xpZGVzW2ldLnN3aXBlclNsaWRlU2l6ZTtcbiAgICAgICAgICBzcHYgKz0gMTtcbiAgICAgICAgICBpZiAoc2xpZGVTaXplID4gc3dpcGVyU2l6ZSkgYnJlYWtMb29wID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGlmICh2aWV3ID09PSAnY3VycmVudCcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4ICsgMTsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGNvbnN0IHNsaWRlSW5WaWV3ID0gZXhhY3QgPyBzbGlkZXNHcmlkW2ldICsgc2xpZGVzU2l6ZXNHcmlkW2ldIC0gc2xpZGVzR3JpZFthY3RpdmVJbmRleF0gPCBzd2lwZXJTaXplIDogc2xpZGVzR3JpZFtpXSAtIHNsaWRlc0dyaWRbYWN0aXZlSW5kZXhdIDwgc3dpcGVyU2l6ZTtcbiAgICAgICAgICBpZiAoc2xpZGVJblZpZXcpIHtcbiAgICAgICAgICAgIHNwdiArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcHJldmlvdXNcbiAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4IC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICBjb25zdCBzbGlkZUluVmlldyA9IHNsaWRlc0dyaWRbYWN0aXZlSW5kZXhdIC0gc2xpZGVzR3JpZFtpXSA8IHN3aXBlclNpemU7XG4gICAgICAgICAgaWYgKHNsaWRlSW5WaWV3KSB7XG4gICAgICAgICAgICBzcHYgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNwdjtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgc25hcEdyaWQsXG4gICAgICBwYXJhbXNcbiAgICB9ID0gc3dpcGVyO1xuICAgIC8vIEJyZWFrcG9pbnRzXG4gICAgaWYgKHBhcmFtcy5icmVha3BvaW50cykge1xuICAgICAgc3dpcGVyLnNldEJyZWFrcG9pbnQoKTtcbiAgICB9XG4gICAgWy4uLnN3aXBlci5lbC5xdWVyeVNlbGVjdG9yQWxsKCdbbG9hZGluZz1cImxhenlcIl0nKV0uZm9yRWFjaChpbWFnZUVsID0+IHtcbiAgICAgIGlmIChpbWFnZUVsLmNvbXBsZXRlKSB7XG4gICAgICAgIHByb2Nlc3NMYXp5UHJlbG9hZGVyKHN3aXBlciwgaW1hZ2VFbCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc3dpcGVyLnVwZGF0ZVNpemUoKTtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzKCk7XG4gICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKCk7XG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICBmdW5jdGlvbiBzZXRUcmFuc2xhdGUoKSB7XG4gICAgICBjb25zdCB0cmFuc2xhdGVWYWx1ZSA9IHN3aXBlci5ydGxUcmFuc2xhdGUgPyBzd2lwZXIudHJhbnNsYXRlICogLTEgOiBzd2lwZXIudHJhbnNsYXRlO1xuICAgICAgY29uc3QgbmV3VHJhbnNsYXRlID0gTWF0aC5taW4oTWF0aC5tYXgodHJhbnNsYXRlVmFsdWUsIHN3aXBlci5tYXhUcmFuc2xhdGUoKSksIHN3aXBlci5taW5UcmFuc2xhdGUoKSk7XG4gICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKG5ld1RyYW5zbGF0ZSk7XG4gICAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgfVxuICAgIGxldCB0cmFuc2xhdGVkO1xuICAgIGlmIChwYXJhbXMuZnJlZU1vZGUgJiYgcGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQgJiYgIXBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICBzZXRUcmFuc2xhdGUoKTtcbiAgICAgIGlmIChwYXJhbXMuYXV0b0hlaWdodCkge1xuICAgICAgICBzd2lwZXIudXBkYXRlQXV0b0hlaWdodCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoKHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycgfHwgcGFyYW1zLnNsaWRlc1BlclZpZXcgPiAxKSAmJiBzd2lwZXIuaXNFbmQgJiYgIXBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgICBjb25zdCBzbGlkZXMgPSBzd2lwZXIudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzIDogc3dpcGVyLnNsaWRlcztcbiAgICAgICAgdHJhbnNsYXRlZCA9IHN3aXBlci5zbGlkZVRvKHNsaWRlcy5sZW5ndGggLSAxLCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2xhdGVkID0gc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4LCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRyYW5zbGF0ZWQpIHtcbiAgICAgICAgc2V0VHJhbnNsYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzbmFwR3JpZCAhPT0gc3dpcGVyLnNuYXBHcmlkKSB7XG4gICAgICBzd2lwZXIuY2hlY2tPdmVyZmxvdygpO1xuICAgIH1cbiAgICBzd2lwZXIuZW1pdCgndXBkYXRlJyk7XG4gIH1cbiAgY2hhbmdlRGlyZWN0aW9uKG5ld0RpcmVjdGlvbiwgbmVlZFVwZGF0ZSkge1xuICAgIGlmIChuZWVkVXBkYXRlID09PSB2b2lkIDApIHtcbiAgICAgIG5lZWRVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IGN1cnJlbnREaXJlY3Rpb24gPSBzd2lwZXIucGFyYW1zLmRpcmVjdGlvbjtcbiAgICBpZiAoIW5ld0RpcmVjdGlvbikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBuZXdEaXJlY3Rpb24gPSBjdXJyZW50RGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICAgIH1cbiAgICBpZiAobmV3RGlyZWN0aW9uID09PSBjdXJyZW50RGlyZWN0aW9uIHx8IG5ld0RpcmVjdGlvbiAhPT0gJ2hvcml6b250YWwnICYmIG5ld0RpcmVjdGlvbiAhPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgcmV0dXJuIHN3aXBlcjtcbiAgICB9XG4gICAgc3dpcGVyLmVsLmNsYXNzTGlzdC5yZW1vdmUoYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfSR7Y3VycmVudERpcmVjdGlvbn1gKTtcbiAgICBzd2lwZXIuZWwuY2xhc3NMaXN0LmFkZChgJHtzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9JHtuZXdEaXJlY3Rpb259YCk7XG4gICAgc3dpcGVyLmVtaXRDb250YWluZXJDbGFzc2VzKCk7XG4gICAgc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPSBuZXdEaXJlY3Rpb247XG4gICAgc3dpcGVyLnNsaWRlcy5mb3JFYWNoKHNsaWRlRWwgPT4ge1xuICAgICAgaWYgKG5ld0RpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBzbGlkZUVsLnN0eWxlLndpZHRoID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbGlkZUVsLnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHN3aXBlci5lbWl0KCdjaGFuZ2VEaXJlY3Rpb24nKTtcbiAgICBpZiAobmVlZFVwZGF0ZSkgc3dpcGVyLnVwZGF0ZSgpO1xuICAgIHJldHVybiBzd2lwZXI7XG4gIH1cbiAgY2hhbmdlTGFuZ3VhZ2VEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoc3dpcGVyLnJ0bCAmJiBkaXJlY3Rpb24gPT09ICdydGwnIHx8ICFzd2lwZXIucnRsICYmIGRpcmVjdGlvbiA9PT0gJ2x0cicpIHJldHVybjtcbiAgICBzd2lwZXIucnRsID0gZGlyZWN0aW9uID09PSAncnRsJztcbiAgICBzd2lwZXIucnRsVHJhbnNsYXRlID0gc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyAmJiBzd2lwZXIucnRsO1xuICAgIGlmIChzd2lwZXIucnRsKSB7XG4gICAgICBzd2lwZXIuZWwuY2xhc3NMaXN0LmFkZChgJHtzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9cnRsYCk7XG4gICAgICBzd2lwZXIuZWwuZGlyID0gJ3J0bCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5lbC5jbGFzc0xpc3QucmVtb3ZlKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ydGxgKTtcbiAgICAgIHN3aXBlci5lbC5kaXIgPSAnbHRyJztcbiAgICB9XG4gICAgc3dpcGVyLnVwZGF0ZSgpO1xuICB9XG4gIG1vdW50KGVsZW1lbnQpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmIChzd2lwZXIubW91bnRlZCkgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBGaW5kIGVsXG4gICAgbGV0IGVsID0gZWxlbWVudCB8fCBzd2lwZXIucGFyYW1zLmVsO1xuICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIH1cbiAgICBpZiAoIWVsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsLnN3aXBlciA9IHN3aXBlcjtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLmhvc3QgJiYgZWwucGFyZW50Tm9kZS5ob3N0Lm5vZGVOYW1lID09PSBzd2lwZXIucGFyYW1zLnN3aXBlckVsZW1lbnROb2RlTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBzd2lwZXIuaXNFbGVtZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZ2V0V3JhcHBlclNlbGVjdG9yID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGAuJHsoc3dpcGVyLnBhcmFtcy53cmFwcGVyQ2xhc3MgfHwgJycpLnRyaW0oKS5zcGxpdCgnICcpLmpvaW4oJy4nKX1gO1xuICAgIH07XG4gICAgY29uc3QgZ2V0V3JhcHBlciA9ICgpID0+IHtcbiAgICAgIGlmIChlbCAmJiBlbC5zaGFkb3dSb290ICYmIGVsLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3Rvcikge1xuICAgICAgICBjb25zdCByZXMgPSBlbC5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoZ2V0V3JhcHBlclNlbGVjdG9yKCkpO1xuICAgICAgICAvLyBDaGlsZHJlbiBuZWVkcyB0byByZXR1cm4gc2xvdCBpdGVtc1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnRDaGlsZHJlbihlbCwgZ2V0V3JhcHBlclNlbGVjdG9yKCkpWzBdO1xuICAgIH07XG4gICAgLy8gRmluZCBXcmFwcGVyXG4gICAgbGV0IHdyYXBwZXJFbCA9IGdldFdyYXBwZXIoKTtcbiAgICBpZiAoIXdyYXBwZXJFbCAmJiBzd2lwZXIucGFyYW1zLmNyZWF0ZUVsZW1lbnRzKSB7XG4gICAgICB3cmFwcGVyRWwgPSBjcmVhdGVFbGVtZW50KCdkaXYnLCBzd2lwZXIucGFyYW1zLndyYXBwZXJDbGFzcyk7XG4gICAgICBlbC5hcHBlbmQod3JhcHBlckVsKTtcbiAgICAgIGVsZW1lbnRDaGlsZHJlbihlbCwgYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVDbGFzc31gKS5mb3JFYWNoKHNsaWRlRWwgPT4ge1xuICAgICAgICB3cmFwcGVyRWwuYXBwZW5kKHNsaWRlRWwpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLCB7XG4gICAgICBlbCxcbiAgICAgIHdyYXBwZXJFbCxcbiAgICAgIHNsaWRlc0VsOiBzd2lwZXIuaXNFbGVtZW50ICYmICFlbC5wYXJlbnROb2RlLmhvc3Quc2xpZGVTbG90cyA/IGVsLnBhcmVudE5vZGUuaG9zdCA6IHdyYXBwZXJFbCxcbiAgICAgIGhvc3RFbDogc3dpcGVyLmlzRWxlbWVudCA/IGVsLnBhcmVudE5vZGUuaG9zdCA6IGVsLFxuICAgICAgbW91bnRlZDogdHJ1ZSxcbiAgICAgIC8vIFJUTFxuICAgICAgcnRsOiBlbC5kaXIudG9Mb3dlckNhc2UoKSA9PT0gJ3J0bCcgfHwgZWxlbWVudFN0eWxlKGVsLCAnZGlyZWN0aW9uJykgPT09ICdydGwnLFxuICAgICAgcnRsVHJhbnNsYXRlOiBzd2lwZXIucGFyYW1zLmRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnICYmIChlbC5kaXIudG9Mb3dlckNhc2UoKSA9PT0gJ3J0bCcgfHwgZWxlbWVudFN0eWxlKGVsLCAnZGlyZWN0aW9uJykgPT09ICdydGwnKSxcbiAgICAgIHdyb25nUlRMOiBlbGVtZW50U3R5bGUod3JhcHBlckVsLCAnZGlzcGxheScpID09PSAnLXdlYmtpdC1ib3gnXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaW5pdChlbCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKHN3aXBlci5pbml0aWFsaXplZCkgcmV0dXJuIHN3aXBlcjtcbiAgICBjb25zdCBtb3VudGVkID0gc3dpcGVyLm1vdW50KGVsKTtcbiAgICBpZiAobW91bnRlZCA9PT0gZmFsc2UpIHJldHVybiBzd2lwZXI7XG4gICAgc3dpcGVyLmVtaXQoJ2JlZm9yZUluaXQnKTtcblxuICAgIC8vIFNldCBicmVha3BvaW50XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuYnJlYWtwb2ludHMpIHtcbiAgICAgIHN3aXBlci5zZXRCcmVha3BvaW50KCk7XG4gICAgfVxuXG4gICAgLy8gQWRkIENsYXNzZXNcbiAgICBzd2lwZXIuYWRkQ2xhc3NlcygpO1xuXG4gICAgLy8gVXBkYXRlIHNpemVcbiAgICBzd2lwZXIudXBkYXRlU2l6ZSgpO1xuXG4gICAgLy8gVXBkYXRlIHNsaWRlc1xuICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93KSB7XG4gICAgICBzd2lwZXIuY2hlY2tPdmVyZmxvdygpO1xuICAgIH1cblxuICAgIC8vIFNldCBHcmFiIEN1cnNvclxuICAgIGlmIChzd2lwZXIucGFyYW1zLmdyYWJDdXJzb3IgJiYgc3dpcGVyLmVuYWJsZWQpIHtcbiAgICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKCk7XG4gICAgfVxuXG4gICAgLy8gU2xpZGUgVG8gSW5pdGlhbCBTbGlkZVxuICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3AgJiYgc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5wYXJhbXMuaW5pdGlhbFNsaWRlICsgc3dpcGVyLnZpcnR1YWwuc2xpZGVzQmVmb3JlLCAwLCBzd2lwZXIucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCwgZmFsc2UsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIucGFyYW1zLmluaXRpYWxTbGlkZSwgMCwgc3dpcGVyLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbG9vcFxuICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgIHN3aXBlci5sb29wQ3JlYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gQXR0YWNoIGV2ZW50c1xuICAgIHN3aXBlci5hdHRhY2hFdmVudHMoKTtcbiAgICBjb25zdCBsYXp5RWxlbWVudHMgPSBbLi4uc3dpcGVyLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tsb2FkaW5nPVwibGF6eVwiXScpXTtcbiAgICBpZiAoc3dpcGVyLmlzRWxlbWVudCkge1xuICAgICAgbGF6eUVsZW1lbnRzLnB1c2goLi4uc3dpcGVyLmhvc3RFbC5xdWVyeVNlbGVjdG9yQWxsKCdbbG9hZGluZz1cImxhenlcIl0nKSk7XG4gICAgfVxuICAgIGxhenlFbGVtZW50cy5mb3JFYWNoKGltYWdlRWwgPT4ge1xuICAgICAgaWYgKGltYWdlRWwuY29tcGxldGUpIHtcbiAgICAgICAgcHJvY2Vzc0xhenlQcmVsb2FkZXIoc3dpcGVyLCBpbWFnZUVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlRWwuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGUgPT4ge1xuICAgICAgICAgIHByb2Nlc3NMYXp5UHJlbG9hZGVyKHN3aXBlciwgZS50YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwcmVsb2FkKHN3aXBlcik7XG5cbiAgICAvLyBJbml0IEZsYWdcbiAgICBzd2lwZXIuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHByZWxvYWQoc3dpcGVyKTtcblxuICAgIC8vIEVtaXRcbiAgICBzd2lwZXIuZW1pdCgnaW5pdCcpO1xuICAgIHN3aXBlci5lbWl0KCdhZnRlckluaXQnKTtcbiAgICByZXR1cm4gc3dpcGVyO1xuICB9XG4gIGRlc3Ryb3koZGVsZXRlSW5zdGFuY2UsIGNsZWFuU3R5bGVzKSB7XG4gICAgaWYgKGRlbGV0ZUluc3RhbmNlID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGV0ZUluc3RhbmNlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNsZWFuU3R5bGVzID09PSB2b2lkIDApIHtcbiAgICAgIGNsZWFuU3R5bGVzID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBwYXJhbXMsXG4gICAgICBlbCxcbiAgICAgIHdyYXBwZXJFbCxcbiAgICAgIHNsaWRlc1xuICAgIH0gPSBzd2lwZXI7XG4gICAgaWYgKHR5cGVvZiBzd2lwZXIucGFyYW1zID09PSAndW5kZWZpbmVkJyB8fCBzd2lwZXIuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3dpcGVyLmVtaXQoJ2JlZm9yZURlc3Ryb3knKTtcblxuICAgIC8vIEluaXQgRmxhZ1xuICAgIHN3aXBlci5pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgLy8gRGV0YWNoIGV2ZW50c1xuICAgIHN3aXBlci5kZXRhY2hFdmVudHMoKTtcblxuICAgIC8vIERlc3Ryb3kgbG9vcFxuICAgIGlmIChwYXJhbXMubG9vcCkge1xuICAgICAgc3dpcGVyLmxvb3BEZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYW51cCBzdHlsZXNcbiAgICBpZiAoY2xlYW5TdHlsZXMpIHtcbiAgICAgIHN3aXBlci5yZW1vdmVDbGFzc2VzKCk7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICB3cmFwcGVyRWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgaWYgKHNsaWRlcyAmJiBzbGlkZXMubGVuZ3RoKSB7XG4gICAgICAgIHNsaWRlcy5mb3JFYWNoKHNsaWRlRWwgPT4ge1xuICAgICAgICAgIHNsaWRlRWwuY2xhc3NMaXN0LnJlbW92ZShwYXJhbXMuc2xpZGVWaXNpYmxlQ2xhc3MsIHBhcmFtcy5zbGlkZUZ1bGx5VmlzaWJsZUNsYXNzLCBwYXJhbXMuc2xpZGVBY3RpdmVDbGFzcywgcGFyYW1zLnNsaWRlTmV4dENsYXNzLCBwYXJhbXMuc2xpZGVQcmV2Q2xhc3MpO1xuICAgICAgICAgIHNsaWRlRWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICAgIHNsaWRlRWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpcGVyLmVtaXQoJ2Rlc3Ryb3knKTtcblxuICAgIC8vIERldGFjaCBlbWl0dGVyIGV2ZW50c1xuICAgIE9iamVjdC5rZXlzKHN3aXBlci5ldmVudHNMaXN0ZW5lcnMpLmZvckVhY2goZXZlbnROYW1lID0+IHtcbiAgICAgIHN3aXBlci5vZmYoZXZlbnROYW1lKTtcbiAgICB9KTtcbiAgICBpZiAoZGVsZXRlSW5zdGFuY2UgIT09IGZhbHNlKSB7XG4gICAgICBzd2lwZXIuZWwuc3dpcGVyID0gbnVsbDtcbiAgICAgIGRlbGV0ZVByb3BzKHN3aXBlcik7XG4gICAgfVxuICAgIHN3aXBlci5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN0YXRpYyBleHRlbmREZWZhdWx0cyhuZXdEZWZhdWx0cykge1xuICAgIGV4dGVuZChleHRlbmRlZERlZmF1bHRzLCBuZXdEZWZhdWx0cyk7XG4gIH1cbiAgc3RhdGljIGdldCBleHRlbmRlZERlZmF1bHRzKCkge1xuICAgIHJldHVybiBleHRlbmRlZERlZmF1bHRzO1xuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRzO1xuICB9XG4gIHN0YXRpYyBpbnN0YWxsTW9kdWxlKG1vZCkge1xuICAgIGlmICghU3dpcGVyLnByb3RvdHlwZS5fX21vZHVsZXNfXykgU3dpcGVyLnByb3RvdHlwZS5fX21vZHVsZXNfXyA9IFtdO1xuICAgIGNvbnN0IG1vZHVsZXMgPSBTd2lwZXIucHJvdG90eXBlLl9fbW9kdWxlc19fO1xuICAgIGlmICh0eXBlb2YgbW9kID09PSAnZnVuY3Rpb24nICYmIG1vZHVsZXMuaW5kZXhPZihtb2QpIDwgMCkge1xuICAgICAgbW9kdWxlcy5wdXNoKG1vZCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyB1c2UobW9kdWxlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobW9kdWxlKSkge1xuICAgICAgbW9kdWxlLmZvckVhY2gobSA9PiBTd2lwZXIuaW5zdGFsbE1vZHVsZShtKSk7XG4gICAgICByZXR1cm4gU3dpcGVyO1xuICAgIH1cbiAgICBTd2lwZXIuaW5zdGFsbE1vZHVsZShtb2R1bGUpO1xuICAgIHJldHVybiBTd2lwZXI7XG4gIH1cbn1cbk9iamVjdC5rZXlzKHByb3RvdHlwZXMpLmZvckVhY2gocHJvdG90eXBlR3JvdXAgPT4ge1xuICBPYmplY3Qua2V5cyhwcm90b3R5cGVzW3Byb3RvdHlwZUdyb3VwXSkuZm9yRWFjaChwcm90b01ldGhvZCA9PiB7XG4gICAgU3dpcGVyLnByb3RvdHlwZVtwcm90b01ldGhvZF0gPSBwcm90b3R5cGVzW3Byb3RvdHlwZUdyb3VwXVtwcm90b01ldGhvZF07XG4gIH0pO1xufSk7XG5Td2lwZXIudXNlKFtSZXNpemUsIE9ic2VydmVyXSk7XG5cbmV4cG9ydCB7IFN3aXBlciBhcyBTLCBkZWZhdWx0cyBhcyBkIH07XG4iXSwibmFtZXMiOlsiYSIsImdldFdpbmRvdyIsImciLCJnZXREb2N1bWVudCIsImVsZW1lbnRQYXJlbnRzIiwibyIsImVsZW1lbnRTdHlsZSIsImUiLCJlbGVtZW50Q2hpbGRyZW4iLCJzIiwic2V0Q1NTUHJvcGVydHkiLCJmIiwiZWxlbWVudE91dGVyU2l6ZSIsInAiLCJlbGVtZW50TmV4dEFsbCIsInEiLCJlbGVtZW50UHJldkFsbCIsImoiLCJnZXRUcmFuc2xhdGUiLCJyIiwiYW5pbWF0ZUNTU01vZGVTY3JvbGwiLCJuIiwibmV4dFRpY2siLCJ0Iiwic2hvd1dhcm5pbmciLCJjIiwiY3JlYXRlRWxlbWVudCIsImQiLCJub3ciLCJ1IiwiZXh0ZW5kIiwiaCIsImVsZW1lbnRJbmRleCIsInYiLCJkZWxldGVQcm9wcyIsInN1cHBvcnQiLCJjYWxjU3VwcG9ydCIsIndpbmRvdyIsImRvY3VtZW50Iiwic21vb3RoU2Nyb2xsIiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJ0b3VjaCIsIkRvY3VtZW50VG91Y2giLCJnZXRTdXBwb3J0IiwiZGV2aWNlQ2FjaGVkIiwiY2FsY0RldmljZSIsIl90ZW1wIiwidXNlckFnZW50IiwicGxhdGZvcm0iLCJuYXZpZ2F0b3IiLCJ1YSIsImRldmljZSIsImlvcyIsImFuZHJvaWQiLCJzY3JlZW5XaWR0aCIsInNjcmVlbiIsIndpZHRoIiwic2NyZWVuSGVpZ2h0IiwiaGVpZ2h0IiwibWF0Y2giLCJpcGFkIiwiaXBvZCIsImlwaG9uZSIsIndpbmRvd3MiLCJtYWNvcyIsImlQYWRTY3JlZW5zIiwiaW5kZXhPZiIsIm9zIiwiZ2V0RGV2aWNlIiwib3ZlcnJpZGVzIiwiYnJvd3NlciIsImNhbGNCcm93c2VyIiwibmVlZFBlcnNwZWN0aXZlRml4IiwiaXNTYWZhcmkiLCJ0b0xvd2VyQ2FzZSIsIlN0cmluZyIsImluY2x1ZGVzIiwic3BsaXQiLCJtYXAiLCJudW0iLCJOdW1iZXIiLCJtYWpvciIsIm1pbm9yIiwiaXNXZWJWaWV3IiwidGVzdCIsImlzU2FmYXJpQnJvd3NlciIsIm5lZWQzZEZpeCIsImdldEJyb3dzZXIiLCJSZXNpemUiLCJfcmVmIiwic3dpcGVyIiwib24iLCJlbWl0Iiwib2JzZXJ2ZXIiLCJhbmltYXRpb25GcmFtZSIsInJlc2l6ZUhhbmRsZXIiLCJkZXN0cm95ZWQiLCJpbml0aWFsaXplZCIsImNyZWF0ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCJlbnRyaWVzIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJmb3JFYWNoIiwiX3JlZjIiLCJjb250ZW50Qm94U2l6ZSIsImNvbnRlbnRSZWN0IiwidGFyZ2V0IiwiZWwiLCJpbmxpbmVTaXplIiwiYmxvY2tTaXplIiwib2JzZXJ2ZSIsInJlbW92ZU9ic2VydmVyIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJ1bm9ic2VydmUiLCJvcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIiLCJwYXJhbXMiLCJyZXNpemVPYnNlcnZlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiT2JzZXJ2ZXIiLCJleHRlbmRQYXJhbXMiLCJvYnNlcnZlcnMiLCJhdHRhY2giLCJvcHRpb25zIiwiT2JzZXJ2ZXJGdW5jIiwiTXV0YXRpb25PYnNlcnZlciIsIldlYmtpdE11dGF0aW9uT2JzZXJ2ZXIiLCJtdXRhdGlvbnMiLCJfX3ByZXZlbnRPYnNlcnZlcl9fIiwibGVuZ3RoIiwib2JzZXJ2ZXJVcGRhdGUiLCJzZXRUaW1lb3V0IiwiYXR0cmlidXRlcyIsImNoaWxkTGlzdCIsImNoYXJhY3RlckRhdGEiLCJwdXNoIiwiaW5pdCIsIm9ic2VydmVQYXJlbnRzIiwiY29udGFpbmVyUGFyZW50cyIsImhvc3RFbCIsImkiLCJvYnNlcnZlU2xpZGVDaGlsZHJlbiIsIndyYXBwZXJFbCIsImRlc3Ryb3kiLCJkaXNjb25uZWN0Iiwic3BsaWNlIiwiZXZlbnRzRW1pdHRlciIsImV2ZW50cyIsImhhbmRsZXIiLCJwcmlvcml0eSIsInNlbGYiLCJldmVudHNMaXN0ZW5lcnMiLCJtZXRob2QiLCJldmVudCIsIm9uY2UiLCJvbmNlSGFuZGxlciIsIm9mZiIsIl9fZW1pdHRlclByb3h5IiwiX2xlbiIsImFyZ3VtZW50cyIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJhcHBseSIsIm9uQW55IiwiZXZlbnRzQW55TGlzdGVuZXJzIiwib2ZmQW55IiwiaW5kZXgiLCJldmVudEhhbmRsZXIiLCJkYXRhIiwiY29udGV4dCIsIl9sZW4yIiwiX2tleTIiLCJpc0FycmF5Iiwic2xpY2UiLCJ1bnNoaWZ0IiwiZXZlbnRzQXJyYXkiLCJ1cGRhdGVTaXplIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJpc0hvcml6b250YWwiLCJpc1ZlcnRpY2FsIiwicGFyc2VJbnQiLCJpc05hTiIsIk9iamVjdCIsImFzc2lnbiIsInNpemUiLCJ1cGRhdGVTbGlkZXMiLCJnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlIiwibm9kZSIsImxhYmVsIiwicGFyc2VGbG9hdCIsImdldFByb3BlcnR5VmFsdWUiLCJnZXREaXJlY3Rpb25MYWJlbCIsInNsaWRlc0VsIiwic3dpcGVyU2l6ZSIsInJ0bFRyYW5zbGF0ZSIsInJ0bCIsIndyb25nUlRMIiwiaXNWaXJ0dWFsIiwidmlydHVhbCIsImVuYWJsZWQiLCJwcmV2aW91c1NsaWRlc0xlbmd0aCIsInNsaWRlcyIsInNsaWRlQ2xhc3MiLCJzbGlkZXNMZW5ndGgiLCJzbmFwR3JpZCIsInNsaWRlc0dyaWQiLCJzbGlkZXNTaXplc0dyaWQiLCJvZmZzZXRCZWZvcmUiLCJzbGlkZXNPZmZzZXRCZWZvcmUiLCJjYWxsIiwib2Zmc2V0QWZ0ZXIiLCJzbGlkZXNPZmZzZXRBZnRlciIsInByZXZpb3VzU25hcEdyaWRMZW5ndGgiLCJwcmV2aW91c1NsaWRlc0dyaWRMZW5ndGgiLCJzcGFjZUJldHdlZW4iLCJzbGlkZVBvc2l0aW9uIiwicHJldlNsaWRlU2l6ZSIsInJlcGxhY2UiLCJ2aXJ0dWFsU2l6ZSIsInNsaWRlRWwiLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJtYXJnaW5Cb3R0b20iLCJtYXJnaW5Ub3AiLCJjZW50ZXJlZFNsaWRlcyIsImNzc01vZGUiLCJncmlkRW5hYmxlZCIsImdyaWQiLCJyb3dzIiwiaW5pdFNsaWRlcyIsInVuc2V0U2xpZGVzIiwic2xpZGVTaXplIiwic2hvdWxkUmVzZXRTbGlkZVNpemUiLCJzbGlkZXNQZXJWaWV3IiwiYnJlYWtwb2ludHMiLCJrZXlzIiwiZmlsdGVyIiwia2V5Iiwic2xpZGUiLCJ1cGRhdGVTbGlkZSIsInNsaWRlU3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImN1cnJlbnRUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0iLCJjdXJyZW50V2ViS2l0VHJhbnNmb3JtIiwid2Via2l0VHJhbnNmb3JtIiwicm91bmRMZW5ndGhzIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJib3hTaXppbmciLCJvZmZzZXRXaWR0aCIsIk1hdGgiLCJmbG9vciIsInN3aXBlclNsaWRlU2l6ZSIsImFicyIsInNsaWRlc1Blckdyb3VwIiwibWluIiwic2xpZGVzUGVyR3JvdXBTa2lwIiwibWF4IiwiZWZmZWN0Iiwic2V0V3JhcHBlclNpemUiLCJ1cGRhdGVXcmFwcGVyU2l6ZSIsIm5ld1NsaWRlc0dyaWQiLCJzbGlkZXNHcmlkSXRlbSIsImxvb3AiLCJncm91cHMiLCJjZWlsIiwic2xpZGVzQmVmb3JlIiwic2xpZGVzQWZ0ZXIiLCJncm91cFNpemUiLCJfIiwic2xpZGVJbmRleCIsImNlbnRlcmVkU2xpZGVzQm91bmRzIiwiYWxsU2xpZGVzU2l6ZSIsInNsaWRlU2l6ZVZhbHVlIiwibWF4U25hcCIsInNuYXAiLCJjZW50ZXJJbnN1ZmZpY2llbnRTbGlkZXMiLCJvZmZzZXRTaXplIiwiYWxsU2xpZGVzT2Zmc2V0Iiwic25hcEluZGV4IiwiYWRkVG9TbmFwR3JpZCIsImFkZFRvU2xpZGVzR3JpZCIsIndhdGNoT3ZlcmZsb3ciLCJjaGVja092ZXJmbG93Iiwid2F0Y2hTbGlkZXNQcm9ncmVzcyIsInVwZGF0ZVNsaWRlc09mZnNldCIsImJhY2tGYWNlSGlkZGVuQ2xhc3MiLCJjb250YWluZXJNb2RpZmllckNsYXNzIiwiaGFzQ2xhc3NCYWNrZmFjZUNsYXNzQWRkZWQiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsIm1heEJhY2tmYWNlSGlkZGVuU2xpZGVzIiwiYWRkIiwicmVtb3ZlIiwidXBkYXRlQXV0b0hlaWdodCIsInNwZWVkIiwiYWN0aXZlU2xpZGVzIiwic2V0VHJhbnNpdGlvbiIsImdldFNsaWRlQnlJbmRleCIsImdldFNsaWRlSW5kZXhCeURhdGEiLCJ2aXNpYmxlU2xpZGVzIiwiYWN0aXZlSW5kZXgiLCJvZmZzZXRIZWlnaHQiLCJtaW51c09mZnNldCIsImlzRWxlbWVudCIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJzd2lwZXJTbGlkZU9mZnNldCIsImNzc092ZXJmbG93QWRqdXN0bWVudCIsInRvZ2dsZVNsaWRlQ2xhc3NlcyQxIiwiY29uZGl0aW9uIiwiY2xhc3NOYW1lIiwidXBkYXRlU2xpZGVzUHJvZ3Jlc3MiLCJ0cmFuc2xhdGUiLCJvZmZzZXRDZW50ZXIiLCJ2aXNpYmxlU2xpZGVzSW5kZXhlcyIsInNsaWRlT2Zmc2V0Iiwic2xpZGVQcm9ncmVzcyIsIm1pblRyYW5zbGF0ZSIsIm9yaWdpbmFsU2xpZGVQcm9ncmVzcyIsInNsaWRlQmVmb3JlIiwic2xpZGVBZnRlciIsImlzRnVsbHlWaXNpYmxlIiwiaXNWaXNpYmxlIiwic2xpZGVWaXNpYmxlQ2xhc3MiLCJzbGlkZUZ1bGx5VmlzaWJsZUNsYXNzIiwicHJvZ3Jlc3MiLCJvcmlnaW5hbFByb2dyZXNzIiwidXBkYXRlUHJvZ3Jlc3MiLCJtdWx0aXBsaWVyIiwidHJhbnNsYXRlc0RpZmYiLCJtYXhUcmFuc2xhdGUiLCJpc0JlZ2lubmluZyIsImlzRW5kIiwicHJvZ3Jlc3NMb29wIiwid2FzQmVnaW5uaW5nIiwid2FzRW5kIiwiaXNCZWdpbm5pbmdSb3VuZGVkIiwiaXNFbmRSb3VuZGVkIiwiZmlyc3RTbGlkZUluZGV4IiwibGFzdFNsaWRlSW5kZXgiLCJmaXJzdFNsaWRlVHJhbnNsYXRlIiwibGFzdFNsaWRlVHJhbnNsYXRlIiwidHJhbnNsYXRlTWF4IiwidHJhbnNsYXRlQWJzIiwiYXV0b0hlaWdodCIsInRvZ2dsZVNsaWRlQ2xhc3NlcyIsInVwZGF0ZVNsaWRlc0NsYXNzZXMiLCJnZXRGaWx0ZXJlZFNsaWRlIiwic2VsZWN0b3IiLCJhY3RpdmVTbGlkZSIsInByZXZTbGlkZSIsIm5leHRTbGlkZSIsImNvbHVtbiIsInNsaWRlQWN0aXZlQ2xhc3MiLCJzbGlkZU5leHRDbGFzcyIsInNsaWRlUHJldkNsYXNzIiwiZW1pdFNsaWRlc0NsYXNzZXMiLCJwcm9jZXNzTGF6eVByZWxvYWRlciIsImltYWdlRWwiLCJzbGlkZVNlbGVjdG9yIiwiY2xvc2VzdCIsImxhenlFbCIsInF1ZXJ5U2VsZWN0b3IiLCJsYXp5UHJlbG9hZGVyQ2xhc3MiLCJzaGFkb3dSb290IiwidW5sYXp5IiwicmVtb3ZlQXR0cmlidXRlIiwicHJlbG9hZCIsImFtb3VudCIsImxhenlQcmVsb2FkUHJldk5leHQiLCJsZW4iLCJzbGlkZXNQZXJWaWV3RHluYW1pYyIsInByZWxvYWRDb2x1bW5zIiwiYWN0aXZlQ29sdW1uIiwiZnJvbSIsInNsaWRlSW5kZXhMYXN0SW5WaWV3IiwicmV3aW5kIiwicmVhbEluZGV4IiwiZ2V0QWN0aXZlSW5kZXhCeVRyYW5zbGF0ZSIsIm5vcm1hbGl6ZVNsaWRlSW5kZXgiLCJ1cGRhdGVBY3RpdmVJbmRleCIsIm5ld0FjdGl2ZUluZGV4IiwicHJldmlvdXNJbmRleCIsInByZXZpb3VzUmVhbEluZGV4IiwicHJldmlvdXNTbmFwSW5kZXgiLCJnZXRWaXJ0dWFsUmVhbEluZGV4IiwiYUluZGV4Iiwic2tpcCIsImZpcnN0U2xpZGVJbkNvbHVtbiIsImFjdGl2ZVNsaWRlSW5kZXgiLCJnZXRBdHRyaWJ1dGUiLCJydW5DYWxsYmFja3NPbkluaXQiLCJ1cGRhdGVDbGlja2VkU2xpZGUiLCJwYXRoIiwicGF0aEVsIiwibWF0Y2hlcyIsInNsaWRlRm91bmQiLCJjbGlja2VkU2xpZGUiLCJjbGlja2VkSW5kZXgiLCJ1bmRlZmluZWQiLCJzbGlkZVRvQ2xpY2tlZFNsaWRlIiwidXBkYXRlIiwiZ2V0U3dpcGVyVHJhbnNsYXRlIiwiYXhpcyIsInZpcnR1YWxUcmFuc2xhdGUiLCJjdXJyZW50VHJhbnNsYXRlIiwic2V0VHJhbnNsYXRlIiwiYnlDb250cm9sbGVyIiwieCIsInkiLCJ6IiwicHJldmlvdXNUcmFuc2xhdGUiLCJuZXdQcm9ncmVzcyIsInRyYW5zbGF0ZVRvIiwicnVuQ2FsbGJhY2tzIiwidHJhbnNsYXRlQm91bmRzIiwiaW50ZXJuYWwiLCJhbmltYXRpbmciLCJwcmV2ZW50SW50ZXJhY3Rpb25PblRyYW5zaXRpb24iLCJuZXdUcmFuc2xhdGUiLCJpc0giLCJ0YXJnZXRQb3NpdGlvbiIsInNpZGUiLCJzY3JvbGxUbyIsImJlaGF2aW9yIiwib25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kIiwidHJhbnNpdGlvbkVuZCIsImR1cmF0aW9uIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwidHJhbnNpdGlvbkRlbGF5IiwidHJhbnNpdGlvbkVtaXQiLCJkaXJlY3Rpb24iLCJzdGVwIiwiZGlyIiwidHJhbnNpdGlvblN0YXJ0IiwidHJhbnNpdGlvbiIsInNsaWRlVG8iLCJpbml0aWFsIiwibm9ybWFsaXplZFRyYW5zbGF0ZSIsIm5vcm1hbGl6ZWRHcmlkIiwibm9ybWFsaXplZEdyaWROZXh0IiwiYWxsb3dTbGlkZU5leHQiLCJhbGxvd1NsaWRlUHJldiIsInNjcm9sbFNuYXBUeXBlIiwiX2ltbWVkaWF0ZVZpcnR1YWwiLCJfY3NzTW9kZVZpcnR1YWxJbml0aWFsU2V0IiwiaW5pdGlhbFNsaWRlIiwib25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQiLCJzbGlkZVRvTG9vcCIsImluZGV4QXNOdW1iZXIiLCJuZXdJbmRleCIsInRhcmdldFNsaWRlSW5kZXgiLCJjb2xzIiwibmVlZExvb3BGaXgiLCJsb29wRml4Iiwic2xpZGVSZWFsSW5kZXgiLCJzbGlkZU5leHQiLCJwZXJHcm91cCIsInNsaWRlc1Blckdyb3VwQXV0byIsImluY3JlbWVudCIsImxvb3BQcmV2ZW50c1NsaWRpbmciLCJfY2xpZW50TGVmdCIsImNsaWVudExlZnQiLCJzbGlkZVByZXYiLCJub3JtYWxpemUiLCJ2YWwiLCJub3JtYWxpemVkU25hcEdyaWQiLCJwcmV2U25hcCIsInByZXZTbmFwSW5kZXgiLCJwcmV2SW5kZXgiLCJsYXN0SW5kZXgiLCJzbGlkZVJlc2V0Iiwic2xpZGVUb0Nsb3Nlc3QiLCJ0aHJlc2hvbGQiLCJjdXJyZW50U25hcCIsIm5leHRTbmFwIiwic2xpZGVUb0luZGV4IiwibG9vcGVkU2xpZGVzIiwiZ2V0U2xpZGVJbmRleCIsImxvb3BDcmVhdGUiLCJzZXRBdHRyaWJ1dGUiLCJzaG91bGRGaWxsR3JvdXAiLCJzaG91bGRGaWxsR3JpZCIsImFkZEJsYW5rU2xpZGVzIiwiYW1vdW50T2ZTbGlkZXMiLCJzbGlkZUJsYW5rQ2xhc3MiLCJhcHBlbmQiLCJsb29wQWRkQmxhbmtTbGlkZXMiLCJzbGlkZXNUb0FkZCIsInJlY2FsY1NsaWRlcyIsImJ5TW91c2V3aGVlbCIsImxvb3BBZGRpdGlvbmFsU2xpZGVzIiwiZmlsbCIsInByZXBlbmRTbGlkZXNJbmRleGVzIiwiYXBwZW5kU2xpZGVzSW5kZXhlcyIsImlzTmV4dCIsImlzUHJldiIsInNsaWRlc1ByZXBlbmRlZCIsInNsaWRlc0FwcGVuZGVkIiwiYWN0aXZlQ29sSW5kZXgiLCJhY3RpdmVDb2xJbmRleFdpdGhTaGlmdCIsImNvbEluZGV4VG9QcmVwZW5kIiwic3dpcGVyTG9vcE1vdmVET00iLCJwcmVwZW5kIiwiY3VycmVudFNsaWRlVHJhbnNsYXRlIiwibmV3U2xpZGVUcmFuc2xhdGUiLCJkaWZmIiwidG91Y2hFdmVudHNEYXRhIiwic3RhcnRUcmFuc2xhdGUiLCJzaGlmdCIsImNvbnRyb2xsZXIiLCJjb250cm9sIiwibG9vcFBhcmFtcyIsImNvbnN0cnVjdG9yIiwibG9vcERlc3Ryb3kiLCJuZXdTbGlkZXNPcmRlciIsInN3aXBlclNsaWRlSW5kZXgiLCJzZXRHcmFiQ3Vyc29yIiwibW92aW5nIiwic2ltdWxhdGVUb3VjaCIsImlzTG9ja2VkIiwidG91Y2hFdmVudHNUYXJnZXQiLCJjdXJzb3IiLCJ1bnNldEdyYWJDdXJzb3IiLCJncmFiQ3Vyc29yIiwiY2xvc2VzdEVsZW1lbnQiLCJiYXNlIiwiX19jbG9zZXN0RnJvbSIsImFzc2lnbmVkU2xvdCIsImZvdW5kIiwiZ2V0Um9vdE5vZGUiLCJob3N0IiwicHJldmVudEVkZ2VTd2lwZSIsInN0YXJ0WCIsImVkZ2VTd2lwZURldGVjdGlvbiIsImVkZ2VTd2lwZVRocmVzaG9sZCIsImlubmVyV2lkdGgiLCJwcmV2ZW50RGVmYXVsdCIsIm9uVG91Y2hTdGFydCIsIm9yaWdpbmFsRXZlbnQiLCJ0eXBlIiwicG9pbnRlcklkIiwidGFyZ2V0VG91Y2hlcyIsInRvdWNoSWQiLCJpZGVudGlmaWVyIiwicGFnZVgiLCJ0b3VjaGVzIiwicG9pbnRlclR5cGUiLCJ0YXJnZXRFbCIsIndoaWNoIiwiYnV0dG9uIiwiaXNUb3VjaGVkIiwiaXNNb3ZlZCIsInN3aXBpbmdDbGFzc0hhc1ZhbHVlIiwibm9Td2lwaW5nQ2xhc3MiLCJldmVudFBhdGgiLCJjb21wb3NlZFBhdGgiLCJub1N3aXBpbmdTZWxlY3RvciIsImlzVGFyZ2V0U2hhZG93Iiwibm9Td2lwaW5nIiwiYWxsb3dDbGljayIsInN3aXBlSGFuZGxlciIsImN1cnJlbnRYIiwiY3VycmVudFkiLCJwYWdlWSIsInN0YXJ0WSIsImFsbG93VG91Y2hDYWxsYmFja3MiLCJpc1Njcm9sbGluZyIsInN0YXJ0TW92aW5nIiwidG91Y2hTdGFydFRpbWUiLCJzd2lwZURpcmVjdGlvbiIsImFsbG93VGhyZXNob2xkTW92ZSIsImZvY3VzYWJsZUVsZW1lbnRzIiwibm9kZU5hbWUiLCJhY3RpdmVFbGVtZW50IiwiYmx1ciIsInNob3VsZFByZXZlbnREZWZhdWx0IiwiYWxsb3dUb3VjaE1vdmUiLCJ0b3VjaFN0YXJ0UHJldmVudERlZmF1bHQiLCJ0b3VjaFN0YXJ0Rm9yY2VQcmV2ZW50RGVmYXVsdCIsImlzQ29udGVudEVkaXRhYmxlIiwiZnJlZU1vZGUiLCJvblRvdWNoTW92ZSIsImlkIiwidGFyZ2V0VG91Y2giLCJjaGFuZ2VkVG91Y2hlcyIsInByZXZlbnRlZEJ5TmVzdGVkU3dpcGVyIiwidG91Y2hSZWxlYXNlT25FZGdlcyIsInByZXZpb3VzWCIsInByZXZpb3VzWSIsImRpZmZYIiwiZGlmZlkiLCJzcXJ0IiwidG91Y2hBbmdsZSIsImF0YW4yIiwiUEkiLCJwcmV2ZW50VG91Y2hNb3ZlRnJvbVBvaW50ZXJNb3ZlIiwiY2FuY2VsYWJsZSIsInRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbiIsIm5lc3RlZCIsInN0b3BQcm9wYWdhdGlvbiIsInRvdWNoZXNEaWZmIiwib25lV2F5TW92ZW1lbnQiLCJ0b3VjaFJhdGlvIiwicHJldlRvdWNoZXNEaXJlY3Rpb24iLCJ0b3VjaGVzRGlyZWN0aW9uIiwiaXNMb29wIiwiYWxsb3dMb29wRml4IiwiZXZ0IiwiQ3VzdG9tRXZlbnQiLCJidWJibGVzIiwiZGV0YWlsIiwiYnlTd2lwZXJUb3VjaE1vdmUiLCJkaXNwYXRjaEV2ZW50IiwiYWxsb3dNb21lbnR1bUJvdW5jZSIsImxvb3BGaXhlZCIsIkRhdGUiLCJnZXRUaW1lIiwibG9vcFN3YXBSZXNldCIsImRpc2FibGVQYXJlbnRTd2lwZXIiLCJyZXNpc3RhbmNlUmF0aW8iLCJyZXNpc3RhbmNlIiwiZm9sbG93RmluZ2VyIiwib25Ub3VjaEVuZCIsImlzVG91Y2hFdmVudCIsInByb2NlZWQiLCJ0b3VjaEVuZFRpbWUiLCJ0aW1lRGlmZiIsInBhdGhUcmVlIiwibGFzdENsaWNrVGltZSIsImN1cnJlbnRQb3MiLCJzd2lwZVRvTGFzdCIsInN0b3BJbmRleCIsInJld2luZEZpcnN0SW5kZXgiLCJyZXdpbmRMYXN0SW5kZXgiLCJyYXRpbyIsImxvbmdTd2lwZXNNcyIsImxvbmdTd2lwZXMiLCJsb25nU3dpcGVzUmF0aW8iLCJzaG9ydFN3aXBlcyIsImlzTmF2QnV0dG9uVGFyZ2V0IiwibmF2aWdhdGlvbiIsIm5leHRFbCIsInByZXZFbCIsIm9uUmVzaXplIiwic2V0QnJlYWtwb2ludCIsImlzVmlydHVhbExvb3AiLCJhdXRvcGxheSIsInJ1bm5pbmciLCJwYXVzZWQiLCJjbGVhclRpbWVvdXQiLCJyZXNpemVUaW1lb3V0IiwicmVzdW1lIiwib25DbGljayIsInByZXZlbnRDbGlja3MiLCJwcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24iLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJvblNjcm9sbCIsInNjcm9sbExlZnQiLCJzY3JvbGxUb3AiLCJvbkxvYWQiLCJvbkRvY3VtZW50VG91Y2hTdGFydCIsImRvY3VtZW50VG91Y2hIYW5kbGVyUHJvY2VlZGVkIiwidG91Y2hBY3Rpb24iLCJjYXB0dXJlIiwiZG9tTWV0aG9kIiwic3dpcGVyTWV0aG9kIiwicGFzc2l2ZSIsInVwZGF0ZU9uV2luZG93UmVzaXplIiwiYXR0YWNoRXZlbnRzIiwiYmluZCIsImRldGFjaEV2ZW50cyIsImV2ZW50cyQxIiwiaXNHcmlkRW5hYmxlZCIsImJyZWFrcG9pbnQiLCJnZXRCcmVha3BvaW50IiwiYnJlYWtwb2ludHNCYXNlIiwiY3VycmVudEJyZWFrcG9pbnQiLCJicmVha3BvaW50T25seVBhcmFtcyIsImJyZWFrcG9pbnRQYXJhbXMiLCJvcmlnaW5hbFBhcmFtcyIsIndhc011bHRpUm93IiwiaXNNdWx0aVJvdyIsIndhc0dyYWJDdXJzb3IiLCJpc0dyYWJDdXJzb3IiLCJ3YXNFbmFibGVkIiwiZW1pdENvbnRhaW5lckNsYXNzZXMiLCJwcm9wIiwid2FzTW9kdWxlRW5hYmxlZCIsImlzTW9kdWxlRW5hYmxlZCIsImRpc2FibGUiLCJlbmFibGUiLCJkaXJlY3Rpb25DaGFuZ2VkIiwibmVlZHNSZUxvb3AiLCJ3YXNMb29wIiwiY2hhbmdlRGlyZWN0aW9uIiwiaXNFbmFibGVkIiwiaGFzTG9vcCIsImNvbnRhaW5lckVsIiwiY3VycmVudEhlaWdodCIsImlubmVySGVpZ2h0IiwicG9pbnRzIiwicG9pbnQiLCJtaW5SYXRpbyIsInN1YnN0ciIsInZhbHVlIiwic29ydCIsImIiLCJtYXRjaE1lZGlhIiwicHJlcGFyZUNsYXNzZXMiLCJwcmVmaXgiLCJyZXN1bHRDbGFzc2VzIiwiaXRlbSIsImNsYXNzTmFtZXMiLCJhZGRDbGFzc2VzIiwic3VmZml4ZXMiLCJyZW1vdmVDbGFzc2VzIiwiY2xhc3NlcyIsIndhc0xvY2tlZCIsImxhc3RTbGlkZVJpZ2h0RWRnZSIsImNoZWNrT3ZlcmZsb3ckMSIsImRlZmF1bHRzIiwic3dpcGVyRWxlbWVudE5vZGVOYW1lIiwiY3JlYXRlRWxlbWVudHMiLCJldmVudHNQcmVmaXgiLCJ1cmwiLCJ1bmlxdWVOYXZFbGVtZW50cyIsInBhc3NpdmVMaXN0ZW5lcnMiLCJ3cmFwcGVyQ2xhc3MiLCJfZW1pdENsYXNzZXMiLCJtb2R1bGVFeHRlbmRQYXJhbXMiLCJhbGxNb2R1bGVzUGFyYW1zIiwib2JqIiwibW9kdWxlUGFyYW1OYW1lIiwibW9kdWxlUGFyYW1zIiwiYXV0byIsInByb3RvdHlwZXMiLCJleHRlbmRlZERlZmF1bHRzIiwiU3dpcGVyIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJxdWVyeVNlbGVjdG9yQWxsIiwic3dpcGVycyIsIm5ld1BhcmFtcyIsIl9fc3dpcGVyX18iLCJtb2R1bGVzIiwiX19tb2R1bGVzX18iLCJtb2QiLCJzd2lwZXJQYXJhbXMiLCJwYXNzZWRQYXJhbXMiLCJldmVudE5hbWUiLCJ2ZWxvY2l0eSIsInRydW5jIiwiY2xpY2tUaW1lb3V0IiwidmVsb2NpdGllcyIsImltYWdlc1RvTG9hZCIsImltYWdlc0xvYWRlZCIsInByb3BlcnR5Iiwic2V0UHJvZ3Jlc3MiLCJjdXJyZW50IiwiY2xzIiwiam9pbiIsImdldFNsaWRlQ2xhc3NlcyIsInVwZGF0ZXMiLCJ2aWV3IiwiZXhhY3QiLCJzcHYiLCJicmVha0xvb3AiLCJzbGlkZUluVmlldyIsImNvbXBsZXRlIiwidHJhbnNsYXRlVmFsdWUiLCJ0cmFuc2xhdGVkIiwibmV3RGlyZWN0aW9uIiwibmVlZFVwZGF0ZSIsImN1cnJlbnREaXJlY3Rpb24iLCJjaGFuZ2VMYW5ndWFnZURpcmVjdGlvbiIsIm1vdW50IiwiZWxlbWVudCIsIm1vdW50ZWQiLCJwYXJlbnROb2RlIiwidG9VcHBlckNhc2UiLCJnZXRXcmFwcGVyU2VsZWN0b3IiLCJ0cmltIiwiZ2V0V3JhcHBlciIsInJlcyIsInNsaWRlU2xvdHMiLCJsYXp5RWxlbWVudHMiLCJkZWxldGVJbnN0YW5jZSIsImNsZWFuU3R5bGVzIiwiZXh0ZW5kRGVmYXVsdHMiLCJuZXdEZWZhdWx0cyIsImluc3RhbGxNb2R1bGUiLCJ1c2UiLCJtb2R1bGUiLCJtIiwicHJvdG90eXBlR3JvdXAiLCJwcm90b01ldGhvZCIsIlMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/swiper-core.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/update-on-virtual-data.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/update-on-virtual-data.mjs ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: function() { return /* binding */ getChangedParams; },\n/* harmony export */   g: function() { return /* binding */ getParams; },\n/* harmony export */   m: function() { return /* binding */ mountSwiper; },\n/* harmony export */   u: function() { return /* binding */ updateOnVirtualData; }\n/* harmony export */ });\n/* harmony import */ var _update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./update-swiper.mjs */ \"(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/update-swiper.mjs\");\n/* harmony import */ var _swiper_core_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./swiper-core.mjs */ \"(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/swiper-core.mjs\");\n\n\nfunction getParams(obj, splitEvents) {\n    if (obj === void 0) {\n        obj = {};\n    }\n    if (splitEvents === void 0) {\n        splitEvents = true;\n    }\n    var params = {\n        on: {}\n    };\n    var events = {};\n    var passedParams = {};\n    (0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.e)(params, _swiper_core_mjs__WEBPACK_IMPORTED_MODULE_1__.d);\n    params._emitClasses = true;\n    params.init = false;\n    var rest = {};\n    var allowedParams = _update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.p.map(function(key) {\n        return key.replace(/_/, \"\");\n    });\n    var plainObj = Object.assign({}, obj);\n    Object.keys(plainObj).forEach(function(key) {\n        if (typeof obj[key] === \"undefined\") return;\n        if (allowedParams.indexOf(key) >= 0) {\n            if ((0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(obj[key])) {\n                params[key] = {};\n                passedParams[key] = {};\n                (0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.e)(params[key], obj[key]);\n                (0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.e)(passedParams[key], obj[key]);\n            } else {\n                params[key] = obj[key];\n                passedParams[key] = obj[key];\n            }\n        } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === \"function\") {\n            if (splitEvents) {\n                events[\"\".concat(key[2].toLowerCase()).concat(key.substr(3))] = obj[key];\n            } else {\n                params.on[\"\".concat(key[2].toLowerCase()).concat(key.substr(3))] = obj[key];\n            }\n        } else {\n            rest[key] = obj[key];\n        }\n    });\n    [\n        \"navigation\",\n        \"pagination\",\n        \"scrollbar\"\n    ].forEach(function(key) {\n        if (params[key] === true) params[key] = {};\n        if (params[key] === false) delete params[key];\n    });\n    return {\n        params: params,\n        passedParams: passedParams,\n        rest: rest,\n        events: events\n    };\n}\nfunction mountSwiper(_ref, swiperParams) {\n    var el = _ref.el, nextEl = _ref.nextEl, prevEl = _ref.prevEl, paginationEl = _ref.paginationEl, scrollbarEl = _ref.scrollbarEl, swiper = _ref.swiper;\n    if ((0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.n)(swiperParams) && nextEl && prevEl) {\n        swiper.params.navigation.nextEl = nextEl;\n        swiper.originalParams.navigation.nextEl = nextEl;\n        swiper.params.navigation.prevEl = prevEl;\n        swiper.originalParams.navigation.prevEl = prevEl;\n    }\n    if ((0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.a)(swiperParams) && paginationEl) {\n        swiper.params.pagination.el = paginationEl;\n        swiper.originalParams.pagination.el = paginationEl;\n    }\n    if ((0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(swiperParams) && scrollbarEl) {\n        swiper.params.scrollbar.el = scrollbarEl;\n        swiper.originalParams.scrollbar.el = scrollbarEl;\n    }\n    swiper.init(el);\n}\nfunction getChangedParams(swiperParams, oldParams, children, oldChildren, getKey) {\n    var keys = [];\n    if (!oldParams) return keys;\n    var addKey = function(key) {\n        if (keys.indexOf(key) < 0) keys.push(key);\n    };\n    if (children && oldChildren) {\n        var oldChildrenKeys = oldChildren.map(getKey);\n        var childrenKeys = children.map(getKey);\n        if (oldChildrenKeys.join(\"\") !== childrenKeys.join(\"\")) addKey(\"children\");\n        if (oldChildren.length !== children.length) addKey(\"children\");\n    }\n    var watchParams = _update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.p.filter(function(key) {\n        return key[0] === \"_\";\n    }).map(function(key) {\n        return key.replace(/_/, \"\");\n    });\n    watchParams.forEach(function(key) {\n        if (key in swiperParams && key in oldParams) {\n            if ((0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(swiperParams[key]) && (0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(oldParams[key])) {\n                var newKeys = Object.keys(swiperParams[key]);\n                var oldKeys = Object.keys(oldParams[key]);\n                if (newKeys.length !== oldKeys.length) {\n                    addKey(key);\n                } else {\n                    newKeys.forEach(function(newKey) {\n                        if (swiperParams[key][newKey] !== oldParams[key][newKey]) {\n                            addKey(key);\n                        }\n                    });\n                    oldKeys.forEach(function(oldKey) {\n                        if (swiperParams[key][oldKey] !== oldParams[key][oldKey]) addKey(key);\n                    });\n                }\n            } else if (swiperParams[key] !== oldParams[key]) {\n                addKey(key);\n            }\n        }\n    });\n    return keys;\n}\nvar updateOnVirtualData = function(swiper) {\n    if (!swiper || swiper.destroyed || !swiper.params.virtual || swiper.params.virtual && !swiper.params.virtual.enabled) return;\n    swiper.updateSlides();\n    swiper.updateProgress();\n    swiper.updateSlidesClasses();\n    if (swiper.parallax && swiper.params.parallax && swiper.params.parallax.enabled) {\n        swiper.parallax.setTranslate();\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zd2lwZXJAMTEuMS4zL25vZGVfbW9kdWxlcy9zd2lwZXIvc2hhcmVkL3VwZGF0ZS1vbi12aXJ0dWFsLWRhdGEubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFtSjtBQUNqRztBQUVsRCxTQUFTYyxVQUFVQyxHQUFHLEVBQUVDLFdBQVc7SUFDakMsSUFBSUQsUUFBUSxLQUFLLEdBQUc7UUFDbEJBLE1BQU0sQ0FBQztJQUNUO0lBQ0EsSUFBSUMsZ0JBQWdCLEtBQUssR0FBRztRQUMxQkEsY0FBYztJQUNoQjtJQUNBLElBQU1DLFNBQVM7UUFDYkMsSUFBSSxDQUFDO0lBQ1A7SUFDQSxJQUFNQyxTQUFTLENBQUM7SUFDaEIsSUFBTUMsZUFBZSxDQUFDO0lBQ3RCbkIscURBQU1BLENBQUNnQixRQUFRSiwrQ0FBUUE7SUFDdkJJLE9BQU9JLFlBQVksR0FBRztJQUN0QkosT0FBT0ssSUFBSSxHQUFHO0lBQ2QsSUFBTUMsT0FBTyxDQUFDO0lBQ2QsSUFBTUMsZ0JBQWdCckIsaURBQVVBLENBQUNzQixHQUFHLENBQUNDLFNBQUFBO2VBQU9BLElBQUlDLE9BQU8sQ0FBQyxLQUFLOztJQUM3RCxJQUFNQyxXQUFXQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHZjtJQUNuQ2MsT0FBT0UsSUFBSSxDQUFDSCxVQUFVSSxPQUFPLENBQUNOLFNBQUFBO1FBQzVCLElBQUksT0FBT1gsR0FBRyxDQUFDVyxJQUFJLEtBQUssYUFBYTtRQUNyQyxJQUFJRixjQUFjUyxPQUFPLENBQUNQLFFBQVEsR0FBRztZQUNuQyxJQUFJckIscURBQVFBLENBQUNVLEdBQUcsQ0FBQ1csSUFBSSxHQUFHO2dCQUN0QlQsTUFBTSxDQUFDUyxJQUFJLEdBQUcsQ0FBQztnQkFDZk4sWUFBWSxDQUFDTSxJQUFJLEdBQUcsQ0FBQztnQkFDckJ6QixxREFBTUEsQ0FBQ2dCLE1BQU0sQ0FBQ1MsSUFBSSxFQUFFWCxHQUFHLENBQUNXLElB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LElBQUlhLFlBQVksQ0FBQ2IsSUFBSSxLQUFLeUIsU0FBUyxDQUFDekIsSUFBSSxFQUFFO2dCQUMvQzZCLE9BQU83QjtZQUNUO1FBQ0Y7SUFDRjtJQUNBLE9BQU9LO0FBQ1Q7QUFFQSxJQUFNb0Msc0JBQXNCdEIsU0FBQUE7SUFDMUIsSUFBSSxDQUFDQSxVQUFVQSxPQUFPdUIsU0FBUyxJQUFJLENBQUN2QixPQUFPNUIsTUFBTSxDQUFDb0QsT0FBTyxJQUFJeEIsT0FBTzVCLE1BQU0sQ0FBQ29ELE9BQU8sSUFBSSxDQUFDeEIsT0FBTzVCLE1BQU0sQ0FBQ29ELE9BQU8sQ0FBQ0MsT0FBTyxFQUFFO0lBQ3RIekIsT0FBTzBCLFlBQVk7SUFDbkIxQixPQUFPMkIsY0FBYztJQUNyQjNCLE9BQU80QixtQkFBbUI7SUFDMUIsSUFBSTVCLE9BQU82QixRQUFRLElBQUk3QixPQUFPNUIsTUFBTSxDQUFDeUQsUUFBUSxJQUFJN0IsT0FBTzVCLE1BQU0sQ0FBQ3lELFFBQVEsQ0FBQ0osT0FBTyxFQUFFO1FBQy9FekIsT0FBTzZCLFFBQVEsQ0FBQ0MsWUFBWTtJQUM5QjtBQUNGO0FBRTZGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zd2lwZXJAMTEuMS4zL25vZGVfbW9kdWxlcy9zd2lwZXIvc2hhcmVkL3VwZGF0ZS1vbi12aXJ0dWFsLWRhdGEubWpzPzJiNTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZSBhcyBleHRlbmQsIHAgYXMgcGFyYW1zTGlzdCwgaSBhcyBpc09iamVjdCwgbiBhcyBuZWVkc05hdmlnYXRpb24sIGEgYXMgbmVlZHNQYWdpbmF0aW9uLCBiIGFzIG5lZWRzU2Nyb2xsYmFyIH0gZnJvbSAnLi91cGRhdGUtc3dpcGVyLm1qcyc7XG5pbXBvcnQgeyBkIGFzIGRlZmF1bHRzIH0gZnJvbSAnLi9zd2lwZXItY29yZS5tanMnO1xuXG5mdW5jdGlvbiBnZXRQYXJhbXMob2JqLCBzcGxpdEV2ZW50cykge1xuICBpZiAob2JqID09PSB2b2lkIDApIHtcbiAgICBvYmogPSB7fTtcbiAgfVxuICBpZiAoc3BsaXRFdmVudHMgPT09IHZvaWQgMCkge1xuICAgIHNwbGl0RXZlbnRzID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBwYXJhbXMgPSB7XG4gICAgb246IHt9XG4gIH07XG4gIGNvbnN0IGV2ZW50cyA9IHt9O1xuICBjb25zdCBwYXNzZWRQYXJhbXMgPSB7fTtcbiAgZXh0ZW5kKHBhcmFtcywgZGVmYXVsdHMpO1xuICBwYXJhbXMuX2VtaXRDbGFzc2VzID0gdHJ1ZTtcbiAgcGFyYW1zLmluaXQgPSBmYWxzZTtcbiAgY29uc3QgcmVzdCA9IHt9O1xuICBjb25zdCBhbGxvd2VkUGFyYW1zID0gcGFyYW1zTGlzdC5tYXAoa2V5ID0+IGtleS5yZXBsYWNlKC9fLywgJycpKTtcbiAgY29uc3QgcGxhaW5PYmogPSBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xuICBPYmplY3Qua2V5cyhwbGFpbk9iaikuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgaWYgKGFsbG93ZWRQYXJhbXMuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgIGlmIChpc09iamVjdChvYmpba2V5XSkpIHtcbiAgICAgICAgcGFyYW1zW2tleV0gPSB7fTtcbiAgICAgICAgcGFzc2VkUGFyYW1zW2tleV0gPSB7fTtcbiAgICAgICAgZXh0ZW5kKHBhcmFtc1trZXldLCBvYmpba2V5XSk7XG4gICAgICAgIGV4dGVuZChwYXNzZWRQYXJhbXNba2V5XSwgb2JqW2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgcGFzc2VkUGFyYW1zW2tleV0gPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleS5zZWFyY2goL29uW0EtWl0vKSA9PT0gMCAmJiB0eXBlb2Ygb2JqW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChzcGxpdEV2ZW50cykge1xuICAgICAgICBldmVudHNbYCR7a2V5WzJdLnRvTG93ZXJDYXNlKCl9JHtrZXkuc3Vic3RyKDMpfWBdID0gb2JqW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMub25bYCR7a2V5WzJdLnRvTG93ZXJDYXNlKCl9JHtrZXkuc3Vic3RyKDMpfWBdID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3Rba2V5XSA9IG9ialtrZXldO1xuICAgIH1cbiAgfSk7XG4gIFsnbmF2aWdhdGlvbicsICdwYWdpbmF0aW9uJywgJ3Njcm9sbGJhciddLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAocGFyYW1zW2tleV0gPT09IHRydWUpIHBhcmFtc1trZXldID0ge307XG4gICAgaWYgKHBhcmFtc1trZXldID09PSBmYWxzZSkgZGVsZXRlIHBhcmFtc1trZXldO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwYXJhbXMsXG4gICAgcGFzc2VkUGFyYW1zLFxuICAgIHJlc3QsXG4gICAgZXZlbnRzXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50U3dpcGVyKF9yZWYsIHN3aXBlclBhcmFtcykge1xuICBsZXQge1xuICAgIGVsLFxuICAgIG5leHRFbCxcbiAgICBwcmV2RWwsXG4gICAgcGFnaW5hdGlvbkVsLFxuICAgIHNjcm9sbGJhckVsLFxuICAgIHN3aXBlclxuICB9ID0gX3JlZjtcbiAgaWYgKG5lZWRzTmF2aWdhdGlvbihzd2lwZXJQYXJhbXMpICYmIG5leHRFbCAmJiBwcmV2RWwpIHtcbiAgICBzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24ubmV4dEVsID0gbmV4dEVsO1xuICAgIHN3aXBlci5vcmlnaW5hbFBhcmFtcy5uYXZpZ2F0aW9uLm5leHRFbCA9IG5leHRFbDtcbiAgICBzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24ucHJldkVsID0gcHJldkVsO1xuICAgIHN3aXBlci5vcmlnaW5hbFBhcmFtcy5uYXZpZ2F0aW9uLnByZXZFbCA9IHByZXZFbDtcbiAgfVxuICBpZiAobmVlZHNQYWdpbmF0aW9uKHN3aXBlclBhcmFtcykgJiYgcGFnaW5hdGlvbkVsKSB7XG4gICAgc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmVsID0gcGFnaW5hdGlvbkVsO1xuICAgIHN3aXBlci5vcmlnaW5hbFBhcmFtcy5wYWdpbmF0aW9uLmVsID0gcGFnaW5hdGlvbkVsO1xuICB9XG4gIGlmIChuZWVkc1Njcm9sbGJhcihzd2lwZXJQYXJhbXMpICYmIHNjcm9sbGJhckVsKSB7XG4gICAgc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZWwgPSBzY3JvbGxiYXJFbDtcbiAgICBzd2lwZXIub3JpZ2luYWxQYXJhbXMuc2Nyb2xsYmFyLmVsID0gc2Nyb2xsYmFyRWw7XG4gIH1cbiAgc3dpcGVyLmluaXQoZWwpO1xufVxuXG5mdW5jdGlvbiBnZXRDaGFuZ2VkUGFyYW1zKHN3aXBlclBhcmFtcywgb2xkUGFyYW1zLCBjaGlsZHJlbiwgb2xkQ2hpbGRyZW4sIGdldEtleSkge1xuICBjb25zdCBrZXlzID0gW107XG4gIGlmICghb2xkUGFyYW1zKSByZXR1cm4ga2V5cztcbiAgY29uc3QgYWRkS2V5ID0ga2V5ID0+IHtcbiAgICBpZiAoa2V5cy5pbmRleE9mKGtleSkgPCAwKSBrZXlzLnB1c2goa2V5KTtcbiAgfTtcbiAgaWYgKGNoaWxkcmVuICYmIG9sZENoaWxkcmVuKSB7XG4gICAgY29uc3Qgb2xkQ2hpbGRyZW5LZXlzID0gb2xkQ2hpbGRyZW4ubWFwKGdldEtleSk7XG4gICAgY29uc3QgY2hpbGRyZW5LZXlzID0gY2hpbGRyZW4ubWFwKGdldEtleSk7XG4gICAgaWYgKG9sZENoaWxkcmVuS2V5cy5qb2luKCcnKSAhPT0gY2hpbGRyZW5LZXlzLmpvaW4oJycpKSBhZGRLZXkoJ2NoaWxkcmVuJyk7XG4gICAgaWYgKG9sZENoaWxkcmVuLmxlbmd0aCAhPT0gY2hpbGRyZW4ubGVuZ3RoKSBhZGRLZXkoJ2NoaWxkcmVuJyk7XG4gIH1cbiAgY29uc3Qgd2F0Y2hQYXJhbXMgPSBwYXJhbXNMaXN0LmZpbHRlcihrZXkgPT4ga2V5WzBdID09PSAnXycpLm1hcChrZXkgPT4ga2V5LnJlcGxhY2UoL18vLCAnJykpO1xuICB3YXRjaFBhcmFtcy5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKGtleSBpbiBzd2lwZXJQYXJhbXMgJiYga2V5IGluIG9sZFBhcmFtcykge1xuICAgICAgaWYgKGlzT2JqZWN0KHN3aXBlclBhcmFtc1trZXldKSAmJiBpc09iamVjdChvbGRQYXJhbXNba2V5XSkpIHtcbiAgICAgICAgY29uc3QgbmV3S2V5cyA9IE9iamVjdC5rZXlzKHN3aXBlclBhcmFtc1trZXldKTtcbiAgICAgICAgY29uc3Qgb2xkS2V5cyA9IE9iamVjdC5rZXlzKG9sZFBhcmFtc1trZXldKTtcbiAgICAgICAgaWYgKG5ld0tleXMubGVuZ3RoICE9PSBvbGRLZXlzLmxlbmd0aCkge1xuICAgICAgICAgIGFkZEtleShrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0tleXMuZm9yRWFjaChuZXdLZXkgPT4ge1xuICAgICAgICAgICAgaWYgKHN3aXBlclBhcmFtc1trZXldW25ld0tleV0gIT09IG9sZFBhcmFtc1trZXldW25ld0tleV0pIHtcbiAgICAgICAgICAgICAgYWRkS2V5KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgb2xkS2V5cy5mb3JFYWNoKG9sZEtleSA9PiB7XG4gICAgICAgICAgICBpZiAoc3dpcGVyUGFyYW1zW2tleV1bb2xkS2V5XSAhPT0gb2xkUGFyYW1zW2tleV1bb2xkS2V5XSkgYWRkS2V5KGtleSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3dpcGVyUGFyYW1zW2tleV0gIT09IG9sZFBhcmFtc1trZXldKSB7XG4gICAgICAgIGFkZEtleShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBrZXlzO1xufVxuXG5jb25zdCB1cGRhdGVPblZpcnR1YWxEYXRhID0gc3dpcGVyID0+IHtcbiAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLnBhcmFtcy52aXJ0dWFsIHx8IHN3aXBlci5wYXJhbXMudmlydHVhbCAmJiAhc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHJldHVybjtcbiAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoKTtcbiAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgaWYgKHN3aXBlci5wYXJhbGxheCAmJiBzd2lwZXIucGFyYW1zLnBhcmFsbGF4ICYmIHN3aXBlci5wYXJhbXMucGFyYWxsYXguZW5hYmxlZCkge1xuICAgIHN3aXBlci5wYXJhbGxheC5zZXRUcmFuc2xhdGUoKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgZ2V0Q2hhbmdlZFBhcmFtcyBhcyBhLCBnZXRQYXJhbXMgYXMgZywgbW91bnRTd2lwZXIgYXMgbSwgdXBkYXRlT25WaXJ0dWFsRGF0YSBhcyB1IH07XG4iXSwibmFtZXMiOlsiZSIsImV4dGVuZCIsInAiLCJwYXJhbXNMaXN0IiwiaSIsImlzT2JqZWN0IiwibiIsIm5lZWRzTmF2aWdhdGlvbiIsImEiLCJuZWVkc1BhZ2luYXRpb24iLCJiIiwibmVlZHNTY3JvbGxiYXIiLCJkIiwiZGVmYXVsdHMiLCJnZXRQYXJhbXMiLCJvYmoiLCJzcGxpdEV2ZW50cyIsInBhcmFtcyIsIm9uIiwiZXZlbnRzIiwicGFzc2VkUGFyYW1zIiwiX2VtaXRDbGFzc2VzIiwiaW5pdCIsInJlc3QiLCJhbGxvd2VkUGFyYW1zIiwibWFwIiwia2V5IiwicmVwbGFjZSIsInBsYWluT2JqIiwiT2JqZWN0IiwiYXNzaWduIiwia2V5cyIsImZvckVhY2giLCJpbmRleE9mIiwic2VhcmNoIiwidG9Mb3dlckNhc2UiLCJzdWJzdHIiLCJtb3VudFN3aXBlciIsIl9yZWYiLCJzd2lwZXJQYXJhbXMiLCJlbCIsIm5leHRFbCIsInByZXZFbCIsInBhZ2luYXRpb25FbCIsInNjcm9sbGJhckVsIiwic3dpcGVyIiwibmF2aWdhdGlvbiIsIm9yaWdpbmFsUGFyYW1zIiwicGFnaW5hdGlvbiIsInNjcm9sbGJhciIsImdldENoYW5nZWRQYXJhbXMiLCJvbGRQYXJhbXMiLCJjaGlsZHJlbiIsIm9sZENoaWxkcmVuIiwiZ2V0S2V5IiwiYWRkS2V5IiwicHVzaCIsIm9sZENoaWxkcmVuS2V5cyIsImNoaWxkcmVuS2V5cyIsImpvaW4iLCJsZW5ndGgiLCJ3YXRjaFBhcmFtcyIsImZpbHRlciIsIm5ld0tleXMiLCJvbGRLZXlzIiwibmV3S2V5Iiwib2xkS2V5IiwidXBkYXRlT25WaXJ0dWFsRGF0YSIsImRlc3Ryb3llZCIsInZpcnR1YWwiLCJlbmFibGVkIiwidXBkYXRlU2xpZGVzIiwidXBkYXRlUHJvZ3Jlc3MiLCJ1cGRhdGVTbGlkZXNDbGFzc2VzIiwicGFyYWxsYXgiLCJzZXRUcmFuc2xhdGUiLCJnIiwibSIsInUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/update-on-virtual-data.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/update-swiper.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/update-swiper.mjs ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: function() { return /* binding */ needsPagination; },\n/* harmony export */   b: function() { return /* binding */ needsScrollbar; },\n/* harmony export */   c: function() { return /* binding */ attrToProp; },\n/* harmony export */   d: function() { return /* binding */ uniqueClasses; },\n/* harmony export */   e: function() { return /* binding */ extend; },\n/* harmony export */   i: function() { return /* binding */ isObject; },\n/* harmony export */   n: function() { return /* binding */ needsNavigation; },\n/* harmony export */   p: function() { return /* binding */ paramsList; },\n/* harmony export */   u: function() { return /* binding */ updateSwiper; },\n/* harmony export */   w: function() { return /* binding */ wrapperClass; }\n/* harmony export */ });\n/* underscore in name -> watch for changes */ var paramsList = [\n    \"eventsPrefix\",\n    \"injectStyles\",\n    \"injectStylesUrls\",\n    \"modules\",\n    \"init\",\n    \"_direction\",\n    \"oneWayMovement\",\n    \"swiperElementNodeName\",\n    \"touchEventsTarget\",\n    \"initialSlide\",\n    \"_speed\",\n    \"cssMode\",\n    \"updateOnWindowResize\",\n    \"resizeObserver\",\n    \"nested\",\n    \"focusableElements\",\n    \"_enabled\",\n    \"_width\",\n    \"_height\",\n    \"preventInteractionOnTransition\",\n    \"userAgent\",\n    \"url\",\n    \"_edgeSwipeDetection\",\n    \"_edgeSwipeThreshold\",\n    \"_freeMode\",\n    \"_autoHeight\",\n    \"setWrapperSize\",\n    \"virtualTranslate\",\n    \"_effect\",\n    \"breakpoints\",\n    \"breakpointsBase\",\n    \"_spaceBetween\",\n    \"_slidesPerView\",\n    \"maxBackfaceHiddenSlides\",\n    \"_grid\",\n    \"_slidesPerGroup\",\n    \"_slidesPerGroupSkip\",\n    \"_slidesPerGroupAuto\",\n    \"_centeredSlides\",\n    \"_centeredSlidesBounds\",\n    \"_slidesOffsetBefore\",\n    \"_slidesOffsetAfter\",\n    \"normalizeSlideIndex\",\n    \"_centerInsufficientSlides\",\n    \"_watchOverflow\",\n    \"roundLengths\",\n    \"touchRatio\",\n    \"touchAngle\",\n    \"simulateTouch\",\n    \"_shortSwipes\",\n    \"_longSwipes\",\n    \"longSwipesRatio\",\n    \"longSwipesMs\",\n    \"_followFinger\",\n    \"allowTouchMove\",\n    \"_threshold\",\n    \"touchMoveStopPropagation\",\n    \"touchStartPreventDefault\",\n    \"touchStartForcePreventDefault\",\n    \"touchReleaseOnEdges\",\n    \"uniqueNavElements\",\n    \"_resistance\",\n    \"_resistanceRatio\",\n    \"_watchSlidesProgress\",\n    \"_grabCursor\",\n    \"preventClicks\",\n    \"preventClicksPropagation\",\n    \"_slideToClickedSlide\",\n    \"_loop\",\n    \"loopAdditionalSlides\",\n    \"loopAddBlankSlides\",\n    \"loopPreventsSliding\",\n    \"_rewind\",\n    \"_allowSlidePrev\",\n    \"_allowSlideNext\",\n    \"_swipeHandler\",\n    \"_noSwiping\",\n    \"noSwipingClass\",\n    \"noSwipingSelector\",\n    \"passiveListeners\",\n    \"containerModifierClass\",\n    \"slideClass\",\n    \"slideActiveClass\",\n    \"slideVisibleClass\",\n    \"slideFullyVisibleClass\",\n    \"slideNextClass\",\n    \"slidePrevClass\",\n    \"slideBlankClass\",\n    \"wrapperClass\",\n    \"lazyPreloaderClass\",\n    \"lazyPreloadPrevNext\",\n    \"runCallbacksOnInit\",\n    \"observer\",\n    \"observeParents\",\n    \"observeSlideChildren\",\n    // modules\n    \"a11y\",\n    \"_autoplay\",\n    \"_controller\",\n    \"coverflowEffect\",\n    \"cubeEffect\",\n    \"fadeEffect\",\n    \"flipEffect\",\n    \"creativeEffect\",\n    \"cardsEffect\",\n    \"hashNavigation\",\n    \"history\",\n    \"keyboard\",\n    \"mousewheel\",\n    \"_navigation\",\n    \"_pagination\",\n    \"parallax\",\n    \"_scrollbar\",\n    \"_thumbs\",\n    \"virtual\",\n    \"zoom\",\n    \"control\"\n];\nfunction isObject(o) {\n    return typeof o === \"object\" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === \"Object\" && !o.__swiper__;\n}\nfunction extend(target, src) {\n    var noExtend = [\n        \"__proto__\",\n        \"constructor\",\n        \"prototype\"\n    ];\n    Object.keys(src).filter(function(key) {\n        return noExtend.indexOf(key) < 0;\n    }).forEach(function(key) {\n        if (typeof target[key] === \"undefined\") target[key] = src[key];\n        else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {\n            if (src[key].__swiper__) target[key] = src[key];\n            else extend(target[key], src[key]);\n        } else {\n            target[key] = src[key];\n        }\n    });\n}\nfunction needsNavigation(params) {\n    if (params === void 0) {\n        params = {};\n    }\n    return params.navigation && typeof params.navigation.nextEl === \"undefined\" && typeof params.navigation.prevEl === \"undefined\";\n}\nfunction needsPagination(params) {\n    if (params === void 0) {\n        params = {};\n    }\n    return params.pagination && typeof params.pagination.el === \"undefined\";\n}\nfunction needsScrollbar(params) {\n    if (params === void 0) {\n        params = {};\n    }\n    return params.scrollbar && typeof params.scrollbar.el === \"undefined\";\n}\nfunction uniqueClasses(classNames) {\n    if (classNames === void 0) {\n        classNames = \"\";\n    }\n    var classes = classNames.split(\" \").map(function(c) {\n        return c.trim();\n    }).filter(function(c) {\n        return !!c;\n    });\n    var unique = [];\n    classes.forEach(function(c) {\n        if (unique.indexOf(c) < 0) unique.push(c);\n    });\n    return unique.join(\" \");\n}\nfunction attrToProp(attrName) {\n    if (attrName === void 0) {\n        attrName = \"\";\n    }\n    return attrName.replace(/-[a-z]/g, function(l) {\n        return l.toUpperCase().replace(\"-\", \"\");\n    });\n}\nfunction wrapperClass(className) {\n    if (className === void 0) {\n        className = \"\";\n    }\n    if (!className) return \"swiper-wrapper\";\n    if (!className.includes(\"swiper-wrapper\")) return \"swiper-wrapper \".concat(className);\n    return className;\n}\nfunction updateSwiper(_ref) {\n    var swiper = _ref.swiper, slides = _ref.slides, passedParams = _ref.passedParams, changedParams = _ref.changedParams, nextEl = _ref.nextEl, prevEl = _ref.prevEl, scrollbarEl = _ref.scrollbarEl, paginationEl = _ref.paginationEl;\n    var updateParams = changedParams.filter(function(key) {\n        return key !== \"children\" && key !== \"direction\" && key !== \"wrapperClass\";\n    });\n    var currentParams = swiper.params, pagination = swiper.pagination, navigation = swiper.navigation, scrollbar = swiper.scrollbar, virtual = swiper.virtual, thumbs = swiper.thumbs;\n    var needThumbsInit;\n    var needControllerInit;\n    var needPaginationInit;\n    var needScrollbarInit;\n    var needNavigationInit;\n    var loopNeedDestroy;\n    var loopNeedEnable;\n    var loopNeedReloop;\n    if (changedParams.includes(\"thumbs\") && passedParams.thumbs && passedParams.thumbs.swiper && currentParams.thumbs && !currentParams.thumbs.swiper) {\n        needThumbsInit = true;\n    }\n    if (changedParams.includes(\"controller\") && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {\n        needControllerInit = true;\n    }\n    if (changedParams.includes(\"pagination\") && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {\n        needPaginationInit = true;\n    }\n    if (changedParams.includes(\"scrollbar\") && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {\n        needScrollbarInit = true;\n    }\n    if (changedParams.includes(\"navigation\") && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {\n        needNavigationInit = true;\n    }\n    var destroyModule = function(mod) {\n        if (!swiper[mod]) return;\n        swiper[mod].destroy();\n        if (mod === \"navigation\") {\n            if (swiper.isElement) {\n                swiper[mod].prevEl.remove();\n                swiper[mod].nextEl.remove();\n            }\n            currentParams[mod].prevEl = undefined;\n            currentParams[mod].nextEl = undefined;\n            swiper[mod].prevEl = undefined;\n            swiper[mod].nextEl = undefined;\n        } else {\n            if (swiper.isElement) {\n                swiper[mod].el.remove();\n            }\n            currentParams[mod].el = undefined;\n            swiper[mod].el = undefined;\n        }\n    };\n    if (changedParams.includes(\"loop\") && swiper.isElement) {\n        if (currentParams.loop && !passedParams.loop) {\n            loopNeedDestroy = true;\n        } else if (!currentParams.loop && passedParams.loop) {\n            loopNeedEnable = true;\n        } else {\n            loopNeedReloop = true;\n        }\n    }\n    updateParams.forEach(function(key) {\n        if (isObject(currentParams[key]) && isObject(passedParams[key])) {\n            Object.assign(currentParams[key], passedParams[key]);\n            if ((key === \"navigation\" || key === \"pagination\" || key === \"scrollbar\") && \"enabled\" in passedParams[key] && !passedParams[key].enabled) {\n                destroyModule(key);\n            }\n        } else {\n            var newValue = passedParams[key];\n            if ((newValue === true || newValue === false) && (key === \"navigation\" || key === \"pagination\" || key === \"scrollbar\")) {\n                if (newValue === false) {\n                    destroyModule(key);\n                }\n            } else {\n                currentParams[key] = passedParams[key];\n            }\n        }\n    });\n    if (updateParams.includes(\"controller\") && !needControllerInit && swiper.controller && swiper.controller.control && currentParams.controller && currentParams.controller.control) {\n        swiper.controller.control = currentParams.controller.control;\n    }\n    if (changedParams.includes(\"children\") && slides && virtual && currentParams.virtual.enabled) {\n        virtual.slides = slides;\n        virtual.update(true);\n    } else if (changedParams.includes(\"virtual\") && virtual && currentParams.virtual.enabled) {\n        if (slides) virtual.slides = slides;\n        virtual.update(true);\n    }\n    if (changedParams.includes(\"children\") && slides && currentParams.loop) {\n        loopNeedReloop = true;\n    }\n    if (needThumbsInit) {\n        var initialized = thumbs.init();\n        if (initialized) thumbs.update(true);\n    }\n    if (needControllerInit) {\n        swiper.controller.control = currentParams.controller.control;\n    }\n    if (needPaginationInit) {\n        if (swiper.isElement && (!paginationEl || typeof paginationEl === \"string\")) {\n            paginationEl = document.createElement(\"div\");\n            paginationEl.classList.add(\"swiper-pagination\");\n            paginationEl.part.add(\"pagination\");\n            swiper.el.appendChild(paginationEl);\n        }\n        if (paginationEl) currentParams.pagination.el = paginationEl;\n        pagination.init();\n        pagination.render();\n        pagination.update();\n    }\n    if (needScrollbarInit) {\n        if (swiper.isElement && (!scrollbarEl || typeof scrollbarEl === \"string\")) {\n            scrollbarEl = document.createElement(\"div\");\n            scrollbarEl.classList.add(\"swiper-scrollbar\");\n            scrollbarEl.part.add(\"scrollbar\");\n            swiper.el.appendChild(scrollbarEl);\n        }\n        if (scrollbarEl) currentParams.scrollbar.el = scrollbarEl;\n        scrollbar.init();\n        scrollbar.updateSize();\n        scrollbar.setTranslate();\n    }\n    if (needNavigationInit) {\n        if (swiper.isElement) {\n            if (!nextEl || typeof nextEl === \"string\") {\n                nextEl = document.createElement(\"div\");\n                nextEl.classList.add(\"swiper-button-next\");\n                nextEl.innerHTML = swiper.hostEl.constructor.nextButtonSvg;\n                nextEl.part.add(\"button-next\");\n                swiper.el.appendChild(nextEl);\n            }\n            if (!prevEl || typeof prevEl === \"string\") {\n                prevEl = document.createElement(\"div\");\n                prevEl.classList.add(\"swiper-button-prev\");\n                prevEl.innerHTML = swiper.hostEl.constructor.prevButtonSvg;\n                prevEl.part.add(\"button-prev\");\n                swiper.el.appendChild(prevEl);\n            }\n        }\n        if (nextEl) currentParams.navigation.nextEl = nextEl;\n        if (prevEl) currentParams.navigation.prevEl = prevEl;\n        navigation.init();\n        navigation.update();\n    }\n    if (changedParams.includes(\"allowSlideNext\")) {\n        swiper.allowSlideNext = passedParams.allowSlideNext;\n    }\n    if (changedParams.includes(\"allowSlidePrev\")) {\n        swiper.allowSlidePrev = passedParams.allowSlidePrev;\n    }\n    if (changedParams.includes(\"direction\")) {\n        swiper.changeDirection(passedParams.direction, false);\n    }\n    if (loopNeedDestroy || loopNeedReloop) {\n        swiper.loopDestroy();\n    }\n    if (loopNeedEnable || loopNeedReloop) {\n        swiper.loopCreate();\n    }\n    swiper.update();\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zd2lwZXJAMTEuMS4zL25vZGVfbW9kdWxlcy9zd2lwZXIvc2hhcmVkL3VwZGF0ZS1zd2lwZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBMkMsR0FDM0MsSUFBTUEsYUFBYTtJQUFDO0lBQWdCO0lBQWdCO0lBQW9CO0lBQVc7SUFBUTtJQUFjO0lBQWtCO0lBQXlCO0lBQXFCO0lBQWdCO0lBQVU7SUFBVztJQUF3QjtJQUFrQjtJQUFVO0lBQXFCO0lBQVk7SUFBVTtJQUFXO0lBQWtDO0lBQWE7SUFBTztJQUF1QjtJQUF1QjtJQUFhO0lBQWU7SUFBa0I7SUFBb0I7SUFBVztJQUFlO0lBQW1CO0lBQWlCO0lBQWtCO0lBQTJCO0lBQVM7SUFBbUI7SUFBdUI7SUFBdUI7SUFBbUI7SUFBeUI7SUFBdUI7SUFBc0I7SUFBdUI7SUFBNkI7SUFBa0I7SUFBZ0I7SUFBYztJQUFjO0lBQWlCO0lBQWdCO0lBQWU7SUFBbUI7SUFBZ0I7SUFBaUI7SUFBa0I7SUFBYztJQUE0QjtJQUE0QjtJQUFpQztJQUF1QjtJQUFxQjtJQUFlO0lBQW9CO0lBQXdCO0lBQWU7SUFBaUI7SUFBNEI7SUFBd0I7SUFBUztJQUF3QjtJQUFzQjtJQUF1QjtJQUFXO0lBQW1CO0lBQW1CO0lBQWlCO0lBQWM7SUFBa0I7SUFBcUI7SUFBb0I7SUFBMEI7SUFBYztJQUFvQjtJQUFxQjtJQUEwQjtJQUFrQjtJQUFrQjtJQUFtQjtJQUFnQjtJQUFzQjtJQUF1QjtJQUFzQjtJQUFZO0lBQWtCO0lBQ2x1RCxVQUFVO0lBQ1Y7SUFBUTtJQUFhO0lBQWU7SUFBbUI7SUFBYztJQUFjO0lBQWM7SUFBa0I7SUFBZTtJQUFrQjtJQUFXO0lBQVk7SUFBYztJQUFlO0lBQWU7SUFBWTtJQUFjO0lBQVc7SUFBVztJQUFRO0NBQVU7QUFFelIsU0FBU0MsU0FBU0MsQ0FBQztJQUNqQixPQUFPLE9BQU9BLE1BQU0sWUFBWUEsTUFBTSxR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QDExLjEuMy9ub2RlX21vZHVsZXMvc3dpcGVyL3NoYXJlZC91cGRhdGUtc3dpcGVyLm1qcz9mNzdlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIHVuZGVyc2NvcmUgaW4gbmFtZSAtPiB3YXRjaCBmb3IgY2hhbmdlcyAqL1xuY29uc3QgcGFyYW1zTGlzdCA9IFsnZXZlbnRzUHJlZml4JywgJ2luamVjdFN0eWxlcycsICdpbmplY3RTdHlsZXNVcmxzJywgJ21vZHVsZXMnLCAnaW5pdCcsICdfZGlyZWN0aW9uJywgJ29uZVdheU1vdmVtZW50JywgJ3N3aXBlckVsZW1lbnROb2RlTmFtZScsICd0b3VjaEV2ZW50c1RhcmdldCcsICdpbml0aWFsU2xpZGUnLCAnX3NwZWVkJywgJ2Nzc01vZGUnLCAndXBkYXRlT25XaW5kb3dSZXNpemUnLCAncmVzaXplT2JzZXJ2ZXInLCAnbmVzdGVkJywgJ2ZvY3VzYWJsZUVsZW1lbnRzJywgJ19lbmFibGVkJywgJ193aWR0aCcsICdfaGVpZ2h0JywgJ3ByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbicsICd1c2VyQWdlbnQnLCAndXJsJywgJ19lZGdlU3dpcGVEZXRlY3Rpb24nLCAnX2VkZ2VTd2lwZVRocmVzaG9sZCcsICdfZnJlZU1vZGUnLCAnX2F1dG9IZWlnaHQnLCAnc2V0V3JhcHBlclNpemUnLCAndmlydHVhbFRyYW5zbGF0ZScsICdfZWZmZWN0JywgJ2JyZWFrcG9pbnRzJywgJ2JyZWFrcG9pbnRzQmFzZScsICdfc3BhY2VCZXR3ZWVuJywgJ19zbGlkZXNQZXJWaWV3JywgJ21heEJhY2tmYWNlSGlkZGVuU2xpZGVzJywgJ19ncmlkJywgJ19zbGlkZXNQZXJHcm91cCcsICdfc2xpZGVzUGVyR3JvdXBTa2lwJywgJ19zbGlkZXNQZXJHcm91cEF1dG8nLCAnX2NlbnRlcmVkU2xpZGVzJywgJ19jZW50ZXJlZFNsaWRlc0JvdW5kcycsICdfc2xpZGVzT2Zmc2V0QmVmb3JlJywgJ19zbGlkZXNPZmZzZXRBZnRlcicsICdub3JtYWxpemVTbGlkZUluZGV4JywgJ19jZW50ZXJJbnN1ZmZpY2llbnRTbGlkZXMnLCAnX3dhdGNoT3ZlcmZsb3cnLCAncm91bmRMZW5ndGhzJywgJ3RvdWNoUmF0aW8nLCAndG91Y2hBbmdsZScsICdzaW11bGF0ZVRvdWNoJywgJ19zaG9ydFN3aXBlcycsICdfbG9uZ1N3aXBlcycsICdsb25nU3dpcGVzUmF0aW8nLCAnbG9uZ1N3aXBlc01zJywgJ19mb2xsb3dGaW5nZXInLCAnYWxsb3dUb3VjaE1vdmUnLCAnX3RocmVzaG9sZCcsICd0b3VjaE1vdmVTdG9wUHJvcGFnYXRpb24nLCAndG91Y2hTdGFydFByZXZlbnREZWZhdWx0JywgJ3RvdWNoU3RhcnRGb3JjZVByZXZlbnREZWZhdWx0JywgJ3RvdWNoUmVsZWFzZU9uRWRnZXMnLCAndW5pcXVlTmF2RWxlbWVudHMnLCAnX3Jlc2lzdGFuY2UnLCAnX3Jlc2lzdGFuY2VSYXRpbycsICdfd2F0Y2hTbGlkZXNQcm9ncmVzcycsICdfZ3JhYkN1cnNvcicsICdwcmV2ZW50Q2xpY2tzJywgJ3ByZXZlbnRDbGlja3NQcm9wYWdhdGlvbicsICdfc2xpZGVUb0NsaWNrZWRTbGlkZScsICdfbG9vcCcsICdsb29wQWRkaXRpb25hbFNsaWRlcycsICdsb29wQWRkQmxhbmtTbGlkZXMnLCAnbG9vcFByZXZlbnRzU2xpZGluZycsICdfcmV3aW5kJywgJ19hbGxvd1NsaWRlUHJldicsICdfYWxsb3dTbGlkZU5leHQnLCAnX3N3aXBlSGFuZGxlcicsICdfbm9Td2lwaW5nJywgJ25vU3dpcGluZ0NsYXNzJywgJ25vU3dpcGluZ1NlbGVjdG9yJywgJ3Bhc3NpdmVMaXN0ZW5lcnMnLCAnY29udGFpbmVyTW9kaWZpZXJDbGFzcycsICdzbGlkZUNsYXNzJywgJ3NsaWRlQWN0aXZlQ2xhc3MnLCAnc2xpZGVWaXNpYmxlQ2xhc3MnLCAnc2xpZGVGdWxseVZpc2libGVDbGFzcycsICdzbGlkZU5leHRDbGFzcycsICdzbGlkZVByZXZDbGFzcycsICdzbGlkZUJsYW5rQ2xhc3MnLCAnd3JhcHBlckNsYXNzJywgJ2xhenlQcmVsb2FkZXJDbGFzcycsICdsYXp5UHJlbG9hZFByZXZOZXh0JywgJ3J1bkNhbGxiYWNrc09uSW5pdCcsICdvYnNlcnZlcicsICdvYnNlcnZlUGFyZW50cycsICdvYnNlcnZlU2xpZGVDaGlsZHJlbicsXG4vLyBtb2R1bGVzXG4nYTExeScsICdfYXV0b3BsYXknLCAnX2NvbnRyb2xsZXInLCAnY292ZXJmbG93RWZmZWN0JywgJ2N1YmVFZmZlY3QnLCAnZmFkZUVmZmVjdCcsICdmbGlwRWZmZWN0JywgJ2NyZWF0aXZlRWZmZWN0JywgJ2NhcmRzRWZmZWN0JywgJ2hhc2hOYXZpZ2F0aW9uJywgJ2hpc3RvcnknLCAna2V5Ym9hcmQnLCAnbW91c2V3aGVlbCcsICdfbmF2aWdhdGlvbicsICdfcGFnaW5hdGlvbicsICdwYXJhbGxheCcsICdfc2Nyb2xsYmFyJywgJ190aHVtYnMnLCAndmlydHVhbCcsICd6b29tJywgJ2NvbnRyb2wnXTtcblxuZnVuY3Rpb24gaXNPYmplY3Qobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIG8gIT09IG51bGwgJiYgby5jb25zdHJ1Y3RvciAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpID09PSAnT2JqZWN0JyAmJiAhby5fX3N3aXBlcl9fO1xufVxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc3JjKSB7XG4gIGNvbnN0IG5vRXh0ZW5kID0gWydfX3Byb3RvX18nLCAnY29uc3RydWN0b3InLCAncHJvdG90eXBlJ107XG4gIE9iamVjdC5rZXlzKHNyYykuZmlsdGVyKGtleSA9PiBub0V4dGVuZC5pbmRleE9mKGtleSkgPCAwKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXRba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHRhcmdldFtrZXldID0gc3JjW2tleV07ZWxzZSBpZiAoaXNPYmplY3Qoc3JjW2tleV0pICYmIGlzT2JqZWN0KHRhcmdldFtrZXldKSAmJiBPYmplY3Qua2V5cyhzcmNba2V5XSkubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHNyY1trZXldLl9fc3dpcGVyX18pIHRhcmdldFtrZXldID0gc3JjW2tleV07ZWxzZSBleHRlbmQodGFyZ2V0W2tleV0sIHNyY1trZXldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbmVlZHNOYXZpZ2F0aW9uKHBhcmFtcykge1xuICBpZiAocGFyYW1zID09PSB2b2lkIDApIHtcbiAgICBwYXJhbXMgPSB7fTtcbiAgfVxuICByZXR1cm4gcGFyYW1zLm5hdmlnYXRpb24gJiYgdHlwZW9mIHBhcmFtcy5uYXZpZ2F0aW9uLm5leHRFbCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBhcmFtcy5uYXZpZ2F0aW9uLnByZXZFbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBuZWVkc1BhZ2luYXRpb24ocGFyYW1zKSB7XG4gIGlmIChwYXJhbXMgPT09IHZvaWQgMCkge1xuICAgIHBhcmFtcyA9IHt9O1xuICB9XG4gIHJldHVybiBwYXJhbXMucGFnaW5hdGlvbiAmJiB0eXBlb2YgcGFyYW1zLnBhZ2luYXRpb24uZWwgPT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gbmVlZHNTY3JvbGxiYXIocGFyYW1zKSB7XG4gIGlmIChwYXJhbXMgPT09IHZvaWQgMCkge1xuICAgIHBhcmFtcyA9IHt9O1xuICB9XG4gIHJldHVybiBwYXJhbXMuc2Nyb2xsYmFyICYmIHR5cGVvZiBwYXJhbXMuc2Nyb2xsYmFyLmVsID09PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIHVuaXF1ZUNsYXNzZXMoY2xhc3NOYW1lcykge1xuICBpZiAoY2xhc3NOYW1lcyA9PT0gdm9pZCAwKSB7XG4gICAgY2xhc3NOYW1lcyA9ICcnO1xuICB9XG4gIGNvbnN0IGNsYXNzZXMgPSBjbGFzc05hbWVzLnNwbGl0KCcgJykubWFwKGMgPT4gYy50cmltKCkpLmZpbHRlcihjID0+ICEhYyk7XG4gIGNvbnN0IHVuaXF1ZSA9IFtdO1xuICBjbGFzc2VzLmZvckVhY2goYyA9PiB7XG4gICAgaWYgKHVuaXF1ZS5pbmRleE9mKGMpIDwgMCkgdW5pcXVlLnB1c2goYyk7XG4gIH0pO1xuICByZXR1cm4gdW5pcXVlLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIGF0dHJUb1Byb3AoYXR0ck5hbWUpIHtcbiAgaWYgKGF0dHJOYW1lID09PSB2b2lkIDApIHtcbiAgICBhdHRyTmFtZSA9ICcnO1xuICB9XG4gIHJldHVybiBhdHRyTmFtZS5yZXBsYWNlKC8tW2Etel0vZywgbCA9PiBsLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgnLScsICcnKSk7XG59XG5mdW5jdGlvbiB3cmFwcGVyQ2xhc3MoY2xhc3NOYW1lKSB7XG4gIGlmIChjbGFzc05hbWUgPT09IHZvaWQgMCkge1xuICAgIGNsYXNzTmFtZSA9ICcnO1xuICB9XG4gIGlmICghY2xhc3NOYW1lKSByZXR1cm4gJ3N3aXBlci13cmFwcGVyJztcbiAgaWYgKCFjbGFzc05hbWUuaW5jbHVkZXMoJ3N3aXBlci13cmFwcGVyJykpIHJldHVybiBgc3dpcGVyLXdyYXBwZXIgJHtjbGFzc05hbWV9YDtcbiAgcmV0dXJuIGNsYXNzTmFtZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3dpcGVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgc2xpZGVzLFxuICAgIHBhc3NlZFBhcmFtcyxcbiAgICBjaGFuZ2VkUGFyYW1zLFxuICAgIG5leHRFbCxcbiAgICBwcmV2RWwsXG4gICAgc2Nyb2xsYmFyRWwsXG4gICAgcGFnaW5hdGlvbkVsXG4gIH0gPSBfcmVmO1xuICBjb25zdCB1cGRhdGVQYXJhbXMgPSBjaGFuZ2VkUGFyYW1zLmZpbHRlcihrZXkgPT4ga2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2RpcmVjdGlvbicgJiYga2V5ICE9PSAnd3JhcHBlckNsYXNzJyk7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXM6IGN1cnJlbnRQYXJhbXMsXG4gICAgcGFnaW5hdGlvbixcbiAgICBuYXZpZ2F0aW9uLFxuICAgIHNjcm9sbGJhcixcbiAgICB2aXJ0dWFsLFxuICAgIHRodW1ic1xuICB9ID0gc3dpcGVyO1xuICBsZXQgbmVlZFRodW1ic0luaXQ7XG4gIGxldCBuZWVkQ29udHJvbGxlckluaXQ7XG4gIGxldCBuZWVkUGFnaW5hdGlvbkluaXQ7XG4gIGxldCBuZWVkU2Nyb2xsYmFySW5pdDtcbiAgbGV0IG5lZWROYXZpZ2F0aW9uSW5pdDtcbiAgbGV0IGxvb3BOZWVkRGVzdHJveTtcbiAgbGV0IGxvb3BOZWVkRW5hYmxlO1xuICBsZXQgbG9vcE5lZWRSZWxvb3A7XG4gIGlmIChjaGFuZ2VkUGFyYW1zLmluY2x1ZGVzKCd0aHVtYnMnKSAmJiBwYXNzZWRQYXJhbXMudGh1bWJzICYmIHBhc3NlZFBhcmFtcy50aHVtYnMuc3dpcGVyICYmIGN1cnJlbnRQYXJhbXMudGh1bWJzICYmICFjdXJyZW50UGFyYW1zLnRodW1icy5zd2lwZXIpIHtcbiAgICBuZWVkVGh1bWJzSW5pdCA9IHRydWU7XG4gIH1cbiAgaWYgKGNoYW5nZWRQYXJhbXMuaW5jbHVkZXMoJ2NvbnRyb2xsZXInKSAmJiBwYXNzZWRQYXJhbXMuY29udHJvbGxlciAmJiBwYXNzZWRQYXJhbXMuY29udHJvbGxlci5jb250cm9sICYmIGN1cnJlbnRQYXJhbXMuY29udHJvbGxlciAmJiAhY3VycmVudFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2wpIHtcbiAgICBuZWVkQ29udHJvbGxlckluaXQgPSB0cnVlO1xuICB9XG4gIGlmIChjaGFuZ2VkUGFyYW1zLmluY2x1ZGVzKCdwYWdpbmF0aW9uJykgJiYgcGFzc2VkUGFyYW1zLnBhZ2luYXRpb24gJiYgKHBhc3NlZFBhcmFtcy5wYWdpbmF0aW9uLmVsIHx8IHBhZ2luYXRpb25FbCkgJiYgKGN1cnJlbnRQYXJhbXMucGFnaW5hdGlvbiB8fCBjdXJyZW50UGFyYW1zLnBhZ2luYXRpb24gPT09IGZhbHNlKSAmJiBwYWdpbmF0aW9uICYmICFwYWdpbmF0aW9uLmVsKSB7XG4gICAgbmVlZFBhZ2luYXRpb25Jbml0ID0gdHJ1ZTtcbiAgfVxuICBpZiAoY2hhbmdlZFBhcmFtcy5pbmNsdWRlcygnc2Nyb2xsYmFyJykgJiYgcGFzc2VkUGFyYW1zLnNjcm9sbGJhciAmJiAocGFzc2VkUGFyYW1zLnNjcm9sbGJhci5lbCB8fCBzY3JvbGxiYXJFbCkgJiYgKGN1cnJlbnRQYXJhbXMuc2Nyb2xsYmFyIHx8IGN1cnJlbnRQYXJhbXMuc2Nyb2xsYmFyID09PSBmYWxzZSkgJiYgc2Nyb2xsYmFyICYmICFzY3JvbGxiYXIuZWwpIHtcbiAgICBuZWVkU2Nyb2xsYmFySW5pdCA9IHRydWU7XG4gIH1cbiAgaWYgKGNoYW5nZWRQYXJhbXMuaW5jbHVkZXMoJ25hdmlnYXRpb24nKSAmJiBwYXNzZWRQYXJhbXMubmF2aWdhdGlvbiAmJiAocGFzc2VkUGFyYW1zLm5hdmlnYXRpb24ucHJldkVsIHx8IHByZXZFbCkgJiYgKHBhc3NlZFBhcmFtcy5uYXZpZ2F0aW9uLm5leHRFbCB8fCBuZXh0RWwpICYmIChjdXJyZW50UGFyYW1zLm5hdmlnYXRpb24gfHwgY3VycmVudFBhcmFtcy5uYXZpZ2F0aW9uID09PSBmYWxzZSkgJiYgbmF2aWdhdGlvbiAmJiAhbmF2aWdhdGlvbi5wcmV2RWwgJiYgIW5hdmlnYXRpb24ubmV4dEVsKSB7XG4gICAgbmVlZE5hdmlnYXRpb25Jbml0ID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBkZXN0cm95TW9kdWxlID0gbW9kID0+IHtcbiAgICBpZiAoIXN3aXBlclttb2RdKSByZXR1cm47XG4gICAgc3dpcGVyW21vZF0uZGVzdHJveSgpO1xuICAgIGlmIChtb2QgPT09ICduYXZpZ2F0aW9uJykge1xuICAgICAgaWYgKHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICAgICAgc3dpcGVyW21vZF0ucHJldkVsLnJlbW92ZSgpO1xuICAgICAgICBzd2lwZXJbbW9kXS5uZXh0RWwucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50UGFyYW1zW21vZF0ucHJldkVsID0gdW5kZWZpbmVkO1xuICAgICAgY3VycmVudFBhcmFtc1ttb2RdLm5leHRFbCA9IHVuZGVmaW5lZDtcbiAgICAgIHN3aXBlclttb2RdLnByZXZFbCA9IHVuZGVmaW5lZDtcbiAgICAgIHN3aXBlclttb2RdLm5leHRFbCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICAgICAgc3dpcGVyW21vZF0uZWwucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50UGFyYW1zW21vZF0uZWwgPSB1bmRlZmluZWQ7XG4gICAgICBzd2lwZXJbbW9kXS5lbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG4gIGlmIChjaGFuZ2VkUGFyYW1zLmluY2x1ZGVzKCdsb29wJykgJiYgc3dpcGVyLmlzRWxlbWVudCkge1xuICAgIGlmIChjdXJyZW50UGFyYW1zLmxvb3AgJiYgIXBhc3NlZFBhcmFtcy5sb29wKSB7XG4gICAgICBsb29wTmVlZERlc3Ryb3kgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIWN1cnJlbnRQYXJhbXMubG9vcCAmJiBwYXNzZWRQYXJhbXMubG9vcCkge1xuICAgICAgbG9vcE5lZWRFbmFibGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb29wTmVlZFJlbG9vcCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhcmFtcy5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKGlzT2JqZWN0KGN1cnJlbnRQYXJhbXNba2V5XSkgJiYgaXNPYmplY3QocGFzc2VkUGFyYW1zW2tleV0pKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGN1cnJlbnRQYXJhbXNba2V5XSwgcGFzc2VkUGFyYW1zW2tleV0pO1xuICAgICAgaWYgKChrZXkgPT09ICduYXZpZ2F0aW9uJyB8fCBrZXkgPT09ICdwYWdpbmF0aW9uJyB8fCBrZXkgPT09ICdzY3JvbGxiYXInKSAmJiAnZW5hYmxlZCcgaW4gcGFzc2VkUGFyYW1zW2tleV0gJiYgIXBhc3NlZFBhcmFtc1trZXldLmVuYWJsZWQpIHtcbiAgICAgICAgZGVzdHJveU1vZHVsZShrZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IHBhc3NlZFBhcmFtc1trZXldO1xuICAgICAgaWYgKChuZXdWYWx1ZSA9PT0gdHJ1ZSB8fCBuZXdWYWx1ZSA9PT0gZmFsc2UpICYmIChrZXkgPT09ICduYXZpZ2F0aW9uJyB8fCBrZXkgPT09ICdwYWdpbmF0aW9uJyB8fCBrZXkgPT09ICdzY3JvbGxiYXInKSkge1xuICAgICAgICBpZiAobmV3VmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZGVzdHJveU1vZHVsZShrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50UGFyYW1zW2tleV0gPSBwYXNzZWRQYXJhbXNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAodXBkYXRlUGFyYW1zLmluY2x1ZGVzKCdjb250cm9sbGVyJykgJiYgIW5lZWRDb250cm9sbGVySW5pdCAmJiBzd2lwZXIuY29udHJvbGxlciAmJiBzd2lwZXIuY29udHJvbGxlci5jb250cm9sICYmIGN1cnJlbnRQYXJhbXMuY29udHJvbGxlciAmJiBjdXJyZW50UGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbCkge1xuICAgIHN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wgPSBjdXJyZW50UGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbDtcbiAgfVxuICBpZiAoY2hhbmdlZFBhcmFtcy5pbmNsdWRlcygnY2hpbGRyZW4nKSAmJiBzbGlkZXMgJiYgdmlydHVhbCAmJiBjdXJyZW50UGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkge1xuICAgIHZpcnR1YWwuc2xpZGVzID0gc2xpZGVzO1xuICAgIHZpcnR1YWwudXBkYXRlKHRydWUpO1xuICB9IGVsc2UgaWYgKGNoYW5nZWRQYXJhbXMuaW5jbHVkZXMoJ3ZpcnR1YWwnKSAmJiB2aXJ0dWFsICYmIGN1cnJlbnRQYXJhbXMudmlydHVhbC5lbmFibGVkKSB7XG4gICAgaWYgKHNsaWRlcykgdmlydHVhbC5zbGlkZXMgPSBzbGlkZXM7XG4gICAgdmlydHVhbC51cGRhdGUodHJ1ZSk7XG4gIH1cbiAgaWYgKGNoYW5nZWRQYXJhbXMuaW5jbHVkZXMoJ2NoaWxkcmVuJykgJiYgc2xpZGVzICYmIGN1cnJlbnRQYXJhbXMubG9vcCkge1xuICAgIGxvb3BOZWVkUmVsb29wID0gdHJ1ZTtcbiAgfVxuICBpZiAobmVlZFRodW1ic0luaXQpIHtcbiAgICBjb25zdCBpbml0aWFsaXplZCA9IHRodW1icy5pbml0KCk7XG4gICAgaWYgKGluaXRpYWxpemVkKSB0aHVtYnMudXBkYXRlKHRydWUpO1xuICB9XG4gIGlmIChuZWVkQ29udHJvbGxlckluaXQpIHtcbiAgICBzd2lwZXIuY29udHJvbGxlci5jb250cm9sID0gY3VycmVudFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2w7XG4gIH1cbiAgaWYgKG5lZWRQYWdpbmF0aW9uSW5pdCkge1xuICAgIGlmIChzd2lwZXIuaXNFbGVtZW50ICYmICghcGFnaW5hdGlvbkVsIHx8IHR5cGVvZiBwYWdpbmF0aW9uRWwgPT09ICdzdHJpbmcnKSkge1xuICAgICAgcGFnaW5hdGlvbkVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBwYWdpbmF0aW9uRWwuY2xhc3NMaXN0LmFkZCgnc3dpcGVyLXBhZ2luYXRpb24nKTtcbiAgICAgIHBhZ2luYXRpb25FbC5wYXJ0LmFkZCgncGFnaW5hdGlvbicpO1xuICAgICAgc3dpcGVyLmVsLmFwcGVuZENoaWxkKHBhZ2luYXRpb25FbCk7XG4gICAgfVxuICAgIGlmIChwYWdpbmF0aW9uRWwpIGN1cnJlbnRQYXJhbXMucGFnaW5hdGlvbi5lbCA9IHBhZ2luYXRpb25FbDtcbiAgICBwYWdpbmF0aW9uLmluaXQoKTtcbiAgICBwYWdpbmF0aW9uLnJlbmRlcigpO1xuICAgIHBhZ2luYXRpb24udXBkYXRlKCk7XG4gIH1cbiAgaWYgKG5lZWRTY3JvbGxiYXJJbml0KSB7XG4gICAgaWYgKHN3aXBlci5pc0VsZW1lbnQgJiYgKCFzY3JvbGxiYXJFbCB8fCB0eXBlb2Ygc2Nyb2xsYmFyRWwgPT09ICdzdHJpbmcnKSkge1xuICAgICAgc2Nyb2xsYmFyRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHNjcm9sbGJhckVsLmNsYXNzTGlzdC5hZGQoJ3N3aXBlci1zY3JvbGxiYXInKTtcbiAgICAgIHNjcm9sbGJhckVsLnBhcnQuYWRkKCdzY3JvbGxiYXInKTtcbiAgICAgIHN3aXBlci5lbC5hcHBlbmRDaGlsZChzY3JvbGxiYXJFbCk7XG4gICAgfVxuICAgIGlmIChzY3JvbGxiYXJFbCkgY3VycmVudFBhcmFtcy5zY3JvbGxiYXIuZWwgPSBzY3JvbGxiYXJFbDtcbiAgICBzY3JvbGxiYXIuaW5pdCgpO1xuICAgIHNjcm9sbGJhci51cGRhdGVTaXplKCk7XG4gICAgc2Nyb2xsYmFyLnNldFRyYW5zbGF0ZSgpO1xuICB9XG4gIGlmIChuZWVkTmF2aWdhdGlvbkluaXQpIHtcbiAgICBpZiAoc3dpcGVyLmlzRWxlbWVudCkge1xuICAgICAgaWYgKCFuZXh0RWwgfHwgdHlwZW9mIG5leHRFbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmV4dEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG5leHRFbC5jbGFzc0xpc3QuYWRkKCdzd2lwZXItYnV0dG9uLW5leHQnKTtcbiAgICAgICAgbmV4dEVsLmlubmVySFRNTCA9IHN3aXBlci5ob3N0RWwuY29uc3RydWN0b3IubmV4dEJ1dHRvblN2ZztcbiAgICAgICAgbmV4dEVsLnBhcnQuYWRkKCdidXR0b24tbmV4dCcpO1xuICAgICAgICBzd2lwZXIuZWwuYXBwZW5kQ2hpbGQobmV4dEVsKTtcbiAgICAgIH1cbiAgICAgIGlmICghcHJldkVsIHx8IHR5cGVvZiBwcmV2RWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHByZXZFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwcmV2RWwuY2xhc3NMaXN0LmFkZCgnc3dpcGVyLWJ1dHRvbi1wcmV2Jyk7XG4gICAgICAgIHByZXZFbC5pbm5lckhUTUwgPSBzd2lwZXIuaG9zdEVsLmNvbnN0cnVjdG9yLnByZXZCdXR0b25Tdmc7XG4gICAgICAgIHByZXZFbC5wYXJ0LmFkZCgnYnV0dG9uLXByZXYnKTtcbiAgICAgICAgc3dpcGVyLmVsLmFwcGVuZENoaWxkKHByZXZFbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXh0RWwpIGN1cnJlbnRQYXJhbXMubmF2aWdhdGlvbi5uZXh0RWwgPSBuZXh0RWw7XG4gICAgaWYgKHByZXZFbCkgY3VycmVudFBhcmFtcy5uYXZpZ2F0aW9uLnByZXZFbCA9IHByZXZFbDtcbiAgICBuYXZpZ2F0aW9uLmluaXQoKTtcbiAgICBuYXZpZ2F0aW9uLnVwZGF0ZSgpO1xuICB9XG4gIGlmIChjaGFuZ2VkUGFyYW1zLmluY2x1ZGVzKCdhbGxvd1NsaWRlTmV4dCcpKSB7XG4gICAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gcGFzc2VkUGFyYW1zLmFsbG93U2xpZGVOZXh0O1xuICB9XG4gIGlmIChjaGFuZ2VkUGFyYW1zLmluY2x1ZGVzKCdhbGxvd1NsaWRlUHJldicpKSB7XG4gICAgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID0gcGFzc2VkUGFyYW1zLmFsbG93U2xpZGVQcmV2O1xuICB9XG4gIGlmIChjaGFuZ2VkUGFyYW1zLmluY2x1ZGVzKCdkaXJlY3Rpb24nKSkge1xuICAgIHN3aXBlci5jaGFuZ2VEaXJlY3Rpb24ocGFzc2VkUGFyYW1zLmRpcmVjdGlvbiwgZmFsc2UpO1xuICB9XG4gIGlmIChsb29wTmVlZERlc3Ryb3kgfHwgbG9vcE5lZWRSZWxvb3ApIHtcbiAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcbiAgfVxuICBpZiAobG9vcE5lZWRFbmFibGUgfHwgbG9vcE5lZWRSZWxvb3ApIHtcbiAgICBzd2lwZXIubG9vcENyZWF0ZSgpO1xuICB9XG4gIHN3aXBlci51cGRhdGUoKTtcbn1cblxuZXhwb3J0IHsgbmVlZHNQYWdpbmF0aW9uIGFzIGEsIG5lZWRzU2Nyb2xsYmFyIGFzIGIsIGF0dHJUb1Byb3AgYXMgYywgdW5pcXVlQ2xhc3NlcyBhcyBkLCBleHRlbmQgYXMgZSwgaXNPYmplY3QgYXMgaSwgbmVlZHNOYXZpZ2F0aW9uIGFzIG4sIHBhcmFtc0xpc3QgYXMgcCwgdXBkYXRlU3dpcGVyIGFzIHUsIHdyYXBwZXJDbGFzcyBhcyB3IH07XG4iXSwibmFtZXMiOlsicGFyYW1zTGlzdCIsImlzT2JqZWN0IiwibyIsImNvbnN0cnVjdG9yIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJfX3N3aXBlcl9fIiwiZXh0ZW5kIiwidGFyZ2V0Iiwic3JjIiwibm9FeHRlbmQiLCJrZXlzIiwiZmlsdGVyIiwia2V5IiwiaW5kZXhPZiIsImZvckVhY2giLCJsZW5ndGgiLCJuZWVkc05hdmlnYXRpb24iLCJwYXJhbXMiLCJuYXZpZ2F0aW9uIiwibmV4dEVsIiwicHJldkVsIiwibmVlZHNQYWdpbmF0aW9uIiwicGFnaW5hdGlvbiIsImVsIiwibmVlZHNTY3JvbGxiYXIiLCJzY3JvbGxiYXIiLCJ1bmlxdWVDbGFzc2VzIiwiY2xhc3NOYW1lcyIsImNsYXNzZXMiLCJzcGxpdCIsIm1hcCIsImMiLCJ0cmltIiwidW5pcXVlIiwicHVzaCIsImpvaW4iLCJhdHRyVG9Qcm9wIiwiYXR0ck5hbWUiLCJyZXBsYWNlIiwibCIsInRvVXBwZXJDYXNlIiwid3JhcHBlckNsYXNzIiwiY2xhc3NOYW1lIiwiaW5jbHVkZXMiLCJ1cGRhdGVTd2lwZXIiLCJfcmVmIiwic3dpcGVyIiwic2xpZGVzIiwicGFzc2VkUGFyYW1zIiwiY2hhbmdlZFBhcmFtcyIsInNjcm9sbGJhckVsIiwicGFnaW5hdGlvbkVsIiwidXBkYXRlUGFyYW1zIiwiY3VycmVudFBhcmFtcyIsInZpcnR1YWwiLCJ0aHVtYnMiLCJuZWVkVGh1bWJzSW5pdCIsIm5lZWRDb250cm9sbGVySW5pdCIsIm5lZWRQYWdpbmF0aW9uSW5pdCIsIm5lZWRTY3JvbGxiYXJJbml0IiwibmVlZE5hdmlnYXRpb25Jbml0IiwibG9vcE5lZWREZXN0cm95IiwibG9vcE5lZWRFbmFibGUiLCJsb29wTmVlZFJlbG9vcCIsImNvbnRyb2xsZXIiLCJjb250cm9sIiwiZGVzdHJveU1vZHVsZSIsIm1vZCIsImRlc3Ryb3kiLCJpc0VsZW1lbnQiLCJyZW1vdmUiLCJ1bmRlZmluZWQiLCJsb29wIiwiYXNzaWduIiwiZW5hYmxlZCIsIm5ld1ZhbHVlIiwidXBkYXRlIiwiaW5pdGlhbGl6ZWQiLCJpbml0IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NMaXN0IiwiYWRkIiwicGFydCIsImFwcGVuZENoaWxkIiwicmVuZGVyIiwidXBkYXRlU2l6ZSIsInNldFRyYW5zbGF0ZSIsImlubmVySFRNTCIsImhvc3RFbCIsIm5leHRCdXR0b25TdmciLCJwcmV2QnV0dG9uU3ZnIiwiYWxsb3dTbGlkZU5leHQiLCJhbGxvd1NsaWRlUHJldiIsImNoYW5nZURpcmVjdGlvbiIsImRpcmVjdGlvbiIsImxvb3BEZXN0cm95IiwibG9vcENyZWF0ZSIsImEiLCJiIiwiZCIsImUiLCJpIiwibiIsInAiLCJ1IiwidyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/update-swiper.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/utils.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/utils.mjs ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: function() { return /* binding */ elementParents; },\n/* harmony export */   b: function() { return /* binding */ elementOffset; },\n/* harmony export */   c: function() { return /* binding */ createElement; },\n/* harmony export */   d: function() { return /* binding */ now; },\n/* harmony export */   e: function() { return /* binding */ elementChildren; },\n/* harmony export */   f: function() { return /* binding */ elementOuterSize; },\n/* harmony export */   g: function() { return /* binding */ getSlideTransformEl; },\n/* harmony export */   h: function() { return /* binding */ elementIndex; },\n/* harmony export */   i: function() { return /* binding */ classesToTokens; },\n/* harmony export */   j: function() { return /* binding */ getTranslate; },\n/* harmony export */   k: function() { return /* binding */ elementTransitionEnd; },\n/* harmony export */   l: function() { return /* binding */ isObject; },\n/* harmony export */   m: function() { return /* binding */ makeElementsArray; },\n/* harmony export */   n: function() { return /* binding */ nextTick; },\n/* harmony export */   o: function() { return /* binding */ elementStyle; },\n/* harmony export */   p: function() { return /* binding */ elementNextAll; },\n/* harmony export */   q: function() { return /* binding */ elementPrevAll; },\n/* harmony export */   r: function() { return /* binding */ animateCSSModeScroll; },\n/* harmony export */   s: function() { return /* binding */ setCSSProperty; },\n/* harmony export */   t: function() { return /* binding */ showWarning; },\n/* harmony export */   u: function() { return /* binding */ extend; },\n/* harmony export */   v: function() { return /* binding */ deleteProps; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_define_property */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_define_property.js\");\n/* harmony import */ var _swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_to_consumable_array.js\");\n/* harmony import */ var _ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ssr-window.esm.mjs */ \"(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/ssr-window.esm.mjs\");\n\n\n\nfunction classesToTokens(classes) {\n    if (classes === void 0) {\n        classes = \"\";\n    }\n    return classes.trim().split(\" \").filter(function(c) {\n        return !!c.trim();\n    });\n}\nfunction deleteProps(obj) {\n    var object = obj;\n    Object.keys(object).forEach(function(key) {\n        try {\n            object[key] = null;\n        } catch (e) {\n        // no getter for object\n        }\n        try {\n            delete object[key];\n        } catch (e) {\n        // something got wrong\n        }\n    });\n}\nfunction nextTick(callback, delay) {\n    if (delay === void 0) {\n        delay = 0;\n    }\n    return setTimeout(callback, delay);\n}\nfunction now() {\n    return Date.now();\n}\nfunction getComputedStyle(el) {\n    var window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    var style;\n    if (window1.getComputedStyle) {\n        style = window1.getComputedStyle(el, null);\n    }\n    if (!style && el.currentStyle) {\n        style = el.currentStyle;\n    }\n    if (!style) {\n        style = el.style;\n    }\n    return style;\n}\nfunction getTranslate(el, axis) {\n    if (axis === void 0) {\n        axis = \"x\";\n    }\n    var window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    var matrix;\n    var curTransform;\n    var transformMatrix;\n    var curStyle = getComputedStyle(el);\n    if (window1.WebKitCSSMatrix) {\n        curTransform = curStyle.transform || curStyle.webkitTransform;\n        if (curTransform.split(\",\").length > 6) {\n            curTransform = curTransform.split(\", \").map(function(a) {\n                return a.replace(\",\", \".\");\n            }).join(\", \");\n        }\n        // Some old versions of Webkit choke when 'none' is passed; pass\n        // empty string instead in this case\n        transformMatrix = new window1.WebKitCSSMatrix(curTransform === \"none\" ? \"\" : curTransform);\n    } else {\n        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue(\"transform\").replace(\"translate(\", \"matrix(1, 0, 0, 1,\");\n        matrix = transformMatrix.toString().split(\",\");\n    }\n    if (axis === \"x\") {\n        // Latest Chrome and webkits Fix\n        if (window1.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n        else curTransform = parseFloat(matrix[4]);\n    }\n    if (axis === \"y\") {\n        // Latest Chrome and webkits Fix\n        if (window1.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n        else curTransform = parseFloat(matrix[5]);\n    }\n    return curTransform || 0;\n}\nfunction isObject(o) {\n    return typeof o === \"object\" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === \"Object\";\n}\nfunction isNode(node) {\n    // eslint-disable-next-line\n    if (typeof window !== \"undefined\" && typeof window.HTMLElement !== \"undefined\") {\n        return node instanceof HTMLElement;\n    }\n    return node && (node.nodeType === 1 || node.nodeType === 11);\n}\nfunction extend() {\n    var _arguments, _loop = function(i) {\n        var nextSource = i < 0 || _arguments.length <= i ? undefined : _arguments[i];\n        if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n            var keysArray = Object.keys(Object(nextSource)).filter(function(key) {\n                return noExtend.indexOf(key) < 0;\n            });\n            for(var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1){\n                var nextKey = keysArray[nextIndex];\n                var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n                if (desc !== undefined && desc.enumerable) {\n                    if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                        if (nextSource[nextKey].__swiper__) {\n                            to[nextKey] = nextSource[nextKey];\n                        } else {\n                            extend(to[nextKey], nextSource[nextKey]);\n                        }\n                    } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                        to[nextKey] = {};\n                        if (nextSource[nextKey].__swiper__) {\n                            to[nextKey] = nextSource[nextKey];\n                        } else {\n                            extend(to[nextKey], nextSource[nextKey]);\n                        }\n                    } else {\n                        to[nextKey] = nextSource[nextKey];\n                    }\n                }\n            }\n        }\n    };\n    var to = Object(arguments.length <= 0 ? undefined : arguments[0]);\n    var noExtend = [\n        \"__proto__\",\n        \"constructor\",\n        \"prototype\"\n    ];\n    for(var i = 1; i < arguments.length; i += 1)_arguments = arguments, _loop(i);\n    return to;\n}\nfunction setCSSProperty(el, varName, varValue) {\n    el.style.setProperty(varName, varValue);\n}\nfunction animateCSSModeScroll(_ref) {\n    var swiper = _ref.swiper, targetPosition = _ref.targetPosition, side = _ref.side;\n    var window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    var startPosition = -swiper.translate;\n    var startTime = null;\n    var time;\n    var duration = swiper.params.speed;\n    swiper.wrapperEl.style.scrollSnapType = \"none\";\n    window1.cancelAnimationFrame(swiper.cssModeFrameID);\n    var dir = targetPosition > startPosition ? \"next\" : \"prev\";\n    var isOutOfBound = function(current, target) {\n        return dir === \"next\" && current >= target || dir === \"prev\" && current <= target;\n    };\n    var animate = function() {\n        time = new Date().getTime();\n        if (startTime === null) {\n            startTime = time;\n        }\n        var progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n        var easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n        var currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n        if (isOutOfBound(currentPosition, targetPosition)) {\n            currentPosition = targetPosition;\n        }\n        swiper.wrapperEl.scrollTo((0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_1__._)({}, side, currentPosition));\n        if (isOutOfBound(currentPosition, targetPosition)) {\n            swiper.wrapperEl.style.overflow = \"hidden\";\n            swiper.wrapperEl.style.scrollSnapType = \"\";\n            setTimeout(function() {\n                swiper.wrapperEl.style.overflow = \"\";\n                swiper.wrapperEl.scrollTo((0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_1__._)({}, side, currentPosition));\n            });\n            window1.cancelAnimationFrame(swiper.cssModeFrameID);\n            return;\n        }\n        swiper.cssModeFrameID = window1.requestAnimationFrame(animate);\n    };\n    animate();\n}\nfunction getSlideTransformEl(slideEl) {\n    return slideEl.querySelector(\".swiper-slide-transform\") || slideEl.shadowRoot && slideEl.shadowRoot.querySelector(\".swiper-slide-transform\") || slideEl;\n}\nfunction elementChildren(element, selector) {\n    if (selector === void 0) {\n        selector = \"\";\n    }\n    return (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_2__._)(element.children).filter(function(el) {\n        return el.matches(selector);\n    });\n}\nfunction showWarning(text) {\n    try {\n        console.warn(text);\n        return;\n    } catch (err) {\n    // err\n    }\n}\nfunction createElement(tag, classes) {\n    var _el_classList;\n    if (classes === void 0) {\n        classes = [];\n    }\n    var el = document.createElement(tag);\n    (_el_classList = el.classList).add.apply(_el_classList, (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_2__._)(Array.isArray(classes) ? classes : classesToTokens(classes)));\n    return el;\n}\nfunction elementOffset(el) {\n    var window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    var document1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n    var box = el.getBoundingClientRect();\n    var body = document1.body;\n    var clientTop = el.clientTop || body.clientTop || 0;\n    var clientLeft = el.clientLeft || body.clientLeft || 0;\n    var scrollTop = el === window1 ? window1.scrollY : el.scrollTop;\n    var scrollLeft = el === window1 ? window1.scrollX : el.scrollLeft;\n    return {\n        top: box.top + scrollTop - clientTop,\n        left: box.left + scrollLeft - clientLeft\n    };\n}\nfunction elementPrevAll(el, selector) {\n    var prevEls = [];\n    while(el.previousElementSibling){\n        var prev = el.previousElementSibling; // eslint-disable-line\n        if (selector) {\n            if (prev.matches(selector)) prevEls.push(prev);\n        } else prevEls.push(prev);\n        el = prev;\n    }\n    return prevEls;\n}\nfunction elementNextAll(el, selector) {\n    var nextEls = [];\n    while(el.nextElementSibling){\n        var next = el.nextElementSibling; // eslint-disable-line\n        if (selector) {\n            if (next.matches(selector)) nextEls.push(next);\n        } else nextEls.push(next);\n        el = next;\n    }\n    return nextEls;\n}\nfunction elementStyle(el, prop) {\n    var window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    return window1.getComputedStyle(el, null).getPropertyValue(prop);\n}\nfunction elementIndex(el) {\n    var child = el;\n    var i;\n    if (child) {\n        i = 0;\n        // eslint-disable-next-line\n        while((child = child.previousSibling) !== null){\n            if (child.nodeType === 1) i += 1;\n        }\n        return i;\n    }\n    return undefined;\n}\nfunction elementParents(el, selector) {\n    var parents = []; // eslint-disable-line\n    var parent = el.parentElement; // eslint-disable-line\n    while(parent){\n        if (selector) {\n            if (parent.matches(selector)) parents.push(parent);\n        } else {\n            parents.push(parent);\n        }\n        parent = parent.parentElement;\n    }\n    return parents;\n}\nfunction elementTransitionEnd(el, callback) {\n    function fireCallBack(e) {\n        if (e.target !== el) return;\n        callback.call(el, e);\n        el.removeEventListener(\"transitionend\", fireCallBack);\n    }\n    if (callback) {\n        el.addEventListener(\"transitionend\", fireCallBack);\n    }\n}\nfunction elementOuterSize(el, size, includeMargins) {\n    var window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    if (includeMargins) {\n        return el[size === \"width\" ? \"offsetWidth\" : \"offsetHeight\"] + parseFloat(window1.getComputedStyle(el, null).getPropertyValue(size === \"width\" ? \"margin-right\" : \"margin-top\")) + parseFloat(window1.getComputedStyle(el, null).getPropertyValue(size === \"width\" ? \"margin-left\" : \"margin-bottom\"));\n    }\n    return el.offsetWidth;\n}\nfunction makeElementsArray(el) {\n    return (Array.isArray(el) ? el : [\n        el\n    ]).filter(function(e) {\n        return !!e;\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zd2lwZXJAMTEuMS4zL25vZGVfbW9kdWxlcy9zd2lwZXIvc2hhcmVkL3V0aWxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0U7QUFFeEUsU0FBU0ksZ0JBQWdCQyxPQUFPO0lBQzlCLElBQUlBLFlBQVksS0FBSyxHQUFHO1FBQ3RCQSxVQUFVO0lBQ1o7SUFDQSxPQUFPQSxRQUFRQyxJQUFJLEdBQUdDLEtBQUssQ0FBQyxLQUFLQyxNQUFNLENBQUNDLFNBQUFBO2VBQUssQ0FBQyxDQUFDQSxFQUFFSCxJQUFJOztBQUN2RDtBQUVBLFNBQVNJLFlBQVlDLEdBQUc7SUFDdEIsSUFBTUMsU0FBU0Q7SUFDZkUsT0FBT0MsSUFBSSxDQUFDRixRQUFRRyxPQUFPLENBQUNDLFNBQUFBO1FBQzFCLElBQUk7WUFDRkosTUFBTSxDQUFDSSxJQUFJLEdBQUc7UUFDaEIsRUFBRSxPQUFPQyxHQUFHO1FBQ1YsdUJBQXVCO1FBQ3pCO1FBQ0EsSUFBSTtZQUNGLE9BQU9MLE1BQU0sQ0FBQ0ksSUFBSTtRQUNwQixFQUFFLE9BQU9DLEdBQUc7UUFDVixzQkFBc0I7UUFDeEI7SUFDRjtBQUNGO0FBQ0EsU0FBU0MsU0FBU0MsUUFBUSxFQUFFQyxLQUFLO0lBQy9CLElBQUlBLFVBQVUsS0FBSyxHQUFHO1FBQ3BCQSxRQUFRO0lBQ1Y7SUFDQSxPQUFPQyxXQUFXRixVQUFVQztBQUM5QjtBQUNBLFNBQVNFO0lBQ1AsT0FBT0MsS0FBS0QsR0FBRztBQUNqQjtBQUNBLFNBQVNFLGlCQUFpQkMsRUFBRTtJQUMxQixJQUFNQyxVQUFTekIsc0RBQVNBO0lBQ3hCLElBQUkwQjtJQUNKLElBQUlELFFBQU9GLGdCQUFnQixFQUFFO1FBQzNCRyxRQUFRRCxRQUFPRixnQkFBZ0IsQ0FBQ0MsSUFBSTtJQUN0QztJQUNBLElBQUksQ0FBQ0UsU0FBU0YsR0FBR0csWUFBWSxFQUFFO1FBQzdC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QVE7SUFDeEMsU0FBU21KLGFBQWFySixDQUFDO1FBQ3JCLElBQUlBLEVBQUVtRixNQUFNLEtBQUszRSxJQUFJO1FBQ3JCTixTQUFTb0MsSUFBSSxDQUFDOUIsSUFBSVI7UUFDbEJRLEdBQUc4SSxtQkFBbUIsQ0FBQyxpQkFBaUJEO0lBQzFDO0lBQ0EsSUFBSW5KLFVBQVU7UUFDWk0sR0FBRytJLGdCQUFnQixDQUFDLGlCQUFpQkY7SUFDdkM7QUFDRjtBQUNBLFNBQVNHLGlCQUFpQmhKLEVBQUUsRUFBRWlKLElBQUksRUFBRUMsY0FBYztJQUNoRCxJQUFNakosVUFBU3pCLHNEQUFTQTtJQUN4QixJQUFJMEssZ0JBQWdCO1FBQ2xCLE9BQU9sSixFQUFFLENBQUNpSixTQUFTLFVBQVUsZ0JBQWdCLGVBQWUsR0FBR3pILFdBQVd2QixRQUFPRixnQkFBZ0IsQ0FBQ0MsSUFBSSxNQUFNcUIsZ0JBQWdCLENBQUM0SCxTQUFTLFVBQVUsaUJBQWlCLGlCQUFpQnpILFdBQVd2QixRQUFPRixnQkFBZ0IsQ0FBQ0MsSUFBSSxNQUFNcUIsZ0JBQWdCLENBQUM0SCxTQUFTLFVBQVUsZ0JBQWdCO0lBQ3JSO0lBQ0EsT0FBT2pKLEdBQUdtSixXQUFXO0FBQ3ZCO0FBQ0EsU0FBU0Msa0JBQWtCcEosRUFBRTtJQUMzQixPQUFPLENBQUM0RyxNQUFNQyxPQUFPLENBQUM3RyxNQUFNQSxLQUFLO1FBQUNBO0tBQUcsRUFBRWpCLE1BQU0sQ0FBQ1MsU0FBQUE7ZUFBSyxDQUFDLENBQUNBOztBQUN2RDtBQUVtYyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vc3dpcGVyQDExLjEuMy9ub2RlX21vZHVsZXMvc3dpcGVyL3NoYXJlZC91dGlscy5tanM/NWNmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhIGFzIGdldFdpbmRvdywgZyBhcyBnZXREb2N1bWVudCB9IGZyb20gJy4vc3NyLXdpbmRvdy5lc20ubWpzJztcblxuZnVuY3Rpb24gY2xhc3Nlc1RvVG9rZW5zKGNsYXNzZXMpIHtcbiAgaWYgKGNsYXNzZXMgPT09IHZvaWQgMCkge1xuICAgIGNsYXNzZXMgPSAnJztcbiAgfVxuICByZXR1cm4gY2xhc3Nlcy50cmltKCkuc3BsaXQoJyAnKS5maWx0ZXIoYyA9PiAhIWMudHJpbSgpKTtcbn1cblxuZnVuY3Rpb24gZGVsZXRlUHJvcHMob2JqKSB7XG4gIGNvbnN0IG9iamVjdCA9IG9iajtcbiAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIG9iamVjdFtrZXldID0gbnVsbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBubyBnZXR0ZXIgZm9yIG9iamVjdFxuICAgIH1cbiAgICB0cnkge1xuICAgICAgZGVsZXRlIG9iamVjdFtrZXldO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHNvbWV0aGluZyBnb3Qgd3JvbmdcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbmV4dFRpY2soY2FsbGJhY2ssIGRlbGF5KSB7XG4gIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7XG4gICAgZGVsYXkgPSAwO1xuICB9XG4gIHJldHVybiBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkZWxheSk7XG59XG5mdW5jdGlvbiBub3coKSB7XG4gIHJldHVybiBEYXRlLm5vdygpO1xufVxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbCkge1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgbGV0IHN0eWxlO1xuICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTtcbiAgfVxuICBpZiAoIXN0eWxlICYmIGVsLmN1cnJlbnRTdHlsZSkge1xuICAgIHN0eWxlID0gZWwuY3VycmVudFN0eWxlO1xuICB9XG4gIGlmICghc3R5bGUpIHtcbiAgICBzdHlsZSA9IGVsLnN0eWxlO1xuICB9XG4gIHJldHVybiBzdHlsZTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zbGF0ZShlbCwgYXhpcykge1xuICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7XG4gICAgYXhpcyA9ICd4JztcbiAgfVxuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgbGV0IG1hdHJpeDtcbiAgbGV0IGN1clRyYW5zZm9ybTtcbiAgbGV0IHRyYW5zZm9ybU1hdHJpeDtcbiAgY29uc3QgY3VyU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgaWYgKHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgpIHtcbiAgICBjdXJUcmFuc2Zvcm0gPSBjdXJTdHlsZS50cmFuc2Zvcm0gfHwgY3VyU3R5bGUud2Via2l0VHJhbnNmb3JtO1xuICAgIGlmIChjdXJUcmFuc2Zvcm0uc3BsaXQoJywnKS5sZW5ndGggPiA2KSB7XG4gICAgICBjdXJUcmFuc2Zvcm0gPSBjdXJUcmFuc2Zvcm0uc3BsaXQoJywgJykubWFwKGEgPT4gYS5yZXBsYWNlKCcsJywgJy4nKSkuam9pbignLCAnKTtcbiAgICB9XG4gICAgLy8gU29tZSBvbGQgdmVyc2lvbnMgb2YgV2Via2l0IGNob2tlIHdoZW4gJ25vbmUnIGlzIHBhc3NlZDsgcGFzc1xuICAgIC8vIGVtcHR5IHN0cmluZyBpbnN0ZWFkIGluIHRoaXMgY2FzZVxuICAgIHRyYW5zZm9ybU1hdHJpeCA9IG5ldyB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KGN1clRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBjdXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIHRyYW5zZm9ybU1hdHJpeCA9IGN1clN0eWxlLk1velRyYW5zZm9ybSB8fCBjdXJTdHlsZS5PVHJhbnNmb3JtIHx8IGN1clN0eWxlLk1zVHJhbnNmb3JtIHx8IGN1clN0eWxlLm1zVHJhbnNmb3JtIHx8IGN1clN0eWxlLnRyYW5zZm9ybSB8fCBjdXJTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCd0cmFuc2Zvcm0nKS5yZXBsYWNlKCd0cmFuc2xhdGUoJywgJ21hdHJpeCgxLCAwLCAwLCAxLCcpO1xuICAgIG1hdHJpeCA9IHRyYW5zZm9ybU1hdHJpeC50b1N0cmluZygpLnNwbGl0KCcsJyk7XG4gIH1cbiAgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgIC8vIExhdGVzdCBDaHJvbWUgYW5kIHdlYmtpdHMgRml4XG4gICAgaWYgKHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgpIGN1clRyYW5zZm9ybSA9IHRyYW5zZm9ybU1hdHJpeC5tNDE7XG4gICAgLy8gQ3JhenkgSUUxMCBNYXRyaXhcbiAgICBlbHNlIGlmIChtYXRyaXgubGVuZ3RoID09PSAxNikgY3VyVHJhbnNmb3JtID0gcGFyc2VGbG9hdChtYXRyaXhbMTJdKTtcbiAgICAvLyBOb3JtYWwgQnJvd3NlcnNcbiAgICBlbHNlIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzRdKTtcbiAgfVxuICBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgLy8gTGF0ZXN0IENocm9tZSBhbmQgd2Via2l0cyBGaXhcbiAgICBpZiAod2luZG93LldlYktpdENTU01hdHJpeCkgY3VyVHJhbnNmb3JtID0gdHJhbnNmb3JtTWF0cml4Lm00MjtcbiAgICAvLyBDcmF6eSBJRTEwIE1hdHJpeFxuICAgIGVsc2UgaWYgKG1hdHJpeC5sZW5ndGggPT09IDE2KSBjdXJUcmFuc2Zvcm0gPSBwYXJzZUZsb2F0KG1hdHJpeFsxM10pO1xuICAgIC8vIE5vcm1hbCBCcm93c2Vyc1xuICAgIGVsc2UgY3VyVHJhbnNmb3JtID0gcGFyc2VGbG9hdChtYXRyaXhbNV0pO1xuICB9XG4gIHJldHVybiBjdXJUcmFuc2Zvcm0gfHwgMDtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBvICE9PSBudWxsICYmIG8uY29uc3RydWN0b3IgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKSA9PT0gJ09iamVjdCc7XG59XG5mdW5jdGlvbiBpc05vZGUobm9kZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgfVxuICByZXR1cm4gbm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gMSB8fCBub2RlLm5vZGVUeXBlID09PSAxMSk7XG59XG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gIGNvbnN0IHRvID0gT2JqZWN0KGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSk7XG4gIGNvbnN0IG5vRXh0ZW5kID0gWydfX3Byb3RvX18nLCAnY29uc3RydWN0b3InLCAncHJvdG90eXBlJ107XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgbmV4dFNvdXJjZSA9IGkgPCAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gaSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAobmV4dFNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIG5leHRTb3VyY2UgIT09IG51bGwgJiYgIWlzTm9kZShuZXh0U291cmNlKSkge1xuICAgICAgY29uc3Qga2V5c0FycmF5ID0gT2JqZWN0LmtleXMoT2JqZWN0KG5leHRTb3VyY2UpKS5maWx0ZXIoa2V5ID0+IG5vRXh0ZW5kLmluZGV4T2Yoa2V5KSA8IDApO1xuICAgICAgZm9yIChsZXQgbmV4dEluZGV4ID0gMCwgbGVuID0ga2V5c0FycmF5Lmxlbmd0aDsgbmV4dEluZGV4IDwgbGVuOyBuZXh0SW5kZXggKz0gMSkge1xuICAgICAgICBjb25zdCBuZXh0S2V5ID0ga2V5c0FycmF5W25leHRJbmRleF07XG4gICAgICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5leHRTb3VyY2UsIG5leHRLZXkpO1xuICAgICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkICYmIGRlc2MuZW51bWVyYWJsZSkge1xuICAgICAgICAgIGlmIChpc09iamVjdCh0b1tuZXh0S2V5XSkgJiYgaXNPYmplY3QobmV4dFNvdXJjZVtuZXh0S2V5XSkpIHtcbiAgICAgICAgICAgIGlmIChuZXh0U291cmNlW25leHRLZXldLl9fc3dpcGVyX18pIHtcbiAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXh0ZW5kKHRvW25leHRLZXldLCBuZXh0U291cmNlW25leHRLZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCFpc09iamVjdCh0b1tuZXh0S2V5XSkgJiYgaXNPYmplY3QobmV4dFNvdXJjZVtuZXh0S2V5XSkpIHtcbiAgICAgICAgICAgIHRvW25leHRLZXldID0ge307XG4gICAgICAgICAgICBpZiAobmV4dFNvdXJjZVtuZXh0S2V5XS5fX3N3aXBlcl9fKSB7XG4gICAgICAgICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV4dGVuZCh0b1tuZXh0S2V5XSwgbmV4dFNvdXJjZVtuZXh0S2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuZnVuY3Rpb24gc2V0Q1NTUHJvcGVydHkoZWwsIHZhck5hbWUsIHZhclZhbHVlKSB7XG4gIGVsLnN0eWxlLnNldFByb3BlcnR5KHZhck5hbWUsIHZhclZhbHVlKTtcbn1cbmZ1bmN0aW9uIGFuaW1hdGVDU1NNb2RlU2Nyb2xsKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgc2lkZVxuICB9ID0gX3JlZjtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSAtc3dpcGVyLnRyYW5zbGF0ZTtcbiAgbGV0IHN0YXJ0VGltZSA9IG51bGw7XG4gIGxldCB0aW1lO1xuICBjb25zdCBkdXJhdGlvbiA9IHN3aXBlci5wYXJhbXMuc3BlZWQ7XG4gIHN3aXBlci53cmFwcGVyRWwuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSAnbm9uZSc7XG4gIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShzd2lwZXIuY3NzTW9kZUZyYW1lSUQpO1xuICBjb25zdCBkaXIgPSB0YXJnZXRQb3NpdGlvbiA+IHN0YXJ0UG9zaXRpb24gPyAnbmV4dCcgOiAncHJldic7XG4gIGNvbnN0IGlzT3V0T2ZCb3VuZCA9IChjdXJyZW50LCB0YXJnZXQpID0+IHtcbiAgICByZXR1cm4gZGlyID09PSAnbmV4dCcgJiYgY3VycmVudCA+PSB0YXJnZXQgfHwgZGlyID09PSAncHJldicgJiYgY3VycmVudCA8PSB0YXJnZXQ7XG4gIH07XG4gIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XG4gICAgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGlmIChzdGFydFRpbWUgPT09IG51bGwpIHtcbiAgICAgIHN0YXJ0VGltZSA9IHRpbWU7XG4gICAgfVxuICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5tYXgoTWF0aC5taW4oKHRpbWUgLSBzdGFydFRpbWUpIC8gZHVyYXRpb24sIDEpLCAwKTtcbiAgICBjb25zdCBlYXNlUHJvZ3Jlc3MgPSAwLjUgLSBNYXRoLmNvcyhwcm9ncmVzcyAqIE1hdGguUEkpIC8gMjtcbiAgICBsZXQgY3VycmVudFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbiArIGVhc2VQcm9ncmVzcyAqICh0YXJnZXRQb3NpdGlvbiAtIHN0YXJ0UG9zaXRpb24pO1xuICAgIGlmIChpc091dE9mQm91bmQoY3VycmVudFBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbikpIHtcbiAgICAgIGN1cnJlbnRQb3NpdGlvbiA9IHRhcmdldFBvc2l0aW9uO1xuICAgIH1cbiAgICBzd2lwZXIud3JhcHBlckVsLnNjcm9sbFRvKHtcbiAgICAgIFtzaWRlXTogY3VycmVudFBvc2l0aW9uXG4gICAgfSk7XG4gICAgaWYgKGlzT3V0T2ZCb3VuZChjdXJyZW50UG9zaXRpb24sIHRhcmdldFBvc2l0aW9uKSkge1xuICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9ICcnO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUub3ZlcmZsb3cgPSAnJztcbiAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5zY3JvbGxUbyh7XG4gICAgICAgICAgW3NpZGVdOiBjdXJyZW50UG9zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShzd2lwZXIuY3NzTW9kZUZyYW1lSUQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2lwZXIuY3NzTW9kZUZyYW1lSUQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICB9O1xuICBhbmltYXRlKCk7XG59XG5mdW5jdGlvbiBnZXRTbGlkZVRyYW5zZm9ybUVsKHNsaWRlRWwpIHtcbiAgcmV0dXJuIHNsaWRlRWwucXVlcnlTZWxlY3RvcignLnN3aXBlci1zbGlkZS10cmFuc2Zvcm0nKSB8fCBzbGlkZUVsLnNoYWRvd1Jvb3QgJiYgc2xpZGVFbC5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5zd2lwZXItc2xpZGUtdHJhbnNmb3JtJykgfHwgc2xpZGVFbDtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRDaGlsZHJlbihlbGVtZW50LCBzZWxlY3Rvcikge1xuICBpZiAoc2VsZWN0b3IgPT09IHZvaWQgMCkge1xuICAgIHNlbGVjdG9yID0gJyc7XG4gIH1cbiAgcmV0dXJuIFsuLi5lbGVtZW50LmNoaWxkcmVuXS5maWx0ZXIoZWwgPT4gZWwubWF0Y2hlcyhzZWxlY3RvcikpO1xufVxuZnVuY3Rpb24gc2hvd1dhcm5pbmcodGV4dCkge1xuICB0cnkge1xuICAgIGNvbnNvbGUud2Fybih0ZXh0KTtcbiAgICByZXR1cm47XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIGVyclxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZywgY2xhc3Nlcykge1xuICBpZiAoY2xhc3NlcyA9PT0gdm9pZCAwKSB7XG4gICAgY2xhc3NlcyA9IFtdO1xuICB9XG4gIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBlbC5jbGFzc0xpc3QuYWRkKC4uLihBcnJheS5pc0FycmF5KGNsYXNzZXMpID8gY2xhc3NlcyA6IGNsYXNzZXNUb1Rva2VucyhjbGFzc2VzKSkpO1xuICByZXR1cm4gZWw7XG59XG5mdW5jdGlvbiBlbGVtZW50T2Zmc2V0KGVsKSB7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gIGNvbnN0IGJveCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgY29uc3QgY2xpZW50VG9wID0gZWwuY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDA7XG4gIGNvbnN0IGNsaWVudExlZnQgPSBlbC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuICBjb25zdCBzY3JvbGxUb3AgPSBlbCA9PT0gd2luZG93ID8gd2luZG93LnNjcm9sbFkgOiBlbC5zY3JvbGxUb3A7XG4gIGNvbnN0IHNjcm9sbExlZnQgPSBlbCA9PT0gd2luZG93ID8gd2luZG93LnNjcm9sbFggOiBlbC5zY3JvbGxMZWZ0O1xuICByZXR1cm4ge1xuICAgIHRvcDogYm94LnRvcCArIHNjcm9sbFRvcCAtIGNsaWVudFRvcCxcbiAgICBsZWZ0OiBib3gubGVmdCArIHNjcm9sbExlZnQgLSBjbGllbnRMZWZ0XG4gIH07XG59XG5mdW5jdGlvbiBlbGVtZW50UHJldkFsbChlbCwgc2VsZWN0b3IpIHtcbiAgY29uc3QgcHJldkVscyA9IFtdO1xuICB3aGlsZSAoZWwucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgIGNvbnN0IHByZXYgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBpZiAocHJldi5tYXRjaGVzKHNlbGVjdG9yKSkgcHJldkVscy5wdXNoKHByZXYpO1xuICAgIH0gZWxzZSBwcmV2RWxzLnB1c2gocHJldik7XG4gICAgZWwgPSBwcmV2O1xuICB9XG4gIHJldHVybiBwcmV2RWxzO1xufVxuZnVuY3Rpb24gZWxlbWVudE5leHRBbGwoZWwsIHNlbGVjdG9yKSB7XG4gIGNvbnN0IG5leHRFbHMgPSBbXTtcbiAgd2hpbGUgKGVsLm5leHRFbGVtZW50U2libGluZykge1xuICAgIGNvbnN0IG5leHQgPSBlbC5uZXh0RWxlbWVudFNpYmxpbmc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmIChuZXh0Lm1hdGNoZXMoc2VsZWN0b3IpKSBuZXh0RWxzLnB1c2gobmV4dCk7XG4gICAgfSBlbHNlIG5leHRFbHMucHVzaChuZXh0KTtcbiAgICBlbCA9IG5leHQ7XG4gIH1cbiAgcmV0dXJuIG5leHRFbHM7XG59XG5mdW5jdGlvbiBlbGVtZW50U3R5bGUoZWwsIHByb3ApIHtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRJbmRleChlbCkge1xuICBsZXQgY2hpbGQgPSBlbDtcbiAgbGV0IGk7XG4gIGlmIChjaGlsZCkge1xuICAgIGkgPSAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHdoaWxlICgoY2hpbGQgPSBjaGlsZC5wcmV2aW91c1NpYmxpbmcpICE9PSBudWxsKSB7XG4gICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIGkgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRQYXJlbnRzKGVsLCBzZWxlY3Rvcikge1xuICBjb25zdCBwYXJlbnRzID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgbGV0IHBhcmVudCA9IGVsLnBhcmVudEVsZW1lbnQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgaWYgKHBhcmVudC5tYXRjaGVzKHNlbGVjdG9yKSkgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gcGFyZW50cztcbn1cbmZ1bmN0aW9uIGVsZW1lbnRUcmFuc2l0aW9uRW5kKGVsLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBmaXJlQ2FsbEJhY2soZSkge1xuICAgIGlmIChlLnRhcmdldCAhPT0gZWwpIHJldHVybjtcbiAgICBjYWxsYmFjay5jYWxsKGVsLCBlKTtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZmlyZUNhbGxCYWNrKTtcbiAgfVxuICBpZiAoY2FsbGJhY2spIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZmlyZUNhbGxCYWNrKTtcbiAgfVxufVxuZnVuY3Rpb24gZWxlbWVudE91dGVyU2l6ZShlbCwgc2l6ZSwgaW5jbHVkZU1hcmdpbnMpIHtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gIGlmIChpbmNsdWRlTWFyZ2lucykge1xuICAgIHJldHVybiBlbFtzaXplID09PSAnd2lkdGgnID8gJ29mZnNldFdpZHRoJyA6ICdvZmZzZXRIZWlnaHQnXSArIHBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpLmdldFByb3BlcnR5VmFsdWUoc2l6ZSA9PT0gJ3dpZHRoJyA/ICdtYXJnaW4tcmlnaHQnIDogJ21hcmdpbi10b3AnKSkgKyBwYXJzZUZsb2F0KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHNpemUgPT09ICd3aWR0aCcgPyAnbWFyZ2luLWxlZnQnIDogJ21hcmdpbi1ib3R0b20nKSk7XG4gIH1cbiAgcmV0dXJuIGVsLm9mZnNldFdpZHRoO1xufVxuZnVuY3Rpb24gbWFrZUVsZW1lbnRzQXJyYXkoZWwpIHtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5KGVsKSA/IGVsIDogW2VsXSkuZmlsdGVyKGUgPT4gISFlKTtcbn1cblxuZXhwb3J0IHsgZWxlbWVudFBhcmVudHMgYXMgYSwgZWxlbWVudE9mZnNldCBhcyBiLCBjcmVhdGVFbGVtZW50IGFzIGMsIG5vdyBhcyBkLCBlbGVtZW50Q2hpbGRyZW4gYXMgZSwgZWxlbWVudE91dGVyU2l6ZSBhcyBmLCBnZXRTbGlkZVRyYW5zZm9ybUVsIGFzIGcsIGVsZW1lbnRJbmRleCBhcyBoLCBjbGFzc2VzVG9Ub2tlbnMgYXMgaSwgZ2V0VHJhbnNsYXRlIGFzIGosIGVsZW1lbnRUcmFuc2l0aW9uRW5kIGFzIGssIGlzT2JqZWN0IGFzIGwsIG1ha2VFbGVtZW50c0FycmF5IGFzIG0sIG5leHRUaWNrIGFzIG4sIGVsZW1lbnRTdHlsZSBhcyBvLCBlbGVtZW50TmV4dEFsbCBhcyBwLCBlbGVtZW50UHJldkFsbCBhcyBxLCBhbmltYXRlQ1NTTW9kZVNjcm9sbCBhcyByLCBzZXRDU1NQcm9wZXJ0eSBhcyBzLCBzaG93V2FybmluZyBhcyB0LCBleHRlbmQgYXMgdSwgZGVsZXRlUHJvcHMgYXMgdiB9O1xuIl0sIm5hbWVzIjpbImEiLCJnZXRXaW5kb3ciLCJnIiwiZ2V0RG9jdW1lbnQiLCJjbGFzc2VzVG9Ub2tlbnMiLCJjbGFzc2VzIiwidHJpbSIsInNwbGl0IiwiZmlsdGVyIiwiYyIsImRlbGV0ZVByb3BzIiwib2JqIiwib2JqZWN0IiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJlIiwibmV4dFRpY2siLCJjYWxsYmFjayIsImRlbGF5Iiwic2V0VGltZW91dCIsIm5vdyIsIkRhdGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiZWwiLCJ3aW5kb3ciLCJzdHlsZSIsImN1cnJlbnRTdHlsZSIsImdldFRyYW5zbGF0ZSIsImF4aXMiLCJtYXRyaXgiLCJjdXJUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1NYXRyaXgiLCJjdXJTdHlsZSIsIldlYktpdENTU01hdHJpeCIsInRyYW5zZm9ybSIsIndlYmtpdFRyYW5zZm9ybSIsImxlbmd0aCIsIm1hcCIsInJlcGxhY2UiLCJqb2luIiwiTW96VHJhbnNmb3JtIiwiT1RyYW5zZm9ybSIsIk1zVHJhbnNmb3JtIiwibXNUcmFuc2Zvcm0iLCJnZXRQcm9wZXJ0eVZhbHVlIiwidG9TdHJpbmciLCJtNDEiLCJwYXJzZUZsb2F0IiwibTQyIiwiaXNPYmplY3QiLCJvIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJjYWxsIiwic2xpY2UiLCJpc05vZGUiLCJub2RlIiwiSFRNTEVsZW1lbnQiLCJub2RlVHlwZSIsImV4dGVuZCIsIm5leHRTb3VyY2UiLCJpIiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwia2V5c0FycmF5Iiwibm9FeHRlbmQiLCJpbmRleE9mIiwibmV4dEluZGV4IiwibGVuIiwibmV4dEtleSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwidG8iLCJfX3N3aXBlcl9fIiwic2V0Q1NTUHJvcGVydHkiLCJ2YXJOYW1lIiwidmFyVmFsdWUiLCJzZXRQcm9wZXJ0eSIsImFuaW1hdGVDU1NNb2RlU2Nyb2xsIiwiX3JlZiIsInN3aXBlciIsInRhcmdldFBvc2l0aW9uIiwic2lkZSIsInN0YXJ0UG9zaXRpb24iLCJ0cmFuc2xhdGUiLCJzdGFydFRpbWUiLCJ0aW1lIiwiZHVyYXRpb24iLCJwYXJhbXMiLCJzcGVlZCIsIndyYXBwZXJFbCIsInNjcm9sbFNuYXBUeXBlIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJjc3NNb2RlRnJhbWVJRCIsImRpciIsImlzT3V0T2ZCb3VuZCIsImN1cnJlbnQiLCJ0YXJnZXQiLCJhbmltYXRlIiwiZ2V0VGltZSIsInByb2dyZXNzIiwiTWF0aCIsIm1heCIsIm1pbiIsImVhc2VQcm9ncmVzcyIsImNvcyIsIlBJIiwiY3VycmVudFBvc2l0aW9uIiwic2Nyb2xsVG8iLCJvdmVyZmxvdyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImdldFNsaWRlVHJhbnNmb3JtRWwiLCJzbGlkZUVsIiwicXVlcnlTZWxlY3RvciIsInNoYWRvd1Jvb3QiLCJlbGVtZW50Q2hpbGRyZW4iLCJlbGVtZW50Iiwic2VsZWN0b3IiLCJjaGlsZHJlbiIsIm1hdGNoZXMiLCJzaG93V2FybmluZyIsInRleHQiLCJjb25zb2xlIiwid2FybiIsImVyciIsImNyZWF0ZUVsZW1lbnQiLCJ0YWciLCJkb2N1bWVudCIsImNsYXNzTGlzdCIsImFkZCIsIkFycmF5IiwiaXNBcnJheSIsImVsZW1lbnRPZmZzZXQiLCJib3giLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJib2R5IiwiY2xpZW50VG9wIiwiY2xpZW50TGVmdCIsInNjcm9sbFRvcCIsInNjcm9sbFkiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsWCIsInRvcCIsImxlZnQiLCJlbGVtZW50UHJldkFsbCIsInByZXZFbHMiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwicHJldiIsInB1c2giLCJlbGVtZW50TmV4dEFsbCIsIm5leHRFbHMiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJuZXh0IiwiZWxlbWVudFN0eWxlIiwicHJvcCIsImVsZW1lbnRJbmRleCIsImNoaWxkIiwicHJldmlvdXNTaWJsaW5nIiwiZWxlbWVudFBhcmVudHMiLCJwYXJlbnRzIiwicGFyZW50IiwicGFyZW50RWxlbWVudCIsImVsZW1lbnRUcmFuc2l0aW9uRW5kIiwiZmlyZUNhbGxCYWNrIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJlbGVtZW50T3V0ZXJTaXplIiwic2l6ZSIsImluY2x1ZGVNYXJnaW5zIiwib2Zmc2V0V2lkdGgiLCJtYWtlRWxlbWVudHNBcnJheSIsImIiLCJkIiwiZiIsImgiLCJqIiwiayIsImwiLCJtIiwibiIsInAiLCJxIiwiciIsInMiLCJ0IiwidSIsInYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/utils.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/swiper-react.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/swiper-react.mjs ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Swiper: function() { return /* binding */ Swiper; },\n/* harmony export */   SwiperSlide: function() { return /* binding */ SwiperSlide; },\n/* harmony export */   useSwiper: function() { return /* binding */ useSwiper; },\n/* harmony export */   useSwiperSlide: function() { return /* binding */ useSwiperSlide; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_define_property */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_define_property.js\");\n/* harmony import */ var _swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_spread.js\");\n/* harmony import */ var _swc_helpers_object_without_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_object_without_properties.js\");\n/* harmony import */ var _swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.5/node_modules/@swc/helpers/esm/_sliced_to_array.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _shared_swiper_core_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/swiper-core.mjs */ \"(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/swiper-core.mjs\");\n/* harmony import */ var _shared_update_on_virtual_data_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/update-on-virtual-data.mjs */ \"(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/update-on-virtual-data.mjs\");\n/* harmony import */ var _shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shared/update-swiper.mjs */ \"(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/shared/update-swiper.mjs\");\n/**\n * Swiper React 11.1.3\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2024 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: May 13, 2024\n */ \n\n\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$();\n\n\n\n\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function _extends(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction isChildSwiperSlide(child) {\n    return child.type && child.type.displayName && child.type.displayName.includes(\"SwiperSlide\");\n}\nfunction processChildren(c) {\n    var slides = [];\n    react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(c).forEach(function(child) {\n        if (isChildSwiperSlide(child)) {\n            slides.push(child);\n        } else if (child.props && child.props.children) {\n            processChildren(child.props.children).forEach(function(slide) {\n                return slides.push(slide);\n            });\n        }\n    });\n    return slides;\n}\nfunction getChildren(c) {\n    var slides = [];\n    var slots = {\n        \"container-start\": [],\n        \"container-end\": [],\n        \"wrapper-start\": [],\n        \"wrapper-end\": []\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(c).forEach(function(child) {\n        if (isChildSwiperSlide(child)) {\n            slides.push(child);\n        } else if (child.props && child.props.slot && slots[child.props.slot]) {\n            slots[child.props.slot].push(child);\n        } else if (child.props && child.props.children) {\n            var foundSlides = processChildren(child.props.children);\n            if (foundSlides.length > 0) {\n                foundSlides.forEach(function(slide) {\n                    return slides.push(slide);\n                });\n            } else {\n                slots[\"container-end\"].push(child);\n            }\n        } else {\n            slots[\"container-end\"].push(child);\n        }\n    });\n    return {\n        slides: slides,\n        slots: slots\n    };\n}\nfunction renderVirtual(swiper, slides, virtualData) {\n    if (!virtualData) return null;\n    var getSlideIndex = function(index) {\n        var slideIndex = index;\n        if (index < 0) {\n            slideIndex = slides.length + index;\n        } else if (slideIndex >= slides.length) {\n            // eslint-disable-next-line\n            slideIndex = slideIndex - slides.length;\n        }\n        return slideIndex;\n    };\n    var style = swiper.isHorizontal() ? (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_4__._)({}, swiper.rtlTranslate ? \"right\" : \"left\", \"\".concat(virtualData.offset, \"px\")) : {\n        top: \"\".concat(virtualData.offset, \"px\")\n    };\n    var from = virtualData.from, to = virtualData.to;\n    var loopFrom = swiper.params.loop ? -slides.length : 0;\n    var loopTo = swiper.params.loop ? slides.length * 2 : slides.length;\n    var slidesToRender = [];\n    for(var i = loopFrom; i < loopTo; i += 1){\n        if (i >= from && i <= to) {\n            slidesToRender.push(slides[getSlideIndex(i)]);\n        }\n    }\n    return slidesToRender.map(function(child, index) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(child, {\n            swiper: swiper,\n            style: style,\n            key: child.props.virtualIndex || child.key || \"slide-\".concat(index)\n        });\n    });\n}\nfunction useIsomorphicLayoutEffect(callback, deps) {\n    _s();\n    // eslint-disable-next-line\n    if (typeof window === \"undefined\") return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(callback, deps);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(callback, deps);\n}\n_s(useIsomorphicLayoutEffect, \"MfQzVb+S69pSHKMDKIsojbuzFrw=\");\nvar SwiperSlideContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar useSwiperSlide = function() {\n    _s1();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SwiperSlideContext);\n};\n_s1(useSwiperSlide, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar SwiperContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar useSwiper = function() {\n    _s2();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SwiperContext);\n};\n_s2(useSwiper, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar Swiper = /*#__PURE__*/ _s3((0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(_c = _s3(function(_temp, externalElRef) {\n    _s3();\n    var _ref = _temp === void 0 ? {} : _temp, className = _ref.className, tmp = _ref.tag, Tag = tmp === void 0 ? \"div\" : tmp, tmp1 = _ref.wrapperTag, WrapperTag = tmp1 === void 0 ? \"div\" : tmp1, children = _ref.children, onSwiper = _ref.onSwiper, rest = (0,_swc_helpers_object_without_properties__WEBPACK_IMPORTED_MODULE_5__._)(_ref, [\n        \"className\",\n        \"tag\",\n        \"wrapperTag\",\n        \"children\",\n        \"onSwiper\"\n    ]);\n    var eventsAssigned = false;\n    var _useState = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_6__._)((0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"swiper\"), 2), containerClasses = _useState[0], setContainerClasses = _useState[1];\n    var _useState1 = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_6__._)((0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), 2), virtualData = _useState1[0], setVirtualData = _useState1[1];\n    var _useState2 = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_6__._)((0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false), 2), breakpointChanged = _useState2[0], setBreakpointChanged = _useState2[1];\n    var initializedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    var swiperElRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var swiperRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var oldPassedParamsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var oldSlides = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var nextElRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var prevElRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var paginationElRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var scrollbarElRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var _getParams = (0,_shared_update_on_virtual_data_mjs__WEBPACK_IMPORTED_MODULE_2__.g)(rest), swiperParams = _getParams.params, passedParams = _getParams.passedParams, restProps = _getParams.rest, events = _getParams.events;\n    var _getChildren = getChildren(children), slides = _getChildren.slides, slots = _getChildren.slots;\n    var onBeforeBreakpoint = function() {\n        setBreakpointChanged(!breakpointChanged);\n    };\n    Object.assign(swiperParams.on, {\n        _containerClasses: function(swiper, classes) {\n            setContainerClasses(classes);\n        }\n    });\n    var initSwiper = function() {\n        // init swiper\n        Object.assign(swiperParams.on, events);\n        eventsAssigned = true;\n        var passParams = (0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_7__._)({}, swiperParams);\n        delete passParams.wrapperClass;\n        swiperRef.current = new _shared_swiper_core_mjs__WEBPACK_IMPORTED_MODULE_1__.S(passParams);\n        if (swiperRef.current.virtual && swiperRef.current.params.virtual.enabled) {\n            swiperRef.current.virtual.slides = slides;\n            var extendWith = {\n                cache: false,\n                slides: slides,\n                renderExternal: setVirtualData,\n                renderExternalUpdate: false\n            };\n            (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.e)(swiperRef.current.params.virtual, extendWith);\n            (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.e)(swiperRef.current.originalParams.virtual, extendWith);\n        }\n    };\n    if (!swiperElRef.current) {\n        initSwiper();\n    }\n    // Listen for breakpoints change\n    if (swiperRef.current) {\n        swiperRef.current.on(\"_beforeBreakpoint\", onBeforeBreakpoint);\n    }\n    var attachEvents = function() {\n        if (eventsAssigned || !events || !swiperRef.current) return;\n        Object.keys(events).forEach(function(eventName) {\n            swiperRef.current.on(eventName, events[eventName]);\n        });\n    };\n    var detachEvents = function() {\n        if (!events || !swiperRef.current) return;\n        Object.keys(events).forEach(function(eventName) {\n            swiperRef.current.off(eventName, events[eventName]);\n        });\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        return function() {\n            if (swiperRef.current) swiperRef.current.off(\"_beforeBreakpoint\", onBeforeBreakpoint);\n        };\n    });\n    // set initialized flag\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        if (!initializedRef.current && swiperRef.current) {\n            swiperRef.current.emitSlidesClasses();\n            initializedRef.current = true;\n        }\n    });\n    // mount swiper\n    useIsomorphicLayoutEffect(function() {\n        if (externalElRef) {\n            externalElRef.current = swiperElRef.current;\n        }\n        if (!swiperElRef.current) return;\n        if (swiperRef.current.destroyed) {\n            initSwiper();\n        }\n        (0,_shared_update_on_virtual_data_mjs__WEBPACK_IMPORTED_MODULE_2__.m)({\n            el: swiperElRef.current,\n            nextEl: nextElRef.current,\n            prevEl: prevElRef.current,\n            paginationEl: paginationElRef.current,\n            scrollbarEl: scrollbarElRef.current,\n            swiper: swiperRef.current\n        }, swiperParams);\n        if (onSwiper && !swiperRef.current.destroyed) onSwiper(swiperRef.current);\n        // eslint-disable-next-line\n        return function() {\n            if (swiperRef.current && !swiperRef.current.destroyed) {\n                swiperRef.current.destroy(true, false);\n            }\n        };\n    }, []);\n    // watch for params change\n    useIsomorphicLayoutEffect(function() {\n        attachEvents();\n        var changedParams = (0,_shared_update_on_virtual_data_mjs__WEBPACK_IMPORTED_MODULE_2__.a)(passedParams, oldPassedParamsRef.current, slides, oldSlides.current, function(c) {\n            return c.key;\n        });\n        oldPassedParamsRef.current = passedParams;\n        oldSlides.current = slides;\n        if (changedParams.length && swiperRef.current && !swiperRef.current.destroyed) {\n            (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.u)({\n                swiper: swiperRef.current,\n                slides: slides,\n                passedParams: passedParams,\n                changedParams: changedParams,\n                nextEl: nextElRef.current,\n                prevEl: prevElRef.current,\n                scrollbarEl: scrollbarElRef.current,\n                paginationEl: paginationElRef.current\n            });\n        }\n        return function() {\n            detachEvents();\n        };\n    });\n    // update on virtual update\n    useIsomorphicLayoutEffect(function() {\n        (0,_shared_update_on_virtual_data_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(swiperRef.current);\n    }, [\n        virtualData\n    ]);\n    // bypass swiper instance to slides\n    function renderSlides() {\n        if (swiperParams.virtual) {\n            return renderVirtual(swiperRef.current, slides, virtualData);\n        }\n        return slides.map(function(child, index) {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(child, {\n                swiper: swiperRef.current,\n                swiperSlideIndex: index\n            });\n        });\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tag, _extends({\n        ref: swiperElRef,\n        className: (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.d)(\"\".concat(containerClasses).concat(className ? \" \".concat(className) : \"\"))\n    }, restProps), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SwiperContext.Provider, {\n        value: swiperRef.current\n    }, slots[\"container-start\"], /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(WrapperTag, {\n        className: (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.w)(swiperParams.wrapperClass)\n    }, slots[\"wrapper-start\"], renderSlides(), slots[\"wrapper-end\"]), (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.n)(swiperParams) && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: prevElRef,\n        className: \"swiper-button-prev\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: nextElRef,\n        className: \"swiper-button-next\"\n    })), (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.b)(swiperParams) && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: scrollbarElRef,\n        className: \"swiper-scrollbar\"\n    }), (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.a)(swiperParams) && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: paginationElRef,\n        className: \"swiper-pagination\"\n    }), slots[\"container-end\"]));\n}, \"9TpQP0pvoIUmjWeYYfZrBH2X1HI=\", false, function() {\n    return [\n        useIsomorphicLayoutEffect,\n        useIsomorphicLayoutEffect,\n        useIsomorphicLayoutEffect\n    ];\n})), \"9TpQP0pvoIUmjWeYYfZrBH2X1HI=\", false, function() {\n    return [\n        useIsomorphicLayoutEffect,\n        useIsomorphicLayoutEffect,\n        useIsomorphicLayoutEffect\n    ];\n});\n_c1 = Swiper;\nSwiper.displayName = \"Swiper\";\nvar SwiperSlide = /*#__PURE__*/ _s4((0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(_c2 = _s4(function(_temp, externalRef) {\n    _s4();\n    var _ref = _temp === void 0 ? {} : _temp, tmp = _ref.tag, Tag = tmp === void 0 ? \"div\" : tmp, children = _ref.children, _ref_className = _ref.className, className = _ref_className === void 0 ? \"\" : _ref_className, swiper = _ref.swiper, zoom = _ref.zoom, lazy = _ref.lazy, virtualIndex = _ref.virtualIndex, swiperSlideIndex = _ref.swiperSlideIndex, rest = (0,_swc_helpers_object_without_properties__WEBPACK_IMPORTED_MODULE_5__._)(_ref, [\n        \"tag\",\n        \"children\",\n        \"className\",\n        \"swiper\",\n        \"zoom\",\n        \"lazy\",\n        \"virtualIndex\",\n        \"swiperSlideIndex\"\n    ]);\n    var slideElRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var _useState = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_6__._)((0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"swiper-slide\"), 2), slideClasses = _useState[0], setSlideClasses = _useState[1];\n    var _useState1 = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_6__._)((0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false), 2), lazyLoaded = _useState1[0], setLazyLoaded = _useState1[1];\n    function updateClasses(_s, el, classNames) {\n        if (el === slideElRef.current) {\n            setSlideClasses(classNames);\n        }\n    }\n    useIsomorphicLayoutEffect(function() {\n        if (typeof swiperSlideIndex !== \"undefined\") {\n            slideElRef.current.swiperSlideIndex = swiperSlideIndex;\n        }\n        if (externalRef) {\n            externalRef.current = slideElRef.current;\n        }\n        if (!slideElRef.current || !swiper) {\n            return;\n        }\n        if (swiper.destroyed) {\n            if (slideClasses !== \"swiper-slide\") {\n                setSlideClasses(\"swiper-slide\");\n            }\n            return;\n        }\n        swiper.on(\"_slideClass\", updateClasses);\n        // eslint-disable-next-line\n        return function() {\n            if (!swiper) return;\n            swiper.off(\"_slideClass\", updateClasses);\n        };\n    });\n    useIsomorphicLayoutEffect(function() {\n        if (swiper && slideElRef.current && !swiper.destroyed) {\n            setSlideClasses(swiper.getSlideClasses(slideElRef.current));\n        }\n    }, [\n        swiper\n    ]);\n    var slideData = {\n        isActive: slideClasses.indexOf(\"swiper-slide-active\") >= 0,\n        isVisible: slideClasses.indexOf(\"swiper-slide-visible\") >= 0,\n        isPrev: slideClasses.indexOf(\"swiper-slide-prev\") >= 0,\n        isNext: slideClasses.indexOf(\"swiper-slide-next\") >= 0\n    };\n    var renderChildren = function() {\n        return typeof children === \"function\" ? children(slideData) : children;\n    };\n    var onLoad = function() {\n        setLazyLoaded(true);\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tag, _extends({\n        ref: slideElRef,\n        className: (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.d)(\"\".concat(slideClasses).concat(className ? \" \".concat(className) : \"\")),\n        \"data-swiper-slide-index\": virtualIndex,\n        onLoad: onLoad\n    }, rest), zoom && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SwiperSlideContext.Provider, {\n        value: slideData\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"swiper-zoom-container\",\n        \"data-swiper-zoom\": typeof zoom === \"number\" ? zoom : undefined\n    }, renderChildren(), lazy && !lazyLoaded && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"swiper-lazy-preloader\"\n    }))), !zoom && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SwiperSlideContext.Provider, {\n        value: slideData\n    }, renderChildren(), lazy && !lazyLoaded && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"swiper-lazy-preloader\"\n    })));\n}, \"bKUP/jPUrlpe8syvr1k41XS7eQo=\", false, function() {\n    return [\n        useIsomorphicLayoutEffect,\n        useIsomorphicLayoutEffect\n    ];\n})), \"bKUP/jPUrlpe8syvr1k41XS7eQo=\", false, function() {\n    return [\n        useIsomorphicLayoutEffect,\n        useIsomorphicLayoutEffect\n    ];\n});\n_c3 = SwiperSlide;\nSwiperSlide.displayName = \"SwiperSlide\";\n\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"Swiper$forwardRef\");\n$RefreshReg$(_c1, \"Swiper\");\n$RefreshReg$(_c2, \"SwiperSlide$forwardRef\");\n$RefreshReg$(_c3, \"SwiperSlide\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zd2lwZXJAMTEuMS4zL25vZGVfbW9kdWxlcy9zd2lwZXIvc3dpcGVyLXJlYWN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7OztDQVVDOzs7OztBQUVrSDtBQUMxRDtBQUMrRTtBQUM0QztBQUVwTCxTQUFTOEI7SUFDUEEsV0FBV0MsT0FBT0MsTUFBTSxHQUFHRCxPQUFPQyxNQUFNLENBQUNDLElBQUksS0FBSyxrQkFBVUMsTUFBTTtRQUNoRSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQ3pDLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUN6QixJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQ3RCLElBQUlQLE9BQU9TLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFFBQVFDLE1BQU07b0JBQ3JETCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO2dCQUMzQjtZQUNGO1FBQ0Y7UUFDQSxPQUFPTDtJQUNUO0lBQ0EsT0FBT0osU0FBU2EsS0FBSyxDQUFDLElBQUksRUFBRVA7QUFDOUI7QUFFQSxTQUFTUSxtQkFBbUJDLEtBQUs7SUFDL0IsT0FBT0EsTUFBTUMsSUFBSSxJQUFJRCxNQUFNQyxJQUFJLENBQUNDLFdBQVcsSUFBSUYsTUFBTUMsSUFBSSxDQUFDQyxXQUFXLENBQUNDLFFBQVEsQ0FBQztBQUNqRjtBQUNBLFNBQVNDLGdCQUFnQkMsQ0FBQztJQUN4QixJQUFNQyxTQUFTLEVBQUU7SUFDakJuRCwyQ0FBYyxDQUFDcUQsT0FBTyxDQUFDSCxHQUFHSSxPQUFPLENBQUNULFNBQUFBO1FBQ2hDLElBQUlELG1CQUFtQkMsUUFBUTtZQUM3Qk0sT0FBT0ksSUFBSSxDQUFDVjtRQUNkLE9BQU8sSUFBSUEsTUFBTVcsS0FBSyxJQUFJWCxNQUFNVyxLQUFLLENBQUNDLFFB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Q0FBQytELFFBQVEsV0FBVyxHQUFFOUosZ0RBQW1CLENBQUN3RixtQkFBbUJpRSxRQUFRLEVBQUU7UUFDM0VDLE9BQU9lO0lBQ1QsR0FBR00sa0JBQWtCaEIsUUFBUSxDQUFDSSxjQUFjLFdBQVcsR0FBRW5LLGdEQUFtQixDQUFDLE9BQU87UUFDbEYrRixXQUFXO0lBQ2I7QUFDRjs7UUF6REVYO1FBdUJBQTs7OztRQXZCQUE7UUF1QkFBOzs7O0FBbUNGd0UsWUFBWTdHLFdBQVcsR0FBRztBQUVnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vc3dpcGVyQDExLjEuMy9ub2RlX21vZHVsZXMvc3dpcGVyL3N3aXBlci1yZWFjdC5tanM/YzM2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFN3aXBlciBSZWFjdCAxMS4xLjNcbiAqIE1vc3QgbW9kZXJuIG1vYmlsZSB0b3VjaCBzbGlkZXIgYW5kIGZyYW1ld29yayB3aXRoIGhhcmR3YXJlIGFjY2VsZXJhdGVkIHRyYW5zaXRpb25zXG4gKiBodHRwczovL3N3aXBlcmpzLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMjQgVmxhZGltaXIgS2hhcmxhbXBpZGlcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqXG4gKiBSZWxlYXNlZCBvbjogTWF5IDEzLCAyMDI0XG4gKi9cblxuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VDb250ZXh0LCBjcmVhdGVDb250ZXh0LCBmb3J3YXJkUmVmLCB1c2VTdGF0ZSwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUyBhcyBTd2lwZXIkMSB9IGZyb20gJy4vc2hhcmVkL3N3aXBlci1jb3JlLm1qcyc7XG5pbXBvcnQgeyBnIGFzIGdldFBhcmFtcywgbSBhcyBtb3VudFN3aXBlciwgYSBhcyBnZXRDaGFuZ2VkUGFyYW1zLCB1IGFzIHVwZGF0ZU9uVmlydHVhbERhdGEgfSBmcm9tICcuL3NoYXJlZC91cGRhdGUtb24tdmlydHVhbC1kYXRhLm1qcyc7XG5pbXBvcnQgeyBkIGFzIHVuaXF1ZUNsYXNzZXMsIHcgYXMgd3JhcHBlckNsYXNzLCBuIGFzIG5lZWRzTmF2aWdhdGlvbiwgYiBhcyBuZWVkc1Njcm9sbGJhciwgYSBhcyBuZWVkc1BhZ2luYXRpb24sIGUgYXMgZXh0ZW5kLCB1IGFzIHVwZGF0ZVN3aXBlciB9IGZyb20gJy4vc2hhcmVkL3VwZGF0ZS1zd2lwZXIubWpzJztcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGlzQ2hpbGRTd2lwZXJTbGlkZShjaGlsZCkge1xuICByZXR1cm4gY2hpbGQudHlwZSAmJiBjaGlsZC50eXBlLmRpc3BsYXlOYW1lICYmIGNoaWxkLnR5cGUuZGlzcGxheU5hbWUuaW5jbHVkZXMoJ1N3aXBlclNsaWRlJyk7XG59XG5mdW5jdGlvbiBwcm9jZXNzQ2hpbGRyZW4oYykge1xuICBjb25zdCBzbGlkZXMgPSBbXTtcbiAgUmVhY3QuQ2hpbGRyZW4udG9BcnJheShjKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICBpZiAoaXNDaGlsZFN3aXBlclNsaWRlKGNoaWxkKSkge1xuICAgICAgc2xpZGVzLnB1c2goY2hpbGQpO1xuICAgIH0gZWxzZSBpZiAoY2hpbGQucHJvcHMgJiYgY2hpbGQucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgIHByb2Nlc3NDaGlsZHJlbihjaGlsZC5wcm9wcy5jaGlsZHJlbikuZm9yRWFjaChzbGlkZSA9PiBzbGlkZXMucHVzaChzbGlkZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzbGlkZXM7XG59XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihjKSB7XG4gIGNvbnN0IHNsaWRlcyA9IFtdO1xuICBjb25zdCBzbG90cyA9IHtcbiAgICAnY29udGFpbmVyLXN0YXJ0JzogW10sXG4gICAgJ2NvbnRhaW5lci1lbmQnOiBbXSxcbiAgICAnd3JhcHBlci1zdGFydCc6IFtdLFxuICAgICd3cmFwcGVyLWVuZCc6IFtdXG4gIH07XG4gIFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoYykuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgaWYgKGlzQ2hpbGRTd2lwZXJTbGlkZShjaGlsZCkpIHtcbiAgICAgIHNsaWRlcy5wdXNoKGNoaWxkKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkLnByb3BzICYmIGNoaWxkLnByb3BzLnNsb3QgJiYgc2xvdHNbY2hpbGQucHJvcHMuc2xvdF0pIHtcbiAgICAgIHNsb3RzW2NoaWxkLnByb3BzLnNsb3RdLnB1c2goY2hpbGQpO1xuICAgIH0gZWxzZSBpZiAoY2hpbGQucHJvcHMgJiYgY2hpbGQucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGZvdW5kU2xpZGVzID0gcHJvY2Vzc0NoaWxkcmVuKGNoaWxkLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgIGlmIChmb3VuZFNsaWRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvdW5kU2xpZGVzLmZvckVhY2goc2xpZGUgPT4gc2xpZGVzLnB1c2goc2xpZGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3RzWydjb250YWluZXItZW5kJ10ucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNsb3RzWydjb250YWluZXItZW5kJ10ucHVzaChjaGlsZCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzbGlkZXMsXG4gICAgc2xvdHNcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVmlydHVhbChzd2lwZXIsIHNsaWRlcywgdmlydHVhbERhdGEpIHtcbiAgaWYgKCF2aXJ0dWFsRGF0YSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGdldFNsaWRlSW5kZXggPSBpbmRleCA9PiB7XG4gICAgbGV0IHNsaWRlSW5kZXggPSBpbmRleDtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBzbGlkZUluZGV4ID0gc2xpZGVzLmxlbmd0aCArIGluZGV4O1xuICAgIH0gZWxzZSBpZiAoc2xpZGVJbmRleCA+PSBzbGlkZXMubGVuZ3RoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIHNsaWRlSW5kZXggPSBzbGlkZUluZGV4IC0gc2xpZGVzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHNsaWRlSW5kZXg7XG4gIH07XG4gIGNvbnN0IHN0eWxlID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8ge1xuICAgIFtzd2lwZXIucnRsVHJhbnNsYXRlID8gJ3JpZ2h0JyA6ICdsZWZ0J106IGAke3ZpcnR1YWxEYXRhLm9mZnNldH1weGBcbiAgfSA6IHtcbiAgICB0b3A6IGAke3ZpcnR1YWxEYXRhLm9mZnNldH1weGBcbiAgfTtcbiAgY29uc3Qge1xuICAgIGZyb20sXG4gICAgdG9cbiAgfSA9IHZpcnR1YWxEYXRhO1xuICBjb25zdCBsb29wRnJvbSA9IHN3aXBlci5wYXJhbXMubG9vcCA/IC1zbGlkZXMubGVuZ3RoIDogMDtcbiAgY29uc3QgbG9vcFRvID0gc3dpcGVyLnBhcmFtcy5sb29wID8gc2xpZGVzLmxlbmd0aCAqIDIgOiBzbGlkZXMubGVuZ3RoO1xuICBjb25zdCBzbGlkZXNUb1JlbmRlciA9IFtdO1xuICBmb3IgKGxldCBpID0gbG9vcEZyb207IGkgPCBsb29wVG87IGkgKz0gMSkge1xuICAgIGlmIChpID49IGZyb20gJiYgaSA8PSB0bykge1xuICAgICAgc2xpZGVzVG9SZW5kZXIucHVzaChzbGlkZXNbZ2V0U2xpZGVJbmRleChpKV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xpZGVzVG9SZW5kZXIubWFwKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgc3dpcGVyLFxuICAgICAgc3R5bGUsXG4gICAgICBrZXk6IGNoaWxkLnByb3BzLnZpcnR1YWxJbmRleCB8fCBjaGlsZC5rZXkgfHwgYHNsaWRlLSR7aW5kZXh9YFxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChjYWxsYmFjaywgZGVwcykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdXNlRWZmZWN0KGNhbGxiYWNrLCBkZXBzKTtcbiAgcmV0dXJuIHVzZUxheW91dEVmZmVjdChjYWxsYmFjaywgZGVwcyk7XG59XG5cbmNvbnN0IFN3aXBlclNsaWRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgdXNlU3dpcGVyU2xpZGUgPSAoKSA9PiB7XG4gIHJldHVybiB1c2VDb250ZXh0KFN3aXBlclNsaWRlQ29udGV4dCk7XG59O1xuY29uc3QgU3dpcGVyQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgdXNlU3dpcGVyID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChTd2lwZXJDb250ZXh0KTtcbn07XG5cbmNvbnN0IFN3aXBlciA9IC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKGZ1bmN0aW9uIChfdGVtcCwgZXh0ZXJuYWxFbFJlZikge1xuICBsZXQge1xuICAgIGNsYXNzTmFtZSxcbiAgICB0YWc6IFRhZyA9ICdkaXYnLFxuICAgIHdyYXBwZXJUYWc6IFdyYXBwZXJUYWcgPSAnZGl2JyxcbiAgICBjaGlsZHJlbixcbiAgICBvblN3aXBlcixcbiAgICAuLi5yZXN0XG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgbGV0IGV2ZW50c0Fzc2lnbmVkID0gZmFsc2U7XG4gIGNvbnN0IFtjb250YWluZXJDbGFzc2VzLCBzZXRDb250YWluZXJDbGFzc2VzXSA9IHVzZVN0YXRlKCdzd2lwZXInKTtcbiAgY29uc3QgW3ZpcnR1YWxEYXRhLCBzZXRWaXJ0dWFsRGF0YV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2JyZWFrcG9pbnRDaGFuZ2VkLCBzZXRCcmVha3BvaW50Q2hhbmdlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGluaXRpYWxpemVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3Qgc3dpcGVyRWxSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHN3aXBlclJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qgb2xkUGFzc2VkUGFyYW1zUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBvbGRTbGlkZXMgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IG5leHRFbFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgcHJldkVsUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBwYWdpbmF0aW9uRWxSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNjcm9sbGJhckVsUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCB7XG4gICAgcGFyYW1zOiBzd2lwZXJQYXJhbXMsXG4gICAgcGFzc2VkUGFyYW1zLFxuICAgIHJlc3Q6IHJlc3RQcm9wcyxcbiAgICBldmVudHNcbiAgfSA9IGdldFBhcmFtcyhyZXN0KTtcbiAgY29uc3Qge1xuICAgIHNsaWRlcyxcbiAgICBzbG90c1xuICB9ID0gZ2V0Q2hpbGRyZW4oY2hpbGRyZW4pO1xuICBjb25zdCBvbkJlZm9yZUJyZWFrcG9pbnQgPSAoKSA9PiB7XG4gICAgc2V0QnJlYWtwb2ludENoYW5nZWQoIWJyZWFrcG9pbnRDaGFuZ2VkKTtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzd2lwZXJQYXJhbXMub24sIHtcbiAgICBfY29udGFpbmVyQ2xhc3Nlcyhzd2lwZXIsIGNsYXNzZXMpIHtcbiAgICAgIHNldENvbnRhaW5lckNsYXNzZXMoY2xhc3Nlcyk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgaW5pdFN3aXBlciA9ICgpID0+IHtcbiAgICAvLyBpbml0IHN3aXBlclxuICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyUGFyYW1zLm9uLCBldmVudHMpO1xuICAgIGV2ZW50c0Fzc2lnbmVkID0gdHJ1ZTtcbiAgICBjb25zdCBwYXNzUGFyYW1zID0ge1xuICAgICAgLi4uc3dpcGVyUGFyYW1zXG4gICAgfTtcbiAgICBkZWxldGUgcGFzc1BhcmFtcy53cmFwcGVyQ2xhc3M7XG4gICAgc3dpcGVyUmVmLmN1cnJlbnQgPSBuZXcgU3dpcGVyJDEocGFzc1BhcmFtcyk7XG4gICAgaWYgKHN3aXBlclJlZi5jdXJyZW50LnZpcnR1YWwgJiYgc3dpcGVyUmVmLmN1cnJlbnQucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkge1xuICAgICAgc3dpcGVyUmVmLmN1cnJlbnQudmlydHVhbC5zbGlkZXMgPSBzbGlkZXM7XG4gICAgICBjb25zdCBleHRlbmRXaXRoID0ge1xuICAgICAgICBjYWNoZTogZmFsc2UsXG4gICAgICAgIHNsaWRlcyxcbiAgICAgICAgcmVuZGVyRXh0ZXJuYWw6IHNldFZpcnR1YWxEYXRhLFxuICAgICAgICByZW5kZXJFeHRlcm5hbFVwZGF0ZTogZmFsc2VcbiAgICAgIH07XG4gICAgICBleHRlbmQoc3dpcGVyUmVmLmN1cnJlbnQucGFyYW1zLnZpcnR1YWwsIGV4dGVuZFdpdGgpO1xuICAgICAgZXh0ZW5kKHN3aXBlclJlZi5jdXJyZW50Lm9yaWdpbmFsUGFyYW1zLnZpcnR1YWwsIGV4dGVuZFdpdGgpO1xuICAgIH1cbiAgfTtcbiAgaWYgKCFzd2lwZXJFbFJlZi5jdXJyZW50KSB7XG4gICAgaW5pdFN3aXBlcigpO1xuICB9XG5cbiAgLy8gTGlzdGVuIGZvciBicmVha3BvaW50cyBjaGFuZ2VcbiAgaWYgKHN3aXBlclJlZi5jdXJyZW50KSB7XG4gICAgc3dpcGVyUmVmLmN1cnJlbnQub24oJ19iZWZvcmVCcmVha3BvaW50Jywgb25CZWZvcmVCcmVha3BvaW50KTtcbiAgfVxuICBjb25zdCBhdHRhY2hFdmVudHMgPSAoKSA9PiB7XG4gICAgaWYgKGV2ZW50c0Fzc2lnbmVkIHx8ICFldmVudHMgfHwgIXN3aXBlclJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgT2JqZWN0LmtleXMoZXZlbnRzKS5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICBzd2lwZXJSZWYuY3VycmVudC5vbihldmVudE5hbWUsIGV2ZW50c1tldmVudE5hbWVdKTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZGV0YWNoRXZlbnRzID0gKCkgPT4ge1xuICAgIGlmICghZXZlbnRzIHx8ICFzd2lwZXJSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIE9iamVjdC5rZXlzKGV2ZW50cykuZm9yRWFjaChldmVudE5hbWUgPT4ge1xuICAgICAgc3dpcGVyUmVmLmN1cnJlbnQub2ZmKGV2ZW50TmFtZSwgZXZlbnRzW2V2ZW50TmFtZV0pO1xuICAgIH0pO1xuICB9O1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoc3dpcGVyUmVmLmN1cnJlbnQpIHN3aXBlclJlZi5jdXJyZW50Lm9mZignX2JlZm9yZUJyZWFrcG9pbnQnLCBvbkJlZm9yZUJyZWFrcG9pbnQpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIHNldCBpbml0aWFsaXplZCBmbGFnXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpbml0aWFsaXplZFJlZi5jdXJyZW50ICYmIHN3aXBlclJlZi5jdXJyZW50KSB7XG4gICAgICBzd2lwZXJSZWYuY3VycmVudC5lbWl0U2xpZGVzQ2xhc3NlcygpO1xuICAgICAgaW5pdGlhbGl6ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICAvLyBtb3VudCBzd2lwZXJcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGV4dGVybmFsRWxSZWYpIHtcbiAgICAgIGV4dGVybmFsRWxSZWYuY3VycmVudCA9IHN3aXBlckVsUmVmLmN1cnJlbnQ7XG4gICAgfVxuICAgIGlmICghc3dpcGVyRWxSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGlmIChzd2lwZXJSZWYuY3VycmVudC5kZXN0cm95ZWQpIHtcbiAgICAgIGluaXRTd2lwZXIoKTtcbiAgICB9XG4gICAgbW91bnRTd2lwZXIoe1xuICAgICAgZWw6IHN3aXBlckVsUmVmLmN1cnJlbnQsXG4gICAgICBuZXh0RWw6IG5leHRFbFJlZi5jdXJyZW50LFxuICAgICAgcHJldkVsOiBwcmV2RWxSZWYuY3VycmVudCxcbiAgICAgIHBhZ2luYXRpb25FbDogcGFnaW5hdGlvbkVsUmVmLmN1cnJlbnQsXG4gICAgICBzY3JvbGxiYXJFbDogc2Nyb2xsYmFyRWxSZWYuY3VycmVudCxcbiAgICAgIHN3aXBlcjogc3dpcGVyUmVmLmN1cnJlbnRcbiAgICB9LCBzd2lwZXJQYXJhbXMpO1xuICAgIGlmIChvblN3aXBlciAmJiAhc3dpcGVyUmVmLmN1cnJlbnQuZGVzdHJveWVkKSBvblN3aXBlcihzd2lwZXJSZWYuY3VycmVudCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChzd2lwZXJSZWYuY3VycmVudCAmJiAhc3dpcGVyUmVmLmN1cnJlbnQuZGVzdHJveWVkKSB7XG4gICAgICAgIHN3aXBlclJlZi5jdXJyZW50LmRlc3Ryb3kodHJ1ZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcblxuICAvLyB3YXRjaCBmb3IgcGFyYW1zIGNoYW5nZVxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBhdHRhY2hFdmVudHMoKTtcbiAgICBjb25zdCBjaGFuZ2VkUGFyYW1zID0gZ2V0Q2hhbmdlZFBhcmFtcyhwYXNzZWRQYXJhbXMsIG9sZFBhc3NlZFBhcmFtc1JlZi5jdXJyZW50LCBzbGlkZXMsIG9sZFNsaWRlcy5jdXJyZW50LCBjID0+IGMua2V5KTtcbiAgICBvbGRQYXNzZWRQYXJhbXNSZWYuY3VycmVudCA9IHBhc3NlZFBhcmFtcztcbiAgICBvbGRTbGlkZXMuY3VycmVudCA9IHNsaWRlcztcbiAgICBpZiAoY2hhbmdlZFBhcmFtcy5sZW5ndGggJiYgc3dpcGVyUmVmLmN1cnJlbnQgJiYgIXN3aXBlclJlZi5jdXJyZW50LmRlc3Ryb3llZCkge1xuICAgICAgdXBkYXRlU3dpcGVyKHtcbiAgICAgICAgc3dpcGVyOiBzd2lwZXJSZWYuY3VycmVudCxcbiAgICAgICAgc2xpZGVzLFxuICAgICAgICBwYXNzZWRQYXJhbXMsXG4gICAgICAgIGNoYW5nZWRQYXJhbXMsXG4gICAgICAgIG5leHRFbDogbmV4dEVsUmVmLmN1cnJlbnQsXG4gICAgICAgIHByZXZFbDogcHJldkVsUmVmLmN1cnJlbnQsXG4gICAgICAgIHNjcm9sbGJhckVsOiBzY3JvbGxiYXJFbFJlZi5jdXJyZW50LFxuICAgICAgICBwYWdpbmF0aW9uRWw6IHBhZ2luYXRpb25FbFJlZi5jdXJyZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRldGFjaEV2ZW50cygpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIHVwZGF0ZSBvbiB2aXJ0dWFsIHVwZGF0ZVxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICB1cGRhdGVPblZpcnR1YWxEYXRhKHN3aXBlclJlZi5jdXJyZW50KTtcbiAgfSwgW3ZpcnR1YWxEYXRhXSk7XG5cbiAgLy8gYnlwYXNzIHN3aXBlciBpbnN0YW5jZSB0byBzbGlkZXNcbiAgZnVuY3Rpb24gcmVuZGVyU2xpZGVzKCkge1xuICAgIGlmIChzd2lwZXJQYXJhbXMudmlydHVhbCkge1xuICAgICAgcmV0dXJuIHJlbmRlclZpcnR1YWwoc3dpcGVyUmVmLmN1cnJlbnQsIHNsaWRlcywgdmlydHVhbERhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gc2xpZGVzLm1hcCgoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICBzd2lwZXI6IHN3aXBlclJlZi5jdXJyZW50LFxuICAgICAgICBzd2lwZXJTbGlkZUluZGV4OiBpbmRleFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe1xuICAgIHJlZjogc3dpcGVyRWxSZWYsXG4gICAgY2xhc3NOYW1lOiB1bmlxdWVDbGFzc2VzKGAke2NvbnRhaW5lckNsYXNzZXN9JHtjbGFzc05hbWUgPyBgICR7Y2xhc3NOYW1lfWAgOiAnJ31gKVxuICB9LCByZXN0UHJvcHMpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTd2lwZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHN3aXBlclJlZi5jdXJyZW50XG4gIH0sIHNsb3RzWydjb250YWluZXItc3RhcnQnXSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlclRhZywge1xuICAgIGNsYXNzTmFtZTogd3JhcHBlckNsYXNzKHN3aXBlclBhcmFtcy53cmFwcGVyQ2xhc3MpXG4gIH0sIHNsb3RzWyd3cmFwcGVyLXN0YXJ0J10sIHJlbmRlclNsaWRlcygpLCBzbG90c1snd3JhcHBlci1lbmQnXSksIG5lZWRzTmF2aWdhdGlvbihzd2lwZXJQYXJhbXMpICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBwcmV2RWxSZWYsXG4gICAgY2xhc3NOYW1lOiBcInN3aXBlci1idXR0b24tcHJldlwiXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBuZXh0RWxSZWYsXG4gICAgY2xhc3NOYW1lOiBcInN3aXBlci1idXR0b24tbmV4dFwiXG4gIH0pKSwgbmVlZHNTY3JvbGxiYXIoc3dpcGVyUGFyYW1zKSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBzY3JvbGxiYXJFbFJlZixcbiAgICBjbGFzc05hbWU6IFwic3dpcGVyLXNjcm9sbGJhclwiXG4gIH0pLCBuZWVkc1BhZ2luYXRpb24oc3dpcGVyUGFyYW1zKSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBwYWdpbmF0aW9uRWxSZWYsXG4gICAgY2xhc3NOYW1lOiBcInN3aXBlci1wYWdpbmF0aW9uXCJcbiAgfSksIHNsb3RzWydjb250YWluZXItZW5kJ10pKTtcbn0pO1xuU3dpcGVyLmRpc3BsYXlOYW1lID0gJ1N3aXBlcic7XG5cbmNvbnN0IFN3aXBlclNsaWRlID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoZnVuY3Rpb24gKF90ZW1wLCBleHRlcm5hbFJlZikge1xuICBsZXQge1xuICAgIHRhZzogVGFnID0gJ2RpdicsXG4gICAgY2hpbGRyZW4sXG4gICAgY2xhc3NOYW1lID0gJycsXG4gICAgc3dpcGVyLFxuICAgIHpvb20sXG4gICAgbGF6eSxcbiAgICB2aXJ0dWFsSW5kZXgsXG4gICAgc3dpcGVyU2xpZGVJbmRleCxcbiAgICAuLi5yZXN0XG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgY29uc3Qgc2xpZGVFbFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW3NsaWRlQ2xhc3Nlcywgc2V0U2xpZGVDbGFzc2VzXSA9IHVzZVN0YXRlKCdzd2lwZXItc2xpZGUnKTtcbiAgY29uc3QgW2xhenlMb2FkZWQsIHNldExhenlMb2FkZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBmdW5jdGlvbiB1cGRhdGVDbGFzc2VzKF9zLCBlbCwgY2xhc3NOYW1lcykge1xuICAgIGlmIChlbCA9PT0gc2xpZGVFbFJlZi5jdXJyZW50KSB7XG4gICAgICBzZXRTbGlkZUNsYXNzZXMoY2xhc3NOYW1lcyk7XG4gICAgfVxuICB9XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygc3dpcGVyU2xpZGVJbmRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHNsaWRlRWxSZWYuY3VycmVudC5zd2lwZXJTbGlkZUluZGV4ID0gc3dpcGVyU2xpZGVJbmRleDtcbiAgICB9XG4gICAgaWYgKGV4dGVybmFsUmVmKSB7XG4gICAgICBleHRlcm5hbFJlZi5jdXJyZW50ID0gc2xpZGVFbFJlZi5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoIXNsaWRlRWxSZWYuY3VycmVudCB8fCAhc3dpcGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzd2lwZXIuZGVzdHJveWVkKSB7XG4gICAgICBpZiAoc2xpZGVDbGFzc2VzICE9PSAnc3dpcGVyLXNsaWRlJykge1xuICAgICAgICBzZXRTbGlkZUNsYXNzZXMoJ3N3aXBlci1zbGlkZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2lwZXIub24oJ19zbGlkZUNsYXNzJywgdXBkYXRlQ2xhc3Nlcyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICghc3dpcGVyKSByZXR1cm47XG4gICAgICBzd2lwZXIub2ZmKCdfc2xpZGVDbGFzcycsIHVwZGF0ZUNsYXNzZXMpO1xuICAgIH07XG4gIH0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc3dpcGVyICYmIHNsaWRlRWxSZWYuY3VycmVudCAmJiAhc3dpcGVyLmRlc3Ryb3llZCkge1xuICAgICAgc2V0U2xpZGVDbGFzc2VzKHN3aXBlci5nZXRTbGlkZUNsYXNzZXMoc2xpZGVFbFJlZi5jdXJyZW50KSk7XG4gICAgfVxuICB9LCBbc3dpcGVyXSk7XG4gIGNvbnN0IHNsaWRlRGF0YSA9IHtcbiAgICBpc0FjdGl2ZTogc2xpZGVDbGFzc2VzLmluZGV4T2YoJ3N3aXBlci1zbGlkZS1hY3RpdmUnKSA+PSAwLFxuICAgIGlzVmlzaWJsZTogc2xpZGVDbGFzc2VzLmluZGV4T2YoJ3N3aXBlci1zbGlkZS12aXNpYmxlJykgPj0gMCxcbiAgICBpc1ByZXY6IHNsaWRlQ2xhc3Nlcy5pbmRleE9mKCdzd2lwZXItc2xpZGUtcHJldicpID49IDAsXG4gICAgaXNOZXh0OiBzbGlkZUNsYXNzZXMuaW5kZXhPZignc3dpcGVyLXNsaWRlLW5leHQnKSA+PSAwXG4gIH07XG4gIGNvbnN0IHJlbmRlckNoaWxkcmVuID0gKCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicgPyBjaGlsZHJlbihzbGlkZURhdGEpIDogY2hpbGRyZW47XG4gIH07XG4gIGNvbnN0IG9uTG9hZCA9ICgpID0+IHtcbiAgICBzZXRMYXp5TG9hZGVkKHRydWUpO1xuICB9O1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBzbGlkZUVsUmVmLFxuICAgIGNsYXNzTmFtZTogdW5pcXVlQ2xhc3NlcyhgJHtzbGlkZUNsYXNzZXN9JHtjbGFzc05hbWUgPyBgICR7Y2xhc3NOYW1lfWAgOiAnJ31gKSxcbiAgICBcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCI6IHZpcnR1YWxJbmRleCxcbiAgICBvbkxvYWQ6IG9uTG9hZFxuICB9LCByZXN0KSwgem9vbSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTd2lwZXJTbGlkZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc2xpZGVEYXRhXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwic3dpcGVyLXpvb20tY29udGFpbmVyXCIsXG4gICAgXCJkYXRhLXN3aXBlci16b29tXCI6IHR5cGVvZiB6b29tID09PSAnbnVtYmVyJyA/IHpvb20gOiB1bmRlZmluZWRcbiAgfSwgcmVuZGVyQ2hpbGRyZW4oKSwgbGF6eSAmJiAhbGF6eUxvYWRlZCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInN3aXBlci1sYXp5LXByZWxvYWRlclwiXG4gIH0pKSksICF6b29tICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFN3aXBlclNsaWRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzbGlkZURhdGFcbiAgfSwgcmVuZGVyQ2hpbGRyZW4oKSwgbGF6eSAmJiAhbGF6eUxvYWRlZCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInN3aXBlci1sYXp5LXByZWxvYWRlclwiXG4gIH0pKSk7XG59KTtcblN3aXBlclNsaWRlLmRpc3BsYXlOYW1lID0gJ1N3aXBlclNsaWRlJztcblxuZXhwb3J0IHsgU3dpcGVyLCBTd2lwZXJTbGlkZSwgdXNlU3dpcGVyLCB1c2VTd2lwZXJTbGlkZSB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJmb3J3YXJkUmVmIiwidXNlU3RhdGUiLCJ1c2VSZWYiLCJTIiwiU3dpcGVyJDEiLCJnIiwiZ2V0UGFyYW1zIiwibSIsIm1vdW50U3dpcGVyIiwiYSIsImdldENoYW5nZWRQYXJhbXMiLCJ1IiwidXBkYXRlT25WaXJ0dWFsRGF0YSIsImQiLCJ1bmlxdWVDbGFzc2VzIiwidyIsIndyYXBwZXJDbGFzcyIsIm4iLCJuZWVkc05hdmlnYXRpb24iLCJiIiwibmVlZHNTY3JvbGxiYXIiLCJuZWVkc1BhZ2luYXRpb24iLCJlIiwiZXh0ZW5kIiwidXBkYXRlU3dpcGVyIiwiX2V4dGVuZHMiLCJPYmplY3QiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiaXNDaGlsZFN3aXBlclNsaWRlIiwiY2hpbGQiLCJ0eXBlIiwiZGlzcGxheU5hbWUiLCJpbmNsdWRlcyIsInByb2Nlc3NDaGlsZHJlbiIsImMiLCJzbGlkZXMiLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJmb3JFYWNoIiwicHVzaCIsInByb3BzIiwiY2hpbGRyZW4iLCJzbGlkZSIsImdldENoaWxkcmVuIiwic2xvdHMiLCJzbG90IiwiZm91bmRTbGlkZXMiLCJyZW5kZXJWaXJ0dWFsIiwic3dpcGVyIiwidmlydHVhbERhdGEiLCJnZXRTbGlkZUluZGV4IiwiaW5kZXgiLCJzbGlkZUluZGV4Iiwic3R5bGUiLCJpc0hvcml6b250YWwiLCJydGxUcmFuc2xhdGUiLCJvZmZzZXQiLCJ0b3AiLCJmcm9tIiwidG8iLCJsb29wRnJvbSIsInBhcmFtcyIsImxvb3AiLCJsb29wVG8iLCJzbGlkZXNUb1JlbmRlciIsIm1hcCIsImNsb25lRWxlbWVudCIsInZpcnR1YWxJbmRleCIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJjYWxsYmFjayIsImRlcHMiLCJ3aW5kb3ciLCJTd2lwZXJTbGlkZUNvbnRleHQiLCJ1c2VTd2lwZXJTbGlkZSIsIlN3aXBlckNvbnRleHQiLCJ1c2VTd2lwZXIiLCJTd2lwZXIiLCJfdGVtcCIsImV4dGVybmFsRWxSZWYiLCJjbGFzc05hbWUiLCJUYWciLCJ0YWciLCJXcmFwcGVyVGFnIiwid3JhcHBlclRhZyIsIm9uU3dpcGVyIiwicmVzdCIsImV2ZW50c0Fzc2lnbmVkIiwiY29udGFpbmVyQ2xhc3NlcyIsInNldENvbnRhaW5lckNsYXNzZXMiLCJzZXRWaXJ0dWFsRGF0YSIsImJyZWFrcG9pbnRDaGFuZ2VkIiwic2V0QnJlYWtwb2ludENoYW5nZWQiLCJpbml0aWFsaXplZFJlZiIsInN3aXBlckVsUmVmIiwic3dpcGVyUmVmIiwib2xkUGFzc2VkUGFyYW1zUmVmIiwib2xkU2xpZGVzIiwibmV4dEVsUmVmIiwicHJldkVsUmVmIiwicGFnaW5hdGlvbkVsUmVmIiwic2Nyb2xsYmFyRWxSZWYiLCJzd2lwZXJQYXJhbXMiLCJwYXNzZWRQYXJhbXMiLCJyZXN0UHJvcHMiLCJldmVudHMiLCJvbkJlZm9yZUJyZWFrcG9pbnQiLCJvbiIsIl9jb250YWluZXJDbGFzc2VzIiwiY2xhc3NlcyIsImluaXRTd2lwZXIiLCJwYXNzUGFyYW1zIiwiY3VycmVudCIsInZpcnR1YWwiLCJlbmFibGVkIiwiZXh0ZW5kV2l0aCIsImNhY2hlIiwicmVuZGVyRXh0ZXJuYWwiLCJyZW5kZXJFeHRlcm5hbFVwZGF0ZSIsIm9yaWdpbmFsUGFyYW1zIiwiYXR0YWNoRXZlbnRzIiwia2V5cyIsImV2ZW50TmFtZSIsImRldGFjaEV2ZW50cyIsIm9mZiIsImVtaXRTbGlkZXNDbGFzc2VzIiwiZGVzdHJveWVkIiwiZWwiLCJuZXh0RWwiLCJwcmV2RWwiLCJwYWdpbmF0aW9uRWwiLCJzY3JvbGxiYXJFbCIsImRlc3Ryb3kiLCJjaGFuZ2VkUGFyYW1zIiwicmVuZGVyU2xpZGVzIiwic3dpcGVyU2xpZGVJbmRleCIsImNyZWF0ZUVsZW1lbnQiLCJyZWYiLCJQcm92aWRlciIsInZhbHVlIiwiRnJhZ21lbnQiLCJTd2lwZXJTbGlkZSIsImV4dGVybmFsUmVmIiwiem9vbSIsImxhenkiLCJzbGlkZUVsUmVmIiwic2xpZGVDbGFzc2VzIiwic2V0U2xpZGVDbGFzc2VzIiwibGF6eUxvYWRlZCIsInNldExhenlMb2FkZWQiLCJ1cGRhdGVDbGFzc2VzIiwiX3MiLCJjbGFzc05hbWVzIiwiZ2V0U2xpZGVDbGFzc2VzIiwic2xpZGVEYXRhIiwiaXNBY3RpdmUiLCJpbmRleE9mIiwiaXNWaXNpYmxlIiwiaXNQcmV2IiwiaXNOZXh0IiwicmVuZGVyQ2hpbGRyZW4iLCJvbkxvYWQiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/swiper@11.1.3/node_modules/swiper/swiper-react.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/zustand@4.5.2_@types+react@18.3.2_react@18.3.1/node_modules/zustand/esm/index.mjs":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/zustand@4.5.2_@types+react@18.3.2_react@18.3.1/node_modules/zustand/esm/index.mjs ***!
  \**************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: function() { return /* binding */ create; },\n/* harmony export */   createStore: function() { return /* reexport safe */ zustand_vanilla__WEBPACK_IMPORTED_MODULE_0__.createStore; },\n/* harmony export */   \"default\": function() { return /* binding */ react; },\n/* harmony export */   useStore: function() { return /* binding */ useStore; }\n/* harmony export */ });\n/* harmony import */ var zustand_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand/vanilla */ \"(app-pages-browser)/./node_modules/.pnpm/zustand@4.5.2_@types+react@18.3.2_react@18.3.1/node_modules/zustand/esm/vanilla.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(app-pages-browser)/./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.3.1/node_modules/use-sync-external-store/shim/with-selector.js\");\n\n\n\n\n\nconst { useDebugValue } = react__WEBPACK_IMPORTED_MODULE_1__;\nconst { useSyncExternalStoreWithSelector } = use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__;\nlet didWarnAboutEqualityFn = false;\nconst identity = (arg) => arg;\nfunction useStore(api, selector = identity, equalityFn) {\n  if (( false ? 0 : void 0) !== \"production\" && equalityFn && !didWarnAboutEqualityFn) {\n    console.warn(\n      \"[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937\"\n    );\n    didWarnAboutEqualityFn = true;\n  }\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getInitialState,\n    selector,\n    equalityFn\n  );\n  useDebugValue(slice);\n  return slice;\n}\nconst createImpl = (createState) => {\n  if (( false ? 0 : void 0) !== \"production\" && typeof createState !== \"function\") {\n    console.warn(\n      \"[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.\"\n    );\n  }\n  const api = typeof createState === \"function\" ? (0,zustand_vanilla__WEBPACK_IMPORTED_MODULE_0__.createStore)(createState) : createState;\n  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nconst create = (createState) => createState ? createImpl(createState) : createImpl;\nvar react = (createState) => {\n  if (( false ? 0 : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`.\"\n    );\n  }\n  return create(createState);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS96dXN0YW5kQDQuNS4yX0B0eXBlcytyZWFjdEAxOC4zLjJfcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE4QztBQUNkO0FBQ0M7QUFDdUQ7O0FBRXhGLFFBQVEsZ0JBQWdCLEVBQUUsa0NBQVk7QUFDdEMsUUFBUSxtQ0FBbUMsRUFBRSwwRUFBMkI7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsT0FBTyxNQUFlLEdBQUcsQ0FBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLE1BQWUsR0FBRyxDQUFvQjtBQUM3QztBQUNBLDJHQUEyRyxXQUFXO0FBQ3RIO0FBQ0E7QUFDQSxrREFBa0QsNERBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxNQUFlLEdBQUcsQ0FBb0I7QUFDN0M7QUFDQSx3RUFBd0UsU0FBUztBQUNqRjtBQUNBO0FBQ0E7QUFDQTs7QUFFOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3p1c3RhbmRANC41LjJfQHR5cGVzK3JlYWN0QDE4LjMuMl9yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL3p1c3RhbmQvZXNtL2luZGV4Lm1qcz8yYzA3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVN0b3JlIH0gZnJvbSAnenVzdGFuZC92YW5pbGxhJztcbmV4cG9ydCAqIGZyb20gJ3p1c3RhbmQvdmFuaWxsYSc7XG5pbXBvcnQgUmVhY3RFeHBvcnRzIGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VTeW5jRXh0ZXJuYWxTdG9yZUV4cG9ydHMgZnJvbSAndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzJztcblxuY29uc3QgeyB1c2VEZWJ1Z1ZhbHVlIH0gPSBSZWFjdEV4cG9ydHM7XG5jb25zdCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIH0gPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZUV4cG9ydHM7XG5sZXQgZGlkV2FybkFib3V0RXF1YWxpdHlGbiA9IGZhbHNlO1xuY29uc3QgaWRlbnRpdHkgPSAoYXJnKSA9PiBhcmc7XG5mdW5jdGlvbiB1c2VTdG9yZShhcGksIHNlbGVjdG9yID0gaWRlbnRpdHksIGVxdWFsaXR5Rm4pIHtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmIGVxdWFsaXR5Rm4gJiYgIWRpZFdhcm5BYm91dEVxdWFsaXR5Rm4pIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIltERVBSRUNBVEVEXSBVc2UgYGNyZWF0ZVdpdGhFcXVhbGl0eUZuYCBpbnN0ZWFkIG9mIGBjcmVhdGVgIG9yIHVzZSBgdXNlU3RvcmVXaXRoRXF1YWxpdHlGbmAgaW5zdGVhZCBvZiBgdXNlU3RvcmVgLiBUaGV5IGNhbiBiZSBpbXBvcnRlZCBmcm9tICd6dXN0YW5kL3RyYWRpdGlvbmFsJy4gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy96dXN0YW5kL2Rpc2N1c3Npb25zLzE5MzdcIlxuICAgICk7XG4gICAgZGlkV2FybkFib3V0RXF1YWxpdHlGbiA9IHRydWU7XG4gIH1cbiAgY29uc3Qgc2xpY2UgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICBhcGkuc3Vic2NyaWJlLFxuICAgIGFwaS5nZXRTdGF0ZSxcbiAgICBhcGkuZ2V0U2VydmVyU3RhdGUgfHwgYXBpLmdldEluaXRpYWxTdGF0ZSxcbiAgICBzZWxlY3RvcixcbiAgICBlcXVhbGl0eUZuXG4gICk7XG4gIHVzZURlYnVnVmFsdWUoc2xpY2UpO1xuICByZXR1cm4gc2xpY2U7XG59XG5jb25zdCBjcmVhdGVJbXBsID0gKGNyZWF0ZVN0YXRlKSA9PiB7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0eXBlb2YgY3JlYXRlU3RhdGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiW0RFUFJFQ0FURURdIFBhc3NpbmcgYSB2YW5pbGxhIHN0b3JlIHdpbGwgYmUgdW5zdXBwb3J0ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gSW5zdGVhZCB1c2UgYGltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnenVzdGFuZCdgLlwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBhcGkgPSB0eXBlb2YgY3JlYXRlU3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNyZWF0ZVN0b3JlKGNyZWF0ZVN0YXRlKSA6IGNyZWF0ZVN0YXRlO1xuICBjb25zdCB1c2VCb3VuZFN0b3JlID0gKHNlbGVjdG9yLCBlcXVhbGl0eUZuKSA9PiB1c2VTdG9yZShhcGksIHNlbGVjdG9yLCBlcXVhbGl0eUZuKTtcbiAgT2JqZWN0LmFzc2lnbih1c2VCb3VuZFN0b3JlLCBhcGkpO1xuICByZXR1cm4gdXNlQm91bmRTdG9yZTtcbn07XG5jb25zdCBjcmVhdGUgPSAoY3JlYXRlU3RhdGUpID0+IGNyZWF0ZVN0YXRlID8gY3JlYXRlSW1wbChjcmVhdGVTdGF0ZSkgOiBjcmVhdGVJbXBsO1xudmFyIHJlYWN0ID0gKGNyZWF0ZVN0YXRlKSA9PiB7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiW0RFUFJFQ0FURURdIERlZmF1bHQgZXhwb3J0IGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQgdXNlIGBpbXBvcnQgeyBjcmVhdGUgfSBmcm9tICd6dXN0YW5kJ2AuXCJcbiAgICApO1xuICB9XG4gIHJldHVybiBjcmVhdGUoY3JlYXRlU3RhdGUpO1xufTtcblxuZXhwb3J0IHsgY3JlYXRlLCByZWFjdCBhcyBkZWZhdWx0LCB1c2VTdG9yZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/zustand@4.5.2_@types+react@18.3.2_react@18.3.1/node_modules/zustand/esm/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/zustand@4.5.2_@types+react@18.3.2_react@18.3.1/node_modules/zustand/esm/vanilla.mjs":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/zustand@4.5.2_@types+react@18.3.2_react@18.3.1/node_modules/zustand/esm/vanilla.mjs ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStore: function() { return /* binding */ createStore; },\n/* harmony export */   \"default\": function() { return /* binding */ vanilla; }\n/* harmony export */ });\nconst createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if (( false ? 0 : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, getInitialState, subscribe, destroy };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if (( false ? 0 : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS96dXN0YW5kQDQuNS4yX0B0eXBlcytyZWFjdEAxOC4zLjJfcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS92YW5pbGxhLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEhBQThIO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFlLEdBQUcsQ0FBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLE1BQWUsR0FBRyxDQUFvQjtBQUM3QztBQUNBLHVFQUF1RSxjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBOztBQUUyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0venVzdGFuZEA0LjUuMl9AdHlwZXMrcmVhY3RAMTguMy4yX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vdmFuaWxsYS5tanM/NDMzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjcmVhdGVTdG9yZUltcGwgPSAoY3JlYXRlU3RhdGUpID0+IHtcbiAgbGV0IHN0YXRlO1xuICBjb25zdCBsaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBzZXRTdGF0ZSA9IChwYXJ0aWFsLCByZXBsYWNlKSA9PiB7XG4gICAgY29uc3QgbmV4dFN0YXRlID0gdHlwZW9mIHBhcnRpYWwgPT09IFwiZnVuY3Rpb25cIiA/IHBhcnRpYWwoc3RhdGUpIDogcGFydGlhbDtcbiAgICBpZiAoIU9iamVjdC5pcyhuZXh0U3RhdGUsIHN0YXRlKSkge1xuICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHN0YXRlO1xuICAgICAgc3RhdGUgPSAocmVwbGFjZSAhPSBudWxsID8gcmVwbGFjZSA6IHR5cGVvZiBuZXh0U3RhdGUgIT09IFwib2JqZWN0XCIgfHwgbmV4dFN0YXRlID09PSBudWxsKSA/IG5leHRTdGF0ZSA6IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCBuZXh0U3RhdGUpO1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihzdGF0ZSwgcHJldmlvdXNTdGF0ZSkpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZ2V0U3RhdGUgPSAoKSA9PiBzdGF0ZTtcbiAgY29uc3QgZ2V0SW5pdGlhbFN0YXRlID0gKCkgPT4gaW5pdGlhbFN0YXRlO1xuICBjb25zdCBzdWJzY3JpYmUgPSAobGlzdGVuZXIpID0+IHtcbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gIH07XG4gIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiW0RFUFJFQ0FURURdIFRoZSBgZGVzdHJveWAgbWV0aG9kIHdpbGwgYmUgdW5zdXBwb3J0ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gSW5zdGVhZCB1c2UgdW5zdWJzY3JpYmUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgc3Vic2NyaWJlLiBFdmVyeXRoaW5nIHdpbGwgYmUgZ2FyYmFnZS1jb2xsZWN0ZWQgaWYgc3RvcmUgaXMgZ2FyYmFnZS1jb2xsZWN0ZWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGxpc3RlbmVycy5jbGVhcigpO1xuICB9O1xuICBjb25zdCBhcGkgPSB7IHNldFN0YXRlLCBnZXRTdGF0ZSwgZ2V0SW5pdGlhbFN0YXRlLCBzdWJzY3JpYmUsIGRlc3Ryb3kgfTtcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0gc3RhdGUgPSBjcmVhdGVTdGF0ZShzZXRTdGF0ZSwgZ2V0U3RhdGUsIGFwaSk7XG4gIHJldHVybiBhcGk7XG59O1xuY29uc3QgY3JlYXRlU3RvcmUgPSAoY3JlYXRlU3RhdGUpID0+IGNyZWF0ZVN0YXRlID8gY3JlYXRlU3RvcmVJbXBsKGNyZWF0ZVN0YXRlKSA6IGNyZWF0ZVN0b3JlSW1wbDtcbnZhciB2YW5pbGxhID0gKGNyZWF0ZVN0YXRlKSA9PiB7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiW0RFUFJFQ0FURURdIERlZmF1bHQgZXhwb3J0IGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQgdXNlIGltcG9ydCB7IGNyZWF0ZVN0b3JlIH0gZnJvbSAnenVzdGFuZC92YW5pbGxhJy5cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVN0b3JlKGNyZWF0ZVN0YXRlKTtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZVN0b3JlLCB2YW5pbGxhIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/zustand@4.5.2_@types+react@18.3.2_react@18.3.1/node_modules/zustand/esm/vanilla.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["css-src_components_reputation_rating_styles_module_scss-src_components_reputation_styles_modu-3161cd","css-src_components_typography_typography_scss-src_components_ui_container_Styles_scss-node_mo-774d2c","css-src_components_about_About_module_scss","css-src_components_useful_Useful_module_scss","main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/.pnpm/next@14.2.1_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.2/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cabout%5C%5CAbout.tsx%22%2C%22ids%22%3A%5B%22About%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cdescriptor%5C%5CDescriptor.tsx%22%2C%22ids%22%3A%5B%22Descriptor%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cmotivations%5C%5CMotivations.tsx%22%2C%22ids%22%3A%5B%22Motivations%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cour-projects%5C%5CProjects.tsx%22%2C%22ids%22%3A%5B%22Projects%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cpartners%5C%5CPartners.tsx%22%2C%22ids%22%3A%5B%22Partners%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cui%5C%5CHeading%5C%5CHeading.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cui%5C%5Creference%5C%5CReference.tsx%22%2C%22ids%22%3A%5B%22Reference%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cuseful%5C%5CUseful.module.scss%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C79533%5C%5CDesktop%5C%5Cfront-rband%5C%5Crband%5C%5Csrc%5C%5Ccomponents%5C%5Cuseful%5C%5CUsefulSlider.tsx%22%2C%22ids%22%3A%5B%22UsefulSlider%22%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);